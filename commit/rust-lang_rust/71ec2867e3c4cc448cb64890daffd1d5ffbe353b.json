{"sha": "71ec2867e3c4cc448cb64890daffd1d5ffbe353b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxZWMyODY3ZTNjNGNjNDQ4Y2I2NDg5MGRhZmZkMWQ1ZmZiZTM1M2I=", "commit": {"author": {"name": "Jonathan Turner", "email": "jturner@mozilla.com", "date": "2016-07-11T20:02:03Z"}, "committer": {"name": "Jonathan Turner", "email": "jturner@mozilla.com", "date": "2016-07-14T11:57:46Z"}, "message": "Implement latest rfc style using simpler rendering", "tree": {"sha": "1b200b63c1c5427567ee22a919e28c04914781ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b200b63c1c5427567ee22a919e28c04914781ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71ec2867e3c4cc448cb64890daffd1d5ffbe353b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71ec2867e3c4cc448cb64890daffd1d5ffbe353b", "html_url": "https://github.com/rust-lang/rust/commit/71ec2867e3c4cc448cb64890daffd1d5ffbe353b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71ec2867e3c4cc448cb64890daffd1d5ffbe353b/comments", "author": null, "committer": null, "parents": [{"sha": "a019c2c6bad2bae7e0f5c527ea8a11615acc037f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a019c2c6bad2bae7e0f5c527ea8a11615acc037f", "html_url": "https://github.com/rust-lang/rust/commit/a019c2c6bad2bae7e0f5c527ea8a11615acc037f"}], "stats": {"total": 887, "additions": 693, "deletions": 194}, "files": [{"sha": "52c0ea931408f733db7a907ebd17e8d9da254923", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 626, "deletions": 40, "changes": 666, "blob_url": "https://github.com/rust-lang/rust/blob/71ec2867e3c4cc448cb64890daffd1d5ffbe353b/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ec2867e3c4cc448cb64890daffd1d5ffbe353b/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=71ec2867e3c4cc448cb64890daffd1d5ffbe353b", "patch": "@@ -10,14 +10,15 @@\n \n use self::Destination::*;\n \n-use syntax_pos::{COMMAND_LINE_SP, DUMMY_SP, Span, MultiSpan, LineInfo};\n+use syntax_pos::{COMMAND_LINE_SP, DUMMY_SP, FileMap, Span, MultiSpan, LineInfo, CharPos};\n use registry;\n \n use check_old_skool;\n use {Level, RenderSpan, CodeSuggestion, DiagnosticBuilder, CodeMapper};\n use RenderSpan::*;\n use Level::*;\n-use snippet::{RenderedLineKind, SnippetData, Style, FormatMode};\n+use snippet::{SnippetData, StyledString, Style, FormatMode, Annotation, Line};\n+use styled_buffer::StyledBuffer;\n \n use std::{cmp, fmt};\n use std::io::prelude::*;\n@@ -33,14 +34,13 @@ pub trait Emitter {\n \n impl Emitter for EmitterWriter {\n     fn emit(&mut self, db: &DiagnosticBuilder) {\n-        self.emit_message(&FullSpan(db.span.clone()),\n-                          &db.message,\n-                          db.code.as_ref().map(|s| &**s),\n-                          db.level,\n-                          true,\n-                          true);\n-\n         if check_old_skool() {\n+            self.emit_message(&FullSpan(db.span.clone()),\n+                            &db.message,\n+                            db.code.as_ref().map(|s| &**s),\n+                            db.level,\n+                            true,\n+                            true);\n             let db_span = FullSpan(db.span.clone());\n \n             for child in &db.children {\n@@ -60,18 +60,7 @@ impl Emitter for EmitterWriter {\n                                     show_snippet);\n             }\n         } else {\n-            for child in &db.children {\n-                let render_span = child.render_span\n-                                    .clone()\n-                                    .unwrap_or_else(\n-                                        || FullSpan(child.span.clone()));\n-                self.emit_message(&render_span,\n-                                    &child.message,\n-                                    None,\n-                                    child.level,\n-                                    false,\n-                                    true);\n-            }\n+            self.emit_messages_default(db);\n         }\n     }\n }\n@@ -109,6 +98,12 @@ pub struct EmitterWriter {\n     format_mode: FormatMode\n }\n \n+struct FileWithAnnotatedLines {\n+    file: Rc<FileMap>,\n+    lines: Vec<Line>,\n+}\n+\n+\n /// Do not use this for messages that end in `\\n` \u2013 use `println_maybe_styled` instead. See\n /// `EmitterWriter::print_maybe_styled` for details.\n macro_rules! print_maybe_styled {\n@@ -170,6 +165,560 @@ impl EmitterWriter {\n         }\n     }\n \n+    fn preprocess_annotations(&self, msp: &MultiSpan) -> Vec<FileWithAnnotatedLines> {\n+        fn add_annotation_to_file(file_vec: &mut Vec<FileWithAnnotatedLines>,\n+                                    file: Rc<FileMap>,\n+                                    line_index: usize,\n+                                    ann: Annotation) {\n+\n+            for slot in file_vec.iter_mut() {\n+                // Look through each of our files for the one we're adding to\n+                if slot.file.name == file.name {\n+                    // See if we already have a line for it\n+                    for line_slot in &mut slot.lines {\n+                        if line_slot.line_index == line_index {\n+                            line_slot.annotations.push(ann);\n+                            return;\n+                        }\n+                    }\n+                    // We don't have a line yet, create one\n+                    slot.lines.push(Line {\n+                        line_index: line_index,\n+                        annotations: vec![ann],\n+                    });\n+                    slot.lines.sort();\n+                    return;\n+                }\n+            }\n+            // This is the first time we're seeing the file\n+            file_vec.push(FileWithAnnotatedLines {\n+                file: file,\n+                lines: vec![Line {\n+                                line_index: line_index,\n+                                annotations: vec![ann],\n+                            }],\n+            });\n+        }\n+\n+        let mut output = vec![];\n+\n+        if let Some(ref cm) = self.cm {\n+            for span_label in msp.span_labels() {\n+                let lo = cm.lookup_char_pos(span_label.span.lo);\n+                let hi = cm.lookup_char_pos(span_label.span.hi);\n+\n+                // If the span is multi-line, simplify down to the span of one character\n+                let (start_col, mut end_col, is_minimized) = if lo.line != hi.line {\n+                    (lo.col, CharPos(lo.col.0 + 1), true)\n+                } else {\n+                    (lo.col, hi.col, false)\n+                };\n+\n+                // Watch out for \"empty spans\". If we get a span like 6..6, we\n+                // want to just display a `^` at 6, so convert that to\n+                // 6..7. This is degenerate input, but it's best to degrade\n+                // gracefully -- and the parser likes to supply a span like\n+                // that for EOF, in particular.\n+                if start_col == end_col {\n+                    end_col.0 += 1;\n+                }\n+\n+                add_annotation_to_file(&mut output,\n+                                        lo.file,\n+                                        lo.line,\n+                                        Annotation {\n+                                            start_col: lo.col.0,\n+                                            end_col: hi.col.0,\n+                                            is_primary: span_label.is_primary,\n+                                            is_minimized: is_minimized,\n+                                            label: span_label.label.clone(),\n+                                        });\n+            }\n+        }\n+        output\n+    }\n+\n+    fn render_source_line(&self,\n+                          buffer: &mut StyledBuffer,\n+                          file: Rc<FileMap>,\n+                          line: &Line,\n+                          width_offset: usize) {\n+        let source_string = file.get_line(line.line_index - 1)\n+            .unwrap_or(\"\");\n+\n+        let line_offset = buffer.num_lines();\n+\n+        // First create the source line we will highlight.\n+        buffer.puts(line_offset, width_offset, &source_string, Style::Quotation);\n+        buffer.puts(line_offset,\n+                    0,\n+                    &(line.line_index.to_string()),\n+                    Style::LineNumber);\n+\n+        draw_col_separator(buffer, line_offset, width_offset - 2);\n+\n+        if line.annotations.is_empty() {\n+            return;\n+        }\n+\n+        // We want to display like this:\n+        //\n+        //      vec.push(vec.pop().unwrap());\n+        //      ---      ^^^               _ previous borrow ends here\n+        //      |        |\n+        //      |        error occurs here\n+        //      previous borrow of `vec` occurs here\n+        //\n+        // But there are some weird edge cases to be aware of:\n+        //\n+        //      vec.push(vec.pop().unwrap());\n+        //      --------                    - previous borrow ends here\n+        //      ||\n+        //      |this makes no sense\n+        //      previous borrow of `vec` occurs here\n+        //\n+        // For this reason, we group the lines into \"highlight lines\"\n+        // and \"annotations lines\", where the highlight lines have the `~`.\n+\n+        // let mut highlight_line = Self::whitespace(&source_string);\n+        let old_school = check_old_skool();\n+\n+        // Sort the annotations by (start, end col)\n+        let mut annotations = line.annotations.clone();\n+        annotations.sort();\n+\n+        // Next, create the highlight line.\n+        for annotation in &annotations {\n+            if old_school {\n+                for p in annotation.start_col..annotation.end_col {\n+                    if p == annotation.start_col {\n+                        buffer.putc(line_offset + 1,\n+                                    width_offset + p,\n+                                    '^',\n+                                    if annotation.is_primary {\n+                                        Style::UnderlinePrimary\n+                                    } else {\n+                                        Style::OldSchoolNote\n+                                    });\n+                    } else {\n+                        buffer.putc(line_offset + 1,\n+                                    width_offset + p,\n+                                    '~',\n+                                    if annotation.is_primary {\n+                                        Style::UnderlinePrimary\n+                                    } else {\n+                                        Style::OldSchoolNote\n+                                    });\n+                    }\n+                }\n+            } else {\n+                for p in annotation.start_col..annotation.end_col {\n+                    if annotation.is_primary {\n+                        buffer.putc(line_offset + 1,\n+                                    width_offset + p,\n+                                    '^',\n+                                    Style::UnderlinePrimary);\n+                        if !annotation.is_minimized {\n+                            buffer.set_style(line_offset,\n+                                                width_offset + p,\n+                                                Style::UnderlinePrimary);\n+                        }\n+                    } else {\n+                        buffer.putc(line_offset + 1,\n+                                    width_offset + p,\n+                                    '-',\n+                                    Style::UnderlineSecondary);\n+                        if !annotation.is_minimized {\n+                            buffer.set_style(line_offset,\n+                                                width_offset + p,\n+                                                Style::UnderlineSecondary);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        draw_col_separator(buffer, line_offset + 1, width_offset - 2);\n+\n+        // Now we are going to write labels in. To start, we'll exclude\n+        // the annotations with no labels.\n+        let (labeled_annotations, unlabeled_annotations): (Vec<_>, _) = annotations.into_iter()\n+            .partition(|a| a.label.is_some());\n+\n+        // If there are no annotations that need text, we're done.\n+        if labeled_annotations.is_empty() {\n+            return;\n+        }\n+        if old_school {\n+            return;\n+        }\n+\n+        // Now add the text labels. We try, when possible, to stick the rightmost\n+        // annotation at the end of the highlight line:\n+        //\n+        //      vec.push(vec.pop().unwrap());\n+        //      ---      ---               - previous borrow ends here\n+        //\n+        // But sometimes that's not possible because one of the other\n+        // annotations overlaps it. For example, from the test\n+        // `span_overlap_label`, we have the following annotations\n+        // (written on distinct lines for clarity):\n+        //\n+        //      fn foo(x: u32) {\n+        //      --------------\n+        //             -\n+        //\n+        // In this case, we can't stick the rightmost-most label on\n+        // the highlight line, or we would get:\n+        //\n+        //      fn foo(x: u32) {\n+        //      -------- x_span\n+        //      |\n+        //      fn_span\n+        //\n+        // which is totally weird. Instead we want:\n+        //\n+        //      fn foo(x: u32) {\n+        //      --------------\n+        //      |      |\n+        //      |      x_span\n+        //      fn_span\n+        //\n+        // which is...less weird, at least. In fact, in general, if\n+        // the rightmost span overlaps with any other span, we should\n+        // use the \"hang below\" version, so we can at least make it\n+        // clear where the span *starts*.\n+        let mut labeled_annotations = &labeled_annotations[..];\n+        match labeled_annotations.split_last().unwrap() {\n+            (last, previous) => {\n+                if previous.iter()\n+                    .chain(&unlabeled_annotations)\n+                    .all(|a| !overlaps(a, last)) {\n+                    // append the label afterwards; we keep it in a separate\n+                    // string\n+                    let highlight_label: String = format!(\" {}\", last.label.as_ref().unwrap());\n+                    if last.is_primary {\n+                        buffer.append(line_offset + 1, &highlight_label, Style::LabelPrimary);\n+                    } else {\n+                        buffer.append(line_offset + 1, &highlight_label, Style::LabelSecondary);\n+                    }\n+                    labeled_annotations = previous;\n+                }\n+            }\n+        }\n+\n+        // If that's the last annotation, we're done\n+        if labeled_annotations.is_empty() {\n+            return;\n+        }\n+\n+        for (index, annotation) in labeled_annotations.iter().enumerate() {\n+            // Leave:\n+            // - 1 extra line\n+            // - One line for each thing that comes after\n+            let comes_after = labeled_annotations.len() - index - 1;\n+            let blank_lines = 3 + comes_after;\n+\n+            // For each blank line, draw a `|` at our column. The\n+            // text ought to be long enough for this.\n+            for index in 2..blank_lines {\n+                if annotation.is_primary {\n+                    buffer.putc(line_offset + index,\n+                                width_offset + annotation.start_col,\n+                                '|',\n+                                Style::UnderlinePrimary);\n+                } else {\n+                    buffer.putc(line_offset + index,\n+                                width_offset + annotation.start_col,\n+                                '|',\n+                                Style::UnderlineSecondary);\n+                }\n+                draw_col_separator(buffer, line_offset + index, width_offset - 2);\n+            }\n+\n+            if annotation.is_primary {\n+                buffer.puts(line_offset + blank_lines,\n+                            width_offset + annotation.start_col,\n+                            annotation.label.as_ref().unwrap(),\n+                            Style::LabelPrimary);\n+            } else {\n+                buffer.puts(line_offset + blank_lines,\n+                            width_offset + annotation.start_col,\n+                            annotation.label.as_ref().unwrap(),\n+                            Style::LabelSecondary);\n+            }\n+            draw_col_separator(buffer, line_offset + blank_lines, width_offset - 2);\n+        }\n+    }\n+\n+    fn get_multispan_max_line_num(&mut self, msp: &MultiSpan) -> usize {\n+        let mut max = 0;\n+        if let Some(ref cm) = self.cm {\n+            for primary_span in msp.primary_spans() {\n+                let hi = cm.lookup_char_pos(primary_span.hi);\n+                if hi.line > max {\n+                    max = hi.line;\n+                }\n+            }\n+            for span_label in msp.span_labels() {\n+                let hi = cm.lookup_char_pos(span_label.span.hi);\n+                if hi.line > max {\n+                    max = hi.line;\n+                }\n+            }\n+        }\n+        max\n+    }\n+\n+    fn get_max_line_num(&mut self, db: &DiagnosticBuilder) -> usize {\n+        let mut max = 0;\n+\n+        let primary = self.get_multispan_max_line_num(&db.span);\n+        max = if primary > max { primary } else { max };\n+\n+        for sub in &db.children {\n+            let sub_result = self.get_multispan_max_line_num(&sub.span);\n+            max = if sub_result > max { primary } else { max };\n+        }\n+        max\n+    }\n+\n+    fn emit_message_default(&mut self,\n+                            msp: &MultiSpan,\n+                            msg: &str,\n+                            code: &Option<String>,\n+                            level: &Level,\n+                            max_line_num_len: usize,\n+                            is_secondary: bool)\n+                            -> io::Result<()> {\n+        let mut buffer = StyledBuffer::new();\n+\n+        if msp.primary_spans().is_empty() && msp.span_labels().is_empty() && is_secondary {\n+            // This is a secondary message with no span info\n+            for i in 0..max_line_num_len {\n+                buffer.prepend(0, \" \", Style::NoStyle);\n+            }\n+            draw_note_separator(&mut buffer, 0, max_line_num_len + 1);\n+            buffer.append(0, &level.to_string(), Style::HeaderMsg);\n+            buffer.append(0, \": \", Style::NoStyle);\n+            buffer.append(0, msg, Style::NoStyle);\n+        }\n+        else {\n+            buffer.append(0, &level.to_string(), Style::Level(level.clone()));\n+            match code {\n+                &Some(ref code) => {\n+                    buffer.append(0, \"[\", Style::Level(level.clone()));\n+                    buffer.append(0, &code, Style::Level(level.clone()));\n+                    buffer.append(0, \"]\", Style::Level(level.clone()));\n+                }\n+                _ => {}\n+            }\n+            buffer.append(0, \": \", Style::HeaderMsg);\n+            buffer.append(0, msg, Style::HeaderMsg);\n+        }\n+\n+        // Preprocess all the annotations so that they are grouped by file and by line number\n+        // This helps us quickly iterate over the whole message (including secondary file spans)\n+        let mut annotated_files = self.preprocess_annotations(msp);\n+\n+        // Make sure our primary file comes first\n+        let primary_lo =\n+            if let (Some(ref cm), Some(ref primary_span)) = (self.cm.as_ref(),\n+                                                             msp.primary_span().as_ref()) {\n+                cm.lookup_char_pos(primary_span.lo)\n+            } else {\n+                // If we don't have span information, emit and exit\n+                emit_to_destination(&buffer.render(), level, &mut self.dst);\n+                return Ok(());\n+            };\n+        if let Ok(pos) =\n+                annotated_files.binary_search_by(|x| x.file.name.cmp(&primary_lo.file.name)) {\n+            annotated_files.swap(0, pos);\n+        }\n+\n+        // Print out the annotate source lines that correspond with the error\n+        for annotated_file in annotated_files {\n+            // print out the span location and spacer before we print the annotated source\n+            // to do this, we need to know if this span will be primary\n+            let is_primary = primary_lo.file.name == annotated_file.file.name;\n+            if is_primary {\n+                // remember where we are in the output buffer for easy reference\n+                let mut buffer_msg_line_offset = buffer.num_lines();\n+\n+                buffer.prepend(buffer_msg_line_offset, \"--> \", Style::LineNumber);\n+                let loc = primary_lo.clone();\n+                buffer.append(buffer_msg_line_offset,\n+                                &format!(\"{}:{}:{}\", loc.file.name, loc.line, loc.col.0),\n+                                Style::LineAndColumn);\n+                for i in 0..max_line_num_len {\n+                    buffer.prepend(buffer_msg_line_offset, \" \", Style::NoStyle);\n+                }\n+            } else {\n+                // remember where we are in the output buffer for easy reference\n+                let mut buffer_msg_line_offset = buffer.num_lines();\n+\n+                // Add spacing line\n+                draw_col_separator(&mut buffer, buffer_msg_line_offset, max_line_num_len + 1);\n+\n+                // Then, the secondary file indicator\n+                buffer.prepend(buffer_msg_line_offset + 1, \"::: \", Style::LineNumber);\n+                buffer.append(buffer_msg_line_offset + 1,\n+                                &annotated_file.file.name,\n+                                Style::LineAndColumn);\n+                for i in 0..max_line_num_len {\n+                    buffer.prepend(buffer_msg_line_offset + 1, \" \", Style::NoStyle);\n+                }\n+            }\n+\n+            // Put in the spacer between the location and annotated source\n+            let mut buffer_msg_line_offset = buffer.num_lines();\n+            draw_col_separator(&mut buffer, buffer_msg_line_offset, max_line_num_len + 1);\n+\n+            // Next, output the annotate source for this file\n+            for line_idx in 0..annotated_file.lines.len() {\n+                self.render_source_line(&mut buffer,\n+                                        annotated_file.file.clone(),\n+                                        &annotated_file.lines[line_idx],\n+                                        3 + max_line_num_len);\n+\n+                // check to see if we need to print out or elide lines that come between\n+                // this annotated line and the next one\n+                if line_idx < (annotated_file.lines.len() - 1) {\n+                    let line_idx_delta = annotated_file.lines[line_idx + 1].line_index -\n+                                            annotated_file.lines[line_idx].line_index;\n+                    if line_idx_delta > 2 {\n+                        let last_buffer_line_num = buffer.num_lines();\n+                        buffer.puts(last_buffer_line_num, 0, \"...\", Style::LineNumber);\n+                    } else if line_idx_delta == 2 {\n+                        let unannotated_line = annotated_file.file\n+                            .get_line(annotated_file.lines[line_idx].line_index)\n+                            .unwrap_or(\"\");\n+\n+                        let last_buffer_line_num = buffer.num_lines();\n+\n+                        buffer.puts(last_buffer_line_num,\n+                                    0,\n+                                    &(annotated_file.lines[line_idx + 1].line_index - 1)\n+                                        .to_string(),\n+                                    Style::LineNumber);\n+                        draw_col_separator(&mut buffer, last_buffer_line_num, 1 + max_line_num_len);\n+                        buffer.puts(last_buffer_line_num,\n+                                    3 + max_line_num_len,\n+                                    &unannotated_line,\n+                                    Style::Quotation);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // final step: take our styled buffer, render it, then output it\n+        emit_to_destination(&buffer.render(), level, &mut self.dst);\n+\n+        Ok(())\n+    }\n+    fn emit_suggestion_default(&mut self,\n+                               suggestion: &CodeSuggestion,\n+                               level: &Level,\n+                               msg: &str,\n+                               max_line_num_len: usize)\n+                               -> io::Result<()> {\n+        use std::borrow::Borrow;\n+\n+        let primary_span = suggestion.msp.primary_span().unwrap();\n+        if let Some(ref cm) = self.cm {\n+            let mut buffer = StyledBuffer::new();\n+\n+            buffer.append(0, &level.to_string(), Style::Level(level.clone()));\n+            buffer.append(0, \": \", Style::HeaderMsg);\n+            buffer.append(0, msg, Style::HeaderMsg);\n+\n+            let lines = cm.span_to_lines(primary_span).unwrap();\n+\n+            assert!(!lines.lines.is_empty());\n+\n+            let complete = suggestion.splice_lines(cm.borrow());\n+            let line_count = cmp::min(lines.lines.len(), MAX_HIGHLIGHT_LINES);\n+            let display_lines = &lines.lines[..line_count];\n+\n+            let fm = &*lines.file;\n+            // Calculate the widest number to format evenly\n+            let max_digits = line_num_max_digits(display_lines.last().unwrap());\n+\n+            // print the suggestion without any line numbers, but leave\n+            // space for them. This helps with lining up with previous\n+            // snippets from the actual error being reported.\n+            let mut lines = complete.lines();\n+            let mut row_num = 1;\n+            for line in lines.by_ref().take(MAX_HIGHLIGHT_LINES) {\n+                draw_col_separator(&mut buffer, row_num, max_line_num_len + 1);\n+                buffer.append(row_num, line, Style::NoStyle);\n+                row_num += 1;\n+            }\n+\n+            // if we elided some lines, add an ellipsis\n+            if let Some(_) = lines.next() {\n+                buffer.append(row_num, \"...\", Style::NoStyle);\n+            }\n+            emit_to_destination(&buffer.render(), level, &mut self.dst);\n+        }\n+        Ok(())\n+    }\n+    fn emit_messages_default(&mut self, db: &DiagnosticBuilder) {\n+        let max_line_num = self.get_max_line_num(db);\n+        let max_line_num_len = max_line_num.to_string().len();\n+\n+        match self.emit_message_default(&db.span,\n+                                        &db.message,\n+                                        &db.code,\n+                                        &db.level,\n+                                        max_line_num_len,\n+                                        false) {\n+            Ok(()) => {\n+                if !db.children.is_empty() {\n+                    let mut buffer = StyledBuffer::new();\n+                    draw_col_separator(&mut buffer, 0, max_line_num_len + 1);\n+                    emit_to_destination(&buffer.render(), &db.level, &mut self.dst);\n+                }\n+                for child in &db.children {\n+                    match child.render_span {\n+                        Some(FullSpan(ref msp)) => {\n+                            match self.emit_message_default(msp,\n+                                                            &child.message,\n+                                                            &None,\n+                                                            &child.level,\n+                                                            max_line_num_len,\n+                                                            true) {\n+                                Err(e) => panic!(\"failed to emit error: {}\", e),\n+                                _ => ()\n+                            }\n+                        },\n+                        Some(Suggestion(ref cs)) => {\n+                            match self.emit_suggestion_default(cs,\n+                                                               &child.level,\n+                                                               &child.message,\n+                                                               max_line_num_len) {\n+                                Err(e) => panic!(\"failed to emit error: {}\", e),\n+                                _ => ()\n+                            }\n+                        },\n+                        None => {\n+                            match self.emit_message_default(&child.span,\n+                                                            &child.message,\n+                                                            &None,\n+                                                            &child.level,\n+                                                            max_line_num_len,\n+                                                            true) {\n+                                Err(e) => panic!(\"failed to emit error: {}\", e),\n+                                _ => ()\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            Err(e) => panic!(\"failed to emit error: {}\", e)\n+        }\n+        write!(&mut self.dst, \"\\n\");\n+    }\n+\n     fn emit_message_(&mut self,\n                      rsp: &RenderSpan,\n                      msg: &str,\n@@ -363,6 +912,7 @@ impl EmitterWriter {\n             }\n \n             for snippet_data in output_vec.iter() {\n+                /*\n                 let rendered_lines = snippet_data.render_lines();\n                 for rendered_line in &rendered_lines {\n                     for styled_string in &rendered_line.text {\n@@ -372,6 +922,8 @@ impl EmitterWriter {\n                     }\n                     write!(&mut self.dst, \"\\n\")?;\n                 }\n+                */\n+                emit_to_destination(&snippet_data.render_lines(), &lvl, &mut self.dst);\n             }\n         }\n         else {\n@@ -380,6 +932,8 @@ impl EmitterWriter {\n                                   span_label.is_primary,\n                                   span_label.label);\n             }\n+            emit_to_destination(&snippet_data.render_lines(), &lvl, &mut self.dst);\n+            /*\n             let rendered_lines = snippet_data.render_lines();\n             for rendered_line in &rendered_lines {\n                 for styled_string in &rendered_line.text {\n@@ -389,6 +943,7 @@ impl EmitterWriter {\n                 }\n                 write!(&mut self.dst, \"\\n\")?;\n             }\n+            */\n         }\n         Ok(())\n     }\n@@ -413,6 +968,33 @@ impl EmitterWriter {\n     }\n }\n \n+fn draw_col_separator(buffer: &mut StyledBuffer, line: usize, col: usize) {\n+    buffer.puts(line, col, \"| \", Style::LineNumber);\n+}\n+\n+fn draw_note_separator(buffer: &mut StyledBuffer, line: usize, col: usize) {\n+    buffer.puts(line, col, \"= \", Style::LineNumber);\n+}\n+\n+fn overlaps(a1: &Annotation, a2: &Annotation) -> bool {\n+    (a2.start_col..a2.end_col).contains(a1.start_col) ||\n+    (a1.start_col..a1.end_col).contains(a2.start_col)\n+}\n+\n+fn emit_to_destination(rendered_buffer: &Vec<Vec<StyledString>>,\n+        lvl: &Level,\n+        dst: &mut Destination) -> io::Result<()> {\n+    for line in rendered_buffer {\n+        for part in line {\n+            dst.apply_style(lvl.clone(), part.style);\n+            write!(dst, \"{}\", part.text);\n+            dst.reset_attrs()?;\n+        }\n+        write!(dst, \"\\n\");\n+    }\n+    Ok(())\n+}\n+\n fn line_num_max_digits(line: &LineInfo) -> usize {\n     let mut max_line_num = line.line_index + 1;\n     let mut digits = 0;\n@@ -480,7 +1062,7 @@ fn stderr_isatty() -> bool {\n     }\n }\n \n-enum Destination {\n+pub enum Destination {\n     Terminal(Box<term::StderrTerminal>),\n     Raw(Box<Write + Send>),\n }\n@@ -495,35 +1077,39 @@ impl Destination {\n \n     fn apply_style(&mut self,\n                    lvl: Level,\n-                   _kind: &RenderedLineKind,\n                    style: Style)\n                    -> io::Result<()> {\n         match style {\n-            Style::FileNameStyle |\n-            Style::LineAndColumn => {\n-            }\n+            Style::FileNameStyle | Style::LineAndColumn => {}\n             Style::LineNumber => {\n-                self.start_attr(term::Attr::Bold)?;\n-                self.start_attr(term::Attr::ForegroundColor(term::color::BRIGHT_BLUE))?;\n+                try!(self.start_attr(term::Attr::Bold));\n+                try!(self.start_attr(term::Attr::ForegroundColor(term::color::BRIGHT_BLUE)));\n             }\n-            Style::Quotation => {\n+            Style::ErrorCode => {\n+                try!(self.start_attr(term::Attr::Bold));\n+                //try!(self.start_attr(term::Attr::ForegroundColor(term::color::BRIGHT_MAGENTA)));\n             }\n-            Style::OldSkoolNote => {\n-                self.start_attr(term::Attr::Bold)?;\n-                self.start_attr(term::Attr::ForegroundColor(term::color::BRIGHT_GREEN))?;\n+            Style::Quotation => {}\n+            Style::OldSchoolNote => {\n+                try!(self.start_attr(term::Attr::Bold));\n+                try!(self.start_attr(term::Attr::ForegroundColor(term::color::BRIGHT_GREEN)));\n             }\n-            Style::OldSkoolNoteText => {\n-                self.start_attr(term::Attr::Bold)?;\n+            Style::OldSchoolNoteText | Style::HeaderMsg => {\n+                try!(self.start_attr(term::Attr::Bold));\n             }\n             Style::UnderlinePrimary | Style::LabelPrimary => {\n-                self.start_attr(term::Attr::Bold)?;\n-                self.start_attr(term::Attr::ForegroundColor(lvl.color()))?;\n+                try!(self.start_attr(term::Attr::Bold));\n+                try!(self.start_attr(term::Attr::ForegroundColor(lvl.color())));\n             }\n-            Style::UnderlineSecondary | Style::LabelSecondary => {\n-                self.start_attr(term::Attr::Bold)?;\n-                self.start_attr(term::Attr::ForegroundColor(term::color::BRIGHT_BLUE))?;\n+            Style::UnderlineSecondary |\n+            Style::LabelSecondary => {\n+                try!(self.start_attr(term::Attr::Bold));\n+                try!(self.start_attr(term::Attr::ForegroundColor(term::color::BRIGHT_BLUE)));\n             }\n-            Style::NoStyle => {\n+            Style::NoStyle => {}\n+            Style::Level(l) => {\n+                try!(self.start_attr(term::Attr::Bold));\n+                try!(self.start_attr(term::Attr::ForegroundColor(l.color())));\n             }\n         }\n         Ok(())"}, {"sha": "33781bed759f852d8dfeb06caccaad11a7d005d9", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71ec2867e3c4cc448cb64890daffd1d5ffbe353b/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ec2867e3c4cc448cb64890daffd1d5ffbe353b/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=71ec2867e3c4cc448cb64890daffd1d5ffbe353b", "patch": "@@ -49,6 +49,7 @@ use std::thread::panicking;\n pub mod emitter;\n pub mod snippet;\n pub mod registry;\n+pub mod styled_buffer;\n \n use syntax_pos::{BytePos, Loc, FileLinesResult, FileName, MultiSpan, Span, NO_EXPANSION };\n use syntax_pos::{MacroBacktrace};"}, {"sha": "525c83499fbe5cacf3b5df6c29f1808dbda47592", "filename": "src/librustc_errors/snippet.rs", "status": "modified", "additions": 64, "deletions": 152, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/71ec2867e3c4cc448cb64890daffd1d5ffbe353b/src%2Flibrustc_errors%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ec2867e3c4cc448cb64890daffd1d5ffbe353b/src%2Flibrustc_errors%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fsnippet.rs?ref=71ec2867e3c4cc448cb64890daffd1d5ffbe353b", "patch": "@@ -13,9 +13,11 @@\n use syntax_pos::{Span, FileMap, CharPos, LineInfo};\n use check_old_skool;\n use CodeMapper;\n+use styled_buffer::StyledBuffer;\n use std::cmp;\n use std::rc::Rc;\n use std::mem;\n+use {Level};\n \n #[derive(Clone)]\n pub enum FormatMode {\n@@ -49,53 +51,50 @@ pub struct FileInfo {\n     format_mode: FormatMode,\n }\n \n-#[derive(Clone, Debug)]\n-struct Line {\n-    line_index: usize,\n-    annotations: Vec<Annotation>,\n+#[derive(Clone, Debug, PartialOrd, Ord, PartialEq, Eq)]\n+pub struct Line {\n+    pub line_index: usize,\n+    pub annotations: Vec<Annotation>,\n }\n \n #[derive(Clone, Debug, PartialOrd, Ord, PartialEq, Eq)]\n-struct Annotation {\n+pub struct Annotation {\n     /// Start column, 0-based indexing -- counting *characters*, not\n     /// utf-8 bytes. Note that it is important that this field goes\n     /// first, so that when we sort, we sort orderings by start\n     /// column.\n-    start_col: usize,\n+    pub start_col: usize,\n \n     /// End column within the line (exclusive)\n-    end_col: usize,\n+    pub end_col: usize,\n \n     /// Is this annotation derived from primary span\n-    is_primary: bool,\n+    pub is_primary: bool,\n \n     /// Is this a large span minimized down to a smaller span\n-    is_minimized: bool,\n+    pub is_minimized: bool,\n \n     /// Optional label to display adjacent to the annotation.\n-    label: Option<String>,\n+    pub label: Option<String>,\n }\n \n+/*\n #[derive(Debug)]\n pub struct RenderedLine {\n     pub text: Vec<StyledString>,\n     pub kind: RenderedLineKind,\n }\n+*/\n \n #[derive(Debug)]\n pub struct StyledString {\n     pub text: String,\n     pub style: Style,\n }\n \n-#[derive(Debug)]\n-pub struct StyledBuffer {\n-    text: Vec<Vec<char>>,\n-    styles: Vec<Vec<Style>>\n-}\n-\n #[derive(Copy, Clone, Debug, PartialEq)]\n pub enum Style {\n+    HeaderMsg,\n     FileNameStyle,\n     LineAndColumn,\n     LineNumber,\n@@ -104,11 +103,14 @@ pub enum Style {\n     UnderlineSecondary,\n     LabelPrimary,\n     LabelSecondary,\n-    OldSkoolNoteText,\n-    OldSkoolNote,\n+    OldSchoolNoteText,\n+    OldSchoolNote,\n     NoStyle,\n+    ErrorCode,\n+    Level(Level),\n }\n \n+/*\n #[derive(Debug, Clone)]\n pub enum RenderedLineKind {\n     PrimaryFileName,\n@@ -120,6 +122,7 @@ pub enum RenderedLineKind {\n     Annotations,\n     Elision,\n }\n+*/\n \n impl SnippetData {\n     pub fn new(codemap: Rc<CodeMapper>,\n@@ -186,15 +189,15 @@ impl SnippetData {\n         self.files.last_mut().unwrap()\n     }\n \n-    pub fn render_lines(&self) -> Vec<RenderedLine> {\n+    pub fn render_lines(&self) -> Vec<Vec<StyledString>> {\n         debug!(\"SnippetData::render_lines()\");\n \n         let mut rendered_lines: Vec<_> =\n             self.files.iter()\n                       .flat_map(|f| f.render_file_lines(&self.codemap))\n                       .collect();\n-        prepend_prefixes(&mut rendered_lines, &self.format_mode);\n-        trim_lines(&mut rendered_lines);\n+        //prepend_prefixes(&mut rendered_lines, &self.format_mode);\n+        //trim_lines(&mut rendered_lines);\n         rendered_lines\n     }\n }\n@@ -215,6 +218,7 @@ impl StringSource for Vec<char> {\n     }\n }\n \n+/*\n impl<S> From<(S, Style, RenderedLineKind)> for RenderedLine\n     where S: StringSource\n {\n@@ -282,96 +286,20 @@ impl RenderedLineKind {\n         }\n     }\n }\n+*/\n \n-impl StyledBuffer {\n-    fn new() -> StyledBuffer {\n-        StyledBuffer { text: vec![], styles: vec![] }\n-    }\n-\n-    fn render(&self, source_kind: RenderedLineKind) -> Vec<RenderedLine> {\n-        let mut output: Vec<RenderedLine> = vec![];\n-        let mut styled_vec: Vec<StyledString> = vec![];\n-\n-        for (row, row_style) in self.text.iter().zip(&self.styles) {\n-            let mut current_style = Style::NoStyle;\n-            let mut current_text = String::new();\n-\n-            for (&c, &s) in row.iter().zip(row_style) {\n-                if s != current_style {\n-                    if !current_text.is_empty() {\n-                        styled_vec.push(StyledString { text: current_text, style: current_style });\n-                    }\n-                    current_style = s;\n-                    current_text = String::new();\n-                }\n-                current_text.push(c);\n-            }\n-            if !current_text.is_empty() {\n-                styled_vec.push(StyledString { text: current_text, style: current_style });\n-            }\n-\n-            if output.is_empty() {\n-                //We know our first output line is source and the rest are highlights and labels\n-                output.push(RenderedLine { text: styled_vec, kind: source_kind.clone() });\n-            } else {\n-                output.push(RenderedLine { text: styled_vec, kind: RenderedLineKind::Annotations });\n-            }\n-            styled_vec = vec![];\n-        }\n-\n-        output\n-    }\n-\n-    fn putc(&mut self, line: usize, col: usize, chr: char, style: Style) {\n-        while line >= self.text.len() {\n-            self.text.push(vec![]);\n-            self.styles.push(vec![]);\n-        }\n+impl FileInfo {\n+    fn get_max_line_num(&self) -> usize {\n+        let mut max = 0;\n \n-        if col < self.text[line].len() {\n-            self.text[line][col] = chr;\n-            self.styles[line][col] = style;\n-        } else {\n-            let mut i = self.text[line].len();\n-            while i < col {\n-                let s = match self.text[0].get(i) {\n-                    Some(&'\\t') => '\\t',\n-                    _ => ' '\n-                };\n-                self.text[line].push(s);\n-                self.styles[line].push(Style::NoStyle);\n-                i += 1;\n+        for line in &self.lines {\n+            if line.line_index > max {\n+                max = line.line_index;\n             }\n-            self.text[line].push(chr);\n-            self.styles[line].push(style);\n-        }\n-    }\n-\n-    fn puts(&mut self, line: usize, col: usize, string: &str, style: Style) {\n-        let mut n = col;\n-        for c in string.chars() {\n-            self.putc(line, n, c, style);\n-            n += 1;\n-        }\n-    }\n-\n-    fn set_style(&mut self, line: usize, col: usize, style: Style) {\n-        if self.styles.len() > line && self.styles[line].len() > col {\n-            self.styles[line][col] = style;\n         }\n+        max\n     }\n \n-    fn append(&mut self, line: usize, string: &str, style: Style) {\n-        if line >= self.text.len() {\n-            self.puts(line, 0, string, style);\n-        } else {\n-            let col = self.text[line].len();\n-            self.puts(line, col, string, style);\n-        }\n-    }\n-}\n-\n-impl FileInfo {\n     fn push_lines(&mut self,\n                   lines: &[LineInfo],\n                   is_primary: bool,\n@@ -469,16 +397,13 @@ impl FileInfo {\n         return line_index - first_line_index;\n     }\n \n-    fn render_file_lines(&self, codemap: &Rc<CodeMapper>) -> Vec<RenderedLine> {\n+    fn render_file_lines(&self, codemap: &Rc<CodeMapper>) -> Vec<Vec<StyledString>> {\n         let old_school = match self.format_mode {\n             FormatMode::OriginalErrorFormat => true,\n             FormatMode::NewErrorFormat => false,\n             FormatMode::EnvironmentSelected => check_old_skool()\n         };\n \n-        // As a first step, we elide any instance of more than one\n-        // continuous unannotated line.\n-\n         let mut lines_iter = self.lines.iter();\n         let mut output = vec![];\n \n@@ -487,39 +412,27 @@ impl FileInfo {\n             match self.primary_span {\n                 Some(span) => {\n                     let lo = codemap.lookup_char_pos(span.lo);\n-                    output.push(RenderedLine {\n-                        text: vec![StyledString {\n+                    output.push(vec![StyledString {\n                             text: lo.file.name.clone(),\n                             style: Style::FileNameStyle,\n                         }, StyledString {\n                             text: format!(\":{}:{}\", lo.line, lo.col.0 + 1),\n                             style: Style::LineAndColumn,\n-                        }],\n-                        kind: RenderedLineKind::PrimaryFileName,\n-                    });\n-                    output.push(RenderedLine {\n-                        text: vec![StyledString {\n+                        }]);\n+                    output.push(vec![StyledString {\n                             text: \"\".to_string(),\n                             style: Style::FileNameStyle,\n-                        }],\n-                        kind: RenderedLineKind::Annotations,\n-                    });\n+                        }]);\n                 }\n                 None => {\n-                    output.push(RenderedLine {\n-                        text: vec![StyledString {\n+                    output.push(vec![StyledString {\n                             text: self.file.name.clone(),\n                             style: Style::FileNameStyle,\n-                        }],\n-                        kind: RenderedLineKind::OtherFileName,\n-                    });\n-                    output.push(RenderedLine {\n-                        text: vec![StyledString {\n+                        }]);\n+                    output.push(vec![StyledString {\n                             text: \"\".to_string(),\n                             style: Style::FileNameStyle,\n-                        }],\n-                        kind: RenderedLineKind::Annotations,\n-                    });\n+                        }]);\n                 }\n             }\n         }\n@@ -541,8 +454,7 @@ impl FileInfo {\n                             //as an old-style note\n                             if !line.annotations[0].is_primary {\n                                 if let Some(ann) = line.annotations[0].label.clone() {\n-                                    output.push(RenderedLine {\n-                                        text: vec![StyledString {\n+                                    output.push(vec![StyledString {\n                                             text: lo.file.name.clone(),\n                                             style: Style::FileNameStyle,\n                                         }, StyledString {\n@@ -551,31 +463,29 @@ impl FileInfo {\n                                             style: Style::LineAndColumn,\n                                         }, StyledString {\n                                             text: format!(\"note: \"),\n-                                            style: Style::OldSkoolNote,\n+                                            style: Style::OldSchoolNote,\n                                         }, StyledString {\n                                             text: format!(\"{}\", ann),\n-                                            style: Style::OldSkoolNoteText,\n-                                        }],\n-                                        kind: RenderedLineKind::Annotations,\n-                                    });\n+                                            style: Style::OldSchoolNoteText,\n+                                        }]);\n                                 }\n                             }\n-                            rendered_lines[0].text.insert(0, StyledString {\n+                            rendered_lines[0].insert(0, StyledString {\n                                 text: format!(\":{} \", lo.line),\n                                 style: Style::LineAndColumn,\n                             });\n-                            rendered_lines[0].text.insert(0, StyledString {\n+                            rendered_lines[0].insert(0, StyledString {\n                                 text: lo.file.name.clone(),\n                                 style: Style::FileNameStyle,\n                             });\n                             let gap_amount =\n-                                rendered_lines[0].text[0].text.len() +\n-                                rendered_lines[0].text[1].text.len();\n+                                rendered_lines[0][0].text.len() +\n+                                rendered_lines[0][1].text.len();\n                             assert!(rendered_lines.len() >= 2,\n                                     \"no annotations resulted from: {:?}\",\n                                     line);\n                             for i in 1..rendered_lines.len() {\n-                                rendered_lines[i].text.insert(0, StyledString {\n+                                rendered_lines[i].insert(0, StyledString {\n                                     text: vec![\" \"; gap_amount].join(\"\"),\n                                     style: Style::NoStyle\n                                 });\n@@ -598,9 +508,7 @@ impl FileInfo {\n                 next_line = lines_iter.next();\n             }\n             if unannotated_lines > 1 {\n-                output.push(RenderedLine::from((String::new(),\n-                                                Style::NoStyle,\n-                                                RenderedLineKind::Elision)));\n+                output.push(vec![StyledString{ text: String::new(), style: Style::NoStyle}]);\n             } else if let Some(line) = unannotated_line {\n                 output.append(&mut self.render_line(line));\n             }\n@@ -609,7 +517,7 @@ impl FileInfo {\n         output\n     }\n \n-    fn render_line(&self, line: &Line) -> Vec<RenderedLine> {\n+    fn render_line(&self, line: &Line) -> Vec<Vec<StyledString>> {\n         let old_school = match self.format_mode {\n             FormatMode::OriginalErrorFormat => true,\n             FormatMode::NewErrorFormat => false,\n@@ -618,18 +526,20 @@ impl FileInfo {\n \n         let source_string = self.file.get_line(line.line_index)\n                                      .unwrap_or(\"\");\n+        /*\n         let source_kind = RenderedLineKind::SourceText {\n             file: self.file.clone(),\n             line_index: line.line_index,\n         };\n+        */\n \n         let mut styled_buffer = StyledBuffer::new();\n \n         // First create the source line we will highlight.\n         styled_buffer.append(0, &source_string, Style::Quotation);\n \n         if line.annotations.is_empty() {\n-            return styled_buffer.render(source_kind);\n+            return styled_buffer.render();\n         }\n \n         // We want to display like this:\n@@ -666,15 +576,15 @@ impl FileInfo {\n                             if annotation.is_primary {\n                                 Style::UnderlinePrimary\n                             } else {\n-                                Style::OldSkoolNote\n+                                Style::OldSchoolNote\n                             });\n                     }\n                     else {\n                         styled_buffer.putc(1, p, '~',\n                             if annotation.is_primary {\n                                 Style::UnderlinePrimary\n                             } else {\n-                                Style::OldSkoolNote\n+                                Style::OldSchoolNote\n                             });\n                     }\n                 }\n@@ -704,10 +614,10 @@ impl FileInfo {\n \n         // If there are no annotations that need text, we're done.\n         if labeled_annotations.is_empty() {\n-            return styled_buffer.render(source_kind);\n+            return styled_buffer.render();\n         }\n         if old_school {\n-            return styled_buffer.render(source_kind);\n+            return styled_buffer.render();\n         }\n \n         // Now add the text labels. We try, when possible, to stick the rightmost\n@@ -767,7 +677,7 @@ impl FileInfo {\n \n         // If that's the last annotation, we're done\n         if labeled_annotations.is_empty() {\n-            return styled_buffer.render(source_kind);\n+            return styled_buffer.render();\n         }\n \n         for (index, annotation) in labeled_annotations.iter().enumerate() {\n@@ -796,10 +706,11 @@ impl FileInfo {\n             }\n         }\n \n-        styled_buffer.render(source_kind)\n+        styled_buffer.render()\n     }\n }\n \n+/*\n fn prepend_prefixes(rendered_lines: &mut [RenderedLine], format_mode: &FormatMode) {\n     let old_school = match *format_mode {\n         FormatMode::OriginalErrorFormat => true,\n@@ -882,6 +793,7 @@ fn trim_lines(rendered_lines: &mut [RenderedLine]) {\n         }\n     }\n }\n+*/\n \n impl Line {\n     fn new(line_index: usize) -> Line {"}, {"sha": "570c0a09bc417e418c4d0e6f1c0034035b9d068f", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71ec2867e3c4cc448cb64890daffd1d5ffbe353b/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ec2867e3c4cc448cb64890daffd1d5ffbe353b/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=71ec2867e3c4cc448cb64890daffd1d5ffbe353b", "patch": "@@ -26,7 +26,7 @@ use std::rc::Rc;\n \n use codemap::{self, CodeMap, ExpnInfo, NameAndSpan, MacroAttribute};\n use errors;\n-use errors::snippet::{RenderedLine, SnippetData};\n+use errors::snippet::{SnippetData};\n use config;\n use entry::{self, EntryPointType};\n use ext::base::{ExtCtxt, DummyMacroLoader};"}, {"sha": "7dfe19452a2a933a64cdd849e2a21ce535880f50", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71ec2867e3c4cc448cb64890daffd1d5ffbe353b/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71ec2867e3c4cc448cb64890daffd1d5ffbe353b/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=71ec2867e3c4cc448cb64890daffd1d5ffbe353b", "patch": "@@ -568,7 +568,7 @@ impl Sub for CharPos {\n //\n \n /// A source code location used for error reporting\n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub struct Loc {\n     /// Information about the original source\n     pub file: Rc<FileMap>,"}]}