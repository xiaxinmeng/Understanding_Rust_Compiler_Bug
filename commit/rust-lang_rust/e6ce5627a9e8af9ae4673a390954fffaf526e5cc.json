{"sha": "e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "node_id": "C_kwDOAAsO6NoAKGU2Y2U1NjI3YTllOGFmOWFlNDY3M2EzOTA5NTRmZmZhZjUyNmU1Y2M", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-12T06:57:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-12T06:57:24Z"}, "message": "Auto merge of #102948 - Dylan-DPC:rollup-j8h74rb, r=Dylan-DPC\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #102110 (Migrate rustc_passes diagnostics)\n - #102187 (Use correct location for type tests in promoted constants)\n - #102239 (Move style guide to rust-lang/rust)\n - #102578 (Panic for invalid arguments of `{integer primitive}::ilog{,2,10}` in all modes)\n - #102811 (Use memset to initialize readbuf)\n - #102890 (Check representability in adt_sized_constraint)\n - #102913 (unify `IsPattern` and `IsImport` enum in `show_candidates`)\n - #102924 (rustdoc: remove unused classes from sidebar links)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "a7787f3dd60a56b679bd953185cf48229c971d41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7787f3dd60a56b679bd953185cf48229c971d41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "html_url": "https://github.com/rust-lang/rust/commit/e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b91cbe2d4ce90d30520674876e9d700cf7a561b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b91cbe2d4ce90d30520674876e9d700cf7a561b", "html_url": "https://github.com/rust-lang/rust/commit/2b91cbe2d4ce90d30520674876e9d700cf7a561b"}, {"sha": "96bcced390ee149436bab890b70821ff34912b53", "url": "https://api.github.com/repos/rust-lang/rust/commits/96bcced390ee149436bab890b70821ff34912b53", "html_url": "https://github.com/rust-lang/rust/commit/96bcced390ee149436bab890b70821ff34912b53"}], "stats": {"total": 5173, "additions": 4106, "deletions": 1067}, "files": [{"sha": "dc0f0e7cd3c4c1e46a9adb36c02083a3d31037b9", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -584,6 +584,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         // modify their locations.\n         let all_facts = &mut None;\n         let mut constraints = Default::default();\n+        let mut type_tests = Default::default();\n         let mut closure_bounds = Default::default();\n         let mut liveness_constraints =\n             LivenessValues::new(Rc::new(RegionValueElements::new(&promoted_body)));\n@@ -595,6 +596,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                 &mut this.cx.borrowck_context.constraints.outlives_constraints,\n                 &mut constraints,\n             );\n+            mem::swap(&mut this.cx.borrowck_context.constraints.type_tests, &mut type_tests);\n             mem::swap(\n                 &mut this.cx.borrowck_context.constraints.closure_bounds_mapping,\n                 &mut closure_bounds,\n@@ -619,6 +621,13 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         swap_constraints(self);\n \n         let locations = location.to_locations();\n+\n+        // Use location of promoted const in collected constraints\n+        for type_test in type_tests.iter() {\n+            let mut type_test = type_test.clone();\n+            type_test.locations = locations;\n+            self.cx.borrowck_context.constraints.type_tests.push(type_test)\n+        }\n         for constraint in constraints.outlives().iter() {\n             let mut constraint = constraint.clone();\n             constraint.locations = locations;"}, {"sha": "b9e4499d47f362ab5010ced819a5c6f67f8d16d3", "filename": "compiler/rustc_error_messages/locales/en-US/middle.ftl", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmiddle.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmiddle.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmiddle.ftl?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -18,3 +18,12 @@ middle_limit_invalid =\n \n middle_const_eval_non_int =\n     constant evaluation of enum discriminant resulted in non-integer\n+\n+middle_unknown_layout =\n+    the type `{$ty}` has an unknown layout\n+\n+middle_values_too_big =\n+    values of the type `{$ty}` are too big for the current architecture\n+\n+middle_cannot_be_normalized =\n+    unable to determine layout for `{$ty}` because `{$failure_ty}` cannot be normalized"}, {"sha": "1f1c9c29d665a6184c3543fb772577435e4ba542", "filename": "compiler/rustc_error_messages/locales/en-US/passes.ftl", "status": "modified", "additions": 478, "deletions": 81, "changes": 559, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -10,119 +10,159 @@ passes_outer_crate_level_attr =\n passes_inner_crate_level_attr =\n     crate-level attribute should be in the root module\n \n-passes_ignored_attr_with_macro = `#[{$sym}]` is ignored on struct fields, match arms and macro defs\n+passes_ignored_attr_with_macro =\n+    `#[{$sym}]` is ignored on struct fields, match arms and macro defs\n     .warn = {-passes_previously_accepted}\n     .note = {-passes_see_issue(issue: \"80564\")}\n \n-passes_ignored_attr = `#[{$sym}]` is ignored on struct fields and match arms\n+passes_ignored_attr =\n+    `#[{$sym}]` is ignored on struct fields and match arms\n     .warn = {-passes_previously_accepted}\n     .note = {-passes_see_issue(issue: \"80564\")}\n \n-passes_inline_ignored_function_prototype = `#[inline]` is ignored on function prototypes\n+passes_inline_ignored_function_prototype =\n+    `#[inline]` is ignored on function prototypes\n \n-passes_inline_ignored_constants = `#[inline]` is ignored on constants\n+passes_inline_ignored_constants =\n+    `#[inline]` is ignored on constants\n     .warn = {-passes_previously_accepted}\n     .note = {-passes_see_issue(issue: \"65833\")}\n \n-passes_inline_not_fn_or_closure = attribute should be applied to function or closure\n+passes_inline_not_fn_or_closure =\n+    attribute should be applied to function or closure\n     .label = not a function or closure\n \n-passes_no_coverage_ignored_function_prototype = `#[no_coverage]` is ignored on function prototypes\n+passes_no_coverage_ignored_function_prototype =\n+    `#[no_coverage]` is ignored on function prototypes\n \n passes_no_coverage_propagate =\n     `#[no_coverage]` does not propagate into items and must be applied to the contained functions directly\n \n-passes_no_coverage_fn_defn = `#[no_coverage]` may only be applied to function definitions\n+passes_no_coverage_fn_defn =\n+    `#[no_coverage]` may only be applied to function definitions\n \n-passes_no_coverage_not_coverable = `#[no_coverage]` must be applied to coverable code\n+passes_no_coverage_not_coverable =\n+    `#[no_coverage]` must be applied to coverable code\n     .label = not coverable code\n \n-passes_should_be_applied_to_fn = attribute should be applied to a function definition\n+passes_should_be_applied_to_fn =\n+    attribute should be applied to a function definition\n     .label = not a function definition\n \n-passes_naked_tracked_caller = cannot use `#[track_caller]` with `#[naked]`\n+passes_naked_tracked_caller =\n+    cannot use `#[track_caller]` with `#[naked]`\n \n-passes_should_be_applied_to_struct_enum = attribute should be applied to a struct or enum\n+passes_should_be_applied_to_struct_enum =\n+    attribute should be applied to a struct or enum\n     .label = not a struct or enum\n \n-passes_should_be_applied_to_trait = attribute should be applied to a trait\n+passes_should_be_applied_to_trait =\n+    attribute should be applied to a trait\n     .label = not a trait\n \n-passes_target_feature_on_statement = {passes_should_be_applied_to_fn}\n+passes_target_feature_on_statement =\n+    {passes_should_be_applied_to_fn}\n     .warn = {-passes_previously_accepted}\n     .label = {passes_should_be_applied_to_fn.label}\n \n-passes_should_be_applied_to_static = attribute should be applied to a static\n+passes_should_be_applied_to_static =\n+    attribute should be applied to a static\n     .label = not a static\n \n-passes_doc_expect_str = doc {$attr_name} attribute expects a string: #[doc({$attr_name} = \"a\")]\n+passes_doc_expect_str =\n+    doc {$attr_name} attribute expects a string: #[doc({$attr_name} = \"a\")]\n \n-passes_doc_alias_empty = {$attr_str} attribute cannot have empty value\n+passes_doc_alias_empty =\n+    {$attr_str} attribute cannot have empty value\n \n-passes_doc_alias_bad_char = {$char_} character isn't allowed in {$attr_str}\n+passes_doc_alias_bad_char =\n+    {$char_} character isn't allowed in {$attr_str}\n \n-passes_doc_alias_start_end = {$attr_str} cannot start or end with ' '\n+passes_doc_alias_start_end =\n+    {$attr_str} cannot start or end with ' '\n \n-passes_doc_alias_bad_location = {$attr_str} isn't allowed on {$location}\n+passes_doc_alias_bad_location =\n+    {$attr_str} isn't allowed on {$location}\n \n-passes_doc_alias_not_an_alias = {$attr_str} is the same as the item's name\n+passes_doc_alias_not_an_alias =\n+    {$attr_str} is the same as the item's name\n \n passes_doc_alias_duplicated = doc alias is duplicated\n     .label = first defined here\n \n-passes_doc_alias_not_string_literal = `#[doc(alias(\"a\"))]` expects string literals\n+passes_doc_alias_not_string_literal =\n+    `#[doc(alias(\"a\"))]` expects string literals\n \n passes_doc_alias_malformed =\n     doc alias attribute expects a string `#[doc(alias = \"a\")]` or a list of strings `#[doc(alias(\"a\", \"b\"))]`\n \n-passes_doc_keyword_empty_mod = `#[doc(keyword = \"...\")]` should be used on empty modules\n+passes_doc_keyword_empty_mod =\n+    `#[doc(keyword = \"...\")]` should be used on empty modules\n \n-passes_doc_keyword_not_mod = `#[doc(keyword = \"...\")]` should be used on modules\n+passes_doc_keyword_not_mod =\n+    `#[doc(keyword = \"...\")]` should be used on modules\n \n-passes_doc_keyword_invalid_ident = `{$doc_keyword}` is not a valid identifier\n+passes_doc_keyword_invalid_ident =\n+    `{$doc_keyword}` is not a valid identifier\n \n passes_doc_fake_variadic_not_valid =\n     `#[doc(fake_variadic)]` must be used on the first of a set of tuple or fn pointer trait impls with varying arity\n \n-passes_doc_keyword_only_impl = `#[doc(keyword = \"...\")]` should be used on impl blocks\n+passes_doc_keyword_only_impl =\n+    `#[doc(keyword = \"...\")]` should be used on impl blocks\n \n-passes_doc_inline_conflict_first = this attribute...\n-passes_doc_inline_conflict_second = ...conflicts with this attribute\n-passes_doc_inline_conflict = conflicting doc inlining attributes\n+passes_doc_inline_conflict_first =\n+    this attribute...\n+\n+passes_doc_inline_conflict_second =\n+    {\".\"}..conflicts with this attribute\n+\n+passes_doc_inline_conflict =\n+    conflicting doc inlining attributes\n     .help = remove one of the conflicting attributes\n \n-passes_doc_inline_only_use = this attribute can only be applied to a `use` item\n+passes_doc_inline_only_use =\n+    this attribute can only be applied to a `use` item\n     .label = only applicable on `use` items\n     .not_a_use_item_label = not a `use` item\n     .note = read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#inline-and-no_inline> for more information\n \n passes_doc_attr_not_crate_level =\n     `#![doc({$attr_name} = \"...\")]` isn't allowed as a crate-level attribute\n \n-passes_attr_crate_level = this attribute can only be applied at the crate level\n+passes_attr_crate_level =\n+    this attribute can only be applied at the crate level\n     .suggestion = to apply to the crate, use an inner attribute\n     .help = to apply to the crate, use an inner attribute\n     .note = read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level> for more information\n \n-passes_doc_test_unknown = unknown `doc(test)` attribute `{$path}`\n+passes_doc_test_unknown =\n+    unknown `doc(test)` attribute `{$path}`\n \n-passes_doc_test_takes_list = `#[doc(test(...)]` takes a list of attributes\n+passes_doc_test_takes_list =\n+    `#[doc(test(...)]` takes a list of attributes\n \n-passes_doc_primitive = `doc(primitive)` should never have been stable\n+passes_doc_primitive =\n+    `doc(primitive)` should never have been stable\n \n-passes_doc_test_unknown_any = unknown `doc` attribute `{$path}`\n+passes_doc_test_unknown_any =\n+    unknown `doc` attribute `{$path}`\n \n-passes_doc_test_unknown_spotlight = unknown `doc` attribute `{$path}`\n+passes_doc_test_unknown_spotlight =\n+    unknown `doc` attribute `{$path}`\n     .note = `doc(spotlight)` was renamed to `doc(notable_trait)`\n     .suggestion = use `notable_trait` instead\n     .no_op_note = `doc(spotlight)` is now a no-op\n \n-passes_doc_test_unknown_include = unknown `doc` attribute `{$path}`\n+passes_doc_test_unknown_include =\n+    unknown `doc` attribute `{$path}`\n     .suggestion = use `doc = include_str!` instead\n \n-passes_doc_invalid = invalid `doc` attribute\n+passes_doc_invalid =\n+    invalid `doc` attribute\n \n-passes_pass_by_value = `pass_by_value` attribute should be applied to a struct, enum or type alias\n+passes_pass_by_value =\n+    `pass_by_value` attribute should be applied to a struct, enum or type alias\n     .label = is not a struct, enum or type alias\n \n passes_allow_incoherent_impl =\n@@ -137,42 +177,54 @@ passes_must_use_async =\n     `must_use` attribute on `async` functions applies to the anonymous `Future` returned by the function, not the value within\n     .label = this attribute does nothing, the `Future`s returned by async functions are already `must_use`\n \n-passes_must_use_no_effect = `#[must_use]` has no effect when applied to {$article} {$target}\n+passes_must_use_no_effect =\n+    `#[must_use]` has no effect when applied to {$article} {$target}\n \n-passes_must_not_suspend = `must_not_suspend` attribute should be applied to a struct, enum, or trait\n+passes_must_not_suspend =\n+    `must_not_suspend` attribute should be applied to a struct, enum, or trait\n     .label = is not a struct, enum, or trait\n \n-passes_cold = {passes_should_be_applied_to_fn}\n+passes_cold =\n+    {passes_should_be_applied_to_fn}\n     .warn = {-passes_previously_accepted}\n     .label = {passes_should_be_applied_to_fn.label}\n \n-passes_link = attribute should be applied to an `extern` block with non-Rust ABI\n+passes_link =\n+    attribute should be applied to an `extern` block with non-Rust ABI\n     .warn = {-passes_previously_accepted}\n     .label = not an `extern` block\n \n-passes_link_name = attribute should be applied to a foreign function or static\n+passes_link_name =\n+    attribute should be applied to a foreign function or static\n     .warn = {-passes_previously_accepted}\n     .label = not a foreign function or static\n     .help = try `#[link(name = \"{$value}\")]` instead\n \n-passes_no_link = attribute should be applied to an `extern crate` item\n+passes_no_link =\n+    attribute should be applied to an `extern crate` item\n     .label = not an `extern crate` item\n \n-passes_export_name = attribute should be applied to a free function, impl method or static\n+passes_export_name =\n+    attribute should be applied to a free function, impl method or static\n     .label = not a free function, impl method or static\n \n-passes_rustc_layout_scalar_valid_range_not_struct = attribute should be applied to a struct\n+passes_rustc_layout_scalar_valid_range_not_struct =\n+    attribute should be applied to a struct\n     .label = not a struct\n \n-passes_rustc_layout_scalar_valid_range_arg = expected exactly one integer literal argument\n+passes_rustc_layout_scalar_valid_range_arg =\n+    expected exactly one integer literal argument\n \n-passes_rustc_legacy_const_generics_only = #[rustc_legacy_const_generics] functions must only have const generics\n+passes_rustc_legacy_const_generics_only =\n+    #[rustc_legacy_const_generics] functions must only have const generics\n     .label = non-const generic parameter\n \n-passes_rustc_legacy_const_generics_index = #[rustc_legacy_const_generics] must have one index for each generic parameter\n+passes_rustc_legacy_const_generics_index =\n+    #[rustc_legacy_const_generics] must have one index for each generic parameter\n     .label = generic parameters\n \n-passes_rustc_legacy_const_generics_index_exceed = index exceeds number of arguments\n+passes_rustc_legacy_const_generics_index_exceed =\n+    index exceeds number of arguments\n     .label = there {$arg_count ->\n         [one] is\n         *[other] are\n@@ -181,93 +233,438 @@ passes_rustc_legacy_const_generics_index_exceed = index exceeds number of argume\n         *[other] arguments\n     }\n \n-passes_rustc_legacy_const_generics_index_negative = arguments should be non-negative integers\n+passes_rustc_legacy_const_generics_index_negative =\n+    arguments should be non-negative integers\n \n-passes_rustc_dirty_clean = attribute requires -Z query-dep-graph to be enabled\n+passes_rustc_dirty_clean =\n+    attribute requires -Z query-dep-graph to be enabled\n \n-passes_link_section = attribute should be applied to a function or static\n+passes_link_section =\n+    attribute should be applied to a function or static\n     .warn = {-passes_previously_accepted}\n     .label = not a function or static\n \n-passes_no_mangle_foreign = `#[no_mangle]` has no effect on a foreign {$foreign_item_kind}\n+passes_no_mangle_foreign =\n+    `#[no_mangle]` has no effect on a foreign {$foreign_item_kind}\n     .warn = {-passes_previously_accepted}\n     .label = foreign {$foreign_item_kind}\n     .note = symbol names in extern blocks are not mangled\n     .suggestion = remove this attribute\n \n-passes_no_mangle = attribute should be applied to a free function, impl method or static\n+passes_no_mangle =\n+    attribute should be applied to a free function, impl method or static\n     .warn = {-passes_previously_accepted}\n     .label = not a free function, impl method or static\n \n-passes_repr_ident = meta item in `repr` must be an identifier\n+passes_repr_ident =\n+    meta item in `repr` must be an identifier\n \n-passes_repr_conflicting = conflicting representation hints\n+passes_repr_conflicting =\n+    conflicting representation hints\n \n-passes_used_static = attribute must be applied to a `static` variable\n+passes_used_static =\n+    attribute must be applied to a `static` variable\n \n-passes_used_compiler_linker = `used(compiler)` and `used(linker)` can't be used together\n+passes_used_compiler_linker =\n+    `used(compiler)` and `used(linker)` can't be used together\n \n-passes_allow_internal_unstable = attribute should be applied to a macro\n+passes_allow_internal_unstable =\n+    attribute should be applied to a macro\n     .label = not a macro\n \n-passes_debug_visualizer_placement = attribute should be applied to a module\n+passes_debug_visualizer_placement =\n+    attribute should be applied to a module\n \n-passes_debug_visualizer_invalid = invalid argument\n+passes_debug_visualizer_invalid =\n+    invalid argument\n     .note_1 = expected: `natvis_file = \"...\"`\n     .note_2 = OR\n     .note_3 = expected: `gdb_script_file = \"...\"`\n \n-passes_rustc_allow_const_fn_unstable = attribute should be applied to `const fn`\n+passes_debug_visualizer_unreadable =\n+    couldn't read {$file}: {$error}\n+\n+passes_rustc_allow_const_fn_unstable =\n+    attribute should be applied to `const fn`\n     .label = not a `const fn`\n \n-passes_rustc_std_internal_symbol = attribute should be applied to functions or statics\n+passes_rustc_std_internal_symbol =\n+    attribute should be applied to functions or statics\n     .label = not a function or static\n \n-passes_const_trait = attribute should be applied to a trait\n+passes_const_trait =\n+    attribute should be applied to a trait\n \n-passes_stability_promotable = attribute cannot be applied to an expression\n+passes_stability_promotable =\n+    attribute cannot be applied to an expression\n \n-passes_deprecated = attribute is ignored here\n+passes_deprecated =\n+    attribute is ignored here\n \n-passes_macro_use = `#[{$name}]` only has an effect on `extern crate` and modules\n+passes_macro_use =\n+    `#[{$name}]` only has an effect on `extern crate` and modules\n \n-passes_macro_export = `#[macro_export]` only has an effect on macro definitions\n+passes_macro_export =\n+    `#[macro_export]` only has an effect on macro definitions\n \n-passes_plugin_registrar = `#[plugin_registrar]` only has an effect on functions\n+passes_plugin_registrar =\n+    `#[plugin_registrar]` only has an effect on functions\n \n-passes_unused_empty_lints_note = attribute `{$name}` with an empty list has no effect\n+passes_unused_empty_lints_note =\n+    attribute `{$name}` with an empty list has no effect\n \n-passes_unused_no_lints_note = attribute `{$name}` without any lints has no effect\n+passes_unused_no_lints_note =\n+    attribute `{$name}` without any lints has no effect\n \n passes_unused_default_method_body_const_note =\n     `default_method_body_is_const` has been replaced with `#[const_trait]` on traits\n \n-passes_unused = unused attribute\n+passes_unused =\n+    unused attribute\n     .suggestion = remove this attribute\n \n-passes_non_exported_macro_invalid_attrs = attribute should be applied to function or closure\n+passes_non_exported_macro_invalid_attrs =\n+    attribute should be applied to function or closure\n     .label = not a function or closure\n \n-passes_unused_duplicate = unused attribute\n+passes_unused_duplicate =\n+    unused attribute\n     .suggestion = remove this attribute\n     .note = attribute also specified here\n     .warn = {-passes_previously_accepted}\n \n-passes_unused_multiple = multiple `{$name}` attributes\n+passes_unused_multiple =\n+    multiple `{$name}` attributes\n     .suggestion = remove this attribute\n     .note = attribute also specified here\n \n-passes_rustc_lint_opt_ty = `#[rustc_lint_opt_ty]` should be applied to a struct\n+passes_rustc_lint_opt_ty =\n+    `#[rustc_lint_opt_ty]` should be applied to a struct\n     .label = not a struct\n \n-passes_rustc_lint_opt_deny_field_access = `#[rustc_lint_opt_deny_field_access]` should be applied to a field\n+passes_rustc_lint_opt_deny_field_access =\n+    `#[rustc_lint_opt_deny_field_access]` should be applied to a field\n     .label = not a field\n \n-passes_link_ordinal = attribute should be applied to a foreign function or static\n+passes_link_ordinal =\n+    attribute should be applied to a foreign function or static\n     .label = not a foreign function or static\n \n-passes_collapse_debuginfo = `collapse_debuginfo` attribute should be applied to macro definitions\n+passes_collapse_debuginfo =\n+    `collapse_debuginfo` attribute should be applied to macro definitions\n     .label = not a macro definition\n \n-passes_deprecated_annotation_has_no_effect = this `#[deprecated]` annotation has no effect\n+passes_deprecated_annotation_has_no_effect =\n+    this `#[deprecated]` annotation has no effect\n     .suggestion = remove the unnecessary deprecation attribute\n+\n+passes_unknown_external_lang_item =\n+    unknown external lang item: `{$lang_item}`\n+\n+passes_missing_panic_handler =\n+    `#[panic_handler]` function required, but not found\n+\n+passes_alloc_func_required =\n+    `#[alloc_error_handler]` function required, but not found\n+\n+passes_missing_alloc_error_handler =\n+    use `#![feature(default_alloc_error_handler)]` for a default error handler\n+\n+passes_missing_lang_item =\n+    language item required, but not found: `{$name}`\n+    .note = this can occur when a binary crate with `#![no_std]` is compiled for a target where `{$name}` is defined in the standard library\n+    .help = you may be able to compile for a target that doesn't need `{$name}`, specify a target with `--target` or in `.cargo/config`\n+\n+passes_lang_item_on_incorrect_target =\n+    `{$name}` language item must be applied to a {$expected_target}\n+    .label = attribute should be applied to a {$expected_target}, not a {$actual_target}\n+\n+passes_unknown_lang_item =\n+    definition of an unknown language item: `{$name}`\n+    .label = definition of unknown language item `{$name}`\n+\n+passes_invalid_attr_at_crate_level =\n+    `{$name}` attribute cannot be used at crate level\n+    .suggestion = perhaps you meant to use an outer attribute\n+\n+passes_duplicate_diagnostic_item =\n+    duplicate diagnostic item found: `{$name}`.\n+\n+passes_duplicate_diagnostic_item_in_crate =\n+    duplicate diagnostic item in crate `{$crate_name}`: `{$name}`.\n+\n+passes_diagnostic_item_first_defined =\n+    the diagnostic item is first defined here\n+    .note = the diagnostic item is first defined in crate `{$orig_crate_name}`.\n+\n+passes_abi =\n+    abi: {$abi}\n+\n+passes_align =\n+    align: {$align}\n+\n+passes_size =\n+    size: {$size}\n+\n+passes_homogeneous_aggregate =\n+    homogeneous_aggregate: {$homogeneous_aggregate}\n+\n+passes_layout_of =\n+    layout_of({$normalized_ty}) = {$ty_layout}\n+\n+passes_unrecognized_field =\n+    unrecognized field name `{$name}`\n+\n+passes_layout =\n+    layout error: {$layout_error}\n+\n+passes_feature_stable_twice =\n+    feature `{$feature}` is declared stable since {$since}, but was previously declared stable since {$prev_since}\n+\n+passes_feature_previously_declared =\n+    feature `{$feature}` is declared {$declared}, but was previously declared {$prev_declared}\n+\n+passes_expr_not_allowed_in_context =\n+    {$expr} is not allowed in a `{$context}`\n+\n+passes_const_impl_const_trait =\n+    const `impl`s must be for traits marked with `#[const_trait]`\n+    .note = this trait must be annotated with `#[const_trait]`\n+\n+passes_break_non_loop =\n+    `break` with value from a `{$kind}` loop\n+    .label = can only break with a value inside `loop` or breakable block\n+    .label2 = you can't `break` with a value in a `{$kind}` loop\n+    .suggestion = use `break` on its own without a value inside this `{$kind}` loop\n+    .break_expr_suggestion = alternatively, you might have meant to use the available loop label\n+\n+passes_continue_labeled_block =\n+    `continue` pointing to a labeled block\n+    .label = labeled blocks cannot be `continue`'d\n+    .block_label = labeled block the `continue` points to\n+\n+passes_break_inside_closure =\n+    `{$name}` inside of a closure\n+    .label = cannot `{$name}` inside of a closure\n+    .closure_label = enclosing closure\n+\n+passes_break_inside_async_block =\n+    `{$name}` inside of an `async` block\n+    .label = cannot `{$name}` inside of an `async` block\n+    .async_block_label = enclosing `async` block\n+\n+passes_outside_loop =\n+    `{$name}` outside of a loop\n+    .label = cannot `{$name}` outside of a loop\n+\n+passes_unlabeled_in_labeled_block =\n+    unlabeled `{$cf_type}` inside of a labeled block\n+    .label = `{$cf_type}` statements that would diverge to or through a labeled block need to bear a label\n+\n+passes_unlabeled_cf_in_while_condition =\n+    `break` or `continue` with no label in the condition of a `while` loop\n+    .label = unlabeled `{$cf_type}` in the condition of a `while` loop\n+\n+passes_cannot_inline_naked_function =\n+    naked functions cannot be inlined\n+\n+passes_undefined_naked_function_abi =\n+    Rust ABI is unsupported in naked functions\n+\n+passes_no_patterns =\n+    patterns not allowed in naked function parameters\n+\n+passes_params_not_allowed =\n+    referencing function parameters is not allowed in naked functions\n+    .help = follow the calling convention in asm block to use parameters\n+\n+passes_naked_functions_asm_block =\n+    naked functions must contain a single asm block\n+    .label_multiple_asm = multiple asm blocks are unsupported in naked functions\n+    .label_non_asm = non-asm is unsupported in naked functions\n+\n+passes_naked_functions_operands =\n+    only `const` and `sym` operands are supported in naked functions\n+\n+passes_naked_functions_asm_options =\n+    asm options unsupported in naked functions: {$unsupported_options}\n+\n+passes_naked_functions_must_use_noreturn =\n+    asm in naked functions must use `noreturn` option\n+    .suggestion = consider specifying that the asm block is responsible for returning from the function\n+\n+passes_attr_only_on_main =\n+    `{$attr}` attribute can only be used on `fn main()`\n+\n+passes_attr_only_on_root_main =\n+    `{$attr}` attribute can only be used on root `fn main()`\n+\n+passes_attr_only_in_functions =\n+    `{$attr}` attribute can only be used on functions\n+\n+passes_multiple_rustc_main =\n+    multiple functions with a `#[rustc_main]` attribute\n+    .first = first `#[rustc_main]` function\n+    .additional = additional `#[rustc_main]` function\n+\n+passes_multiple_start_functions =\n+    multiple `start` functions\n+    .label = multiple `start` functions\n+    .previous = previous `#[start]` function here\n+\n+passes_extern_main =\n+    the `main` function cannot be declared in an `extern` block\n+\n+passes_unix_sigpipe_values =\n+    valid values for `#[unix_sigpipe = \"...\"]` are `inherit`, `sig_ign`, or `sig_dfl`\n+\n+passes_no_main_function =\n+    `main` function not found in crate `{$crate_name}`\n+    .here_is_main = here is a function named `main`\n+    .one_or_more_possible_main = you have one or more functions named `main` not defined at the crate level\n+    .consider_moving_main = consider moving the `main` function definitions\n+    .main_must_be_defined_at_crate = the main function must be defined at the crate level{$has_filename ->\n+        [true] {\" \"}(in `{$filename}`)\n+        *[false] {\"\"}\n+    }\n+    .consider_adding_main_to_file = consider adding a `main` function to `{$filename}`\n+    .consider_adding_main_at_crate = consider adding a `main` function at the crate level\n+    .teach_note = If you don't know the basics of Rust, you can go look to the Rust Book to get started: https://doc.rust-lang.org/book/\n+    .non_function_main = non-function item at `crate::main` is found\n+\n+passes_duplicate_lang_item =\n+    found duplicate lang item `{$lang_item_name}`\n+    .first_defined_span = the lang item is first defined here\n+    .first_defined_crate_depends = the lang item is first defined in crate `{$orig_crate_name}` (which `{$orig_dependency_of}` depends on)\n+    .first_defined_crate = the lang item is first defined in crate `{$orig_crate_name}`.\n+    .first_definition_local = first definition in the local crate (`{$orig_crate_name}`)\n+    .second_definition_local = second definition in the local crate (`{$crate_name}`)\n+    .first_definition_path = first definition in `{$orig_crate_name}` loaded from {$orig_path}\n+    .second_definition_path = second definition in `{$crate_name}` loaded from {$path}\n+\n+passes_duplicate_lang_item_crate =\n+    duplicate lang item in crate `{$crate_name}`: `{$lang_item_name}`.\n+    .first_defined_span = the lang item is first defined here\n+    .first_defined_crate_depends = the lang item is first defined in crate `{$orig_crate_name}` (which `{$orig_dependency_of}` depends on)\n+    .first_defined_crate = the lang item is first defined in crate `{$orig_crate_name}`.\n+    .first_definition_local = first definition in the local crate (`{$orig_crate_name}`)\n+    .second_definition_local = second definition in the local crate (`{$crate_name}`)\n+    .first_definition_path = first definition in `{$orig_crate_name}` loaded from {$orig_path}\n+    .second_definition_path = second definition in `{$crate_name}` loaded from {$path}\n+\n+passes_duplicate_lang_item_crate_depends =\n+    duplicate lang item in crate `{$crate_name}` (which `{$dependency_of}` depends on): `{$lang_item_name}`.\n+    .first_defined_span = the lang item is first defined here\n+    .first_defined_crate_depends = the lang item is first defined in crate `{$orig_crate_name}` (which `{$orig_dependency_of}` depends on)\n+    .first_defined_crate = the lang item is first defined in crate `{$orig_crate_name}`.\n+    .first_definition_local = first definition in the local crate (`{$orig_crate_name}`)\n+    .second_definition_local = second definition in the local crate (`{$crate_name}`)\n+    .first_definition_path = first definition in `{$orig_crate_name}` loaded from {$orig_path}\n+    .second_definition_path = second definition in `{$crate_name}` loaded from {$path}\n+\n+passes_incorrect_target =\n+    `{$name}` language item must be applied to a {$kind} with {$at_least ->\n+        [true] at least {$num}\n+        *[false] {$num}\n+    } generic {$num ->\n+        [one] argument\n+        *[other] arguments\n+    }\n+    .label = this {$kind} has {$actual_num} generic {$actual_num ->\n+        [one] argument\n+        *[other] arguments\n+    }\n+\n+passes_useless_assignment =\n+    useless assignment of {$is_field_assign ->\n+        [true] field\n+        *[false] variable\n+    } of type `{$ty}` to itself\n+\n+passes_only_has_effect_on =\n+    `#[{$attr_name}]` only has an effect on {$target_name ->\n+        [function] functions\n+        [module] modules\n+        [implementation_block] implementation blocks\n+        *[unspecified] (unspecified--this is a compiler bug)\n+    }\n+\n+passes_object_lifetime_err =\n+    {$repr}\n+\n+passes_unrecognized_repr_hint =\n+    unrecognized representation hint\n+    .help = valid reprs are `C`, `align`, `packed`, `transparent`, `simd`, `i8`, `u8`, `i16`, `u16`, `i32`, `u32`, `i64`, `u64`, `i128`, `u128`, `isize`, `usize`\n+\n+passes_attr_application_enum =\n+    attribute should be applied to an enum\n+    .label = not an enum\n+\n+passes_attr_application_struct =\n+    attribute should be applied to a struct\n+    .label = not a struct\n+\n+passes_attr_application_struct_union =\n+    attribute should be applied to a struct or union\n+    .label = not a struct or union\n+\n+passes_attr_application_struct_enum_union =\n+    attribute should be applied to a struct, enum, or union\n+    .label = not a struct, enum, or union\n+\n+passes_attr_application_struct_enum_function_union =\n+    attribute should be applied to a struct, enum, function, or union\n+    .label = not a struct, enum, function, or union\n+\n+passes_transparent_incompatible =\n+    transparent {$target} cannot have other repr hints\n+\n+passes_deprecated_attribute =\n+    deprecated attribute must be paired with either stable or unstable attribute\n+\n+passes_useless_stability =\n+    this stability annotation is useless\n+    .label = useless stability annotation\n+    .item = the stability attribute annotates this item\n+\n+passes_invalid_stability =\n+    invalid stability version found\n+    .label = invalid stability version\n+    .item = the stability attribute annotates this item\n+\n+passes_cannot_stabilize_deprecated =\n+    an API can't be stabilized after it is deprecated\n+    .label = invalid version\n+    .item = the stability attribute annotates this item\n+\n+passes_invalid_deprecation_version =\n+    invalid deprecation version found\n+    .label = invalid deprecation version\n+    .item = the stability attribute annotates this item\n+\n+passes_missing_stability_attr =\n+    {$descr} has missing stability attribute\n+\n+passes_missing_const_stab_attr =\n+    {$descr} has missing const stability attribute\n+\n+passes_trait_impl_const_stable =\n+    trait implementations cannot be const stable yet\n+    .note = see issue #67792 <https://github.com/rust-lang/rust/issues/67792> for more information\n+\n+passes_feature_only_on_nightly =\n+    `#![feature]` may not be used on the {$release_channel} release channel\n+\n+passes_unknown_feature =\n+    unknown feature `{$feature}`\n+\n+passes_implied_feature_not_exist =\n+    feature `{$implied_by}` implying `{$feature}` does not exist\n+\n+passes_duplicate_feature_err =\n+    the feature `{$feature}` has already been declared\n+\n+passes_missing_const_err =\n+    attributes `#[rustc_const_unstable]` and `#[rustc_const_stable]` require the function or method to be `const`\n+    .help = make the function or method const\n+    .label = attribute specified here"}, {"sha": "9b41234dcfb6685dd77f705ba663d3a952566662", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -255,6 +255,56 @@ impl EmissionGuarantee for () {\n     }\n }\n \n+/// Marker type which enables implementation of `create_note` and `emit_note` functions for\n+/// note-without-error struct diagnostics.\n+#[derive(Copy, Clone)]\n+pub struct Noted;\n+\n+impl<'a> DiagnosticBuilder<'a, Noted> {\n+    /// Convenience function for internal use, clients should use one of the\n+    /// `struct_*` methods on [`Handler`].\n+    pub(crate) fn new_note(handler: &'a Handler, message: impl Into<DiagnosticMessage>) -> Self {\n+        let diagnostic = Diagnostic::new_with_code(Level::Note, None, message);\n+        Self::new_diagnostic_note(handler, diagnostic)\n+    }\n+\n+    /// Creates a new `DiagnosticBuilder` with an already constructed\n+    /// diagnostic.\n+    pub(crate) fn new_diagnostic_note(handler: &'a Handler, diagnostic: Diagnostic) -> Self {\n+        debug!(\"Created new diagnostic\");\n+        Self {\n+            inner: DiagnosticBuilderInner {\n+                state: DiagnosticBuilderState::Emittable(handler),\n+                diagnostic: Box::new(diagnostic),\n+            },\n+            _marker: PhantomData,\n+        }\n+    }\n+}\n+\n+impl EmissionGuarantee for Noted {\n+    fn diagnostic_builder_emit_producing_guarantee(db: &mut DiagnosticBuilder<'_, Self>) -> Self {\n+        match db.inner.state {\n+            // First `.emit()` call, the `&Handler` is still available.\n+            DiagnosticBuilderState::Emittable(handler) => {\n+                db.inner.state = DiagnosticBuilderState::AlreadyEmittedOrDuringCancellation;\n+                handler.emit_diagnostic(&mut db.inner.diagnostic);\n+            }\n+            // `.emit()` was previously called, disallowed from repeating it.\n+            DiagnosticBuilderState::AlreadyEmittedOrDuringCancellation => {}\n+        }\n+\n+        Noted\n+    }\n+\n+    fn make_diagnostic_builder(\n+        handler: &Handler,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> DiagnosticBuilder<'_, Self> {\n+        DiagnosticBuilder::new_note(handler, msg)\n+    }\n+}\n+\n impl<'a> DiagnosticBuilder<'a, !> {\n     /// Convenience function for internal use, clients should use one of the\n     /// `struct_*` methods on [`Handler`]."}, {"sha": "c8ccdc539af5a2b13c7ff227cf63a46e06c0fd19", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -374,7 +374,7 @@ pub use diagnostic::{\n     AddToDiagnostic, DecorateLint, Diagnostic, DiagnosticArg, DiagnosticArgFromDisplay,\n     DiagnosticArgValue, DiagnosticId, DiagnosticStyledString, IntoDiagnosticArg, SubDiagnostic,\n };\n-pub use diagnostic_builder::{DiagnosticBuilder, EmissionGuarantee};\n+pub use diagnostic_builder::{DiagnosticBuilder, EmissionGuarantee, Noted};\n use std::backtrace::Backtrace;\n \n /// A handler deals with errors and other compiler output."}, {"sha": "f6f25603581b25a7b6d1a46004cd2e20ab0b6a57", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -380,7 +380,6 @@ fn check_struct(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     let def = tcx.adt_def(def_id);\n     let span = tcx.def_span(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n-    let _ = tcx.representability(def_id);\n \n     if def.repr().simd() {\n         check_simd(tcx, span, def_id);\n@@ -394,7 +393,6 @@ fn check_union(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     let def = tcx.adt_def(def_id);\n     let span = tcx.def_span(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n-    let _ = tcx.representability(def_id);\n     check_transparent(tcx, span, def);\n     check_union_fields(tcx, span, def_id);\n     check_packed(tcx, span, def);\n@@ -1489,7 +1487,6 @@ fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, vs: &'tcx [hir::Variant<'tcx>], def_id: L\n \n     detect_discriminant_duplicate(tcx, def.discriminants(tcx).collect(), vs, sp);\n \n-    let _ = tcx.representability(def_id);\n     check_transparent(tcx, sp, def);\n }\n "}, {"sha": "0a8a1bec9b8a3be020e802f79bd056f8be3752d2", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -1041,6 +1041,8 @@ fn check_type_defn<'tcx, F>(\n ) where\n     F: FnMut(&WfCheckingCtxt<'_, 'tcx>) -> Vec<AdtVariant<'tcx>>,\n {\n+    let _ = tcx.representability(item.def_id.def_id);\n+\n     enter_wf_checking_ctxt(tcx, item.span, item.def_id.def_id, |wfcx| {\n         let variants = lookup_fields(wfcx);\n         let packed = tcx.adt_def(item.def_id).repr().packed();"}, {"sha": "06eb10c9137a12f73bf1027fd9ba15267a1bd0c5", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -613,16 +613,8 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n-    // The cycle error here should be reported as an error by `check_representable`.\n-    // We consider the type as Sized in the meanwhile to avoid\n-    // further errors (done in impl Value for AdtSizedConstraint).\n-    // Use `cycle_delay_bug` to delay the cycle error here to be emitted later\n-    // in case we accidentally otherwise don't emit an error.\n-    query adt_sized_constraint(\n-        key: DefId\n-    ) -> AdtSizedConstraint<'tcx> {\n+    query adt_sized_constraint(key: DefId) -> &'tcx [Ty<'tcx>] {\n         desc { |tcx| \"computing `Sized` constraints for `{}`\", tcx.def_path_str(key) }\n-        cycle_delay_bug\n     }\n \n     query adt_dtorck_constraint("}, {"sha": "b0a2412ab153f88c5f96eb0194e60786220a4023", "filename": "compiler/rustc_middle/src/ty/adt.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -26,9 +26,6 @@ use super::{\n     Destructor, FieldDef, GenericPredicates, ReprOptions, Ty, TyCtxt, VariantDef, VariantDiscr,\n };\n \n-#[derive(Copy, Clone, HashStable, Debug)]\n-pub struct AdtSizedConstraint<'tcx>(pub &'tcx [Ty<'tcx>]);\n-\n bitflags! {\n     #[derive(HashStable, TyEncodable, TyDecodable)]\n     pub struct AdtFlags: u32 {\n@@ -563,7 +560,7 @@ impl<'tcx> AdtDef<'tcx> {\n     /// Due to normalization being eager, this applies even if\n     /// the associated type is behind a pointer (e.g., issue #31299).\n     pub fn sized_constraint(self, tcx: TyCtxt<'tcx>) -> ty::EarlyBinder<&'tcx [Ty<'tcx>]> {\n-        ty::EarlyBinder(tcx.adt_sized_constraint(self.did()).0)\n+        ty::EarlyBinder(tcx.adt_sized_constraint(self.did()))\n     }\n }\n "}, {"sha": "6045c1acdd0323703b2d923e08940ae28a84c860", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -191,10 +191,29 @@ pub enum LayoutError<'tcx> {\n \n impl<'a> IntoDiagnostic<'a, !> for LayoutError<'a> {\n     fn into_diagnostic(self, handler: &'a Handler) -> DiagnosticBuilder<'a, !> {\n-        handler.struct_fatal(self.to_string())\n+        let mut diag = handler.struct_fatal(\"\");\n+\n+        match self {\n+            LayoutError::Unknown(ty) => {\n+                diag.set_arg(\"ty\", ty);\n+                diag.set_primary_message(rustc_errors::fluent::middle::unknown_layout);\n+            }\n+            LayoutError::SizeOverflow(ty) => {\n+                diag.set_arg(\"ty\", ty);\n+                diag.set_primary_message(rustc_errors::fluent::middle::values_too_big);\n+            }\n+            LayoutError::NormalizationFailure(ty, e) => {\n+                diag.set_arg(\"ty\", ty);\n+                diag.set_arg(\"failure_ty\", e.get_type_for_failure());\n+                diag.set_primary_message(rustc_errors::fluent::middle::cannot_be_normalized);\n+            }\n+        }\n+        diag\n     }\n }\n \n+// FIXME: Once the other errors that embed this error have been converted to translateable\n+// diagnostics, this Display impl should be removed.\n impl<'tcx> fmt::Display for LayoutError<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {"}, {"sha": "ce1b69935f27a7d0fe6b74860f50c8e454aa9dfb", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -32,7 +32,7 @@ use crate::ty::layout::TyAndLayout;\n use crate::ty::subst::{GenericArg, SubstsRef};\n use crate::ty::util::AlwaysRequiresDrop;\n use crate::ty::GeneratorDiagnosticData;\n-use crate::ty::{self, AdtSizedConstraint, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt};\n+use crate::ty::{self, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt};\n use rustc_ast as ast;\n use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_attr as attr;"}, {"sha": "f4b4c3fb05a7cb9e666741851661948f101a5215", "filename": "compiler/rustc_middle/src/values.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -3,7 +3,7 @@ use rustc_errors::{pluralize, struct_span_err, Applicability, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_middle::ty::Representability;\n-use rustc_middle::ty::{self, AdtSizedConstraint, DefIdTree, Ty, TyCtxt};\n+use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt};\n use rustc_query_system::query::QueryInfo;\n use rustc_query_system::Value;\n use rustc_span::def_id::LocalDefId;\n@@ -31,18 +31,6 @@ impl<'tcx> Value<TyCtxt<'tcx>> for ty::SymbolName<'_> {\n     }\n }\n \n-impl<'tcx> Value<TyCtxt<'tcx>> for AdtSizedConstraint<'_> {\n-    fn from_cycle_error(tcx: TyCtxt<'tcx>, _: &[QueryInfo]) -> Self {\n-        // SAFETY: This is never called when `Self` is not `AdtSizedConstraint<'tcx>`.\n-        // FIXME: Represent the above fact in the trait system somehow.\n-        unsafe {\n-            std::mem::transmute::<AdtSizedConstraint<'tcx>, AdtSizedConstraint<'_>>(\n-                AdtSizedConstraint(tcx.intern_type_list(&[tcx.ty_error()])),\n-            )\n-        }\n-    }\n-}\n-\n impl<'tcx> Value<TyCtxt<'tcx>> for ty::Binder<'_, ty::FnSig<'_>> {\n     fn from_cycle_error(tcx: TyCtxt<'tcx>, _: &[QueryInfo]) -> Self {\n         let err = tcx.ty_error();"}, {"sha": "73fb89bbc385e8efc78ac72de7f2eeb9b96d3058", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 61, "deletions": 90, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -4,10 +4,13 @@\n //! conflicts between multiple such attributes attached to the same\n //! item.\n \n-use crate::errors;\n+use crate::errors::{\n+    self, AttrApplication, DebugVisualizerUnreadable, InvalidAttrAtCrateLevel, ObjectLifetimeErr,\n+    OnlyHasEffectOn, TransparentIncompatible, UnrecognizedReprHint,\n+};\n use rustc_ast::{ast, AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{fluent, struct_span_err, Applicability, MultiSpan};\n+use rustc_errors::{fluent, Applicability, MultiSpan};\n use rustc_expand::base::resolve_path;\n use rustc_feature::{AttributeDuplicates, AttributeType, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n use rustc_hir as hir;\n@@ -164,17 +167,17 @@ impl CheckAttrVisitor<'_> {\n                 sym::no_mangle => self.check_no_mangle(hir_id, attr, span, target),\n                 sym::deprecated => self.check_deprecated(hir_id, attr, span, target),\n                 sym::macro_use | sym::macro_escape => self.check_macro_use(hir_id, attr, target),\n-                sym::path => self.check_generic_attr(hir_id, attr, target, &[Target::Mod]),\n+                sym::path => self.check_generic_attr(hir_id, attr, target, Target::Mod),\n                 sym::plugin_registrar => self.check_plugin_registrar(hir_id, attr, target),\n                 sym::macro_export => self.check_macro_export(hir_id, attr, target),\n                 sym::ignore | sym::should_panic | sym::proc_macro_derive => {\n-                    self.check_generic_attr(hir_id, attr, target, &[Target::Fn])\n+                    self.check_generic_attr(hir_id, attr, target, Target::Fn)\n                 }\n                 sym::automatically_derived => {\n-                    self.check_generic_attr(hir_id, attr, target, &[Target::Impl])\n+                    self.check_generic_attr(hir_id, attr, target, Target::Impl)\n                 }\n                 sym::no_implicit_prelude => {\n-                    self.check_generic_attr(hir_id, attr, target, &[Target::Mod])\n+                    self.check_generic_attr(hir_id, attr, target, Target::Mod)\n                 }\n                 sym::rustc_object_lifetime_default => self.check_object_lifetime_default(hir_id),\n                 _ => {}\n@@ -351,31 +354,17 @@ impl CheckAttrVisitor<'_> {\n         hir_id: HirId,\n         attr: &Attribute,\n         target: Target,\n-        allowed_targets: &[Target],\n+        allowed_target: Target,\n     ) {\n-        if !allowed_targets.iter().any(|t| t == &target) {\n-            let name = attr.name_or_empty();\n-            let mut i = allowed_targets.iter();\n-            // Pluralize\n-            let b = i.next().map_or_else(String::new, |t| t.to_string() + \"s\");\n-            let supported_names = i.enumerate().fold(b, |mut b, (i, allowed_target)| {\n-                if allowed_targets.len() > 2 && i == allowed_targets.len() - 2 {\n-                    b.push_str(\", and \");\n-                } else if allowed_targets.len() == 2 && i == allowed_targets.len() - 2 {\n-                    b.push_str(\" and \");\n-                } else {\n-                    b.push_str(\", \");\n-                }\n-                // Pluralize\n-                b.push_str(&(allowed_target.to_string() + \"s\"));\n-                b\n-            });\n-            self.tcx.struct_span_lint_hir(\n+        if target != allowed_target {\n+            self.tcx.emit_spanned_lint(\n                 UNUSED_ATTRIBUTES,\n                 hir_id,\n                 attr.span,\n-                &format!(\"`#[{name}]` only has an effect on {}\", supported_names),\n-                |lint| lint,\n+                OnlyHasEffectOn {\n+                    attr_name: attr.name_or_empty(),\n+                    target_name: allowed_target.name().replace(\" \", \"_\"),\n+                },\n             );\n         }\n     }\n@@ -432,7 +421,7 @@ impl CheckAttrVisitor<'_> {\n                     ObjectLifetimeDefault::Param(def_id) => tcx.item_name(def_id).to_string(),\n                     ObjectLifetimeDefault::Ambiguous => \"Ambiguous\".to_owned(),\n                 };\n-                tcx.sess.span_err(p.span, &repr);\n+                tcx.sess.emit_err(ObjectLifetimeErr { span: p.span, repr });\n             }\n         }\n     }\n@@ -1605,12 +1594,17 @@ impl CheckAttrVisitor<'_> {\n                 continue;\n             }\n \n-            let (article, allowed_targets) = match hint.name_or_empty() {\n+            match hint.name_or_empty() {\n                 sym::C => {\n                     is_c = true;\n                     match target {\n                         Target::Struct | Target::Union | Target::Enum => continue,\n-                        _ => (\"a\", \"struct, enum, or union\"),\n+                        _ => {\n+                            self.tcx.sess.emit_err(AttrApplication::StructEnumUnion {\n+                                hint_span: hint.span(),\n+                                span,\n+                            });\n+                        }\n                     }\n                 }\n                 sym::align => {\n@@ -1626,20 +1620,30 @@ impl CheckAttrVisitor<'_> {\n \n                     match target {\n                         Target::Struct | Target::Union | Target::Enum | Target::Fn => continue,\n-                        _ => (\"a\", \"struct, enum, function, or union\"),\n+                        _ => {\n+                            self.tcx.sess.emit_err(AttrApplication::StructEnumFunctionUnion {\n+                                hint_span: hint.span(),\n+                                span,\n+                            });\n+                        }\n                     }\n                 }\n                 sym::packed => {\n                     if target != Target::Struct && target != Target::Union {\n-                        (\"a\", \"struct or union\")\n+                        self.tcx.sess.emit_err(AttrApplication::StructUnion {\n+                            hint_span: hint.span(),\n+                            span,\n+                        });\n                     } else {\n                         continue;\n                     }\n                 }\n                 sym::simd => {\n                     is_simd = true;\n                     if target != Target::Struct {\n-                        (\"a\", \"struct\")\n+                        self.tcx\n+                            .sess\n+                            .emit_err(AttrApplication::Struct { hint_span: hint.span(), span });\n                     } else {\n                         continue;\n                     }\n@@ -1648,7 +1652,12 @@ impl CheckAttrVisitor<'_> {\n                     is_transparent = true;\n                     match target {\n                         Target::Struct | Target::Union | Target::Enum => continue,\n-                        _ => (\"a\", \"struct, enum, or union\"),\n+                        _ => {\n+                            self.tcx.sess.emit_err(AttrApplication::StructEnumUnion {\n+                                hint_span: hint.span(),\n+                                span,\n+                            });\n+                        }\n                     }\n                 }\n                 sym::i8\n@@ -1665,35 +1674,18 @@ impl CheckAttrVisitor<'_> {\n                 | sym::usize => {\n                     int_reprs += 1;\n                     if target != Target::Enum {\n-                        (\"an\", \"enum\")\n+                        self.tcx\n+                            .sess\n+                            .emit_err(AttrApplication::Enum { hint_span: hint.span(), span });\n                     } else {\n                         continue;\n                     }\n                 }\n                 _ => {\n-                    struct_span_err!(\n-                        self.tcx.sess,\n-                        hint.span(),\n-                        E0552,\n-                        \"unrecognized representation hint\"\n-                    )\n-                    .help(\"valid reprs are `C`, `align`, `packed`, `transparent`, `simd`, `i8`, `u8`, \\\n-                          `i16`, `u16`, `i32`, `u32`, `i64`, `u64`, `i128`, `u128`, `isize`, `usize`\")\n-                    .emit();\n-\n+                    self.tcx.sess.emit_err(UnrecognizedReprHint { span: hint.span() });\n                     continue;\n                 }\n             };\n-\n-            struct_span_err!(\n-                self.tcx.sess,\n-                hint.span(),\n-                E0517,\n-                \"{}\",\n-                &format!(\"attribute should be applied to {article} {allowed_targets}\")\n-            )\n-            .span_label(span, &format!(\"not {article} {allowed_targets}\"))\n-            .emit();\n         }\n \n         // Just point at all repr hints if there are any incompatibilities.\n@@ -1703,14 +1695,9 @@ impl CheckAttrVisitor<'_> {\n         // Error on repr(transparent, <anything else>).\n         if is_transparent && hints.len() > 1 {\n             let hint_spans: Vec<_> = hint_spans.clone().collect();\n-            struct_span_err!(\n-                self.tcx.sess,\n-                hint_spans,\n-                E0692,\n-                \"transparent {} cannot have other repr hints\",\n-                target\n-            )\n-            .emit();\n+            self.tcx\n+                .sess\n+                .emit_err(TransparentIncompatible { hint_spans, target: target.to_string() });\n         }\n         // Warn on repr(u8, u16), repr(C, simd), and c-like-enum-repr(C, u8)\n         if (int_reprs > 1)\n@@ -1862,14 +1849,12 @@ impl CheckAttrVisitor<'_> {\n \n         match std::fs::File::open(&file) {\n             Ok(_) => true,\n-            Err(err) => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(\n-                        meta_item.span,\n-                        &format!(\"couldn't read {}: {}\", file.display(), err),\n-                    )\n-                    .emit();\n+            Err(error) => {\n+                self.tcx.sess.emit_err(DebugVisualizerUnreadable {\n+                    span: meta_item.span,\n+                    file: &file,\n+                    error,\n+                });\n                 false\n             }\n         }\n@@ -2180,25 +2165,11 @@ fn check_invalid_crate_level_attr(tcx: TyCtxt<'_>, attrs: &[Attribute]) {\n         if attr.style == AttrStyle::Inner {\n             for attr_to_check in ATTRS_TO_CHECK {\n                 if attr.has_name(*attr_to_check) {\n-                    let mut err = tcx.sess.struct_span_err(\n-                        attr.span,\n-                        &format!(\n-                            \"`{}` attribute cannot be used at crate level\",\n-                            attr_to_check.to_ident_string()\n-                        ),\n-                    );\n-                    // Only emit an error with a suggestion if we can create a\n-                    // string out of the attribute span\n-                    if let Ok(src) = tcx.sess.source_map().span_to_snippet(attr.span) {\n-                        let replacement = src.replace(\"#!\", \"#\");\n-                        err.span_suggestion_verbose(\n-                            attr.span,\n-                            \"perhaps you meant to use an outer attribute\",\n-                            replacement,\n-                            rustc_errors::Applicability::MachineApplicable,\n-                        );\n-                    }\n-                    err.emit();\n+                    tcx.sess.emit_err(InvalidAttrAtCrateLevel {\n+                        span: attr.span,\n+                        snippet: tcx.sess.source_map().span_to_snippet(attr.span).ok(),\n+                        name: *attr_to_check,\n+                    });\n                 }\n             }\n         }"}, {"sha": "aa726d6cd92aad0b9a7ce3374f23c64c944fe7d1", "filename": "compiler/rustc_passes/src/check_const.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -8,7 +8,6 @@\n //! through, but errors for structured control flow in a `const` should be emitted here.\n \n use rustc_attr as attr;\n-use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, Visitor};\n@@ -18,6 +17,8 @@ use rustc_middle::ty::TyCtxt;\n use rustc_session::parse::feature_err;\n use rustc_span::{sym, Span, Symbol};\n \n+use crate::errors::ExprNotAllowedInContext;\n+\n /// An expression that is not *always* legal in a const context.\n #[derive(Clone, Copy)]\n enum NonConstExpr {\n@@ -133,18 +134,22 @@ impl<'tcx> CheckConstVisitor<'tcx> {\n         let const_kind =\n             const_kind.expect(\"`const_check_violated` may only be called inside a const context\");\n \n-        let msg = format!(\"{} is not allowed in a `{}`\", expr.name(), const_kind.keyword_name());\n-\n         let required_gates = required_gates.unwrap_or(&[]);\n         let missing_gates: Vec<_> =\n             required_gates.iter().copied().filter(|&g| !features.enabled(g)).collect();\n \n         match missing_gates.as_slice() {\n             [] => {\n-                struct_span_err!(tcx.sess, span, E0744, \"{}\", msg).emit();\n+                tcx.sess.emit_err(ExprNotAllowedInContext {\n+                    span,\n+                    expr: expr.name(),\n+                    context: const_kind.keyword_name(),\n+                });\n             }\n \n             [missing_primary, ref missing_secondary @ ..] => {\n+                let msg =\n+                    format!(\"{} is not allowed in a `{}`\", expr.name(), const_kind.keyword_name());\n                 let mut err = feature_err(&tcx.sess.parse_sess, *missing_primary, span, &msg);\n \n                 // If multiple feature gates would be required to enable this expression, include"}, {"sha": "6a97ad3fe86e2cc367a425c92490400ed1bc279f", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -4,7 +4,7 @@\n \n use itertools::Itertools;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::{pluralize, Applicability, DelayDm, MultiSpan};\n+use rustc_errors::{pluralize, Applicability, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -18,6 +18,8 @@ use rustc_session::lint;\n use rustc_span::symbol::{sym, Symbol};\n use std::mem;\n \n+use crate::errors::UselessAssignment;\n+\n // Any local node that may call something in its body block should be\n // explored. For example, if it's a live Node::Item that is a\n // function, then we should explore its block to check for codes that\n@@ -180,19 +182,11 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n                 && !assign.span.from_expansion()\n         {\n                 let is_field_assign = matches!(lhs.kind, hir::ExprKind::Field(..));\n-                self.tcx.struct_span_lint_hir(\n+                self.tcx.emit_spanned_lint(\n                     lint::builtin::DEAD_CODE,\n                     assign.hir_id,\n                     assign.span,\n-                    DelayDm(|| format!(\n-                            \"useless assignment of {} of type `{}` to itself\",\n-                            if is_field_assign { \"field\" } else { \"variable\" },\n-                            self.typeck_results().expr_ty(lhs),\n-                        )),\n-                    |lint| {\n-                        lint\n-\n-                    },\n+                    UselessAssignment { is_field_assign, ty: self.typeck_results().expr_ty(lhs) }\n                 )\n         }\n     }"}, {"sha": "253b0a88e48aa69590a0972bc17eb29e29661c44", "filename": "compiler/rustc_passes/src/debugger_visualizer.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_passes%2Fsrc%2Fdebugger_visualizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_passes%2Fsrc%2Fdebugger_visualizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdebugger_visualizer.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -13,6 +13,8 @@ use rustc_span::{sym, DebuggerVisualizerFile, DebuggerVisualizerType};\n \n use std::sync::Arc;\n \n+use crate::errors::DebugVisualizerUnreadable;\n+\n fn check_for_debugger_visualizer<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     hir_id: HirId,\n@@ -54,13 +56,12 @@ fn check_for_debugger_visualizer<'tcx>(\n                     debugger_visualizers\n                         .insert(DebuggerVisualizerFile::new(Arc::from(contents), visualizer_type));\n                 }\n-                Err(err) => {\n-                    tcx.sess\n-                        .struct_span_err(\n-                            meta_item.span,\n-                            &format!(\"couldn't read {}: {}\", file.display(), err),\n-                        )\n-                        .emit();\n+                Err(error) => {\n+                    tcx.sess.emit_err(DebugVisualizerUnreadable {\n+                        span: meta_item.span,\n+                        file: &file,\n+                        error,\n+                    });\n                 }\n             }\n         }"}, {"sha": "3f991cf65724128814a1bf44879299b65f702a07", "filename": "compiler/rustc_passes/src/diagnostic_items.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -14,7 +14,9 @@ use rustc_hir::diagnostic_items::DiagnosticItems;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::{kw::Empty, sym, Symbol};\n+\n+use crate::errors::{DuplicateDiagnosticItem, DuplicateDiagnosticItemInCrate};\n \n fn observe_item<'tcx>(\n     tcx: TyCtxt<'tcx>,\n@@ -33,25 +35,22 @@ fn collect_item(tcx: TyCtxt<'_>, items: &mut DiagnosticItems, name: Symbol, item\n     items.id_to_name.insert(item_def_id, name);\n     if let Some(original_def_id) = items.name_to_id.insert(name, item_def_id) {\n         if original_def_id != item_def_id {\n-            let mut err = match tcx.hir().span_if_local(item_def_id) {\n-                Some(span) => tcx\n-                    .sess\n-                    .struct_span_err(span, &format!(\"duplicate diagnostic item found: `{name}`.\")),\n-                None => tcx.sess.struct_err(&format!(\n-                    \"duplicate diagnostic item in crate `{}`: `{}`.\",\n-                    tcx.crate_name(item_def_id.krate),\n-                    name\n-                )),\n-            };\n-            if let Some(span) = tcx.hir().span_if_local(original_def_id) {\n-                err.span_note(span, \"the diagnostic item is first defined here\");\n+            let orig_span = tcx.hir().span_if_local(original_def_id);\n+            let orig_crate_name = if orig_span.is_some() {\n+                None\n             } else {\n-                err.note(&format!(\n-                    \"the diagnostic item is first defined in crate `{}`.\",\n-                    tcx.crate_name(original_def_id.krate)\n-                ));\n-            }\n-            err.emit();\n+                Some(tcx.crate_name(original_def_id.krate))\n+            };\n+            match tcx.hir().span_if_local(item_def_id) {\n+                Some(span) => tcx.sess.emit_err(DuplicateDiagnosticItem { span, name }),\n+                None => tcx.sess.emit_err(DuplicateDiagnosticItemInCrate {\n+                    span: orig_span,\n+                    orig_crate_name: orig_crate_name.unwrap_or(Empty),\n+                    have_orig_crate_name: orig_crate_name.map(|_| ()),\n+                    crate_name: tcx.crate_name(item_def_id.krate),\n+                    name,\n+                }),\n+            };\n         }\n     }\n }"}, {"sha": "38a259ca8846f14834a0eb982f73dffd439c8025", "filename": "compiler/rustc_passes/src/entry.rs", "status": "modified", "additions": 55, "deletions": 90, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fentry.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -1,5 +1,5 @@\n use rustc_ast::entry::EntryPointType;\n-use rustc_errors::struct_span_err;\n+use rustc_errors::error_code;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::{ItemId, Node, CRATE_HIR_ID};\n@@ -8,7 +8,12 @@ use rustc_middle::ty::{DefIdTree, TyCtxt};\n use rustc_session::config::{sigpipe, CrateType, EntryFnType};\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::sym;\n-use rustc_span::{Span, Symbol, DUMMY_SP};\n+use rustc_span::{Span, Symbol};\n+\n+use crate::errors::{\n+    AttrOnlyInFunctions, AttrOnlyOnMain, AttrOnlyOnRootMain, ExternMain, MultipleRustcMain,\n+    MultipleStartFunctions, NoMainErr, UnixSigpipeValues,\n+};\n \n struct EntryContext<'tcx> {\n     tcx: TyCtxt<'tcx>,\n@@ -71,64 +76,57 @@ fn entry_point_type(ctxt: &EntryContext<'_>, id: ItemId, at_root: bool) -> Entry\n     }\n }\n \n-fn err_if_attr_found(ctxt: &EntryContext<'_>, id: ItemId, sym: Symbol, details: &str) {\n+fn attr_span_by_symbol(ctxt: &EntryContext<'_>, id: ItemId, sym: Symbol) -> Option<Span> {\n     let attrs = ctxt.tcx.hir().attrs(id.hir_id());\n-    if let Some(attr) = ctxt.tcx.sess.find_by_name(attrs, sym) {\n-        ctxt.tcx\n-            .sess\n-            .struct_span_err(attr.span, &format!(\"`{}` attribute {}\", sym, details))\n-            .emit();\n-    }\n+    ctxt.tcx.sess.find_by_name(attrs, sym).map(|attr| attr.span)\n }\n \n fn find_item(id: ItemId, ctxt: &mut EntryContext<'_>) {\n     let at_root = ctxt.tcx.opt_local_parent(id.def_id.def_id) == Some(CRATE_DEF_ID);\n \n     match entry_point_type(ctxt, id, at_root) {\n         EntryPointType::None => {\n-            err_if_attr_found(ctxt, id, sym::unix_sigpipe, \"can only be used on `fn main()`\");\n+            if let Some(span) = attr_span_by_symbol(ctxt, id, sym::unix_sigpipe) {\n+                ctxt.tcx.sess.emit_err(AttrOnlyOnMain { span, attr: sym::unix_sigpipe });\n+            }\n         }\n         _ if !matches!(ctxt.tcx.def_kind(id.def_id), DefKind::Fn) => {\n-            err_if_attr_found(ctxt, id, sym::start, \"can only be used on functions\");\n-            err_if_attr_found(ctxt, id, sym::rustc_main, \"can only be used on functions\");\n+            for attr in [sym::start, sym::rustc_main] {\n+                if let Some(span) = attr_span_by_symbol(ctxt, id, attr) {\n+                    ctxt.tcx.sess.emit_err(AttrOnlyInFunctions { span, attr });\n+                }\n+            }\n         }\n         EntryPointType::MainNamed => (),\n         EntryPointType::OtherMain => {\n-            err_if_attr_found(ctxt, id, sym::unix_sigpipe, \"can only be used on root `fn main()`\");\n+            if let Some(span) = attr_span_by_symbol(ctxt, id, sym::unix_sigpipe) {\n+                ctxt.tcx.sess.emit_err(AttrOnlyOnRootMain { span, attr: sym::unix_sigpipe });\n+            }\n             ctxt.non_main_fns.push(ctxt.tcx.def_span(id.def_id));\n         }\n         EntryPointType::RustcMainAttr => {\n             if ctxt.attr_main_fn.is_none() {\n                 ctxt.attr_main_fn = Some((id.def_id.def_id, ctxt.tcx.def_span(id.def_id)));\n             } else {\n-                struct_span_err!(\n-                    ctxt.tcx.sess,\n-                    ctxt.tcx.def_span(id.def_id.to_def_id()),\n-                    E0137,\n-                    \"multiple functions with a `#[rustc_main]` attribute\"\n-                )\n-                .span_label(\n-                    ctxt.tcx.def_span(id.def_id.to_def_id()),\n-                    \"additional `#[rustc_main]` function\",\n-                )\n-                .span_label(ctxt.attr_main_fn.unwrap().1, \"first `#[rustc_main]` function\")\n-                .emit();\n+                ctxt.tcx.sess.emit_err(MultipleRustcMain {\n+                    span: ctxt.tcx.def_span(id.def_id.to_def_id()),\n+                    first: ctxt.attr_main_fn.unwrap().1,\n+                    additional: ctxt.tcx.def_span(id.def_id.to_def_id()),\n+                });\n             }\n         }\n         EntryPointType::Start => {\n-            err_if_attr_found(ctxt, id, sym::unix_sigpipe, \"can only be used on `fn main()`\");\n+            if let Some(span) = attr_span_by_symbol(ctxt, id, sym::unix_sigpipe) {\n+                ctxt.tcx.sess.emit_err(AttrOnlyOnMain { span, attr: sym::unix_sigpipe });\n+            }\n             if ctxt.start_fn.is_none() {\n                 ctxt.start_fn = Some((id.def_id.def_id, ctxt.tcx.def_span(id.def_id)));\n             } else {\n-                struct_span_err!(\n-                    ctxt.tcx.sess,\n-                    ctxt.tcx.def_span(id.def_id),\n-                    E0138,\n-                    \"multiple `start` functions\"\n-                )\n-                .span_label(ctxt.start_fn.unwrap().1, \"previous `#[start]` function here\")\n-                .span_label(ctxt.tcx.def_span(id.def_id.to_def_id()), \"multiple `start` functions\")\n-                .emit();\n+                ctxt.tcx.sess.emit_err(MultipleStartFunctions {\n+                    span: ctxt.tcx.def_span(id.def_id),\n+                    labeled: ctxt.tcx.def_span(id.def_id.to_def_id()),\n+                    previous: ctxt.start_fn.unwrap().1,\n+                });\n             }\n         }\n     }\n@@ -144,12 +142,7 @@ fn configure_main(tcx: TyCtxt<'_>, visitor: &EntryContext<'_>) -> Option<(DefId,\n         if let Some(main_def) = tcx.resolutions(()).main_def && let Some(def_id) = main_def.opt_fn_def_id() {\n             // non-local main imports are handled below\n             if let Some(def_id) = def_id.as_local() && matches!(tcx.hir().find_by_def_id(def_id), Some(Node::ForeignItem(_))) {\n-                tcx.sess\n-                    .struct_span_err(\n-                        tcx.def_span(def_id),\n-                        \"the `main` function cannot be declared in an `extern` block\",\n-                    )\n-                    .emit();\n+                tcx.sess.emit_err(ExternMain { span: tcx.def_span(def_id) });\n                 return None;\n             }\n \n@@ -182,12 +175,7 @@ fn sigpipe(tcx: TyCtxt<'_>, def_id: DefId) -> u8 {\n                 sigpipe::DEFAULT\n             }\n             _ => {\n-                tcx.sess\n-                    .struct_span_err(\n-                        attr.span,\n-                        \"valid values for `#[unix_sigpipe = \\\"...\\\"]` are `inherit`, `sig_ign`, or `sig_dfl`\",\n-                    )\n-                    .emit();\n+                tcx.sess.emit_err(UnixSigpipeValues { span: attr.span });\n                 sigpipe::DEFAULT\n             }\n         }\n@@ -206,52 +194,29 @@ fn no_main_err(tcx: TyCtxt<'_>, visitor: &EntryContext<'_>) {\n     }\n \n     // There is no main function.\n-    let mut err = struct_span_err!(\n-        tcx.sess,\n-        DUMMY_SP,\n-        E0601,\n-        \"`main` function not found in crate `{}`\",\n-        tcx.crate_name(LOCAL_CRATE)\n-    );\n-    let filename = &tcx.sess.local_crate_source_file;\n-    let note = if !visitor.non_main_fns.is_empty() {\n-        for &span in &visitor.non_main_fns {\n-            err.span_note(span, \"here is a function named `main`\");\n-        }\n-        err.note(\"you have one or more functions named `main` not defined at the crate level\");\n-        err.help(\"consider moving the `main` function definitions\");\n-        // There were some functions named `main` though. Try to give the user a hint.\n-        format!(\n-            \"the main function must be defined at the crate level{}\",\n-            filename.as_ref().map(|f| format!(\" (in `{}`)\", f.display())).unwrap_or_default()\n-        )\n-    } else if let Some(filename) = filename {\n-        format!(\"consider adding a `main` function to `{}`\", filename.display())\n-    } else {\n-        String::from(\"consider adding a `main` function at the crate level\")\n-    };\n+    let mut has_filename = true;\n+    let filename = tcx.sess.local_crate_source_file.clone().unwrap_or_else(|| {\n+        has_filename = false;\n+        Default::default()\n+    });\n+    let main_def_opt = tcx.resolutions(()).main_def;\n+    let diagnostic_id = error_code!(E0601);\n+    let add_teach_note = tcx.sess.teach(&diagnostic_id);\n     // The file may be empty, which leads to the diagnostic machinery not emitting this\n     // note. This is a relatively simple way to detect that case and emit a span-less\n     // note instead.\n-    if tcx.sess.source_map().lookup_line(sp.hi()).is_ok() {\n-        err.set_span(sp.shrink_to_hi());\n-        err.span_label(sp.shrink_to_hi(), &note);\n-    } else {\n-        err.note(&note);\n-    }\n-\n-    if let Some(main_def) = tcx.resolutions(()).main_def && main_def.opt_fn_def_id().is_none(){\n-        // There is something at `crate::main`, but it is not a function definition.\n-        err.span_label(main_def.span, \"non-function item at `crate::main` is found\");\n-    }\n-\n-    if tcx.sess.teach(&err.get_code().unwrap()) {\n-        err.note(\n-            \"If you don't know the basics of Rust, you can go look to the Rust Book \\\n-                  to get started: https://doc.rust-lang.org/book/\",\n-        );\n-    }\n-    err.emit();\n+    let file_empty = !tcx.sess.source_map().lookup_line(sp.hi()).is_ok();\n+\n+    tcx.sess.emit_err(NoMainErr {\n+        sp,\n+        crate_name: tcx.crate_name(LOCAL_CRATE),\n+        has_filename,\n+        filename,\n+        file_empty,\n+        non_main_fns: visitor.non_main_fns.clone(),\n+        main_def_opt,\n+        add_teach_note,\n+    });\n }\n \n pub fn provide(providers: &mut Providers) {"}, {"sha": "1cc81a9ab9884697fafcbedfbff7c76374c9b09a", "filename": "compiler/rustc_passes/src/errors.rs", "status": "modified", "additions": 783, "deletions": 2, "changes": 785, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -1,6 +1,16 @@\n-use rustc_errors::{Applicability, MultiSpan};\n+use std::{\n+    io::Error,\n+    path::{Path, PathBuf},\n+};\n+\n+use rustc_ast::Label;\n+use rustc_errors::{error_code, Applicability, ErrorGuaranteed, IntoDiagnostic, MultiSpan};\n+use rustc_hir::{self as hir, ExprKind, Target};\n use rustc_macros::{Diagnostic, LintDiagnostic, Subdiagnostic};\n-use rustc_span::{Span, Symbol};\n+use rustc_middle::ty::{MainDefinition, Ty};\n+use rustc_span::{Span, Symbol, DUMMY_SP};\n+\n+use crate::lang_items::Duplicate;\n \n #[derive(LintDiagnostic)]\n #[diag(passes::outer_crate_level_attr)]\n@@ -526,6 +536,15 @@ pub struct DebugVisualizerInvalid {\n     pub span: Span,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(passes::debug_visualizer_unreadable)]\n+pub struct DebugVisualizerUnreadable<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub file: &'a Path,\n+    pub error: Error,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(passes::rustc_allow_const_fn_unstable)]\n pub struct RustcAllowConstFnUnstable {\n@@ -665,3 +684,765 @@ pub struct DeprecatedAnnotationHasNoEffect {\n     #[suggestion(applicability = \"machine-applicable\", code = \"\")]\n     pub span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::unknown_external_lang_item, code = \"E0264\")]\n+pub struct UnknownExternLangItem {\n+    #[primary_span]\n+    pub span: Span,\n+    pub lang_item: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::missing_panic_handler)]\n+pub struct MissingPanicHandler;\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::alloc_func_required)]\n+pub struct AllocFuncRequired;\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::missing_alloc_error_handler)]\n+pub struct MissingAllocErrorHandler;\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::missing_lang_item)]\n+#[note]\n+#[help]\n+pub struct MissingLangItem {\n+    pub name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::lang_item_on_incorrect_target, code = \"E0718\")]\n+pub struct LangItemOnIncorrectTarget {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub expected_target: Target,\n+    pub actual_target: Target,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::unknown_lang_item, code = \"E0522\")]\n+pub struct UnknownLangItem {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+pub struct InvalidAttrAtCrateLevel {\n+    pub span: Span,\n+    pub snippet: Option<String>,\n+    pub name: Symbol,\n+}\n+\n+impl IntoDiagnostic<'_> for InvalidAttrAtCrateLevel {\n+    fn into_diagnostic(\n+        self,\n+        handler: &'_ rustc_errors::Handler,\n+    ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n+        let mut diag =\n+            handler.struct_err(rustc_errors::fluent::passes::invalid_attr_at_crate_level);\n+        diag.set_span(self.span);\n+        diag.set_arg(\"name\", self.name);\n+        // Only emit an error with a suggestion if we can create a string out\n+        // of the attribute span\n+        if let Some(src) = self.snippet {\n+            let replacement = src.replace(\"#!\", \"#\");\n+            diag.span_suggestion_verbose(\n+                self.span,\n+                rustc_errors::fluent::passes::suggestion,\n+                replacement,\n+                rustc_errors::Applicability::MachineApplicable,\n+            );\n+        }\n+        diag\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::duplicate_diagnostic_item)]\n+pub struct DuplicateDiagnosticItem {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::duplicate_diagnostic_item_in_crate)]\n+pub struct DuplicateDiagnosticItemInCrate {\n+    #[note(passes::diagnostic_item_first_defined)]\n+    pub span: Option<Span>,\n+    pub orig_crate_name: Symbol,\n+    #[note]\n+    pub have_orig_crate_name: Option<()>,\n+    pub crate_name: Symbol,\n+    pub name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::abi)]\n+pub struct Abi {\n+    #[primary_span]\n+    pub span: Span,\n+    pub abi: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::align)]\n+pub struct Align {\n+    #[primary_span]\n+    pub span: Span,\n+    pub align: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::size)]\n+pub struct Size {\n+    #[primary_span]\n+    pub span: Span,\n+    pub size: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::homogeneous_aggregate)]\n+pub struct HomogeneousAggregate {\n+    #[primary_span]\n+    pub span: Span,\n+    pub homogeneous_aggregate: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::layout_of)]\n+pub struct LayoutOf {\n+    #[primary_span]\n+    pub span: Span,\n+    pub normalized_ty: String,\n+    pub ty_layout: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::unrecognized_field)]\n+pub struct UnrecognizedField {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::feature_stable_twice, code = \"E0711\")]\n+pub struct FeatureStableTwice {\n+    #[primary_span]\n+    pub span: Span,\n+    pub feature: Symbol,\n+    pub since: Symbol,\n+    pub prev_since: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::feature_previously_declared, code = \"E0711\")]\n+pub struct FeaturePreviouslyDeclared<'a, 'b> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub feature: Symbol,\n+    pub declared: &'a str,\n+    pub prev_declared: &'b str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::expr_not_allowed_in_context, code = \"E0744\")]\n+pub struct ExprNotAllowedInContext<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub expr: String,\n+    pub context: &'a str,\n+}\n+\n+pub struct BreakNonLoop<'a> {\n+    pub span: Span,\n+    pub head: Option<Span>,\n+    pub kind: &'a str,\n+    pub suggestion: String,\n+    pub loop_label: Option<Label>,\n+    pub break_label: Option<Label>,\n+    pub break_expr_kind: &'a ExprKind<'a>,\n+    pub break_expr_span: Span,\n+}\n+\n+impl<'a> IntoDiagnostic<'_> for BreakNonLoop<'a> {\n+    fn into_diagnostic(\n+        self,\n+        handler: &rustc_errors::Handler,\n+    ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n+        let mut diag = handler.struct_span_err_with_code(\n+            self.span,\n+            rustc_errors::fluent::passes::break_non_loop,\n+            error_code!(E0571),\n+        );\n+        diag.set_arg(\"kind\", self.kind);\n+        diag.span_label(self.span, rustc_errors::fluent::passes::label);\n+        if let Some(head) = self.head {\n+            diag.span_label(head, rustc_errors::fluent::passes::label2);\n+        }\n+        diag.span_suggestion(\n+            self.span,\n+            rustc_errors::fluent::passes::suggestion,\n+            self.suggestion,\n+            Applicability::MaybeIncorrect,\n+        );\n+        if let (Some(label), None) = (self.loop_label, self.break_label) {\n+            match self.break_expr_kind {\n+                ExprKind::Path(hir::QPath::Resolved(\n+                    None,\n+                    hir::Path { segments: [segment], res: hir::def::Res::Err, .. },\n+                )) if label.ident.to_string() == format!(\"'{}\", segment.ident) => {\n+                    // This error is redundant, we will have already emitted a\n+                    // suggestion to use the label when `segment` wasn't found\n+                    // (hence the `Res::Err` check).\n+                    diag.delay_as_bug();\n+                }\n+                _ => {\n+                    diag.span_suggestion(\n+                        self.break_expr_span,\n+                        rustc_errors::fluent::passes::break_expr_suggestion,\n+                        label.ident,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+            }\n+        }\n+        diag\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::continue_labeled_block, code = \"E0696\")]\n+pub struct ContinueLabeledBlock {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(passes::block_label)]\n+    pub block_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::break_inside_closure, code = \"E0267\")]\n+pub struct BreakInsideClosure<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(passes::closure_label)]\n+    pub closure_span: Span,\n+    pub name: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::break_inside_async_block, code = \"E0267\")]\n+pub struct BreakInsideAsyncBlock<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(passes::async_block_label)]\n+    pub closure_span: Span,\n+    pub name: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::outside_loop, code = \"E0268\")]\n+pub struct OutsideLoop<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub name: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::unlabeled_in_labeled_block, code = \"E0695\")]\n+pub struct UnlabeledInLabeledBlock<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub cf_type: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::unlabeled_cf_in_while_condition, code = \"E0590\")]\n+pub struct UnlabeledCfInWhileCondition<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub cf_type: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::cannot_inline_naked_function)]\n+pub struct CannotInlineNakedFunction {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(passes::undefined_naked_function_abi)]\n+pub struct UndefinedNakedFunctionAbi;\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::no_patterns)]\n+pub struct NoPatterns {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::params_not_allowed)]\n+#[help]\n+pub struct ParamsNotAllowed {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+pub struct NakedFunctionsAsmBlock {\n+    pub span: Span,\n+    pub multiple_asms: Vec<Span>,\n+    pub non_asms: Vec<Span>,\n+}\n+\n+impl IntoDiagnostic<'_> for NakedFunctionsAsmBlock {\n+    fn into_diagnostic(\n+        self,\n+        handler: &rustc_errors::Handler,\n+    ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n+        let mut diag = handler.struct_span_err_with_code(\n+            self.span,\n+            rustc_errors::fluent::passes::naked_functions_asm_block,\n+            error_code!(E0787),\n+        );\n+        for span in self.multiple_asms.iter() {\n+            diag.span_label(*span, rustc_errors::fluent::passes::label_multiple_asm);\n+        }\n+        for span in self.non_asms.iter() {\n+            diag.span_label(*span, rustc_errors::fluent::passes::label_non_asm);\n+        }\n+        diag\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::naked_functions_operands, code = \"E0787\")]\n+pub struct NakedFunctionsOperands {\n+    #[primary_span]\n+    pub unsupported_operands: Vec<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::naked_functions_asm_options, code = \"E0787\")]\n+pub struct NakedFunctionsAsmOptions {\n+    #[primary_span]\n+    pub span: Span,\n+    pub unsupported_options: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::naked_functions_must_use_noreturn, code = \"E0787\")]\n+pub struct NakedFunctionsMustUseNoreturn {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \", options(noreturn)\", applicability = \"machine-applicable\")]\n+    pub last_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::attr_only_on_main)]\n+pub struct AttrOnlyOnMain {\n+    #[primary_span]\n+    pub span: Span,\n+    pub attr: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::attr_only_on_root_main)]\n+pub struct AttrOnlyOnRootMain {\n+    #[primary_span]\n+    pub span: Span,\n+    pub attr: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::attr_only_in_functions)]\n+pub struct AttrOnlyInFunctions {\n+    #[primary_span]\n+    pub span: Span,\n+    pub attr: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::multiple_rustc_main, code = \"E0137\")]\n+pub struct MultipleRustcMain {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label(passes::first)]\n+    pub first: Span,\n+    #[label(passes::additional)]\n+    pub additional: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::multiple_start_functions, code = \"E0138\")]\n+pub struct MultipleStartFunctions {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub labeled: Span,\n+    #[label(passes::previous)]\n+    pub previous: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::extern_main)]\n+pub struct ExternMain {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::unix_sigpipe_values)]\n+pub struct UnixSigpipeValues {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::no_main_function, code = \"E0601\")]\n+pub struct NoMainFunction {\n+    #[primary_span]\n+    pub span: Span,\n+    pub crate_name: String,\n+}\n+\n+pub struct NoMainErr {\n+    pub sp: Span,\n+    pub crate_name: Symbol,\n+    pub has_filename: bool,\n+    pub filename: PathBuf,\n+    pub file_empty: bool,\n+    pub non_main_fns: Vec<Span>,\n+    pub main_def_opt: Option<MainDefinition>,\n+    pub add_teach_note: bool,\n+}\n+\n+impl<'a> IntoDiagnostic<'a> for NoMainErr {\n+    fn into_diagnostic(\n+        self,\n+        handler: &'a rustc_errors::Handler,\n+    ) -> rustc_errors::DiagnosticBuilder<'a, ErrorGuaranteed> {\n+        let mut diag = handler.struct_span_err_with_code(\n+            DUMMY_SP,\n+            rustc_errors::fluent::passes::no_main_function,\n+            error_code!(E0601),\n+        );\n+        diag.set_arg(\"crate_name\", self.crate_name);\n+        diag.set_arg(\"filename\", self.filename);\n+        diag.set_arg(\"has_filename\", self.has_filename);\n+        let note = if !self.non_main_fns.is_empty() {\n+            for &span in &self.non_main_fns {\n+                diag.span_note(span, rustc_errors::fluent::passes::here_is_main);\n+            }\n+            diag.note(rustc_errors::fluent::passes::one_or_more_possible_main);\n+            diag.help(rustc_errors::fluent::passes::consider_moving_main);\n+            // There were some functions named `main` though. Try to give the user a hint.\n+            rustc_errors::fluent::passes::main_must_be_defined_at_crate\n+        } else if self.has_filename {\n+            rustc_errors::fluent::passes::consider_adding_main_to_file\n+        } else {\n+            rustc_errors::fluent::passes::consider_adding_main_at_crate\n+        };\n+        if self.file_empty {\n+            diag.note(note);\n+        } else {\n+            diag.set_span(self.sp.shrink_to_hi());\n+            diag.span_label(self.sp.shrink_to_hi(), note);\n+        }\n+\n+        if let Some(main_def) = self.main_def_opt && main_def.opt_fn_def_id().is_none(){\n+            // There is something at `crate::main`, but it is not a function definition.\n+            diag.span_label(main_def.span, rustc_errors::fluent::passes::non_function_main);\n+        }\n+\n+        if self.add_teach_note {\n+            diag.note(rustc_errors::fluent::passes::teach_note);\n+        }\n+        diag\n+    }\n+}\n+\n+pub struct DuplicateLangItem {\n+    pub local_span: Option<Span>,\n+    pub lang_item_name: Symbol,\n+    pub crate_name: Symbol,\n+    pub dependency_of: Symbol,\n+    pub is_local: bool,\n+    pub path: String,\n+    pub first_defined_span: Option<Span>,\n+    pub orig_crate_name: Symbol,\n+    pub orig_dependency_of: Symbol,\n+    pub orig_is_local: bool,\n+    pub orig_path: String,\n+    pub(crate) duplicate: Duplicate,\n+}\n+\n+impl IntoDiagnostic<'_> for DuplicateLangItem {\n+    fn into_diagnostic(\n+        self,\n+        handler: &rustc_errors::Handler,\n+    ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n+        let mut diag = handler.struct_err_with_code(\n+            match self.duplicate {\n+                Duplicate::Plain => rustc_errors::fluent::passes::duplicate_lang_item,\n+\n+                Duplicate::Crate => rustc_errors::fluent::passes::duplicate_lang_item_crate,\n+                Duplicate::CrateDepends => {\n+                    rustc_errors::fluent::passes::duplicate_lang_item_crate_depends\n+                }\n+            },\n+            error_code!(E0152),\n+        );\n+        diag.set_arg(\"lang_item_name\", self.lang_item_name);\n+        diag.set_arg(\"crate_name\", self.crate_name);\n+        diag.set_arg(\"dependency_of\", self.dependency_of);\n+        diag.set_arg(\"path\", self.path);\n+        diag.set_arg(\"orig_crate_name\", self.orig_crate_name);\n+        diag.set_arg(\"orig_dependency_of\", self.orig_dependency_of);\n+        diag.set_arg(\"orig_path\", self.orig_path);\n+        if let Some(span) = self.local_span {\n+            diag.set_span(span);\n+        }\n+        if let Some(span) = self.first_defined_span {\n+            diag.span_note(span, rustc_errors::fluent::passes::first_defined_span);\n+        } else {\n+            if self.orig_dependency_of.is_empty() {\n+                diag.note(rustc_errors::fluent::passes::first_defined_crate);\n+            } else {\n+                diag.note(rustc_errors::fluent::passes::first_defined_crate_depends);\n+            }\n+\n+            if self.orig_is_local {\n+                diag.note(rustc_errors::fluent::passes::first_definition_local);\n+            } else {\n+                diag.note(rustc_errors::fluent::passes::first_definition_path);\n+            }\n+\n+            if self.is_local {\n+                diag.note(rustc_errors::fluent::passes::second_definition_local);\n+            } else {\n+                diag.note(rustc_errors::fluent::passes::second_definition_path);\n+            }\n+        }\n+        diag\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::incorrect_target, code = \"E0718\")]\n+pub struct IncorrectTarget<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub generics_span: Span,\n+    pub name: &'a str, // cannot be symbol because it renders e.g. `r#fn` instead of `fn`\n+    pub kind: &'static str,\n+    pub num: usize,\n+    pub actual_num: usize,\n+    pub at_least: bool,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(passes::useless_assignment)]\n+pub struct UselessAssignment<'a> {\n+    pub is_field_assign: bool,\n+    pub ty: Ty<'a>,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(passes::only_has_effect_on)]\n+pub struct OnlyHasEffectOn {\n+    pub attr_name: Symbol,\n+    pub target_name: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::object_lifetime_err)]\n+pub struct ObjectLifetimeErr {\n+    #[primary_span]\n+    pub span: Span,\n+    pub repr: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::unrecognized_repr_hint, code = \"E0552\")]\n+#[help]\n+pub struct UnrecognizedReprHint {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+pub enum AttrApplication {\n+    #[diag(passes::attr_application_enum, code = \"E0517\")]\n+    Enum {\n+        #[primary_span]\n+        hint_span: Span,\n+        #[label]\n+        span: Span,\n+    },\n+    #[diag(passes::attr_application_struct, code = \"E0517\")]\n+    Struct {\n+        #[primary_span]\n+        hint_span: Span,\n+        #[label]\n+        span: Span,\n+    },\n+    #[diag(passes::attr_application_struct_union, code = \"E0517\")]\n+    StructUnion {\n+        #[primary_span]\n+        hint_span: Span,\n+        #[label]\n+        span: Span,\n+    },\n+    #[diag(passes::attr_application_struct_enum_union, code = \"E0517\")]\n+    StructEnumUnion {\n+        #[primary_span]\n+        hint_span: Span,\n+        #[label]\n+        span: Span,\n+    },\n+    #[diag(passes::attr_application_struct_enum_function_union, code = \"E0517\")]\n+    StructEnumFunctionUnion {\n+        #[primary_span]\n+        hint_span: Span,\n+        #[label]\n+        span: Span,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::transparent_incompatible, code = \"E0692\")]\n+pub struct TransparentIncompatible {\n+    #[primary_span]\n+    pub hint_spans: Vec<Span>,\n+    pub target: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::deprecated_attribute, code = \"E0549\")]\n+pub struct DeprecatedAttribute {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::useless_stability)]\n+pub struct UselessStability {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(passes::item)]\n+    pub item_sp: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::invalid_stability)]\n+pub struct InvalidStability {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(passes::item)]\n+    pub item_sp: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::cannot_stabilize_deprecated)]\n+pub struct CannotStabilizeDeprecated {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(passes::item)]\n+    pub item_sp: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::invalid_deprecation_version)]\n+pub struct InvalidDeprecationVersion {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(passes::item)]\n+    pub item_sp: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::missing_stability_attr)]\n+pub struct MissingStabilityAttr<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub descr: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::missing_const_stab_attr)]\n+pub struct MissingConstStabAttr<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub descr: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::trait_impl_const_stable)]\n+#[note]\n+pub struct TraitImplConstStable {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::feature_only_on_nightly, code = \"E0554\")]\n+pub struct FeatureOnlyOnNightly {\n+    #[primary_span]\n+    pub span: Span,\n+    pub release_channel: &'static str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::unknown_feature, code = \"E0635\")]\n+pub struct UnknownFeature {\n+    #[primary_span]\n+    pub span: Span,\n+    pub feature: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::implied_feature_not_exist)]\n+pub struct ImpliedFeatureNotExist {\n+    #[primary_span]\n+    pub span: Span,\n+    pub feature: Symbol,\n+    pub implied_by: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::duplicate_feature_err, code = \"E0636\")]\n+pub struct DuplicateFeatureErr {\n+    #[primary_span]\n+    pub span: Span,\n+    pub feature: Symbol,\n+}\n+#[derive(Diagnostic)]\n+#[diag(passes::missing_const_err)]\n+pub struct MissingConstErr {\n+    #[primary_span]\n+    #[help]\n+    pub fn_sig_span: Span,\n+    #[label]\n+    pub const_span: Span,\n+}"}, {"sha": "71b0735192ac49df244fad49b54b3d7f688c53a2", "filename": "compiler/rustc_passes/src/lang_items.rs", "status": "modified", "additions": 92, "deletions": 115, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -8,20 +8,28 @@\n //! * Functions called by the compiler itself.\n \n use crate::check_attr::target_from_impl_item;\n+use crate::errors::{\n+    DuplicateLangItem, IncorrectTarget, LangItemOnIncorrectTarget, UnknownLangItem,\n+};\n use crate::weak_lang_items;\n \n-use rustc_errors::{pluralize, struct_span_err};\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::{extract, GenericRequirement, ITEM_REFS};\n use rustc_hir::{HirId, LangItem, LanguageItems, Target};\n use rustc_middle::ty::TyCtxt;\n use rustc_session::cstore::ExternCrate;\n-use rustc_span::Span;\n+use rustc_span::{symbol::kw::Empty, Span};\n \n use rustc_middle::ty::query::Providers;\n \n+pub(crate) enum Duplicate {\n+    Plain,\n+    Crate,\n+    CrateDepends,\n+}\n+\n struct LanguageItemCollector<'tcx> {\n     items: LanguageItems,\n     tcx: TyCtxt<'tcx>,\n@@ -34,42 +42,24 @@ impl<'tcx> LanguageItemCollector<'tcx> {\n \n     fn check_for_lang(&mut self, actual_target: Target, hir_id: HirId) {\n         let attrs = self.tcx.hir().attrs(hir_id);\n-        if let Some((value, span)) = extract(&attrs) {\n-            match ITEM_REFS.get(&value).cloned() {\n+        if let Some((name, span)) = extract(&attrs) {\n+            match ITEM_REFS.get(&name).cloned() {\n                 // Known lang item with attribute on correct target.\n                 Some((item_index, expected_target)) if actual_target == expected_target => {\n                     self.collect_item_extended(item_index, hir_id, span);\n                 }\n                 // Known lang item with attribute on incorrect target.\n                 Some((_, expected_target)) => {\n-                    struct_span_err!(\n-                        self.tcx.sess,\n+                    self.tcx.sess.emit_err(LangItemOnIncorrectTarget {\n                         span,\n-                        E0718,\n-                        \"`{}` language item must be applied to a {}\",\n-                        value,\n+                        name,\n                         expected_target,\n-                    )\n-                    .span_label(\n-                        span,\n-                        format!(\n-                            \"attribute should be applied to a {}, not a {}\",\n-                            expected_target, actual_target,\n-                        ),\n-                    )\n-                    .emit();\n+                        actual_target,\n+                    });\n                 }\n                 // Unknown lang item.\n                 _ => {\n-                    struct_span_err!(\n-                        self.tcx.sess,\n-                        span,\n-                        E0522,\n-                        \"definition of an unknown language item: `{}`\",\n-                        value\n-                    )\n-                    .span_label(span, format!(\"definition of unknown language item `{}`\", value))\n-                    .emit();\n+                    self.tcx.sess.emit_err(UnknownLangItem { span, name });\n                 }\n             }\n         }\n@@ -79,74 +69,72 @@ impl<'tcx> LanguageItemCollector<'tcx> {\n         // Check for duplicates.\n         if let Some(original_def_id) = self.items.items[item_index] {\n             if original_def_id != item_def_id {\n-                let lang_item = LangItem::from_u32(item_index as u32).unwrap();\n-                let name = lang_item.name();\n-                let mut err = match self.tcx.hir().span_if_local(item_def_id) {\n-                    Some(span) => struct_span_err!(\n-                        self.tcx.sess,\n-                        span,\n-                        E0152,\n-                        \"found duplicate lang item `{}`\",\n-                        name\n-                    ),\n-                    None => match self.tcx.extern_crate(item_def_id) {\n-                        Some(ExternCrate { dependency_of, .. }) => {\n-                            self.tcx.sess.struct_err(&format!(\n-                                \"duplicate lang item in crate `{}` (which `{}` depends on): `{}`.\",\n-                                self.tcx.crate_name(item_def_id.krate),\n-                                self.tcx.crate_name(*dependency_of),\n-                                name\n-                            ))\n-                        }\n-                        _ => self.tcx.sess.struct_err(&format!(\n-                            \"duplicate lang item in crate `{}`: `{}`.\",\n-                            self.tcx.crate_name(item_def_id.krate),\n-                            name\n-                        )),\n-                    },\n+                let local_span = self.tcx.hir().span_if_local(item_def_id);\n+                let lang_item_name = LangItem::from_u32(item_index as u32).unwrap().name();\n+                let crate_name = self.tcx.crate_name(item_def_id.krate);\n+                let mut dependency_of = Empty;\n+                let is_local = item_def_id.is_local();\n+                let path = if is_local {\n+                    String::new()\n+                } else {\n+                    self.tcx\n+                        .crate_extern_paths(item_def_id.krate)\n+                        .iter()\n+                        .map(|p| p.display().to_string())\n+                        .collect::<Vec<_>>()\n+                        .join(\", \")\n+                        .into()\n                 };\n-                if let Some(span) = self.tcx.hir().span_if_local(original_def_id) {\n-                    err.span_note(span, \"the lang item is first defined here\");\n+                let first_defined_span = self.tcx.hir().span_if_local(original_def_id);\n+                let mut orig_crate_name = Empty;\n+                let mut orig_dependency_of = Empty;\n+                let orig_is_local = original_def_id.is_local();\n+                let orig_path = if orig_is_local {\n+                    String::new()\n                 } else {\n-                    match self.tcx.extern_crate(original_def_id) {\n-                        Some(ExternCrate { dependency_of, .. }) => {\n-                            err.note(&format!(\n-                                \"the lang item is first defined in crate `{}` (which `{}` depends on)\",\n-                                self.tcx.crate_name(original_def_id.krate),\n-                                self.tcx.crate_name(*dependency_of)\n-                            ));\n-                        }\n-                        _ => {\n-                            err.note(&format!(\n-                                \"the lang item is first defined in crate `{}`.\",\n-                                self.tcx.crate_name(original_def_id.krate)\n-                            ));\n-                        }\n+                    self.tcx\n+                        .crate_extern_paths(original_def_id.krate)\n+                        .iter()\n+                        .map(|p| p.display().to_string())\n+                        .collect::<Vec<_>>()\n+                        .join(\", \")\n+                        .into()\n+                };\n+                if first_defined_span.is_none() {\n+                    orig_crate_name = self.tcx.crate_name(original_def_id.krate);\n+                    if let Some(ExternCrate { dependency_of: inner_dependency_of, .. }) =\n+                        self.tcx.extern_crate(original_def_id)\n+                    {\n+                        orig_dependency_of = self.tcx.crate_name(*inner_dependency_of);\n                     }\n-                    let mut note_def = |which, def_id: DefId| {\n-                        let crate_name = self.tcx.crate_name(def_id.krate);\n-                        let note = if def_id.is_local() {\n-                            format!(\"{} definition in the local crate (`{}`)\", which, crate_name)\n-                        } else {\n-                            let paths: Vec<_> = self\n-                                .tcx\n-                                .crate_extern_paths(def_id.krate)\n-                                .iter()\n-                                .map(|p| p.display().to_string())\n-                                .collect();\n-                            format!(\n-                                \"{} definition in `{}` loaded from {}\",\n-                                which,\n-                                crate_name,\n-                                paths.join(\", \")\n-                            )\n-                        };\n-                        err.note(&note);\n-                    };\n-                    note_def(\"first\", original_def_id);\n-                    note_def(\"second\", item_def_id);\n                 }\n-                err.emit();\n+\n+                let duplicate = if local_span.is_some() {\n+                    Duplicate::Plain\n+                } else {\n+                    match self.tcx.extern_crate(item_def_id) {\n+                        Some(ExternCrate { dependency_of: inner_dependency_of, .. }) => {\n+                            dependency_of = self.tcx.crate_name(*inner_dependency_of);\n+                            Duplicate::CrateDepends\n+                        }\n+                        _ => Duplicate::Crate,\n+                    }\n+                };\n+\n+                self.tcx.sess.emit_err(DuplicateLangItem {\n+                    local_span,\n+                    lang_item_name,\n+                    crate_name,\n+                    dependency_of,\n+                    is_local,\n+                    path,\n+                    first_defined_span,\n+                    orig_crate_name,\n+                    orig_dependency_of,\n+                    orig_is_local,\n+                    orig_path,\n+                    duplicate,\n+                });\n             }\n         }\n \n@@ -179,41 +167,30 @@ impl<'tcx> LanguageItemCollector<'tcx> {\n                 None => (0, *item_span),\n             };\n \n+            let mut at_least = false;\n             let required = match lang_item.required_generics() {\n-                GenericRequirement::Exact(num) if num != actual_num => {\n-                    Some((format!(\"{}\", num), pluralize!(num)))\n-                }\n+                GenericRequirement::Exact(num) if num != actual_num => Some(num),\n                 GenericRequirement::Minimum(num) if actual_num < num => {\n-                    Some((format!(\"at least {}\", num), pluralize!(num)))\n-                }\n+                    at_least = true;\n+                    Some(num)}\n+                ,\n                 // If the number matches, or there is no requirement, handle it normally\n                 _ => None,\n             };\n \n-            if let Some((range_str, pluralized)) = required {\n+            if let Some(num) = required {\n                 // We are issuing E0718 \"incorrect target\" here, because while the\n                 // item kind of the target is correct, the target is still wrong\n                 // because of the wrong number of generic arguments.\n-                struct_span_err!(\n-                    self.tcx.sess,\n+                self.tcx.sess.emit_err(IncorrectTarget {\n                     span,\n-                    E0718,\n-                    \"`{}` language item must be applied to a {} with {} generic argument{}\",\n-                    name,\n-                    kind.descr(),\n-                    range_str,\n-                    pluralized,\n-                )\n-                .span_label(\n                     generics_span,\n-                    format!(\n-                        \"this {} has {} generic argument{}\",\n-                        kind.descr(),\n-                        actual_num,\n-                        pluralize!(actual_num),\n-                    ),\n-                )\n-                .emit();\n+                    name: name.as_str(),\n+                    kind: kind.descr(),\n+                    num,\n+                    actual_num,\n+                    at_least,\n+                });\n \n                 // return early to not collect the lang item\n                 return;"}, {"sha": "c1085094962a741110a9de703057e7c9a6a57b34", "filename": "compiler/rustc_passes/src/layout_test.rs", "status": "modified", "additions": 38, "deletions": 33, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -3,10 +3,13 @@ use rustc_hir::def::DefKind;\n use rustc_hir::def_id::LocalDefId;\n use rustc_middle::ty::layout::{HasParamEnv, HasTyCtxt, LayoutError, LayoutOfHelpers, TyAndLayout};\n use rustc_middle::ty::{ParamEnv, Ty, TyCtxt};\n+use rustc_span::source_map::Spanned;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_target::abi::{HasDataLayout, TargetDataLayout};\n \n+use crate::errors::{Abi, Align, HomogeneousAggregate, LayoutOf, Size, UnrecognizedField};\n+\n pub fn test_layout(tcx: TyCtxt<'_>) {\n     if tcx.features().rustc_attrs {\n         // if the `rustc_attrs` feature is not enabled, don't bother testing layout\n@@ -35,62 +38,64 @@ fn dump_layout_of<'tcx>(tcx: TyCtxt<'tcx>, item_def_id: LocalDefId, attr: &Attri\n             for meta_item in meta_items {\n                 match meta_item.name_or_empty() {\n                     sym::abi => {\n-                        tcx.sess.span_err(\n-                            tcx.def_span(item_def_id.to_def_id()),\n-                            &format!(\"abi: {:?}\", ty_layout.abi),\n-                        );\n+                        tcx.sess.emit_err(Abi {\n+                            span: tcx.def_span(item_def_id.to_def_id()),\n+                            abi: format!(\"{:?}\", ty_layout.abi),\n+                        });\n                     }\n \n                     sym::align => {\n-                        tcx.sess.span_err(\n-                            tcx.def_span(item_def_id.to_def_id()),\n-                            &format!(\"align: {:?}\", ty_layout.align),\n-                        );\n+                        tcx.sess.emit_err(Align {\n+                            span: tcx.def_span(item_def_id.to_def_id()),\n+                            align: format!(\"{:?}\", ty_layout.align),\n+                        });\n                     }\n \n                     sym::size => {\n-                        tcx.sess.span_err(\n-                            tcx.def_span(item_def_id.to_def_id()),\n-                            &format!(\"size: {:?}\", ty_layout.size),\n-                        );\n+                        tcx.sess.emit_err(Size {\n+                            span: tcx.def_span(item_def_id.to_def_id()),\n+                            size: format!(\"{:?}\", ty_layout.size),\n+                        });\n                     }\n \n                     sym::homogeneous_aggregate => {\n-                        tcx.sess.span_err(\n-                            tcx.def_span(item_def_id.to_def_id()),\n-                            &format!(\n-                                \"homogeneous_aggregate: {:?}\",\n-                                ty_layout.homogeneous_aggregate(&UnwrapLayoutCx { tcx, param_env }),\n+                        tcx.sess.emit_err(HomogeneousAggregate {\n+                            span: tcx.def_span(item_def_id.to_def_id()),\n+                            homogeneous_aggregate: format!(\n+                                \"{:?}\",\n+                                ty_layout.homogeneous_aggregate(&UnwrapLayoutCx { tcx, param_env })\n                             ),\n-                        );\n+                        });\n                     }\n \n                     sym::debug => {\n-                        let normalized_ty = tcx.normalize_erasing_regions(\n-                            param_env.with_reveal_all_normalized(tcx),\n-                            ty,\n-                        );\n-                        tcx.sess.span_err(\n-                            tcx.def_span(item_def_id.to_def_id()),\n-                            &format!(\"layout_of({:?}) = {:#?}\", normalized_ty, *ty_layout),\n+                        let normalized_ty = format!(\n+                            \"{:?}\",\n+                            tcx.normalize_erasing_regions(\n+                                param_env.with_reveal_all_normalized(tcx),\n+                                ty,\n+                            )\n                         );\n+                        let ty_layout = format!(\"{:#?}\", *ty_layout);\n+                        tcx.sess.emit_err(LayoutOf {\n+                            span: tcx.def_span(item_def_id.to_def_id()),\n+                            normalized_ty,\n+                            ty_layout,\n+                        });\n                     }\n \n                     name => {\n-                        tcx.sess.span_err(\n-                            meta_item.span(),\n-                            &format!(\"unrecognized field name `{}`\", name),\n-                        );\n+                        tcx.sess.emit_err(UnrecognizedField { span: meta_item.span(), name });\n                     }\n                 }\n             }\n         }\n \n         Err(layout_error) => {\n-            tcx.sess.span_err(\n-                tcx.def_span(item_def_id.to_def_id()),\n-                &format!(\"layout error: {:?}\", layout_error),\n-            );\n+            tcx.sess.emit_fatal(Spanned {\n+                node: layout_error,\n+                span: tcx.def_span(item_def_id.to_def_id()),\n+            });\n         }\n     }\n }"}, {"sha": "15f60f626c89aa54be31b73707b0a34a87f80c6d", "filename": "compiler/rustc_passes/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -5,6 +5,8 @@\n //! This API is completely unstable and subject to change.\n \n #![allow(rustc::potential_query_instability)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(iter_intersperse)]\n #![feature(let_chains)]"}, {"sha": "b5843c0ae488b1f17c58d81c1ae91758baf4e8e7", "filename": "compiler/rustc_passes/src/lib_features.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -6,7 +6,6 @@\n \n use rustc_ast::{Attribute, MetaItemKind};\n use rustc_attr::{rust_version_symbol, VERSION_PLACEHOLDER};\n-use rustc_errors::struct_span_err;\n use rustc_hir::intravisit::Visitor;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::lib_features::LibFeatures;\n@@ -15,6 +14,8 @@ use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::Symbol;\n use rustc_span::{sym, Span};\n \n+use crate::errors::{FeaturePreviouslyDeclared, FeatureStableTwice};\n+\n fn new_lib_features() -> LibFeatures {\n     LibFeatures { stable: Default::default(), unstable: Default::default() }\n }\n@@ -92,14 +93,12 @@ impl<'tcx> LibFeatureCollector<'tcx> {\n             (Some(since), _, false) => {\n                 if let Some((prev_since, _)) = self.lib_features.stable.get(&feature) {\n                     if *prev_since != since {\n-                        self.span_feature_error(\n+                        self.tcx.sess.emit_err(FeatureStableTwice {\n                             span,\n-                            &format!(\n-                                \"feature `{}` is declared stable since {}, \\\n-                                 but was previously declared stable since {}\",\n-                                feature, since, prev_since,\n-                            ),\n-                        );\n+                            feature,\n+                            since,\n+                            prev_since: *prev_since,\n+                        });\n                         return;\n                     }\n                 }\n@@ -110,22 +109,17 @@ impl<'tcx> LibFeatureCollector<'tcx> {\n                 self.lib_features.unstable.insert(feature, span);\n             }\n             (Some(_), _, true) | (None, true, _) => {\n-                self.span_feature_error(\n+                let declared = if since.is_some() { \"stable\" } else { \"unstable\" };\n+                let prev_declared = if since.is_none() { \"stable\" } else { \"unstable\" };\n+                self.tcx.sess.emit_err(FeaturePreviouslyDeclared {\n                     span,\n-                    &format!(\n-                        \"feature `{}` is declared {}, but was previously declared {}\",\n-                        feature,\n-                        if since.is_some() { \"stable\" } else { \"unstable\" },\n-                        if since.is_none() { \"stable\" } else { \"unstable\" },\n-                    ),\n-                );\n+                    feature,\n+                    declared,\n+                    prev_declared,\n+                });\n             }\n         }\n     }\n-\n-    fn span_feature_error(&self, span: Span, msg: &str) {\n-        struct_span_err!(self.tcx.sess, span, E0711, \"{}\", &msg).emit();\n-    }\n }\n \n impl<'tcx> Visitor<'tcx> for LibFeatureCollector<'tcx> {"}, {"sha": "077194ec687bff4da85cddbba83e80d2357543e6", "filename": "compiler/rustc_passes/src/loops.rs", "status": "modified", "additions": 45, "deletions": 116, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_passes%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_passes%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Floops.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -1,6 +1,5 @@\n use Context::*;\n \n-use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, Visitor};\n@@ -13,6 +12,11 @@ use rustc_session::Session;\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::Span;\n \n+use crate::errors::{\n+    BreakInsideAsyncBlock, BreakInsideClosure, BreakNonLoop, ContinueLabeledBlock, OutsideLoop,\n+    UnlabeledCfInWhileCondition, UnlabeledInLabeledBlock,\n+};\n+\n #[derive(Clone, Copy, Debug, PartialEq)]\n enum Context {\n     Normal,\n@@ -90,7 +94,10 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                     Ok(loop_id) => Some(loop_id),\n                     Err(hir::LoopIdError::OutsideLoopScope) => None,\n                     Err(hir::LoopIdError::UnlabeledCfInWhileCondition) => {\n-                        self.emit_unlabled_cf_in_while_condition(e.span, \"break\");\n+                        self.sess.emit_err(UnlabeledCfInWhileCondition {\n+                            span: e.span,\n+                            cf_type: \"break\",\n+                        });\n                         None\n                     }\n                     Err(hir::LoopIdError::UnresolvedLabel) => None,\n@@ -116,69 +123,22 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                     match loop_kind {\n                         None | Some(hir::LoopSource::Loop) => (),\n                         Some(kind) => {\n-                            let mut err = struct_span_err!(\n-                                self.sess,\n-                                e.span,\n-                                E0571,\n-                                \"`break` with value from a `{}` loop\",\n-                                kind.name()\n-                            );\n-                            err.span_label(\n-                                e.span,\n-                                \"can only break with a value inside `loop` or breakable block\",\n+                            let suggestion = format!(\n+                                \"break{}\",\n+                                break_label\n+                                    .label\n+                                    .map_or_else(String::new, |l| format!(\" {}\", l.ident))\n                             );\n-                            if let Some(head) = head {\n-                                err.span_label(\n-                                    head,\n-                                    &format!(\n-                                        \"you can't `break` with a value in a `{}` loop\",\n-                                        kind.name()\n-                                    ),\n-                                );\n-                            }\n-                            err.span_suggestion(\n-                                e.span,\n-                                &format!(\n-                                    \"use `break` on its own without a value inside this `{}` loop\",\n-                                    kind.name(),\n-                                ),\n-                                format!(\n-                                    \"break{}\",\n-                                    break_label\n-                                        .label\n-                                        .map_or_else(String::new, |l| format!(\" {}\", l.ident))\n-                                ),\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                            if let (Some(label), None) = (loop_label, break_label.label) {\n-                                match break_expr.kind {\n-                                    hir::ExprKind::Path(hir::QPath::Resolved(\n-                                        None,\n-                                        hir::Path {\n-                                            segments: [segment],\n-                                            res: hir::def::Res::Err,\n-                                            ..\n-                                        },\n-                                    )) if label.ident.to_string()\n-                                        == format!(\"'{}\", segment.ident) =>\n-                                    {\n-                                        // This error is redundant, we will have already emitted a\n-                                        // suggestion to use the label when `segment` wasn't found\n-                                        // (hence the `Res::Err` check).\n-                                        err.delay_as_bug();\n-                                    }\n-                                    _ => {\n-                                        err.span_suggestion(\n-                                            break_expr.span,\n-                                            \"alternatively, you might have meant to use the \\\n-                                             available loop label\",\n-                                            label.ident,\n-                                            Applicability::MaybeIncorrect,\n-                                        );\n-                                    }\n-                                }\n-                            }\n-                            err.emit();\n+                            self.sess.emit_err(BreakNonLoop {\n+                                span: e.span,\n+                                head,\n+                                kind: kind.name(),\n+                                suggestion,\n+                                loop_label,\n+                                break_label: break_label.label,\n+                                break_expr_kind: &break_expr.kind,\n+                                break_expr_span: break_expr.span,\n+                            });\n                         }\n                     }\n                 }\n@@ -191,19 +151,17 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                 match destination.target_id {\n                     Ok(loop_id) => {\n                         if let Node::Block(block) = self.hir_map.find(loop_id).unwrap() {\n-                            struct_span_err!(\n-                                self.sess,\n-                                e.span,\n-                                E0696,\n-                                \"`continue` pointing to a labeled block\"\n-                            )\n-                            .span_label(e.span, \"labeled blocks cannot be `continue`'d\")\n-                            .span_label(block.span, \"labeled block the `continue` points to\")\n-                            .emit();\n+                            self.sess.emit_err(ContinueLabeledBlock {\n+                                span: e.span,\n+                                block_span: block.span,\n+                            });\n                         }\n                     }\n                     Err(hir::LoopIdError::UnlabeledCfInWhileCondition) => {\n-                        self.emit_unlabled_cf_in_while_condition(e.span, \"continue\");\n+                        self.sess.emit_err(UnlabeledCfInWhileCondition {\n+                            span: e.span,\n+                            cf_type: \"continue\",\n+                        });\n                     }\n                     Err(_) => {}\n                 }\n@@ -226,21 +184,16 @@ impl<'a, 'hir> CheckLoopVisitor<'a, 'hir> {\n     }\n \n     fn require_break_cx(&self, name: &str, span: Span) {\n-        let err_inside_of = |article, ty, closure_span| {\n-            struct_span_err!(self.sess, span, E0267, \"`{}` inside of {} {}\", name, article, ty)\n-                .span_label(span, format!(\"cannot `{}` inside of {} {}\", name, article, ty))\n-                .span_label(closure_span, &format!(\"enclosing {}\", ty))\n-                .emit();\n-        };\n-\n         match self.cx {\n             LabeledBlock | Loop(_) => {}\n-            Closure(closure_span) => err_inside_of(\"a\", \"closure\", closure_span),\n-            AsyncClosure(closure_span) => err_inside_of(\"an\", \"`async` block\", closure_span),\n+            Closure(closure_span) => {\n+                self.sess.emit_err(BreakInsideClosure { span, closure_span, name });\n+            }\n+            AsyncClosure(closure_span) => {\n+                self.sess.emit_err(BreakInsideAsyncBlock { span, closure_span, name });\n+            }\n             Normal | AnonConst => {\n-                struct_span_err!(self.sess, span, E0268, \"`{}` outside of a loop\", name)\n-                    .span_label(span, format!(\"cannot `{}` outside of a loop\", name))\n-                    .emit();\n+                self.sess.emit_err(OutsideLoop { span, name });\n             }\n         }\n     }\n@@ -251,37 +204,13 @@ impl<'a, 'hir> CheckLoopVisitor<'a, 'hir> {\n         label: &Destination,\n         cf_type: &str,\n     ) -> bool {\n-        if !span.is_desugaring(DesugaringKind::QuestionMark) && self.cx == LabeledBlock {\n-            if label.label.is_none() {\n-                struct_span_err!(\n-                    self.sess,\n-                    span,\n-                    E0695,\n-                    \"unlabeled `{}` inside of a labeled block\",\n-                    cf_type\n-                )\n-                .span_label(\n-                    span,\n-                    format!(\n-                        \"`{}` statements that would diverge to or through \\\n-                                a labeled block need to bear a label\",\n-                        cf_type\n-                    ),\n-                )\n-                .emit();\n-                return true;\n-            }\n+        if !span.is_desugaring(DesugaringKind::QuestionMark)\n+            && self.cx == LabeledBlock\n+            && label.label.is_none()\n+        {\n+            self.sess.emit_err(UnlabeledInLabeledBlock { span, cf_type });\n+            return true;\n         }\n         false\n     }\n-    fn emit_unlabled_cf_in_while_condition(&mut self, span: Span, cf_type: &str) {\n-        struct_span_err!(\n-            self.sess,\n-            span,\n-            E0590,\n-            \"`break` or `continue` with no label in the condition of a `while` loop\"\n-        )\n-        .span_label(span, format!(\"unlabeled `{}` in the condition of a `while` loop\", cf_type))\n-        .emit();\n-    }\n }"}, {"sha": "acc54e7e11006885c3eee899c05fba4a44252295", "filename": "compiler/rustc_passes/src/naked_functions.rs", "status": "modified", "additions": 25, "deletions": 59, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -1,7 +1,6 @@\n //! Checks validity of naked functions.\n \n use rustc_ast::InlineAsmOptions;\n-use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::LocalDefId;\n@@ -14,6 +13,12 @@ use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_target::spec::abi::Abi;\n \n+use crate::errors::{\n+    CannotInlineNakedFunction, NakedFunctionsAsmBlock, NakedFunctionsAsmOptions,\n+    NakedFunctionsMustUseNoreturn, NakedFunctionsOperands, NoPatterns, ParamsNotAllowed,\n+    UndefinedNakedFunctionAbi,\n+};\n+\n pub(crate) fn provide(providers: &mut Providers) {\n     *providers = Providers { check_mod_naked_functions, ..*providers };\n }\n@@ -56,7 +61,7 @@ fn check_mod_naked_functions(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n fn check_inline(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     let attrs = tcx.get_attrs(def_id.to_def_id(), sym::inline);\n     for attr in attrs {\n-        tcx.sess.struct_span_err(attr.span, \"naked functions cannot be inlined\").emit();\n+        tcx.sess.emit_err(CannotInlineNakedFunction { span: attr.span });\n     }\n }\n \n@@ -65,12 +70,11 @@ fn check_abi(tcx: TyCtxt<'_>, def_id: LocalDefId, abi: Abi) {\n     if abi == Abi::Rust {\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n         let span = tcx.def_span(def_id);\n-        tcx.struct_span_lint_hir(\n+        tcx.emit_spanned_lint(\n             UNDEFINED_NAKED_FUNCTION_ABI,\n             hir_id,\n             span,\n-            \"Rust ABI is unsupported in naked functions\",\n-            |lint| lint,\n+            UndefinedNakedFunctionAbi,\n         );\n     }\n }\n@@ -82,12 +86,7 @@ fn check_no_patterns(tcx: TyCtxt<'_>, params: &[hir::Param<'_>]) {\n             hir::PatKind::Wild\n             | hir::PatKind::Binding(hir::BindingAnnotation::NONE, _, _, None) => {}\n             _ => {\n-                tcx.sess\n-                    .struct_span_err(\n-                        param.pat.span,\n-                        \"patterns not allowed in naked function parameters\",\n-                    )\n-                    .emit();\n+                tcx.sess.emit_err(NoPatterns { span: param.pat.span });\n             }\n         }\n     }\n@@ -117,14 +116,7 @@ impl<'tcx> Visitor<'tcx> for CheckParameters<'tcx> {\n         )) = expr.kind\n         {\n             if self.params.contains(var_hir_id) {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(\n-                        expr.span,\n-                        \"referencing function parameters is not allowed in naked functions\",\n-                    )\n-                    .help(\"follow the calling convention in asm block to use parameters\")\n-                    .emit();\n+                self.tcx.sess.emit_err(ParamsNotAllowed { span: expr.span });\n                 return;\n             }\n         }\n@@ -139,26 +131,21 @@ fn check_asm<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId, body: &'tcx hir::Body<\n     if let [(ItemKind::Asm | ItemKind::Err, _)] = this.items[..] {\n         // Ok.\n     } else {\n-        let mut diag = struct_span_err!(\n-            tcx.sess,\n-            tcx.def_span(def_id),\n-            E0787,\n-            \"naked functions must contain a single asm block\"\n-        );\n-\n         let mut must_show_error = false;\n         let mut has_asm = false;\n         let mut has_err = false;\n+        let mut multiple_asms = vec![];\n+        let mut non_asms = vec![];\n         for &(kind, span) in &this.items {\n             match kind {\n                 ItemKind::Asm if has_asm => {\n                     must_show_error = true;\n-                    diag.span_label(span, \"multiple asm blocks are unsupported in naked functions\");\n+                    multiple_asms.push(span);\n                 }\n                 ItemKind::Asm => has_asm = true,\n                 ItemKind::NonAsm => {\n                     must_show_error = true;\n-                    diag.span_label(span, \"non-asm is unsupported in naked functions\");\n+                    non_asms.push(span);\n                 }\n                 ItemKind::Err => has_err = true,\n             }\n@@ -168,9 +155,11 @@ fn check_asm<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId, body: &'tcx hir::Body<\n         // errors, then don't show an additional error. This allows for appending/prepending\n         // `compile_error!(\"...\")` statements and reduces error noise.\n         if must_show_error || !has_err {\n-            diag.emit();\n-        } else {\n-            diag.cancel();\n+            tcx.sess.emit_err(NakedFunctionsAsmBlock {\n+                span: tcx.def_span(def_id),\n+                multiple_asms,\n+                non_asms,\n+            });\n         }\n     }\n }\n@@ -251,13 +240,7 @@ impl<'tcx> CheckInlineAssembly<'tcx> {\n             })\n             .collect();\n         if !unsupported_operands.is_empty() {\n-            struct_span_err!(\n-                self.tcx.sess,\n-                unsupported_operands,\n-                E0787,\n-                \"only `const` and `sym` operands are supported in naked functions\",\n-            )\n-            .emit();\n+            self.tcx.sess.emit_err(NakedFunctionsOperands { unsupported_operands });\n         }\n \n         let unsupported_options: Vec<&'static str> = [\n@@ -273,14 +256,10 @@ impl<'tcx> CheckInlineAssembly<'tcx> {\n         .collect();\n \n         if !unsupported_options.is_empty() {\n-            struct_span_err!(\n-                self.tcx.sess,\n+            self.tcx.sess.emit_err(NakedFunctionsAsmOptions {\n                 span,\n-                E0787,\n-                \"asm options unsupported in naked functions: {}\",\n-                unsupported_options.join(\", \")\n-            )\n-            .emit();\n+                unsupported_options: unsupported_options.join(\", \"),\n+            });\n         }\n \n         if !asm.options.contains(InlineAsmOptions::NORETURN) {\n@@ -290,20 +269,7 @@ impl<'tcx> CheckInlineAssembly<'tcx> {\n                 .map_or_else(|| asm.template_strs.last().unwrap().2, |op| op.1)\n                 .shrink_to_hi();\n \n-            struct_span_err!(\n-                self.tcx.sess,\n-                span,\n-                E0787,\n-                \"asm in naked functions must use `noreturn` option\"\n-            )\n-            .span_suggestion(\n-                last_span,\n-                \"consider specifying that the asm block is responsible \\\n-                for returning from the function\",\n-                \", options(noreturn)\",\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+            self.tcx.sess.emit_err(NakedFunctionsMustUseNoreturn { span, last_span });\n         }\n     }\n }"}, {"sha": "cfd6acd8d7cd0b404310d043e6838cc3768f2ffa", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 46, "deletions": 84, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -1,13 +1,18 @@\n //! A pass that annotates every item and method with its stability level,\n //! propagating default levels lexically from parent to children ast nodes.\n \n-use crate::errors;\n+use crate::errors::{\n+    self, CannotStabilizeDeprecated, DeprecatedAttribute, DuplicateFeatureErr,\n+    FeatureOnlyOnNightly, ImpliedFeatureNotExist, InvalidDeprecationVersion, InvalidStability,\n+    MissingConstErr, MissingConstStabAttr, MissingStabilityAttr, TraitImplConstStable,\n+    UnknownFeature, UselessStability,\n+};\n use rustc_attr::{\n     self as attr, rust_version_symbol, ConstStability, Stability, StabilityLevel, Unstable,\n     UnstableReason, VERSION_PLACEHOLDER,\n };\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n-use rustc_errors::{struct_span_err, Applicability};\n+use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n@@ -20,7 +25,6 @@ use rustc_middle::middle::stability::{AllowUnstable, DeprecationEntry, Index};\n use rustc_middle::ty::{query::Providers, TyCtxt};\n use rustc_session::lint;\n use rustc_session::lint::builtin::{INEFFECTIVE_UNSTABLE_TRAIT_IMPL, USELESS_DEPRECATED};\n-use rustc_session::Session;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n use rustc_target::spec::abi::Abi;\n@@ -179,7 +183,9 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n                 if !self.in_trait_impl\n                     || (self.in_trait_impl && !self.tcx.is_const_fn_raw(def_id.to_def_id()))\n                 {\n-                    missing_const_err(&self.tcx.sess, fn_sig.span, const_span);\n+                    self.tcx\n+                        .sess\n+                        .emit_err(MissingConstErr { fn_sig_span: fn_sig.span, const_span });\n                 }\n             }\n         }\n@@ -197,14 +203,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n \n         if let Some((rustc_attr::Deprecation { is_since_rustc_version: true, .. }, span)) = &depr {\n             if stab.is_none() {\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    *span,\n-                    E0549,\n-                    \"deprecated attribute must be paired with \\\n-                    either stable or unstable attribute\"\n-                )\n-                .emit();\n+                self.tcx.sess.emit_err(DeprecatedAttribute { span: *span });\n             }\n         }\n \n@@ -220,10 +219,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             if kind == AnnotationKind::Prohibited\n                 || (kind == AnnotationKind::Container && stab.level.is_stable() && is_deprecated)\n             {\n-                self.tcx.sess.struct_span_err(span,\"this stability annotation is useless\")\n-                    .span_label(span, \"useless stability annotation\")\n-                    .span_label(item_sp, \"the stability attribute annotates this item\")\n-                    .emit();\n+                self.tcx.sess.emit_err(UselessStability { span, item_sp });\n             }\n \n             debug!(\"annotate: found {:?}\", stab);\n@@ -239,30 +235,25 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n                 {\n                     match stab_v.parse::<u64>() {\n                         Err(_) => {\n-                            self.tcx.sess.struct_span_err(span, \"invalid stability version found\")\n-                                .span_label(span, \"invalid stability version\")\n-                                .span_label(item_sp, \"the stability attribute annotates this item\")\n-                                .emit();\n+                            self.tcx.sess.emit_err(InvalidStability { span, item_sp });\n                             break;\n                         }\n                         Ok(stab_vp) => match dep_v.parse::<u64>() {\n                             Ok(dep_vp) => match dep_vp.cmp(&stab_vp) {\n                                 Ordering::Less => {\n-                                    self.tcx.sess.struct_span_err(span, \"an API can't be stabilized after it is deprecated\")\n-                                        .span_label(span, \"invalid version\")\n-                                        .span_label(item_sp, \"the stability attribute annotates this item\")\n-                                        .emit();\n+                                    self.tcx\n+                                        .sess\n+                                        .emit_err(CannotStabilizeDeprecated { span, item_sp });\n                                     break;\n                                 }\n                                 Ordering::Equal => continue,\n                                 Ordering::Greater => break,\n                             },\n                             Err(_) => {\n                                 if dep_v != \"TBD\" {\n-                                    self.tcx.sess.struct_span_err(span, \"invalid deprecation version found\")\n-                                        .span_label(span, \"invalid deprecation version\")\n-                                        .span_label(item_sp, \"the stability attribute annotates this item\")\n-                                        .emit();\n+                                    self.tcx\n+                                        .sess\n+                                        .emit_err(InvalidDeprecationVersion { span, item_sp });\n                                 }\n                                 break;\n                             }\n@@ -271,7 +262,9 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n                 }\n             }\n \n-            if let Stability { level: Unstable { implied_by: Some(implied_by), .. }, feature } = stab {\n+            if let Stability { level: Unstable { implied_by: Some(implied_by), .. }, feature } =\n+                stab\n+            {\n                 self.index.implications.insert(implied_by, feature);\n             }\n \n@@ -531,7 +524,7 @@ impl<'tcx> MissingStabilityAnnotations<'tcx> {\n         let stab = self.tcx.stability().local_stability(def_id);\n         if !self.tcx.sess.opts.test && stab.is_none() && self.access_levels.is_reachable(def_id) {\n             let descr = self.tcx.def_kind(def_id).descr(def_id.to_def_id());\n-            self.tcx.sess.span_err(span, &format!(\"{} has missing stability attribute\", descr));\n+            self.tcx.sess.emit_err(MissingStabilityAttr { span, descr });\n         }\n     }\n \n@@ -551,7 +544,7 @@ impl<'tcx> MissingStabilityAnnotations<'tcx> {\n \n         if is_const && is_stable && missing_const_stability_attribute && is_reachable {\n             let descr = self.tcx.def_kind(def_id).descr(def_id.to_def_id());\n-            self.tcx.sess.span_err(span, &format!(\"{descr} has missing const stability attribute\"));\n+            self.tcx.sess.emit_err(MissingConstStabAttr { span, descr });\n         }\n     }\n }\n@@ -764,11 +757,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'tcx> {\n                         && *constness == hir::Constness::Const\n                         && const_stab.map_or(false, |(stab, _)| stab.is_const_stable())\n                     {\n-                        self.tcx\n-                            .sess\n-                            .struct_span_err(item.span, \"trait implementations cannot be const stable yet\")\n-                            .note(\"see issue #67792 <https://github.com/rust-lang/rust/issues/67792> for more information\")\n-                            .emit();\n+                        self.tcx.sess.emit_err(TraitImplConstStable { span: item.span });\n                     }\n                 }\n \n@@ -929,26 +918,22 @@ pub fn check_unused_or_stable_features(tcx: TyCtxt<'_>) {\n         }\n         if !lang_features.insert(feature) {\n             // Warn if the user enables a lang feature multiple times.\n-            duplicate_feature_err(tcx.sess, span, feature);\n+            tcx.sess.emit_err(DuplicateFeatureErr { span, feature });\n         }\n     }\n \n     let declared_lib_features = &tcx.features().declared_lib_features;\n     let mut remaining_lib_features = FxIndexMap::default();\n     for (feature, span) in declared_lib_features {\n         if !tcx.sess.opts.unstable_features.is_nightly_build() {\n-            struct_span_err!(\n-                tcx.sess,\n-                *span,\n-                E0554,\n-                \"`#![feature]` may not be used on the {} release channel\",\n-                env!(\"CFG_RELEASE_CHANNEL\")\n-            )\n-            .emit();\n+            tcx.sess.emit_err(FeatureOnlyOnNightly {\n+                span: *span,\n+                release_channel: env!(\"CFG_RELEASE_CHANNEL\"),\n+            });\n         }\n         if remaining_lib_features.contains_key(&feature) {\n             // Warn if the user enables a lib feature multiple times.\n-            duplicate_feature_err(tcx.sess, *span, *feature);\n+            tcx.sess.emit_err(DuplicateFeatureErr { span: *span, feature: *feature });\n         }\n         remaining_lib_features.insert(feature, *span);\n     }\n@@ -1049,23 +1034,18 @@ pub fn check_unused_or_stable_features(tcx: TyCtxt<'_>) {\n     }\n \n     for (feature, span) in remaining_lib_features {\n-        struct_span_err!(tcx.sess, span, E0635, \"unknown feature `{}`\", feature).emit();\n+        tcx.sess.emit_err(UnknownFeature { span, feature: *feature });\n     }\n \n     for (implied_by, feature) in remaining_implications {\n         let local_defined_features = tcx.lib_features(());\n-        let span = local_defined_features\n+        let span = *local_defined_features\n             .stable\n             .get(&feature)\n             .map(|(_, span)| span)\n             .or_else(|| local_defined_features.unstable.get(&feature))\n             .expect(\"feature that implied another does not exist\");\n-        tcx.sess\n-            .struct_span_err(\n-                *span,\n-                format!(\"feature `{implied_by}` implying `{feature}` does not exist\"),\n-            )\n-            .emit();\n+        tcx.sess.emit_err(ImpliedFeatureNotExist { span, feature, implied_by });\n     }\n \n     // FIXME(#44232): the `used_features` table no longer exists, so we\n@@ -1088,21 +1068,20 @@ fn unnecessary_partially_stable_feature_lint(\n              by the feature `{implies}`\"\n         ),\n         |lint| {\n-            lint\n-        .span_suggestion(\n-            span,\n-            &format!(\n+            lint.span_suggestion(\n+                span,\n+                &format!(\n                 \"if you are using features which are still unstable, change to using `{implies}`\"\n             ),\n-            implies,\n-            Applicability::MaybeIncorrect,\n-        )\n-        .span_suggestion(\n-            tcx.sess.source_map().span_extend_to_line(span),\n-            \"if you are using features which are now stable, remove this line\",\n-            \"\",\n-            Applicability::MaybeIncorrect,\n-        )\n+                implies,\n+                Applicability::MaybeIncorrect,\n+            )\n+            .span_suggestion(\n+                tcx.sess.source_map().span_extend_to_line(span),\n+                \"if you are using features which are now stable, remove this line\",\n+                \"\",\n+                Applicability::MaybeIncorrect,\n+            )\n         },\n     );\n }\n@@ -1120,20 +1099,3 @@ fn unnecessary_stable_feature_lint(\n         lint\n     });\n }\n-\n-fn duplicate_feature_err(sess: &Session, span: Span, feature: Symbol) {\n-    struct_span_err!(sess, span, E0636, \"the feature `{}` has already been declared\", feature)\n-        .emit();\n-}\n-\n-fn missing_const_err(session: &Session, fn_sig_span: Span, const_span: Span) {\n-    const ERROR_MSG: &'static str = \"attributes `#[rustc_const_unstable]` \\\n-         and `#[rustc_const_stable]` require \\\n-         the function or method to be `const`\";\n-\n-    session\n-        .struct_span_err(fn_sig_span, ERROR_MSG)\n-        .span_help(fn_sig_span, \"make the function or method const\")\n-        .span_label(const_span, \"attribute specified here\")\n-        .emit();\n-}"}, {"sha": "92024989a75e250b07226a86da559ec97602ce3c", "filename": "compiler/rustc_passes/src/weak_lang_items.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -1,13 +1,17 @@\n //! Validity checking for weak lang items\n \n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::struct_span_err;\n use rustc_hir::lang_items::{self, LangItem};\n use rustc_hir::weak_lang_items::WEAK_ITEMS_REFS;\n use rustc_middle::middle::lang_items::required;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::CrateType;\n \n+use crate::errors::{\n+    AllocFuncRequired, MissingAllocErrorHandler, MissingLangItem, MissingPanicHandler,\n+    UnknownExternLangItem,\n+};\n+\n /// Checks the crate for usage of weak lang items, returning a vector of all the\n /// language items required by this crate, but not defined yet.\n pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx>, items: &mut lang_items::LanguageItems) {\n@@ -31,14 +35,7 @@ pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx>, items: &mut lang_items::LanguageItem\n                 }\n             } else {\n                 let span = tcx.def_span(id.def_id);\n-                struct_span_err!(\n-                    tcx.sess,\n-                    span,\n-                    E0264,\n-                    \"unknown external lang item: `{}`\",\n-                    lang_item\n-                )\n-                .emit();\n+                tcx.sess.emit_err(UnknownExternLangItem { span, lang_item });\n             }\n         }\n     }\n@@ -71,20 +68,14 @@ fn verify<'tcx>(tcx: TyCtxt<'tcx>, items: &lang_items::LanguageItems) {\n     for (name, &item) in WEAK_ITEMS_REFS.iter() {\n         if missing.contains(&item) && required(tcx, item) && items.require(item).is_err() {\n             if item == LangItem::PanicImpl {\n-                tcx.sess.err(\"`#[panic_handler]` function required, but not found\");\n+                tcx.sess.emit_err(MissingPanicHandler);\n             } else if item == LangItem::Oom {\n                 if !tcx.features().default_alloc_error_handler {\n-                    tcx.sess.err(\"`#[alloc_error_handler]` function required, but not found\");\n-                    tcx.sess.note_without_error(\"use `#![feature(default_alloc_error_handler)]` for a default error handler\");\n+                    tcx.sess.emit_err(AllocFuncRequired);\n+                    tcx.sess.emit_note(MissingAllocErrorHandler);\n                 }\n             } else {\n-                tcx\n-                    .sess\n-                    .diagnostic()\n-                    .struct_err(&format!(\"language item required, but not found: `{}`\", name))\n-                    .note(&format!(\"this can occur when a binary crate with `#![no_std]` is compiled for a target where `{}` is defined in the standard library\", name))\n-                    .help(&format!(\"you may be able to compile for a target that doesn't need `{}`, specify a target with `--target` or in `.cargo/config`\", name))\n-                    .emit();\n+                tcx.sess.emit_err(MissingLangItem { name: *name });\n             }\n         }\n     }"}, {"sha": "c4644d4f076e2ee3eded9b9a7d8febda3b703835", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 33, "deletions": 35, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -139,8 +139,7 @@ impl<'a> Resolver<'a> {\n                     &candidates,\n                     if instead { Instead::Yes } else { Instead::No },\n                     found_use,\n-                    IsPattern::No,\n-                    IsImport::No,\n+                    DiagnosticMode::Normal,\n                     path,\n                 );\n                 err.emit();\n@@ -699,8 +698,7 @@ impl<'a> Resolver<'a> {\n                         &import_suggestions,\n                         Instead::No,\n                         FoundUse::Yes,\n-                        IsPattern::Yes,\n-                        IsImport::No,\n+                        DiagnosticMode::Pattern,\n                         vec![],\n                     );\n                 }\n@@ -1496,8 +1494,7 @@ impl<'a> Resolver<'a> {\n             &import_suggestions,\n             Instead::No,\n             FoundUse::Yes,\n-            IsPattern::No,\n-            IsImport::No,\n+            DiagnosticMode::Normal,\n             vec![],\n         );\n \n@@ -2458,18 +2455,13 @@ enum FoundUse {\n     No,\n }\n \n-/// Whether a binding is part of a pattern or an expression. Used for diagnostics.\n-enum IsPattern {\n+/// Whether a binding is part of a pattern or a use statement. Used for diagnostics.\n+enum DiagnosticMode {\n+    Normal,\n     /// The binding is part of a pattern\n-    Yes,\n-    /// The binding is part of an expression\n-    No,\n-}\n-\n-/// Whether a binding is part of a use statement. Used for diagnostics.\n-enum IsImport {\n-    Yes,\n-    No,\n+    Pattern,\n+    /// The binding is part of a use statement\n+    Import,\n }\n \n pub(crate) fn import_candidates(\n@@ -2488,8 +2480,7 @@ pub(crate) fn import_candidates(\n         candidates,\n         Instead::Yes,\n         FoundUse::Yes,\n-        IsPattern::No,\n-        IsImport::Yes,\n+        DiagnosticMode::Import,\n         vec![],\n     );\n }\n@@ -2506,8 +2497,7 @@ fn show_candidates(\n     candidates: &[ImportSuggestion],\n     instead: Instead,\n     found_use: FoundUse,\n-    is_pattern: IsPattern,\n-    is_import: IsImport,\n+    mode: DiagnosticMode,\n     path: Vec<Segment>,\n ) {\n     if candidates.is_empty() {\n@@ -2542,7 +2532,7 @@ fn show_candidates(\n         };\n \n         let instead = if let Instead::Yes = instead { \" instead\" } else { \"\" };\n-        let mut msg = if let IsPattern::Yes = is_pattern {\n+        let mut msg = if let DiagnosticMode::Pattern = mode {\n             format!(\n                 \"if you meant to match on {}{}{}, use the full path in the pattern\",\n                 kind, instead, name\n@@ -2555,19 +2545,24 @@ fn show_candidates(\n             err.note(note);\n         }\n \n-        if let (IsPattern::Yes, Some(span)) = (is_pattern, use_placement_span) {\n-            err.span_suggestions(\n-                span,\n-                &msg,\n-                accessible_path_strings.into_iter().map(|a| a.0),\n-                Applicability::MaybeIncorrect,\n-            );\n-        } else if let Some(span) = use_placement_span {\n+        if let Some(span) = use_placement_span {\n+            let add_use = match mode {\n+                DiagnosticMode::Pattern => {\n+                    err.span_suggestions(\n+                        span,\n+                        &msg,\n+                        accessible_path_strings.into_iter().map(|a| a.0),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                    return;\n+                }\n+                DiagnosticMode::Import => \"\",\n+                DiagnosticMode::Normal => \"use \",\n+            };\n             for candidate in &mut accessible_path_strings {\n                 // produce an additional newline to separate the new use statement\n                 // from the directly following item.\n                 let additional_newline = if let FoundUse::Yes = found_use { \"\" } else { \"\\n\" };\n-                let add_use = if let IsImport::Yes = is_import { \"\" } else { \"use \" };\n                 candidate.0 = format!(\"{}{};\\n{}\", add_use, &candidate.0, additional_newline);\n             }\n \n@@ -2598,19 +2593,22 @@ fn show_candidates(\n \n             err.note(&msg);\n         }\n-    } else if matches!(is_import, IsImport::No) {\n+    } else if !matches!(mode, DiagnosticMode::Import) {\n         assert!(!inaccessible_path_strings.is_empty());\n \n-        let prefix =\n-            if let IsPattern::Yes = is_pattern { \"you might have meant to match on \" } else { \"\" };\n+        let prefix = if let DiagnosticMode::Pattern = mode {\n+            \"you might have meant to match on \"\n+        } else {\n+            \"\"\n+        };\n         if inaccessible_path_strings.len() == 1 {\n             let (name, descr, def_id, note) = &inaccessible_path_strings[0];\n             let msg = format!(\n                 \"{}{} `{}`{} exists but is inaccessible\",\n                 prefix,\n                 descr,\n                 name,\n-                if let IsPattern::Yes = is_pattern { \", which\" } else { \"\" }\n+                if let DiagnosticMode::Pattern = mode { \", which\" } else { \"\" }\n             );\n \n             if let Some(local_def_id) = def_id.and_then(|did| did.as_local()) {"}, {"sha": "a199947ebed05c1791a2a7e237442898795d7323", "filename": "compiler/rustc_session/src/parse.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fparse.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -12,7 +12,7 @@ use rustc_data_structures::sync::{Lock, Lrc};\n use rustc_errors::{emitter::SilentEmitter, ColorConfig, Handler};\n use rustc_errors::{\n     fallback_fluent_bundle, Diagnostic, DiagnosticBuilder, DiagnosticId, DiagnosticMessage,\n-    EmissionGuarantee, ErrorGuaranteed, IntoDiagnostic, MultiSpan, StashKey,\n+    EmissionGuarantee, ErrorGuaranteed, IntoDiagnostic, MultiSpan, Noted, StashKey,\n };\n use rustc_feature::{find_feature_issue, GateIssue, UnstableFeatures};\n use rustc_span::edition::Edition;\n@@ -354,6 +354,17 @@ impl ParseSess {\n         self.create_warning(warning).emit()\n     }\n \n+    pub fn create_note<'a>(\n+        &'a self,\n+        note: impl IntoDiagnostic<'a, Noted>,\n+    ) -> DiagnosticBuilder<'a, Noted> {\n+        note.into_diagnostic(&self.span_diagnostic)\n+    }\n+\n+    pub fn emit_note<'a>(&'a self, note: impl IntoDiagnostic<'a, Noted>) -> Noted {\n+        self.create_note(note).emit()\n+    }\n+\n     pub fn create_fatal<'a>(\n         &'a self,\n         fatal: impl IntoDiagnostic<'a, !>,"}, {"sha": "beb22ab3eb951a69e187126902eb6b33791689bf", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -28,7 +28,7 @@ use rustc_errors::json::JsonEmitter;\n use rustc_errors::registry::Registry;\n use rustc_errors::{\n     error_code, fallback_fluent_bundle, DiagnosticBuilder, DiagnosticId, DiagnosticMessage,\n-    ErrorGuaranteed, FluentBundle, IntoDiagnostic, LazyFallbackBundle, MultiSpan,\n+    ErrorGuaranteed, FluentBundle, IntoDiagnostic, LazyFallbackBundle, MultiSpan, Noted,\n };\n use rustc_macros::HashStable_Generic;\n pub use rustc_span::def_id::StableCrateId;\n@@ -489,6 +489,15 @@ impl Session {\n     pub fn emit_warning<'a>(&'a self, warning: impl IntoDiagnostic<'a, ()>) {\n         self.parse_sess.emit_warning(warning)\n     }\n+    pub fn create_note<'a>(\n+        &'a self,\n+        note: impl IntoDiagnostic<'a, Noted>,\n+    ) -> DiagnosticBuilder<'a, Noted> {\n+        self.parse_sess.create_note(note)\n+    }\n+    pub fn emit_note<'a>(&'a self, note: impl IntoDiagnostic<'a, Noted>) -> Noted {\n+        self.parse_sess.emit_note(note)\n+    }\n     pub fn create_fatal<'a>(\n         &'a self,\n         fatal: impl IntoDiagnostic<'a, !>,"}, {"sha": "cd9d229640571e08a65902f690fe860aab67ea0f", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -85,9 +85,13 @@ fn impl_defaultness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::Defaultness {\n ///     - a type parameter or projection whose Sizedness can't be known\n ///     - a tuple of type parameters or projections, if there are multiple\n ///       such.\n-///     - an Error, if a type contained itself. The representability\n-///       check should catch this case.\n-fn adt_sized_constraint(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AdtSizedConstraint<'_> {\n+///     - an Error, if a type is infinitely sized\n+fn adt_sized_constraint(tcx: TyCtxt<'_>, def_id: DefId) -> &[Ty<'_>] {\n+    if let Some(def_id) = def_id.as_local() {\n+        if matches!(tcx.representability(def_id), ty::Representability::Infinite) {\n+            return tcx.intern_type_list(&[tcx.ty_error()]);\n+        }\n+    }\n     let def = tcx.adt_def(def_id);\n \n     let result = tcx.mk_type_list(\n@@ -99,7 +103,7 @@ fn adt_sized_constraint(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AdtSizedConstrain\n \n     debug!(\"adt_sized_constraint: {:?} => {:?}\", def, result);\n \n-    ty::AdtSizedConstraint(result)\n+    result\n }\n \n /// See `ParamEnv` struct definition for details."}, {"sha": "ff3b7bc2c90474c072f082ab6087ede3f5d4d652", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 8, "deletions": 43, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -2279,9 +2279,8 @@ macro_rules! int_impl {\n         ///\n         /// # Panics\n         ///\n-        /// When the number is negative, zero, or if the base is not at least 2; it\n-        /// panics in debug mode and the return value is 0 in release\n-        /// mode.\n+        /// This function will panic if `self` is less than or equal to zero,\n+        /// or if `base` is less then 2.\n         ///\n         /// # Examples\n         ///\n@@ -2294,27 +2293,16 @@ macro_rules! int_impl {\n                       without modifying the original\"]\n         #[inline]\n         #[track_caller]\n-        #[rustc_inherit_overflow_checks]\n-        #[allow(arithmetic_overflow)]\n         pub const fn ilog(self, base: Self) -> u32 {\n-            match self.checked_ilog(base) {\n-                Some(n) => n,\n-                None => {\n-                    // In debug builds, trigger a panic on None.\n-                    // This should optimize completely out in release builds.\n-                    let _ = Self::MAX + 1;\n-\n-                    0\n-                },\n-            }\n+            assert!(base >= 2, \"base of integer logarithm must be at least 2\");\n+            self.checked_ilog(base).expect(\"argument of integer logarithm must be positive\")\n         }\n \n         /// Returns the base 2 logarithm of the number, rounded down.\n         ///\n         /// # Panics\n         ///\n-        /// When the number is negative or zero it panics in debug mode and the return value\n-        /// is 0 in release mode.\n+        /// This function will panic if `self` is less than or equal to zero.\n         ///\n         /// # Examples\n         ///\n@@ -2327,27 +2315,15 @@ macro_rules! int_impl {\n                       without modifying the original\"]\n         #[inline]\n         #[track_caller]\n-        #[rustc_inherit_overflow_checks]\n-        #[allow(arithmetic_overflow)]\n         pub const fn ilog2(self) -> u32 {\n-            match self.checked_ilog2() {\n-                Some(n) => n,\n-                None => {\n-                    // In debug builds, trigger a panic on None.\n-                    // This should optimize completely out in release builds.\n-                    let _ = Self::MAX + 1;\n-\n-                    0\n-                },\n-            }\n+            self.checked_ilog2().expect(\"argument of integer logarithm must be positive\")\n         }\n \n         /// Returns the base 10 logarithm of the number, rounded down.\n         ///\n         /// # Panics\n         ///\n-        /// When the number is negative or zero it panics in debug mode and the return value\n-        /// is 0 in release mode.\n+        /// This function will panic if `self` is less than or equal to zero.\n         ///\n         /// # Example\n         ///\n@@ -2360,19 +2336,8 @@ macro_rules! int_impl {\n                       without modifying the original\"]\n         #[inline]\n         #[track_caller]\n-        #[rustc_inherit_overflow_checks]\n-        #[allow(arithmetic_overflow)]\n         pub const fn ilog10(self) -> u32 {\n-            match self.checked_ilog10() {\n-                Some(n) => n,\n-                None => {\n-                    // In debug builds, trigger a panic on None.\n-                    // This should optimize completely out in release builds.\n-                    let _ = Self::MAX + 1;\n-\n-                    0\n-                },\n-            }\n+            self.checked_ilog10().expect(\"argument of integer logarithm must be positive\")\n         }\n \n         /// Returns the logarithm of the number with respect to an arbitrary base,"}, {"sha": "d921ff9ba102655d40970332f39347d819d7cc12", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 7, "deletions": 42, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -692,8 +692,7 @@ macro_rules! uint_impl {\n         ///\n         /// # Panics\n         ///\n-        /// When the number is zero, or if the base is not at least 2;\n-        /// it panics in debug mode and the return value is 0 in release mode.\n+        /// This function will panic if `self` is zero, or if `base` is less then 2.\n         ///\n         /// # Examples\n         ///\n@@ -706,27 +705,16 @@ macro_rules! uint_impl {\n                       without modifying the original\"]\n         #[inline]\n         #[track_caller]\n-        #[rustc_inherit_overflow_checks]\n-        #[allow(arithmetic_overflow)]\n         pub const fn ilog(self, base: Self) -> u32 {\n-            match self.checked_ilog(base) {\n-                Some(n) => n,\n-                None => {\n-                    // In debug builds, trigger a panic on None.\n-                    // This should optimize completely out in release builds.\n-                    let _ = Self::MAX + 1;\n-\n-                    0\n-                },\n-            }\n+            assert!(base >= 2, \"base of integer logarithm must be at least 2\");\n+            self.checked_ilog(base).expect(\"argument of integer logarithm must be positive\")\n         }\n \n         /// Returns the base 2 logarithm of the number, rounded down.\n         ///\n         /// # Panics\n         ///\n-        /// When the number is zero it panics in debug mode and\n-        /// the return value is 0 in release mode.\n+        /// This function will panic if `self` is zero.\n         ///\n         /// # Examples\n         ///\n@@ -739,27 +727,15 @@ macro_rules! uint_impl {\n                       without modifying the original\"]\n         #[inline]\n         #[track_caller]\n-        #[rustc_inherit_overflow_checks]\n-        #[allow(arithmetic_overflow)]\n         pub const fn ilog2(self) -> u32 {\n-            match self.checked_ilog2() {\n-                Some(n) => n,\n-                None => {\n-                    // In debug builds, trigger a panic on None.\n-                    // This should optimize completely out in release builds.\n-                    let _ = Self::MAX + 1;\n-\n-                    0\n-                },\n-            }\n+            self.checked_ilog2().expect(\"argument of integer logarithm must be positive\")\n         }\n \n         /// Returns the base 10 logarithm of the number, rounded down.\n         ///\n         /// # Panics\n         ///\n-        /// When the number is zero it panics in debug mode and the\n-        /// return value is 0 in release mode.\n+        /// This function will panic if `self` is zero.\n         ///\n         /// # Example\n         ///\n@@ -772,19 +748,8 @@ macro_rules! uint_impl {\n                       without modifying the original\"]\n         #[inline]\n         #[track_caller]\n-        #[rustc_inherit_overflow_checks]\n-        #[allow(arithmetic_overflow)]\n         pub const fn ilog10(self) -> u32 {\n-            match self.checked_ilog10() {\n-                Some(n) => n,\n-                None => {\n-                    // In debug builds, trigger a panic on None.\n-                    // This should optimize completely out in release builds.\n-                    let _ = Self::MAX + 1;\n-\n-                    0\n-                },\n-            }\n+            self.checked_ilog10().expect(\"argument of integer logarithm must be positive\")\n         }\n \n         /// Returns the logarithm of the number with respect to an arbitrary base,"}, {"sha": "a1edb1a51863214bf9c12feb8e745ec12d74a5bb", "filename": "library/core/tests/num/int_log.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/library%2Fcore%2Ftests%2Fnum%2Fint_log.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/library%2Fcore%2Ftests%2Fnum%2Fint_log.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fint_log.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -164,3 +164,33 @@ fn ilog10_u64() {\n fn ilog10_u128() {\n     ilog10_loop! { u128, 38 }\n }\n+\n+#[test]\n+#[should_panic(expected = \"argument of integer logarithm must be positive\")]\n+fn ilog2_of_0_panic() {\n+    let _ = 0u32.ilog2();\n+}\n+\n+#[test]\n+#[should_panic(expected = \"argument of integer logarithm must be positive\")]\n+fn ilog10_of_0_panic() {\n+    let _ = 0u32.ilog10();\n+}\n+\n+#[test]\n+#[should_panic(expected = \"argument of integer logarithm must be positive\")]\n+fn ilog3_of_0_panic() {\n+    let _ = 0u32.ilog(3);\n+}\n+\n+#[test]\n+#[should_panic(expected = \"base of integer logarithm must be at least 2\")]\n+fn ilog0_of_1_panic() {\n+    let _ = 1u32.ilog(0);\n+}\n+\n+#[test]\n+#[should_panic(expected = \"base of integer logarithm must be at least 2\")]\n+fn ilog1_of_1_panic() {\n+    let _ = 1u32.ilog(1);\n+}"}, {"sha": "4800eeda022bb7753ed60a1e051bb0393380086a", "filename": "library/std/src/io/readbuf.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/library%2Fstd%2Fsrc%2Fio%2Freadbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/library%2Fstd%2Fsrc%2Fio%2Freadbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Freadbuf.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -3,10 +3,10 @@\n #[cfg(test)]\n mod tests;\n \n-use crate::cmp;\n use crate::fmt::{self, Debug, Formatter};\n use crate::io::{Result, Write};\n use crate::mem::{self, MaybeUninit};\n+use crate::{cmp, ptr};\n \n /// A borrowed byte buffer which is incrementally filled and initialized.\n ///\n@@ -250,8 +250,11 @@ impl<'a> BorrowedCursor<'a> {\n     /// Initializes all bytes in the cursor.\n     #[inline]\n     pub fn ensure_init(&mut self) -> &mut Self {\n-        for byte in self.uninit_mut() {\n-            byte.write(0);\n+        let uninit = self.uninit_mut();\n+        // SAFETY: 0 is a valid value for MaybeUninit<u8> and the length matches the allocation\n+        // since it is comes from a slice reference.\n+        unsafe {\n+            ptr::write_bytes(uninit.as_mut_ptr(), 0, uninit.len());\n         }\n         self.buf.init = self.buf.capacity();\n "}, {"sha": "8b144f14635792cb65416c010c1bbd6a83290d35", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -704,6 +704,7 @@ impl<'a> Builder<'a> {\n                 doc::Miri,\n                 doc::EmbeddedBook,\n                 doc::EditionGuide,\n+                doc::StyleGuide,\n             ),\n             Kind::Dist => describe!(\n                 dist::Docs,"}, {"sha": "7bdd226cb692ea3695c11387f9ddc2bcf33d31d7", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -82,6 +82,7 @@ book!(\n     Reference, \"src/doc/reference\", \"reference\", submodule;\n     RustByExample, \"src/doc/rust-by-example\", \"rust-by-example\", submodule;\n     RustdocBook, \"src/doc/rustdoc\", \"rustdoc\";\n+    StyleGuide, \"src/doc/style-guide\", \"style-guide\";\n );\n \n fn open(builder: &Builder<'_>, path: impl AsRef<Path>) {"}, {"sha": "bf08960f338a3e3cee51b3f11e75864bdbff7ede", "filename": "src/doc/index.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -113,6 +113,12 @@ resources useful.\n [The Reference](reference/index.html) is not a formal spec, but is more detailed and\n comprehensive than the book.\n \n+## The Style Guide\n+\n+[The Rust Style Guide](style-guide/index.html) describes the standard formatting of Rust\n+code. Most developers use rustfmt to format their code, and rustfmt's default\n+formatting matches this style guide.\n+\n ## The Rustonomicon\n \n [The Rustonomicon](nomicon/index.html) is your guidebook to the dark arts of unsafe"}, {"sha": "056aec8cdd4f631c1e4c174891c2b1f9f8aaa812", "filename": "src/doc/style-guide/book.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Fdoc%2Fstyle-guide%2Fbook.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Fdoc%2Fstyle-guide%2Fbook.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle-guide%2Fbook.toml?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -0,0 +1,8 @@\n+[book]\n+title = \"The Rust Style Guide\"\n+author = \"The Rust Style Team\"\n+multilingual = false\n+src = \"src\"\n+\n+[output.html]\n+git-repository-url = \"https://github.com/rust-lang/rust/tree/HEAD/src/doc/style-guide/\""}, {"sha": "adb73a7eef6e00345cea87f43b2ca474e75390f8", "filename": "src/doc/style-guide/src/README.md", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Fdoc%2Fstyle-guide%2Fsrc%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Fdoc%2Fstyle-guide%2Fsrc%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle-guide%2Fsrc%2FREADME.md?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -0,0 +1,190 @@\n+# Rust Style Guide\n+\n+## Motivation - why use a formatting tool?\n+\n+Formatting code is a mostly mechanical task which takes both time and mental\n+effort. By using an automatic formatting tool, a programmer is relieved of\n+this task and can concentrate on more important things.\n+\n+Furthermore, by sticking to an established style guide (such as this one),\n+programmers don't need to formulate ad hoc style rules, nor do they need to\n+debate with other programmers what style rules should be used, saving time,\n+communication overhead, and mental energy.\n+\n+Humans comprehend information through pattern matching. By ensuring that all\n+Rust code has similar formatting, less mental effort is required to comprehend a\n+new project, lowering the barrier to entry for new developers.\n+\n+Thus, there are productivity benefits to using a formatting tool (such as\n+rustfmt), and even larger benefits by using a community-consistent formatting,\n+typically by using a formatting tool's default settings.\n+\n+\n+## Formatting conventions\n+\n+### Indentation and line width\n+\n+* Use spaces, not tabs.\n+* Each level of indentation must be four spaces (that is, all indentation\n+  outside of string literals and comments must be a multiple of four).\n+* The maximum width for a line is 100 characters.\n+* A tool should be configurable for all three of these variables.\n+\n+\n+### Blank lines\n+\n+Separate items and statements by either zero or one blank lines (i.e., one or\n+two newlines). E.g,\n+\n+```rust\n+fn foo() {\n+    let x = ...;\n+\n+    let y = ...;\n+    let z = ...;\n+}\n+\n+fn bar() {}\n+fn baz() {}\n+```\n+\n+Formatting tools should make the bounds on blank lines configurable: there\n+should be separate minimum and maximum numbers of newlines between both\n+statements and (top-level) items (i.e., four options). As described above, the\n+defaults for both statements and items should be minimum: 1, maximum: 2.\n+\n+\n+### [Module-level items](items.md)\n+### [Statements](statements.md)\n+### [Expressions](expressions.md)\n+### [Types](types.md)\n+\n+\n+### Comments\n+\n+The following guidelines for comments are recommendations only, a mechanical\n+formatter might skip formatting of comments.\n+\n+Prefer line comments (`//`) to block comments (`/* ... */`).\n+\n+When using line comments there should be a single space after the opening sigil.\n+\n+When using single-line block comments there should be a single space after the\n+opening sigil and before the closing sigil. Multi-line block comments should\n+have a newline after the opening sigil and before the closing sigil.\n+\n+Prefer to put a comment on its own line. Where a comment follows code, there\n+should be a single space before it. Where a block comment is inline, there\n+should be surrounding whitespace as if it were an identifier or keyword. There\n+should be no trailing whitespace after a comment or at the end of any line in a\n+multi-line comment. Examples:\n+\n+```rust\n+// A comment on an item.\n+struct Foo { ... }\n+\n+fn foo() {} // A comment after an item.\n+\n+pub fn foo(/* a comment before an argument */ x: T) {...}\n+```\n+\n+Comments should usually be complete sentences. Start with a capital letter, end\n+with a period (`.`). An inline block comment may be treated as a note without\n+punctuation.\n+\n+Source lines which are entirely a comment should be limited to 80 characters\n+in length (including comment sigils, but excluding indentation) or the maximum\n+width of the line (including comment sigils and indentation), whichever is\n+smaller:\n+\n+```rust\n+// This comment goes up to the ................................. 80 char margin.\n+\n+{\n+    // This comment is .............................................. 80 chars wide.\n+}\n+\n+{\n+    {\n+        {\n+            {\n+                {\n+                    {\n+                        // This comment is limited by the ......................... 100 char margin.\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+```\n+\n+#### Doc comments\n+\n+Prefer line comments (`///`) to block comments (`/** ... */`).\n+\n+Prefer outer doc comments (`///` or `/** ... */`), only use inner doc comments\n+(`//!` and `/*! ... */`) to write module-level or crate-level documentation.\n+\n+Doc comments should come before attributes.\n+\n+### Attributes\n+\n+Put each attribute on its own line, indented to the level of the item.\n+In the case of inner attributes (`#!`), indent it to the level of the inside of\n+the item. Prefer outer attributes, where possible.\n+\n+For attributes with argument lists, format like functions.\n+\n+```rust\n+#[repr(C)]\n+#[foo(foo, bar)]\n+struct CRepr {\n+    #![repr(C)]\n+    x: f32,\n+    y: f32,\n+}\n+```\n+\n+For attributes with an equal sign, there should be a single space before and\n+after the `=`, e.g., `#[foo = 42]`.\n+\n+There must only be a single `derive` attribute. Note for tool authors: if\n+combining multiple `derive` attributes into a single attribute, the ordering of\n+the derived names should be preserved. E.g., `#[derive(bar)] #[derive(foo)]\n+struct Baz;` should be formatted to `#[derive(bar, foo)] struct Baz;`.\n+\n+### *small* items\n+\n+In many places in this guide we specify that a formatter may format an item\n+differently if it is *small*, for example struct literals:\n+\n+```rust\n+// Normal formatting\n+Foo {\n+    f1: an_expression,\n+    f2: another_expression(),\n+}\n+\n+// *small* formatting\n+Foo { f1, f2 }\n+```\n+\n+We leave it to individual tools to decide on exactly what *small* means. In\n+particular, tools are free to use different definitions in different\n+circumstances.\n+\n+Some suitable heuristics are the size of the item (in characters) or the\n+complexity of an item (for example, that all components must be simple names,\n+not more complex sub-expressions). For more discussion on suitable heuristics,\n+see [this issue](https://github.com/rust-lang-nursery/fmt-rfcs/issues/47).\n+\n+Tools should give the user an option to ignore such heuristics and always use\n+the normal formatting.\n+\n+\n+## [Non-formatting conventions](advice.md)\n+\n+## [Cargo.toml conventions](cargo.md)\n+\n+## [Principles used for deciding these guidelines](principles.md)"}, {"sha": "004692fa6a22bad19ca1f9b4f36b1eff1dcbb38e", "filename": "src/doc/style-guide/src/SUMMARY.md", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Fdoc%2Fstyle-guide%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Fdoc%2Fstyle-guide%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle-guide%2Fsrc%2FSUMMARY.md?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -0,0 +1,11 @@\n+# Summary\n+\n+[Introduction](README.md)\n+\n+- [Module-level items](items.md)\n+- [Statements](statements.md)\n+- [Expressions](expressions.md)\n+- [Types](types.md)\n+- [Non-formatting conventions](advice.md)\n+- [`Cargo.toml` conventions](cargo.md)\n+- [Principles used for deciding these guidelines](principles.md)"}, {"sha": "ab4b92b0a24783fc211b25a601276d4b0943b975", "filename": "src/doc/style-guide/src/advice.md", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fadvice.md", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fadvice.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fadvice.md?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -0,0 +1,34 @@\n+# Other style advice\n+\n+## Expressions\n+\n+Prefer to use Rust's expression oriented nature where possible;\n+\n+```rust\n+// use\n+let x = if y { 1 } else { 0 };\n+// not\n+let x;\n+if y {\n+    x = 1;\n+} else {\n+    x = 0;\n+}\n+```\n+\n+## Names\n+\n+ * Types shall be `UpperCamelCase`,\n+ * Enum variants shall be `UpperCamelCase`,\n+ * Struct fields shall be `snake_case`,\n+ * Function and method names shall be `snake_case`,\n+ * Local variables shall be `snake_case`,\n+ * Macro names shall be `snake_case`,\n+ * Constants (`const`s and immutable `static`s) shall be `SCREAMING_SNAKE_CASE`.\n+ * When a name is forbidden because it is a reserved word (e.g., `crate`), use a\n+   trailing underscore to make the name legal (e.g., `crate_`), or use raw\n+   identifiers if possible.\n+\n+### Modules\n+\n+Avoid `#[path]` annotations where possible."}, {"sha": "f4993ba06a88871ffb9afebb6ea9d3e62602c480", "filename": "src/doc/style-guide/src/cargo.md", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fcargo.md", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fcargo.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fcargo.md?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -0,0 +1,78 @@\n+# Cargo.toml conventions\n+\n+## Formatting conventions\n+\n+Use the same line width and indentation as Rust code.\n+\n+Put a blank line between the last key-value pair in a section and the header of\n+the next section. Do not place a blank line between section headers and the\n+key-value pairs in that section, or between key-value pairs in a section.\n+\n+Sort key names alphabetically within each section, with the exception of the\n+`[package]` section. Put the `[package]` section at the top of the file; put\n+the `name` and `version` keys in that order at the top of that section,\n+followed by the remaining keys other than `description` in alphabetical order,\n+followed by the `description` at the end of that section.\n+\n+Don't use quotes around any standard key names; use bare keys. Only use quoted\n+keys for non-standard keys whose names require them, and avoid introducing such\n+key names when possible.  See the [TOML\n+specification](https://github.com/toml-lang/toml/blob/master/versions/en/toml-v0.4.0.md#table)\n+for details.\n+\n+Put a single space both before and after the `=` between a key and value. Do\n+not indent any key names; start all key names at the start of a line.\n+\n+Use multi-line strings (rather than newline escape sequences) for any string\n+values that include multiple lines, such as the crate description.\n+\n+For array values, such as a list of authors, put the entire list on the same\n+line as the key, if it fits. Otherwise, use block indentation: put a newline\n+after the opening square bracket, indent each item by one indentation level,\n+put a comma after each item (including the last), and put the closing square\n+bracket at the start of a line by itself after the last item.\n+\n+```rust\n+authors = [\n+    \"A Uthor <a.uthor@example.org>\",\n+    \"Another Author <author@example.net>\",\n+]\n+```\n+\n+For table values, such as a crate dependency with a path, write the entire\n+table using curly braces and commas on the same line as the key if it fits. If\n+the entire table does not fit on the same line as the key, separate it out into\n+a separate section with key-value pairs:\n+\n+```toml\n+[dependencies]\n+crate1 = { path = \"crate1\", version = \"1.2.3\" }\n+\n+[dependencies.extremely_long_crate_name_goes_here]\n+path = \"extremely_long_path_name_goes_right_here\"\n+version = \"4.5.6\"\n+```\n+\n+## Metadata conventions\n+\n+The authors list should consist of strings that each contain an author name\n+followed by an email address in angle brackets: `Full Name <email@address>`.\n+It should not contain bare email addresses, or names without email addresses.\n+(The authors list may also include a mailing list address without an associated\n+name.)\n+\n+The license field must contain a valid [SPDX\n+expression](https://spdx.org/spdx-specification-21-web-version#h.jxpfx0ykyb60),\n+using valid [SPDX license names](https://spdx.org/licenses/). (As an exception,\n+by widespread convention, the license field may use `/` in place of ` OR `; for\n+example, `MIT/Apache-2.0`.)\n+\n+The homepage field, if present, must consist of a single URL, including the\n+scheme (e.g. `https://example.org/`, not just `example.org`.)\n+\n+Within the description field, wrap text at 80 columns. Don't start the\n+description field with the name of the crate (e.g. \"cratename is a ...\"); just\n+describe the crate itself. If providing a multi-sentence description, the first\n+sentence should go on a line by itself and summarize the crate, like the\n+subject of an email or commit message; subsequent sentences can then describe\n+the crate in more detail."}, {"sha": "c7d0446dded19a58a73903854025d1ec75dce94b", "filename": "src/doc/style-guide/src/expressions.md", "status": "added", "additions": 850, "deletions": 0, "changes": 850, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fexpressions.md", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fexpressions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fexpressions.md?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -0,0 +1,850 @@\n+## Expressions\n+\n+### Blocks\n+\n+A block expression should have a newline after the initial `{` and before the\n+terminal `}`. Any qualifier before the block (e.g., `unsafe`) should always be\n+on the same line as the opening brace, and separated with a single space. The\n+contents of the block should be block indented:\n+\n+```rust\n+fn block_as_stmt() {\n+    a_call();\n+\n+    {\n+        a_call_inside_a_block();\n+\n+        // a comment in a block\n+        the_value\n+    }\n+}\n+\n+fn block_as_expr() {\n+    let foo = {\n+        a_call_inside_a_block();\n+\n+        // a comment in a block\n+        the_value\n+    };\n+}\n+\n+fn unsafe_block_as_stmt() {\n+    a_call();\n+\n+    unsafe {\n+        a_call_inside_a_block();\n+\n+        // a comment in a block\n+        the_value\n+    }\n+}\n+```\n+\n+If a block has an attribute, it should be on its own line:\n+\n+```rust\n+fn block_as_stmt() {\n+    #[an_attribute]\n+    {\n+        #![an_inner_attribute]\n+\n+        // a comment in a block\n+        the_value\n+    }\n+}\n+```\n+\n+Avoid writing comments on the same line as the braces.\n+\n+An empty block should be written as `{}`.\n+\n+A block may be written on a single line if:\n+\n+* it is either used in expression position (not statement position) or is an\n+  unsafe block in statement position\n+* contains a single-line expression and no statements\n+* contains no comments\n+\n+A single line block should have spaces after the opening brace and before the\n+closing brace.\n+\n+Examples:\n+\n+```rust\n+fn main() {\n+    // Single line\n+    let _ = { a_call() };\n+    let _ = unsafe { a_call() };\n+\n+    // Not allowed on one line\n+    // Statement position.\n+    {\n+        a_call()\n+    }\n+\n+    // Contains a statement\n+    let _ = {\n+        a_call();\n+    };\n+    unsafe {\n+        a_call();\n+    }\n+\n+    // Contains a comment\n+    let _ = {\n+        // A comment\n+    };\n+    let _ = {\n+        // A comment\n+        a_call()\n+    };\n+\n+    // Multiple lines\n+    let _ = {\n+        a_call();\n+        another_call()\n+    };\n+    let _ = {\n+        a_call(\n+            an_argument,\n+            another_arg,\n+        )\n+    };\n+}\n+```\n+\n+\n+### Closures\n+\n+Don't put any extra spaces before the first `|` (unless the closure is prefixed\n+by `move`); put a space between the second `|` and the expression of the\n+closure. Between the `|`s, you should use function definition syntax, however,\n+elide types where possible.\n+\n+Use closures without the enclosing `{}`, if possible. Add the `{}` when you have\n+a return type, when there are statements, there are comments in the body, or the\n+body expression spans multiple lines and is a control-flow expression. If using\n+braces, follow the rules above for blocks. Examples:\n+\n+```rust\n+|arg1, arg2| expr\n+\n+move |arg1: i32, arg2: i32| -> i32 {\n+    expr1;\n+    expr2\n+}\n+\n+|| Foo {\n+    field1,\n+    field2: 0,\n+}\n+\n+|| {\n+    if true {\n+        blah\n+    } else {\n+        boo\n+    }\n+}\n+\n+|x| unsafe {\n+    expr\n+}\n+```\n+\n+\n+### Struct literals\n+\n+If a struct literal is *small* it may be formatted on a single line. If not,\n+each field should be on it's own, block-indented line. There should be a\n+trailing comma in the multi-line form only. There should be a space after the\n+colon only.\n+\n+There should be a space before the opening brace. In the single-line form there\n+should be spaces after the opening brace and before the closing brace.\n+\n+```rust\n+Foo { field1, field2: 0 }\n+let f = Foo {\n+    field1,\n+    field2: an_expr,\n+};\n+```\n+\n+Functional record update syntax is treated like a field, but it must never have\n+a trailing comma. There should be no space after `..`.\n+\n+let f = Foo {\n+    field1,\n+    ..an_expr\n+};\n+\n+\n+### Tuple literals\n+\n+Use a single-line form where possible. There should not be spaces around the\n+parentheses. Where a single-line form is not possible, each element of the tuple\n+should be on its own block-indented line and there should be a trailing comma.\n+\n+```rust\n+(a, b, c)\n+\n+let x = (\n+    a_long_expr,\n+    another_very_long_expr,\n+);\n+```\n+\n+\n+### Tuple struct literals\n+\n+There should be no space between the identifier and the opening parenthesis.\n+Otherwise, follow the rules for tuple literals, e.g., `Foo(a, b)`.\n+\n+\n+### Enum literals\n+\n+Follow the formatting rules for the various struct literals. Prefer using the\n+name of the enum as a qualifying name, unless the enum is in the prelude. E.g.,\n+\n+```rust\n+Foo::Bar(a, b)\n+Foo::Baz {\n+    field1,\n+    field2: 1001,\n+}\n+Ok(an_expr)\n+```\n+\n+\n+### Array literals\n+\n+For simple array literals, avoid line breaking, no spaces around square\n+brackets, contents of the array should be separated by commas and spaces. If\n+using the repeating initialiser, there should be a space after the semicolon\n+only. Apply the same rules if using the `vec!` or similar macros (always use\n+square brackets here). Examples:\n+\n+```rust\n+fn main() {\n+    [1, 2, 3];\n+    vec![a, b, c, d];\n+    let a = [42; 10];\n+}\n+```\n+\n+If a line must be broken, prefer breaking only after the `;`, if possible.\n+Otherwise, follow the rules below for function calls. In any case, the contents\n+of the initialiser should be block indented and there should be line breaks\n+after the opening bracket and before the closing bracket:\n+\n+```rust\n+fn main() {\n+    [\n+        a_long_expression();\n+        1234567890\n+    ]\n+    let x = [\n+        an_expression,\n+        another_expression,\n+        a_third_expression,\n+    ];\n+}\n+```\n+\n+\n+### Array accesses, indexing, and slicing.\n+\n+No spaces around the square brackets, avoid breaking lines if possible, never\n+break a line between the target expression and the opening bracket. If the\n+indexing expression covers multiple lines, then it should be block indented and\n+there should be newlines after the opening brackets and before the closing\n+bracket. However, this should be avoided where possible.\n+\n+Examples:\n+\n+```rust\n+fn main() {\n+    foo[42];\n+    &foo[..10];\n+    bar[0..100];\n+    foo[4 + 5 / bar];\n+    a_long_target[\n+        a_long_indexing_expression\n+    ];\n+}\n+```\n+\n+### Unary operations\n+\n+Do not include a space between a unary op and its operand (i.e., `!x`, not\n+`! x`). However, there must be a space after `&mut`. Avoid line-breaking\n+between a unary operator and its operand.\n+\n+### Binary operations\n+\n+Do include spaces around binary ops (i.e., `x + 1`, not `x+1`) (including `=`\n+and other assignment operators such as `+=` or `*=`).\n+\n+For comparison operators, because for `T op U`, `&T op &U` is also implemented:\n+if you have `t: &T`, and `u: U`, prefer `*t op u` to `t op &u`. In general,\n+within expressions, prefer dereferencing to taking references.\n+\n+Use parentheses liberally, do not necessarily elide them due to precedence.\n+Tools should not automatically insert or remove parentheses. Do not use spaces\n+to indicate precedence.\n+\n+If line-breaking, put the operator on a new line and block indent. Put each\n+sub-expression on its own line. E.g.,\n+\n+```rust\n+foo_bar\n+    + bar\n+    + baz\n+    + qux\n+    + whatever\n+```\n+\n+Prefer line-breaking at an assignment operator (either `=` or `+=`, etc.) rather\n+than at other binary operators.\n+\n+### Control flow\n+\n+Do not include extraneous parentheses for `if` and `while` expressions.\n+\n+```rust\n+if true {\n+}\n+```\n+\n+is better than\n+\n+```rust\n+if (true) {\n+}\n+```\n+\n+Do include extraneous parentheses if it makes an arithmetic or logic expression\n+easier to understand (`(x * 15) + (y * 20)` is fine)\n+\n+### Function calls\n+\n+Do not put a space between the function name, and the opening parenthesis.\n+\n+Do not put a space between an argument, and the comma which follows.\n+\n+Do put a space between an argument, and the comma which precedes it.\n+\n+Prefer not to break a line in the callee expression.\n+\n+#### Single-line calls\n+\n+Do not put a space between the function name and open paren, between the open\n+paren and the first argument, or between the last argument and the close paren.\n+\n+Do not put a comma after the last argument.\n+\n+```rust\n+foo(x, y, z)\n+```\n+\n+#### Multi-line calls\n+\n+If the function call is not *small*, it would otherwise over-run the max width,\n+or any argument or the callee is multi-line, then the call should be formatted\n+across multiple lines. In this case, each argument should be on it's own block-\n+indented line, there should be a newline after the opening parenthesis and\n+before the closing parenthesis, and there should be a trailing comma. E.g.,\n+\n+```rust\n+a_function_call(\n+    arg1,\n+    a_nested_call(a, b),\n+)\n+```\n+\n+\n+### Method calls\n+\n+Follow the function rules for calling.\n+\n+Do not put any spaces around the `.`.\n+\n+```rust\n+x.foo().bar().baz(x, y, z);\n+```\n+\n+\n+### Macro uses\n+\n+Macros which can be parsed like other constructs should be formatted like those\n+constructs. For example, a macro use `foo!(a, b, c)` can be parsed like a\n+function call (ignoring the `!`), therefore it should be formatted following the\n+rules for function calls.\n+\n+#### Special case macros\n+\n+Macros which take a format string and where all other arguments are *small* may\n+be formatted with arguments before and after the format string on a single line\n+and the format string on its own line, rather than putting each argument on its\n+own line. For example,\n+\n+```rust\n+println!(\n+    \"Hello {} and {}\",\n+    name1, name2,\n+);\n+\n+assert_eq!(\n+    x, y,\n+    \"x and y were not equal, see {}\",\n+    reason,\n+);\n+```\n+\n+\n+### Casts (`as`)\n+\n+Put spaces before and after `as`:\n+\n+```rust\n+let cstr = \"Hi\\0\" as *const str as *const [u8] as *const std::os::raw::c_char;\n+```\n+\n+\n+### Chains of fields and method calls\n+\n+A chain is a sequence of field accesses and/or method calls. A chain may also\n+include the try operator ('?'). E.g., `a.b.c().d` or `foo?.bar().baz?`.\n+\n+Prefer formatting on one line if possible, and the chain is *small*. If\n+formatting on multiple lines, each field access or method call in the chain\n+should be on its own line with the line-break before the `.` and after any `?`.\n+Each line should be block-indented. E.g.,\n+\n+```rust\n+let foo = bar\n+    .baz?\n+    .qux();\n+```\n+\n+If the length of the last line of the first element plus its indentation is\n+less than or equal to the indentation of the second line (and there is space),\n+then combine the first and second lines, e.g.,\n+\n+```rust\n+x.baz?\n+    .qux()\n+\n+let foo = x\n+    .baz?\n+    .qux();\n+\n+foo(\n+    expr1,\n+    expr2,\n+).baz?\n+    .qux();\n+```\n+\n+#### Multi-line elements\n+\n+If any element in a chain is formatted across multiple lines, then that element\n+and any later elements must be on their own line. Earlier elements may be kept\n+on a single line. E.g.,\n+\n+```rust\n+a.b.c()?.d\n+    .foo(\n+        an_expr,\n+        another_expr,\n+    )\n+    .bar\n+    .baz\n+```\n+\n+Note there is block indent due to the chain and the function call in the above\n+example.\n+\n+Prefer formatting the whole chain in multi-line style and each element on one\n+line, rather than putting some elements on multiple lines and some on a single\n+line, e.g.,\n+\n+```rust\n+// Better\n+self.pre_comment\n+    .as_ref()\n+    .map_or(false, |comment| comment.starts_with(\"//\"))\n+\n+// Worse\n+self.pre_comment.as_ref().map_or(\n+    false,\n+    |comment| comment.starts_with(\"//\"),\n+)\n+```\n+\n+### Control flow expressions\n+\n+This section covers `if`, `if let`, `loop`, `while`, `while let`, and `for`\n+expressions.\n+\n+The keyword, any initial clauses, and the opening brace of the block should be\n+on a single line. The usual rules for [block formatting](#blocks) should be\n+applied to the block.\n+\n+If there is an `else` component, then the closing brace, `else`, any following\n+clause, and the opening brace should all be on the same line. There should be a\n+single space before and after the `else` keyword. For example:\n+\n+```rust\n+if ... {\n+    ...\n+} else {\n+    ...\n+}\n+\n+if let ... {\n+    ...\n+} else if ... {\n+    ...\n+} else {\n+    ...\n+}\n+```\n+\n+If the control line needs to be broken, then prefer to break before the `=` in\n+`* let` expressions and before `in` in a `for` expression; the following line\n+should be block indented. If the control line is broken for any reason, then the\n+opening brace should be on its own line and not indented. Examples:\n+\n+```rust\n+while let Some(foo)\n+    = a_long_expression\n+{\n+    ...\n+}\n+\n+for foo\n+    in a_long_expression\n+{\n+    ...\n+}\n+\n+if a_long_expression\n+    && another_long_expression\n+    || a_third_long_expression\n+{\n+    ...\n+}\n+```\n+\n+Where the initial clause is multi-lined and ends with one or more closing\n+parentheses, square brackets, or braces, and there is nothing else on that line,\n+and that line is not indented beyond the indent on the first line of the control\n+flow expression, then the opening brace of the block should be put on the same\n+line with a preceding space. For example:\n+\n+```rust\n+if !self.config.file_lines().intersects(\n+    &self.codemap.lookup_line_range(\n+        stmt.span,\n+    ),\n+) {  // Opening brace on same line as initial clause.\n+    ...\n+}\n+```\n+\n+\n+#### Single line `if else`\n+\n+Formatters may place an `if else` or `if let else` on a single line if it occurs\n+in expression context (i.e., is not a standalone statement), it contains a\n+single `else` clause, and is *small*. For example:\n+\n+```rust\n+let y = if x { 0 } else { 1 };\n+\n+// Examples that must be multi-line.\n+let y = if something_very_long {\n+    not_small\n+} else {\n+    also_not_small\n+};\n+\n+if x {\n+    0\n+} else {\n+    1\n+}\n+```\n+\n+\n+### Match\n+\n+Prefer not to line-break inside the discriminant expression. There must always\n+be a line break after the opening brace and before the closing brace. The match\n+arms must be block indented once:\n+\n+```rust\n+match foo {\n+    // arms\n+}\n+\n+let x = match foo.bar.baz() {\n+    // arms\n+};\n+```\n+\n+Use a trailing comma for a match arm if and only if not using a block.\n+\n+Never start a match arm pattern with `|`, e.g.,\n+\n+```rust\n+match foo {\n+    // Don't do this.\n+    | foo => bar,\n+    // Or this.\n+    | a_very_long_pattern\n+    | another_pattern\n+    | yet_another_pattern\n+    | a_forth_pattern => {\n+        ...\n+    }\n+}\n+```\n+\n+Prefer\n+\n+\n+```rust\n+match foo {\n+    foo => bar,\n+    a_very_long_pattern\n+    | another_pattern\n+    | yet_another_pattern\n+    | a_forth_pattern => {\n+        ...\n+    }\n+}\n+```\n+\n+Avoid splitting the left-hand side (before the `=>`) of a match arm where\n+possible. If the right-hand side of the match arm is kept on the same line,\n+never use a block (unless the block is empty).\n+\n+If the right-hand side consists of multiple statements or has line comments or\n+the start of the line cannot be fit on the same line as the left-hand side, use\n+a block.\n+\n+The body of a block arm should be block indented once.\n+\n+Examples:\n+\n+```rust\n+match foo {\n+    foo => bar,\n+    a_very_long_patten | another_pattern if an_expression() => {\n+        no_room_for_this_expression()\n+    }\n+    foo => {\n+        // A comment.\n+        an_expression()\n+    }\n+    foo => {\n+        let a = statement();\n+        an_expression()\n+    }\n+    bar => {}\n+    // Trailing comma on last item.\n+    foo => bar,\n+}\n+```\n+\n+If the body is a single expression with no line comments and not a control flow\n+expression, then it may be started on the same line as the right-hand side. If\n+not, then it must be in a block. Example,\n+\n+```rust\n+match foo {\n+    // A combinable expression.\n+    foo => a_function_call(another_call(\n+        argument1,\n+        argument2,\n+    )),\n+    // A non-combinable expression\n+    bar => {\n+        a_function_call(\n+            another_call(\n+                argument1,\n+                argument2,\n+            ),\n+            another_argument,\n+        )\n+    }\n+}\n+```\n+\n+#### Line-breaking\n+\n+Where it is possible to use a block form on the right-hand side and avoid\n+breaking the left-hand side, do that. E.g.\n+\n+```rust\n+    // Assuming the following line does done fit in the max width\n+    a_very_long_pattern | another_pattern => ALongStructName {\n+        ...\n+    },\n+    // Prefer this\n+    a_very_long_pattern | another_pattern => {\n+        ALongStructName {\n+            ...\n+        }\n+    }\n+    // To splitting the pattern.\n+```\n+\n+Never break after `=>` without using the block form of the body.\n+\n+If the left-hand side must be split and there is an `if` clause, break before\n+the `if` and block indent. In this case, always use a block body and start the\n+body on a new line:\n+\n+```rust\n+    a_very_long_pattern | another_pattern\n+        if expr =>\n+    {\n+        ...\n+    }\n+```\n+\n+If required to break the pattern, put each clause of the pattern on its own\n+line with no additional indent, breaking before the `|`. If there is an `if`\n+clause, then you must use the above form:\n+\n+```rust\n+    a_very_long_pattern\n+    | another_pattern\n+    | yet_another_pattern\n+    | a_forth_pattern => {\n+        ...\n+    }\n+    a_very_long_pattern\n+    | another_pattern\n+    | yet_another_pattern\n+    | a_forth_pattern\n+        if expr =>\n+    {\n+        ...\n+    }\n+```\n+\n+If the pattern is multi-line, and the last line is less wide than the indent, do\n+not put the `if` clause on a newline. E.g.,\n+\n+```rust\n+    Token::Dimension {\n+         value,\n+         ref unit,\n+         ..\n+    } if num_context.is_ok(context.parsing_mode, value) => {\n+        ...\n+    }\n+```\n+\n+If every clause in a pattern is *small*, but does not fit on one line, then the\n+pattern may be formatted across multiple lines with as many clauses per line as\n+possible. Again break before a `|`:\n+\n+```rust\n+    foo | bar | baz\n+    | qux => {\n+        ...\n+    }\n+```\n+\n+We define a pattern clause to be *small* if it matches the following grammar:\n+\n+```\n+[small, ntp]:\n+    - single token\n+    - `&[single-line, ntp]`\n+\n+[small]:\n+    - `[small, ntp]`\n+    - unary tuple constructor `([small, ntp])`\n+    - `&[small]`\n+```\n+\n+E.g., `&&Some(foo)` matches, `Foo(4, Bar)` does not.\n+\n+\n+### Combinable expressions\n+\n+Where a function call has a single argument, and that argument is formatted\n+across multiple-lines, the outer call may be formatted as if it were a single-\n+line call. The same combining behaviour may be applied to any similar\n+expressions which have multi-line, block-indented lists of sub-expressions\n+delimited by parentheses (e.g., macros or tuple struct literals). E.g.,\n+\n+```rust\n+foo(bar(\n+    an_expr,\n+    another_expr,\n+))\n+\n+let x = foo(Bar {\n+    field: whatever,\n+});\n+\n+foo(|param| {\n+    action();\n+    foo(param)\n+})\n+```\n+\n+Such behaviour should extend recursively, however, tools may choose to limit the\n+depth of nesting.\n+\n+Only where the multi-line sub-expression is a closure with an explicit block,\n+this combining behaviour may be used where there are other arguments, as long as\n+all the arguments and the first line of the closure fit on the first line, the\n+closure is the last argument, and there is only one closure argument:\n+\n+```rust\n+foo(first_arg, x, |param| {\n+    action();\n+    foo(param)\n+})\n+```\n+\n+\n+### Ranges\n+\n+Do not put spaces in ranges, e.g., `0..10`, `x..=y`, `..x.len()`, `foo..`.\n+\n+When writing a range with both upper and lower bounds, if the line must be\n+broken, break before the range operator and block indent the second line:\n+\n+```rust\n+a_long_expression\n+    ..another_long_expression\n+```\n+\n+For the sake of indicating precedence, we recommend that if either bound is a\n+compound expression, then use parentheses around it, e.g., `..(x + 1)`,\n+`(x.f)..(x.f.len())`, or `0..(x - 10)`.\n+\n+\n+### Hexadecimal literals\n+\n+Hexadecimal literals may use upper- or lower-case letters, but they must not be\n+mixed within the same literal. Projects should use the same case for all\n+literals, but we do not make a recommendation for either lower- or upper-case.\n+Tools should have an option to convert mixed case literals to upper-case, and\n+may have an option to convert all literals to either lower- or upper-case.\n+\n+\n+## Patterns\n+\n+Patterns should be formatted like their corresponding expressions. See the\n+section on `match` for additional formatting for patterns in match arms."}, {"sha": "2835975355fcaf0cbc5799981f38580fd92a369a", "filename": "src/doc/style-guide/src/items.md", "status": "added", "additions": 565, "deletions": 0, "changes": 565, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fitems.md", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fitems.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fitems.md?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -0,0 +1,565 @@\n+## Items\n+\n+`extern crate` statements must be first in a file. They must be ordered\n+alphabetically.\n+\n+`use` statements, and module *declarations* (`mod foo;`, not `mod { ... }`)\n+must come before other items. We recommend that imports come before module\n+declarations; if imports and modules are separated, then they should be ordered\n+alphabetically. When sorting, `self` and `super` must come before any other\n+names. Module declarations should not be moved if they are annotated with\n+`#[macro_use]`, since that may be semantics changing.\n+\n+Tools should make the above ordering optional.\n+\n+\n+### Function definitions\n+\n+In Rust, one finds functions by searching for `fn [function-name]`; It's\n+important that you style your code so that it's very searchable in this way.\n+\n+The proper ordering and spacing is:\n+\n+```rust\n+[pub] [unsafe] [extern [\"ABI\"]] fn foo(arg1: i32, arg2: i32) -> i32 {\n+    ...\n+}\n+```\n+\n+Avoid comments within the signature itself.\n+\n+If the function signature does not fit on one line, then break after the opening\n+parenthesis and before the closing parenthesis and put each argument on its own\n+block-indented line. For example,\n+\n+```rust\n+fn foo(\n+    arg1: i32,\n+    arg2: i32,\n+) -> i32 {\n+    ...\n+}\n+```\n+\n+Note the trailing comma on the last argument.\n+\n+\n+### Tuples and tuple structs\n+\n+Write the type list as you would a parameter list to a function.\n+\n+Build a tuple or tuple struct as you would call a function.\n+\n+#### Single-line\n+\n+```rust\n+struct Bar(Type1, Type2);\n+\n+let x = Bar(11, 22);\n+let y = (11, 22, 33);\n+```\n+\n+### Enums\n+\n+In the declaration, put each variant on its own line, block indented.\n+\n+Format each variant accordingly as either a struct, tuple struct, or identifier,\n+which doesn't require special formatting (but without the `struct` keyword.\n+\n+```rust\n+enum FooBar {\n+    First(u32),\n+    Second,\n+    Error {\n+        err: Box<Error>,\n+        line: u32,\n+    },\n+}\n+```\n+\n+If a struct variant is [*small*](index.html#small-items), it may be formatted on\n+one line. In this case, do not use a trailing comma for the field list, but do\n+put spaces around each brace:\n+\n+```rust\n+enum FooBar {\n+    Error { err: Box<Error>, line: u32 },\n+}\n+```\n+\n+In an enum with multiple struct variants, if any struct variant is written on\n+multiple lines, then the multi-line formatting should be used for all struct\n+variants. However, such a situation might be an indication that you should\n+factor out the fields of the variant into their own struct.\n+\n+\n+### Structs and Unions\n+\n+Struct names follow on the same line as the `struct` keyword, with the opening\n+brace on the same line when it fits within the right margin. All struct fields\n+are indented once and end with a trailing comma. The closing brace is not\n+indented and appears on its own line.\n+\n+```rust\n+struct Foo {\n+    a: A,\n+    b: B,\n+}\n+```\n+\n+If and only if the type of a field does not fit within the right margin, it is\n+pulled down to its own line and indented again.\n+\n+```rust\n+struct Foo {\n+    a: A,\n+    long_name:\n+        LongType,\n+}\n+```\n+\n+Prefer using a unit struct (e.g., `struct Foo;`) to an empty struct (e.g.,\n+`struct Foo();` or `struct Foo {}`, these only exist to simplify code\n+generation), but if you must use an empty struct, keep it on one line with no\n+space between the braces: `struct Foo;` or `struct Foo {}`.\n+\n+The same guidelines are used for untagged union declarations.\n+\n+```rust\n+union Foo {\n+    a: A,\n+    b: B,\n+    long_name:\n+        LongType,\n+}\n+```\n+\n+\n+### Tuple structs\n+\n+Put the whole struct on one line if possible. Types in the parentheses should be\n+separated by a comma and space with no trailing comma. No spaces around the\n+parentheses or semi-colon:\n+\n+```rust\n+pub struct Foo(String, u8);\n+```\n+\n+Prefer unit structs to empty tuple structs (these only exist to simplify code\n+generation), e.g., `struct Foo;` rather than `struct Foo();`.\n+\n+For more than a few fields, prefer a proper struct with named fields. Given\n+this, a tuple struct should always fit on one line. If it does not, block format\n+the fields with a field on each line and a trailing comma:\n+\n+```rust\n+pub struct Foo(\n+    String,\n+    u8,\n+);\n+```\n+\n+\n+### Traits\n+\n+Trait items should be block-indented. If there are no items, the trait may be\n+formatted on a single line. Otherwise there should be line-breaks after the\n+opening brace and before the closing brace:\n+\n+```rust\n+trait Foo {}\n+\n+pub trait Bar {\n+    ...\n+}\n+```\n+\n+If the trait has bounds, there should be a space after the colon but not before\n+and before and after each `+`, e.g.,\n+\n+```rust\n+trait Foo: Debug + Bar {}\n+```\n+\n+Prefer not to line-break in the bounds if possible (consider using a `where`\n+clause). Prefer to break between bounds than to break any individual bound. If\n+you must break the bounds, put each bound (including the first) on its own\n+block-indented line, break before the `+` and put the opening brace on its own\n+line:\n+\n+```rust\n+pub trait IndexRanges:\n+    Index<Range<usize>, Output=Self>\n+    + Index<RangeTo<usize>, Output=Self>\n+    + Index<RangeFrom<usize>, Output=Self>\n+    + Index<RangeFull, Output=Self>\n+{\n+    ...\n+}\n+```\n+\n+\n+### Impls\n+\n+Impl items should be block indented. If there are no items, the impl may be\n+formatted on a single line. Otherwise there should be line-breaks after the\n+opening brace and before the closing brace:\n+\n+```rust\n+impl Foo {}\n+\n+impl Bar for Foo {\n+    ...\n+}\n+```\n+\n+Avoid line-breaking in the signature if possible. If a line break is required in\n+a non-inherent impl, break immediately before `for`, block indent the concrete type\n+and put the opening brace on its own line:\n+\n+```rust\n+impl Bar\n+    for Foo\n+{\n+    ...\n+}\n+```\n+\n+\n+### Extern crate\n+\n+`extern crate foo;`\n+\n+Use spaces around keywords, no spaces around the semi-colon.\n+\n+\n+### Modules\n+\n+```rust\n+mod foo {\n+}\n+```\n+\n+```rust\n+mod foo;\n+```\n+\n+Use spaces around keywords and before the opening brace, no spaces around the\n+semi-colon.\n+\n+### macro\\_rules!\n+\n+Use `{}` for the full definition of the macro.\n+\n+```rust\n+macro_rules! foo {\n+}\n+```\n+\n+\n+### Generics\n+\n+Prefer to put a generics clause on one line. Break other parts of an item\n+declaration rather than line-breaking a generics clause. If a generics clause is\n+large enough to require line-breaking, you should prefer to use a `where` clause\n+instead.\n+\n+Do not put spaces before or after `<` nor before `>`. Only put a space after `>`\n+if it is followed by a word or opening brace, not an opening parenthesis. There\n+should be a space after each comma and no trailing comma.\n+\n+```rust\n+fn foo<T: Display, U: Debug>(x: Vec<T>, y: Vec<U>) ...\n+\n+impl<T: Display, U: Debug> SomeType<T, U> { ...\n+```\n+\n+If the generics clause must be formatted across multiple lines, each parameter\n+should have its own block-indented line, there should be newlines after the\n+opening bracket and before the closing bracket, and the should be a trailing\n+comma.\n+\n+```rust\n+fn foo<\n+    T: Display,\n+    U: Debug,\n+>(x: Vec<T>, y: Vec<U>) ...\n+```\n+\n+If an associated type is bound in a generic type, then there should be spaces on\n+either side of the `=`:\n+\n+```rust\n+<T: Example<Item = u32>>\n+```\n+\n+Prefer to use single-letter names for generic parameters.\n+\n+\n+### `where` clauses\n+\n+These rules apply for `where` clauses on any item.\n+\n+A `where` clause may immediately follow a closing bracket of any kind.\n+Otherwise, it must start a new line, with no indent. Each component of a `where`\n+clause must be on its own line and be block indented. There should be a trailing\n+comma, unless the clause is terminated with a semicolon. If the `where` clause\n+is followed by a block (or assignment), the block should be started on a new\n+line. Examples:\n+\n+```rust\n+fn function<T, U>(args)\n+where\n+    T: Bound,\n+    U: AnotherBound,\n+{\n+    body\n+}\n+\n+fn foo<T>(\n+    args\n+) -> ReturnType\n+where\n+    T: Bound,\n+{\n+    body\n+}\n+\n+fn foo<T, U>(\n+    args,\n+) where\n+    T: Bound,\n+    U: AnotherBound,\n+{\n+    body\n+}\n+\n+fn foo<T, U>(\n+    args\n+) -> ReturnType\n+where\n+    T: Bound,\n+    U: AnotherBound;  // Note, no trailing comma.\n+\n+// Note that where clauses on `type` aliases are not enforced and should not\n+// be used.\n+type Foo<T>\n+where\n+    T: Bound\n+= Bar<T>;\n+```\n+\n+If a `where` clause is very short, we recommend using an inline bound on the\n+type parameter.\n+\n+\n+If a component of a `where` clause is long, it may be broken before `+` and\n+further block indented. Each bound should go on its own line. E.g.,\n+\n+```rust\n+impl<T: ?Sized, Idx> IndexRanges<Idx> for T\n+where\n+    T: Index<Range<Idx>, Output = Self::Output>\n+        + Index<RangeTo<Idx>, Output = Self::Output>\n+        + Index<RangeFrom<Idx>, Output = Self::Output>\n+        + Index<RangeInclusive<Idx>, Output = Self::Output>\n+        + Index<RangeToInclusive<Idx>, Output = Self::Output> + Index<RangeFull>\n+```\n+\n+#### Option - `where_single_line`\n+\n+`where_single_line` is `false` by default. If `true`, then a where clause with\n+exactly one component may be formatted on a single line if the rest of the\n+item's signature is also kept on one line. In this case, there is no need for a\n+trailing comma and if followed by a block, no need for a newline before the\n+block. E.g.,\n+\n+```rust\n+// May be single-lined.\n+fn foo<T>(args) -> ReturnType\n+where T: Bound {\n+    body\n+}\n+\n+// Must be multi-lined.\n+fn foo<T>(\n+    args\n+) -> ReturnType\n+where\n+    T: Bound,\n+{\n+    body\n+}\n+```\n+\n+\n+### Type aliases\n+\n+Type aliases should generally be kept on one line. If necessary to break the\n+line, do so after the `=`; the right-hand-side should be block indented:\n+\n+```rust\n+pub type Foo = Bar<T>;\n+\n+// If multi-line is required\n+type VeryLongType<T, U: SomeBound> =\n+    AnEvenLongerType<T, U, Foo<T>>;\n+```\n+\n+Where possible avoid `where` clauses and keep type constraints inline. Where\n+that is not possible split the line before and after the `where` clause (and\n+split the `where` clause as normal), e.g.,\n+\n+```rust\n+type VeryLongType<T, U>\n+where\n+    T: U::AnAssociatedType,\n+    U: SomeBound,\n+= AnEvenLongerType<T, U, Foo<T>>;\n+```\n+\n+\n+### Associated types\n+\n+Associated types should follow the guidelines above for type aliases. Where an\n+associated type has a bound, there should be a space after the colon but not\n+before:\n+\n+```rust\n+pub type Foo: Bar;\n+```\n+\n+\n+### extern items\n+\n+When writing extern items (such as `extern \"C\" fn`), always be explicit about\n+the ABI. For example, write `extern \"C\" fn foo ...`, not `extern fn foo ...`, or\n+`extern \"C\" { ... }`.\n+\n+\n+### Imports (`use` statements)\n+\n+If an import can be formatted on one line, do so. There should be no spaces\n+around braces.\n+\n+```rust\n+use a::b::c;\n+use a::b::d::*;\n+use a::b::{foo, bar, baz};\n+```\n+\n+\n+#### Large list imports\n+\n+Prefer to use multiple imports rather than a multi-line import. However, tools\n+should not split imports by default (they may offer this as an option).\n+\n+If an import does require multiple lines (either because a list of single names\n+does not fit within the max width, or because of the rules for nested imports\n+below), then break after the opening brace and before the closing brace, use a\n+trailing comma, and block indent the names.\n+\n+\n+```rust\n+// Prefer\n+foo::{long, list, of, imports};\n+foo::{more, imports};\n+\n+// If necessary\n+foo::{\n+    long, list, of, imports, more,\n+    imports,  // Note trailing comma\n+};\n+```\n+\n+\n+#### Ordering of imports\n+\n+A *group* of imports is a set of imports on the same or sequential lines. One or\n+more blank lines or other items (e.g., a function) separate groups of imports.\n+\n+Within a group of imports, imports must be sorted ascii-betically. Groups of\n+imports must not be merged or re-ordered.\n+\n+\n+E.g., input:\n+\n+```rust\n+use d;\n+use c;\n+\n+use b;\n+use a;\n+```\n+\n+output:\n+\n+```rust\n+use c;\n+use d;\n+\n+use a;\n+use b;\n+```\n+\n+Because of `macro_use`, attributes must also start a new group and prevent\n+re-ordering.\n+\n+Note that tools which only have access to syntax (such as Rustfmt) cannot tell\n+which imports are from an external crate or the std lib, etc.\n+\n+\n+#### Ordering list import\n+\n+Names in a list import must be sorted ascii-betically, but with `self` and\n+`super` first, and groups and glob imports last. This applies recursively. For\n+example, `a::*` comes before `b::a` but `a::b` comes before `a::*`. E.g.,\n+`use foo::bar::{a, b::c, b::d, b::d::{x, y, z}, b::{self, r, s}};`.\n+\n+\n+#### Normalisation\n+\n+Tools must make the following normalisations:\n+\n+* `use a::self;` -> `use a;`\n+* `use a::{};` -> (nothing)\n+* `use a::{b};` -> `use a::b;`\n+\n+And must apply these recursively.\n+\n+Tools must not otherwise merge or un-merge import lists or adjust glob imports\n+(without an explicit option).\n+\n+\n+#### Nested imports\n+\n+If there are any nested imports in a list import, then use the multi-line form,\n+even if the import fits on one line. Each nested import must be on its own line,\n+but non-nested imports must be grouped on as few lines as possible.\n+\n+For example,\n+\n+```rust\n+use a::b::{\n+    x, y, z,\n+    u::{...},\n+    w::{...},\n+};\n+```\n+\n+\n+#### Merging/un-merging imports\n+\n+An example:\n+\n+```rust\n+// Un-merged\n+use a::b;\n+use a::c::d;\n+\n+// Merged\n+use a::{b, c::d};\n+```\n+\n+Tools must not merge or un-merge imports by default. They may offer merging or\n+un-merging as an option."}, {"sha": "b02b3c0471f2865eb39c7cc7887eaedac4c09ab0", "filename": "src/doc/style-guide/src/principles.md", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fprinciples.md", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fprinciples.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fprinciples.md?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -0,0 +1,51 @@\n+# Guiding principles and rationale\n+\n+When deciding on style guidelines, the style team tried to be guided by the\n+following principles (in rough priority order):\n+\n+* readability\n+    - scan-ability\n+    - avoiding misleading formatting\n+    - accessibility - readable and editable by users using the the widest\n+      variety of hardware, including non-visual accessibility interfaces\n+    - readability of code when quoted in rustc error messages\n+\n+* aesthetics\n+    - sense of 'beauty'\n+    - consistent with other languages/tools\n+\n+* specifics\n+    - compatibility with version control practices - preserving diffs,\n+      merge-friendliness, etc.\n+    - preventing right-ward drift\n+    - minimising vertical space\n+\n+* application\n+    - ease of manual application\n+    - ease of implementation (in Rustfmt, and in other tools/editors/code generators)\n+    - internal consistency\n+    - simplicity of formatting rules\n+\n+\n+## Overarching guidelines\n+\n+Prefer block indent over visual indent. E.g.,\n+\n+```rust\n+// Block indent\n+a_function_call(\n+    foo,\n+    bar,\n+);\n+\n+// Visual indent\n+a_function_call(foo,\n+                bar);\n+```\n+\n+This makes for smaller diffs (e.g., if `a_function_call` is renamed in the above\n+example) and less rightward drift.\n+\n+Lists should have a trailing comma when followed by a newline, see the block\n+indent example above. This choice makes moving code (e.g., by copy and paste)\n+easier and makes smaller diffs."}, {"sha": "29b48bb1ee0b78a8be8127a31031cc935d35de07", "filename": "src/doc/style-guide/src/statements.md", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fstatements.md", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fstatements.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle-guide%2Fsrc%2Fstatements.md?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -0,0 +1,150 @@\n+### Let statements\n+\n+There should be spaces after the `:` and on both sides of the `=` (if they are\n+present). No space before the semi-colon.\n+\n+```rust\n+// A comment.\n+let pattern: Type = expr;\n+\n+let pattern;\n+let pattern: Type;\n+let pattern = expr;\n+```\n+\n+If possible the declaration should be formatted on a single line. If this is not\n+possible, then try splitting after the `=`, if the declaration can fit on two\n+lines. The expression should be block indented.\n+\n+```rust\n+let pattern: Type =\n+    expr;\n+```\n+\n+If the first line does not fit on a single line, then split after the colon,\n+using block indentation. If the type covers multiple lines, even after line-\n+breaking after the `:`, then the first line may be placed on the same line as\n+the `:`, subject to the [combining rules](https://github.com/rust-lang-nursery/fmt-rfcs/issues/61) (WIP).\n+\n+\n+```rust\n+let pattern:\n+    Type =\n+    expr;\n+```\n+\n+e.g,\n+\n+```rust\n+let Foo {\n+    f: abcd,\n+    g: qwer,\n+}: Foo<Bar> =\n+    Foo { f, g };\n+\n+let (abcd,\n+    defg):\n+    Baz =\n+{ ... }\n+```\n+\n+If the expression covers multiple lines, if the first line of the expression\n+fits in the remaining space, it stays on the same line as the `=`, the rest of the\n+expression is not indented. If the first line does not fit, then it should start\n+on the next lines, and should be block indented. If the expression is a block\n+and the type or pattern cover multiple lines, then the opening brace should be\n+on a new line and not indented (this provides separation for the interior of the\n+block from the type), otherwise the opening brace follows the `=`.\n+\n+Examples:\n+\n+```rust\n+let foo = Foo {\n+    f: abcd,\n+    g: qwer,\n+};\n+\n+let foo =\n+    ALongName {\n+        f: abcd,\n+        g: qwer,\n+    };\n+\n+let foo: Type = {\n+    an_expression();\n+    ...\n+};\n+\n+let foo:\n+    ALongType =\n+{\n+    an_expression();\n+    ...\n+};\n+\n+let Foo {\n+    f: abcd,\n+    g: qwer,\n+}: Foo<Bar> = Foo {\n+    f: blimblimblim,\n+    g: blamblamblam,\n+};\n+\n+let Foo {\n+    f: abcd,\n+    g: qwer,\n+}: Foo<Bar> = foo(\n+    blimblimblim,\n+    blamblamblam,\n+);\n+```\n+\n+\n+### Macros in statement position\n+\n+A macro use in statement position should use parentheses or square brackets as\n+delimiters and should be terminated with a semi-colon. There should be no spaces\n+between the name, `!`, the delimiters, or the `;`.\n+\n+```rust\n+// A comment.\n+a_macro!(...);\n+```\n+\n+\n+### Expressions in statement position\n+\n+There should be no space between the expression and the semi-colon.\n+\n+```\n+<expr>;\n+```\n+\n+All expressions in statement position should be terminated with a semi-colon,\n+unless they end with a block or are used as the value for a block.\n+\n+E.g.,\n+\n+```rust\n+{\n+    an_expression();\n+    expr_as_value()\n+}\n+\n+return foo();\n+\n+loop {\n+    break;\n+}\n+```\n+\n+Use a semi-colon where an expression has void type, even if it could be\n+propagated. E.g.,\n+\n+```rust\n+fn foo() { ... }\n+\n+fn bar() {\n+    foo();\n+}\n+```"}, {"sha": "25861ddabb8d0e0b2e4a0deed53026ecd95a4846", "filename": "src/doc/style-guide/src/types.md", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Fdoc%2Fstyle-guide%2Fsrc%2Ftypes.md", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Fdoc%2Fstyle-guide%2Fsrc%2Ftypes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle-guide%2Fsrc%2Ftypes.md?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -0,0 +1,58 @@\n+## Types and Bounds\n+\n+### Single line formatting\n+\n+* `[T]` no spaces\n+* `[T; expr]`, e.g., `[u32; 42]`, `[Vec<Foo>; 10 * 2 + foo()]` (space after colon, no spaces around square brackets)\n+* `*const T`, `*mut T` (no space after `*`, space before type)\n+* `&'a T`, `&T`, `&'a mut T`, `&mut T` (no space after `&`, single spaces separating other words)\n+* `unsafe extern \"C\" fn<'a, 'b, 'c>(T, U, V) -> W` or `fn()` (single spaces around keyowrds and sigils, and after commas, no trailing commas, no spaces around brackets)\n+* `!` should be treated like any other type name, `Name`\n+* `(A, B, C, D)` (spaces after commas, no spaces around parens, no trailing comma unless it is a one-tuple)\n+* `<Baz<T> as SomeTrait>::Foo::Bar` or `Foo::Bar` or `::Foo::Bar` (no spaces around `::` or angle brackets, single spaces around `as`)\n+* `Foo::Bar<T, U, V>` (spaces after commas, no trailing comma, no spaces around angle brackets)\n+* `T + T + T` (single spaces between types, and `+`).\n+* `impl T + T + T` (single spaces between keyword, types, and `+`).\n+\n+Parentheses used in types should not be surrounded by whitespace, e.g., `(Foo)`\n+\n+\n+### Line breaks\n+\n+Avoid breaking lines in types where possible. Prefer breaking at outermost scope, e.g., prefer\n+\n+```rust\n+Foo<\n+    Bar,\n+    Baz<Type1, Type2>,\n+>\n+```\n+\n+to\n+\n+```rust\n+Foo<Bar, Baz<\n+    Type1,\n+    Type2,\n+>>\n+```\n+\n+`[T; expr]` may be broken after the `;` if necessary.\n+\n+Function types may be broken following the rules for function declarations.\n+\n+Generic types may be broken following the rules for generics.\n+\n+Types with `+` may be broken after any `+` using block indent and breaking before the `+`. When breaking such a type, all `+`s should be line broken, e.g.,\n+\n+```rust\n+impl Clone\n+    + Copy\n+    + Debug\n+\n+Box<\n+    Clone\n+    + Copy\n+    + Debug\n+>\n+```"}, {"sha": "f5b0d15d733aa863844f624367d76e01d9a5d68a", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -218,55 +218,55 @@ pre.rust a,\n .sidebar h2 a,\n .sidebar h3 a,\n .mobile-topbar h2 a,\n-h1.fqn a,\n+h1 a,\n .search-results a,\n .module-item .stab,\n .import-item .stab,\n .result-name .primitive > i, .result-name .keyword > i,\n-.content .method .where,\n-.content .fn .where,\n-.content .where.fmt-newline {\n+.method .where,\n+.fn .where,\n+.where.fmt-newline {\n \tcolor: var(--main-color);\n }\n \n-.content span.enum, .content a.enum,\n-.content span.struct, .content a.struct,\n-.content span.union, .content a.union,\n-.content span.primitive, .content a.primitive,\n-.content span.type, .content a.type,\n-.content span.foreigntype, .content a.foreigntype {\n+span.enum, a.enum,\n+span.struct, a.struct,\n+span.union, a.union,\n+span.primitive, a.primitive,\n+span.type, a.type,\n+span.foreigntype, a.foreigntype {\n \tcolor: var(--type-link-color);\n }\n \n-.content span.trait, .content a.trait,\n-.content span.traitalias, .content a.traitalias {\n+span.trait, a.trait,\n+span.traitalias, a.traitalias {\n \tcolor: var(--trait-link-color);\n }\n \n-.content span.associatedtype, .content a.associatedtype,\n-.content span.constant, .content a.constant,\n-.content span.static, .content a.static {\n+span.associatedtype, a.associatedtype,\n+span.constant, a.constant,\n+span.static, a.static {\n \tcolor: var(--assoc-item-link-color);\n }\n \n-.content span.fn, .content a.fn,\n-.content .fnname,\n-.content span.method, .content a.method,\n-.content span.tymethod, .content a.tymethod {\n+span.fn, a.fn,\n+.fnname,\n+span.method, a.method,\n+span.tymethod, a.tymethod {\n \tcolor: var(--function-link-color);\n }\n \n-.content span.attr, .content a.attr,\n-.content span.derive, .content a.derive,\n-.content span.macro, .content a.macro {\n+span.attr, a.attr,\n+span.derive, a.derive,\n+span.macro, a.macro {\n \tcolor: var(--macro-link-color);\n }\n \n-.content span.mod, .content a.mod, .block a.current.mod {\n+span.mod, a.mod {\n \tcolor: var(--mod-link-color);\n }\n \n-.content span.keyword, .content a.keyword {\n+span.keyword, a.keyword {\n \tcolor: var(--keyword-link-color);\n }\n \n@@ -685,9 +685,9 @@ pre, .rustdoc.source .example-wrap {\n }\n \n /* Shift \"where ...\" part of method or fn definition down a line */\n-.content .method .where,\n-.content .fn .where,\n-.content .where.fmt-newline {\n+.method .where,\n+.fn .where,\n+.where.fmt-newline {\n \tdisplay: block;\n \tfont-size: 0.875rem;\n }"}, {"sha": "fc7713b98857b19df9d3d1f2d76b4e928589f166", "filename": "src/librustdoc/html/static/css/themes/ayu.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -56,7 +56,7 @@ input:focus + .slider {\n h1, h2, h3, h4 {\n \tcolor: white;\n }\n-h1.fqn  a {\n+h1 a {\n \tcolor: #fff;\n }\n h4 {"}, {"sha": "dc5b8acdf53a86cf73e99e35b3a26651457155be", "filename": "src/librustdoc/html/static/js/main.js", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -451,21 +451,19 @@ function loadCss(cssFileName) {\n                 const name = item[0];\n                 const desc = item[1]; // can be null\n \n-                let klass = shortty;\n                 let path;\n                 if (shortty === \"mod\") {\n                     path = name + \"/index.html\";\n                 } else {\n                     path = shortty + \".\" + name + \".html\";\n                 }\n                 const current_page = document.location.href.split(\"/\").pop();\n-                if (path === current_page) {\n-                    klass += \" current\";\n-                }\n                 const link = document.createElement(\"a\");\n                 link.href = path;\n                 link.title = desc;\n-                link.className = klass;\n+                if (path === current_page) {\n+                    link.className = \"current\";\n+                }\n                 link.textContent = name;\n                 const li = document.createElement(\"li\");\n                 li.appendChild(link);"}, {"sha": "18a1a3fadea5527eaf492f793a617aea856b7258", "filename": "src/test/rustdoc-gui/sidebar-links-color.goml", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Ftest%2Frustdoc-gui%2Fsidebar-links-color.goml", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Ftest%2Frustdoc-gui%2Fsidebar-links-color.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsidebar-links-color.goml?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -13,72 +13,72 @@ reload:\n \n // Struct\n assert-css: (\n-    \".sidebar a.struct:not(.current)\",\n+    \".sidebar .block.struct a:not(.current)\",\n     {\"color\": \"rgb(83, 177, 219)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n )\n-move-cursor-to: \".sidebar a.struct:not(.current)\"\n+move-cursor-to: \".sidebar .block.struct a:not(.current)\"\n assert-css: (\n-    \".sidebar a.struct:hover\",\n+    \".sidebar .block.struct a:hover\",\n     {\"color\": \"rgb(255, 180, 76)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n )\n // Enum\n assert-css: (\n-    \".sidebar a.enum\",\n+    \".sidebar .block.enum a\",\n     {\"color\": \"rgb(83, 177, 219)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n )\n-move-cursor-to: \".sidebar a.enum\"\n+move-cursor-to: \".sidebar .block.enum a\"\n assert-css: (\n-    \".sidebar a.enum:hover\",\n+    \".sidebar .block.enum a:hover\",\n     {\"color\": \"rgb(255, 180, 76)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n )\n // Union\n assert-css: (\n-    \".sidebar a.union\",\n+    \".sidebar .block.union a\",\n     {\"color\": \"rgb(83, 177, 219)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n )\n-move-cursor-to: \".sidebar a.union\"\n+move-cursor-to: \".sidebar .block.union a\"\n assert-css: (\n-    \".sidebar a.union:hover\",\n+    \".sidebar .block.union a:hover\",\n     {\"color\": \"rgb(255, 180, 76)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n )\n // Trait\n assert-css: (\n-    \".sidebar a.trait\",\n+    \".sidebar .block.trait a\",\n     {\"color\": \"rgb(83, 177, 219)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n )\n-move-cursor-to: \".sidebar a.trait\"\n+move-cursor-to: \".sidebar .block.trait a\"\n assert-css: (\n-    \".sidebar a.trait:hover\",\n+    \".sidebar .block.trait a:hover\",\n     {\"color\": \"rgb(255, 180, 76)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n )\n // Function\n assert-css: (\n-    \".sidebar a.fn\",\n+    \".sidebar .block.fn a\",\n     {\"color\": \"rgb(83, 177, 219)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n )\n-move-cursor-to: \".sidebar a.fn\"\n+move-cursor-to: \".sidebar .block.fn a\"\n assert-css: (\n-    \".sidebar a.fn:hover\",\n+    \".sidebar .block.fn a:hover\",\n     {\"color\": \"rgb(255, 180, 76)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n )\n // Type definition\n assert-css: (\n-    \".sidebar a.type\",\n+    \".sidebar .block.type a\",\n     {\"color\": \"rgb(83, 177, 219)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n )\n-move-cursor-to: \".sidebar a.type\"\n+move-cursor-to: \".sidebar .block.type a\"\n assert-css: (\n-    \".sidebar a.type:hover\",\n+    \".sidebar .block.type a:hover\",\n     {\"color\": \"rgb(255, 180, 76)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n )\n // Keyword\n assert-css: (\n-    \".sidebar a.keyword\",\n+    \".sidebar .block.keyword a\",\n     {\"color\": \"rgb(83, 177, 219)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n )\n-move-cursor-to: \".sidebar a.keyword\"\n+move-cursor-to: \".sidebar .block.keyword a\"\n assert-css: (\n-    \".sidebar a.keyword:hover\",\n+    \".sidebar .block.keyword a:hover\",\n     {\"color\": \"rgb(255, 180, 76)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n )\n \n@@ -88,72 +88,72 @@ reload:\n \n // Struct\n assert-css: (\n-    \".sidebar a.struct:not(.current)\",\n+    \".sidebar .block.struct a:not(.current)\",\n     {\"color\": \"rgb(253, 191, 53)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n )\n-move-cursor-to: \".sidebar a.struct:not(.current)\"\n+move-cursor-to: \".sidebar .block.struct a:not(.current)\"\n assert-css: (\n-    \".sidebar a.struct:hover\",\n+    \".sidebar .block.struct a:hover\",\n     {\"color\": \"rgb(253, 191, 53)\", \"background-color\": \"rgb(68, 68, 68)\"},\n )\n // Enum\n assert-css: (\n-    \".sidebar a.enum\",\n+    \".sidebar .block.enum a\",\n     {\"color\": \"rgb(253, 191, 53)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n )\n-move-cursor-to: \".sidebar a.enum\"\n+move-cursor-to: \".sidebar .block.enum a\"\n assert-css: (\n-    \".sidebar a.enum:hover\",\n+    \".sidebar .block.enum a:hover\",\n     {\"color\": \"rgb(253, 191, 53)\", \"background-color\": \"rgb(68, 68, 68)\"},\n )\n // Union\n assert-css: (\n-    \".sidebar a.union\",\n+    \".sidebar .block.union a\",\n     {\"color\": \"rgb(253, 191, 53)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n )\n-move-cursor-to: \".sidebar a.union\"\n+move-cursor-to: \".sidebar .block.union a\"\n assert-css: (\n-    \".sidebar a.union:hover\",\n+    \".sidebar .block.union a:hover\",\n     {\"color\": \"rgb(253, 191, 53)\", \"background-color\": \"rgb(68, 68, 68)\"},\n )\n // Trait\n assert-css: (\n-    \".sidebar a.trait\",\n+    \".sidebar .block.trait a\",\n     {\"color\": \"rgb(253, 191, 53)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n )\n-move-cursor-to: \".sidebar a.trait\"\n+move-cursor-to: \".sidebar .block.trait a\"\n assert-css: (\n-    \".sidebar a.trait:hover\",\n+    \".sidebar .block.trait a:hover\",\n     {\"color\": \"rgb(253, 191, 53)\", \"background-color\": \"rgb(68, 68, 68)\"},\n )\n // Function\n assert-css: (\n-    \".sidebar a.fn\",\n+    \".sidebar .block.fn a\",\n     {\"color\": \"rgb(253, 191, 53)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n )\n-move-cursor-to: \".sidebar a.fn\"\n+move-cursor-to: \".sidebar .block.fn a\"\n assert-css: (\n-    \".sidebar a.fn:hover\",\n+    \".sidebar .block.fn a:hover\",\n     {\"color\": \"rgb(253, 191, 53)\", \"background-color\": \"rgb(68, 68, 68)\"},\n )\n // Type definition\n assert-css: (\n-    \".sidebar a.type\",\n+    \".sidebar .block.type a\",\n     {\"color\": \"rgb(253, 191, 53)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n )\n-move-cursor-to: \".sidebar a.type\"\n+move-cursor-to: \".sidebar .block.type a\"\n assert-css: (\n-    \".sidebar a.type:hover\",\n+    \".sidebar .block.type a:hover\",\n     {\"color\": \"rgb(253, 191, 53)\", \"background-color\": \"rgb(68, 68, 68)\"},\n )\n // Keyword\n assert-css: (\n-    \".sidebar a.keyword\",\n+    \".sidebar .block.keyword a\",\n     {\"color\": \"rgb(253, 191, 53)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n )\n-move-cursor-to: \".sidebar a.keyword\"\n+move-cursor-to: \".sidebar .block.keyword a\"\n assert-css: (\n-    \".sidebar a.keyword:hover\",\n+    \".sidebar .block.keyword a:hover\",\n     {\"color\": \"rgb(253, 191, 53)\", \"background-color\": \"rgb(68, 68, 68)\"},\n )\n \n@@ -163,71 +163,71 @@ reload:\n \n // Struct\n assert-css: (\n-    \".sidebar a.struct:not(.current)\",\n+    \".sidebar .block.struct a:not(.current)\",\n     {\"color\": \"rgb(53, 109, 164)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n )\n-move-cursor-to: \".sidebar a.struct:not(.current)\"\n+move-cursor-to: \".sidebar .block.struct a:not(.current)\"\n assert-css: (\n-    \".sidebar a.struct:hover\",\n+    \".sidebar .block.struct a:hover\",\n     {\"color\": \"rgb(53, 109, 164)\", \"background-color\": \"rgb(255, 255, 255)\"},\n )\n // Enum\n assert-css: (\n-    \".sidebar a.enum\",\n+    \".sidebar .block.enum a\",\n     {\"color\": \"rgb(53, 109, 164)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n )\n-move-cursor-to: \".sidebar a.enum\"\n+move-cursor-to: \".sidebar .block.enum a\"\n assert-css: (\n-    \".sidebar a.enum:hover\",\n+    \".sidebar .block.enum a:hover\",\n     {\"color\": \"rgb(53, 109, 164)\", \"background-color\": \"rgb(255, 255, 255)\"},\n )\n // Union\n assert-css: (\n-    \".sidebar a.union\",\n+    \".sidebar .block.union a\",\n     {\"color\": \"rgb(53, 109, 164)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n )\n-move-cursor-to: \".sidebar a.union\"\n+move-cursor-to: \".sidebar .block.union a\"\n assert-css: (\n-    \".sidebar a.union:hover\",\n+    \".sidebar .block.union a:hover\",\n     {\"color\": \"rgb(53, 109, 164)\", \"background-color\": \"rgb(255, 255, 255)\"},\n )\n // Trait\n assert-css: (\n-    \".sidebar a.trait\",\n+    \".sidebar .block.trait a\",\n     {\"color\": \"rgb(53, 109, 164)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n )\n-move-cursor-to: \".sidebar a.trait\"\n+move-cursor-to: \".sidebar .block.trait a\"\n assert-css: (\n-    \".sidebar a.trait:hover\",\n+    \".sidebar .block.trait a:hover\",\n     {\"color\": \"rgb(53, 109, 164)\", \"background-color\": \"rgb(255, 255, 255)\"},\n )\n // Function\n assert-css: (\n-    \".sidebar a.fn\",\n+    \".sidebar .block.fn a\",\n     {\"color\": \"rgb(53, 109, 164)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n )\n-move-cursor-to: \".sidebar a.fn\"\n+move-cursor-to: \".sidebar .block.fn a\"\n assert-css: (\n-    \".sidebar a.fn:hover\",\n+    \".sidebar .block.fn a:hover\",\n     {\"color\": \"rgb(53, 109, 164)\", \"background-color\": \"rgb(255, 255, 255)\"},\n )\n // Type definition\n assert-css: (\n-    \".sidebar a.type\",\n+    \".sidebar .block.type a\",\n     {\"color\": \"rgb(53, 109, 164)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n )\n-move-cursor-to: \".sidebar a.type\"\n+move-cursor-to: \".sidebar .block.type a\"\n assert-css: (\n-    \".sidebar a.type:hover\",\n+    \".sidebar .block.type a:hover\",\n     {\"color\": \"rgb(53, 109, 164)\", \"background-color\": \"rgb(255, 255, 255)\"},\n )\n // Keyword\n assert-css: (\n-    \".sidebar a.keyword\",\n+    \".sidebar .block.keyword a\",\n     {\"color\": \"rgb(53, 109, 164)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n )\n-move-cursor-to: \".sidebar a.keyword\"\n+move-cursor-to: \".sidebar .block.keyword a\"\n assert-css: (\n-    \".sidebar a.keyword:hover\",\n+    \".sidebar .block.keyword a:hover\",\n     {\"color\": \"rgb(53, 109, 164)\", \"background-color\": \"rgb(255, 255, 255)\"},\n )"}, {"sha": "b5c1b6a4390b6e54410103222a338843984ca1b0", "filename": "src/test/rustdoc-gui/sidebar-macro-reexport.goml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Ftest%2Frustdoc-gui%2Fsidebar-macro-reexport.goml", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Ftest%2Frustdoc-gui%2Fsidebar-macro-reexport.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsidebar-macro-reexport.goml?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -1,5 +1,5 @@\n // This test ensures that the reexport of a macro doesn't make the original macro\n // displayed twice in the sidebar.\n goto: \"file://\" + |DOC_PATH| + \"/test_docs/macro.repro.html\"\n-wait-for: \".sidebar-elems .macro .macro\"\n+wait-for: \".sidebar-elems .block.macro a\"\n assert-count: (\"//*[@class='sidebar-elems']//*[@class='block macro']//a[text()='repro']\", 1)"}, {"sha": "4b1e04234c870594bcaaf458bb9b2fbe39507c8c", "filename": "src/test/rustdoc-ui/infinite-recursive-type-impl-trait-return.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Ftest%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Ftest%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait-return.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -1,11 +1,12 @@\n+// check-pass\n // normalize-stderr-test: \"`.*`\" -> \"`DEF_ID`\"\n // normalize-stdout-test: \"`.*`\" -> \"`DEF_ID`\"\n // edition:2018\n \n pub async fn f() -> impl std::fmt::Debug {\n+    // rustdoc doesn't care that this is infinitely sized\n     #[derive(Debug)]\n     enum E {\n-    //~^ ERROR recursive type `f::{closure#0}::E` has infinite size\n         This(E),\n         Unit,\n     }"}, {"sha": "e6ab67d59ce5818e55fcc7c93e84b3a8c3ebaddf", "filename": "src/test/rustdoc-ui/infinite-recursive-type-impl-trait-return.stderr", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2b91cbe2d4ce90d30520674876e9d700cf7a561b/src%2Ftest%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b91cbe2d4ce90d30520674876e9d700cf7a561b/src%2Ftest%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait-return.stderr?ref=2b91cbe2d4ce90d30520674876e9d700cf7a561b", "patch": "@@ -1,17 +0,0 @@\n-error[E0072]: recursive type `DEF_ID` has infinite size\n-  --> $DIR/infinite-recursive-type-impl-trait-return.rs:7:5\n-   |\n-LL |     enum E {\n-   |     ^^^^^^\n-LL |\n-LL |         This(E),\n-   |              - recursive without indirection\n-   |\n-help: insert some indirection (e.g., a `DEF_ID`) to break the cycle\n-   |\n-LL |         This(Box<E>),\n-   |              ++++ +\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `DEF_ID`."}, {"sha": "ac79582fb3f0df48e75c11cc1101e0d9f99ac5bc", "filename": "src/test/rustdoc-ui/infinite-recursive-type-impl-trait.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Ftest%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Ftest%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -1,6 +1,8 @@\n+// check-pass\n+\n fn f() -> impl Sized {\n+    // rustdoc doesn't care that this is infinitely sized\n     enum E {\n-    //~^ ERROR recursive type `f::E` has infinite size\n         V(E),\n     }\n     unimplemented!()"}, {"sha": "165ff6783724417adf64e0b8a1d0760924198bb3", "filename": "src/test/rustdoc-ui/infinite-recursive-type-impl-trait.stderr", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2b91cbe2d4ce90d30520674876e9d700cf7a561b/src%2Ftest%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b91cbe2d4ce90d30520674876e9d700cf7a561b/src%2Ftest%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait.stderr?ref=2b91cbe2d4ce90d30520674876e9d700cf7a561b", "patch": "@@ -1,17 +0,0 @@\n-error[E0072]: recursive type `f::E` has infinite size\n-  --> $DIR/infinite-recursive-type-impl-trait.rs:2:5\n-   |\n-LL |     enum E {\n-   |     ^^^^^^\n-LL |\n-LL |         V(E),\n-   |           - recursive without indirection\n-   |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n-   |\n-LL |         V(Box<E>),\n-   |           ++++ +\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0072`."}, {"sha": "9c6a419e9f72d85c5969e1a350ca95dae248fa16", "filename": "src/test/ui/associated-types/issue-85103.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Ftest%2Fui%2Fassociated-types%2Fissue-85103.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Ftest%2Fui%2Fassociated-types%2Fissue-85103.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-85103.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -4,6 +4,6 @@ use std::borrow::Cow;\n \n #[rustc_layout(debug)]\n type Edges<'a, E> = Cow<'a, [E]>;\n-//~^ ERROR layout error: NormalizationFailure\n+//~^ 6:1: 6:18: unable to determine layout for `<[E] as ToOwned>::Owned` because `<[E] as ToOwned>::Owned` cannot be normalized\n \n fn main() {}"}, {"sha": "17f7148074cf3fc01d757b5c44bfdeabe6eda2fd", "filename": "src/test/ui/associated-types/issue-85103.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Ftest%2Fui%2Fassociated-types%2Fissue-85103.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Ftest%2Fui%2Fassociated-types%2Fissue-85103.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-85103.stderr?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -1,4 +1,4 @@\n-error: layout error: NormalizationFailure(<[E] as std::borrow::ToOwned>::Owned, Type(<[E] as std::borrow::ToOwned>::Owned))\n+error: unable to determine layout for `<[E] as ToOwned>::Owned` because `<[E] as ToOwned>::Owned` cannot be normalized\n   --> $DIR/issue-85103.rs:6:1\n    |\n LL | type Edges<'a, E> = Cow<'a, [E]>;"}, {"sha": "b77342c4135e1b896fa31f164eb02291a6c564ef", "filename": "src/test/ui/consts/issue-102117.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Ftest%2Fui%2Fconsts%2Fissue-102117.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Ftest%2Fui%2Fconsts%2Fissue-102117.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-102117.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -0,0 +1,30 @@\n+#![feature(inline_const, const_type_id)]\n+\n+use std::alloc::Layout;\n+use std::any::TypeId;\n+use std::mem::transmute;\n+use std::ptr::drop_in_place;\n+\n+pub struct VTable {\n+    layout: Layout,\n+    type_id: TypeId,\n+    drop_in_place: unsafe fn(*mut ()),\n+}\n+\n+impl VTable {\n+    pub fn new<T>() -> &'static Self {\n+        const {\n+          //~^ ERROR the parameter type `T` may not live long enough\n+          //~| ERROR the parameter type `T` may not live long enough\n+            &VTable {\n+                layout: Layout::new::<T>(),\n+                type_id: TypeId::of::<T>(),\n+                drop_in_place: unsafe {\n+                    transmute::<unsafe fn(*mut T), unsafe fn(*mut ())>(drop_in_place::<T>)\n+                },\n+            }\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "eb4b329bd8134d06855a7ef5afdc22a6819e66b4", "filename": "src/test/ui/consts/issue-102117.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Ftest%2Fui%2Fconsts%2Fissue-102117.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Ftest%2Fui%2Fconsts%2Fissue-102117.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-102117.stderr?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -0,0 +1,37 @@\n+error[E0310]: the parameter type `T` may not live long enough\n+  --> $DIR/issue-102117.rs:16:9\n+   |\n+LL | /         const {\n+LL | |\n+LL | |\n+LL | |             &VTable {\n+...  |\n+LL | |             }\n+LL | |         }\n+   | |_________^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     pub fn new<T: 'static>() -> &'static Self {\n+   |                 +++++++++\n+\n+error[E0310]: the parameter type `T` may not live long enough\n+  --> $DIR/issue-102117.rs:16:9\n+   |\n+LL | /         const {\n+LL | |\n+LL | |\n+LL | |             &VTable {\n+...  |\n+LL | |             }\n+LL | |         }\n+   | |_________^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     pub fn new<T: 'static>() -> &'static Self {\n+   |                 +++++++++\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0310`."}, {"sha": "54f7e9ac592eb536813361a295cc4f8408a70f3c", "filename": "src/test/ui/issues/issue-72554.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Ftest%2Fui%2Fissues%2Fissue-72554.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Ftest%2Fui%2Fissues%2Fissue-72554.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-72554.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -3,7 +3,6 @@ use std::collections::BTreeSet;\n #[derive(Hash)]\n pub enum ElemDerived {\n     //~^ ERROR recursive type `ElemDerived` has infinite size\n-    //~| ERROR cycle detected when computing drop-check constraints for `ElemDerived`\n     A(ElemDerived)\n }\n "}, {"sha": "d12be539f7c1733c7748069f6b30cadf400f2c0d", "filename": "src/test/ui/issues/issue-72554.stderr", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Ftest%2Fui%2Fissues%2Fissue-72554.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Ftest%2Fui%2Fissues%2Fissue-72554.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-72554.stderr?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -3,7 +3,7 @@ error[E0072]: recursive type `ElemDerived` has infinite size\n    |\n LL | pub enum ElemDerived {\n    | ^^^^^^^^^^^^^^^^^^^^\n-...\n+LL |\n LL |     A(ElemDerived)\n    |       ----------- recursive without indirection\n    |\n@@ -12,20 +12,6 @@ help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n LL |     A(Box<ElemDerived>)\n    |       ++++           +\n \n-error[E0391]: cycle detected when computing drop-check constraints for `ElemDerived`\n-  --> $DIR/issue-72554.rs:4:1\n-   |\n-LL | pub enum ElemDerived {\n-   | ^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: ...which immediately requires computing drop-check constraints for `ElemDerived` again\n-note: cycle used when computing drop-check constraints for `Elem`\n-  --> $DIR/issue-72554.rs:11:1\n-   |\n-LL | pub enum Elem {\n-   | ^^^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0072, E0391.\n-For more information about an error, try `rustc --explain E0072`.\n+For more information about this error, try `rustc --explain E0072`."}, {"sha": "6c2c24ddbc7283a9f79d636724835a5e32a56d52", "filename": "src/test/ui/variance/variance-regions-unused-indirect.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Ftest%2Fui%2Fvariance%2Fvariance-regions-unused-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Ftest%2Fui%2Fvariance%2Fvariance-regions-unused-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvariance%2Fvariance-regions-unused-indirect.rs?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -1,6 +1,7 @@\n // Test that disallow lifetime parameters that are unused.\n \n enum Foo<'a> { //~ ERROR parameter `'a` is never used\n+    //~^ ERROR recursive types `Foo` and `Bar` have infinite size\n     Foo1(Bar<'a>)\n }\n "}, {"sha": "14fdd849294b10e4476fb037226948e988aceabe", "filename": "src/test/ui/variance/variance-regions-unused-indirect.stderr", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Ftest%2Fui%2Fvariance%2Fvariance-regions-unused-indirect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/src%2Ftest%2Fui%2Fvariance%2Fvariance-regions-unused-indirect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvariance%2Fvariance-regions-unused-indirect.stderr?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -1,3 +1,26 @@\n+error[E0072]: recursive types `Foo` and `Bar` have infinite size\n+  --> $DIR/variance-regions-unused-indirect.rs:3:1\n+   |\n+LL | enum Foo<'a> {\n+   | ^^^^^^^^^^^^\n+LL |\n+LL |     Foo1(Bar<'a>)\n+   |          ------- recursive without indirection\n+...\n+LL | enum Bar<'a> {\n+   | ^^^^^^^^^^^^\n+LL |     Bar1(Foo<'a>)\n+   |          ------- recursive without indirection\n+   |\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n+   |\n+LL ~     Foo1(Box<Bar<'a>>)\n+LL | }\n+LL | \n+LL | enum Bar<'a> {\n+LL ~     Bar1(Box<Foo<'a>>)\n+   |\n+\n error[E0392]: parameter `'a` is never used\n   --> $DIR/variance-regions-unused-indirect.rs:3:10\n    |\n@@ -7,13 +30,14 @@ LL | enum Foo<'a> {\n    = help: consider removing `'a`, referring to it in a field, or using a marker such as `PhantomData`\n \n error[E0392]: parameter `'a` is never used\n-  --> $DIR/variance-regions-unused-indirect.rs:7:10\n+  --> $DIR/variance-regions-unused-indirect.rs:8:10\n    |\n LL | enum Bar<'a> {\n    |          ^^ unused parameter\n    |\n    = help: consider removing `'a`, referring to it in a field, or using a marker such as `PhantomData`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 3 previous errors\n \n-For more information about this error, try `rustc --explain E0392`.\n+Some errors have detailed explanations: E0072, E0392.\n+For more information about an error, try `rustc --explain E0072`."}, {"sha": "181fb1de9305511c3b7dfee465277f5b3bafa73a", "filename": "triagebot.toml", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/triagebot.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e6ce5627a9e8af9ae4673a390954fffaf526e5cc/triagebot.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/triagebot.toml?ref=e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "patch": "@@ -189,6 +189,11 @@ trigger_files = [\n     \"src/tools/bump-stage0\",\n ]\n \n+[autolabel.\"T-style\"]\n+trigger_files = [\n+    \"src/doc/style-guide\",\n+]\n+\n [autolabel.\"A-translation\"]\n trigger_files = [\n     \"compiler/rustc_error_messages\","}]}