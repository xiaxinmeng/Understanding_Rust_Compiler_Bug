{"sha": "70fd012439d75fd6ce561a6518b9b8fd399f455f", "node_id": "C_kwDOAAsO6NoAKDcwZmQwMTI0MzlkNzVmZDZjZTU2MWE2NTE4YjliOGZkMzk5ZjQ1NWY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-26T02:04:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-26T02:04:23Z"}, "message": "Auto merge of #108473 - matthiaskrgr:rollup-qjyae58, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #107062 (Do some cleanup of doc/index.md)\n - #107890 (Lint against `Iterator::map` receiving a callable that returns `()`)\n - #108431 (Add regression test for #107918)\n - #108432 (test: drop unused deps)\n - #108436 (make \"proc macro panicked\" translatable)\n - #108444 (docs/test: add UI test and docs for `E0476`)\n - #108449 (Do not lint ineffective unstable trait impl for unresolved trait)\n - #108456 (Complete migrating `ast_passes` to derive diagnostics)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "3460e49200b4697ae0acc1a036f3ba3762e47c2d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3460e49200b4697ae0acc1a036f3ba3762e47c2d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70fd012439d75fd6ce561a6518b9b8fd399f455f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70fd012439d75fd6ce561a6518b9b8fd399f455f", "html_url": "https://github.com/rust-lang/rust/commit/70fd012439d75fd6ce561a6518b9b8fd399f455f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70fd012439d75fd6ce561a6518b9b8fd399f455f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f37f9f6512cb6b295acb70938302704a80c29b2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f37f9f6512cb6b295acb70938302704a80c29b2b", "html_url": "https://github.com/rust-lang/rust/commit/f37f9f6512cb6b295acb70938302704a80c29b2b"}, {"sha": "767c865f0751e65a6cbb231449c24116f82b4d4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/767c865f0751e65a6cbb231449c24116f82b4d4e", "html_url": "https://github.com/rust-lang/rust/commit/767c865f0751e65a6cbb231449c24116f82b4d4e"}], "stats": {"total": 1908, "additions": 1394, "deletions": 514}, "files": [{"sha": "a226a10f89d4f20c39b952800c0345b6314a11a4", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -5497,10 +5497,8 @@ dependencies = [\n name = \"test\"\n version = \"0.0.0\"\n dependencies = [\n- \"cfg-if\",\n  \"core\",\n  \"getopts\",\n- \"libc\",\n  \"panic_abort\",\n  \"panic_unwind\",\n  \"proc_macro\","}, {"sha": "747bd52b22c7d6b14fe9ffdb88d5a4bdd4877113", "filename": "compiler/rustc_ast_passes/locales/en-US.ftl", "status": "modified", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/compiler%2Frustc_ast_passes%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/compiler%2Frustc_ast_passes%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Flocales%2Fen-US.ftl?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -87,3 +87,150 @@ ast_passes_fn_without_body =\n     .suggestion = provide a definition for the function\n \n ast_passes_extern_block_suggestion = if you meant to declare an externally defined function, use an `extern` block\n+\n+ast_passes_bound_in_context = bounds on `type`s in {$ctx} have no effect\n+\n+ast_passes_extern_types_cannot = `type`s inside `extern` blocks cannot have {$descr}\n+    .suggestion = remove the {$remove_descr}\n+    .label = `extern` block begins here\n+\n+ast_passes_extern_keyword_link = for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+ast_passes_body_in_extern = incorrect `{$kind}` inside `extern` block\n+    .cannot_have = cannot have a body\n+    .invalid = the invalid body\n+    .existing = `extern` blocks define existing foreign {$kind}s and {$kind}s inside of them cannot have a body\n+\n+ast_passes_fn_body_extern = incorrect function inside `extern` block\n+    .cannot_have = cannot have a body\n+    .suggestion = remove the invalid body\n+    .help = you might have meant to write a function accessible through FFI, which can be done by writing `extern fn` outside of the `extern` block\n+    .label = `extern` blocks define existing foreign functions and functions inside of them cannot have a body\n+\n+ast_passes_extern_fn_qualifiers = functions in `extern` blocks cannot have qualifiers\n+    .label = in this `extern` block\n+    .suggestion = remove the qualifiers\n+\n+ast_passes_extern_item_ascii = items in `extern` blocks cannot use non-ascii identifiers\n+    .label = in this `extern` block\n+    .note = this limitation may be lifted in the future; see issue #83942 <https://github.com/rust-lang/rust/issues/83942> for more information\n+\n+ast_passes_bad_c_variadic = only foreign or `unsafe extern \"C\"` functions may be C-variadic\n+\n+ast_passes_item_underscore = `{$kind}` items in this context need a name\n+    .label = `_` is not a valid name for this `{$kind}` item\n+\n+ast_passes_nomangle_ascii = `#[no_mangle]` requires ASCII identifier\n+\n+ast_passes_module_nonascii = trying to load file for module `{$name}` with non-ascii identifier name\n+    .help = consider using the `#[path]` attribute to specify filesystem path\n+\n+ast_passes_auto_generic = auto traits cannot have generic parameters\n+    .label = auto trait cannot have generic parameters\n+    .suggestion = remove the parameters\n+\n+ast_passes_auto_super_lifetime = auto traits cannot have super traits or lifetime bounds\n+    .label = {ast_passes_auto_super_lifetime}\n+    .suggestion = remove the super traits or lifetime bounds\n+\n+ast_passes_auto_items = auto traits cannot have associated items\n+    .label = {ast_passes_auto_items}\n+    .suggestion = remove these associated items\n+\n+ast_passes_generic_before_constraints = generic arguments must come before the first constraint\n+    .constraints = {$constraint_len ->\n+    [one] constraint\n+    *[other] constraints\n+    }\n+    .args = generic {$args_len ->\n+    [one] argument\n+    *[other] arguments\n+    }\n+    .empty_string = {\"\"},\n+    .suggestion = move the {$constraint_len ->\n+    [one] constraint\n+    *[other] constraints\n+    } after the generic {$args_len ->\n+    [one] argument\n+    *[other] arguments\n+    }\n+\n+ast_passes_pattern_in_fn_pointer = patterns aren't allowed in function pointer types\n+\n+ast_passes_trait_object_single_bound = only a single explicit lifetime bound is permitted\n+\n+ast_passes_impl_trait_path = `impl Trait` is not allowed in path parameters\n+\n+ast_passes_nested_impl_trait = nested `impl Trait` is not allowed\n+    .outer = outer `impl Trait`\n+    .inner = nested `impl Trait` here\n+\n+ast_passes_at_least_one_trait = at least one trait must be specified\n+\n+ast_passes_extern_without_abi = extern declarations without an explicit ABI are deprecated\n+\n+ast_passes_out_of_order_params = {$param_ord} parameters must be declared prior to {$max_param} parameters\n+    .suggestion = reorder the parameters: lifetimes, then consts and types\n+\n+ast_passes_obsolete_auto = `impl Trait for .. {\"{}\"}` is an obsolete syntax\n+    .help = use `auto trait Trait {\"{}\"}` instead\n+\n+ast_passes_unsafe_negative_impl = negative impls cannot be unsafe\n+    .negative = negative because of this\n+    .unsafe = unsafe because of this\n+\n+ast_passes_inherent_cannot_be = inherent impls cannot be {$annotation}\n+    .because = {$annotation} because of this\n+    .type = inherent impl for this type\n+    .only_trait = only trait implementations may be annotated with {$annotation}\n+\n+ast_passes_unsafe_item = {$kind} cannot be declared unsafe\n+\n+ast_passes_fieldless_union = unions cannot have zero fields\n+\n+ast_passes_where_after_type_alias = where clauses are not allowed after the type for type aliases\n+    .note = see issue #89122 <https://github.com/rust-lang/rust/issues/89122> for more information\n+\n+ast_passes_generic_default_trailing = generic parameters with a default must be trailing\n+\n+ast_passes_nested_lifetimes = nested quantification of lifetimes\n+\n+ast_passes_optional_trait_supertrait = `?Trait` is not permitted in supertraits\n+    .note = traits are `?{$path_str}` by default\n+\n+ast_passes_optional_trait_object = `?Trait` is not permitted in trait object types\n+\n+ast_passes_tilde_const_disallowed = `~const` is not allowed here\n+    .trait = trait objects cannot have `~const` trait bounds\n+    .closure = closures cannot have `~const` trait bounds\n+    .function = this function is not `const`, so it cannot have `~const` trait bounds\n+\n+ast_passes_optional_const_exclusive = `~const` and `?` are mutually exclusive\n+\n+ast_passes_const_and_async = functions cannot be both `const` and `async`\n+    .const = `const` because of this\n+    .async = `async` because of this\n+    .label = {\"\"}\n+\n+ast_passes_pattern_in_foreign = patterns aren't allowed in foreign function declarations\n+    .label = pattern not allowed in foreign function\n+\n+ast_passes_pattern_in_bodiless = patterns aren't allowed in functions without bodies\n+    .label = pattern not allowed in function without body\n+\n+ast_passes_equality_in_where = equality constraints are not yet supported in `where` clauses\n+    .label = not supported\n+    .suggestion = if `{$ident}` is an associated type you're trying to set, use the associated type binding syntax\n+    .suggestion_path = if `{$trait_segment}::{$potential_assoc}` is an associated type you're trying to set, use the associated type binding syntax\n+    .note = see issue #20041 <https://github.com/rust-lang/rust/issues/20041> for more information\n+\n+ast_passes_stability_outside_std = stability attributes may not be used outside of the standard library\n+\n+ast_passes_feature_on_non_nightly = `#![feature]` may not be used on the {$channel} release channel\n+    .suggestion = remove the attribute\n+    .stable_since = the feature `{$name}` has been stable since `{$since}` and no longer requires an attribute to enable\n+\n+ast_passes_incompatbile_features = `{$f1}` and `{$f2}` are incompatible, using them at the same time is not allowed\n+    .help = remove one of these features\n+\n+ast_passes_show_span = {$msg}"}, {"sha": "1c561375626cf2d3325c3370ddf57a6727605f28", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 176, "deletions": 382, "changes": 558, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -13,7 +13,6 @@ use rustc_ast::walk_list;\n use rustc_ast::*;\n use rustc_ast_pretty::pprust::{self, State};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{error_code, pluralize, struct_span_err, Applicability};\n use rustc_macros::Subdiagnostic;\n use rustc_parse::validate_attr;\n use rustc_session::lint::builtin::{\n@@ -29,12 +28,9 @@ use std::mem;\n use std::ops::{Deref, DerefMut};\n use thin_vec::thin_vec;\n \n-use crate::errors::*;\n+use crate::errors;\n use crate::fluent_generated as fluent;\n \n-const MORE_EXTERN: &str =\n-    \"for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\";\n-\n /// Is `self` allowed semantically as the first parameter in an `FnDecl`?\n enum SelfSemantic {\n     Yes,\n@@ -134,9 +130,9 @@ impl<'a> AstValidator<'a> {\n     fn ban_let_expr(&self, expr: &'a Expr, forbidden_let_reason: ForbiddenLetReason) {\n         let sess = &self.session;\n         if sess.opts.unstable_features.is_nightly_build() {\n-            sess.emit_err(ForbiddenLet { span: expr.span, reason: forbidden_let_reason });\n+            sess.emit_err(errors::ForbiddenLet { span: expr.span, reason: forbidden_let_reason });\n         } else {\n-            sess.emit_err(ForbiddenLetStable { span: expr.span });\n+            sess.emit_err(errors::ForbiddenLetStable { span: expr.span });\n         }\n     }\n \n@@ -234,22 +230,22 @@ impl<'a> AstValidator<'a> {\n     fn check_lifetime(&self, ident: Ident) {\n         let valid_names = [kw::UnderscoreLifetime, kw::StaticLifetime, kw::Empty];\n         if !valid_names.contains(&ident.name) && ident.without_first_quote().is_reserved() {\n-            self.session.emit_err(KeywordLifetime { span: ident.span });\n+            self.session.emit_err(errors::KeywordLifetime { span: ident.span });\n         }\n     }\n \n     fn check_label(&self, ident: Ident) {\n         if ident.without_first_quote().is_reserved() {\n-            self.session.emit_err(InvalidLabel { span: ident.span, name: ident.name });\n+            self.session.emit_err(errors::InvalidLabel { span: ident.span, name: ident.name });\n         }\n     }\n \n-    fn invalid_visibility(&self, vis: &Visibility, note: Option<InvalidVisibilityNote>) {\n+    fn invalid_visibility(&self, vis: &Visibility, note: Option<errors::InvalidVisibilityNote>) {\n         if let VisibilityKind::Inherited = vis.kind {\n             return;\n         }\n \n-        self.session.emit_err(InvalidVisibility {\n+        self.session.emit_err(errors::InvalidVisibility {\n             span: vis.span,\n             implied: vis.kind.is_pub().then_some(vis.span),\n             note,\n@@ -270,7 +266,7 @@ impl<'a> AstValidator<'a> {\n \n     fn check_trait_fn_not_const(&self, constness: Const) {\n         if let Const::Yes(span) = constness {\n-            self.session.emit_err(TraitFnConst { span });\n+            self.session.emit_err(errors::TraitFnConst { span });\n         }\n     }\n \n@@ -287,21 +283,21 @@ impl<'a> AstValidator<'a> {\n         let max_num_args: usize = u16::MAX.into();\n         if fn_decl.inputs.len() > max_num_args {\n             let Param { span, .. } = fn_decl.inputs[0];\n-            self.session.emit_fatal(FnParamTooMany { span, max_num_args });\n+            self.session.emit_fatal(errors::FnParamTooMany { span, max_num_args });\n         }\n     }\n \n     fn check_decl_cvaradic_pos(&self, fn_decl: &FnDecl) {\n         match &*fn_decl.inputs {\n             [Param { ty, span, .. }] => {\n                 if let TyKind::CVarArgs = ty.kind {\n-                    self.session.emit_err(FnParamCVarArgsOnly { span: *span });\n+                    self.session.emit_err(errors::FnParamCVarArgsOnly { span: *span });\n                 }\n             }\n             [ps @ .., _] => {\n                 for Param { ty, span, .. } in ps {\n                     if let TyKind::CVarArgs = ty.kind {\n-                        self.session.emit_err(FnParamCVarArgsNotLast { span: *span });\n+                        self.session.emit_err(errors::FnParamCVarArgsNotLast { span: *span });\n                     }\n                 }\n             }\n@@ -328,25 +324,25 @@ impl<'a> AstValidator<'a> {\n             })\n             .for_each(|attr| {\n                 if attr.is_doc_comment() {\n-                    self.session.emit_err(FnParamDocComment { span: attr.span });\n+                    self.session.emit_err(errors::FnParamDocComment { span: attr.span });\n                 } else {\n-                    self.session.emit_err(FnParamForbiddenAttr { span: attr.span });\n+                    self.session.emit_err(errors::FnParamForbiddenAttr { span: attr.span });\n                 }\n             });\n     }\n \n     fn check_decl_self_param(&self, fn_decl: &FnDecl, self_semantic: SelfSemantic) {\n         if let (SelfSemantic::No, [param, ..]) = (self_semantic, &*fn_decl.inputs) {\n             if param.is_self() {\n-                self.session.emit_err(FnParamForbiddenSelf { span: param.span });\n+                self.session.emit_err(errors::FnParamForbiddenSelf { span: param.span });\n             }\n         }\n     }\n \n     fn check_defaultness(&self, span: Span, defaultness: Defaultness) {\n         if let Defaultness::Default(def_span) = defaultness {\n             let span = self.session.source_map().guess_head_span(span);\n-            self.session.emit_err(ForbiddenDefault { span, def_span });\n+            self.session.emit_err(errors::ForbiddenDefault { span, def_span });\n         }\n     }\n \n@@ -369,27 +365,17 @@ impl<'a> AstValidator<'a> {\n             [b0] => b0.span(),\n             [b0, .., bl] => b0.span().to(bl.span()),\n         };\n-        self.err_handler()\n-            .struct_span_err(span, &format!(\"bounds on `type`s in {} have no effect\", ctx))\n-            .emit();\n+        self.err_handler().emit_err(errors::BoundInContext { span, ctx });\n     }\n \n     fn check_foreign_ty_genericless(&self, generics: &Generics, where_span: Span) {\n         let cannot_have = |span, descr, remove_descr| {\n-            self.err_handler()\n-                .struct_span_err(\n-                    span,\n-                    &format!(\"`type`s inside `extern` blocks cannot have {}\", descr),\n-                )\n-                .span_suggestion(\n-                    span,\n-                    &format!(\"remove the {}\", remove_descr),\n-                    \"\",\n-                    Applicability::MaybeIncorrect,\n-                )\n-                .span_label(self.current_extern_span(), \"`extern` block begins here\")\n-                .note(MORE_EXTERN)\n-                .emit();\n+            self.err_handler().emit_err(errors::ExternTypesCannotHave {\n+                span,\n+                descr,\n+                remove_descr,\n+                block_span: self.current_extern_span(),\n+            });\n         };\n \n         if !generics.params.is_empty() {\n@@ -405,47 +391,24 @@ impl<'a> AstValidator<'a> {\n         let Some(body) = body else {\n             return;\n         };\n-        self.err_handler()\n-            .struct_span_err(ident.span, &format!(\"incorrect `{}` inside `extern` block\", kind))\n-            .span_label(ident.span, \"cannot have a body\")\n-            .span_label(body, \"the invalid body\")\n-            .span_label(\n-                self.current_extern_span(),\n-                format!(\n-                    \"`extern` blocks define existing foreign {0}s and {0}s \\\n-                    inside of them cannot have a body\",\n-                    kind\n-                ),\n-            )\n-            .note(MORE_EXTERN)\n-            .emit();\n+        self.err_handler().emit_err(errors::BodyInExtern {\n+            span: ident.span,\n+            body,\n+            block: self.current_extern_span(),\n+            kind,\n+        });\n     }\n \n     /// An `fn` in `extern { ... }` cannot have a body `{ ... }`.\n     fn check_foreign_fn_bodyless(&self, ident: Ident, body: Option<&Block>) {\n         let Some(body) = body else {\n             return;\n         };\n-        self.err_handler()\n-            .struct_span_err(ident.span, \"incorrect function inside `extern` block\")\n-            .span_label(ident.span, \"cannot have a body\")\n-            .span_suggestion(\n-                body.span,\n-                \"remove the invalid body\",\n-                \";\",\n-                Applicability::MaybeIncorrect,\n-            )\n-            .help(\n-                \"you might have meant to write a function accessible through FFI, \\\n-                which can be done by writing `extern fn` outside of the `extern` block\",\n-            )\n-            .span_label(\n-                self.current_extern_span(),\n-                \"`extern` blocks define existing foreign functions and functions \\\n-                inside of them cannot have a body\",\n-            )\n-            .note(MORE_EXTERN)\n-            .emit();\n+        self.err_handler().emit_err(errors::FnBodyInExtern {\n+            span: ident.span,\n+            body: body.span,\n+            block: self.current_extern_span(),\n+        });\n     }\n \n     fn current_extern_span(&self) -> Span {\n@@ -455,34 +418,21 @@ impl<'a> AstValidator<'a> {\n     /// An `fn` in `extern { ... }` cannot have qualifiers, e.g. `async fn`.\n     fn check_foreign_fn_headerless(&self, ident: Ident, span: Span, header: FnHeader) {\n         if header.has_qualifiers() {\n-            self.err_handler()\n-                .struct_span_err(ident.span, \"functions in `extern` blocks cannot have qualifiers\")\n-                .span_label(self.current_extern_span(), \"in this `extern` block\")\n-                .span_suggestion_verbose(\n-                    span.until(ident.span.shrink_to_lo()),\n-                    \"remove the qualifiers\",\n-                    \"fn \",\n-                    Applicability::MaybeIncorrect,\n-                )\n-                .emit();\n+            self.err_handler().emit_err(errors::FnQualifierInExtern {\n+                span: ident.span,\n+                block: self.current_extern_span(),\n+                sugg_span: span.until(ident.span.shrink_to_lo()),\n+            });\n         }\n     }\n \n     /// An item in `extern { ... }` cannot use non-ascii identifier.\n     fn check_foreign_item_ascii_only(&self, ident: Ident) {\n         if !ident.as_str().is_ascii() {\n-            let n = 83942;\n-            self.err_handler()\n-                .struct_span_err(\n-                    ident.span,\n-                    \"items in `extern` blocks cannot use non-ascii identifiers\",\n-                )\n-                .span_label(self.current_extern_span(), \"in this `extern` block\")\n-                .note(&format!(\n-                    \"this limitation may be lifted in the future; see issue #{} <https://github.com/rust-lang/rust/issues/{}> for more information\",\n-                    n, n,\n-                ))\n-                .emit();\n+            self.err_handler().emit_err(errors::ExternItemAscii {\n+                span: ident.span,\n+                block: self.current_extern_span(),\n+            });\n         }\n     }\n \n@@ -505,12 +455,7 @@ impl<'a> AstValidator<'a> {\n \n         for Param { ty, span, .. } in &fk.decl().inputs {\n             if let TyKind::CVarArgs = ty.kind {\n-                self.err_handler()\n-                    .struct_span_err(\n-                        *span,\n-                        \"only foreign or `unsafe extern \\\"C\\\"` functions may be C-variadic\",\n-                    )\n-                    .emit();\n+                self.err_handler().emit_err(errors::BadCVariadic { span: *span });\n             }\n         }\n     }\n@@ -519,75 +464,32 @@ impl<'a> AstValidator<'a> {\n         if ident.name != kw::Underscore {\n             return;\n         }\n-        self.err_handler()\n-            .struct_span_err(ident.span, &format!(\"`{}` items in this context need a name\", kind))\n-            .span_label(ident.span, format!(\"`_` is not a valid name for this `{}` item\", kind))\n-            .emit();\n+        self.err_handler().emit_err(errors::ItemUnderscore { span: ident.span, kind });\n     }\n \n     fn check_nomangle_item_asciionly(&self, ident: Ident, item_span: Span) {\n         if ident.name.as_str().is_ascii() {\n             return;\n         }\n-        let head_span = self.session.source_map().guess_head_span(item_span);\n-        struct_span_err!(\n-            self.session,\n-            head_span,\n-            E0754,\n-            \"`#[no_mangle]` requires ASCII identifier\"\n-        )\n-        .emit();\n+        let span = self.session.source_map().guess_head_span(item_span);\n+        self.session.emit_err(errors::NoMangleAscii { span });\n     }\n \n     fn check_mod_file_item_asciionly(&self, ident: Ident) {\n         if ident.name.as_str().is_ascii() {\n             return;\n         }\n-        struct_span_err!(\n-            self.session,\n-            ident.span,\n-            E0754,\n-            \"trying to load file for module `{}` with non-ascii identifier name\",\n-            ident.name\n-        )\n-        .help(\"consider using `#[path]` attribute to specify filesystem path\")\n-        .emit();\n+        self.session.emit_err(errors::ModuleNonAscii { span: ident.span, name: ident.name });\n     }\n \n-    fn deny_generic_params(&self, generics: &Generics, ident_span: Span) {\n+    fn deny_generic_params(&self, generics: &Generics, ident: Span) {\n         if !generics.params.is_empty() {\n-            struct_span_err!(\n-                self.session,\n-                generics.span,\n-                E0567,\n-                \"auto traits cannot have generic parameters\"\n-            )\n-            .span_label(ident_span, \"auto trait cannot have generic parameters\")\n-            .span_suggestion(\n-                generics.span,\n-                \"remove the parameters\",\n-                \"\",\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+            self.session.emit_err(errors::AutoTraitGeneric { span: generics.span, ident });\n         }\n     }\n \n-    fn emit_e0568(&self, span: Span, ident_span: Span) {\n-        struct_span_err!(\n-            self.session,\n-            span,\n-            E0568,\n-            \"auto traits cannot have super traits or lifetime bounds\"\n-        )\n-        .span_label(ident_span, \"auto trait cannot have super traits or lifetime bounds\")\n-        .span_suggestion(\n-            span,\n-            \"remove the super traits or lifetime bounds\",\n-            \"\",\n-            Applicability::MachineApplicable,\n-        )\n-        .emit();\n+    fn emit_e0568(&self, span: Span, ident: Span) {\n+        self.session.emit_err(errors::AutoTraitBounds { span, ident });\n     }\n \n     fn deny_super_traits(&self, bounds: &GenericBounds, ident_span: Span) {\n@@ -603,24 +505,11 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n-    fn deny_items(&self, trait_items: &[P<AssocItem>], ident_span: Span) {\n+    fn deny_items(&self, trait_items: &[P<AssocItem>], ident: Span) {\n         if !trait_items.is_empty() {\n             let spans: Vec<_> = trait_items.iter().map(|i| i.ident.span).collect();\n-            let total_span = trait_items.first().unwrap().span.to(trait_items.last().unwrap().span);\n-            struct_span_err!(\n-                self.session,\n-                spans,\n-                E0380,\n-                \"auto traits cannot have associated items\"\n-            )\n-            .span_suggestion(\n-                total_span,\n-                \"remove these associated items\",\n-                \"\",\n-                Applicability::MachineApplicable,\n-            )\n-            .span_label(ident_span, \"auto trait cannot have associated items\")\n-            .emit();\n+            let total = trait_items.first().unwrap().span.to(trait_items.last().unwrap().span);\n+            self.session.emit_err(errors::AutoTraitItems { spans, total, ident });\n         }\n     }\n \n@@ -666,43 +555,25 @@ impl<'a> AstValidator<'a> {\n         let args_len = arg_spans.len();\n         let constraint_len = constraint_spans.len();\n         // ...and then error:\n-        self.err_handler()\n-            .struct_span_err(\n-                arg_spans.clone(),\n-                \"generic arguments must come before the first constraint\",\n-            )\n-            .span_label(constraint_spans[0], &format!(\"constraint{}\", pluralize!(constraint_len)))\n-            .span_label(\n-                *arg_spans.iter().last().unwrap(),\n-                &format!(\"generic argument{}\", pluralize!(args_len)),\n-            )\n-            .span_labels(constraint_spans, \"\")\n-            .span_labels(arg_spans, \"\")\n-            .span_suggestion_verbose(\n-                data.span,\n-                &format!(\n-                    \"move the constraint{} after the generic argument{}\",\n-                    pluralize!(constraint_len),\n-                    pluralize!(args_len)\n-                ),\n-                self.correct_generic_order_suggestion(&data),\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+        self.err_handler().emit_err(errors::ArgsBeforeConstraint {\n+            arg_spans: arg_spans.clone(),\n+            constraints: constraint_spans[0],\n+            args: *arg_spans.iter().last().unwrap(),\n+            data: data.span,\n+            constraint_spans: errors::EmptyLabelManySpans(constraint_spans),\n+            arg_spans2: errors::EmptyLabelManySpans(arg_spans),\n+            suggestion: self.correct_generic_order_suggestion(&data),\n+            constraint_len,\n+            args_len,\n+        });\n     }\n \n     fn visit_ty_common(&mut self, ty: &'a Ty) {\n         match &ty.kind {\n             TyKind::BareFn(bfty) => {\n                 self.check_fn_decl(&bfty.decl, SelfSemantic::No);\n                 Self::check_decl_no_pat(&bfty.decl, |span, _, _| {\n-                    struct_span_err!(\n-                        self.session,\n-                        span,\n-                        E0561,\n-                        \"patterns aren't allowed in function pointer types\"\n-                    )\n-                    .emit();\n+                    self.session.emit_err(errors::PatternFnPointer { span });\n                 });\n                 if let Extern::Implicit(_) = bfty.ext {\n                     let sig_span = self.session.source_map().next_point(ty.span.shrink_to_lo());\n@@ -714,13 +585,8 @@ impl<'a> AstValidator<'a> {\n                 for bound in bounds {\n                     if let GenericBound::Outlives(lifetime) = bound {\n                         if any_lifetime_bounds {\n-                            struct_span_err!(\n-                                self.session,\n-                                lifetime.ident.span,\n-                                E0226,\n-                                \"only a single explicit lifetime bound is permitted\"\n-                            )\n-                            .emit();\n+                            self.session\n+                                .emit_err(errors::TraitObjectBound { span: lifetime.ident.span });\n                             break;\n                         }\n                         any_lifetime_bounds = true;\n@@ -729,29 +595,19 @@ impl<'a> AstValidator<'a> {\n             }\n             TyKind::ImplTrait(_, bounds) => {\n                 if self.is_impl_trait_banned {\n-                    struct_span_err!(\n-                        self.session,\n-                        ty.span,\n-                        E0667,\n-                        \"`impl Trait` is not allowed in path parameters\"\n-                    )\n-                    .emit();\n+                    self.session.emit_err(errors::ImplTraitPath { span: ty.span });\n                 }\n \n                 if let Some(outer_impl_trait_sp) = self.outer_impl_trait {\n-                    struct_span_err!(\n-                        self.session,\n-                        ty.span,\n-                        E0666,\n-                        \"nested `impl Trait` is not allowed\"\n-                    )\n-                    .span_label(outer_impl_trait_sp, \"outer `impl Trait`\")\n-                    .span_label(ty.span, \"nested `impl Trait` here\")\n-                    .emit();\n+                    self.session.emit_err(errors::NestedImplTrait {\n+                        span: ty.span,\n+                        outer: outer_impl_trait_sp,\n+                        inner: ty.span,\n+                    });\n                 }\n \n                 if !bounds.iter().any(|b| matches!(b, GenericBound::Trait(..))) {\n-                    self.err_handler().span_err(ty.span, \"at least one trait must be specified\");\n+                    self.err_handler().emit_err(errors::AtLeastOneTrait { span: ty.span });\n                 }\n             }\n             _ => {}\n@@ -772,7 +628,7 @@ impl<'a> AstValidator<'a> {\n                 MISSING_ABI,\n                 id,\n                 span,\n-                \"extern declarations without an explicit ABI are deprecated\",\n+                fluent::ast_passes_extern_without_abi,\n                 BuiltinLintDiagnostics::MissingAbi(span, abi::Abi::FALLBACK),\n             )\n         }\n@@ -845,20 +701,13 @@ fn validate_generic_param_order(\n         ordered_params += \">\";\n \n         for (param_ord, (max_param, spans)) in &out_of_order {\n-            let mut err = handler.struct_span_err(\n-                spans.clone(),\n-                &format!(\n-                    \"{} parameters must be declared prior to {} parameters\",\n-                    param_ord, max_param,\n-                ),\n-            );\n-            err.span_suggestion(\n-                span,\n-                \"reorder the parameters: lifetimes, then consts and types\",\n-                &ordered_params,\n-                Applicability::MachineApplicable,\n-            );\n-            err.emit();\n+            handler.emit_err(errors::OutOfOrderParams {\n+                spans: spans.clone(),\n+                sugg_span: span,\n+                param_ord,\n+                max_param,\n+                ordered_params: &ordered_params,\n+            });\n         }\n     }\n }\n@@ -972,25 +821,15 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 self.with_in_trait_impl(true, Some(*constness), |this| {\n                     this.invalid_visibility(&item.vis, None);\n                     if let TyKind::Err = self_ty.kind {\n-                        this.err_handler()\n-                            .struct_span_err(\n-                                item.span,\n-                                \"`impl Trait for .. {}` is an obsolete syntax\",\n-                            )\n-                            .help(\"use `auto trait Trait {}` instead\")\n-                            .emit();\n+                        this.err_handler().emit_err(errors::ObsoleteAuto { span: item.span });\n                     }\n                     if let (&Unsafe::Yes(span), &ImplPolarity::Negative(sp)) = (unsafety, polarity)\n                     {\n-                        struct_span_err!(\n-                            this.session,\n-                            sp.to(t.path.span),\n-                            E0198,\n-                            \"negative impls cannot be unsafe\"\n-                        )\n-                        .span_label(sp, \"negative because of this\")\n-                        .span_label(span, \"unsafe because of this\")\n-                        .emit();\n+                        this.session.emit_err(errors::UnsafeNegativeImpl {\n+                            span: sp.to(t.path.span),\n+                            negative: sp,\n+                            r#unsafe: span,\n+                        });\n                     }\n \n                     this.visit_vis(&item.vis);\n@@ -1018,52 +857,54 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 self_ty,\n                 items: _,\n             }) => {\n-                let error = |annotation_span, annotation| {\n-                    let mut err = self.err_handler().struct_span_err(\n-                        self_ty.span,\n-                        &format!(\"inherent impls cannot be {}\", annotation),\n-                    );\n-                    err.span_label(annotation_span, &format!(\"{} because of this\", annotation));\n-                    err.span_label(self_ty.span, \"inherent impl for this type\");\n-                    err\n-                };\n+                let error =\n+                    |annotation_span, annotation, only_trait: bool| errors::InherentImplCannot {\n+                        span: self_ty.span,\n+                        annotation_span,\n+                        annotation,\n+                        self_ty: self_ty.span,\n+                        only_trait: only_trait.then_some(()),\n+                    };\n \n                 self.invalid_visibility(\n                     &item.vis,\n-                    Some(InvalidVisibilityNote::IndividualImplItems),\n+                    Some(errors::InvalidVisibilityNote::IndividualImplItems),\n                 );\n                 if let &Unsafe::Yes(span) = unsafety {\n-                    error(span, \"unsafe\").code(error_code!(E0197)).emit();\n+                    self.err_handler().emit_err(errors::InherentImplCannotUnsafe {\n+                        span: self_ty.span,\n+                        annotation_span: span,\n+                        annotation: \"unsafe\",\n+                        self_ty: self_ty.span,\n+                    });\n                 }\n                 if let &ImplPolarity::Negative(span) = polarity {\n-                    error(span, \"negative\").emit();\n+                    self.err_handler().emit_err(error(span, \"negative\", false));\n                 }\n                 if let &Defaultness::Default(def_span) = defaultness {\n-                    error(def_span, \"`default`\")\n-                        .note(\"only trait implementations may be annotated with `default`\")\n-                        .emit();\n+                    self.err_handler().emit_err(error(def_span, \"`default`\", true));\n                 }\n                 if let &Const::Yes(span) = constness {\n-                    error(span, \"`const`\")\n-                        .note(\"only trait implementations may be annotated with `const`\")\n-                        .emit();\n+                    self.err_handler().emit_err(error(span, \"`const`\", true));\n                 }\n             }\n             ItemKind::Fn(box Fn { defaultness, sig, generics, body }) => {\n                 self.check_defaultness(item.span, *defaultness);\n \n                 if body.is_none() {\n-                    self.session.emit_err(FnWithoutBody {\n+                    self.session.emit_err(errors::FnWithoutBody {\n                         span: item.span,\n                         replace_span: self.ending_semi_or_hi(item.span),\n                         extern_block_suggestion: match sig.header.ext {\n                             Extern::None => None,\n-                            Extern::Implicit(start_span) => Some(ExternBlockSuggestion::Implicit {\n-                                start_span,\n-                                end_span: item.span.shrink_to_hi(),\n-                            }),\n+                            Extern::Implicit(start_span) => {\n+                                Some(errors::ExternBlockSuggestion::Implicit {\n+                                    start_span,\n+                                    end_span: item.span.shrink_to_hi(),\n+                                })\n+                            }\n                             Extern::Explicit(abi, start_span) => {\n-                                Some(ExternBlockSuggestion::Explicit {\n+                                Some(errors::ExternBlockSuggestion::Explicit {\n                                     start_span,\n                                     end_span: item.span.shrink_to_hi(),\n                                     abi: abi.symbol_unescaped,\n@@ -1085,10 +926,10 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 let old_item = mem::replace(&mut self.extern_mod, Some(item));\n                 self.invalid_visibility(\n                     &item.vis,\n-                    Some(InvalidVisibilityNote::IndividualForeignItems),\n+                    Some(errors::InvalidVisibilityNote::IndividualForeignItems),\n                 );\n                 if let &Unsafe::Yes(span) = unsafety {\n-                    self.err_handler().span_err(span, \"extern block cannot be declared unsafe\");\n+                    self.err_handler().emit_err(errors::UnsafeItem { span, kind: \"extern block\" });\n                 }\n                 if abi.is_none() {\n                     self.maybe_lint_missing_abi(item.span, item.id);\n@@ -1128,7 +969,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }\n             ItemKind::Mod(unsafety, mod_kind) => {\n                 if let &Unsafe::Yes(span) = unsafety {\n-                    self.err_handler().span_err(span, \"module cannot be declared unsafe\");\n+                    self.err_handler().emit_err(errors::UnsafeItem { span, kind: \"module\" });\n                 }\n                 // Ensure that `path` attributes on modules are recorded as used (cf. issue #35584).\n                 if !matches!(mod_kind, ModKind::Loaded(_, Inline::Yes, _))\n@@ -1139,40 +980,34 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }\n             ItemKind::Union(vdata, ..) => {\n                 if vdata.fields().is_empty() {\n-                    self.err_handler().span_err(item.span, \"unions cannot have zero fields\");\n+                    self.err_handler().emit_err(errors::FieldlessUnion { span: item.span });\n                 }\n             }\n             ItemKind::Const(def, .., None) => {\n                 self.check_defaultness(item.span, *def);\n-                self.session.emit_err(ConstWithoutBody {\n+                self.session.emit_err(errors::ConstWithoutBody {\n                     span: item.span,\n                     replace_span: self.ending_semi_or_hi(item.span),\n                 });\n             }\n             ItemKind::Static(.., None) => {\n-                self.session.emit_err(StaticWithoutBody {\n+                self.session.emit_err(errors::StaticWithoutBody {\n                     span: item.span,\n                     replace_span: self.ending_semi_or_hi(item.span),\n                 });\n             }\n             ItemKind::TyAlias(box TyAlias { defaultness, where_clauses, bounds, ty, .. }) => {\n                 self.check_defaultness(item.span, *defaultness);\n                 if ty.is_none() {\n-                    self.session.emit_err(TyAliasWithoutBody {\n+                    self.session.emit_err(errors::TyAliasWithoutBody {\n                         span: item.span,\n                         replace_span: self.ending_semi_or_hi(item.span),\n                     });\n                 }\n                 self.check_type_no_bounds(bounds, \"this context\");\n                 if where_clauses.1.0 {\n-                    let mut err = self.err_handler().struct_span_err(\n-                        where_clauses.1.1,\n-                        \"where clauses are not allowed after the type for type aliases\",\n-                    );\n-                    err.note(\n-                        \"see issue #89122 <https://github.com/rust-lang/rust/issues/89122> for more information\",\n-                    );\n-                    err.emit();\n+                    self.err_handler()\n+                        .emit_err(errors::WhereAfterTypeAlias { span: where_clauses.1.1 });\n                 }\n             }\n             _ => {}\n@@ -1254,11 +1089,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 }\n                 GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n                     if let Some(span) = prev_param_default {\n-                        let mut err = self.err_handler().struct_span_err(\n-                            span,\n-                            \"generic parameters with a default must be trailing\",\n-                        );\n-                        err.emit();\n+                        self.err_handler().emit_err(errors::GenericDefaultTrailing { span });\n                         break;\n                     }\n                 }\n@@ -1286,13 +1117,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                             match bound {\n                                 GenericBound::Trait(t, _) => {\n                                     if !t.bound_generic_params.is_empty() {\n-                                        struct_span_err!(\n-                                            self.err_handler(),\n-                                            t.span,\n-                                            E0316,\n-                                            \"nested quantification of lifetimes\"\n-                                        )\n-                                        .emit();\n+                                        self.err_handler()\n+                                            .emit_err(errors::NestedLifetimes { span: t.span });\n                                     }\n                                 }\n                                 GenericBound::Outlives(_) => {}\n@@ -1317,32 +1143,27 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         if let GenericBound::Trait(poly, modify) = bound {\n             match (ctxt, modify) {\n                 (BoundKind::SuperTraits, TraitBoundModifier::Maybe) => {\n-                    let mut err = self\n-                        .err_handler()\n-                        .struct_span_err(poly.span, \"`?Trait` is not permitted in supertraits\");\n-                    let path_str = pprust::path_to_string(&poly.trait_ref.path);\n-                    err.note(&format!(\"traits are `?{}` by default\", path_str));\n-                    err.emit();\n+                    self.err_handler().emit_err(errors::OptionalTraitSupertrait {\n+                        span: poly.span,\n+                        path_str: pprust::path_to_string(&poly.trait_ref.path)\n+                    });\n                 }\n                 (BoundKind::TraitObject, TraitBoundModifier::Maybe) => {\n-                    let mut err = self.err_handler().struct_span_err(\n-                        poly.span,\n-                        \"`?Trait` is not permitted in trait object types\",\n-                    );\n-                    err.emit();\n+                    self.err_handler().emit_err(errors::OptionalTraitObject {span: poly.span});\n                 }\n                 (_, TraitBoundModifier::MaybeConst) if let Some(reason) = &self.disallow_tilde_const => {\n-                    let mut err = self.err_handler().struct_span_err(bound.span(), \"`~const` is not allowed here\");\n-                    match reason {\n-                        DisallowTildeConstContext::TraitObject => err.note(\"trait objects cannot have `~const` trait bounds\"),\n-                        DisallowTildeConstContext::Fn(FnKind::Closure(..)) => err.note(\"closures cannot have `~const` trait bounds\"),\n-                        DisallowTildeConstContext::Fn(FnKind::Fn(_, ident, ..)) => err.span_note(ident.span, \"this function is not `const`, so it cannot have `~const` trait bounds\"),\n+                    let reason = match reason {\n+                        DisallowTildeConstContext::TraitObject => errors::TildeConstReason::TraitObject,\n+                        DisallowTildeConstContext::Fn(FnKind::Closure(..)) => errors::TildeConstReason::Closure,\n+                        DisallowTildeConstContext::Fn(FnKind::Fn(_, ident, ..)) => errors::TildeConstReason::Function { ident: ident.span },\n                     };\n-                    err.emit();\n+                    self.err_handler().emit_err(errors::TildeConstDisallowed {\n+                        span: bound.span(),\n+                        reason\n+                    });\n                 }\n                 (_, TraitBoundModifier::MaybeConstMaybe) => {\n-                    self.err_handler()\n-                        .span_err(bound.span(), \"`~const` and `?` are mutually exclusive\");\n+                    self.err_handler().emit_err(errors::OptionalConstExclusive {span: bound.span()});\n                 }\n                 _ => {}\n             }\n@@ -1362,21 +1183,18 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         self.check_c_variadic_type(fk);\n \n         // Functions cannot both be `const async`\n-        if let Some(FnHeader {\n+        if let Some(&FnHeader {\n             constness: Const::Yes(cspan),\n             asyncness: Async::Yes { span: aspan, .. },\n             ..\n         }) = fk.header()\n         {\n-            self.err_handler()\n-                .struct_span_err(\n-                    vec![*cspan, *aspan],\n-                    \"functions cannot be both `const` and `async`\",\n-                )\n-                .span_label(*cspan, \"`const` because of this\")\n-                .span_label(*aspan, \"`async` because of this\")\n-                .span_label(span, \"\") // Point at the fn header.\n-                .emit();\n+            self.err_handler().emit_err(errors::ConstAndAsync {\n+                spans: vec![cspan, aspan],\n+                cspan,\n+                aspan,\n+                span,\n+            });\n         }\n \n         if let FnKind::Fn(\n@@ -1394,20 +1212,12 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         // Functions without bodies cannot have patterns.\n         if let FnKind::Fn(ctxt, _, sig, _, _, None) = fk {\n             Self::check_decl_no_pat(&sig.decl, |span, ident, mut_ident| {\n-                let (code, msg, label) = match ctxt {\n-                    FnCtxt::Foreign => (\n-                        error_code!(E0130),\n-                        \"patterns aren't allowed in foreign function declarations\",\n-                        \"pattern not allowed in foreign function\",\n-                    ),\n-                    _ => (\n-                        error_code!(E0642),\n-                        \"patterns aren't allowed in functions without bodies\",\n-                        \"pattern not allowed in function without body\",\n-                    ),\n-                };\n                 if mut_ident && matches!(ctxt, FnCtxt::Assoc(_)) {\n                     if let Some(ident) = ident {\n+                        let msg = match ctxt {\n+                            FnCtxt::Foreign => fluent::ast_passes_pattern_in_foreign,\n+                            _ => fluent::ast_passes_pattern_in_bodiless,\n+                        };\n                         let diag = BuiltinLintDiagnostics::PatternsInFnsWithoutBody(span, ident);\n                         self.lint_buffer.buffer_lint_with_diagnostic(\n                             PATTERNS_IN_FNS_WITHOUT_BODY,\n@@ -1418,11 +1228,12 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                         )\n                     }\n                 } else {\n-                    self.err_handler()\n-                        .struct_span_err(span, msg)\n-                        .span_label(span, label)\n-                        .code(code)\n-                        .emit();\n+                    match ctxt {\n+                        FnCtxt::Foreign => {\n+                            self.err_handler().emit_err(errors::PatternInForeign { span })\n+                        }\n+                        _ => self.err_handler().emit_err(errors::PatternInBodiless { span }),\n+                    };\n                 }\n             });\n         }\n@@ -1449,15 +1260,15 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             match &item.kind {\n                 AssocItemKind::Const(_, _, body) => {\n                     if body.is_none() {\n-                        self.session.emit_err(AssocConstWithoutBody {\n+                        self.session.emit_err(errors::AssocConstWithoutBody {\n                             span: item.span,\n                             replace_span: self.ending_semi_or_hi(item.span),\n                         });\n                     }\n                 }\n                 AssocItemKind::Fn(box Fn { body, .. }) => {\n                     if body.is_none() {\n-                        self.session.emit_err(AssocFnWithoutBody {\n+                        self.session.emit_err(errors::AssocFnWithoutBody {\n                             span: item.span,\n                             replace_span: self.ending_semi_or_hi(item.span),\n                         });\n@@ -1472,7 +1283,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     ..\n                 }) => {\n                     if ty.is_none() {\n-                        self.session.emit_err(AssocTypeWithoutBody {\n+                        self.session.emit_err(errors::AssocTypeWithoutBody {\n                             span: item.span,\n                             replace_span: self.ending_semi_or_hi(item.span),\n                         });\n@@ -1544,11 +1355,7 @@ fn deny_equality_constraints(\n     predicate: &WhereEqPredicate,\n     generics: &Generics,\n ) {\n-    let mut err = this.err_handler().struct_span_err(\n-        predicate.span,\n-        \"equality constraints are not yet supported in `where` clauses\",\n-    );\n-    err.span_label(predicate.span, \"not supported\");\n+    let mut err = errors::EqualityInWhere { span: predicate.span, assoc: None, assoc2: None };\n \n     // Given `<A as Foo>::Bar = RhsTy`, suggest `A: Foo<Bar = RhsTy>`.\n     if let TyKind::Path(Some(qself), full_path) = &predicate.lhs_ty.kind {\n@@ -1592,20 +1399,12 @@ fn deny_equality_constraints(\n                                             .into();\n                                         }\n                                     }\n-                                    err.span_suggestion_verbose(\n-                                        predicate.span,\n-                                        &format!(\n-                                            \"if `{}` is an associated type you're trying to set, \\\n-                                            use the associated type binding syntax\",\n-                                            ident\n-                                        ),\n-                                        format!(\n-                                            \"{}: {}\",\n-                                            param,\n-                                            pprust::path_to_string(&assoc_path)\n-                                        ),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n+                                    err.assoc = Some(errors::AssociatedSuggestion {\n+                                        span: predicate.span,\n+                                        ident: *ident,\n+                                        param: *param,\n+                                        path: pprust::path_to_string(&assoc_path),\n+                                    })\n                                 }\n                                 _ => {}\n                             };\n@@ -1647,26 +1446,21 @@ fn deny_equality_constraints(\n                                         trait_segment.span().shrink_to_hi(),\n                                     ),\n                                 };\n-                                err.multipart_suggestion(\n-                                    &format!(\n-                                        \"if `{}::{}` is an associated type you're trying to set, \\\n-                                        use the associated type binding syntax\",\n-                                        trait_segment.ident, potential_assoc.ident,\n-                                    ),\n-                                    vec![(span, args), (predicate.span, String::new())],\n-                                    Applicability::MaybeIncorrect,\n-                                );\n+                                err.assoc2 = Some(errors::AssociatedSuggestion2 {\n+                                    span,\n+                                    args,\n+                                    predicate: predicate.span,\n+                                    trait_segment: trait_segment.ident,\n+                                    potential_assoc: potential_assoc.ident,\n+                                });\n                             }\n                         }\n                     }\n                 }\n             }\n         }\n     }\n-    err.note(\n-        \"see issue #20041 <https://github.com/rust-lang/rust/issues/20041> for more information\",\n-    );\n-    err.emit();\n+    this.err_handler().emit_err(err);\n }\n \n pub fn check_crate(session: &Session, krate: &Crate, lints: &mut LintBuffer) -> bool {"}, {"sha": "d007097d91818b6c705b7ad3d34ddbf60139be52", "filename": "compiler/rustc_ast_passes/src/errors.rs", "status": "modified", "additions": 475, "deletions": 1, "changes": 476, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -1,9 +1,12 @@\n //! Errors emitted by ast_passes.\n \n+use rustc_ast::ParamKindOrd;\n+use rustc_errors::AddToDiagnostic;\n use rustc_macros::{Diagnostic, Subdiagnostic};\n-use rustc_span::{Span, Symbol};\n+use rustc_span::{symbol::Ident, Span, Symbol};\n \n use crate::ast_validation::ForbiddenLetReason;\n+use crate::fluent_generated as fluent;\n \n #[derive(Diagnostic)]\n #[diag(ast_passes_forbidden_let)]\n@@ -217,3 +220,474 @@ pub enum ExternBlockSuggestion {\n         abi: Symbol,\n     },\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_bound_in_context)]\n+pub struct BoundInContext<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ctx: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_extern_types_cannot)]\n+#[note(ast_passes_extern_keyword_link)]\n+pub struct ExternTypesCannotHave<'a> {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"maybe-incorrect\")]\n+    pub span: Span,\n+    pub descr: &'a str,\n+    pub remove_descr: &'a str,\n+    #[label]\n+    pub block_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_body_in_extern)]\n+#[note(ast_passes_extern_keyword_link)]\n+pub struct BodyInExtern<'a> {\n+    #[primary_span]\n+    #[label(ast_passes_cannot_have)]\n+    pub span: Span,\n+    #[label(ast_passes_invalid)]\n+    pub body: Span,\n+    #[label(ast_passes_existing)]\n+    pub block: Span,\n+    pub kind: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_fn_body_extern)]\n+#[help]\n+#[note(ast_passes_extern_keyword_link)]\n+pub struct FnBodyInExtern {\n+    #[primary_span]\n+    #[label(ast_passes_cannot_have)]\n+    pub span: Span,\n+    #[suggestion(code = \";\", applicability = \"maybe-incorrect\")]\n+    pub body: Span,\n+    #[label]\n+    pub block: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_extern_fn_qualifiers)]\n+pub struct FnQualifierInExtern {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub block: Span,\n+    #[suggestion(code = \"fn \", applicability = \"maybe-incorrect\", style = \"verbose\")]\n+    pub sugg_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_extern_item_ascii)]\n+#[note]\n+pub struct ExternItemAscii {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub block: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_bad_c_variadic)]\n+pub struct BadCVariadic {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_item_underscore)]\n+pub struct ItemUnderscore<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub kind: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_nomangle_ascii, code = \"E0754\")]\n+pub struct NoMangleAscii {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_module_nonascii, code = \"E0754\")]\n+#[help]\n+pub struct ModuleNonAscii {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_auto_generic, code = \"E0567\")]\n+pub struct AutoTraitGeneric {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+    #[label]\n+    pub ident: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_auto_super_lifetime, code = \"E0568\")]\n+pub struct AutoTraitBounds {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+    #[label]\n+    pub ident: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_auto_items, code = \"E0380\")]\n+pub struct AutoTraitItems {\n+    #[primary_span]\n+    pub spans: Vec<Span>,\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub total: Span,\n+    #[label]\n+    pub ident: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_generic_before_constraints)]\n+pub struct ArgsBeforeConstraint {\n+    #[primary_span]\n+    pub arg_spans: Vec<Span>,\n+    #[label(ast_passes_constraints)]\n+    pub constraints: Span,\n+    #[label(ast_passes_args)]\n+    pub args: Span,\n+    #[suggestion(code = \"{suggestion}\", applicability = \"machine-applicable\", style = \"verbose\")]\n+    pub data: Span,\n+    pub suggestion: String,\n+    pub constraint_len: usize,\n+    pub args_len: usize,\n+    #[subdiagnostic]\n+    pub constraint_spans: EmptyLabelManySpans,\n+    #[subdiagnostic]\n+    pub arg_spans2: EmptyLabelManySpans,\n+}\n+\n+pub struct EmptyLabelManySpans(pub Vec<Span>);\n+\n+// The derive for `Vec<Span>` does multiple calls to `span_label`, adding commas between each\n+impl AddToDiagnostic for EmptyLabelManySpans {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut rustc_errors::Diagnostic, _: F)\n+    where\n+        F: Fn(\n+            &mut rustc_errors::Diagnostic,\n+            rustc_errors::SubdiagnosticMessage,\n+        ) -> rustc_errors::SubdiagnosticMessage,\n+    {\n+        diag.span_labels(self.0, \"\");\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_pattern_in_fn_pointer, code = \"E0561\")]\n+pub struct PatternFnPointer {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_trait_object_single_bound, code = \"E0226\")]\n+pub struct TraitObjectBound {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_impl_trait_path, code = \"E0667\")]\n+pub struct ImplTraitPath {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_nested_impl_trait, code = \"E0666\")]\n+pub struct NestedImplTrait {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label(ast_passes_outer)]\n+    pub outer: Span,\n+    #[label(ast_passes_inner)]\n+    pub inner: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_at_least_one_trait)]\n+pub struct AtLeastOneTrait {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_out_of_order_params)]\n+pub struct OutOfOrderParams<'a> {\n+    #[primary_span]\n+    pub spans: Vec<Span>,\n+    #[suggestion(code = \"{ordered_params}\", applicability = \"machine-applicable\")]\n+    pub sugg_span: Span,\n+    pub param_ord: &'a ParamKindOrd,\n+    pub max_param: &'a ParamKindOrd,\n+    pub ordered_params: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_obsolete_auto)]\n+#[help]\n+pub struct ObsoleteAuto {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_unsafe_negative_impl, code = \"E0198\")]\n+pub struct UnsafeNegativeImpl {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label(ast_passes_negative)]\n+    pub negative: Span,\n+    #[label(ast_passes_unsafe)]\n+    pub r#unsafe: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_inherent_cannot_be)]\n+pub struct InherentImplCannot<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label(ast_passes_because)]\n+    pub annotation_span: Span,\n+    pub annotation: &'a str,\n+    #[label(ast_passes_type)]\n+    pub self_ty: Span,\n+    #[note(ast_passes_only_trait)]\n+    pub only_trait: Option<()>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_inherent_cannot_be, code = \"E0197\")]\n+pub struct InherentImplCannotUnsafe<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label(ast_passes_because)]\n+    pub annotation_span: Span,\n+    pub annotation: &'a str,\n+    #[label(ast_passes_type)]\n+    pub self_ty: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_unsafe_item)]\n+pub struct UnsafeItem {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: &'static str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_fieldless_union)]\n+pub struct FieldlessUnion {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_where_after_type_alias)]\n+#[note]\n+pub struct WhereAfterTypeAlias {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_generic_default_trailing)]\n+pub struct GenericDefaultTrailing {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_nested_lifetimes, code = \"E0316\")]\n+pub struct NestedLifetimes {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_optional_trait_supertrait)]\n+#[note]\n+pub struct OptionalTraitSupertrait {\n+    #[primary_span]\n+    pub span: Span,\n+    pub path_str: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_optional_trait_object)]\n+pub struct OptionalTraitObject {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_tilde_const_disallowed)]\n+pub struct TildeConstDisallowed {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub reason: TildeConstReason,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum TildeConstReason {\n+    #[note(ast_passes_trait)]\n+    TraitObject,\n+    #[note(ast_passes_closure)]\n+    Closure,\n+    #[note(ast_passes_function)]\n+    Function {\n+        #[primary_span]\n+        ident: Span,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_optional_const_exclusive)]\n+pub struct OptionalConstExclusive {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_const_and_async)]\n+pub struct ConstAndAsync {\n+    #[primary_span]\n+    pub spans: Vec<Span>,\n+    #[label(ast_passes_const)]\n+    pub cspan: Span,\n+    #[label(ast_passes_async)]\n+    pub aspan: Span,\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_pattern_in_foreign, code = \"E0130\")]\n+pub struct PatternInForeign {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_pattern_in_bodiless, code = \"E0642\")]\n+pub struct PatternInBodiless {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_equality_in_where)]\n+#[note]\n+pub struct EqualityInWhere {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub assoc: Option<AssociatedSuggestion>,\n+    #[subdiagnostic]\n+    pub assoc2: Option<AssociatedSuggestion2>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    ast_passes_suggestion,\n+    code = \"{param}: {path}\",\n+    style = \"verbose\",\n+    applicability = \"maybe-incorrect\"\n+)]\n+pub struct AssociatedSuggestion {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ident: Ident,\n+    pub param: Ident,\n+    pub path: String,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(ast_passes_suggestion_path, applicability = \"maybe-incorrect\")]\n+pub struct AssociatedSuggestion2 {\n+    #[suggestion_part(code = \"{args}\")]\n+    pub span: Span,\n+    pub args: String,\n+    #[suggestion_part(code = \"\")]\n+    pub predicate: Span,\n+    pub trait_segment: Ident,\n+    pub potential_assoc: Ident,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_stability_outside_std, code = \"E0734\")]\n+pub struct StabilityOutsideStd {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_feature_on_non_nightly, code = \"E0554\")]\n+pub struct FeatureOnNonNightly {\n+    #[primary_span]\n+    pub span: Span,\n+    pub channel: &'static str,\n+    #[subdiagnostic]\n+    pub stable_features: Vec<StableFeature>,\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub sugg: Option<Span>,\n+}\n+\n+pub struct StableFeature {\n+    pub name: Symbol,\n+    pub since: Symbol,\n+}\n+\n+impl AddToDiagnostic for StableFeature {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut rustc_errors::Diagnostic, _: F)\n+    where\n+        F: Fn(\n+            &mut rustc_errors::Diagnostic,\n+            rustc_errors::SubdiagnosticMessage,\n+        ) -> rustc_errors::SubdiagnosticMessage,\n+    {\n+        diag.set_arg(\"name\", self.name);\n+        diag.set_arg(\"since\", self.since);\n+        diag.help(fluent::ast_passes_stable_since);\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_incompatbile_features)]\n+#[help]\n+pub struct IncompatibleFeatures {\n+    #[primary_span]\n+    pub spans: Vec<Span>,\n+    pub f1: Symbol,\n+    pub f2: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_show_span)]\n+pub struct ShowSpan {\n+    #[primary_span]\n+    pub span: Span,\n+    pub msg: &'static str,\n+}"}, {"sha": "926b0da2ec610a70a0c5896abc32b3195048485f", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 15, "deletions": 39, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -2,7 +2,7 @@ use rustc_ast as ast;\n use rustc_ast::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n use rustc_ast::{AssocConstraint, AssocConstraintKind, NodeId};\n use rustc_ast::{PatKind, RangeEnd};\n-use rustc_errors::{struct_span_err, Applicability, StashKey};\n+use rustc_errors::{Applicability, StashKey};\n use rustc_feature::{AttributeGate, BuiltinAttribute, Features, GateIssue, BUILTIN_ATTRIBUTE_MAP};\n use rustc_session::parse::{feature_err, feature_err_issue, feature_warn};\n use rustc_session::Session;\n@@ -13,7 +13,7 @@ use rustc_target::spec::abi;\n use thin_vec::ThinVec;\n use tracing::debug;\n \n-use crate::errors::ForbiddenLifetimeBound;\n+use crate::errors;\n \n macro_rules! gate_feature_fn {\n     ($visitor: expr, $has_feature: expr, $span: expr, $name: expr, $explain: expr, $help: expr) => {{\n@@ -164,7 +164,7 @@ impl<'a> PostExpansionVisitor<'a> {\n         for param in params {\n             if !param.bounds.is_empty() {\n                 let spans: Vec<_> = param.bounds.iter().map(|b| b.span()).collect();\n-                self.sess.emit_err(ForbiddenLifetimeBound { spans });\n+                self.sess.emit_err(errors::ForbiddenLifetimeBound { spans });\n             }\n         }\n     }\n@@ -218,13 +218,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 || attr.has_name(sym::rustc_const_stable)\n                 || attr.has_name(sym::rustc_default_body_unstable)\n             {\n-                struct_span_err!(\n-                    self.sess,\n-                    attr.span,\n-                    E0734,\n-                    \"stability attributes may not be used outside of the standard library\",\n-                )\n-                .emit();\n+                self.sess.emit_err(errors::StabilityOutsideStd { span: attr.span });\n             }\n         }\n     }\n@@ -635,13 +629,13 @@ fn maybe_stage_features(sess: &Session, krate: &ast::Crate) {\n             return;\n         }\n         for attr in krate.attrs.iter().filter(|attr| attr.has_name(sym::feature)) {\n-            let mut err = struct_span_err!(\n-                sess.parse_sess.span_diagnostic,\n-                attr.span,\n-                E0554,\n-                \"`#![feature]` may not be used on the {} release channel\",\n-                option_env!(\"CFG_RELEASE_CHANNEL\").unwrap_or(\"(unknown)\")\n-            );\n+            let mut err = errors::FeatureOnNonNightly {\n+                span: attr.span,\n+                channel: option_env!(\"CFG_RELEASE_CHANNEL\").unwrap_or(\"(unknown)\"),\n+                stable_features: vec![],\n+                sugg: None,\n+            };\n+\n             let mut all_stable = true;\n             for ident in\n                 attr.meta_item_list().into_iter().flatten().flat_map(|nested| nested.ident())\n@@ -652,24 +646,15 @@ fn maybe_stage_features(sess: &Session, krate: &ast::Crate) {\n                     .flat_map(|&(feature, _, since)| if feature == name { since } else { None })\n                     .next();\n                 if let Some(since) = stable_since {\n-                    err.help(&format!(\n-                        \"the feature `{}` has been stable since {} and no longer requires \\\n-                                  an attribute to enable\",\n-                        name, since\n-                    ));\n+                    err.stable_features.push(errors::StableFeature { name, since });\n                 } else {\n                     all_stable = false;\n                 }\n             }\n             if all_stable {\n-                err.span_suggestion(\n-                    attr.span,\n-                    \"remove the attribute\",\n-                    \"\",\n-                    Applicability::MachineApplicable,\n-                );\n+                err.sugg = Some(attr.span);\n             }\n-            err.emit();\n+            sess.parse_sess.span_diagnostic.emit_err(err);\n         }\n     }\n }\n@@ -692,16 +677,7 @@ fn check_incompatible_features(sess: &Session) {\n             if let Some((f2_name, f2_span)) = declared_features.clone().find(|(name, _)| name == f2)\n             {\n                 let spans = vec![f1_span, f2_span];\n-                sess.struct_span_err(\n-                    spans,\n-                    &format!(\n-                        \"features `{}` and `{}` are incompatible, using them at the same time \\\n-                        is not allowed\",\n-                        f1_name, f2_name\n-                    ),\n-                )\n-                .help(\"remove one of these features\")\n-                .emit();\n+                sess.emit_err(errors::IncompatibleFeatures { spans, f1: f1_name, f2: f2_name });\n             }\n         }\n     }"}, {"sha": "b9dcaee2373d2f049035383ecde336230b96157f", "filename": "compiler/rustc_ast_passes/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -10,6 +10,8 @@\n #![feature(iter_is_partitioned)]\n #![feature(let_chains)]\n #![recursion_limit = \"256\"]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n use rustc_macros::fluent_messages;"}, {"sha": "280cf3284c38ccd4940902c8c6346a7059ba7603", "filename": "compiler/rustc_ast_passes/src/show_span.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/compiler%2Frustc_ast_passes%2Fsrc%2Fshow_span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/compiler%2Frustc_ast_passes%2Fsrc%2Fshow_span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fshow_span.rs?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -9,6 +9,8 @@ use rustc_ast as ast;\n use rustc_ast::visit;\n use rustc_ast::visit::Visitor;\n \n+use crate::errors;\n+\n enum Mode {\n     Expression,\n     Pattern,\n@@ -36,21 +38,21 @@ struct ShowSpanVisitor<'a> {\n impl<'a> Visitor<'a> for ShowSpanVisitor<'a> {\n     fn visit_expr(&mut self, e: &'a ast::Expr) {\n         if let Mode::Expression = self.mode {\n-            self.span_diagnostic.span_warn(e.span, \"expression\");\n+            self.span_diagnostic.emit_warning(errors::ShowSpan { span: e.span, msg: \"expression\" });\n         }\n         visit::walk_expr(self, e);\n     }\n \n     fn visit_pat(&mut self, p: &'a ast::Pat) {\n         if let Mode::Pattern = self.mode {\n-            self.span_diagnostic.span_warn(p.span, \"pattern\");\n+            self.span_diagnostic.emit_warning(errors::ShowSpan { span: p.span, msg: \"pattern\" });\n         }\n         visit::walk_pat(self, p);\n     }\n \n     fn visit_ty(&mut self, t: &'a ast::Ty) {\n         if let Mode::Type = self.mode {\n-            self.span_diagnostic.span_warn(t.span, \"type\");\n+            self.span_diagnostic.emit_warning(errors::ShowSpan { span: t.span, msg: \"type\" });\n         }\n         visit::walk_ty(self, t);\n     }"}, {"sha": "97201219cdf680baf8c81f3d4c29877910b9d27d", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -253,6 +253,7 @@ E0466: include_str!(\"./error_codes/E0466.md\"),\n E0468: include_str!(\"./error_codes/E0468.md\"),\n E0469: include_str!(\"./error_codes/E0469.md\"),\n E0472: include_str!(\"./error_codes/E0472.md\"),\n+E0476: include_str!(\"./error_codes/E0476.md\"),\n E0477: include_str!(\"./error_codes/E0477.md\"),\n E0478: include_str!(\"./error_codes/E0478.md\"),\n E0482: include_str!(\"./error_codes/E0482.md\"),\n@@ -611,7 +612,6 @@ E0793: include_str!(\"./error_codes/E0793.md\"),\n //  E0473, // dereference of reference outside its lifetime\n //  E0474, // captured variable `..` does not outlive the enclosing closure\n //  E0475, // index of slice outside its lifetime\n-    E0476, // lifetime of the source pointer does not outlive lifetime bound...\n //  E0479, // the type `..` (provided as the value of a type parameter) is...\n //  E0480, // lifetime of method receiver does not outlive the method call\n //  E0481, // lifetime of function argument does not outlive the function call"}, {"sha": "fc141ba77f5df1ef6bf1bed0919cd1c13b060cc5", "filename": "compiler/rustc_error_codes/src/error_codes/E0476.md", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0476.md", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0476.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0476.md?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -0,0 +1,21 @@\n+The coerced type does not outlive the value being coerced to.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0476\n+#![feature(coerce_unsized)]\n+#![feature(unsize)]\n+\n+use std::marker::Unsize;\n+use std::ops::CoerceUnsized;\n+\n+// error: lifetime of the source pointer does not outlive lifetime bound of the\n+//        object type\n+impl<'a, 'b, T, S> CoerceUnsized<&'a T> for &'b S where S: Unsize<T> {}\n+```\n+\n+During a coercion, the \"source pointer\" (the coerced type) did not outlive the\n+\"object type\" (value being coerced to). In the above example, `'b` is not a\n+subtype of `'a`. This error can currently only be encountered with the unstable\n+`CoerceUnsized` trait which allows custom coercions of unsized types behind a\n+smart pointer to be implemented."}, {"sha": "e82bad67b21ecc122043dc34ff5eceb5c857f0c0", "filename": "compiler/rustc_errors/src/diagnostic_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -54,6 +54,7 @@ macro_rules! into_diagnostic_arg_using_display {\n }\n \n into_diagnostic_arg_using_display!(\n+    ast::ParamKindOrd,\n     i8,\n     u8,\n     i16,"}, {"sha": "b475d285f6b7e093ead43bc683d89318c066229b", "filename": "compiler/rustc_expand/locales/en-US.ftl", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/compiler%2Frustc_expand%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/compiler%2Frustc_expand%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Flocales%2Fen-US.ftl?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -129,3 +129,7 @@ expand_module_multiple_candidates =\n     .help = delete or rename one of them to remove the ambiguity\n \n expand_trace_macro = trace_macro\n+\n+expand_proc_macro_panicked =\n+    proc macro panicked\n+    .help = message: {$message}"}, {"sha": "70ab222b484700b7620cfce71992389ae40ac36a", "filename": "compiler/rustc_expand/src/errors.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -375,3 +375,18 @@ pub struct TraceMacro {\n     #[primary_span]\n     pub span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_proc_macro_panicked)]\n+pub(crate) struct ProcMacroPanicked {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub message: Option<ProcMacroPanickedHelp>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[help(expand_help)]\n+pub(crate) struct ProcMacroPanickedHelp {\n+    pub message: String,\n+}"}, {"sha": "cef64a1047902afdf12fb0f5cf87dfb6a2cefbc5", "filename": "compiler/rustc_expand/src/proc_macro.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -1,4 +1,5 @@\n use crate::base::{self, *};\n+use crate::errors;\n use crate::proc_macro_server;\n \n use rustc_ast as ast;\n@@ -60,11 +61,12 @@ impl base::BangProcMacro for BangProcMacro {\n         let strategy = exec_strategy(ecx);\n         let server = proc_macro_server::Rustc::new(ecx);\n         self.client.run(&strategy, server, input, proc_macro_backtrace).map_err(|e| {\n-            let mut err = ecx.struct_span_err(span, \"proc macro panicked\");\n-            if let Some(s) = e.as_str() {\n-                err.help(&format!(\"message: {}\", s));\n-            }\n-            err.emit()\n+            ecx.sess.emit_err(errors::ProcMacroPanicked {\n+                span,\n+                message: e\n+                    .as_str()\n+                    .map(|message| errors::ProcMacroPanickedHelp { message: message.into() }),\n+            })\n         })\n     }\n }"}, {"sha": "68e62c9789aed9fda1e5a0118d1642cd4f8c6f95", "filename": "compiler/rustc_lint/locales/en-US.ftl", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/compiler%2Frustc_lint%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/compiler%2Frustc_lint%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Flocales%2Fen-US.ftl?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -24,6 +24,13 @@ lint_for_loops_over_fallibles =\n     .use_while_let = to check pattern in a loop use `while let`\n     .use_question_mark = consider unwrapping the `Result` with `?` to iterate over its contents\n \n+lint_map_unit_fn = `Iterator::map` call that discard the iterator's values\n+    .note = `Iterator::map`, like many of the methods on `Iterator`, gets executed lazily, meaning that its effects won't be visible until it is iterated\n+    .function_label = this function returns `()`, which is likely not what you wanted\n+    .argument_label = called `Iterator::map` with callable that returns `()`\n+    .map_label = after this call to map, the resulting iterator is `impl Iterator<Item = ()>`, which means the only information carried by the iterator is the number of items\n+    .suggestion = you might have meant to use `Iterator::for_each`\n+\n lint_non_binding_let_on_sync_lock =\n     non-binding let on a synchronization lock\n "}, {"sha": "35dc533e56c24ea900ad26f4ed9bd11850d46d11", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -63,6 +63,7 @@ mod late;\n mod let_underscore;\n mod levels;\n mod lints;\n+mod map_unit_fn;\n mod methods;\n mod multiple_supertrait_upcastable;\n mod non_ascii_idents;\n@@ -100,6 +101,7 @@ use for_loops_over_fallibles::*;\n use hidden_unicode_codepoints::*;\n use internal::*;\n use let_underscore::*;\n+use map_unit_fn::*;\n use methods::*;\n use multiple_supertrait_upcastable::*;\n use non_ascii_idents::*;\n@@ -239,6 +241,7 @@ late_lint_methods!(\n             NamedAsmLabels: NamedAsmLabels,\n             OpaqueHiddenInferredBound: OpaqueHiddenInferredBound,\n             MultipleSupertraitUpcastable: MultipleSupertraitUpcastable,\n+            MapUnitFn: MapUnitFn,\n         ]\n     ]\n );\n@@ -298,7 +301,8 @@ fn register_builtins(store: &mut LintStore) {\n         UNUSED_LABELS,\n         UNUSED_PARENS,\n         UNUSED_BRACES,\n-        REDUNDANT_SEMICOLONS\n+        REDUNDANT_SEMICOLONS,\n+        MAP_UNIT_FN\n     );\n \n     add_lint_group!(\"let_underscore\", LET_UNDERSCORE_DROP, LET_UNDERSCORE_LOCK);"}, {"sha": "20ab0af5856518a22d7099d3c3160849f59f555e", "filename": "compiler/rustc_lint/src/lints.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flints.rs?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -748,6 +748,22 @@ impl AddToDiagnostic for HiddenUnicodeCodepointsDiagSub {\n     }\n }\n \n+// map_unit_fn.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_map_unit_fn)]\n+#[note]\n+pub struct MappingToUnit {\n+    #[label(lint_function_label)]\n+    pub function_label: Span,\n+    #[label(lint_argument_label)]\n+    pub argument_label: Span,\n+    #[label(lint_map_label)]\n+    pub map_label: Span,\n+    #[suggestion(style = \"verbose\", code = \"{replace}\", applicability = \"maybe-incorrect\")]\n+    pub suggestion: Span,\n+    pub replace: String,\n+}\n+\n // internal.rs\n #[derive(LintDiagnostic)]\n #[diag(lint_default_hash_types)]"}, {"sha": "62e8b4fe9e4a2073b7763ceb5174fc1117d34b4f", "filename": "compiler/rustc_lint/src/map_unit_fn.rs", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/compiler%2Frustc_lint%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/compiler%2Frustc_lint%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fmap_unit_fn.rs?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -0,0 +1,120 @@\n+use crate::lints::MappingToUnit;\n+use crate::{LateContext, LateLintPass, LintContext};\n+\n+use rustc_hir::{Expr, ExprKind, HirId, Stmt, StmtKind};\n+use rustc_middle::{\n+    query::Key,\n+    ty::{self, Ty},\n+};\n+\n+declare_lint! {\n+    /// The `map_unit_fn` lint checks for `Iterator::map` receive\n+    /// a callable that returns `()`.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// fn foo(items: &mut Vec<u8>) {\n+    ///     items.sort();\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     let mut x: Vec<Vec<u8>> = vec![\n+    ///         vec![0, 2, 1],\n+    ///         vec![5, 4, 3],\n+    ///     ];\n+    ///     x.iter_mut().map(foo);\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Mapping to `()` is almost always a mistake.\n+    pub MAP_UNIT_FN,\n+    Warn,\n+    \"`Iterator::map` call that discard the iterator's values\"\n+}\n+\n+declare_lint_pass!(MapUnitFn => [MAP_UNIT_FN]);\n+\n+impl<'tcx> LateLintPass<'tcx> for MapUnitFn {\n+    fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &Stmt<'_>) {\n+        if stmt.span.from_expansion() {\n+            return;\n+        }\n+\n+        if let StmtKind::Semi(expr) = stmt.kind {\n+            if let ExprKind::MethodCall(path, receiver, args, span) = expr.kind {\n+                if path.ident.name.as_str() == \"map\" {\n+                    if receiver.span.from_expansion()\n+                        || args.iter().any(|e| e.span.from_expansion())\n+                        || !is_impl_slice(cx, receiver)\n+                        || !is_diagnostic_name(cx, expr.hir_id, \"IteratorMap\")\n+                    {\n+                        return;\n+                    }\n+                    let arg_ty = cx.typeck_results().expr_ty(&args[0]);\n+                    if let ty::FnDef(id, _) = arg_ty.kind() {\n+                        let fn_ty = cx.tcx.fn_sig(id).skip_binder();\n+                        let ret_ty = fn_ty.output().skip_binder();\n+                        if is_unit_type(ret_ty) {\n+                            cx.emit_spanned_lint(\n+                                MAP_UNIT_FN,\n+                                span,\n+                                MappingToUnit {\n+                                    function_label: cx.tcx.span_of_impl(*id).unwrap(),\n+                                    argument_label: args[0].span,\n+                                    map_label: arg_ty.default_span(cx.tcx),\n+                                    suggestion: path.ident.span,\n+                                    replace: \"for_each\".to_string(),\n+                                },\n+                            )\n+                        }\n+                    } else if let ty::Closure(id, subs) = arg_ty.kind() {\n+                        let cl_ty = subs.as_closure().sig();\n+                        let ret_ty = cl_ty.output().skip_binder();\n+                        if is_unit_type(ret_ty) {\n+                            cx.emit_spanned_lint(\n+                                MAP_UNIT_FN,\n+                                span,\n+                                MappingToUnit {\n+                                    function_label: cx.tcx.span_of_impl(*id).unwrap(),\n+                                    argument_label: args[0].span,\n+                                    map_label: arg_ty.default_span(cx.tcx),\n+                                    suggestion: path.ident.span,\n+                                    replace: \"for_each\".to_string(),\n+                                },\n+                            )\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn is_impl_slice(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    if let Some(method_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id) {\n+        if let Some(impl_id) = cx.tcx.impl_of_method(method_id) {\n+            return cx.tcx.type_of(impl_id).skip_binder().is_slice();\n+        }\n+    }\n+    false\n+}\n+\n+fn is_unit_type(ty: Ty<'_>) -> bool {\n+    ty.is_unit() || ty.is_never()\n+}\n+\n+fn is_diagnostic_name(cx: &LateContext<'_>, id: HirId, name: &str) -> bool {\n+    if let Some(def_id) = cx.typeck_results().type_dependent_def_id(id) {\n+        if let Some(item) = cx.tcx.get_diagnostic_name(def_id) {\n+            if item.as_str() == name {\n+                return true;\n+            }\n+        }\n+    }\n+    false\n+}"}, {"sha": "16194a6f196ea9d4eb402cc35c43400c62744a75", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -748,7 +748,10 @@ impl<'tcx> Visitor<'tcx> for Checker<'tcx> {\n                         let mut c = CheckTraitImplStable { tcx: self.tcx, fully_stable: true };\n                         c.visit_ty(self_ty);\n                         c.visit_trait_ref(t);\n-                        if c.fully_stable {\n+\n+                        // do not lint when the trait isn't resolved, since resolution error should\n+                        // be fixed first\n+                        if t.path.res != Res::Err && c.fully_stable {\n                             self.tcx.struct_span_lint_hir(\n                                 INEFFECTIVE_UNSTABLE_TRAIT_IMPL,\n                                 item.hir_id(),"}, {"sha": "ae00232c12c8ab9ee7987081f765f88d7d2a33c7", "filename": "library/core/src/iter/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -278,6 +278,7 @@\n //!\n //! ```\n //! # #![allow(unused_must_use)]\n+//! # #![cfg_attr(not(bootstrap), allow(map_unit_fn))]\n //! let v = vec![1, 2, 3, 4, 5];\n //! v.iter().map(|x| println!(\"{x}\"));\n //! ```"}, {"sha": "b8e7d0a68da573f229c6cd3deb5474f48b9b4a2d", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -789,6 +789,7 @@ pub trait Iterator {\n     ///     println!(\"{x}\");\n     /// }\n     /// ```\n+    #[rustc_diagnostic_item = \"IteratorMap\"]\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_do_not_const_check]"}, {"sha": "18cb023d274a48374d9547f2d6c8163b4392e58f", "filename": "library/test/Cargo.toml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/library%2Ftest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/library%2Ftest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2FCargo.toml?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -7,11 +7,9 @@ edition = \"2021\"\n crate-type = [\"dylib\", \"rlib\"]\n \n [dependencies]\n-cfg-if = { version = \"1.0\", features = ['rustc-dep-of-std'] }\n getopts = { version = \"0.2.21\", features = ['rustc-dep-of-std'] }\n std = { path = \"../std\" }\n core = { path = \"../core\" }\n-libc = { version = \"0.2\", default-features = false }\n panic_unwind = { path = \"../panic_unwind\" }\n panic_abort = { path = \"../panic_abort\" }\n "}, {"sha": "7c97c16c20bdc0350bee6f8313837972a8126dbe", "filename": "src/doc/index.md", "status": "modified", "additions": 165, "deletions": 63, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -4,6 +4,20 @@\n nav {\n     display: none;\n }\n+body {\n+    font-family: serif;\n+}\n+h1, h2, h3, h4, h5, h6 {\n+    font-family: sans-serif;\n+}\n+h3 {\n+    font-size: 1.35rem;\n+}\n+h4 {\n+    font-size: 1.1rem;\n+}\n+\n+/* Formatting for docs search bar */\n #search-input {\n     width: calc(100% - 58px);\n }\n@@ -21,53 +35,74 @@ nav {\n #search-but:hover, #search-input:focus {\n     border-color: #55a9ff;\n }\n-h2 {\n-    font-size: 18px;\n+\n+/* Formatting for external link icon */\n+svg.external-link {\n+  display: inline-block;\n+  position: relative;\n+  vertical-align: super;\n+  width: 0.7rem;\n+  height: 0.7rem;\n+  padding-left: 2px;\n+  top: 3px;\n }\n </style>\n \n-Welcome to an overview of the documentation provided by the [Rust project].\n-All of these projects are managed by the Docs Team; there are other\n-unofficial documentation resources as well!\n+Welcome to an overview of the documentation provided by the [Rust\n+project]. This page contains links to various helpful references,\n+most of which are available offline (if opened with `rustup doc`). Many of these\n+resources take the form of \"books\"; we collectively call these \"The Rust\n+Bookshelf.\" Some are large, some are small.\n \n-Many of these resources take the form of \"books\"; we collectively call these\n-\"The Rust Bookshelf.\" Some are large, some are small.\n+All of these books are managed by the Rust Organization, but other unofficial\n+documentation resources are included here as well!\n \n-# Learn Rust\n+If you're just looking for the standard library reference, here it is:\n+[Rust API documentation](std/index.html)\n \n-If you'd like to learn Rust, this is the spot for you! All of these resources\n+\n+## Learning Rust\n+\n+If you'd like to learn Rust, this is the section for you! All of these resources\n assume that you have programmed before, but not in any specific language:\n \n-## The Rust Programming Language\n+### The Rust Programming Language\n \n-Affectionately nicknamed \"the book,\" [The Rust Programming\n-Language](book/index.html) will give you an overview of the language from\n-first principles. You'll build a few projects along the way, and by the end,\n-you'll have a solid grasp of the language.\n+Affectionately nicknamed \"the book,\" [The Rust Programming Language](book/index.html)\n+will give you an overview of the language from first principles. You'll build a\n+few projects along the way, and by the end, you'll have a solid grasp of how to\n+use the language.\n \n-## Rust By Example\n+### Rust By Example\n \n If reading multiple hundreds of pages about a language isn't your style, then\n-[Rust By Example](rust-by-example/index.html) has you covered. While the book talks about code with\n-a lot of words, RBE shows off a bunch of code, and keeps the talking to a\n-minimum. It also includes exercises!\n+[Rust By Example](rust-by-example/index.html) has you covered. RBE shows off a\n+bunch of code without using a lot of words. It also includes exercises!\n+\n+### Rustlings\n+\n+[Rustlings](https://github.com/rust-lang/rustlings) guides you\n+through downloading and setting up the Rust toolchain, then provides an\n+interactive tool that teaches you how to solve coding challenges in Rust.\n+\n+### Rust Playground\n \n-## Rustlings\n+The [Rust Playground](https://play.rust-lang.org) is a great place\n+to try out and share small bits of code, or experiment with some of the most\n+popular crates.\n \n-[Rustlings](https://github.com/rust-lang/rustlings) guides you through downloading and setting up the Rust toolchain,\n-and teaches you the basics of reading and writing Rust syntax. It's an\n-alternative to Rust by Example that works with your own environment.\n \n-# Use Rust\n+## Using Rust\n \n-Once you've gotten familiar with the language, these resources can help you\n-when you're actually using it day-to-day.\n+Once you've gotten familiar with the language, these resources can help you put\n+it to work.\n \n-## The Standard Library\n+### The Standard Library\n \n-Rust's standard library has [extensive API documentation](std/index.html),\n-with explanations of how to use various things, as well as example code for\n-accomplishing various tasks.\n+Rust's standard library has [extensive API documentation](std/index.html), with\n+explanations of how to use various things, as well as example code for\n+accomplishing various tasks. Code examples have a \"Run\" button on hover that\n+opens the sample in the playground.\n \n <div>\n   <form action=\"std/index.html\" method=\"get\">\n@@ -77,76 +112,143 @@ accomplishing various tasks.\n   </form>\n </div>\n \n-## The Edition Guide\n+### Your Personal Documentation\n \n-[The Edition Guide](edition-guide/index.html) describes the Rust editions.\n+Whenever you are working in a crate, `cargo doc --open` will generate\n+documentation for your project _and_ all its dependencies in their correct\n+version, and open it in your browser. Add the flag `--document-private-items` to\n+also show items not marked `pub`.\n \n-## The Rustc Book\n+### The Edition Guide\n \n-[The Rustc Book](rustc/index.html) describes the Rust compiler, `rustc`.\n+[The Edition Guide](edition-guide/index.html) describes the Rust editions and\n+their differences.\n \n-## The Cargo Book\n+### The `rustc` Book\n \n-[The Cargo Book](cargo/index.html) is a guide to Cargo, Rust's build tool and dependency manager.\n+[The `rustc` Book](rustc/index.html) describes the Rust compiler, `rustc`.\n \n-## The Rustdoc Book\n+### The Cargo Book\n+\n+[The Cargo Book](cargo/index.html) is a guide to Cargo, Rust's build tool and\n+dependency manager.\n+\n+### The Rustdoc Book\n \n [The Rustdoc Book](rustdoc/index.html) describes our documentation tool, `rustdoc`.\n \n-## The Clippy Book\n+### The Clippy Book\n \n [The Clippy Book](clippy/index.html) describes our static analyzer, Clippy.\n \n-## Extended Error Listing\n+### Extended Error Listing\n \n Many of Rust's errors come with error codes, and you can request extended\n-diagnostics from the compiler on those errors. You can also [read them\n-here](error_codes/index.html), if you prefer to read them that way.\n+diagnostics from the compiler on those errors (with `rustc --explain`). You can\n+also read them here if you prefer: [rustc error codes](error_codes/index.html)\n+\n \n-# Master Rust\n+## Mastering Rust\n \n Once you're quite familiar with the language, you may find these advanced\n resources useful.\n \n-## The Reference\n+### The Reference\n \n-[The Reference](reference/index.html) is not a formal spec, but is more detailed and\n-comprehensive than the book.\n+[The Reference](reference/index.html) is not a formal spec, but is more detailed\n+and comprehensive than the book.\n \n-## The Style Guide\n+### The Style Guide\n \n-[The Rust Style Guide](style-guide/index.html) describes the standard formatting of Rust\n-code. Most developers use rustfmt to format their code, and rustfmt's default\n-formatting matches this style guide.\n+[The Rust Style Guide](style-guide/index.html) describes the standard formatting\n+of Rust code. Most developers use `cargo fmt` to invoke `rustfmt` and format the\n+code automatically (the result matches this style guide).\n \n-## The Rustonomicon\n+### The Rustonomicon\n \n-[The Rustonomicon](nomicon/index.html) is your guidebook to the dark arts of unsafe\n-Rust. It's also sometimes called \"the 'nomicon.\"\n+[The Rustonomicon](nomicon/index.html) is your guidebook to the dark arts of\n+unsafe Rust. It's also sometimes called \"the 'nomicon.\"\n \n-## The Unstable Book\n+### The Unstable Book\n \n-[The Unstable Book](unstable-book/index.html) has documentation for unstable features.\n+[The Unstable Book](unstable-book/index.html) has documentation for unstable\n+features.\n \n-## The `rustc` Contribution Guide\n+### The `rustc` Contribution Guide\n \n-[The `rustc` Guide](https://rustc-dev-guide.rust-lang.org/) documents how\n-the compiler works and how to contribute to it. This is useful if you want to build\n-or modify the Rust compiler from source (e.g. to target something non-standard).\n+[The `rustc` Guide](https://rustc-dev-guide.rust-lang.org/)\n+documents how the compiler works and how to contribute to it. This is useful if\n+you want to build or modify the Rust compiler from source (e.g. to target\n+something non-standard).\n \n-# Specialize Rust\n \n-When using Rust in specific domain areas, consider using the following resources tailored to each domain.\n+## Specialized Rust\n \n-## Embedded Systems\n+When using Rust in specific domains, consider using the following resources\n+tailored to each area.\n \n-When developing for Bare Metal or Embedded Linux systems, you may find these resources maintained by the [Embedded Working Group] useful.\n+### Embedded Systems\n+\n+When developing for Bare Metal or Embedded Linux systems, you may find these\n+resources maintained by the [Embedded Working Group] useful.\n \n [Embedded Working Group]: https://github.com/rust-embedded\n \n-### The Embedded Rust Book\n+#### The Embedded Rust Book\n \n-[The Embedded Rust Book] is targeted at developers familiar with embedded development and familiar with Rust, but have not used Rust for embedded development.\n+[The Embedded Rust Book] is targeted at developers familiar with embedded\n+development and familiar with Rust, but have not used Rust for embedded\n+development.\n \n [The Embedded Rust Book]: embedded-book/index.html\n [Rust project]: https://www.rust-lang.org\n+\n+<script>\n+// check if a given link is external\n+function isExternalLink(url) {\n+  const tmp = document.createElement('a');\n+  tmp.href = url;\n+  return tmp.host !== window.location.host;\n+}\n+\n+// Add the `external` class to all <a> tags with external links and append the external link SVG\n+function updateExternalAnchors() {\n+  /*\n+    External link SVG from Font-Awesome\n+    CC BY-SA 3.0 https://creativecommons.org/licenses/by-sa/3.0\n+    via Wikimedia Commons\n+  */\n+  const svgText = `<svg\n+     class='external-link'\n+     xmlns='http://www.w3.org/2000/svg'\n+     viewBox='0 -256 1850 1850'\n+     width='100%'\n+     height='100%'>\n+       <g transform='matrix(1,0,0,-1,30,1427)'>\n+         <path d='M 1408,608 V 288 Q 1408,169 1323.5,84.5 1239,0 1120,\n+           0 H 288 Q 169,0 84.5,84.5 0,169 0,288 v 832 Q 0,1239 84.5,1323.5 169,\n+           1408 288,1408 h 704 q 14,0 23,-9 9,-9 9,-23 v -64 q 0,-14 -9,-23 -9,\n+           -9 -23,-9 H 288 q -66,0 -113,-47 -47,-47 -47,-113 V 288 q 0,-66 47,\n+           -113 47,-47 113,-47 h 832 q 66,0 113,47 47,47 47,113 v 320 q 0,14 9,\n+           23 9,9 23,9 h 64 q 14,0 23,-9 9,-9 9,-23 z m 384,864 V 960 q 0,\n+           -26 -19,-45 -19,-19 -45,-19 -26,0 -45,19 L 1507,1091 855,439 q -10,\n+           -10 -23,-10 -13,0 -23,10 L 695,553 q -10,10 -10,23 0,13 10,23 l 652,\n+           652 -176,176 q -19,19 -19,45 0,26 19,45 19,19 45,19 h 512 q 26,0 45,\n+           -19 19,-19 19,-45 z' style='fill:currentColor' />\n+         </g>\n+     </svg>`;\n+  let allAnchors = document.getElementsByTagName(\"a\");\n+\n+  for (var i = 0; i < allAnchors.length; ++i) {\n+    let anchor = allAnchors[i];\n+    if (isExternalLink(anchor.href)) {\n+      anchor.classList.add(\"external\");\n+      anchor.innerHTML += svgText;\n+    }\n+  }\n+}\n+\n+// on page load, update external anchors\n+document.addEventListener(\"DOMContentLoaded\", updateExternalAnchors);\n+\n+</script>"}, {"sha": "373196b6642818efa16a3d7bc52a02f9c818e18f", "filename": "src/tools/error_index_generator/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ferror_index_generator%2Fmain.rs?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -22,7 +22,7 @@ macro_rules! register_diagnostics {\n         pub fn error_codes() -> Vec<(&'static str, Option<&'static str>)> {\n             let mut errors: Vec<(&str, Option<&str>)> = vec![\n                 $((stringify!($error_code), Some($message)),)+\n-                $((stringify!($undocumented), None),)+\n+                $((stringify!($undocumented), None),)*\n             ];\n             errors.sort();\n             errors"}, {"sha": "8c904e8d7123ad6795cb512e339ab3508384145e", "filename": "src/tools/tidy/src/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes.rs?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -31,7 +31,7 @@ const IGNORE_DOCTEST_CHECK: &[&str] = &[\"E0464\", \"E0570\", \"E0601\", \"E0602\", \"E06\n \n // Error codes that don't yet have a UI test. This list will eventually be removed.\n const IGNORE_UI_TEST_CHECK: &[&str] =\n-    &[\"E0461\", \"E0465\", \"E0476\", \"E0514\", \"E0554\", \"E0640\", \"E0717\", \"E0729\"];\n+    &[\"E0461\", \"E0465\", \"E0514\", \"E0554\", \"E0640\", \"E0717\", \"E0729\"];\n \n macro_rules! verbose_print {\n     ($verbose:expr, $($fmt:tt)*) => {"}, {"sha": "0aaaeee105147a47890ac15a5032fef0b4ea5325", "filename": "tests/rustdoc-ui/auxiliary/panic-handler.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Frustdoc-ui%2Fauxiliary%2Fpanic-handler.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Frustdoc-ui%2Fauxiliary%2Fpanic-handler.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fauxiliary%2Fpanic-handler.rs?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -0,0 +1,9 @@\n+// compile-flags: -C panic=abort\n+\n+#![no_std]\n+#![no_main]\n+\n+#[panic_handler]\n+fn panic(_: &core::panic::PanicInfo) -> ! {\n+    loop {}\n+}"}, {"sha": "13788df0fc99697e5796e3474fb734b8be34a709", "filename": "tests/rustdoc-ui/issue-107918.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Frustdoc-ui%2Fissue-107918.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Frustdoc-ui%2Fissue-107918.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fissue-107918.rs?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -0,0 +1,12 @@\n+// aux-build:panic-handler.rs\n+// compile-flags: --document-private-items\n+// build-pass\n+// ignore-windows\n+\n+#![no_std]\n+#![no_main]\n+\n+#[panic_handler]\n+fn panic(_: &core::panic::PanicInfo) -> ! {\n+    loop {}\n+}"}, {"sha": "89b63d23d4c8eeabbf0fde0f67ccb416678508ee", "filename": "tests/ui/auto-traits/auto-trait-validation.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Fui%2Fauto-traits%2Fauto-trait-validation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Fui%2Fauto-traits%2Fauto-trait-validation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauto-traits%2Fauto-trait-validation.stderr?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -12,15 +12,15 @@ error[E0568]: auto traits cannot have super traits or lifetime bounds\n LL | auto trait Bound : Copy {}\n    |            -----^^^^^^^ help: remove the super traits or lifetime bounds\n    |            |\n-   |            auto trait cannot have super traits or lifetime bounds\n+   |            auto traits cannot have super traits or lifetime bounds\n \n error[E0568]: auto traits cannot have super traits or lifetime bounds\n   --> $DIR/auto-trait-validation.rs:9:25\n    |\n LL | auto trait LifetimeBound : 'static {}\n    |            -------------^^^^^^^^^^ help: remove the super traits or lifetime bounds\n    |            |\n-   |            auto trait cannot have super traits or lifetime bounds\n+   |            auto traits cannot have super traits or lifetime bounds\n \n error[E0380]: auto traits cannot have associated items\n   --> $DIR/auto-trait-validation.rs:11:25\n@@ -29,7 +29,7 @@ LL | auto trait MyTrait { fn foo() {} }\n    |            -------   ---^^^-----\n    |            |         |\n    |            |         help: remove these associated items\n-   |            auto trait cannot have associated items\n+   |            auto traits cannot have associated items\n \n error: aborting due to 4 previous errors\n "}, {"sha": "fed485612daca458e94871a5d86ade61b0ed90d0", "filename": "tests/ui/auto-traits/issue-23080-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Fui%2Fauto-traits%2Fissue-23080-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Fui%2Fauto-traits%2Fissue-23080-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauto-traits%2Fissue-23080-2.stderr?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -2,7 +2,7 @@ error[E0380]: auto traits cannot have associated items\n   --> $DIR/issue-23080-2.rs:5:10\n    |\n LL | unsafe auto trait Trait {\n-   |                   ----- auto trait cannot have associated items\n+   |                   ----- auto traits cannot have associated items\n LL |     type Output;\n    |     -----^^^^^^- help: remove these associated items\n "}, {"sha": "f5d607298b7977d37764e571f9c39f2131d5591e", "filename": "tests/ui/auto-traits/issue-23080.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Fui%2Fauto-traits%2Fissue-23080.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Fui%2Fauto-traits%2Fissue-23080.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauto-traits%2Fissue-23080.stderr?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -2,7 +2,7 @@ error[E0380]: auto traits cannot have associated items\n   --> $DIR/issue-23080.rs:5:8\n    |\n LL |   unsafe auto trait Trait {\n-   |                     ----- auto trait cannot have associated items\n+   |                     ----- auto traits cannot have associated items\n LL |       fn method(&self) {\n    |  _____-  ^^^^^^\n LL | |         println!(\"Hello\");"}, {"sha": "6fbdc669b6ffbe83aed3266905655d6e712ea12a", "filename": "tests/ui/auto-traits/issue-84075.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Fui%2Fauto-traits%2Fissue-84075.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Fui%2Fauto-traits%2Fissue-84075.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauto-traits%2Fissue-84075.stderr?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -4,7 +4,7 @@ error[E0568]: auto traits cannot have super traits or lifetime bounds\n LL | auto trait Magic where Self: Copy {}\n    |            ----- ^^^^^^^^^^^^^^^^ help: remove the super traits or lifetime bounds\n    |            |\n-   |            auto trait cannot have super traits or lifetime bounds\n+   |            auto traits cannot have super traits or lifetime bounds\n \n error: aborting due to previous error\n "}, {"sha": "547b4bb54489dc6fd27319a63f7ecb25845481f4", "filename": "tests/ui/auto-traits/typeck-auto-trait-no-supertraits-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Fui%2Fauto-traits%2Ftypeck-auto-trait-no-supertraits-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Fui%2Fauto-traits%2Ftypeck-auto-trait-no-supertraits-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauto-traits%2Ftypeck-auto-trait-no-supertraits-2.stderr?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -4,15 +4,15 @@ error[E0568]: auto traits cannot have super traits or lifetime bounds\n LL | auto trait Magic : Sized where Option<Self> : Magic {}\n    |            -----^^^^^^^^ help: remove the super traits or lifetime bounds\n    |            |\n-   |            auto trait cannot have super traits or lifetime bounds\n+   |            auto traits cannot have super traits or lifetime bounds\n \n error[E0568]: auto traits cannot have super traits or lifetime bounds\n   --> $DIR/typeck-auto-trait-no-supertraits-2.rs:4:26\n    |\n LL | auto trait Magic : Sized where Option<Self> : Magic {}\n    |            -----         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove the super traits or lifetime bounds\n    |            |\n-   |            auto trait cannot have super traits or lifetime bounds\n+   |            auto traits cannot have super traits or lifetime bounds\n \n error: aborting due to 2 previous errors\n "}, {"sha": "80f07410381272281c118a025723672f4c0474ab", "filename": "tests/ui/auto-traits/typeck-auto-trait-no-supertraits.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Fui%2Fauto-traits%2Ftypeck-auto-trait-no-supertraits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Fui%2Fauto-traits%2Ftypeck-auto-trait-no-supertraits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauto-traits%2Ftypeck-auto-trait-no-supertraits.stderr?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -4,7 +4,7 @@ error[E0568]: auto traits cannot have super traits or lifetime bounds\n LL | auto trait Magic: Copy {}\n    |            -----^^^^^^ help: remove the super traits or lifetime bounds\n    |            |\n-   |            auto trait cannot have super traits or lifetime bounds\n+   |            auto traits cannot have super traits or lifetime bounds\n \n error: aborting due to previous error\n "}, {"sha": "d5e4b8d2372743c357dbcc13434d6e3e377b4168", "filename": "tests/ui/error-codes/E0476.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Fui%2Ferror-codes%2FE0476.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Fui%2Ferror-codes%2FE0476.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0476.rs?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -0,0 +1,13 @@\n+#![feature(coerce_unsized)]\n+#![feature(unsize)]\n+\n+use std::marker::Unsize;\n+use std::ops::CoerceUnsized;\n+\n+struct Wrapper<T>(T);\n+\n+impl<'a, 'b, T, S> CoerceUnsized<&'a Wrapper<T>> for &'b Wrapper<S> where S: Unsize<T> {}\n+//~^ ERROR lifetime of the source pointer does not outlive lifetime bound of the object type [E0476]\n+//~^^ ERROR E0119\n+\n+fn main() {}"}, {"sha": "a4bb26532a24fd08cf815defd52bd30d12b653ed", "filename": "tests/ui/error-codes/E0476.stderr", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Fui%2Ferror-codes%2FE0476.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Fui%2Ferror-codes%2FE0476.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0476.stderr?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -0,0 +1,31 @@\n+error[E0119]: conflicting implementations of trait `CoerceUnsized<&Wrapper<_>>` for type `&Wrapper<_>`\n+  --> $DIR/E0476.rs:9:1\n+   |\n+LL | impl<'a, 'b, T, S> CoerceUnsized<&'a Wrapper<T>> for &'b Wrapper<S> where S: Unsize<T> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: conflicting implementation in crate `core`:\n+           - impl<'a, 'b, T, U> CoerceUnsized<&'a U> for &'b T\n+             where 'b: 'a, T: Unsize<U>, T: ?Sized, U: ?Sized;\n+\n+error[E0476]: lifetime of the source pointer does not outlive lifetime bound of the object type\n+  --> $DIR/E0476.rs:9:1\n+   |\n+LL | impl<'a, 'b, T, S> CoerceUnsized<&'a Wrapper<T>> for &'b Wrapper<S> where S: Unsize<T> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: object type is valid for the lifetime `'a` as defined here\n+  --> $DIR/E0476.rs:9:6\n+   |\n+LL | impl<'a, 'b, T, S> CoerceUnsized<&'a Wrapper<T>> for &'b Wrapper<S> where S: Unsize<T> {}\n+   |      ^^\n+note: source pointer is only valid for the lifetime `'b` as defined here\n+  --> $DIR/E0476.rs:9:10\n+   |\n+LL | impl<'a, 'b, T, S> CoerceUnsized<&'a Wrapper<T>> for &'b Wrapper<S> where S: Unsize<T> {}\n+   |          ^^\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0119, E0476.\n+For more information about an error, try `rustc --explain E0119`."}, {"sha": "e4d7f765b4a8a0ec704be2e83825bcaf45831e91", "filename": "tests/ui/lint/issue-106991.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Fui%2Flint%2Fissue-106991.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Fui%2Flint%2Fissue-106991.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Fissue-106991.rs?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -0,0 +1,13 @@\n+fn foo(items: &mut Vec<u8>) {\n+    items.sort();\n+}\n+\n+fn bar() -> impl Iterator<Item = i32> {\n+    //~^ ERROR expected `foo` to be a fn item that returns `i32`, but it returns `()` [E0271]\n+    let mut x: Vec<Vec<u8>> = vec![vec![0, 2, 1], vec![5, 4, 3]];\n+    x.iter_mut().map(foo)\n+}\n+\n+fn main() {\n+    bar();\n+}"}, {"sha": "7b43f0b2ca8f32f5a5e5279618ff21d80a17ab22", "filename": "tests/ui/lint/issue-106991.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Fui%2Flint%2Fissue-106991.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Fui%2Flint%2Fissue-106991.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Fissue-106991.stderr?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -0,0 +1,11 @@\n+error[E0271]: expected `foo` to be a fn item that returns `i32`, but it returns `()`\n+  --> $DIR/issue-106991.rs:5:13\n+   |\n+LL | fn bar() -> impl Iterator<Item = i32> {\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found `i32`\n+   |\n+   = note: required for `Map<std::slice::IterMut<'_, Vec<u8>>, for<'a> fn(&'a mut Vec<u8>) {foo}>` to implement `Iterator`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0271`."}, {"sha": "dc1ecbf8424d4cf9abb73e1c68dd42ff2e4c0068", "filename": "tests/ui/lint/lint_map_unit_fn.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Fui%2Flint%2Flint_map_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Fui%2Flint%2Flint_map_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Flint_map_unit_fn.rs?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -0,0 +1,20 @@\n+#![deny(map_unit_fn)]\n+\n+fn foo(items: &mut Vec<u8>) {\n+    items.sort();\n+}\n+\n+fn main() {\n+    let mut x: Vec<Vec<u8>> = vec![vec![0, 2, 1], vec![5, 4, 3]];\n+    x.iter_mut().map(foo);\n+    //~^ ERROR `Iterator::map` call that discard the iterator's values\n+    x.iter_mut().map(|items| {\n+    //~^ ERROR `Iterator::map` call that discard the iterator's values\n+        items.sort();\n+    });\n+    let f = |items: &mut Vec<u8>| {\n+        items.sort();\n+    };\n+    x.iter_mut().map(f);\n+    //~^ ERROR `Iterator::map` call that discard the iterator's values\n+}"}, {"sha": "fbf689c54219ebe29782ea688bbe7f3b3163c759", "filename": "tests/ui/lint/lint_map_unit_fn.stderr", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Fui%2Flint%2Flint_map_unit_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Fui%2Flint%2Flint_map_unit_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Flint_map_unit_fn.stderr?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -0,0 +1,66 @@\n+error: `Iterator::map` call that discard the iterator's values\n+  --> $DIR/lint_map_unit_fn.rs:9:18\n+   |\n+LL | fn foo(items: &mut Vec<u8>) {\n+   | --------------------------- this function returns `()`, which is likely not what you wanted\n+...\n+LL |     x.iter_mut().map(foo);\n+   |                  ^^^^---^\n+   |                  |   |\n+   |                  |   called `Iterator::map` with callable that returns `()`\n+   |                  after this call to map, the resulting iterator is `impl Iterator<Item = ()>`, which means the only information carried by the iterator is the number of items\n+   |\n+   = note: `Iterator::map`, like many of the methods on `Iterator`, gets executed lazily, meaning that its effects won't be visible until it is iterated\n+note: the lint level is defined here\n+  --> $DIR/lint_map_unit_fn.rs:1:9\n+   |\n+LL | #![deny(map_unit_fn)]\n+   |         ^^^^^^^^^^^\n+help: you might have meant to use `Iterator::for_each`\n+   |\n+LL |     x.iter_mut().for_each(foo);\n+   |                  ~~~~~~~~\n+\n+error: `Iterator::map` call that discard the iterator's values\n+  --> $DIR/lint_map_unit_fn.rs:11:18\n+   |\n+LL |         x.iter_mut().map(|items| {\n+   |                      ^   -------\n+   |                      |   |\n+   |  ____________________|___this function returns `()`, which is likely not what you wanted\n+   | |  __________________|\n+   | | |\n+LL | | |\n+LL | | |         items.sort();\n+LL | | |     });\n+   | | |     -^ after this call to map, the resulting iterator is `impl Iterator<Item = ()>`, which means the only information carried by the iterator is the number of items\n+   | | |_____||\n+   | |_______|\n+   |         called `Iterator::map` with callable that returns `()`\n+   |\n+   = note: `Iterator::map`, like many of the methods on `Iterator`, gets executed lazily, meaning that its effects won't be visible until it is iterated\n+help: you might have meant to use `Iterator::for_each`\n+   |\n+LL |     x.iter_mut().for_each(|items| {\n+   |                  ~~~~~~~~\n+\n+error: `Iterator::map` call that discard the iterator's values\n+  --> $DIR/lint_map_unit_fn.rs:18:18\n+   |\n+LL |     let f = |items: &mut Vec<u8>| {\n+   |             --------------------- this function returns `()`, which is likely not what you wanted\n+...\n+LL |     x.iter_mut().map(f);\n+   |                  ^^^^-^\n+   |                  |   |\n+   |                  |   called `Iterator::map` with callable that returns `()`\n+   |                  after this call to map, the resulting iterator is `impl Iterator<Item = ()>`, which means the only information carried by the iterator is the number of items\n+   |\n+   = note: `Iterator::map`, like many of the methods on `Iterator`, gets executed lazily, meaning that its effects won't be visible until it is iterated\n+help: you might have meant to use `Iterator::for_each`\n+   |\n+LL |     x.iter_mut().for_each(f);\n+   |                  ~~~~~~~~\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "19ccd2de685a1aade402157b8527eca8af7e5203", "filename": "tests/ui/methods/issues/issue-105732.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Fui%2Fmethods%2Fissues%2Fissue-105732.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Fui%2Fmethods%2Fissues%2Fissue-105732.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods%2Fissues%2Fissue-105732.stderr?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -2,7 +2,7 @@ error[E0380]: auto traits cannot have associated items\n   --> $DIR/issue-105732.rs:4:8\n    |\n LL | auto trait Foo {\n-   |            --- auto trait cannot have associated items\n+   |            --- auto traits cannot have associated items\n LL |     fn g(&self);\n    |     ---^-------- help: remove these associated items\n "}, {"sha": "7639ae9f6a4fd09a334805bf6e102e6e1bacb3e6", "filename": "tests/ui/rfc-2457/mod_file_nonascii_forbidden.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Fui%2Frfc-2457%2Fmod_file_nonascii_forbidden.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Fui%2Frfc-2457%2Fmod_file_nonascii_forbidden.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2457%2Fmod_file_nonascii_forbidden.stderr?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -12,7 +12,7 @@ error[E0754]: trying to load file for module `\u0159\u0173\u015b\u0165` with non-ascii identifie\n LL | mod \u0159\u0173\u015b\u0165;\n    |     ^^^^\n    |\n-   = help: consider using `#[path]` attribute to specify filesystem path\n+   = help: consider using the `#[path]` attribute to specify filesystem path\n \n error: aborting due to 2 previous errors\n "}, {"sha": "818d228bc91c5b08828d718dde3862bf239a1ebd", "filename": "tests/ui/stability-attribute/unresolved_stability_lint.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Fui%2Fstability-attribute%2Funresolved_stability_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Fui%2Fstability-attribute%2Funresolved_stability_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstability-attribute%2Funresolved_stability_lint.rs?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -0,0 +1,8 @@\n+#![feature(staged_api)]\n+#![stable(feature = \"uwu\", since = \"1.0.0\")]\n+\n+#[unstable(feature = \"foo\", issue = \"none\")]\n+impl Foo for () {}\n+//~^ ERROR cannot find trait `Foo` in this scope\n+\n+fn main() {}"}, {"sha": "11d6abcaf361f27361bb11d9bed1b624bf0946f1", "filename": "tests/ui/stability-attribute/unresolved_stability_lint.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Fui%2Fstability-attribute%2Funresolved_stability_lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Fui%2Fstability-attribute%2Funresolved_stability_lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstability-attribute%2Funresolved_stability_lint.stderr?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -0,0 +1,9 @@\n+error[E0405]: cannot find trait `Foo` in this scope\n+  --> $DIR/unresolved_stability_lint.rs:5:6\n+   |\n+LL | impl Foo for () {}\n+   |      ^^^ not found in this scope\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0405`."}, {"sha": "dc967d51298710e841ce8739a3ca60ea2ab6fba1", "filename": "tests/ui/traits/inductive-overflow/supertrait-auto-trait.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Fui%2Ftraits%2Finductive-overflow%2Fsupertrait-auto-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/70fd012439d75fd6ce561a6518b9b8fd399f455f/tests%2Fui%2Ftraits%2Finductive-overflow%2Fsupertrait-auto-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Finductive-overflow%2Fsupertrait-auto-trait.stderr?ref=70fd012439d75fd6ce561a6518b9b8fd399f455f", "patch": "@@ -4,7 +4,7 @@ error[E0568]: auto traits cannot have super traits or lifetime bounds\n LL | auto trait Magic: Copy {}\n    |            -----^^^^^^ help: remove the super traits or lifetime bounds\n    |            |\n-   |            auto trait cannot have super traits or lifetime bounds\n+   |            auto traits cannot have super traits or lifetime bounds\n \n error[E0277]: the trait bound `NoClone: Copy` is not satisfied\n   --> $DIR/supertrait-auto-trait.rs:16:23"}]}