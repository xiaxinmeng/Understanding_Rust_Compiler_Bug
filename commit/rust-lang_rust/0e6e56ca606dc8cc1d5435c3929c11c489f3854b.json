{"sha": "0e6e56ca606dc8cc1d5435c3929c11c489f3854b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlNmU1NmNhNjA2ZGM4Y2MxZDU0MzVjMzkyOWMxMWM0ODlmMzg1NGI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-12T08:05:40Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-12T09:07:17Z"}, "message": "Make the names of the arg mode tag reflect their (revised) meaning", "tree": {"sha": "ac206c7aa885357d93a692ec36a94b46b3bc48fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac206c7aa885357d93a692ec36a94b46b3bc48fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e6e56ca606dc8cc1d5435c3929c11c489f3854b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e6e56ca606dc8cc1d5435c3929c11c489f3854b", "html_url": "https://github.com/rust-lang/rust/commit/0e6e56ca606dc8cc1d5435c3929c11c489f3854b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e6e56ca606dc8cc1d5435c3929c11c489f3854b/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4be7e1e5cd10646acc814da147f4e91dd610d45a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4be7e1e5cd10646acc814da147f4e91dd610d45a", "html_url": "https://github.com/rust-lang/rust/commit/4be7e1e5cd10646acc814da147f4e91dd610d45a"}], "stats": {"total": 145, "additions": 54, "deletions": 91}, "files": [{"sha": "f5ef18066d1d6f48146de3424439075c2d4baaf1", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e6e56ca606dc8cc1d5435c3929c11c489f3854b/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e6e56ca606dc8cc1d5435c3929c11c489f3854b/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=0e6e56ca606dc8cc1d5435c3929c11c489f3854b", "patch": "@@ -290,7 +290,8 @@ fn mk_main(cx: &test_ctxt) -> @ast::item {\n     let args_ty: ast::ty = nospan(ast::ty_vec(args_mt));\n \n     let args_arg: ast::arg =\n-        {mode: ast::val, ty: @args_ty, ident: \"args\", id: cx.next_node_id()};\n+        {mode: ast::by_ref, ty: @args_ty, ident: \"args\",\n+         id: cx.next_node_id()};\n \n     let ret_ty = nospan(ast::ty_nil);\n "}, {"sha": "788c5d0bc5d2b7a9be083a61525e0a6ee05627e4", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0e6e56ca606dc8cc1d5435c3929c11c489f3854b/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e6e56ca606dc8cc1d5435c3929c11c489f3854b/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=0e6e56ca606dc8cc1d5435c3929c11c489f3854b", "patch": "@@ -379,16 +379,12 @@ fn parse_ty_fn(st: @pstate, sd: str_def) ->\n     assert (next(st) as char == '[');\n     let inputs: [ty::arg] = [];\n     while peek(st) as char != ']' {\n-        let mode = ty::mo_val;\n+        let mode = ast::by_ref;\n         if peek(st) as char == '&' {\n-            mode = ty::mo_alias(false);\n+            mode = ast::by_mut_ref;\n             st.pos += 1u;\n-            if peek(st) as char == 'm' {\n-                mode = ty::mo_alias(true);\n-                st.pos += 1u;\n-            }\n         } else if peek(st) as char == '-' {\n-            mode = ty::mo_move;\n+            mode = ast::by_move;\n             st.pos += 1u;\n         }\n         inputs += [{mode: mode, ty: parse_ty(st, sd)}];"}, {"sha": "999a3c65716179e9eaf1b67fa69a4fa3aea37413", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0e6e56ca606dc8cc1d5435c3929c11c489f3854b/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e6e56ca606dc8cc1d5435c3929c11c489f3854b/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=0e6e56ca606dc8cc1d5435c3929c11c489f3854b", "patch": "@@ -207,12 +207,9 @@ fn enc_ty_fn(w: &io::writer, cx: &@ctxt, args: &[ty::arg], out: ty::t,\n     w.write_char('[');\n     for arg: ty::arg in args {\n         alt arg.mode {\n-          ty::mo_alias(mut) {\n-            w.write_char('&');\n-            if mut { w.write_char('m'); }\n-          }\n-          ty::mo_move. { w.write_char('-'); }\n-          ty::mo_val. { }\n+          by_mut_ref. { w.write_char('&'); }\n+          by_move. { w.write_char('-'); }\n+          by_ref. { }\n         }\n         enc_ty(w, cx, arg.ty);\n     }"}, {"sha": "03cd853e9a2e024c89998299efea14788d8d1383", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e6e56ca606dc8cc1d5435c3929c11c489f3854b/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e6e56ca606dc8cc1d5435c3929c11c489f3854b/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=0e6e56ca606dc8cc1d5435c3929c11c489f3854b", "patch": "@@ -180,7 +180,7 @@ fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope)\n     for arg_t: ty::arg in arg_ts {\n         let arg = args[i];\n         let root = expr_root(cx.tcx, arg, false);\n-        if arg_t.mode == ty::mo_alias(true) {\n+        if arg_t.mode == ast::by_mut_ref {\n             alt path_def(cx, arg) {\n               some(def) {\n                 let dnum = ast_util::def_id_of_def(def).node;\n@@ -202,7 +202,7 @@ fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope)\n                depends_on: deps(sc, root_var),\n                mutable ok: valid,\n                // FIXME kludge\n-               mutable given_up: arg_t.mode == ty::mo_move}];\n+               mutable given_up: arg_t.mode == ast::by_move}];\n         i += 1u;\n     }\n     let f_may_close =\n@@ -228,7 +228,7 @@ fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope)\n           some(ty) {\n             let i = 0u;\n             for arg_t: ty::arg in arg_ts {\n-                let mut_alias = arg_t.mode == ty::mo_alias(true);\n+                let mut_alias = arg_t.mode == ast::by_mut_ref;\n                 if i != j &&\n                    ty_can_unsafely_include(cx, ty, arg_t.ty, mut_alias) &&\n                    cant_copy(cx, r) {"}, {"sha": "a257064853582dbb3a99f8661ab7da49eca8c03d", "filename": "src/comp/middle/mut.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0e6e56ca606dc8cc1d5435c3929c11c489f3854b/src%2Fcomp%2Fmiddle%2Fmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e6e56ca606dc8cc1d5435c3929c11c489f3854b/src%2Fcomp%2Fmiddle%2Fmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmut.rs?ref=0e6e56ca606dc8cc1d5435c3929c11c489f3854b", "patch": "@@ -193,7 +193,9 @@ fn check_lval(cx: &@ctx, dest: &@expr, msg: msg) {\n       _ {\n         let root = expr_root(cx.tcx, dest, false);\n         if vec::len(*root.ds) == 0u {\n-            mk_err(cx, dest.span, msg, \"non-lvalue\");\n+            if msg == msg_assign {\n+                mk_err(cx, dest.span, msg, \"non-lvalue\");\n+            }\n         } else if !root.ds[0].mut {\n             let name =\n                 alt root.ds[0].kind {\n@@ -235,7 +237,7 @@ fn check_call(cx: &@ctx, f: &@expr, args: &[@expr]) {\n                        ty::type_autoderef(cx.tcx, ty::expr_ty(cx.tcx, f)));\n     let i = 0u;\n     for arg_t: ty::arg in arg_ts {\n-        if arg_t.mode == ty::mo_alias(true) {\n+        if arg_t.mode != by_ref {\n             check_lval(cx, args[i], msg_mut_alias);\n         }\n         i += 1u;\n@@ -249,7 +251,6 @@ fn is_immutable_def(def: &def) -> option::t<str> {\n         some(\"static item\")\n       }\n       def_obj_field(_, imm.) { some(\"immutable object field\") }\n-      def_arg(_, alias(false)) { some(\"immutable alias\") }\n       def_upvar(_, inner, mut) {\n         if !mut { some(\"upvar\") } else { is_immutable_def(*inner) }\n       }"}, {"sha": "3d0cd917f536372e319b5c37840348bb7cc6c93a", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0e6e56ca606dc8cc1d5435c3929c11c489f3854b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e6e56ca606dc8cc1d5435c3929c11c489f3854b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=0e6e56ca606dc8cc1d5435c3929c11c489f3854b", "patch": "@@ -3516,7 +3516,7 @@ fn trans_arg_expr(cx: &@block_ctxt, arg: &ty::arg, lldestty0: TypeRef,\n         // be inspected. It's important for the value\n         // to have type lldestty0 (the callee's expected type).\n         val = llvm::LLVMGetUndef(lldestty0);\n-    } else if arg.mode == ty::mo_val || arg.mode == ty::mo_alias(false) {\n+    } else if arg.mode == ast::by_ref {\n         let copied = false;\n         if !lv.is_mem && type_is_immediate(ccx, e_ty) {\n             val = do_spill_noroot(bcx, val);\n@@ -3545,7 +3545,7 @@ fn trans_arg_expr(cx: &@block_ctxt, arg: &ty::arg, lldestty0: TypeRef,\n     }\n \n     // Collect arg for later if it happens to be one we've moving out.\n-    if arg.mode == ty::mo_move {\n+    if arg.mode == ast::by_move {\n         if lv.is_mem {\n             // Use actual ty, not declared ty -- anything else doesn't make\n             // sense if declared ty is a ty param\n@@ -4241,7 +4241,7 @@ fn trans_put(in_cx: &@block_ctxt, e: &option::t<@ast::expr>) -> result {\n       none. { }\n       some(x) {\n         let e_ty = ty::expr_ty(bcx_tcx(cx), x);\n-        let arg = {mode: ty::mo_alias(false), ty: e_ty};\n+        let arg = {mode: ast::by_ref, ty: e_ty};\n         let arg_tys = type_of_explicit_args(bcx_ccx(cx), x.span, [arg]);\n         let z = [];\n         let k = [];\n@@ -4867,7 +4867,7 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, scope: @block_ctxt, args: &[ast::arg],\n     for aarg: ast::arg in args {\n         let arg_ty = arg_tys[arg_n].ty;\n         alt aarg.mode {\n-          ast::val. | ast::alias(false) {\n+          ast::by_ref. {\n             let mutated = !ignore_mut &&\n                 fcx.lcx.ccx.mut_map.contains_key(aarg.id);\n             // Overwrite the llargs entry for locally mutated params\n@@ -4881,7 +4881,7 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, scope: @block_ctxt, args: &[ast::arg],\n                 add_clean(scope, alloc, arg_ty);\n             }\n           }\n-          ast::move. {\n+          ast::by_move. {\n             add_clean(scope, bcx.fcx.llargs.get(aarg.id), arg_ty);\n           }\n           _ { }\n@@ -5109,7 +5109,7 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n     let i = 0u;\n     for varg: ast::variant_arg in variant.node.args {\n         fn_args +=\n-            [{mode: ast::alias(false),\n+            [{mode: ast::by_ref,\n               ty: varg.ty,\n               ident: \"arg\" + uint::to_str(i, 10u),\n               id: varg.id}];\n@@ -5334,7 +5334,7 @@ fn create_main_wrapper(ccx: &@crate_ctxt, sp: &span, main_llfn: ValueRef,\n                    takes_argv: bool) -> ValueRef {\n         let unit_ty = ty::mk_str(ccx.tcx);\n         let vecarg_ty: ty::arg =\n-            {mode: ty::mo_val,\n+            {mode: ast::by_ref,\n              ty: ty::mk_vec(ccx.tcx, {ty: unit_ty, mut: ast::imm})};\n         let llfty =\n             type_of_fn(ccx, sp, ast::proto_fn, [vecarg_ty],\n@@ -5528,7 +5528,7 @@ fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[str],\n     }\n     fn convert_arg_to_i32(cx: &@block_ctxt, v: ValueRef, t: ty::t,\n                           mode: ty::mode) -> ValueRef {\n-        if mode == ty::mo_val {\n+        if mode == ast::by_ref {\n             if ty::type_is_integral(bcx_tcx(cx), t) {\n                 // FIXME: would be nice to have a postcondition that says\n                 // if a type is integral, then it has static size (#586)\n@@ -5582,7 +5582,7 @@ fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[str],\n     let i = arg_n;\n     for arg: ty::arg in args {\n         let llarg = llvm::LLVMGetParam(fcx.llfn, i);\n-        if arg.mode == ty::mo_val {\n+        if arg.mode == ast::by_ref {\n             llarg = load_if_immediate(bcx, llarg, arg.ty);\n         }\n         assert (llarg as int != 0);"}, {"sha": "7322bb50df768f952c98207c67c25d12dfc80650", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e6e56ca606dc8cc1d5435c3929c11c489f3854b/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e6e56ca606dc8cc1d5435c3929c11c489f3854b/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=0e6e56ca606dc8cc1d5435c3929c11c489f3854b", "patch": "@@ -358,7 +358,7 @@ fn get_res_dtor(ccx: &@crate_ctxt, sp: &span, did: &ast::def_id,\n     let params = csearch::get_type_param_count(ccx.sess.get_cstore(), did);\n     let f_t =\n         trans::type_of_fn(ccx, sp, ast::proto_fn,\n-                          [{mode: ty::mo_alias(false), ty: inner_t}],\n+                          [{mode: ast::by_ref, ty: inner_t}],\n                           ty::mk_nil(ccx.tcx), params);\n     ret trans::get_extern_const(ccx.externs, ccx.llmod,\n                                 csearch::get_symbol(ccx.sess.get_cstore(),"}, {"sha": "392d8fccbedf3977c48f4757309f08cb9bff650f", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0e6e56ca606dc8cc1d5435c3929c11c489f3854b/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e6e56ca606dc8cc1d5435c3929c11c489f3854b/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=0e6e56ca606dc8cc1d5435c3929c11c489f3854b", "patch": "@@ -49,7 +49,7 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n     let fn_args: [ast::arg] = [];\n     for f: ast::obj_field in ob.fields {\n         fn_args +=\n-            [{mode: ast::alias(false), ty: f.ty, ident: f.ident, id: f.id}];\n+            [{mode: ast::by_ref, ty: f.ty, ident: f.ident, id: f.id}];\n     }\n     let fcx = new_fn_ctxt(cx, sp, llctor_decl);\n \n@@ -689,12 +689,8 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     // function (they're in fcx.llargs) to llouter_mthd_args.\n \n     let a: uint = 3u; // retptr, task ptr, env come first\n-    let passed_arg: ValueRef = llvm::LLVMGetParam(llbackwarding_fn, a);\n     for arg: ty::arg in m.inputs {\n-        if arg.mode == ty::mo_val {\n-            passed_arg = load_if_immediate(bcx, passed_arg, arg.ty);\n-        }\n-        llouter_mthd_args += [passed_arg];\n+        llouter_mthd_args += [llvm::LLVMGetParam(llbackwarding_fn, a)];\n         a += 1u;\n     }\n \n@@ -861,12 +857,8 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     // function (they're in fcx.llargs) to llorig_mthd_args.\n \n     let a: uint = 3u; // retptr, task ptr, env come first\n-    let passed_arg: ValueRef = llvm::LLVMGetParam(llforwarding_fn, a);\n     for arg: ty::arg in m.inputs {\n-        if arg.mode == ty::mo_val {\n-            passed_arg = load_if_immediate(bcx, passed_arg, arg.ty);\n-        }\n-        llorig_mthd_args += [passed_arg];\n+        llorig_mthd_args += [llvm::LLVMGetParam(llforwarding_fn, a)];\n         a += 1u;\n     }\n "}, {"sha": "63ff90c4792f1d689e3b4257bda56083636ceabf", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e6e56ca606dc8cc1d5435c3929c11c489f3854b/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e6e56ca606dc8cc1d5435c3929c11c489f3854b/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=0e6e56ca606dc8cc1d5435c3929c11c489f3854b", "patch": "@@ -1113,7 +1113,7 @@ fn callee_modes(fcx: &fn_ctxt, callee: node_id) -> [ty::mode] {\n \n fn callee_arg_init_ops(fcx: &fn_ctxt, callee: node_id) -> [init_op] {\n     fn mode_to_op(m: &ty::mode) -> init_op {\n-        alt m { ty::mo_move. { init_move } _ { init_assign } }\n+        alt m { by_move. { init_move } _ { init_assign } }\n     }\n     vec::map(mode_to_op, callee_modes(fcx, callee))\n }"}, {"sha": "72fef222e7d2547bdf8d3b6195ceb8089e6c8f7d", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e6e56ca606dc8cc1d5435c3929c11c489f3854b/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e6e56ca606dc8cc1d5435c3929c11c489f3854b/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=0e6e56ca606dc8cc1d5435c3929c11c489f3854b", "patch": "@@ -311,7 +311,7 @@ fn forget_args_moved_in(fcx: &fn_ctxt, parent: &@expr, modes: &[ty::mode],\n                         operands: &[@expr]) {\n     let i = 0u;\n     for mode: ty::mode in modes {\n-        if mode == ty::mo_move {\n+        if mode == by_move {\n             forget_in_postcond(fcx, parent.id, operands[i].id);\n         }\n         i += 1u;"}, {"sha": "eb829a0760dbf77e8fb92c356ec4f25f98c21bcd", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e6e56ca606dc8cc1d5435c3929c11c489f3854b/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e6e56ca606dc8cc1d5435c3929c11c489f3854b/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=0e6e56ca606dc8cc1d5435c3929c11c489f3854b", "patch": "@@ -86,9 +86,6 @@ export mk_uniq;\n export mk_var;\n export mk_iter_body_fn;\n export mode;\n-export mo_val;\n-export mo_alias;\n-export mo_move;\n export mt;\n export node_type_table;\n export pat_ty;\n@@ -177,7 +174,6 @@ export walk_ty;\n export occurs_check_fails;\n \n // Data types\n-tag mode { mo_val; mo_alias(bool); mo_move; }\n \n type arg = {mode: mode, ty: t};\n \n@@ -587,7 +583,7 @@ fn mk_type(_cx: &ctxt) -> t { ret idx_type; }\n fn mk_native(cx: &ctxt, did: &def_id) -> t { ret gen_ty(cx, ty_native(did)); }\n \n fn mk_iter_body_fn(cx: &ctxt, output: t) -> t {\n-    ret mk_fn(cx, ast::proto_block, [{mode: ty::mo_alias(false), ty: output}],\n+    ret mk_fn(cx, ast::proto_block, [{mode: ast::by_ref, ty: output}],\n               ty::mk_nil(cx), ast::return, []);\n }\n "}, {"sha": "3d68eaabff7110f74f4b940e7b0038914518d1fa", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0e6e56ca606dc8cc1d5435c3929c11c489f3854b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e6e56ca606dc8cc1d5435c3929c11c489f3854b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=0e6e56ca606dc8cc1d5435c3929c11c489f3854b", "patch": "@@ -20,9 +20,6 @@ import middle::ty::block_ty;\n import middle::ty::expr_ty;\n import middle::ty::field;\n import middle::ty::method;\n-import middle::ty::mo_val;\n-import middle::ty::mo_alias;\n-import middle::ty::mo_move;\n import middle::ty::node_type_table;\n import middle::ty::pat_ty;\n import middle::ty::ty_param_substs_opt_and_ty;\n@@ -213,15 +210,6 @@ fn instantiate_path(fcx: &@fn_ctxt, pth: &ast::path,\n     ret {substs: ty_substs_opt, ty: tpt.ty};\n }\n \n-fn ast_mode_to_mode(mode: ast::mode) -> ty::mode {\n-    alt mode {\n-      ast::val. { mo_val }\n-      ast::alias(mut) { mo_alias(mut) }\n-      ast::move. { mo_move }\n-    }\n-}\n-\n-\n // Type tests\n fn structurally_resolved_type(fcx: &@fn_ctxt, sp: &span, tp: ty::t) -> ty::t {\n     alt ty::unify::resolve_type_structure(fcx.ccx.tcx, fcx.var_bindings, tp) {\n@@ -282,8 +270,7 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n     tcx.ast_ty_to_ty_cache.insert(ast_ty, none::<ty::t>);\n     fn ast_arg_to_arg(tcx: &ty::ctxt, getter: &ty_getter, arg: &ast::ty_arg)\n        -> {mode: ty::mode, ty: ty::t} {\n-        let ty_mode = ast_mode_to_mode(arg.node.mode);\n-        ret {mode: ty_mode, ty: ast_ty_to_ty(tcx, getter, arg.node.ty)};\n+        ret {mode: arg.node.mode, ty: ast_ty_to_ty(tcx, getter, arg.node.ty)};\n     }\n     fn ast_mt_to_mt(tcx: &ty::ctxt, getter: &ty_getter, mt: &ast::mt) ->\n        ty::mt {\n@@ -592,10 +579,9 @@ mod collect {\n         ret tpt;\n     }\n     fn ty_of_arg(cx: @ctxt, a: &ast::arg) -> ty::arg {\n-        let ty_mode = ast_mode_to_mode(a.mode);\n         let f = bind getter(cx, _);\n         let tt = ast_ty_to_ty(cx.tcx, f, a.ty);\n-        ret {mode: ty_mode, ty: tt};\n+        ret {mode: a.mode, ty: tt};\n     }\n     fn ty_of_method(cx: @ctxt, m: &@ast::method) -> ty::method {\n         let get = bind getter(cx, _);\n@@ -635,7 +621,7 @@ mod collect {\n         for f: ast::obj_field in ob.fields {\n             let g = bind getter(cx, _);\n             let t_field = ast_ty_to_ty(cx.tcx, g, f.ty);\n-            t_inputs += [{mode: ty::mo_alias(false), ty: t_field}];\n+            t_inputs += [{mode: ast::by_ref, ty: t_field}];\n         }\n \n         let t_fn =\n@@ -745,7 +731,7 @@ mod collect {\n                 let args: [arg] = [];\n                 for va: ast::variant_arg in variant.node.args {\n                     let arg_ty = ast_ty_to_ty(cx.tcx, f, va.ty);\n-                    args += [{mode: ty::mo_alias(false), ty: arg_ty}];\n+                    args += [{mode: ast::by_ref, ty: arg_ty}];\n                 }\n                 let tag_t = ty::mk_tag(cx.tcx, tag_id, ty_param_tys);\n                 // FIXME: this will be different for constrained types\n@@ -1605,7 +1591,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n                                            } else { \"s were\" }]);\n             // HACK: build an arguments list with dummy arguments to\n             // check against\n-            let dummy = {mode: ty::mo_val, ty: ty::mk_bot(fcx.ccx.tcx)};\n+            let dummy = {mode: ast::by_ref, ty: ty::mk_bot(fcx.ccx.tcx)};\n             arg_tys = vec::init_elt(dummy, supplied_arg_count);\n         }\n \n@@ -2018,9 +2004,8 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n         let convert = bind ast_ty_to_ty_crate_tyvar(fcx, _);\n         let ty_of_arg =\n             lambda (a: &ast::arg) -> ty::arg {\n-                let ty_mode = ast_mode_to_mode(a.mode);\n                 let tt = ast_ty_to_ty_crate_tyvar(fcx, a.ty);\n-                ret {mode: ty_mode, ty: tt};\n+                ret {mode: a.mode, ty: tt};\n             };\n         let fty =\n             collect::ty_of_fn_decl(cx, convert, ty_of_arg, f.decl, f.proto,\n@@ -2292,8 +2277,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n         // FIXME: These next three functions are largely ripped off from\n         // similar ones in collect::.  Is there a better way to do this?\n         fn ty_of_arg(ccx: @crate_ctxt, a: &ast::arg) -> ty::arg {\n-            let ty_mode = ast_mode_to_mode(a.mode);\n-            ret {mode: ty_mode, ty: ast_ty_to_ty_crate(ccx, a.ty)};\n+            ret {mode: a.mode, ty: ast_ty_to_ty_crate(ccx, a.ty)};\n         }\n \n         fn ty_of_method(ccx: @crate_ctxt, m: &@ast::method) -> ty::method {"}, {"sha": "67d0f6022f7234ffc4e23527db8ece408be7b8be", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e6e56ca606dc8cc1d5435c3929c11c489f3854b/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e6e56ca606dc8cc1d5435c3929c11c489f3854b/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=0e6e56ca606dc8cc1d5435c3929c11c489f3854b", "patch": "@@ -127,7 +127,7 @@ tag binop {\n \n tag unop { box(mutability); deref; not; neg; }\n \n-tag mode { val; alias(bool); move; }\n+tag mode { by_ref; by_mut_ref; by_move; }\n \n type stmt = spanned<stmt_>;\n \n@@ -296,7 +296,7 @@ tag ty_ {\n      /* bot represents the value of functions that don't return a value\n         locally to their context. in contrast, things like log that do\n         return, but don't return a meaningful value, have result type nil. */\n-     ty_bool;\n+    ty_bool;\n     ty_int;\n     ty_uint;\n     ty_float;"}, {"sha": "a6ffde02c55259a0431504ff0c13031f44eec8b7", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0e6e56ca606dc8cc1d5435c3929c11c489f3854b/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e6e56ca606dc8cc1d5435c3929c11c489f3854b/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=0e6e56ca606dc8cc1d5435c3929c11c489f3854b", "patch": "@@ -285,11 +285,7 @@ fn parse_ty_fn(proto: ast::proto, p: &parser) -> ast::ty_ {\n             p.bump();\n             p.bump();\n         }\n-        let mode = ast::val;\n-        if p.peek() == token::BINOP(token::AND) {\n-            p.bump();\n-            mode = ast::alias(eat_word(p, \"mutable\"));\n-        }\n+        let mode = parse_arg_mode(p);\n         let t = parse_ty(p, false);\n         ret spanned(lo, t.span.hi, {mode: mode, ty: t});\n     }\n@@ -583,11 +579,13 @@ fn parse_ty(p: &parser, colons_before_params: bool) -> @ast::ty {\n }\n \n fn parse_arg_mode(p: &parser) -> ast::mode {\n+    let mode = ast::by_ref;\n     if eat(p, token::BINOP(token::AND)) {\n-        ast::alias(eat_word(p, \"mutable\"))\n+        if eat_word(p, \"mutable\") { mode = ast::by_mut_ref; }\n     } else if eat(p, token::BINOP(token::MINUS)) {\n-        ast::move\n-    } else { ast::val }\n+        mode = ast::by_move;\n+    }\n+    ret mode;\n }\n \n fn parse_arg(p: &parser) -> ast::arg {\n@@ -1868,7 +1866,7 @@ fn parse_item_res(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n     let dtor = parse_block(p);\n     let decl =\n         {inputs:\n-             [{mode: ast::alias(false),\n+             [{mode: ast::by_ref,\n                ty: t,\n                ident: arg_ident,\n                id: p.get_id()}],"}, {"sha": "38e2dbed5b6c0ac953a3100c062e238949431c5c", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0e6e56ca606dc8cc1d5435c3929c11c489f3854b/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e6e56ca606dc8cc1d5435c3929c11c489f3854b/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=0e6e56ca606dc8cc1d5435c3929c11c489f3854b", "patch": "@@ -1243,10 +1243,9 @@ fn print_fn_block_args(s: &ps, decl: &ast::fn_decl) {\n \n fn print_alias(s: &ps, m: ast::mode) {\n     alt m {\n-      ast::alias(true) { word_space(s, \"&mutable\"); }\n-      ast::alias(false) { word(s.s, \"&\"); }\n-      ast::move. { word(s.s, \"-\"); }\n-      ast::val. { }\n+      ast::by_mut_ref. { word_space(s, \"&mutable\"); }\n+      ast::by_move. { word(s.s, \"-\"); }\n+      ast::by_ref. { }\n     }\n }\n "}, {"sha": "ac2d2bd752c98f384086a24302dbb8c110522abd", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0e6e56ca606dc8cc1d5435c3929c11c489f3854b/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e6e56ca606dc8cc1d5435c3929c11c489f3854b/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=0e6e56ca606dc8cc1d5435c3929c11c489f3854b", "patch": "@@ -23,15 +23,14 @@ import metadata::csearch;\n \n fn mode_str(m: &ty::mode) -> str {\n     alt m {\n-      mo_val. { \"\" }\n-      mo_alias(false) { \"&\" }\n-      mo_alias(true) { \"&mutable \" }\n-      mo_move. { \"-\" }\n+      ast::by_ref. { \"\" }\n+      ast::by_mut_ref. { \"&\" }\n+      ast::by_move. { \"-\" }\n     }\n }\n \n fn mode_str_1(m: &ty::mode) -> str {\n-    alt m { mo_val. { \"val\" } _ { mode_str(m) } }\n+    alt m { ast::by_ref. { \"ref\" } _ { mode_str(m) } }\n }\n \n fn fn_ident_to_string(id: ast::node_id, i: &ast::fn_ident) -> str {"}]}