{"sha": "26398b4f6d7b9016f1ddb6c23b5090cd98f1fa2e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2Mzk4YjRmNmQ3YjkwMTZmMWRkYjZjMjNiNTA5MGNkOThmMWZhMmU=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-06T18:37:24Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-13T12:21:45Z"}, "message": "Introduce a common recursion limit for auto-dereference and monomorphization.", "tree": {"sha": "bb13c1add07637c54bf252ef00fbda6eda0bde8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb13c1add07637c54bf252ef00fbda6eda0bde8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26398b4f6d7b9016f1ddb6c23b5090cd98f1fa2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26398b4f6d7b9016f1ddb6c23b5090cd98f1fa2e", "html_url": "https://github.com/rust-lang/rust/commit/26398b4f6d7b9016f1ddb6c23b5090cd98f1fa2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26398b4f6d7b9016f1ddb6c23b5090cd98f1fa2e/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20b4e159edb54cecb8abdedb187ba05a869b3bf0", "url": "https://api.github.com/repos/rust-lang/rust/commits/20b4e159edb54cecb8abdedb187ba05a869b3bf0", "html_url": "https://github.com/rust-lang/rust/commit/20b4e159edb54cecb8abdedb187ba05a869b3bf0"}], "stats": {"total": 114, "additions": 56, "deletions": 58}, "files": [{"sha": "10b209c998bc1eac94d92bbebc70429356a17282", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26398b4f6d7b9016f1ddb6c23b5090cd98f1fa2e/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26398b4f6d7b9016f1ddb6c23b5090cd98f1fa2e/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=26398b4f6d7b9016f1ddb6c23b5090cd98f1fa2e", "patch": "@@ -1020,7 +1020,8 @@ pub fn build_session_(sopts: @session::Options,\n         lints: RefCell::new(HashMap::new()),\n         node_id: Cell::new(1),\n         crate_types: @RefCell::new(Vec::new()),\n-        features: front::feature_gate::Features::new()\n+        features: front::feature_gate::Features::new(),\n+        recursion_limit: Cell::new(64),\n     }\n }\n "}, {"sha": "b4e1516074e6f58f2e18dfdc2e860455132a87f7", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26398b4f6d7b9016f1ddb6c23b5090cd98f1fa2e/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26398b4f6d7b9016f1ddb6c23b5090cd98f1fa2e/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=26398b4f6d7b9016f1ddb6c23b5090cd98f1fa2e", "patch": "@@ -194,7 +194,11 @@ pub struct Session_ {\n                            Vec<(lint::Lint, codemap::Span, ~str)> >>,\n     node_id: Cell<ast::NodeId>,\n     crate_types: @RefCell<Vec<CrateType> >,\n-    features: front::feature_gate::Features\n+    features: front::feature_gate::Features,\n+\n+    /// The maximum recursion limit for potentially infinitely recursive\n+    /// operations such as auto-dereference and monomorphization.\n+    recursion_limit: Cell<uint>,\n }\n \n pub type Session = @Session_;"}, {"sha": "b39bcfb075fab5ba68c986fbb0e9ddba3a8f1d2d", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26398b4f6d7b9016f1ddb6c23b5090cd98f1fa2e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26398b4f6d7b9016f1ddb6c23b5090cd98f1fa2e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=26398b4f6d7b9016f1ddb6c23b5090cd98f1fa2e", "patch": "@@ -172,11 +172,11 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n         // Random cut-off -- code that needs to instantiate the same function\n         // recursively more than thirty times can probably safely be assumed\n         // to be causing an infinite expansion.\n-        if depth > 30 {\n-            ccx.sess.span_fatal(\n-                ccx.tcx.map.span(fn_id.node),\n-                \"overly deep expansion of inlined function\");\n+        if depth > ccx.sess.recursion_limit.get() {\n+            ccx.sess.span_fatal(ccx.tcx.map.span(fn_id.node),\n+                \"reached the recursion limit during monomorphization\");\n         }\n+\n         monomorphizing.get().insert(fn_id, depth + 1);\n     }\n "}, {"sha": "9d0fb8669169845880d5912a40175c5487b6edbc", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/26398b4f6d7b9016f1ddb6c23b5090cd98f1fa2e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26398b4f6d7b9016f1ddb6c23b5090cd98f1fa2e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=26398b4f6d7b9016f1ddb6c23b5090cd98f1fa2e", "patch": "@@ -3467,37 +3467,6 @@ pub fn param_tys_in_type(ty: t) -> Vec<param_ty> {\n     rslt\n }\n \n-pub fn occurs_check(tcx: ctxt, sp: Span, vid: TyVid, rt: t) {\n-    // Returns a vec of all the type variables occurring in `ty`. It may\n-    // contain duplicates.  (Integral type vars aren't counted.)\n-    fn vars_in_type(ty: t) -> Vec<TyVid> {\n-        let mut rslt = Vec::new();\n-        walk_ty(ty, |ty| {\n-            match get(ty).sty {\n-              ty_infer(TyVar(v)) => rslt.push(v),\n-              _ => ()\n-            }\n-        });\n-        rslt\n-    }\n-\n-    // Fast path\n-    if !type_needs_infer(rt) { return; }\n-\n-    // Occurs check!\n-    if vars_in_type(rt).contains(&vid) {\n-            // Maybe this should be span_err -- however, there's an\n-            // assertion later on that the type doesn't contain\n-            // variables, so in this case we have to be sure to die.\n-            tcx.sess.span_fatal\n-                (sp, ~\"type inference failed because I \\\n-                     could not find a type\\n that's both of the form \"\n-                 + ::util::ppaux::ty_to_str(tcx, mk_var(tcx, vid)) +\n-                 \" and of the form \" + ::util::ppaux::ty_to_str(tcx, rt) +\n-                 \" - such a type would have to be infinitely large.\");\n-    }\n-}\n-\n pub fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n     match get(t).sty {\n         ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) |"}, {"sha": "e3db7f16064a4a44f53f0663cd1dfa1de959834b", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/26398b4f6d7b9016f1ddb6c23b5090cd98f1fa2e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26398b4f6d7b9016f1ddb6c23b5090cd98f1fa2e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=26398b4f6d7b9016f1ddb6c23b5090cd98f1fa2e", "patch": "@@ -1241,7 +1241,7 @@ pub enum LvaluePreference {\n     NoPreference\n }\n \n-pub fn autoderef<T>(fcx: @FnCtxt, sp: Span, t: ty::t,\n+pub fn autoderef<T>(fcx: @FnCtxt, sp: Span, base_ty: ty::t,\n                     expr_id: Option<ast::NodeId>,\n                     mut lvalue_pref: LvaluePreference,\n                     should_stop: |ty::t, uint| -> Option<T>)\n@@ -1253,24 +1253,10 @@ pub fn autoderef<T>(fcx: @FnCtxt, sp: Span, t: ty::t,\n      * responsible for inserting an AutoAdjustment record into `tcx.adjustments`\n      * so that trans/borrowck/etc know about this autoderef. */\n \n-    let mut t = t;\n-    let mut autoderefs = 0;\n-    loop {\n+    let mut t = base_ty;\n+    for autoderefs in range(0, fcx.tcx().sess.recursion_limit.get()) {\n         let resolved_t = structurally_resolved_type(fcx, sp, t);\n \n-        // Some extra checks to detect weird cycles and so forth:\n-        match ty::get(resolved_t).sty {\n-            ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_rptr(_, _) => {\n-                match ty::get(t).sty {\n-                    ty::ty_infer(ty::TyVar(v1)) => {\n-                        ty::occurs_check(fcx.ccx.tcx, sp, v1, resolved_t);\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            _ => { /*ok*/ }\n-        }\n-\n         match should_stop(resolved_t, autoderefs) {\n             Some(x) => return (resolved_t, autoderefs, Some(x)),\n             None => {}\n@@ -1291,11 +1277,16 @@ pub fn autoderef<T>(fcx: @FnCtxt, sp: Span, t: ty::t,\n                 if mt.mutbl == ast::MutImmutable {\n                     lvalue_pref = NoPreference;\n                 }\n-                autoderefs += 1;\n             }\n             None => return (resolved_t, autoderefs, None)\n         }\n     }\n+\n+    // We've reached the recursion limit, error gracefully.\n+    fcx.tcx().sess.span_err(sp,\n+        format!(\"reached the recursion limit while auto-dereferencing {}\",\n+                base_ty.repr(fcx.tcx())));\n+    (ty::mk_err(), 0, None)\n }\n \n fn try_overloaded_deref(fcx: @FnCtxt,"}, {"sha": "ddef459453ec491eba284711b98eef8858e8d3eb", "filename": "src/test/compile-fail/infinite-autoderef.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/26398b4f6d7b9016f1ddb6c23b5090cd98f1fa2e/src%2Ftest%2Fcompile-fail%2Finfinite-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26398b4f6d7b9016f1ddb6c23b5090cd98f1fa2e/src%2Ftest%2Fcompile-fail%2Finfinite-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-autoderef.rs?ref=26398b4f6d7b9016f1ddb6c23b5090cd98f1fa2e", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern: reached the recursion limit while auto-dereferencing\n+\n+use std::ops::Deref;\n+\n+struct Foo;\n+\n+impl Deref<Foo> for Foo {\n+    fn deref<'a>(&'a self) -> &'a Foo {\n+        self\n+    }\n+}\n+\n+pub fn main() {\n+    let mut x;\n+    loop {\n+        x = ~x;\n+        x.foo;\n+        x.bar();\n+    }\n+\n+    Foo.foo;\n+    Foo.bar();\n+}"}, {"sha": "b8fa6285d99553e547c2f77bc1b8a755bbe437af", "filename": "src/test/compile-fail/infinite-instantiation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26398b4f6d7b9016f1ddb6c23b5090cd98f1fa2e/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26398b4f6d7b9016f1ddb6c23b5090cd98f1fa2e/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs?ref=26398b4f6d7b9016f1ddb6c23b5090cd98f1fa2e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: overly deep expansion\n+// error-pattern: reached the recursion limit during monomorphization\n // issue 2258\n \n trait to_opt {"}, {"sha": "fca59ed74ee8d5135a86bf77a5fb6fdd11eeedaf", "filename": "src/test/compile-fail/issue-8727.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26398b4f6d7b9016f1ddb6c23b5090cd98f1fa2e/src%2Ftest%2Fcompile-fail%2Fissue-8727.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26398b4f6d7b9016f1ddb6c23b5090cd98f1fa2e/src%2Ftest%2Fcompile-fail%2Fissue-8727.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-8727.rs?ref=26398b4f6d7b9016f1ddb6c23b5090cd98f1fa2e", "patch": "@@ -15,7 +15,7 @@\n struct Data(~Option<Data>);\n \n fn generic<T>( _ : ~[(Data,T)] ) {\n-    //~^ ERROR overly deep expansion of inlined function\n+    //~^ ERROR reached the recursion limit during monomorphization\n     let rec : ~[(Data,(bool,T))] = ~[];\n     generic( rec );\n }"}, {"sha": "96676257184ce1f7cc8e076a70be2f7b154c07d7", "filename": "src/test/compile-fail/recursion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26398b4f6d7b9016f1ddb6c23b5090cd98f1fa2e/src%2Ftest%2Fcompile-fail%2Frecursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26398b4f6d7b9016f1ddb6c23b5090cd98f1fa2e/src%2Ftest%2Fcompile-fail%2Frecursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frecursion.rs?ref=26398b4f6d7b9016f1ddb6c23b5090cd98f1fa2e", "patch": "@@ -20,7 +20,7 @@ impl<T:Dot> Dot for Cons<T> {\n   }\n }\n fn test<T:Dot> (n:int, i:int, first:T, second:T) ->int {\n-    //~^ ERROR: overly deep expansion of inlined function\n+    //~^ ERROR: reached the recursion limit during monomorphization\n   match n {\n     0 => {first.dot(second)}\n       // Error message should be here. It should be a type error"}]}