{"sha": "a7653337380071ebc5b83a8133121b87dc892442", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3NjUzMzM3MzgwMDcxZWJjNWI4M2E4MTMzMTIxYjg3ZGM4OTI0NDI=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-04-04T20:55:39Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-07-16T21:29:02Z"}, "message": "Add initial implementation of HIR-based WF checking for diagnostics\n\nDuring well-formed checking, we walk through all types 'nested' in\ngeneric arguments. For example, WF-checking `Option<MyStruct<u8>>`\nwill cause us to check `MyStruct<u8>` and `u8`. However, this is done\non a `rustc_middle::ty::Ty`, which has no span information. As a result,\nany errors that occur will have a very general span (e.g. the\ndefinintion of an associated item).\n\nThis becomes a problem when macros are involved. In general, an\nassociated type like `type MyType = Option<MyStruct<u8>>;` may\nhave completely different spans for each nested type in the HIR. Using\nthe span of the entire associated item might end up pointing to a macro\ninvocation, even though a user-provided span is available in one of the\nnested types.\n\nThis PR adds a framework for HIR-based well formed checking. This check\nis only run during error reporting, and is used to obtain a more precise\nspan for an existing error. This is accomplished by individually\nchecking each 'nested' type in the HIR for the type, allowing us to\nfind the most-specific type (and span) that produces a given error.\n\nThe majority of the changes are to the error-reporting code. However,\nsome of the general trait code is modified to pass through more\ninformation.\n\nSince this has no soundness implications, I've implemented a minimal\nversion to begin with, which can be extended over time. In particular,\nthis only works for HIR items with a corresponding `DefId` (e.g. it will\nnot work for WF-checking performed within function bodies).", "tree": {"sha": "731dc884e12d998b11796e2dbdf2cb08cbe2dcce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/731dc884e12d998b11796e2dbdf2cb08cbe2dcce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7653337380071ebc5b83a8133121b87dc892442", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAmDx+h8ACgkQtAh+UQ6Y\nsWTPJhAAr4ulxbhb3eOfIdekaY8YkVuA8YMzNwNx6OAXN063sQNMg+S4Z6jLO7o5\nqsbgRNwFa+UyOZZQndBNQgm70TD4Ms1WcQfr4vMuLb032U/HKaRZgq4hCim2JIie\n2NjEpF7gK10ZOIi7r4hfaQVKvRr/ttYlf6yBhiSFpk6GIiu3A+J2uJE0CmCTATzg\n3m4LWNsX9Phr5hxIuqrsqLhwWRgDWxWTc+BjuOvMfFn0GxNRnkywTRYhn1zc5FmD\nrQaEaG/CLwJmpIKCascUbo9vCg8KNrKaNTrmi5hdmM0lv3AGCHr+BFrNuYMM2B+E\nBSC4iazg3OudSeN90lc1HIc9RX9kXeqiwi9iuxNB0MhvspAyKhl2aXMoSG8glAs0\nH+tKz1tvUJ4Iujfr9Jw+uRaxRj1eoDnjy4L9/VkyEVKgfsTfU5Mu3GTdSpwbVtLR\nXDASNEFb1VBiafdWDUxToe3MUeXbHSkT2PmIm0Pu45KSFXgXpEhu9HQLG4xjttb2\nRtxHDC84+r8uYBXCAsSM3n2sJ39h8alhnIoZ73C0R9SRULko12L9n8G1eArnYCdz\np8ObckiyLE69Cyg8dP76abNUzNGLsk75VD+Vo5up7Q/OZ7fKtr01GVqDmur7QKLH\n9t6ngzsN/pYhCgj58ygXYh1/Lijpi8Jra1jOWKj0goYhnjsinN8=\n=u3eZ\n-----END PGP SIGNATURE-----", "payload": "tree 731dc884e12d998b11796e2dbdf2cb08cbe2dcce\nparent 59d92bd0173fb0436b93aa56ff2cb288d4717701\nauthor Aaron Hill <aa1ronham@gmail.com> 1617569739 -0400\ncommitter Aaron Hill <aa1ronham@gmail.com> 1626470942 -0500\n\nAdd initial implementation of HIR-based WF checking for diagnostics\n\nDuring well-formed checking, we walk through all types 'nested' in\ngeneric arguments. For example, WF-checking `Option<MyStruct<u8>>`\nwill cause us to check `MyStruct<u8>` and `u8`. However, this is done\non a `rustc_middle::ty::Ty`, which has no span information. As a result,\nany errors that occur will have a very general span (e.g. the\ndefinintion of an associated item).\n\nThis becomes a problem when macros are involved. In general, an\nassociated type like `type MyType = Option<MyStruct<u8>>;` may\nhave completely different spans for each nested type in the HIR. Using\nthe span of the entire associated item might end up pointing to a macro\ninvocation, even though a user-provided span is available in one of the\nnested types.\n\nThis PR adds a framework for HIR-based well formed checking. This check\nis only run during error reporting, and is used to obtain a more precise\nspan for an existing error. This is accomplished by individually\nchecking each 'nested' type in the HIR for the type, allowing us to\nfind the most-specific type (and span) that produces a given error.\n\nThe majority of the changes are to the error-reporting code. However,\nsome of the general trait code is modified to pass through more\ninformation.\n\nSince this has no soundness implications, I've implemented a minimal\nversion to begin with, which can be extended over time. In particular,\nthis only works for HIR items with a corresponding `DefId` (e.g. it will\nnot work for WF-checking performed within function bodies).\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7653337380071ebc5b83a8133121b87dc892442", "html_url": "https://github.com/rust-lang/rust/commit/a7653337380071ebc5b83a8133121b87dc892442", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7653337380071ebc5b83a8133121b87dc892442/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59d92bd0173fb0436b93aa56ff2cb288d4717701", "url": "https://api.github.com/repos/rust-lang/rust/commits/59d92bd0173fb0436b93aa56ff2cb288d4717701", "html_url": "https://github.com/rust-lang/rust/commit/59d92bd0173fb0436b93aa56ff2cb288d4717701"}], "stats": {"total": 416, "additions": 350, "deletions": 66}, "files": [{"sha": "d5c17ede2143d4b8fdbc459a399a6ac5e5351da1", "filename": "compiler/rustc_infer/src/traits/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs?ref=a7653337380071ebc5b83a8133121b87dc892442", "patch": "@@ -70,6 +70,10 @@ pub struct FulfillmentError<'tcx> {\n     /// obligation error caused by a call argument. When this is the case, we also signal that in\n     /// this field to ensure accuracy of suggestions.\n     pub points_at_arg_span: bool,\n+    /// Diagnostics only: the 'root' obligation which resulted in\n+    /// the failure to process `obligation`. This is the obligation\n+    /// that was initially passed to `register_predicate_obligation`\n+    pub root_obligation: PredicateObligation<'tcx>,\n }\n \n #[derive(Clone)]\n@@ -122,8 +126,9 @@ impl<'tcx> FulfillmentError<'tcx> {\n     pub fn new(\n         obligation: PredicateObligation<'tcx>,\n         code: FulfillmentErrorCode<'tcx>,\n+        root_obligation: PredicateObligation<'tcx>,\n     ) -> FulfillmentError<'tcx> {\n-        FulfillmentError { obligation, code, points_at_arg_span: false }\n+        FulfillmentError { obligation, code, points_at_arg_span: false, root_obligation }\n     }\n }\n "}, {"sha": "1651853a55205cf3ecfc029f629735984991371c", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=a7653337380071ebc5b83a8133121b87dc892442", "patch": "@@ -1713,4 +1713,18 @@ rustc_queries! {\n     query limits(key: ()) -> Limits {\n         desc { \"looking up limits\" }\n     }\n+\n+    /// Performs an HIR-based well-formed check on the item with the given `HirId`. If\n+    /// we get an `Umimplemented` error that matches the provided `Predicate`, return\n+    /// the cause of the newly created obligation.\n+    ///\n+    /// This is only used by error-reporting code to get a better cause (in particular, a better\n+    /// span) for an *existing* error. Therefore, it is best-effort, and may never handle\n+    /// all of the cases that the normal `ty::Ty`-based wfcheck does. This is fine,\n+    /// because the `ty::Ty`-based wfcheck is always run.\n+    query diagnostic_hir_wf_check(key: (ty::Predicate<'tcx>, hir::HirId)) -> Option<traits::ObligationCause<'tcx>> {\n+        eval_always\n+        no_hash\n+        desc { \"performing HIR wf-checking for predicate {:?} at item {:?}\", key.0, key.1 }\n+    }\n }"}, {"sha": "221dac9ca035dccb9bb83090aad5fc409507c416", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=a7653337380071ebc5b83a8133121b87dc892442", "patch": "@@ -13,6 +13,7 @@ use crate::mir::abstract_const::NotConstEvaluatable;\n use crate::ty::subst::SubstsRef;\n use crate::ty::{self, AdtKind, Ty, TyCtxt};\n \n+use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -24,7 +25,6 @@ use smallvec::SmallVec;\n use std::borrow::Cow;\n use std::fmt;\n use std::ops::Deref;\n-use std::rc::Rc;\n \n pub use self::select::{EvaluationCache, EvaluationResult, OverflowError, SelectionCache};\n \n@@ -87,7 +87,7 @@ pub enum Reveal {\n #[derive(Clone, PartialEq, Eq, Hash, Lift)]\n pub struct ObligationCause<'tcx> {\n     /// `None` for `ObligationCause::dummy`, `Some` otherwise.\n-    data: Option<Rc<ObligationCauseData<'tcx>>>,\n+    data: Option<Lrc<ObligationCauseData<'tcx>>>,\n }\n \n const DUMMY_OBLIGATION_CAUSE_DATA: ObligationCauseData<'static> =\n@@ -131,7 +131,7 @@ impl<'tcx> ObligationCause<'tcx> {\n         body_id: hir::HirId,\n         code: ObligationCauseCode<'tcx>,\n     ) -> ObligationCause<'tcx> {\n-        ObligationCause { data: Some(Rc::new(ObligationCauseData { span, body_id, code })) }\n+        ObligationCause { data: Some(Lrc::new(ObligationCauseData { span, body_id, code })) }\n     }\n \n     pub fn misc(span: Span, body_id: hir::HirId) -> ObligationCause<'tcx> {\n@@ -148,7 +148,7 @@ impl<'tcx> ObligationCause<'tcx> {\n     }\n \n     pub fn make_mut(&mut self) -> &mut ObligationCauseData<'tcx> {\n-        Rc::make_mut(self.data.get_or_insert_with(|| Rc::new(DUMMY_OBLIGATION_CAUSE_DATA)))\n+        Lrc::make_mut(self.data.get_or_insert_with(|| Lrc::new(DUMMY_OBLIGATION_CAUSE_DATA)))\n     }\n \n     pub fn span(&self, tcx: TyCtxt<'tcx>) -> Span {\n@@ -326,6 +326,13 @@ pub enum ObligationCauseCode<'tcx> {\n \n     /// If `X` is the concrete type of an opaque type `impl Y`, then `X` must implement `Y`\n     OpaqueType,\n+\n+    /// Well-formed checking. If a `HirId` is provided,\n+    /// it is used to perform HIR-based wf checking if an error\n+    /// occurs, in order to generate a more precise error message.\n+    /// This is purely for diagnostic purposes - it is always\n+    /// correct to use `MiscObligation` instead\n+    WellFormed(Option<hir::HirId>),\n }\n \n impl ObligationCauseCode<'_> {\n@@ -389,7 +396,7 @@ pub struct DerivedObligationCause<'tcx> {\n     pub parent_trait_ref: ty::PolyTraitRef<'tcx>,\n \n     /// The parent trait had this cause.\n-    pub parent_code: Rc<ObligationCauseCode<'tcx>>,\n+    pub parent_code: Lrc<ObligationCauseCode<'tcx>>,\n }\n \n #[derive(Clone, Debug, TypeFoldable, Lift)]"}, {"sha": "b4fe3313e8a1ed15e9ca2eb7a17092f584dfe728", "filename": "compiler/rustc_mir/src/borrow_check/type_check/mod.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=a7653337380071ebc5b83a8133121b87dc892442", "patch": "@@ -2070,24 +2070,26 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                 debug!(\"check_rvalue: is_const_fn={:?}\", is_const_fn);\n \n                                 let def_id = body.source.def_id().expect_local();\n-                                self.infcx.report_selection_error(\n-                                    &traits::Obligation::new(\n-                                        ObligationCause::new(\n-                                            span,\n-                                            self.tcx().hir().local_def_id_to_hir_id(def_id),\n-                                            traits::ObligationCauseCode::RepeatVec(is_const_fn),\n-                                        ),\n-                                        self.param_env,\n-                                        ty::Binder::dummy(ty::TraitRef::new(\n-                                            self.tcx().require_lang_item(\n-                                                LangItem::Copy,\n-                                                Some(self.last_span),\n-                                            ),\n-                                            tcx.mk_substs_trait(ty, &[]),\n-                                        ))\n-                                        .without_const()\n-                                        .to_predicate(self.tcx()),\n+                                let obligation = traits::Obligation::new(\n+                                    ObligationCause::new(\n+                                        span,\n+                                        self.tcx().hir().local_def_id_to_hir_id(def_id),\n+                                        traits::ObligationCauseCode::RepeatVec(is_const_fn),\n                                     ),\n+                                    self.param_env,\n+                                    ty::Binder::dummy(ty::TraitRef::new(\n+                                        self.tcx().require_lang_item(\n+                                            LangItem::Copy,\n+                                            Some(self.last_span),\n+                                        ),\n+                                        tcx.mk_substs_trait(ty, &[]),\n+                                    ))\n+                                    .without_const()\n+                                    .to_predicate(self.tcx()),\n+                                );\n+                                self.infcx.report_selection_error(\n+                                    obligation.clone(),\n+                                    &obligation,\n                                     &traits::SelectionError::Unimplemented,\n                                     false,\n                                     false,"}, {"sha": "1993e0a602fa50a0e57576d3db27e5ace963cd3c", "filename": "compiler/rustc_query_impl/src/keys.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs?ref=a7653337380071ebc5b83a8133121b87dc892442", "patch": "@@ -1,6 +1,7 @@\n //! Defines the set of legal keys that can be used in queries.\n \n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n+use rustc_hir::HirId;\n use rustc_middle::infer::canonical::Canonical;\n use rustc_middle::mir;\n use rustc_middle::ty::fast_reject::SimplifiedType;\n@@ -395,3 +396,14 @@ impl<'tcx> Key for (DefId, Ty<'tcx>, SubstsRef<'tcx>, ty::ParamEnv<'tcx>) {\n         DUMMY_SP\n     }\n }\n+\n+impl<'tcx> Key for (ty::Predicate<'tcx>, HirId) {\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n+    }\n+\n+    fn default_span(&self, _tcx: TyCtxt<'_>) -> Span {\n+        DUMMY_SP\n+    }\n+}"}, {"sha": "ea074192d23b14262f97d2455e783b6978552bbb", "filename": "compiler/rustc_trait_selection/src/infer.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs?ref=a7653337380071ebc5b83a8133121b87dc892442", "patch": "@@ -30,8 +30,7 @@ pub trait InferCtxtExt<'tcx> {\n \n     fn partially_normalize_associated_types_in<T>(\n         &self,\n-        span: Span,\n-        body_id: hir::HirId,\n+        cause: ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         value: T,\n     ) -> InferOk<'tcx, T>\n@@ -79,8 +78,7 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n     /// new obligations that must further be processed.\n     fn partially_normalize_associated_types_in<T>(\n         &self,\n-        span: Span,\n-        body_id: hir::HirId,\n+        cause: ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         value: T,\n     ) -> InferOk<'tcx, T>\n@@ -89,7 +87,6 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n     {\n         debug!(\"partially_normalize_associated_types_in(value={:?})\", value);\n         let mut selcx = traits::SelectionContext::new(self);\n-        let cause = ObligationCause::misc(span, body_id);\n         let traits::Normalized { value, obligations } =\n             traits::normalize(&mut selcx, param_env, cause, value);\n         debug!("}, {"sha": "e11ac9b49f33294a7514dd1a3f2f9273207cb23a", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=a7653337380071ebc5b83a8133121b87dc892442", "patch": "@@ -1,5 +1,5 @@\n use crate::infer::InferCtxtExt as _;\n-use crate::traits::{self, PredicateObligation};\n+use crate::traits::{self, ObligationCause, PredicateObligation};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::vec_map::VecMap;\n@@ -1051,8 +1051,11 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n             item_bounds.iter().map(|(bound, _)| bound.subst(tcx, substs)).collect();\n \n         let param_env = tcx.param_env(def_id);\n-        let InferOk { value: bounds, obligations } =\n-            infcx.partially_normalize_associated_types_in(span, self.body_id, param_env, bounds);\n+        let InferOk { value: bounds, obligations } = infcx.partially_normalize_associated_types_in(\n+            ObligationCause::misc(span, self.body_id),\n+            param_env,\n+            bounds,\n+        );\n         self.obligations.extend(obligations);\n \n         debug!(\"instantiate_opaque_types: bounds={:?}\", bounds);"}, {"sha": "7a690af0cc6e5e78e49a3dfc645979438e41c6ce", "filename": "compiler/rustc_trait_selection/src/traits/chalk_fulfill.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs?ref=a7653337380071ebc5b83a8133121b87dc892442", "patch": "@@ -58,6 +58,9 @@ impl TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n                     obligation: obligation.clone(),\n                     code: FulfillmentErrorCode::CodeAmbiguity,\n                     points_at_arg_span: false,\n+                    // FIXME - does Chalk have a notation of 'root obligation'?\n+                    // This is just for diagnostics, so it's okay if this is wrong\n+                    root_obligation: obligation.clone(),\n                 })\n                 .collect();\n             Err(errors)\n@@ -105,11 +108,14 @@ impl TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n                                 ),\n \n                                 Err(_err) => errors.push(FulfillmentError {\n-                                    obligation,\n+                                    obligation: obligation.clone(),\n                                     code: FulfillmentErrorCode::CodeSelectionError(\n                                         SelectionError::Unimplemented,\n                                     ),\n                                     points_at_arg_span: false,\n+                                    // FIXME - does Chalk have a notation of 'root obligation'?\n+                                    // This is just for diagnostics, so it's okay if this is wrong\n+                                    root_obligation: obligation,\n                                 }),\n                             }\n                         } else {\n@@ -119,11 +125,14 @@ impl TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n                     }\n \n                     Err(NoSolution) => errors.push(FulfillmentError {\n-                        obligation,\n+                        obligation: obligation.clone(),\n                         code: FulfillmentErrorCode::CodeSelectionError(\n                             SelectionError::Unimplemented,\n                         ),\n                         points_at_arg_span: false,\n+                        // FIXME - does Chalk have a notation of 'root obligation'?\n+                        // This is just for diagnostics, so it's okay if this is wrong\n+                        root_obligation: obligation,\n                     }),\n                 }\n             }"}, {"sha": "5c4aef529e5ac775c24d6f042080e68a93c6d263", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=a7653337380071ebc5b83a8133121b87dc892442", "patch": "@@ -55,9 +55,13 @@ pub trait InferCtxtExt<'tcx> {\n \n     fn report_overflow_error_cycle(&self, cycle: &[PredicateObligation<'tcx>]) -> !;\n \n+    /// The `root_obligation` parameter should be the `root_obligation` field\n+    /// from a `FulfillmentError`. If no `FulfillmentError` is available,\n+    /// then it should be the same as `obligation`.\n     fn report_selection_error(\n         &self,\n-        obligation: &PredicateObligation<'tcx>,\n+        obligation: PredicateObligation<'tcx>,\n+        root_obligation: &PredicateObligation<'tcx>,\n         error: &SelectionError<'tcx>,\n         fallback_has_occurred: bool,\n         points_at_arg: bool,\n@@ -225,16 +229,29 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn report_selection_error(\n         &self,\n-        obligation: &PredicateObligation<'tcx>,\n+        mut obligation: PredicateObligation<'tcx>,\n+        root_obligation: &PredicateObligation<'tcx>,\n         error: &SelectionError<'tcx>,\n         fallback_has_occurred: bool,\n         points_at_arg: bool,\n     ) {\n         let tcx = self.tcx;\n-        let span = obligation.cause.span;\n+        let mut span = obligation.cause.span;\n \n         let mut err = match *error {\n             SelectionError::Unimplemented => {\n+                // If this obligation was generated as a result of well-formed checking, see if we\n+                // can get a better error message by performing HIR-based well formed checking.\n+                if let ObligationCauseCode::WellFormed(Some(wf_hir_id)) =\n+                    root_obligation.cause.code.peel_derives()\n+                {\n+                    if let Some(cause) =\n+                        self.tcx.diagnostic_hir_wf_check((obligation.predicate, *wf_hir_id))\n+                    {\n+                        obligation.cause = cause;\n+                        span = obligation.cause.span;\n+                    }\n+                }\n                 if let ObligationCauseCode::CompareImplMethodObligation {\n                     item_name,\n                     impl_item_def_id,\n@@ -279,7 +296,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             .unwrap_or_default();\n \n                         let OnUnimplementedNote { message, label, note, enclosing_scope } =\n-                            self.on_unimplemented_note(trait_ref, obligation);\n+                            self.on_unimplemented_note(trait_ref, &obligation);\n                         let have_alt_message = message.is_some() || label.is_some();\n                         let is_try_conversion = self.is_try_conversion(span, trait_ref.def_id());\n                         let is_unsize =\n@@ -338,7 +355,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                                     Applicability::MachineApplicable,\n                                 );\n                             }\n-                            if let Some(ret_span) = self.return_type_span(obligation) {\n+                            if let Some(ret_span) = self.return_type_span(&obligation) {\n                                 err.span_label(\n                                     ret_span,\n                                     &format!(\n@@ -368,7 +385,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             points_at_arg,\n                             have_alt_message,\n                         ) {\n-                            self.note_obligation_cause(&mut err, obligation);\n+                            self.note_obligation_cause(&mut err, &obligation);\n                             err.emit();\n                             return;\n                         }\n@@ -821,7 +838,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n         };\n \n-        self.note_obligation_cause(&mut err, obligation);\n+        self.note_obligation_cause(&mut err, &obligation);\n         self.point_at_returns_when_relevant(&mut err, &obligation);\n \n         err.emit();\n@@ -1168,7 +1185,8 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         match error.code {\n             FulfillmentErrorCode::CodeSelectionError(ref selection_error) => {\n                 self.report_selection_error(\n-                    &error.obligation,\n+                    error.obligation.clone(),\n+                    &error.root_obligation,\n                     selection_error,\n                     fallback_has_occurred,\n                     error.points_at_arg_span,"}, {"sha": "adeb1d58d1ece72ff2dbdd6382978973be8dd1d5", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=a7653337380071ebc5b83a8133121b87dc892442", "patch": "@@ -1902,7 +1902,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             | ObligationCauseCode::ReturnNoExpression\n             | ObligationCauseCode::UnifyReceiver(..)\n             | ObligationCauseCode::OpaqueType\n-            | ObligationCauseCode::MiscObligation => {}\n+            | ObligationCauseCode::MiscObligation\n+            | ObligationCauseCode::WellFormed(..) => {}\n             ObligationCauseCode::SliceOrArrayElem => {\n                 err.note(\"slice and array elements must have `Sized` type\");\n             }"}, {"sha": "21ed586ab560b4db023dcc6c39244cdd53e9f8a9", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=a7653337380071ebc5b83a8133121b87dc892442", "patch": "@@ -717,6 +717,10 @@ fn substs_infer_vars<'a, 'tcx>(\n fn to_fulfillment_error<'tcx>(\n     error: Error<PendingPredicateObligation<'tcx>, FulfillmentErrorCode<'tcx>>,\n ) -> FulfillmentError<'tcx> {\n-    let obligation = error.backtrace.into_iter().next().unwrap().obligation;\n-    FulfillmentError::new(obligation, error.error)\n+    let mut iter = error.backtrace.into_iter();\n+    let obligation = iter.next().unwrap().obligation;\n+    // The root obligation is the last item in the backtrace - if there's only\n+    // one item, then it's the same as the main obligation\n+    let root_obligation = iter.next_back().map_or_else(|| obligation.clone(), |e| e.obligation);\n+    FulfillmentError::new(obligation, error.error, root_obligation)\n }"}, {"sha": "f17965f6f6be659acb95b2107b7d9496bc91e1ed", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=a7653337380071ebc5b83a8133121b87dc892442", "patch": "@@ -28,6 +28,7 @@ use crate::traits::error_reporting::InferCtxtExt;\n use crate::traits::project::ProjectionCacheKeyExt;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stack::ensure_sufficient_stack;\n+use rustc_data_structures::sync::Lrc;\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -48,7 +49,6 @@ use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::fmt::{self, Display};\n use std::iter;\n-use std::rc::Rc;\n \n pub use rustc_middle::traits::select::*;\n \n@@ -2168,7 +2168,7 @@ impl<'tcx> TraitObligationExt<'tcx> for TraitObligation<'tcx> {\n         // by using -Z verbose or just a CLI argument.\n         let derived_cause = DerivedObligationCause {\n             parent_trait_ref: obligation.predicate.to_poly_trait_ref(),\n-            parent_code: Rc::new(obligation.cause.code.clone()),\n+            parent_code: Lrc::new(obligation.cause.code.clone()),\n         };\n         let derived_code = variant(derived_cause);\n         ObligationCause::new(obligation.cause.span, obligation.cause.body_id, derived_code)"}, {"sha": "9ee6eeb1fd5eddc89d114154bd8e5a68393290e9", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=a7653337380071ebc5b83a8133121b87dc892442", "patch": "@@ -1,6 +1,7 @@\n use crate::infer::InferCtxt;\n use crate::opaque_types::required_region_bounds;\n use crate::traits;\n+use rustc_data_structures::sync::Lrc;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n@@ -9,7 +10,6 @@ use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstnes\n use rustc_span::Span;\n \n use std::iter;\n-use std::rc::Rc;\n /// Returns the set of obligations needed to make `arg` well-formed.\n /// If `arg` contains unresolved inference variables, this may include\n /// further WF obligations. However, if `arg` IS an unresolved\n@@ -295,7 +295,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n             if let Some(parent_trait_ref) = obligation.predicate.to_opt_poly_trait_ref() {\n                 let derived_cause = traits::DerivedObligationCause {\n                     parent_trait_ref: parent_trait_ref.value,\n-                    parent_code: Rc::new(obligation.cause.code.clone()),\n+                    parent_code: Lrc::new(obligation.cause.code.clone()),\n                 };\n                 cause.make_mut().code =\n                     traits::ObligationCauseCode::DerivedObligation(derived_cause);"}, {"sha": "2c55ea7f5c14ea555e71e43c53e4c16487fa72e7", "filename": "compiler/rustc_traits/src/type_op.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs?ref=a7653337380071ebc5b83a8133121b87dc892442", "patch": "@@ -67,8 +67,7 @@ impl AscribeUserTypeCx<'me, 'tcx> {\n     {\n         self.infcx\n             .partially_normalize_associated_types_in(\n-                DUMMY_SP,\n-                hir::CRATE_HIR_ID,\n+                ObligationCause::misc(DUMMY_SP, hir::CRATE_HIR_ID),\n                 self.param_env,\n                 value,\n             )"}, {"sha": "ba76b9c8dd5a033ab083ee548ecc33b21b81a289", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=a7653337380071ebc5b83a8133121b87dc892442", "patch": "@@ -640,7 +640,13 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n                 // Object safety violations or miscellaneous.\n                 Err(err) => {\n-                    self.report_selection_error(&obligation, &err, false, false);\n+                    self.report_selection_error(\n+                        obligation.clone(),\n+                        &obligation,\n+                        &err,\n+                        false,\n+                        false,\n+                    );\n                     // Treat this like an obligation and follow through\n                     // with the unsizing - the lack of a coercion should\n                     // be silent, as it causes a type mismatch later."}, {"sha": "e045c30e0de6be9f834e367fb866346be9bec1c3", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=a7653337380071ebc5b83a8133121b87dc892442", "patch": "@@ -39,7 +39,7 @@ use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::opaque_types::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::{\n-    self, ObligationCauseCode, StatementAsExpression, TraitEngine, TraitEngineExt,\n+    self, ObligationCause, ObligationCauseCode, StatementAsExpression, TraitEngine, TraitEngineExt,\n };\n \n use std::collections::hash_map::Entry;\n@@ -408,6 +408,29 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         value\n     }\n \n+    /// Convenience method which tracks extra diagnostic information for normalization\n+    /// that occurs as a result of WF checking. The `hir_id` is the `HirId` of the hir item\n+    /// whose type is being wf-checked - this is used to construct a more precise span if\n+    /// an error occurs.\n+    ///\n+    /// It is never necessary to call this method - calling `normalize_associated_types_in` will\n+    /// just result in a slightly worse diagnostic span, and will still be sound.\n+    pub(in super::super) fn normalize_associated_types_in_wf<T>(\n+        &self,\n+        span: Span,\n+        value: T,\n+        hir_id: hir::HirId,\n+    ) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        self.inh.normalize_associated_types_in_with_cause(\n+            ObligationCause::new(span, self.body_id, ObligationCauseCode::WellFormed(Some(hir_id))),\n+            self.param_env,\n+            value,\n+        )\n+    }\n+\n     pub(in super::super) fn normalize_associated_types_in<T>(&self, span: Span, value: T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n@@ -423,7 +446,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        self.inh.partially_normalize_associated_types_in(span, self.body_id, self.param_env, value)\n+        self.inh.partially_normalize_associated_types_in(\n+            ObligationCause::misc(span, self.body_id),\n+            self.param_env,\n+            value,\n+        )\n     }\n \n     pub fn require_type_meets("}, {"sha": "237861f1dd24807a96af7b9e1514a6a8f3d9ca52", "filename": "compiler/rustc_typeck/src/check/inherited.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs?ref=a7653337380071ebc5b83a8133121b87dc892442", "patch": "@@ -13,7 +13,7 @@ use rustc_middle::ty::{self, OpaqueTypeKey, Ty, TyCtxt};\n use rustc_span::{self, Span};\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::opaque_types::OpaqueTypeDecl;\n-use rustc_trait_selection::traits::{self, TraitEngine, TraitEngineExt};\n+use rustc_trait_selection::traits::{self, ObligationCause, TraitEngine, TraitEngineExt};\n \n use std::cell::RefCell;\n use std::ops::Deref;\n@@ -162,7 +162,23 @@ impl Inherited<'a, 'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        let ok = self.partially_normalize_associated_types_in(span, body_id, param_env, value);\n+        self.normalize_associated_types_in_with_cause(\n+            ObligationCause::misc(span, body_id),\n+            param_env,\n+            value,\n+        )\n+    }\n+\n+    pub(super) fn normalize_associated_types_in_with_cause<T>(\n+        &self,\n+        cause: ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        value: T,\n+    ) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        let ok = self.partially_normalize_associated_types_in(cause, param_env, value);\n         self.register_infer_ok_obligations(ok)\n     }\n }"}, {"sha": "bff391eb2d7a8dcf18ac0435c267c8cfa0f83572", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=a7653337380071ebc5b83a8133121b87dc892442", "patch": "@@ -387,7 +387,7 @@ fn check_associated_item(\n ) {\n     debug!(\"check_associated_item: {:?}\", item_id);\n \n-    let code = ObligationCauseCode::MiscObligation;\n+    let code = ObligationCauseCode::WellFormed(Some(item_id));\n     for_id(tcx, item_id, span).with_fcx(|fcx| {\n         let item = fcx.tcx.associated_item(fcx.tcx.hir().local_def_id(item_id));\n \n@@ -401,7 +401,7 @@ fn check_associated_item(\n         match item.kind {\n             ty::AssocKind::Const => {\n                 let ty = fcx.tcx.type_of(item.def_id);\n-                let ty = fcx.normalize_associated_types_in(span, ty);\n+                let ty = fcx.normalize_associated_types_in_wf(span, ty, item_id);\n                 fcx.register_wf_obligation(ty.into(), span, code.clone());\n             }\n             ty::AssocKind::Fn => {\n@@ -423,7 +423,7 @@ fn check_associated_item(\n                 }\n                 if item.defaultness.has_value() {\n                     let ty = fcx.tcx.type_of(item.def_id);\n-                    let ty = fcx.normalize_associated_types_in(span, ty);\n+                    let ty = fcx.normalize_associated_types_in_wf(span, ty, item_id);\n                     fcx.register_wf_obligation(ty.into(), span, code.clone());\n                 }\n             }\n@@ -515,7 +515,8 @@ fn check_type_defn<'tcx, F>(\n                 fcx.register_wf_obligation(\n                     field.ty.into(),\n                     field.span,\n-                    ObligationCauseCode::MiscObligation,\n+                    // We don't have an HIR id for the field\n+                    ObligationCauseCode::WellFormed(None),\n                 )\n             }\n \n@@ -621,7 +622,7 @@ fn check_item_type(tcx: TyCtxt<'_>, item_id: hir::HirId, ty_span: Span, allow_fo\n \n     for_id(tcx, item_id, ty_span).with_fcx(|fcx| {\n         let ty = tcx.type_of(tcx.hir().local_def_id(item_id));\n-        let item_ty = fcx.normalize_associated_types_in(ty_span, ty);\n+        let item_ty = fcx.normalize_associated_types_in_wf(ty_span, ty, item_id);\n \n         let mut forbid_unsized = true;\n         if allow_foreign_ty {\n@@ -631,7 +632,11 @@ fn check_item_type(tcx: TyCtxt<'_>, item_id: hir::HirId, ty_span: Span, allow_fo\n             }\n         }\n \n-        fcx.register_wf_obligation(item_ty.into(), ty_span, ObligationCauseCode::MiscObligation);\n+        fcx.register_wf_obligation(\n+            item_ty.into(),\n+            ty_span,\n+            ObligationCauseCode::WellFormed(Some(item_id)),\n+        );\n         if forbid_unsized {\n             fcx.register_bound(\n                 item_ty,\n@@ -680,7 +685,7 @@ fn check_impl<'tcx>(\n                 fcx.register_wf_obligation(\n                     self_ty.into(),\n                     ast_self_ty.span,\n-                    ObligationCauseCode::MiscObligation,\n+                    ObligationCauseCode::WellFormed(Some(item.hir_id())),\n                 );\n             }\n         }\n@@ -746,7 +751,7 @@ fn check_where_clauses<'tcx, 'fcx>(\n                         fcx.register_wf_obligation(\n                             default_ct.into(),\n                             tcx.def_span(param.def_id),\n-                            ObligationCauseCode::MiscObligation,\n+                            ObligationCauseCode::WellFormed(None),\n                         );\n                     }\n                 }\n@@ -900,7 +905,7 @@ fn check_fn_or_method<'fcx, 'tcx>(\n     let sig = fcx.normalize_associated_types_in(span, sig);\n \n     for (&input_ty, ty) in iter::zip(sig.inputs(), hir_decl.inputs) {\n-        fcx.register_wf_obligation(input_ty.into(), ty.span, ObligationCauseCode::MiscObligation);\n+        fcx.register_wf_obligation(input_ty.into(), ty.span, ObligationCauseCode::WellFormed(None));\n     }\n     implied_bounds.extend(sig.inputs());\n "}, {"sha": "fa9c44bb89191dc1c7131fe986ee96723e7391da", "filename": "compiler/rustc_typeck/src/hir_wf_check.rs", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs?ref=a7653337380071ebc5b83a8133121b87dc892442", "patch": "@@ -0,0 +1,133 @@\n+use crate::collect::ItemCtxt;\n+use rustc_hir as hir;\n+use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc_hir::HirId;\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::traits::ObligationCause;\n+use rustc_infer::traits::TraitEngine;\n+use rustc_middle::ty::query::Providers;\n+use rustc_middle::ty::{self, ToPredicate, TyCtxt};\n+use rustc_trait_selection::traits;\n+\n+pub fn provide(providers: &mut Providers) {\n+    *providers = Providers { diagnostic_hir_wf_check, ..*providers };\n+}\n+\n+// Ideally, this would be in `rustc_trait_selection`, but we\n+// need access to `ItemCtxt`\n+fn diagnostic_hir_wf_check<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    (predicate, hir_id): (ty::Predicate<'tcx>, HirId),\n+) -> Option<ObligationCause<'tcx>> {\n+    let hir = tcx.hir();\n+    // HIR wfcheck should only ever happen as part of improving an existing error\n+    tcx.sess.delay_span_bug(hir.span(hir_id), \"Performed HIR wfcheck without an existing error!\");\n+\n+    // Currently, we only handle WF checking for items (e.g. associated items).\n+    // It would be nice to extend this to handle wf checks inside functions.\n+    let def_id = match tcx.hir().opt_local_def_id(hir_id) {\n+        Some(def_id) => def_id,\n+        None => return None,\n+    };\n+\n+    // FIXME - figure out how we want to handle wf-checking for\n+    // things inside a function body.\n+    let icx = ItemCtxt::new(tcx, def_id.to_def_id());\n+\n+    // To perform HIR-based WF checking, we iterate over all HIR types\n+    // that occur 'inside' the item we're checking. For example,\n+    // given the type `Option<MyStruct<u8>>`, we will check\n+    // `Option<MyStruct<u8>>`, `MyStruct<u8>`, and `u8`.\n+    // For each type, we perform a well-formed check, and see if we get\n+    // an erorr that matches our expected predicate. We keep save\n+    // the `ObligationCause` corresponding to the *innermost* type,\n+    // which is the most specific type that we can point to.\n+    // In general, the different components of an `hir::Ty` may have\n+    // completely differentr spans due to macro invocations. Pointing\n+    // to the most accurate part of the type can be the difference\n+    // between a useless span (e.g. the macro invocation site)\n+    // and a useful span (e.g. a user-provided type passed in to the macro).\n+    //\n+    // This approach is quite inefficient - we redo a lot of work done\n+    // by the normal WF checker. However, this code is run at most once\n+    // per reported error - it will have no impact when compilation succeeds,\n+    // and should only have an impact if a very large number of errors are\n+    // displaydd to the user.\n+    struct HirWfCheck<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+        predicate: ty::Predicate<'tcx>,\n+        cause: Option<ObligationCause<'tcx>>,\n+        cause_depth: usize,\n+        icx: ItemCtxt<'tcx>,\n+        hir_id: HirId,\n+        param_env: ty::ParamEnv<'tcx>,\n+        depth: usize,\n+    }\n+\n+    impl<'tcx> Visitor<'tcx> for HirWfCheck<'tcx> {\n+        type Map = intravisit::ErasedMap<'tcx>;\n+        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+            NestedVisitorMap::None\n+        }\n+        fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n+            self.tcx.infer_ctxt().enter(|infcx| {\n+                let mut fulfill = traits::FulfillmentContext::new();\n+                let tcx_ty = self.icx.to_ty(ty);\n+                let cause = traits::ObligationCause::new(\n+                    ty.span,\n+                    self.hir_id,\n+                    traits::ObligationCauseCode::MiscObligation,\n+                );\n+                fulfill.register_predicate_obligation(\n+                    &infcx,\n+                    traits::Obligation::new(\n+                        cause,\n+                        self.param_env,\n+                        ty::PredicateKind::WellFormed(tcx_ty.into()).to_predicate(self.tcx),\n+                    ),\n+                );\n+\n+                if let Err(errors) = fulfill.select_all_or_error(&infcx) {\n+                    tracing::debug!(\"Wf-check got errors for {:?}: {:?}\", ty, errors);\n+                    for error in errors {\n+                        if error.obligation.predicate == self.predicate {\n+                            // Save the cause from the greatest depth - this corresponds\n+                            // to picking more-specific types (e.g. `MyStruct<u8>`)\n+                            // over less-specific types (e.g. `Option<MyStruct<u8>>`)\n+                            if self.depth >= self.cause_depth {\n+                                self.cause = Some(error.obligation.cause);\n+                                self.cause_depth = self.depth\n+                            }\n+                        }\n+                    }\n+                }\n+            });\n+            self.depth += 1;\n+            intravisit::walk_ty(self, ty);\n+            self.depth -= 1;\n+        }\n+    }\n+\n+    let mut visitor = HirWfCheck {\n+        tcx,\n+        predicate,\n+        cause: None,\n+        cause_depth: 0,\n+        icx,\n+        hir_id,\n+        param_env: tcx.param_env(def_id.to_def_id()),\n+        depth: 0,\n+    };\n+\n+    let ty = match tcx.hir().get(hir_id) {\n+        hir::Node::ImplItem(item) => match item.kind {\n+            hir::ImplItemKind::TyAlias(ref ty) => Some(ty),\n+            _ => None,\n+        },\n+        _ => None,\n+    };\n+    if let Some(ty) = ty {\n+        visitor.visit_ty(ty);\n+    }\n+    visitor.cause\n+}"}, {"sha": "5b717862e020f9d2bc622b8c4a4991de85ebda03", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7653337380071ebc5b83a8133121b87dc892442/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=a7653337380071ebc5b83a8133121b87dc892442", "patch": "@@ -88,6 +88,7 @@ mod coherence;\n mod collect;\n mod constrained_generic_params;\n mod errors;\n+pub mod hir_wf_check;\n mod impl_wf_check;\n mod mem_categorization;\n mod outlives;\n@@ -462,6 +463,7 @@ pub fn provide(providers: &mut Providers) {\n     variance::provide(providers);\n     outlives::provide(providers);\n     impl_wf_check::provide(providers);\n+    hir_wf_check::provide(providers);\n }\n \n pub fn check_crate(tcx: TyCtxt<'_>) -> Result<(), ErrorReported> {"}, {"sha": "c3811e82394292b158ae332608a33437db39d9a3", "filename": "src/test/ui/wf/wf-complex-assoc-type.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a7653337380071ebc5b83a8133121b87dc892442/src%2Ftest%2Fui%2Fwf%2Fwf-complex-assoc-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7653337380071ebc5b83a8133121b87dc892442/src%2Ftest%2Fui%2Fwf%2Fwf-complex-assoc-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-complex-assoc-type.rs?ref=a7653337380071ebc5b83a8133121b87dc892442", "patch": "@@ -0,0 +1,12 @@\n+trait MyTrait {}\n+struct AssertMyTrait<T: MyTrait>(T);\n+\n+trait HelperTrait {\n+    type MyItem;\n+}\n+\n+impl HelperTrait for () {\n+    type MyItem = Option<((AssertMyTrait<bool>, u8))>; //~ ERROR the trait bound\n+}\n+\n+fn main() {}"}, {"sha": "c366519a8d74ece7de4b3bf772ce91eebf1efff6", "filename": "src/test/ui/wf/wf-complex-assoc-type.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a7653337380071ebc5b83a8133121b87dc892442/src%2Ftest%2Fui%2Fwf%2Fwf-complex-assoc-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a7653337380071ebc5b83a8133121b87dc892442/src%2Ftest%2Fui%2Fwf%2Fwf-complex-assoc-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-complex-assoc-type.stderr?ref=a7653337380071ebc5b83a8133121b87dc892442", "patch": "@@ -0,0 +1,12 @@\n+error[E0277]: the trait bound `bool: MyTrait` is not satisfied\n+  --> $DIR/wf-complex-assoc-type.rs:9:28\n+   |\n+LL | struct AssertMyTrait<T: MyTrait>(T);\n+   |                         ------- required by this bound in `AssertMyTrait`\n+...\n+LL |     type MyItem = Option<((AssertMyTrait<bool>, u8))>;\n+   |                            ^^^^^^^^^^^^^^^^^^^ the trait `MyTrait` is not implemented for `bool`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "0d4480fbf26e012956677e35924f018ba3231ea1", "filename": "src/test/ui/wf/wf-impl-associated-type-trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7653337380071ebc5b83a8133121b87dc892442/src%2Ftest%2Fui%2Fwf%2Fwf-impl-associated-type-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a7653337380071ebc5b83a8133121b87dc892442/src%2Ftest%2Fui%2Fwf%2Fwf-impl-associated-type-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-impl-associated-type-trait.stderr?ref=a7653337380071ebc5b83a8133121b87dc892442", "patch": "@@ -1,11 +1,11 @@\n error[E0277]: the trait bound `T: MyHash` is not satisfied\n-  --> $DIR/wf-impl-associated-type-trait.rs:17:5\n+  --> $DIR/wf-impl-associated-type-trait.rs:17:16\n    |\n LL | pub struct MySet<T:MyHash> {\n    |                    ------ required by this bound in `MySet`\n ...\n LL |     type Bar = MySet<T>;\n-   |     ^^^^^^^^^^^^^^^^^^^^ the trait `MyHash` is not implemented for `T`\n+   |                ^^^^^^^^ the trait `MyHash` is not implemented for `T`\n    |\n help: consider restricting type parameter `T`\n    |"}]}