{"sha": "a3f98a7501384d4cd11ba94a46bdf88b7e2bc816", "node_id": "C_kwDOAAsO6NoAKGEzZjk4YTc1MDEzODRkNGNkMTFiYTk0YTQ2YmRmODhiN2UyYmM4MTY", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-10-07T19:56:40Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-10-07T20:42:18Z"}, "message": "Fix inherent impl overlap check.", "tree": {"sha": "a52c4f0b9056675297e7629a7c14791485ae4a0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a52c4f0b9056675297e7629a7c14791485ae4a0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3f98a7501384d4cd11ba94a46bdf88b7e2bc816", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3f98a7501384d4cd11ba94a46bdf88b7e2bc816", "html_url": "https://github.com/rust-lang/rust/commit/a3f98a7501384d4cd11ba94a46bdf88b7e2bc816", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3f98a7501384d4cd11ba94a46bdf88b7e2bc816/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0157cc977fd71297ce73e2f249321f5ba2555d42", "url": "https://api.github.com/repos/rust-lang/rust/commits/0157cc977fd71297ce73e2f249321f5ba2555d42", "html_url": "https://github.com/rust-lang/rust/commit/0157cc977fd71297ce73e2f249321f5ba2555d42"}], "stats": {"total": 110, "additions": 65, "deletions": 45}, "files": [{"sha": "66399d2999848d1b6380362853bb61f19aec1016", "filename": "compiler/rustc_index/src/vec.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3f98a7501384d4cd11ba94a46bdf88b7e2bc816/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f98a7501384d4cd11ba94a46bdf88b7e2bc816/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fvec.rs?ref=a3f98a7501384d4cd11ba94a46bdf88b7e2bc816", "patch": "@@ -741,6 +741,12 @@ impl<I: Idx, T> IndexVec<I, Option<T>> {\n         self.ensure_contains_elem(index, || None);\n         self[index].get_or_insert_with(value)\n     }\n+\n+    #[inline]\n+    pub fn remove(&mut self, index: I) -> Option<T> {\n+        self.ensure_contains_elem(index, || None);\n+        self[index].take()\n+    }\n }\n \n impl<I: Idx, T: Clone> IndexVec<I, T> {"}, {"sha": "0373035a09ad80606117228d074bcfadf3f8b22a", "filename": "compiler/rustc_typeck/src/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 58, "deletions": 45, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/a3f98a7501384d4cd11ba94a46bdf88b7e2bc816/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f98a7501384d4cd11ba94a46bdf88b7e2bc816/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs?ref=a3f98a7501384d4cd11ba94a46bdf88b7e2bc816", "patch": "@@ -3,6 +3,7 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n+use rustc_index::vec::IndexVec;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::Symbol;\n use rustc_trait_selection::traits::{self, SkipLeakCheck};\n@@ -158,22 +159,26 @@ impl ItemLikeVisitor<'v> for InherentOverlapChecker<'tcx> {\n                     // This is advantageous to running the algorithm over the\n                     // entire graph when there are many connected regions.\n \n+                    rustc_index::newtype_index! {\n+                        pub struct RegionId {\n+                            ENCODABLE = custom\n+                        }\n+                    }\n                     struct ConnectedRegion {\n                         idents: SmallVec<[Symbol; 8]>,\n                         impl_blocks: FxHashSet<usize>,\n                     }\n-                    // Highest connected region id\n-                    let mut highest_region_id = 0;\n+                    let mut connected_regions: IndexVec<RegionId, _> = Default::default();\n+                    // Reverse map from the Symbol to the connected region id.\n                     let mut connected_region_ids = FxHashMap::default();\n-                    let mut connected_regions = FxHashMap::default();\n \n                     for (i, &(&_impl_def_id, impl_items)) in impls_items.iter().enumerate() {\n                         if impl_items.len() == 0 {\n                             continue;\n                         }\n                         // First obtain a list of existing connected region ids\n                         let mut idents_to_add = SmallVec::<[Symbol; 8]>::new();\n-                        let ids = impl_items\n+                        let mut ids = impl_items\n                             .in_definition_order()\n                             .filter_map(|item| {\n                                 let entry = connected_region_ids.entry(item.ident.name);\n@@ -184,62 +189,64 @@ impl ItemLikeVisitor<'v> for InherentOverlapChecker<'tcx> {\n                                     None\n                                 }\n                             })\n-                            .collect::<FxHashSet<usize>>();\n-                        match ids.len() {\n-                            0 | 1 => {\n-                                let id_to_set = if ids.is_empty() {\n-                                    // Create a new connected region\n-                                    let region = ConnectedRegion {\n+                            .collect::<SmallVec<[RegionId; 8]>>();\n+                        // Sort the id list so that the algorithm is deterministic\n+                        ids.sort_unstable();\n+                        let ids = ids;\n+                        match &ids[..] {\n+                            // Create a new connected region\n+                            [] => {\n+                                let id_to_set = connected_regions.next_index();\n+                                // Update the connected region ids\n+                                for ident in &idents_to_add {\n+                                    connected_region_ids.insert(*ident, id_to_set);\n+                                }\n+                                connected_regions.insert(\n+                                    id_to_set,\n+                                    ConnectedRegion {\n                                         idents: idents_to_add,\n                                         impl_blocks: std::iter::once(i).collect(),\n-                                    };\n-                                    connected_regions.insert(highest_region_id, region);\n-                                    (highest_region_id, highest_region_id += 1).0\n-                                } else {\n-                                    // Take the only id inside the list\n-                                    let id_to_set = *ids.iter().next().unwrap();\n-                                    let region = connected_regions.get_mut(&id_to_set).unwrap();\n-                                    region.impl_blocks.insert(i);\n-                                    region.idents.extend_from_slice(&idents_to_add);\n-                                    id_to_set\n-                                };\n-                                let (_id, region) = connected_regions.iter().next().unwrap();\n+                                    },\n+                                );\n+                            }\n+                            // Take the only id inside the list\n+                            &[id_to_set] => {\n+                                let region = connected_regions[id_to_set].as_mut().unwrap();\n+                                region.impl_blocks.insert(i);\n+                                region.idents.extend_from_slice(&idents_to_add);\n                                 // Update the connected region ids\n-                                for ident in region.idents.iter() {\n+                                for ident in &idents_to_add {\n                                     connected_region_ids.insert(*ident, id_to_set);\n                                 }\n                             }\n-                            _ => {\n-                                // We have multiple connected regions to merge.\n-                                // In the worst case this might add impl blocks\n-                                // one by one and can thus be O(n^2) in the size\n-                                // of the resulting final connected region, but\n-                                // this is no issue as the final step to check\n-                                // for overlaps runs in O(n^2) as well.\n-\n-                                // Take the smallest id from the list\n-                                let id_to_set = *ids.iter().min().unwrap();\n-\n-                                // Sort the id list so that the algorithm is deterministic\n-                                let mut ids = ids.into_iter().collect::<SmallVec<[usize; 8]>>();\n-                                ids.sort_unstable();\n-\n-                                let mut region = connected_regions.remove(&id_to_set).unwrap();\n-                                region.idents.extend_from_slice(&idents_to_add);\n+                            // We have multiple connected regions to merge.\n+                            // In the worst case this might add impl blocks\n+                            // one by one and can thus be O(n^2) in the size\n+                            // of the resulting final connected region, but\n+                            // this is no issue as the final step to check\n+                            // for overlaps runs in O(n^2) as well.\n+                            &[id_to_set, ..] => {\n+                                let mut region = connected_regions.remove(id_to_set).unwrap();\n                                 region.impl_blocks.insert(i);\n+                                region.idents.extend_from_slice(&idents_to_add);\n+                                // Update the connected region ids\n+                                for ident in &idents_to_add {\n+                                    connected_region_ids.insert(*ident, id_to_set);\n+                                }\n \n+                                // Remove other regions from ids.\n                                 for &id in ids.iter() {\n                                     if id == id_to_set {\n                                         continue;\n                                     }\n-                                    let r = connected_regions.remove(&id).unwrap();\n-                                    // Update the connected region ids\n+                                    let r = connected_regions.remove(id).unwrap();\n                                     for ident in r.idents.iter() {\n                                         connected_region_ids.insert(*ident, id_to_set);\n                                     }\n                                     region.idents.extend_from_slice(&r.idents);\n                                     region.impl_blocks.extend(r.impl_blocks);\n                                 }\n+\n                                 connected_regions.insert(id_to_set, region);\n                             }\n                         }\n@@ -254,16 +261,22 @@ impl ItemLikeVisitor<'v> for InherentOverlapChecker<'tcx> {\n                             let avg = impls.len() / connected_regions.len();\n                             let s = connected_regions\n                                 .iter()\n-                                .map(|r| r.1.impl_blocks.len() as isize - avg as isize)\n+                                .flatten()\n+                                .map(|r| r.impl_blocks.len() as isize - avg as isize)\n                                 .map(|v| v.abs() as usize)\n                                 .sum::<usize>();\n                             s / connected_regions.len()\n                         },\n-                        connected_regions.iter().map(|r| r.1.impl_blocks.len()).max().unwrap()\n+                        connected_regions\n+                            .iter()\n+                            .flatten()\n+                            .map(|r| r.impl_blocks.len())\n+                            .max()\n+                            .unwrap()\n                     );\n                     // List of connected regions is built. Now, run the overlap check\n                     // for each pair of impl blocks in the same connected region.\n-                    for (_id, region) in connected_regions.into_iter() {\n+                    for region in connected_regions.into_iter().flatten() {\n                         let mut impl_blocks =\n                             region.impl_blocks.into_iter().collect::<SmallVec<[usize; 8]>>();\n                         impl_blocks.sort_unstable();"}, {"sha": "971776c882a157e4946fbe714bb2a54cafb375fd", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3f98a7501384d4cd11ba94a46bdf88b7e2bc816/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f98a7501384d4cd11ba94a46bdf88b7e2bc816/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=a3f98a7501384d4cd11ba94a46bdf88b7e2bc816", "patch": "@@ -63,6 +63,7 @@ This API is completely unstable and subject to change.\n #![feature(in_band_lifetimes)]\n #![feature(is_sorted)]\n #![feature(iter_zip)]\n+#![feature(min_specialization)]\n #![feature(nll)]\n #![feature(try_blocks)]\n #![feature(never_type)]"}]}