{"sha": "43e6ef876f8d2aab6e7fe28c5d929686e81beac4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzZTZlZjg3NmY4ZDJhYWI2ZTdmZTI4YzVkOTI5Njg2ZTgxYmVhYzQ=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-09-26T20:12:51Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-09-26T22:15:06Z"}, "message": "Update engine to use new interface", "tree": {"sha": "357060bc2e7441e51fccc249e07774e18dfe0526", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/357060bc2e7441e51fccc249e07774e18dfe0526"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43e6ef876f8d2aab6e7fe28c5d929686e81beac4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43e6ef876f8d2aab6e7fe28c5d929686e81beac4", "html_url": "https://github.com/rust-lang/rust/commit/43e6ef876f8d2aab6e7fe28c5d929686e81beac4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43e6ef876f8d2aab6e7fe28c5d929686e81beac4/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c5f9f742c0a8a4187116f1e443d6a0126990941", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c5f9f742c0a8a4187116f1e443d6a0126990941", "html_url": "https://github.com/rust-lang/rust/commit/4c5f9f742c0a8a4187116f1e443d6a0126990941"}], "stats": {"total": 146, "additions": 68, "deletions": 78}, "files": [{"sha": "ca2bb6e0bf7e91582c7157ee81c295ead9098779", "filename": "compiler/rustc_mir/src/dataflow/framework/direction.rs", "status": "modified", "additions": 68, "deletions": 78, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/43e6ef876f8d2aab6e7fe28c5d929686e81beac4/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fdirection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43e6ef876f8d2aab6e7fe28c5d929686e81beac4/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fdirection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fdirection.rs?ref=43e6ef876f8d2aab6e7fe28c5d929686e81beac4", "patch": "@@ -1,10 +1,10 @@\n use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::{self, BasicBlock, Location};\n-use rustc_middle::ty::{self, TyCtxt};\n+use rustc_middle::ty::TyCtxt;\n use std::ops::RangeInclusive;\n \n use super::visitor::{ResultsVisitable, ResultsVisitor};\n-use super::{Analysis, Effect, EffectIndex, GenKillAnalysis, GenKillSet};\n+use super::{Analysis, Effect, EffectIndex, GenKillAnalysis, GenKillSet, SwitchIntTarget};\n \n pub trait Direction {\n     fn is_forward() -> bool;\n@@ -425,8 +425,8 @@ impl Direction for Forward {\n \n     fn join_state_into_successors_of<A>(\n         analysis: &A,\n-        tcx: TyCtxt<'tcx>,\n-        body: &mir::Body<'tcx>,\n+        _tcx: TyCtxt<'tcx>,\n+        _body: &mir::Body<'tcx>,\n         dead_unwinds: Option<&BitSet<BasicBlock>>,\n         exit_state: &mut A::Domain,\n         (bb, bb_data): (BasicBlock, &'_ mir::BasicBlockData<'tcx>),\n@@ -489,88 +489,78 @@ impl Direction for Forward {\n             }\n \n             SwitchInt { ref targets, ref values, ref discr, switch_ty: _ } => {\n-                let enum_ = discr\n-                    .place()\n-                    .and_then(|discr| switch_on_enum_discriminant(tcx, &body, bb_data, discr));\n-                match enum_ {\n-                    // If this is a switch on an enum discriminant, a custom effect may be applied\n-                    // along each outgoing edge.\n-                    Some((enum_place, enum_def)) => {\n-                        // MIR building adds discriminants to the `values` array in the same order as they\n-                        // are yielded by `AdtDef::discriminants`. We rely on this to match each\n-                        // discriminant in `values` to its corresponding variant in linear time.\n-                        let mut tmp = analysis.bottom_value(body);\n-                        let mut discriminants = enum_def.discriminants(tcx);\n-                        for (value, target) in values.iter().zip(targets.iter().copied()) {\n-                            let (variant_idx, _) =\n-                                discriminants.find(|&(_, discr)| discr.val == *value).expect(\n-                                    \"Order of `AdtDef::discriminants` differed \\\n-                                         from that of `SwitchInt::values`\",\n-                                );\n-\n-                            tmp.clone_from(exit_state);\n-                            analysis.apply_discriminant_switch_effect(\n-                                &mut tmp,\n-                                bb,\n-                                enum_place,\n-                                enum_def,\n-                                variant_idx,\n-                            );\n-                            propagate(target, &tmp);\n-                        }\n-\n-                        // Move out of `tmp` so we don't accidentally use it below.\n-                        std::mem::drop(tmp);\n-\n-                        // Propagate dataflow state along the \"otherwise\" edge.\n-                        let otherwise = targets.last().copied().unwrap();\n-                        propagate(otherwise, exit_state)\n-                    }\n-\n-                    // Otherwise, it's just a normal `SwitchInt`, and every successor sees the same\n-                    // exit state.\n-                    None => {\n-                        for target in targets.iter().copied() {\n-                            propagate(target, exit_state);\n-                        }\n+                let mut applier = SwitchIntEdgeEffectApplier {\n+                    exit_state,\n+                    targets: targets.as_ref(),\n+                    values: values.as_ref(),\n+                    propagate,\n+                    effects_applied: false,\n+                };\n+\n+                analysis.apply_switch_int_edge_effects(bb, discr, &mut applier);\n+\n+                let SwitchIntEdgeEffectApplier {\n+                    exit_state, mut propagate, effects_applied, ..\n+                } = applier;\n+\n+                if !effects_applied {\n+                    for &target in targets.iter() {\n+                        propagate(target, exit_state);\n                     }\n                 }\n             }\n         }\n     }\n }\n \n-/// Inspect a `SwitchInt`-terminated basic block to see if the condition of that `SwitchInt` is\n-/// an enum discriminant.\n-///\n-/// We expect such blocks to have a call to `discriminant` as their last statement like so:\n-///   _42 = discriminant(_1)\n-///   SwitchInt(_42, ..)\n-///\n-/// If the basic block matches this pattern, this function returns the place corresponding to the\n-/// enum (`_1` in the example above) as well as the `AdtDef` of that enum.\n-fn switch_on_enum_discriminant(\n-    tcx: TyCtxt<'tcx>,\n-    body: &'mir mir::Body<'tcx>,\n-    block: &'mir mir::BasicBlockData<'tcx>,\n-    switch_on: mir::Place<'tcx>,\n-) -> Option<(mir::Place<'tcx>, &'tcx ty::AdtDef)> {\n-    match block.statements.last().map(|stmt| &stmt.kind) {\n-        Some(mir::StatementKind::Assign(box (lhs, mir::Rvalue::Discriminant(discriminated))))\n-            if *lhs == switch_on =>\n-        {\n-            match &discriminated.ty(body, tcx).ty.kind() {\n-                ty::Adt(def, _) => Some((*discriminated, def)),\n-\n-                // `Rvalue::Discriminant` is also used to get the active yield point for a\n-                // generator, but we do not need edge-specific effects in that case. This may\n-                // change in the future.\n-                ty::Generator(..) => None,\n-\n-                t => bug!(\"`discriminant` called on unexpected type {:?}\", t),\n-            }\n+struct SwitchIntEdgeEffectApplier<'a, D, F> {\n+    exit_state: &'a mut D,\n+    values: &'a [u128],\n+    targets: &'a [BasicBlock],\n+    propagate: F,\n+\n+    effects_applied: bool,\n+}\n+\n+impl<D, F> super::SwitchIntEdgeEffects<D> for SwitchIntEdgeEffectApplier<'_, D, F>\n+where\n+    D: Clone,\n+    F: FnMut(BasicBlock, &D),\n+{\n+    fn apply(&mut self, mut apply_edge_effect: impl FnMut(&mut D, SwitchIntTarget)) {\n+        assert!(!self.effects_applied);\n+\n+        let mut tmp = None;\n+        for (&value, &target) in self.values.iter().zip(self.targets.iter()) {\n+            let tmp = opt_clone_from_or_clone(&mut tmp, self.exit_state);\n+            apply_edge_effect(tmp, SwitchIntTarget { value: Some(value), target });\n+            (self.propagate)(target, tmp);\n         }\n \n-        _ => None,\n+        // Once we get to the final, \"otherwise\" branch, there is no need to preserve `exit_state`,\n+        // so pass it directly to `apply_edge_effect` to save a clone of the dataflow state.\n+        let otherwise = self.targets.last().copied().unwrap();\n+        apply_edge_effect(self.exit_state, SwitchIntTarget { value: None, target: otherwise });\n+        (self.propagate)(otherwise, self.exit_state);\n+\n+        self.effects_applied = true;\n+    }\n+}\n+\n+/// An analogue of `Option::get_or_insert_with` that stores a clone of `val` into `opt`, but uses\n+/// the more efficient `clone_from` if `opt` was `Some`.\n+///\n+/// Returns a mutable reference to the new clone that resides in `opt`.\n+//\n+// FIXME: Figure out how to express this using `Option::clone_from`, or maybe lift it into the\n+// standard library?\n+fn opt_clone_from_or_clone<T: Clone>(opt: &'a mut Option<T>, val: &T) -> &'a mut T {\n+    if opt.is_some() {\n+        let ret = opt.as_mut().unwrap();\n+        ret.clone_from(val);\n+        ret\n+    } else {\n+        *opt = Some(val.clone());\n+        opt.as_mut().unwrap()\n     }\n }"}]}