{"sha": "fafce9ae37128f14c890b0805b410527ab81472f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhZmNlOWFlMzcxMjhmMTRjODkwYjA4MDViNDEwNTI3YWI4MTQ3MmY=", "commit": {"author": {"name": "Kevin Cantu", "email": "me@kevincantu.org", "date": "2012-10-04T19:41:45Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-10-05T00:09:08Z"}, "message": "More looking at the tutorial, small changes", "tree": {"sha": "efcb98dacfcb1efe915aaa91485507f608dd0627", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efcb98dacfcb1efe915aaa91485507f608dd0627"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fafce9ae37128f14c890b0805b410527ab81472f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fafce9ae37128f14c890b0805b410527ab81472f", "html_url": "https://github.com/rust-lang/rust/commit/fafce9ae37128f14c890b0805b410527ab81472f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fafce9ae37128f14c890b0805b410527ab81472f/comments", "author": {"login": "killerswan", "id": 195060, "node_id": "MDQ6VXNlcjE5NTA2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/195060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killerswan", "html_url": "https://github.com/killerswan", "followers_url": "https://api.github.com/users/killerswan/followers", "following_url": "https://api.github.com/users/killerswan/following{/other_user}", "gists_url": "https://api.github.com/users/killerswan/gists{/gist_id}", "starred_url": "https://api.github.com/users/killerswan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killerswan/subscriptions", "organizations_url": "https://api.github.com/users/killerswan/orgs", "repos_url": "https://api.github.com/users/killerswan/repos", "events_url": "https://api.github.com/users/killerswan/events{/privacy}", "received_events_url": "https://api.github.com/users/killerswan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2dfd8229627e39cbef20b2b1663985232082890a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2dfd8229627e39cbef20b2b1663985232082890a", "html_url": "https://github.com/rust-lang/rust/commit/2dfd8229627e39cbef20b2b1663985232082890a"}], "stats": {"total": 120, "additions": 61, "deletions": 59}, "files": [{"sha": "5d1a39078dcf7073f1153b0946f90d4c2727c18f", "filename": "doc/tutorial.md", "status": "modified", "additions": 61, "deletions": 59, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/fafce9ae37128f14c890b0805b410527ab81472f/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/fafce9ae37128f14c890b0805b410527ab81472f/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=fafce9ae37128f14c890b0805b410527ab81472f", "patch": "@@ -329,7 +329,6 @@ something\u2014in which case you'll have embedded it in a bigger statement.\n # fn foo() -> bool { true }\n # fn bar() -> bool { true }\n # fn baz() -> bool { true }\n-\n // `let` is not an expression, so it is semi-colon terminated;\n let x = foo();\n \n@@ -711,8 +710,8 @@ Structs can be destructured in `match` patterns. The basic syntax is\n # struct Point { x: float, y: float }\n # let mypoint = Point { x: 0.0, y: 0.0 };\n match mypoint {\n-    Point { x: 0.0, y: y } => { io::println(y.to_str());                    }\n-    Point { x: x, y: y }   => { io::println(x.to_str() + \" \" + y.to_str()); }\n+    Point { x: 0.0, y: yy } => { io::println(yy.to_str());                     }\n+    Point { x: xx,  y: yy } => { io::println(xx.to_str() + \" \" + yy.to_str()); }\n }\n ~~~~\n \n@@ -802,7 +801,7 @@ dereference (`*`) unary operator:\n \n ~~~~\n # enum GizmoId = int;\n-let my_gizmo_id = GizmoId(10);\n+let my_gizmo_id: GizmoId = GizmoId(10);\n let id_int: int = *my_gizmo_id;\n ~~~~\n \n@@ -863,12 +862,8 @@ back to [later](#modules-and-crates)). They are introduced with the\n the return type follows the arrow.\n \n ~~~~\n-fn repeat(string: &str, count: int) -> ~str {\n-    let mut result = ~\"\";\n-    for count.times {\n-        result += string;\n-    }\n-    return result;\n+fn line(a: int, b: int, x: int) -> int {\n+    return a*x + b;\n }\n ~~~~\n \n@@ -889,10 +884,8 @@ fn int_to_str(i: int) -> ~str {\n ~~~~\n \n ~~~~\n-# const copernicus: int = 0;\n-fn int_to_str(i: int) -> ~str {\n-    if i == copernicus { ~\"tube sock\" }\n-    else { ~\"violin\" }\n+fn line(a: int, b: int, x: int) -> int {\n+    a*x + b\n }\n ~~~~\n \n@@ -906,6 +899,16 @@ fn do_nothing_the_hard_way() -> () { return (); }\n fn do_nothing_the_easy_way() { }\n ~~~~\n \n+Ending the function with a semicolon like so is equivalent to returning `()`.\n+\n+~~~~\n+fn line(a: int, b: int, x: int) -> int { a*x + b  }\n+fn oops(a: int, b: int, x: int) -> ()  { a*x + b; }\n+\n+assert 8  == line(5,3,1);\n+assert () == oops(5,3,1);\n+~~~~\n+\n Methods are like functions, except that they are defined for a specific\n 'self' type (like 'this' in C++). Calling a method is done with\n dot notation, as in `my_vec.len()`. Methods may be defined on most\n@@ -1005,7 +1008,7 @@ easy for programmers to reason about. Heap isolation has the\n additional benefit that garbage collection must only be done\n per-heap. Rust never \"stops the world\" to reclaim memory.\n \n-Complete isolation of heaps between tasks implies that any data\n+Complete isolation of heaps between tasks would, however, mean that any data\n transferred between tasks must be copied. While this is a fine and\n useful way to implement communication between tasks, it is also very\n inefficient for large data structures.  Because of this, Rust also\n@@ -1117,6 +1120,9 @@ If you really want to copy a unique box you must say so explicitly.\n ~~~~\n let x = ~10;\n let y = copy x;\n+\n+let z = *x + *y;\n+assert z = 20;\n ~~~~\n \n This is where the 'move' operator comes in. It is similar to\n@@ -1125,9 +1131,11 @@ from `x` to `y`, without violating the constraint that it only has a\n single owner (if you used assignment instead of the move operator, the\n box would, in principle, be copied).\n \n-~~~~\n+~~~~ {.ignore}\n let x = ~10;\n let y = move x;\n+\n+let z = *x + *y; // would cause an error: use of moved variable: `x`\n ~~~~\n \n Owned boxes, when they do not contain any managed boxes, can be sent\n@@ -1265,7 +1273,7 @@ also done with square brackets (zero-based):\n #               BananaMania, Beaver, Bittersweet };\n # fn draw_scene(c: Crayon) { }\n \n-let crayons = [BananaMania, Beaver, Bittersweet];\n+let crayons: [Crayon] = [BananaMania, Beaver, Bittersweet];\n match crayons[0] {\n     Bittersweet => draw_scene(crayons[0]),\n     _ => ()\n@@ -1282,7 +1290,7 @@ elements. Mutable vector literals are written `[mut]` (empty) or `[mut\n #               Aquamarine, Asparagus, AtomicTangerine,\n #               BananaMania, Beaver, Bittersweet };\n \n-let crayons = [mut BananaMania, Beaver, Bittersweet];\n+let crayons: [mut Crayon] = [mut BananaMania, Beaver, Bittersweet];\n crayons[0] = AtomicTangerine;\n ~~~~\n \n@@ -1318,8 +1326,8 @@ my_crayons += your_crayons;\n > not well supported yet, owned vectors are often the most\n > usable.\n \n-Strings are simply vectors of `[u8]`, though they have a distinct\n-type. They support most of the same allocation aptions as\n+Strings are implemented with vectors of `[u8]`, though they have a distinct\n+type. They support most of the same allocation options as\n vectors, though the string literal without a storage sigil, e.g.\n `\"foo\"` is treated differently than a comparable vector (`[foo]`).\n Where\n@@ -1328,7 +1336,7 @@ Where\n // A plain string is a slice to read-only (static) memory\n let stack_crayons: &str = \"Almond, AntiqueBrass, Apricot\";\n \n-// The same thing, but without\n+// The same thing, but with the `&`\n let stack_crayons: &str = &\"Almond, AntiqueBrass, Apricot\";\n \n // A local heap (managed) string\n@@ -1511,9 +1519,12 @@ call_twice(bare_function);\n \n ## Do syntax\n \n-Closures in Rust are frequently used in combination with higher-order\n-functions to simulate control structures like `if` and\n-`loop`. Consider this function that iterates over a vector of\n+The `do` expression is syntactic sugar for use with functions which\n+take a closure as a final argument, because closures in Rust\n+are so frequently used in combination with higher-order\n+functions.\n+\n+Consider this function which iterates over a vector of\n integers, passing in a pointer to each integer in the vector:\n \n ~~~~\n@@ -1558,8 +1569,7 @@ do each(&[1, 2, 3]) |n| {\n The call is prefixed with the keyword `do` and, instead of writing the\n final closure inside the argument list it is moved outside of the\n parenthesis where it looks visually more like a typical block of\n-code. The `do` expression is purely syntactic sugar for a call that\n-takes a final closure argument.\n+code.\n \n `do` is often used for task spawning.\n \n@@ -1653,6 +1663,10 @@ fn contains(v: &[int], elt: int) -> bool {\n \n `for` syntax only works with stack closures.\n \n+> ***Note:*** This is, essentially, a special loop protocol:\n+> the keywords `break`, `loop`, and `return` work, in varying degree,\n+> with `while`, `loop`, `do`, and `for` constructs.\n+\n # Generics\n \n Throughout this tutorial, we've been defining functions that act only on\n@@ -2057,6 +2071,9 @@ The compiler will now look for `poultry/chicken.rs` and\n and `poultry::turkey`. You can also provide a `poultry.rs` to add\n content to the `poultry` module itself.\n \n+The compiler then builds the crate as a platform-specific shared library or\n+executable which can be distributed.\n+\n ## Using other crates\n \n Having compiled a crate that contains the `#[crate_type = \"lib\"]`\n@@ -2111,22 +2128,22 @@ Now for something that you can actually compile yourself. We have\n these two files:\n \n ~~~~\n-// mylib.rs\n-#[link(name = \"mylib\", vers = \"1.0\")];\n-fn world() -> ~str { ~\"world\" }\n+// world.rs\n+#[link(name = \"world\", vers = \"1.0\")];\n+fn explore() -> ~str { ~\"world\" }\n ~~~~\n \n ~~~~ {.ignore}\n // main.rs\n-extern mod mylib;\n-fn main() { io::println(~\"hello \" + mylib::world()); }\n+extern mod world;\n+fn main() { io::println(~\"hello \" + world::explore()); }\n ~~~~\n \n Now compile and run like this (adjust to your platform if necessary):\n \n ~~~~ {.notrust}\n-> rustc --lib mylib.rs\n-> rustc main.rs -L .\n+> rustc --lib world.rs  # compiles libworld-94839cbfe144198-1.0.so\n+> rustc main.rs -L .    # compiles main\n > ./main\n \"hello world\"\n ~~~~\n@@ -2146,12 +2163,14 @@ fn main() {\n }\n ~~~~\n \n+\n It is also possible to import just the name of a module (`use\n std::list;`, then use `list::find`), to import all identifiers exported\n by a given module (`use io::*`), or to import a specific set\n of identifiers (`use math::{min, max, pi}`).\n \n-You can rename an identifier when importing using the `=` operator:\n+Rust uses different namespaces for modules, types, and values.  You\n+can also rename an identifier when importing using the `=` operator:\n \n ~~~~\n use prnt = io::println;\n@@ -2175,27 +2194,6 @@ This defines a rock-solid encryption algorithm. Code outside of the\n module can refer to the `enc::encrypt` and `enc::decrypt` identifiers\n just fine, but it does not have access to `enc::super_secret_number`.\n \n-## Namespaces\n-\n-Rust uses three different namespaces: one for modules, one for types,\n-and one for values. This means that this code is valid:\n-\n-~~~~\n-#[legacy_exports]\n-mod buffalo {\n-    type buffalo = int;\n-    fn buffalo<buffalo>(+buffalo: buffalo) -> buffalo { buffalo }\n-}\n-fn main() {\n-    let buffalo: buffalo::buffalo = 1;\n-    buffalo::buffalo::<buffalo::buffalo>(buffalo::buffalo(buffalo));\n-}\n-~~~~\n-\n-You don't want to write things like that, but it *is* very practical\n-to not have to worry about name clashes between types, values, and\n-modules.\n-\n ## Resolution\n \n The resolution process in Rust simply goes up the chain of contexts,\n@@ -2211,21 +2209,25 @@ Identifiers can shadow each other. In this program, `x` is of type\n type MyType = ~str;\n fn main() {\n     type MyType = int;\n-    let x: MyType;\n+    let x: MyType = 17;\n }\n ~~~~\n \n An `use` directive will only import into the namespaces for which\n identifiers are actually found. Consider this example:\n \n ~~~~\n-mod foo { fn bar() {} }\n-fn baz() {\n-    let bar = 10u;\n+mod foo {\n+   fn bar() {}\n+}\n+\n+fn main() {\n+    let bar = 10;\n \n     {\n         use foo::bar;\n         let quux = bar;\n+        assert quux == 10;\n     }\n }\n ~~~~"}]}