{"sha": "9a90d436f64b004a55368751b64b850d710fad34", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhOTBkNDM2ZjY0YjAwNGE1NTM2ODc1MWI2NGI4NTBkNzEwZmFkMzQ=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-01-04T16:47:58Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-01-04T16:47:58Z"}, "message": "rustc: allow paths in constants to refer to polymorphic items.", "tree": {"sha": "82f12d791bf7712529df148dfee60a614c8ec4d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82f12d791bf7712529df148dfee60a614c8ec4d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a90d436f64b004a55368751b64b850d710fad34", "comment_count": 7, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a90d436f64b004a55368751b64b850d710fad34", "html_url": "https://github.com/rust-lang/rust/commit/9a90d436f64b004a55368751b64b850d710fad34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a90d436f64b004a55368751b64b850d710fad34/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0c07dabd1d790698991d3f40c9619d56a71a8b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0c07dabd1d790698991d3f40c9619d56a71a8b9", "html_url": "https://github.com/rust-lang/rust/commit/a0c07dabd1d790698991d3f40c9619d56a71a8b9"}], "stats": {"total": 475, "additions": 286, "deletions": 189}, "files": [{"sha": "ac53bdbefcf10a4e2d63c37efa7f4a4a9ae83474", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9a90d436f64b004a55368751b64b850d710fad34/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a90d436f64b004a55368751b64b850d710fad34/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=9a90d436f64b004a55368751b64b850d710fad34", "patch": "@@ -111,20 +111,11 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &ast::Expr) {\n                            expression\");\n             }\n         }\n-        ast::ExprPath(ref pth) => {\n-            // NB: In the future you might wish to relax this slightly\n-            // to handle on-demand instantiation of functions via\n-            // foo::<bar> in a const. Currently that is only done on\n-            // a path in trans::callee that only works in block contexts.\n-            if !pth.segments.iter().all(|segment| segment.parameters.is_empty()) {\n-                span_err!(v.tcx.sess, e.span, E0013,\n-                          \"paths in constants may only refer to items without \\\n-                           type parameters\");\n-            }\n+        ast::ExprPath(_) => {\n             match v.tcx.def_map.borrow()[e.id] {\n                 DefStatic(..) | DefConst(..) |\n-                DefFn(..) | DefStruct(_) |\n-                DefVariant(_, _, _) => {}\n+                DefFn(..) | DefStaticMethod(..) | DefMethod(..) |\n+                DefStruct(_) | DefVariant(_, _, _) => {}\n \n                 def => {\n                     debug!(\"(checking const) found bad def: {}\", def);"}, {"sha": "31c3ca4199febfa27dea50422c9caa64d6a00405", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a90d436f64b004a55368751b64b850d710fad34/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a90d436f64b004a55368751b64b850d710fad34/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=9a90d436f64b004a55368751b64b850d710fad34", "patch": "@@ -559,14 +559,14 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                id, expr_ty.repr(self.tcx()), def);\n \n         match def {\n-          def::DefStruct(..) | def::DefVariant(..) | def::DefFn(..) |\n-          def::DefStaticMethod(..) | def::DefConst(..) => {\n+          def::DefStruct(..) | def::DefVariant(..) | def::DefConst(..) |\n+          def::DefFn(..) | def::DefStaticMethod(..) |  def::DefMethod(..) => {\n                 Ok(self.cat_rvalue_node(id, span, expr_ty))\n           }\n           def::DefMod(_) | def::DefForeignMod(_) | def::DefUse(_) |\n           def::DefTrait(_) | def::DefTy(..) | def::DefPrimTy(_) |\n           def::DefTyParam(..) | def::DefTyParamBinder(..) | def::DefRegion(_) |\n-          def::DefLabel(_) | def::DefSelfTy(..) | def::DefMethod(..) |\n+          def::DefLabel(_) | def::DefSelfTy(..) |\n           def::DefAssociatedTy(..) | def::DefAssociatedPath(..)=> {\n               Ok(Rc::new(cmt_ {\n                   id:id,"}, {"sha": "986c96e1cdf1d4c7068448c578eaf136d75fa1cd", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a90d436f64b004a55368751b64b850d710fad34/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a90d436f64b004a55368751b64b850d710fad34/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=9a90d436f64b004a55368751b64b850d710fad34", "patch": "@@ -511,7 +511,7 @@ pub fn get_res_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // Since we're in trans we don't care for any region parameters\n         let substs = subst::Substs::erased(substs.types.clone());\n \n-        let (val, _) = monomorphize::monomorphic_fn(ccx, did, &substs, None);\n+        let (val, _, _) = monomorphize::monomorphic_fn(ccx, did, &substs, None);\n \n         val\n     } else if did.krate == ast::LOCAL_CRATE {"}, {"sha": "c8d3a973a350e0dc77d8bde4c627fc59563896d1", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 58, "deletions": 40, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/9a90d436f64b004a55368751b64b850d710fad34/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a90d436f64b004a55368751b64b850d710fad34/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=9a90d436f64b004a55368751b64b850d710fad34", "patch": "@@ -38,6 +38,7 @@ use trans::cleanup::CleanupMethods;\n use trans::closure;\n use trans::common;\n use trans::common::*;\n+use trans::consts;\n use trans::datum::*;\n use trans::expr;\n use trans::glue;\n@@ -152,7 +153,8 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                     _ => false\n                 }\n             } => {\n-                let substs = node_id_substs(bcx, ExprId(ref_expr.id));\n+                let substs = node_id_substs(bcx.ccx(), ExprId(ref_expr.id),\n+                                            bcx.fcx.param_substs);\n                 Callee {\n                     bcx: bcx,\n                     data: NamedTupleConstructor(substs, 0)\n@@ -162,23 +164,28 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                 ty::ty_bare_fn(_, ref f) => f.abi == synabi::RustIntrinsic,\n                 _ => false\n             } => {\n-                let substs = node_id_substs(bcx, ExprId(ref_expr.id));\n+                let substs = node_id_substs(bcx.ccx(), ExprId(ref_expr.id),\n+                                            bcx.fcx.param_substs);\n                 let def_id = inline::maybe_instantiate_inline(bcx.ccx(), did);\n                 Callee { bcx: bcx, data: Intrinsic(def_id.node, substs) }\n             }\n             def::DefFn(did, _) | def::DefMethod(did, _, def::FromImpl(_)) |\n             def::DefStaticMethod(did, def::FromImpl(_)) => {\n-                fn_callee(bcx, trans_fn_ref(bcx, did, ExprId(ref_expr.id)))\n+                fn_callee(bcx, trans_fn_ref(bcx.ccx(), did, ExprId(ref_expr.id),\n+                                            bcx.fcx.param_substs).val)\n             }\n             def::DefStaticMethod(meth_did, def::FromTrait(trait_did)) |\n             def::DefMethod(meth_did, _, def::FromTrait(trait_did)) => {\n-                fn_callee(bcx, meth::trans_static_method_callee(bcx, meth_did,\n+                fn_callee(bcx, meth::trans_static_method_callee(bcx.ccx(),\n+                                                                meth_did,\n                                                                 trait_did,\n-                                                                ref_expr.id))\n+                                                                ref_expr.id,\n+                                                                bcx.fcx.param_substs).val)\n             }\n             def::DefVariant(tid, vid, _) => {\n                 let vinfo = ty::enum_variant_with_id(bcx.tcx(), tid, vid);\n-                let substs = node_id_substs(bcx, ExprId(ref_expr.id));\n+                let substs = node_id_substs(bcx.ccx(), ExprId(ref_expr.id),\n+                                            bcx.fcx.param_substs);\n \n                 // Nullary variants are not callable\n                 assert!(vinfo.args.len() > 0u);\n@@ -189,7 +196,8 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                 }\n             }\n             def::DefStruct(_) => {\n-                let substs = node_id_substs(bcx, ExprId(ref_expr.id));\n+                let substs = node_id_substs(bcx.ccx(), ExprId(ref_expr.id),\n+                                            bcx.fcx.param_substs);\n                 Callee {\n                     bcx: bcx,\n                     data: NamedTupleConstructor(substs, 0)\n@@ -217,15 +225,19 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n \n /// Translates a reference (with id `ref_id`) to the fn/method with id `def_id` into a function\n /// pointer. This may require monomorphization or inlining.\n-pub fn trans_fn_ref(bcx: Block, def_id: ast::DefId, node: ExprOrMethodCall) -> ValueRef {\n+pub fn trans_fn_ref<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                              def_id: ast::DefId,\n+                              node: ExprOrMethodCall,\n+                              param_substs: &subst::Substs<'tcx>)\n+                              -> Datum<'tcx, Rvalue> {\n     let _icx = push_ctxt(\"trans_fn_ref\");\n \n-    let substs = node_id_substs(bcx, node);\n+    let substs = node_id_substs(ccx, node, param_substs);\n     debug!(\"trans_fn_ref(def_id={}, node={}, substs={})\",\n-           def_id.repr(bcx.tcx()),\n+           def_id.repr(ccx.tcx()),\n            node,\n-           substs.repr(bcx.tcx()));\n-    trans_fn_ref_with_substs(bcx, def_id, node, substs)\n+           substs.repr(ccx.tcx()));\n+    trans_fn_ref_with_substs(ccx, def_id, node, param_substs, substs)\n }\n \n fn trans_fn_ref_with_substs_to_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n@@ -235,10 +247,11 @@ fn trans_fn_ref_with_substs_to_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                   -> Callee<'blk, 'tcx> {\n     Callee {\n         bcx: bcx,\n-        data: Fn(trans_fn_ref_with_substs(bcx,\n+        data: Fn(trans_fn_ref_with_substs(bcx.ccx(),\n                                           def_id,\n                                           ExprId(ref_id),\n-                                          substs)),\n+                                          bcx.fcx.param_substs,\n+                                          substs).val),\n     }\n }\n \n@@ -364,28 +377,30 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n ///\n /// # Parameters\n ///\n-/// - `bcx`: the current block where the reference to the fn occurs\n+/// - `ccx`: the crate context\n /// - `def_id`: def id of the fn or method item being referenced\n /// - `node`: node id of the reference to the fn/method, if applicable.\n ///   This parameter may be zero; but, if so, the resulting value may not\n ///   have the right type, so it must be cast before being used.\n+/// - `param_substs`: if the `node` is in a polymorphic function, these\n+///   are the substitutions required to monomorphize its type\n /// - `substs`: values for each of the fn/method's parameters\n-pub fn trans_fn_ref_with_substs<'blk, 'tcx>(\n-    bcx: Block<'blk, 'tcx>,      //\n-    def_id: ast::DefId,          // def id of fn\n-    node: ExprOrMethodCall,      // node id of use of fn; may be zero if N/A\n-    substs: subst::Substs<'tcx>) // vtables for the call\n-    -> ValueRef\n+pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n+    ccx: &CrateContext<'a, 'tcx>,\n+    def_id: ast::DefId,\n+    node: ExprOrMethodCall,\n+    param_substs: &subst::Substs<'tcx>,\n+    substs: subst::Substs<'tcx>)\n+    -> Datum<'tcx, Rvalue>\n {\n     let _icx = push_ctxt(\"trans_fn_ref_with_substs\");\n-    let ccx = bcx.ccx();\n-    let tcx = bcx.tcx();\n+    let tcx = ccx.tcx();\n \n-    debug!(\"trans_fn_ref_with_substs(bcx={}, def_id={}, node={}, \\\n-            substs={})\",\n-           bcx.to_str(),\n+    debug!(\"trans_fn_ref_with_substs(def_id={}, node={}, \\\n+            param_substs={}, substs={})\",\n            def_id.repr(tcx),\n            node,\n+           param_substs.repr(tcx),\n            substs.repr(tcx));\n \n     assert!(substs.types.all(|t| !ty::type_needs_infer(*t)));\n@@ -443,15 +458,15 @@ pub fn trans_fn_ref_with_substs<'blk, 'tcx>(\n                     (true, source_id, new_substs)\n                 }\n                 ty::TypeTraitItem(_) => {\n-                    bcx.tcx().sess.bug(\"trans_fn_ref_with_vtables() tried \\\n-                                        to translate an associated type?!\")\n+                    tcx.sess.bug(\"trans_fn_ref_with_vtables() tried \\\n+                                  to translate an associated type?!\")\n                 }\n             }\n         }\n     };\n \n     // If this is an unboxed closure, redirect to it.\n-    match closure::get_or_create_declaration_if_unboxed_closure(bcx,\n+    match closure::get_or_create_declaration_if_unboxed_closure(ccx,\n                                                                 def_id,\n                                                                 &substs) {\n         None => {}\n@@ -494,24 +509,27 @@ pub fn trans_fn_ref_with_substs<'blk, 'tcx>(\n             MethodCallKey(_) => None,\n         };\n \n-        let (val, must_cast) =\n+        let (val, fn_ty, must_cast) =\n             monomorphize::monomorphic_fn(ccx, def_id, &substs, opt_ref_id);\n-        let mut val = val;\n         if must_cast && node != ExprId(0) {\n             // Monotype of the REFERENCE to the function (type params\n             // are subst'd)\n             let ref_ty = match node {\n-                ExprId(id) => node_id_type(bcx, id),\n+                ExprId(id) => ty::node_id_to_type(tcx, id),\n                 MethodCallKey(method_call) => {\n-                    let t = (*bcx.tcx().method_map.borrow())[method_call].ty;\n-                    monomorphize_type(bcx, t)\n+                    (*tcx.method_map.borrow())[method_call].ty\n                 }\n             };\n-\n-            val = PointerCast(\n-                bcx, val, type_of::type_of_fn_from_ty(ccx, ref_ty).ptr_to());\n+            let ref_ty = monomorphize::apply_param_substs(tcx,\n+                                                          param_substs,\n+                                                          &ref_ty);\n+            let llptrty = type_of::type_of_fn_from_ty(ccx, ref_ty).ptr_to();\n+            if llptrty != val_ty(val) {\n+                let val = consts::ptrcast(val, llptrty);\n+                return Datum::new(val, ref_ty, Rvalue::new(ByValue));\n+            }\n         }\n-        return val;\n+        return Datum::new(val, fn_ty, Rvalue::new(ByValue));\n     }\n \n     // Type scheme of the function item (may have type params)\n@@ -556,12 +574,12 @@ pub fn trans_fn_ref_with_substs<'blk, 'tcx>(\n     let llptrty = llty.ptr_to();\n     if val_ty(val) != llptrty {\n         debug!(\"trans_fn_ref_with_vtables(): casting pointer!\");\n-        val = BitCast(bcx, val, llptrty);\n+        val = consts::ptrcast(val, llptrty);\n     } else {\n         debug!(\"trans_fn_ref_with_vtables(): not casting pointer!\");\n     }\n \n-    val\n+    Datum::new(val, fn_type, Rvalue::new(ByValue))\n }\n \n // ______________________________________________________________________"}, {"sha": "79a5898e3d33ea2db7e3aaefd46ac2eee6b0b2e6", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a90d436f64b004a55368751b64b850d710fad34/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a90d436f64b004a55368751b64b850d710fad34/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=9a90d436f64b004a55368751b64b850d710fad34", "patch": "@@ -726,7 +726,10 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n         // specify any of the types for the function, we just make it a symbol\n         // that LLVM can later use.\n         let llpersonality = match pad_bcx.tcx().lang_items.eh_personality() {\n-            Some(def_id) => callee::trans_fn_ref(pad_bcx, def_id, ExprId(0)),\n+            Some(def_id) => {\n+                callee::trans_fn_ref(pad_bcx.ccx(), def_id, ExprId(0),\n+                                     pad_bcx.fcx.param_substs).val\n+            }\n             None => {\n                 let mut personality = self.ccx.eh_personality().borrow_mut();\n                 match *personality {"}, {"sha": "7b394cef192eb99479ac7944a0bb52496cb3abef", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9a90d436f64b004a55368751b64b850d710fad34/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a90d436f64b004a55368751b64b850d710fad34/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=9a90d436f64b004a55368751b64b850d710fad34", "patch": "@@ -20,6 +20,7 @@ use trans::build::*;\n use trans::cleanup::{CleanupMethods, ScopeId};\n use trans::common::*;\n use trans::datum::{Datum, DatumBlock, Expr, Lvalue, rvalue_scratch_datum};\n+use trans::datum::{Rvalue, ByValue};\n use trans::debuginfo;\n use trans::expr;\n use trans::monomorphize::{self, MonoId};\n@@ -453,22 +454,21 @@ pub fn trans_expr_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n /// Returns the LLVM function declaration for an unboxed closure, creating it\n /// if necessary. If the ID does not correspond to a closure ID, returns None.\n-pub fn get_or_create_declaration_if_unboxed_closure<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                                                closure_id: ast::DefId,\n-                                                                substs: &Substs<'tcx>)\n-                                                                -> Option<ValueRef> {\n-    let ccx = bcx.ccx();\n+pub fn get_or_create_declaration_if_unboxed_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                                              closure_id: ast::DefId,\n+                                                              substs: &Substs<'tcx>)\n+                                                              -> Option<Datum<'tcx, Rvalue>> {\n     if !ccx.tcx().unboxed_closures.borrow().contains_key(&closure_id) {\n         // Not an unboxed closure.\n         return None\n     }\n \n-    let function_type = ty::node_id_to_type(bcx.tcx(), closure_id.node);\n-    let function_type = monomorphize::apply_param_substs(bcx.tcx(), substs, &function_type);\n+    let function_type = ty::node_id_to_type(ccx.tcx(), closure_id.node);\n+    let function_type = monomorphize::apply_param_substs(ccx.tcx(), substs, &function_type);\n \n     // Normalize type so differences in regions and typedefs don't cause\n     // duplicate declarations\n-    let function_type = ty::normalize_ty(bcx.tcx(), function_type);\n+    let function_type = ty::normalize_ty(ccx.tcx(), function_type);\n     let params = match function_type.sty {\n         ty::ty_unboxed_closure(_, _, ref substs) => substs.types.clone(),\n         _ => unreachable!()\n@@ -479,10 +479,10 @@ pub fn get_or_create_declaration_if_unboxed_closure<'blk, 'tcx>(bcx: Block<'blk,\n     };\n \n     match ccx.unboxed_closure_vals().borrow().get(&mono_id) {\n-        Some(llfn) => {\n+        Some(&llfn) => {\n             debug!(\"get_or_create_declaration_if_unboxed_closure(): found \\\n                     closure\");\n-            return Some(*llfn)\n+            return Some(Datum::new(llfn, function_type, Rvalue::new(ByValue)))\n         }\n         None => {}\n     }\n@@ -502,7 +502,7 @@ pub fn get_or_create_declaration_if_unboxed_closure<'blk, 'tcx>(bcx: Block<'blk,\n            ccx.tn().type_to_string(val_ty(llfn)));\n     ccx.unboxed_closure_vals().borrow_mut().insert(mono_id, llfn);\n \n-    Some(llfn)\n+    Some(Datum::new(llfn, function_type, Rvalue::new(ByValue)))\n }\n \n pub fn trans_unboxed_closure<'blk, 'tcx>(\n@@ -519,7 +519,7 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n \n     let closure_id = ast_util::local_def(id);\n     let llfn = get_or_create_declaration_if_unboxed_closure(\n-        bcx,\n+        bcx.ccx(),\n         closure_id,\n         bcx.fcx.param_substs).unwrap();\n \n@@ -539,7 +539,7 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n     trans_closure(bcx.ccx(),\n                   decl,\n                   body,\n-                  llfn,\n+                  llfn.val,\n                   bcx.fcx.param_substs,\n                   id,\n                   &[],"}, {"sha": "e8dee19ed54c1f7acb82f645b2e3574391d211d0", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9a90d436f64b004a55368751b64b850d710fad34/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a90d436f64b004a55368751b64b850d710fad34/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=9a90d436f64b004a55368751b64b850d710fad34", "patch": "@@ -28,6 +28,7 @@ use middle::subst::{self, Subst, Substs};\n use trans::base;\n use trans::build;\n use trans::cleanup;\n+use trans::consts;\n use trans::datum;\n use trans::debuginfo;\n use trans::machine;\n@@ -803,12 +804,9 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> Va\n // NB: Do not use `do_spill_noroot` to make this into a constant string, or\n // you will be kicked off fast isel. See issue #4352 for an example of this.\n pub fn C_str_slice(cx: &CrateContext, s: InternedString) -> ValueRef {\n-    unsafe {\n-        let len = s.get().len();\n-        let cs = llvm::LLVMConstPointerCast(C_cstr(cx, s, false),\n-                                            Type::i8p(cx).to_ref());\n-        C_named_struct(cx.tn().find_type(\"str_slice\").unwrap(), &[cs, C_uint(cx, len)])\n-    }\n+    let len = s.get().len();\n+    let cs = consts::ptrcast(C_cstr(cx, s, false), Type::i8p(cx));\n+    C_named_struct(cx.tn().find_type(\"str_slice\").unwrap(), &[cs, C_uint(cx, len)])\n }\n \n pub fn C_binary_slice(cx: &CrateContext, data: &[u8]) -> ValueRef {\n@@ -824,7 +822,7 @@ pub fn C_binary_slice(cx: &CrateContext, data: &[u8]) -> ValueRef {\n         llvm::LLVMSetGlobalConstant(g, True);\n         llvm::SetLinkage(g, llvm::InternalLinkage);\n \n-        let cs = llvm::LLVMConstPointerCast(g, Type::i8p(cx).to_ref());\n+        let cs = consts::ptrcast(g, Type::i8p(cx));\n         C_struct(cx, &[cs, C_uint(cx, len)], false)\n     }\n }\n@@ -1095,11 +1093,11 @@ pub enum ExprOrMethodCall {\n     MethodCallKey(ty::MethodCall)\n }\n \n-pub fn node_id_substs<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                  node: ExprOrMethodCall)\n-                                  -> subst::Substs<'tcx>\n-{\n-    let tcx = bcx.tcx();\n+pub fn node_id_substs<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                node: ExprOrMethodCall,\n+                                param_substs: &subst::Substs<'tcx>)\n+                                -> subst::Substs<'tcx> {\n+    let tcx = ccx.tcx();\n \n     let substs = match node {\n         ExprId(id) => {\n@@ -1111,15 +1109,13 @@ pub fn node_id_substs<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     };\n \n     if substs.types.any(|t| ty::type_needs_infer(*t)) {\n-        bcx.sess().bug(\n-            format!(\"type parameters for node {} include inference types: \\\n-                     {}\",\n-                    node,\n-                    substs.repr(bcx.tcx()))[]);\n+        tcx.sess.bug(format!(\"type parameters for node {} include inference types: {}\",\n+                             node, substs.repr(tcx))[]);\n     }\n \n-    let substs = substs.erase_regions();\n-    bcx.monomorphize(&substs)\n+    monomorphize::apply_param_substs(tcx,\n+                                     param_substs,\n+                                     &substs.erase_regions())\n }\n \n pub fn langcall(bcx: Block,"}, {"sha": "b17e852d7cbc44e7408e9107a0ebea6c81321880", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/9a90d436f64b004a55368751b64b850d710fad34/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a90d436f64b004a55368751b64b850d710fad34/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=9a90d436f64b004a55368751b64b850d710fad34", "patch": "@@ -14,13 +14,13 @@ use llvm;\n use llvm::{ConstFCmp, ConstICmp, SetLinkage, PrivateLinkage, ValueRef, Bool, True, False};\n use llvm::{IntEQ, IntNE, IntUGT, IntUGE, IntULT, IntULE, IntSGT, IntSGE, IntSLT, IntSLE,\n            RealOEQ, RealOGT, RealOGE, RealOLT, RealOLE, RealONE};\n-use metadata::csearch;\n use middle::{const_eval, def};\n use trans::{adt, closure, consts, debuginfo, expr, inline, machine};\n use trans::base::{self, push_ctxt};\n use trans::common::*;\n use trans::type_::Type;\n use trans::type_of;\n+use middle::subst::Substs;\n use middle::ty::{self, Ty};\n use util::ppaux::{Repr, ty_to_string};\n \n@@ -79,11 +79,9 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n     }\n }\n \n-pub fn const_ptrcast(cx: &CrateContext, a: ValueRef, t: Type) -> ValueRef {\n+pub fn ptrcast(val: ValueRef, ty: Type) -> ValueRef {\n     unsafe {\n-        let b = llvm::LLVMConstPointerCast(a, t.ptr_to().to_ref());\n-        assert!(cx.const_globals().borrow_mut().insert(b as int, a).is_none());\n-        b\n+        llvm::LLVMConstPointerCast(val, ty.to_ref())\n     }\n }\n \n@@ -258,7 +256,9 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, e: &ast::Expr)\n                                     match ty.sty {\n                                         ty::ty_vec(unit_ty, Some(len)) => {\n                                             let llunitty = type_of::type_of(cx, unit_ty);\n-                                            let llptr = const_ptrcast(cx, llconst, llunitty);\n+                                            let llptr = ptrcast(llconst, llunitty.ptr_to());\n+                                            assert!(cx.const_globals().borrow_mut()\n+                                                      .insert(llptr as int, llconst).is_none());\n                                             assert_eq!(abi::FAT_PTR_ADDR, 0);\n                                             assert_eq!(abi::FAT_PTR_EXTRA, 1);\n                                             llconst = C_struct(cx, &[\n@@ -523,7 +523,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                 }\n               }\n               (expr::cast_pointer, expr::cast_pointer) => {\n-                llvm::LLVMConstPointerCast(v, llty.to_ref())\n+                ptrcast(v, llty)\n               }\n               (expr::cast_integral, expr::cast_pointer) => {\n                 llvm::LLVMConstIntToPtr(v, llty.to_ref())\n@@ -616,36 +616,38 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                 C_array(llunitty, vs[])\n             }\n           }\n-          ast::ExprPath(ref pth) => {\n-            // Assert that there are no type parameters in this path.\n-            assert!(pth.segments.iter().all(|seg| !seg.parameters.has_types()));\n-\n-            let opt_def = cx.tcx().def_map.borrow().get(&e.id).cloned();\n-            match opt_def {\n-                Some(def::DefFn(def_id, _)) => {\n-                    if !ast_util::is_local(def_id) {\n-                        let ty = csearch::get_type(cx.tcx(), def_id).ty;\n-                        base::trans_external_path(cx, def_id, ty)\n-                    } else {\n-                        assert!(ast_util::is_local(def_id));\n-                        base::get_item_val(cx, def_id.node)\n-                    }\n+          ast::ExprPath(_) => {\n+            let def = cx.tcx().def_map.borrow()[e.id];\n+            match def {\n+                def::DefFn(..) | def::DefStaticMethod(..) | def::DefMethod(..) => {\n+                    expr::trans_def_fn_unadjusted(cx, e, def, &Substs::trans_empty()).val\n                 }\n-                Some(def::DefConst(def_id)) => {\n+                def::DefConst(def_id) => {\n                     get_const_val(cx, def_id)\n                 }\n-                Some(def::DefVariant(enum_did, variant_did, _)) => {\n-                    let ety = ty::expr_ty(cx.tcx(), e);\n-                    let repr = adt::represent_type(cx, ety);\n+                def::DefVariant(enum_did, variant_did, _) => {\n                     let vinfo = ty::enum_variant_with_id(cx.tcx(),\n                                                          enum_did,\n                                                          variant_did);\n-                    adt::trans_const(cx, &*repr, vinfo.disr_val, &[])\n+                    if vinfo.args.len() > 0 {\n+                        // N-ary variant.\n+                        expr::trans_def_fn_unadjusted(cx, e, def, &Substs::trans_empty()).val\n+                    } else {\n+                        // Nullary variant.\n+                        let ety = ty::expr_ty(cx.tcx(), e);\n+                        let repr = adt::represent_type(cx, ety);\n+                        adt::trans_const(cx, &*repr, vinfo.disr_val, &[])\n+                    }\n                 }\n-                Some(def::DefStruct(_)) => {\n+                def::DefStruct(_) => {\n                     let ety = ty::expr_ty(cx.tcx(), e);\n-                    let llty = type_of::type_of(cx, ety);\n-                    C_null(llty)\n+                    if let ty::ty_bare_fn(..) = ety.sty {\n+                        // Tuple struct.\n+                        expr::trans_def_fn_unadjusted(cx, e, def, &Substs::trans_empty()).val\n+                    } else {\n+                        // Unit struct.\n+                        C_null(type_of::type_of(cx, ety))\n+                    }\n                 }\n                 _ => {\n                     cx.sess().span_bug(e.span, \"expected a const, fn, struct, \\"}, {"sha": "68557289d52ce30db9e01a3678f3ce6248f4ce12", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9a90d436f64b004a55368751b64b850d710fad34/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a90d436f64b004a55368751b64b850d710fad34/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=9a90d436f64b004a55368751b64b850d710fad34", "patch": "@@ -853,7 +853,9 @@ fn trans_def<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     match def {\n         def::DefFn(..) | def::DefStaticMethod(..) | def::DefMethod(..) |\n         def::DefStruct(_) | def::DefVariant(..) => {\n-            trans_def_fn_unadjusted(bcx, ref_expr, def)\n+            let datum = trans_def_fn_unadjusted(bcx.ccx(), ref_expr, def,\n+                                                bcx.fcx.param_substs);\n+            DatumBlock::new(bcx, datum.to_expr_datum())\n         }\n         def::DefStatic(did, _) => {\n             // There are two things that may happen here:\n@@ -1250,7 +1252,9 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let variant_info = ty::enum_variant_with_id(bcx.tcx(), tid, vid);\n             if variant_info.args.len() > 0u {\n                 // N-ary variant.\n-                let llfn = callee::trans_fn_ref(bcx, vid, ExprId(ref_expr.id));\n+                let llfn = callee::trans_fn_ref(bcx.ccx(), vid,\n+                                                ExprId(ref_expr.id),\n+                                                bcx.fcx.param_substs).val;\n                 Store(bcx, llfn, lldest);\n                 return bcx;\n             } else {\n@@ -1281,34 +1285,33 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-fn trans_def_fn_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                       ref_expr: &ast::Expr,\n-                                       def: def::Def)\n-                                       -> DatumBlock<'blk, 'tcx, Expr> {\n+pub fn trans_def_fn_unadjusted<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                         ref_expr: &ast::Expr,\n+                                         def: def::Def,\n+                                         param_substs: &subst::Substs<'tcx>)\n+                                         -> Datum<'tcx, Rvalue> {\n     let _icx = push_ctxt(\"trans_def_datum_unadjusted\");\n \n-    let llfn = match def {\n+    match def {\n         def::DefFn(did, _) |\n         def::DefStruct(did) | def::DefVariant(_, did, _) |\n         def::DefStaticMethod(did, def::FromImpl(_)) |\n         def::DefMethod(did, _, def::FromImpl(_)) => {\n-            callee::trans_fn_ref(bcx, did, ExprId(ref_expr.id))\n+            callee::trans_fn_ref(ccx, did, ExprId(ref_expr.id), param_substs)\n         }\n         def::DefStaticMethod(impl_did, def::FromTrait(trait_did)) |\n         def::DefMethod(impl_did, _, def::FromTrait(trait_did)) => {\n-            meth::trans_static_method_callee(bcx, impl_did,\n-                                             trait_did, ref_expr.id)\n+            meth::trans_static_method_callee(ccx, impl_did,\n+                                             trait_did, ref_expr.id,\n+                                             param_substs)\n         }\n         _ => {\n-            bcx.tcx().sess.span_bug(ref_expr.span, format!(\n+            ccx.tcx().sess.span_bug(ref_expr.span, format!(\n                     \"trans_def_fn_unadjusted invoked on: {} for {}\",\n                     def,\n-                    ref_expr.repr(bcx.tcx()))[]);\n+                    ref_expr.repr(ccx.tcx()))[]);\n         }\n-    };\n-\n-    let fn_ty = expr_ty(bcx, ref_expr);\n-    DatumBlock::new(bcx, Datum::new(llfn, fn_ty, RvalueExpr(Rvalue::new(ByValue))))\n+    }\n }\n \n /// Translates a reference to a local variable or argument. This always results in an lvalue datum."}, {"sha": "c049704181354d9c8b1f91323be55e10c73d149f", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a90d436f64b004a55368751b64b850d710fad34/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a90d436f64b004a55368751b64b850d710fad34/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=9a90d436f64b004a55368751b64b850d710fad34", "patch": "@@ -26,6 +26,7 @@ use trans::build::*;\n use trans::callee;\n use trans::cleanup;\n use trans::cleanup::CleanupMethods;\n+use trans::consts;\n use trans::common::*;\n use trans::datum;\n use trans::debuginfo;\n@@ -577,9 +578,7 @@ pub fn emit_tydescs(ccx: &CrateContext) {\n         // before being put into the tydesc because we only have a singleton\n         // tydesc type. Then we'll recast each function to its real type when\n         // calling it.\n-        let drop_glue = unsafe {\n-            llvm::LLVMConstPointerCast(get_drop_glue(ccx, ti.ty), glue_fn_ty.to_ref())\n-        };\n+        let drop_glue = consts::ptrcast(get_drop_glue(ccx, ti.ty), glue_fn_ty);\n         ccx.stats().n_real_glues.set(ccx.stats().n_real_glues.get() + 1);\n \n         let tydesc = C_named_struct(ccx.tydesc_type(),"}, {"sha": "c13516134c20c7988a940899f429e17a95a44189", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 37, "deletions": 35, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/9a90d436f64b004a55368751b64b850d710fad34/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a90d436f64b004a55368751b64b850d710fad34/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=9a90d436f64b004a55368751b64b850d710fad34", "patch": "@@ -122,9 +122,10 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ty::MethodStaticUnboxedClosure(did) => {\n             Callee {\n                 bcx: bcx,\n-                data: Fn(callee::trans_fn_ref(bcx,\n+                data: Fn(callee::trans_fn_ref(bcx.ccx(),\n                                               did,\n-                                              MethodCallKey(method_call))),\n+                                              MethodCallKey(method_call),\n+                                              bcx.fcx.param_substs).val),\n             }\n         }\n \n@@ -166,46 +167,47 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-pub fn trans_static_method_callee(bcx: Block,\n-                                  method_id: ast::DefId,\n-                                  trait_id: ast::DefId,\n-                                  expr_id: ast::NodeId)\n-                                  -> ValueRef\n+pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                            method_id: ast::DefId,\n+                                            trait_id: ast::DefId,\n+                                            expr_id: ast::NodeId,\n+                                            param_substs: &subst::Substs<'tcx>)\n+                                            -> Datum<'tcx, Rvalue>\n {\n     let _icx = push_ctxt(\"meth::trans_static_method_callee\");\n-    let ccx = bcx.ccx();\n+    let tcx = ccx.tcx();\n \n     debug!(\"trans_static_method_callee(method_id={}, trait_id={}, \\\n             expr_id={})\",\n            method_id,\n-           ty::item_path_str(bcx.tcx(), trait_id),\n+           ty::item_path_str(tcx, trait_id),\n            expr_id);\n \n     let mname = if method_id.krate == ast::LOCAL_CRATE {\n-        match bcx.tcx().map.get(method_id.node) {\n+        match tcx.map.get(method_id.node) {\n             ast_map::NodeTraitItem(method) => {\n                 let ident = match *method {\n                     ast::RequiredMethod(ref m) => m.ident,\n                     ast::ProvidedMethod(ref m) => m.pe_ident(),\n                     ast::TypeTraitItem(_) => {\n-                        bcx.tcx().sess.bug(\"trans_static_method_callee() on \\\n-                                            an associated type?!\")\n+                        tcx.sess.bug(\"trans_static_method_callee() on \\\n+                                      an associated type?!\")\n                     }\n                 };\n                 ident.name\n             }\n             _ => panic!(\"callee is not a trait method\")\n         }\n     } else {\n-        csearch::get_item_path(bcx.tcx(), method_id).last().unwrap().name()\n+        csearch::get_item_path(tcx, method_id).last().unwrap().name()\n     };\n     debug!(\"trans_static_method_callee: method_id={}, expr_id={}, \\\n             name={}\", method_id, expr_id, token::get_name(mname));\n \n     // Find the substitutions for the fn itself. This includes\n     // type parameters that belong to the trait but also some that\n     // belong to the method:\n-    let rcvr_substs = node_id_substs(bcx, ExprId(expr_id));\n+    let rcvr_substs = node_id_substs(ccx, ExprId(expr_id), param_substs);\n     let subst::SeparateVecsPerParamSpace {\n         types: rcvr_type,\n         selfs: rcvr_self,\n@@ -238,11 +240,11 @@ pub fn trans_static_method_callee(bcx: Block,\n         Substs::erased(VecPerParamSpace::new(rcvr_type,\n                                              rcvr_self,\n                                              Vec::new()));\n-    let trait_substs = bcx.tcx().mk_substs(trait_substs);\n-    debug!(\"trait_substs={}\", trait_substs.repr(bcx.tcx()));\n+    let trait_substs = tcx.mk_substs(trait_substs);\n+    debug!(\"trait_substs={}\", trait_substs.repr(tcx));\n     let trait_ref = ty::Binder(Rc::new(ty::TraitRef { def_id: trait_id,\n                                                       substs: trait_substs }));\n-    let vtbl = fulfill_obligation(bcx.ccx(),\n+    let vtbl = fulfill_obligation(ccx,\n                                   DUMMY_SP,\n                                   trait_ref);\n \n@@ -282,17 +284,13 @@ pub fn trans_static_method_callee(bcx: Block,\n                                                      rcvr_method));\n \n             let mth_id = method_with_name(ccx, impl_did, mname);\n-            let llfn = trans_fn_ref_with_substs(bcx, mth_id, ExprId(expr_id),\n-                                                callee_substs);\n-\n-            let callee_ty = node_id_type(bcx, expr_id);\n-            let llty = type_of_fn_from_ty(ccx, callee_ty).ptr_to();\n-            PointerCast(bcx, llfn, llty)\n+            trans_fn_ref_with_substs(ccx, mth_id, ExprId(expr_id),\n+                                     param_substs,\n+                                     callee_substs)\n         }\n         _ => {\n-            bcx.tcx().sess.bug(\n-                format!(\"static call to invalid vtable: {}\",\n-                        vtbl.repr(bcx.tcx()))[]);\n+            tcx.sess.bug(format!(\"static call to invalid vtable: {}\",\n+                                 vtbl.repr(tcx))[]);\n         }\n     }\n }\n@@ -346,20 +344,22 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     bcx, MethodCallKey(method_call), vtable_impl.substs);\n \n             // translate the function\n-            let llfn = trans_fn_ref_with_substs(bcx,\n+            let llfn = trans_fn_ref_with_substs(bcx.ccx(),\n                                                 mth_id,\n                                                 MethodCallKey(method_call),\n-                                                callee_substs);\n+                                                bcx.fcx.param_substs,\n+                                                callee_substs).val;\n \n             Callee { bcx: bcx, data: Fn(llfn) }\n         }\n         traits::VtableUnboxedClosure(closure_def_id, substs) => {\n             // The substitutions should have no type parameters remaining\n             // after passing through fulfill_obligation\n-            let llfn = trans_fn_ref_with_substs(bcx,\n+            let llfn = trans_fn_ref_with_substs(bcx.ccx(),\n                                                 closure_def_id,\n                                                 MethodCallKey(method_call),\n-                                                substs);\n+                                                bcx.fcx.param_substs,\n+                                                substs).val;\n \n             Callee {\n                 bcx: bcx,\n@@ -400,7 +400,7 @@ fn combine_impl_and_methods_tps<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n {\n     let ccx = bcx.ccx();\n \n-    let node_substs = node_id_substs(bcx, node);\n+    let node_substs = node_id_substs(ccx, node, bcx.fcx.param_substs);\n \n     debug!(\"rcvr_substs={}\", rcvr_substs.repr(ccx.tcx()));\n     debug!(\"node_substs={}\", node_substs.repr(ccx.tcx()));\n@@ -684,10 +684,11 @@ pub fn get_vtable<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n             traits::VtableUnboxedClosure(closure_def_id, substs) => {\n                 let llfn = trans_fn_ref_with_substs(\n-                    bcx,\n+                    bcx.ccx(),\n                     closure_def_id,\n                     ExprId(0),\n-                    substs.clone());\n+                    bcx.fcx.param_substs,\n+                    substs.clone()).val;\n \n                 (vec!(llfn)).into_iter()\n             }\n@@ -788,10 +789,11 @@ fn emit_vtable_methods<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     Some(C_null(Type::nil(ccx).ptr_to())).into_iter()\n                 } else {\n                     let fn_ref = trans_fn_ref_with_substs(\n-                        bcx,\n+                        ccx,\n                         m_id,\n                         ExprId(0),\n-                        substs.clone());\n+                        bcx.fcx.param_substs,\n+                        substs.clone()).val;\n \n                     // currently, at least, by-value self is not object safe\n                     assert!(m.explicit_self != ty::ByValueExplicitSelfCategory);"}, {"sha": "e6db462a342da21d05c3c731077441b1da369b2f", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9a90d436f64b004a55368751b64b850d710fad34/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a90d436f64b004a55368751b64b850d710fad34/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=9a90d436f64b004a55368751b64b850d710fad34", "patch": "@@ -38,7 +38,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 fn_id: ast::DefId,\n                                 psubsts: &subst::Substs<'tcx>,\n                                 ref_id: Option<ast::NodeId>)\n-    -> (ValueRef, bool) {\n+    -> (ValueRef, Ty<'tcx>, bool) {\n     debug!(\"monomorphic_fn(\\\n             fn_id={}, \\\n             real_substs={}, \\\n@@ -58,11 +58,14 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         params: psubsts.types.clone()\n     };\n \n+    let item_ty = ty::lookup_item_type(ccx.tcx(), fn_id).ty;\n+    let mono_ty = item_ty.subst(ccx.tcx(), psubsts);\n+\n     match ccx.monomorphized().borrow().get(&hash_id) {\n         Some(&val) => {\n             debug!(\"leaving monomorphic fn {}\",\n             ty::item_path_str(ccx.tcx(), fn_id));\n-            return (val, false);\n+            return (val, mono_ty, false);\n         }\n         None => ()\n     }\n@@ -75,8 +78,6 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            psubsts.repr(ccx.tcx()),\n            hash_id);\n \n-    let tpt = ty::lookup_item_type(ccx.tcx(), fn_id);\n-    let llitem_ty = tpt.ty;\n \n     let map_node = session::expect(\n         ccx.sess(),\n@@ -91,13 +92,12 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     if let ast_map::NodeForeignItem(_) = map_node {\n         if ccx.tcx().map.get_foreign_abi(fn_id.node) != abi::RustIntrinsic {\n             // Foreign externs don't have to be monomorphized.\n-            return (get_item_val(ccx, fn_id.node), true);\n+            return (get_item_val(ccx, fn_id.node), mono_ty, true);\n         }\n     }\n \n-    debug!(\"monomorphic_fn about to subst into {}\", llitem_ty.repr(ccx.tcx()));\n+    debug!(\"monomorphic_fn about to subst into {}\", item_ty.repr(ccx.tcx()));\n \n-    let mono_ty = llitem_ty.subst(ccx.tcx(), psubsts);\n     debug!(\"mono_ty = {} (post-substitution)\", mono_ty.repr(ccx.tcx()));\n \n     let mono_ty = normalize_associated_type(ccx.tcx(), &mono_ty);\n@@ -283,7 +283,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     ccx.monomorphizing().borrow_mut().insert(fn_id, depth);\n \n     debug!(\"leaving monomorphic fn {}\", ty::item_path_str(ccx.tcx(), fn_id));\n-    (lldecl, true)\n+    (lldecl, mono_ty, true)\n }\n \n #[derive(PartialEq, Eq, Hash, Show)]"}, {"sha": "de71a1c2217ec9597aa848f9d1944405157e96c6", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9a90d436f64b004a55368751b64b850d710fad34/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a90d436f64b004a55368751b64b850d710fad34/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=9a90d436f64b004a55368751b64b850d710fad34", "patch": "@@ -19,6 +19,7 @@ use trans::build::*;\n use trans::cleanup;\n use trans::cleanup::CleanupMethods;\n use trans::common::*;\n+use trans::consts;\n use trans::datum::*;\n use trans::expr::{Dest, Ignore, SaveIn};\n use trans::expr;\n@@ -213,15 +214,13 @@ pub fn trans_lit_str<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     match dest {\n         Ignore => bcx,\n         SaveIn(lldest) => {\n-            unsafe {\n-                let bytes = str_lit.get().len();\n-                let llbytes = C_uint(bcx.ccx(), bytes);\n-                let llcstr = C_cstr(bcx.ccx(), str_lit, false);\n-                let llcstr = llvm::LLVMConstPointerCast(llcstr, Type::i8p(bcx.ccx()).to_ref());\n-                Store(bcx, llcstr, GEPi(bcx, lldest, &[0u, abi::FAT_PTR_ADDR]));\n-                Store(bcx, llbytes, GEPi(bcx, lldest, &[0u, abi::FAT_PTR_EXTRA]));\n-                bcx\n-            }\n+            let bytes = str_lit.get().len();\n+            let llbytes = C_uint(bcx.ccx(), bytes);\n+            let llcstr = C_cstr(bcx.ccx(), str_lit, false);\n+            let llcstr = consts::ptrcast(llcstr, Type::i8p(bcx.ccx()));\n+            Store(bcx, llcstr, GEPi(bcx, lldest, &[0u, abi::FAT_PTR_ADDR]));\n+            Store(bcx, llbytes, GEPi(bcx, lldest, &[0u, abi::FAT_PTR_EXTRA]));\n+            bcx\n         }\n     }\n }"}, {"sha": "25c1464adfaf436e6ef9a0de8c5a95cf8a916586", "filename": "src/test/run-pass/const-polymorphic-paths.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/9a90d436f64b004a55368751b64b850d710fad34/src%2Ftest%2Frun-pass%2Fconst-polymorphic-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a90d436f64b004a55368751b64b850d710fad34/src%2Ftest%2Frun-pass%2Fconst-polymorphic-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-polymorphic-paths.rs?ref=9a90d436f64b004a55368751b64b850d710fad34", "patch": "@@ -0,0 +1,84 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(macro_rules)]\n+\n+use std::collections::Bitv;\n+use std::default::Default;\n+use std::iter::FromIterator;\n+use std::option::IntoIter as OptionIter;\n+use std::rand::Rand;\n+use std::rand::XorShiftRng as DummyRng;\n+// FIXME the glob std::prelude::*; import of Vec is missing non-static inherent methods.\n+use std::vec::Vec;\n+\n+#[derive(PartialEq, Eq)]\n+struct Newt<T>(T);\n+\n+fn id<T>(x: T) -> T { x }\n+fn eq<T: Eq>(a: T, b: T) -> bool { a == b }\n+fn u8_as_i8(x: u8) -> i8 { x as i8 }\n+fn odd(x: uint) -> bool { x % 2 == 1 }\n+fn dummy_rng() -> DummyRng { DummyRng::new_unseeded() }\n+\n+macro_rules! tests {\n+    ($($expr:expr: $ty:ty /($($test:expr),*);)+) => (pub fn main() {$({\n+        const C: $ty = $expr;\n+        static S: $ty = $expr;\n+        assert!(eq(C($($test),*), $expr($($test),*)));\n+        assert!(eq(S($($test),*), $expr($($test),*)));\n+        assert!(eq(C($($test),*), S($($test),*)));\n+    })+})\n+}\n+\n+tests! {\n+    // Free function.\n+    id: fn(int) -> int /(5);\n+    id::<int>: fn(int) -> int /(5);\n+\n+    // Enum variant constructor.\n+    Some: fn(int) -> Option<int> /(5);\n+    Some::<int>: fn(int) -> Option<int> /(5);\n+\n+    // Tuple struct constructor.\n+    Newt: fn(int) -> Newt<int> /(5);\n+    Newt::<int>: fn(int) -> Newt<int> /(5);\n+\n+    // Inherent static methods.\n+    Vec::new: fn() -> Vec<()> /();\n+    Vec::<()>::new: fn() -> Vec<()> /();\n+    Vec::with_capacity: fn(uint) -> Vec<()> /(5);\n+    Vec::<()>::with_capacity: fn(uint) -> Vec<()> /(5);\n+    Bitv::from_fn: fn(uint, fn(uint) -> bool) -> Bitv /(5, odd);\n+    Bitv::from_fn::<fn(uint) -> bool>: fn(uint, fn(uint) -> bool) -> Bitv /(5, odd);\n+\n+    // Inherent non-static method.\n+    Vec::map_in_place: fn(Vec<u8>, fn(u8) -> i8) -> Vec<i8>\n+        /(vec![b'f', b'o', b'o'], u8_as_i8);\n+    Vec::map_in_place::<i8, fn(u8) -> i8>: fn(Vec<u8>, fn(u8) -> i8) -> Vec<i8>\n+        /(vec![b'f', b'o', b'o'], u8_as_i8);\n+    // FIXME these break with \"type parameter might not appear here pointing at `<u8>`.\n+    // Vec::<u8>::map_in_place: fn(Vec<u8>, fn(u8) -> i8) -> Vec<i8>\n+    //     /(vec![b'f', b'o', b'o'], u8_as_i8);\n+    // Vec::<u8>::map_in_place::<i8, fn(u8) -> i8>: fn(Vec<u8>, fn(u8) -> i8) -> Vec<i8>\n+    //     /(vec![b'f', b'o', b'o'], u8_as_i8);\n+\n+    // Trait static methods.\n+    // FIXME qualified path expressions aka UFCS i.e. <T as Trait>::method.\n+    Default::default: fn() -> int /();\n+    Rand::rand: fn(&mut DummyRng) -> int /(&mut dummy_rng());\n+    Rand::rand::<DummyRng>: fn(&mut DummyRng) -> int /(&mut dummy_rng());\n+\n+    // Trait non-static methods.\n+    Clone::clone: fn(&int) -> int /(&5);\n+    FromIterator::from_iter: fn(OptionIter<int>) -> Vec<int> /(Some(5).into_iter());\n+    FromIterator::from_iter::<OptionIter<int>>: fn(OptionIter<int>) -> Vec<int>\n+        /(Some(5).into_iter());\n+}"}]}