{"sha": "8a19b234c7315af478786801eb53a984a7059e14", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhMTliMjM0YzczMTVhZjQ3ODc4NjgwMWViNTNhOTg0YTcwNTllMTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-15T15:01:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-15T15:01:05Z"}, "message": "Auto merge of #28413 - arielb1:deduplication, r=eddyb\n\nclean a few things discovered during my split_ty work\r\n\r\nr? @eddyb", "tree": {"sha": "3fbb770abac3c4a55a69a9c2fb25b023ae7d6bce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3fbb770abac3c4a55a69a9c2fb25b023ae7d6bce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a19b234c7315af478786801eb53a984a7059e14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a19b234c7315af478786801eb53a984a7059e14", "html_url": "https://github.com/rust-lang/rust/commit/8a19b234c7315af478786801eb53a984a7059e14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a19b234c7315af478786801eb53a984a7059e14/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3887ca27f16771b960b57e1c80997b2482ba5b76", "url": "https://api.github.com/repos/rust-lang/rust/commits/3887ca27f16771b960b57e1c80997b2482ba5b76", "html_url": "https://github.com/rust-lang/rust/commit/3887ca27f16771b960b57e1c80997b2482ba5b76"}, {"sha": "5e4704f6ee147e198f99bc565bb608684b9ae66b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e4704f6ee147e198f99bc565bb608684b9ae66b", "html_url": "https://github.com/rust-lang/rust/commit/5e4704f6ee147e198f99bc565bb608684b9ae66b"}], "stats": {"total": 426, "additions": 140, "deletions": 286}, "files": [{"sha": "917727907ba885651b4dd28b6b60ba55b4f5173d", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 6, "deletions": 71, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/8a19b234c7315af478786801eb53a984a7059e14/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a19b234c7315af478786801eb53a984a7059e14/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=8a19b234c7315af478786801eb53a984a7059e14", "patch": "@@ -503,7 +503,7 @@ pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n {\n     debug!(\"normalize_associated_type(t={:?})\", value);\n \n-    let value = erase_regions(tcx, value);\n+    let value = tcx.erase_regions(value);\n \n     if !value.has_projection_types() {\n         return value;\n@@ -525,17 +525,15 @@ pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n         fulfill_cx.register_predicate_obligation(&infcx, obligation);\n     }\n \n-    let result = drain_fulfillment_cx_or_panic(DUMMY_SP, &infcx, &mut fulfill_cx, &result);\n-\n-    result\n+    drain_fulfillment_cx_or_panic(DUMMY_SP, &infcx, &mut fulfill_cx, &result)\n }\n \n pub fn drain_fulfillment_cx_or_panic<'a,'tcx,T>(span: Span,\n                                                 infcx: &InferCtxt<'a,'tcx>,\n                                                 fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n                                                 result: &T)\n                                                 -> T\n-    where T : TypeFoldable<'tcx>\n+    where T : TypeFoldable<'tcx> + HasTypeFlags\n {\n     match drain_fulfillment_cx(infcx, fulfill_cx, result) {\n         Ok(v) => v,\n@@ -559,7 +557,7 @@ pub fn drain_fulfillment_cx<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n                                        fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n                                        result: &T)\n                                        -> Result<T,Vec<traits::FulfillmentError<'tcx>>>\n-    where T : TypeFoldable<'tcx>\n+    where T : TypeFoldable<'tcx> + HasTypeFlags\n {\n     debug!(\"drain_fulfillment_cx(result={:?})\",\n            result);\n@@ -574,71 +572,8 @@ pub fn drain_fulfillment_cx<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n         }\n     }\n \n-    // Use freshen to simultaneously replace all type variables with\n-    // their bindings and replace all regions with 'static.  This is\n-    // sort of overkill because we do not expect there to be any\n-    // unbound type variables, hence no `TyFresh` types should ever be\n-    // inserted.\n-    Ok(result.fold_with(&mut infcx.freshener()))\n-}\n-\n-/// Returns an equivalent value with all free regions removed (note\n-/// that late-bound regions remain, because they are important for\n-/// subtyping, but they are anonymized and normalized as well). This\n-/// is a stronger, caching version of `ty::fold::erase_regions`.\n-pub fn erase_regions<'tcx,T>(cx: &ty::ctxt<'tcx>, value: &T) -> T\n-    where T : TypeFoldable<'tcx>\n-{\n-    let value1 = value.fold_with(&mut RegionEraser(cx));\n-    debug!(\"erase_regions({:?}) = {:?}\",\n-           value, value1);\n-    return value1;\n-\n-    struct RegionEraser<'a, 'tcx: 'a>(&'a ty::ctxt<'tcx>);\n-\n-    impl<'a, 'tcx> TypeFolder<'tcx> for RegionEraser<'a, 'tcx> {\n-        fn tcx(&self) -> &ty::ctxt<'tcx> { self.0 }\n-\n-        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-            match self.tcx().normalized_cache.borrow().get(&ty).cloned() {\n-                None => {}\n-                Some(u) => return u\n-            }\n-\n-            let t_norm = ty::fold::super_fold_ty(self, ty);\n-            self.tcx().normalized_cache.borrow_mut().insert(ty, t_norm);\n-            return t_norm;\n-        }\n-\n-        fn fold_binder<T>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T>\n-            where T : TypeFoldable<'tcx>\n-        {\n-            let u = self.tcx().anonymize_late_bound_regions(t);\n-            ty::fold::super_fold_binder(self, &u)\n-        }\n-\n-        fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n-            // because late-bound regions affect subtyping, we can't\n-            // erase the bound/free distinction, but we can replace\n-            // all free regions with 'static.\n-            //\n-            // Note that we *CAN* replace early-bound regions -- the\n-            // type system never \"sees\" those, they get substituted\n-            // away. In trans, they will always be erased to 'static\n-            // whenever a substitution occurs.\n-            match r {\n-                ty::ReLateBound(..) => r,\n-                _ => ty::ReStatic\n-            }\n-        }\n-\n-        fn fold_substs(&mut self,\n-                       substs: &subst::Substs<'tcx>)\n-                       -> subst::Substs<'tcx> {\n-            subst::Substs { regions: subst::ErasedRegions,\n-                            types: substs.types.fold_with(self) }\n-        }\n-    }\n+    let result = infcx.resolve_type_vars_if_possible(result);\n+    Ok(infcx.tcx.erase_regions(&result))\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {"}, {"sha": "8ce211120019d60c053b1425bc825c95897125cb", "filename": "src/librustc/middle/traits/structural_impls.rs", "status": "modified", "additions": 55, "deletions": 9, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/8a19b234c7315af478786801eb53a984a7059e14/src%2Flibrustc%2Fmiddle%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a19b234c7315af478786801eb53a984a7059e14/src%2Flibrustc%2Fmiddle%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fstructural_impls.rs?ref=8a19b234c7315af478786801eb53a984a7059e14", "patch": "@@ -150,6 +150,52 @@ impl<'tcx, T: HasTypeFlags> HasTypeFlags for Normalized<'tcx, T> {\n     }\n }\n \n+impl<'tcx, N: HasTypeFlags> HasTypeFlags for traits::VtableImplData<'tcx, N> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.substs.has_type_flags(flags) ||\n+            self.nested.has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx, N: HasTypeFlags> HasTypeFlags for traits::VtableClosureData<'tcx, N> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.substs.has_type_flags(flags) ||\n+            self.nested.has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx, N: HasTypeFlags> HasTypeFlags for traits::VtableDefaultImplData<N> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.nested.has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx, N: HasTypeFlags> HasTypeFlags for traits::VtableBuiltinData<N> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.nested.has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx> HasTypeFlags for traits::VtableObjectData<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.upcast_trait_ref.has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx, N: HasTypeFlags> HasTypeFlags for traits::Vtable<'tcx, N> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        match *self {\n+            traits::VtableImpl(ref v) => v.has_type_flags(flags),\n+            traits::VtableDefaultImpl(ref t) => t.has_type_flags(flags),\n+            traits::VtableClosure(ref d) => d.has_type_flags(flags),\n+            traits::VtableFnPointer(ref d) => d.has_type_flags(flags),\n+            traits::VtableParam(ref n) => n.has_type_flags(flags),\n+            traits::VtableBuiltin(ref d) => d.has_type_flags(flags),\n+            traits::VtableObject(ref d) => d.has_type_flags(flags)\n+        }\n+    }\n+}\n+\n impl<'tcx, O: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Obligation<'tcx, O>\n {\n     fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::Obligation<'tcx, O> {\n@@ -198,6 +244,15 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableBuiltinDa\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for traits::VtableObjectData<'tcx> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableObjectData<'tcx> {\n+        traits::VtableObjectData {\n+            upcast_trait_ref: self.upcast_trait_ref.fold_with(folder),\n+            vtable_base: self.vtable_base\n+        }\n+    }\n+}\n+\n impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N> {\n     fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::Vtable<'tcx, N> {\n         match *self {\n@@ -216,15 +271,6 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N>\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for traits::VtableObjectData<'tcx> {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableObjectData<'tcx> {\n-        traits::VtableObjectData {\n-            upcast_trait_ref: self.upcast_trait_ref.fold_with(folder),\n-            vtable_base: self.vtable_base\n-        }\n-    }\n-}\n-\n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Normalized<'tcx, T> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Normalized<'tcx, T> {\n         Normalized {"}, {"sha": "605e78e92811514357f2e9597eae9dccd317c96f", "filename": "src/librustc/middle/ty/fold.rs", "status": "modified", "additions": 52, "deletions": 28, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/8a19b234c7315af478786801eb53a984a7059e14/src%2Flibrustc%2Fmiddle%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a19b234c7315af478786801eb53a984a7059e14/src%2Flibrustc%2Fmiddle%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Ffold.rs?ref=8a19b234c7315af478786801eb53a984a7059e14", "patch": "@@ -37,7 +37,7 @@\n use middle::region;\n use middle::subst;\n use middle::ty::adjustment;\n-use middle::ty::{self, Binder, Ty, HasTypeFlags, RegionEscape};\n+use middle::ty::{self, Binder, Ty, RegionEscape};\n \n use std::fmt;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n@@ -588,39 +588,63 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionReplacer<'a, 'tcx>\n \n ///////////////////////////////////////////////////////////////////////////\n // Region eraser\n-//\n-// Replaces all free regions with 'static. Useful in contexts, such as\n-// method probing, where precise region relationships are not\n-// important. Note that in trans you should use\n-// `common::erase_regions` instead.\n \n-pub struct RegionEraser<'a, 'tcx: 'a> {\n-    tcx: &'a ty::ctxt<'tcx>,\n-}\n+impl<'tcx> ty::ctxt<'tcx> {\n+    /// Returns an equivalent value with all free regions removed (note\n+    /// that late-bound regions remain, because they are important for\n+    /// subtyping, but they are anonymized and normalized as well)..\n+    pub fn erase_regions<T>(&self, value: &T) -> T\n+        where T : TypeFoldable<'tcx>\n+    {\n+        let value1 = value.fold_with(&mut RegionEraser(self));\n+        debug!(\"erase_regions({:?}) = {:?}\",\n+               value, value1);\n+        return value1;\n \n-pub fn erase_regions<'tcx, T: TypeFoldable<'tcx>>(tcx: &ty::ctxt<'tcx>, t: T) -> T {\n-    let mut eraser = RegionEraser { tcx: tcx };\n-    t.fold_with(&mut eraser)\n-}\n+        struct RegionEraser<'a, 'tcx: 'a>(&'a ty::ctxt<'tcx>);\n \n-impl<'a, 'tcx> TypeFolder<'tcx> for RegionEraser<'a, 'tcx> {\n-    fn tcx(&self) -> &ty::ctxt<'tcx> { self.tcx }\n+        impl<'a, 'tcx> TypeFolder<'tcx> for RegionEraser<'a, 'tcx> {\n+            fn tcx(&self) -> &ty::ctxt<'tcx> { self.0 }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !t.has_erasable_regions() {\n-            return t;\n-        }\n+            fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+                match self.tcx().normalized_cache.borrow().get(&ty).cloned() {\n+                    None => {}\n+                    Some(u) => return u\n+                }\n \n-        super_fold_ty(self, t)\n-    }\n+                let t_norm = ty::fold::super_fold_ty(self, ty);\n+                self.tcx().normalized_cache.borrow_mut().insert(ty, t_norm);\n+                return t_norm;\n+            }\n \n-    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n-        // because whether or not a region is bound affects subtyping,\n-        // we can't erase the bound/free distinction, but we can\n-        // replace all free regions with 'static\n-        match r {\n-            ty::ReLateBound(..) | ty::ReEarlyBound(..) => r,\n-            _ => ty::ReStatic\n+            fn fold_binder<T>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T>\n+                where T : TypeFoldable<'tcx>\n+            {\n+                let u = self.tcx().anonymize_late_bound_regions(t);\n+                ty::fold::super_fold_binder(self, &u)\n+            }\n+\n+            fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+                // because late-bound regions affect subtyping, we can't\n+                // erase the bound/free distinction, but we can replace\n+                // all free regions with 'static.\n+                //\n+                // Note that we *CAN* replace early-bound regions -- the\n+                // type system never \"sees\" those, they get substituted\n+                // away. In trans, they will always be erased to 'static\n+                // whenever a substitution occurs.\n+                match r {\n+                    ty::ReLateBound(..) => r,\n+                    _ => ty::ReStatic\n+                }\n+            }\n+\n+            fn fold_substs(&mut self,\n+                           substs: &subst::Substs<'tcx>)\n+                           -> subst::Substs<'tcx> {\n+                subst::Substs { regions: subst::ErasedRegions,\n+                                types: substs.types.fold_with(self) }\n+            }\n         }\n     }\n }"}, {"sha": "a8adb3886442442093073996d76d26d4adf32c96", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8a19b234c7315af478786801eb53a984a7059e14/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a19b234c7315af478786801eb53a984a7059e14/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=8a19b234c7315af478786801eb53a984a7059e14", "patch": "@@ -979,18 +979,6 @@ impl<'tcx> Predicate<'tcx> {\n         vec.into_iter()\n     }\n \n-    pub fn has_escaping_regions(&self) -> bool {\n-        match *self {\n-            Predicate::Trait(ref trait_ref) => trait_ref.has_escaping_regions(),\n-            Predicate::Equate(ref p) => p.has_escaping_regions(),\n-            Predicate::RegionOutlives(ref p) => p.has_escaping_regions(),\n-            Predicate::TypeOutlives(ref p) => p.has_escaping_regions(),\n-            Predicate::Projection(ref p) => p.has_escaping_regions(),\n-            Predicate::WellFormed(p) => p.has_escaping_regions(),\n-            Predicate::ObjectSafe(_trait_def_id) => false,\n-        }\n-    }\n-\n     pub fn to_opt_poly_trait_ref(&self) -> Option<PolyTraitRef<'tcx>> {\n         match *self {\n             Predicate::Trait(ref t) => {\n@@ -1037,10 +1025,6 @@ impl<'tcx> InstantiatedPredicates<'tcx> {\n         InstantiatedPredicates { predicates: VecPerParamSpace::empty() }\n     }\n \n-    pub fn has_escaping_regions(&self) -> bool {\n-        self.predicates.any(|p| p.has_escaping_regions())\n-    }\n-\n     pub fn is_empty(&self) -> bool {\n         self.predicates.is_empty()\n     }"}, {"sha": "4ed87e673d99682f3efd3ea72754492ea6dc8da8", "filename": "src/librustc/middle/ty/structural_impls.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8a19b234c7315af478786801eb53a984a7059e14/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a19b234c7315af478786801eb53a984a7059e14/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs?ref=8a19b234c7315af478786801eb53a984a7059e14", "patch": "@@ -45,6 +45,12 @@ impl<'tcx> RegionEscape for ty::ExistentialBounds<'tcx> {\n     }\n }\n \n+impl<'tcx> RegionEscape for ty::InstantiatedPredicates<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.predicates.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n impl<'tcx> RegionEscape for subst::Substs<'tcx> {\n     fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n         self.types.has_regions_escaping_depth(depth) ||\n@@ -179,6 +185,13 @@ impl<'tcx> RegionEscape for ty::ProjectionTy<'tcx> {\n         self.trait_ref.has_regions_escaping_depth(depth)\n     }\n }\n+\n+impl HasTypeFlags for () {\n+    fn has_type_flags(&self, _flags: TypeFlags) -> bool {\n+        false\n+    }\n+}\n+\n impl<'tcx,T:HasTypeFlags> HasTypeFlags for Vec<T> {\n     fn has_type_flags(&self, flags: TypeFlags) -> bool {\n         self[..].has_type_flags(flags)"}, {"sha": "124f50d660329bddae84f400fbc1a18a0b458fae", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a19b234c7315af478786801eb53a984a7059e14/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a19b234c7315af478786801eb53a984a7059e14/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=8a19b234c7315af478786801eb53a984a7059e14", "patch": "@@ -24,6 +24,7 @@ use session;\n use llvm::{self, ValueRef, get_params};\n use middle::def;\n use middle::def_id::{DefId, LOCAL_CRATE};\n+use middle::infer::normalize_associated_type;\n use middle::subst;\n use middle::subst::{Subst, Substs};\n use rustc::front::map as hir_map;\n@@ -260,7 +261,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     let tcx = ccx.tcx();\n \n     // Normalize the type for better caching.\n-    let bare_fn_ty = common::erase_regions(tcx, &bare_fn_ty);\n+    let bare_fn_ty = tcx.erase_regions(&bare_fn_ty);\n \n     // If this is an impl of `Fn` or `FnMut` trait, the receiver is `&self`.\n     let is_by_ref = match closure_kind {\n@@ -521,7 +522,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n \n     // Type scheme of the function item (may have type params)\n     let fn_type_scheme = tcx.lookup_item_type(def_id);\n-    let fn_type = monomorphize::normalize_associated_type(tcx, &fn_type_scheme.ty);\n+    let fn_type = normalize_associated_type(tcx, &fn_type_scheme.ty);\n \n     // Find the actual function pointer.\n     let mut val = {"}, {"sha": "dc9ea62e9d11aedfd520cfb6e5b487b44e55cde8", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a19b234c7315af478786801eb53a984a7059e14/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a19b234c7315af478786801eb53a984a7059e14/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=8a19b234c7315af478786801eb53a984a7059e14", "patch": "@@ -135,7 +135,7 @@ pub fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                    -> ValueRef {\n     // Normalize type so differences in regions and typedefs don't cause\n     // duplicate declarations\n-    let substs = erase_regions(ccx.tcx(), substs);\n+    let substs = ccx.tcx().erase_regions(substs);\n     let mono_id = MonoId {\n         def: closure_id,\n         params: &substs.func_substs.types"}, {"sha": "ec34d0dd5925782f23ce2a8a47ebf37dadc84346", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 4, "deletions": 115, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/8a19b234c7315af478786801eb53a984a7059e14/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a19b234c7315af478786801eb53a984a7059e14/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=8a19b234c7315af478786801eb53a984a7059e14", "patch": "@@ -47,7 +47,6 @@ use arena::TypedArena;\n use libc::{c_uint, c_char};\n use std::ffi::CString;\n use std::cell::{Cell, RefCell};\n-use std::result::Result as StdResult;\n use std::vec::Vec;\n use syntax::ast;\n use syntax::codemap::{DUMMY_SP, Span};\n@@ -56,65 +55,6 @@ use syntax::parse::token;\n \n pub use trans::context::CrateContext;\n \n-/// Returns an equivalent value with all free regions removed (note\n-/// that late-bound regions remain, because they are important for\n-/// subtyping, but they are anonymized and normalized as well). This\n-/// is a stronger, caching version of `ty::fold::erase_regions`.\n-pub fn erase_regions<'tcx,T>(cx: &ty::ctxt<'tcx>, value: &T) -> T\n-    where T : TypeFoldable<'tcx>\n-{\n-    let value1 = value.fold_with(&mut RegionEraser(cx));\n-    debug!(\"erase_regions({:?}) = {:?}\",\n-           value, value1);\n-    return value1;\n-\n-    struct RegionEraser<'a, 'tcx: 'a>(&'a ty::ctxt<'tcx>);\n-\n-    impl<'a, 'tcx> TypeFolder<'tcx> for RegionEraser<'a, 'tcx> {\n-        fn tcx(&self) -> &ty::ctxt<'tcx> { self.0 }\n-\n-        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-            match self.tcx().normalized_cache.borrow().get(&ty).cloned() {\n-                None => {}\n-                Some(u) => return u\n-            }\n-\n-            let t_norm = ty::fold::super_fold_ty(self, ty);\n-            self.tcx().normalized_cache.borrow_mut().insert(ty, t_norm);\n-            return t_norm;\n-        }\n-\n-        fn fold_binder<T>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T>\n-            where T : TypeFoldable<'tcx>\n-        {\n-            let u = self.tcx().anonymize_late_bound_regions(t);\n-            ty::fold::super_fold_binder(self, &u)\n-        }\n-\n-        fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n-            // because late-bound regions affect subtyping, we can't\n-            // erase the bound/free distinction, but we can replace\n-            // all free regions with 'static.\n-            //\n-            // Note that we *CAN* replace early-bound regions -- the\n-            // type system never \"sees\" those, they get substituted\n-            // away. In trans, they will always be erased to 'static\n-            // whenever a substitution occurs.\n-            match r {\n-                ty::ReLateBound(..) => r,\n-                _ => ty::ReStatic\n-            }\n-        }\n-\n-        fn fold_substs(&mut self,\n-                       substs: &subst::Substs<'tcx>)\n-                       -> subst::Substs<'tcx> {\n-            subst::Substs { regions: subst::ErasedRegions,\n-                            types: substs.types.fold_with(self) }\n-        }\n-    }\n-}\n-\n /// Is the type's representation size known at compile time?\n pub fn type_is_sized<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     ty.is_sized(&tcx.empty_parameter_environment(), DUMMY_SP)\n@@ -1043,7 +983,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let tcx = ccx.tcx();\n \n     // Remove any references to regions; this helps improve caching.\n-    let trait_ref = erase_regions(tcx, &trait_ref);\n+    let trait_ref = tcx.erase_regions(&trait_ref);\n \n     // First check the cache.\n     match ccx.trait_cache().borrow().get(&trait_ref) {\n@@ -1098,8 +1038,8 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let vtable = selection.map(|predicate| {\n         fulfill_cx.register_predicate_obligation(&infcx, predicate);\n     });\n-    let vtable = erase_regions(tcx,\n-        &drain_fulfillment_cx_or_panic(span, &infcx, &mut fulfill_cx, &vtable)\n+    let vtable = infer::drain_fulfillment_cx_or_panic(\n+        span, &infcx, &mut fulfill_cx, &vtable\n     );\n \n     info!(\"Cache miss: {:?} => {:?}\", trait_ref, vtable);\n@@ -1134,59 +1074,8 @@ pub fn normalize_and_test_predicates<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         let obligation = traits::Obligation::new(cause.clone(), predicate);\n         fulfill_cx.register_predicate_obligation(&infcx, obligation);\n     }\n-    drain_fulfillment_cx(&infcx, &mut fulfill_cx, &()).is_ok()\n-}\n-\n-pub fn drain_fulfillment_cx_or_panic<'a,'tcx,T>(span: Span,\n-                                                infcx: &infer::InferCtxt<'a,'tcx>,\n-                                                fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n-                                                result: &T)\n-                                                -> T\n-    where T : TypeFoldable<'tcx>\n-{\n-    match drain_fulfillment_cx(infcx, fulfill_cx, result) {\n-        Ok(v) => v,\n-        Err(errors) => {\n-            infcx.tcx.sess.span_bug(\n-                span,\n-                &format!(\"Encountered errors `{:?}` fulfilling during trans\",\n-                         errors));\n-        }\n-    }\n-}\n-\n-/// Finishes processes any obligations that remain in the fulfillment\n-/// context, and then \"freshens\" and returns `result`. This is\n-/// primarily used during normalization and other cases where\n-/// processing the obligations in `fulfill_cx` may cause type\n-/// inference variables that appear in `result` to be unified, and\n-/// hence we need to process those obligations to get the complete\n-/// picture of the type.\n-pub fn drain_fulfillment_cx<'a,'tcx,T>(infcx: &infer::InferCtxt<'a,'tcx>,\n-                                       fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n-                                       result: &T)\n-                                       -> StdResult<T,Vec<traits::FulfillmentError<'tcx>>>\n-    where T : TypeFoldable<'tcx>\n-{\n-    debug!(\"drain_fulfillment_cx(result={:?})\",\n-           result);\n-\n-    // In principle, we only need to do this so long as `result`\n-    // contains unbound type parameters. It could be a slight\n-    // optimization to stop iterating early.\n-    match fulfill_cx.select_all_or_error(infcx) {\n-        Ok(()) => { }\n-        Err(errors) => {\n-            return Err(errors);\n-        }\n-    }\n \n-    // Use freshen to simultaneously replace all type variables with\n-    // their bindings and replace all regions with 'static.  This is\n-    // sort of overkill because we do not expect there to be any\n-    // unbound type variables, hence no `TyFresh` types should ever be\n-    // inserted.\n-    Ok(result.fold_with(&mut infcx.freshener()))\n+    infer::drain_fulfillment_cx(&infcx, &mut fulfill_cx, &()).is_ok()\n }\n \n // Key used to lookup values supplied for type parameters in an expr."}, {"sha": "dbb1355c9e6123d4c0e68f4624689fadb3d486bf", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8a19b234c7315af478786801eb53a984a7059e14/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a19b234c7315af478786801eb53a984a7059e14/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=8a19b234c7315af478786801eb53a984a7059e14", "patch": "@@ -27,6 +27,7 @@ use llvm::{ModuleRef, ContextRef, ValueRef};\n use llvm::debuginfo::{DIFile, DIType, DIScope, DIBuilderRef, DISubprogram, DIArray,\n                       DIDescriptor, FlagPrototyped};\n use middle::def_id::DefId;\n+use middle::infer::normalize_associated_type;\n use middle::subst::{self, Substs};\n use rustc_front;\n use rustc_front::hir;\n@@ -463,7 +464,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                          -> DIArray\n     {\n         let self_type = param_substs.self_ty();\n-        let self_type = monomorphize::normalize_associated_type(cx.tcx(), &self_type);\n+        let self_type = normalize_associated_type(cx.tcx(), &self_type);\n \n         // Only true for static default methods:\n         let has_self_type = self_type.is_some();"}, {"sha": "ce9f3b4b05da1bf935cf3d8e25e11fa54d67a5c3", "filename": "src/librustc_trans/trans/declare.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8a19b234c7315af478786801eb53a984a7059e14/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a19b234c7315af478786801eb53a984a7059e14/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs?ref=8a19b234c7315af478786801eb53a984a7059e14", "patch": "@@ -26,7 +26,6 @@ use syntax::abi;\n use trans::attributes;\n use trans::base;\n use trans::context::CrateContext;\n-use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of;\n \n@@ -104,7 +103,7 @@ pub fn declare_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n                                  fn_type: ty::Ty<'tcx>) -> ValueRef {\n     debug!(\"declare_rust_fn(name={:?}, fn_type={:?})\", name,\n            fn_type);\n-    let fn_type = monomorphize::normalize_associated_type(ccx.tcx(), &fn_type);\n+    let fn_type = infer::normalize_associated_type(ccx.tcx(), &fn_type);\n     debug!(\"declare_rust_fn (after normalised associated types) fn_type={:?}\",\n            fn_type);\n "}, {"sha": "20c3f356b1122b50676b6e6832f05c901fc01b11", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 39, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8a19b234c7315af478786801eb53a984a7059e14/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a19b234c7315af478786801eb53a984a7059e14/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=8a19b234c7315af478786801eb53a984a7059e14", "patch": "@@ -13,10 +13,9 @@ use session;\n use llvm::ValueRef;\n use llvm;\n use middle::def_id::DefId;\n-use middle::infer;\n+use middle::infer::normalize_associated_type;\n use middle::subst;\n use middle::subst::{Subst, Substs};\n-use middle::traits;\n use middle::ty::fold::{TypeFolder, TypeFoldable};\n use trans::attributes;\n use trans::base::{trans_enum_variant, push_ctxt, get_item_val};\n@@ -33,7 +32,6 @@ use rustc_front::attr;\n \n use syntax::abi;\n use syntax::ast;\n-use syntax::codemap::DUMMY_SP;\n use std::hash::{Hasher, Hash, SipHasher};\n \n pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -300,39 +298,3 @@ pub fn field_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n {\n     normalize_associated_type(tcx, &f.ty(tcx, param_substs))\n }\n-\n-/// Removes associated types, if any. Since this during\n-/// monomorphization, we know that only concrete types are involved,\n-/// and hence we can be sure that all associated types will be\n-/// completely normalized away.\n-pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n-    where T : TypeFoldable<'tcx> + HasTypeFlags\n-{\n-    debug!(\"normalize_associated_type(t={:?})\", value);\n-\n-    let value = erase_regions(tcx, value);\n-\n-    if !value.has_projection_types() {\n-        return value;\n-    }\n-\n-    // FIXME(#20304) -- cache\n-    let infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables);\n-    let mut selcx = traits::SelectionContext::new(&infcx);\n-    let cause = traits::ObligationCause::dummy();\n-    let traits::Normalized { value: result, obligations } =\n-        traits::normalize(&mut selcx, cause, &value);\n-\n-    debug!(\"normalize_associated_type: result={:?} obligations={:?}\",\n-           result,\n-           obligations);\n-\n-    let mut fulfill_cx = infcx.fulfillment_cx.borrow_mut();\n-\n-    for obligation in obligations {\n-        fulfill_cx.register_predicate_obligation(&infcx, obligation);\n-    }\n-    let result = drain_fulfillment_cx_or_panic(DUMMY_SP, &infcx, &mut fulfill_cx, &result);\n-\n-    result\n-}"}, {"sha": "43e1ad8115beda7f619098fc6966fafb2fd23818", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a19b234c7315af478786801eb53a984a7059e14/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a19b234c7315af478786801eb53a984a7059e14/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=8a19b234c7315af478786801eb53a984a7059e14", "patch": "@@ -325,7 +325,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n     // Rust types are defined as the same LLVM types.  If we don't do\n     // this then, e.g. `Option<{myfield: bool}>` would be a different\n     // type than `Option<myrec>`.\n-    let t_norm = erase_regions(cx.tcx(), &t);\n+    let t_norm = cx.tcx().erase_regions(&t);\n \n     if t != t_norm {\n         let llty = in_memory_type_of(cx, t_norm);"}, {"sha": "edf1cc9b7ef38c31a4812bae98b31b35a2c56d94", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a19b234c7315af478786801eb53a984a7059e14/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a19b234c7315af478786801eb53a984a7059e14/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=8a19b234c7315af478786801eb53a984a7059e14", "patch": "@@ -17,7 +17,7 @@ use middle::def_id::DefId;\n use middle::privacy::{AllPublic, DependsOn, LastPrivate, LastMod};\n use middle::subst;\n use middle::traits;\n-use middle::ty::{self, ToPredicate, ToPolyTraitRef, TraitRef};\n+use middle::ty::{self, RegionEscape, ToPredicate, ToPolyTraitRef, TraitRef};\n use middle::ty::adjustment::{AdjustDerefRef, AutoDerefRef, AutoPtr};\n use middle::infer;\n "}]}