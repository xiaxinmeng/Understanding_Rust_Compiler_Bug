{"sha": "248bfdea8628ee8606d78759397323e139710e42", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0OGJmZGVhODYyOGVlODYwNmQ3ODc1OTM5NzMyM2UxMzk3MTBlNDI=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-09-08T09:12:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-08T09:12:36Z"}, "message": "Merge pull request #50 from oli-obk/casts\n\nimplement more casts", "tree": {"sha": "9461ff6cd264fb71a8f94b144a40acbcaac651d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9461ff6cd264fb71a8f94b144a40acbcaac651d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/248bfdea8628ee8606d78759397323e139710e42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/248bfdea8628ee8606d78759397323e139710e42", "html_url": "https://github.com/rust-lang/rust/commit/248bfdea8628ee8606d78759397323e139710e42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/248bfdea8628ee8606d78759397323e139710e42/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1dc961c5a2aa2516d93e8e126052361a03394c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1dc961c5a2aa2516d93e8e126052361a03394c9", "html_url": "https://github.com/rust-lang/rust/commit/f1dc961c5a2aa2516d93e8e126052361a03394c9"}, {"sha": "168d9e77456b09d062f84d808c0f42336c03acb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/168d9e77456b09d062f84d808c0f42336c03acb1", "html_url": "https://github.com/rust-lang/rust/commit/168d9e77456b09d062f84d808c0f42336c03acb1"}], "stats": {"total": 196, "additions": 168, "deletions": 28}, "files": [{"sha": "726a4dcfa3fe5d0ce43f084a16935947e2a5e894", "filename": "src/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/248bfdea8628ee8606d78759397323e139710e42/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/248bfdea8628ee8606d78759397323e139710e42/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=248bfdea8628ee8606d78759397323e139710e42", "patch": "@@ -28,7 +28,7 @@ pub enum EvalError<'tcx> {\n     ExecuteMemory,\n     ArrayIndexOutOfBounds(Span, u64, u64),\n     Math(Span, ConstMathErr),\n-    InvalidChar(u32),\n+    InvalidChar(u64),\n     OutOfMemory {\n         allocation_size: usize,\n         memory_size: usize,"}, {"sha": "580f957b44916ada448e496463e727b37b8bc81d", "filename": "src/interpreter/cast.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/248bfdea8628ee8606d78759397323e139710e42/src%2Finterpreter%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/248bfdea8628ee8606d78759397323e139710e42/src%2Finterpreter%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fcast.rs?ref=248bfdea8628ee8606d78759397323e139710e42", "patch": "@@ -0,0 +1,96 @@\n+\n+use super::{\n+    EvalContext,\n+};\n+use error::{EvalResult, EvalError};\n+use rustc::ty;\n+use primval::PrimVal;\n+use memory::Pointer;\n+\n+use rustc::ty::Ty;\n+use syntax::ast;\n+\n+impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+    pub(super) fn cast_primval(&self, val: PrimVal, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n+        use primval::PrimVal::*;\n+        match val {\n+            Bool(b) => self.cast_const_int(b as u64, ty, false),\n+            F32(f) => self.cast_const_float(f as f64, ty),\n+            F64(f) => self.cast_const_float(f, ty),\n+            I8(i) => self.cast_signed_int(i as i64, ty),\n+            I16(i) => self.cast_signed_int(i as i64, ty),\n+            I32(i) => self.cast_signed_int(i as i64, ty),\n+            I64(i) => self.cast_signed_int(i, ty),\n+            U8(u) => self.cast_const_int(u as u64, ty, false),\n+            U16(u) => self.cast_const_int(u as u64, ty, false),\n+            U32(u) => self.cast_const_int(u as u64, ty, false),\n+            Char(c) => self.cast_const_int(c as u64, ty, false),\n+            U64(u) |\n+            IntegerPtr(u) => self.cast_const_int(u, ty, false),\n+            FnPtr(ptr) |\n+            AbstractPtr(ptr) => self.cast_ptr(ptr, ty),\n+        }\n+    }\n+\n+    fn cast_ptr(&self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n+        use primval::PrimVal::*;\n+        match ty.sty {\n+            ty::TyRef(..) |\n+            ty::TyRawPtr(_) => Ok(AbstractPtr(ptr)),\n+            ty::TyFnPtr(_) => Ok(FnPtr(ptr)),\n+            _ => Err(EvalError::Unimplemented(format!(\"ptr to {:?} cast\", ty))),\n+        }\n+    }\n+\n+    fn cast_signed_int(&self, val: i64, ty: ty::Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n+        self.cast_const_int(val as u64, ty, val < 0)\n+    }\n+\n+    fn cast_const_int(&self, v: u64, ty: ty::Ty<'tcx>, negative: bool) -> EvalResult<'tcx, PrimVal> {\n+        use primval::PrimVal::*;\n+        match ty.sty {\n+            ty::TyBool if v == 0 => Ok(Bool(false)),\n+            ty::TyBool if v == 1 => Ok(Bool(true)),\n+            ty::TyBool => Err(EvalError::InvalidBool),\n+            ty::TyInt(ast::IntTy::I8) => Ok(I8(v as i64 as i8)),\n+            ty::TyInt(ast::IntTy::I16) => Ok(I16(v as i64 as i16)),\n+            ty::TyInt(ast::IntTy::I32) => Ok(I32(v as i64 as i32)),\n+            ty::TyInt(ast::IntTy::I64) => Ok(I64(v as i64)),\n+            ty::TyInt(ast::IntTy::Is) => {\n+                let int_ty = self.tcx.sess.target.int_type;\n+                let ty = self.tcx.mk_mach_int(int_ty);\n+                self.cast_const_int(v, ty, negative)\n+            },\n+            ty::TyUint(ast::UintTy::U8) => Ok(U8(v as u8)),\n+            ty::TyUint(ast::UintTy::U16) => Ok(U16(v as u16)),\n+            ty::TyUint(ast::UintTy::U32) => Ok(U32(v as u32)),\n+            ty::TyUint(ast::UintTy::U64) => Ok(U64(v)),\n+            ty::TyUint(ast::UintTy::Us) => {\n+                let uint_ty = self.tcx.sess.target.uint_type;\n+                let ty = self.tcx.mk_mach_uint(uint_ty);\n+                self.cast_const_int(v, ty, negative)\n+            },\n+            ty::TyFloat(ast::FloatTy::F64) if negative => Ok(F64(v as i64 as f64)),\n+            ty::TyFloat(ast::FloatTy::F64) => Ok(F64(v as f64)),\n+            ty::TyFloat(ast::FloatTy::F32) if negative => Ok(F32(v as i64 as f32)),\n+            ty::TyFloat(ast::FloatTy::F32) => Ok(F32(v as f32)),\n+            ty::TyRawPtr(_) => Ok(IntegerPtr(v)),\n+            ty::TyChar if v as u8 as u64 == v => Ok(Char(v as u8 as char)),\n+            ty::TyChar => Err(EvalError::InvalidChar(v)),\n+            _ => Err(EvalError::Unimplemented(format!(\"int to {:?} cast\", ty))),\n+        }\n+    }\n+\n+    fn cast_const_float(&self, val: f64, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n+        use primval::PrimVal::*;\n+        match ty.sty {\n+            // casting negative floats to unsigned integers yields zero\n+            ty::TyUint(_) if val < 0.0 => self.cast_const_int(0, ty, false),\n+            ty::TyInt(_) if val < 0.0 => self.cast_const_int(val as i64 as u64, ty, true),\n+            ty::TyInt(_) | ty::TyUint(_) => self.cast_const_int(val as u64, ty, false),\n+            ty::TyFloat(ast::FloatTy::F64) => Ok(F64(val)),\n+            ty::TyFloat(ast::FloatTy::F32) => Ok(F32(val as f32)),\n+            _ => Err(EvalError::Unimplemented(format!(\"float to {:?} cast\", ty))),\n+        }\n+    }\n+}"}, {"sha": "e77ec942bbf556c3f4f3d3e6249ccad525b79d35", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 68, "deletions": 24, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/248bfdea8628ee8606d78759397323e139710e42/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/248bfdea8628ee8606d78759397323e139710e42/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=248bfdea8628ee8606d78759397323e139710e42", "patch": "@@ -5,7 +5,7 @@ use rustc::mir::repr as mir;\n use rustc::traits::Reveal;\n use rustc::ty::layout::{self, Layout, Size};\n use rustc::ty::subst::{self, Subst, Substs};\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::util::nodemap::DefIdMap;\n use rustc_data_structures::indexed_vec::Idx;\n use std::cell::RefCell;\n@@ -22,6 +22,7 @@ use std::collections::HashMap;\n \n mod step;\n mod terminator;\n+mod cast;\n \n pub struct EvalContext<'a, 'tcx: 'a> {\n     /// The results of the type checker, from rustc.\n@@ -211,9 +212,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let psize = self.memory.pointer_size();\n                 let static_ptr = self.memory.allocate(s.len(), 1)?;\n                 let ptr = self.memory.allocate(psize * 2, psize)?;\n+                let (ptr, extra) = self.get_fat_ptr(ptr);\n                 self.memory.write_bytes(static_ptr, s.as_bytes())?;\n                 self.memory.write_ptr(ptr, static_ptr)?;\n-                self.memory.write_usize(ptr.offset(psize as isize), s.len() as u64)?;\n+                self.memory.write_usize(extra, s.len() as u64)?;\n                 Ok(ptr)\n             }\n             ByteStr(ref bs) => {\n@@ -244,6 +246,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n+        // generics are weird, don't run this function on a generic\n+        assert!(!ty.needs_subst());\n         ty.is_sized(self.tcx, &self.tcx.empty_parameter_environment(), DUMMY_SP)\n     }\n \n@@ -558,12 +562,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Ref(_, _, ref lvalue) => {\n                 let lv = self.eval_lvalue(lvalue)?;\n-                self.memory.write_ptr(dest, lv.ptr)?;\n+                let (ptr, extra) = self.get_fat_ptr(dest);\n+                self.memory.write_ptr(ptr, lv.ptr)?;\n                 match lv.extra {\n                     LvalueExtra::None => {},\n                     LvalueExtra::Length(len) => {\n-                        let len_ptr = dest.offset(self.memory.pointer_size() as isize);\n-                        self.memory.write_usize(len_ptr, len)?;\n+                        self.memory.write_usize(extra, len)?;\n                     }\n                     LvalueExtra::DowncastVariant(..) =>\n                         bug!(\"attempted to take a reference to an enum downcast lvalue\"),\n@@ -583,14 +587,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Unsize => {\n                         let src = self.eval_operand(operand)?;\n                         let src_ty = self.operand_ty(operand);\n-                        self.move_(src, dest, src_ty)?;\n+                        let (ptr, extra) = self.get_fat_ptr(dest);\n+                        self.move_(src, ptr, src_ty)?;\n                         let src_pointee_ty = pointee_type(src_ty).unwrap();\n                         let dest_pointee_ty = pointee_type(dest_ty).unwrap();\n \n                         match (&src_pointee_ty.sty, &dest_pointee_ty.sty) {\n                             (&ty::TyArray(_, length), &ty::TySlice(_)) => {\n-                                let len_ptr = dest.offset(self.memory.pointer_size() as isize);\n-                                self.memory.write_usize(len_ptr, length as u64)?;\n+                                self.memory.write_usize(extra, length as u64)?;\n                             }\n \n                             _ => return Err(EvalError::Unimplemented(format!(\"can't handle cast: {:?}\", rvalue))),\n@@ -600,20 +604,25 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Misc => {\n                         let src = self.eval_operand(operand)?;\n                         let src_ty = self.operand_ty(operand);\n-                        // FIXME(solson): Wrong for almost everything.\n-                        warn!(\"misc cast from {:?} to {:?}\", src_ty, dest_ty);\n-                        let dest_size = self.type_size(dest_ty);\n-                        let src_size = self.type_size(src_ty);\n-                        let dest_align = self.type_align(dest_ty);\n-\n-                        // Hack to support fat pointer -> thin pointer casts to keep tests for\n-                        // other things passing for now.\n-                        let is_fat_ptr_cast = pointee_type(src_ty).map_or(false, |ty| !self.type_is_sized(ty));\n-\n-                        if dest_size == src_size || is_fat_ptr_cast {\n-                            self.memory.copy(src, dest, dest_size, dest_align)?;\n+                        if self.type_is_fat_ptr(src_ty) {\n+                            let (data_ptr, _meta_ptr) = self.get_fat_ptr(src);\n+                            let ptr_size = self.memory.pointer_size();\n+                            let dest_ty = self.monomorphize(dest_ty, self.substs());\n+                            if self.type_is_fat_ptr(dest_ty) {\n+                                // FIXME: add assertion that the extra part of the src_ty and\n+                                // dest_ty is of the same type\n+                                self.memory.copy(data_ptr, dest, ptr_size * 2, ptr_size)?;\n+                            } else { // cast to thin-ptr\n+                                // Cast of fat-ptr to thin-ptr is an extraction of data-ptr and\n+                                // pointer-cast of that pointer to desired pointer type.\n+                                self.memory.copy(data_ptr, dest, ptr_size, ptr_size)?;\n+                            }\n                         } else {\n-                            return Err(EvalError::Unimplemented(format!(\"can't handle cast: {:?}\", rvalue)));\n+                            // FIXME: dest_ty should already be monomorphized\n+                            let dest_ty = self.monomorphize(dest_ty, self.substs());\n+                            let src_val = self.read_primval(src, src_ty)?;\n+                            let dest_val = self.cast_primval(src_val, dest_ty)?;\n+                            self.memory.write_primval(dest, dest_val)?;\n                         }\n                     }\n \n@@ -644,6 +653,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n+    fn type_is_fat_ptr(&self, ty: Ty<'tcx>) -> bool {\n+        match ty.sty {\n+            ty::TyRawPtr(ty::TypeAndMut{ty, ..}) |\n+            ty::TyRef(_, ty::TypeAndMut{ty, ..}) |\n+            ty::TyBox(ty) => !self.type_is_sized(ty),\n+            _ => false,\n+        }\n+    }\n+\n     fn nonnull_offset(&self, ty: Ty<'tcx>, nndiscr: u64, discrfield: &[u32]) -> EvalResult<'tcx, Size> {\n         // Skip the constant 0 at the start meant for LLVM GEP.\n         let mut path = discrfield.iter().skip(1).map(|&i| i as usize);\n@@ -809,11 +827,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                     Deref => {\n                         let pointee_ty = pointee_type(base_ty).expect(\"Deref of non-pointer\");\n+                        self.memory.dump(base.ptr.alloc_id);\n                         let ptr = self.memory.read_ptr(base.ptr)?;\n                         let extra = match pointee_ty.sty {\n                             ty::TySlice(_) | ty::TyStr => {\n-                                let len_ptr = base.ptr.offset(self.memory.pointer_size() as isize);\n-                                let len = self.memory.read_usize(len_ptr)?;\n+                                let (_, extra) = self.get_fat_ptr(base.ptr);\n+                                let len = self.memory.read_usize(extra)?;\n                                 LvalueExtra::Length(len)\n                             }\n                             ty::TyTrait(_) => unimplemented!(),\n@@ -842,6 +861,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(Lvalue { ptr: ptr, extra: LvalueExtra::None })\n     }\n \n+    fn get_fat_ptr(&self, ptr: Pointer) -> (Pointer, Pointer) {\n+        assert_eq!(layout::FAT_PTR_ADDR, 0);\n+        assert_eq!(layout::FAT_PTR_EXTRA, 1);\n+        (ptr, ptr.offset(self.memory.pointer_size() as isize))\n+    }\n+\n     fn lvalue_ty(&self, lvalue: &mir::Lvalue<'tcx>) -> Ty<'tcx> {\n         self.monomorphize(lvalue.ty(&self.mir(), self.tcx).to_ty(self.tcx), self.substs())\n     }\n@@ -865,7 +890,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let c = self.memory.read_uint(ptr, 4)? as u32;\n                 match ::std::char::from_u32(c) {\n                     Some(ch) => PrimVal::Char(ch),\n-                    None => return Err(EvalError::InvalidChar(c)),\n+                    None => return Err(EvalError::InvalidChar(c as u64)),\n                 }\n             }\n             (_, &ty::TyInt(IntTy::I8))    => PrimVal::I8(self.memory.read_int(ptr, 1)? as i8),\n@@ -905,6 +930,25 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 }\n             }\n \n+            (_, &ty::TyEnum(..)) => {\n+                use rustc::ty::layout::Layout::*;\n+                if let CEnum { discr, signed, .. } = *self.type_layout(ty) {\n+                    match (discr.size().bytes(), signed) {\n+                        (1, true)  => PrimVal::I8(self.memory.read_int(ptr, 1)? as i8),\n+                        (2, true)  => PrimVal::I16(self.memory.read_int(ptr, 2)? as i16),\n+                        (4, true)  => PrimVal::I32(self.memory.read_int(ptr, 4)? as i32),\n+                        (8, true)  => PrimVal::I64(self.memory.read_int(ptr, 8)? as i64),\n+                        (1, false) => PrimVal::U8(self.memory.read_uint(ptr, 1)? as u8),\n+                        (2, false) => PrimVal::U16(self.memory.read_uint(ptr, 2)? as u16),\n+                        (4, false) => PrimVal::U32(self.memory.read_uint(ptr, 4)? as u32),\n+                        (8, false) => PrimVal::U64(self.memory.read_uint(ptr, 8)? as u64),\n+                        (size, _) => bug!(\"CEnum discr size {}\", size),\n+                    }\n+                } else {\n+                    bug!(\"primitive read of non-clike enum: {:?}\", ty);\n+                }\n+            },\n+\n             _ => bug!(\"primitive read of non-primitive type: {:?}\", ty),\n         };\n         Ok(val)"}, {"sha": "afba23fac5999d6dd8a4af85cd5b25c77fef16fd", "filename": "src/interpreter/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/248bfdea8628ee8606d78759397323e139710e42/src%2Finterpreter%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/248bfdea8628ee8606d78759397323e139710e42/src%2Finterpreter%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator.rs?ref=248bfdea8628ee8606d78759397323e139710e42", "patch": "@@ -47,7 +47,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let discr_val = self.memory.read_uint(discr_ptr, discr_size)?;\n                 if let ty::TyChar = discr_ty.sty {\n                     if ::std::char::from_u32(discr_val as u32).is_none() {\n-                        return Err(EvalError::InvalidChar(discr_val as u32));\n+                        return Err(EvalError::InvalidChar(discr_val as u64));\n                     }\n                 }\n "}, {"sha": "75cbb16122f9bc766f31d7a20e7c16bca7a829d3", "filename": "src/memory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/248bfdea8628ee8606d78759397323e139710e42/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/248bfdea8628ee8606d78759397323e139710e42/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=248bfdea8628ee8606d78759397323e139710e42", "patch": "@@ -455,8 +455,8 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             PrimVal::IntegerPtr(n) => self.write_uint(ptr, n as u64, pointer_size),\n             PrimVal::F32(f) => self.write_f32(ptr, f),\n             PrimVal::F64(f) => self.write_f64(ptr, f),\n-            PrimVal::FnPtr(_p) |\n-            PrimVal::AbstractPtr(_p) => unimplemented!(),\n+            PrimVal::FnPtr(p) |\n+            PrimVal::AbstractPtr(p) => self.write_ptr(ptr, p),\n         }\n     }\n "}]}