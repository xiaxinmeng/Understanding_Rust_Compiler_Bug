{"sha": "48c3e46cf13f88a8278306d1c86fcc1247aa23df", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4YzNlNDZjZjEzZjg4YTgyNzgzMDZkMWM4NmZjYzEyNDdhYTIzZGY=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-07-16T07:07:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-07-16T07:07:05Z"}, "message": "Merge pull request #2829 from scampi/issue1210\n\nfix rewrite_string when a line feed is present in a sequence of whitespaces, resulting in strange formatting", "tree": {"sha": "5d3b8db3e07b76d259dfd8a367589b4ca8f6f5a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d3b8db3e07b76d259dfd8a367589b4ca8f6f5a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48c3e46cf13f88a8278306d1c86fcc1247aa23df", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbTEQZCRBK7hj4Ov3rIwAAdHIIAEZPy0JxXZtKnjyleQ07Md0i\n7yyHtGWs0AP17qIKdAFevvJ8BtyBhmUSlcsA0yvkJgDJO9ktlpSHDUfl12K6wSbQ\n+355srUbdsnAVHc7ulcDhknL+S/Nu7H2ypOsqPbndQRiUXTEt03yXENE/cf+F6ae\nVUvVsywwrl5Eg2lnUxZWHp5/c7KgBvuDgSwsMpea83FvwuVdh+lJaZmNR6C9UaOy\nA4GrFTcqxKSZZPmJ0Bhs/yq5UcJOJR/BXqBRhNM3zc9+ZmGWqjLYBRwsW9qO2/LP\n4aNQWSwYiHmPl4OBXaKaax3S7h5R8FZ/LACRbHyEhhYUOJ8aH9OT7NRQYYOb6c0=\n=SAnY\n-----END PGP SIGNATURE-----\n", "payload": "tree 5d3b8db3e07b76d259dfd8a367589b4ca8f6f5a8\nparent e110d95f53cbb755aa706ba16467834dfafbdede\nparent 86018133a02064e838404c94a860e57547a5a9ef\nauthor Seiichi Uchida <seuchida@gmail.com> 1531724825 +0900\ncommitter GitHub <noreply@github.com> 1531724825 +0900\n\nMerge pull request #2829 from scampi/issue1210\n\nfix rewrite_string when a line feed is present in a sequence of whitespaces, resulting in strange formatting"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48c3e46cf13f88a8278306d1c86fcc1247aa23df", "html_url": "https://github.com/rust-lang/rust/commit/48c3e46cf13f88a8278306d1c86fcc1247aa23df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48c3e46cf13f88a8278306d1c86fcc1247aa23df/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e110d95f53cbb755aa706ba16467834dfafbdede", "url": "https://api.github.com/repos/rust-lang/rust/commits/e110d95f53cbb755aa706ba16467834dfafbdede", "html_url": "https://github.com/rust-lang/rust/commit/e110d95f53cbb755aa706ba16467834dfafbdede"}, {"sha": "86018133a02064e838404c94a860e57547a5a9ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/86018133a02064e838404c94a860e57547a5a9ef", "html_url": "https://github.com/rust-lang/rust/commit/86018133a02064e838404c94a860e57547a5a9ef"}], "stats": {"total": 406, "additions": 324, "deletions": 82}, "files": [{"sha": "53e496bf45748be45f6dbf368a954b7fc903b53c", "filename": "src/comment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/48c3e46cf13f88a8278306d1c86fcc1247aa23df/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48c3e46cf13f88a8278306d1c86fcc1247aa23df/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=48c3e46cf13f88a8278306d1c86fcc1247aa23df", "patch": "@@ -438,7 +438,7 @@ fn rewrite_comment_inner(\n         }\n \n         if config.wrap_comments() && line.len() > fmt.shape.width && !has_url(line) {\n-            match rewrite_string(line, &fmt, Some(max_chars)) {\n+            match rewrite_string(line, &fmt) {\n                 Some(ref s) => {\n                     is_prev_line_multi_line = s.contains('\\n');\n                     result.push_str(s);\n@@ -449,7 +449,7 @@ fn rewrite_comment_inner(\n                     result.pop();\n                     result.push_str(&comment_line_separator);\n                     fmt.shape = Shape::legacy(max_chars, fmt_indent);\n-                    match rewrite_string(line, &fmt, Some(max_chars)) {\n+                    match rewrite_string(line, &fmt) {\n                         Some(ref s) => {\n                             is_prev_line_multi_line = s.contains('\\n');\n                             result.push_str(s);"}, {"sha": "6e1af266e9bfe8e9dfb95470a6fc1e3edef01c5a", "filename": "src/expr.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/48c3e46cf13f88a8278306d1c86fcc1247aa23df/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48c3e46cf13f88a8278306d1c86fcc1247aa23df/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=48c3e46cf13f88a8278306d1c86fcc1247aa23df", "patch": "@@ -1229,7 +1229,6 @@ fn rewrite_string_lit(context: &RewriteContext, span: Span, shape: Shape) -> Opt\n     rewrite_string(\n         str_lit,\n         &StringFormat::new(shape.visual_indent(0), context.config),\n-        None,\n     )\n }\n "}, {"sha": "fd7ac89013a32cba04c94a37bd7cbd2a1bc0df62", "filename": "src/string.rs", "status": "modified", "additions": 226, "deletions": 78, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/48c3e46cf13f88a8278306d1c86fcc1247aa23df/src%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48c3e46cf13f88a8278306d1c86fcc1247aa23df/src%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring.rs?ref=48c3e46cf13f88a8278306d1c86fcc1247aa23df", "patch": "@@ -41,21 +41,39 @@ impl<'a> StringFormat<'a> {\n             config,\n         }\n     }\n+\n+    /// Returns the maximum number of graphemes that is possible on a line while taking the\n+    /// indentation into account.\n+    ///\n+    /// If we cannot put at least a single character per line, the rewrite won't succeed.\n+    fn max_chars_with_indent(&self) -> Option<usize> {\n+        Some(\n+            self.shape\n+                .width\n+                .checked_sub(self.opener.len() + self.line_end.len() + 1)?\n+                + 1,\n+        )\n+    }\n+\n+    /// Like max_chars_with_indent but the indentation is not substracted.\n+    /// This allows to fit more graphemes from the string on a line when\n+    /// SnippetState::Overflow.\n+    fn max_chars_without_indent(&self) -> Option<usize> {\n+        Some(self.config.max_width().checked_sub(self.line_end.len())?)\n+    }\n }\n \n-// FIXME: simplify this!\n-pub fn rewrite_string<'a>(\n-    orig: &str,\n-    fmt: &StringFormat<'a>,\n-    max_width: Option<usize>,\n-) -> Option<String> {\n+pub fn rewrite_string<'a>(orig: &str, fmt: &StringFormat<'a>) -> Option<String> {\n+    let max_chars_with_indent = fmt.max_chars_with_indent()?;\n+    let max_chars_without_indent = fmt.max_chars_without_indent()?;\n+    let indent = fmt.shape.indent.to_string_with_newline(fmt.config);\n+\n     // Strip line breaks.\n-    let re = Regex::new(r\"([^\\\\](\\\\\\\\)*)\\\\[\\n\\r][[:space:]]*\").unwrap();\n-    let stripped_str = re.replace_all(orig, \"$1\");\n+    // With this regex applied, all remaining whitespaces are significant\n+    let strip_line_breaks_re = Regex::new(r\"([^\\\\](\\\\\\\\)*)\\\\[\\n\\r][[:space:]]*\").unwrap();\n+    let stripped_str = strip_line_breaks_re.replace_all(orig, \"$1\");\n \n     let graphemes = UnicodeSegmentation::graphemes(&*stripped_str, false).collect::<Vec<&str>>();\n-    let shape = fmt.shape;\n-    let indent = shape.indent.to_string_with_newline(fmt.config);\n \n     // `cur_start` is the position in `orig` of the start of the current line.\n     let mut cur_start = 0;\n@@ -67,85 +85,129 @@ pub fn rewrite_string<'a>(\n     );\n     result.push_str(fmt.opener);\n \n-    let ender_length = fmt.line_end.len();\n-    // If we cannot put at least a single character per line, the rewrite won't\n-    // succeed.\n-    let mut max_chars = shape\n-        .width\n-        .checked_sub(fmt.opener.len() + ender_length + 1)?\n-        + 1;\n-\n-    // Snip a line at a time from `orig` until it is used up. Push the snippet\n+    // Snip a line at a time from `stripped_str` until it is used up. Push the snippet\n     // onto result.\n-    'outer: loop {\n-        // `cur_end` will be where we break the line, as an offset into `orig`.\n-        // Initialised to the maximum it could be (which may be beyond `orig`).\n-        let mut cur_end = cur_start + max_chars;\n-\n-        // We can fit the rest of the string on this line, so we're done.\n-        if cur_end >= graphemes.len() {\n-            let line = &graphemes[cur_start..].join(\"\");\n-            result.push_str(line);\n-            break 'outer;\n+    let mut cur_max_chars = max_chars_with_indent;\n+    loop {\n+        // All the input starting at cur_start fits on the current line\n+        if graphemes.len() - cur_start <= cur_max_chars {\n+            result.push_str(&graphemes[cur_start..].join(\"\"));\n+            break;\n         }\n \n-        // Push cur_end left until we reach whitespace (or the line is too small).\n-        while !is_whitespace(graphemes[cur_end - 1]) {\n-            cur_end -= 1;\n-            if cur_end < cur_start + MIN_STRING {\n-                // We couldn't find whitespace before the string got too small.\n-                // So start again at the max length and look for punctuation.\n-                cur_end = cur_start + max_chars;\n-                while !is_punctuation(graphemes[cur_end - 1]) {\n-                    cur_end -= 1;\n-\n-                    // If we can't break at whitespace or punctuation, grow the string instead.\n-                    if cur_end < cur_start + MIN_STRING {\n-                        cur_end = cur_start + max_chars;\n-                        while !(is_punctuation(graphemes[cur_end - 1])\n-                            || is_whitespace(graphemes[cur_end - 1]))\n-                        {\n-                            cur_end += 1;\n-                            if cur_end == graphemes.len() {\n-                                let line = &graphemes[cur_start..].join(\"\");\n-                                result.push_str(line);\n-                                break 'outer;\n-                            }\n-                        }\n-                        break;\n-                    }\n-                }\n+        // The input starting at cur_start needs to be broken\n+        match break_string(cur_max_chars, fmt.trim_end, &graphemes[cur_start..]) {\n+            SnippetState::LineEnd(line, len) => {\n+                result.push_str(&line);\n+                result.push_str(fmt.line_end);\n+                result.push_str(&indent);\n+                result.push_str(fmt.line_start);\n+                cur_max_chars = max_chars_with_indent;\n+                cur_start += len;\n+            }\n+            SnippetState::Overflow(line, len) => {\n+                result.push_str(&line);\n+                cur_max_chars = max_chars_without_indent;\n+                cur_start += len;\n+            }\n+            SnippetState::EndOfInput(line) => {\n+                result.push_str(&line);\n                 break;\n             }\n         }\n-        // Make sure there is no whitespace to the right of the break.\n-        while cur_end < stripped_str.len() && is_whitespace(graphemes[cur_end]) {\n-            cur_end += 1;\n-        }\n+    }\n \n-        // Make the current line and add it on to result.\n-        let raw_line = graphemes[cur_start..cur_end].join(\"\");\n-        let line = if fmt.trim_end {\n-            raw_line.trim()\n-        } else {\n-            raw_line.as_str()\n-        };\n+    result.push_str(fmt.closer);\n+    wrap_str(result, fmt.config.max_width(), fmt.shape)\n+}\n \n-        result.push_str(line);\n-        result.push_str(fmt.line_end);\n-        result.push_str(&indent);\n-        result.push_str(fmt.line_start);\n+/// Result of breaking a string so it fits in a line and the state it ended in.\n+/// The state informs about what to do with the snippet and how to continue the breaking process.\n+#[derive(Debug, PartialEq)]\n+enum SnippetState {\n+    /// The input could not be broken and so rewriting the string is finished.\n+    EndOfInput(String),\n+    /// The input could be broken and the returned snippet should be ended with a\n+    /// `[StringFormat::line_end]`. The next snippet needs to be indented.\n+    LineEnd(String, usize),\n+    /// The input could be broken but the returned snippet should not be ended with a\n+    /// `[StringFormat::line_end]` because the whitespace is significant. Therefore, the next\n+    /// snippet should not be indented.\n+    Overflow(String, usize),\n+}\n \n-        // The next line starts where the current line ends.\n-        cur_start = cur_end;\n+/// Break the input string at a boundary character around the offset `max_chars`. A boundary\n+/// character is either a punctuation or a whitespace.\n+fn break_string(max_chars: usize, trim_end: bool, input: &[&str]) -> SnippetState {\n+    let break_at = |index /* grapheme at index is included */| {\n+        // Take in any whitespaces to the left/right of `input[index]` and\n+        // check if there is a line feed, in which case whitespaces needs to be kept.\n+        let mut index_minus_ws = index;\n+        for (i, grapheme) in input[0..=index].iter().enumerate().rev() {\n+            if !trim_end && is_line_feed(grapheme) {\n+                return SnippetState::Overflow(input[0..=i].join(\"\").to_string(), i + 1);\n+            } else if !is_whitespace(grapheme) {\n+                index_minus_ws = i;\n+                break;\n+            }\n+        }\n+        let mut index_plus_ws = index;\n+        for (i, grapheme) in input[index + 1..].iter().enumerate() {\n+            if !trim_end && is_line_feed(grapheme) {\n+                return SnippetState::Overflow(\n+                    input[0..=index + 1 + i].join(\"\").to_string(),\n+                    index + 2 + i,\n+                );\n+            } else if !is_whitespace(grapheme) {\n+                index_plus_ws = index + i;\n+                break;\n+            }\n+        }\n \n-        if let Some(new_max_chars) = max_width {\n-            max_chars = new_max_chars.checked_sub(fmt.opener.len() + ender_length + 1)? + 1;\n+        if trim_end {\n+            SnippetState::LineEnd(\n+                input[0..=index_minus_ws].join(\"\").to_string(),\n+                index_plus_ws + 1,\n+            )\n+        } else {\n+            SnippetState::LineEnd(\n+                input[0..=index_plus_ws].join(\"\").to_string(),\n+                index_plus_ws + 1,\n+            )\n         }\n+    };\n+\n+    // Find the position in input for breaking the string\n+    match input[0..max_chars]\n+        .iter()\n+        .rposition(|grapheme| is_whitespace(grapheme))\n+    {\n+        // Found a whitespace and what is on its left side is big enough.\n+        Some(index) if index >= MIN_STRING => break_at(index),\n+        // No whitespace found, try looking for a punctuation instead\n+        _ => match input[0..max_chars]\n+            .iter()\n+            .rposition(|grapheme| is_punctuation(grapheme))\n+        {\n+            // Found a punctuation and what is on its left side is big enough.\n+            Some(index) if index >= MIN_STRING => break_at(index),\n+            // Either no boundary character was found to the left of `input[max_chars]`, or the line\n+            // got too small. We try searching for a boundary character to the right.\n+            _ => match input[max_chars..]\n+                .iter()\n+                .position(|grapheme| is_whitespace(grapheme) || is_punctuation(grapheme))\n+            {\n+                // A boundary was found after the line limit\n+                Some(index) => break_at(max_chars + index),\n+                // No boundary to the right, the input cannot be broken\n+                None => SnippetState::EndOfInput(input.join(\"\").to_string()),\n+            },\n+        },\n     }\n+}\n \n-    result.push_str(fmt.closer);\n-    wrap_str(result, fmt.config.max_width(), fmt.shape)\n+fn is_line_feed(grapheme: &str) -> bool {\n+    grapheme.as_bytes()[0] == b'\\n'\n }\n \n fn is_whitespace(grapheme: &str) -> bool {\n@@ -161,13 +223,99 @@ fn is_punctuation(grapheme: &str) -> bool {\n \n #[cfg(test)]\n mod test {\n-    use super::{rewrite_string, StringFormat};\n+    use super::{break_string, rewrite_string, SnippetState, StringFormat};\n     use shape::{Indent, Shape};\n+    use unicode_segmentation::UnicodeSegmentation;\n \n     #[test]\n     fn issue343() {\n         let config = Default::default();\n         let fmt = StringFormat::new(Shape::legacy(2, Indent::empty()), &config);\n-        rewrite_string(\"eq_\", &fmt, None);\n+        rewrite_string(\"eq_\", &fmt);\n+    }\n+\n+    #[test]\n+    fn should_break_on_whitespace() {\n+        let string = \"Placerat felis. Mauris porta ante sagittis purus.\";\n+        let graphemes = UnicodeSegmentation::graphemes(&*string, false).collect::<Vec<&str>>();\n+        assert_eq!(\n+            break_string(20, false, &graphemes[..]),\n+            SnippetState::LineEnd(\"Placerat felis. \".to_string(), 16)\n+        );\n+        assert_eq!(\n+            break_string(20, true, &graphemes[..]),\n+            SnippetState::LineEnd(\"Placerat felis.\".to_string(), 16)\n+        );\n+    }\n+\n+    #[test]\n+    fn should_break_on_punctuation() {\n+        let string = \"Placerat_felis._Mauris_porta_ante_sagittis_purus.\";\n+        let graphemes = UnicodeSegmentation::graphemes(&*string, false).collect::<Vec<&str>>();\n+        assert_eq!(\n+            break_string(20, false, &graphemes[..]),\n+            SnippetState::LineEnd(\"Placerat_felis.\".to_string(), 15)\n+        );\n+    }\n+\n+    #[test]\n+    fn should_break_forward() {\n+        let string = \"Venenatis_tellus_vel_tellus. Aliquam aliquam dolor at justo.\";\n+        let graphemes = UnicodeSegmentation::graphemes(&*string, false).collect::<Vec<&str>>();\n+        assert_eq!(\n+            break_string(20, false, &graphemes[..]),\n+            SnippetState::LineEnd(\"Venenatis_tellus_vel_tellus. \".to_string(), 29)\n+        );\n+        assert_eq!(\n+            break_string(20, true, &graphemes[..]),\n+            SnippetState::LineEnd(\"Venenatis_tellus_vel_tellus.\".to_string(), 29)\n+        );\n+    }\n+\n+    #[test]\n+    fn nothing_to_break() {\n+        let string = \"Venenatis_tellus_vel_tellus\";\n+        let graphemes = UnicodeSegmentation::graphemes(&*string, false).collect::<Vec<&str>>();\n+        assert_eq!(\n+            break_string(20, false, &graphemes[..]),\n+            SnippetState::EndOfInput(\"Venenatis_tellus_vel_tellus\".to_string())\n+        );\n+    }\n+\n+    #[test]\n+    fn significant_whitespaces() {\n+        let string = \"Neque in sem.      \\n      Pellentesque tellus augue.\";\n+        let graphemes = UnicodeSegmentation::graphemes(&*string, false).collect::<Vec<&str>>();\n+        assert_eq!(\n+            break_string(15, false, &graphemes[..]),\n+            SnippetState::Overflow(\"Neque in sem.      \\n\".to_string(), 20)\n+        );\n+        assert_eq!(\n+            break_string(25, false, &graphemes[..]),\n+            SnippetState::Overflow(\"Neque in sem.      \\n\".to_string(), 20)\n+        );\n+        // if `StringFormat::line_end` is true, then the line feed does not matter anymore\n+        assert_eq!(\n+            break_string(15, true, &graphemes[..]),\n+            SnippetState::LineEnd(\"Neque in sem.\".to_string(), 26)\n+        );\n+        assert_eq!(\n+            break_string(25, true, &graphemes[..]),\n+            SnippetState::LineEnd(\"Neque in sem.\".to_string(), 26)\n+        );\n+    }\n+\n+    #[test]\n+    fn big_whitespace() {\n+        let string = \"Neque in sem.            Pellentesque tellus augue.\";\n+        let graphemes = UnicodeSegmentation::graphemes(&*string, false).collect::<Vec<&str>>();\n+        assert_eq!(\n+            break_string(20, false, &graphemes[..]),\n+            SnippetState::LineEnd(\"Neque in sem.            \".to_string(), 25)\n+        );\n+        assert_eq!(\n+            break_string(20, true, &graphemes[..]),\n+            SnippetState::LineEnd(\"Neque in sem.\".to_string(), 25)\n+        );\n     }\n }"}, {"sha": "99275b52dc12531872e3e2be8fdc6730f560fd3a", "filename": "src/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48c3e46cf13f88a8278306d1c86fcc1247aa23df/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48c3e46cf13f88a8278306d1c86fcc1247aa23df/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=48c3e46cf13f88a8278306d1c86fcc1247aa23df", "patch": "@@ -320,7 +320,7 @@ macro_rules! skip_out_of_file_lines_range_visitor {\n }\n \n // Wraps String in an Option. Returns Some when the string adheres to the\n-// Rewrite constraints defined for the Rewrite trait and else otherwise.\n+// Rewrite constraints defined for the Rewrite trait and None otherwise.\n pub fn wrap_str(s: String, max_width: usize, shape: Shape) -> Option<String> {\n     if is_valid_str(&s, max_width, shape) {\n         Some(s)"}, {"sha": "6bb9964b4e3538243e1ee1c676fb013531e53580", "filename": "tests/source/issue-1210/a.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/48c3e46cf13f88a8278306d1c86fcc1247aa23df/tests%2Fsource%2Fissue-1210%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48c3e46cf13f88a8278306d1c86fcc1247aa23df/tests%2Fsource%2Fissue-1210%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fissue-1210%2Fa.rs?ref=48c3e46cf13f88a8278306d1c86fcc1247aa23df", "patch": "@@ -0,0 +1,12 @@\n+// rustfmt-format_strings: true\n+// rustfmt-max_width: 50\n+\n+impl Foo {\n+    fn cxx(&self, target: &str) -> &Path {\n+        match self.cxx.get(target) {\n+            Some(p) => p.path(),\n+            None => panic!(\"\\n\\ntarget `{}` is not configured as a host,\n+                            only as a target\\n\\n\", target),\n+        }\n+    }\n+}"}, {"sha": "8c71ef98b7fcfd450ed1a5fb9ee3ba0fdc335825", "filename": "tests/source/issue-1210/b.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/48c3e46cf13f88a8278306d1c86fcc1247aa23df/tests%2Fsource%2Fissue-1210%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48c3e46cf13f88a8278306d1c86fcc1247aa23df/tests%2Fsource%2Fissue-1210%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fissue-1210%2Fb.rs?ref=48c3e46cf13f88a8278306d1c86fcc1247aa23df", "patch": "@@ -0,0 +1,12 @@\n+// rustfmt-format_strings: true\n+// rustfmt-max_width: 50\n+\n+impl Foo {\n+    fn cxx(&self, target: &str) -> &Path {\n+        match self.cxx.get(target) {\n+            Some(p) => p.path(),\n+            None => panic!(\"\\ntarget `{}`: is not, configured as a host,\n+                            only as a target\\n\\n\", target),\n+        }\n+    }\n+}"}, {"sha": "c080cef950b3dbcca438e9b7d14649c73ab5a674", "filename": "tests/source/issue-1210/c.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/48c3e46cf13f88a8278306d1c86fcc1247aa23df/tests%2Fsource%2Fissue-1210%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48c3e46cf13f88a8278306d1c86fcc1247aa23df/tests%2Fsource%2Fissue-1210%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fissue-1210%2Fc.rs?ref=48c3e46cf13f88a8278306d1c86fcc1247aa23df", "patch": "@@ -0,0 +1,5 @@\n+// rustfmt-format_strings: true\n+// rustfmt-max_width: 50\n+\n+const foo: String = \"trailing_spaces!!            \n+                keep them! Amet neque. Praesent rhoncus eros non velit.\";"}, {"sha": "783736bc3b2c5352dc9d8eca01ce0ef0d367db31", "filename": "tests/source/issue-1210/d.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/48c3e46cf13f88a8278306d1c86fcc1247aa23df/tests%2Fsource%2Fissue-1210%2Fd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48c3e46cf13f88a8278306d1c86fcc1247aa23df/tests%2Fsource%2Fissue-1210%2Fd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fissue-1210%2Fd.rs?ref=48c3e46cf13f88a8278306d1c86fcc1247aa23df", "patch": "@@ -0,0 +1,4 @@\n+// rustfmt-wrap_comments: true\n+\n+// trailing_spaces_in_comment!!                   \n+//                remove those from above"}, {"sha": "9abada1d6d86f4490d9aafafa52ea21f2fcba025", "filename": "tests/source/issue-1210/e.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/48c3e46cf13f88a8278306d1c86fcc1247aa23df/tests%2Fsource%2Fissue-1210%2Fe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48c3e46cf13f88a8278306d1c86fcc1247aa23df/tests%2Fsource%2Fissue-1210%2Fe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fissue-1210%2Fe.rs?ref=48c3e46cf13f88a8278306d1c86fcc1247aa23df", "patch": "@@ -0,0 +1,8 @@\n+// rustfmt-format_strings: true\n+// rustfmt-max_width: 50\n+\n+// explicit line breaks should be kept in order to preserve the layout\n+\n+const foo: String = \"Suspendisse vel augue at felis tincidunt sollicitudin. Fusce arcu.\n+               Duis et odio et leo\n+        sollicitudin consequat. Aliquam lobortis.  Phasellus condimentum.\";"}, {"sha": "94c1b44e5e56d0e851f9c42ebb93a199874717b0", "filename": "tests/target/issue-1210/a.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/48c3e46cf13f88a8278306d1c86fcc1247aa23df/tests%2Ftarget%2Fissue-1210%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48c3e46cf13f88a8278306d1c86fcc1247aa23df/tests%2Ftarget%2Fissue-1210%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-1210%2Fa.rs?ref=48c3e46cf13f88a8278306d1c86fcc1247aa23df", "patch": "@@ -0,0 +1,16 @@\n+// rustfmt-format_strings: true\n+// rustfmt-max_width: 50\n+\n+impl Foo {\n+    fn cxx(&self, target: &str) -> &Path {\n+        match self.cxx.get(target) {\n+            Some(p) => p.path(),\n+            None => panic!(\n+                \"\\n\\ntarget `{}` is not \\\n+                 configured as a host,\n+                            only as a target\\n\\n\",\n+                target\n+            ),\n+        }\n+    }\n+}"}, {"sha": "a7b1e3bcdc893d4f2d1049e0c1c3de8604193282", "filename": "tests/target/issue-1210/b.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/48c3e46cf13f88a8278306d1c86fcc1247aa23df/tests%2Ftarget%2Fissue-1210%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48c3e46cf13f88a8278306d1c86fcc1247aa23df/tests%2Ftarget%2Fissue-1210%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-1210%2Fb.rs?ref=48c3e46cf13f88a8278306d1c86fcc1247aa23df", "patch": "@@ -0,0 +1,16 @@\n+// rustfmt-format_strings: true\n+// rustfmt-max_width: 50\n+\n+impl Foo {\n+    fn cxx(&self, target: &str) -> &Path {\n+        match self.cxx.get(target) {\n+            Some(p) => p.path(),\n+            None => panic!(\n+                \"\\ntarget `{}`: is not, \\\n+                 configured as a host,\n+                            only as a target\\n\\n\",\n+                target\n+            ),\n+        }\n+    }\n+}"}, {"sha": "183d79f925860e41314bab14d3af01454eea3b53", "filename": "tests/target/issue-1210/c.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/48c3e46cf13f88a8278306d1c86fcc1247aa23df/tests%2Ftarget%2Fissue-1210%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48c3e46cf13f88a8278306d1c86fcc1247aa23df/tests%2Ftarget%2Fissue-1210%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-1210%2Fc.rs?ref=48c3e46cf13f88a8278306d1c86fcc1247aa23df", "patch": "@@ -0,0 +1,7 @@\n+// rustfmt-format_strings: true\n+// rustfmt-max_width: 50\n+\n+const foo: String =\n+    \"trailing_spaces!!            \n+                keep them! Amet neque. Praesent \\\n+     rhoncus eros non velit.\";"}, {"sha": "9279e6fc9990b9e62615f3bb6580548f51b87e11", "filename": "tests/target/issue-1210/d.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/48c3e46cf13f88a8278306d1c86fcc1247aa23df/tests%2Ftarget%2Fissue-1210%2Fd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48c3e46cf13f88a8278306d1c86fcc1247aa23df/tests%2Ftarget%2Fissue-1210%2Fd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-1210%2Fd.rs?ref=48c3e46cf13f88a8278306d1c86fcc1247aa23df", "patch": "@@ -0,0 +1,4 @@\n+// rustfmt-wrap_comments: true\n+\n+// trailing_spaces_in_comment!!\n+//                remove those from above"}, {"sha": "55f80c6c3cc24eaf94922cc66cda472fd72ee318", "filename": "tests/target/issue-1210/e.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/48c3e46cf13f88a8278306d1c86fcc1247aa23df/tests%2Ftarget%2Fissue-1210%2Fe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48c3e46cf13f88a8278306d1c86fcc1247aa23df/tests%2Ftarget%2Fissue-1210%2Fe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-1210%2Fe.rs?ref=48c3e46cf13f88a8278306d1c86fcc1247aa23df", "patch": "@@ -0,0 +1,11 @@\n+// rustfmt-format_strings: true\n+// rustfmt-max_width: 50\n+\n+// explicit line breaks should be kept in order to preserve the layout\n+\n+const foo: String =\n+    \"Suspendisse vel augue at felis tincidunt \\\n+     sollicitudin. Fusce arcu.\n+               Duis et odio et leo\n+        sollicitudin consequat. Aliquam \\\n+     lobortis.  Phasellus condimentum.\";"}]}