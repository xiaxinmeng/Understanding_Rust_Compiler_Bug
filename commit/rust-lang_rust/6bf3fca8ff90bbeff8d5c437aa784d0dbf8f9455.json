{"sha": "6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiZjNmY2E4ZmY5MGJiZWZmOGQ1YzQzN2FhNzg0ZDBkYmY4Zjk0NTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-25T01:11:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-25T01:11:51Z"}, "message": "auto merge of #12900 : alexcrichton/rust/rewrite-sync, r=brson\n\n* Remove clone-ability from all primitives. All shared state will now come\r\n  from the usage of the primitives being shared, not the primitives being\r\n  inherently shareable. This allows for fewer allocations for stack-allocated\r\n  primitives.\r\n* Add `Mutex<T>` and `RWLock<T>` which are stack-allocated primitives for purely\r\n  wrapping a piece of data\r\n* Remove `RWArc<T>` in favor of `Arc<RWLock<T>>`\r\n* Remove `MutexArc<T>` in favor of `Arc<Mutex<T>>`\r\n* Shuffle around where things are located\r\n  * The `arc` module now only contains `Arc`\r\n  * A new `lock` module contains `Mutex`, `RWLock`, and `Barrier`\r\n  * A new `raw` module contains the primitive implementations of `Semaphore`,\r\n    `Mutex`, and `RWLock`\r\n* The Deref/DerefMut trait was implemented where appropriate\r\n* `CowArc` was removed, the functionality is now part of `Arc` and is tagged\r\n  with `#[experimental]`.\r\n* The crate now has #[deny(missing_doc)]\r\n* `Arc` now supports weak pointers\r\n\r\nThis is not a large-scale rewrite of the functionality contained within the\r\n`sync` crate, but rather a shuffling of who does what an a thinner hierarchy of\r\nownership to allow for better composability.", "tree": {"sha": "7fe1f4e9c71ec942f54defdd4b1be123f212804f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7fe1f4e9c71ec942f54defdd4b1be123f212804f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "html_url": "https://github.com/rust-lang/rust/commit/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33", "html_url": "https://github.com/rust-lang/rust/commit/bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33"}, {"sha": "218461d01049242e3544337055b7f6d06943344b", "url": "https://api.github.com/repos/rust-lang/rust/commits/218461d01049242e3544337055b7f6d06943344b", "html_url": "https://github.com/rust-lang/rust/commit/218461d01049242e3544337055b7f6d06943344b"}], "stats": {"total": 3761, "additions": 1727, "deletions": 2034}, "files": [{"sha": "3dd29ff38d1d3da2a3f67ecd658e568d2e13b30d", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -12,7 +12,6 @@\n #[feature(phase)];\n \n #[allow(non_camel_case_types)];\n-#[allow(deprecated_owned_vector)]; // NOTE: remove after stage0\n #[deny(warnings)];\n \n extern crate test;"}, {"sha": "2ffa4529f0882cc8a280603068f8ba7b9ad6d442", "filename": "src/doc/guide-tasks.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Fdoc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Fdoc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-tasks.md?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -359,7 +359,7 @@ fn main() {\n \n         spawn(proc() {\n             let local_arc : Arc<~[f64]> = rx.recv();\n-            let task_numbers = local_arc.get();\n+            let task_numbers = &*local_arc;\n             println!(\"{}-norm = {}\", num, pnorm(task_numbers, num));\n         });\n     }\n@@ -411,7 +411,7 @@ Each task recovers the underlying data by\n # let (tx, rx) = channel();\n # tx.send(numbers_arc.clone());\n # let local_arc : Arc<~[f64]> = rx.recv();\n-let task_numbers = local_arc.get();\n+let task_numbers = &*local_arc;\n # }\n ~~~\n "}, {"sha": "ca462fc7a39226b9386b3775e0a5431248655949", "filename": "src/driver/driver.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fdriver.rs?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -14,9 +14,4 @@ extern crate this = \"rustdoc\";\n #[cfg(rustc)]\n extern crate this = \"rustc\";\n \n-#[cfg(not(stage0))]\n fn main() { this::main() }\n-\n-#[cfg(stage0)]\n-#[start]\n-fn start(argc: int, argv: **u8) -> int { native::start(argc, argv, this::main) }"}, {"sha": "3287aae80e3740785a86d9c5dc315e4cc229e9d1", "filename": "src/etc/licenseck.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Fetc%2Flicenseck.py", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Fetc%2Flicenseck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flicenseck.py?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -41,7 +41,7 @@\n     \"libstd/sync/mpsc_queue.rs\", # BSD\n     \"libstd/sync/spsc_queue.rs\", # BSD\n     \"libstd/sync/mpmc_bounded_queue.rs\", # BSD\n-    \"libsync/sync/mpsc_intrusive.rs\", # BSD\n+    \"libsync/mpsc_intrusive.rs\", # BSD\n ]\n \n def check_license(name, contents):"}, {"sha": "b9fb424cae818e80f23914eb474e3d863571fd5f", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -207,16 +207,6 @@ pub mod sleeper_list;\n pub mod stack;\n pub mod task;\n \n-#[lang = \"start\"]\n-#[cfg(not(test), stage0)]\n-pub fn lang_start(main: *u8, argc: int, argv: **u8) -> int {\n-    use std::cast;\n-    start(argc, argv, proc() {\n-        let main: extern \"Rust\" fn() = unsafe { cast::transmute(main) };\n-        main();\n-    })\n-}\n-\n /// Set up a default runtime configuration, given compiler-supplied arguments.\n ///\n /// This function will block until the entire pool of M:N schedulers have"}, {"sha": "01e620df2d675dda9e3bfc43b6c2bd4679816e62", "filename": "src/libgreen/simple.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibgreen%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibgreen%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsimple.rs?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -40,7 +40,7 @@ impl Runtime for SimpleTask {\n         // See libnative/task.rs for what's going on here with the `awoken`\n         // field and the while loop around wait()\n         unsafe {\n-            let mut guard = (*me).lock.lock();\n+            let guard = (*me).lock.lock();\n             (*me).awoken = false;\n             match f(task) {\n                 Ok(()) => {\n@@ -60,7 +60,7 @@ impl Runtime for SimpleTask {\n         to_wake.put_runtime(self as ~Runtime);\n         unsafe {\n             cast::forget(to_wake);\n-            let mut guard = (*me).lock.lock();\n+            let guard = (*me).lock.lock();\n             (*me).awoken = true;\n             guard.signal();\n         }"}, {"sha": "e5f70c4e4b31c81698bf18c72cb32305c7d24772", "filename": "src/libnative/io/timer_helper.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibnative%2Fio%2Ftimer_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibnative%2Fio%2Ftimer_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_helper.rs?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -75,7 +75,7 @@ pub fn send(req: Req) {\n fn shutdown() {\n     // Request a shutdown, and then wait for the task to exit\n     unsafe {\n-        let mut guard = TIMER_HELPER_EXIT.lock();\n+        let guard = TIMER_HELPER_EXIT.lock();\n         send(Shutdown);\n         guard.wait();\n         drop(guard);"}, {"sha": "34e85a9819a9a4c46069a42e6d58348b8e1218fc", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -69,7 +69,7 @@ static OS_DEFAULT_STACK_ESTIMATE: uint = 1 << 20;\n static OS_DEFAULT_STACK_ESTIMATE: uint = 2 * (1 << 20);\n \n #[lang = \"start\"]\n-#[cfg(not(test), not(stage0))]\n+#[cfg(not(test))]\n pub fn lang_start(main: *u8, argc: int, argv: **u8) -> int {\n     use std::cast;\n     start(argc, argv, proc() {"}, {"sha": "659e417b8ad4bfdf3f4a0d0bbb4a2c322a9595a0", "filename": "src/libnative/task.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -190,7 +190,7 @@ impl rt::Runtime for Ops {\n             let task = BlockedTask::block(cur_task);\n \n             if times == 1 {\n-                let mut guard = (*me).lock.lock();\n+                let guard = (*me).lock.lock();\n                 (*me).awoken = false;\n                 match f(task) {\n                     Ok(()) => {\n@@ -202,7 +202,7 @@ impl rt::Runtime for Ops {\n                 }\n             } else {\n                 let mut iter = task.make_selectable(times);\n-                let mut guard = (*me).lock.lock();\n+                let guard = (*me).lock.lock();\n                 (*me).awoken = false;\n                 let success = iter.all(|task| {\n                     match f(task) {\n@@ -232,7 +232,7 @@ impl rt::Runtime for Ops {\n             let me = &mut *self as *mut Ops;\n             to_wake.put_runtime(self as ~rt::Runtime);\n             cast::forget(to_wake);\n-            let mut guard = (*me).lock.lock();\n+            let guard = (*me).lock.lock();\n             (*me).awoken = true;\n             guard.signal();\n         }"}, {"sha": "acf6446a191f1ad7dc2166c9420d8c8c990d7e79", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -208,8 +208,8 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n         let loc = loc.unwrap();\n \n         local_data::get(cache_key, |cache| {\n-            let cache = cache.unwrap().get();\n-            let abs_root = root(cache, loc.as_slice());\n+            let cache = cache.unwrap();\n+            let abs_root = root(&**cache, loc.as_slice());\n             let rel_root = match path.segments.get(0).name.as_slice() {\n                 \"self\" => Some(~\"./\"),\n                 _ => None,\n@@ -241,7 +241,7 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n                 }\n             }\n \n-            match info(cache) {\n+            match info(&**cache) {\n                 // This is a documented path, link to it!\n                 Some((ref fqp, shortty)) if abs_root.is_some() => {\n                     let mut url = abs_root.unwrap();\n@@ -301,7 +301,7 @@ impl fmt::Show for clean::Type {\n         match *self {\n             clean::TyParamBinder(id) | clean::Generic(id) => {\n                 local_data::get(cache_key, |cache| {\n-                    let m = cache.unwrap().get();\n+                    let m = cache.unwrap();\n                     f.buf.write(m.typarams.get(&id).as_bytes())\n                 })\n             }"}, {"sha": "d2a34bc4e4a0de358644549945451982cf33bbd8", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -1265,7 +1265,7 @@ fn item_trait(w: &mut Writer, it: &clean::Item,\n     }\n \n     local_data::get(cache_key, |cache| {\n-        let cache = cache.unwrap().get();\n+        let cache = cache.unwrap();\n         match cache.implementors.find(&it.id) {\n             Some(implementors) => {\n                 try!(write!(w, \"\n@@ -1496,7 +1496,7 @@ fn render_struct(w: &mut Writer, it: &clean::Item,\n \n fn render_methods(w: &mut Writer, it: &clean::Item) -> fmt::Result {\n     local_data::get(cache_key, |cache| {\n-        let c = cache.unwrap().get();\n+        let c = cache.unwrap();\n         match c.impls.find(&it.id) {\n             Some(v) => {\n                 let mut non_trait = v.iter().filter(|p| {\n@@ -1576,7 +1576,7 @@ fn render_impl(w: &mut Writer, i: &clean::Impl,\n             Some(id) => id,\n         };\n         try!(local_data::get(cache_key, |cache| {\n-            let cache = cache.unwrap().get();\n+            let cache = cache.unwrap();\n             match cache.traits.find(&trait_id) {\n                 Some(t) => {\n                     let name = meth.name.clone();\n@@ -1606,7 +1606,7 @@ fn render_impl(w: &mut Writer, i: &clean::Impl,\n         None => {}\n         Some(id) => {\n             try!(local_data::get(cache_key, |cache| {\n-                let cache = cache.unwrap().get();\n+                let cache = cache.unwrap();\n                 match cache.traits.find(&id) {\n                     Some(t) => {\n                         for method in t.methods.iter() {"}, {"sha": "e8ba9d6e62809badaabe510e61a4d3024ee48dbb", "filename": "src/libstd/comm/shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibstd%2Fcomm%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibstd%2Fcomm%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fshared.rs?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -68,7 +68,7 @@ pub enum Failure {\n impl<T: Send> Packet<T> {\n     // Creation of a packet *must* be followed by a call to inherit_blocker\n     pub fn new() -> Packet<T> {\n-        let mut p = Packet {\n+        let p = Packet {\n             queue: mpsc::Queue::new(),\n             cnt: atomics::AtomicInt::new(0),\n             steals: 0,"}, {"sha": "55e7746a44ddcc44ea1d3812dc0d5db507774dff", "filename": "src/libstd/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibstd%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibstd%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fintrinsics.rs?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -164,7 +164,6 @@ pub trait TyVisitor {\n     fn visit_self(&mut self) -> bool;\n }\n \n-\n extern \"rust-intrinsic\" {\n \n     // NB: These intrinsics take unsafe pointers because they mutate aliased"}, {"sha": "932cd7af033d709b45c459c78ee36b4b42c774f1", "filename": "src/libstd/rt/bookkeeping.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibstd%2Frt%2Fbookkeeping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibstd%2Frt%2Fbookkeeping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbookkeeping.rs?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -34,7 +34,7 @@ pub fn increment() {\n pub fn decrement() {\n     unsafe {\n         if TASK_COUNT.fetch_sub(1, atomics::SeqCst) == 1 {\n-            let mut guard = TASK_LOCK.lock();\n+            let guard = TASK_LOCK.lock();\n             guard.signal();\n         }\n     }\n@@ -44,7 +44,7 @@ pub fn decrement() {\n /// the entry points of native programs\n pub fn wait_for_other_tasks() {\n     unsafe {\n-        let mut guard = TASK_LOCK.lock();\n+        let guard = TASK_LOCK.lock();\n         while TASK_COUNT.load(atomics::SeqCst) > 0 {\n             guard.wait();\n         }"}, {"sha": "d5f6fac2296e9238a71d011cb652ef7585717875", "filename": "src/libstd/sync/atomics.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibstd%2Fsync%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibstd%2Fsync%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fatomics.rs?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -39,8 +39,7 @@\n //!\n //! A simple spinlock:\n //!\n-//! ```ignore\n-//! # // FIXME: Needs PR #12430\n+//! ```\n //! extern crate sync;\n //!\n //! use sync::Arc;\n@@ -68,8 +67,7 @@\n //!\n //! Transferring a heap object with `AtomicOption`:\n //!\n-//! ```ignore\n-//! # // FIXME: Needs PR #12430\n+//! ```\n //! extern crate sync;\n //!\n //! use sync::Arc;"}, {"sha": "9802271e28f269cdba8e3ecaf1fd54d6ceff29e0", "filename": "src/libstd/unstable/mutex.rs", "status": "modified", "additions": 54, "deletions": 45, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibstd%2Funstable%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibstd%2Funstable%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmutex.rs?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -86,7 +86,7 @@ pub struct NativeMutex {\n /// then.\n #[must_use]\n pub struct LockGuard<'a> {\n-    priv lock: &'a mut StaticNativeMutex\n+    priv lock: &'a StaticNativeMutex\n }\n \n pub static NATIVE_MUTEX_INIT: StaticNativeMutex = StaticNativeMutex {\n@@ -106,6 +106,7 @@ impl StaticNativeMutex {\n     /// already hold the lock.\n     ///\n     /// # Example\n+    ///\n     /// ```rust\n     /// use std::unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n     /// static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n@@ -114,15 +115,15 @@ impl StaticNativeMutex {\n     ///     // critical section...\n     /// } // automatically unlocked in `_guard`'s destructor\n     /// ```\n-    pub unsafe fn lock<'a>(&'a mut self) -> LockGuard<'a> {\n+    pub unsafe fn lock<'a>(&'a self) -> LockGuard<'a> {\n         self.inner.lock();\n \n         LockGuard { lock: self }\n     }\n \n     /// Attempts to acquire the lock. The value returned is `Some` if\n     /// the attempt succeeded.\n-    pub unsafe fn trylock<'a>(&'a mut self) -> Option<LockGuard<'a>> {\n+    pub unsafe fn trylock<'a>(&'a self) -> Option<LockGuard<'a>> {\n         if self.inner.trylock() {\n             Some(LockGuard { lock: self })\n         } else {\n@@ -134,36 +135,36 @@ impl StaticNativeMutex {\n     ///\n     /// These needs to be paired with a call to `.unlock_noguard`. Prefer using\n     /// `.lock`.\n-    pub unsafe fn lock_noguard(&mut self) { self.inner.lock() }\n+    pub unsafe fn lock_noguard(&self) { self.inner.lock() }\n \n     /// Attempts to acquire the lock without creating a\n     /// `LockGuard`. The value returned is whether the lock was\n     /// acquired or not.\n     ///\n     /// If `true` is returned, this needs to be paired with a call to\n     /// `.unlock_noguard`. Prefer using `.trylock`.\n-    pub unsafe fn trylock_noguard(&mut self) -> bool {\n+    pub unsafe fn trylock_noguard(&self) -> bool {\n         self.inner.trylock()\n     }\n \n     /// Unlocks the lock. This assumes that the current thread already holds the\n     /// lock.\n-    pub unsafe fn unlock_noguard(&mut self) { self.inner.unlock() }\n+    pub unsafe fn unlock_noguard(&self) { self.inner.unlock() }\n \n     /// Block on the internal condition variable.\n     ///\n     /// This function assumes that the lock is already held. Prefer\n     /// using `LockGuard.wait` since that guarantees that the lock is\n     /// held.\n-    pub unsafe fn wait_noguard(&mut self) { self.inner.wait() }\n+    pub unsafe fn wait_noguard(&self) { self.inner.wait() }\n \n     /// Signals a thread in `wait` to wake up\n-    pub unsafe fn signal_noguard(&mut self) { self.inner.signal() }\n+    pub unsafe fn signal_noguard(&self) { self.inner.signal() }\n \n     /// This function is especially unsafe because there are no guarantees made\n     /// that no other thread is currently holding the lock or waiting on the\n     /// condition variable contained inside.\n-    pub unsafe fn destroy(&mut self) { self.inner.destroy() }\n+    pub unsafe fn destroy(&self) { self.inner.destroy() }\n }\n \n impl NativeMutex {\n@@ -190,45 +191,45 @@ impl NativeMutex {\n     ///     } // automatically unlocked in `_guard`'s destructor\n     /// }\n     /// ```\n-    pub unsafe fn lock<'a>(&'a mut self) -> LockGuard<'a> {\n+    pub unsafe fn lock<'a>(&'a self) -> LockGuard<'a> {\n         self.inner.lock()\n     }\n \n     /// Attempts to acquire the lock. The value returned is `Some` if\n     /// the attempt succeeded.\n-    pub unsafe fn trylock<'a>(&'a mut self) -> Option<LockGuard<'a>> {\n+    pub unsafe fn trylock<'a>(&'a self) -> Option<LockGuard<'a>> {\n         self.inner.trylock()\n     }\n \n     /// Acquire the lock without creating a `LockGuard`.\n     ///\n     /// These needs to be paired with a call to `.unlock_noguard`. Prefer using\n     /// `.lock`.\n-    pub unsafe fn lock_noguard(&mut self) { self.inner.lock_noguard() }\n+    pub unsafe fn lock_noguard(&self) { self.inner.lock_noguard() }\n \n     /// Attempts to acquire the lock without creating a\n     /// `LockGuard`. The value returned is whether the lock was\n     /// acquired or not.\n     ///\n     /// If `true` is returned, this needs to be paired with a call to\n     /// `.unlock_noguard`. Prefer using `.trylock`.\n-    pub unsafe fn trylock_noguard(&mut self) -> bool {\n+    pub unsafe fn trylock_noguard(&self) -> bool {\n         self.inner.trylock_noguard()\n     }\n \n     /// Unlocks the lock. This assumes that the current thread already holds the\n     /// lock.\n-    pub unsafe fn unlock_noguard(&mut self) { self.inner.unlock_noguard() }\n+    pub unsafe fn unlock_noguard(&self) { self.inner.unlock_noguard() }\n \n     /// Block on the internal condition variable.\n     ///\n     /// This function assumes that the lock is already held. Prefer\n     /// using `LockGuard.wait` since that guarantees that the lock is\n     /// held.\n-    pub unsafe fn wait_noguard(&mut self) { self.inner.wait_noguard() }\n+    pub unsafe fn wait_noguard(&self) { self.inner.wait_noguard() }\n \n     /// Signals a thread in `wait` to wake up\n-    pub unsafe fn signal_noguard(&mut self) { self.inner.signal_noguard() }\n+    pub unsafe fn signal_noguard(&self) { self.inner.signal_noguard() }\n }\n \n impl Drop for NativeMutex {\n@@ -239,12 +240,12 @@ impl Drop for NativeMutex {\n \n impl<'a> LockGuard<'a> {\n     /// Block on the internal condition variable.\n-    pub unsafe fn wait(&mut self) {\n+    pub unsafe fn wait(&self) {\n         self.lock.wait_noguard()\n     }\n \n     /// Signals a thread in `wait` to wake up.\n-    pub unsafe fn signal(&mut self) {\n+    pub unsafe fn signal(&self) {\n         self.lock.signal_noguard()\n     }\n }\n@@ -262,6 +263,8 @@ mod imp {\n     use self::os::{PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER,\n                    pthread_mutex_t, pthread_cond_t};\n     use mem;\n+    use ty::Unsafe;\n+    use kinds::marker;\n \n     type pthread_mutexattr_t = libc::c_void;\n     type pthread_condattr_t = libc::c_void;\n@@ -369,40 +372,46 @@ mod imp {\n     }\n \n     pub struct Mutex {\n-        priv lock: pthread_mutex_t,\n-        priv cond: pthread_cond_t,\n+        priv lock: Unsafe<pthread_mutex_t>,\n+        priv cond: Unsafe<pthread_cond_t>,\n     }\n \n     pub static MUTEX_INIT: Mutex = Mutex {\n-        lock: PTHREAD_MUTEX_INITIALIZER,\n-        cond: PTHREAD_COND_INITIALIZER,\n+        lock: Unsafe {\n+            value: PTHREAD_MUTEX_INITIALIZER,\n+            marker1: marker::InvariantType,\n+        },\n+        cond: Unsafe {\n+            value: PTHREAD_COND_INITIALIZER,\n+            marker1: marker::InvariantType,\n+        },\n     };\n \n     impl Mutex {\n         pub unsafe fn new() -> Mutex {\n-            let mut m = Mutex {\n-                lock: mem::init(),\n-                cond: mem::init(),\n+            let m = Mutex {\n+                lock: Unsafe::new(mem::init()),\n+                cond: Unsafe::new(mem::init()),\n             };\n \n-            pthread_mutex_init(&mut m.lock, 0 as *libc::c_void);\n-            pthread_cond_init(&mut m.cond, 0 as *libc::c_void);\n+            pthread_mutex_init(m.lock.get(), 0 as *libc::c_void);\n+            pthread_cond_init(m.cond.get(), 0 as *libc::c_void);\n \n             return m;\n         }\n \n-        pub unsafe fn lock(&mut self) { pthread_mutex_lock(&mut self.lock); }\n-        pub unsafe fn unlock(&mut self) { pthread_mutex_unlock(&mut self.lock); }\n-        pub unsafe fn signal(&mut self) { pthread_cond_signal(&mut self.cond); }\n-        pub unsafe fn wait(&mut self) {\n-            pthread_cond_wait(&mut self.cond, &mut self.lock);\n+        pub unsafe fn lock(&self) { pthread_mutex_lock(self.lock.get()); }\n+        pub unsafe fn unlock(&self) { pthread_mutex_unlock(self.lock.get()); }\n+        pub unsafe fn signal(&self) { pthread_cond_signal(self.cond.get()); }\n+        pub unsafe fn wait(&self) {\n+            pthread_cond_wait(self.cond.get(), self.lock.get());\n         }\n-        pub unsafe fn trylock(&mut self) -> bool {\n-            pthread_mutex_trylock(&mut self.lock) == 0\n+        pub unsafe fn trylock(&self) -> bool {\n+            pthread_mutex_trylock(self.lock.get()) == 0\n         }\n-        pub unsafe fn destroy(&mut self) {\n-            pthread_mutex_destroy(&mut self.lock);\n-            pthread_cond_destroy(&mut self.cond);\n+        pub unsafe fn destroy(&self) {\n+            pthread_mutex_destroy(self.lock.get());\n+            pthread_cond_destroy(self.cond.get());\n         }\n     }\n \n@@ -454,37 +463,37 @@ mod imp {\n                 cond: atomics::AtomicUint::new(init_cond()),\n             }\n         }\n-        pub unsafe fn lock(&mut self) {\n+        pub unsafe fn lock(&self) {\n             EnterCriticalSection(self.getlock() as LPCRITICAL_SECTION)\n         }\n-        pub unsafe fn trylock(&mut self) -> bool {\n+        pub unsafe fn trylock(&self) -> bool {\n             TryEnterCriticalSection(self.getlock() as LPCRITICAL_SECTION) != 0\n         }\n-        pub unsafe fn unlock(&mut self) {\n+        pub unsafe fn unlock(&self) {\n             LeaveCriticalSection(self.getlock() as LPCRITICAL_SECTION)\n         }\n \n-        pub unsafe fn wait(&mut self) {\n+        pub unsafe fn wait(&self) {\n             self.unlock();\n             WaitForSingleObject(self.getcond() as HANDLE, libc::INFINITE);\n             self.lock();\n         }\n \n-        pub unsafe fn signal(&mut self) {\n+        pub unsafe fn signal(&self) {\n             assert!(SetEvent(self.getcond() as HANDLE) != 0);\n         }\n \n         /// This function is especially unsafe because there are no guarantees made\n         /// that no other thread is currently holding the lock or waiting on the\n         /// condition variable contained inside.\n-        pub unsafe fn destroy(&mut self) {\n+        pub unsafe fn destroy(&self) {\n             let lock = self.lock.swap(0, atomics::SeqCst);\n             let cond = self.cond.swap(0, atomics::SeqCst);\n             if lock != 0 { free_lock(lock) }\n             if cond != 0 { free_cond(cond) }\n         }\n \n-        unsafe fn getlock(&mut self) -> *mut c_void {\n+        unsafe fn getlock(&self) -> *mut c_void {\n             match self.lock.load(atomics::SeqCst) {\n                 0 => {}\n                 n => return n as *mut c_void\n@@ -498,7 +507,7 @@ mod imp {\n             return self.lock.load(atomics::SeqCst) as *mut c_void;\n         }\n \n-        unsafe fn getcond(&mut self) -> *mut c_void {\n+        unsafe fn getcond(&self) -> *mut c_void {\n             match self.cond.load(atomics::SeqCst) {\n                 0 => {}\n                 n => return n as *mut c_void"}, {"sha": "367967b8e675879f10b7bdf03ab95d942a49e528", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -79,7 +79,7 @@ impl<T:Send> Exclusive<T> {\n     #[inline]\n     pub unsafe fn hold_and_signal(&self, f: |x: &mut T|) {\n         let rec = self.x.get();\n-        let mut guard = (*rec).lock.lock();\n+        let guard = (*rec).lock.lock();\n         if (*rec).failed {\n             fail!(\"Poisoned Exclusive::new - another task failed inside!\");\n         }\n@@ -92,7 +92,7 @@ impl<T:Send> Exclusive<T> {\n     #[inline]\n     pub unsafe fn hold_and_wait(&self, f: |x: &T| -> bool) {\n         let rec = self.x.get();\n-        let mut l = (*rec).lock.lock();\n+        let l = (*rec).lock.lock();\n         if (*rec).failed {\n             fail!(\"Poisoned Exclusive::new - another task failed inside!\");\n         }"}, {"sha": "28841b780a482cfb3aa014c209c31f55ac411566", "filename": "src/libsync/arc.rs", "status": "modified", "additions": 239, "deletions": 929, "changes": 1168, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibsync%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibsync%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Farc.rs?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -11,571 +11,247 @@\n /*!\n  * Concurrency-enabled mechanisms for sharing mutable and/or immutable state\n  * between tasks.\n- *\n- * # Example\n- *\n- * In this example, a large vector of floats is shared between several tasks.\n- * With simple pipes, without Arc, a copy would have to be made for each task.\n- *\n- * ```rust\n- * extern crate sync;\n- * extern crate rand;\n- *\n- * use std::slice;\n- * use sync::Arc;\n- *\n- * fn main() {\n- *     let numbers = slice::from_fn(100, |i| (i as f32) * rand::random());\n- *     let shared_numbers = Arc::new(numbers);\n- *\n- *     for _ in range(0, 10) {\n- *         let (tx, rx) = channel();\n- *         tx.send(shared_numbers.clone());\n- *\n- *         spawn(proc() {\n- *             let shared_numbers = rx.recv();\n- *             let local_numbers = shared_numbers.get();\n- *\n- *             // Work with the local numbers\n- *         });\n- *     }\n- * }\n- * ```\n  */\n \n-#[allow(missing_doc, dead_code)];\n-\n-\n-use sync;\n-use sync::{Mutex, RWLock};\n-\n use std::cast;\n-use std::kinds::{Share, marker};\n-use std::sync::arc::UnsafeArc;\n-use std::task;\n-\n-/// As sync::condvar, a mechanism for unlock-and-descheduling and\n-/// signaling, for use with the Arc types.\n-pub struct ArcCondvar<'a> {\n-    priv is_mutex: bool,\n-    priv failed: &'a bool,\n-    priv cond: &'a sync::Condvar<'a>\n+use std::ptr;\n+use std::rt::global_heap;\n+use std::sync::atomics;\n+\n+/// An atomically reference counted wrapper for shared state.\n+///\n+/// # Example\n+///\n+/// In this example, a large vector of floats is shared between several tasks.\n+/// With simple pipes, without `Arc`, a copy would have to be made for each\n+/// task.\n+///\n+/// ```rust\n+/// use sync::Arc;\n+///\n+/// fn main() {\n+///     let numbers = Vec::from_fn(100, |i| i as f32);\n+///     let shared_numbers = Arc::new(numbers);\n+///\n+///     for _ in range(0, 10) {\n+///         let child_numbers = shared_numbers.clone();\n+///\n+///         spawn(proc() {\n+///             let local_numbers = child_numbers.as_slice();\n+///\n+///             // Work with the local numbers\n+///         });\n+///     }\n+/// }\n+/// ```\n+#[unsafe_no_drop_flag]\n+pub struct Arc<T> {\n+    priv x: *mut ArcInner<T>,\n }\n \n-impl<'a> ArcCondvar<'a> {\n-    /// Atomically exit the associated Arc and block until a signal is sent.\n-    #[inline]\n-    pub fn wait(&self) { self.wait_on(0) }\n-\n-    /**\n-     * Atomically exit the associated Arc and block on a specified condvar\n-     * until a signal is sent on that same condvar (as sync::cond.wait_on).\n-     *\n-     * wait() is equivalent to wait_on(0).\n-     */\n-    #[inline]\n-    pub fn wait_on(&self, condvar_id: uint) {\n-        assert!(!*self.failed);\n-        self.cond.wait_on(condvar_id);\n-        // This is why we need to wrap sync::condvar.\n-        check_poison(self.is_mutex, *self.failed);\n-    }\n-\n-    /// Wake up a blocked task. Returns false if there was no blocked task.\n-    #[inline]\n-    pub fn signal(&self) -> bool { self.signal_on(0) }\n-\n-    /**\n-     * Wake up a blocked task on a specified condvar (as\n-     * sync::cond.signal_on). Returns false if there was no blocked task.\n-     */\n-    #[inline]\n-    pub fn signal_on(&self, condvar_id: uint) -> bool {\n-        assert!(!*self.failed);\n-        self.cond.signal_on(condvar_id)\n-    }\n-\n-    /// Wake up all blocked tasks. Returns the number of tasks woken.\n-    #[inline]\n-    pub fn broadcast(&self) -> uint { self.broadcast_on(0) }\n-\n-    /**\n-     * Wake up all blocked tasks on a specified condvar (as\n-     * sync::cond.broadcast_on). Returns the number of tasks woken.\n-     */\n-    #[inline]\n-    pub fn broadcast_on(&self, condvar_id: uint) -> uint {\n-        assert!(!*self.failed);\n-        self.cond.broadcast_on(condvar_id)\n-    }\n+/// A weak pointer to an `Arc`.\n+///\n+/// Weak pointers will not keep the data inside of the `Arc` alive, and can be\n+/// used to break cycles between `Arc` pointers.\n+#[unsafe_no_drop_flag]\n+pub struct Weak<T> {\n+    priv x: *mut ArcInner<T>,\n }\n \n-/****************************************************************************\n- * Immutable Arc\n- ****************************************************************************/\n-\n-/// An atomically reference counted wrapper for shared immutable state.\n-pub struct Arc<T> { priv x: UnsafeArc<T> }\n-\n+struct ArcInner<T> {\n+    strong: atomics::AtomicUint,\n+    weak: atomics::AtomicUint,\n+    data: T,\n+}\n \n-/**\n- * Access the underlying data in an atomically reference counted\n- * wrapper.\n- */\n impl<T: Share + Send> Arc<T> {\n     /// Create an atomically reference counted wrapper.\n     #[inline]\n     pub fn new(data: T) -> Arc<T> {\n-        Arc { x: UnsafeArc::new(data) }\n+        // Start the weak pointer count as 1 which is the weak pointer that's\n+        // held by all the strong pointers (kinda), see std/rc.rs for more info\n+        let x = ~ArcInner {\n+            strong: atomics::AtomicUint::new(1),\n+            weak: atomics::AtomicUint::new(1),\n+            data: data,\n+        };\n+        Arc { x: unsafe { cast::transmute(x) } }\n     }\n \n     #[inline]\n-    pub fn get<'a>(&'a self) -> &'a T {\n-        unsafe { &*self.x.get_immut() }\n+    fn inner<'a>(&'a self) -> &'a ArcInner<T> {\n+        // This unsafety is ok because while this arc is alive we're guaranteed\n+        // that the inner pointer is valid. Furthermore, we know that the\n+        // `ArcInner` structure itself is `Share` because the inner data is\n+        // `Share` as well, so we're ok loaning out an immutable pointer to\n+        // these contents.\n+        unsafe { &*self.x }\n+    }\n+\n+    /// Downgrades a strong pointer to a weak pointer\n+    ///\n+    /// Weak pointers will not keep the data alive. Once all strong references\n+    /// to the underlying data have been dropped, the data itself will be\n+    /// destroyed.\n+    pub fn downgrade(&self) -> Weak<T> {\n+        // See the clone() impl for why this is relaxed\n+        self.inner().weak.fetch_add(1, atomics::Relaxed);\n+        Weak { x: self.x }\n     }\n }\n \n impl<T: Share + Send> Clone for Arc<T> {\n-    /**\n-    * Duplicate an atomically reference counted wrapper.\n-    *\n-    * The resulting two `arc` objects will point to the same underlying data\n-    * object. However, one of the `arc` objects can be sent to another task,\n-    * allowing them to share the underlying data.\n-    */\n+    /// Duplicate an atomically reference counted wrapper.\n+    ///\n+    /// The resulting two `Arc` objects will point to the same underlying data\n+    /// object. However, one of the `Arc` objects can be sent to another task,\n+    /// allowing them to share the underlying data.\n     #[inline]\n     fn clone(&self) -> Arc<T> {\n-        Arc { x: self.x.clone() }\n+        // Using a relaxed ordering is alright here, as knowledge of the\n+        // original reference prevents other threads from erroneously deleting\n+        // the object.\n+        //\n+        // As explained in the [Boost documentation][1], Increasing the\n+        // reference counter can always be done with memory_order_relaxed: New\n+        // references to an object can only be formed from an existing\n+        // reference, and passing an existing reference from one thread to\n+        // another must already provide any required synchronization.\n+        //\n+        // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n+        self.inner().strong.fetch_add(1, atomics::Relaxed);\n+        Arc { x: self.x }\n     }\n }\n \n-/****************************************************************************\n- * Mutex protected Arc (unsafe)\n- ****************************************************************************/\n-\n-#[doc(hidden)]\n-struct MutexArcInner<T> { lock: Mutex, failed: bool, data: T }\n-\n-/// An Arc with mutable data protected by a blocking mutex.\n-pub struct MutexArc<T> {\n-    priv x: UnsafeArc<MutexArcInner<T>>,\n-}\n-\n-impl<T:Send> Clone for MutexArc<T> {\n-    /// Duplicate a mutex-protected Arc. See arc::clone for more details.\n+// FIXME(#13042): this should have T: Send, and use self.inner()\n+impl<T> Deref<T> for Arc<T> {\n     #[inline]\n-    fn clone(&self) -> MutexArc<T> {\n-        // NB: Cloning the underlying mutex is not necessary. Its reference\n-        // count would be exactly the same as the shared state's.\n-        MutexArc { x: self.x.clone() }\n+    fn deref<'a>(&'a self) -> &'a T {\n+        let inner = unsafe { &*self.x };\n+        &inner.data\n     }\n }\n \n-impl<T:Send> MutexArc<T> {\n-    /// Create a mutex-protected Arc with the supplied data.\n-    pub fn new(user_data: T) -> MutexArc<T> {\n-        MutexArc::new_with_condvars(user_data, 1)\n-    }\n-\n-    /**\n-     * Create a mutex-protected Arc with the supplied data and a specified number\n-     * of condvars (as sync::Mutex::new_with_condvars).\n-     */\n-    pub fn new_with_condvars(user_data: T, num_condvars: uint) -> MutexArc<T> {\n-        let data = MutexArcInner {\n-            lock: Mutex::new_with_condvars(num_condvars),\n-            failed: false, data: user_data\n-        };\n-        MutexArc { x: UnsafeArc::new(data) }\n-    }\n-\n-    /**\n-     * Access the underlying mutable data with mutual exclusion from other\n-     * tasks. The argument closure will be run with the mutex locked; all\n-     * other tasks wishing to access the data will block until the closure\n-     * finishes running.\n-     *\n-     * If you wish to nest MutexArcs, one strategy for ensuring safety at\n-     * runtime is to add a \"nesting level counter\" inside the stored data, and\n-     * when traversing the arcs, assert that they monotonically decrease.\n-     *\n-     * # Failure\n-     *\n-     * Failing while inside the Arc will unlock the Arc while unwinding, so\n-     * that other tasks won't block forever. It will also poison the Arc:\n-     * any tasks that subsequently try to access it (including those already\n-     * blocked on the mutex) will also fail immediately.\n-     */\n-    #[inline]\n-    pub fn access<U>(&self, blk: |x: &mut T| -> U) -> U {\n-        let state = self.x.get();\n-        unsafe {\n-            // Borrowck would complain about this if the code were\n-            // not already unsafe. See borrow_rwlock, far below.\n-            (&(*state).lock).lock(|| {\n-                check_poison(true, (*state).failed);\n-                let _z = PoisonOnFail::new(&mut (*state).failed);\n-                blk(&mut (*state).data)\n-            })\n-        }\n-    }\n-\n-    /// As access(), but with a condvar, as sync::mutex.lock_cond().\n+impl<T: Send + Share + Clone> Arc<T> {\n+    /// Acquires a mutable pointer to the inner contents by guaranteeing that\n+    /// the reference count is one (no sharing is possible).\n+    ///\n+    /// This is also referred to as a copy-on-write operation because the inner\n+    /// data is cloned if the reference count is greater than one.\n     #[inline]\n-    pub fn access_cond<U>(&self, blk: |x: &mut T, c: &ArcCondvar| -> U) -> U {\n-        let state = self.x.get();\n-        unsafe {\n-            (&(*state).lock).lock_cond(|cond| {\n-                check_poison(true, (*state).failed);\n-                let _z = PoisonOnFail::new(&mut (*state).failed);\n-                blk(&mut (*state).data,\n-                    &ArcCondvar {is_mutex: true,\n-                            failed: &(*state).failed,\n-                            cond: cond })\n-            })\n-        }\n-    }\n-}\n-\n-// Common code for {mutex.access,rwlock.write}{,_cond}.\n-#[inline]\n-#[doc(hidden)]\n-fn check_poison(is_mutex: bool, failed: bool) {\n-    if failed {\n-        if is_mutex {\n-            fail!(\"Poisoned MutexArc - another task failed inside!\");\n-        } else {\n-            fail!(\"Poisoned rw_arc - another task failed inside!\");\n+    #[experimental]\n+    pub fn make_unique<'a>(&'a mut self) -> &'a mut T {\n+        if self.inner().strong.load(atomics::SeqCst) != 1 {\n+            *self = Arc::new(self.deref().clone())\n         }\n+        // This unsafety is ok because we're guaranteed that the pointer\n+        // returned is the *only* pointer that will ever be returned to T. Our\n+        // reference count is guaranteed to be 1 at this point, and we required\n+        // the Arc itself to be `mut`, so we're returning the only possible\n+        // reference to the inner data.\n+        unsafe { cast::transmute_mut(self.deref()) }\n     }\n }\n \n-#[doc(hidden)]\n-struct PoisonOnFail {\n-    flag: *mut bool,\n-    failed: bool,\n-}\n-\n-impl Drop for PoisonOnFail {\n+#[unsafe_destructor]\n+impl<T: Share + Send> Drop for Arc<T> {\n     fn drop(&mut self) {\n-        unsafe {\n-            /* assert!(!*self.failed);\n-               -- might be false in case of cond.wait() */\n-            if !self.failed && task::failing() {\n-                *self.flag = true;\n-            }\n+        // This structure has #[unsafe_no_drop_flag], so this drop glue may run\n+        // more than once (but it is guaranteed to be zeroed after the first if\n+        // it's run more than once)\n+        if self.x.is_null() { return }\n+\n+        // Because `fetch_sub` is already atomic, we do not need to synchronize\n+        // with other threads unless we are going to delete the object. This\n+        // same logic applies to the below `fetch_sub` to the `weak` count.\n+        if self.inner().strong.fetch_sub(1, atomics::Release) != 0 { return }\n+\n+        // This fence is needed to prevent reordering of use of the data and\n+        // deletion of the data. Because it is marked `Release`, the\n+        // decreasing of the reference count sychronizes with this `Acquire`\n+        // fence. This means that use of the data happens before decreasing\n+        // the refernce count, which happens before this fence, which\n+        // happens before the deletion of the data.\n+        //\n+        // As explained in the [Boost documentation][1],\n+        //\n+        // It is important to enforce any possible access to the object in\n+        // one thread (through an existing reference) to *happen before*\n+        // deleting the object in a different thread. This is achieved by a\n+        // \"release\" operation after dropping a reference (any access to the\n+        // object through this reference must obviously happened before),\n+        // and an \"acquire\" operation before deleting the object.\n+        //\n+        // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n+        atomics::fence(atomics::Acquire);\n+\n+        // Destroy the data at this time, even though we may not free the box\n+        // allocation itself (there may still be weak pointers lying around).\n+        unsafe { drop(ptr::read(&self.inner().data)); }\n+\n+        if self.inner().weak.fetch_sub(1, atomics::Release) == 0 {\n+            atomics::fence(atomics::Acquire);\n+            unsafe { global_heap::exchange_free(self.x as *u8) }\n         }\n     }\n }\n \n-impl PoisonOnFail {\n-    fn new<'a>(flag: &'a mut bool) -> PoisonOnFail {\n-        PoisonOnFail {\n-            flag: flag,\n-            failed: task::failing()\n+impl<T: Share + Send> Weak<T> {\n+    /// Attempts to upgrade this weak reference to a strong reference.\n+    ///\n+    /// This method will fail to upgrade this reference if the strong reference\n+    /// count has already reached 0, but if there are still other active strong\n+    /// references this function will return a new strong reference to the data\n+    pub fn upgrade(&self) -> Option<Arc<T>> {\n+        // We use a CAS loop to increment the strong count instead of a\n+        // fetch_add because once the count hits 0 is must never be above 0.\n+        let inner = self.inner();\n+        loop {\n+            let n = inner.strong.load(atomics::SeqCst);\n+            if n == 0 { return None }\n+            let old = inner.strong.compare_and_swap(n, n + 1, atomics::SeqCst);\n+            if old == n { return Some(Arc { x: self.x }) }\n         }\n     }\n-}\n \n-/****************************************************************************\n- * R/W lock protected Arc\n- ****************************************************************************/\n-\n-#[doc(hidden)]\n-struct RWArcInner<T> { lock: RWLock, failed: bool, data: T }\n-/**\n- * A dual-mode Arc protected by a reader-writer lock. The data can be accessed\n- * mutably or immutably, and immutably-accessing tasks may run concurrently.\n- *\n- * Unlike mutex_arcs, rw_arcs are safe, because they cannot be nested.\n- */\n-pub struct RWArc<T> {\n-    priv x: UnsafeArc<RWArcInner<T>>,\n-    priv marker: marker::NoShare,\n-}\n-\n-impl<T: Share + Send> Clone for RWArc<T> {\n-    /// Duplicate a rwlock-protected Arc. See arc::clone for more details.\n     #[inline]\n-    fn clone(&self) -> RWArc<T> {\n-        RWArc {\n-            x: self.x.clone(),\n-            marker: marker::NoShare\n-        }\n+    fn inner<'a>(&'a self) -> &'a ArcInner<T> {\n+        // See comments above for why this is \"safe\"\n+        unsafe { &*self.x }\n     }\n-\n }\n \n-impl<T: Share + Send> RWArc<T> {\n-    /// Create a reader/writer Arc with the supplied data.\n-    pub fn new(user_data: T) -> RWArc<T> {\n-        RWArc::new_with_condvars(user_data, 1)\n-    }\n-\n-    /**\n-     * Create a reader/writer Arc with the supplied data and a specified number\n-     * of condvars (as sync::RWLock::new_with_condvars).\n-     */\n-    pub fn new_with_condvars(user_data: T, num_condvars: uint) -> RWArc<T> {\n-        let data = RWArcInner {\n-            lock: RWLock::new_with_condvars(num_condvars),\n-            failed: false, data: user_data\n-        };\n-        RWArc {\n-            x: UnsafeArc::new(data),\n-            marker: marker::NoShare\n-        }\n-    }\n-\n-    /**\n-     * Access the underlying data mutably. Locks the rwlock in write mode;\n-     * other readers and writers will block.\n-     *\n-     * # Failure\n-     *\n-     * Failing while inside the Arc will unlock the Arc while unwinding, so\n-     * that other tasks won't block forever. As MutexArc.access, it will also\n-     * poison the Arc, so subsequent readers and writers will both also fail.\n-     */\n+impl<T: Share + Send> Clone for Weak<T> {\n     #[inline]\n-    pub fn write<U>(&self, blk: |x: &mut T| -> U) -> U {\n-        unsafe {\n-            let state = self.x.get();\n-            (*borrow_rwlock(state)).write(|| {\n-                check_poison(false, (*state).failed);\n-                let _z = PoisonOnFail::new(&mut (*state).failed);\n-                blk(&mut (*state).data)\n-            })\n-        }\n-    }\n-\n-    /// As write(), but with a condvar, as sync::rwlock.write_cond().\n-    #[inline]\n-    pub fn write_cond<U>(&self,\n-                         blk: |x: &mut T, c: &ArcCondvar| -> U)\n-                         -> U {\n-        unsafe {\n-            let state = self.x.get();\n-            (*borrow_rwlock(state)).write_cond(|cond| {\n-                check_poison(false, (*state).failed);\n-                let _z = PoisonOnFail::new(&mut (*state).failed);\n-                blk(&mut (*state).data,\n-                    &ArcCondvar {is_mutex: false,\n-                              failed: &(*state).failed,\n-                              cond: cond})\n-            })\n-        }\n-    }\n-\n-    /**\n-     * Access the underlying data immutably. May run concurrently with other\n-     * reading tasks.\n-     *\n-     * # Failure\n-     *\n-     * Failing will unlock the Arc while unwinding. However, unlike all other\n-     * access modes, this will not poison the Arc.\n-     */\n-    pub fn read<U>(&self, blk: |x: &T| -> U) -> U {\n-        unsafe {\n-            let state = self.x.get();\n-            (*state).lock.read(|| {\n-                check_poison(false, (*state).failed);\n-                blk(&(*state).data)\n-            })\n-        }\n-    }\n-\n-    /**\n-     * As write(), but with the ability to atomically 'downgrade' the lock.\n-     * See sync::rwlock.write_downgrade(). The RWWriteMode token must be used\n-     * to obtain the &mut T, and can be transformed into a RWReadMode token by\n-     * calling downgrade(), after which a &T can be obtained instead.\n-     *\n-     * # Example\n-     *\n-     * ```rust\n-     * use sync::RWArc;\n-     *\n-     * let arc = RWArc::new(1);\n-     * arc.write_downgrade(|mut write_token| {\n-     *     write_token.write_cond(|state, condvar| {\n-     *         // ... exclusive access with mutable state ...\n-     *     });\n-     *     let read_token = arc.downgrade(write_token);\n-     *     read_token.read(|state| {\n-     *         // ... shared access with immutable state ...\n-     *     });\n-     * })\n-     * ```\n-     */\n-    pub fn write_downgrade<U>(&self, blk: |v: RWWriteMode<T>| -> U) -> U {\n-        unsafe {\n-            let state = self.x.get();\n-            (*borrow_rwlock(state)).write_downgrade(|write_mode| {\n-                check_poison(false, (*state).failed);\n-                blk(RWWriteMode {\n-                    data: &mut (*state).data,\n-                    token: write_mode,\n-                    poison: PoisonOnFail::new(&mut (*state).failed)\n-                })\n-            })\n-        }\n-    }\n-\n-    /// To be called inside of the write_downgrade block.\n-    pub fn downgrade<'a>(&self, token: RWWriteMode<'a, T>)\n-                         -> RWReadMode<'a, T> {\n-        unsafe {\n-            // The rwlock should assert that the token belongs to us for us.\n-            let state = self.x.get();\n-            let RWWriteMode {\n-                data: data,\n-                token: t,\n-                poison: _poison\n-            } = token;\n-            // Let readers in\n-            let new_token = (*state).lock.downgrade(t);\n-            // Whatever region the input reference had, it will be safe to use\n-            // the same region for the output reference. (The only 'unsafe' part\n-            // of this cast is removing the mutability.)\n-            let new_data = data;\n-            // Downgrade ensured the token belonged to us. Just a sanity check.\n-            assert!((&(*state).data as *T as uint) == (new_data as *mut T as uint));\n-            // Produce new token\n-            RWReadMode {\n-                data: new_data,\n-                token: new_token,\n-            }\n-        }\n-    }\n-}\n-\n-// Borrowck rightly complains about immutably aliasing the rwlock in order to\n-// lock it. This wraps the unsafety, with the justification that the 'lock'\n-// field is never overwritten; only 'failed' and 'data'.\n-#[doc(hidden)]\n-fn borrow_rwlock<T: Share + Send>(state: *mut RWArcInner<T>) -> *RWLock {\n-    unsafe { cast::transmute(&(*state).lock) }\n-}\n-\n-/// The \"write permission\" token used for RWArc.write_downgrade().\n-pub struct RWWriteMode<'a, T> {\n-    priv data: &'a mut T,\n-    priv token: sync::RWLockWriteMode<'a>,\n-    priv poison: PoisonOnFail,\n-}\n-\n-/// The \"read permission\" token used for RWArc.write_downgrade().\n-pub struct RWReadMode<'a, T> {\n-    priv data: &'a T,\n-    priv token: sync::RWLockReadMode<'a>,\n-}\n-\n-impl<'a, T: Share + Send> RWWriteMode<'a, T> {\n-    /// Access the pre-downgrade RWArc in write mode.\n-    pub fn write<U>(&mut self, blk: |x: &mut T| -> U) -> U {\n-        match *self {\n-            RWWriteMode {\n-                data: &ref mut data,\n-                token: ref token,\n-                poison: _\n-            } => {\n-                token.write(|| blk(data))\n-            }\n-        }\n-    }\n-\n-    /// Access the pre-downgrade RWArc in write mode with a condvar.\n-    pub fn write_cond<U>(&mut self,\n-                         blk: |x: &mut T, c: &ArcCondvar| -> U)\n-                         -> U {\n-        match *self {\n-            RWWriteMode {\n-                data: &ref mut data,\n-                token: ref token,\n-                poison: ref poison\n-            } => {\n-                token.write_cond(|cond| {\n-                    unsafe {\n-                        let cvar = ArcCondvar {\n-                            is_mutex: false,\n-                            failed: &*poison.flag,\n-                            cond: cond\n-                        };\n-                        blk(data, &cvar)\n-                    }\n-                })\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, T: Share + Send> RWReadMode<'a, T> {\n-    /// Access the post-downgrade rwlock in read mode.\n-    pub fn read<U>(&self, blk: |x: &T| -> U) -> U {\n-        match *self {\n-            RWReadMode {\n-                data: data,\n-                token: ref token\n-            } => {\n-                token.read(|| blk(data))\n-            }\n-        }\n+    fn clone(&self) -> Weak<T> {\n+        // See comments in Arc::clone() for why this is relaxed\n+        self.inner().weak.fetch_add(1, atomics::Relaxed);\n+        Weak { x: self.x }\n     }\n }\n \n-/****************************************************************************\n- * Copy-on-write Arc\n- ****************************************************************************/\n-\n-pub struct CowArc<T> { priv x: UnsafeArc<T> }\n-\n-/// A Copy-on-write Arc functions the same way as an `arc` except it allows\n-/// mutation of the contents if there is only a single reference to\n-/// the data. If there are multiple references the data is automatically\n-/// cloned and the task modifies the cloned data in place of the shared data.\n-impl<T: Clone + Send + Share> CowArc<T> {\n-    /// Create a copy-on-write atomically reference counted wrapper\n-    #[inline]\n-    pub fn new(data: T) -> CowArc<T> {\n-        CowArc { x: UnsafeArc::new(data) }\n-    }\n-\n-    #[inline]\n-    pub fn get<'a>(&'a self) -> &'a T {\n-        unsafe { &*self.x.get_immut() }\n-    }\n-\n-    /// get a mutable reference to the contents. If there are more then one\n-    /// reference to the contents of the `CowArc` will be cloned\n-    /// and this reference updated to point to the cloned data.\n-    #[inline]\n-    pub fn get_mut<'a>(&'a mut self) -> &'a mut T {\n-        if !self.x.is_owned() {\n-            *self = CowArc::new(self.get().clone())\n+#[unsafe_destructor]\n+impl<T: Share + Send> Drop for Weak<T> {\n+    fn drop(&mut self) {\n+        // see comments above for why this check is here\n+        if self.x.is_null() { return }\n+\n+        // If we find out that we were the last weak pointer, then its time to\n+        // deallocate the data entirely. See the discussion in Arc::drop() about\n+        // the memory orderings\n+        if self.inner().weak.fetch_sub(1, atomics::Release) == 0 {\n+            atomics::fence(atomics::Acquire);\n+            unsafe { global_heap::exchange_free(self.x as *u8) }\n         }\n-        unsafe { &mut *self.x.get() }\n-    }\n-}\n-\n-impl<T: Clone + Send + Share> Clone for CowArc<T> {\n-    /// Duplicate a Copy-on-write Arc. See arc::clone for more details.\n-    fn clone(&self) -> CowArc<T> {\n-        CowArc { x: self.x.clone() }\n     }\n }\n \n-\n-\n-/****************************************************************************\n- * Tests\n- ****************************************************************************/\n-\n #[cfg(test)]\n+#[allow(experimental)]\n mod tests {\n-\n-    use super::{Arc, RWArc, MutexArc, CowArc};\n+    use super::{Arc, Weak};\n+    use Mutex;\n \n     use std::task;\n \n@@ -588,455 +264,89 @@ mod tests {\n \n         task::spawn(proc() {\n             let arc_v: Arc<Vec<int>> = rx.recv();\n-\n-            let v = arc_v.get().clone();\n-            assert_eq!(*v.get(3), 4);\n+            assert_eq!(*arc_v.get(3), 4);\n         });\n \n         tx.send(arc_v.clone());\n \n-        assert_eq!(*arc_v.get().get(2), 3);\n-        assert_eq!(*arc_v.get().get(4), 5);\n+        assert_eq!(*arc_v.get(2), 3);\n+        assert_eq!(*arc_v.get(4), 5);\n \n         info!(\"{:?}\", arc_v);\n     }\n \n     #[test]\n-    fn test_mutex_arc_condvar() {\n-        let arc = ~MutexArc::new(false);\n-        let arc2 = ~arc.clone();\n-        let (tx, rx) = channel();\n-        task::spawn(proc() {\n-            // wait until parent gets in\n-            rx.recv();\n-            arc2.access_cond(|state, cond| {\n-                *state = true;\n-                cond.signal();\n-            })\n-        });\n-\n-        arc.access_cond(|state, cond| {\n-            tx.send(());\n-            assert!(!*state);\n-            while !*state {\n-                cond.wait();\n-            }\n-        })\n-    }\n-\n-    #[test] #[should_fail]\n-    fn test_arc_condvar_poison() {\n-        let arc = ~MutexArc::new(1);\n-        let arc2 = ~arc.clone();\n-        let (tx, rx) = channel();\n-\n-        spawn(proc() {\n-            let _ = rx.recv();\n-            arc2.access_cond(|one, cond| {\n-                cond.signal();\n-                // Parent should fail when it wakes up.\n-                assert_eq!(*one, 0);\n-            })\n-        });\n-\n-        arc.access_cond(|one, cond| {\n-            tx.send(());\n-            while *one == 1 {\n-                cond.wait();\n-            }\n-        })\n-    }\n-\n-    #[test] #[should_fail]\n-    fn test_mutex_arc_poison() {\n-        let arc = ~MutexArc::new(1);\n-        let arc2 = ~arc.clone();\n-        let _ = task::try(proc() {\n-            arc2.access(|one| {\n-                assert_eq!(*one, 2);\n-            })\n-        });\n-        arc.access(|one| {\n-            assert_eq!(*one, 1);\n-        })\n-    }\n-\n-    #[test]\n-    fn test_mutex_arc_nested() {\n-        // Tests nested mutexes and access\n-        // to underlaying data.\n-        let arc = ~MutexArc::new(1);\n-        let arc2 = ~MutexArc::new(*arc);\n-        task::spawn(proc() {\n-            (*arc2).access(|mutex| {\n-                (*mutex).access(|one| {\n-                    assert!(*one == 1);\n-                })\n-            })\n-        });\n-    }\n-\n-    #[test]\n-    fn test_mutex_arc_access_in_unwind() {\n-        let arc = MutexArc::new(1i);\n-        let arc2 = arc.clone();\n-        let _ = task::try::<()>(proc() {\n-            struct Unwinder {\n-                i: MutexArc<int>\n-            }\n-            impl Drop for Unwinder {\n-                fn drop(&mut self) {\n-                    self.i.access(|num| *num += 1);\n-                }\n-            }\n-            let _u = Unwinder { i: arc2 };\n-            fail!();\n-        });\n-        assert_eq!(2, arc.access(|n| *n));\n-    }\n-\n-    #[test] #[should_fail]\n-    fn test_rw_arc_poison_wr() {\n-        let arc = RWArc::new(1);\n-        let arc2 = arc.clone();\n-        let _ = task::try(proc() {\n-            arc2.write(|one| {\n-                assert_eq!(*one, 2);\n-            })\n-        });\n-        arc.read(|one| {\n-            assert_eq!(*one, 1);\n-        })\n-    }\n-\n-    #[test] #[should_fail]\n-    fn test_rw_arc_poison_ww() {\n-        let arc = RWArc::new(1);\n-        let arc2 = arc.clone();\n-        let _ = task::try(proc() {\n-            arc2.write(|one| {\n-                assert_eq!(*one, 2);\n-            })\n-        });\n-        arc.write(|one| {\n-            assert_eq!(*one, 1);\n-        })\n-    }\n-    #[test] #[should_fail]\n-    fn test_rw_arc_poison_dw() {\n-        let arc = RWArc::new(1);\n-        let arc2 = arc.clone();\n-        let _ = task::try(proc() {\n-            arc2.write_downgrade(|mut write_mode| {\n-                write_mode.write(|one| {\n-                    assert_eq!(*one, 2);\n-                })\n-            })\n-        });\n-        arc.write(|one| {\n-            assert_eq!(*one, 1);\n-        })\n-    }\n-    #[test]\n-    fn test_rw_arc_no_poison_rr() {\n-        let arc = RWArc::new(1);\n-        let arc2 = arc.clone();\n-        let _ = task::try(proc() {\n-            arc2.read(|one| {\n-                assert_eq!(*one, 2);\n-            })\n-        });\n-        arc.read(|one| {\n-            assert_eq!(*one, 1);\n-        })\n-    }\n-    #[test]\n-    fn test_rw_arc_no_poison_rw() {\n-        let arc = RWArc::new(1);\n-        let arc2 = arc.clone();\n-        let _ = task::try(proc() {\n-            arc2.read(|one| {\n-                assert_eq!(*one, 2);\n-            })\n-        });\n-        arc.write(|one| {\n-            assert_eq!(*one, 1);\n-        })\n-    }\n-    #[test]\n-    fn test_rw_arc_no_poison_dr() {\n-        let arc = RWArc::new(1);\n-        let arc2 = arc.clone();\n-        let _ = task::try(proc() {\n-            arc2.write_downgrade(|write_mode| {\n-                let read_mode = arc2.downgrade(write_mode);\n-                read_mode.read(|one| {\n-                    assert_eq!(*one, 2);\n-                })\n-            })\n-        });\n-        arc.write(|one| {\n-            assert_eq!(*one, 1);\n-        })\n-    }\n-    #[test]\n-    fn test_rw_arc() {\n-        let arc = RWArc::new(0);\n-        let arc2 = arc.clone();\n-        let (tx, rx) = channel();\n-\n-        task::spawn(proc() {\n-            arc2.write(|num| {\n-                for _ in range(0, 10) {\n-                    let tmp = *num;\n-                    *num = -1;\n-                    task::deschedule();\n-                    *num = tmp + 1;\n-                }\n-                tx.send(());\n-            })\n-        });\n+    fn test_cowarc_clone_make_unique() {\n+        let mut cow0 = Arc::new(75u);\n+        let mut cow1 = cow0.clone();\n+        let mut cow2 = cow1.clone();\n \n-        // Readers try to catch the writer in the act\n-        let mut children = Vec::new();\n-        for _ in range(0, 5) {\n-            let arc3 = arc.clone();\n-            let mut builder = task::task();\n-            children.push(builder.future_result());\n-            builder.spawn(proc() {\n-                arc3.read(|num| {\n-                    assert!(*num >= 0);\n-                })\n-            });\n-        }\n+        assert!(75 == *cow0.make_unique());\n+        assert!(75 == *cow1.make_unique());\n+        assert!(75 == *cow2.make_unique());\n \n-        // Wait for children to pass their asserts\n-        for r in children.mut_iter() {\n-            let _ = r.recv();\n-        }\n+        *cow0.make_unique() += 1;\n+        *cow1.make_unique() += 2;\n+        *cow2.make_unique() += 3;\n \n-        // Wait for writer to finish\n-        rx.recv();\n-        arc.read(|num| {\n-            assert_eq!(*num, 10);\n-        })\n-    }\n+        assert!(76 == *cow0);\n+        assert!(77 == *cow1);\n+        assert!(78 == *cow2);\n \n-    #[test]\n-    fn test_rw_arc_access_in_unwind() {\n-        let arc = RWArc::new(1i);\n-        let arc2 = arc.clone();\n-        let _ = task::try::<()>(proc() {\n-            struct Unwinder {\n-                i: RWArc<int>\n-            }\n-            impl Drop for Unwinder {\n-                fn drop(&mut self) {\n-                    self.i.write(|num| *num += 1);\n-                }\n-            }\n-            let _u = Unwinder { i: arc2 };\n-            fail!();\n-        });\n-        assert_eq!(2, arc.read(|n| *n));\n+        // none should point to the same backing memory\n+        assert!(*cow0 != *cow1);\n+        assert!(*cow0 != *cow2);\n+        assert!(*cow1 != *cow2);\n     }\n \n     #[test]\n-    fn test_rw_downgrade() {\n-        // (1) A downgrader gets in write mode and does cond.wait.\n-        // (2) A writer gets in write mode, sets state to 42, and does signal.\n-        // (3) Downgrader wakes, sets state to 31337.\n-        // (4) tells writer and all other readers to contend as it downgrades.\n-        // (5) Writer attempts to set state back to 42, while downgraded task\n-        //     and all reader tasks assert that it's 31337.\n-        let arc = RWArc::new(0);\n-\n-        // Reader tasks\n-        let mut reader_convos = Vec::new();\n-        for _ in range(0, 10) {\n-            let ((tx1, rx1), (tx2, rx2)) = (channel(), channel());\n-            reader_convos.push((tx1, rx2));\n-            let arcn = arc.clone();\n-            task::spawn(proc() {\n-                rx1.recv(); // wait for downgrader to give go-ahead\n-                arcn.read(|state| {\n-                    assert_eq!(*state, 31337);\n-                    tx2.send(());\n-                })\n-            });\n-        }\n-\n-        // Writer task\n-        let arc2 = arc.clone();\n-        let ((tx1, rx1), (tx2, rx2)) = (channel(), channel());\n-        task::spawn(proc() {\n-            rx1.recv();\n-            arc2.write_cond(|state, cond| {\n-                assert_eq!(*state, 0);\n-                *state = 42;\n-                cond.signal();\n-            });\n-            rx1.recv();\n-            arc2.write(|state| {\n-                // This shouldn't happen until after the downgrade read\n-                // section, and all other readers, finish.\n-                assert_eq!(*state, 31337);\n-                *state = 42;\n-            });\n-            tx2.send(());\n-        });\n-\n-        // Downgrader (us)\n-        arc.write_downgrade(|mut write_mode| {\n-            write_mode.write_cond(|state, cond| {\n-                tx1.send(()); // send to another writer who will wake us up\n-                while *state == 0 {\n-                    cond.wait();\n-                }\n-                assert_eq!(*state, 42);\n-                *state = 31337;\n-                // send to other readers\n-                for &(ref mut rc, _) in reader_convos.mut_iter() {\n-                    rc.send(())\n-                }\n-            });\n-            let read_mode = arc.downgrade(write_mode);\n-            read_mode.read(|state| {\n-                // complete handshake with other readers\n-                for &(_, ref mut rp) in reader_convos.mut_iter() {\n-                    rp.recv()\n-                }\n-                tx1.send(()); // tell writer to try again\n-                assert_eq!(*state, 31337);\n-            });\n-        });\n-\n-        rx2.recv(); // complete handshake with writer\n-    }\n-    #[cfg(test)]\n-    fn test_rw_write_cond_downgrade_read_race_helper() {\n-        // Tests that when a downgrader hands off the \"reader cloud\" lock\n-        // because of a contending reader, a writer can't race to get it\n-        // instead, which would result in readers_and_writers. This tests\n-        // the sync module rather than this one, but it's here because an\n-        // rwarc gives us extra shared state to help check for the race.\n-        // If you want to see this test fail, go to sync.rs and replace the\n-        // line in RWLock::write_cond() that looks like:\n-        //     \"blk(&ArcCondvar { order: opt_lock, ..*cond })\"\n-        // with just \"blk(cond)\".\n-        let x = RWArc::new(true);\n-        let (tx, rx) = channel();\n+    fn test_cowarc_clone_unique2() {\n+        let mut cow0 = Arc::new(75u);\n+        let cow1 = cow0.clone();\n+        let cow2 = cow1.clone();\n \n-        // writer task\n-        let xw = x.clone();\n-        task::spawn(proc() {\n-            xw.write_cond(|state, c| {\n-                tx.send(()); // tell downgrader it's ok to go\n-                c.wait();\n-                // The core of the test is here: the condvar reacquire path\n-                // must involve order_lock, so that it cannot race with a reader\n-                // trying to receive the \"reader cloud lock hand-off\".\n-                *state = false;\n-            })\n-        });\n+        assert!(75 == *cow0);\n+        assert!(75 == *cow1);\n+        assert!(75 == *cow2);\n \n-        rx.recv(); // wait for writer to get in\n+        *cow0.make_unique() += 1;\n \n-        x.write_downgrade(|mut write_mode| {\n-            write_mode.write_cond(|state, c| {\n-                assert!(*state);\n-                // make writer contend in the cond-reacquire path\n-                c.signal();\n-            });\n-            // make a reader task to trigger the \"reader cloud lock\" handoff\n-            let xr = x.clone();\n-            let (tx, rx) = channel();\n-            task::spawn(proc() {\n-                tx.send(());\n-                xr.read(|_state| { })\n-            });\n-            rx.recv(); // wait for reader task to exist\n+        assert!(76 == *cow0);\n+        assert!(75 == *cow1);\n+        assert!(75 == *cow2);\n \n-            let read_mode = x.downgrade(write_mode);\n-            read_mode.read(|state| {\n-                // if writer mistakenly got in, make sure it mutates state\n-                // before we assert on it\n-                for _ in range(0, 5) { task::deschedule(); }\n-                // make sure writer didn't get in.\n-                assert!(*state);\n-            })\n-        });\n-    }\n-    #[test]\n-    fn test_rw_write_cond_downgrade_read_race() {\n-        // Ideally the above test case would have deschedule statements in it that\n-        // helped to expose the race nearly 100% of the time... but adding\n-        // deschedules in the intuitively-right locations made it even less likely,\n-        // and I wasn't sure why :( . This is a mediocre \"next best\" option.\n-        for _ in range(0, 8) { test_rw_write_cond_downgrade_read_race_helper(); }\n+        // cow1 and cow2 should share the same contents\n+        // cow0 should have a unique reference\n+        assert!(*cow0 != *cow1);\n+        assert!(*cow0 != *cow2);\n+        assert!(*cow1 == *cow2);\n     }\n \n     #[test]\n-    fn test_cowarc_clone()\n-    {\n-        let cow0 = CowArc::new(75u);\n-        let cow1 = cow0.clone();\n-        let cow2 = cow1.clone();\n-\n-        assert!(75 == *cow0.get());\n-        assert!(75 == *cow1.get());\n-        assert!(75 == *cow2.get());\n-\n-        assert!(cow0.get() == cow1.get());\n-        assert!(cow0.get() == cow2.get());\n+    fn test_live() {\n+        let x = Arc::new(5);\n+        let y = x.downgrade();\n+        assert!(y.upgrade().is_some());\n     }\n \n     #[test]\n-    fn test_cowarc_clone_get_mut()\n-    {\n-        let mut cow0 = CowArc::new(75u);\n-        let mut cow1 = cow0.clone();\n-        let mut cow2 = cow1.clone();\n-\n-        assert!(75 == *cow0.get_mut());\n-        assert!(75 == *cow1.get_mut());\n-        assert!(75 == *cow2.get_mut());\n-\n-        *cow0.get_mut() += 1;\n-        *cow1.get_mut() += 2;\n-        *cow2.get_mut() += 3;\n-\n-        assert!(76 == *cow0.get());\n-        assert!(77 == *cow1.get());\n-        assert!(78 == *cow2.get());\n-\n-        // none should point to the same backing memory\n-        assert!(cow0.get() != cow1.get());\n-        assert!(cow0.get() != cow2.get());\n-        assert!(cow1.get() != cow2.get());\n+    fn test_dead() {\n+        let x = Arc::new(5);\n+        let y = x.downgrade();\n+        drop(x);\n+        assert!(y.upgrade().is_none());\n     }\n \n     #[test]\n-    fn test_cowarc_clone_get_mut2()\n-    {\n-        let mut cow0 = CowArc::new(75u);\n-        let cow1 = cow0.clone();\n-        let cow2 = cow1.clone();\n-\n-        assert!(75 == *cow0.get());\n-        assert!(75 == *cow1.get());\n-        assert!(75 == *cow2.get());\n-\n-        *cow0.get_mut() += 1;\n+    fn weak_self_cyclic() {\n+        struct Cycle {\n+            x: Mutex<Option<Weak<Cycle>>>\n+        }\n \n-        assert!(76 == *cow0.get());\n-        assert!(75 == *cow1.get());\n-        assert!(75 == *cow2.get());\n+        let a = Arc::new(Cycle { x: Mutex::new(None) });\n+        let b = a.clone().downgrade();\n+        *a.deref().x.lock().deref_mut() = Some(b);\n \n-        // cow1 and cow2 should share the same contents\n-        // cow0 should have a unique reference\n-        assert!(cow0.get() != cow1.get());\n-        assert!(cow0.get() != cow2.get());\n-        assert!(cow1.get() == cow2.get());\n+        // hopefully we don't double-free (or leak)...\n     }\n }"}, {"sha": "d166076e96e15044ebf415d87196975b13b408fc", "filename": "src/libsync/lib.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibsync%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibsync%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Flib.rs?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -20,18 +20,28 @@\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://static.rust-lang.org/doc/master\")];\n #[feature(phase)];\n+#[deny(missing_doc, deprecated_owned_vector)];\n \n-#[cfg(test)] #[phase(syntax, link)] extern crate log;\n+#[cfg(test)]\n+#[phase(syntax, link)] extern crate log;\n \n-pub use arc::{Arc, MutexArc, RWArc, RWWriteMode, RWReadMode, ArcCondvar, CowArc};\n-pub use sync::{Mutex, RWLock, Condvar, Semaphore, RWLockWriteMode,\n-               RWLockReadMode, Barrier, one, mutex};\n pub use comm::{DuplexStream, SyncSender, SyncReceiver, rendezvous, duplex};\n pub use task_pool::TaskPool;\n pub use future::Future;\n+pub use arc::{Arc, Weak};\n+pub use lock::{Mutex, MutexGuard, Condvar, Barrier,\n+               RWLock, RWLockReadGuard, RWLockWriteGuard};\n+\n+// The mutex/rwlock in this module are not meant for reexport\n+pub use raw::{Semaphore, SemaphoreGuard};\n \n mod arc;\n-mod sync;\n mod comm;\n-mod task_pool;\n mod future;\n+mod lock;\n+mod mpsc_intrusive;\n+mod task_pool;\n+\n+pub mod raw;\n+pub mod mutex;\n+pub mod one;"}, {"sha": "6ddd0d400f2eb54cb680fe21e1641b9690e5e455", "filename": "src/libsync/lock.rs", "status": "added", "additions": 816, "deletions": 0, "changes": 816, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibsync%2Flock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibsync%2Flock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Flock.rs?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -0,0 +1,816 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Wrappers for safe, shared, mutable memory between tasks\n+//!\n+//! The wrappers in this module build on the primitives from `sync::raw` to\n+//! provide safe interfaces around using the primitive locks. These primitives\n+//! implement a technique called \"poisoning\" where when a task failed with a\n+//! held lock, all future attempts to use the lock will fail.\n+//!\n+//! For example, if two tasks are contending on a mutex and one of them fails\n+//! after grabbing the lock, the second task will immediately fail because the\n+//! lock is now poisoned.\n+\n+use std::task;\n+use std::ty::Unsafe;\n+\n+use raw;\n+\n+/****************************************************************************\n+ * Poisoning helpers\n+ ****************************************************************************/\n+\n+struct PoisonOnFail<'a> {\n+    flag: &'a mut bool,\n+    failed: bool,\n+}\n+\n+impl<'a> PoisonOnFail<'a> {\n+    fn check(flag: bool, name: &str) {\n+        if flag {\n+            fail!(\"Poisoned {} - another task failed inside!\", name);\n+        }\n+    }\n+\n+    fn new<'a>(flag: &'a mut bool, name: &str) -> PoisonOnFail<'a> {\n+        PoisonOnFail::check(*flag, name);\n+        PoisonOnFail {\n+            flag: flag,\n+            failed: task::failing()\n+        }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<'a> Drop for PoisonOnFail<'a> {\n+    fn drop(&mut self) {\n+        if !self.failed && task::failing() {\n+            *self.flag = true;\n+        }\n+    }\n+}\n+\n+/****************************************************************************\n+ * Condvar\n+ ****************************************************************************/\n+\n+enum Inner<'a> {\n+    InnerMutex(raw::MutexGuard<'a>),\n+    InnerRWLock(raw::RWLockWriteGuard<'a>),\n+}\n+\n+impl<'b> Inner<'b> {\n+    fn cond<'a>(&'a self) -> &'a raw::Condvar<'b> {\n+        match *self {\n+            InnerMutex(ref m) => &m.cond,\n+            InnerRWLock(ref m) => &m.cond,\n+        }\n+    }\n+}\n+\n+/// A condition variable, a mechanism for unlock-and-descheduling and\n+/// signaling, for use with the lock types.\n+pub struct Condvar<'a> {\n+    priv name: &'static str,\n+    // n.b. Inner must be after PoisonOnFail because we must set the poison flag\n+    //      *inside* the mutex, and struct fields are destroyed top-to-bottom\n+    //      (destroy the lock guard last).\n+    priv poison: PoisonOnFail<'a>,\n+    priv inner: Inner<'a>,\n+}\n+\n+impl<'a> Condvar<'a> {\n+    /// Atomically exit the associated lock and block until a signal is sent.\n+    ///\n+    /// wait() is equivalent to wait_on(0).\n+    ///\n+    /// # Failure\n+    ///\n+    /// A task which is killed while waiting on a condition variable will wake\n+    /// up, fail, and unlock the associated lock as it unwinds.\n+    #[inline]\n+    pub fn wait(&self) { self.wait_on(0) }\n+\n+    /// Atomically exit the associated lock and block on a specified condvar\n+    /// until a signal is sent on that same condvar.\n+    ///\n+    /// The associated lock must have been initialised with an appropriate\n+    /// number of condvars. The condvar_id must be between 0 and num_condvars-1\n+    /// or else this call will fail.\n+    #[inline]\n+    pub fn wait_on(&self, condvar_id: uint) {\n+        assert!(!*self.poison.flag);\n+        self.inner.cond().wait_on(condvar_id);\n+        // This is why we need to wrap sync::condvar.\n+        PoisonOnFail::check(*self.poison.flag, self.name);\n+    }\n+\n+    /// Wake up a blocked task. Returns false if there was no blocked task.\n+    #[inline]\n+    pub fn signal(&self) -> bool { self.signal_on(0) }\n+\n+    /// Wake up a blocked task on a specified condvar (as\n+    /// sync::cond.signal_on). Returns false if there was no blocked task.\n+    #[inline]\n+    pub fn signal_on(&self, condvar_id: uint) -> bool {\n+        assert!(!*self.poison.flag);\n+        self.inner.cond().signal_on(condvar_id)\n+    }\n+\n+    /// Wake up all blocked tasks. Returns the number of tasks woken.\n+    #[inline]\n+    pub fn broadcast(&self) -> uint { self.broadcast_on(0) }\n+\n+    /// Wake up all blocked tasks on a specified condvar (as\n+    /// sync::cond.broadcast_on). Returns the number of tasks woken.\n+    #[inline]\n+    pub fn broadcast_on(&self, condvar_id: uint) -> uint {\n+        assert!(!*self.poison.flag);\n+        self.inner.cond().broadcast_on(condvar_id)\n+    }\n+}\n+\n+/****************************************************************************\n+ * Mutex\n+ ****************************************************************************/\n+\n+/// A wrapper type which provides synchronized access to the underlying data, of\n+/// type `T`. A mutex always provides exclusive access, and concurrent requests\n+/// will block while the mutex is already locked.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use sync::{Mutex, Arc};\n+///\n+/// let mutex = Arc::new(Mutex::new(1));\n+/// let mutex2 = mutex.clone();\n+///\n+/// spawn(proc() {\n+///     let mut val = mutex2.lock();\n+///     *val += 1;\n+///     val.cond.signal();\n+/// });\n+///\n+/// let mut value = mutex.lock();\n+/// while *value != 2 {\n+///     value.cond.wait();\n+/// }\n+/// ```\n+pub struct Mutex<T> {\n+    priv lock: raw::Mutex,\n+    priv failed: Unsafe<bool>,\n+    priv data: Unsafe<T>,\n+}\n+\n+/// An guard which is created by locking a mutex. Through this guard the\n+/// underlying data can be accessed.\n+pub struct MutexGuard<'a, T> {\n+    priv data: &'a mut T,\n+    /// Inner condition variable connected to the locked mutex that this guard\n+    /// was created from. This can be used for atomic-unlock-and-deschedule.\n+    cond: Condvar<'a>,\n+}\n+\n+impl<T: Send> Mutex<T> {\n+    /// Creates a new mutex to protect the user-supplied data.\n+    pub fn new(user_data: T) -> Mutex<T> {\n+        Mutex::new_with_condvars(user_data, 1)\n+    }\n+\n+    /// Create a new mutex, with a specified number of associated condvars.\n+    ///\n+    /// This will allow calling wait_on/signal_on/broadcast_on with condvar IDs\n+    /// between 0 and num_condvars-1. (If num_condvars is 0, lock_cond will be\n+    /// allowed but any operations on the condvar will fail.)\n+    pub fn new_with_condvars(user_data: T, num_condvars: uint) -> Mutex<T> {\n+        Mutex {\n+            lock: raw::Mutex::new_with_condvars(num_condvars),\n+            failed: Unsafe::new(false),\n+            data: Unsafe::new(user_data),\n+        }\n+    }\n+\n+    /// Access the underlying mutable data with mutual exclusion from other\n+    /// tasks. The returned value is an RAII guard which will unlock the mutex\n+    /// when dropped. All concurrent tasks attempting to lock the mutex will\n+    /// block while the returned value is still alive.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Failing while inside the Mutex will unlock the Mutex while unwinding, so\n+    /// that other tasks won't block forever. It will also poison the Mutex:\n+    /// any tasks that subsequently try to access it (including those already\n+    /// blocked on the mutex) will also fail immediately.\n+    #[inline]\n+    pub fn lock<'a>(&'a self) -> MutexGuard<'a, T> {\n+        let guard = self.lock.lock();\n+\n+        // These two accesses are safe because we're guranteed at this point\n+        // that we have exclusive access to this mutex. We are indeed able to\n+        // promote ourselves from &Mutex to `&mut T`\n+        let poison = unsafe { &mut *self.failed.get() };\n+        let data = unsafe { &mut *self.data.get() };\n+\n+        MutexGuard {\n+            data: data,\n+            cond: Condvar {\n+                name: \"Mutex\",\n+                poison: PoisonOnFail::new(poison, \"Mutex\"),\n+                inner: InnerMutex(guard),\n+            },\n+        }\n+    }\n+}\n+\n+// FIXME(#13042): these should both have T: Send\n+impl<'a, T> Deref<T> for MutexGuard<'a, T> {\n+    fn deref<'a>(&'a self) -> &'a T { &*self.data }\n+}\n+impl<'a, T> DerefMut<T> for MutexGuard<'a, T> {\n+    fn deref_mut<'a>(&'a mut self) -> &'a mut T { &mut *self.data }\n+}\n+\n+/****************************************************************************\n+ * R/W lock protected lock\n+ ****************************************************************************/\n+\n+/// A dual-mode reader-writer lock. The data can be accessed mutably or\n+/// immutably, and immutably-accessing tasks may run concurrently.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use sync::{RWLock, Arc};\n+///\n+/// let lock1 = Arc::new(RWLock::new(1));\n+/// let lock2 = lock1.clone();\n+///\n+/// spawn(proc() {\n+///     let mut val = lock2.write();\n+///     *val = 3;\n+///     let val = val.downgrade();\n+///     println!(\"{}\", *val);\n+/// });\n+///\n+/// let val = lock1.read();\n+/// println!(\"{}\", *val);\n+/// ```\n+pub struct RWLock<T> {\n+    priv lock: raw::RWLock,\n+    priv failed: Unsafe<bool>,\n+    priv data: Unsafe<T>,\n+}\n+\n+/// A guard which is created by locking an rwlock in write mode. Through this\n+/// guard the underlying data can be accessed.\n+pub struct RWLockWriteGuard<'a, T> {\n+    priv data: &'a mut T,\n+    /// Inner condition variable that can be used to sleep on the write mode of\n+    /// this rwlock.\n+    cond: Condvar<'a>,\n+}\n+\n+/// A guard which is created by locking an rwlock in read mode. Through this\n+/// guard the underlying data can be accessed.\n+pub struct RWLockReadGuard<'a, T> {\n+    priv data: &'a T,\n+    priv guard: raw::RWLockReadGuard<'a>,\n+}\n+\n+impl<T: Send + Share> RWLock<T> {\n+    /// Create a reader/writer lock with the supplied data.\n+    pub fn new(user_data: T) -> RWLock<T> {\n+        RWLock::new_with_condvars(user_data, 1)\n+    }\n+\n+    /// Create a reader/writer lock with the supplied data and a specified number\n+    /// of condvars (as sync::RWLock::new_with_condvars).\n+    pub fn new_with_condvars(user_data: T, num_condvars: uint) -> RWLock<T> {\n+        RWLock {\n+            lock: raw::RWLock::new_with_condvars(num_condvars),\n+            failed: Unsafe::new(false),\n+            data: Unsafe::new(user_data),\n+        }\n+    }\n+\n+    /// Access the underlying data mutably. Locks the rwlock in write mode;\n+    /// other readers and writers will block.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Failing while inside the lock will unlock the lock while unwinding, so\n+    /// that other tasks won't block forever. As Mutex.lock, it will also poison\n+    /// the lock, so subsequent readers and writers will both also fail.\n+    #[inline]\n+    pub fn write<'a>(&'a self) -> RWLockWriteGuard<'a, T> {\n+        let guard = self.lock.write();\n+\n+        // These two accesses are safe because we're guranteed at this point\n+        // that we have exclusive access to this rwlock. We are indeed able to\n+        // promote ourselves from &RWLock to `&mut T`\n+        let poison = unsafe { &mut *self.failed.get() };\n+        let data = unsafe { &mut *self.data.get() };\n+\n+        RWLockWriteGuard {\n+            data: data,\n+            cond: Condvar {\n+                name: \"RWLock\",\n+                poison: PoisonOnFail::new(poison, \"RWLock\"),\n+                inner: InnerRWLock(guard),\n+            },\n+        }\n+    }\n+\n+    /// Access the underlying data immutably. May run concurrently with other\n+    /// reading tasks.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Failing will unlock the lock while unwinding. However, unlike all other\n+    /// access modes, this will not poison the lock.\n+    pub fn read<'a>(&'a self) -> RWLockReadGuard<'a, T> {\n+        let guard = self.lock.read();\n+        PoisonOnFail::check(unsafe { *self.failed.get() }, \"RWLock\");\n+        RWLockReadGuard {\n+            guard: guard,\n+            data: unsafe { &*self.data.get() },\n+        }\n+    }\n+}\n+\n+impl<'a, T: Send + Share> RWLockWriteGuard<'a, T> {\n+    /// Consumes this write lock token, returning a new read lock token.\n+    ///\n+    /// This will allow pending readers to come into the lock.\n+    pub fn downgrade(self) -> RWLockReadGuard<'a, T> {\n+        let RWLockWriteGuard { data, cond } = self;\n+        // convert the data to read-only explicitly\n+        let data = &*data;\n+        let guard = match cond.inner {\n+            InnerMutex(..) => unreachable!(),\n+            InnerRWLock(guard) => guard.downgrade()\n+        };\n+        RWLockReadGuard { guard: guard, data: data }\n+    }\n+}\n+\n+// FIXME(#13042): these should all have T: Send + Share\n+impl<'a, T> Deref<T> for RWLockReadGuard<'a, T> {\n+    fn deref<'a>(&'a self) -> &'a T { self.data }\n+}\n+impl<'a, T> Deref<T> for RWLockWriteGuard<'a, T> {\n+    fn deref<'a>(&'a self) -> &'a T { &*self.data }\n+}\n+impl<'a, T> DerefMut<T> for RWLockWriteGuard<'a, T> {\n+    fn deref_mut<'a>(&'a mut self) -> &'a mut T { &mut *self.data }\n+}\n+\n+/****************************************************************************\n+ * Barrier\n+ ****************************************************************************/\n+\n+/// A barrier enables multiple tasks to synchronize the beginning\n+/// of some computation.\n+///\n+/// ```rust\n+/// use sync::{Arc, Barrier};\n+///\n+/// let barrier = Arc::new(Barrier::new(10));\n+/// for _ in range(0, 10) {\n+///     let c = barrier.clone();\n+///     // The same messages will be printed together.\n+///     // You will NOT see any interleaving.\n+///     spawn(proc() {\n+///         println!(\"before wait\");\n+///         c.wait();\n+///         println!(\"after wait\");\n+///     });\n+/// }\n+/// ```\n+pub struct Barrier {\n+    priv lock: Mutex<BarrierState>,\n+    priv num_tasks: uint,\n+}\n+\n+// The inner state of a double barrier\n+struct BarrierState {\n+    count: uint,\n+    generation_id: uint,\n+}\n+\n+impl Barrier {\n+    /// Create a new barrier that can block a given number of tasks.\n+    pub fn new(num_tasks: uint) -> Barrier {\n+        Barrier {\n+            lock: Mutex::new(BarrierState {\n+                count: 0,\n+                generation_id: 0,\n+            }),\n+            num_tasks: num_tasks,\n+        }\n+    }\n+\n+    /// Block the current task until a certain number of tasks is waiting.\n+    pub fn wait(&self) {\n+        let mut lock = self.lock.lock();\n+        let local_gen = lock.generation_id;\n+        lock.count += 1;\n+        if lock.count < self.num_tasks {\n+            // We need a while loop to guard against spurious wakeups.\n+            // http://en.wikipedia.org/wiki/Spurious_wakeup\n+            while local_gen == lock.generation_id &&\n+                  lock.count < self.num_tasks {\n+                lock.cond.wait();\n+            }\n+        } else {\n+            lock.count = 0;\n+            lock.generation_id += 1;\n+            lock.cond.broadcast();\n+        }\n+    }\n+}\n+\n+/****************************************************************************\n+ * Tests\n+ ****************************************************************************/\n+\n+#[cfg(test)]\n+mod tests {\n+    use std::comm::Empty;\n+    use std::task;\n+\n+    use arc::Arc;\n+    use super::{Mutex, Barrier, RWLock};\n+\n+    #[test]\n+    fn test_mutex_arc_condvar() {\n+        let arc = Arc::new(Mutex::new(false));\n+        let arc2 = arc.clone();\n+        let (tx, rx) = channel();\n+        task::spawn(proc() {\n+            // wait until parent gets in\n+            rx.recv();\n+            let mut lock = arc2.lock();\n+            *lock = true;\n+            lock.cond.signal();\n+        });\n+\n+        let lock = arc.lock();\n+        tx.send(());\n+        assert!(!*lock);\n+        while !*lock {\n+            lock.cond.wait();\n+        }\n+    }\n+\n+    #[test] #[should_fail]\n+    fn test_arc_condvar_poison() {\n+        let arc = Arc::new(Mutex::new(1));\n+        let arc2 = arc.clone();\n+        let (tx, rx) = channel();\n+\n+        spawn(proc() {\n+            rx.recv();\n+            let lock = arc2.lock();\n+            lock.cond.signal();\n+            // Parent should fail when it wakes up.\n+            fail!();\n+        });\n+\n+        let lock = arc.lock();\n+        tx.send(());\n+        while *lock == 1 {\n+            lock.cond.wait();\n+        }\n+    }\n+\n+    #[test] #[should_fail]\n+    fn test_mutex_arc_poison() {\n+        let arc = Arc::new(Mutex::new(1));\n+        let arc2 = arc.clone();\n+        let _ = task::try(proc() {\n+            let lock = arc2.lock();\n+            assert_eq!(*lock, 2);\n+        });\n+        let lock = arc.lock();\n+        assert_eq!(*lock, 1);\n+    }\n+\n+    #[test]\n+    fn test_mutex_arc_nested() {\n+        // Tests nested mutexes and access\n+        // to underlaying data.\n+        let arc = Arc::new(Mutex::new(1));\n+        let arc2 = Arc::new(Mutex::new(arc));\n+        task::spawn(proc() {\n+            let lock = arc2.lock();\n+            let lock2 = lock.deref().lock();\n+            assert_eq!(*lock2, 1);\n+        });\n+    }\n+\n+    #[test]\n+    fn test_mutex_arc_access_in_unwind() {\n+        let arc = Arc::new(Mutex::new(1i));\n+        let arc2 = arc.clone();\n+        let _ = task::try::<()>(proc() {\n+            struct Unwinder {\n+                i: Arc<Mutex<int>>,\n+            }\n+            impl Drop for Unwinder {\n+                fn drop(&mut self) {\n+                    let mut lock = self.i.lock();\n+                    *lock += 1;\n+                }\n+            }\n+            let _u = Unwinder { i: arc2 };\n+            fail!();\n+        });\n+        let lock = arc.lock();\n+        assert_eq!(*lock, 2);\n+    }\n+\n+    #[test] #[should_fail]\n+    fn test_rw_arc_poison_wr() {\n+        let arc = Arc::new(RWLock::new(1));\n+        let arc2 = arc.clone();\n+        let _ = task::try(proc() {\n+            let lock = arc2.write();\n+            assert_eq!(*lock, 2);\n+        });\n+        let lock = arc.read();\n+        assert_eq!(*lock, 1);\n+    }\n+    #[test] #[should_fail]\n+    fn test_rw_arc_poison_ww() {\n+        let arc = Arc::new(RWLock::new(1));\n+        let arc2 = arc.clone();\n+        let _ = task::try(proc() {\n+            let lock = arc2.write();\n+            assert_eq!(*lock, 2);\n+        });\n+        let lock = arc.write();\n+        assert_eq!(*lock, 1);\n+    }\n+    #[test]\n+    fn test_rw_arc_no_poison_rr() {\n+        let arc = Arc::new(RWLock::new(1));\n+        let arc2 = arc.clone();\n+        let _ = task::try(proc() {\n+            let lock = arc2.read();\n+            assert_eq!(*lock, 2);\n+        });\n+        let lock = arc.read();\n+        assert_eq!(*lock, 1);\n+    }\n+    #[test]\n+    fn test_rw_arc_no_poison_rw() {\n+        let arc = Arc::new(RWLock::new(1));\n+        let arc2 = arc.clone();\n+        let _ = task::try(proc() {\n+            let lock = arc2.read();\n+            assert_eq!(*lock, 2);\n+        });\n+        let lock = arc.write();\n+        assert_eq!(*lock, 1);\n+    }\n+    #[test]\n+    fn test_rw_arc_no_poison_dr() {\n+        let arc = Arc::new(RWLock::new(1));\n+        let arc2 = arc.clone();\n+        let _ = task::try(proc() {\n+            let lock = arc2.write().downgrade();\n+            assert_eq!(*lock, 2);\n+        });\n+        let lock = arc.write();\n+        assert_eq!(*lock, 1);\n+    }\n+\n+    #[test]\n+    fn test_rw_arc() {\n+        let arc = Arc::new(RWLock::new(0));\n+        let arc2 = arc.clone();\n+        let (tx, rx) = channel();\n+\n+        task::spawn(proc() {\n+            let mut lock = arc2.write();\n+            for _ in range(0, 10) {\n+                let tmp = *lock;\n+                *lock = -1;\n+                task::deschedule();\n+                *lock = tmp + 1;\n+            }\n+            tx.send(());\n+        });\n+\n+        // Readers try to catch the writer in the act\n+        let mut children = Vec::new();\n+        for _ in range(0, 5) {\n+            let arc3 = arc.clone();\n+            let mut builder = task::task();\n+            children.push(builder.future_result());\n+            builder.spawn(proc() {\n+                let lock = arc3.read();\n+                assert!(*lock >= 0);\n+            });\n+        }\n+\n+        // Wait for children to pass their asserts\n+        for r in children.mut_iter() {\n+            assert!(r.recv().is_ok());\n+        }\n+\n+        // Wait for writer to finish\n+        rx.recv();\n+        let lock = arc.read();\n+        assert_eq!(*lock, 10);\n+    }\n+\n+    #[test]\n+    fn test_rw_arc_access_in_unwind() {\n+        let arc = Arc::new(RWLock::new(1i));\n+        let arc2 = arc.clone();\n+        let _ = task::try::<()>(proc() {\n+            struct Unwinder {\n+                i: Arc<RWLock<int>>,\n+            }\n+            impl Drop for Unwinder {\n+                fn drop(&mut self) {\n+                    let mut lock = self.i.write();\n+                    *lock += 1;\n+                }\n+            }\n+            let _u = Unwinder { i: arc2 };\n+            fail!();\n+        });\n+        let lock = arc.read();\n+        assert_eq!(*lock, 2);\n+    }\n+\n+    #[test]\n+    fn test_rw_downgrade() {\n+        // (1) A downgrader gets in write mode and does cond.wait.\n+        // (2) A writer gets in write mode, sets state to 42, and does signal.\n+        // (3) Downgrader wakes, sets state to 31337.\n+        // (4) tells writer and all other readers to contend as it downgrades.\n+        // (5) Writer attempts to set state back to 42, while downgraded task\n+        //     and all reader tasks assert that it's 31337.\n+        let arc = Arc::new(RWLock::new(0));\n+\n+        // Reader tasks\n+        let mut reader_convos = Vec::new();\n+        for _ in range(0, 10) {\n+            let ((tx1, rx1), (tx2, rx2)) = (channel(), channel());\n+            reader_convos.push((tx1, rx2));\n+            let arcn = arc.clone();\n+            task::spawn(proc() {\n+                rx1.recv(); // wait for downgrader to give go-ahead\n+                let lock = arcn.read();\n+                assert_eq!(*lock, 31337);\n+                tx2.send(());\n+            });\n+        }\n+\n+        // Writer task\n+        let arc2 = arc.clone();\n+        let ((tx1, rx1), (tx2, rx2)) = (channel(), channel());\n+        task::spawn(proc() {\n+            rx1.recv();\n+            {\n+                let mut lock = arc2.write();\n+                assert_eq!(*lock, 0);\n+                *lock = 42;\n+                lock.cond.signal();\n+            }\n+            rx1.recv();\n+            {\n+                let mut lock = arc2.write();\n+                // This shouldn't happen until after the downgrade read\n+                // section, and all other readers, finish.\n+                assert_eq!(*lock, 31337);\n+                *lock = 42;\n+            }\n+            tx2.send(());\n+        });\n+\n+        // Downgrader (us)\n+        let mut lock = arc.write();\n+        tx1.send(()); // send to another writer who will wake us up\n+        while *lock == 0 {\n+            lock.cond.wait();\n+        }\n+        assert_eq!(*lock, 42);\n+        *lock = 31337;\n+        // send to other readers\n+        for &(ref mut rc, _) in reader_convos.mut_iter() {\n+            rc.send(())\n+        }\n+        let lock = lock.downgrade();\n+        // complete handshake with other readers\n+        for &(_, ref mut rp) in reader_convos.mut_iter() {\n+            rp.recv()\n+        }\n+        tx1.send(()); // tell writer to try again\n+        assert_eq!(*lock, 31337);\n+        drop(lock);\n+\n+        rx2.recv(); // complete handshake with writer\n+    }\n+\n+    #[cfg(test)]\n+    fn test_rw_write_cond_downgrade_read_race_helper() {\n+        // Tests that when a downgrader hands off the \"reader cloud\" lock\n+        // because of a contending reader, a writer can't race to get it\n+        // instead, which would result in readers_and_writers. This tests\n+        // the raw module rather than this one, but it's here because an\n+        // rwarc gives us extra shared state to help check for the race.\n+        let x = Arc::new(RWLock::new(true));\n+        let (tx, rx) = channel();\n+\n+        // writer task\n+        let xw = x.clone();\n+        task::spawn(proc() {\n+            let mut lock = xw.write();\n+            tx.send(()); // tell downgrader it's ok to go\n+            lock.cond.wait();\n+            // The core of the test is here: the condvar reacquire path\n+            // must involve order_lock, so that it cannot race with a reader\n+            // trying to receive the \"reader cloud lock hand-off\".\n+            *lock = false;\n+        });\n+\n+        rx.recv(); // wait for writer to get in\n+\n+        let lock = x.write();\n+        assert!(*lock);\n+        // make writer contend in the cond-reacquire path\n+        lock.cond.signal();\n+        // make a reader task to trigger the \"reader cloud lock\" handoff\n+        let xr = x.clone();\n+        let (tx, rx) = channel();\n+        task::spawn(proc() {\n+            tx.send(());\n+            drop(xr.read());\n+        });\n+        rx.recv(); // wait for reader task to exist\n+\n+        let lock = lock.downgrade();\n+        // if writer mistakenly got in, make sure it mutates state\n+        // before we assert on it\n+        for _ in range(0, 5) { task::deschedule(); }\n+        // make sure writer didn't get in.\n+        assert!(*lock);\n+    }\n+    #[test]\n+    fn test_rw_write_cond_downgrade_read_race() {\n+        // Ideally the above test case would have deschedule statements in it\n+        // that helped to expose the race nearly 100% of the time... but adding\n+        // deschedules in the intuitively-right locations made it even less\n+        // likely, and I wasn't sure why :( . This is a mediocre \"next best\"\n+        // option.\n+        for _ in range(0, 8) {\n+            test_rw_write_cond_downgrade_read_race_helper();\n+        }\n+    }\n+\n+    /************************************************************************\n+     * Barrier tests\n+     ************************************************************************/\n+    #[test]\n+    fn test_barrier() {\n+        let barrier = Arc::new(Barrier::new(10));\n+        let (tx, rx) = channel();\n+\n+        for _ in range(0, 9) {\n+            let c = barrier.clone();\n+            let tx = tx.clone();\n+            spawn(proc() {\n+                c.wait();\n+                tx.send(true);\n+            });\n+        }\n+\n+        // At this point, all spawned tasks should be blocked,\n+        // so we shouldn't get anything from the port\n+        assert!(match rx.try_recv() {\n+            Empty => true,\n+            _ => false,\n+        });\n+\n+        barrier.wait();\n+        // Now, the barrier is cleared and we should get data.\n+        for _ in range(0, 9) {\n+            rx.recv();\n+        }\n+    }\n+}\n+"}, {"sha": "12e8ca48ba1a9d10beb2596f0ea14ec4bafcdae9", "filename": "src/libsync/mpsc_intrusive.rs", "status": "renamed", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibsync%2Fmpsc_intrusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibsync%2Fmpsc_intrusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmpsc_intrusive.rs?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -35,6 +35,7 @@\n \n use std::cast;\n use std::sync::atomics;\n+use std::ty::Unsafe;\n \n // NB: all links are done as AtomicUint instead of AtomicPtr to allow for static\n // initialization.\n@@ -50,22 +51,22 @@ pub struct DummyNode {\n \n pub struct Queue<T> {\n     head: atomics::AtomicUint,\n-    tail: *mut Node<T>,\n+    tail: Unsafe<*mut Node<T>>,\n     stub: DummyNode,\n }\n \n impl<T: Send> Queue<T> {\n     pub fn new() -> Queue<T> {\n         Queue {\n             head: atomics::AtomicUint::new(0),\n-            tail: 0 as *mut Node<T>,\n+            tail: Unsafe::new(0 as *mut Node<T>),\n             stub: DummyNode {\n                 next: atomics::AtomicUint::new(0),\n             },\n         }\n     }\n \n-    pub unsafe fn push(&mut self, node: *mut Node<T>) {\n+    pub unsafe fn push(&self, node: *mut Node<T>) {\n         (*node).next.store(0, atomics::Release);\n         let prev = self.head.swap(node as uint, atomics::AcqRel);\n \n@@ -93,8 +94,8 @@ impl<T: Send> Queue<T> {\n     /// Right now consumers of this queue must be ready for this fact. Just\n     /// because `pop` returns `None` does not mean that there is not data\n     /// on the queue.\n-    pub unsafe fn pop(&mut self) -> Option<*mut Node<T>> {\n-        let tail = self.tail;\n+    pub unsafe fn pop(&self) -> Option<*mut Node<T>> {\n+        let tail = *self.tail.get();\n         let mut tail = if !tail.is_null() {tail} else {\n             cast::transmute(&self.stub)\n         };\n@@ -103,12 +104,12 @@ impl<T: Send> Queue<T> {\n             if next.is_null() {\n                 return None;\n             }\n-            self.tail = next;\n+            *self.tail.get() = next;\n             tail = next;\n             next = (*next).next(atomics::Relaxed);\n         }\n         if !next.is_null() {\n-            self.tail = next;\n+            *self.tail.get() = next;\n             return Some(tail);\n         }\n         let head = self.head.load(atomics::Acquire) as *mut Node<T>;\n@@ -119,7 +120,7 @@ impl<T: Send> Queue<T> {\n         self.push(stub);\n         next = (*tail).next(atomics::Relaxed);\n         if !next.is_null() {\n-            self.tail = next;\n+            *self.tail.get() = next;\n             return Some(tail);\n         }\n         return None\n@@ -133,7 +134,7 @@ impl<T: Send> Node<T> {\n             next: atomics::AtomicUint::new(0),\n         }\n     }\n-    pub unsafe fn next(&mut self, ord: atomics::Ordering) -> *mut Node<T> {\n+    pub unsafe fn next(&self, ord: atomics::Ordering) -> *mut Node<T> {\n         cast::transmute::<uint, *mut Node<T>>(self.next.load(ord))\n     }\n }", "previous_filename": "src/libsync/sync/mpsc_intrusive.rs"}, {"sha": "b01c82eb7ac464f5c497e02f4c8ab5e30fb0243c", "filename": "src/libsync/mutex.rs", "status": "renamed", "additions": 82, "deletions": 61, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmutex.rs?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -57,13 +57,16 @@\n // times in order to manage a few flags about who's blocking where and whether\n // it's locked or not.\n \n+use std::kinds::marker;\n+use std::mem;\n use std::rt::local::Local;\n use std::rt::task::{BlockedTask, Task};\n use std::rt::thread::Thread;\n use std::sync::atomics;\n+use std::ty::Unsafe;\n use std::unstable::mutex;\n \n-use q = sync::mpsc_intrusive;\n+use q = mpsc_intrusive;\n \n pub static LOCKED: uint = 1 << 0;\n pub static GREEN_BLOCKED: uint = 1 << 1;\n@@ -85,7 +88,7 @@ pub static NATIVE_BLOCKED: uint = 1 << 2;\n /// ```rust\n /// use sync::mutex::Mutex;\n ///\n-/// let mut m = Mutex::new();\n+/// let m = Mutex::new();\n /// let guard = m.lock();\n /// // do some work\n /// drop(guard); // unlock the lock\n@@ -126,14 +129,15 @@ enum Flavor {\n pub struct StaticMutex {\n     /// Current set of flags on this mutex\n     priv state: atomics::AtomicUint,\n+    /// an OS mutex used by native threads\n+    priv lock: mutex::StaticNativeMutex,\n+\n     /// Type of locking operation currently on this mutex\n-    priv flavor: Flavor,\n+    priv flavor: Unsafe<Flavor>,\n     /// uint-cast of the green thread waiting for this mutex\n-    priv green_blocker: uint,\n+    priv green_blocker: Unsafe<uint>,\n     /// uint-cast of the native thread waiting for this mutex\n-    priv native_blocker: uint,\n-    /// an OS mutex used by native threads\n-    priv lock: mutex::StaticNativeMutex,\n+    priv native_blocker: Unsafe<uint>,\n \n     /// A concurrent mpsc queue used by green threads, along with a count used\n     /// to figure out when to dequeue and enqueue.\n@@ -145,21 +149,24 @@ pub struct StaticMutex {\n /// dropped (falls out of scope), the lock will be unlocked.\n #[must_use]\n pub struct Guard<'a> {\n-    priv lock: &'a mut StaticMutex,\n+    priv lock: &'a StaticMutex,\n }\n \n /// Static initialization of a mutex. This constant can be used to initialize\n /// other mutex constants.\n pub static MUTEX_INIT: StaticMutex = StaticMutex {\n     lock: mutex::NATIVE_MUTEX_INIT,\n     state: atomics::INIT_ATOMIC_UINT,\n-    flavor: Unlocked,\n-    green_blocker: 0,\n-    native_blocker: 0,\n+    flavor: Unsafe { value: Unlocked, marker1: marker::InvariantType },\n+    green_blocker: Unsafe { value: 0, marker1: marker::InvariantType },\n+    native_blocker: Unsafe { value: 0, marker1: marker::InvariantType },\n     green_cnt: atomics::INIT_ATOMIC_UINT,\n     q: q::Queue {\n         head: atomics::INIT_ATOMIC_UINT,\n-        tail: 0 as *mut q::Node<uint>,\n+        tail: Unsafe {\n+            value: 0 as *mut q::Node<uint>,\n+            marker1: marker::InvariantType,\n+        },\n         stub: q::DummyNode {\n             next: atomics::INIT_ATOMIC_UINT,\n         }\n@@ -168,34 +175,34 @@ pub static MUTEX_INIT: StaticMutex = StaticMutex {\n \n impl StaticMutex {\n     /// Attempts to grab this lock, see `Mutex::try_lock`\n-    pub fn try_lock<'a>(&'a mut self) -> Option<Guard<'a>> {\n+    pub fn try_lock<'a>(&'a self) -> Option<Guard<'a>> {\n         // Attempt to steal the mutex from an unlocked state.\n         //\n         // FIXME: this can mess up the fairness of the mutex, seems bad\n         match self.state.compare_and_swap(0, LOCKED, atomics::SeqCst) {\n             0 => {\n-                assert!(self.flavor == Unlocked);\n-                self.flavor = TryLockAcquisition;\n+                // After acquiring the mutex, we can safely access the inner\n+                // fields.\n+                let prev = unsafe {\n+                    mem::replace(&mut *self.flavor.get(), TryLockAcquisition)\n+                };\n+                assert_eq!(prev, Unlocked);\n                 Some(Guard::new(self))\n             }\n             _ => None\n         }\n     }\n \n     /// Acquires this lock, see `Mutex::lock`\n-    pub fn lock<'a>(&'a mut self) -> Guard<'a> {\n+    pub fn lock<'a>(&'a self) -> Guard<'a> {\n         // First, attempt to steal the mutex from an unlocked state. The \"fast\n         // path\" needs to have as few atomic instructions as possible, and this\n         // one cmpxchg is already pretty expensive.\n         //\n         // FIXME: this can mess up the fairness of the mutex, seems bad\n-        match self.state.compare_and_swap(0, LOCKED, atomics::SeqCst) {\n-            0 => {\n-                assert!(self.flavor == Unlocked);\n-                self.flavor = TryLockAcquisition;\n-                return Guard::new(self)\n-            }\n-            _ => {}\n+        match self.try_lock() {\n+            Some(guard) => return guard,\n+            None => {}\n         }\n \n         // After we've failed the fast path, then we delegate to the differnet\n@@ -219,11 +226,14 @@ impl StaticMutex {\n         let mut old = match self.state.compare_and_swap(0, LOCKED,\n                                                         atomics::SeqCst) {\n             0 => {\n-                self.flavor = if can_block {\n+                let flavor = if can_block {\n                     NativeAcquisition\n                 } else {\n                     GreenAcquisition\n                 };\n+                // We've acquired the lock, so this unsafe access to flavor is\n+                // allowed.\n+                unsafe { *self.flavor.get() = flavor; }\n                 return Guard::new(self)\n             }\n             old => old,\n@@ -237,13 +247,15 @@ impl StaticMutex {\n         let t: ~Task = Local::take();\n         t.deschedule(1, |task| {\n             let task = unsafe { task.cast_to_uint() };\n-            if can_block {\n-                assert_eq!(self.native_blocker, 0);\n-                self.native_blocker = task;\n+\n+            // These accesses are protected by the respective native/green\n+            // mutexes which were acquired above.\n+            let prev = if can_block {\n+                unsafe { mem::replace(&mut *self.native_blocker.get(), task) }\n             } else {\n-                assert_eq!(self.green_blocker, 0);\n-                self.green_blocker = task;\n-            }\n+                unsafe { mem::replace(&mut *self.green_blocker.get(), task) }\n+            };\n+            assert_eq!(prev, 0);\n \n             loop {\n                 assert_eq!(old & native_bit, 0);\n@@ -264,14 +276,23 @@ impl StaticMutex {\n                                                             old | LOCKED,\n                                                             atomics::SeqCst) {\n                         n if n == old => {\n-                            assert_eq!(self.flavor, Unlocked);\n-                            if can_block {\n-                                self.native_blocker = 0;\n-                                self.flavor = NativeAcquisition;\n+                            // After acquiring the lock, we have access to the\n+                            // flavor field, and we've regained access to our\n+                            // respective native/green blocker field.\n+                            let prev = if can_block {\n+                                unsafe {\n+                                    *self.native_blocker.get() = 0;\n+                                    mem::replace(&mut *self.flavor.get(),\n+                                                 NativeAcquisition)\n+                                }\n                             } else {\n-                                self.green_blocker = 0;\n-                                self.flavor = GreenAcquisition;\n-                            }\n+                                unsafe {\n+                                    *self.green_blocker.get() = 0;\n+                                    mem::replace(&mut *self.flavor.get(),\n+                                                 GreenAcquisition)\n+                                }\n+                            };\n+                            assert_eq!(prev, Unlocked);\n                             return Err(unsafe {\n                                 BlockedTask::cast_from_uint(task)\n                             })\n@@ -287,16 +308,16 @@ impl StaticMutex {\n \n     // Tasks which can block are super easy. These tasks just call the blocking\n     // `lock()` function on an OS mutex\n-    fn native_lock(&mut self, t: ~Task) {\n+    fn native_lock(&self, t: ~Task) {\n         Local::put(t);\n         unsafe { self.lock.lock_noguard(); }\n     }\n \n-    fn native_unlock(&mut self) {\n+    fn native_unlock(&self) {\n         unsafe { self.lock.unlock_noguard(); }\n     }\n \n-    fn green_lock(&mut self, t: ~Task) {\n+    fn green_lock(&self, t: ~Task) {\n         // Green threads flag their presence with an atomic counter, and if they\n         // fail to be the first to the mutex, they enqueue themselves on a\n         // concurrent internal queue with a stack-allocated node.\n@@ -318,7 +339,7 @@ impl StaticMutex {\n         });\n     }\n \n-    fn green_unlock(&mut self) {\n+    fn green_unlock(&self) {\n         // If we're the only green thread, then no need to check the queue,\n         // otherwise the fixme above forces us to spin for a bit.\n         if self.green_cnt.fetch_sub(1, atomics::SeqCst) == 1 { return }\n@@ -333,7 +354,7 @@ impl StaticMutex {\n         task.wake().map(|t| t.reawaken());\n     }\n \n-    fn unlock(&mut self) {\n+    fn unlock(&self) {\n         // Unlocking this mutex is a little tricky. We favor any task that is\n         // manually blocked (not in each of the separate locks) in order to help\n         // provide a little fairness (green threads will wake up the pending\n@@ -351,8 +372,7 @@ impl StaticMutex {\n         // task needs to be woken, and in this case it's ok that the \"mutex\n         // halves\" are unlocked, we're just mainly dealing with the atomic state\n         // of the outer mutex.\n-        let flavor = self.flavor;\n-        self.flavor = Unlocked;\n+        let flavor = unsafe { mem::replace(&mut *self.flavor.get(), Unlocked) };\n \n         let mut state = self.state.load(atomics::SeqCst);\n         let mut unlocked = false;\n@@ -362,18 +382,18 @@ impl StaticMutex {\n             if state & GREEN_BLOCKED != 0 {\n                 self.unset(state, GREEN_BLOCKED);\n                 task = unsafe {\n-                    BlockedTask::cast_from_uint(self.green_blocker)\n+                    *self.flavor.get() = GreenAcquisition;\n+                    let task = mem::replace(&mut *self.green_blocker.get(), 0);\n+                    BlockedTask::cast_from_uint(task)\n                 };\n-                self.green_blocker = 0;\n-                self.flavor = GreenAcquisition;\n                 break;\n             } else if state & NATIVE_BLOCKED != 0 {\n                 self.unset(state, NATIVE_BLOCKED);\n                 task = unsafe {\n-                    BlockedTask::cast_from_uint(self.native_blocker)\n+                    *self.flavor.get() = NativeAcquisition;\n+                    let task = mem::replace(&mut *self.native_blocker.get(), 0);\n+                    BlockedTask::cast_from_uint(task)\n                 };\n-                self.native_blocker = 0;\n-                self.flavor = NativeAcquisition;\n                 break;\n             } else {\n                 assert_eq!(state, LOCKED);\n@@ -405,7 +425,7 @@ impl StaticMutex {\n     }\n \n     /// Loops around a CAS to unset the `bit` in `state`\n-    fn unset(&mut self, mut state: uint, bit: uint) {\n+    fn unset(&self, mut state: uint, bit: uint) {\n         loop {\n             assert!(state & bit != 0);\n             let new = state ^ bit;\n@@ -426,7 +446,7 @@ impl StaticMutex {\n     /// *all* platforms. It may be the case that some platforms do not leak\n     /// memory if this method is not called, but this is not guaranteed to be\n     /// true on all platforms.\n-    pub unsafe fn destroy(&mut self) {\n+    pub unsafe fn destroy(&self) {\n         self.lock.destroy()\n     }\n }\n@@ -437,9 +457,9 @@ impl Mutex {\n         Mutex {\n             lock: StaticMutex {\n                 state: atomics::AtomicUint::new(0),\n-                flavor: Unlocked,\n-                green_blocker: 0,\n-                native_blocker: 0,\n+                flavor: Unsafe::new(Unlocked),\n+                green_blocker: Unsafe::new(0),\n+                native_blocker: Unsafe::new(0),\n                 green_cnt: atomics::AtomicUint::new(0),\n                 q: q::Queue::new(),\n                 lock: unsafe { mutex::StaticNativeMutex::new() },\n@@ -454,7 +474,7 @@ impl Mutex {\n     /// guard is dropped.\n     ///\n     /// This function does not block.\n-    pub fn try_lock<'a>(&'a mut self) -> Option<Guard<'a>> {\n+    pub fn try_lock<'a>(&'a self) -> Option<Guard<'a>> {\n         self.lock.try_lock()\n     }\n \n@@ -464,13 +484,14 @@ impl Mutex {\n     /// the mutex. Upon returning, the task is the only task with the mutex\n     /// held. An RAII guard is returned to allow scoped unlock of the lock. When\n     /// the guard goes out of scope, the mutex will be unlocked.\n-    pub fn lock<'a>(&'a mut self) -> Guard<'a> { self.lock.lock() }\n+    pub fn lock<'a>(&'a self) -> Guard<'a> { self.lock.lock() }\n }\n \n impl<'a> Guard<'a> {\n-    fn new<'b>(lock: &'b mut StaticMutex) -> Guard<'b> {\n+    fn new<'b>(lock: &'b StaticMutex) -> Guard<'b> {\n         if cfg!(debug) {\n-            assert!(lock.flavor != Unlocked);\n+            // once we've acquired a lock, it's ok to access the flavor\n+            assert!(unsafe { *lock.flavor.get() != Unlocked });\n             assert!(lock.state.load(atomics::SeqCst) & LOCKED != 0);\n         }\n         Guard { lock: lock }\n@@ -501,7 +522,7 @@ mod test {\n \n     #[test]\n     fn smoke() {\n-        let mut m = Mutex::new();\n+        let m = Mutex::new();\n         drop(m.lock());\n         drop(m.lock());\n     }\n@@ -552,7 +573,7 @@ mod test {\n \n     #[test]\n     fn trylock() {\n-        let mut m = Mutex::new();\n+        let m = Mutex::new();\n         assert!(m.try_lock().is_some());\n     }\n }", "previous_filename": "src/libsync/sync/mutex.rs"}, {"sha": "161f759ca2ddf5393b18243131bb2adecfb3e841", "filename": "src/libsync/one.rs", "status": "renamed", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibsync%2Fone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibsync%2Fone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fone.rs?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -15,7 +15,8 @@\n \n use std::int;\n use std::sync::atomics;\n-use sync::mutex::{StaticMutex, MUTEX_INIT};\n+\n+use mutex::{StaticMutex, MUTEX_INIT};\n \n /// A type which can be used to run a one-time global initialization. This type\n /// is *unsafe* to use because it is built on top of the `Mutex` in this module.\n@@ -62,7 +63,7 @@ impl Once {\n     ///\n     /// When this function returns, it is guaranteed that some initialization\n     /// has run and completed (it may not be the closure specified).\n-    pub fn doit(&mut self, f: ||) {\n+    pub fn doit(&self, f: ||) {\n         // Implementation-wise, this would seem like a fairly trivial primitive.\n         // The stickler part is where our mutexes currently require an\n         // allocation, and usage of a `Once` should't leak this allocation.\n@@ -101,14 +102,13 @@ impl Once {\n         // If the count is negative, then someone else finished the job,\n         // otherwise we run the job and record how many people will try to grab\n         // this lock\n-        {\n-            let _guard = self.mutex.lock();\n-            if self.cnt.load(atomics::SeqCst) > 0 {\n-                f();\n-                let prev = self.cnt.swap(int::MIN, atomics::SeqCst);\n-                self.lock_cnt.store(prev, atomics::SeqCst);\n-            }\n+        let guard = self.mutex.lock();\n+        if self.cnt.load(atomics::SeqCst) > 0 {\n+            f();\n+            let prev = self.cnt.swap(int::MIN, atomics::SeqCst);\n+            self.lock_cnt.store(prev, atomics::SeqCst);\n         }\n+        drop(guard);\n \n         // Last one out cleans up after everyone else, no leaks!\n         if self.lock_cnt.fetch_add(-1, atomics::SeqCst) == 1 {", "previous_filename": "src/libsync/sync/one.rs"}, {"sha": "36f0748fe717f80b667c243401d2e2f70cb3ada2", "filename": "src/libsync/raw.rs", "status": "renamed", "additions": 406, "deletions": 617, "changes": 1023, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibsync%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibsync%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fraw.rs?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -8,42 +8,34 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[allow(missing_doc)];\n-\n-/**\n- * The concurrency primitives you know and love.\n- *\n- * Maybe once we have a \"core exports x only to std\" mechanism, these can be\n- * in std.\n- */\n+//! Raw concurrency primitives you know and love.\n+//!\n+//! These primitives are not recommended for general use, but are provided for\n+//! flavorful use-cases. It is recommended to use the types at the top of the\n+//! `sync` crate which wrap values directly and provide safer abstractions for\n+//! containing data.\n \n use std::cast;\n use std::comm;\n use std::kinds::marker;\n use std::mem::replace;\n-use std::sync::arc::UnsafeArc;\n use std::sync::atomics;\n use std::unstable::finally::Finally;\n \n-use arc::MutexArc;\n+use mutex;\n \n /****************************************************************************\n  * Internals\n  ****************************************************************************/\n \n-pub mod mutex;\n-pub mod one;\n-mod mpsc_intrusive;\n-\n // Each waiting task receives on one of these.\n-#[doc(hidden)]\n type WaitEnd = Receiver<()>;\n-#[doc(hidden)]\n type SignalEnd = Sender<()>;\n // A doubly-ended queue of waiting tasks.\n-#[doc(hidden)]\n-struct WaitQueue { head: Receiver<SignalEnd>,\n-                   tail: Sender<SignalEnd> }\n+struct WaitQueue {\n+    head: Receiver<SignalEnd>,\n+    tail: Sender<SignalEnd>,\n+}\n \n impl WaitQueue {\n     fn new() -> WaitQueue {\n@@ -90,33 +82,49 @@ impl WaitQueue {\n }\n \n // The building-block used to make semaphores, mutexes, and rwlocks.\n-struct SemInner<Q> {\n+struct Sem<Q> {\n     lock: mutex::Mutex,\n+    // n.b, we need Sem to be `Share`, but the WaitQueue type is not send/share\n+    //      (for good reason). We have an internal invariant on this semaphore,\n+    //      however, that the queue is never accessed outside of a locked\n+    //      context. For this reason, we shove these behind a pointer which will\n+    //      be inferred to be `Share`.\n+    //\n+    // FIXME: this requires an extra allocation, which is bad.\n+    inner: *()\n+}\n+\n+struct SemInner<Q> {\n     count: int,\n-    waiters:   WaitQueue,\n+    waiters: WaitQueue,\n     // Can be either unit or another waitqueue. Some sems shouldn't come with\n     // a condition variable attached, others should.\n-    blocked:   Q\n+    blocked: Q,\n }\n \n-struct Sem<Q>(UnsafeArc<SemInner<Q>>);\n+#[must_use]\n+struct SemGuard<'a, Q> {\n+    sem: &'a Sem<Q>,\n+}\n \n-#[doc(hidden)]\n-impl<Q:Send> Sem<Q> {\n+impl<Q: Send> Sem<Q> {\n     fn new(count: int, q: Q) -> Sem<Q> {\n-        Sem(UnsafeArc::new(SemInner {\n-            count: count,\n-            waiters: WaitQueue::new(),\n-            blocked: q,\n+        let inner = unsafe {\n+            cast::transmute(~SemInner {\n+                waiters: WaitQueue::new(),\n+                count: count,\n+                blocked: q,\n+            })\n+        };\n+        Sem {\n             lock: mutex::Mutex::new(),\n-        }))\n+            inner: inner,\n+        }\n     }\n \n     unsafe fn with(&self, f: |&mut SemInner<Q>|) {\n-        let Sem(ref arc) = *self;\n-        let state = arc.get();\n-        let _g = (*state).lock.lock();\n-        f(cast::transmute(state));\n+        let _g = self.lock.lock();\n+        f(&mut *(self.inner as *mut SemInner<Q>))\n     }\n \n     pub fn acquire(&self) {\n@@ -130,7 +138,8 @@ impl<Q:Send> Sem<Q> {\n                     waiter_nobe = Some(state.waiters.wait_end());\n                 }\n             });\n-            // Uncomment if you wish to test for sem races. Not valgrind-friendly.\n+            // Uncomment if you wish to test for sem races. Not\n+            // valgrind-friendly.\n             /* for _ in range(0, 1000) { task::deschedule(); } */\n             // Need to wait outside the exclusive.\n             if waiter_nobe.is_some() {\n@@ -150,24 +159,42 @@ impl<Q:Send> Sem<Q> {\n         }\n     }\n \n-    pub fn access<U>(&self, blk: || -> U) -> U {\n-        (|| {\n-            self.acquire();\n-            blk()\n-        }).finally(|| {\n-            self.release();\n-        })\n+    pub fn access<'a>(&'a self) -> SemGuard<'a, Q> {\n+        self.acquire();\n+        SemGuard { sem: self }\n     }\n }\n \n-#[doc(hidden)]\n-impl Sem<Vec<WaitQueue> > {\n-    fn new_and_signal(count: int, num_condvars: uint)\n-        -> Sem<Vec<WaitQueue> > {\n+#[unsafe_destructor]\n+impl<Q: Send> Drop for Sem<Q> {\n+    fn drop(&mut self) {\n+        let _waiters: ~SemInner<Q> = unsafe { cast::transmute(self.inner) };\n+        self.inner = 0 as *();\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<'a, Q: Send> Drop for SemGuard<'a, Q> {\n+    fn drop(&mut self) {\n+        self.sem.release();\n+    }\n+}\n+\n+impl Sem<Vec<WaitQueue>> {\n+    fn new_and_signal(count: int, num_condvars: uint) -> Sem<Vec<WaitQueue>> {\n         let mut queues = Vec::new();\n         for _ in range(0, num_condvars) { queues.push(WaitQueue::new()); }\n         Sem::new(count, queues)\n     }\n+\n+    // The only other places that condvars get built are rwlock.write_cond()\n+    // and rwlock_write_mode.\n+    pub fn access_cond<'a>(&'a self) -> SemCondGuard<'a> {\n+        SemCondGuard {\n+            guard: self.access(),\n+            cvar: Condvar { sem: self, order: Nothing, nopod: marker::NoPod },\n+        }\n+    }\n }\n \n // FIXME(#3598): Want to use an Option down below, but we need a custom enum\n@@ -195,27 +222,23 @@ pub struct Condvar<'a> {\n }\n \n impl<'a> Condvar<'a> {\n-    /**\n-     * Atomically drop the associated lock, and block until a signal is sent.\n-     *\n-     * # Failure\n-     * A task which is killed (i.e., by linked failure with another task)\n-     * while waiting on a condition variable will wake up, fail, and unlock\n-     * the associated lock as it unwinds.\n-     */\n+    /// Atomically drop the associated lock, and block until a signal is sent.\n+    ///\n+    /// # Failure\n+    ///\n+    /// A task which is killed while waiting on a condition variable will wake\n+    /// up, fail, and unlock the associated lock as it unwinds.\n     pub fn wait(&self) { self.wait_on(0) }\n \n-    /**\n-     * As wait(), but can specify which of multiple condition variables to\n-     * wait on. Only a signal_on() or broadcast_on() with the same condvar_id\n-     * will wake this thread.\n-     *\n-     * The associated lock must have been initialised with an appropriate\n-     * number of condvars. The condvar_id must be between 0 and num_condvars-1\n-     * or else this call will fail.\n-     *\n-     * wait() is equivalent to wait_on(0).\n-     */\n+    /// As wait(), but can specify which of multiple condition variables to\n+    /// wait on. Only a signal_on() or broadcast_on() with the same condvar_id\n+    /// will wake this thread.\n+    ///\n+    /// The associated lock must have been initialised with an appropriate\n+    /// number of condvars. The condvar_id must be between 0 and num_condvars-1\n+    /// or else this call will fail.\n+    ///\n+    /// wait() is equivalent to wait_on(0).\n     pub fn wait_on(&self, condvar_id: uint) {\n         let mut wait_end = None;\n         let mut out_of_bounds = None;\n@@ -248,7 +271,10 @@ impl<'a> Condvar<'a> {\n             }).finally(|| {\n                 // Reacquire the condvar.\n                 match self.order {\n-                    Just(lock) => lock.access(|| self.sem.acquire()),\n+                    Just(lock) => {\n+                        let _g = lock.access();\n+                        self.sem.acquire();\n+                    }\n                     Nothing => self.sem.acquire(),\n                 }\n             })\n@@ -309,7 +335,6 @@ impl<'a> Condvar<'a> {\n // Checks whether a condvar ID was out of bounds, and fails if so, or does\n // something else next on success.\n #[inline]\n-#[doc(hidden)]\n fn check_cvar_bounds<U>(\n                      out_of_bounds: Option<uint>,\n                      id: uint,\n@@ -325,35 +350,26 @@ fn check_cvar_bounds<U>(\n     }\n }\n \n-#[doc(hidden)]\n-impl Sem<Vec<WaitQueue> > {\n-    // The only other places that condvars get built are rwlock.write_cond()\n-    // and rwlock_write_mode.\n-    pub fn access_cond<U>(&self, blk: |c: &Condvar| -> U) -> U {\n-        self.access(|| {\n-            blk(&Condvar {\n-                sem: self,\n-                order: Nothing,\n-                nopod: marker::NoPod\n-            })\n-        })\n-    }\n+#[must_use]\n+struct SemCondGuard<'a> {\n+    guard: SemGuard<'a, Vec<WaitQueue>>,\n+    cvar: Condvar<'a>,\n }\n \n /****************************************************************************\n  * Semaphores\n  ****************************************************************************/\n \n /// A counting, blocking, bounded-waiting semaphore.\n-pub struct Semaphore { priv sem: Sem<()> }\n-\n+pub struct Semaphore {\n+    priv sem: Sem<()>,\n+}\n \n-impl Clone for Semaphore {\n-    /// Create a new handle to the semaphore.\n-    fn clone(&self) -> Semaphore {\n-        let Sem(ref lock) = self.sem;\n-        Semaphore { sem: Sem(lock.clone()) }\n-    }\n+/// An RAII guard used to represent an acquired resource to a semaphore. When\n+/// dropped, this value will release the resource back to the semaphore.\n+#[must_use]\n+pub struct SemaphoreGuard<'a> {\n+    priv guard: SemGuard<'a, ()>,\n }\n \n impl Semaphore {\n@@ -362,66 +378,64 @@ impl Semaphore {\n         Semaphore { sem: Sem::new(count, ()) }\n     }\n \n-    /**\n-     * Acquire a resource represented by the semaphore. Blocks if necessary\n-     * until resource(s) become available.\n-     */\n-    pub fn acquire(&self) { (&self.sem).acquire() }\n+    /// Acquire a resource represented by the semaphore. Blocks if necessary\n+    /// until resource(s) become available.\n+    pub fn acquire(&self) { self.sem.acquire() }\n \n-    /**\n-     * Release a held resource represented by the semaphore. Wakes a blocked\n-     * contending task, if any exist. Won't block the caller.\n-     */\n-    pub fn release(&self) { (&self.sem).release() }\n+    /// Release a held resource represented by the semaphore. Wakes a blocked\n+    /// contending task, if any exist. Won't block the caller.\n+    pub fn release(&self) { self.sem.release() }\n \n-    /// Run a function with ownership of one of the semaphore's resources.\n-    pub fn access<U>(&self, blk: || -> U) -> U { (&self.sem).access(blk) }\n+    /// Acquire a resource of this semaphore, returning an RAII guard which will\n+    /// release the resource when dropped.\n+    pub fn access<'a>(&'a self) -> SemaphoreGuard<'a> {\n+        SemaphoreGuard { guard: self.sem.access() }\n+    }\n }\n \n /****************************************************************************\n  * Mutexes\n  ****************************************************************************/\n \n-/**\n- * A blocking, bounded-waiting, mutual exclusion lock with an associated\n- * FIFO condition variable.\n- *\n- * # Failure\n- * A task which fails while holding a mutex will unlock the mutex as it\n- * unwinds.\n- */\n-\n-pub struct Mutex { priv sem: Sem<Vec<WaitQueue> > }\n-impl Clone for Mutex {\n-    /// Create a new handle to the mutex.\n-    fn clone(&self) -> Mutex {\n-        let Sem(ref queue) = self.sem;\n-        Mutex { sem: Sem(queue.clone()) } }\n+/// A blocking, bounded-waiting, mutual exclusion lock with an associated\n+/// FIFO condition variable.\n+///\n+/// # Failure\n+/// A task which fails while holding a mutex will unlock the mutex as it\n+/// unwinds.\n+pub struct Mutex {\n+    priv sem: Sem<Vec<WaitQueue>>,\n+}\n+\n+/// An RAII structure which is used to gain access to a mutex's condition\n+/// variable. Additionally, when a value of this type is dropped, the\n+/// corresponding mutex is also unlocked.\n+#[must_use]\n+pub struct MutexGuard<'a> {\n+    priv guard: SemGuard<'a, Vec<WaitQueue>>,\n+    /// Inner condition variable which is connected to the outer mutex, and can\n+    /// be used for atomic-unlock-and-deschedule.\n+    cond: Condvar<'a>,\n }\n \n impl Mutex {\n     /// Create a new mutex, with one associated condvar.\n     pub fn new() -> Mutex { Mutex::new_with_condvars(1) }\n \n-    /**\n-    * Create a new mutex, with a specified number of associated condvars. This\n-    * will allow calling wait_on/signal_on/broadcast_on with condvar IDs between\n-    * 0 and num_condvars-1. (If num_condvars is 0, lock_cond will be allowed but\n-    * any operations on the condvar will fail.)\n-    */\n+    /// Create a new mutex, with a specified number of associated condvars. This\n+    /// will allow calling wait_on/signal_on/broadcast_on with condvar IDs\n+    /// between 0 and num_condvars-1. (If num_condvars is 0, lock_cond will be\n+    /// allowed but any operations on the condvar will fail.)\n     pub fn new_with_condvars(num_condvars: uint) -> Mutex {\n         Mutex { sem: Sem::new_and_signal(1, num_condvars) }\n     }\n \n-\n-    /// Run a function with ownership of the mutex.\n-    pub fn lock<U>(&self, blk: || -> U) -> U {\n-        (&self.sem).access(blk)\n-    }\n-\n-    /// Run a function with ownership of the mutex and a handle to a condvar.\n-    pub fn lock_cond<U>(&self, blk: |c: &Condvar| -> U) -> U {\n-        (&self.sem).access_cond(blk)\n+    /// Acquires ownership of this mutex, returning an RAII guard which will\n+    /// unlock the mutex when dropped. The associated condition variable can\n+    /// also be accessed through the returned guard.\n+    pub fn lock<'a>(&'a self) -> MutexGuard<'a> {\n+        let SemCondGuard { guard, cvar } = self.sem.access_cond();\n+        MutexGuard { guard: guard, cond: cvar }\n     }\n }\n \n@@ -431,118 +445,95 @@ impl Mutex {\n \n // NB: Wikipedia - Readers-writers_problem#The_third_readers-writers_problem\n \n-#[doc(hidden)]\n-struct RWLockInner {\n-    // You might ask, \"Why don't you need to use an atomic for the mode flag?\"\n-    // This flag affects the behaviour of readers (for plain readers, they\n-    // assert on it; for downgraders, they use it to decide which mode to\n-    // unlock for). Consider that the flag is only unset when the very last\n-    // reader exits; therefore, it can never be unset during a reader/reader\n-    // (or reader/downgrader) race.\n-    // By the way, if we didn't care about the assert in the read unlock path,\n-    // we could instead store the mode flag in write_downgrade's stack frame,\n-    // and have the downgrade tokens store a reference to it.\n-    read_mode:  bool,\n+/// A blocking, no-starvation, reader-writer lock with an associated condvar.\n+///\n+/// # Failure\n+///\n+/// A task which fails while holding an rwlock will unlock the rwlock as it\n+/// unwinds.\n+pub struct RWLock {\n+    priv order_lock:  Semaphore,\n+    priv access_lock: Sem<Vec<WaitQueue>>,\n+\n     // The only way the count flag is ever accessed is with xadd. Since it is\n     // a read-modify-write operation, multiple xadds on different cores will\n     // always be consistent with respect to each other, so a monotonic/relaxed\n     // consistency ordering suffices (i.e., no extra barriers are needed).\n+    //\n     // FIXME(#6598): The atomics module has no relaxed ordering flag, so I use\n     // acquire/release orderings superfluously. Change these someday.\n-    read_count: atomics::AtomicUint,\n+    priv read_count: atomics::AtomicUint,\n }\n \n-/**\n- * A blocking, no-starvation, reader-writer lock with an associated condvar.\n- *\n- * # Failure\n- * A task which fails while holding an rwlock will unlock the rwlock as it\n- * unwinds.\n- */\n-pub struct RWLock {\n-    priv order_lock:  Semaphore,\n-    priv access_lock: Sem<Vec<WaitQueue> >,\n-    priv state:       UnsafeArc<RWLockInner>,\n+/// An RAII helper which is created by acquiring a read lock on an RWLock. When\n+/// dropped, this will unlock the RWLock.\n+#[must_use]\n+pub struct RWLockReadGuard<'a> {\n+    priv lock: &'a RWLock,\n+}\n+\n+/// An RAII helper which is created by acquiring a write lock on an RWLock. When\n+/// dropped, this will unlock the RWLock.\n+///\n+/// A value of this type can also be consumed to downgrade to a read-only lock.\n+#[must_use]\n+pub struct RWLockWriteGuard<'a> {\n+    priv lock: &'a RWLock,\n+    /// Inner condition variable that is connected to the write-mode of the\n+    /// outer rwlock.\n+    cond: Condvar<'a>,\n }\n \n impl RWLock {\n     /// Create a new rwlock, with one associated condvar.\n     pub fn new() -> RWLock { RWLock::new_with_condvars(1) }\n \n-    /**\n-    * Create a new rwlock, with a specified number of associated condvars.\n-    * Similar to mutex_with_condvars.\n-    */\n+    /// Create a new rwlock, with a specified number of associated condvars.\n+    /// Similar to mutex_with_condvars.\n     pub fn new_with_condvars(num_condvars: uint) -> RWLock {\n-        let state = UnsafeArc::new(RWLockInner {\n-            read_mode:  false,\n+        RWLock {\n+            order_lock: Semaphore::new(1),\n+            access_lock: Sem::new_and_signal(1, num_condvars),\n             read_count: atomics::AtomicUint::new(0),\n-        });\n-        RWLock { order_lock:  Semaphore::new(1),\n-                access_lock: Sem::new_and_signal(1, num_condvars),\n-                state:       state, }\n-    }\n-\n-    /// Create a new handle to the rwlock.\n-    pub fn clone(&self) -> RWLock {\n-        let Sem(ref access_lock_queue) = self.access_lock;\n-        RWLock { order_lock:  (&(self.order_lock)).clone(),\n-                 access_lock: Sem(access_lock_queue.clone()),\n-                 state:       self.state.clone() }\n-    }\n-\n-    /**\n-     * Run a function with the rwlock in read mode. Calls to 'read' from other\n-     * tasks may run concurrently with this one.\n-     */\n-    pub fn read<U>(&self, blk: || -> U) -> U {\n-        unsafe {\n-            (&self.order_lock).access(|| {\n-                let state = &mut *self.state.get();\n-                let old_count = state.read_count.fetch_add(1, atomics::Acquire);\n-                if old_count == 0 {\n-                    (&self.access_lock).acquire();\n-                    state.read_mode = true;\n-                }\n-            });\n-            (|| {\n-                blk()\n-            }).finally(|| {\n-                let state = &mut *self.state.get();\n-                assert!(state.read_mode);\n-                let old_count = state.read_count.fetch_sub(1, atomics::Release);\n-                assert!(old_count > 0);\n-                if old_count == 1 {\n-                    state.read_mode = false;\n-                    // Note: this release used to be outside of a locked access\n-                    // to exclusive-protected state. If this code is ever\n-                    // converted back to such (instead of using atomic ops),\n-                    // this access MUST NOT go inside the exclusive access.\n-                    (&self.access_lock).release();\n-                }\n-            })\n         }\n     }\n \n-    /**\n-     * Run a function with the rwlock in write mode. No calls to 'read' or\n-     * 'write' from other tasks will run concurrently with this one.\n-     */\n-    pub fn write<U>(&self, blk: || -> U) -> U {\n-        (&self.order_lock).acquire();\n-        (&self.access_lock).access(|| {\n-            (&self.order_lock).release();\n-            blk()\n-        })\n-    }\n+    /// Acquires a read-lock, returning an RAII guard that will unlock the lock\n+    /// when dropped. Calls to 'read' from other tasks may run concurrently with\n+    /// this one.\n+    pub fn read<'a>(&'a self) -> RWLockReadGuard<'a> {\n+        let _guard = self.order_lock.access();\n+        let old_count = self.read_count.fetch_add(1, atomics::Acquire);\n+        if old_count == 0 {\n+            self.access_lock.acquire();\n+        }\n+        RWLockReadGuard { lock: self }\n+    }\n+\n+    /// Acquire a write-lock, returning an RAII guard that will unlock the lock\n+    /// when dropped. No calls to 'read' or 'write' from other tasks will run\n+    /// concurrently with this one.\n+    ///\n+    /// You can also downgrade a write to a read by calling the `downgrade`\n+    /// method on the returned guard. Additionally, the guard will contain a\n+    /// `Condvar` attached to this lock.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use sync::raw::RWLock;\n+    ///\n+    /// let lock = RWLock::new();\n+    /// let write = lock.write();\n+    /// // ... exclusive access ...\n+    /// let read = write.downgrade();\n+    /// // ... shared access ...\n+    /// drop(read);\n+    /// ```\n+    pub fn write<'a>(&'a self) -> RWLockWriteGuard<'a> {\n+        let _g = self.order_lock.access();\n+        self.access_lock.acquire();\n \n-    /**\n-     * As write(), but also with a handle to a condvar. Waiting on this\n-     * condvar will allow readers and writers alike to take the rwlock before\n-     * the waiting task is signalled. (Note: a writer that waited and then\n-     * was signalled might reacquire the lock before other waiting writers.)\n-     */\n-    pub fn write_cond<U>(&self, blk: |c: &Condvar| -> U) -> U {\n         // It's important to thread our order lock into the condvar, so that\n         // when a cond.wait() wakes up, it uses it while reacquiring the\n         // access lock. If we permitted a waking-up writer to \"cut in line\",\n@@ -569,188 +560,60 @@ impl RWLock {\n         // which can't happen until T2 finishes the downgrade-read entirely.\n         // The astute reader will also note that making waking writers use the\n         // order_lock is better for not starving readers.\n-        (&self.order_lock).acquire();\n-        (&self.access_lock).access_cond(|cond| {\n-            (&self.order_lock).release();\n-            let opt_lock = Just(&self.order_lock);\n-            blk(&Condvar { sem: cond.sem, order: opt_lock,\n-                           nopod: marker::NoPod })\n-        })\n-    }\n-\n-    /**\n-     * As write(), but with the ability to atomically 'downgrade' the lock;\n-     * i.e., to become a reader without letting other writers get the lock in\n-     * the meantime (such as unlocking and then re-locking as a reader would\n-     * do). The block takes a \"write mode token\" argument, which can be\n-     * transformed into a \"read mode token\" by calling downgrade(). Example:\n-     *\n-     * # Example\n-     *\n-     * ```rust\n-     * use sync::RWLock;\n-     *\n-     * let lock = RWLock::new();\n-     * lock.write_downgrade(|mut write_token| {\n-     *     write_token.write_cond(|condvar| {\n-     *         // ... exclusive access ...\n-     *     });\n-     *     let read_token = lock.downgrade(write_token);\n-     *     read_token.read(|| {\n-     *         // ... shared access ...\n-     *     })\n-     * })\n-     * ```\n-     */\n-    pub fn write_downgrade<U>(&self, blk: |v: RWLockWriteMode| -> U) -> U {\n-        // Implementation slightly different from the slicker 'write's above.\n-        // The exit path is conditional on whether the caller downgrades.\n-        (&self.order_lock).acquire();\n-        (&self.access_lock).acquire();\n-        (&self.order_lock).release();\n-        (|| {\n-            blk(RWLockWriteMode { lock: self, nopod: marker::NoPod })\n-        }).finally(|| {\n-            let writer_or_last_reader;\n-            // Check if we're releasing from read mode or from write mode.\n-            let state = unsafe { &mut *self.state.get() };\n-            if state.read_mode {\n-                // Releasing from read mode.\n-                let old_count = state.read_count.fetch_sub(1, atomics::Release);\n-                assert!(old_count > 0);\n-                // Check if other readers remain.\n-                if old_count == 1 {\n-                    // Case 1: Writer downgraded & was the last reader\n-                    writer_or_last_reader = true;\n-                    state.read_mode = false;\n-                } else {\n-                    // Case 2: Writer downgraded & was not the last reader\n-                    writer_or_last_reader = false;\n-                }\n-            } else {\n-                // Case 3: Writer did not downgrade\n-                writer_or_last_reader = true;\n-            }\n-            if writer_or_last_reader {\n-                // Nobody left inside; release the \"reader cloud\" lock.\n-                (&self.access_lock).release();\n-            }\n-        })\n-    }\n-\n-    /// To be called inside of the write_downgrade block.\n-    pub fn downgrade<'a>(&self, token: RWLockWriteMode<'a>)\n-                         -> RWLockReadMode<'a> {\n-        if !((self as *RWLock) == (token.lock as *RWLock)) {\n-            fail!(\"Can't downgrade() with a different rwlock's write_mode!\");\n-        }\n-        unsafe {\n-            let state = &mut *self.state.get();\n-            assert!(!state.read_mode);\n-            state.read_mode = true;\n-            // If a reader attempts to enter at this point, both the\n-            // downgrader and reader will set the mode flag. This is fine.\n-            let old_count = state.read_count.fetch_add(1, atomics::Release);\n-            // If another reader was already blocking, we need to hand-off\n-            // the \"reader cloud\" access lock to them.\n-            if old_count != 0 {\n-                // Guaranteed not to let another writer in, because\n-                // another reader was holding the order_lock. Hence they\n-                // must be the one to get the access_lock (because all\n-                // access_locks are acquired with order_lock held). See\n-                // the comment in write_cond for more justification.\n-                (&self.access_lock).release();\n+        RWLockWriteGuard {\n+            lock: self,\n+            cond: Condvar {\n+                sem: &self.access_lock,\n+                order: Just(&self.order_lock),\n+                nopod: marker::NoPod,\n             }\n         }\n-        RWLockReadMode { lock: token.lock, nopod: marker::NoPod }\n     }\n }\n \n-/// The \"write permission\" token used for rwlock.write_downgrade().\n-\n-pub struct RWLockWriteMode<'a> { priv lock: &'a RWLock, priv nopod: marker::NoPod }\n-/// The \"read permission\" token used for rwlock.write_downgrade().\n-pub struct RWLockReadMode<'a> { priv lock: &'a RWLock,\n-                                   priv nopod: marker::NoPod }\n-\n-impl<'a> RWLockWriteMode<'a> {\n-    /// Access the pre-downgrade rwlock in write mode.\n-    pub fn write<U>(&self, blk: || -> U) -> U { blk() }\n-    /// Access the pre-downgrade rwlock in write mode with a condvar.\n-    pub fn write_cond<U>(&self, blk: |c: &Condvar| -> U) -> U {\n-        // Need to make the condvar use the order lock when reacquiring the\n-        // access lock. See comment in RWLock::write_cond for why.\n-        blk(&Condvar { sem:        &self.lock.access_lock,\n-                       order: Just(&self.lock.order_lock),\n-                       nopod: marker::NoPod })\n+impl<'a> RWLockWriteGuard<'a> {\n+    /// Consumes this write lock and converts it into a read lock.\n+    pub fn downgrade(self) -> RWLockReadGuard<'a> {\n+        let lock = self.lock;\n+        // Don't run the destructor of the write guard, we're in charge of\n+        // things from now on\n+        unsafe { cast::forget(self) }\n+\n+        let old_count = lock.read_count.fetch_add(1, atomics::Release);\n+        // If another reader was already blocking, we need to hand-off\n+        // the \"reader cloud\" access lock to them.\n+        if old_count != 0 {\n+            // Guaranteed not to let another writer in, because\n+            // another reader was holding the order_lock. Hence they\n+            // must be the one to get the access_lock (because all\n+            // access_locks are acquired with order_lock held). See\n+            // the comment in write_cond for more justification.\n+            lock.access_lock.release();\n+        }\n+        RWLockReadGuard { lock: lock }\n     }\n }\n \n-impl<'a> RWLockReadMode<'a> {\n-    /// Access the post-downgrade rwlock in read mode.\n-    pub fn read<U>(&self, blk: || -> U) -> U { blk() }\n-}\n-\n-/// A barrier enables multiple tasks to synchronize the beginning\n-/// of some computation.\n-///\n-/// ```rust\n-/// use sync::Barrier;\n-///\n-/// let barrier = Barrier::new(10);\n-/// for _ in range(0, 10) {\n-///     let c = barrier.clone();\n-///     // The same messages will be printed together.\n-///     // You will NOT see any interleaving.\n-///     spawn(proc() {\n-///         println!(\"before wait\");\n-///         c.wait();\n-///         println!(\"after wait\");\n-///     });\n-/// }\n-/// ```\n-#[deriving(Clone)]\n-pub struct Barrier {\n-    priv arc: MutexArc<BarrierState>,\n-    priv num_tasks: uint,\n-}\n-\n-// The inner state of a double barrier\n-struct BarrierState {\n-    count: uint,\n-    generation_id: uint,\n+#[unsafe_destructor]\n+impl<'a> Drop for RWLockWriteGuard<'a> {\n+    fn drop(&mut self) {\n+        self.lock.access_lock.release();\n+    }\n }\n \n-impl Barrier {\n-    /// Create a new barrier that can block a given number of tasks.\n-    pub fn new(num_tasks: uint) -> Barrier {\n-        Barrier {\n-            arc: MutexArc::new(BarrierState {\n-                count: 0,\n-                generation_id: 0,\n-            }),\n-            num_tasks: num_tasks,\n+#[unsafe_destructor]\n+impl<'a> Drop for RWLockReadGuard<'a> {\n+    fn drop(&mut self) {\n+        let old_count = self.lock.read_count.fetch_sub(1, atomics::Release);\n+        assert!(old_count > 0);\n+        if old_count == 1 {\n+            // Note: this release used to be outside of a locked access\n+            // to exclusive-protected state. If this code is ever\n+            // converted back to such (instead of using atomic ops),\n+            // this access MUST NOT go inside the exclusive access.\n+            self.lock.access_lock.release();\n         }\n     }\n-\n-    /// Block the current task until a certain number of tasks is waiting.\n-    pub fn wait(&self) {\n-        self.arc.access_cond(|state, cond| {\n-            let local_gen = state.generation_id;\n-            state.count += 1;\n-            if state.count < self.num_tasks {\n-                // We need a while loop to guard against spurious wakeups.\n-                // http://en.wikipedia.org/wiki/Spurious_wakeup\n-                while local_gen == state.generation_id && state.count < self.num_tasks {\n-                    cond.wait();\n-                }\n-            } else {\n-                state.count = 0;\n-                state.generation_id += 1;\n-                cond.broadcast();\n-            }\n-        });\n-    }\n }\n \n /****************************************************************************\n@@ -759,12 +622,12 @@ impl Barrier {\n \n #[cfg(test)]\n mod tests {\n-    use sync::{Semaphore, Mutex, RWLock, Barrier, Condvar};\n+    use arc::Arc;\n+    use super::{Semaphore, Mutex, RWLock, Condvar};\n \n     use std::cast;\n     use std::result;\n     use std::task;\n-    use std::comm::Empty;\n \n     /************************************************************************\n      * Semaphore tests\n@@ -779,26 +642,24 @@ mod tests {\n     #[test]\n     fn test_sem_basic() {\n         let s = Semaphore::new(1);\n-        s.access(|| { })\n+        let _g = s.access();\n     }\n     #[test]\n     fn test_sem_as_mutex() {\n-        let s = Semaphore::new(1);\n+        let s = Arc::new(Semaphore::new(1));\n         let s2 = s.clone();\n         task::spawn(proc() {\n-            s2.access(|| {\n-                for _ in range(0, 5) { task::deschedule(); }\n-            })\n-        });\n-        s.access(|| {\n+            let _g = s2.access();\n             for _ in range(0, 5) { task::deschedule(); }\n-        })\n+        });\n+        let _g = s.access();\n+        for _ in range(0, 5) { task::deschedule(); }\n     }\n     #[test]\n     fn test_sem_as_cvar() {\n         /* Child waits and parent signals */\n         let (tx, rx) = channel();\n-        let s = Semaphore::new(0);\n+        let s = Arc::new(Semaphore::new(0));\n         let s2 = s.clone();\n         task::spawn(proc() {\n             s2.acquire();\n@@ -810,7 +671,7 @@ mod tests {\n \n         /* Parent waits and child signals */\n         let (tx, rx) = channel();\n-        let s = Semaphore::new(0);\n+        let s = Arc::new(Semaphore::new(0));\n         let s2 = s.clone();\n         task::spawn(proc() {\n             for _ in range(0, 5) { task::deschedule(); }\n@@ -824,40 +685,37 @@ mod tests {\n     fn test_sem_multi_resource() {\n         // Parent and child both get in the critical section at the same\n         // time, and shake hands.\n-        let s = Semaphore::new(2);\n+        let s = Arc::new(Semaphore::new(2));\n         let s2 = s.clone();\n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n         task::spawn(proc() {\n-            s2.access(|| {\n-                let _ = rx2.recv();\n-                tx1.send(());\n-            })\n+            let _g = s2.access();\n+            let _ = rx2.recv();\n+            tx1.send(());\n         });\n-        s.access(|| {\n-            tx2.send(());\n-            let _ = rx1.recv();\n-        })\n+        let _g = s.access();\n+        tx2.send(());\n+        let _ = rx1.recv();\n     }\n     #[test]\n     fn test_sem_runtime_friendly_blocking() {\n         // Force the runtime to schedule two threads on the same sched_loop.\n         // When one blocks, it should schedule the other one.\n-        let s = Semaphore::new(1);\n+        let s = Arc::new(Semaphore::new(1));\n         let s2 = s.clone();\n         let (tx, rx) = channel();\n-        let mut child_data = Some((s2, tx));\n-        s.access(|| {\n-            let (s2, tx) = child_data.take_unwrap();\n+        {\n+            let _g = s.access();\n             task::spawn(proc() {\n                 tx.send(());\n-                s2.access(|| { });\n+                drop(s2.access());\n                 tx.send(());\n             });\n-            let _ = rx.recv(); // wait for child to come alive\n+            rx.recv(); // wait for child to come alive\n             for _ in range(0, 5) { task::deschedule(); } // let the child contend\n-        });\n-        let _ = rx.recv(); // wait for child to be done\n+        }\n+        rx.recv(); // wait for child to be done\n     }\n     /************************************************************************\n      * Mutex tests\n@@ -867,93 +725,90 @@ mod tests {\n         // Unsafely achieve shared state, and do the textbook\n         // \"load tmp = move ptr; inc tmp; store ptr <- tmp\" dance.\n         let (tx, rx) = channel();\n-        let m = Mutex::new();\n+        let m = Arc::new(Mutex::new());\n         let m2 = m.clone();\n         let mut sharedstate = ~0;\n         {\n-            let ptr: *int = &*sharedstate;\n+            let ptr: *mut int = &mut *sharedstate;\n             task::spawn(proc() {\n-                let sharedstate: &mut int =\n-                    unsafe { cast::transmute(ptr) };\n-                access_shared(sharedstate, &m2, 10);\n+                access_shared(ptr, &m2, 10);\n                 tx.send(());\n             });\n         }\n         {\n-            access_shared(sharedstate, &m, 10);\n+            access_shared(&mut *sharedstate, &m, 10);\n             let _ = rx.recv();\n \n             assert_eq!(*sharedstate, 20);\n         }\n \n-        fn access_shared(sharedstate: &mut int, m: &Mutex, n: uint) {\n+        fn access_shared(sharedstate: *mut int, m: &Arc<Mutex>, n: uint) {\n             for _ in range(0, n) {\n-                m.lock(|| {\n-                    let oldval = *sharedstate;\n-                    task::deschedule();\n-                    *sharedstate = oldval + 1;\n-                })\n+                let _g = m.lock();\n+                let oldval = unsafe { *sharedstate };\n+                task::deschedule();\n+                unsafe { *sharedstate = oldval + 1; }\n             }\n         }\n     }\n     #[test]\n     fn test_mutex_cond_wait() {\n-        let m = Mutex::new();\n+        let m = Arc::new(Mutex::new());\n \n         // Child wakes up parent\n-        m.lock_cond(|cond| {\n+        {\n+            let lock = m.lock();\n             let m2 = m.clone();\n             task::spawn(proc() {\n-                m2.lock_cond(|cond| {\n-                    let woken = cond.signal();\n-                    assert!(woken);\n-                })\n+                let lock = m2.lock();\n+                let woken = lock.cond.signal();\n+                assert!(woken);\n             });\n-            cond.wait();\n-        });\n+            lock.cond.wait();\n+        }\n         // Parent wakes up child\n         let (tx, rx) = channel();\n         let m3 = m.clone();\n         task::spawn(proc() {\n-            m3.lock_cond(|cond| {\n-                tx.send(());\n-                cond.wait();\n-                tx.send(());\n-            })\n+            let lock = m3.lock();\n+            tx.send(());\n+            lock.cond.wait();\n+            tx.send(());\n         });\n-        let _ = rx.recv(); // Wait until child gets in the mutex\n-        m.lock_cond(|cond| {\n-            let woken = cond.signal();\n+        rx.recv(); // Wait until child gets in the mutex\n+        {\n+            let lock = m.lock();\n+            let woken = lock.cond.signal();\n             assert!(woken);\n-        });\n-        let _ = rx.recv(); // Wait until child wakes up\n+        }\n+        rx.recv(); // Wait until child wakes up\n     }\n-    #[cfg(test)]\n+\n     fn test_mutex_cond_broadcast_helper(num_waiters: uint) {\n-        let m = Mutex::new();\n-        let mut rxs = vec!();\n+        let m = Arc::new(Mutex::new());\n+        let mut rxs = Vec::new();\n \n         for _ in range(0, num_waiters) {\n             let mi = m.clone();\n             let (tx, rx) = channel();\n             rxs.push(rx);\n             task::spawn(proc() {\n-                mi.lock_cond(|cond| {\n-                    tx.send(());\n-                    cond.wait();\n-                    tx.send(());\n-                })\n+                let lock = mi.lock();\n+                tx.send(());\n+                lock.cond.wait();\n+                tx.send(());\n             });\n         }\n \n         // wait until all children get in the mutex\n-        for rx in rxs.mut_iter() { let _ = rx.recv(); }\n-        m.lock_cond(|cond| {\n-            let num_woken = cond.broadcast();\n+        for rx in rxs.mut_iter() { rx.recv(); }\n+        {\n+            let lock = m.lock();\n+            let num_woken = lock.cond.broadcast();\n             assert_eq!(num_woken, num_waiters);\n-        });\n+        }\n         // wait until all children wake up\n-        for rx in rxs.mut_iter() { let _ = rx.recv(); }\n+        for rx in rxs.mut_iter() { rx.recv(); }\n     }\n     #[test]\n     fn test_mutex_cond_broadcast() {\n@@ -965,61 +820,57 @@ mod tests {\n     }\n     #[test]\n     fn test_mutex_cond_no_waiter() {\n-        let m = Mutex::new();\n+        let m = Arc::new(Mutex::new());\n         let m2 = m.clone();\n         let _ = task::try(proc() {\n-            m.lock_cond(|_x| { })\n+            drop(m.lock());\n         });\n-        m2.lock_cond(|cond| {\n-            assert!(!cond.signal());\n-        })\n+        let lock = m2.lock();\n+        assert!(!lock.cond.signal());\n     }\n     #[test]\n     fn test_mutex_killed_simple() {\n         use std::any::Any;\n \n         // Mutex must get automatically unlocked if failed/killed within.\n-        let m = Mutex::new();\n+        let m = Arc::new(Mutex::new());\n         let m2 = m.clone();\n \n         let result: result::Result<(), ~Any> = task::try(proc() {\n-            m2.lock(|| {\n-                fail!();\n-            })\n+            let _lock = m2.lock();\n+            fail!();\n         });\n         assert!(result.is_err());\n         // child task must have finished by the time try returns\n-        m.lock(|| { })\n+        drop(m.lock());\n     }\n     #[test]\n     fn test_mutex_cond_signal_on_0() {\n         // Tests that signal_on(0) is equivalent to signal().\n-        let m = Mutex::new();\n-        m.lock_cond(|cond| {\n-            let m2 = m.clone();\n-            task::spawn(proc() {\n-                m2.lock_cond(|cond| {\n-                    cond.signal_on(0);\n-                })\n-            });\n-            cond.wait();\n-        })\n+        let m = Arc::new(Mutex::new());\n+        let lock = m.lock();\n+        let m2 = m.clone();\n+        task::spawn(proc() {\n+            let lock = m2.lock();\n+            lock.cond.signal_on(0);\n+        });\n+        lock.cond.wait();\n     }\n     #[test]\n     fn test_mutex_no_condvars() {\n         let result = task::try(proc() {\n             let m = Mutex::new_with_condvars(0);\n-            m.lock_cond(|cond| { cond.wait(); })\n+            m.lock().cond.wait();\n         });\n         assert!(result.is_err());\n         let result = task::try(proc() {\n             let m = Mutex::new_with_condvars(0);\n-            m.lock_cond(|cond| { cond.signal(); })\n+            m.lock().cond.signal();\n         });\n         assert!(result.is_err());\n         let result = task::try(proc() {\n             let m = Mutex::new_with_condvars(0);\n-            m.lock_cond(|cond| { cond.broadcast(); })\n+            m.lock().cond.broadcast();\n         });\n         assert!(result.is_err());\n     }\n@@ -1029,23 +880,16 @@ mod tests {\n     #[cfg(test)]\n     pub enum RWLockMode { Read, Write, Downgrade, DowngradeRead }\n     #[cfg(test)]\n-    fn lock_rwlock_in_mode(x: &RWLock, mode: RWLockMode, blk: ||) {\n+    fn lock_rwlock_in_mode(x: &Arc<RWLock>, mode: RWLockMode, blk: ||) {\n         match mode {\n-            Read => x.read(blk),\n-            Write => x.write(blk),\n-            Downgrade =>\n-                x.write_downgrade(|mode| {\n-                    mode.write(|| { blk() });\n-                }),\n-            DowngradeRead =>\n-                x.write_downgrade(|mode| {\n-                    let mode = x.downgrade(mode);\n-                    mode.read(|| { blk() });\n-                }),\n+            Read => { let _g = x.read(); blk() }\n+            Write => { let _g = x.write(); blk() }\n+            Downgrade => { let _g = x.write(); blk() }\n+            DowngradeRead => { let _g = x.write().downgrade(); blk() }\n         }\n     }\n     #[cfg(test)]\n-    fn test_rwlock_exclusion(x: &RWLock,\n+    fn test_rwlock_exclusion(x: Arc<RWLock>,\n                              mode1: RWLockMode,\n                              mode2: RWLockMode) {\n         // Test mutual exclusion between readers and writers. Just like the\n@@ -1063,14 +907,14 @@ mod tests {\n             });\n         }\n         {\n-            access_shared(sharedstate, x, mode2, 10);\n+            access_shared(sharedstate, &x, mode2, 10);\n             let _ = rx.recv();\n \n             assert_eq!(*sharedstate, 20);\n         }\n \n-        fn access_shared(sharedstate: &mut int, x: &RWLock, mode: RWLockMode,\n-                         n: uint) {\n+        fn access_shared(sharedstate: &mut int, x: &Arc<RWLock>,\n+                         mode: RWLockMode, n: uint) {\n             for _ in range(0, n) {\n                 lock_rwlock_in_mode(x, mode, || {\n                     let oldval = *sharedstate;\n@@ -1082,132 +926,127 @@ mod tests {\n     }\n     #[test]\n     fn test_rwlock_readers_wont_modify_the_data() {\n-        test_rwlock_exclusion(&RWLock::new(), Read, Write);\n-        test_rwlock_exclusion(&RWLock::new(), Write, Read);\n-        test_rwlock_exclusion(&RWLock::new(), Read, Downgrade);\n-        test_rwlock_exclusion(&RWLock::new(), Downgrade, Read);\n+        test_rwlock_exclusion(Arc::new(RWLock::new()), Read, Write);\n+        test_rwlock_exclusion(Arc::new(RWLock::new()), Write, Read);\n+        test_rwlock_exclusion(Arc::new(RWLock::new()), Read, Downgrade);\n+        test_rwlock_exclusion(Arc::new(RWLock::new()), Downgrade, Read);\n+        test_rwlock_exclusion(Arc::new(RWLock::new()), Write, DowngradeRead);\n+        test_rwlock_exclusion(Arc::new(RWLock::new()), DowngradeRead, Write);\n     }\n     #[test]\n     fn test_rwlock_writers_and_writers() {\n-        test_rwlock_exclusion(&RWLock::new(), Write, Write);\n-        test_rwlock_exclusion(&RWLock::new(), Write, Downgrade);\n-        test_rwlock_exclusion(&RWLock::new(), Downgrade, Write);\n-        test_rwlock_exclusion(&RWLock::new(), Downgrade, Downgrade);\n+        test_rwlock_exclusion(Arc::new(RWLock::new()), Write, Write);\n+        test_rwlock_exclusion(Arc::new(RWLock::new()), Write, Downgrade);\n+        test_rwlock_exclusion(Arc::new(RWLock::new()), Downgrade, Write);\n+        test_rwlock_exclusion(Arc::new(RWLock::new()), Downgrade, Downgrade);\n     }\n     #[cfg(test)]\n-    fn test_rwlock_handshake(x: &RWLock,\n-                                 mode1: RWLockMode,\n-                                 mode2: RWLockMode,\n-                                 make_mode2_go_first: bool) {\n+    fn test_rwlock_handshake(x: Arc<RWLock>,\n+                             mode1: RWLockMode,\n+                             mode2: RWLockMode,\n+                             make_mode2_go_first: bool) {\n         // Much like sem_multi_resource.\n         let x2 = x.clone();\n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n         task::spawn(proc() {\n             if !make_mode2_go_first {\n-                let _ = rx2.recv(); // parent sends to us once it locks, or ...\n+                rx2.recv(); // parent sends to us once it locks, or ...\n             }\n             lock_rwlock_in_mode(&x2, mode2, || {\n                 if make_mode2_go_first {\n                     tx1.send(()); // ... we send to it once we lock\n                 }\n-                let _ = rx2.recv();\n+                rx2.recv();\n                 tx1.send(());\n             })\n         });\n         if make_mode2_go_first {\n-            let _ = rx1.recv(); // child sends to us once it locks, or ...\n+            rx1.recv(); // child sends to us once it locks, or ...\n         }\n-        lock_rwlock_in_mode(x, mode1, || {\n+        lock_rwlock_in_mode(&x, mode1, || {\n             if !make_mode2_go_first {\n                 tx2.send(()); // ... we send to it once we lock\n             }\n             tx2.send(());\n-            let _ = rx1.recv();\n+            rx1.recv();\n         })\n     }\n     #[test]\n     fn test_rwlock_readers_and_readers() {\n-        test_rwlock_handshake(&RWLock::new(), Read, Read, false);\n+        test_rwlock_handshake(Arc::new(RWLock::new()), Read, Read, false);\n         // The downgrader needs to get in before the reader gets in, otherwise\n         // they cannot end up reading at the same time.\n-        test_rwlock_handshake(&RWLock::new(), DowngradeRead, Read, false);\n-        test_rwlock_handshake(&RWLock::new(), Read, DowngradeRead, true);\n+        test_rwlock_handshake(Arc::new(RWLock::new()), DowngradeRead, Read, false);\n+        test_rwlock_handshake(Arc::new(RWLock::new()), Read, DowngradeRead, true);\n         // Two downgrade_reads can never both end up reading at the same time.\n     }\n     #[test]\n     fn test_rwlock_downgrade_unlock() {\n         // Tests that downgrade can unlock the lock in both modes\n-        let x = RWLock::new();\n+        let x = Arc::new(RWLock::new());\n         lock_rwlock_in_mode(&x, Downgrade, || { });\n-        test_rwlock_handshake(&x, Read, Read, false);\n-        let y = RWLock::new();\n+        test_rwlock_handshake(x, Read, Read, false);\n+        let y = Arc::new(RWLock::new());\n         lock_rwlock_in_mode(&y, DowngradeRead, || { });\n-        test_rwlock_exclusion(&y, Write, Write);\n+        test_rwlock_exclusion(y, Write, Write);\n     }\n     #[test]\n     fn test_rwlock_read_recursive() {\n         let x = RWLock::new();\n-        x.read(|| { x.read(|| { }) })\n+        let _g1 = x.read();\n+        let _g2 = x.read();\n     }\n     #[test]\n     fn test_rwlock_cond_wait() {\n         // As test_mutex_cond_wait above.\n-        let x = RWLock::new();\n+        let x = Arc::new(RWLock::new());\n \n         // Child wakes up parent\n-        x.write_cond(|cond| {\n+        {\n+            let lock = x.write();\n             let x2 = x.clone();\n             task::spawn(proc() {\n-                x2.write_cond(|cond| {\n-                    let woken = cond.signal();\n-                    assert!(woken);\n-                })\n+                let lock = x2.write();\n+                assert!(lock.cond.signal());\n             });\n-            cond.wait();\n-        });\n+            lock.cond.wait();\n+        }\n         // Parent wakes up child\n         let (tx, rx) = channel();\n         let x3 = x.clone();\n         task::spawn(proc() {\n-            x3.write_cond(|cond| {\n-                tx.send(());\n-                cond.wait();\n-                tx.send(());\n-            })\n-        });\n-        let _ = rx.recv(); // Wait until child gets in the rwlock\n-        x.read(|| { }); // Must be able to get in as a reader in the meantime\n-        x.write_cond(|cond| { // Or as another writer\n-            let woken = cond.signal();\n-            assert!(woken);\n+            let lock = x3.write();\n+            tx.send(());\n+            lock.cond.wait();\n+            tx.send(());\n         });\n-        let _ = rx.recv(); // Wait until child wakes up\n-        x.read(|| { }); // Just for good measure\n+        rx.recv(); // Wait until child gets in the rwlock\n+        drop(x.read()); // Must be able to get in as a reader\n+        {\n+            let x = x.write();\n+            assert!(x.cond.signal());\n+        }\n+        rx.recv(); // Wait until child wakes up\n+        drop(x.read()); // Just for good measure\n     }\n     #[cfg(test)]\n-    fn test_rwlock_cond_broadcast_helper(num_waiters: uint,\n-                                             dg1: bool,\n-                                             dg2: bool) {\n+    fn test_rwlock_cond_broadcast_helper(num_waiters: uint) {\n         // Much like the mutex broadcast test. Downgrade-enabled.\n-        fn lock_cond(x: &RWLock, downgrade: bool, blk: |c: &Condvar|) {\n-            if downgrade {\n-                x.write_downgrade(|mode| {\n-                    mode.write_cond(|c| { blk(c) });\n-                });\n-            } else {\n-                x.write_cond(|c| { blk(c) });\n-            }\n+        fn lock_cond(x: &Arc<RWLock>, blk: |c: &Condvar|) {\n+            let lock = x.write();\n+            blk(&lock.cond);\n         }\n-        let x = RWLock::new();\n-        let mut rxs = vec!();\n+\n+        let x = Arc::new(RWLock::new());\n+        let mut rxs = Vec::new();\n \n         for _ in range(0, num_waiters) {\n             let xi = x.clone();\n             let (tx, rx) = channel();\n             rxs.push(rx);\n             task::spawn(proc() {\n-                lock_cond(&xi, dg1, |cond| {\n+                lock_cond(&xi, |cond| {\n                     tx.send(());\n                     cond.wait();\n                     tx.send(());\n@@ -1217,7 +1056,7 @@ mod tests {\n \n         // wait until all children get in the mutex\n         for rx in rxs.mut_iter() { let _ = rx.recv(); }\n-        lock_cond(&x, dg2, |cond| {\n+        lock_cond(&x, |cond| {\n             let num_woken = cond.broadcast();\n             assert_eq!(num_woken, num_waiters);\n         });\n@@ -1226,21 +1065,15 @@ mod tests {\n     }\n     #[test]\n     fn test_rwlock_cond_broadcast() {\n-        test_rwlock_cond_broadcast_helper(0, true, true);\n-        test_rwlock_cond_broadcast_helper(0, true, false);\n-        test_rwlock_cond_broadcast_helper(0, false, true);\n-        test_rwlock_cond_broadcast_helper(0, false, false);\n-        test_rwlock_cond_broadcast_helper(12, true, true);\n-        test_rwlock_cond_broadcast_helper(12, true, false);\n-        test_rwlock_cond_broadcast_helper(12, false, true);\n-        test_rwlock_cond_broadcast_helper(12, false, false);\n+        test_rwlock_cond_broadcast_helper(0);\n+        test_rwlock_cond_broadcast_helper(12);\n     }\n     #[cfg(test)]\n     fn rwlock_kill_helper(mode1: RWLockMode, mode2: RWLockMode) {\n         use std::any::Any;\n \n         // Mutex must get automatically unlocked if failed/killed within.\n-        let x = RWLock::new();\n+        let x = Arc::new(RWLock::new());\n         let x2 = x.clone();\n \n         let result: result::Result<(), ~Any> = task::try(proc() {\n@@ -1283,48 +1116,4 @@ mod tests {\n         rwlock_kill_helper(Downgrade, DowngradeRead);\n         rwlock_kill_helper(Downgrade, DowngradeRead);\n     }\n-    #[test] #[should_fail]\n-    fn test_rwlock_downgrade_cant_swap() {\n-        // Tests that you can't downgrade with a different rwlock's token.\n-        let x = RWLock::new();\n-        let y = RWLock::new();\n-        x.write_downgrade(|xwrite| {\n-            let mut xopt = Some(xwrite);\n-            y.write_downgrade(|_ywrite| {\n-                y.downgrade(xopt.take_unwrap());\n-                error!(\"oops, y.downgrade(x) should have failed!\");\n-            })\n-        })\n-    }\n-\n-    /************************************************************************\n-     * Barrier tests\n-     ************************************************************************/\n-    #[test]\n-    fn test_barrier() {\n-        let barrier = Barrier::new(10);\n-        let (tx, rx) = channel();\n-\n-        for _ in range(0, 9) {\n-            let c = barrier.clone();\n-            let tx = tx.clone();\n-            spawn(proc() {\n-                c.wait();\n-                tx.send(true);\n-            });\n-        }\n-\n-        // At this point, all spawned tasks should be blocked,\n-        // so we shouldn't get anything from the port\n-        assert!(match rx.try_recv() {\n-            Empty => true,\n-            _ => false,\n-        });\n-\n-        barrier.wait();\n-        // Now, the barrier is cleared and we should get data.\n-        for _ in range(0, 9) {\n-            rx.recv();\n-        }\n-    }\n }", "previous_filename": "src/libsync/sync/mod.rs"}, {"sha": "9c0328d4b11d0de3406ab290425e6f8f649cfd4b", "filename": "src/libworkcache/lib.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibworkcache%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Flibworkcache%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibworkcache%2Flib.rs?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -26,7 +26,7 @@ extern crate sync;\n use serialize::json;\n use serialize::json::ToJson;\n use serialize::{Encoder, Encodable, Decoder, Decodable};\n-use sync::{Arc,RWArc};\n+use sync::{Arc, RWLock};\n use collections::TreeMap;\n use std::str;\n use std::io;\n@@ -225,7 +225,7 @@ pub type FreshnessMap = TreeMap<~str,extern fn(&str,&str)->bool>;\n \n #[deriving(Clone)]\n pub struct Context {\n-    db: RWArc<Database>,\n+    db: Arc<RWLock<Database>>,\n     priv cfg: Arc<json::Object>,\n     /// Map from kinds (source, exe, url, etc.) to a freshness function.\n     /// The freshness function takes a name (e.g. file path) and value\n@@ -269,12 +269,12 @@ fn json_decode<T:Decodable<json::Decoder>>(s: &str) -> T {\n \n impl Context {\n \n-    pub fn new(db: RWArc<Database>,\n+    pub fn new(db: Arc<RWLock<Database>>,\n                cfg: Arc<json::Object>) -> Context {\n         Context::new_with_freshness(db, cfg, Arc::new(TreeMap::new()))\n     }\n \n-    pub fn new_with_freshness(db: RWArc<Database>,\n+    pub fn new_with_freshness(db: Arc<RWLock<Database>>,\n                               cfg: Arc<json::Object>,\n                               freshness: Arc<FreshnessMap>) -> Context {\n         Context {\n@@ -364,7 +364,7 @@ impl<'a> Prep<'a> {\n     fn is_fresh(&self, cat: &str, kind: &str,\n                 name: &str, val: &str) -> bool {\n         let k = kind.to_owned();\n-        let f = self.ctxt.freshness.get().find(&k);\n+        let f = self.ctxt.freshness.deref().find(&k);\n         debug!(\"freshness for: {}/{}/{}/{}\", cat, kind, name, val)\n         let fresh = match f {\n             None => fail!(\"missing freshness-function for '{}'\", kind),\n@@ -406,9 +406,10 @@ impl<'a> Prep<'a> {\n \n         debug!(\"exec_work: looking up {} and {:?}\", self.fn_name,\n                self.declared_inputs);\n-        let cached = self.ctxt.db.read(|db| {\n-            db.prepare(self.fn_name, &self.declared_inputs)\n-        });\n+        let cached = {\n+            let db = self.ctxt.db.deref().read();\n+            db.deref().prepare(self.fn_name, &self.declared_inputs)\n+        };\n \n         match cached {\n             Some((ref disc_in, ref disc_out, ref res))\n@@ -460,13 +461,12 @@ impl<'a, T:Send +\n             WorkFromTask(prep, port) => {\n                 let (exe, v) = port.recv();\n                 let s = json_encode(&v);\n-                prep.ctxt.db.write(|db| {\n-                    db.cache(prep.fn_name,\n-                             &prep.declared_inputs,\n-                             &exe.discovered_inputs,\n-                             &exe.discovered_outputs,\n-                             s)\n-                });\n+                let mut db = prep.ctxt.db.deref().write();\n+                db.deref_mut().cache(prep.fn_name,\n+                                     &prep.declared_inputs,\n+                                     &exe.discovered_inputs,\n+                                     &exe.discovered_outputs,\n+                                     s);\n                 v\n             }\n         }\n@@ -496,7 +496,7 @@ fn test() {\n \n     let db_path = make_path(~\"db.json\");\n \n-    let cx = Context::new(RWArc::new(Database::new(db_path)),\n+    let cx = Context::new(Arc::new(RWLock::new(Database::new(db_path))),\n                           Arc::new(TreeMap::new()));\n \n     let s = cx.with_prep(\"test1\", |prep| {"}, {"sha": "b24dc588babf6cc6046e4523ba0253085cca4a4c", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -18,36 +18,28 @@\n extern crate sync;\n extern crate time;\n \n-use sync::Arc;\n-use sync::MutexArc;\n-use sync::Future;\n+use sync::{Arc, Future, Mutex};\n use std::os;\n use std::uint;\n \n // A poor man's pipe.\n-type pipe = MutexArc<Vec<uint> >;\n+type pipe = Arc<Mutex<Vec<uint>>>;\n \n fn send(p: &pipe, msg: uint) {\n-    unsafe {\n-        p.access_cond(|state, cond| {\n-            state.push(msg);\n-            cond.signal();\n-        })\n-    }\n+    let mut arr = p.lock();\n+    arr.push(msg);\n+    arr.cond.signal();\n }\n fn recv(p: &pipe) -> uint {\n-    unsafe {\n-        p.access_cond(|state, cond| {\n-            while state.is_empty() {\n-                cond.wait();\n-            }\n-            state.pop().unwrap()\n-        })\n+    let mut arr = p.lock();\n+    while arr.is_empty() {\n+        arr.cond.wait();\n     }\n+    arr.pop().unwrap()\n }\n \n fn init() -> (pipe,pipe) {\n-    let m = MutexArc::new(Vec::new());\n+    let m = Arc::new(Mutex::new(Vec::new()));\n     ((&m).clone(), m)\n }\n "}, {"sha": "8e4a34384e8095144c13de9c3644daa5423f5abe", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -18,31 +18,29 @@\n extern crate sync;\n extern crate time;\n \n-use sync::RWArc;\n+use sync::{RWLock, Arc};\n use sync::Future;\n use std::os;\n use std::uint;\n \n // A poor man's pipe.\n-type pipe = RWArc<Vec<uint> >;\n+type pipe = Arc<RWLock<Vec<uint>>>;\n \n fn send(p: &pipe, msg: uint) {\n-    p.write_cond(|state, cond| {\n-        state.push(msg);\n-        cond.signal();\n-    })\n+    let mut arr = p.write();\n+    arr.push(msg);\n+    arr.cond.signal();\n }\n fn recv(p: &pipe) -> uint {\n-    p.write_cond(|state, cond| {\n-        while state.is_empty() {\n-            cond.wait();\n-        }\n-        state.pop().unwrap()\n-    })\n+    let mut arr = p.write();\n+    while arr.is_empty() {\n+        arr.cond.wait();\n+    }\n+    arr.pop().unwrap()\n }\n \n fn init() -> (pipe,pipe) {\n-    let x = RWArc::new(Vec::new());\n+    let x = Arc::new(RWLock::new(Vec::new()));\n     ((&x).clone(), x)\n }\n "}, {"sha": "939f8eaab68c4f210d1e8da5a59e238e7178a075", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -14,7 +14,8 @@ use std::from_str::FromStr;\n use std::iter::count;\n use std::cmp::min;\n use std::os;\n-use sync::RWArc;\n+use std::slice::from_elem;\n+use sync::{Arc, RWLock};\n \n fn A(i: uint, j: uint) -> f64 {\n     ((i + j) * (i + j + 1) / 2 + i + 1) as f64\n@@ -28,17 +29,16 @@ fn dot(v: &[f64], u: &[f64]) -> f64 {\n     sum\n }\n \n-fn mult(v: RWArc<Vec<f64>>,\n-        out: RWArc<Vec<f64>>,\n+fn mult(v: Arc<RWLock<Vec<f64>>>, out: Arc<RWLock<Vec<f64>>>,\n         f: fn(&Vec<f64>, uint) -> f64) {\n-    // We launch in different tasks the work to be done.  To finish\n+    // We lanch in different tasks the work to be done.  To finish\n     // this fuction, we need to wait for the completion of every\n     // tasks.  To do that, we give to each tasks a wait_chan that we\n     // drop at the end of the work.  At the end of this function, we\n     // wait until the channel hang up.\n     let (tx, rx) = channel();\n \n-    let len = out.read(|out| out.len());\n+    let len = out.read().len();\n     let chunk = len / 100 + 1;\n     for chk in count(0, chunk) {\n         if chk >= len {break;}\n@@ -47,8 +47,8 @@ fn mult(v: RWArc<Vec<f64>>,\n         let out = out.clone();\n         spawn(proc() {\n             for i in range(chk, min(len, chk + chunk)) {\n-                let val = v.read(|v| f(v, i));\n-                out.write(|out| *out.get_mut(i) = val);\n+                let val = f(&*v.read(), i);\n+                *out.write().get_mut(i) = val;\n             }\n             drop(tx)\n         });\n@@ -67,7 +67,7 @@ fn mult_Av_impl(v: &Vec<f64> , i: uint) -> f64 {\n     sum\n }\n \n-fn mult_Av(v: RWArc<Vec<f64> >, out: RWArc<Vec<f64> >) {\n+fn mult_Av(v: Arc<RWLock<Vec<f64>>>, out: Arc<RWLock<Vec<f64>>>) {\n     mult(v, out, mult_Av_impl);\n }\n \n@@ -79,11 +79,12 @@ fn mult_Atv_impl(v: &Vec<f64> , i: uint) -> f64 {\n     sum\n }\n \n-fn mult_Atv(v: RWArc<Vec<f64> >, out: RWArc<Vec<f64> >) {\n+fn mult_Atv(v: Arc<RWLock<Vec<f64>>>, out: Arc<RWLock<Vec<f64>>>) {\n     mult(v, out, mult_Atv_impl);\n }\n \n-fn mult_AtAv(v: RWArc<Vec<f64> >, out: RWArc<Vec<f64> >, tmp: RWArc<Vec<f64> >) {\n+fn mult_AtAv(v: Arc<RWLock<Vec<f64>>>, out: Arc<RWLock<Vec<f64>>>,\n+             tmp: Arc<RWLock<Vec<f64>>>) {\n     mult_Av(v, tmp.clone());\n     mult_Atv(tmp, out);\n }\n@@ -97,16 +98,16 @@ fn main() {\n     } else {\n         FromStr::from_str(args[1]).unwrap()\n     };\n-    let u = RWArc::new(Vec::from_elem(n, 1.));\n-    let v = RWArc::new(Vec::from_elem(n, 1.));\n-    let tmp = RWArc::new(Vec::from_elem(n, 1.));\n+    let u = Arc::new(RWLock::new(Vec::from_elem(n, 1.)));\n+    let v = Arc::new(RWLock::new(Vec::from_elem(n, 1.)));\n+    let tmp = Arc::new(RWLock::new(Vec::from_elem(n, 1.)));\n     for _ in range(0, 10) {\n         mult_AtAv(u.clone(), v.clone(), tmp.clone());\n         mult_AtAv(v.clone(), u.clone(), tmp.clone());\n     }\n \n-    u.read(|u| v.read(|v| {\n-        println!(\"{:.9f}\",\n-                 (dot(u.as_slice(), v.as_slice()) / dot(v.as_slice(), v.as_slice())).sqrt());\n-    }))\n+    let u = u.read();\n+    let v = v.read();\n+    println!(\"{:.9f}\", (dot(u.as_slice(), v.as_slice()) /\n+                        dot(v.as_slice(), v.as_slice())).sqrt());\n }"}, {"sha": "151f4940d5702937dbed732b640c89ba0993252c", "filename": "src/test/compile-fail/arc-cant-nest-rw-arc-3177.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33/src%2Ftest%2Fcompile-fail%2Farc-cant-nest-rw-arc-3177.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33/src%2Ftest%2Fcompile-fail%2Farc-cant-nest-rw-arc-3177.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-cant-nest-rw-arc-3177.rs?ref=bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-extern crate sync;\n-use sync::RWArc;\n-\n-fn main() {\n-    let arc1  = RWArc::new(true);\n-    let _arc2 = RWArc::new(arc1); //~ ERROR instantiating a type parameter with an incompatible type\n-}"}, {"sha": "71d42d46e7c5f4409cfdcef5b76561610c8fb0f1", "filename": "src/test/compile-fail/arc-rw-cond-shouldnt-escape.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33/src%2Ftest%2Fcompile-fail%2Farc-rw-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33/src%2Ftest%2Fcompile-fail%2Farc-rw-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-cond-shouldnt-escape.rs?ref=bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33", "patch": "@@ -1,19 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: lifetime of return value does not outlive the function call\n-extern crate sync;\n-use sync::RWArc;\n-fn main() {\n-    let x = ~RWArc::new(1);\n-    let mut y = None;\n-    x.write_cond(|_one, cond| y = Some(cond));\n-    y.unwrap().wait();\n-}"}, {"sha": "1787cd5d0b46c47b0ed0668ffad3e3908882c4ea", "filename": "src/test/compile-fail/arc-rw-read-mode-shouldnt-escape.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs?ref=bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-extern crate sync;\n-use sync::RWArc;\n-fn main() {\n-    let x = ~RWArc::new(1);\n-    let mut y = None;\n-    x.write_downgrade(|write_mode| {\n-        y = Some(x.downgrade(write_mode));\n-        //~^ ERROR cannot infer\n-    });\n-    y.unwrap();\n-    // Adding this line causes a method unification failure instead\n-    // (&option::unwrap(y)).read(|state| { assert!(*state == 1); })\n-}"}, {"sha": "cccca050696a34682891a1c28887debcfb44788c", "filename": "src/test/compile-fail/arc-rw-state-shouldnt-escape.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33/src%2Ftest%2Fcompile-fail%2Farc-rw-state-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33/src%2Ftest%2Fcompile-fail%2Farc-rw-state-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-state-shouldnt-escape.rs?ref=bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-extern crate sync;\n-use sync::RWArc;\n-fn main() {\n-    let x = ~RWArc::new(1);\n-    let mut y = None; //~ ERROR lifetime of variable does not enclose its declaration\n-    x.write(|one| y = Some(one));\n-    *y.unwrap() = 2;\n-    //~^ ERROR lifetime of return value does not outlive the function call\n-    //~^^ ERROR dereference of reference outside its lifetime\n-}"}, {"sha": "a08cb055020a531dfc8d3321a2b33dc886f794c7", "filename": "src/test/compile-fail/arc-rw-write-mode-cond-shouldnt-escape.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-cond-shouldnt-escape.rs?ref=bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: lifetime of variable does not enclose its declaration\n-extern crate sync;\n-use sync::RWArc;\n-fn main() {\n-    let x = ~RWArc::new(1);\n-    let mut y = None;\n-    x.write_downgrade(|write_mode| {\n-        (&write_mode).write_cond(|_one, cond| {\n-            y = Some(cond);\n-        })\n-    });\n-    y.unwrap().wait();\n-}"}, {"sha": "8f93d672b90161fd77e0aeedfc5d62f794532887", "filename": "src/test/compile-fail/arc-rw-write-mode-shouldnt-escape.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs?ref=bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: lifetime of variable does not enclose its declaration\n-extern crate sync;\n-use sync::RWArc;\n-fn main() {\n-    let x = ~RWArc::new(1);\n-    let mut y = None;\n-    x.write_downgrade(|write_mode| y = Some(write_mode));\n-    y.unwrap();\n-    // Adding this line causes a method unification failure instead\n-    // (&option::unwrap(y)).write(|state| { assert!(*state == 1); })\n-}"}, {"sha": "0ba4db4f211c249a2fa22e0f67cb92e54984bfe8", "filename": "src/test/compile-fail/functional-struct-update-noncopyable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Ftest%2Fcompile-fail%2Ffunctional-struct-update-noncopyable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Ftest%2Fcompile-fail%2Ffunctional-struct-update-noncopyable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffunctional-struct-update-noncopyable.rs?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -17,7 +17,7 @@ use sync::Arc;\n struct A { y: Arc<int>, x: Arc<int> }\n \n impl Drop for A {\n-    fn drop(&mut self) { println!(\"x={:?}\", self.x.get()); }\n+    fn drop(&mut self) { println!(\"x={}\", *self.x); }\n }\n fn main() {\n     let a = A { y: Arc::new(1), x: Arc::new(2) };"}, {"sha": "7e71b6fdf28d27833556fad33d63674ab63de131", "filename": "src/test/compile-fail/no-capture-arc.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -20,11 +20,10 @@ fn main() {\n     let arc_v = Arc::new(v);\n \n     task::spawn(proc() {\n-        let v = arc_v.get();\n-        assert_eq!(*v.get(3), 4);\n+        assert_eq!(*arc_v.get(3), 4);\n     });\n \n-    assert_eq!(*(arc_v.get()).get(2), 3);\n+    assert_eq!(*arc_v.get(2), 3);\n \n-    println!(\"{:?}\", arc_v);\n+    println!(\"{}\", *arc_v);\n }"}, {"sha": "83e0ae0218cc60297451e26b702a6384ecbbae58", "filename": "src/test/compile-fail/no-reuse-move-arc.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -18,11 +18,10 @@ fn main() {\n     let arc_v = Arc::new(v);\n \n     task::spawn(proc() {\n-        let v = arc_v.get();\n-        assert_eq!(*v.get(3), 4);\n+        assert_eq!(*arc_v.get(3), 4);\n     });\n \n-    assert_eq!(*(arc_v.get()).get(2), 3); //~ ERROR use of moved value: `arc_v`\n+    assert_eq!(*arc_v.get(2), 3); //~ ERROR use of moved value: `arc_v`\n \n-    println!(\"{:?}\", arc_v); //~ ERROR use of moved value: `arc_v`\n+    println!(\"{}\", *arc_v); //~ ERROR use of moved value: `arc_v`\n }"}, {"sha": "c9ee105fe7b93b01f1ef55f399d5116ce59a7fc9", "filename": "src/test/compile-fail/once-cant-call-twice-on-heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-heap.rs?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -23,7 +23,7 @@ fn foo(blk: proc()) {\n fn main() {\n     let x = Arc::new(true);\n     foo(proc() {\n-        assert!(*x.get());\n+        assert!(*x);\n         drop(x);\n     });\n }"}, {"sha": "a81ddf06ac86e28b6e00486f3dae9b1fc06ff212", "filename": "src/test/compile-fail/once-cant-call-twice-on-stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-stack.rs?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -23,7 +23,7 @@ fn foo(blk: once ||) {\n fn main() {\n     let x = Arc::new(true);\n     foo(|| {\n-        assert!(*x.get());\n+        assert!(*x);\n         drop(x);\n     })\n }"}, {"sha": "8f3f9cf74dbad2d51b1a2a5679f82468a549aebe", "filename": "src/test/compile-fail/once-cant-move-out-of-non-once-on-stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Ftest%2Fcompile-fail%2Fonce-cant-move-out-of-non-once-on-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Ftest%2Fcompile-fail%2Fonce-cant-move-out-of-non-once-on-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fonce-cant-move-out-of-non-once-on-stack.rs?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -22,7 +22,7 @@ fn foo(blk: ||) {\n fn main() {\n     let x = Arc::new(true);\n     foo(|| {\n-        assert!(*x.get());\n+        assert!(*x);\n         drop(x); //~ ERROR cannot move out of captured outer variable\n     })\n }"}, {"sha": "4ba1c5c7cfeec458e2525486c38b70a23ec43e41", "filename": "src/test/compile-fail/sync-cond-shouldnt-escape.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33/src%2Ftest%2Fcompile-fail%2Fsync-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33/src%2Ftest%2Fcompile-fail%2Fsync-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-cond-shouldnt-escape.rs?ref=bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: lifetime of variable does not enclose its declaration\n-extern crate sync;\n-use sync::Mutex;\n-\n-fn main() {\n-    let m = ~sync::Mutex::new();\n-    let mut cond = None;\n-    m.lock_cond(|c| {\n-        cond = Some(c);\n-    });\n-    cond.unwrap().signal();\n-}"}, {"sha": "697858f40da6084b761f1005317c464de2d26e56", "filename": "src/test/compile-fail/sync-rwlock-cond-shouldnt-escape.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-cond-shouldnt-escape.rs?ref=bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: lifetime of method receiver does not outlive the method call\n-extern crate sync;\n-use sync::RWLock;\n-fn main() {\n-    let x = ~RWLock::new();\n-    let mut y = None;\n-    x.write_cond(|cond| {\n-        y = Some(cond);\n-    });\n-    y.unwrap().wait();\n-}"}, {"sha": "30ed0912f6a8a9242b1f683ae1e6687fc7a7b8cf", "filename": "src/test/compile-fail/sync-rwlock-read-mode-shouldnt-escape.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-read-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-read-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-read-mode-shouldnt-escape.rs?ref=bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: cannot infer\n-extern crate sync;\n-use sync::RWLock;\n-fn main() {\n-    let x = ~RWLock::new();\n-    let mut y = None;\n-    x.write_downgrade(|write_mode| {\n-        y = Some(x.downgrade(write_mode));\n-    })\n-    // Adding this line causes a method unification failure instead\n-    // (&option::unwrap(y)).read(proc() { });\n-}"}, {"sha": "09b4e34ea8c135b99608252e93a5dd1aaf5cfd82", "filename": "src/test/compile-fail/sync-rwlock-write-mode-cond-shouldnt-escape.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-cond-shouldnt-escape.rs?ref=bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: lifetime of variable does not enclose its declaration\n-extern crate sync;\n-use sync::RWLock;\n-fn main() {\n-    let x = ~RWLock::new();\n-    let mut y = None;\n-    x.write_downgrade(|write_mode| {\n-        (&write_mode).write_cond(|cond| {\n-            y = Some(cond);\n-        })\n-    });\n-    y.unwrap().wait();\n-}"}, {"sha": "0fca360d0ce3d76bf48c122b3cb8158e1e931392", "filename": "src/test/compile-fail/sync-rwlock-write-mode-shouldnt-escape.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-shouldnt-escape.rs?ref=bcaaffbe1e1c6a6a3abdabdb4fdaef36358dae33", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: lifetime of variable does not enclose its declaration\n-extern crate sync;\n-use sync::RWLock;\n-fn main() {\n-    let x = ~RWLock::new();\n-    let mut y = None;\n-    x.write_downgrade(|write_mode| {\n-        y = Some(write_mode);\n-    });\n-    // Adding this line causes a method unification failure instead\n-    // (&option::unwrap(y)).write(proc() { })\n-}"}, {"sha": "d27cce4dd368c1ef7cef7d2dc9a9fc6b5dd34474", "filename": "src/test/run-pass/once-move-out-on-heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Ftest%2Frun-pass%2Fonce-move-out-on-heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Ftest%2Frun-pass%2Fonce-move-out-on-heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fonce-move-out-on-heap.rs?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -23,7 +23,7 @@ fn foo(blk: proc()) {\n pub fn main() {\n     let x = Arc::new(true);\n     foo(proc() {\n-        assert!(*x.get());\n+        assert!(*x);\n         drop(x);\n     });\n }"}, {"sha": "f14827c7245f423d4f837c281a47831ee1fd0ba3", "filename": "src/test/run-pass/once-move-out-on-stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Ftest%2Frun-pass%2Fonce-move-out-on-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Ftest%2Frun-pass%2Fonce-move-out-on-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fonce-move-out-on-stack.rs?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -23,7 +23,7 @@ fn foo(blk: once ||) {\n pub fn main() {\n     let x = Arc::new(true);\n     foo(|| {\n-        assert!(*x.get());\n+        assert!(*x);\n         drop(x);\n     })\n }"}, {"sha": "3deb0b7527d9f1d52d44a9bdf40cb683a9fff994", "filename": "src/test/run-pass/trait-bounds-in-arc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs?ref=6bf3fca8ff90bbeff8d5c437aa784d0dbf8f9455", "patch": "@@ -85,20 +85,20 @@ pub fn main() {\n \n fn check_legs(arc: Arc<Vec<~Pet:Share+Send>>) {\n     let mut legs = 0;\n-    for pet in arc.get().iter() {\n+    for pet in arc.iter() {\n         legs += pet.num_legs();\n     }\n     assert!(legs == 12);\n }\n fn check_names(arc: Arc<Vec<~Pet:Share+Send>>) {\n-    for pet in arc.get().iter() {\n+    for pet in arc.iter() {\n         pet.name(|name| {\n             assert!(name[0] == 'a' as u8 && name[1] == 'l' as u8);\n         })\n     }\n }\n fn check_pedigree(arc: Arc<Vec<~Pet:Share+Send>>) {\n-    for pet in arc.get().iter() {\n+    for pet in arc.iter() {\n         assert!(pet.of_good_pedigree());\n     }\n }"}]}