{"sha": "f7a4c9d7b55950c6b8451b42f203df2c009fc653", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3YTRjOWQ3YjU1OTUwYzZiODQ1MWI0MmYyMDNkZjJjMDA5ZmM2NTM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-05-28T20:31:01Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-06-01T17:44:05Z"}, "message": "rustc: collect upvars from HIR, instead of during name resolution.", "tree": {"sha": "e1963482859a17651e52875fe5e6deed2077ed8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1963482859a17651e52875fe5e6deed2077ed8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7a4c9d7b55950c6b8451b42f203df2c009fc653", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7a4c9d7b55950c6b8451b42f203df2c009fc653", "html_url": "https://github.com/rust-lang/rust/commit/f7a4c9d7b55950c6b8451b42f203df2c009fc653", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7a4c9d7b55950c6b8451b42f203df2c009fc653/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "648b4d884d663b9afad7188120e13fc285d61516", "url": "https://api.github.com/repos/rust-lang/rust/commits/648b4d884d663b9afad7188120e13fc285d61516", "html_url": "https://github.com/rust-lang/rust/commit/648b4d884d663b9afad7188120e13fc285d61516"}], "stats": {"total": 240, "additions": 143, "deletions": 97}, "files": [{"sha": "e8c3914e695ad1c71c214cbf240625e758382fbf", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f7a4c9d7b55950c6b8451b42f203df2c009fc653/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7a4c9d7b55950c6b8451b42f203df2c009fc653/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=f7a4c9d7b55950c6b8451b42f203df2c009fc653", "patch": "@@ -109,6 +109,7 @@ macro_rules! arena_types {\n             >,\n             [few] crate_variances: rustc::ty::CrateVariancesMap<'tcx>,\n             [few] inferred_outlives_crate: rustc::ty::CratePredicatesMap<'tcx>,\n+            [] upvars: rustc_data_structures::fx::FxIndexMap<rustc::hir::HirId, rustc::hir::Upvar>,\n         ], $tcx);\n     )\n }"}, {"sha": "c84c18ce8a7e37bb9aa702c124da211efaba5167", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f7a4c9d7b55950c6b8451b42f203df2c009fc653/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7a4c9d7b55950c6b8451b42f203df2c009fc653/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=f7a4c9d7b55950c6b8451b42f203df2c009fc653", "patch": "@@ -26,7 +26,7 @@ use crate::util::common::time;\n \n use std::io;\n use std::result::Result::Err;\n-use crate::ty::TyCtxt;\n+use crate::ty::query::Providers;\n \n pub mod blocks;\n mod collector;\n@@ -1450,11 +1450,13 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n     }\n }\n \n-pub fn def_kind(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Option<DefKind> {\n-    if let Some(node_id) = tcx.hir().as_local_node_id(def_id) {\n-        tcx.hir().def_kind(node_id)\n-    } else {\n-        bug!(\"Calling local def_kind query provider for upstream DefId: {:?}\",\n-             def_id)\n-    }\n+pub fn provide(providers: &mut Providers<'_>) {\n+    providers.def_kind = |tcx, def_id| {\n+        if let Some(node_id) = tcx.hir().as_local_node_id(def_id) {\n+            tcx.hir().def_kind(node_id)\n+        } else {\n+            bug!(\"Calling local def_kind query provider for upstream DefId: {:?}\",\n+                def_id)\n+        }\n+    };\n }"}, {"sha": "f7daa7a94551f3e578927fd9db6a2dfdf0c7d358", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f7a4c9d7b55950c6b8451b42f203df2c009fc653/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7a4c9d7b55950c6b8451b42f203df2c009fc653/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=f7a4c9d7b55950c6b8451b42f203df2c009fc653", "patch": "@@ -30,7 +30,6 @@ use syntax::util::parser::ExprPrecedence;\n use crate::ty::AdtKind;\n use crate::ty::query::Providers;\n \n-use rustc_data_structures::fx::FxIndexMap;\n use rustc_data_structures::sync::{par_for_each_in, Send, Sync};\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_macros::HashStable;\n@@ -64,6 +63,7 @@ pub mod lowering;\n pub mod map;\n pub mod pat_util;\n pub mod print;\n+pub mod upvars;\n \n /// Uniquely identifies a node in the HIR of the current crate. It is\n /// composed of the `owner`, which is the `DefIndex` of the directly enclosing\n@@ -2498,8 +2498,6 @@ pub struct Upvar {\n     pub span: Span\n }\n \n-pub type UpvarMap = NodeMap<FxIndexMap<ast::NodeId, Upvar>>;\n-\n pub type CaptureModeMap = NodeMap<CaptureClause>;\n \n  // The TraitCandidate's import_ids is empty if the trait is defined in the same module, and\n@@ -2518,10 +2516,10 @@ pub type TraitMap = NodeMap<Vec<TraitCandidate>>;\n // imported.\n pub type GlobMap = NodeMap<FxHashSet<Name>>;\n \n-\n pub fn provide(providers: &mut Providers<'_>) {\n     check_attr::provide(providers);\n-    providers.def_kind = map::def_kind;\n+    map::provide(providers);\n+    upvars::provide(providers);\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]"}, {"sha": "a053deb558464b4a849ff7077786fb4944129928", "filename": "src/librustc/hir/upvars.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/f7a4c9d7b55950c6b8451b42f203df2c009fc653/src%2Flibrustc%2Fhir%2Fupvars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7a4c9d7b55950c6b8451b42f203df2c009fc653/src%2Flibrustc%2Fhir%2Fupvars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fupvars.rs?ref=f7a4c9d7b55950c6b8451b42f203df2c009fc653", "patch": "@@ -0,0 +1,104 @@\n+//! Upvar (closure capture) collection from cross-body HIR uses of `Res::Local`s.\n+\n+use crate::hir::{self, HirId};\n+use crate::hir::def::Res;\n+use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use crate::ty::TyCtxt;\n+use crate::ty::query::Providers;\n+use syntax_pos::Span;\n+use rustc_data_structures::fx::{FxIndexMap, FxHashSet};\n+\n+pub fn provide(providers: &mut Providers<'_>) {\n+    providers.upvars = |tcx, def_id| {\n+        if !tcx.is_closure(def_id) {\n+            return None;\n+        }\n+\n+        let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n+        let body = tcx.hir().body(tcx.hir().maybe_body_owned_by(node_id)?);\n+\n+        let mut local_collector = LocalCollector::default();\n+        local_collector.visit_body(body);\n+\n+        let mut capture_collector = CaptureCollector {\n+            tcx,\n+            locals: &local_collector.locals,\n+            upvars: FxIndexMap::default(),\n+        };\n+        capture_collector.visit_body(body);\n+\n+        if !capture_collector.upvars.is_empty() {\n+            Some(tcx.arena.alloc(capture_collector.upvars))\n+        } else {\n+            None\n+        }\n+    };\n+}\n+\n+#[derive(Default)]\n+struct LocalCollector {\n+    // FIXME(eddyb) perhaps use `ItemLocalId` instead?\n+    locals: FxHashSet<HirId>,\n+}\n+\n+impl Visitor<'tcx> for LocalCollector {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n+        if let hir::PatKind::Binding(_, hir_id, ..) = pat.node {\n+            self.locals.insert(hir_id);\n+        }\n+        intravisit::walk_pat(self, pat);\n+    }\n+}\n+\n+struct CaptureCollector<'a, 'tcx> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    locals: &'a FxHashSet<HirId>,\n+    upvars: FxIndexMap<HirId, hir::Upvar>,\n+}\n+\n+impl CaptureCollector<'_, '_> {\n+    fn visit_local_use(&mut self, var_id: HirId, span: Span) {\n+        if !self.locals.contains(&var_id) {\n+            self.upvars.entry(var_id).or_insert(hir::Upvar { span });\n+        }\n+    }\n+}\n+\n+impl Visitor<'tcx> for CaptureCollector<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_path(&mut self, path: &'tcx hir::Path, _: hir::HirId) {\n+        if let Res::Local(var_id) = path.res {\n+            self.visit_local_use(var_id, path.span);\n+        }\n+\n+        intravisit::walk_path(self, path);\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+        if let hir::ExprKind::Closure(..) = expr.node {\n+            let closure_def_id = self.tcx.hir().local_def_id_from_hir_id(expr.hir_id);\n+            if let Some(upvars) = self.tcx.upvars(closure_def_id) {\n+                // Every capture of a closure expression is a local in scope,\n+                // that is moved/copied/borrowed into the closure value, and\n+                // for this analysis they are like any other access to a local.\n+                //\n+                // E.g. in `|b| |c| (a, b, c)`, the upvars of the inner closure\n+                // are `a` and `b`, and while `a` is not directly used in the\n+                // outer closure, it needs to be an upvar there too, so that\n+                // the inner closure can take it (from the outer closure's env).\n+                for (&var_id, upvar) in upvars {\n+                    self.visit_local_use(var_id, upvar.span);\n+                }\n+            }\n+        }\n+\n+        intravisit::walk_expr(self, expr);\n+    }\n+}"}, {"sha": "b2d080a4f965a2efb40d311a9876f1061251f843", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f7a4c9d7b55950c6b8451b42f203df2c009fc653/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7a4c9d7b55950c6b8451b42f203df2c009fc653/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=f7a4c9d7b55950c6b8451b42f203df2c009fc653", "patch": "@@ -54,7 +54,6 @@ use rustc_data_structures::stable_hasher::{HashStable, hash_stable_hashmap,\n                                            StableHasher, StableHasherResult,\n                                            StableVec};\n use arena::SyncDroplessArena;\n-use rustc_data_structures::fx::FxIndexMap;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::sync::{Lrc, Lock, WorkerLocal};\n use std::any::Any;\n@@ -1063,11 +1062,6 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub queries: query::Queries<'tcx>,\n \n-    // Records the captured variables referenced by every closure\n-    // expression. Do not track deps for this, just recompute it from\n-    // scratch every time.\n-    upvars: FxHashMap<DefId, FxIndexMap<hir::HirId, hir::Upvar>>,\n-\n     maybe_unused_trait_imports: FxHashSet<DefId>,\n     maybe_unused_extern_crates: Vec<(DefId, Span)>,\n     /// A map of glob use to a set of names it actually imports. Currently only\n@@ -1298,12 +1292,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 }).collect();\n                 (k, exports)\n             }).collect(),\n-            upvars: resolutions.upvars.into_iter().map(|(k, upvars)| {\n-                let upvars: FxIndexMap<_, _> = upvars.into_iter().map(|(var_id, upvar)| {\n-                    (hir.node_to_hir_id(var_id), upvar)\n-                }).collect();\n-                (hir.local_def_id(k), upvars)\n-            }).collect(),\n             maybe_unused_trait_imports:\n                 resolutions.maybe_unused_trait_imports\n                     .into_iter()\n@@ -3024,7 +3012,6 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n         assert_eq!(id, LOCAL_CRATE);\n         tcx.arena.alloc(middle::lang_items::collect(tcx))\n     };\n-    providers.upvars = |tcx, id| tcx.gcx.upvars.get(&id);\n     providers.maybe_unused_trait_import = |tcx, id| {\n         tcx.maybe_unused_trait_imports.contains(&id)\n     };"}, {"sha": "e89fb53c236194ec230fef70d6d35708d1f1d6eb", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f7a4c9d7b55950c6b8451b42f203df2c009fc653/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7a4c9d7b55950c6b8451b42f203df2c009fc653/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=f7a4c9d7b55950c6b8451b42f203df2c009fc653", "patch": "@@ -8,7 +8,7 @@ pub use self::BorrowKind::*;\n pub use self::IntVarValue::*;\n pub use self::fold::TypeFoldable;\n \n-use crate::hir::{map as hir_map, UpvarMap, GlobMap, TraitMap};\n+use crate::hir::{map as hir_map, GlobMap, TraitMap};\n use crate::hir::Node;\n use crate::hir::def::{Res, DefKind, CtorOf, CtorKind, ExportMap};\n use crate::hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -123,7 +123,6 @@ mod sty;\n \n #[derive(Clone)]\n pub struct Resolutions {\n-    pub upvars: UpvarMap,\n     pub trait_map: TraitMap,\n     pub maybe_unused_trait_imports: NodeSet,\n     pub maybe_unused_extern_crates: Vec<(NodeId, Span)>,"}, {"sha": "9691d0337d7d20091f59e602544aff2dab92b174", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7a4c9d7b55950c6b8451b42f203df2c009fc653/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7a4c9d7b55950c6b8451b42f203df2c009fc653/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=f7a4c9d7b55950c6b8451b42f203df2c009fc653", "patch": "@@ -178,7 +178,6 @@ impl ExpansionResult {\n         ExpansionResult {\n             defs: Steal::new(resolver.definitions),\n             resolutions: Steal::new(Resolutions {\n-                upvars: resolver.upvars,\n                 export_map: resolver.export_map,\n                 trait_map: resolver.trait_map,\n                 glob_map: resolver.glob_map,\n@@ -197,7 +196,6 @@ impl ExpansionResult {\n         ExpansionResult {\n             defs: Steal::new(resolver.definitions.clone()),\n             resolutions: Steal::new(Resolutions {\n-                upvars: resolver.upvars.clone(),\n                 export_map: resolver.export_map.clone(),\n                 trait_map: resolver.trait_map.clone(),\n                 glob_map: resolver.glob_map.clone(),"}, {"sha": "21e759ccc650e79b470e2d21118c25ed8580b151", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 13, "deletions": 56, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/f7a4c9d7b55950c6b8451b42f203df2c009fc653/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7a4c9d7b55950c6b8451b42f203df2c009fc653/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=f7a4c9d7b55950c6b8451b42f203df2c009fc653", "patch": "@@ -29,7 +29,7 @@ use rustc::hir::def::{\n };\n use rustc::hir::def::Namespace::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n-use rustc::hir::{Upvar, UpvarMap, TraitCandidate, TraitMap, GlobMap};\n+use rustc::hir::{TraitCandidate, TraitMap, GlobMap};\n use rustc::ty::{self, DefIdTree};\n use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet, DefIdMap};\n use rustc::{bug, span_bug};\n@@ -852,7 +852,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n                 function_kind: FnKind<'tcx>,\n                 declaration: &'tcx FnDecl,\n                 _: Span,\n-                node_id: NodeId)\n+                _: NodeId)\n     {\n         debug!(\"(resolving function) entering function\");\n         let (rib_kind, asyncness) = match function_kind {\n@@ -863,17 +863,14 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n             FnKind::Closure(_) =>\n                 // Async closures aren't resolved through `visit_fn`-- they're\n                 // processed separately\n-                (ClosureRibKind(node_id), &IsAsync::NotAsync),\n+                (NormalRibKind, &IsAsync::NotAsync),\n         };\n \n         // Create a value rib for the function.\n         self.ribs[ValueNS].push(Rib::new(rib_kind));\n \n         // Create a label rib for the function.\n-        match rib_kind {\n-            ClosureRibKind(_) => {}\n-            _ => self.label_ribs.push(Rib::new(rib_kind)),\n-        }\n+        self.label_ribs.push(Rib::new(rib_kind));\n \n         // Add each argument to the rib.\n         let mut bindings_list = FxHashMap::default();\n@@ -900,11 +897,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n         visit::walk_fn_ret_ty(self, &declaration.output);\n \n         // Resolve the function body, potentially inside the body of an async closure\n-        if let IsAsync::Async { closure_id, .. } = asyncness {\n-            let rib_kind = ClosureRibKind(*closure_id);\n-            self.ribs[ValueNS].push(Rib::new(rib_kind));\n-        }\n-\n         match function_kind {\n             FnKind::ItemFn(.., body) | FnKind::Method(.., body) => {\n                 if let IsAsync::Async { ref arguments, .. } = asyncness {\n@@ -927,19 +919,9 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n             }\n         };\n \n-        // Leave the body of the async closure\n-        if asyncness.is_async() {\n-            self.ribs[ValueNS].pop();\n-        }\n-\n         debug!(\"(resolving function) leaving function\");\n \n-        match rib_kind {\n-            ClosureRibKind(_) => {}\n-            _ => {\n-                self.label_ribs.pop();\n-            }\n-        }\n+        self.label_ribs.pop();\n         self.ribs[ValueNS].pop();\n     }\n \n@@ -1023,17 +1005,13 @@ enum GenericParameters<'a, 'b> {\n                       RibKind<'a>),\n }\n \n-/// The rib kind controls the translation of local\n-/// definitions (`Res::Local`) to upvars (`Res::Upvar`).\n+/// The rib kind restricts certain accesses,\n+/// e.g. to a `Res::Local` of an outer item.\n #[derive(Copy, Clone, Debug)]\n enum RibKind<'a> {\n-    /// No translation needs to be applied.\n+    /// No restriction needs to be applied.\n     NormalRibKind,\n \n-    /// We passed through a closure scope at the given `NodeId`.\n-    /// Translate upvars as appropriate.\n-    ClosureRibKind(NodeId /* func id */),\n-\n     /// We passed through an impl or trait and are now in one of its\n     /// methods or associated types. Allow references to ty params that impl or trait\n     /// binds. Disallow any other upvars (including other ty params that are\n@@ -1673,7 +1651,6 @@ pub struct Resolver<'a> {\n     /// Resolutions for labels (node IDs of their corresponding blocks or loops).\n     label_res_map: NodeMap<NodeId>,\n \n-    pub upvars: UpvarMap,\n     pub export_map: ExportMap<NodeId>,\n     pub trait_map: TraitMap,\n \n@@ -2036,7 +2013,6 @@ impl<'a> Resolver<'a> {\n             partial_res_map: Default::default(),\n             import_res_map: Default::default(),\n             label_res_map: Default::default(),\n-            upvars: Default::default(),\n             export_map: FxHashMap::default(),\n             trait_map: Default::default(),\n             module_map,\n@@ -2506,9 +2482,6 @@ impl<'a> Resolver<'a> {\n         for rib in self.label_ribs.iter().rev() {\n             match rib.kind {\n                 NormalRibKind => {}\n-                ClosureRibKind(_) => {\n-                    span_bug!(ident.span, \"rustc_resolve: `ClosureRibKind` in `label_ribs`\");\n-                }\n                 // If an invocation of this macro created `ident`, give up on `ident`\n                 // and switch to `ident`'s source from the macro definition.\n                 MacroDefinition(def) => {\n@@ -4014,7 +3987,7 @@ impl<'a> Resolver<'a> {\n             diag);\n     }\n \n-    // Validate a local resolution (from ribs), potentially recording closure upvars.\n+    // Validate a local resolution (from ribs).\n     fn validate_res_from_ribs(\n         &mut self,\n         ns: Namespace,\n@@ -4045,7 +4018,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         match res {\n-            Res::Local(var_id) => {\n+            Res::Local(_) => {\n                 use ResolutionError::*;\n                 let mut res_err = None;\n \n@@ -4055,12 +4028,6 @@ impl<'a> Resolver<'a> {\n                         ForwardTyParamBanRibKind | TyParamAsConstParamTy => {\n                             // Nothing to do. Continue.\n                         }\n-                        ClosureRibKind(function_id) => {\n-                            if record_used {\n-                                self.upvars.entry(function_id).or_default()\n-                                    .entry(var_id).or_insert(Upvar { span });\n-                            }\n-                        }\n                         ItemRibKind | FnItemRibKind | AssocItemRibKind => {\n                             // This was an attempt to access an upvar inside a\n                             // named function item. This is not allowed, so we\n@@ -4090,7 +4057,7 @@ impl<'a> Resolver<'a> {\n             Res::Def(DefKind::TyParam, _) | Res::SelfTy(..) => {\n                 for rib in ribs {\n                     match rib.kind {\n-                        NormalRibKind | AssocItemRibKind | ClosureRibKind(..) |\n+                        NormalRibKind | AssocItemRibKind |\n                         ModuleRibKind(..) | MacroDefinition(..) | ForwardTyParamBanRibKind |\n                         ConstantItemRibKind | TyParamAsConstParamTy => {\n                             // Nothing to do. Continue.\n@@ -4470,21 +4437,14 @@ impl<'a> Resolver<'a> {\n                 visit::walk_expr(self, expr);\n                 self.current_type_ascription.pop();\n             }\n-            // Resolve the body of async exprs inside the async closure to which they desugar\n-            ExprKind::Async(_, async_closure_id, ref block) => {\n-                let rib_kind = ClosureRibKind(async_closure_id);\n-                self.ribs[ValueNS].push(Rib::new(rib_kind));\n-                self.visit_block(&block);\n-                self.ribs[ValueNS].pop();\n-            }\n             // `async |x| ...` gets desugared to `|x| future_from_generator(|| ...)`, so we need to\n             // resolve the arguments within the proper scopes so that usages of them inside the\n             // closure are detected as upvars rather than normal closure arg usages.\n             ExprKind::Closure(\n-                _, IsAsync::Async { closure_id: inner_closure_id, .. }, _,\n+                _, IsAsync::Async { .. }, _,\n                 ref fn_decl, ref body, _span,\n             ) => {\n-                let rib_kind = ClosureRibKind(expr.id);\n+                let rib_kind = NormalRibKind;\n                 self.ribs[ValueNS].push(Rib::new(rib_kind));\n                 // Resolve arguments:\n                 let mut bindings_list = FxHashMap::default();\n@@ -4497,14 +4457,11 @@ impl<'a> Resolver<'a> {\n \n                 // Now resolve the inner closure\n                 {\n-                    let rib_kind = ClosureRibKind(inner_closure_id);\n-                    self.ribs[ValueNS].push(Rib::new(rib_kind));\n                     // No need to resolve arguments: the inner closure has none.\n                     // Resolve the return type:\n                     visit::walk_fn_ret_ty(self, &fn_decl.output);\n                     // Resolve the body\n                     self.visit_expr(body);\n-                    self.ribs[ValueNS].pop();\n                 }\n                 self.ribs[ValueNS].pop();\n             }"}, {"sha": "f22b7da811949293aaea9b318b6dbdede47f29a0", "filename": "src/test/ui/borrowck/borrowck-closures-use-after-free.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7a4c9d7b55950c6b8451b42f203df2c009fc653/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-use-after-free.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f7a4c9d7b55950c6b8451b42f203df2c009fc653/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-use-after-free.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-use-after-free.stderr?ref=f7a4c9d7b55950c6b8451b42f203df2c009fc653", "patch": "@@ -4,7 +4,7 @@ error[E0502]: cannot borrow `*ptr` as immutable because it is also borrowed as m\n LL |   let mut test = |foo: &Foo| {\n    |                  ----------- mutable borrow occurs here\n LL |     ptr = box Foo { x: ptr.x + 1 };\n-   |     --- first borrow occurs due to use of `ptr` in closure\n+   |                        --- first borrow occurs due to use of `ptr` in closure\n LL |   };\n LL |   test(&*ptr);\n    |   ---- ^^^^^ immutable borrow occurs here"}, {"sha": "dfe7b3f6b5f9c74262ad17deb52589e915479832", "filename": "src/test/ui/issues/issue-11192.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7a4c9d7b55950c6b8451b42f203df2c009fc653/src%2Ftest%2Fui%2Fissues%2Fissue-11192.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f7a4c9d7b55950c6b8451b42f203df2c009fc653/src%2Ftest%2Fui%2Fissues%2Fissue-11192.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-11192.stderr?ref=f7a4c9d7b55950c6b8451b42f203df2c009fc653", "patch": "@@ -5,7 +5,7 @@ LL |     let mut test = |foo: &Foo| {\n    |                    ----------- mutable borrow occurs here\n LL |         println!(\"access {}\", foo.x);\n LL |         ptr = box Foo { x: ptr.x + 1 };\n-   |         --- first borrow occurs due to use of `ptr` in closure\n+   |                            --- first borrow occurs due to use of `ptr` in closure\n ...\n LL |     test(&*ptr);\n    |     ---- ^^^^^ immutable borrow occurs here"}, {"sha": "186f25a3c89db100d25a30b842221820b31d436f", "filename": "src/test/ui/nll/closure-requirements/escape-upvar-nested.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f7a4c9d7b55950c6b8451b42f203df2c009fc653/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f7a4c9d7b55950c6b8451b42f203df2c009fc653/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.stderr?ref=f7a4c9d7b55950c6b8451b42f203df2c009fc653", "patch": "@@ -7,11 +7,11 @@ LL |             let mut closure1 = || p = &y;\n    = note: defining type: DefId(0:14 ~ escape_upvar_nested[317d]::test[0]::{{closure}}[0]::{{closure}}[0]) with closure substs [\n                i16,\n                extern \"rust-call\" fn(()),\n-               &'_#1r mut &'_#2r i32,\n-               &'_#3r i32,\n+               &'_#1r i32,\n+               &'_#2r mut &'_#3r i32,\n            ]\n    = note: number of external vids: 4\n-   = note: where '_#3r: '_#2r\n+   = note: where '_#1r: '_#3r\n \n note: External requirements\n   --> $DIR/escape-upvar-nested.rs:20:27\n@@ -26,11 +26,11 @@ LL | |         };\n    = note: defining type: DefId(0:13 ~ escape_upvar_nested[317d]::test[0]::{{closure}}[0]) with closure substs [\n                i16,\n                extern \"rust-call\" fn(()),\n-               &'_#1r mut &'_#2r i32,\n-               &'_#3r i32,\n+               &'_#1r i32,\n+               &'_#2r mut &'_#3r i32,\n            ]\n    = note: number of external vids: 4\n-   = note: where '_#3r: '_#2r\n+   = note: where '_#1r: '_#3r\n \n note: No external requirements\n   --> $DIR/escape-upvar-nested.rs:13:1"}, {"sha": "0df2c0f69a71b32757f0718c038bb5cf594eb566", "filename": "src/test/ui/nll/closure-requirements/escape-upvar-ref.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7a4c9d7b55950c6b8451b42f203df2c009fc653/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f7a4c9d7b55950c6b8451b42f203df2c009fc653/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.stderr?ref=f7a4c9d7b55950c6b8451b42f203df2c009fc653", "patch": "@@ -7,11 +7,11 @@ LL |         let mut closure = || p = &y;\n    = note: defining type: DefId(0:13 ~ escape_upvar_ref[317d]::test[0]::{{closure}}[0]) with closure substs [\n                i16,\n                extern \"rust-call\" fn(()),\n-               &'_#1r mut &'_#2r i32,\n-               &'_#3r i32,\n+               &'_#1r i32,\n+               &'_#2r mut &'_#3r i32,\n            ]\n    = note: number of external vids: 4\n-   = note: where '_#3r: '_#2r\n+   = note: where '_#1r: '_#3r\n \n note: No external requirements\n   --> $DIR/escape-upvar-ref.rs:17:1"}]}