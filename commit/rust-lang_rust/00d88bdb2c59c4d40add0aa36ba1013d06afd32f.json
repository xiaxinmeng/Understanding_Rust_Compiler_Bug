{"sha": "00d88bdb2c59c4d40add0aa36ba1013d06afd32f", "node_id": "C_kwDOAAsO6NoAKDAwZDg4YmRiMmM1OWM0ZDQwYWRkMGFhMzZiYTEwMTNkMDZhZmQzMmY", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-09-17T17:27:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-09-17T17:27:05Z"}, "message": "Rollup merge of #101672 - idigdoug:array_try_into, r=Mark-Simulacrum\n\narray docs - advertise how to get array from slice\n\nOn my first Rust project, I spent more time than I care to admit figuring out how to efficiently get an array from a slice. Update the array documentation to explain this a bit more clearly.\n\n(As a side note, it's a bit unfortunate that get-array-from-slice is only available via trait since that means it can't be used from const functions yet.)", "tree": {"sha": "bafe288b41347b881e2cf8e607135d61a586a1f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bafe288b41347b881e2cf8e607135d61a586a1f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00d88bdb2c59c4d40add0aa36ba1013d06afd32f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjJgNpCRBK7hj4Ov3rIwAANpIIAAMJ5jcHw9P3aRBpzJGTeZbk\nUdAfbUTIMov4k1LkxpiUWHm2KeRUUJZuUMOyn/9/84/31PttYq/SBZNVzD9gyTro\no4mSXZdEHVZwKJz59kN9M8V0J26ETPVozDwrxV1eYDf5ENtd5HyZnQgyWhzHaI81\nyMr814Jr/uNSPLa5a34BaSZMIvJOv3cm6oBH2azgo0dPhmeIYA8U02zRNyYkxsoG\nRlU94lwY3oejqiwzKogJr6S9Eync1bmOrJW1+ycP0eP8tv0wkrCcCjyH+hKtF79L\nAaWAjYbbT/XftxvJedGZSseaPmWjCneCNE8Y+VtPbaDi1lZs61b2Cbe7mMhJDcg=\n=Y2fi\n-----END PGP SIGNATURE-----\n", "payload": "tree bafe288b41347b881e2cf8e607135d61a586a1f3\nparent 48de123d7a0753026c362a06109f9a9cebde2a2a\nparent 705a7667c5e14c7155145041ca2abe45c2863ea7\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1663435625 +0200\ncommitter GitHub <noreply@github.com> 1663435625 +0200\n\nRollup merge of #101672 - idigdoug:array_try_into, r=Mark-Simulacrum\n\narray docs - advertise how to get array from slice\n\nOn my first Rust project, I spent more time than I care to admit figuring out how to efficiently get an array from a slice. Update the array documentation to explain this a bit more clearly.\n\n(As a side note, it's a bit unfortunate that get-array-from-slice is only available via trait since that means it can't be used from const functions yet.)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00d88bdb2c59c4d40add0aa36ba1013d06afd32f", "html_url": "https://github.com/rust-lang/rust/commit/00d88bdb2c59c4d40add0aa36ba1013d06afd32f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00d88bdb2c59c4d40add0aa36ba1013d06afd32f/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48de123d7a0753026c362a06109f9a9cebde2a2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/48de123d7a0753026c362a06109f9a9cebde2a2a", "html_url": "https://github.com/rust-lang/rust/commit/48de123d7a0753026c362a06109f9a9cebde2a2a"}, {"sha": "705a7667c5e14c7155145041ca2abe45c2863ea7", "url": "https://api.github.com/repos/rust-lang/rust/commits/705a7667c5e14c7155145041ca2abe45c2863ea7", "html_url": "https://github.com/rust-lang/rust/commit/705a7667c5e14c7155145041ca2abe45c2863ea7"}], "stats": {"total": 94, "additions": 92, "deletions": 2}, "files": [{"sha": "165b9d24d934bfcfbaeeb4ced4b105fdc470b146", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/00d88bdb2c59c4d40add0aa36ba1013d06afd32f/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d88bdb2c59c4d40add0aa36ba1013d06afd32f/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=00d88bdb2c59c4d40add0aa36ba1013d06afd32f", "patch": "@@ -184,6 +184,18 @@ impl<T, const N: usize> const BorrowMut<[T]> for [T; N] {\n     }\n }\n \n+/// Tries to create an array `[T; N]` by copying from a slice `&[T]`. Succeeds if\n+/// `slice.len() == N`.\n+///\n+/// ```\n+/// let bytes: [u8; 3] = [1, 0, 2];\n+///\n+/// let bytes_head: [u8; 2] = <[u8; 2]>::try_from(&bytes[0..2]).unwrap();\n+/// assert_eq!(1, u16::from_le_bytes(bytes_head));\n+///\n+/// let bytes_tail: [u8; 2] = bytes[1..3].try_into().unwrap();\n+/// assert_eq!(512, u16::from_le_bytes(bytes_tail));\n+/// ```\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n impl<T, const N: usize> TryFrom<&[T]> for [T; N]\n where\n@@ -196,6 +208,18 @@ where\n     }\n }\n \n+/// Tries to create an array `[T; N]` by copying from a mutable slice `&mut [T]`.\n+/// Succeeds if `slice.len() == N`.\n+///\n+/// ```\n+/// let mut bytes: [u8; 3] = [1, 0, 2];\n+///\n+/// let bytes_head: [u8; 2] = <[u8; 2]>::try_from(&mut bytes[0..2]).unwrap();\n+/// assert_eq!(1, u16::from_le_bytes(bytes_head));\n+///\n+/// let bytes_tail: [u8; 2] = (&mut bytes[1..3]).try_into().unwrap();\n+/// assert_eq!(512, u16::from_le_bytes(bytes_tail));\n+/// ```\n #[stable(feature = \"try_from_mut_slice_to_array\", since = \"1.59.0\")]\n impl<T, const N: usize> TryFrom<&mut [T]> for [T; N]\n where\n@@ -208,6 +232,18 @@ where\n     }\n }\n \n+/// Tries to create an array ref `&[T; N]` from a slice ref `&[T]`. Succeeds if\n+/// `slice.len() == N`.\n+///\n+/// ```\n+/// let bytes: [u8; 3] = [1, 0, 2];\n+///\n+/// let bytes_head: &[u8; 2] = <&[u8; 2]>::try_from(&bytes[0..2]).unwrap();\n+/// assert_eq!(1, u16::from_le_bytes(*bytes_head));\n+///\n+/// let bytes_tail: &[u8; 2] = bytes[1..3].try_into().unwrap();\n+/// assert_eq!(512, u16::from_le_bytes(*bytes_tail));\n+/// ```\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n impl<'a, T, const N: usize> TryFrom<&'a [T]> for &'a [T; N] {\n     type Error = TryFromSliceError;\n@@ -223,6 +259,18 @@ impl<'a, T, const N: usize> TryFrom<&'a [T]> for &'a [T; N] {\n     }\n }\n \n+/// Tries to create a mutable array ref `&mut [T; N]` from a mutable slice ref\n+/// `&mut [T]`. Succeeds if `slice.len() == N`.\n+///\n+/// ```\n+/// let mut bytes: [u8; 3] = [1, 0, 2];\n+///\n+/// let bytes_head: &mut [u8; 2] = <&mut [u8; 2]>::try_from(&mut bytes[0..2]).unwrap();\n+/// assert_eq!(1, u16::from_le_bytes(*bytes_head));\n+///\n+/// let bytes_tail: &mut [u8; 2] = (&mut bytes[1..3]).try_into().unwrap();\n+/// assert_eq!(512, u16::from_le_bytes(*bytes_tail));\n+/// ```\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n impl<'a, T, const N: usize> TryFrom<&'a mut [T]> for &'a mut [T; N] {\n     type Error = TryFromSliceError;"}, {"sha": "331714a993c609210adb04bfdbdd35c053408e70", "filename": "library/core/src/primitive_docs.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/00d88bdb2c59c4d40add0aa36ba1013d06afd32f/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d88bdb2c59c4d40add0aa36ba1013d06afd32f/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fprimitive_docs.rs?ref=00d88bdb2c59c4d40add0aa36ba1013d06afd32f", "patch": "@@ -611,7 +611,19 @@ mod prim_pointer {}\n ///\n /// Arrays coerce to [slices (`[T]`)][slice], so a slice method may be called on\n /// an array. Indeed, this provides most of the API for working with arrays.\n-/// Slices have a dynamic size and do not coerce to arrays.\n+///\n+/// Slices have a dynamic size and do not coerce to arrays. Instead, use\n+/// `slice.try_into().unwrap()` or `<ArrayType>::try_from(slice).unwrap()`.\n+///\n+/// Array's `try_from(slice)` implementations (and the corresponding `slice.try_into()`\n+/// array implementations) succeed if the input slice length is the same as the result\n+/// array length. They optimize especially well when the optimizer can easily determine\n+/// the slice length, e.g. `<[u8; 4]>::try_from(&slice[4..8]).unwrap()`. Array implements\n+/// [TryFrom](crate::convert::TryFrom) returning:\n+///\n+/// - `[T; N]` copies from the slice's elements\n+/// - `&[T; N]` references the original slice's elements\n+/// - `&mut [T; N]` references the original slice's elements\n ///\n /// You can move elements out of an array with a [slice pattern]. If you want\n /// one element, see [`mem::replace`].\n@@ -640,6 +652,15 @@ mod prim_pointer {}\n /// for x in &array { }\n /// ```\n ///\n+/// You can use `<ArrayType>::try_from(slice)` or `slice.try_into()` to get an array from\n+/// a slice:\n+///\n+/// ```\n+/// let bytes: [u8; 3] = [1, 0, 2];\n+/// assert_eq!(1, u16::from_le_bytes(<[u8; 2]>::try_from(&bytes[0..2]).unwrap()));\n+/// assert_eq!(512, u16::from_le_bytes(bytes[1..3].try_into().unwrap()));\n+/// ```\n+///\n /// You can use a [slice pattern] to move elements out of an array:\n ///\n /// ```"}, {"sha": "331714a993c609210adb04bfdbdd35c053408e70", "filename": "library/std/src/primitive_docs.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/00d88bdb2c59c4d40add0aa36ba1013d06afd32f/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00d88bdb2c59c4d40add0aa36ba1013d06afd32f/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprimitive_docs.rs?ref=00d88bdb2c59c4d40add0aa36ba1013d06afd32f", "patch": "@@ -611,7 +611,19 @@ mod prim_pointer {}\n ///\n /// Arrays coerce to [slices (`[T]`)][slice], so a slice method may be called on\n /// an array. Indeed, this provides most of the API for working with arrays.\n-/// Slices have a dynamic size and do not coerce to arrays.\n+///\n+/// Slices have a dynamic size and do not coerce to arrays. Instead, use\n+/// `slice.try_into().unwrap()` or `<ArrayType>::try_from(slice).unwrap()`.\n+///\n+/// Array's `try_from(slice)` implementations (and the corresponding `slice.try_into()`\n+/// array implementations) succeed if the input slice length is the same as the result\n+/// array length. They optimize especially well when the optimizer can easily determine\n+/// the slice length, e.g. `<[u8; 4]>::try_from(&slice[4..8]).unwrap()`. Array implements\n+/// [TryFrom](crate::convert::TryFrom) returning:\n+///\n+/// - `[T; N]` copies from the slice's elements\n+/// - `&[T; N]` references the original slice's elements\n+/// - `&mut [T; N]` references the original slice's elements\n ///\n /// You can move elements out of an array with a [slice pattern]. If you want\n /// one element, see [`mem::replace`].\n@@ -640,6 +652,15 @@ mod prim_pointer {}\n /// for x in &array { }\n /// ```\n ///\n+/// You can use `<ArrayType>::try_from(slice)` or `slice.try_into()` to get an array from\n+/// a slice:\n+///\n+/// ```\n+/// let bytes: [u8; 3] = [1, 0, 2];\n+/// assert_eq!(1, u16::from_le_bytes(<[u8; 2]>::try_from(&bytes[0..2]).unwrap()));\n+/// assert_eq!(512, u16::from_le_bytes(bytes[1..3].try_into().unwrap()));\n+/// ```\n+///\n /// You can use a [slice pattern] to move elements out of an array:\n ///\n /// ```"}]}