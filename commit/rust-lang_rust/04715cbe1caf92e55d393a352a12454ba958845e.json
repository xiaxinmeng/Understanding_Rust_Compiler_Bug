{"sha": "04715cbe1caf92e55d393a352a12454ba958845e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0NzE1Y2JlMWNhZjkyZTU1ZDM5M2EzNTJhMTI0NTRiYTk1ODg0NWU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-12-18T16:41:33Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-12-18T16:41:33Z"}, "message": "Forbid <T>::foo syntax in mod paths", "tree": {"sha": "8c4a839f9b3ac037429d20b568c5a573c7d65825", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c4a839f9b3ac037429d20b568c5a573c7d65825"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04715cbe1caf92e55d393a352a12454ba958845e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04715cbe1caf92e55d393a352a12454ba958845e", "html_url": "https://github.com/rust-lang/rust/commit/04715cbe1caf92e55d393a352a12454ba958845e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04715cbe1caf92e55d393a352a12454ba958845e/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88c6109897417e7ab815ea1711f49545bff94601", "url": "https://api.github.com/repos/rust-lang/rust/commits/88c6109897417e7ab815ea1711f49545bff94601", "html_url": "https://github.com/rust-lang/rust/commit/88c6109897417e7ab815ea1711f49545bff94601"}], "stats": {"total": 47, "additions": 27, "deletions": 20}, "files": [{"sha": "b8752cbad52aea70267acf22dd0e79a7f257aec9", "filename": "crates/ra_assists/src/assists/add_import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04715cbe1caf92e55d393a352a12454ba958845e/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04715cbe1caf92e55d393a352a12454ba958845e/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_import.rs?ref=04715cbe1caf92e55d393a352a12454ba958845e", "patch": "@@ -590,7 +590,7 @@ fn collect_hir_path_segments(path: &hir::Path) -> Option<Vec<SmolStr>> {\n             }\n             ps.push(chain.into());\n         }\n-        hir::PathKind::Type(_) | hir::PathKind::DollarCrate(_) => return None,\n+        hir::PathKind::DollarCrate(_) => return None,\n     }\n     ps.extend(path.segments().iter().map(|it| it.name.to_string().into()));\n     Some(ps)"}, {"sha": "d4cab05614096cab4fa3d456ace3c1573628dc7e", "filename": "crates/ra_hir_def/src/body.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/04715cbe1caf92e55d393a352a12454ba958845e/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04715cbe1caf92e55d393a352a12454ba958845e/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody.rs?ref=04715cbe1caf92e55d393a352a12454ba958845e", "patch": "@@ -15,7 +15,7 @@ use crate::{\n     db::DefDatabase,\n     expr::{Expr, ExprId, Pat, PatId},\n     nameres::{BuiltinShadowMode, CrateDefMap},\n-    path::Path,\n+    path::{ModPath, Path},\n     src::HasSource,\n     DefWithBodyId, HasModule, Lookup, ModuleId,\n };\n@@ -44,7 +44,7 @@ impl Expander {\n             db.ast_id_map(self.current_file_id).ast_id(&macro_call),\n         );\n \n-        if let Some(path) = macro_call.path().and_then(|path| self.parse_path(path)) {\n+        if let Some(path) = macro_call.path().and_then(|path| self.parse_mod_path(path)) {\n             if let Some(def) = self.resolve_path_as_macro(db, &path) {\n                 let call_id = def.as_call_id(db, MacroCallKind::FnLike(ast_id));\n                 let file_id = call_id.as_file();\n@@ -81,9 +81,13 @@ impl Expander {\n         Path::from_src(path, &self.hygiene)\n     }\n \n-    fn resolve_path_as_macro(&self, db: &impl DefDatabase, path: &Path) -> Option<MacroDefId> {\n+    fn parse_mod_path(&mut self, path: ast::Path) -> Option<ModPath> {\n+        ModPath::from_src(path, &self.hygiene)\n+    }\n+\n+    fn resolve_path_as_macro(&self, db: &impl DefDatabase, path: &ModPath) -> Option<MacroDefId> {\n         self.crate_def_map\n-            .resolve_path(db, self.module.local_id, path.mod_path(), BuiltinShadowMode::Other)\n+            .resolve_path(db, self.module.local_id, path, BuiltinShadowMode::Other)\n             .0\n             .take_macros()\n     }"}, {"sha": "2dd779b66e667bb65f3d68fc0016ad16f87682f1", "filename": "crates/ra_hir_def/src/nameres/path_resolution.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/04715cbe1caf92e55d393a352a12454ba958845e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04715cbe1caf92e55d393a352a12454ba958845e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=04715cbe1caf92e55d393a352a12454ba958845e", "patch": "@@ -145,11 +145,6 @@ impl CrateDefMap {\n                     return ResolvePathResult::empty(ReachedFixedPoint::No); // extern crate declarations can add to the extern prelude\n                 }\n             }\n-            PathKind::Type(_) => {\n-                // This is handled in `infer::infer_path_expr`\n-                // The result returned here does not matter\n-                return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n-            }\n         };\n \n         for (i, segment) in segments {"}, {"sha": "1e2da6b4812aff5464c3e59c2cbaef4677bb0e49", "filename": "crates/ra_hir_def/src/path.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/04715cbe1caf92e55d393a352a12454ba958845e/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04715cbe1caf92e55d393a352a12454ba958845e/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath.rs?ref=04715cbe1caf92e55d393a352a12454ba958845e", "patch": "@@ -26,8 +26,6 @@ pub enum PathKind {\n     Crate,\n     /// Absolute path (::foo)\n     Abs,\n-    /// Type based path like `<T>::foo`\n-    Type(Box<TypeRef>),\n     /// `$crate` from macro expansion\n     DollarCrate(CrateId),\n }\n@@ -84,6 +82,8 @@ impl ModPath {\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Path {\n+    /// Type based path like `<T>::foo`\n+    type_anchor: Option<Box<TypeRef>>,\n     mod_path: ModPath,\n     /// Invariant: the same len as self.path.segments\n     generic_args: Vec<Option<Arc<GenericArgs>>>,\n@@ -126,7 +126,7 @@ impl Path {\n \n     /// Converts an `ast::NameRef` into a single-identifier `Path`.\n     pub(crate) fn from_name_ref(name_ref: &ast::NameRef) -> Path {\n-        Path { mod_path: name_ref.as_name().into(), generic_args: vec![None] }\n+        Path { type_anchor: None, mod_path: name_ref.as_name().into(), generic_args: vec![None] }\n     }\n \n     /// `true` if this path is just a standalone `self`\n@@ -138,6 +138,10 @@ impl Path {\n         &self.mod_path.kind\n     }\n \n+    pub fn type_anchor(&self) -> Option<&TypeRef> {\n+        self.type_anchor.as_ref().map(|it| &**it)\n+    }\n+\n     pub fn segments(&self) -> PathSegments<'_> {\n         PathSegments {\n             segments: self.mod_path.segments.as_slice(),\n@@ -154,6 +158,7 @@ impl Path {\n             return None;\n         }\n         let res = Path {\n+            type_anchor: self.type_anchor.clone(),\n             mod_path: ModPath {\n                 kind: self.mod_path.kind.clone(),\n                 segments: self.mod_path.segments[..self.mod_path.segments.len() - 1].to_vec(),\n@@ -226,6 +231,7 @@ impl GenericArgs {\n impl From<Name> for Path {\n     fn from(name: Name) -> Path {\n         Path {\n+            type_anchor: None,\n             mod_path: ModPath::from_simple_segments(PathKind::Plain, iter::once(name)),\n             generic_args: vec![None],\n         }"}, {"sha": "62aafd508e14651d3bde1cd0e2d8fad9b9a36e4d", "filename": "crates/ra_hir_def/src/path/lower.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04715cbe1caf92e55d393a352a12454ba958845e/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04715cbe1caf92e55d393a352a12454ba958845e/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs?ref=04715cbe1caf92e55d393a352a12454ba958845e", "patch": "@@ -22,6 +22,7 @@ pub(super) use lower_use::lower_use_tree;\n /// It correctly handles `$crate` based path from macro call.\n pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path> {\n     let mut kind = PathKind::Plain;\n+    let mut type_anchor = None;\n     let mut segments = Vec::new();\n     let mut generic_args = Vec::new();\n     loop {\n@@ -63,7 +64,8 @@ pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path>\n                 match trait_ref {\n                     // <T>::foo\n                     None => {\n-                        kind = PathKind::Type(Box::new(self_type));\n+                        type_anchor = Some(Box::new(self_type));\n+                        kind = PathKind::Plain;\n                     }\n                     // <T as Trait<A>>::Foo desugars to Trait<Self=T, A>::Foo\n                     Some(trait_ref) => {\n@@ -111,7 +113,7 @@ pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path>\n     segments.reverse();\n     generic_args.reverse();\n     let mod_path = ModPath { kind, segments };\n-    return Some(Path { mod_path, generic_args });\n+    return Some(Path { type_anchor, mod_path, generic_args });\n \n     fn qualifier(path: &ast::Path) -> Option<ast::Path> {\n         if let Some(q) = path.qualifier() {"}, {"sha": "402a89386ba60ce9a5f119a6638dff3f972205f2", "filename": "crates/ra_hir_ty/src/infer/path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04715cbe1caf92e55d393a352a12454ba958845e/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04715cbe1caf92e55d393a352a12454ba958845e/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=04715cbe1caf92e55d393a352a12454ba958845e", "patch": "@@ -3,7 +3,7 @@\n use std::iter;\n \n use hir_def::{\n-    path::{Path, PathKind, PathSegment},\n+    path::{Path, PathSegment},\n     resolver::{ResolveValueResult, Resolver, TypeNs, ValueNs},\n     AssocItemId, ContainerId, Lookup,\n };\n@@ -32,7 +32,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         path: &Path,\n         id: ExprOrPatId,\n     ) -> Option<Ty> {\n-        let (value, self_subst) = if let PathKind::Type(type_ref) = path.kind() {\n+        let (value, self_subst) = if let Some(type_ref) = path.type_anchor() {\n             if path.segments().is_empty() {\n                 // This can't actually happen syntax-wise\n                 return None;"}, {"sha": "2b84309d7aacf2f9936d1afb90b112004a6896b4", "filename": "crates/ra_hir_ty/src/lower.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04715cbe1caf92e55d393a352a12454ba958845e/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04715cbe1caf92e55d393a352a12454ba958845e/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flower.rs?ref=04715cbe1caf92e55d393a352a12454ba958845e", "patch": "@@ -11,7 +11,7 @@ use std::sync::Arc;\n use hir_def::{\n     builtin_type::BuiltinType,\n     generics::WherePredicate,\n-    path::{GenericArg, Path, PathKind, PathSegment, PathSegments},\n+    path::{GenericArg, Path, PathSegment, PathSegments},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{TypeBound, TypeRef},\n     AdtId, ConstId, EnumId, EnumVariantId, FunctionId, GenericDefId, HasModule, ImplId,\n@@ -101,7 +101,7 @@ impl Ty {\n             TypeRef::Path(path) => path,\n             _ => return None,\n         };\n-        if let PathKind::Type(_) = path.kind() {\n+        if path.type_anchor().is_some() {\n             return None;\n         }\n         if path.segments().len() > 1 {\n@@ -202,7 +202,7 @@ impl Ty {\n \n     pub(crate) fn from_hir_path(db: &impl HirDatabase, resolver: &Resolver, path: &Path) -> Ty {\n         // Resolve the path (in type namespace)\n-        if let PathKind::Type(type_ref) = path.kind() {\n+        if let Some(type_ref) = path.type_anchor() {\n             let ty = Ty::from_hir(db, resolver, &type_ref);\n             return Ty::from_type_relative_path(db, resolver, ty, path.segments());\n         }"}]}