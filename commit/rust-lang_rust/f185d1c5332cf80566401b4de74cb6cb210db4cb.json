{"sha": "f185d1c5332cf80566401b4de74cb6cb210db4cb", "node_id": "C_kwDOAAsO6NoAKGYxODVkMWM1MzMyY2Y4MDU2NjQwMWI0ZGU3NGNiNmNiMjEwZGI0Y2I", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-10-12T18:35:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-12T18:35:03Z"}, "message": "Merge #10423\n\n10423: Internal: refactor for mdbook plugin r=Veykril a=HKalbasi\n\nThis PR is for upstreaming changes that I made for mdbook plugin. Changes are adding inlay hints to `StaticIndex` and changing some functions for working around privacy of crates.\r\n\r\nAside this, is it okay if I bring the plugin in tree? It is a simple binary crate. I feel it will better maintained here and become resistant to api changes.\n\nCo-authored-by: hamidreza kalbasi <hamidrezakalbasi@protonmail.com>", "tree": {"sha": "1e240d8ae9339effe2208ac48f5a8d52d0b280e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e240d8ae9339effe2208ac48f5a8d52d0b280e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f185d1c5332cf80566401b4de74cb6cb210db4cb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhZdVXCRBK7hj4Ov3rIwAAGbsIAAlVJ40gnuhvkCI+CZn/+BQP\noz2RqvMOyG/egdtAKb4O7t5DjfrhEiPcz76e2dvMyNJmRgHuYRbuTJiWEhaz5qI4\nVOqXMzB6nOqWUU/fVZwBnJJRHSExSGNAMJeiI5pj3c6OuuRukQPrSO9SbvaWNkVx\n0BS6yyHkE+pViTFdGX3sOxMxAUKczNhcVN1z6N1aG7yyCpJ5nycRg8YxOe2DAbbp\nEQuCtKQ/Z1uwLzQCSZd+hMlkORGcc1fAFxGCj+ax2hMZH+O8ImB0FhGm6HqGUIzf\nFzlkEg6CHPSE8QAX84OfKPI3NIy05xRmaoNp9DEopg7e+P9IO8In0XVc4S5dqX8=\n=jEEd\n-----END PGP SIGNATURE-----\n", "payload": "tree 1e240d8ae9339effe2208ac48f5a8d52d0b280e8\nparent a871da36937f427624883860eafb580d6349f8da\nparent 0f49c97e93581cc85768513cfb4aa8b29680d341\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1634063703 +0000\ncommitter GitHub <noreply@github.com> 1634063703 +0000\n\nMerge #10423\n\n10423: Internal: refactor for mdbook plugin r=Veykril a=HKalbasi\n\nThis PR is for upstreaming changes that I made for mdbook plugin. Changes are adding inlay hints to `StaticIndex` and changing some functions for working around privacy of crates.\r\n\r\nAside this, is it okay if I bring the plugin in tree? It is a simple binary crate. I feel it will better maintained here and become resistant to api changes.\n\nCo-authored-by: hamidreza kalbasi <hamidrezakalbasi@protonmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f185d1c5332cf80566401b4de74cb6cb210db4cb", "html_url": "https://github.com/rust-lang/rust/commit/f185d1c5332cf80566401b4de74cb6cb210db4cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f185d1c5332cf80566401b4de74cb6cb210db4cb/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a871da36937f427624883860eafb580d6349f8da", "url": "https://api.github.com/repos/rust-lang/rust/commits/a871da36937f427624883860eafb580d6349f8da", "html_url": "https://github.com/rust-lang/rust/commit/a871da36937f427624883860eafb580d6349f8da"}, {"sha": "0f49c97e93581cc85768513cfb4aa8b29680d341", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f49c97e93581cc85768513cfb4aa8b29680d341", "html_url": "https://github.com/rust-lang/rust/commit/0f49c97e93581cc85768513cfb4aa8b29680d341"}], "stats": {"total": 50, "additions": 41, "deletions": 9}, "files": [{"sha": "5369f9c31fabdf43c311925a9415702cdee338de", "filename": "crates/ide/src/static_index.rs", "status": "modified", "additions": 33, "deletions": 7, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f185d1c5332cf80566401b4de74cb6cb210db4cb/crates%2Fide%2Fsrc%2Fstatic_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f185d1c5332cf80566401b4de74cb6cb210db4cb/crates%2Fide%2Fsrc%2Fstatic_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fstatic_index.rs?ref=f185d1c5332cf80566401b4de74cb6cb210db4cb", "patch": "@@ -14,11 +14,14 @@ use syntax::{SyntaxToken, TextRange};\n \n use crate::display::TryToNav;\n use crate::hover::hover_for_definition;\n-use crate::{Analysis, Fold, HoverConfig, HoverDocFormat, HoverResult};\n+use crate::{\n+    Analysis, Fold, HoverConfig, HoverDocFormat, HoverResult, InlayHint, InlayHintsConfig,\n+};\n \n /// A static representation of fully analyzed source code.\n ///\n /// The intended use-case is powering read-only code browsers and emitting LSIF\n+#[derive(Debug)]\n pub struct StaticIndex<'a> {\n     pub files: Vec<StaticIndexedFile>,\n     pub tokens: TokenStore,\n@@ -27,21 +30,29 @@ pub struct StaticIndex<'a> {\n     def_map: HashMap<Definition, TokenId>,\n }\n \n+#[derive(Debug)]\n pub struct ReferenceData {\n     pub range: FileRange,\n     pub is_definition: bool,\n }\n \n+#[derive(Debug)]\n pub struct TokenStaticData {\n     pub hover: Option<HoverResult>,\n     pub definition: Option<FileRange>,\n     pub references: Vec<ReferenceData>,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct TokenId(usize);\n \n-#[derive(Default)]\n+impl TokenId {\n+    pub fn raw(self) -> usize {\n+        self.0\n+    }\n+}\n+\n+#[derive(Default, Debug)]\n pub struct TokenStore(Vec<TokenStaticData>);\n \n impl TokenStore {\n@@ -64,9 +75,11 @@ impl TokenStore {\n     }\n }\n \n+#[derive(Debug)]\n pub struct StaticIndexedFile {\n     pub file_id: FileId,\n     pub folds: Vec<Fold>,\n+    pub inlay_hints: Vec<InlayHint>,\n     pub tokens: Vec<(TextRange, TokenId)>,\n }\n \n@@ -86,6 +99,18 @@ fn all_modules(db: &dyn HirDatabase) -> Vec<Module> {\n impl StaticIndex<'_> {\n     fn add_file(&mut self, file_id: FileId) {\n         let folds = self.analysis.folding_ranges(file_id).unwrap();\n+        let inlay_hints = self\n+            .analysis\n+            .inlay_hints(\n+                &InlayHintsConfig {\n+                    type_hints: true,\n+                    parameter_hints: true,\n+                    chaining_hints: true,\n+                    max_length: Some(25),\n+                },\n+                file_id,\n+            )\n+            .unwrap();\n         // hovers\n         let sema = hir::Semantics::new(self.db);\n         let tokens_or_nodes = sema.parse(file_id).syntax().clone();\n@@ -99,7 +124,7 @@ impl StaticIndex<'_> {\n             IDENT | INT_NUMBER | LIFETIME_IDENT | T![self] | T![super] | T![crate] => true,\n             _ => false,\n         });\n-        let mut result = StaticIndexedFile { file_id, folds, tokens: vec![] };\n+        let mut result = StaticIndexedFile { file_id, inlay_hints, folds, tokens: vec![] };\n         for token in tokens {\n             let range = token.text_range();\n             let node = token.parent().unwrap();\n@@ -133,7 +158,8 @@ impl StaticIndex<'_> {\n         self.files.push(result);\n     }\n \n-    pub fn compute<'a>(db: &'a RootDatabase, analysis: &'a Analysis) -> StaticIndex<'a> {\n+    pub fn compute<'a>(analysis: &'a Analysis) -> StaticIndex<'a> {\n+        let db = &*analysis.db;\n         let work = all_modules(db).into_iter().filter(|module| {\n             let file_id = module.definition_source(db).file_id.original_file(db);\n             let source_root = db.file_source_root(file_id);\n@@ -181,7 +207,7 @@ mod tests {\n \n     fn check_all_ranges(ra_fixture: &str) {\n         let (analysis, ranges) = fixture::annotations_without_marker(ra_fixture);\n-        let s = StaticIndex::compute(&*analysis.db, &analysis);\n+        let s = StaticIndex::compute(&analysis);\n         let mut range_set: HashSet<_> = ranges.iter().map(|x| x.0).collect();\n         for f in s.files {\n             for (range, _) in f.tokens {\n@@ -199,7 +225,7 @@ mod tests {\n \n     fn check_definitions(ra_fixture: &str) {\n         let (analysis, ranges) = fixture::annotations_without_marker(ra_fixture);\n-        let s = StaticIndex::compute(&*analysis.db, &analysis);\n+        let s = StaticIndex::compute(&analysis);\n         let mut range_set: HashSet<_> = ranges.iter().map(|x| x.0).collect();\n         for (_, t) in s.tokens.iter() {\n             if let Some(x) = t.definition {"}, {"sha": "f3b843dc088c7f6447d85729f547ed3b34fcaf5e", "filename": "crates/rust-analyzer/src/cli/lsif.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f185d1c5332cf80566401b4de74cb6cb210db4cb/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f185d1c5332cf80566401b4de74cb6cb210db4cb/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs?ref=f185d1c5332cf80566401b4de74cb6cb210db4cb", "patch": "@@ -186,7 +186,7 @@ impl LsifManager<'_> {\n     }\n \n     fn add_file(&mut self, file: StaticIndexedFile) {\n-        let StaticIndexedFile { file_id, tokens, folds } = file;\n+        let StaticIndexedFile { file_id, tokens, folds, .. } = file;\n         let doc_id = self.get_file_id(file_id);\n         let text = self.analysis.file_text(file_id).unwrap();\n         let line_index = self.db.line_index(file_id);\n@@ -247,7 +247,7 @@ impl flags::Lsif {\n         let db = host.raw_database();\n         let analysis = host.analysis();\n \n-        let si = StaticIndex::compute(db, &analysis);\n+        let si = StaticIndex::compute(&analysis);\n \n         let mut lsif = LsifManager::new(&analysis, db, &vfs);\n         lsif.add_vertex(lsif::Vertex::MetaData(lsif::MetaData {"}, {"sha": "c4ecc9bb0565e51018e5da61b9a6be69cf6ab6ef", "filename": "crates/vfs/src/vfs_path.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f185d1c5332cf80566401b4de74cb6cb210db4cb/crates%2Fvfs%2Fsrc%2Fvfs_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f185d1c5332cf80566401b4de74cb6cb210db4cb/crates%2Fvfs%2Fsrc%2Fvfs_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Fvfs_path.rs?ref=f185d1c5332cf80566401b4de74cb6cb210db4cb", "patch": "@@ -25,6 +25,12 @@ impl VfsPath {\n         VfsPath(VfsPathRepr::VirtualPath(VirtualPath(path)))\n     }\n \n+    /// Create a path from string. Input should be a string representation of\n+    /// an absolute path inside filesystem\n+    pub fn new_real_path(path: String) -> VfsPath {\n+        VfsPath::from(AbsPathBuf::assert(path.into()))\n+    }\n+\n     /// Returns the `AbsPath` representation of `self` if `self` is on the file system.\n     pub fn as_path(&self) -> Option<&AbsPath> {\n         match &self.0 {"}]}