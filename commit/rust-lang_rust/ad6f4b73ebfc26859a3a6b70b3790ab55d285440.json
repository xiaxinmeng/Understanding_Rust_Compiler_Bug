{"sha": "ad6f4b73ebfc26859a3a6b70b3790ab55d285440", "node_id": "C_kwDOAAsO6NoAKGFkNmY0YjczZWJmYzI2ODU5YTNhNmI3MGIzNzkwYWI1NWQyODU0NDA", "commit": {"author": {"name": "Urgau", "email": "urgau@numericable.fr", "date": "2023-04-30T09:51:36Z"}, "committer": {"name": "Urgau", "email": "urgau@numericable.fr", "date": "2023-05-05T11:06:47Z"}, "message": "Use explicit instead of implicit control-flow for check-cfg parsing", "tree": {"sha": "068293914abd251db2fa44de520c11f6b238c8d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/068293914abd251db2fa44de520c11f6b238c8d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad6f4b73ebfc26859a3a6b70b3790ab55d285440", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad6f4b73ebfc26859a3a6b70b3790ab55d285440", "html_url": "https://github.com/rust-lang/rust/commit/ad6f4b73ebfc26859a3a6b70b3790ab55d285440", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad6f4b73ebfc26859a3a6b70b3790ab55d285440/comments", "author": {"login": "Urgau", "id": 3616612, "node_id": "MDQ6VXNlcjM2MTY2MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3616612?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Urgau", "html_url": "https://github.com/Urgau", "followers_url": "https://api.github.com/users/Urgau/followers", "following_url": "https://api.github.com/users/Urgau/following{/other_user}", "gists_url": "https://api.github.com/users/Urgau/gists{/gist_id}", "starred_url": "https://api.github.com/users/Urgau/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Urgau/subscriptions", "organizations_url": "https://api.github.com/users/Urgau/orgs", "repos_url": "https://api.github.com/users/Urgau/repos", "events_url": "https://api.github.com/users/Urgau/events{/privacy}", "received_events_url": "https://api.github.com/users/Urgau/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Urgau", "id": 3616612, "node_id": "MDQ6VXNlcjM2MTY2MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3616612?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Urgau", "html_url": "https://github.com/Urgau", "followers_url": "https://api.github.com/users/Urgau/followers", "following_url": "https://api.github.com/users/Urgau/following{/other_user}", "gists_url": "https://api.github.com/users/Urgau/gists{/gist_id}", "starred_url": "https://api.github.com/users/Urgau/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Urgau/subscriptions", "organizations_url": "https://api.github.com/users/Urgau/orgs", "repos_url": "https://api.github.com/users/Urgau/repos", "events_url": "https://api.github.com/users/Urgau/events{/privacy}", "received_events_url": "https://api.github.com/users/Urgau/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cad92b4c979760b088ffd18e6c89801668c944f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/cad92b4c979760b088ffd18e6c89801668c944f2", "html_url": "https://github.com/rust-lang/rust/commit/cad92b4c979760b088ffd18e6c89801668c944f2"}], "stats": {"total": 63, "additions": 40, "deletions": 23}, "files": [{"sha": "de24a25f1336e7d88614f943506f54889d932cfb", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 40, "deletions": 23, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/ad6f4b73ebfc26859a3a6b70b3790ab55d285440/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad6f4b73ebfc26859a3a6b70b3790ab55d285440/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=ad6f4b73ebfc26859a3a6b70b3790ab55d285440", "patch": "@@ -13,7 +13,8 @@ use rustc_middle::ty;\n use rustc_parse::maybe_new_parser_from_source_str;\n use rustc_query_impl::QueryCtxt;\n use rustc_query_system::query::print_query_stack;\n-use rustc_session::config::{self, CheckCfg, ErrorOutputType, Input, OutputFilenames};\n+use rustc_session::config::{self, ErrorOutputType, Input, OutputFilenames};\n+use rustc_session::config::{CheckCfg, ExpectedValues};\n use rustc_session::lint;\n use rustc_session::parse::{CrateConfig, ParseSess};\n use rustc_session::Session;\n@@ -121,9 +122,9 @@ pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> FxHashSet<(String, Option<String\n /// Converts strings provided as `--check-cfg [specs]` into a `CheckCfg`.\n pub fn parse_check_cfg(specs: Vec<String>) -> CheckCfg {\n     rustc_span::create_default_session_if_not_set_then(move |_| {\n-        let mut cfg = CheckCfg::default();\n+        let mut check_cfg = CheckCfg::default();\n \n-        'specs: for s in specs {\n+        for s in specs {\n             let sess = ParseSess::with_silent_emitter(Some(format!(\n                 \"this error occurred on the command line: `--check-cfg={s}`\"\n             )));\n@@ -137,17 +138,24 @@ pub fn parse_check_cfg(specs: Vec<String>) -> CheckCfg {\n                             concat!(\"invalid `--check-cfg` argument: `{}` (\", $reason, \")\"),\n                             s\n                         ),\n-                    );\n+                    )\n                 };\n             }\n \n+            let expected_error = || {\n+                error!(\n+                    \"expected `names(name1, name2, ... nameN)` or \\\n+                        `values(name, \\\"value1\\\", \\\"value2\\\", ... \\\"valueN\\\")`\"\n+                )\n+            };\n+\n             match maybe_new_parser_from_source_str(&sess, filename, s.to_string()) {\n                 Ok(mut parser) => match parser.parse_meta_item() {\n                     Ok(meta_item) if parser.token == token::Eof => {\n                         if let Some(args) = meta_item.meta_item_list() {\n                             if meta_item.has_name(sym::names) {\n                                 let names_valid =\n-                                    cfg.names_valid.get_or_insert_with(|| FxHashSet::default());\n+                                    check_cfg.names_valid.get_or_insert_with(|| FxHashSet::default());\n                                 for arg in args {\n                                     if arg.is_word() && arg.ident().is_some() {\n                                         let ident = arg.ident().expect(\"multi-segment cfg key\");\n@@ -156,15 +164,20 @@ pub fn parse_check_cfg(specs: Vec<String>) -> CheckCfg {\n                                         error!(\"`names()` arguments must be simple identifiers\");\n                                     }\n                                 }\n-                                continue 'specs;\n                             } else if meta_item.has_name(sym::values) {\n                                 if let Some((name, values)) = args.split_first() {\n                                     if name.is_word() && name.ident().is_some() {\n                                         let ident = name.ident().expect(\"multi-segment cfg key\");\n-                                        let ident_values = cfg\n+                                        let ident_values = check_cfg\n                                             .values_valid\n                                             .entry(ident.name.to_string())\n-                                            .or_insert_with(|| FxHashSet::default());\n+                                            .or_insert_with(|| {\n+                                                ExpectedValues::Some(FxHashSet::default())\n+                                            });\n+\n+                                        let ExpectedValues::Some(expected_values) = expected_values else {\n+                                            bug!(\"shoudn't be possible\")\n+                                        };\n \n                                         for val in values {\n                                             if let Some(LitKind::Str(s, _)) =\n@@ -177,36 +190,40 @@ pub fn parse_check_cfg(specs: Vec<String>) -> CheckCfg {\n                                                 );\n                                             }\n                                         }\n-\n-                                        continue 'specs;\n                                     } else {\n                                         error!(\n                                             \"`values()` first argument must be a simple identifier\"\n                                         );\n                                     }\n                                 } else if args.is_empty() {\n-                                    cfg.well_known_values = true;\n-                                    continue 'specs;\n+                                    check_cfg.well_known_values = true;\n+                                } else {\n+                                    expected_error();\n                                 }\n+                            } else {\n+                                expected_error();\n                             }\n+                        } else {\n+                            expected_error();\n                         }\n                     }\n-                    Ok(..) => {}\n-                    Err(err) => err.cancel(),\n+                    Ok(..) => expected_error(),\n+                    Err(err) => {\n+                        err.cancel();\n+                        expected_error();\n+                    }\n                 },\n-                Err(errs) => drop(errs),\n+                Err(errs) => {\n+                    drop(errs);\n+                    expected_error();\n+                }\n             }\n-\n-            error!(\n-                \"expected `names(name1, name2, ... nameN)` or \\\n-                `values(name, \\\"value1\\\", \\\"value2\\\", ... \\\"valueN\\\")`\"\n-            );\n         }\n \n-        if let Some(names_valid) = &mut cfg.names_valid {\n-            names_valid.extend(cfg.values_valid.keys().cloned());\n+        if let Some(names_valid) = &mut check_cfg.names_valid {\n+            names_valid.extend(check_cfg.values_valid.keys().cloned());\n         }\n-        cfg\n+        check_cfg\n     })\n }\n "}]}