{"sha": "138365368a71a04ff9539704f478b014379b7ee5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzODM2NTM2OGE3MWEwNGZmOTUzOTcwNGY0NzhiMDE0Mzc5YjdlZTU=", "commit": {"author": {"name": "bobtwinkles", "email": "srkoser+github@gmail.com", "date": "2018-03-05T07:44:10Z"}, "committer": {"name": "bobtwinkles", "email": "srkoser+github@gmail.com", "date": "2018-03-09T18:53:35Z"}, "message": "Finally start down the right path", "tree": {"sha": "8e6b399c8e2feb58f575949027e013f3c2a42eb2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e6b399c8e2feb58f575949027e013f3c2a42eb2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/138365368a71a04ff9539704f478b014379b7ee5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/138365368a71a04ff9539704f478b014379b7ee5", "html_url": "https://github.com/rust-lang/rust/commit/138365368a71a04ff9539704f478b014379b7ee5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/138365368a71a04ff9539704f478b014379b7ee5/comments", "author": {"login": "bobtwinkles", "id": 1514748, "node_id": "MDQ6VXNlcjE1MTQ3NDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1514748?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobtwinkles", "html_url": "https://github.com/bobtwinkles", "followers_url": "https://api.github.com/users/bobtwinkles/followers", "following_url": "https://api.github.com/users/bobtwinkles/following{/other_user}", "gists_url": "https://api.github.com/users/bobtwinkles/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobtwinkles/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobtwinkles/subscriptions", "organizations_url": "https://api.github.com/users/bobtwinkles/orgs", "repos_url": "https://api.github.com/users/bobtwinkles/repos", "events_url": "https://api.github.com/users/bobtwinkles/events{/privacy}", "received_events_url": "https://api.github.com/users/bobtwinkles/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bobtwinkles", "id": 1514748, "node_id": "MDQ6VXNlcjE1MTQ3NDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1514748?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobtwinkles", "html_url": "https://github.com/bobtwinkles", "followers_url": "https://api.github.com/users/bobtwinkles/followers", "following_url": "https://api.github.com/users/bobtwinkles/following{/other_user}", "gists_url": "https://api.github.com/users/bobtwinkles/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobtwinkles/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobtwinkles/subscriptions", "organizations_url": "https://api.github.com/users/bobtwinkles/orgs", "repos_url": "https://api.github.com/users/bobtwinkles/repos", "events_url": "https://api.github.com/users/bobtwinkles/events{/privacy}", "received_events_url": "https://api.github.com/users/bobtwinkles/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "580467d3065c5520dbe6c8318a1a0e3519b01a3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/580467d3065c5520dbe6c8318a1a0e3519b01a3a", "html_url": "https://github.com/rust-lang/rust/commit/580467d3065c5520dbe6c8318a1a0e3519b01a3a"}], "stats": {"total": 858, "additions": 427, "deletions": 431}, "files": [{"sha": "7ab52e98a0ee181646bfc29be7229f8c8c8182fa", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/138365368a71a04ff9539704f478b014379b7ee5/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/138365368a71a04ff9539704f478b014379b7ee5/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=138365368a71a04ff9539704f478b014379b7ee5", "patch": "@@ -18,7 +18,7 @@ use rustc_data_structures::sync::Lrc;\n \n use super::{Context, MirBorrowckCtxt};\n use super::{InitializationRequiringAction, PrefixSet};\n-use dataflow::{ActiveBorrows, BorrowData, FlowAtLocation, MovingOutStatements};\n+use dataflow::{Borrows, BorrowData, FlowAtLocation, MovingOutStatements};\n use dataflow::move_paths::MovePathIndex;\n use util::borrowck_errors::{BorrowckErrors, Origin};\n \n@@ -372,10 +372,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         context: Context,\n         borrow: &BorrowData<'tcx>,\n         drop_span: Span,\n-        borrows: &ActiveBorrows<'cx, 'gcx, 'tcx>,\n+        borrows: &Borrows<'cx, 'gcx, 'tcx>\n     ) {\n         let end_span = borrows.opt_region_end_span(&borrow.region);\n-        let scope_tree = borrows.0.scope_tree();\n+        let scope_tree = borrows.scope_tree();\n         let root_place = self.prefixes(&borrow.borrowed_place, PrefixSet::All)\n             .last()\n             .unwrap();"}, {"sha": "ceff380c594ed48f37abdcab322c14f6f4ef2f4d", "filename": "src/librustc_mir/borrow_check/flows.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/138365368a71a04ff9539704f478b014379b7ee5/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/138365368a71a04ff9539704f478b014379b7ee5/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs?ref=138365368a71a04ff9539704f478b014379b7ee5", "patch": "@@ -17,13 +17,14 @@ use rustc::mir::{BasicBlock, Location};\n \n use dataflow::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n use dataflow::{EverInitializedPlaces, MovingOutStatements};\n-use dataflow::{ActiveBorrows, FlowAtLocation, FlowsAtLocation};\n+use dataflow::{Borrows};\n+use dataflow::{FlowAtLocation, FlowsAtLocation};\n use dataflow::move_paths::HasMoveData;\n use std::fmt;\n \n // (forced to be `pub` due to its use as an associated type below.)\n pub(crate) struct Flows<'b, 'gcx: 'tcx, 'tcx: 'b> {\n-    pub borrows: FlowAtLocation<ActiveBorrows<'b, 'gcx, 'tcx>>,\n+    pub borrows: FlowAtLocation<Borrows<'b, 'gcx, 'tcx>>,\n     pub inits: FlowAtLocation<MaybeInitializedPlaces<'b, 'gcx, 'tcx>>,\n     pub uninits: FlowAtLocation<MaybeUninitializedPlaces<'b, 'gcx, 'tcx>>,\n     pub move_outs: FlowAtLocation<MovingOutStatements<'b, 'gcx, 'tcx>>,\n@@ -32,7 +33,7 @@ pub(crate) struct Flows<'b, 'gcx: 'tcx, 'tcx: 'b> {\n \n impl<'b, 'gcx, 'tcx> Flows<'b, 'gcx, 'tcx> {\n     pub fn new(\n-        borrows: FlowAtLocation<ActiveBorrows<'b, 'gcx, 'tcx>>,\n+        borrows: FlowAtLocation<Borrows<'b, 'gcx, 'tcx>>,\n         inits: FlowAtLocation<MaybeInitializedPlaces<'b, 'gcx, 'tcx>>,\n         uninits: FlowAtLocation<MaybeUninitializedPlaces<'b, 'gcx, 'tcx>>,\n         move_outs: FlowAtLocation<MovingOutStatements<'b, 'gcx, 'tcx>>,"}, {"sha": "3f111ebcb78029ddb3ed1d219e007035050f0730", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 15, "deletions": 38, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/138365368a71a04ff9539704f478b014379b7ee5/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/138365368a71a04ff9539704f478b014379b7ee5/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=138365368a71a04ff9539704f478b014379b7ee5", "patch": "@@ -34,11 +34,10 @@ use syntax_pos::Span;\n use dataflow::{do_dataflow, DebugFormatted};\n use dataflow::FlowAtLocation;\n use dataflow::MoveDataParamEnv;\n-use dataflow::{DataflowAnalysis, DataflowResultsConsumer};\n+use dataflow::{DataflowResultsConsumer};\n use dataflow::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n use dataflow::{EverInitializedPlaces, MovingOutStatements};\n use dataflow::{BorrowData, Borrows, ReserveOrActivateIndex};\n-use dataflow::{ActiveBorrows, Reservations};\n use dataflow::indexes::BorrowIndex;\n use dataflow::move_paths::{IllegalMoveOriginKind, MoveError};\n use dataflow::move_paths::{HasMoveData, LookupResult, MoveData, MovePathIndex};\n@@ -54,8 +53,6 @@ mod error_reporting;\n mod flows;\n mod prefixes;\n \n-use std::borrow::Cow;\n-\n pub(crate) mod nll;\n \n pub fn provide(providers: &mut Providers) {\n@@ -209,6 +206,18 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     };\n     let flow_inits = flow_inits; // remove mut\n \n+    let flow_borrows = FlowAtLocation::new(do_dataflow(\n+        tcx,\n+        mir,\n+        id,\n+        &attributes,\n+        &dead_unwinds,\n+        Borrows::new(tcx, mir, opt_regioncx.clone(), def_id, body_id),\n+        |rs, i| {\n+            DebugFormatted::new(&(i.kind(), rs.location(i.borrow_index())))\n+        }\n+    ));\n+\n     let movable_generator = !match tcx.hir.get(id) {\n         hir::map::Node::NodeExpr(&hir::Expr {\n             node: hir::ExprClosure(.., Some(hir::GeneratorMovability::Static)),\n@@ -230,44 +239,12 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         },\n         access_place_error_reported: FxHashSet(),\n         reservation_error_reported: FxHashSet(),\n-        nonlexical_regioncx: opt_regioncx.clone(),\n+        nonlexical_regioncx: opt_regioncx,\n         nonlexical_cause_info: None,\n     };\n \n-    let borrows = Borrows::new(tcx, mir, opt_regioncx, def_id, body_id);\n-    let flow_reservations = do_dataflow(\n-        tcx,\n-        mir,\n-        id,\n-        &attributes,\n-        &dead_unwinds,\n-        Reservations::new(borrows),\n-        |rs, i| {\n-            // In principle we could make the dataflow ensure that\n-            // only reservation bits show up, and assert so here.\n-            //\n-            // In practice it is easier to be looser; in particular,\n-            // it is okay for the kill-sets to hold activation bits.\n-            DebugFormatted::new(&(i.kind(), rs.location(i)))\n-        },\n-    );\n-    let flow_active_borrows = {\n-        let reservations_on_entry = flow_reservations.0.sets.entry_set_state();\n-        let reservations = flow_reservations.0.operator;\n-        let a = DataflowAnalysis::new_with_entry_sets(\n-            mir,\n-            &dead_unwinds,\n-            Cow::Borrowed(reservations_on_entry),\n-            ActiveBorrows::new(reservations),\n-        );\n-        let results = a.run(tcx, id, &attributes, |ab, i| {\n-            DebugFormatted::new(&(i.kind(), ab.location(i)))\n-        });\n-        FlowAtLocation::new(results)\n-    };\n-\n     let mut state = Flows::new(\n-        flow_active_borrows,\n+        flow_borrows,\n         flow_inits,\n         flow_uninits,\n         flow_move_outs,"}, {"sha": "4b63d8e2ff78ab92cc7ead36bc44007e6b9dec14", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 365, "deletions": 351, "changes": 716, "blob_url": "https://github.com/rust-lang/rust/blob/138365368a71a04ff9539704f478b014379b7ee5/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/138365368a71a04ff9539704f478b014379b7ee5/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=138365368a71a04ff9539704f478b014379b7ee5", "patch": "@@ -63,46 +63,25 @@ pub struct Borrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     /// to its borrow-indexes.\n     assigned_map: FxHashMap<Place<'tcx>, FxHashSet<BorrowIndex>>,\n \n+    /// Locations which activate borrows.\n+    /// NOTE: A given location may activate more than one borrow in the future\n+    /// when more general two-phase borrow support is introduced, but for now we\n+    /// only need to store one borrow index\n+    activation_map: FxHashMap<Location, BorrowIndex>,\n+\n     /// Every borrow has a region; this maps each such regions back to\n     /// its borrow-indexes.\n     region_map: FxHashMap<Region<'tcx>, FxHashSet<BorrowIndex>>,\n+\n+    /// Map from local to all the borrows on that local\n     local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n-    region_span_map: FxHashMap<RegionKind, Span>,\n-    nonlexical_regioncx: Option<Rc<RegionInferenceContext<'tcx>>>,\n-}\n \n-// Two-phase borrows actually requires two flow analyses; they need\n-// to be separate because the final results of the first are used to\n-// construct the gen+kill sets for the second. (The dataflow system\n-// is not designed to allow the gen/kill sets to change during the\n-// fixed-point iteration.)\n-\n-/// The `Reservations` analysis is the first of the two flow analyses\n-/// tracking (phased) borrows. It computes where a borrow is reserved;\n-/// i.e. where it can reach in the control flow starting from its\n-/// initial `assigned = &'rgn borrowed` statement, and ending\n-/// wherever `'rgn` itself ends.\n-pub(crate) struct Reservations<'a, 'gcx: 'tcx, 'tcx: 'a>(pub(crate) Borrows<'a, 'gcx, 'tcx>);\n-\n-/// The `ActiveBorrows` analysis is the second of the two flow\n-/// analyses tracking (phased) borrows. It computes where any given\n-/// borrow `&assigned = &'rgn borrowed` is *active*, which starts at\n-/// the first use of `assigned` after the reservation has started, and\n-/// ends wherever `'rgn` itself ends.\n-pub(crate) struct ActiveBorrows<'a, 'gcx: 'tcx, 'tcx: 'a>(pub(crate) Borrows<'a, 'gcx, 'tcx>);\n-\n-impl<'a, 'gcx, 'tcx> Reservations<'a, 'gcx, 'tcx> {\n-    pub(crate) fn new(b: Borrows<'a, 'gcx, 'tcx>) -> Self { Reservations(b) }\n-    pub(crate) fn location(&self, idx: ReserveOrActivateIndex) -> &Location {\n-        self.0.location(idx.borrow_index())\n-    }\n-}\n+    /// Maps regions to their corresponding source spans\n+    /// Only contains ReScope()s as keys\n+    region_span_map: FxHashMap<RegionKind, Span>,\n \n-impl<'a, 'gcx, 'tcx> ActiveBorrows<'a, 'gcx, 'tcx> {\n-    pub(crate) fn new(r: Reservations<'a, 'gcx, 'tcx>) -> Self { ActiveBorrows(r.0) }\n-    pub(crate) fn location(&self, idx: ReserveOrActivateIndex) -> &Location {\n-        self.0.location(idx.borrow_index())\n-    }\n+    /// NLL region inference context with which NLL queries should be resolved\n+    nonlexical_regioncx: Option<Rc<RegionInferenceContext<'tcx>>>,\n }\n \n // temporarily allow some dead fields: `kind` and `region` will be\n@@ -114,9 +93,15 @@ pub struct BorrowData<'tcx> {\n     /// Location where the borrow reservation starts.\n     /// In many cases, this will be equal to the activation location but not always.\n     pub(crate) reserve_location: Location,\n+    /// Point where the borrow is activated.\n+    pub(crate) activate_location: Location,\n+    /// What kind of borrow this is\n     pub(crate) kind: mir::BorrowKind,\n+    /// The region for which this borrow is live\n     pub(crate) region: Region<'tcx>,\n+    /// Place from which we are borrowing\n     pub(crate) borrowed_place: mir::Place<'tcx>,\n+    /// Place to which the borrow was stored\n     pub(crate) assigned_place: mir::Place<'tcx>,\n }\n \n@@ -165,9 +150,11 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n             idx_vec: IndexVec::new(),\n             location_map: FxHashMap(),\n             assigned_map: FxHashMap(),\n+            activation_map: FxHashMap(),\n             region_map: FxHashMap(),\n             local_map: FxHashMap(),\n-            region_span_map: FxHashMap()\n+            region_span_map: FxHashMap(),\n+            nonlexical_regioncx: nonlexical_regioncx.clone()\n         };\n         visitor.visit_mir(mir);\n         return Borrows { tcx: tcx,\n@@ -177,6 +164,7 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                          root_scope,\n                          location_map: visitor.location_map,\n                          assigned_map: visitor.assigned_map,\n+                         activation_map: visitor.activation_map,\n                          region_map: visitor.region_map,\n                          local_map: visitor.local_map,\n                          region_span_map: visitor.region_span_map,\n@@ -188,9 +176,11 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n             idx_vec: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n             location_map: FxHashMap<Location, BorrowIndex>,\n             assigned_map: FxHashMap<Place<'tcx>, FxHashSet<BorrowIndex>>,\n+            activation_map: FxHashMap<Location, BorrowIndex>,\n             region_map: FxHashMap<Region<'tcx>, FxHashSet<BorrowIndex>>,\n             local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n             region_span_map: FxHashMap<RegionKind, Span>,\n+            nonlexical_regioncx: Option<Rc<RegionInferenceContext<'tcx>>>,\n         }\n \n         impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n@@ -210,15 +200,25 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                 if let mir::Rvalue::Ref(region, kind, ref borrowed_place) = *rvalue {\n                     if is_unsafe_place(self.tcx, self.mir, borrowed_place) { return; }\n \n+                    let activate_location = self.compute_activation_location(location,\n+                                                                             &assigned_place,\n+                                                                             region,\n+                                                                             kind);\n                     let borrow = BorrowData {\n+                        activate_location, kind, region,\n                         reserve_location: location,\n-                        kind, region,\n                         borrowed_place: borrowed_place.clone(),\n                         assigned_place: assigned_place.clone(),\n                     };\n                     let idx = self.idx_vec.push(borrow);\n                     self.location_map.insert(location, idx);\n \n+                    // This assert is a good sanity check until more general 2-phase borrow\n+                    // support is introduced. See NOTE on the activation_map field for more\n+                    assert!(!self.activation_map.contains_key(&activate_location),\n+                            \"More than one activation introduced at the same location.\");\n+                    self.activation_map.insert(activate_location, idx);\n+\n                     insert(&mut self.assigned_map, assigned_place, idx);\n                     insert(&mut self.region_map, &region, idx);\n                     if let Some(local) = root_local(borrowed_place) {\n@@ -273,6 +273,246 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                 return self.super_statement(block, statement, location);\n             }\n         }\n+\n+        /// Represents what kind of usage we've seen.\n+        enum PlaceUsageType {\n+            /// No usage seen\n+            None,\n+            /// Has been seen as the argument to a StorageDead statement. This is required to\n+            /// gracefully handle cases where user code has an unneeded \n+            StorageKilled,\n+            /// Has been used in borrow-activating context\n+            BorrowActivateUsage\n+        }\n+\n+        /// A MIR visitor that determines if a specific place is used in a two-phase activating\n+        /// manner in a given chunk of MIR.\n+        struct ContainsUseOfPlace<'b, 'tcx: 'b> {\n+            target: &'b Place<'tcx>,\n+            use_found: bool,\n+        }\n+\n+        impl<'b, 'tcx: 'b> ContainsUseOfPlace<'b, 'tcx> {\n+            fn new(place: &'b Place<'tcx>) -> Self {\n+                Self { target: place, use_found: false }\n+            }\n+\n+            /// return whether `context` should be considered a \"use\" of a\n+            /// place found in that context. \"Uses\" activate associated\n+            /// borrows (at least when such uses occur while the borrow also\n+            /// has a reservation at the time).\n+            fn is_potential_use(context: PlaceContext) -> bool {\n+                match context {\n+                    // storage effects on a place do not activate it\n+                    PlaceContext::StorageLive | PlaceContext::StorageDead => false,\n+\n+                    // validation effects do not activate a place\n+                    //\n+                    // FIXME: Should they? Is it just another read? Or can we\n+                    // guarantee it won't dereference the stored address? How\n+                    // \"deep\" does validation go?\n+                    PlaceContext::Validate => false,\n+\n+                    // FIXME: This is here to not change behaviour from before\n+                    // AsmOutput existed, but it's not necessarily a pure overwrite.\n+                    // so it's possible this should activate the place.\n+                    PlaceContext::AsmOutput |\n+                    // pure overwrites of a place do not activate it. (note\n+                    // PlaceContext::Call is solely about dest place)\n+                    PlaceContext::Store | PlaceContext::Call => false,\n+\n+                    // reads of a place *do* activate it\n+                    PlaceContext::Move |\n+                    PlaceContext::Copy |\n+                    PlaceContext::Drop |\n+                    PlaceContext::Inspect |\n+                    PlaceContext::Borrow { .. } |\n+                    PlaceContext::Projection(..) => true,\n+                }\n+            }\n+        }\n+\n+        impl<'b, 'tcx: 'b> Visitor<'tcx> for ContainsUseOfPlace<'b, 'tcx> {\n+            fn visit_place(&mut self,\n+                           place: &mir::Place<'tcx>,\n+                           context: PlaceContext<'tcx>,\n+                           location: Location) {\n+                if Self::is_potential_use(context) && place == self.target {\n+                    self.use_found = true;\n+                    return;\n+                    // There is no need to keep checking the statement, we already found a use\n+                }\n+\n+                self.super_place(place, context, location);\n+            }\n+\n+            /*\n+            fn visit_statement(&mut self,\n+                               block: BasicBlock,\n+                               statement: &mir::Statement<'tcx>,\n+                               location: Location) {\n+                if let mir::StatementKind::StorageDead(loc) = *statement {\n+                }\n+\n+                self.super_statement(block, statement, location);\n+            }\n+            */\n+        }\n+\n+        impl<'a, 'gcx, 'tcx> GatherBorrows<'a, 'gcx, 'tcx> {\n+            /// Returns true if the borrow represented by `kind` is\n+            /// allowed to be split into separate Reservation and\n+            /// Activation phases.\n+            fn allow_two_phase_borrow(&self, kind: mir::BorrowKind) -> bool {\n+                self.tcx.sess.two_phase_borrows() &&\n+                    (kind.allows_two_phase_borrow() ||\n+                     self.tcx.sess.opts.debugging_opts.two_phase_beyond_autoref)\n+            }\n+\n+            /// Returns true if the given location contains an NLL-activating use of the given place\n+            fn location_contains_use(&self, location: Location, place: &Place) -> bool {\n+                let mut use_checker = ContainsUseOfPlace::new(place);\n+                let block = &self.mir.basic_blocks().get(location.block).unwrap_or_else(|| {\n+                    panic!(\"could not find block at location {:?}\", location);\n+                });\n+                if location.statement_index != block.statements.len() {\n+                    // This is a statement\n+                    let stmt = block.statements.get(location.statement_index).unwrap_or_else(|| {\n+                        panic!(\"could not find statement at location {:?}\");\n+                    });\n+                    use_checker.visit_statement(location.block, stmt, location);\n+                } else {\n+                    // This is a terminator\n+                    match block.terminator {\n+                        Some(ref term) => {\n+                            use_checker.visit_terminator(location.block, term, location);\n+                        }\n+                        None => {\n+                            // There is no way for Place to be used by the terminator if there is no\n+                            // terminator\n+                        }\n+                    }\n+                }\n+\n+                use_checker.use_found\n+            }\n+\n+            /// Determines if the provided region is terminated after the provided location.\n+            /// EndRegion statements terminate their enclosed region::Scope.\n+            /// We also consult with the NLL region inference engine, should one be available\n+            fn region_terminated_after(&self, region: Region<'tcx>, location: Location) -> bool {\n+                let block_data = &self.mir[location.block];\n+                if location.statement_index != block_data.statements.len() {\n+                    let stmt = &block_data.statements[location.statement_index];\n+                    if let mir::StatementKind::EndRegion(region_scope) = stmt.kind {\n+                        if &ReScope(region_scope) == region {\n+                            // We encountered an EndRegion statement that terminates the provided region\n+                            return true;\n+                        }\n+                    }\n+                }\n+                if let Some(ref regioncx) = self.nonlexical_regioncx {\n+                    if !regioncx.region_contains_point(region, location) {\n+                        // NLL says the region has ended already\n+                        return true;\n+                    }\n+                }\n+\n+                false\n+            }\n+\n+            /// Computes the activation location of a borrow.\n+            /// The general idea is to start at the beginning of the region and perform a DFS\n+            /// until we exit the region, either via an explicit EndRegion or because NLL tells\n+            /// us so. If we find more than one valid activation point, we currently panic the\n+            /// compiler since two-phase borrows are only currently supported for compiler-\n+            /// generated code. More precisely, we only allow two-phase borrows for:\n+            ///   - Function calls (fn some_func(&mut self, ....))\n+            ///   - *Assign operators (a += b -> fn add_assign(&mut self, other: Self))\n+            /// See\n+            ///   - https://github.com/rust-lang/rust/issues/48431\n+            /// for detailed design notes.\n+            /// See the TODO in the body of the function for notes on extending support to more\n+            /// general two-phased borrows.\n+            fn compute_activation_location(&self,\n+                                           start_location: Location,\n+                                           assigned_place: &mir::Place<'tcx>,\n+                                           region: Region<'tcx>,\n+                                           kind: mir::BorrowKind) -> Location {\n+                debug!(\"Borrows::compute_activation_location({:?}, {:?}, {:?})\",\n+                       start_location,\n+                       assigned_place,\n+                       region);\n+                if !self.allow_two_phase_borrow(kind) {\n+                    debug!(\"  -> {:?}\", start_location);\n+                    return start_location;\n+                }\n+\n+                // Perform the DFS.\n+                // `stack` is the stack of locations still under consideration\n+                // `found_use` is an Option that becomes Some when we find a use\n+                let mut stack = vec![start_location];\n+                let mut found_use = None;\n+                while let Some(curr_loc) = stack.pop() {\n+                    let block_data = &self.mir.basic_blocks()\n+                        .get(curr_loc.block)\n+                        .unwrap_or_else(|| {\n+                            panic!(\"could not find block at location {:?}\", curr_loc);\n+                        });\n+\n+                    if self.region_terminated_after(region, curr_loc) {\n+                        // No need to process this statement.\n+                        // It's either an EndRegion (and thus couldn't use assigned_place) or not\n+                        // contained in the NLL region and thus a use would be invalid\n+                        continue;\n+                    }\n+\n+                    if self.location_contains_use(curr_loc, assigned_place) {\n+                        // TODO: Handle this case a little more gracefully. Perhaps collect\n+                        // all uses in a vector, and find the point in the CFG that dominates\n+                        // all of them?\n+                        // Right now this is sufficient though since there should only be exactly\n+                        // one borrow-activating use of the borrow.\n+                        assert!(found_use.is_none(), \"Found secondary use of place\");\n+                        found_use = Some(curr_loc);\n+                    }\n+\n+                    // Push the points we should consider next.\n+                    if curr_loc.statement_index < block_data.statements.len() {\n+                        stack.push(curr_loc.successor_within_block());\n+                    } else {\n+                        stack.extend(block_data.terminator().successors().iter().map(\n+                            |&basic_block| {\n+                                Location {\n+                                    statement_index: 0,\n+                                    block: basic_block\n+                                }\n+                            }\n+                        ))\n+                    }\n+                }\n+\n+                let found_use = found_use.expect(\"Did not find use of two-phase place\");\n+                debug!(\"  -> {:?}\", found_use);\n+                found_use\n+            }\n+        }\n+    }\n+\n+    /// Returns the span for the \"end point\" given region. This will\n+    /// return `None` if NLL is enabled, since that concept has no\n+    /// meaning there.  Otherwise, return region span if it exists and\n+    /// span for end of the function if it doesn't exist.\n+    pub(crate) fn opt_region_end_span(&self, region: &Region) -> Option<Span> {\n+        match self.nonlexical_regioncx {\n+            Some(_) => None,\n+            None => {\n+                match self.region_span_map.get(region) {\n+                    Some(span) => Some(self.tcx.sess.codemap().end_point(*span)),\n+                    None => Some(self.tcx.sess.codemap().end_point(self.mir.span))\n+                }\n+            }\n+        }\n     }\n \n     pub fn borrows(&self) -> &IndexVec<BorrowIndex, BorrowData<'tcx>> { &self.borrows }\n@@ -284,18 +524,24 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n     }\n \n     /// Add all borrows to the kill set, if those borrows are out of scope at `location`.\n-    ///\n-    /// `is_activations` tracks whether we are in the Reservations or\n-    /// the ActiveBorrows flow analysis, and does not set the\n-    /// activation kill bits in the former case. (Technically, we\n-    /// could set those kill bits without such a guard, since they are\n-    /// never gen'ed by Reservations in the first place.  But it makes\n-    /// the instrumentation and graph renderings nicer to leave\n-    /// activations out when of the Reservations kill sets.)\n+    /// That means either they went out of either a nonlexical scope, if we care about those\n+    /// at the moment, or the location represents a lexical EndRegion\n     fn kill_loans_out_of_scope_at_location(&self,\n                                            sets: &mut BlockSets<ReserveOrActivateIndex>,\n-                                           location: Location,\n-                                           is_activations: bool) {\n+                                           location: Location) {\n+        /*\n+         XXX: bob_twinkles  reintroduce this\n+        let block_data = &self.mir[location.block];\n+        if location.statement_index != block_data.statements.len() {\n+            let statement = &block_data.statements[location.statement_index];\n+            if let mir::StatementKind::EndRegion(region_scope) = statement.kind {\n+                for &borrow_index in &self.region_map[&ReScope(region_scope)] {\n+                    sets.kill(&ReserveOrActivateIndex::reserved(borrow_index));\n+                    sets.kill(&ReserveOrActivateIndex::active(borrow_index));\n+                }\n+            }\n+        }\n+        */\n         if let Some(ref regioncx) = self.nonlexical_regioncx {\n             // NOTE: The state associated with a given `location`\n             // reflects the dataflow on entry to the statement. If it\n@@ -312,42 +558,59 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                 let borrow_region = borrow_data.region.to_region_vid();\n                 if !regioncx.region_contains_point(borrow_region, location) {\n                     sets.kill(&ReserveOrActivateIndex::reserved(borrow_index));\n-                    if is_activations {\n-                        sets.kill(&ReserveOrActivateIndex::active(borrow_index));\n-                    }\n+                    sets.kill(&ReserveOrActivateIndex::active(borrow_index));\n                 }\n             }\n         }\n     }\n \n-    /// Models statement effect in Reservations and ActiveBorrows flow\n-    /// analyses; `is activations` tells us if we are in the latter\n-    /// case.\n-    fn statement_effect_on_borrows(&self,\n-                                   sets: &mut BlockSets<ReserveOrActivateIndex>,\n-                                   location: Location,\n-                                   is_activations: bool) {\n+    fn kill_borrows_on_local(&self,\n+                             sets: &mut BlockSets<ReserveOrActivateIndex>,\n+                             local: &rustc::mir::Local)\n+    {\n+        if let Some(borrow_indexes) = self.local_map.get(local) {\n+            sets.kill_all(borrow_indexes.iter()\n+                          .map(|b| ReserveOrActivateIndex::reserved(*b)));\n+            sets.kill_all(borrow_indexes.iter()\n+                          .map(|b| ReserveOrActivateIndex::active(*b)));\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n+    type Idx = ReserveOrActivateIndex;\n+    fn name() -> &'static str { \"borrows\" }\n+    fn bits_per_block(&self) -> usize {\n+        self.borrows.len() * 2\n+    }\n+\n+    fn start_block_effect(&self, _entry_set: &mut IdxSet<ReserveOrActivateIndex>) {\n+        // no borrows of code region_scopes have been taken prior to\n+        // function execution, so this method has no effect on\n+        // `_sets`.\n+    }\n+\n+    fn before_statement_effect(&self, sets: &mut BlockSets<ReserveOrActivateIndex>, location: Location) {\n+        debug!(\"Borrows::before_statement_effect sets: {:?} location: {:?}\", sets, location);\n+        self.kill_loans_out_of_scope_at_location(sets, location);\n+    }\n+\n+    fn statement_effect(&self, sets: &mut BlockSets<ReserveOrActivateIndex>, location: Location) {\n+        debug!(\"Borrows::statement_effect sets: {:?} location: {:?}\", sets, location);\n+\n         let block = &self.mir.basic_blocks().get(location.block).unwrap_or_else(|| {\n             panic!(\"could not find block at location {:?}\", location);\n         });\n         let stmt = block.statements.get(location.statement_index).unwrap_or_else(|| {\n             panic!(\"could not find statement at location {:?}\");\n         });\n \n-        // Do kills introduced by NLL before setting up any potential\n-        // gens. (See NOTE in kill_loans_out_of_scope_at_location.)\n-        self.kill_loans_out_of_scope_at_location(sets, location, is_activations);\n-\n-        if is_activations {\n-            // INVARIANT: `sets.on_entry` accurately captures\n-            // reservations on entry to statement (b/c\n-            // accumulates_intrablock_state is overridden for\n-            // ActiveBorrows).\n-            //\n-            // Now compute the activations generated by uses within\n-            // the statement based on that reservation state.\n-            let mut find = FindPlaceUses { sets, assigned_map: &self.assigned_map };\n-            find.visit_statement(location.block, stmt, location);\n+        // Handle activations\n+        match self.activation_map.get(&location) {\n+            Some(&activated) => {\n+                sets.gen(&ReserveOrActivateIndex::active(activated))\n+            }\n+            None => {}\n         }\n \n         match stmt.kind {\n@@ -357,9 +620,7 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                     assert!(self.nonlexical_regioncx.is_none());\n                     for idx in borrow_indexes {\n                         sets.kill(&ReserveOrActivateIndex::reserved(*idx));\n-                        if is_activations {\n-                            sets.kill(&ReserveOrActivateIndex::active(*idx));\n-                        }\n+                        sets.kill(&ReserveOrActivateIndex::active(*idx));\n                     }\n                 } else {\n                     // (if there is no entry, then there are no borrows to be tracked)\n@@ -372,7 +633,7 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                 if let Place::Local(ref local) = *lhs {\n                     // FIXME: Handle the case in which we're assigning over\n                     // a projection (`foo.bar`).\n-                    self.kill_borrows_on_local(sets, local, is_activations);\n+                    self.kill_borrows_on_local(sets, local);\n                 }\n \n                 // NOTE: if/when the Assign case is revised to inspect\n@@ -396,18 +657,17 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                     }).contains(&index));\n                     sets.gen(&ReserveOrActivateIndex::reserved(*index));\n \n-                    if is_activations {\n-                        // Issue #46746: Two-phase borrows handles\n-                        // stmts of form `Tmp = &mut Borrow` ...\n-                        match lhs {\n-                            Place::Local(..) | Place::Static(..) => {} // okay\n-                            Place::Projection(..) => {\n-                                // ... can assign into projections,\n-                                // e.g. `box (&mut _)`. Current\n-                                // conservative solution: force\n-                                // immediate activation here.\n-                                sets.gen(&ReserveOrActivateIndex::active(*index));\n-                            }\n+                    // Issue #46746: Two-phase borrows handles\n+                    // stmts of form `Tmp = &mut Borrow` ...\n+                    // XXX bob_twinkles experiment with removing this\n+                    match lhs {\n+                        Place::Local(..) | Place::Static(..) => {} // okay\n+                        Place::Projection(..) => {\n+                            // ... can assign into projections,\n+                            // e.g. `box (&mut _)`. Current\n+                            // conservative solution: force\n+                            // immediate activation here.\n+                            sets.gen(&ReserveOrActivateIndex::active(*index));\n                         }\n                     }\n                 }\n@@ -416,7 +676,7 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n             mir::StatementKind::StorageDead(local) => {\n                 // Make sure there are no remaining borrows for locals that\n                 // are gone out of scope.\n-                self.kill_borrows_on_local(sets, &local, is_activations)\n+                self.kill_borrows_on_local(sets, &local)\n             }\n \n             mir::StatementKind::InlineAsm { ref outputs, ref asm, .. } => {\n@@ -427,7 +687,7 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                         if let Place::Local(ref local) = *output {\n                             // FIXME: Handle the case in which we're assigning over\n                             // a projection (`foo.bar`).\n-                            self.kill_borrows_on_local(sets, local, is_activations);\n+                            self.kill_borrows_on_local(sets, local);\n                         }\n                     }\n                 }\n@@ -441,47 +701,26 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn kill_borrows_on_local(&self,\n-                             sets: &mut BlockSets<ReserveOrActivateIndex>,\n-                             local: &rustc::mir::Local,\n-                             is_activations: bool)\n-    {\n-        if let Some(borrow_indexes) = self.local_map.get(local) {\n-            sets.kill_all(borrow_indexes.iter()\n-                            .map(|b| ReserveOrActivateIndex::reserved(*b)));\n-            if is_activations {\n-                sets.kill_all(borrow_indexes.iter()\n-                                .map(|b| ReserveOrActivateIndex::active(*b)));\n-            }\n-        }\n+    fn before_terminator_effect(&self, sets: &mut BlockSets<ReserveOrActivateIndex>, location: Location) {\n+        debug!(\"Borrows::before_terminator_effect sets: {:?} location: {:?}\", sets, location);\n+        self.kill_loans_out_of_scope_at_location(sets, location);\n     }\n \n-    /// Models terminator effect in Reservations and ActiveBorrows\n-    /// flow analyses; `is activations` tells us if we are in the\n-    /// latter case.\n-    fn terminator_effect_on_borrows(&self,\n-                                    sets: &mut BlockSets<ReserveOrActivateIndex>,\n-                                    location: Location,\n-                                    is_activations: bool) {\n+    fn terminator_effect(&self, sets: &mut BlockSets<ReserveOrActivateIndex>, location: Location) {\n+        debug!(\"Borrows::terminator_effect sets: {:?} location: {:?}\", sets, location);\n+\n         let block = &self.mir.basic_blocks().get(location.block).unwrap_or_else(|| {\n             panic!(\"could not find block at location {:?}\", location);\n         });\n \n-        // Do kills introduced by NLL before setting up any potential\n-        // gens. (See NOTE in kill_loans_out_of_scope_at_location.)\n-        self.kill_loans_out_of_scope_at_location(sets, location, is_activations);\n-\n         let term = block.terminator();\n-        if is_activations {\n-            // INVARIANT: `sets.on_entry` accurately captures\n-            // reservations on entry to terminator (b/c\n-            // accumulates_intrablock_state is overridden for\n-            // ActiveBorrows).\n-            //\n-            // Now compute effect of the terminator on the activations\n-            // themselves in the ActiveBorrows state.\n-            let mut find = FindPlaceUses { sets, assigned_map: &self.assigned_map };\n-            find.visit_terminator(location.block, term, location);\n+\n+        // Handle activations\n+        match self.activation_map.get(&location) {\n+            Some(&activated) => {\n+                sets.gen(&ReserveOrActivateIndex::active(activated))\n+            }\n+            None => {}\n         }\n \n         match term.kind {\n@@ -504,9 +743,7 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                                 self.scope_tree.is_subscope_of(*scope, root_scope)\n                             {\n                                 sets.kill(&ReserveOrActivateIndex::reserved(borrow_index));\n-                                if is_activations {\n-                                    sets.kill(&ReserveOrActivateIndex::active(borrow_index));\n-                                }\n+                                sets.kill(&ReserveOrActivateIndex::active(borrow_index));\n                             }\n                         }\n                     }\n@@ -525,161 +762,6 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n             mir::TerminatorKind::Unreachable => {}\n         }\n     }\n-}\n-\n-impl<'a, 'gcx, 'tcx> ActiveBorrows<'a, 'gcx, 'tcx> {\n-    pub(crate) fn borrows(&self) -> &IndexVec<BorrowIndex, BorrowData<'tcx>> {\n-        self.0.borrows()\n-    }\n-\n-    /// Returns the span for the \"end point\" given region. This will\n-    /// return `None` if NLL is enabled, since that concept has no\n-    /// meaning there.  Otherwise, return region span if it exists and\n-    /// span for end of the function if it doesn't exist.\n-    pub(crate) fn opt_region_end_span(&self, region: &Region) -> Option<Span> {\n-        match self.0.nonlexical_regioncx {\n-            Some(_) => None,\n-            None => {\n-                match self.0.region_span_map.get(region) {\n-                    Some(span) => Some(self.0.tcx.sess.codemap().end_point(*span)),\n-                    None => Some(self.0.tcx.sess.codemap().end_point(self.0.mir.span))\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-/// `FindPlaceUses` is a MIR visitor that updates `self.sets` for all\n-/// of the borrows activated by a given statement or terminator.\n-///\n-/// ----\n-///\n-/// The `ActiveBorrows` flow analysis, when inspecting any given\n-/// statement or terminator, needs to \"generate\" (i.e. set to 1) all\n-/// of the bits for the borrows that are activated by that\n-/// statement/terminator.\n-///\n-/// This struct will seek out all places that are assignment-targets\n-/// for borrows (gathered in `self.assigned_map`; see also the\n-/// `assigned_map` in `struct Borrows`), and set the corresponding\n-/// gen-bits for activations of those borrows in `self.sets`\n-struct FindPlaceUses<'a, 'b: 'a, 'tcx: 'a> {\n-    assigned_map: &'a FxHashMap<Place<'tcx>, FxHashSet<BorrowIndex>>,\n-    sets: &'a mut BlockSets<'b, ReserveOrActivateIndex>,\n-}\n-\n-impl<'a, 'b, 'tcx> FindPlaceUses<'a, 'b, 'tcx> {\n-    fn has_been_reserved(&self, b: &BorrowIndex) -> bool {\n-        self.sets.on_entry.contains(&ReserveOrActivateIndex::reserved(*b))\n-    }\n-\n-    /// return whether `context` should be considered a \"use\" of a\n-    /// place found in that context. \"Uses\" activate associated\n-    /// borrows (at least when such uses occur while the borrow also\n-    /// has a reservation at the time).\n-    fn is_potential_use(context: PlaceContext) -> bool {\n-        match context {\n-            // storage effects on a place do not activate it\n-            PlaceContext::StorageLive | PlaceContext::StorageDead => false,\n-\n-            // validation effects do not activate a place\n-            //\n-            // FIXME: Should they? Is it just another read? Or can we\n-            // guarantee it won't dereference the stored address? How\n-            // \"deep\" does validation go?\n-            PlaceContext::Validate => false,\n-\n-            // FIXME: This is here to not change behaviour from before\n-            // AsmOutput existed, but it's not necessarily a pure overwrite.\n-            // so it's possible this should activate the place.\n-            PlaceContext::AsmOutput |\n-            // pure overwrites of a place do not activate it. (note\n-            // PlaceContext::Call is solely about dest place)\n-            PlaceContext::Store | PlaceContext::Call => false,\n-\n-            // reads of a place *do* activate it\n-            PlaceContext::Move |\n-            PlaceContext::Copy |\n-            PlaceContext::Drop |\n-            PlaceContext::Inspect |\n-            PlaceContext::Borrow { .. } |\n-            PlaceContext::Projection(..) => true,\n-        }\n-    }\n-}\n-\n-impl<'a, 'b, 'tcx> Visitor<'tcx> for FindPlaceUses<'a, 'b, 'tcx> {\n-    fn visit_place(&mut self,\n-                    place: &mir::Place<'tcx>,\n-                    context: PlaceContext<'tcx>,\n-                    location: Location) {\n-        debug!(\"FindPlaceUses place: {:?} assigned from borrows: {:?} \\\n-                used in context: {:?} at location: {:?}\",\n-               place, self.assigned_map.get(place), context, location);\n-        if Self::is_potential_use(context) {\n-            if let Some(borrows) = self.assigned_map.get(place) {\n-                for borrow_idx in borrows {\n-                    debug!(\"checking if index {:?} for {:?} is reserved ({}) \\\n-                            and thus needs active gen-bit set in sets {:?}\",\n-                           borrow_idx, place, self.has_been_reserved(&borrow_idx), self.sets);\n-                    if self.has_been_reserved(&borrow_idx) {\n-                        self.sets.gen(&ReserveOrActivateIndex::active(*borrow_idx));\n-                    } else {\n-                        // (This can certainly happen in valid code. I\n-                        // just want to know about it in the short\n-                        // term.)\n-                        debug!(\"encountered use of Place {:?} of borrow_idx {:?} \\\n-                                at location {:?} outside of reservation\",\n-                               place, borrow_idx, location);\n-                    }\n-                }\n-            }\n-        }\n-\n-        self.super_place(place, context, location);\n-    }\n-}\n-\n-\n-impl<'a, 'gcx, 'tcx> BitDenotation for Reservations<'a, 'gcx, 'tcx> {\n-    type Idx = ReserveOrActivateIndex;\n-    fn name() -> &'static str { \"reservations\" }\n-    fn bits_per_block(&self) -> usize {\n-        self.0.borrows.len() * 2\n-    }\n-    fn start_block_effect(&self, _entry_set: &mut IdxSet<ReserveOrActivateIndex>)  {\n-        // no borrows of code region_scopes have been taken prior to\n-        // function execution, so this method has no effect on\n-        // `_sets`.\n-    }\n-\n-    fn before_statement_effect(&self,\n-                               sets: &mut BlockSets<ReserveOrActivateIndex>,\n-                               location: Location) {\n-        debug!(\"Reservations::before_statement_effect sets: {:?} location: {:?}\", sets, location);\n-        self.0.kill_loans_out_of_scope_at_location(sets, location, false);\n-    }\n-\n-    fn statement_effect(&self,\n-                        sets: &mut BlockSets<ReserveOrActivateIndex>,\n-                        location: Location) {\n-        debug!(\"Reservations::statement_effect sets: {:?} location: {:?}\", sets, location);\n-        self.0.statement_effect_on_borrows(sets, location, false);\n-    }\n-\n-    fn before_terminator_effect(&self,\n-                                sets: &mut BlockSets<ReserveOrActivateIndex>,\n-                                location: Location) {\n-        debug!(\"Reservations::before_terminator_effect sets: {:?} location: {:?}\", sets, location);\n-        self.0.kill_loans_out_of_scope_at_location(sets, location, false);\n-    }\n-\n-    fn terminator_effect(&self,\n-                         sets: &mut BlockSets<ReserveOrActivateIndex>,\n-                         location: Location) {\n-        debug!(\"Reservations::terminator_effect sets: {:?} location: {:?}\", sets, location);\n-        self.0.terminator_effect_on_borrows(sets, location, false);\n-    }\n \n     fn propagate_call_return(&self,\n                              _in_out: &mut IdxSet<ReserveOrActivateIndex>,\n@@ -694,85 +776,17 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Reservations<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitDenotation for ActiveBorrows<'a, 'gcx, 'tcx> {\n-    type Idx = ReserveOrActivateIndex;\n-    fn name() -> &'static str { \"active_borrows\" }\n-\n-    /// Overriding this method; `ActiveBorrows` uses the intrablock\n-    /// state in `on_entry` to track the current reservations (which\n-    /// then affect the construction of the gen/kill sets for\n-    /// activations).\n-    fn accumulates_intrablock_state() -> bool { true }\n-\n-    fn bits_per_block(&self) -> usize {\n-        self.0.borrows.len() * 2\n-    }\n-\n-    fn start_block_effect(&self, _entry_sets: &mut IdxSet<ReserveOrActivateIndex>)  {\n-        // no borrows of code region_scopes have been taken prior to\n-        // function execution, so this method has no effect on\n-        // `_sets`.\n-    }\n-\n-    fn before_statement_effect(&self,\n-                               sets: &mut BlockSets<ReserveOrActivateIndex>,\n-                               location: Location) {\n-        debug!(\"ActiveBorrows::before_statement_effect sets: {:?} location: {:?}\", sets, location);\n-        self.0.kill_loans_out_of_scope_at_location(sets, location, true);\n-    }\n-\n-    fn statement_effect(&self,\n-                        sets: &mut BlockSets<ReserveOrActivateIndex>,\n-                        location: Location) {\n-        debug!(\"ActiveBorrows::statement_effect sets: {:?} location: {:?}\", sets, location);\n-        self.0.statement_effect_on_borrows(sets, location, true);\n-    }\n-\n-    fn before_terminator_effect(&self,\n-                                sets: &mut BlockSets<ReserveOrActivateIndex>,\n-                                location: Location) {\n-        debug!(\"ActiveBorrows::before_terminator_effect sets: {:?} location: {:?}\", sets, location);\n-        self.0.kill_loans_out_of_scope_at_location(sets, location, true);\n-    }\n-\n-    fn terminator_effect(&self,\n-                         sets: &mut BlockSets<ReserveOrActivateIndex>,\n-                         location: Location) {\n-        debug!(\"ActiveBorrows::terminator_effect sets: {:?} location: {:?}\", sets, location);\n-        self.0.terminator_effect_on_borrows(sets, location, true);\n-    }\n-\n-    fn propagate_call_return(&self,\n-                             _in_out: &mut IdxSet<ReserveOrActivateIndex>,\n-                             _call_bb: mir::BasicBlock,\n-                             _dest_bb: mir::BasicBlock,\n-                             _dest_place: &mir::Place) {\n-        // there are no effects on borrows from method call return...\n-        //\n-        // ... but If overwriting a place can affect flow state, then\n-        // latter is not true; see NOTE on Assign case in\n-        // statement_effect_on_borrows.\n-    }\n-}\n-\n-impl<'a, 'gcx, 'tcx> BitwiseOperator for Reservations<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitwiseOperator for Borrows<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn join(&self, pred1: usize, pred2: usize) -> usize {\n         pred1 | pred2 // union effects of preds when computing reservations\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitwiseOperator for ActiveBorrows<'a, 'gcx, 'tcx> {\n-    #[inline]\n-    fn join(&self, pred1: usize, pred2: usize) -> usize {\n-        pred1 | pred2 // union effects of preds when computing activations\n-    }\n-}\n-\n-impl<'a, 'gcx, 'tcx> InitialFlow for Reservations<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> InitialFlow for Borrows<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn bottom_value() -> bool {\n-        false // bottom = no Rvalue::Refs are reserved by default\n+        false // bottom = nothing is reserved or activated yet\n     }\n }\n "}, {"sha": "f7675d611cc5c08de8e7f0688e1e401749e080cc", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/138365368a71a04ff9539704f478b014379b7ee5/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/138365368a71a04ff9539704f478b014379b7ee5/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=138365368a71a04ff9539704f478b014379b7ee5", "patch": "@@ -18,7 +18,7 @@ use rustc::ty::{self, TyCtxt};\n use rustc::mir::{self, Mir, BasicBlock, BasicBlockData, Location, Statement, Terminator};\n use rustc::session::Session;\n \n-use std::borrow::{Borrow, Cow};\n+use std::borrow::Borrow;\n use std::fmt;\n use std::io;\n use std::mem;\n@@ -31,7 +31,7 @@ pub use self::impls::{DefinitelyInitializedPlaces, MovingOutStatements};\n pub use self::impls::EverInitializedPlaces;\n pub use self::impls::borrows::{Borrows, BorrowData};\n pub use self::impls::HaveBeenBorrowedLocals;\n-pub(crate) use self::impls::borrows::{ActiveBorrows, Reservations, ReserveOrActivateIndex};\n+pub(crate) use self::impls::borrows::{ReserveOrActivateIndex};\n pub use self::at_location::{FlowAtLocation, FlowsAtLocation};\n pub(crate) use self::drop_flag_effects::*;\n \n@@ -584,9 +584,6 @@ impl<E:Idx> AllSets<E> {\n     pub fn on_entry_set_for(&self, block_idx: usize) -> &IdxSet<E> {\n         self.lookup_set_for(&self.on_entry_sets, block_idx)\n     }\n-    pub(crate) fn entry_set_state(&self) -> &Bits<E> {\n-        &self.on_entry_sets\n-    }\n }\n \n /// Parameterization for the precise form of data flow that is used.\n@@ -739,27 +736,17 @@ impl<'a, 'tcx, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n                dead_unwinds: &'a IdxSet<mir::BasicBlock>,\n                denotation: D) -> Self where D: InitialFlow {\n         let bits_per_block = denotation.bits_per_block();\n+        let usize_bits = mem::size_of::<usize>() * 8;\n+        let words_per_block = (bits_per_block + usize_bits - 1) / usize_bits;\n         let num_overall = Self::num_bits_overall(mir, bits_per_block);\n+\n+        let zeroes = Bits::new(IdxSetBuf::new_empty(num_overall));\n         let on_entry = Bits::new(if D::bottom_value() {\n             IdxSetBuf::new_filled(num_overall)\n         } else {\n             IdxSetBuf::new_empty(num_overall)\n         });\n \n-        Self::new_with_entry_sets(mir, dead_unwinds, Cow::Owned(on_entry), denotation)\n-    }\n-\n-    pub(crate) fn new_with_entry_sets(mir: &'a Mir<'tcx>,\n-                                      dead_unwinds: &'a IdxSet<mir::BasicBlock>,\n-                                      on_entry: Cow<Bits<D::Idx>>,\n-                                      denotation: D)\n-                                      -> Self {\n-        let bits_per_block = denotation.bits_per_block();\n-        let usize_bits = mem::size_of::<usize>() * 8;\n-        let words_per_block = (bits_per_block + usize_bits - 1) / usize_bits;\n-        let num_overall = Self::num_bits_overall(mir, bits_per_block);\n-        assert_eq!(num_overall, on_entry.bits.words().len() * usize_bits);\n-        let zeroes = Bits::new(IdxSetBuf::new_empty(num_overall));\n         DataflowAnalysis {\n             mir,\n             dead_unwinds,\n@@ -769,13 +756,27 @@ impl<'a, 'tcx, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n                     words_per_block,\n                     gen_sets: zeroes.clone(),\n                     kill_sets: zeroes,\n-                    on_entry_sets: on_entry.into_owned(),\n+                    on_entry_sets: on_entry,\n                 },\n                 operator: denotation,\n             }\n         }\n     }\n \n+    pub fn new_from_sets(mir: &'a Mir<'tcx>,\n+                         dead_unwinds: &'a IdxSet<mir::BasicBlock>,\n+                         sets: AllSets<D::Idx>,\n+                         denotation: D) -> Self {\n+        DataflowAnalysis {\n+            mir,\n+            dead_unwinds,\n+            flow_state: DataflowState {\n+                sets: sets,\n+                operator: denotation,\n+            }\n+        }\n+    }\n+\n     fn num_bits_overall(mir: &Mir, bits_per_block: usize) -> usize {\n         let usize_bits = mem::size_of::<usize>() * 8;\n         let words_per_block = (bits_per_block + usize_bits - 1) / usize_bits;"}, {"sha": "1d3d61fb3fbf8bc73dc0d85ed55fc5f6bfab53bf", "filename": "src/test/compile-fail/borrowck/two-phase-activation-sharing-interference.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/138365368a71a04ff9539704f478b014379b7ee5/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-activation-sharing-interference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/138365368a71a04ff9539704f478b014379b7ee5/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-activation-sharing-interference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-activation-sharing-interference.rs?ref=138365368a71a04ff9539704f478b014379b7ee5", "patch": "@@ -10,10 +10,12 @@\n \n // ignore-tidy-linelength\n \n-// revisions: lxl_beyond nll_beyond nll_target\n+// revisions: nll_target\n \n+// The following revisions are disabled due to missing support from two-phase beyond autorefs\n //[lxl_beyond] compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z two-phase-beyond-autoref\n //[nll_beyond] compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z two-phase-beyond-autoref -Z nll\n+\n //[nll_target] compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n \n // This is an important corner case pointed out by Niko: one is"}, {"sha": "d2f4154433ab152b4c9a8eac7657d97233162788", "filename": "src/test/compile-fail/borrowck/two-phase-allow-access-during-reservation.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/138365368a71a04ff9539704f478b014379b7ee5/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-allow-access-during-reservation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/138365368a71a04ff9539704f478b014379b7ee5/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-allow-access-during-reservation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-allow-access-during-reservation.rs?ref=138365368a71a04ff9539704f478b014379b7ee5", "patch": "@@ -10,9 +10,13 @@\n \n // ignore-tidy-linelength\n \n-// revisions: lxl_beyond nll_beyond nll_target\n+// revisions: nll_target\n+\n+// The following revisions are disabled due to missing support for two_phase_beyond_autoref\n //[lxl_beyond] compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z two_phase_beyond_autoref\n //[nll_beyond] compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z two_phase_beyond_autoref -Z nll\n+\n+\n //[nll_target] compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n \n // This is the second counter-example from Niko's blog post"}, {"sha": "bf8e02adb1ae6580ae5d9cdaf93fbf9ea4f7bded", "filename": "src/test/compile-fail/borrowck/two-phase-nonrecv-autoref.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/138365368a71a04ff9539704f478b014379b7ee5/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-nonrecv-autoref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/138365368a71a04ff9539704f478b014379b7ee5/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-nonrecv-autoref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-nonrecv-autoref.rs?ref=138365368a71a04ff9539704f478b014379b7ee5", "patch": "@@ -8,10 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// revisions: lxl nll g2p\n+// revisions: lxl nll\n //[lxl]compile-flags: -Z borrowck=mir -Z two-phase-borrows\n //[nll]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n+\n //[g2p]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll -Z two-phase-beyond-autoref\n+// the above revision is disabled until two-phase-beyond-autoref support is better\n \n // This is a test checking that when we limit two-phase borrows to\n // method receivers, we do not let other kinds of auto-ref to leak\n@@ -70,10 +72,8 @@ fn overloaded_call_traits() {\n     fn twice_ten_sm<F: FnMut(i32) -> i32>(f: &mut F) {\n         f(f(10));\n         //[lxl]~^     ERROR cannot borrow `*f` as mutable more than once at a time\n-        //[lxl]~|     ERROR cannot borrow `*f` as mutable more than once at a time\n-        //[nll]~^^^   ERROR cannot borrow `*f` as mutable more than once at a time\n-        //[nll]~|     ERROR cannot borrow `*f` as mutable more than once at a time\n-        //[g2p]~^^^^^ ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[nll]~^^   ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[g2p]~^^^ ERROR cannot borrow `*f` as mutable more than once at a time\n     }\n     fn twice_ten_si<F: Fn(i32) -> i32>(f: &mut F) {\n         f(f(10));\n@@ -88,10 +88,8 @@ fn overloaded_call_traits() {\n     fn twice_ten_om(f: &mut FnMut(i32) -> i32) {\n         f(f(10));\n         //[lxl]~^     ERROR cannot borrow `*f` as mutable more than once at a time\n-        //[lxl]~|     ERROR cannot borrow `*f` as mutable more than once at a time\n-        //[nll]~^^^   ERROR cannot borrow `*f` as mutable more than once at a time\n-        //[nll]~|     ERROR cannot borrow `*f` as mutable more than once at a time\n-        //[g2p]~^^^^^ ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[nll]~^^   ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[g2p]~^^^ ERROR cannot borrow `*f` as mutable more than once at a time\n     }\n     fn twice_ten_oi(f: &mut Fn(i32) -> i32) {\n         f(f(10));"}, {"sha": "058022ad588e85beb9ceae07b977a9e0bfbf0146", "filename": "src/test/compile-fail/borrowck/two-phase-reservation-sharing-interference.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/138365368a71a04ff9539704f478b014379b7ee5/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-reservation-sharing-interference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/138365368a71a04ff9539704f478b014379b7ee5/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-reservation-sharing-interference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-reservation-sharing-interference.rs?ref=138365368a71a04ff9539704f478b014379b7ee5", "patch": "@@ -12,8 +12,12 @@\n \n // revisions: lxl_beyond nll_beyond nll_target\n \n+// The following revisions are disabled due to missing support from two-phase beyond autorefs\n //[lxl_beyond]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z two-phase-beyond-autoref\n+//[lxl_beyond] should-fail\n //[nll_beyond]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z two-phase-beyond-autoref -Z nll\n+//[nll_beyond] should-fail\n+\n //[nll_target]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n \n // This is a corner case that the current implementation is (probably)\n@@ -31,10 +35,6 @@\n // \"nll_beyond\" means the generalization of two-phase borrows to all\n // `&mut`-borrows (doing so makes it easier to write code for specific\n // corner cases).\n-//\n-// FIXME: in \"nll_target\", we currently see the same error reported\n-// twice. This is injected by `-Z two-phase-borrows`; not sure why as\n-// of yet.\n \n fn main() {\n     let mut vec = vec![0, 1];\n@@ -49,7 +49,6 @@ fn main() {\n         //[lxl_beyond]~^   ERROR cannot borrow `vec` as mutable because it is also borrowed as immutable\n         //[nll_beyond]~^^  ERROR cannot borrow `vec` as mutable because it is also borrowed as immutable\n         //[nll_target]~^^^ ERROR cannot borrow `vec` as mutable because it is also borrowed as immutable\n-        //[nll_target]~|   ERROR cannot borrow `vec` as mutable because it is also borrowed as immutable\n \n         shared[0];\n     }"}]}