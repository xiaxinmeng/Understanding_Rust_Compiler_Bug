{"sha": "ea43eb3721e9a6567ff402db442fc5c1ad942009", "node_id": "C_kwDOAAsO6NoAKGVhNDNlYjM3MjFlOWE2NTY3ZmY0MDJkYjQ0MmZjNWMxYWQ5NDIwMDk", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2023-01-03T00:23:08Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2023-01-05T16:51:16Z"}, "message": "Point at expressions where inference refines an unexpected type\n\nAddress #106355.", "tree": {"sha": "9e8e66f5292910507af667a0eb4b560cf903e88d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e8e66f5292910507af667a0eb4b560cf903e88d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea43eb3721e9a6567ff402db442fc5c1ad942009", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea43eb3721e9a6567ff402db442fc5c1ad942009", "html_url": "https://github.com/rust-lang/rust/commit/ea43eb3721e9a6567ff402db442fc5c1ad942009", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea43eb3721e9a6567ff402db442fc5c1ad942009/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d284af117716473e1a35cc0d91c170e44e3fc6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d284af117716473e1a35cc0d91c170e44e3fc6e", "html_url": "https://github.com/rust-lang/rust/commit/1d284af117716473e1a35cc0d91c170e44e3fc6e"}], "stats": {"total": 316, "additions": 299, "deletions": 17}, "files": [{"sha": "c9ee5c6cac8bd668f890447b24c0ebb86a866bb0", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 159, "deletions": 3, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/ea43eb3721e9a6567ff402db442fc5c1ad942009/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43eb3721e9a6567ff402db442fc5c1ad942009/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=ea43eb3721e9a6567ff402db442fc5c1ad942009", "patch": "@@ -4,15 +4,19 @@ use rustc_errors::MultiSpan;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::def::CtorKind;\n+use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{is_range_literal, Node};\n use rustc_infer::infer::InferOk;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::middle::stability::EvalResult;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n-use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_middle::ty::{self, Article, AssocItem, Ty, TypeAndMut};\n+use rustc_middle::ty::fold::TypeFolder;\n+use rustc_middle::ty::print::{with_forced_trimmed_paths, with_no_trimmed_paths};\n+use rustc_middle::ty::{\n+    self, Article, AssocItem, Ty, TyCtxt, TypeAndMut, TypeSuperFoldable, TypeVisitable,\n+};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{BytePos, Span};\n use rustc_trait_selection::infer::InferCtxtExt as _;\n@@ -53,7 +57,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             || self.suggest_block_to_brackets_peeling_refs(err, expr, expr_ty, expected)\n             || self.suggest_copied_or_cloned(err, expr, expr_ty, expected)\n             || self.suggest_into(err, expr, expr_ty, expected)\n-            || self.suggest_floating_point_literal(err, expr, expected);\n+            || self.suggest_floating_point_literal(err, expr, expected)\n+            || self.point_inference_types(err, expr);\n     }\n \n     pub fn emit_coerce_suggestions(\n@@ -205,6 +210,157 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         (expected, Some(err))\n     }\n \n+    fn point_inference_types(&self, err: &mut Diagnostic, expr: &hir::Expr<'_>) -> bool {\n+        let tcx = self.tcx;\n+        let map = self.tcx.hir();\n+\n+        // Hack to make equality checks on types with inference variables and regions useful.\n+        struct TypeEraser<'tcx> {\n+            tcx: TyCtxt<'tcx>,\n+        }\n+        impl<'tcx> TypeFolder<'tcx> for TypeEraser<'tcx> {\n+            fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n+                self.tcx\n+            }\n+            fn fold_region(&mut self, _r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+                self.tcx().lifetimes.re_erased\n+            }\n+            fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+                if !t.needs_infer() && !t.has_erasable_regions() {\n+                    return t;\n+                }\n+                match *t.kind() {\n+                    ty::Infer(ty::TyVar(_) | ty::FreshTy(_)) => {\n+                        self.tcx.mk_ty_infer(ty::TyVar(ty::TyVid::from_u32(0)))\n+                    }\n+                    ty::Infer(ty::IntVar(_) | ty::FreshIntTy(_)) => {\n+                        self.tcx.mk_ty_infer(ty::IntVar(ty::IntVid { index: 0 }))\n+                    }\n+                    ty::Infer(ty::FloatVar(_) | ty::FreshFloatTy(_)) => {\n+                        self.tcx.mk_ty_infer(ty::FloatVar(ty::FloatVid { index: 0 }))\n+                    }\n+                    _ => t.super_fold_with(self),\n+                }\n+            }\n+            fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n+                ct.super_fold_with(self)\n+            }\n+        }\n+\n+        let hir::ExprKind::Path(hir::QPath::Resolved(None, p)) = expr.kind else { return false; };\n+        let [hir::PathSegment { ident, args: None, .. }] = p.segments else { return false; };\n+        let hir::def::Res::Local(hir_id) = p.res else { return false; };\n+        let Some(node) = map.find(hir_id) else { return false; };\n+        let hir::Node::Pat(pat) = node else { return false; };\n+        let parent = map.get_parent_node(pat.hir_id);\n+        let Some(hir::Node::Local(hir::Local {\n+            ty: None,\n+            init: Some(init),\n+            ..\n+        })) = map.find(parent) else { return false; };\n+\n+        let ty = self.node_ty(init.hir_id);\n+        if ty.is_closure() || init.span.overlaps(expr.span) {\n+            return false;\n+        }\n+        let mut span_labels = vec![(\n+            init.span,\n+            with_forced_trimmed_paths!(format!(\n+                \"here the type of `{ident}` is inferred to be `{ty}`\",\n+            )),\n+        )];\n+\n+        // Locate all the usages of the relevant binding.\n+        struct FindExprs<'hir> {\n+            hir_id: hir::HirId,\n+            uses: Vec<&'hir hir::Expr<'hir>>,\n+        }\n+        impl<'v> Visitor<'v> for FindExprs<'v> {\n+            fn visit_expr(&mut self, ex: &'v hir::Expr<'v>) {\n+                if let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = ex.kind\n+                    && let hir::def::Res::Local(hir_id) = path.res\n+                    && hir_id == self.hir_id\n+                {\n+                    self.uses.push(ex);\n+                }\n+                hir::intravisit::walk_expr(self, ex);\n+            }\n+        }\n+\n+        let mut expr_finder = FindExprs { hir_id, uses: vec![] };\n+        let id = map.get_parent_item(hir_id);\n+        let hir_id: hir::HirId = id.into();\n+\n+        if let Some(node) = map.find(hir_id) && let Some(body_id) = node.body_id() {\n+            let body = map.body(body_id);\n+            expr_finder.visit_expr(body.value);\n+            let mut eraser = TypeEraser { tcx };\n+            let mut prev = eraser.fold_ty(ty);\n+\n+            for ex in expr_finder.uses {\n+                if ex.span.overlaps(expr.span) { break; }\n+                let parent = map.get_parent_node(ex.hir_id);\n+                if let Some(hir::Node::Expr(expr))\n+                | Some(hir::Node::Stmt(hir::Stmt {\n+                    kind: hir::StmtKind::Expr(expr) | hir::StmtKind::Semi(expr),\n+                    ..\n+                })) = &map.find(parent)\n+                    && let hir::ExprKind::MethodCall(s, rcvr, args, span) = expr.kind\n+                    && rcvr.hir_id == ex.hir_id\n+                {\n+                    let ty = if let Ok(m) = self.lookup_method(ty, s, span, expr, rcvr, args) {\n+                        // We get the self type from `lookup_method` because the `rcvr` node\n+                        // type will not have had any adjustments from the fn arguments.\n+                        let ty = m.sig.inputs_and_output[0];\n+                        match ty.kind() {\n+                            // Remove one layer of references to account for `&mut self` and\n+                            // `&self`, so that we can compare it against the binding.\n+                            ty::Ref(_, ty, _) => *ty,\n+                            _ => ty,\n+                        }\n+                    } else {\n+                        self.node_ty(rcvr.hir_id)\n+                    };\n+                    let ty = eraser.fold_ty(ty);\n+                    if ty.references_error() {\n+                        break;\n+                    }\n+                    if ty != prev {\n+                        span_labels.push((\n+                            s.ident.span,\n+                            with_forced_trimmed_paths!(format!(\n+                                \"here the type of `{ident}` is inferred to be `{ty}`\",\n+                            )),\n+                        ));\n+                        prev = ty;\n+                    }\n+                } else {\n+                    let ty = eraser.fold_ty(self.node_ty(ex.hir_id));\n+                    if ty.references_error() {\n+                        break;\n+                    }\n+                    if ty != prev {\n+                        span_labels.push((\n+                            ex.span,\n+                            with_forced_trimmed_paths!(format!(\n+                                \"here the type of `{ident}` is inferred to be `{ty}`\",\n+                            )),\n+                        ));\n+                    }\n+                    prev = ty;\n+                }\n+                if ex.hir_id == expr.hir_id {\n+                    // Stop showing spans after the error type was emitted.\n+                    break;\n+                }\n+            }\n+        }\n+        for (sp, label) in span_labels {\n+            err.span_label(sp, &label);\n+        }\n+        true\n+    }\n+\n     fn annotate_expected_due_to_let_ty(\n         &self,\n         err: &mut Diagnostic,"}, {"sha": "3ccd399863d556e2692a3b24497c5cb0196ca77b", "filename": "src/test/ui/argument-suggestions/two-mismatch-notes.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Fargument-suggestions%2Ftwo-mismatch-notes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Fargument-suggestions%2Ftwo-mismatch-notes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fargument-suggestions%2Ftwo-mismatch-notes.stderr?ref=ea43eb3721e9a6567ff402db442fc5c1ad942009", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: arguments to this function are incorrect\n   --> $DIR/two-mismatch-notes.rs:10:5\n    |\n+LL |     let w = Wrapper::<isize>(1isize);\n+   |             ------------------------ here the type of `w` is inferred to be `Wrapper<isize>`\n LL |     foo(f, w);\n    |     ^^^\n    |"}, {"sha": "6e232dd006426fcd72381080a7feb9a4025b383e", "filename": "src/test/ui/async-await/dont-suggest-missing-await.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-missing-await.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-missing-await.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-missing-await.stderr?ref=ea43eb3721e9a6567ff402db442fc5c1ad942009", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/dont-suggest-missing-await.rs:14:18\n    |\n+LL |         let x = make_u32();\n+   |                 ---------- here the type of `x` is inferred to be `impl Future<Output = u32>`\n LL |         take_u32(x)\n    |         -------- ^ expected `u32`, found opaque type\n    |         |"}, {"sha": "9f51832365b615d7170fe451da928c66e5960d89", "filename": "src/test/ui/async-await/suggest-missing-await-closure.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await-closure.stderr?ref=ea43eb3721e9a6567ff402db442fc5c1ad942009", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/suggest-missing-await-closure.rs:16:18\n    |\n+LL |         let x = make_u32();\n+   |                 ---------- here the type of `x` is inferred to be `impl Future<Output = u32>`\n LL |         take_u32(x)\n    |         -------- ^ expected `u32`, found opaque type\n    |         |"}, {"sha": "ce4c8edaf74d6d2d1e1633efdfa5c003f0f0ce2b", "filename": "src/test/ui/async-await/suggest-missing-await.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr?ref=ea43eb3721e9a6567ff402db442fc5c1ad942009", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/suggest-missing-await.rs:12:14\n    |\n+LL |     let x = make_u32();\n+   |             ---------- here the type of `x` is inferred to be `impl Future<Output = u32>`\n LL |     take_u32(x)\n    |     -------- ^ expected `u32`, found opaque type\n    |     |"}, {"sha": "d33cf383cbcb4ca38d5e550dd6ffccfff6faa956", "filename": "src/test/ui/closures/closure-return-type-mismatch.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Fclosures%2Fclosure-return-type-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Fclosures%2Fclosure-return-type-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-return-type-mismatch.stderr?ref=ea43eb3721e9a6567ff402db442fc5c1ad942009", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/closure-return-type-mismatch.rs:7:9\n    |\n+LL |         let a = true;\n+   |                 ---- here the type of `a` is inferred to be `bool`\n LL |         a\n    |         ^ expected `&str`, found `bool`\n    |"}, {"sha": "d2fd0f788384eda78315d144a2d2e469e53ba1d0", "filename": "src/test/ui/coercion/coerce-to-bang.stderr", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-to-bang.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-to-bang.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-to-bang.stderr?ref=ea43eb3721e9a6567ff402db442fc5c1ad942009", "patch": "@@ -33,6 +33,9 @@ LL | fn foo(x: usize, y: !, z: usize) { }\n error[E0308]: mismatched types\n   --> $DIR/coerce-to-bang.rs:26:12\n    |\n+LL |     let b = 22;\n+   |             -- here the type of `b` is inferred to be `{integer}`\n+LL |     let c = 44;\n LL |     foo(a, b, c); // ... and hence a reference to `a` is expected to diverge.\n    |     ---    ^ expected `!`, found integer\n    |     |\n@@ -49,6 +52,9 @@ LL | fn foo(x: usize, y: !, z: usize) { }\n error[E0308]: mismatched types\n   --> $DIR/coerce-to-bang.rs:36:12\n    |\n+LL |     let b = 22;\n+   |             -- here the type of `b` is inferred to be `{integer}`\n+LL |     let c = 44;\n LL |     foo(a, b, c);\n    |     ---    ^ expected `!`, found integer\n    |     |\n@@ -65,6 +71,9 @@ LL | fn foo(x: usize, y: !, z: usize) { }\n error[E0308]: mismatched types\n   --> $DIR/coerce-to-bang.rs:45:12\n    |\n+LL |     let b = 22;\n+   |             -- here the type of `b` is inferred to be `{integer}`\n+LL |     let c = 44;\n LL |     foo(a, b, c);\n    |     ---    ^ expected `!`, found integer\n    |     |"}, {"sha": "c11a5acc35244fbac426d91025372eb37c9eda2a", "filename": "src/test/ui/generic-associated-types/collections-project-default.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fcollections-project-default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fcollections-project-default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fcollections-project-default.stderr?ref=ea43eb3721e9a6567ff402db442fc5c1ad942009", "patch": "@@ -4,6 +4,9 @@ error[E0308]: mismatched types\n LL | fn floatify_sibling<C>(ints: &C) -> <C as Collection<i32>>::Sibling<f32>\n    |                                     ------------------------------------ expected `<C as Collection<i32>>::Sibling<f32>` because of return type\n ...\n+LL |     let mut res = <C::Family as CollectionFamily>::Member::<f32>::empty();\n+   |                   ------------------------------------------------------- here the type of `res` is inferred to be `<<C as Collection<i32>>::Family as CollectionFamily>::Member<f32>`\n+...\n LL |     res\n    |     ^^^ expected Collection::Sibling, found CollectionFamily::Member\n    |"}, {"sha": "74a7c5de7abe271e5eeffb5fe1b9f38b0aa1da05", "filename": "src/test/ui/issues/issue-15783.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Fissues%2Fissue-15783.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Fissues%2Fissue-15783.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-15783.stderr?ref=ea43eb3721e9a6567ff402db442fc5c1ad942009", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/issue-15783.rs:8:19\n    |\n+LL |     let x = Some(&[name]);\n+   |             ------------- here the type of `x` is inferred to be `Option<_>`\n LL |     let msg = foo(x);\n    |               --- ^ expected slice `[&str]`, found array `[&str; 1]`\n    |               |"}, {"sha": "39b57ceb43d379247fb7dd840c29775bd5a56aaa", "filename": "src/test/ui/let-else/let-else-ref-bindings.stderr", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Flet-else%2Flet-else-ref-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Flet-else%2Flet-else-ref-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-ref-bindings.stderr?ref=ea43eb3721e9a6567ff402db442fc5c1ad942009", "patch": "@@ -19,6 +19,12 @@ LL |     let Some(ref a): Option<&[u8]> = &some else { return };\n error[E0308]: mismatched types\n   --> $DIR/let-else-ref-bindings.rs:24:34\n    |\n+LL |     let some = Some(bytes);\n+   |                ----------- here the type of `some` is inferred to be `Option<_>`\n+...\n+LL |     let Some(ref a): Option<&[u8]> = some else { return };\n+   |                                      ---- here the type of `some` is inferred to be `Option<Vec<u8>>`\n+...\n LL |     let Some(a): Option<&[u8]> = some else { return };\n    |                  -------------   ^^^^ expected `&[u8]`, found struct `Vec`\n    |                  |\n@@ -59,6 +65,12 @@ LL |     let Some(ref mut a): Option<&mut [u8]> = &mut some else { return };\n error[E0308]: mismatched types\n   --> $DIR/let-else-ref-bindings.rs:52:38\n    |\n+LL |     let mut some = Some(bytes);\n+   |                    ----------- here the type of `some` is inferred to be `Option<_>`\n+...\n+LL |     let Some(ref mut a): Option<&mut [u8]> = some else { return };\n+   |                                              ---- here the type of `some` is inferred to be `Option<Vec<u8>>`\n+...\n LL |     let Some(a): Option<&mut [u8]> = some else { return };\n    |                  -----------------   ^^^^ expected `&mut [u8]`, found struct `Vec`\n    |                  |"}, {"sha": "1d836f20012720699916dabf37111d8e8c4ad960", "filename": "src/test/ui/methods/method-deref-to-same-trait-object-with-separate-params.stderr", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Fmethods%2Fmethod-deref-to-same-trait-object-with-separate-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Fmethods%2Fmethod-deref-to-same-trait-object-with-separate-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-deref-to-same-trait-object-with-separate-params.stderr?ref=ea43eb3721e9a6567ff402db442fc5c1ad942009", "patch": "@@ -10,6 +10,9 @@ LL | #![feature(unsized_locals, unsized_fn_params)]\n error[E0308]: mismatched types\n   --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:87:24\n    |\n+LL |     let z = x.foo();\n+   |             ------- here the type of `z` is inferred to be `u32`\n+...\n LL |     let _seetype: () = z;\n    |                   --   ^ expected `()`, found `u32`\n    |                   |\n@@ -18,6 +21,9 @@ LL |     let _seetype: () = z;\n error[E0308]: mismatched types\n   --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:104:24\n    |\n+LL |     let z = x.foo();\n+   |             ------- here the type of `z` is inferred to be `u64`\n+...\n LL |     let _seetype: () = z;\n    |                   --   ^ expected `()`, found `u64`\n    |                   |\n@@ -60,6 +66,9 @@ LL |     let z = FinalFoo::foo(x);\n error[E0308]: mismatched types\n   --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:139:24\n    |\n+LL |     let z = x.foo();\n+   |             ------- here the type of `z` is inferred to be `u8`\n+...\n LL |     let _seetype: () = z;\n    |                   --   ^ expected `()`, found `u8`\n    |                   |\n@@ -68,6 +77,9 @@ LL |     let _seetype: () = z;\n error[E0308]: mismatched types\n   --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:157:24\n    |\n+LL |     let z = x.foo();\n+   |             ------- here the type of `z` is inferred to be `u32`\n+...\n LL |     let _seetype: () = z;\n    |                   --   ^ expected `()`, found `u32`\n    |                   |\n@@ -76,6 +88,9 @@ LL |     let _seetype: () = z;\n error[E0308]: mismatched types\n   --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:174:24\n    |\n+LL |     let z = x.foo();\n+   |             ------- here the type of `z` is inferred to be `u32`\n+...\n LL |     let _seetype: () = z;\n    |                   --   ^ expected `()`, found `u32`\n    |                   |"}, {"sha": "8fd3239e8ee2c273732352035cfae38d81e2d348", "filename": "src/test/ui/mismatched_types/abridged.stderr", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Fmismatched_types%2Fabridged.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Fmismatched_types%2Fabridged.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fabridged.stderr?ref=ea43eb3721e9a6567ff402db442fc5c1ad942009", "patch": "@@ -53,23 +53,39 @@ LL |     Ok(Foo { bar: 1 })\n error[E0308]: mismatched types\n   --> $DIR/abridged.rs:39:5\n    |\n-LL | fn d() -> X<X<String, String>, String> {\n-   |           ---------------------------- expected `X<X<String, String>, String>` because of return type\n-...\n-LL |     x\n-   |     ^ expected struct `String`, found integer\n+LL |   fn d() -> X<X<String, String>, String> {\n+   |             ---------------------------- expected `X<X<String, String>, String>` because of return type\n+LL |       let x = X {\n+   |  _____________-\n+LL | |         x: X {\n+LL | |             x: \"\".to_string(),\n+LL | |             y: 2,\n+LL | |         },\n+LL | |         y: 3,\n+LL | |     };\n+   | |_____- here the type of `x` is inferred to be `X<_, _>`\n+LL |       x\n+   |       ^ expected struct `String`, found integer\n    |\n    = note: expected struct `X<X<_, String>, String>`\n               found struct `X<X<_, {integer}>, {integer}>`\n \n error[E0308]: mismatched types\n   --> $DIR/abridged.rs:50:5\n    |\n-LL | fn e() -> X<X<String, String>, String> {\n-   |           ---------------------------- expected `X<X<String, String>, String>` because of return type\n-...\n-LL |     x\n-   |     ^ expected struct `String`, found integer\n+LL |   fn e() -> X<X<String, String>, String> {\n+   |             ---------------------------- expected `X<X<String, String>, String>` because of return type\n+LL |       let x = X {\n+   |  _____________-\n+LL | |         x: X {\n+LL | |             x: \"\".to_string(),\n+LL | |             y: 2,\n+LL | |         },\n+LL | |         y: \"\".to_string(),\n+LL | |     };\n+   | |_____- here the type of `x` is inferred to be `X<_, _>`\n+LL |       x\n+   |       ^ expected struct `String`, found integer\n    |\n    = note: expected struct `X<X<_, String>, _>`\n               found struct `X<X<_, {integer}>, _>`"}, {"sha": "97cdd130d0bec0862a3b9b76e1dfa5b71a30ac3e", "filename": "src/test/ui/parser/struct-literal-variant-in-if.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-variant-in-if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-variant-in-if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-variant-in-if.stderr?ref=ea43eb3721e9a6567ff402db442fc5c1ad942009", "patch": "@@ -51,6 +51,8 @@ LL |     if x == E::V { field } {}\n error[E0308]: mismatched types\n   --> $DIR/struct-literal-variant-in-if.rs:10:20\n    |\n+LL |     let field = true;\n+   |                 ---- here the type of `field` is inferred to be `bool`\n LL |     if x == E::V { field } {}\n    |     ---------------^^^^^--\n    |     |              |"}, {"sha": "1785c31cfb94832c4a1289dae0b471649f4f841f", "filename": "src/test/ui/rfc-2497-if-let-chains/ensure-that-let-else-does-not-interact-with-let-chains.stderr", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fensure-that-let-else-does-not-interact-with-let-chains.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fensure-that-let-else-does-not-interact-with-let-chains.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fensure-that-let-else-does-not-interact-with-let-chains.stderr?ref=ea43eb3721e9a6567ff402db442fc5c1ad942009", "patch": "@@ -100,6 +100,12 @@ LL |     let Some(n) = opt && let another = n else {\n error[E0308]: mismatched types\n   --> $DIR/ensure-that-let-else-does-not-interact-with-let-chains.rs:9:19\n    |\n+LL |     let opt = Some(1i32);\n+   |               ---------- here the type of `opt` is inferred to be `Option<_>`\n+LL |\n+LL |     let Some(n) = opt else {\n+   |                   --- here the type of `opt` is inferred to be `Option<i32>`\n+...\n LL |     let Some(n) = opt && n == 1 else {\n    |                   ^^^ expected `bool`, found enum `Option`\n    |\n@@ -120,6 +126,12 @@ LL |     let Some(n) = opt && n == 1 else {\n error[E0308]: mismatched types\n   --> $DIR/ensure-that-let-else-does-not-interact-with-let-chains.rs:15:19\n    |\n+LL |     let opt = Some(1i32);\n+   |               ---------- here the type of `opt` is inferred to be `Option<_>`\n+LL |\n+LL |     let Some(n) = opt else {\n+   |                   --- here the type of `opt` is inferred to be `Option<i32>`\n+...\n LL |     let Some(n) = opt && let another = n else {\n    |                   ^^^ expected `bool`, found enum `Option`\n    |"}, {"sha": "75d460d7d8ca9006eceb4a0072c4130ca3c22f4e", "filename": "src/test/ui/span/coerce-suggestions.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Fspan%2Fcoerce-suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Fspan%2Fcoerce-suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fcoerce-suggestions.stderr?ref=ea43eb3721e9a6567ff402db442fc5c1ad942009", "patch": "@@ -63,7 +63,10 @@ error[E0308]: mismatched types\n   --> $DIR/coerce-suggestions.rs:21:9\n    |\n LL |     s = format!(\"foo\");\n-   |         ^^^^^^^^^^^^^^ expected `&mut String`, found struct `String`\n+   |         ^^^^^^^^^^^^^^\n+   |         |\n+   |         expected `&mut String`, found struct `String`\n+   |         here the type of `res` is inferred to be `String`\n    |\n    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n "}, {"sha": "30e248f381c675e15d81d4c1ff7920cd0fbf9cf6", "filename": "src/test/ui/span/issue-33884.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Fspan%2Fissue-33884.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Fspan%2Fissue-33884.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-33884.stderr?ref=ea43eb3721e9a6567ff402db442fc5c1ad942009", "patch": "@@ -2,7 +2,10 @@ error[E0308]: mismatched types\n   --> $DIR/issue-33884.rs:6:22\n    |\n LL |     stream.write_fmt(format!(\"message received\"))\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Arguments`, found struct `String`\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                      |\n+   |                      expected struct `Arguments`, found struct `String`\n+   |                      here the type of `res` is inferred to be `String`\n    |\n    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n "}, {"sha": "30feb9cdd70c117f86c28ee92c521bca26881d4a", "filename": "src/test/ui/structs/struct-base-wrong-type.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Fstructs%2Fstruct-base-wrong-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Fstructs%2Fstruct-base-wrong-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-base-wrong-type.stderr?ref=ea43eb3721e9a6567ff402db442fc5c1ad942009", "patch": "@@ -13,6 +13,8 @@ LL | static foo_i: Foo = Foo { a: 2, ..4 };\n error[E0308]: mismatched types\n   --> $DIR/struct-base-wrong-type.rs:12:27\n    |\n+LL |     let b = Bar { x: 5 };\n+   |             ------------ here the type of `b` is inferred to be `Bar`\n LL |     let f = Foo { a: 2, ..b };\n    |                           ^ expected struct `Foo`, found struct `Bar`\n "}, {"sha": "8295e010f400eb3e119aa95ea19e023101a65402", "filename": "src/test/ui/suggestions/call-boxed.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Fsuggestions%2Fcall-boxed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Fsuggestions%2Fcall-boxed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fcall-boxed.stderr?ref=ea43eb3721e9a6567ff402db442fc5c1ad942009", "patch": "@@ -4,7 +4,10 @@ error[E0308]: mismatched types\n LL |     let mut x = 1i32;\n    |                 ---- expected due to this value\n LL |     let y = Box::new(|| 1);\n-   |                      -- the found closure\n+   |             --------------\n+   |             |        |\n+   |             |        the found closure\n+   |             here the type of `y` is inferred to be `Box<_>`\n LL |     x = y;\n    |         ^ expected `i32`, found struct `Box`\n    |"}, {"sha": "2546f2515d749453b996f5b194dc8f99deef1530", "filename": "src/test/ui/suggestions/dont-suggest-deref-inside-macro-issue-58298.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-deref-inside-macro-issue-58298.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-deref-inside-macro-issue-58298.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-deref-inside-macro-issue-58298.stderr?ref=ea43eb3721e9a6567ff402db442fc5c1ad942009", "patch": "@@ -4,7 +4,10 @@ error[E0308]: mismatched types\n LL | /     intrinsic_match! {\n LL | |         \"abc\"\n LL | |     };\n-   | |_____^ expected `&str`, found struct `String`\n+   | |     ^\n+   | |     |\n+   | |_____expected `&str`, found struct `String`\n+   |       here the type of `res` is inferred to be `String`\n    |\n    = note: this error originates in the macro `format` which comes from the expansion of the macro `intrinsic_match` (in Nightly builds, run with -Z macro-backtrace for more info)\n "}, {"sha": "388d8d8d895e323e4851f687e773e4b74da081a2", "filename": "src/test/ui/suggestions/issue-86100-tuple-paren-comma.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Fsuggestions%2Fissue-86100-tuple-paren-comma.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Fsuggestions%2Fissue-86100-tuple-paren-comma.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-86100-tuple-paren-comma.stderr?ref=ea43eb3721e9a6567ff402db442fc5c1ad942009", "patch": "@@ -49,6 +49,8 @@ LL |     let _s = S { _s: (\"abc\".to_string(),) };\n error[E0308]: mismatched types\n   --> $DIR/issue-86100-tuple-paren-comma.rs:23:22\n    |\n+LL |     let t = (1, 2);\n+   |             ------ here the type of `t` is inferred to be `({integer}, {integer})`\n LL |     let _x: (i32,) = (t);\n    |             ------   ^^^ expected a tuple with 1 element, found one with 2 elements\n    |             |"}, {"sha": "f7b5b7fca06e87db9eca21ab204d26219a9f6bde", "filename": "src/test/ui/traits/issue-52893.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Ftraits%2Fissue-52893.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Ftraits%2Fissue-52893.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-52893.stderr?ref=ea43eb3721e9a6567ff402db442fc5c1ad942009", "patch": "@@ -4,6 +4,8 @@ error[E0308]: mismatched types\n LL | impl<F, Name, P> AddClass<Name, F> for Class<P>\n    |      - this type parameter\n ...\n+LL |         let output = builder.to_ref();\n+   |                      ---------------- here the type of `output` is inferred to be `Class<P>`\n LL |         builder.push(output);\n    |                 ---- ^^^^^^ expected type parameter `F`, found struct `Class`\n    |                 |"}, {"sha": "c83bc28d8553aae973b448c590ee3d7fc59e13e7", "filename": "src/test/ui/tuple/wrong_argument_ice-3.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Ftuple%2Fwrong_argument_ice-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Ftuple%2Fwrong_argument_ice-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftuple%2Fwrong_argument_ice-3.stderr?ref=ea43eb3721e9a6567ff402db442fc5c1ad942009", "patch": "@@ -1,6 +1,9 @@\n error[E0061]: this method takes 1 argument but 2 arguments were supplied\n   --> $DIR/wrong_argument_ice-3.rs:9:16\n    |\n+LL |     let new_group = vec![String::new()];\n+   |                     ------------------- here the type of `new_group` is inferred to be `Vec<_, _>`\n+...\n LL |         groups.push(new_group, vec![process]);\n    |                ^^^^            ------------- argument of type `Vec<&Process>` unexpected\n    |"}, {"sha": "fb11d6160bbaa4978cbb8fbbba134394842e30ad", "filename": "src/test/ui/type/type-check/assignment-in-if.stderr", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.stderr?ref=ea43eb3721e9a6567ff402db442fc5c1ad942009", "patch": "@@ -67,6 +67,12 @@ LL |             x == 5\n error[E0308]: mismatched types\n   --> $DIR/assignment-in-if.rs:44:18\n    |\n+LL |     let x = 1;\n+   |             - here the type of `x` is inferred to be `{integer}`\n+...\n+LL |         println!(\"{}\", x);\n+   |                        - here the type of `x` is inferred to be `usize`\n+...\n LL |     if x == x && x = x && x == x {\n    |        ------    ^ expected `bool`, found `usize`\n    |        |\n@@ -75,6 +81,12 @@ LL |     if x == x && x = x && x == x {\n error[E0308]: mismatched types\n   --> $DIR/assignment-in-if.rs:44:22\n    |\n+LL |     let x = 1;\n+   |             - here the type of `x` is inferred to be `{integer}`\n+...\n+LL |         println!(\"{}\", x);\n+   |                        - here the type of `x` is inferred to be `usize`\n+...\n LL |     if x == x && x = x && x == x {\n    |                      ^ expected `bool`, found `usize`\n \n@@ -92,6 +104,12 @@ LL |     if x == x && x == x && x == x {\n error[E0308]: mismatched types\n   --> $DIR/assignment-in-if.rs:51:28\n    |\n+LL |     let x = 1;\n+   |             - here the type of `x` is inferred to be `{integer}`\n+...\n+LL |         println!(\"{}\", x);\n+   |                        - here the type of `x` is inferred to be `usize`\n+...\n LL |     if x == x && x == x && x = x {\n    |        ----------------    ^ expected `bool`, found `usize`\n    |        |"}, {"sha": "e99d30d33963126b5912eba980c2d6ced48e87b9", "filename": "src/test/ui/type/type-mismatch-same-crate-name.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Ftype%2Ftype-mismatch-same-crate-name.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea43eb3721e9a6567ff402db442fc5c1ad942009/src%2Ftest%2Fui%2Ftype%2Ftype-mismatch-same-crate-name.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-mismatch-same-crate-name.stderr?ref=ea43eb3721e9a6567ff402db442fc5c1ad942009", "patch": "@@ -1,6 +1,9 @@\n error[E0308]: mismatched types\n   --> $DIR/type-mismatch-same-crate-name.rs:16:20\n    |\n+LL |     let foo2 = {extern crate crate_a2 as a; a::Foo};\n+   |                ------------------------------------ here the type of `foo2` is inferred to be `_`\n+...\n LL |         a::try_foo(foo2);\n    |         ---------- ^^^^ expected struct `main::a::Foo`, found a different struct `main::a::Foo`\n    |         |\n@@ -27,6 +30,9 @@ LL | pub fn try_foo(x: Foo){}\n error[E0308]: mismatched types\n   --> $DIR/type-mismatch-same-crate-name.rs:20:20\n    |\n+LL |     let bar2 = {extern crate crate_a2 as a; a::bar()};\n+   |                -------------------------------------- here the type of `bar2` is inferred to be `_`\n+...\n LL |         a::try_bar(bar2);\n    |         ---------- ^^^^ expected trait `main::a::Bar`, found a different trait `main::a::Bar`\n    |         |"}]}