{"sha": "29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "node_id": "C_kwDOAAsO6NoAKDI5YWM0MjljOWJkNWY2YWE1YWY4ZDJjMDRmM2VmODczMmNkOGJkMTU", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-05-08T16:30:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-05-08T16:30:21Z"}, "message": "Rollup merge of #109410 - fmease:iat-alias-kind-inherent, r=compiler-errors\n\nIntroduce `AliasKind::Inherent` for inherent associated types\n\nAllows us to check (possibly generic) inherent associated types for well-formedness.\nType inference now also works properly.\n\nFollow-up to #105961. Supersedes #108430.\nFixes #106722.\nFixes #108957.\nFixes #109768.\nFixes #109789.\nFixes #109790.\n\n~Not to be merged before #108860 (`AliasKind::Weak`).~\n\nCC `@jackh726`\nr? `@compiler-errors`\n\n`@rustbot` label T-types F-inherent_associated_types", "tree": {"sha": "fb9a55891b26a4ce71e471cadc3a964959724ecf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb9a55891b26a4ce71e471cadc3a964959724ecf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkWSOdCRBK7hj4Ov3rIwAAKIQIAKGzLBowG6qmRhof2EIyR0fN\nJYwJ/4rqjsd8QTw2r9SxEFiOgYMEoAXbKPuuMA3Z7JbgC9Cd7ruN8GvAC29qbGvR\nfOwaM57DYu5R5qZ7dEt/3yr7BUmtDxRObfvegijmQusWhWDSDyUicLBipi2hPhYm\nDLaPCIMRN3Hfhe1BXVnm7A2HP0oUXiGz2B4MKsgFao51GqGPr8CKBhVf8pFf0xzw\nOTHVUb1dV68FU2WQlWEwNVIylMRoCLa5rBrik4Z9cN3UXXuzL/alPh34CnCmOd9V\n1eO5XFvueb+U6XWWWCaxl4nZB8QNg7aqG2OVAqcMvXLStOMI8p1Y/FvjEqZECnM=\n=39dq\n-----END PGP SIGNATURE-----\n", "payload": "tree fb9a55891b26a4ce71e471cadc3a964959724ecf\nparent fcb275f85e0e64bf3bb488cbd518bb085040c0cf\nparent cd6dec33c2b484fbcb672cb1f80b68b602c1a6f1\nauthor Michael Goulet <michael@errs.io> 1683563421 -0700\ncommitter GitHub <noreply@github.com> 1683563421 -0700\n\nRollup merge of #109410 - fmease:iat-alias-kind-inherent, r=compiler-errors\n\nIntroduce `AliasKind::Inherent` for inherent associated types\n\nAllows us to check (possibly generic) inherent associated types for well-formedness.\nType inference now also works properly.\n\nFollow-up to #105961. Supersedes #108430.\nFixes #106722.\nFixes #108957.\nFixes #109768.\nFixes #109789.\nFixes #109790.\n\n~Not to be merged before #108860 (`AliasKind::Weak`).~\n\nCC `@jackh726`\nr? `@compiler-errors`\n\n`@rustbot` label T-types F-inherent_associated_types\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "html_url": "https://github.com/rust-lang/rust/commit/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcb275f85e0e64bf3bb488cbd518bb085040c0cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcb275f85e0e64bf3bb488cbd518bb085040c0cf", "html_url": "https://github.com/rust-lang/rust/commit/fcb275f85e0e64bf3bb488cbd518bb085040c0cf"}, {"sha": "cd6dec33c2b484fbcb672cb1f80b68b602c1a6f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd6dec33c2b484fbcb672cb1f80b68b602c1a6f1", "html_url": "https://github.com/rust-lang/rust/commit/cd6dec33c2b484fbcb672cb1f80b68b602c1a6f1"}], "stats": {"total": 1594, "additions": 1365, "deletions": 229}, "files": [{"sha": "6ac1df6a079287c8779394fbd684c1bcfa54535f", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 35, "deletions": 26, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -2419,6 +2419,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             return Ok(None);\n         }\n \n+        //\n+        // Select applicable inherent associated type candidates modulo regions.\n+        //\n+\n         // In contexts that have no inference context, just make a new one.\n         // We do need a local variable to store it, though.\n         let infcx_;\n@@ -2431,14 +2435,18 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n         };\n \n-        let param_env = tcx.param_env(block.owner.to_def_id());\n+        // FIXME(inherent_associated_types): Acquiring the ParamEnv this early leads to cycle errors\n+        // when inside of an ADT (#108491) or where clause.\n+        let param_env = tcx.param_env(block.owner);\n         let cause = ObligationCause::misc(span, block.owner.def_id);\n \n         let mut fulfillment_errors = Vec::new();\n         let mut applicable_candidates: Vec<_> = infcx.probe(|_| {\n             let universe = infcx.create_next_universe();\n \n             // Regions are not considered during selection.\n+            // FIXME(non_lifetime_binders): Here we are \"truncating\" or \"flattening\" the universes\n+            // of type and const binders. Is that correct in the selection phase? See also #109505.\n             let self_ty = tcx.replace_escaping_bound_vars_uncached(\n                 self_ty,\n                 FnMutDelegate {\n@@ -2454,41 +2462,40 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n             candidates\n                 .iter()\n-                .filter_map(|&(impl_, (assoc_item, def_scope))| {\n+                .copied()\n+                .filter(|&(impl_, _)| {\n                     infcx.probe(|_| {\n                         let ocx = ObligationCtxt::new_in_snapshot(&infcx);\n \n-                        let impl_ty = tcx.type_of(impl_);\n                         let impl_substs = infcx.fresh_item_substs(impl_);\n-                        let impl_ty = impl_ty.subst(tcx, impl_substs);\n+                        let impl_ty = tcx.type_of(impl_).subst(tcx, impl_substs);\n                         let impl_ty = ocx.normalize(&cause, param_env, impl_ty);\n \n-                        // Check that the Self-types can be related.\n-                        // FIXME(fmease): Should we use `eq` here?\n-                        ocx.sup(&ObligationCause::dummy(), param_env, impl_ty, self_ty).ok()?;\n+                        // Check that the self types can be related.\n+                        // FIXME(inherent_associated_types): Should we use `eq` here? Method probing uses\n+                        // `sup` for this situtation, too. What for? To constrain inference variables?\n+                        if ocx.sup(&ObligationCause::dummy(), param_env, impl_ty, self_ty).is_err()\n+                        {\n+                            return false;\n+                        }\n \n                         // Check whether the impl imposes obligations we have to worry about.\n-                        let impl_bounds = tcx.predicates_of(impl_);\n-                        let impl_bounds = impl_bounds.instantiate(tcx, impl_substs);\n-\n+                        let impl_bounds = tcx.predicates_of(impl_).instantiate(tcx, impl_substs);\n                         let impl_bounds = ocx.normalize(&cause, param_env, impl_bounds);\n-\n                         let impl_obligations = traits::predicates_for_generics(\n                             |_, _| cause.clone(),\n                             param_env,\n                             impl_bounds,\n                         );\n-\n                         ocx.register_obligations(impl_obligations);\n \n                         let mut errors = ocx.select_where_possible();\n                         if !errors.is_empty() {\n                             fulfillment_errors.append(&mut errors);\n-                            return None;\n+                            return false;\n                         }\n \n-                        // FIXME(fmease): Unsolved vars can escape this InferCtxt snapshot.\n-                        Some((assoc_item, def_scope, infcx.resolve_vars_if_possible(impl_substs)))\n+                        true\n                     })\n                 })\n                 .collect()\n@@ -2497,24 +2504,26 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         if applicable_candidates.len() > 1 {\n             return Err(self.complain_about_ambiguous_inherent_assoc_type(\n                 name,\n-                applicable_candidates.into_iter().map(|(candidate, ..)| candidate).collect(),\n+                applicable_candidates.into_iter().map(|(_, (candidate, _))| candidate).collect(),\n                 span,\n             ));\n         }\n \n-        if let Some((assoc_item, def_scope, impl_substs)) = applicable_candidates.pop() {\n+        if let Some((impl_, (assoc_item, def_scope))) = applicable_candidates.pop() {\n             self.check_assoc_ty(assoc_item, name, def_scope, block, span);\n \n-            // FIXME(inherent_associated_types): To fully *confirm* the *probed* candidate, we still\n-            // need to relate the Self-type with fresh item substs & register region obligations for\n-            // regionck to prove/disprove.\n-\n-            let item_substs =\n-                self.create_substs_for_associated_item(span, assoc_item, segment, impl_substs);\n+            // FIXME(fmease): Currently creating throwaway `parent_substs` to please\n+            // `create_substs_for_associated_item`. Modify the latter instead (or sth. similar) to\n+            // not require the parent substs logic.\n+            let parent_substs = InternalSubsts::identity_for_item(tcx, impl_);\n+            let substs =\n+                self.create_substs_for_associated_item(span, assoc_item, segment, parent_substs);\n+            let substs = tcx.mk_substs_from_iter(\n+                std::iter::once(ty::GenericArg::from(self_ty))\n+                    .chain(substs.into_iter().skip(parent_substs.len())),\n+            );\n \n-            // FIXME(fmease, #106722): Check if the bounds on the parameters of the\n-            // associated type hold, if any.\n-            let ty = tcx.type_of(assoc_item).subst(tcx, item_substs);\n+            let ty = tcx.mk_alias(ty::Inherent, tcx.mk_alias_ty(assoc_item, substs));\n \n             return Ok(Some((ty, assoc_item)));\n         }"}, {"sha": "272177dfbd0f858ea5bc562e4ad6bda2d2255cd0", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -210,6 +210,19 @@ fn do_orphan_check_impl<'tcx>(\n                 NonlocalImpl::DisallowOther,\n             ),\n \n+            // ```\n+            // struct S<T>(T);\n+            // impl<T: ?Sized> S<T> {\n+            //     type This = T;\n+            // }\n+            // impl<T: ?Sized> AutoTrait for S<T>::This {}\n+            // ```\n+            // FIXME(inherent_associated_types): The example code above currently leads to a cycle\n+            ty::Alias(AliasKind::Inherent, _) => (\n+                LocalImpl::Disallow { problematic_kind: \"associated type\" },\n+                NonlocalImpl::DisallowOther,\n+            ),\n+\n             // type Opaque = impl Trait;\n             // impl AutoTrait for Opaque {}\n             ty::Alias(AliasKind::Opaque, _) => ("}, {"sha": "5c7f7f10b17ecc2cd1b3f8b3f59bd23eb67ad90e", "filename": "compiler/rustc_hir_analysis/src/collect/resolve_bound_vars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -1948,7 +1948,7 @@ fn is_late_bound_map(\n                 ty::Param(param_ty) => {\n                     self.arg_is_constrained[param_ty.index as usize] = true;\n                 }\n-                ty::Alias(ty::Projection, _) => return ControlFlow::Continue(()),\n+                ty::Alias(ty::Projection | ty::Inherent, _) => return ControlFlow::Continue(()),\n                 _ => (),\n             }\n             t.super_visit_with(self)"}, {"sha": "8df0166f76b4b269c8f97d2760f914b927423eef", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -127,7 +127,7 @@ fn anon_const_type_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Ty<'tcx> {\n             // the def_id that this query was called with. We filter to only type and const args here\n             // as a precaution for if it's ever allowed to elide lifetimes in GAT's. It currently isn't\n             // but it can't hurt to be safe ^^\n-            if let ty::Alias(ty::Projection, projection) = ty.kind() {\n+            if let ty::Alias(ty::Projection | ty::Inherent, projection) = ty.kind() {\n                 let generics = tcx.generics_of(projection.def_id);\n \n                 let arg_index = segment"}, {"sha": "9200c2aecf55c07699e9bcdf1f289ea64d2d6977", "filename": "compiler/rustc_hir_analysis/src/constrained_generic_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -59,7 +59,7 @@ struct ParameterCollector {\n impl<'tcx> TypeVisitor<TyCtxt<'tcx>> for ParameterCollector {\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         match *t.kind() {\n-            ty::Alias(ty::Projection, ..) if !self.include_nonconstraining => {\n+            ty::Alias(ty::Projection | ty::Inherent, ..) if !self.include_nonconstraining => {\n                 // projections are not injective\n                 return ControlFlow::Continue(());\n             }"}, {"sha": "0cd2fc1aa299a4dc3f8a5b532de37fdaebca84e5", "filename": "compiler/rustc_hir_analysis/src/outlives/implicit_infer.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -210,6 +210,9 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 );\n             }\n \n+            // FIXME(inherent_associated_types): Handle this case properly.\n+            ty::Alias(ty::Inherent, _) => {}\n+\n             _ => {}\n         }\n     }"}, {"sha": "05e5d850bf958cc6471a15ed5ff489abdbbe0a09", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/adjust_fulfillment_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -843,7 +843,7 @@ fn find_param_in_ty<'tcx>(\n             return true;\n         }\n         if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-                && let ty::Alias(ty::Projection, ..) = ty.kind()\n+                && let ty::Alias(ty::Projection | ty::Inherent, ..) = ty.kind()\n             {\n                 // This logic may seem a bit strange, but typically when\n                 // we have a projection type in a function signature, the"}, {"sha": "67f45f9aa3f0dd64977c8bdd10ab4d142ab76bde", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -300,7 +300,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         match ty.kind() {\n             ty::Adt(adt_def, _) => Some(*adt_def),\n             // FIXME(#104767): Should we handle bound regions here?\n-            ty::Alias(ty::Projection, _) if !ty.has_escaping_bound_vars() => {\n+            ty::Alias(ty::Projection | ty::Inherent, _) if !ty.has_escaping_bound_vars() => {\n                 self.normalize(span, ty).ty_adt_def()\n             }\n             _ => None,"}, {"sha": "3741672e5683c3e906f658d0819f3da82a094768", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -2211,7 +2211,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         | ty::Float(_)\n                         | ty::Adt(_, _)\n                         | ty::Str\n-                        | ty::Alias(ty::Projection, _)\n+                        | ty::Alias(ty::Projection | ty::Inherent, _)\n                         | ty::Param(_) => format!(\"{deref_ty}\"),\n                         // we need to test something like  <&[_]>::len or <(&[u32])>::len\n                         // and Vec::function();"}, {"sha": "08eec0707c0adaf9db0f3b720a9896fd1f2efc35", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -127,7 +127,8 @@ impl<'tcx> InferCtxt<'tcx> {\n                 bug!()\n             }\n \n-            (_, ty::Alias(AliasKind::Projection, _)) | (ty::Alias(AliasKind::Projection, _), _)\n+            (_, ty::Alias(AliasKind::Projection | AliasKind::Inherent, _))\n+            | (ty::Alias(AliasKind::Projection | AliasKind::Inherent, _), _)\n                 if self.tcx.trait_solver_next() =>\n             {\n                 relation.register_type_relate_obligation(a, b);"}, {"sha": "ce70f39cc4014d66aae79c447b747a06e9732761", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -2354,7 +2354,9 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         let labeled_user_string = match bound_kind {\n             GenericKind::Param(ref p) => format!(\"the parameter type `{}`\", p),\n             GenericKind::Alias(ref p) => match p.kind(self.tcx) {\n-                ty::AliasKind::Projection => format!(\"the associated type `{}`\", p),\n+                ty::AliasKind::Projection | ty::AliasKind::Inherent => {\n+                    format!(\"the associated type `{}`\", p)\n+                }\n                 ty::AliasKind::Opaque => format!(\"the opaque type `{}`\", p),\n             },\n         };"}, {"sha": "064811bd29d77a25aade79585d08a67122adb6f9", "filename": "compiler/rustc_infer/src/infer/error_reporting/note_and_explain.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -71,9 +71,10 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                              #traits-as-parameters\",\n                         );\n                     }\n-                    (ty::Alias(ty::Projection, _), ty::Alias(ty::Projection, _)) => {\n+                    (ty::Alias(ty::Projection | ty::Inherent, _), ty::Alias(ty::Projection | ty::Inherent, _)) => {\n                         diag.note(\"an associated type was expected, but a different one was found\");\n                     }\n+                    // FIXME(inherent_associated_types): Extend this to support `ty::Inherent`, too.\n                     (ty::Param(p), ty::Alias(ty::Projection, proj)) | (ty::Alias(ty::Projection, proj), ty::Param(p))\n                         if !tcx.is_impl_trait_in_trait(proj.def_id) =>\n                     {\n@@ -222,7 +223,7 @@ impl<T> Trait<T> for X {\n                             diag.span_label(p_span, \"this type parameter\");\n                         }\n                     }\n-                    (ty::Alias(ty::Projection, proj_ty), _) if !tcx.is_impl_trait_in_trait(proj_ty.def_id) => {\n+                    (ty::Alias(ty::Projection | ty::Inherent, proj_ty), _) if !tcx.is_impl_trait_in_trait(proj_ty.def_id) => {\n                         self.expected_projection(\n                             diag,\n                             proj_ty,\n@@ -231,7 +232,7 @@ impl<T> Trait<T> for X {\n                             cause.code(),\n                         );\n                     }\n-                    (_, ty::Alias(ty::Projection, proj_ty)) if !tcx.is_impl_trait_in_trait(proj_ty.def_id) => {\n+                    (_, ty::Alias(ty::Projection | ty::Inherent, proj_ty)) if !tcx.is_impl_trait_in_trait(proj_ty.def_id) => {\n                         let msg = format!(\n                             \"consider constraining the associated type `{}` to `{}`\",\n                             values.found, values.expected,"}, {"sha": "362b22b23a8dad81e64d37cb4bad130696df32fe", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -549,6 +549,7 @@ impl<'tcx> InferCtxt<'tcx> {\n                     // We can't normalize associated types from `rustc_infer`,\n                     // but we can eagerly register inference variables for them.\n                     // FIXME(RPITIT): Don't replace RPITITs with inference vars.\n+                    // FIXME(inherent_associated_types): Extend this to support `ty::Inherent`, too.\n                     ty::Alias(ty::Projection, projection_ty)\n                         if !projection_ty.has_escaping_bound_vars()\n                             && !tcx.is_impl_trait_in_trait(projection_ty.def_id) =>\n@@ -569,6 +570,7 @@ impl<'tcx> InferCtxt<'tcx> {\n                         hidden_ty\n                     }\n                     // FIXME(RPITIT): This can go away when we move to associated types\n+                    // FIXME(inherent_associated_types): Extend this to support `ty::Inherent`, too.\n                     ty::Alias(\n                         ty::Projection,\n                         ty::AliasTy { def_id: def_id2, substs: substs2, .. },"}, {"sha": "3025cce7ba7e52960b0724e427782264f49c7cb2", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -62,6 +62,7 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::layout::{LayoutError, LayoutOf};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::subst::GenericArgKind;\n+use rustc_middle::ty::TypeVisitableExt;\n use rustc_middle::ty::{self, Instance, Ty, TyCtxt, VariantDef};\n use rustc_session::config::ExpectedValues;\n use rustc_session::lint::{BuiltinLintDiagnostics, FutureIncompatibilityReason};\n@@ -1442,6 +1443,10 @@ impl<'tcx> LateLintPass<'tcx> for TypeAliasBounds {\n             // Bounds are respected for `type X = impl Trait`\n             return;\n         }\n+        if cx.tcx.type_of(item.owner_id).skip_binder().has_inherent_projections() {\n+            // Bounds are respected for `type X = \u2026 Type::Inherent \u2026`\n+            return;\n+        }\n         // There must not be a where clause\n         if type_alias_generics.predicates.is_empty() {\n             return;\n@@ -1561,7 +1566,6 @@ declare_lint_pass!(\n \n impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n-        use rustc_middle::ty::visit::TypeVisitableExt;\n         use rustc_middle::ty::Clause;\n         use rustc_middle::ty::PredicateKind::*;\n \n@@ -2898,6 +2902,7 @@ impl ClashingExternDeclarations {\n                         | (Generator(..), Generator(..))\n                         | (GeneratorWitness(..), GeneratorWitness(..))\n                         | (Alias(ty::Projection, ..), Alias(ty::Projection, ..))\n+                        | (Alias(ty::Inherent, ..), Alias(ty::Inherent, ..))\n                         | (Alias(ty::Opaque, ..), Alias(ty::Opaque, ..)) => false,\n \n                         // These definitely should have been caught above."}, {"sha": "125b4dc5503100548be60daa014cd00d05560fb5", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -1119,14 +1119,14 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n             // `extern \"C\" fn` functions can have type parameters, which may or may not be FFI-safe,\n             //  so they are currently ignored for the purposes of this lint.\n-            ty::Param(..) | ty::Alias(ty::Projection, ..)\n+            ty::Param(..) | ty::Alias(ty::Projection | ty::Inherent, ..)\n                 if matches!(self.mode, CItemKind::Definition) =>\n             {\n                 FfiSafe\n             }\n \n             ty::Param(..)\n-            | ty::Alias(ty::Projection, ..)\n+            | ty::Alias(ty::Projection | ty::Inherent, ..)\n             | ty::Infer(..)\n             | ty::Bound(..)\n             | ty::Error(_)"}, {"sha": "d5b185e45d6b4aba261ce06424c011b12e93bfc8", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -1821,6 +1821,16 @@ rustc_queries! {\n         desc { \"normalizing `{}`\", goal.value.value }\n     }\n \n+    /// Do not call this query directly: invoke `normalize` instead.\n+    query normalize_inherent_projection_ty(\n+        goal: CanonicalProjectionGoal<'tcx>\n+    ) -> Result<\n+        &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, NormalizationResult<'tcx>>>,\n+        NoSolution,\n+    > {\n+        desc { \"normalizing `{}`\", goal.value.value }\n+    }\n+\n     /// Do not call this query directly: invoke `try_normalize_erasing_regions` instead.\n     query try_normalize_generic_arg_after_erasing_regions(\n         goal: ParamEnvAnd<'tcx, GenericArg<'tcx>>"}, {"sha": "8aea2d8aedf982aeb936247069f5ee966fd32e02", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -1848,7 +1848,17 @@ impl<'tcx> TyCtxt<'tcx> {\n         let substs = substs.into_iter().map(Into::into);\n         #[cfg(debug_assertions)]\n         {\n-            let n = self.generics_of(_def_id).count();\n+            let generics = self.generics_of(_def_id);\n+\n+            let n = if let DefKind::AssocTy = self.def_kind(_def_id)\n+                && let DefKind::Impl { of_trait: false } = self.def_kind(self.parent(_def_id))\n+            {\n+                // If this is an inherent projection.\n+\n+                generics.params.len() + 1\n+            } else {\n+                generics.count()\n+            };\n             assert_eq!(\n                 (n, Some(n)),\n                 substs.size_hint(),\n@@ -2009,7 +2019,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         debug_assert_matches!(\n             (kind, self.def_kind(alias_ty.def_id)),\n             (ty::Opaque, DefKind::OpaqueTy)\n-                | (ty::Projection, DefKind::AssocTy)\n+                | (ty::Projection | ty::Inherent, DefKind::AssocTy)\n                 | (ty::Opaque | ty::Projection, DefKind::ImplTraitPlaceholder)\n         );\n         self.mk_ty_from_kind(Alias(kind, alias_ty))"}, {"sha": "49ab9b79e96f32de0dbf5799d9a35f4a56d3d44d", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -265,7 +265,7 @@ impl<'tcx> Ty<'tcx> {\n             ty::Infer(ty::FreshTy(_)) => \"fresh type\".into(),\n             ty::Infer(ty::FreshIntTy(_)) => \"fresh integral type\".into(),\n             ty::Infer(ty::FreshFloatTy(_)) => \"fresh floating-point type\".into(),\n-            ty::Alias(ty::Projection, _) => \"associated type\".into(),\n+            ty::Alias(ty::Projection | ty::Inherent, _) => \"associated type\".into(),\n             ty::Param(p) => format!(\"type parameter `{p}`\").into(),\n             ty::Alias(ty::Opaque, ..) => if tcx.ty_is_opaque_future(self) { \"future\".into() } else { \"opaque type\".into() },\n             ty::Error(_) => \"type error\".into(),\n@@ -312,7 +312,7 @@ impl<'tcx> Ty<'tcx> {\n             ty::Tuple(..) => \"tuple\".into(),\n             ty::Placeholder(..) => \"higher-ranked type\".into(),\n             ty::Bound(..) => \"bound type variable\".into(),\n-            ty::Alias(ty::Projection, _) => \"associated type\".into(),\n+            ty::Alias(ty::Projection | ty::Inherent, _) => \"associated type\".into(),\n             ty::Param(_) => \"type parameter\".into(),\n             ty::Alias(ty::Opaque, ..) => \"opaque type\".into(),\n         }"}, {"sha": "d64875a9f00e8cc08cae1abf9cd1a3829836ecb7", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -176,14 +176,14 @@ impl FlagComputation {\n                 self.add_substs(substs);\n             }\n \n-            &ty::Alias(ty::Projection, data) => {\n-                self.add_flags(TypeFlags::HAS_TY_PROJECTION);\n-                self.add_alias_ty(data);\n-            }\n+            &ty::Alias(kind, data) => {\n+                self.add_flags(match kind {\n+                    ty::Projection => TypeFlags::HAS_TY_PROJECTION,\n+                    ty::Inherent => TypeFlags::HAS_TY_INHERENT,\n+                    ty::Opaque => TypeFlags::HAS_TY_OPAQUE,\n+                });\n \n-            &ty::Alias(ty::Opaque, ty::AliasTy { substs, .. }) => {\n-                self.add_flags(TypeFlags::HAS_TY_OPAQUE);\n-                self.add_substs(substs);\n+                self.add_alias_ty(data);\n             }\n \n             &ty::Dynamic(obj, r, _) => {"}, {"sha": "9e672004cf9c0e6dc8d5fbe7598a2643c7831434", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -113,6 +113,12 @@ impl<'tcx> Ty<'tcx> {\n             }\n             Never => InhabitedPredicate::False,\n             Param(_) | Alias(ty::Projection, _) => InhabitedPredicate::GenericType(self),\n+            // FIXME(inherent_associated_types): Most likely we can just map to `GenericType` like above.\n+            // However it's unclear if the substs passed to `InhabitedPredicate::subst` are of the correct\n+            // format, i.e. don't contain parent substs. If you hit this case, please verify this beforehand.\n+            Alias(ty::Inherent, _) => {\n+                bug!(\"unimplemented: inhabitedness checking for inherent projections\")\n+            }\n             Tuple(tys) if tys.is_empty() => InhabitedPredicate::True,\n             // use a query for more complex cases\n             Adt(..) | Array(..) | Tuple(_) => tcx.inhabited_predicate_type(self),"}, {"sha": "47cf48f46cf891fbff7c6493190295f94638ad66", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -324,7 +324,7 @@ impl<'tcx> SizeSkeleton<'tcx> {\n                 let non_zero = !ty.is_unsafe_ptr();\n                 let tail = tcx.struct_tail_erasing_lifetimes(pointee, param_env);\n                 match tail.kind() {\n-                    ty::Param(_) | ty::Alias(ty::Projection, _) => {\n+                    ty::Param(_) | ty::Alias(ty::Projection | ty::Inherent, _) => {\n                         debug_assert!(tail.has_non_region_param());\n                         Ok(SizeSkeleton::Pointer { non_zero, tail: tcx.erase_regions(tail) })\n                     }"}, {"sha": "f882f54d6281118999c2e1badb136b59dcb58b44", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -1004,7 +1004,7 @@ impl<'tcx> Term<'tcx> {\n         match self.unpack() {\n             TermKind::Ty(ty) => match ty.kind() {\n                 ty::Alias(kind, alias_ty) => match kind {\n-                    AliasKind::Projection => Some(*alias_ty),\n+                    AliasKind::Projection | AliasKind::Inherent => Some(*alias_ty),\n                     AliasKind::Opaque => None,\n                 },\n                 _ => None,"}, {"sha": "926172ff828c725a9451a193b3d3c7f0cdacad72", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -729,7 +729,7 @@ pub trait PrettyPrinter<'tcx>:\n             ty::Foreign(def_id) => {\n                 p!(print_def_path(def_id, &[]));\n             }\n-            ty::Alias(ty::Projection, ref data) => {\n+            ty::Alias(ty::Projection | ty::Inherent, ref data) => {\n                 if !(self.should_print_verbose() || NO_QUERIES.with(|q| q.get()))\n                     && self.tcx().is_impl_trait_in_trait(data.def_id)\n                 {"}, {"sha": "da43475941ee5a309780d63a02e38febb36ec9bc", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -550,6 +550,11 @@ pub fn super_relate_tys<'tcx, R: TypeRelation<'tcx>>(\n             Ok(tcx.mk_projection(projection_ty.def_id, projection_ty.substs))\n         }\n \n+        (&ty::Alias(ty::Inherent, a_data), &ty::Alias(ty::Inherent, b_data)) => {\n+            let alias_ty = relation.relate(a_data, b_data)?;\n+            Ok(tcx.mk_alias(ty::Inherent, tcx.mk_alias_ty(alias_ty.def_id, alias_ty.substs)))\n+        }\n+\n         (\n             &ty::Alias(ty::Opaque, ty::AliasTy { def_id: a_def_id, substs: a_substs, .. }),\n             &ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, substs: b_substs, .. }),"}, {"sha": "8d0737e1eeeeb979b95e4ff4fb1ca194c6984f81", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 41, "deletions": 10, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -1190,9 +1190,9 @@ where\n \n /// Represents the projection of an associated type.\n ///\n-/// For a projection, this would be `<Ty as Trait<...>>::N`.\n-///\n-/// For an opaque type, there is no explicit syntax.\n+/// * For a projection, this would be `<Ty as Trait<...>>::N<...>`.\n+/// * For an inherent projection, this would be `Ty::N<...>`.\n+/// * For an opaque type, there is no explicit syntax.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct AliasTy<'tcx> {\n@@ -1201,12 +1201,16 @@ pub struct AliasTy<'tcx> {\n     /// For a projection, these are the substitutions for the trait and the\n     /// GAT substitutions, if there are any.\n     ///\n+    /// For an inherent projection, they consist of the self type and the GAT substitutions,\n+    /// if there are any.\n+    ///\n     /// For RPIT the substitutions are for the generics of the function,\n     /// while for TAIT it is used for the generic parameters of the alias.\n     pub substs: SubstsRef<'tcx>,\n \n-    /// The `DefId` of the `TraitItem` for the associated type `N` if this is a projection,\n-    /// or the `OpaqueType` item if this is an opaque.\n+    /// The `DefId` of the `TraitItem` or `ImplItem` for the associated type `N` depending on whether\n+    /// this is a projection or an inherent projection or the `DefId` of the `OpaqueType` item if\n+    /// this is an opaque.\n     ///\n     /// During codegen, `tcx.type_of(def_id)` can be used to get the type of the\n     /// underlying type if the type is an opaque.\n@@ -1224,6 +1228,7 @@ pub struct AliasTy<'tcx> {\n impl<'tcx> AliasTy<'tcx> {\n     pub fn kind(self, tcx: TyCtxt<'tcx>) -> ty::AliasKind {\n         match tcx.def_kind(self.def_id) {\n+            DefKind::AssocTy if let DefKind::Impl { of_trait: false } = tcx.def_kind(tcx.parent(self.def_id)) => ty::Inherent,\n             DefKind::AssocTy | DefKind::ImplTraitPlaceholder => ty::Projection,\n             DefKind::OpaqueTy => ty::Opaque,\n             kind => bug!(\"unexpected DefKind in AliasTy: {kind:?}\"),\n@@ -1236,6 +1241,17 @@ impl<'tcx> AliasTy<'tcx> {\n }\n \n /// The following methods work only with associated type projections.\n+impl<'tcx> AliasTy<'tcx> {\n+    pub fn self_ty(self) -> Ty<'tcx> {\n+        self.substs.type_at(0)\n+    }\n+\n+    pub fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self {\n+        tcx.mk_alias_ty(self.def_id, [self_ty.into()].into_iter().chain(self.substs.iter().skip(1)))\n+    }\n+}\n+\n+/// The following methods work only with trait associated type projections.\n impl<'tcx> AliasTy<'tcx> {\n     pub fn trait_def_id(self, tcx: TyCtxt<'tcx>) -> DefId {\n         match tcx.def_kind(self.def_id) {\n@@ -1274,13 +1290,28 @@ impl<'tcx> AliasTy<'tcx> {\n         let def_id = self.trait_def_id(tcx);\n         ty::TraitRef::new(tcx, def_id, self.substs.truncate_to(tcx, tcx.generics_of(def_id)))\n     }\n+}\n \n-    pub fn self_ty(self) -> Ty<'tcx> {\n-        self.substs.type_at(0)\n-    }\n+/// The following methods work only with inherent associated type projections.\n+impl<'tcx> AliasTy<'tcx> {\n+    /// Transform the substitutions to have the given `impl` substs as the base and the GAT substs on top of that.\n+    ///\n+    /// Does the following transformation:\n+    ///\n+    /// ```text\n+    /// [Self, P_0...P_m] -> [I_0...I_n, P_0...P_m]\n+    ///\n+    ///     I_i impl subst\n+    ///     P_j GAT subst\n+    /// ```\n+    pub fn rebase_substs_onto_impl(\n+        self,\n+        impl_substs: ty::SubstsRef<'tcx>,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> ty::SubstsRef<'tcx> {\n+        debug_assert_eq!(self.kind(tcx), ty::Inherent);\n \n-    pub fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self {\n-        tcx.mk_alias_ty(self.def_id, [self_ty.into()].into_iter().chain(self.substs.iter().skip(1)))\n+        tcx.mk_substs_from_iter(impl_substs.into_iter().chain(self.substs.into_iter().skip(1)))\n     }\n }\n "}, {"sha": "520bb55e031c70f366f8e6029eb37cc84c86b421", "filename": "compiler/rustc_middle/src/ty/visit.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -49,6 +49,9 @@ pub trait TypeVisitableExt<'tcx>: TypeVisitable<TyCtxt<'tcx>> {\n     fn has_projections(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_PROJECTION)\n     }\n+    fn has_inherent_projections(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_TY_INHERENT)\n+    }\n     fn has_opaque_types(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_TY_OPAQUE)\n     }"}, {"sha": "f27b8d9df1aa282bcfcc40dc832e3bea6b7b64a8", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -243,6 +243,39 @@ where\n                 // This will also visit substs if necessary, so we don't need to recurse.\n                 return self.visit_projection_ty(proj);\n             }\n+            ty::Alias(ty::Inherent, data) => {\n+                if self.def_id_visitor.skip_assoc_tys() {\n+                    // Visitors searching for minimal visibility/reachability want to\n+                    // conservatively approximate associated types like `Type::Alias`\n+                    // as visible/reachable even if `Type` is private.\n+                    // Ideally, associated types should be substituted in the same way as\n+                    // free type aliases, but this isn't done yet.\n+                    return ControlFlow::Continue(());\n+                }\n+\n+                self.def_id_visitor.visit_def_id(\n+                    data.def_id,\n+                    \"associated type\",\n+                    &LazyDefPathStr { def_id: data.def_id, tcx },\n+                )?;\n+\n+                struct LazyDefPathStr<'tcx> {\n+                    def_id: DefId,\n+                    tcx: TyCtxt<'tcx>,\n+                }\n+                impl<'tcx> fmt::Display for LazyDefPathStr<'tcx> {\n+                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                        write!(f, \"{}\", self.tcx.def_path_str(self.def_id))\n+                    }\n+                }\n+\n+                // This will also visit substs if necessary, so we don't need to recurse.\n+                return if self.def_id_visitor.shallow() {\n+                    ControlFlow::Continue(())\n+                } else {\n+                    data.substs.iter().try_for_each(|subst| subst.visit_with(self))\n+                };\n+            }\n             ty::Dynamic(predicates, ..) => {\n                 // All traits in the list are considered the \"primary\" part of the type\n                 // and are visited by shallow visitors."}, {"sha": "8fea3fc140d7296d6bb352a33d9bd11e6d3e530f", "filename": "compiler/rustc_trait_selection/messages.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_trait_selection%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_trait_selection%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fmessages.ftl?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -20,3 +20,5 @@ trait_selection_negative_positive_conflict = found both positive and negative im\n     .negative_implementation_in_crate = negative implementation in crate `{$negative_impl_cname}`\n     .positive_implementation_here = positive implementation here\n     .positive_implementation_in_crate = positive implementation in crate `{$positive_impl_cname}`\n+\n+trait_selection_inherent_projection_normalization_overflow = overflow evaluating associated type `{$ty}`"}, {"sha": "54e22cc3d7fe28635e2bf4115bd8f204fca2ac01", "filename": "compiler/rustc_trait_selection/src/errors.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_trait_selection%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_trait_selection%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ferrors.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -89,3 +89,11 @@ impl IntoDiagnostic<'_> for NegativePositiveConflict<'_> {\n         diag\n     }\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(trait_selection_inherent_projection_normalization_overflow)]\n+pub struct InherentProjectionNormalizationOverflow {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ty: String,\n+}"}, {"sha": "0ede32c753c6924ba22fa60e9d82c7a2d33abb47", "filename": "compiler/rustc_trait_selection/src/solve/assembly/structural_traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fstructural_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fstructural_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fstructural_traits.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -33,7 +33,7 @@ pub(in crate::solve) fn instantiate_constituent_tys_for_auto_trait<'tcx>(\n         ty::Dynamic(..)\n         | ty::Param(..)\n         | ty::Foreign(..)\n-        | ty::Alias(ty::Projection, ..)\n+        | ty::Alias(ty::Projection | ty::Inherent, ..)\n         | ty::Placeholder(..)\n         | ty::Bound(..)\n         | ty::Infer(_) => {"}, {"sha": "04b38edc1265fc783b1a6133623fef0b1a98d334", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -655,7 +655,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             ty::Dynamic(..)\n             | ty::Param(..)\n             | ty::Foreign(..)\n-            | ty::Alias(ty::Projection, ..)\n+            | ty::Alias(ty::Projection | ty::Inherent, ..)\n             | ty::Placeholder(..) => Some(Err(NoSolution)),\n \n             ty::Infer(_) | ty::Bound(_, _) => bug!(\"unexpected type `{self_ty}`\"),"}, {"sha": "402b09419c87784070d12d205b309c054526832f", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -673,7 +673,7 @@ impl<'tcx> TypeVisitor<TyCtxt<'tcx>> for OrphanChecker<'tcx> {\n             | ty::RawPtr(..)\n             | ty::Never\n             | ty::Tuple(..)\n-            | ty::Alias(ty::Projection, ..) => self.found_non_local_ty(ty),\n+            | ty::Alias(ty::Projection | ty::Inherent, ..) => self.found_non_local_ty(ty),\n \n             ty::Param(..) => self.found_param_ty(ty),\n "}, {"sha": "c9e2ed092d160b0cfd10d05f01eb1e3a808dd568", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -1687,13 +1687,14 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 ty::Tuple(..) => Some(10),\n                 ty::Param(..) => Some(11),\n                 ty::Alias(ty::Projection, ..) => Some(12),\n-                ty::Alias(ty::Opaque, ..) => Some(13),\n-                ty::Never => Some(14),\n-                ty::Adt(..) => Some(15),\n-                ty::Generator(..) => Some(16),\n-                ty::Foreign(..) => Some(17),\n-                ty::GeneratorWitness(..) => Some(18),\n-                ty::GeneratorWitnessMIR(..) => Some(19),\n+                ty::Alias(ty::Inherent, ..) => Some(13),\n+                ty::Alias(ty::Opaque, ..) => Some(14),\n+                ty::Never => Some(15),\n+                ty::Adt(..) => Some(16),\n+                ty::Generator(..) => Some(17),\n+                ty::Foreign(..) => Some(18),\n+                ty::GeneratorWitness(..) => Some(19),\n+                ty::GeneratorWitnessMIR(..) => Some(20),\n                 ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) | ty::Error(_) => None,\n             }\n         }"}, {"sha": "b162e5b8995db2f0e9ce4878442d4cbe60cfa056", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -49,7 +49,8 @@ pub use self::object_safety::astconv_object_safety_violations;\n pub use self::object_safety::is_vtable_safe_method;\n pub use self::object_safety::MethodViolationCode;\n pub use self::object_safety::ObjectSafetyViolation;\n-pub use self::project::{normalize_projection_type, NormalizeExt};\n+pub use self::project::NormalizeExt;\n+pub use self::project::{normalize_inherent_projection, normalize_projection_type};\n pub use self::select::{EvaluationCache, SelectionCache, SelectionContext};\n pub use self::select::{EvaluationResult, IntercrateAmbiguityCause, OverflowError};\n pub use self::specialize::specialization_graph::FutureCompatOverlapError;"}, {"sha": "8e684b7ac239b38ee3697a474ba605254af8e906", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 161, "deletions": 2, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -16,6 +16,7 @@ use super::{\n };\n use super::{Normalized, NormalizedTy, ProjectionCacheEntry, ProjectionCacheKey};\n \n+use crate::errors::InherentProjectionNormalizationOverflow;\n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n use crate::traits::error_reporting::TypeErrCtxtExt as _;\n@@ -370,10 +371,14 @@ pub(crate) fn needs_normalization<'tcx, T: TypeVisitable<TyCtxt<'tcx>>>(\n     reveal: Reveal,\n ) -> bool {\n     match reveal {\n-        Reveal::UserFacing => value\n-            .has_type_flags(ty::TypeFlags::HAS_TY_PROJECTION | ty::TypeFlags::HAS_CT_PROJECTION),\n+        Reveal::UserFacing => value.has_type_flags(\n+            ty::TypeFlags::HAS_TY_PROJECTION\n+                | ty::TypeFlags::HAS_TY_INHERENT\n+                | ty::TypeFlags::HAS_CT_PROJECTION,\n+        ),\n         Reveal::All => value.has_type_flags(\n             ty::TypeFlags::HAS_TY_PROJECTION\n+                | ty::TypeFlags::HAS_TY_INHERENT\n                 | ty::TypeFlags::HAS_TY_OPAQUE\n                 | ty::TypeFlags::HAS_CT_PROJECTION,\n         ),\n@@ -616,6 +621,51 @@ impl<'a, 'b, 'tcx> TypeFolder<TyCtxt<'tcx>> for AssocTypeNormalizer<'a, 'b, 'tcx\n                 );\n                 normalized_ty\n             }\n+\n+            ty::Inherent if !data.has_escaping_bound_vars() => {\n+                // This branch is *mostly* just an optimization: when we don't\n+                // have escaping bound vars, we don't need to replace them with\n+                // placeholders (see branch below). *Also*, we know that we can\n+                // register an obligation to *later* project, since we know\n+                // there won't be bound vars there.\n+\n+                let data = data.fold_with(self);\n+\n+                // FIXME(inherent_associated_types): Do we need to honor `self.eager_inference_replacement`\n+                // here like `ty::Projection`?\n+                normalize_inherent_projection(\n+                    self.selcx,\n+                    self.param_env,\n+                    data,\n+                    self.cause.clone(),\n+                    self.depth,\n+                    &mut self.obligations,\n+                )\n+            }\n+\n+            ty::Inherent => {\n+                let infcx = self.selcx.infcx;\n+                let (data, mapped_regions, mapped_types, mapped_consts) =\n+                    BoundVarReplacer::replace_bound_vars(infcx, &mut self.universes, data);\n+                let data = data.fold_with(self);\n+                let ty = normalize_inherent_projection(\n+                    self.selcx,\n+                    self.param_env,\n+                    data,\n+                    self.cause.clone(),\n+                    self.depth,\n+                    &mut self.obligations,\n+                );\n+\n+                PlaceholderReplacer::replace_placeholders(\n+                    infcx,\n+                    mapped_regions,\n+                    mapped_types,\n+                    mapped_consts,\n+                    &self.universes,\n+                    ty,\n+                )\n+            }\n         }\n     }\n \n@@ -1204,6 +1254,115 @@ fn normalize_to_error<'a, 'tcx>(\n     Normalized { value: new_value, obligations: vec![trait_obligation] }\n }\n \n+/// Confirm and normalize the given inherent projection.\n+#[instrument(level = \"debug\", skip(selcx, param_env, cause, obligations))]\n+pub fn normalize_inherent_projection<'a, 'b, 'tcx>(\n+    selcx: &'a mut SelectionContext<'b, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    alias_ty: ty::AliasTy<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    depth: usize,\n+    obligations: &mut Vec<PredicateObligation<'tcx>>,\n+) -> Ty<'tcx> {\n+    let tcx = selcx.tcx();\n+\n+    if !tcx.recursion_limit().value_within_limit(depth) {\n+        // Halt compilation because it is important that overflows never be masked.\n+        tcx.sess.emit_fatal(InherentProjectionNormalizationOverflow {\n+            span: cause.span,\n+            ty: alias_ty.to_string(),\n+        });\n+    }\n+\n+    let substs = compute_inherent_assoc_ty_substs(\n+        selcx,\n+        param_env,\n+        alias_ty,\n+        cause.clone(),\n+        depth,\n+        obligations,\n+    );\n+\n+    // Register the obligations arising from the impl and from the associated type itself.\n+    let predicates = tcx.predicates_of(alias_ty.def_id).instantiate(tcx, substs);\n+    for (predicate, span) in predicates {\n+        let predicate = normalize_with_depth_to(\n+            selcx,\n+            param_env,\n+            cause.clone(),\n+            depth + 1,\n+            predicate,\n+            obligations,\n+        );\n+\n+        let nested_cause = ObligationCause::new(\n+            cause.span,\n+            cause.body_id,\n+            // FIXME(inherent_associated_types): Since we can't pass along the self type to the\n+            // cause code, inherent projections will be printed with identity substitutions in\n+            // diagnostics which is not ideal.\n+            // Consider creating separate cause codes for this specific situation.\n+            if span.is_dummy() {\n+                super::ItemObligation(alias_ty.def_id)\n+            } else {\n+                super::BindingObligation(alias_ty.def_id, span)\n+            },\n+        );\n+\n+        obligations.push(Obligation::with_depth(\n+            tcx,\n+            nested_cause,\n+            depth + 1,\n+            param_env,\n+            predicate,\n+        ));\n+    }\n+\n+    let ty = tcx.type_of(alias_ty.def_id).subst(tcx, substs);\n+\n+    let mut ty = selcx.infcx.resolve_vars_if_possible(ty);\n+    if ty.has_projections() {\n+        ty = normalize_with_depth_to(selcx, param_env, cause.clone(), depth + 1, ty, obligations);\n+    }\n+\n+    ty\n+}\n+\n+pub fn compute_inherent_assoc_ty_substs<'a, 'b, 'tcx>(\n+    selcx: &'a mut SelectionContext<'b, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    alias_ty: ty::AliasTy<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    depth: usize,\n+    obligations: &mut Vec<PredicateObligation<'tcx>>,\n+) -> ty::SubstsRef<'tcx> {\n+    let tcx = selcx.tcx();\n+\n+    let impl_def_id = tcx.parent(alias_ty.def_id);\n+    let impl_substs = selcx.infcx.fresh_substs_for_item(cause.span, impl_def_id);\n+\n+    let impl_ty = tcx.type_of(impl_def_id).subst(tcx, impl_substs);\n+    let impl_ty =\n+        normalize_with_depth_to(selcx, param_env, cause.clone(), depth + 1, impl_ty, obligations);\n+\n+    // Infer the generic parameters of the impl by unifying the\n+    // impl type with the self type of the projection.\n+    let self_ty = alias_ty.self_ty();\n+    match selcx.infcx.at(&cause, param_env).eq(DefineOpaqueTypes::No, impl_ty, self_ty) {\n+        Ok(mut ok) => obligations.append(&mut ok.obligations),\n+        Err(_) => {\n+            tcx.sess.delay_span_bug(\n+                cause.span,\n+                format!(\n+                    \"{self_ty:?} was a subtype of {impl_ty:?} during selection but now it is not\"\n+                ),\n+            );\n+        }\n+    }\n+\n+    alias_ty.rebase_substs_onto_impl(impl_substs, tcx)\n+}\n+\n enum Projected<'tcx> {\n     Progress(Progress<'tcx>),\n     NoProgress(ty::Term<'tcx>),"}, {"sha": "8bf934cb78ae1545fdfaa28162541d208ab4d41e", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -257,11 +257,11 @@ impl<'cx, 'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for QueryNormalizer<'cx, 'tcx>\n \n             ty::Opaque => ty.try_super_fold_with(self)?,\n \n-            ty::Projection => {\n+            ty::Projection | ty::Inherent => {\n                 // See note in `rustc_trait_selection::traits::project`\n \n-                let tcx = self.infcx.tcx;\n                 let infcx = self.infcx;\n+                let tcx = infcx.tcx;\n                 // Just an optimization: When we don't have escaping bound vars,\n                 // we don't need to replace them with placeholders.\n                 let (data, maps) = if data.has_escaping_bound_vars() {\n@@ -276,12 +276,15 @@ impl<'cx, 'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for QueryNormalizer<'cx, 'tcx>\n                 let mut orig_values = OriginalQueryValues::default();\n                 // HACK(matthewjasper) `'static` is special-cased in selection,\n                 // so we cannot canonicalize it.\n-                let c_data = self\n-                    .infcx\n+                let c_data = infcx\n                     .canonicalize_query_keep_static(self.param_env.and(data), &mut orig_values);\n                 debug!(\"QueryNormalizer: c_data = {:#?}\", c_data);\n                 debug!(\"QueryNormalizer: orig_values = {:#?}\", orig_values);\n-                let result = tcx.normalize_projection_ty(c_data)?;\n+                let result = match kind {\n+                    ty::Projection => tcx.normalize_projection_ty(c_data),\n+                    ty::Inherent => tcx.normalize_inherent_projection_ty(c_data),\n+                    _ => unreachable!(),\n+                }?;\n                 // We don't expect ambiguity.\n                 if result.is_ambiguous() {\n                     // Rustdoc normalizes possibly not well-formed types, so only\n@@ -294,8 +297,8 @@ impl<'cx, 'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for QueryNormalizer<'cx, 'tcx>\n                     }\n                     return Err(NoSolution);\n                 }\n-                let InferOk { value: result, obligations } =\n-                    self.infcx.instantiate_query_response_and_region_obligations(\n+                let InferOk { value: result, obligations } = infcx\n+                    .instantiate_query_response_and_region_obligations(\n                         self.cause,\n                         self.param_env,\n                         &orig_values,"}, {"sha": "a8fb55df2d3029cf04a93a4fb143746e5300f9b9", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -498,7 +498,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     // this trait and type.\n                 }\n                 ty::Param(..)\n-                | ty::Alias(ty::Projection, ..)\n+                | ty::Alias(ty::Projection | ty::Inherent, ..)\n                 | ty::Placeholder(..)\n                 | ty::Bound(..) => {\n                     // In these cases, we don't know what the actual"}, {"sha": "616187b69dde4bd89cbb05cd00599f585212cddc", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -1268,7 +1268,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                 // If we have a projection type, make sure to normalize it so we replace it\n                 // with a fresh infer variable\n-                ty::Alias(ty::Projection, ..) => {\n+                ty::Alias(ty::Projection | ty::Inherent, ..) => {\n                     let predicate = normalize_with_depth_to(\n                         self,\n                         obligation.param_env,"}, {"sha": "e4f5a84f4244e1a8a02eefefd5cdd6d70106aa1f", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -2315,7 +2315,7 @@ impl<'tcx> SelectionContext<'_, 'tcx> {\n             | ty::Dynamic(..)\n             | ty::Param(..)\n             | ty::Foreign(..)\n-            | ty::Alias(ty::Projection, ..)\n+            | ty::Alias(ty::Projection | ty::Inherent, ..)\n             | ty::Bound(..)\n             | ty::Infer(ty::TyVar(_) | ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {\n                 bug!(\"asked to assemble constituent types of unexpected type: {:?}\", t);"}, {"sha": "086ab32b520076946de1e1efcd46cff83e66f8d8", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 57, "deletions": 29, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -58,15 +58,8 @@ pub fn obligations<'tcx>(\n         GenericArgKind::Lifetime(..) => return Some(Vec::new()),\n     };\n \n-    let mut wf = WfPredicates {\n-        tcx: infcx.tcx,\n-        param_env,\n-        body_id,\n-        span,\n-        out: vec![],\n-        recursion_depth,\n-        item: None,\n-    };\n+    let mut wf =\n+        WfPredicates { infcx, param_env, body_id, span, out: vec![], recursion_depth, item: None };\n     wf.compute(arg);\n     debug!(\"wf::obligations({:?}, body_id={:?}) = {:?}\", arg, body_id, wf.out);\n \n@@ -91,7 +84,7 @@ pub fn unnormalized_obligations<'tcx>(\n     debug_assert_eq!(arg, infcx.resolve_vars_if_possible(arg));\n \n     let mut wf = WfPredicates {\n-        tcx: infcx.tcx,\n+        infcx,\n         param_env,\n         body_id: CRATE_DEF_ID,\n         span: DUMMY_SP,\n@@ -116,7 +109,7 @@ pub fn trait_obligations<'tcx>(\n     item: &'tcx hir::Item<'tcx>,\n ) -> Vec<traits::PredicateObligation<'tcx>> {\n     let mut wf = WfPredicates {\n-        tcx: infcx.tcx,\n+        infcx,\n         param_env,\n         body_id,\n         span,\n@@ -138,7 +131,7 @@ pub fn predicate_obligations<'tcx>(\n     span: Span,\n ) -> Vec<traits::PredicateObligation<'tcx>> {\n     let mut wf = WfPredicates {\n-        tcx: infcx.tcx,\n+        infcx,\n         param_env,\n         body_id,\n         span,\n@@ -190,8 +183,8 @@ pub fn predicate_obligations<'tcx>(\n     wf.normalize(infcx)\n }\n \n-struct WfPredicates<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n+struct WfPredicates<'a, 'tcx> {\n+    infcx: &'a InferCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body_id: LocalDefId,\n     span: Span,\n@@ -290,9 +283,9 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n     }\n }\n \n-impl<'tcx> WfPredicates<'tcx> {\n+impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.tcx\n+        self.infcx.tcx\n     }\n \n     fn cause(&self, code: traits::ObligationCauseCode<'tcx>) -> traits::ObligationCause<'tcx> {\n@@ -325,7 +318,7 @@ impl<'tcx> WfPredicates<'tcx> {\n \n     /// Pushes the obligations required for `trait_ref` to be WF into `self.out`.\n     fn compute_trait_pred(&mut self, trait_pred: &ty::TraitPredicate<'tcx>, elaborate: Elaborate) {\n-        let tcx = self.tcx;\n+        let tcx = self.tcx();\n         let trait_ref = &trait_pred.trait_ref;\n \n         // Negative trait predicates don't require supertraits to hold, just\n@@ -369,7 +362,6 @@ impl<'tcx> WfPredicates<'tcx> {\n             self.out.extend(obligations);\n         }\n \n-        let tcx = self.tcx();\n         self.out.extend(\n             trait_ref\n                 .substs\n@@ -436,13 +428,45 @@ impl<'tcx> WfPredicates<'tcx> {\n         let obligations = self.nominal_obligations_without_const(data.def_id, data.substs);\n         self.out.extend(obligations);\n \n+        self.compute_projection_substs(data.substs);\n+    }\n+\n+    fn compute_inherent_projection(&mut self, data: ty::AliasTy<'tcx>) {\n+        // An inherent projection is well-formed if\n+        //\n+        // (a) its predicates hold (*)\n+        // (b) its substs are wf\n+        //\n+        // (*) The predicates of an inherent associated type include the\n+        //     predicates of the impl that it's contained in.\n+\n+        if !data.self_ty().has_escaping_bound_vars() {\n+            // FIXME(inherent_associated_types): Should this happen inside of a snapshot?\n+            // FIXME(inherent_associated_types): This is incompatible with the new solver and lazy norm!\n+            let substs = traits::project::compute_inherent_assoc_ty_substs(\n+                &mut traits::SelectionContext::new(self.infcx),\n+                self.param_env,\n+                data,\n+                self.cause(traits::WellFormed(None)),\n+                self.recursion_depth,\n+                &mut self.out,\n+            );\n+            // Inherent projection types do not require const predicates.\n+            let obligations = self.nominal_obligations_without_const(data.def_id, substs);\n+            self.out.extend(obligations);\n+        }\n+\n+        self.compute_projection_substs(data.substs);\n+    }\n+\n+    fn compute_projection_substs(&mut self, substs: SubstsRef<'tcx>) {\n         let tcx = self.tcx();\n         let cause = self.cause(traits::WellFormed(None));\n         let param_env = self.param_env;\n         let depth = self.recursion_depth;\n \n         self.out.extend(\n-            data.substs\n+            substs\n                 .iter()\n                 .filter(|arg| {\n                     matches!(arg.unpack(), GenericArgKind::Type(..) | GenericArgKind::Const(..))\n@@ -464,9 +488,9 @@ impl<'tcx> WfPredicates<'tcx> {\n         if !subty.has_escaping_bound_vars() {\n             let cause = self.cause(cause);\n             let trait_ref =\n-                ty::TraitRef::from_lang_item(self.tcx, LangItem::Sized, cause.span, [subty]);\n+                ty::TraitRef::from_lang_item(self.tcx(), LangItem::Sized, cause.span, [subty]);\n             self.out.push(traits::Obligation::with_depth(\n-                self.tcx,\n+                self.tcx(),\n                 cause,\n                 self.recursion_depth,\n                 self.param_env,\n@@ -605,6 +629,10 @@ impl<'tcx> WfPredicates<'tcx> {\n                     walker.skip_current_subtree(); // Subtree handled by compute_projection.\n                     self.compute_projection(data);\n                 }\n+                ty::Alias(ty::Inherent, data) => {\n+                    walker.skip_current_subtree(); // Subtree handled by compute_inherent_projection.\n+                    self.compute_inherent_projection(data);\n+                }\n \n                 ty::Adt(def, substs) => {\n                     // WfNominalType\n@@ -697,7 +725,7 @@ impl<'tcx> WfPredicates<'tcx> {\n                     // All of the requirements on type parameters\n                     // have already been checked for `impl Trait` in\n                     // return position. We do need to check type-alias-impl-trait though.\n-                    if self.tcx.is_type_alias_impl_trait(def_id) {\n+                    if self.tcx().is_type_alias_impl_trait(def_id) {\n                         let obligations = self.nominal_obligations(def_id, substs);\n                         self.out.extend(obligations);\n                     }\n@@ -767,15 +795,15 @@ impl<'tcx> WfPredicates<'tcx> {\n         substs: SubstsRef<'tcx>,\n         remap_constness: bool,\n     ) -> Vec<traits::PredicateObligation<'tcx>> {\n-        let predicates = self.tcx.predicates_of(def_id);\n+        let predicates = self.tcx().predicates_of(def_id);\n         let mut origins = vec![def_id; predicates.predicates.len()];\n         let mut head = predicates;\n         while let Some(parent) = head.parent {\n-            head = self.tcx.predicates_of(parent);\n+            head = self.tcx().predicates_of(parent);\n             origins.extend(iter::repeat(parent).take(head.predicates.len()));\n         }\n \n-        let predicates = predicates.instantiate(self.tcx, substs);\n+        let predicates = predicates.instantiate(self.tcx(), substs);\n         trace!(\"{:#?}\", predicates);\n         debug_assert_eq!(predicates.predicates.len(), origins.len());\n \n@@ -788,10 +816,10 @@ impl<'tcx> WfPredicates<'tcx> {\n                 };\n                 let cause = self.cause(code);\n                 if remap_constness {\n-                    pred = pred.without_const(self.tcx);\n+                    pred = pred.without_const(self.tcx());\n                 }\n                 traits::Obligation::with_depth(\n-                    self.tcx,\n+                    self.tcx(),\n                     cause,\n                     self.recursion_depth,\n                     self.param_env,\n@@ -856,7 +884,7 @@ impl<'tcx> WfPredicates<'tcx> {\n         // Note: in fact we only permit builtin traits, not `Bar<'d>`, I\n         // am looking forward to the future here.\n         if !data.has_escaping_bound_vars() && !region.has_escaping_bound_vars() {\n-            let implicit_bounds = object_region_bounds(self.tcx, data);\n+            let implicit_bounds = object_region_bounds(self.tcx(), data);\n \n             let explicit_bound = region;\n \n@@ -866,7 +894,7 @@ impl<'tcx> WfPredicates<'tcx> {\n                 let outlives =\n                     ty::Binder::dummy(ty::OutlivesPredicate(explicit_bound, implicit_bound));\n                 self.out.push(traits::Obligation::with_depth(\n-                    self.tcx,\n+                    self.tcx(),\n                     cause,\n                     self.recursion_depth,\n                     self.param_env,"}, {"sha": "2f9e480d8bd529dc1fff1892ba61e3859bf28296", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -372,6 +372,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n                     substitution: substs.lower_into(interner),\n                 }))\n             }\n+            ty::Alias(ty::Inherent, _) => unimplemented!(),\n             ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n                 chalk_ir::TyKind::Alias(chalk_ir::AliasTy::Opaque(chalk_ir::OpaqueTy {\n                     opaque_ty_id: chalk_ir::OpaqueTyId(def_id),"}, {"sha": "36d80a06ee7e9edc13c4cf94bfa3fc8f2121f6ca", "filename": "compiler/rustc_traits/src/normalize_projection_ty.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_traits%2Fsrc%2Fnormalize_projection_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_traits%2Fsrc%2Fnormalize_projection_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_projection_ty.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -10,7 +10,7 @@ use rustc_trait_selection::traits::{self, ObligationCause, SelectionContext};\n use std::sync::atomic::Ordering;\n \n pub(crate) fn provide(p: &mut Providers) {\n-    *p = Providers { normalize_projection_ty, ..*p };\n+    *p = Providers { normalize_projection_ty, normalize_inherent_projection_ty, ..*p };\n }\n \n fn normalize_projection_ty<'tcx>(\n@@ -42,3 +42,30 @@ fn normalize_projection_ty<'tcx>(\n         },\n     )\n }\n+\n+fn normalize_inherent_projection_ty<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    goal: CanonicalProjectionGoal<'tcx>,\n+) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, NormalizationResult<'tcx>>>, NoSolution> {\n+    debug!(\"normalize_provider(goal={:#?})\", goal);\n+\n+    tcx.infer_ctxt().enter_canonical_trait_query(\n+        &goal,\n+        |ocx, ParamEnvAnd { param_env, value: goal }| {\n+            let selcx = &mut SelectionContext::new(ocx.infcx);\n+            let cause = ObligationCause::dummy();\n+            let mut obligations = vec![];\n+            let answer = traits::normalize_inherent_projection(\n+                selcx,\n+                param_env,\n+                goal,\n+                cause,\n+                0,\n+                &mut obligations,\n+            );\n+            ocx.register_obligations(obligations);\n+\n+            Ok(NormalizationResult { normalized_ty: answer })\n+        },\n+    )\n+}"}, {"sha": "7e5a4d1c735324cccdabcd7ad5c4012820e90b72", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -229,50 +229,53 @@ bitflags! {\n \n         /// Does this have `Projection`?\n         const HAS_TY_PROJECTION           = 1 << 10;\n+        /// Does this have `Inherent`?\n+        const HAS_TY_INHERENT             = 1 << 11;\n         /// Does this have `Opaque`?\n-        const HAS_TY_OPAQUE               = 1 << 11;\n+        const HAS_TY_OPAQUE               = 1 << 12;\n         /// Does this have `ConstKind::Unevaluated`?\n-        const HAS_CT_PROJECTION           = 1 << 12;\n+        const HAS_CT_PROJECTION           = 1 << 13;\n \n         /// Could this type be normalized further?\n         const HAS_PROJECTION              = TypeFlags::HAS_TY_PROJECTION.bits\n                                           | TypeFlags::HAS_TY_OPAQUE.bits\n+                                          | TypeFlags::HAS_TY_INHERENT.bits\n                                           | TypeFlags::HAS_CT_PROJECTION.bits;\n \n         /// Is an error type/const reachable?\n-        const HAS_ERROR                   = 1 << 13;\n+        const HAS_ERROR                   = 1 << 14;\n \n         /// Does this have any region that \"appears free\" in the type?\n         /// Basically anything but `ReLateBound` and `ReErased`.\n-        const HAS_FREE_REGIONS            = 1 << 14;\n+        const HAS_FREE_REGIONS            = 1 << 15;\n \n         /// Does this have any `ReLateBound` regions?\n-        const HAS_RE_LATE_BOUND           = 1 << 15;\n+        const HAS_RE_LATE_BOUND           = 1 << 16;\n         /// Does this have any `Bound` types?\n-        const HAS_TY_LATE_BOUND           = 1 << 16;\n+        const HAS_TY_LATE_BOUND           = 1 << 17;\n         /// Does this have any `ConstKind::Bound` consts?\n-        const HAS_CT_LATE_BOUND           = 1 << 17;\n+        const HAS_CT_LATE_BOUND           = 1 << 18;\n         /// Does this have any bound variables?\n         /// Used to check if a global bound is safe to evaluate.\n         const HAS_LATE_BOUND              = TypeFlags::HAS_RE_LATE_BOUND.bits\n                                           | TypeFlags::HAS_TY_LATE_BOUND.bits\n                                           | TypeFlags::HAS_CT_LATE_BOUND.bits;\n \n         /// Does this have any `ReErased` regions?\n-        const HAS_RE_ERASED               = 1 << 18;\n+        const HAS_RE_ERASED               = 1 << 19;\n \n         /// Does this value have parameters/placeholders/inference variables which could be\n         /// replaced later, in a way that would change the results of `impl` specialization?\n-        const STILL_FURTHER_SPECIALIZABLE = 1 << 19;\n+        const STILL_FURTHER_SPECIALIZABLE = 1 << 20;\n \n         /// Does this value have `InferTy::FreshTy/FreshIntTy/FreshFloatTy`?\n-        const HAS_TY_FRESH                = 1 << 20;\n+        const HAS_TY_FRESH                = 1 << 21;\n \n         /// Does this value have `InferConst::Fresh`?\n-        const HAS_CT_FRESH                = 1 << 21;\n+        const HAS_CT_FRESH                = 1 << 22;\n \n         /// Does this have `Generator` or `GeneratorWitness`?\n-        const HAS_TY_GENERATOR            = 1 << 22;\n+        const HAS_TY_GENERATOR            = 1 << 23;\n     }\n }\n "}, {"sha": "f7344bacc028cfabde19ed343575dc54a9020616", "filename": "compiler/rustc_type_ir/src/sty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -37,6 +37,7 @@ pub enum DynKind {\n #[derive(Encodable, Decodable, HashStable_Generic)]\n pub enum AliasKind {\n     Projection,\n+    Inherent,\n     Opaque,\n }\n "}, {"sha": "baf2b0a8585297e1654dbf08112eb83fad7c0868", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -556,7 +556,10 @@ where\n                 WherePredicate::EqPredicate { lhs, rhs, bound_params } => {\n                     match *lhs {\n                         Type::QPath(box QPathData {\n-                            ref assoc, ref self_type, ref trait_, ..\n+                            ref assoc,\n+                            ref self_type,\n+                            trait_: Some(ref trait_),\n+                            ..\n                         }) => {\n                             let ty = &*self_type;\n                             let mut new_trait = trait_.clone();"}, {"sha": "c852f9cca2bfde764fd4086449cdf143d5fe89a5", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -706,7 +706,12 @@ fn filter_non_trait_generics(trait_did: DefId, mut g: clean::Generics) -> clean:\n \n     g.where_predicates.retain(|pred| match pred {\n         clean::WherePredicate::BoundPredicate {\n-            ty: clean::QPath(box clean::QPathData { self_type: clean::Generic(ref s), trait_, .. }),\n+            ty:\n+                clean::QPath(box clean::QPathData {\n+                    self_type: clean::Generic(ref s),\n+                    trait_: Some(trait_),\n+                    ..\n+                }),\n             bounds,\n             ..\n         } => !(bounds.is_empty() || *s == kw::SelfUpper && trait_.def_id() == trait_did),"}, {"sha": "657f3c9ec4577fc598a237069a727de4cec02873", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 46, "deletions": 12, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -441,7 +441,7 @@ fn clean_projection<'tcx>(\n         assoc: projection_to_path_segment(ty, cx),\n         should_show_cast,\n         self_type,\n-        trait_,\n+        trait_: Some(trait_),\n     }))\n }\n \n@@ -1330,7 +1330,13 @@ pub(crate) fn clean_middle_assoc_item<'tcx>(\n                 let mut bounds: Vec<GenericBound> = Vec::new();\n                 generics.where_predicates.retain_mut(|pred| match *pred {\n                     WherePredicate::BoundPredicate {\n-                        ty: QPath(box QPathData { ref assoc, ref self_type, ref trait_, .. }),\n+                        ty:\n+                            QPath(box QPathData {\n+                                ref assoc,\n+                                ref self_type,\n+                                trait_: Some(ref trait_),\n+                                ..\n+                            }),\n                         bounds: ref mut pred_bounds,\n                         ..\n                     } => {\n@@ -1492,25 +1498,30 @@ fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type\n                 assoc: clean_path_segment(p.segments.last().expect(\"segments were empty\"), cx),\n                 should_show_cast,\n                 self_type,\n-                trait_,\n+                trait_: Some(trait_),\n             }))\n         }\n         hir::QPath::TypeRelative(qself, segment) => {\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n-            let res = match ty.kind() {\n+            let self_type = clean_ty(qself, cx);\n+\n+            let (trait_, should_show_cast) = match ty.kind() {\n                 ty::Alias(ty::Projection, proj) => {\n-                    Res::Def(DefKind::Trait, proj.trait_ref(cx.tcx).def_id)\n+                    let res = Res::Def(DefKind::Trait, proj.trait_ref(cx.tcx).def_id);\n+                    let trait_ = clean_path(&hir::Path { span, res, segments: &[] }, cx);\n+                    register_res(cx, trait_.res);\n+                    let self_def_id = res.opt_def_id();\n+                    let should_show_cast =\n+                        compute_should_show_cast(self_def_id, &trait_, &self_type);\n+\n+                    (Some(trait_), should_show_cast)\n                 }\n+                ty::Alias(ty::Inherent, _) => (None, false),\n                 // Rustdoc handles `ty::Error`s by turning them into `Type::Infer`s.\n                 ty::Error(_) => return Type::Infer,\n-                // Otherwise, this is an inherent associated type.\n-                _ => return clean_middle_ty(ty::Binder::dummy(ty), cx, None),\n+                _ => bug!(\"clean: expected associated type, found `{ty:?}`\"),\n             };\n-            let trait_ = clean_path(&hir::Path { span, res, segments: &[] }, cx);\n-            register_res(cx, trait_.res);\n-            let self_def_id = res.opt_def_id();\n-            let self_type = clean_ty(qself, cx);\n-            let should_show_cast = compute_should_show_cast(self_def_id, &trait_, &self_type);\n+\n             Type::QPath(Box::new(QPathData {\n                 assoc: clean_path_segment(segment, cx),\n                 should_show_cast,\n@@ -1836,6 +1847,29 @@ pub(crate) fn clean_middle_ty<'tcx>(\n             clean_projection(bound_ty.rebind(*data), cx, parent_def_id)\n         }\n \n+        ty::Alias(ty::Inherent, alias_ty) => {\n+            let alias_ty = bound_ty.rebind(alias_ty);\n+            let self_type = clean_middle_ty(alias_ty.map_bound(|ty| ty.self_ty()), cx, None);\n+\n+            Type::QPath(Box::new(QPathData {\n+                assoc: PathSegment {\n+                    name: cx.tcx.associated_item(alias_ty.skip_binder().def_id).name,\n+                    args: GenericArgs::AngleBracketed {\n+                        args: substs_to_args(\n+                            cx,\n+                            alias_ty.map_bound(|ty| ty.substs.as_slice()),\n+                            true,\n+                        )\n+                        .into(),\n+                        bindings: Default::default(),\n+                    },\n+                },\n+                should_show_cast: false,\n+                self_type,\n+                trait_: None,\n+            }))\n+        }\n+\n         ty::Param(ref p) => {\n             if let Some(bounds) = cx.impl_trait_bounds.remove(&p.index.into()) {\n                 ImplTrait(bounds)"}, {"sha": "38664c3e359a6b5fc44260599db35812cadd8599", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -1660,7 +1660,7 @@ impl Type {\n \n     pub(crate) fn projection(&self) -> Option<(&Type, DefId, PathSegment)> {\n         if let QPath(box QPathData { self_type, trait_, assoc, .. }) = self {\n-            Some((self_type, trait_.def_id(), assoc.clone()))\n+            Some((self_type, trait_.as_ref()?.def_id(), assoc.clone()))\n         } else {\n             None\n         }\n@@ -1704,7 +1704,7 @@ pub(crate) struct QPathData {\n     pub self_type: Type,\n     /// FIXME: compute this field on demand.\n     pub should_show_cast: bool,\n-    pub trait_: Path,\n+    pub trait_: Option<Path>,\n }\n \n /// A primitive (aka, builtin) type."}, {"sha": "d963d6092c48f5b201fbc985ded3e589f7698916", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 35, "deletions": 11, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -1116,14 +1116,17 @@ fn fmt_type<'cx>(\n             ref trait_,\n             should_show_cast,\n         }) => {\n+            // FIXME(inherent_associated_types): Once we support non-ADT self-types (#106719),\n+            // we need to surround them with angle brackets in some cases (e.g. `<dyn \u2026>::P`).\n+\n             if f.alternate() {\n-                if should_show_cast {\n+                if let Some(trait_) = trait_ && should_show_cast {\n                     write!(f, \"<{:#} as {:#}>::\", self_type.print(cx), trait_.print(cx))?\n                 } else {\n                     write!(f, \"{:#}::\", self_type.print(cx))?\n                 }\n             } else {\n-                if should_show_cast {\n+                if let Some(trait_) = trait_ && should_show_cast {\n                     write!(f, \"&lt;{} as {}&gt;::\", self_type.print(cx), trait_.print(cx))?\n                 } else {\n                     write!(f, \"{}::\", self_type.print(cx))?\n@@ -1139,15 +1142,36 @@ fn fmt_type<'cx>(\n             //        the ugliness comes from inlining across crates where\n             //        everything comes in as a fully resolved QPath (hard to\n             //        look at).\n-            if !f.alternate() && let Ok((url, _, path)) = href(trait_.def_id(), cx) {\n-                write!(\n-                    f,\n-                    \"<a class=\\\"associatedtype\\\" href=\\\"{url}#{shortty}.{name}\\\" \\\n-                                title=\\\"type {path}::{name}\\\">{name}</a>\",\n-                    shortty = ItemType::AssocType,\n-                    name = assoc.name,\n-                    path = join_with_double_colon(&path),\n-                )\n+            if !f.alternate() {\n+                // FIXME(inherent_associated_types): We always link to the very first associated\n+                // type (in respect to source order) that bears the given name (`assoc.name`) and that is\n+                // affiliated with the computed `DefId`. This is obviously incorrect when we have\n+                // multiple impl blocks. Ideally, we would thread the `DefId` of the assoc ty itself\n+                // through here and map it to the corresponding HTML ID that was generated by\n+                // `render::Context::derive_id` when the impl blocks were rendered.\n+                // There is no such mapping unfortunately.\n+                // As a hack, we could badly imitate `derive_id` here by keeping *count* when looking\n+                // for the assoc ty `DefId` in `tcx.associated_items(self_ty_did).in_definition_order()`\n+                // considering privacy, `doc(hidden)`, etc.\n+                // I don't feel like that right now :cold_sweat:.\n+\n+                let parent_href = match trait_ {\n+                    Some(trait_) => href(trait_.def_id(), cx).ok(),\n+                    None => self_type.def_id(cx.cache()).and_then(|did| href(did, cx).ok()),\n+                };\n+\n+                if let Some((url, _, path)) = parent_href {\n+                    write!(\n+                        f,\n+                        \"<a class=\\\"associatedtype\\\" href=\\\"{url}#{shortty}.{name}\\\" \\\n+                                    title=\\\"type {path}::{name}\\\">{name}</a>\",\n+                        shortty = ItemType::AssocType,\n+                        name = assoc.name,\n+                        path = join_with_double_colon(&path),\n+                    )\n+                } else {\n+                    write!(f, \"{}\", assoc.name)\n+                }\n             } else {\n                 write!(f, \"{}\", assoc.name)\n             }?;"}, {"sha": "d6773169639c37e51b87d060a4d009e5678eb732", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -2202,7 +2202,9 @@ fn collect_paths_for_type(first_ty: clean::Type, cache: &Cache) -> Vec<String> {\n             }\n             clean::Type::QPath(box clean::QPathData { self_type, trait_, .. }) => {\n                 work.push_back(self_type);\n-                process_path(trait_.def_id());\n+                if let Some(trait_) = trait_ {\n+                    process_path(trait_.def_id());\n+                }\n             }\n             _ => {}\n         }"}, {"sha": "b1cef20b434a650d1e7235dbf8fbd702d0cb264e", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -574,7 +574,7 @@ impl FromWithTcx<clean::Type> for Type {\n                 name: assoc.name.to_string(),\n                 args: Box::new(assoc.args.into_tcx(tcx)),\n                 self_type: Box::new(self_type.into_tcx(tcx)),\n-                trait_: trait_.into_tcx(tcx),\n+                trait_: trait_.map(|trait_| trait_.into_tcx(tcx)),\n             },\n         }\n     }"}, {"sha": "3556834071fc964272e902fbdf3d706b5780cdad", "filename": "src/rustdoc-json-types/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/src%2Frustdoc-json-types%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/src%2Frustdoc-json-types%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc-json-types%2Flib.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -8,7 +8,7 @@ use serde::{Deserialize, Serialize};\n use std::path::PathBuf;\n \n /// rustdoc format-version.\n-pub const FORMAT_VERSION: u32 = 24;\n+pub const FORMAT_VERSION: u32 = 25;\n \n /// A `Crate` is the root of the emitted JSON blob. It contains all type/documentation information\n /// about the language items in the local crate, as well as info about external items to allow\n@@ -581,13 +581,15 @@ pub enum Type {\n         #[serde(rename = \"type\")]\n         type_: Box<Type>,\n     },\n-    /// `<Type as Trait>::Name` or associated types like `T::Item` where `T: Iterator`\n+    /// Associated types like `<Type as Trait>::Name` and `T::Item` where\n+    /// `T: Iterator` or inherent associated types like `Struct::Name`.\n     QualifiedPath {\n         name: String,\n         args: Box<GenericArgs>,\n         self_type: Box<Type>,\n+        /// `None` iff this is an *inherent* associated type.\n         #[serde(rename = \"trait\")]\n-        trait_: Path,\n+        trait_: Option<Path>,\n     },\n }\n "}, {"sha": "b27ffe73ffda442d153333d8a92bcd5b1e91de1f", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -1424,6 +1424,7 @@ fn ty_auto_deref_stability<'tcx>(\n                 continue;\n             },\n             ty::Param(_) => TyPosition::new_deref_stable_for_result(precedence, ty),\n+            ty::Alias(ty::Inherent, _) => unreachable!(\"inherent projection should have been normalized away above\"),\n             ty::Alias(ty::Projection, _) if ty.has_non_region_param() => {\n                 TyPosition::new_deref_stable_for_result(precedence, ty)\n             },"}, {"sha": "bf8a64acf08d69237d717d1745085a0f2f8e7cb2", "filename": "src/tools/jsondoclint/src/validator.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -273,7 +273,9 @@ impl<'a> Validator<'a> {\n             Type::QualifiedPath { name: _, args, self_type, trait_ } => {\n                 self.check_generic_args(&**args);\n                 self.check_type(&**self_type);\n-                self.check_path(trait_, PathKind::Trait);\n+                if let Some(trait_) = trait_ {\n+                    self.check_path(trait_, PathKind::Trait);\n+                }\n             }\n         }\n     }"}, {"sha": "9bda0acaf83fe7808a3e00eac2b1f1679278c99f", "filename": "tests/rustdoc/inherent-projections.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Frustdoc%2Finherent-projections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Frustdoc%2Finherent-projections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Finherent-projections.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,44 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+// @has 'inherent_projections/fn.create.html'\n+// @has - '//pre[@class=\"rust item-decl\"]' \"create() -> Owner::Metadata\"\n+// @has - '//pre[@class=\"rust item-decl\"]//a[@class=\"associatedtype\"]/@href' 'struct.Owner.html#associatedtype.Metadata'\n+pub fn create() -> Owner::Metadata {}\n+\n+pub struct Owner;\n+\n+impl Owner {\n+    pub type Metadata = ();\n+}\n+\n+// Make sure we handle bound vars correctly.\n+// @has 'inherent_projections/type.User.html' '//pre[@class=\"rust item-decl\"]' \"for<'a> fn(_: Carrier<'a>::Focus)\"\n+pub type User = for<'a> fn(Carrier<'a>::Focus);\n+\n+pub struct Carrier<'a>(&'a ());\n+\n+impl<'a> Carrier<'a> {\n+    pub type Focus = &'a mut i32;\n+}\n+\n+////////////////////////////////////////\n+\n+// FIXME(inherent_associated_types): Below we link to `Proj` but we should link to `Proj-1`.\n+// The current test checks for the buggy behavior for demonstration purposes.\n+\n+// @has 'inherent_projections/type.Test.html'\n+// @has - '//pre[@class=\"rust item-decl\"]' \"Parametrized<i32>\"\n+// @has - '//pre[@class=\"rust item-decl\"]//a[@class=\"associatedtype\"]/@href' 'struct.Parametrized.html#associatedtype.Proj'\n+// @!has - '//pre[@class=\"rust item-decl\"]//a[@class=\"associatedtype\"]/@href' 'struct.Parametrized.html#associatedtype.Proj-1'\n+pub type Test = Parametrized<i32>::Proj;\n+\n+pub struct Parametrized<T>(T);\n+\n+impl Parametrized<bool> {\n+    pub type Proj = ();\n+}\n+\n+impl Parametrized<i32> {\n+    pub type Proj = String;\n+}"}, {"sha": "2b28d2ae60bd4c45de72448f70c73c260062049b", "filename": "tests/rustdoc/intra-doc/inherent-associated-types.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Frustdoc%2Fintra-doc%2Finherent-associated-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Frustdoc%2Fintra-doc%2Finherent-associated-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fintra-doc%2Finherent-associated-types.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,45 @@\n+#![feature(inherent_associated_types)]\n+\n+#![allow(incomplete_features)]\n+#![deny(rustdoc::broken_intra_doc_links)]\n+\n+// @has inherent_associated_types/index.html\n+\n+// @has - '//a/@href' 'enum.Simple.html#associatedtype.Type'\n+//! [`Simple::Type`]\n+\n+pub enum Simple {}\n+\n+impl Simple {\n+    pub type Type = ();\n+}\n+\n+////////////////////////////////////////\n+\n+// @has 'inherent_associated_types/type.Test0.html' '//a/@href' \\\n+//          'struct.Parametrized.html#associatedtype.Proj'\n+/// [`Parametrized<bool>::Proj`]\n+pub type Test0 = ();\n+\n+// FIXME(inherent_associated_types): The intra-doc link below should point to `Proj-1` not `Proj`.\n+// The current test checks for the buggy behavior for demonstration purposes.\n+// The same bug happens for inherent associated functions and constants (see #85960, #93398).\n+//\n+// Further, at some point we should reject the intra-doc link `Parametrized::Proj`.\n+// It currently links to `Parametrized<bool>::Proj`.\n+\n+// @has 'inherent_associated_types/type.Test1.html'\n+// @has - '//a/@href' 'struct.Parametrized.html#associatedtype.Proj'\n+// @!has - '//a/@href' 'struct.Parametrized.html#associatedtype.Proj-1'\n+/// [`Parametrized<i32>::Proj`]\n+pub type Test1 = ();\n+\n+pub struct Parametrized<T>(T);\n+\n+impl Parametrized<bool> {\n+    pub type Proj = ();\n+}\n+\n+impl Parametrized<i32> {\n+    pub type Proj = String;\n+}"}, {"sha": "f41574403d88766c4d6fdc6af2ef8ee6bb43f4f3", "filename": "tests/ui/associated-inherent-types/bugs/cycle-iat-inside-of-adt.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-adt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-adt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-adt.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,10 @@\n+// known-bug: #108491\n+\n+// FIXME(inherent_associated_types): This should pass.\n+\n+struct Foo {\n+    bar: Self::Bar,\n+}\n+impl Foo {\n+    pub type Bar = usize;\n+}"}, {"sha": "f313c4946714cebbac02e699ca5e2d893b74456f", "filename": "tests/ui/associated-inherent-types/bugs/cycle-iat-inside-of-adt.stderr", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-adt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-adt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-adt.stderr?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,49 @@\n+error[E0601]: `main` function not found in crate `cycle_iat_inside_of_adt`\n+  --> $DIR/cycle-iat-inside-of-adt.rs:10:2\n+   |\n+LL | }\n+   |  ^ consider adding a `main` function to `$DIR/cycle-iat-inside-of-adt.rs`\n+\n+error[E0391]: cycle detected when computing predicates of `Foo`\n+  --> $DIR/cycle-iat-inside-of-adt.rs:5:1\n+   |\n+LL | struct Foo {\n+   | ^^^^^^^^^^\n+   |\n+note: ...which requires computing predicates of `Foo`...\n+  --> $DIR/cycle-iat-inside-of-adt.rs:5:1\n+   |\n+LL | struct Foo {\n+   | ^^^^^^^^^^\n+note: ...which requires computing inferred outlives predicates of `Foo`...\n+  --> $DIR/cycle-iat-inside-of-adt.rs:5:1\n+   |\n+LL | struct Foo {\n+   | ^^^^^^^^^^\n+   = note: ...which requires computing the inferred outlives predicates for items in this crate...\n+note: ...which requires computing type of `Foo::bar`...\n+  --> $DIR/cycle-iat-inside-of-adt.rs:6:5\n+   |\n+LL |     bar: Self::Bar,\n+   |     ^^^^^^^^^^^^^^\n+note: ...which requires computing normalized predicates of `Foo`...\n+  --> $DIR/cycle-iat-inside-of-adt.rs:5:1\n+   |\n+LL | struct Foo {\n+   | ^^^^^^^^^^\n+   = note: ...which again requires computing predicates of `Foo`, completing the cycle\n+note: cycle used when collecting item types in top-level module\n+  --> $DIR/cycle-iat-inside-of-adt.rs:5:1\n+   |\n+LL | / struct Foo {\n+LL | |     bar: Self::Bar,\n+LL | | }\n+LL | | impl Foo {\n+LL | |     pub type Bar = usize;\n+LL | | }\n+   | |_^\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0391, E0601.\n+For more information about an error, try `rustc --explain E0391`."}, {"sha": "0c2a38b1173d9cdf5e2ce02d227ab9952441ff7a", "filename": "tests/ui/associated-inherent-types/bugs/cycle-iat-inside-of-where-predicate.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-where-predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-where-predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-where-predicate.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,16 @@\n+// known-bug: unknown\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+// FIXME(inherent_associated_types): This shouldn't lead to a cycle error.\n+\n+fn user<T>() where S<T>::P: std::fmt::Debug {}\n+\n+struct S<T>;\n+\n+impl<T: Copy> S<T> {\n+    type P = ();\n+}\n+\n+fn main() {}"}, {"sha": "aaa9a39ea0f4a1d45bdddf2249d63e7e0bd44d94", "filename": "tests/ui/associated-inherent-types/bugs/cycle-iat-inside-of-where-predicate.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-where-predicate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-where-predicate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-where-predicate.stderr?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,37 @@\n+error[E0391]: cycle detected when computing predicates of `user`\n+  --> $DIR/cycle-iat-inside-of-where-predicate.rs:8:1\n+   |\n+LL | fn user<T>() where S<T>::P: std::fmt::Debug {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: ...which requires computing predicates of `user`...\n+  --> $DIR/cycle-iat-inside-of-where-predicate.rs:8:1\n+   |\n+LL | fn user<T>() where S<T>::P: std::fmt::Debug {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires computing explicit predicates of `user`...\n+  --> $DIR/cycle-iat-inside-of-where-predicate.rs:8:1\n+   |\n+LL | fn user<T>() where S<T>::P: std::fmt::Debug {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires computing normalized predicates of `user`...\n+  --> $DIR/cycle-iat-inside-of-where-predicate.rs:8:1\n+   |\n+LL | fn user<T>() where S<T>::P: std::fmt::Debug {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...which again requires computing predicates of `user`, completing the cycle\n+note: cycle used when collecting item types in top-level module\n+  --> $DIR/cycle-iat-inside-of-where-predicate.rs:3:1\n+   |\n+LL | / #![feature(inherent_associated_types)]\n+LL | | #![allow(incomplete_features)]\n+LL | |\n+LL | | // FIXME(inherent_associated_types): This shouldn't lead to a cycle error.\n+...  |\n+LL | |\n+LL | | fn main() {}\n+   | |____________^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0391`."}, {"sha": "53ac79e0561baee45614c02ff575e52b27855a20", "filename": "tests/ui/associated-inherent-types/bugs/ice-substitution.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fcb275f85e0e64bf3bb488cbd518bb085040c0cf/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fice-substitution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcb275f85e0e64bf3bb488cbd518bb085040c0cf/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fice-substitution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fice-substitution.rs?ref=fcb275f85e0e64bf3bb488cbd518bb085040c0cf", "patch": "@@ -1,23 +0,0 @@\n-// known-bug: unknown\n-// failure-status: 101\n-// normalize-stderr-test \"note: .*\\n\\n\" -> \"\"\n-// normalize-stderr-test \"thread 'rustc' panicked.*\\n\" -> \"\"\n-// rustc-env:RUST_BACKTRACE=0\n-\n-// FIXME: I presume a type variable that couldn't be solved by `resolve_vars_if_possible`\n-//        escapes the InferCtxt snapshot.\n-\n-#![feature(inherent_associated_types)]\n-#![allow(incomplete_features)]\n-\n-struct Cont<T>(T);\n-\n-impl<T: Copy> Cont<T> {\n-    type Out = Vec<T>;\n-}\n-\n-pub fn weird<T: Copy>(x: T) {\n-    let _: Cont<_>::Out = vec![true];\n-}\n-\n-fn main() {}"}, {"sha": "1648cfb266b5652fc23c0e125b92378215f854c8", "filename": "tests/ui/associated-inherent-types/bugs/ice-substitution.stderr", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fcb275f85e0e64bf3bb488cbd518bb085040c0cf/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fice-substitution.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fcb275f85e0e64bf3bb488cbd518bb085040c0cf/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fice-substitution.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fice-substitution.stderr?ref=fcb275f85e0e64bf3bb488cbd518bb085040c0cf", "patch": "@@ -1,6 +0,0 @@\n-error: the compiler unexpectedly panicked. this is a bug.\n-\n-query stack during panic:\n-#0 [typeck] type-checking `weird`\n-#1 [used_trait_imports] finding used_trait_imports `weird`\n-end of query stack"}, {"sha": "a920b412b1a492a9840b0c588299bed9d0838926", "filename": "tests/ui/associated-inherent-types/bugs/inference-fail.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fcb275f85e0e64bf3bb488cbd518bb085040c0cf/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Finference-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcb275f85e0e64bf3bb488cbd518bb085040c0cf/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Finference-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Finference-fail.rs?ref=fcb275f85e0e64bf3bb488cbd518bb085040c0cf", "patch": "@@ -1,15 +0,0 @@\n-// known-bug: unknown\n-\n-#![feature(inherent_associated_types)]\n-#![allow(incomplete_features)]\n-\n-struct S<T>(T);\n-\n-impl S<()> {\n-    type P = i128;\n-}\n-\n-fn main() {\n-    // We fail to infer `_ == ()` here.\n-    let _: S<_>::P;\n-}"}, {"sha": "632dbf3854b2b7b0eb5f09225f4be7c938abb462", "filename": "tests/ui/associated-inherent-types/bugs/lack-of-regionck.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fcb275f85e0e64bf3bb488cbd518bb085040c0cf/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Flack-of-regionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcb275f85e0e64bf3bb488cbd518bb085040c0cf/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Flack-of-regionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Flack-of-regionck.rs?ref=fcb275f85e0e64bf3bb488cbd518bb085040c0cf", "patch": "@@ -1,19 +0,0 @@\n-// known-bug: unknown\n-// check-pass\n-\n-// We currently don't region-check inherent associated type projections at all.\n-\n-#![feature(inherent_associated_types)]\n-#![allow(incomplete_features, dead_code)]\n-\n-struct S<T>(T);\n-\n-impl S<&'static ()> {\n-    type T = ();\n-}\n-\n-fn usr<'a>() {\n-    let _: S::<&'a ()>::T; // this should *fail* but it doesn't!\n-}\n-\n-fn main() {}"}, {"sha": "c7f66e645bb577a59783da59bab4a750d71f1afb", "filename": "tests/ui/associated-inherent-types/bugs/wf-check-skipped.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fwf-check-skipped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fwf-check-skipped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fwf-check-skipped.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,15 @@\n+// known-bug: #100041\n+// check-pass\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+// FIXME(inherent_associated_types): This should fail.\n+\n+struct Foo;\n+\n+impl Foo {\n+    type Bar<T> = ();\n+}\n+\n+fn main() -> Foo::Bar::<Vec<[u32]>> {}"}, {"sha": "83be4f43b5e943fad07a64a9e40d2d47179c501d", "filename": "tests/ui/associated-inherent-types/dispatch-on-self-type-0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-0.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -31,7 +31,7 @@ fn main() {\n     let _: Select<u8>::Projection = ();\n \n     let _: Choose<NonCopy>::Result = ();\n-    let _: Choose<bool>::Result = vec![true];\n+    let _: Choose<&str>::Result = vec![\"\u2026\"]; // regression test for issue #108957\n }\n \n // Test if we use the correct `ParamEnv` when proving obligations."}, {"sha": "48390b9430b60e1ad39752755b73187da6d8e6c8", "filename": "tests/ui/associated-inherent-types/former-subst-ice.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fformer-subst-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fformer-subst-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fformer-subst-ice.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct Cont<T>(T);\n+\n+impl<T: Copy> Cont<T> {\n+    type Out = Vec<T>;\n+}\n+\n+pub fn weird<T: Copy>(x: T) {\n+    let _: Cont<_>::Out = vec![true];\n+}\n+\n+fn main() {}"}, {"sha": "464b59c249fe1f232e3695be86d4999e64a4723e", "filename": "tests/ui/associated-inherent-types/generic-associated-types-bad.item.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.item.stderr?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,15 @@\n+error[E0277]: the trait bound `String: Copy` is not satisfied\n+  --> $DIR/generic-associated-types-bad.rs:16:10\n+   |\n+LL | const _: Ty::Pr<String> = String::new();\n+   |          ^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `String`\n+   |\n+note: required by a bound in `Ty::Pr`\n+  --> $DIR/generic-associated-types-bad.rs:10:16\n+   |\n+LL |     type Pr<T: Copy> = T;\n+   |                ^^^^ required by this bound in `Ty::Pr`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "4f371b24e80344afffd6bf806e7e3f672dc7c3b0", "filename": "tests/ui/associated-inherent-types/generic-associated-types-bad.local.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.local.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.local.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.local.stderr?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,15 @@\n+error[E0277]: the trait bound `Vec<()>: Copy` is not satisfied\n+  --> $DIR/generic-associated-types-bad.rs:20:12\n+   |\n+LL |     let _: Ty::Pr<Vec<()>>;\n+   |            ^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `Vec<()>`\n+   |\n+note: required by a bound in `Ty::Pr`\n+  --> $DIR/generic-associated-types-bad.rs:10:16\n+   |\n+LL |     type Pr<T: Copy> = T;\n+   |                ^^^^ required by this bound in `Ty::Pr`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "74ec39424edcbdeb6fdfdf503b3dbb229b040f17", "filename": "tests/ui/associated-inherent-types/generic-associated-types-bad.region.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.region.stderr?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,11 @@\n+error: lifetime may not live long enough\n+  --> $DIR/generic-associated-types-bad.rs:25:12\n+   |\n+LL | fn user<'a>() {\n+   |         -- lifetime `'a` defined here\n+LL |     #[cfg(region)]\n+LL |     let _: Ty::Static<&'a str> = \"\";\n+   |            ^^^^^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n+\n+error: aborting due to previous error\n+"}, {"sha": "e66392a0a94116c0a1120451d44f700d183ccfbe", "filename": "tests/ui/associated-inherent-types/generic-associated-types-bad.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,26 @@\n+// revisions: item local region\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+#[derive(Clone, Copy)]\n+pub enum Ty {}\n+\n+impl Ty {\n+    type Pr<T: Copy> = T;\n+\n+    type Static<Q: 'static> = Q;\n+}\n+\n+#[cfg(item)]\n+const _: Ty::Pr<String> = String::new(); //[item]~ the trait bound `String: Copy` is not satisfied\n+\n+fn main() {\n+    #[cfg(local)]\n+    let _: Ty::Pr<Vec<()>>; //[local]~ ERROR the trait bound `Vec<()>: Copy` is not satisfied\n+}\n+\n+fn user<'a>() {\n+    #[cfg(region)]\n+    let _: Ty::Static<&'a str> = \"\"; //[region]~ ERROR lifetime may not live long enough\n+}"}, {"sha": "939a4ff60f2bb2fbdce77e970d8d2d68d915dfc0", "filename": "tests/ui/associated-inherent-types/inference-fail.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Finference-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Finference-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Finference-fail.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,11 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct S<T>(T);\n+\n+impl<T> S<T> { type P = (); }\n+\n+fn main() {\n+    // There is no way to infer this type.\n+    let _: S<_>::P = (); //~ ERROR type annotations needed\n+}"}, {"sha": "f29144e4aa7553cc71e70e36828d19446e717d40", "filename": "tests/ui/associated-inherent-types/inference-fail.stderr", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Finference-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Finference-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Finference-fail.stderr?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -1,8 +1,8 @@\n error[E0282]: type annotations needed\n-  --> $DIR/inference-fail.rs:14:14\n+  --> $DIR/inference-fail.rs:10:12\n    |\n-LL |     let _: S<_>::P;\n-   |              ^ cannot infer type\n+LL |     let _: S<_>::P = ();\n+   |            ^^^^^^^ cannot infer type for type parameter `T`\n \n error: aborting due to previous error\n ", "previous_filename": "tests/ui/associated-inherent-types/bugs/inference-fail.stderr"}, {"sha": "38179214fa124de03df6c8dc4fb259de750b518a", "filename": "tests/ui/associated-inherent-types/inference.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Finference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Finference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Finference.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,39 @@\n+// Testing inference capabilities.\n+// check-pass\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+use std::convert::identity;\n+\n+struct Container<T>(T);\n+\n+impl Container<u32> {\n+    type Sink = ();\n+}\n+\n+impl<Any> Container<Any> {\n+    type Thing = Any;\n+}\n+\n+impl<T> Container<(T, ())> {\n+    type Output = ((), Wrapped<T>);\n+}\n+\n+fn main() {\n+    // Inferred via the Self type of the impl.\n+    let _: Container<_>::Sink;\n+\n+    // Inferred via the RHS:\n+\n+    let _: Container<_>::Thing = 0;\n+\n+    let _: Container<Wrapped<_>>::Thing = Wrapped(false);\n+\n+    let _: Container<_>::Output = (drop(1), Wrapped(\"...\"));\n+\n+    let binding: Container<_>::Thing = Default::default(); // unsolved at this point\n+    identity::<String>(binding); // constrained and solved here\n+}\n+\n+struct Wrapped<T>(T);"}, {"sha": "a3ae2e2ab4476728f7eb3313af3290ad196373a5", "filename": "tests/ui/associated-inherent-types/issue-109768.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fissue-109768.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fissue-109768.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fissue-109768.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,12 @@\n+// incremental\n+\n+struct Wrapper<T>(T);\n+\n+struct Local<T, U>(T, U);\n+\n+impl<T> Local { //~ ERROR missing generics for struct `Local`\n+    type AssocType3 = T; //~ ERROR inherent associated types are unstable\n+\n+    const WRAPPED_ASSOC_3: Wrapper<Self::AssocType3> = Wrapper();\n+}\n+//~^ ERROR `main` function not found"}, {"sha": "97706d4062a979fef9f4770bae20beca4ecd707d", "filename": "tests/ui/associated-inherent-types/issue-109768.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fissue-109768.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fissue-109768.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fissue-109768.stderr?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,35 @@\n+error[E0601]: `main` function not found in crate `issue_109768`\n+  --> $DIR/issue-109768.rs:11:2\n+   |\n+LL | }\n+   |  ^ consider adding a `main` function to `$DIR/issue-109768.rs`\n+\n+error[E0107]: missing generics for struct `Local`\n+  --> $DIR/issue-109768.rs:7:9\n+   |\n+LL | impl<T> Local {\n+   |         ^^^^^ expected 2 generic arguments\n+   |\n+note: struct defined here, with 2 generic parameters: `T`, `U`\n+  --> $DIR/issue-109768.rs:5:8\n+   |\n+LL | struct Local<T, U>(T, U);\n+   |        ^^^^^ -  -\n+help: add missing generic arguments\n+   |\n+LL | impl<T> Local<T, U> {\n+   |              ++++++\n+\n+error[E0658]: inherent associated types are unstable\n+  --> $DIR/issue-109768.rs:8:5\n+   |\n+LL |     type AssocType3 = T;\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #8995 <https://github.com/rust-lang/rust/issues/8995> for more information\n+   = help: add `#![feature(inherent_associated_types)]` to the crate attributes to enable\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0107, E0601, E0658.\n+For more information about an error, try `rustc --explain E0107`."}, {"sha": "0b5ba7d1fb55da493ca4375156e4ad1d960ac82e", "filename": "tests/ui/associated-inherent-types/issue-109789.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fissue-109789.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fissue-109789.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fissue-109789.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,22 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct Foo<T>(T);\n+\n+impl Foo<fn(&'static ())> {\n+    type Assoc = u32;\n+}\n+\n+trait Other {}\n+impl Other for u32 {}\n+\n+// FIXME(inherent_associated_types): Avoid emitting two diagnostics (they only differ in span).\n+// FIXME(inherent_associated_types): Enhancement: Spruce up the diagnostic by saying something like\n+// \"implementation is not general enough\" as is done for traits via\n+// `try_report_trait_placeholder_mismatch`.\n+\n+fn bar(_: Foo<for<'a> fn(&'a ())>::Assoc) {}\n+//~^ ERROR mismatched types\n+//~| ERROR mismatched types\n+\n+fn main() {}"}, {"sha": "7af338274a12ba38fceb0dc03ebb114dc8369eee", "filename": "tests/ui/associated-inherent-types/issue-109789.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fissue-109789.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fissue-109789.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fissue-109789.stderr?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,21 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-109789.rs:18:1\n+   |\n+LL | fn bar(_: Foo<for<'a> fn(&'a ())>::Assoc) {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected struct `Foo<fn(&'static ())>`\n+              found struct `Foo<for<'a> fn(&'a ())>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-109789.rs:18:11\n+   |\n+LL | fn bar(_: Foo<for<'a> fn(&'a ())>::Assoc) {}\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected struct `Foo<fn(&'static ())>`\n+              found struct `Foo<for<'a> fn(&'a ())>`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "b2be19a28f442efc4405b0275bf18656db82b541", "filename": "tests/ui/associated-inherent-types/issue-109790.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fissue-109790.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fissue-109790.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fissue-109790.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,17 @@\n+// check-pass\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct Foo<T>(T);\n+\n+impl<'a> Foo<fn(&'a ())> {\n+    type Assoc = &'a ();\n+}\n+\n+trait Other {}\n+impl Other for u32 {}\n+\n+fn bar(_: for<'a> fn(Foo<fn(&'a ())>::Assoc)) {}\n+\n+fn main() {}"}, {"sha": "488a2cda649ce9d71727b83e9a17ac4a1a446011", "filename": "tests/ui/associated-inherent-types/late-bound-regions.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Flate-bound-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Flate-bound-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Flate-bound-regions.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,25 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+// Test if we correctly normalize `S<'a>::P` with respect to late-bound regions.\n+\n+type Function = for<'a> fn(&'a i32) -> S<'a>::P;\n+\n+struct S<'a>(&'a ());\n+\n+trait Inter {\n+    type P;\n+}\n+\n+impl<'a> S<'a> {\n+    type P = &'a i32;\n+}\n+\n+fn ret_ref_local<'e>() -> &'e i32 {\n+    let f: Function = |x| x;\n+\n+    let local = 0;\n+    f(&local) //~ ERROR cannot return value referencing local variable `local`\n+}\n+\n+fn main() {}"}, {"sha": "4706fcca91d0644340b2cd5d393637b22b566dde", "filename": "tests/ui/associated-inherent-types/late-bound-regions.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Flate-bound-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Flate-bound-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Flate-bound-regions.stderr?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,12 @@\n+error[E0515]: cannot return value referencing local variable `local`\n+  --> $DIR/late-bound-regions.rs:22:5\n+   |\n+LL |     f(&local)\n+   |     ^^------^\n+   |     | |\n+   |     | `local` is borrowed here\n+   |     returns a value referencing data owned by the current function\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0515`."}, {"sha": "4228238aa7b7a26b84a4ebeed7c1b54e070ca48a", "filename": "tests/ui/associated-inherent-types/normalization-overflow.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fnormalization-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fnormalization-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fnormalization-overflow.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,12 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+// FIXME(fmease): I'd prefer to report a cycle error here instead of an overflow one.\n+\n+struct T;\n+\n+impl T {\n+    type This = Self::This; //~ ERROR overflow evaluating associated type `T::This`\n+}\n+\n+fn main() {}"}, {"sha": "16bb64281e3af1ed7f0a2b0dbad513228f377a8a", "filename": "tests/ui/associated-inherent-types/normalization-overflow.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fnormalization-overflow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fnormalization-overflow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fnormalization-overflow.stderr?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,8 @@\n+error: overflow evaluating associated type `T::This`\n+  --> $DIR/normalization-overflow.rs:9:17\n+   |\n+LL |     type This = Self::This;\n+   |                 ^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "a4b372537c789d680e32a81e767c3992e3ce88bf", "filename": "tests/ui/associated-inherent-types/private-in-public.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fprivate-in-public.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fprivate-in-public.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fprivate-in-public.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,26 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+#![crate_type = \"lib\"]\n+\n+#![deny(private_in_public)]\n+\n+pub type PubAlias0 = PubTy::PrivAssocTy;\n+//~^ ERROR private associated type `PubTy::PrivAssocTy` in public interface (error E0446)\n+//~| WARNING this was previously accepted\n+pub type PubAlias1 = PrivTy::PubAssocTy;\n+//~^ ERROR private type `PrivTy` in public interface (error E0446)\n+//~| WARNING this was previously accepted\n+pub type PubAlias2 = PubTy::PubAssocTy<PrivTy>;\n+//~^ ERROR private type `PrivTy` in public interface (error E0446)\n+//~| WARNING this was previously accepted\n+\n+pub struct PubTy;\n+impl PubTy {\n+    type PrivAssocTy = ();\n+    pub type PubAssocTy<T> = T;\n+}\n+\n+struct PrivTy;\n+impl PrivTy {\n+    pub type PubAssocTy = ();\n+}"}, {"sha": "f0a64e96179ac39dd2a0d5aa5141209c77ffbdf7", "filename": "tests/ui/associated-inherent-types/private-in-public.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fprivate-in-public.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fprivate-in-public.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fprivate-in-public.stderr?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,34 @@\n+error: private associated type `PubTy::PrivAssocTy` in public interface (error E0446)\n+  --> $DIR/private-in-public.rs:7:1\n+   |\n+LL | pub type PubAlias0 = PubTy::PrivAssocTy;\n+   | ^^^^^^^^^^^^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #34537 <https://github.com/rust-lang/rust/issues/34537>\n+note: the lint level is defined here\n+  --> $DIR/private-in-public.rs:5:9\n+   |\n+LL | #![deny(private_in_public)]\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error: private type `PrivTy` in public interface (error E0446)\n+  --> $DIR/private-in-public.rs:10:1\n+   |\n+LL | pub type PubAlias1 = PrivTy::PubAssocTy;\n+   | ^^^^^^^^^^^^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #34537 <https://github.com/rust-lang/rust/issues/34537>\n+\n+error: private type `PrivTy` in public interface (error E0446)\n+  --> $DIR/private-in-public.rs:13:1\n+   |\n+LL | pub type PubAlias2 = PubTy::PubAssocTy<PrivTy>;\n+   | ^^^^^^^^^^^^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #34537 <https://github.com/rust-lang/rust/issues/34537>\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "7c94539ace1f904db8cc32a2d93ed2d71055598e", "filename": "tests/ui/associated-inherent-types/regionck-0.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fregionck-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fregionck-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fregionck-0.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,14 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct S<T>(T);\n+\n+impl S<&'static ()> {\n+    type T = ();\n+}\n+\n+fn user<'a>() {\n+    let _: S::<&'a ()>::T; //~ ERROR lifetime may not live long enough\n+}\n+\n+fn main() {}"}, {"sha": "3a438ee630e1e3eea1f0facfd8713a1a50f01df0", "filename": "tests/ui/associated-inherent-types/regionck-0.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fregionck-0.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fregionck-0.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fregionck-0.stderr?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,10 @@\n+error: lifetime may not live long enough\n+  --> $DIR/regionck-0.rs:11:12\n+   |\n+LL | fn user<'a>() {\n+   |         -- lifetime `'a` defined here\n+LL |     let _: S::<&'a ()>::T;\n+   |            ^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n+\n+error: aborting due to previous error\n+"}, {"sha": "ec663cd0f77fa0bedef29f4d0a78560322ce467c", "filename": "tests/ui/associated-inherent-types/regionck-1.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fregionck-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fregionck-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fregionck-1.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,13 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct U;\n+\n+impl U {\n+    // Don't imply any bounds here.\n+\n+    type NoTyOutliv<'a, T> = &'a T; //~ ERROR the parameter type `T` may not live long enough\n+    type NoReOutliv<'a, 'b> = &'a &'b (); //~ ERROR reference has a longer lifetime than the data it references\n+}\n+\n+fn main() {}"}, {"sha": "b17d89ca306f41cf1ea76c5f60116ea4019764fd", "filename": "tests/ui/associated-inherent-types/regionck-1.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fregionck-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fregionck-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fregionck-1.stderr?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,29 @@\n+error[E0309]: the parameter type `T` may not live long enough\n+  --> $DIR/regionck-1.rs:9:30\n+   |\n+LL |     type NoTyOutliv<'a, T> = &'a T;\n+   |                              ^^^^^- help: consider adding a where clause: `where T: 'a`\n+   |                              |\n+   |                              ...so that the reference type `&'a T` does not outlive the data it points at\n+\n+error[E0491]: in type `&'a &'b ()`, reference has a longer lifetime than the data it references\n+  --> $DIR/regionck-1.rs:10:31\n+   |\n+LL |     type NoReOutliv<'a, 'b> = &'a &'b ();\n+   |                               ^^^^^^^^^^\n+   |\n+note: the pointer is valid for the lifetime `'a` as defined here\n+  --> $DIR/regionck-1.rs:10:21\n+   |\n+LL |     type NoReOutliv<'a, 'b> = &'a &'b ();\n+   |                     ^^\n+note: but the referenced data is only valid for the lifetime `'b` as defined here\n+  --> $DIR/regionck-1.rs:10:25\n+   |\n+LL |     type NoReOutliv<'a, 'b> = &'a &'b ();\n+   |                         ^^\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0309, E0491.\n+For more information about an error, try `rustc --explain E0309`."}, {"sha": "7a0b8b08300157083bedad04ab32402b2903e4ad", "filename": "tests/ui/associated-inherent-types/regionck-2.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fregionck-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fregionck-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fregionck-2.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,14 @@\n+// Regression test for issue #109299.\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct Lexer<'d>(&'d ());\n+\n+impl Lexer<'static> {\n+    type Cursor = ();\n+}\n+\n+fn test(_: Lexer::Cursor) {} //~ ERROR mismatched types\n+\n+fn main() {}"}, {"sha": "b0a4ed35d560973266a21c49da4590808f2a3ab4", "filename": "tests/ui/associated-inherent-types/regionck-2.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fregionck-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Fregionck-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fregionck-2.stderr?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,18 @@\n+error[E0308]: mismatched types\n+  --> $DIR/regionck-2.rs:12:12\n+   |\n+LL | fn test(_: Lexer::Cursor) {}\n+   |            ^^^^^^^^^^^^^ lifetime mismatch\n+   |\n+   = note: expected struct `Lexer<'static>`\n+              found struct `Lexer<'_>`\n+note: the anonymous lifetime defined here...\n+  --> $DIR/regionck-2.rs:12:12\n+   |\n+LL | fn test(_: Lexer::Cursor) {}\n+   |            ^^^^^\n+   = note: ...does not necessarily outlive the static lifetime\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "b32b4288ac9f67cd5bc86efb32dca47833bc0ff6", "filename": "tests/ui/associated-inherent-types/type-alias-bounds-are-enforced.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Ftype-alias-bounds-are-enforced.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Ftype-alias-bounds-are-enforced.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Ftype-alias-bounds-are-enforced.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,26 @@\n+// check-pass\n+// compile-flags: --crate-type=lib\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+// Bounds on the self type play a major role in the resolution of inherent associated types (*).\n+// As a result of that, if a type alias contains any then its bounds have to be respected and the\n+// lint `type_alias_bounds` should not fire.\n+//\n+// FIXME(inherent_associated_types): In the current implementation that is. We might move the\n+// selection phase of IATs from hir_typeck to trait_selection resulting in us not requiring the\n+// ParamEnv that early allowing us to ignore bounds on type aliases again.\n+// Triage this before stabilization.\n+\n+#![deny(type_alias_bounds)]\n+\n+pub type Alias<T: Bound> = (Source<T>::Assoc,);\n+\n+\n+pub struct Source<T>(T);\n+pub trait Bound {}\n+\n+impl<T: Bound> Source<T> {\n+    pub type Assoc = ();\n+}"}, {"sha": "d081c4d5b78e6206af5bf1f9c7a2bb823e28aac8", "filename": "tests/ui/associated-inherent-types/unsatisfied-bounds-inferred-type.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-inferred-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-inferred-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-inferred-type.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,12 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct S<T>(T);\n+\n+impl<T: Copy> S<T> {\n+    type T = T;\n+}\n+\n+fn main() {\n+    let _: S<_>::T = String::new(); //~ ERROR the trait bound `String: Copy` is not satisfied\n+}"}, {"sha": "ecf30f4cdec58626e3b9714c5832dfabe00f0cf6", "filename": "tests/ui/associated-inherent-types/unsatisfied-bounds-inferred-type.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-inferred-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-inferred-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-inferred-type.stderr?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,17 @@\n+error[E0277]: the trait bound `String: Copy` is not satisfied\n+  --> $DIR/unsatisfied-bounds-inferred-type.rs:11:12\n+   |\n+LL |     let _: S<_>::T = String::new();\n+   |            ^^^^^^^ the trait `Copy` is not implemented for `String`\n+   |\n+note: required by a bound in `S<T>::T`\n+  --> $DIR/unsatisfied-bounds-inferred-type.rs:6:9\n+   |\n+LL | impl<T: Copy> S<T> {\n+   |         ^^^^ required by this bound in `S<T>::T`\n+LL |     type T = T;\n+   |          - required by a bound in this associated type\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "97bd2c421604af81da3ab3e050f216ae9e52527b", "filename": "tests/ui/associated-inherent-types/unsatisfied-bounds-where-clause-on-assoc-ty.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-where-clause-on-assoc-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-where-clause-on-assoc-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-where-clause-on-assoc-ty.rs?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,14 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct S<T>(T);\n+\n+impl<T> S<T> {\n+    type X = ()\n+    where\n+        T: Copy;\n+}\n+\n+fn main() {\n+    let _: S::<String>::X; //~ ERROR the trait bound `String: Copy` is not satisfied\n+}"}, {"sha": "d4968cd05dceefa000f1f11dd6888f323331d01b", "filename": "tests/ui/associated-inherent-types/unsatisfied-bounds-where-clause-on-assoc-ty.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-where-clause-on-assoc-ty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-where-clause-on-assoc-ty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-where-clause-on-assoc-ty.stderr?ref=29ac429c9bd5f6aa5af8d2c04f3ef8732cd8bd15", "patch": "@@ -0,0 +1,18 @@\n+error[E0277]: the trait bound `String: Copy` is not satisfied\n+  --> $DIR/unsatisfied-bounds-where-clause-on-assoc-ty.rs:13:12\n+   |\n+LL |     let _: S::<String>::X;\n+   |            ^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `String`\n+   |\n+note: required by a bound in `S<T>::X`\n+  --> $DIR/unsatisfied-bounds-where-clause-on-assoc-ty.rs:9:12\n+   |\n+LL |     type X = ()\n+   |          - required by a bound in this associated type\n+LL |     where\n+LL |         T: Copy;\n+   |            ^^^^ required by this bound in `S<T>::X`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}]}