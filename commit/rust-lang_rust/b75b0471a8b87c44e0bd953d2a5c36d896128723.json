{"sha": "b75b0471a8b87c44e0bd953d2a5c36d896128723", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3NWIwNDcxYThiODdjNDRlMGJkOTUzZDJhNWMzNmQ4OTYxMjg3MjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-22T17:43:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-22T17:43:44Z"}, "message": "Auto merge of #53581 - varkor:tyvariants-rename, r=eddyb\n\nRename TyVariants and variants\n\n- Rename `TypeVariants` to `TyKind`.\n- Remove the `Ty` prefix from each one of its variants (plus the identically-named variants of `PrimTy`).\n- Rename `ty::Slice` to `ty::List`.\n\nThe new names look cleaner.\n\nr? @eddyb", "tree": {"sha": "3b5f6732874f52544bc5ed6f88df476aae07b488", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b5f6732874f52544bc5ed6f88df476aae07b488"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b75b0471a8b87c44e0bd953d2a5c36d896128723", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b75b0471a8b87c44e0bd953d2a5c36d896128723", "html_url": "https://github.com/rust-lang/rust/commit/b75b0471a8b87c44e0bd953d2a5c36d896128723", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b75b0471a8b87c44e0bd953d2a5c36d896128723/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c24f27c0452a9aaecfb70d225d846df2e517385f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c24f27c0452a9aaecfb70d225d846df2e517385f", "html_url": "https://github.com/rust-lang/rust/commit/c24f27c0452a9aaecfb70d225d846df2e517385f"}, {"sha": "71722b9cef68388790fbbd5f30d35750cb2f93f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/71722b9cef68388790fbbd5f30d35750cb2f93f9", "html_url": "https://github.com/rust-lang/rust/commit/71722b9cef68388790fbbd5f30d35750cb2f93f9"}], "stats": {"total": 4475, "additions": 2238, "deletions": 2237}, "files": [{"sha": "65146f2de8441ea0ee74b37e2d4f4b8674e6dec7", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -53,7 +53,7 @@ pub enum Def {\n     Existential(DefId),\n     /// `type Foo = Bar;`\n     TyAlias(DefId),\n-    TyForeign(DefId),\n+    ForeignTy(DefId),\n     TraitAlias(DefId),\n     AssociatedTy(DefId),\n     /// `existential type Foo: Bar;`\n@@ -272,7 +272,7 @@ impl Def {\n             Def::AssociatedTy(id) | Def::TyParam(id) | Def::Struct(id) | Def::StructCtor(id, ..) |\n             Def::Union(id) | Def::Trait(id) | Def::Method(id) | Def::Const(id) |\n             Def::AssociatedConst(id) | Def::Macro(id, ..) |\n-            Def::Existential(id) | Def::AssociatedExistential(id) | Def::TyForeign(id) => {\n+            Def::Existential(id) | Def::AssociatedExistential(id) | Def::ForeignTy(id) => {\n                 id\n             }\n \n@@ -311,7 +311,7 @@ impl Def {\n             Def::StructCtor(.., CtorKind::Fictive) => bug!(\"impossible struct constructor\"),\n             Def::Union(..) => \"union\",\n             Def::Trait(..) => \"trait\",\n-            Def::TyForeign(..) => \"foreign type\",\n+            Def::ForeignTy(..) => \"foreign type\",\n             Def::Method(..) => \"method\",\n             Def::Const(..) => \"constant\",\n             Def::AssociatedConst(..) => \"associated constant\","}, {"sha": "a43afa9e34a73c388b91db7b1f4d8f26fe001114", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -1183,7 +1183,7 @@ impl<'a> LoweringContext<'a> {\n                     }\n                     ImplTraitContext::Universal(in_band_ty_params) => {\n                         self.lower_node_id(def_node_id);\n-                        // Add a definition for the in-band TyParam\n+                        // Add a definition for the in-band Param\n                         let def_index = self\n                             .resolver\n                             .definitions()"}, {"sha": "c3112da4f8c3ac2daff485cadf967152a04c291c", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -453,7 +453,7 @@ impl<'hir> Map<'hir> {\n                 match item.node {\n                     ForeignItemKind::Fn(..) => Some(Def::Fn(def_id)),\n                     ForeignItemKind::Static(_, m) => Some(Def::Static(def_id, m)),\n-                    ForeignItemKind::Type => Some(Def::TyForeign(def_id)),\n+                    ForeignItemKind::Type => Some(Def::ForeignTy(def_id)),\n                 }\n             }\n             NodeTraitItem(item) => {"}, {"sha": "6bdfbd40e8d36905f586622d9b605e411c533f80", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -1672,12 +1672,12 @@ impl fmt::Debug for Ty {\n /// Not represented directly in the AST, referred to by name through a ty_path.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum PrimTy {\n-    TyInt(IntTy),\n-    TyUint(UintTy),\n-    TyFloat(FloatTy),\n-    TyStr,\n-    TyBool,\n-    TyChar,\n+    Int(IntTy),\n+    Uint(UintTy),\n+    Float(FloatTy),\n+    Str,\n+    Bool,\n+    Char,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]"}, {"sha": "e82ef8bbdae554ca4910129dcaedfe4b8b5bc6da", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -308,12 +308,12 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Ty {\n }\n \n impl_stable_hash_for!(enum hir::PrimTy {\n-    TyInt(int_ty),\n-    TyUint(uint_ty),\n-    TyFloat(float_ty),\n-    TyStr,\n-    TyBool,\n-    TyChar\n+    Int(int_ty),\n+    Uint(uint_ty),\n+    Float(float_ty),\n+    Str,\n+    Bool,\n+    Char\n });\n \n impl_stable_hash_for!(struct hir::BareFnTy {\n@@ -1012,7 +1012,7 @@ impl_stable_hash_for!(enum hir::def::Def {\n     PrimTy(prim_ty),\n     TyParam(def_id),\n     SelfTy(trait_def_id, impl_def_id),\n-    TyForeign(def_id),\n+    ForeignTy(def_id),\n     Fn(def_id),\n     Const(def_id),\n     Static(def_id, is_mutbl),"}, {"sha": "709b53f248dd1cd768bd05db9ee78b011c7a78da", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -25,7 +25,7 @@ use ty;\n use mir;\n \n impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>>\n-for &'gcx ty::Slice<T>\n+for &'gcx ty::List<T>\n     where T: HashStable<StableHashingContext<'a>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n@@ -53,7 +53,7 @@ for &'gcx ty::Slice<T>\n     }\n }\n \n-impl<'a, 'gcx, T> ToStableHashKey<StableHashingContext<'a>> for &'gcx ty::Slice<T>\n+impl<'a, 'gcx, T> ToStableHashKey<StableHashingContext<'a>> for &'gcx ty::List<T>\n     where T: HashStable<StableHashingContext<'a>>\n {\n     type KeyType = Fingerprint;\n@@ -797,90 +797,90 @@ impl_stable_hash_for!(enum ty::BoundRegion {\n });\n \n impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n-for ty::TypeVariants<'gcx>\n+for ty::TyKind<'gcx>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n-        use ty::TypeVariants::*;\n+        use ty::TyKind::*;\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n-            TyBool  |\n-            TyChar  |\n-            TyStr   |\n-            TyError |\n-            TyNever => {\n+            Bool  |\n+            Char  |\n+            Str   |\n+            Error |\n+            Never => {\n                 // Nothing more to hash.\n             }\n-            TyInt(int_ty) => {\n+            Int(int_ty) => {\n                 int_ty.hash_stable(hcx, hasher);\n             }\n-            TyUint(uint_ty) => {\n+            Uint(uint_ty) => {\n                 uint_ty.hash_stable(hcx, hasher);\n             }\n-            TyFloat(float_ty)  => {\n+            Float(float_ty)  => {\n                 float_ty.hash_stable(hcx, hasher);\n             }\n-            TyAdt(adt_def, substs) => {\n+            Adt(adt_def, substs) => {\n                 adt_def.hash_stable(hcx, hasher);\n                 substs.hash_stable(hcx, hasher);\n             }\n-            TyArray(inner_ty, len) => {\n+            Array(inner_ty, len) => {\n                 inner_ty.hash_stable(hcx, hasher);\n                 len.hash_stable(hcx, hasher);\n             }\n-            TySlice(inner_ty) => {\n+            Slice(inner_ty) => {\n                 inner_ty.hash_stable(hcx, hasher);\n             }\n-            TyRawPtr(pointee_ty) => {\n+            RawPtr(pointee_ty) => {\n                 pointee_ty.hash_stable(hcx, hasher);\n             }\n-            TyRef(region, pointee_ty, mutbl) => {\n+            Ref(region, pointee_ty, mutbl) => {\n                 region.hash_stable(hcx, hasher);\n                 pointee_ty.hash_stable(hcx, hasher);\n                 mutbl.hash_stable(hcx, hasher);\n             }\n-            TyFnDef(def_id, substs) => {\n+            FnDef(def_id, substs) => {\n                 def_id.hash_stable(hcx, hasher);\n                 substs.hash_stable(hcx, hasher);\n             }\n-            TyFnPtr(ref sig) => {\n+            FnPtr(ref sig) => {\n                 sig.hash_stable(hcx, hasher);\n             }\n-            TyDynamic(ref existential_predicates, region) => {\n+            Dynamic(ref existential_predicates, region) => {\n                 existential_predicates.hash_stable(hcx, hasher);\n                 region.hash_stable(hcx, hasher);\n             }\n-            TyClosure(def_id, closure_substs) => {\n+            Closure(def_id, closure_substs) => {\n                 def_id.hash_stable(hcx, hasher);\n                 closure_substs.hash_stable(hcx, hasher);\n             }\n-            TyGenerator(def_id, generator_substs, movability) => {\n+            Generator(def_id, generator_substs, movability) => {\n                 def_id.hash_stable(hcx, hasher);\n                 generator_substs.hash_stable(hcx, hasher);\n                 movability.hash_stable(hcx, hasher);\n             }\n-            TyGeneratorWitness(types) => {\n+            GeneratorWitness(types) => {\n                 types.hash_stable(hcx, hasher)\n             }\n-            TyTuple(inner_tys) => {\n+            Tuple(inner_tys) => {\n                 inner_tys.hash_stable(hcx, hasher);\n             }\n-            TyProjection(ref projection_ty) => {\n+            Projection(ref projection_ty) => {\n                 projection_ty.hash_stable(hcx, hasher);\n             }\n-            TyAnon(def_id, substs) => {\n+            Anon(def_id, substs) => {\n                 def_id.hash_stable(hcx, hasher);\n                 substs.hash_stable(hcx, hasher);\n             }\n-            TyParam(param_ty) => {\n+            Param(param_ty) => {\n                 param_ty.hash_stable(hcx, hasher);\n             }\n-            TyForeign(def_id) => {\n+            Foreign(def_id) => {\n                 def_id.hash_stable(hcx, hasher);\n             }\n-            TyInfer(infer_ty) => {\n+            Infer(infer_ty) => {\n                 infer_ty.hash_stable(hcx, hasher);\n             }\n         }\n@@ -905,7 +905,7 @@ for ty::TyVid\n                                           _hasher: &mut StableHasher<W>) {\n         // TyVid values are confined to an inference context and hence\n         // should not be hashed.\n-        bug!(\"ty::TypeVariants::hash_stable() - can't hash a TyVid {:?}.\", *self)\n+        bug!(\"ty::TyKind::hash_stable() - can't hash a TyVid {:?}.\", *self)\n     }\n }\n \n@@ -917,7 +917,7 @@ for ty::IntVid\n                                           _hasher: &mut StableHasher<W>) {\n         // IntVid values are confined to an inference context and hence\n         // should not be hashed.\n-        bug!(\"ty::TypeVariants::hash_stable() - can't hash an IntVid {:?}.\", *self)\n+        bug!(\"ty::TyKind::hash_stable() - can't hash an IntVid {:?}.\", *self)\n     }\n }\n \n@@ -929,7 +929,7 @@ for ty::FloatVid\n                                           _hasher: &mut StableHasher<W>) {\n         // FloatVid values are confined to an inference context and hence\n         // should not be hashed.\n-        bug!(\"ty::TypeVariants::hash_stable() - can't hash a FloatVid {:?}.\", *self)\n+        bug!(\"ty::TyKind::hash_stable() - can't hash a FloatVid {:?}.\", *self)\n     }\n }\n "}, {"sha": "96c64c05ccfbd9418868d5d1e8dbdf9d54a9976f", "filename": "src/librustc/infer/anon_types/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -592,7 +592,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ReverseMapper<'cx, 'gcx, 'tcx>\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         match ty.sty {\n-            ty::TyClosure(def_id, substs) => {\n+            ty::Closure(def_id, substs) => {\n                 // I am a horrible monster and I pray for death. When\n                 // we encounter a closure here, it is always a closure\n                 // from within the function that we are currently\n@@ -655,7 +655,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n             tcx,\n             reg_op: |reg| reg,\n             fldop: |ty| {\n-                if let ty::TyAnon(def_id, substs) = ty.sty {\n+                if let ty::Anon(def_id, substs) = ty.sty {\n                     // Check that this is `impl Trait` type is\n                     // declared by `parent_def_id` -- i.e., one whose\n                     // value we are inferring.  At present, this is\n@@ -679,7 +679,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n                     // ```\n                     //\n                     // Here, the return type of `foo` references a\n-                    // `TyAnon` indeed, but not one whose value is\n+                    // `Anon` indeed, but not one whose value is\n                     // presently being inferred. You can get into a\n                     // similar situation with closure return types\n                     // today:\n@@ -755,11 +755,11 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n         let tcx = infcx.tcx;\n \n         debug!(\n-            \"instantiate_anon_types: TyAnon(def_id={:?}, substs={:?})\",\n+            \"instantiate_anon_types: Anon(def_id={:?}, substs={:?})\",\n             def_id, substs\n         );\n \n-        // Use the same type variable if the exact same TyAnon appears more\n+        // Use the same type variable if the exact same Anon appears more\n         // than once in the return type (e.g. if it's passed to a type alias).\n         if let Some(anon_defn) = self.anon_types.get(&def_id) {\n             return anon_defn.concrete_ty;\n@@ -805,7 +805,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n \n         for predicate in bounds.predicates {\n             // Change the predicate to refer to the type variable,\n-            // which will be the concrete type, instead of the TyAnon.\n+            // which will be the concrete type, instead of the Anon.\n             // This also instantiates nested `impl Trait`.\n             let predicate = self.instantiate_anon_types_in_map(&predicate);\n "}, {"sha": "16c33e9adf8908c4567b09b2ac2dde5ed620f138", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -23,7 +23,7 @@ use infer::InferCtxt;\n use std::sync::atomic::Ordering;\n use ty::fold::{TypeFoldable, TypeFolder};\n use ty::subst::Kind;\n-use ty::{self, CanonicalVar, Lift, Slice, Ty, TyCtxt, TypeFlags};\n+use ty::{self, CanonicalVar, Lift, List, Ty, TyCtxt, TypeFlags};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -246,46 +246,46 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Canonicalizer<'cx, 'gcx, 'tcx>\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         match t.sty {\n-            ty::TyInfer(ty::TyVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::General, t),\n+            ty::Infer(ty::TyVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::General, t),\n \n-            ty::TyInfer(ty::IntVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::Int, t),\n+            ty::Infer(ty::IntVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::Int, t),\n \n-            ty::TyInfer(ty::FloatVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::Float, t),\n+            ty::Infer(ty::FloatVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::Float, t),\n \n-            ty::TyInfer(ty::FreshTy(_))\n-            | ty::TyInfer(ty::FreshIntTy(_))\n-            | ty::TyInfer(ty::FreshFloatTy(_)) => {\n+            ty::Infer(ty::FreshTy(_))\n+            | ty::Infer(ty::FreshIntTy(_))\n+            | ty::Infer(ty::FreshFloatTy(_)) => {\n                 bug!(\"encountered a fresh type during canonicalization\")\n             }\n \n-            ty::TyInfer(ty::CanonicalTy(_)) => {\n+            ty::Infer(ty::CanonicalTy(_)) => {\n                 bug!(\"encountered a canonical type during canonicalization\")\n             }\n \n-            ty::TyClosure(..)\n-            | ty::TyGenerator(..)\n-            | ty::TyGeneratorWitness(..)\n-            | ty::TyBool\n-            | ty::TyChar\n-            | ty::TyInt(..)\n-            | ty::TyUint(..)\n-            | ty::TyFloat(..)\n-            | ty::TyAdt(..)\n-            | ty::TyStr\n-            | ty::TyError\n-            | ty::TyArray(..)\n-            | ty::TySlice(..)\n-            | ty::TyRawPtr(..)\n-            | ty::TyRef(..)\n-            | ty::TyFnDef(..)\n-            | ty::TyFnPtr(_)\n-            | ty::TyDynamic(..)\n-            | ty::TyNever\n-            | ty::TyTuple(..)\n-            | ty::TyProjection(..)\n-            | ty::TyForeign(..)\n-            | ty::TyParam(..)\n-            | ty::TyAnon(..) => {\n+            ty::Closure(..)\n+            | ty::Generator(..)\n+            | ty::GeneratorWitness(..)\n+            | ty::Bool\n+            | ty::Char\n+            | ty::Int(..)\n+            | ty::Uint(..)\n+            | ty::Float(..)\n+            | ty::Adt(..)\n+            | ty::Str\n+            | ty::Error\n+            | ty::Array(..)\n+            | ty::Slice(..)\n+            | ty::RawPtr(..)\n+            | ty::Ref(..)\n+            | ty::FnDef(..)\n+            | ty::FnPtr(_)\n+            | ty::Dynamic(..)\n+            | ty::Never\n+            | ty::Tuple(..)\n+            | ty::Projection(..)\n+            | ty::Foreign(..)\n+            | ty::Param(..)\n+            | ty::Anon(..) => {\n                 if t.flags.intersects(self.needs_canonical_flags) {\n                     t.super_fold_with(self)\n                 } else {\n@@ -327,7 +327,7 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n         if !value.has_type_flags(needs_canonical_flags) {\n             let out_value = gcx.lift(value).unwrap();\n             let canon_value = Canonical {\n-                variables: Slice::empty(),\n+                variables: List::empty(),\n                 value: out_value,\n             };\n             return canon_value;"}, {"sha": "cb1e39bb9f7428d033f52306b761ec2d84835fe1", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -40,7 +40,7 @@ use std::ops::Index;\n use syntax::source_map::Span;\n use ty::fold::TypeFoldable;\n use ty::subst::Kind;\n-use ty::{self, CanonicalVar, Lift, Region, Slice, TyCtxt};\n+use ty::{self, CanonicalVar, Lift, Region, List, TyCtxt};\n \n mod canonicalizer;\n \n@@ -57,7 +57,7 @@ pub struct Canonical<'gcx, V> {\n     pub value: V,\n }\n \n-pub type CanonicalVarInfos<'gcx> = &'gcx Slice<CanonicalVarInfo>;\n+pub type CanonicalVarInfos<'gcx> = &'gcx List<CanonicalVarInfo>;\n \n impl<'gcx> UseSpecializedDecodable for CanonicalVarInfos<'gcx> {}\n \n@@ -221,7 +221,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     fn fresh_inference_vars_for_canonical_vars(\n         &self,\n         span: Span,\n-        variables: &Slice<CanonicalVarInfo>,\n+        variables: &List<CanonicalVarInfo>,\n     ) -> CanonicalVarValues<'tcx> {\n         let var_values: IndexVec<CanonicalVar, Kind<'tcx>> = variables\n             .iter()"}, {"sha": "341089d8a815fcae015207ade5208a22dee211cc", "filename": "src/librustc/infer/canonical/query_result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -421,7 +421,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n             match result_value.unpack() {\n                 UnpackedKind::Type(result_value) => {\n                     // e.g., here `result_value` might be `?0` in the example above...\n-                    if let ty::TyInfer(ty::InferTy::CanonicalTy(index)) = result_value.sty {\n+                    if let ty::Infer(ty::InferTy::CanonicalTy(index)) = result_value.sty {\n                         // in which case we would set `canonical_vars[0]` to `Some(?U)`.\n                         opt_values[index] = Some(*original_value);\n                     }"}, {"sha": "f3fe01d5fd121659b064b389ac35e240fb200034", "filename": "src/librustc/infer/canonical/substitute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -85,7 +85,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for CanonicalVarValuesSubst<'cx, 'g\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         match t.sty {\n-            ty::TyInfer(ty::InferTy::CanonicalTy(c)) => {\n+            ty::Infer(ty::InferTy::CanonicalTy(c)) => {\n                 match self.var_values.var_values[c].unpack() {\n                     UnpackedKind::Type(ty) => ty,\n                     r => bug!(\"{:?} is a type but value is {:?}\", c, r),"}, {"sha": "4738a03cbd3ec4177f2ecf1a7905b6a334aaf5b1", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -76,44 +76,44 @@ impl<'infcx, 'gcx, 'tcx> InferCtxt<'infcx, 'gcx, 'tcx> {\n \n         match (&a.sty, &b.sty) {\n             // Relate integral variables to other types\n-            (&ty::TyInfer(ty::IntVar(a_id)), &ty::TyInfer(ty::IntVar(b_id))) => {\n+            (&ty::Infer(ty::IntVar(a_id)), &ty::Infer(ty::IntVar(b_id))) => {\n                 self.int_unification_table\n                     .borrow_mut()\n                     .unify_var_var(a_id, b_id)\n                     .map_err(|e| int_unification_error(a_is_expected, e))?;\n                 Ok(a)\n             }\n-            (&ty::TyInfer(ty::IntVar(v_id)), &ty::TyInt(v)) => {\n+            (&ty::Infer(ty::IntVar(v_id)), &ty::Int(v)) => {\n                 self.unify_integral_variable(a_is_expected, v_id, IntType(v))\n             }\n-            (&ty::TyInt(v), &ty::TyInfer(ty::IntVar(v_id))) => {\n+            (&ty::Int(v), &ty::Infer(ty::IntVar(v_id))) => {\n                 self.unify_integral_variable(!a_is_expected, v_id, IntType(v))\n             }\n-            (&ty::TyInfer(ty::IntVar(v_id)), &ty::TyUint(v)) => {\n+            (&ty::Infer(ty::IntVar(v_id)), &ty::Uint(v)) => {\n                 self.unify_integral_variable(a_is_expected, v_id, UintType(v))\n             }\n-            (&ty::TyUint(v), &ty::TyInfer(ty::IntVar(v_id))) => {\n+            (&ty::Uint(v), &ty::Infer(ty::IntVar(v_id))) => {\n                 self.unify_integral_variable(!a_is_expected, v_id, UintType(v))\n             }\n \n             // Relate floating-point variables to other types\n-            (&ty::TyInfer(ty::FloatVar(a_id)), &ty::TyInfer(ty::FloatVar(b_id))) => {\n+            (&ty::Infer(ty::FloatVar(a_id)), &ty::Infer(ty::FloatVar(b_id))) => {\n                 self.float_unification_table\n                     .borrow_mut()\n                     .unify_var_var(a_id, b_id)\n                     .map_err(|e| float_unification_error(relation.a_is_expected(), e))?;\n                 Ok(a)\n             }\n-            (&ty::TyInfer(ty::FloatVar(v_id)), &ty::TyFloat(v)) => {\n+            (&ty::Infer(ty::FloatVar(v_id)), &ty::Float(v)) => {\n                 self.unify_float_variable(a_is_expected, v_id, v)\n             }\n-            (&ty::TyFloat(v), &ty::TyInfer(ty::FloatVar(v_id))) => {\n+            (&ty::Float(v), &ty::Infer(ty::FloatVar(v_id))) => {\n                 self.unify_float_variable(!a_is_expected, v_id, v)\n             }\n \n             // All other cases of inference are errors\n-            (&ty::TyInfer(_), _) |\n-            (_, &ty::TyInfer(_)) => {\n+            (&ty::Infer(_), _) |\n+            (_, &ty::Infer(_)) => {\n                 Err(TypeError::Sorts(ty::relate::expected_found(relation, &a, &b)))\n             }\n \n@@ -393,7 +393,7 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n         // subtyping. This is basically our \"occurs check\", preventing\n         // us from creating infinitely sized types.\n         match t.sty {\n-            ty::TyInfer(ty::TyVar(vid)) => {\n+            ty::Infer(ty::TyVar(vid)) => {\n                 let mut variables = self.infcx.type_variables.borrow_mut();\n                 let vid = variables.root_var(vid);\n                 let sub_vid = variables.sub_root_var(vid);\n@@ -433,8 +433,8 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                     }\n                 }\n             }\n-            ty::TyInfer(ty::IntVar(_)) |\n-            ty::TyInfer(ty::FloatVar(_)) => {\n+            ty::Infer(ty::IntVar(_)) |\n+            ty::Infer(ty::FloatVar(_)) => {\n                 // No matter what mode we are in,\n                 // integer/floating-point types must be equal to be\n                 // relatable."}, {"sha": "26eb2ffbf6aba763e12245a9d92c53d3fa52ba96", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -75,17 +75,17 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         let a = infcx.type_variables.borrow_mut().replace_if_possible(a);\n         let b = infcx.type_variables.borrow_mut().replace_if_possible(b);\n         match (&a.sty, &b.sty) {\n-            (&ty::TyInfer(TyVar(a_id)), &ty::TyInfer(TyVar(b_id))) => {\n+            (&ty::Infer(TyVar(a_id)), &ty::Infer(TyVar(b_id))) => {\n                 infcx.type_variables.borrow_mut().equate(a_id, b_id);\n                 Ok(a)\n             }\n \n-            (&ty::TyInfer(TyVar(a_id)), _) => {\n+            (&ty::Infer(TyVar(a_id)), _) => {\n                 self.fields.instantiate(b, RelationDir::EqTo, a_id, self.a_is_expected)?;\n                 Ok(a)\n             }\n \n-            (_, &ty::TyInfer(TyVar(b_id))) => {\n+            (_, &ty::Infer(TyVar(b_id))) => {\n                 self.fields.instantiate(a, RelationDir::EqTo, b_id, self.a_is_expected)?;\n                 Ok(a)\n             }"}, {"sha": "02da3701db2979336de640f56aa51d337769bac3", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -66,7 +66,7 @@ use hir::map as hir_map;\n use hir::def_id::DefId;\n use middle::region;\n use traits::{ObligationCause, ObligationCauseCode};\n-use ty::{self, subst::Subst, Region, Ty, TyCtxt, TypeFoldable, TypeVariants};\n+use ty::{self, subst::Subst, Region, Ty, TyCtxt, TypeFoldable, TyKind};\n use ty::error::TypeError;\n use syntax::ast::DUMMY_NODE_ID;\n use syntax_pos::{Pos, Span};\n@@ -484,7 +484,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 // if they are both \"path types\", there's a chance of ambiguity\n                 // due to different versions of the same crate\n                 match (&exp_found.expected.sty, &exp_found.found.sty) {\n-                    (&ty::TyAdt(exp_adt, _), &ty::TyAdt(found_adt, _)) => {\n+                    (&ty::Adt(exp_adt, _), &ty::Adt(found_adt, _)) => {\n                         report_path_match(err, exp_adt.did, found_adt.did);\n                     }\n                     _ => (),\n@@ -636,7 +636,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 self.highlight_outer(&mut t1_out, &mut t2_out, path, sub, i, &other_ty);\n                 return Some(());\n             }\n-            if let &ty::TyAdt(def, _) = &ta.sty {\n+            if let &ty::Adt(def, _) = &ta.sty {\n                 let path_ = self.tcx.item_path_str(def.did.clone());\n                 if path_ == other_path {\n                     self.highlight_outer(&mut t1_out, &mut t2_out, path, sub, i, &other_ty);\n@@ -704,14 +704,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         fn equals<'tcx>(a: &Ty<'tcx>, b: &Ty<'tcx>) -> bool {\n             match (&a.sty, &b.sty) {\n                 (a, b) if *a == *b => true,\n-                (&ty::TyInt(_), &ty::TyInfer(ty::InferTy::IntVar(_)))\n-                | (&ty::TyInfer(ty::InferTy::IntVar(_)), &ty::TyInt(_))\n-                | (&ty::TyInfer(ty::InferTy::IntVar(_)), &ty::TyInfer(ty::InferTy::IntVar(_)))\n-                | (&ty::TyFloat(_), &ty::TyInfer(ty::InferTy::FloatVar(_)))\n-                | (&ty::TyInfer(ty::InferTy::FloatVar(_)), &ty::TyFloat(_))\n+                (&ty::Int(_), &ty::Infer(ty::InferTy::IntVar(_)))\n+                | (&ty::Infer(ty::InferTy::IntVar(_)), &ty::Int(_))\n+                | (&ty::Infer(ty::InferTy::IntVar(_)), &ty::Infer(ty::InferTy::IntVar(_)))\n+                | (&ty::Float(_), &ty::Infer(ty::InferTy::FloatVar(_)))\n+                | (&ty::Infer(ty::InferTy::FloatVar(_)), &ty::Float(_))\n                 | (\n-                    &ty::TyInfer(ty::InferTy::FloatVar(_)),\n-                    &ty::TyInfer(ty::InferTy::FloatVar(_)),\n+                    &ty::Infer(ty::InferTy::FloatVar(_)),\n+                    &ty::Infer(ty::InferTy::FloatVar(_)),\n                 ) => true,\n                 _ => false,\n             }\n@@ -738,7 +738,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         match (&t1.sty, &t2.sty) {\n-            (&ty::TyAdt(def1, sub1), &ty::TyAdt(def2, sub2)) => {\n+            (&ty::Adt(def1, sub1), &ty::Adt(def2, sub2)) => {\n                 let sub_no_defaults_1 = self.strip_generic_default_params(def1.did, sub1);\n                 let sub_no_defaults_2 = self.strip_generic_default_params(def2.did, sub2);\n                 let mut values = (DiagnosticStyledString::new(), DiagnosticStyledString::new());\n@@ -877,22 +877,22 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             // When finding T != &T, highlight only the borrow\n-            (&ty::TyRef(r1, ref_ty1, mutbl1), _) if equals(&ref_ty1, &t2) => {\n+            (&ty::Ref(r1, ref_ty1, mutbl1), _) if equals(&ref_ty1, &t2) => {\n                 let mut values = (DiagnosticStyledString::new(), DiagnosticStyledString::new());\n                 push_ty_ref(&r1, ref_ty1, mutbl1, &mut values.0);\n                 values.1.push_normal(t2.to_string());\n                 values\n             }\n-            (_, &ty::TyRef(r2, ref_ty2, mutbl2)) if equals(&t1, &ref_ty2) => {\n+            (_, &ty::Ref(r2, ref_ty2, mutbl2)) if equals(&t1, &ref_ty2) => {\n                 let mut values = (DiagnosticStyledString::new(), DiagnosticStyledString::new());\n                 values.0.push_normal(t1.to_string());\n                 push_ty_ref(&r2, ref_ty2, mutbl2, &mut values.1);\n                 values\n             }\n \n             // When encountering &T != &mut T, highlight only the borrow\n-            (&ty::TyRef(r1, ref_ty1, mutbl1),\n-             &ty::TyRef(r2, ref_ty2, mutbl2)) if equals(&ref_ty1, &ref_ty2) => {\n+            (&ty::Ref(r1, ref_ty1, mutbl1),\n+             &ty::Ref(r2, ref_ty2, mutbl2)) if equals(&ref_ty1, &ref_ty2) => {\n                 let mut values = (DiagnosticStyledString::new(), DiagnosticStyledString::new());\n                 push_ty_ref(&r1, ref_ty1, mutbl1, &mut values.0);\n                 push_ty_ref(&r2, ref_ty2, mutbl2, &mut values.1);\n@@ -979,14 +979,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 (_, false, _) => {\n                     if let Some(exp_found) = exp_found {\n                         let (def_id, ret_ty) = match exp_found.found.sty {\n-                            TypeVariants::TyFnDef(def, _) => {\n+                            TyKind::FnDef(def, _) => {\n                                 (Some(def), Some(self.tcx.fn_sig(def).output()))\n                             }\n                             _ => (None, None),\n                         };\n \n                         let exp_is_struct = match exp_found.expected.sty {\n-                            TypeVariants::TyAdt(def, _) => def.is_struct(),\n+                            TyKind::Adt(def, _) => def.is_struct(),\n                             _ => false,\n                         };\n \n@@ -1123,7 +1123,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         let type_param = generics.type_param(param, self.tcx);\n                         let hir = &self.tcx.hir;\n                         hir.as_local_node_id(type_param.def_id).map(|id| {\n-                            // Get the `hir::TyParam` to verify whether it already has any bounds.\n+                            // Get the `hir::Param` to verify whether it already has any bounds.\n                             // We do this to avoid suggesting code that ends up as `T: 'a'b`,\n                             // instead we suggest `T: 'a + 'b` in that case.\n                             let mut has_bounds = false;"}, {"sha": "505b1bc032d2021b9dbe6457c07b8015b460c049", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -12,7 +12,7 @@ use hir::{self, Local, Pat, Body, HirId};\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use infer::InferCtxt;\n use infer::type_variable::TypeVariableOrigin;\n-use ty::{self, Ty, TyInfer, TyVar};\n+use ty::{self, Ty, Infer, TyVar};\n use syntax::source_map::CompilerDesugaringKind;\n use syntax_pos::Span;\n use errors::DiagnosticBuilder;\n@@ -35,7 +35,7 @@ impl<'a, 'gcx, 'tcx> FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n                 let ty = self.infcx.resolve_type_vars_if_possible(&ty);\n                 ty.walk().any(|inner_ty| {\n                     inner_ty == *self.target_ty || match (&inner_ty.sty, &self.target_ty.sty) {\n-                        (&TyInfer(TyVar(a_vid)), &TyInfer(TyVar(b_vid))) => {\n+                        (&Infer(TyVar(a_vid)), &Infer(TyVar(b_vid))) => {\n                             self.infcx\n                                 .type_variables\n                                 .borrow_mut()\n@@ -75,7 +75,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn extract_type_name(&self, ty: &'a Ty<'tcx>) -> String {\n-        if let ty::TyInfer(ty::TyVar(ty_vid)) = (*ty).sty {\n+        if let ty::Infer(ty::TyVar(ty_vid)) = (*ty).sty {\n             let ty_vars = self.type_variables.borrow();\n             if let TypeVariableOrigin::TypeParameterDefinition(_, name) =\n                 *ty_vars.var_origin(ty_vid) {"}, {"sha": "8cb0df18bc8fff5c96e786b0173323539ada4d52", "filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -162,7 +162,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     ) -> Option<Span> {\n         let ret_ty = self.tcx.type_of(scope_def_id);\n         match ret_ty.sty {\n-            ty::TyFnDef(_, _) => {\n+            ty::FnDef(_, _) => {\n                 let sig = ret_ty.fn_sig(self.tcx);\n                 let late_bound_regions = self.tcx\n                     .collect_referenced_late_bound_regions(&sig.output());\n@@ -181,7 +181,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     ) -> bool {\n         let ret_ty = self.tcx.type_of(scope_def_id);\n         match ret_ty.sty {\n-            ty::TyFnDef(_, _) => {\n+            ty::FnDef(_, _) => {\n                 let sig = ret_ty.fn_sig(self.tcx);\n                 let output = self.tcx.erase_late_bound_regions(&sig.output());\n                 return output.is_impl_trait();"}, {"sha": "4673aac1872ffb94fef08677e182cee5462e0c4c", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -133,15 +133,15 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n         let tcx = self.infcx.tcx;\n \n         match t.sty {\n-            ty::TyInfer(ty::TyVar(v)) => {\n+            ty::Infer(ty::TyVar(v)) => {\n                 let opt_ty = self.infcx.type_variables.borrow_mut().probe(v).known();\n                 self.freshen(\n                     opt_ty,\n                     ty::TyVar(v),\n                     ty::FreshTy)\n             }\n \n-            ty::TyInfer(ty::IntVar(v)) => {\n+            ty::Infer(ty::IntVar(v)) => {\n                 self.freshen(\n                     self.infcx.int_unification_table.borrow_mut()\n                                                     .probe_value(v)\n@@ -150,7 +150,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n                     ty::FreshIntTy)\n             }\n \n-            ty::TyInfer(ty::FloatVar(v)) => {\n+            ty::Infer(ty::FloatVar(v)) => {\n                 self.freshen(\n                     self.infcx.float_unification_table.borrow_mut()\n                                                       .probe_value(v)\n@@ -159,9 +159,9 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n                     ty::FreshFloatTy)\n             }\n \n-            ty::TyInfer(ty::FreshTy(c)) |\n-            ty::TyInfer(ty::FreshIntTy(c)) |\n-            ty::TyInfer(ty::FreshFloatTy(c)) => {\n+            ty::Infer(ty::FreshTy(c)) |\n+            ty::Infer(ty::FreshIntTy(c)) |\n+            ty::Infer(ty::FreshFloatTy(c)) => {\n                 if c >= self.freshen_count {\n                     bug!(\"Encountered a freshend type with id {} \\\n                           but our counter is only at {}\",\n@@ -171,33 +171,33 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n                 t\n             }\n \n-            ty::TyInfer(ty::CanonicalTy(..)) =>\n+            ty::Infer(ty::CanonicalTy(..)) =>\n                 bug!(\"encountered canonical ty during freshening\"),\n \n-            ty::TyGenerator(..) |\n-            ty::TyBool |\n-            ty::TyChar |\n-            ty::TyInt(..) |\n-            ty::TyUint(..) |\n-            ty::TyFloat(..) |\n-            ty::TyAdt(..) |\n-            ty::TyStr |\n-            ty::TyError |\n-            ty::TyArray(..) |\n-            ty::TySlice(..) |\n-            ty::TyRawPtr(..) |\n-            ty::TyRef(..) |\n-            ty::TyFnDef(..) |\n-            ty::TyFnPtr(_) |\n-            ty::TyDynamic(..) |\n-            ty::TyNever |\n-            ty::TyTuple(..) |\n-            ty::TyProjection(..) |\n-            ty::TyForeign(..) |\n-            ty::TyParam(..) |\n-            ty::TyClosure(..) |\n-            ty::TyGeneratorWitness(..) |\n-            ty::TyAnon(..) => {\n+            ty::Generator(..) |\n+            ty::Bool |\n+            ty::Char |\n+            ty::Int(..) |\n+            ty::Uint(..) |\n+            ty::Float(..) |\n+            ty::Adt(..) |\n+            ty::Str |\n+            ty::Error |\n+            ty::Array(..) |\n+            ty::Slice(..) |\n+            ty::RawPtr(..) |\n+            ty::Ref(..) |\n+            ty::FnDef(..) |\n+            ty::FnPtr(_) |\n+            ty::Dynamic(..) |\n+            ty::Never |\n+            ty::Tuple(..) |\n+            ty::Projection(..) |\n+            ty::Foreign(..) |\n+            ty::Param(..) |\n+            ty::Closure(..) |\n+            ty::GeneratorWitness(..) |\n+            ty::Anon(..) => {\n                 t.super_fold_with(self)\n             }\n         }"}, {"sha": "39dc24b86e72a8851c08aa06894eefb91f4fb3df", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -123,7 +123,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFudger<'a, 'gcx, 'tcx> {\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         match ty.sty {\n-            ty::TyInfer(ty::InferTy::TyVar(vid)) => {\n+            ty::Infer(ty::InferTy::TyVar(vid)) => {\n                 match self.type_variables.get(&vid) {\n                     None => {\n                         // This variable was created before the"}, {"sha": "6848c625b5a1ff7fe6bac250f2b27aef24bcb905", "filename": "src/librustc/infer/lattice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flattice.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -88,12 +88,12 @@ pub fn super_lattice_tys<'a, 'gcx, 'tcx, L>(this: &mut L,\n         // is (e.g.) `Box<i32>`. A more obvious solution might be to\n         // iterate on the subtype obligations that are returned, but I\n         // think this suffices. -nmatsakis\n-        (&ty::TyInfer(TyVar(..)), _) => {\n+        (&ty::Infer(TyVar(..)), _) => {\n             let v = infcx.next_ty_var(TypeVariableOrigin::LatticeVariable(this.cause().span));\n             this.relate_bound(v, b, a)?;\n             Ok(v)\n         }\n-        (_, &ty::TyInfer(TyVar(..))) => {\n+        (_, &ty::Infer(TyVar(..))) => {\n             let v = infcx.next_ty_var(TypeVariableOrigin::LatticeVariable(this.cause().span));\n             this.relate_bound(v, a, b)?;\n             Ok(v)"}, {"sha": "a3c9d14eef2954f1530ed8f1cf997fe63f668417", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -546,7 +546,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn type_var_diverges(&'a self, ty: Ty) -> bool {\n         match ty.sty {\n-            ty::TyInfer(ty::TyVar(vid)) => self.type_variables.borrow().var_diverges(vid),\n+            ty::Infer(ty::TyVar(vid)) => self.type_variables.borrow().var_diverges(vid),\n             _ => false\n         }\n     }\n@@ -559,14 +559,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         use ty::error::UnconstrainedNumeric::Neither;\n         use ty::error::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat};\n         match ty.sty {\n-            ty::TyInfer(ty::IntVar(vid)) => {\n+            ty::Infer(ty::IntVar(vid)) => {\n                 if self.int_unification_table.borrow_mut().probe_value(vid).is_some() {\n                     Neither\n                 } else {\n                     UnconstrainedInt\n                 }\n             },\n-            ty::TyInfer(ty::FloatVar(vid)) => {\n+            ty::Infer(ty::FloatVar(vid)) => {\n                 if self.float_unification_table.borrow_mut().probe_value(vid).is_some() {\n                     Neither\n                 } else {\n@@ -1118,7 +1118,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn shallow_resolve(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n         match typ.sty {\n-            ty::TyInfer(ty::TyVar(v)) => {\n+            ty::Infer(ty::TyVar(v)) => {\n                 // Not entirely obvious: if `typ` is a type variable,\n                 // it can be resolved to an int/float variable, which\n                 // can then be recursively resolved, hence the\n@@ -1135,15 +1135,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                    .unwrap_or(typ)\n             }\n \n-            ty::TyInfer(ty::IntVar(v)) => {\n+            ty::Infer(ty::IntVar(v)) => {\n                 self.int_unification_table\n                     .borrow_mut()\n                     .probe_value(v)\n                     .map(|v| v.to_type(self.tcx))\n                     .unwrap_or(typ)\n             }\n \n-            ty::TyInfer(ty::FloatVar(v)) => {\n+            ty::Infer(ty::FloatVar(v)) => {\n                 self.float_unification_table\n                     .borrow_mut()\n                     .probe_value(v)\n@@ -1210,12 +1210,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     // [Note-Type-error-reporting]\n-    // An invariant is that anytime the expected or actual type is TyError (the special\n+    // An invariant is that anytime the expected or actual type is Error (the special\n     // error type, meaning that an error occurred when typechecking this expression),\n     // this is a derived error. The error cascaded from another error (that was already\n     // reported), so it's not useful to display it to the user.\n     // The following methods implement this logic.\n-    // They check if either the actual or expected type is TyError, and don't print the error\n+    // They check if either the actual or expected type is Error, and don't print the error\n     // in this case. The typechecker should only ever report type errors involving mismatched\n     // types using one of these methods, and should not call span_err directly for such\n     // errors.\n@@ -1230,7 +1230,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let actual_ty = self.resolve_type_vars_if_possible(&actual_ty);\n         debug!(\"type_error_struct_with_diag({:?}, {:?})\", sp, actual_ty);\n \n-        // Don't report an error if actual type is TyError.\n+        // Don't report an error if actual type is Error.\n         if actual_ty.references_error() {\n             return self.tcx.sess.diagnostic().struct_dummy();\n         }"}, {"sha": "817280b97e0315f8997e76e31c95dc70352eefbd", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -450,8 +450,8 @@ where\n \n     fn type_bound(&self, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n         match ty.sty {\n-            ty::TyParam(p) => self.param_bound(p),\n-            ty::TyProjection(data) => {\n+            ty::Param(p) => self.param_bound(p),\n+            ty::Projection(data) => {\n                 let declared_bounds = self.projection_declared_bounds(data);\n                 self.projection_bound(declared_bounds, data)\n             }"}, {"sha": "be13fb9a2a5ebf8818925001a71e5d0bea08e7e4", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -104,7 +104,7 @@ impl<'a, 'gcx, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeFinder<'a, 'gcx, 'tcx>\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n         let t = self.infcx.shallow_resolve(t);\n         if t.has_infer_types() {\n-            if let ty::TyInfer(_) = t.sty {\n+            if let ty::Infer(_) = t.sty {\n                 // Since we called `shallow_resolve` above, this must\n                 // be an (as yet...) unresolved inference variable.\n                 true\n@@ -158,19 +158,19 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for FullTypeResolver<'a, 'gcx, 'tcx>\n         } else {\n             let t = self.infcx.shallow_resolve(t);\n             match t.sty {\n-                ty::TyInfer(ty::TyVar(vid)) => {\n+                ty::Infer(ty::TyVar(vid)) => {\n                     self.err = Some(FixupError::UnresolvedTy(vid));\n                     self.tcx().types.err\n                 }\n-                ty::TyInfer(ty::IntVar(vid)) => {\n+                ty::Infer(ty::IntVar(vid)) => {\n                     self.err = Some(FixupError::UnresolvedIntTy(vid));\n                     self.tcx().types.err\n                 }\n-                ty::TyInfer(ty::FloatVar(vid)) => {\n+                ty::Infer(ty::FloatVar(vid)) => {\n                     self.err = Some(FixupError::UnresolvedFloatTy(vid));\n                     self.tcx().types.err\n                 }\n-                ty::TyInfer(_) => {\n+                ty::Infer(_) => {\n                     bug!(\"Unexpected type in full type resolver: {:?}\", t);\n                 }\n                 _ => {"}, {"sha": "048810c042722f552de6844b3e5862f1d13b9a53", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -80,7 +80,7 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         let a = infcx.type_variables.borrow_mut().replace_if_possible(a);\n         let b = infcx.type_variables.borrow_mut().replace_if_possible(b);\n         match (&a.sty, &b.sty) {\n-            (&ty::TyInfer(TyVar(a_vid)), &ty::TyInfer(TyVar(b_vid))) => {\n+            (&ty::Infer(TyVar(a_vid)), &ty::Infer(TyVar(b_vid))) => {\n                 // Shouldn't have any LBR here, so we can safely put\n                 // this under a binder below without fear of accidental\n                 // capture.\n@@ -106,17 +106,17 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n \n                 Ok(a)\n             }\n-            (&ty::TyInfer(TyVar(a_id)), _) => {\n+            (&ty::Infer(TyVar(a_id)), _) => {\n                 self.fields\n                     .instantiate(b, RelationDir::SupertypeOf, a_id, !self.a_is_expected)?;\n                 Ok(a)\n             }\n-            (_, &ty::TyInfer(TyVar(b_id))) => {\n+            (_, &ty::Infer(TyVar(b_id))) => {\n                 self.fields.instantiate(a, RelationDir::SubtypeOf, b_id, self.a_is_expected)?;\n                 Ok(a)\n             }\n \n-            (&ty::TyError, _) | (_, &ty::TyError) => {\n+            (&ty::Error, _) | (_, &ty::Error) => {\n                 infcx.set_tainted_by_errors();\n                 Ok(self.tcx().types.err)\n             }"}, {"sha": "b1e4fc7c7fc7b1127e9192bf3dcbbd72162ceb17", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -245,7 +245,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     /// instantiated. Otherwise, returns `t`.\n     pub fn replace_if_possible(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         match t.sty {\n-            ty::TyInfer(ty::TyVar(v)) => {\n+            ty::Infer(ty::TyVar(v)) => {\n                 match self.probe(v) {\n                     TypeVariableValue::Unknown { .. } => t,\n                     TypeVariableValue::Known { value } => value,"}, {"sha": "ba04842ac7c0a1bcda1021f2682ca354eadbbceb", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -105,19 +105,19 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn handle_field_access(&mut self, lhs: &hir::Expr, node_id: ast::NodeId) {\n         match self.tables.expr_ty_adjusted(lhs).sty {\n-            ty::TyAdt(def, _) => {\n+            ty::Adt(def, _) => {\n                 let index = self.tcx.field_index(node_id, self.tables);\n                 self.insert_def_id(def.non_enum_variant().fields[index].did);\n             }\n-            ty::TyTuple(..) => {}\n+            ty::Tuple(..) => {}\n             _ => span_bug!(lhs.span, \"named field access on non-ADT\"),\n         }\n     }\n \n     fn handle_field_pattern_match(&mut self, lhs: &hir::Pat, def: Def,\n                                   pats: &[source_map::Spanned<hir::FieldPat>]) {\n         let variant = match self.tables.node_id_to_type(lhs.hir_id).sty {\n-            ty::TyAdt(adt, _) => adt.variant_of_def(def),\n+            ty::Adt(adt, _) => adt.variant_of_def(def),\n             _ => span_bug!(lhs.span, \"non-ADT in struct pattern\")\n         };\n         for pat in pats {\n@@ -236,7 +236,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n                 self.handle_field_access(&lhs, expr.id);\n             }\n             hir::ExprKind::Struct(_, ref fields, _) => {\n-                if let ty::TypeVariants::TyAdt(ref adt, _) = self.tables.expr_ty(expr).sty {\n+                if let ty::Adt(ref adt, _) = self.tables.expr_ty(expr).sty {\n                     self.mark_as_used_if_union(adt, fields);\n                 }\n             }"}, {"sha": "90692bcd30103303fa1df4cecade47c976500d7d", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -457,7 +457,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 // make sure that the thing we are pointing out stays valid\n                 // for the lifetime `scope_r` of the resulting ptr:\n                 let expr_ty = return_if_err!(self.mc.expr_ty(expr));\n-                if let ty::TyRef(r, _, _) = expr_ty.sty {\n+                if let ty::Ref(r, _, _) = expr_ty.sty {\n                     let bk = ty::BorrowKind::from_mutbl(m);\n                     self.borrow_expr(&base, r, bk, AddrOf);\n                 }\n@@ -551,10 +551,10 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"walk_callee: callee={:?} callee_ty={:?}\",\n                callee, callee_ty);\n         match callee_ty.sty {\n-            ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n+            ty::FnDef(..) | ty::FnPtr(_) => {\n                 self.consume_expr(callee);\n             }\n-            ty::TyError => { }\n+            ty::Error => { }\n             _ => {\n                 if let Some(def) = self.mc.tables.type_dependent_defs().get(call.hir_id) {\n                     let def_id = def.def_id();\n@@ -659,7 +659,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         // Select just those fields of the `with`\n         // expression that will actually be used\n         match with_cmt.ty.sty {\n-            ty::TyAdt(adt, substs) if adt.is_struct() => {\n+            ty::Adt(adt, substs) if adt.is_struct() => {\n                 // Consume those fields of the with expression that are needed.\n                 for (f_index, with_field) in adt.non_enum_variant().fields.iter().enumerate() {\n                     let is_mentioned = fields.iter().any(|f| {\n@@ -867,7 +867,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                     // It is also a borrow or copy/move of the value being matched.\n                     match bm {\n                         ty::BindByReference(m) => {\n-                            if let ty::TyRef(r, _, _) = pat_ty.sty {\n+                            if let ty::Ref(r, _, _) = pat_ty.sty {\n                                 let bk = ty::BorrowKind::from_mutbl(m);\n                                 delegate.borrow(pat.id, pat.span, &cmt_pat, r, bk, RefBinding);\n                             }"}, {"sha": "8058f3dde668d8fd23f44eef940ecb1f15b929ed", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -41,7 +41,7 @@ fn unpack_option_like<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 ty: Ty<'tcx>)\n                                 -> Ty<'tcx> {\n     let (def, substs) = match ty.sty {\n-        ty::TyAdt(def, substs) => (def, substs),\n+        ty::Adt(def, substs) => (def, substs),\n         _ => return ty\n     };\n \n@@ -83,7 +83,7 @@ impl<'a, 'tcx> ExprVisitor<'a, 'tcx> {\n             // Special-case transmutting from `typeof(function)` and\n             // `Option<typeof(function)>` to present a clearer error.\n             let from = unpack_option_like(self.tcx.global_tcx(), from);\n-            if let (&ty::TyFnDef(..), SizeSkeleton::Known(size_to)) = (&from.sty, sk_to) {\n+            if let (&ty::FnDef(..), SizeSkeleton::Known(size_to)) = (&from.sty, sk_to) {\n                 if size_to == Pointer.size(self.tcx) {\n                     struct_span_err!(self.tcx.sess, span, E0591,\n                                      \"can't transmute zero-sized type\")"}, {"sha": "e0ed0f1da509ee30bace777fd56ebeaae91eebab", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -214,8 +214,8 @@ impl<'tcx> cmt_<'tcx> {\n     fn resolve_field(&self, field_index: usize) -> Option<(&'tcx ty::AdtDef, &'tcx ty::FieldDef)>\n     {\n         let adt_def = match self.ty.sty {\n-            ty::TyAdt(def, _) => def,\n-            ty::TyTuple(..) => return None,\n+            ty::Adt(def, _) => def,\n+            ty::Tuple(..) => return None,\n             // closures get `Categorization::Upvar` rather than `Categorization::Interior`\n             _ =>  bug!(\"interior cmt {:?} is not an ADT\", self)\n         };\n@@ -783,8 +783,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // FnOnce         | copied               | upvar -> &'up bk\n \n         let kind = match self.node_ty(fn_hir_id)?.sty {\n-            ty::TyGenerator(..) => ty::ClosureKind::FnOnce,\n-            ty::TyClosure(closure_def_id, closure_substs) => {\n+            ty::Generator(..) => ty::ClosureKind::FnOnce,\n+            ty::Closure(closure_def_id, closure_substs) => {\n                 match self.infcx {\n                     // During upvar inference we may not know the\n                     // closure kind, just use the LATTICE_BOTTOM value.\n@@ -893,7 +893,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // that the above is actually immutable and\n         // has a ref type.  However, nothing should\n         // actually look at the type, so we can get\n-        // away with stuffing a `TyError` in there\n+        // away with stuffing a `Error` in there\n         // instead of bothering to construct a proper\n         // one.\n         let cmt_result = cmt_ {\n@@ -956,7 +956,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         // Always promote `[T; 0]` (even when e.g. borrowed mutably).\n         let promotable = match expr_ty.sty {\n-            ty::TyArray(_, len) if len.assert_usize(self.tcx) == Some(0) => true,\n+            ty::Array(_, len) if len.assert_usize(self.tcx) == Some(0) => true,\n             _ => promotable,\n         };\n \n@@ -1035,7 +1035,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         let base_ty = self.expr_ty_adjusted(base)?;\n \n         let (region, mutbl) = match base_ty.sty {\n-            ty::TyRef(region, _, mutbl) => (region, mutbl),\n+            ty::Ref(region, _, mutbl) => (region, mutbl),\n             _ => {\n                 span_bug!(expr.span, \"cat_overloaded_place: base is not a reference\")\n             }\n@@ -1068,9 +1068,9 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         };\n \n         let ptr = match base_cmt.ty.sty {\n-            ty::TyAdt(def, ..) if def.is_box() => Unique,\n-            ty::TyRawPtr(ref mt) => UnsafePtr(mt.mutbl),\n-            ty::TyRef(r, _, mutbl) => {\n+            ty::Adt(def, ..) if def.is_box() => Unique,\n+            ty::RawPtr(ref mt) => UnsafePtr(mt.mutbl),\n+            ty::Ref(r, _, mutbl) => {\n                 let bk = ty::BorrowKind::from_mutbl(mutbl);\n                 BorrowedPtr(bk, r)\n             }\n@@ -1290,7 +1290,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 }\n                 Def::StructCtor(_, CtorKind::Fn) => {\n                     match self.pat_ty_unadjusted(&pat)?.sty {\n-                        ty::TyAdt(adt_def, _) => {\n+                        ty::Adt(adt_def, _) => {\n                             (cmt, adt_def.non_enum_variant().fields.len())\n                         }\n                         ref ty => {\n@@ -1343,7 +1343,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n           PatKind::Tuple(ref subpats, ddpos) => {\n             // (p1, ..., pN)\n             let expected_len = match self.pat_ty_unadjusted(&pat)?.sty {\n-                ty::TyTuple(ref tys) => tys.len(),\n+                ty::Tuple(ref tys) => tys.len(),\n                 ref ty => span_bug!(pat.span, \"tuple pattern unexpected type {:?}\", ty),\n             };\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {"}, {"sha": "66a42cfb11a749116b9f0e76a1d36255db9d12fe", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -2221,18 +2221,18 @@ impl<'tcx> Debug for Constant<'tcx> {\n \n /// Write a `ConstValue` in a way closer to the original source code than the `Debug` output.\n pub fn fmt_const_val(f: &mut impl Write, const_val: &ty::Const) -> fmt::Result {\n-    use ty::TypeVariants::*;\n+    use ty::TyKind::*;\n     let value = const_val.val;\n     let ty = const_val.ty;\n     // print some primitives\n     if let ConstValue::Scalar(Scalar::Bits { bits, .. }) = value {\n         match ty.sty {\n-            TyBool if bits == 0 => return write!(f, \"false\"),\n-            TyBool if bits == 1 => return write!(f, \"true\"),\n-            TyFloat(ast::FloatTy::F32) => return write!(f, \"{}f32\", Single::from_bits(bits)),\n-            TyFloat(ast::FloatTy::F64) => return write!(f, \"{}f64\", Double::from_bits(bits)),\n-            TyUint(ui) => return write!(f, \"{:?}{}\", bits, ui),\n-            TyInt(i) => {\n+            Bool if bits == 0 => return write!(f, \"false\"),\n+            Bool if bits == 1 => return write!(f, \"true\"),\n+            Float(ast::FloatTy::F32) => return write!(f, \"{}f32\", Single::from_bits(bits)),\n+            Float(ast::FloatTy::F64) => return write!(f, \"{}f64\", Double::from_bits(bits)),\n+            Uint(ui) => return write!(f, \"{:?}{}\", bits, ui),\n+            Int(i) => {\n                 let bit_width = ty::tls::with(|tcx| {\n                     let ty = tcx.lift_to_global(&ty).unwrap();\n                     tcx.layout_of(ty::ParamEnv::empty().and(ty))\n@@ -2243,19 +2243,19 @@ pub fn fmt_const_val(f: &mut impl Write, const_val: &ty::Const) -> fmt::Result {\n                 let shift = 128 - bit_width;\n                 return write!(f, \"{:?}{}\", ((bits as i128) << shift) >> shift, i);\n             }\n-            TyChar => return write!(f, \"{:?}\", ::std::char::from_u32(bits as u32).unwrap()),\n+            Char => return write!(f, \"{:?}\", ::std::char::from_u32(bits as u32).unwrap()),\n             _ => {},\n         }\n     }\n     // print function definitons\n-    if let TyFnDef(did, _) = ty.sty {\n+    if let FnDef(did, _) = ty.sty {\n         return write!(f, \"{}\", item_path_str(did));\n     }\n     // print string literals\n     if let ConstValue::ScalarPair(ptr, len) = value {\n         if let Scalar::Ptr(ptr) = ptr {\n             if let ScalarMaybeUndef::Scalar(Scalar::Bits { bits: len, .. }) = len {\n-                if let TyRef(_, &ty::TyS { sty: TyStr, .. }, _) = ty.sty {\n+                if let Ref(_, &ty::TyS { sty: Str, .. }, _) = ty.sty {\n                     return ty::tls::with(|tcx| {\n                         let alloc = tcx.alloc_map.lock().get(ptr.alloc_id);\n                         if let Some(interpret::AllocType::Memory(alloc)) = alloc {"}, {"sha": "ec395478ec6b57ecde1d4870368bae142aeca2fa", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -68,12 +68,12 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n                 let ty = self.to_ty(tcx);\n                 PlaceTy::Ty {\n                     ty: match ty.sty {\n-                        ty::TyArray(inner, size) => {\n+                        ty::Array(inner, size) => {\n                             let size = size.unwrap_usize(tcx);\n                             let len = size - (from as u64) - (to as u64);\n                             tcx.mk_array(inner, len)\n                         }\n-                        ty::TySlice(..) => ty,\n+                        ty::Slice(..) => ty,\n                         _ => {\n                             bug!(\"cannot subslice non-array type: `{:?}`\", self)\n                         }\n@@ -82,7 +82,7 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n             }\n             ProjectionElem::Downcast(adt_def1, index) =>\n                 match self.to_ty(tcx).sty {\n-                    ty::TyAdt(adt_def, substs) => {\n+                    ty::Adt(adt_def, substs) => {\n                         assert!(adt_def.is_enum());\n                         assert!(index < adt_def.variants.len());\n                         assert_eq!(adt_def, adt_def1);\n@@ -199,7 +199,7 @@ impl<'tcx> Rvalue<'tcx> {\n             }\n             Rvalue::Discriminant(ref place) => {\n                 let ty = place.ty(local_decls, tcx).to_ty(tcx);\n-                if let ty::TyAdt(adt_def, _) = ty.sty {\n+                if let ty::Adt(adt_def, _) = ty.sty {\n                     adt_def.repr.discr_type().to_ty(tcx)\n                 } else {\n                     // This can only be `0`, for now, so `u8` will suffice."}, {"sha": "ed95aa73078a92f5282e1137fd8a0b24d21fa969", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -606,8 +606,8 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         }\n \n         return match substs.type_at(0).sty {\n-            ty::TyParam(_) => true,\n-            ty::TyProjection(p) => self.is_of_param(p.substs),\n+            ty::Param(_) => true,\n+            ty::Projection(p) => self.is_of_param(p.substs),\n             _ => false,\n         };\n     }"}, {"sha": "c283c4d3caba38e9ffe521f09f4c31be069723dd", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -407,7 +407,7 @@ fn uncovered_tys<'tcx>(tcx: TyCtxt, ty: Ty<'tcx>, in_crate: InCrate)\n \n fn is_possibly_remote_type(ty: Ty, _in_crate: InCrate) -> bool {\n     match ty.sty {\n-        ty::TyProjection(..) | ty::TyParam(..) => true,\n+        ty::Projection(..) | ty::Param(..) => true,\n         _ => false,\n     }\n }\n@@ -419,9 +419,9 @@ fn ty_is_local(tcx: TyCtxt, ty: Ty, in_crate: InCrate) -> bool {\n \n fn fundamental_ty(tcx: TyCtxt, ty: Ty) -> bool {\n     match ty.sty {\n-        ty::TyRef(..) => true,\n-        ty::TyAdt(def, _) => def.is_fundamental(),\n-        ty::TyDynamic(ref data, ..) => {\n+        ty::Ref(..) => true,\n+        ty::Adt(def, _) => def.is_fundamental(),\n+        ty::Dynamic(ref data, ..) => {\n             data.principal().map_or(false, |p| tcx.has_attr(p.def_id(), \"fundamental\"))\n         }\n         _ => false\n@@ -441,49 +441,49 @@ fn ty_is_local_constructor(ty: Ty, in_crate: InCrate) -> bool {\n     debug!(\"ty_is_local_constructor({:?})\", ty);\n \n     match ty.sty {\n-        ty::TyBool |\n-        ty::TyChar |\n-        ty::TyInt(..) |\n-        ty::TyUint(..) |\n-        ty::TyFloat(..) |\n-        ty::TyStr |\n-        ty::TyFnDef(..) |\n-        ty::TyFnPtr(_) |\n-        ty::TyArray(..) |\n-        ty::TySlice(..) |\n-        ty::TyRawPtr(..) |\n-        ty::TyRef(..) |\n-        ty::TyNever |\n-        ty::TyTuple(..) |\n-        ty::TyParam(..) |\n-        ty::TyProjection(..) => {\n+        ty::Bool |\n+        ty::Char |\n+        ty::Int(..) |\n+        ty::Uint(..) |\n+        ty::Float(..) |\n+        ty::Str |\n+        ty::FnDef(..) |\n+        ty::FnPtr(_) |\n+        ty::Array(..) |\n+        ty::Slice(..) |\n+        ty::RawPtr(..) |\n+        ty::Ref(..) |\n+        ty::Never |\n+        ty::Tuple(..) |\n+        ty::Param(..) |\n+        ty::Projection(..) => {\n             false\n         }\n \n-        ty::TyInfer(..) => match in_crate {\n+        ty::Infer(..) => match in_crate {\n             InCrate::Local => false,\n             // The inference variable might be unified with a local\n             // type in that remote crate.\n             InCrate::Remote => true,\n         },\n \n-        ty::TyAdt(def, _) => def_id_is_local(def.did, in_crate),\n-        ty::TyForeign(did) => def_id_is_local(did, in_crate),\n+        ty::Adt(def, _) => def_id_is_local(def.did, in_crate),\n+        ty::Foreign(did) => def_id_is_local(did, in_crate),\n \n-        ty::TyDynamic(ref tt, ..) => {\n+        ty::Dynamic(ref tt, ..) => {\n             tt.principal().map_or(false, |p| {\n                 def_id_is_local(p.def_id(), in_crate)\n             })\n         }\n \n-        ty::TyError => {\n+        ty::Error => {\n             true\n         }\n \n-        ty::TyClosure(..) |\n-        ty::TyGenerator(..) |\n-        ty::TyGeneratorWitness(..) |\n-        ty::TyAnon(..) => {\n+        ty::Closure(..) |\n+        ty::Generator(..) |\n+        ty::GeneratorWitness(..) |\n+        ty::Anon(..) => {\n             bug!(\"ty_is_local invoked on unexpected type: {:?}\", ty)\n         }\n     }"}, {"sha": "0aa15a4ae0c2552db3ebab60dd5b9326a075563c", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -244,36 +244,36 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         /// if the type can be equated to any type.\n         fn type_category<'tcx>(t: Ty<'tcx>) -> Option<u32> {\n             match t.sty {\n-                ty::TyBool => Some(0),\n-                ty::TyChar => Some(1),\n-                ty::TyStr => Some(2),\n-                ty::TyInt(..) | ty::TyUint(..) | ty::TyInfer(ty::IntVar(..)) => Some(3),\n-                ty::TyFloat(..) | ty::TyInfer(ty::FloatVar(..)) => Some(4),\n-                ty::TyRef(..) | ty::TyRawPtr(..) => Some(5),\n-                ty::TyArray(..) | ty::TySlice(..) => Some(6),\n-                ty::TyFnDef(..) | ty::TyFnPtr(..) => Some(7),\n-                ty::TyDynamic(..) => Some(8),\n-                ty::TyClosure(..) => Some(9),\n-                ty::TyTuple(..) => Some(10),\n-                ty::TyProjection(..) => Some(11),\n-                ty::TyParam(..) => Some(12),\n-                ty::TyAnon(..) => Some(13),\n-                ty::TyNever => Some(14),\n-                ty::TyAdt(adt, ..) => match adt.adt_kind() {\n+                ty::Bool => Some(0),\n+                ty::Char => Some(1),\n+                ty::Str => Some(2),\n+                ty::Int(..) | ty::Uint(..) | ty::Infer(ty::IntVar(..)) => Some(3),\n+                ty::Float(..) | ty::Infer(ty::FloatVar(..)) => Some(4),\n+                ty::Ref(..) | ty::RawPtr(..) => Some(5),\n+                ty::Array(..) | ty::Slice(..) => Some(6),\n+                ty::FnDef(..) | ty::FnPtr(..) => Some(7),\n+                ty::Dynamic(..) => Some(8),\n+                ty::Closure(..) => Some(9),\n+                ty::Tuple(..) => Some(10),\n+                ty::Projection(..) => Some(11),\n+                ty::Param(..) => Some(12),\n+                ty::Anon(..) => Some(13),\n+                ty::Never => Some(14),\n+                ty::Adt(adt, ..) => match adt.adt_kind() {\n                     AdtKind::Struct => Some(15),\n                     AdtKind::Union => Some(16),\n                     AdtKind::Enum => Some(17),\n                 },\n-                ty::TyGenerator(..) => Some(18),\n-                ty::TyForeign(..) => Some(19),\n-                ty::TyGeneratorWitness(..) => Some(20),\n-                ty::TyInfer(..) | ty::TyError => None\n+                ty::Generator(..) => Some(18),\n+                ty::Foreign(..) => Some(19),\n+                ty::GeneratorWitness(..) => Some(20),\n+                ty::Infer(..) | ty::Error => None\n             }\n         }\n \n         match (type_category(a), type_category(b)) {\n             (Some(cat_a), Some(cat_b)) => match (&a.sty, &b.sty) {\n-                (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) => def_a == def_b,\n+                (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => def_a == def_b,\n                 _ => cat_a == cat_b\n             },\n             // infer and error can be equated to all types\n@@ -784,25 +784,25 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 let found_trait_ty = found_trait_ref.self_ty();\n \n                 let found_did = match found_trait_ty.sty {\n-                    ty::TyClosure(did, _) |\n-                    ty::TyForeign(did) |\n-                    ty::TyFnDef(did, _) => Some(did),\n-                    ty::TyAdt(def, _) => Some(def.did),\n+                    ty::Closure(did, _) |\n+                    ty::Foreign(did) |\n+                    ty::FnDef(did, _) => Some(did),\n+                    ty::Adt(def, _) => Some(def.did),\n                     _ => None,\n                 };\n                 let found_span = found_did.and_then(|did| {\n                     self.tcx.hir.span_if_local(did)\n                 }).map(|sp| self.tcx.sess.source_map().def_span(sp)); // the sp could be an fn def\n \n                 let found = match found_trait_ref.skip_binder().substs.type_at(1).sty {\n-                    ty::TyTuple(ref tys) => tys.iter()\n+                    ty::Tuple(ref tys) => tys.iter()\n                         .map(|_| ArgKind::empty()).collect::<Vec<_>>(),\n                     _ => vec![ArgKind::empty()],\n                 };\n                 let expected = match expected_trait_ref.skip_binder().substs.type_at(1).sty {\n-                    ty::TyTuple(ref tys) => tys.iter()\n+                    ty::Tuple(ref tys) => tys.iter()\n                         .map(|t| match t.sty {\n-                            ty::TypeVariants::TyTuple(ref tys) => ArgKind::Tuple(\n+                            ty::Tuple(ref tys) => ArgKind::Tuple(\n                                 Some(span),\n                                 tys.iter()\n                                     .map(|ty| (\"_\".to_owned(), ty.sty.to_string()))\n@@ -899,7 +899,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             let mut trait_type = trait_ref.self_ty();\n \n             for refs_remaining in 0..refs_number {\n-                if let ty::TypeVariants::TyRef(_, t_type, _) = trait_type.sty {\n+                if let ty::Ref(_, t_type, _) = trait_type.sty {\n                     trait_type = t_type;\n \n                     let substs = self.tcx.mk_substs_trait(trait_type, &[]);\n@@ -1143,7 +1143,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         fn build_fn_sig_string<'a, 'gcx, 'tcx>(tcx: ty::TyCtxt<'a, 'gcx, 'tcx>,\n                                                trait_ref: &ty::TraitRef<'tcx>) -> String {\n             let inputs = trait_ref.substs.type_at(1);\n-            let sig = if let ty::TyTuple(inputs) = inputs.sty {\n+            let sig = if let ty::Tuple(inputs) = inputs.sty {\n                 tcx.mk_fn_sig(\n                     inputs.iter().map(|&x| x),\n                     tcx.mk_infer(ty::TyVar(ty::TyVid { index: 0 })),\n@@ -1348,7 +1348,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.infcx.tcx }\n \n             fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-                if let ty::TyParam(ty::ParamTy {name, ..}) = ty.sty {\n+                if let ty::Param(ty::ParamTy {name, ..}) = ty.sty {\n                     let infcx = self.infcx;\n                     self.var_map.entry(ty).or_insert_with(||\n                         infcx.next_ty_var(\n@@ -1594,7 +1594,7 @@ impl ArgKind {\n     /// argument. This has no name (`_`) and no source spans..\n     pub fn from_expected_ty(t: Ty<'_>) -> ArgKind {\n         match t.sty {\n-            ty::TyTuple(ref tys) => ArgKind::Tuple(\n+            ty::Tuple(ref tys) => ArgKind::Tuple(\n                 None,\n                 tys.iter()\n                    .map(|ty| (\"_\".to_owned(), ty.sty.to_string()))"}, {"sha": "5c977e1bf624be9a0c6a804d7aa4ae3aaec88eb8", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -540,7 +540,7 @@ fn trait_ref_type_vars<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 't\n      .map(|t| selcx.infcx().resolve_type_vars_if_possible(&t))\n      .filter(|t| t.has_infer_types())\n      .flat_map(|t| t.walk())\n-     .filter(|t| match t.sty { ty::TyInfer(_) => true, _ => false })\n+     .filter(|t| match t.sty { ty::Infer(_) => true, _ => false })\n      .collect()\n }\n "}, {"sha": "e2dbe88354060b2221957de9398ed8696e392ecd", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -24,7 +24,7 @@ use infer::outlives::env::OutlivesEnvironment;\n use middle::region;\n use mir::interpret::ConstEvalErr;\n use ty::subst::Substs;\n-use ty::{self, AdtKind, Slice, Ty, TyCtxt, GenericParamDefKind, ToPredicate};\n+use ty::{self, AdtKind, List, Ty, TyCtxt, GenericParamDefKind, ToPredicate};\n use ty::error::{ExpectedFound, TypeError};\n use ty::fold::{TypeFolder, TypeFoldable, TypeVisitor};\n use infer::{InferCtxt};\n@@ -325,7 +325,7 @@ pub enum Goal<'tcx> {\n     CannotProve,\n }\n \n-pub type Goals<'tcx> = &'tcx Slice<Goal<'tcx>>;\n+pub type Goals<'tcx> = &'tcx List<Goal<'tcx>>;\n \n impl<'tcx> DomainGoal<'tcx> {\n     pub fn into_goal(self) -> Goal<'tcx> {\n@@ -357,7 +357,7 @@ pub enum Clause<'tcx> {\n }\n \n /// Multiple clauses.\n-pub type Clauses<'tcx> = &'tcx Slice<Clause<'tcx>>;\n+pub type Clauses<'tcx> = &'tcx List<Clause<'tcx>>;\n \n /// A \"program clause\" has the form `D :- G1, ..., Gn`. It is saying\n /// that the domain goal `D` is true if `G1...Gn` are provable. This"}, {"sha": "17d55b77625b2c5cc347cbec2229b5c4d9a9978d", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -371,15 +371,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let mut error = false;\n         ty.maybe_walk(|ty| {\n             match ty.sty {\n-                ty::TyParam(ref param_ty) => {\n+                ty::Param(ref param_ty) => {\n                     if param_ty.is_self() {\n                         error = true;\n                     }\n \n                     false // no contained types to walk\n                 }\n \n-                ty::TyProjection(ref data) => {\n+                ty::Projection(ref data) => {\n                     // This is a projected type `<Foo as SomeTrait>::X`.\n \n                     // Compute supertraits of current trait lazily."}, {"sha": "939ba92c7badfdce7af71823f05079204bc405f2", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -366,7 +366,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n \n         let ty = ty.super_fold_with(self);\n         match ty.sty {\n-            ty::TyAnon(def_id, substs) if !substs.has_escaping_regions() => { // (*)\n+            ty::Anon(def_id, substs) if !substs.has_escaping_regions() => { // (*)\n                 // Only normalize `impl Trait` after type-checking, usually in codegen.\n                 match self.param_env.reveal {\n                     Reveal::UserFacing => ty,\n@@ -393,7 +393,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n                 }\n             }\n \n-            ty::TyProjection(ref data) if !data.has_escaping_regions() => { // (*)\n+            ty::Projection(ref data) if !data.has_escaping_regions() => { // (*)\n \n                 // (*) This is kind of hacky -- we need to be able to\n                 // handle normalization within binders because\n@@ -812,10 +812,10 @@ fn get_paranoid_cache_value_obligation<'a, 'gcx, 'tcx>(\n /// return an associated obligation that, when fulfilled, will lead to\n /// an error.\n ///\n-/// Note that we used to return `TyError` here, but that was quite\n+/// Note that we used to return `Error` here, but that was quite\n /// dubious -- the premise was that an error would *eventually* be\n /// reported, when the obligation was processed. But in general once\n-/// you see a `TyError` you are supposed to be able to assume that an\n+/// you see a `Error` you are supposed to be able to assume that an\n /// error *has been* reported, so that you can take whatever heuristic\n /// paths you want to take. To make things worse, it was possible for\n /// cycles to arise, where you basically had a setup like `<MyType<$0>\n@@ -983,11 +983,11 @@ fn assemble_candidates_from_trait_def<'cx, 'gcx, 'tcx>(\n     let tcx = selcx.tcx();\n     // Check whether the self-type is itself a projection.\n     let (def_id, substs) = match obligation_trait_ref.self_ty().sty {\n-        ty::TyProjection(ref data) => {\n+        ty::Projection(ref data) => {\n             (data.trait_ref(tcx).def_id, data.substs)\n         }\n-        ty::TyAnon(def_id, substs) => (def_id, substs),\n-        ty::TyInfer(ty::TyVar(_)) => {\n+        ty::Anon(def_id, substs) => (def_id, substs),\n+        ty::Infer(ty::TyVar(_)) => {\n             // If the self-type is an inference variable, then it MAY wind up\n             // being a projected type, so induce an ambiguity.\n             candidate_set.mark_ambiguous();\n@@ -1265,7 +1265,7 @@ fn confirm_object_candidate<'cx, 'gcx, 'tcx>(\n     debug!(\"confirm_object_candidate(object_ty={:?})\",\n            object_ty);\n     let data = match object_ty.sty {\n-        ty::TyDynamic(ref data, ..) => data,\n+        ty::Dynamic(ref data, ..) => data,\n         _ => {\n             span_bug!(\n                 obligation.cause.span,\n@@ -1506,7 +1506,7 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n         // This means that the impl is missing a definition for the\n         // associated type. This error will be reported by the type\n         // checker method `check_impl_items_against_trait`, so here we\n-        // just return TyError.\n+        // just return Error.\n         debug!(\"confirm_impl_candidate: no associated type {:?} for {:?}\",\n                assoc_ty.item.ident,\n                obligation.predicate);"}, {"sha": "b479cafd1cea17f9ececd16525539fe1de88d0ee", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -214,34 +214,34 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'_, '_, 'tcx>, ty: Ty<'tcx>) ->\n         // None of these types have a destructor and hence they do not\n         // require anything in particular to outlive the dtor's\n         // execution.\n-        ty::TyInfer(ty::FreshIntTy(_))\n-        | ty::TyInfer(ty::FreshFloatTy(_))\n-        | ty::TyBool\n-        | ty::TyInt(_)\n-        | ty::TyUint(_)\n-        | ty::TyFloat(_)\n-        | ty::TyNever\n-        | ty::TyFnDef(..)\n-        | ty::TyFnPtr(_)\n-        | ty::TyChar\n-        | ty::TyGeneratorWitness(..)\n-        | ty::TyRawPtr(_)\n-        | ty::TyRef(..)\n-        | ty::TyStr\n-        | ty::TyForeign(..)\n-        | ty::TyError => true,\n+        ty::Infer(ty::FreshIntTy(_))\n+        | ty::Infer(ty::FreshFloatTy(_))\n+        | ty::Bool\n+        | ty::Int(_)\n+        | ty::Uint(_)\n+        | ty::Float(_)\n+        | ty::Never\n+        | ty::FnDef(..)\n+        | ty::FnPtr(_)\n+        | ty::Char\n+        | ty::GeneratorWitness(..)\n+        | ty::RawPtr(_)\n+        | ty::Ref(..)\n+        | ty::Str\n+        | ty::Foreign(..)\n+        | ty::Error => true,\n \n         // [T; N] and [T] have same properties as T.\n-        ty::TyArray(ty, _) | ty::TySlice(ty) => trivial_dropck_outlives(tcx, ty),\n+        ty::Array(ty, _) | ty::Slice(ty) => trivial_dropck_outlives(tcx, ty),\n \n         // (T1..Tn) and closures have same properties as T1..Tn --\n         // check if *any* of those are trivial.\n-        ty::TyTuple(ref tys) => tys.iter().cloned().all(|t| trivial_dropck_outlives(tcx, t)),\n-        ty::TyClosure(def_id, ref substs) => substs\n+        ty::Tuple(ref tys) => tys.iter().cloned().all(|t| trivial_dropck_outlives(tcx, t)),\n+        ty::Closure(def_id, ref substs) => substs\n             .upvar_tys(def_id, tcx)\n             .all(|t| trivial_dropck_outlives(tcx, t)),\n \n-        ty::TyAdt(def, _) => {\n+        ty::Adt(def, _) => {\n             if Some(def.did) == tcx.lang_items().manually_drop() {\n                 // `ManuallyDrop` never has a dtor.\n                 true\n@@ -255,11 +255,11 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'_, '_, 'tcx>, ty: Ty<'tcx>) ->\n         }\n \n         // The following *might* require a destructor: it would deeper inspection to tell.\n-        ty::TyDynamic(..)\n-        | ty::TyProjection(..)\n-        | ty::TyParam(_)\n-        | ty::TyAnon(..)\n-        | ty::TyInfer(_)\n-        | ty::TyGenerator(..) => false,\n+        ty::Dynamic(..)\n+        | ty::Projection(..)\n+        | ty::Param(_)\n+        | ty::Anon(..)\n+        | ty::Infer(_)\n+        | ty::Generator(..) => false,\n     }\n }"}, {"sha": "7b81989c6415b99898748f2f5d971e19d8068845", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -99,7 +99,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         let ty = ty.super_fold_with(self);\n         match ty.sty {\n-            ty::TyAnon(def_id, substs) if !substs.has_escaping_regions() => {\n+            ty::Anon(def_id, substs) if !substs.has_escaping_regions() => {\n                 // (*)\n                 // Only normalize `impl Trait` after type-checking, usually in codegen.\n                 match self.param_env.reveal {\n@@ -159,7 +159,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n                 }\n             }\n \n-            ty::TyProjection(ref data) if !data.has_escaping_regions() => {\n+            ty::Projection(ref data) if !data.has_escaping_regions() => {\n                 // (*)\n                 // (*) This is kind of hacky -- we need to be able to\n                 // handle normalization within binders because"}, {"sha": "dd383732bf8274ea119c62dc63be8c9dd1329c3b", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 98, "deletions": 98, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -1128,7 +1128,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                               -> SelectionResult<'tcx, SelectionCandidate<'tcx>>\n     {\n         if stack.obligation.predicate.references_error() {\n-            // If we encounter a `TyError`, we generally prefer the\n+            // If we encounter a `Error`, we generally prefer the\n             // most \"optimistic\" result in response -- that is, the\n             // one least likely to report downstream errors. But\n             // because this routine is shared by coherence and by\n@@ -1492,8 +1492,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // before we go into the whole skolemization thing, just\n         // quickly check if the self-type is a projection at all.\n         match obligation.predicate.skip_binder().trait_ref.self_ty().sty {\n-            ty::TyProjection(_) | ty::TyAnon(..) => {}\n-            ty::TyInfer(ty::TyVar(_)) => {\n+            ty::Projection(_) | ty::Anon(..) => {}\n+            ty::Infer(ty::TyVar(_)) => {\n                 span_bug!(obligation.cause.span,\n                     \"Self=_ should have been handled by assemble_candidates\");\n             }\n@@ -1526,9 +1526,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                skol_map);\n \n         let (def_id, substs) = match skol_trait_predicate.trait_ref.self_ty().sty {\n-            ty::TyProjection(ref data) =>\n+            ty::Projection(ref data) =>\n                 (data.trait_ref(self.tcx()).def_id, data.substs),\n-            ty::TyAnon(def_id, substs) => (def_id, substs),\n+            ty::Anon(def_id, substs) => (def_id, substs),\n             _ => {\n                 span_bug!(\n                     obligation.cause.span,\n@@ -1661,15 +1661,15 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // type/region parameters\n         let self_ty = *obligation.self_ty().skip_binder();\n         match self_ty.sty {\n-            ty::TyGenerator(..) => {\n+            ty::Generator(..) => {\n                 debug!(\"assemble_generator_candidates: self_ty={:?} obligation={:?}\",\n                        self_ty,\n                        obligation);\n \n                 candidates.vec.push(GeneratorCandidate);\n                 Ok(())\n             }\n-            ty::TyInfer(ty::TyVar(_)) => {\n+            ty::Infer(ty::TyVar(_)) => {\n                 debug!(\"assemble_generator_candidates: ambiguous self-type\");\n                 candidates.ambiguous = true;\n                 return Ok(());\n@@ -1698,7 +1698,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters\n         match obligation.self_ty().skip_binder().sty {\n-            ty::TyClosure(closure_def_id, closure_substs) => {\n+            ty::Closure(closure_def_id, closure_substs) => {\n                 debug!(\"assemble_unboxed_candidates: kind={:?} obligation={:?}\",\n                        kind, obligation);\n                 match self.infcx.closure_kind(closure_def_id, closure_substs) {\n@@ -1715,7 +1715,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 };\n                 Ok(())\n             }\n-            ty::TyInfer(ty::TyVar(_)) => {\n+            ty::Infer(ty::TyVar(_)) => {\n                 debug!(\"assemble_unboxed_closure_candidates: ambiguous self-type\");\n                 candidates.ambiguous = true;\n                 return Ok(());\n@@ -1738,13 +1738,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // ok to skip binder because what we are inspecting doesn't involve bound regions\n         let self_ty = *obligation.self_ty().skip_binder();\n         match self_ty.sty {\n-            ty::TyInfer(ty::TyVar(_)) => {\n+            ty::Infer(ty::TyVar(_)) => {\n                 debug!(\"assemble_fn_pointer_candidates: ambiguous self-type\");\n                 candidates.ambiguous = true; // could wind up being a fn() type\n             }\n \n             // provide an impl, but only for suitable `fn` pointers\n-            ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n+            ty::FnDef(..) | ty::FnPtr(_) => {\n                 if let ty::FnSig {\n                     unsafety: hir::Unsafety::Normal,\n                     abi: Abi::Rust,\n@@ -1804,20 +1804,20 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         if self.tcx().trait_is_auto(def_id) {\n             match self_ty.sty {\n-                ty::TyDynamic(..) => {\n+                ty::Dynamic(..) => {\n                     // For object types, we don't know what the closed\n                     // over types are. This means we conservatively\n                     // say nothing; a candidate may be added by\n                     // `assemble_candidates_from_object_ty`.\n                 }\n-                ty::TyForeign(..) => {\n+                ty::Foreign(..) => {\n                     // Since the contents of foreign types is unknown,\n                     // we don't add any `..` impl. Default traits could\n                     // still be provided by a manual implementation for\n                     // this trait and type.\n                 }\n-                ty::TyParam(..) |\n-                ty::TyProjection(..) => {\n+                ty::Param(..) |\n+                ty::Projection(..) => {\n                     // In these cases, we don't know what the actual\n                     // type is.  Therefore, we cannot break it down\n                     // into its constituent types. So we don't\n@@ -1832,7 +1832,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     // for an example of a test case that exercises\n                     // this path.\n                 }\n-                ty::TyInfer(ty::TyVar(_)) => {\n+                ty::Infer(ty::TyVar(_)) => {\n                     // the auto impl might apply, we don't know\n                     candidates.ambiguous = true;\n                 }\n@@ -1871,7 +1871,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             // any LBR.\n             let self_ty = this.tcx().erase_late_bound_regions(&obligation.self_ty());\n             let poly_trait_ref = match self_ty.sty {\n-                ty::TyDynamic(ref data, ..) => {\n+                ty::Dynamic(ref data, ..) => {\n                     if data.auto_traits().any(|did| did == obligation.predicate.def_id()) {\n                         debug!(\"assemble_candidates_from_object_ty: matched builtin bound, \\\n                                     pushing candidate\");\n@@ -1884,7 +1884,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         None => return,\n                     }\n                 }\n-                ty::TyInfer(ty::TyVar(_)) => {\n+                ty::Infer(ty::TyVar(_)) => {\n                     debug!(\"assemble_candidates_from_object_ty: ambiguous\");\n                     candidates.ambiguous = true; // could wind up being an object type\n                     return;\n@@ -1953,7 +1953,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         let may_apply = match (&source.sty, &target.sty) {\n             // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n-            (&ty::TyDynamic(ref data_a, ..), &ty::TyDynamic(ref data_b, ..)) => {\n+            (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n                 // Upcasts permit two things:\n                 //\n                 // 1. Dropping builtin bounds, e.g. `Foo+Send` to `Foo`\n@@ -1975,28 +1975,28 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             // T -> Trait.\n-            (_, &ty::TyDynamic(..)) => true,\n+            (_, &ty::Dynamic(..)) => true,\n \n             // Ambiguous handling is below T -> Trait, because inference\n             // variables can still implement Unsize<Trait> and nested\n             // obligations will have the final say (likely deferred).\n-            (&ty::TyInfer(ty::TyVar(_)), _) |\n-            (_, &ty::TyInfer(ty::TyVar(_))) => {\n+            (&ty::Infer(ty::TyVar(_)), _) |\n+            (_, &ty::Infer(ty::TyVar(_))) => {\n                 debug!(\"assemble_candidates_for_unsizing: ambiguous\");\n                 candidates.ambiguous = true;\n                 false\n             }\n \n             // [T; n] -> [T].\n-            (&ty::TyArray(..), &ty::TySlice(_)) => true,\n+            (&ty::Array(..), &ty::Slice(_)) => true,\n \n             // Struct<T> -> Struct<U>.\n-            (&ty::TyAdt(def_id_a, _), &ty::TyAdt(def_id_b, _)) if def_id_a.is_struct() => {\n+            (&ty::Adt(def_id_a, _), &ty::Adt(def_id_b, _)) if def_id_a.is_struct() => {\n                 def_id_a == def_id_b\n             }\n \n             // (.., T) -> (.., U).\n-            (&ty::TyTuple(tys_a), &ty::TyTuple(tys_b)) => {\n+            (&ty::Tuple(tys_a), &ty::Tuple(tys_b)) => {\n                 tys_a.len() == tys_b.len()\n             }\n \n@@ -2179,37 +2179,37 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             obligation.predicate.skip_binder().self_ty());\n \n         match self_ty.sty {\n-            ty::TyInfer(ty::IntVar(_)) | ty::TyInfer(ty::FloatVar(_)) |\n-            ty::TyUint(_) | ty::TyInt(_) | ty::TyBool | ty::TyFloat(_) |\n-            ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyRawPtr(..) |\n-            ty::TyChar | ty::TyRef(..) | ty::TyGenerator(..) |\n-            ty::TyGeneratorWitness(..) | ty::TyArray(..) | ty::TyClosure(..) |\n-            ty::TyNever | ty::TyError => {\n+            ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_)) |\n+            ty::Uint(_) | ty::Int(_) | ty::Bool | ty::Float(_) |\n+            ty::FnDef(..) | ty::FnPtr(_) | ty::RawPtr(..) |\n+            ty::Char | ty::Ref(..) | ty::Generator(..) |\n+            ty::GeneratorWitness(..) | ty::Array(..) | ty::Closure(..) |\n+            ty::Never | ty::Error => {\n                 // safe for everything\n                 Where(ty::Binder::dummy(Vec::new()))\n             }\n \n-            ty::TyStr | ty::TySlice(_) | ty::TyDynamic(..) | ty::TyForeign(..) => None,\n+            ty::Str | ty::Slice(_) | ty::Dynamic(..) | ty::Foreign(..) => None,\n \n-            ty::TyTuple(tys) => {\n+            ty::Tuple(tys) => {\n                 Where(ty::Binder::bind(tys.last().into_iter().cloned().collect()))\n             }\n \n-            ty::TyAdt(def, substs) => {\n+            ty::Adt(def, substs) => {\n                 let sized_crit = def.sized_constraint(self.tcx());\n                 // (*) binder moved here\n                 Where(ty::Binder::bind(\n                     sized_crit.iter().map(|ty| ty.subst(self.tcx(), substs)).collect()\n                 ))\n             }\n \n-            ty::TyProjection(_) | ty::TyParam(_) | ty::TyAnon(..) => None,\n-            ty::TyInfer(ty::TyVar(_)) => Ambiguous,\n+            ty::Projection(_) | ty::Param(_) | ty::Anon(..) => None,\n+            ty::Infer(ty::TyVar(_)) => Ambiguous,\n \n-            ty::TyInfer(ty::CanonicalTy(_)) |\n-            ty::TyInfer(ty::FreshTy(_)) |\n-            ty::TyInfer(ty::FreshIntTy(_)) |\n-            ty::TyInfer(ty::FreshFloatTy(_)) => {\n+            ty::Infer(ty::CanonicalTy(_)) |\n+            ty::Infer(ty::FreshTy(_)) |\n+            ty::Infer(ty::FreshIntTy(_)) |\n+            ty::Infer(ty::FreshFloatTy(_)) => {\n                 bug!(\"asked to assemble builtin bounds of unexpected type: {:?}\",\n                      self_ty);\n             }\n@@ -2226,35 +2226,35 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         use self::BuiltinImplConditions::{Ambiguous, None, Where};\n \n         match self_ty.sty {\n-            ty::TyInfer(ty::IntVar(_)) | ty::TyInfer(ty::FloatVar(_)) |\n-            ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyError => {\n+            ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_)) |\n+            ty::FnDef(..) | ty::FnPtr(_) | ty::Error => {\n                 Where(ty::Binder::dummy(Vec::new()))\n             }\n \n-            ty::TyUint(_) | ty::TyInt(_) | ty::TyBool | ty::TyFloat(_) |\n-            ty::TyChar | ty::TyRawPtr(..) | ty::TyNever |\n-            ty::TyRef(_, _, hir::MutImmutable) => {\n+            ty::Uint(_) | ty::Int(_) | ty::Bool | ty::Float(_) |\n+            ty::Char | ty::RawPtr(..) | ty::Never |\n+            ty::Ref(_, _, hir::MutImmutable) => {\n                 // Implementations provided in libcore\n                 None\n             }\n \n-            ty::TyDynamic(..) | ty::TyStr | ty::TySlice(..) |\n-            ty::TyGenerator(..) | ty::TyGeneratorWitness(..) | ty::TyForeign(..) |\n-            ty::TyRef(_, _, hir::MutMutable) => {\n+            ty::Dynamic(..) | ty::Str | ty::Slice(..) |\n+            ty::Generator(..) | ty::GeneratorWitness(..) | ty::Foreign(..) |\n+            ty::Ref(_, _, hir::MutMutable) => {\n                 None\n             }\n \n-            ty::TyArray(element_ty, _) => {\n+            ty::Array(element_ty, _) => {\n                 // (*) binder moved here\n                 Where(ty::Binder::bind(vec![element_ty]))\n             }\n \n-            ty::TyTuple(tys) => {\n+            ty::Tuple(tys) => {\n                 // (*) binder moved here\n                 Where(ty::Binder::bind(tys.to_vec()))\n             }\n \n-            ty::TyClosure(def_id, substs) => {\n+            ty::Closure(def_id, substs) => {\n                 let trait_id = obligation.predicate.def_id();\n                 let is_copy_trait = Some(trait_id) == self.tcx().lang_items().copy_trait();\n                 let is_clone_trait = Some(trait_id) == self.tcx().lang_items().clone_trait();\n@@ -2265,22 +2265,22 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 }\n             }\n \n-            ty::TyAdt(..) | ty::TyProjection(..) | ty::TyParam(..) | ty::TyAnon(..) => {\n+            ty::Adt(..) | ty::Projection(..) | ty::Param(..) | ty::Anon(..) => {\n                 // Fallback to whatever user-defined impls exist in this case.\n                 None\n             }\n \n-            ty::TyInfer(ty::TyVar(_)) => {\n+            ty::Infer(ty::TyVar(_)) => {\n                 // Unbound type variable. Might or might not have\n                 // applicable impls and so forth, depending on what\n                 // those type variables wind up being bound to.\n                 Ambiguous\n             }\n \n-            ty::TyInfer(ty::CanonicalTy(_)) |\n-            ty::TyInfer(ty::FreshTy(_)) |\n-            ty::TyInfer(ty::FreshIntTy(_)) |\n-            ty::TyInfer(ty::FreshFloatTy(_)) => {\n+            ty::Infer(ty::CanonicalTy(_)) |\n+            ty::Infer(ty::FreshTy(_)) |\n+            ty::Infer(ty::FreshIntTy(_)) |\n+            ty::Infer(ty::FreshFloatTy(_)) => {\n                 bug!(\"asked to assemble builtin bounds of unexpected type: {:?}\",\n                      self_ty);\n             }\n@@ -2300,76 +2300,76 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     /// ```\n     fn constituent_types_for_ty(&self, t: Ty<'tcx>) -> Vec<Ty<'tcx>> {\n         match t.sty {\n-            ty::TyUint(_) |\n-            ty::TyInt(_) |\n-            ty::TyBool |\n-            ty::TyFloat(_) |\n-            ty::TyFnDef(..) |\n-            ty::TyFnPtr(_) |\n-            ty::TyStr |\n-            ty::TyError |\n-            ty::TyInfer(ty::IntVar(_)) |\n-            ty::TyInfer(ty::FloatVar(_)) |\n-            ty::TyNever |\n-            ty::TyChar => {\n+            ty::Uint(_) |\n+            ty::Int(_) |\n+            ty::Bool |\n+            ty::Float(_) |\n+            ty::FnDef(..) |\n+            ty::FnPtr(_) |\n+            ty::Str |\n+            ty::Error |\n+            ty::Infer(ty::IntVar(_)) |\n+            ty::Infer(ty::FloatVar(_)) |\n+            ty::Never |\n+            ty::Char => {\n                 Vec::new()\n             }\n \n-            ty::TyDynamic(..) |\n-            ty::TyParam(..) |\n-            ty::TyForeign(..) |\n-            ty::TyProjection(..) |\n-            ty::TyInfer(ty::CanonicalTy(_)) |\n-            ty::TyInfer(ty::TyVar(_)) |\n-            ty::TyInfer(ty::FreshTy(_)) |\n-            ty::TyInfer(ty::FreshIntTy(_)) |\n-            ty::TyInfer(ty::FreshFloatTy(_)) => {\n+            ty::Dynamic(..) |\n+            ty::Param(..) |\n+            ty::Foreign(..) |\n+            ty::Projection(..) |\n+            ty::Infer(ty::CanonicalTy(_)) |\n+            ty::Infer(ty::TyVar(_)) |\n+            ty::Infer(ty::FreshTy(_)) |\n+            ty::Infer(ty::FreshIntTy(_)) |\n+            ty::Infer(ty::FreshFloatTy(_)) => {\n                 bug!(\"asked to assemble constituent types of unexpected type: {:?}\",\n                      t);\n             }\n \n-            ty::TyRawPtr(ty::TypeAndMut { ty: element_ty, ..}) |\n-            ty::TyRef(_, element_ty, _) => {\n+            ty::RawPtr(ty::TypeAndMut { ty: element_ty, ..}) |\n+            ty::Ref(_, element_ty, _) => {\n                 vec![element_ty]\n             },\n \n-            ty::TyArray(element_ty, _) | ty::TySlice(element_ty) => {\n+            ty::Array(element_ty, _) | ty::Slice(element_ty) => {\n                 vec![element_ty]\n             }\n \n-            ty::TyTuple(ref tys) => {\n+            ty::Tuple(ref tys) => {\n                 // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n                 tys.to_vec()\n             }\n \n-            ty::TyClosure(def_id, ref substs) => {\n+            ty::Closure(def_id, ref substs) => {\n                 substs.upvar_tys(def_id, self.tcx()).collect()\n             }\n \n-            ty::TyGenerator(def_id, ref substs, _) => {\n+            ty::Generator(def_id, ref substs, _) => {\n                 let witness = substs.witness(def_id, self.tcx());\n                 substs.upvar_tys(def_id, self.tcx()).chain(iter::once(witness)).collect()\n             }\n \n-            ty::TyGeneratorWitness(types) => {\n+            ty::GeneratorWitness(types) => {\n                 // This is sound because no regions in the witness can refer to\n                 // the binder outside the witness. So we'll effectivly reuse\n                 // the implicit binder around the witness.\n                 types.skip_binder().to_vec()\n             }\n \n             // for `PhantomData<T>`, we pass `T`\n-            ty::TyAdt(def, substs) if def.is_phantom_data() => {\n+            ty::Adt(def, substs) if def.is_phantom_data() => {\n                 substs.types().collect()\n             }\n \n-            ty::TyAdt(def, substs) => {\n+            ty::Adt(def, substs) => {\n                 def.all_fields()\n                     .map(|f| f.ty(self.tcx(), substs))\n                     .collect()\n             }\n \n-            ty::TyAnon(def_id, substs) => {\n+            ty::Anon(def_id, substs) => {\n                 // We can resolve the `impl Trait` to its concrete type,\n                 // which enforces a DAG between the functions requiring\n                 // the auto trait bounds in question.\n@@ -2728,7 +2728,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // case that results. -nmatsakis\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let poly_trait_ref = match self_ty.sty {\n-            ty::TyDynamic(ref data, ..) => {\n+            ty::Dynamic(ref data, ..) => {\n                 data.principal().unwrap().with_self_ty(self.tcx(), self_ty)\n             }\n             _ => {\n@@ -2823,7 +2823,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // type/region parameters\n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty().skip_binder());\n         let (generator_def_id, substs) = match self_ty.sty {\n-            ty::TyGenerator(id, substs, _) => (id, substs),\n+            ty::Generator(id, substs, _) => (id, substs),\n             _ => bug!(\"closure candidate for non-closure {:?}\", obligation)\n         };\n \n@@ -2879,7 +2879,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // type/region parameters\n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty().skip_binder());\n         let (closure_def_id, substs) = match self_ty.sty {\n-            ty::TyClosure(id, substs) => (id, substs),\n+            ty::Closure(id, substs) => (id, substs),\n             _ => bug!(\"closure candidate for non-closure {:?}\", obligation)\n         };\n \n@@ -2976,7 +2976,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let mut nested = vec![];\n         match (&source.sty, &target.sty) {\n             // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n-            (&ty::TyDynamic(ref data_a, r_a), &ty::TyDynamic(ref data_b, r_b)) => {\n+            (&ty::Dynamic(ref data_a, r_a), &ty::Dynamic(ref data_b, r_b)) => {\n                 // See assemble_candidates_for_unsizing for more info.\n                 let existential_predicates = data_a.map_bound(|data_a| {\n                     let principal = data_a.principal();\n@@ -3005,7 +3005,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             // T -> Trait.\n-            (_, &ty::TyDynamic(ref data, r)) => {\n+            (_, &ty::Dynamic(ref data, r)) => {\n                 let mut object_dids =\n                     data.auto_traits().chain(data.principal().map(|p| p.def_id()));\n                 if let Some(did) = object_dids.find(|did| {\n@@ -3048,7 +3048,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             // [T; n] -> [T].\n-            (&ty::TyArray(a, _), &ty::TySlice(b)) => {\n+            (&ty::Array(a, _), &ty::Slice(b)) => {\n                 let InferOk { obligations, .. } =\n                     self.infcx.at(&obligation.cause, obligation.param_env)\n                               .eq(b, a)\n@@ -3057,7 +3057,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             // Struct<T> -> Struct<U>.\n-            (&ty::TyAdt(def, substs_a), &ty::TyAdt(_, substs_b)) => {\n+            (&ty::Adt(def, substs_a), &ty::Adt(_, substs_b)) => {\n                 let fields = def\n                     .all_fields()\n                     .map(|f| tcx.type_of(f.did))\n@@ -3072,7 +3072,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 let mut ty_params = BitArray::new(substs_a.types().count());\n                 let mut found = false;\n                 for ty in field.walk() {\n-                    if let ty::TyParam(p) = ty.sty {\n+                    if let ty::Param(p) = ty.sty {\n                         ty_params.insert(p.idx as usize);\n                         found = true;\n                     }\n@@ -3082,7 +3082,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 }\n \n                 // Replace type parameters used in unsizing with\n-                // TyError and ensure they do not affect any other fields.\n+                // Error and ensure they do not affect any other fields.\n                 // This could be checked after type collection for any struct\n                 // with a potentially unsized trailing field.\n                 let params = substs_a.iter().enumerate().map(|(i, &k)| {\n@@ -3130,7 +3130,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             // (.., T) -> (.., U).\n-            (&ty::TyTuple(tys_a), &ty::TyTuple(tys_b)) => {\n+            (&ty::Tuple(tys_a), &ty::Tuple(tys_b)) => {\n                 assert_eq!(tys_a.len(), tys_b.len());\n \n                 // The last field of the tuple has to exist."}, {"sha": "9343eff9e79b4f2f43407ade6b09ea0e74d85a8e", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -90,7 +90,7 @@ pub fn translate_substs<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                 .unwrap()\n                                 .subst(infcx.tcx, &source_substs);\n \n-    // translate the Self and TyParam parts of the substitution, since those\n+    // translate the Self and Param parts of the substitution, since those\n     // vary across impls\n     let target_substs = match target_node {\n         specialization_graph::Node::Impl(target_impl) => {"}, {"sha": "87535a6ae8d1466d53f908d4b6e08f7ed26ee596", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -620,7 +620,7 @@ EnumLiftImpl! {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<traits::Goal<'tcx>> {\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<traits::Goal<'tcx>> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let v = self.iter()\n             .map(|t| t.fold_with(folder))\n@@ -658,7 +658,7 @@ EnumTypeFoldableImpl! {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<traits::Clause<'tcx>> {\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<traits::Clause<'tcx>> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let v = self.iter()\n             .map(|t| t.fold_with(folder))"}, {"sha": "c9b0e97c9b05c61847e79409a6232055c2ba1647", "filename": "src/librustc/ty/_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2F_match.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -67,18 +67,18 @@ impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Match<'a, 'gcx, 'tcx> {\n         if a == b { return Ok(a); }\n \n         match (&a.sty, &b.sty) {\n-            (_, &ty::TyInfer(ty::FreshTy(_))) |\n-            (_, &ty::TyInfer(ty::FreshIntTy(_))) |\n-            (_, &ty::TyInfer(ty::FreshFloatTy(_))) => {\n+            (_, &ty::Infer(ty::FreshTy(_))) |\n+            (_, &ty::Infer(ty::FreshIntTy(_))) |\n+            (_, &ty::Infer(ty::FreshFloatTy(_))) => {\n                 Ok(a)\n             }\n \n-            (&ty::TyInfer(_), _) |\n-            (_, &ty::TyInfer(_)) => {\n+            (&ty::Infer(_), _) |\n+            (_, &ty::Infer(_)) => {\n                 Err(TypeError::Sorts(relate::expected_found(self, &a, &b)))\n             }\n \n-            (&ty::TyError, _) | (_, &ty::TyError) => {\n+            (&ty::Error, _) | (_, &ty::Error) => {\n                 Ok(self.tcx().types.err)\n             }\n "}, {"sha": "c0861abb774deda27da77623d852da04f2d8f316", "filename": "src/librustc/ty/cast.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcast.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -60,18 +60,18 @@ pub enum CastKind {\n impl<'tcx> CastTy<'tcx> {\n     pub fn from_ty(t: Ty<'tcx>) -> Option<CastTy<'tcx>> {\n         match t.sty {\n-            ty::TyBool => Some(CastTy::Int(IntTy::Bool)),\n-            ty::TyChar => Some(CastTy::Int(IntTy::Char)),\n-            ty::TyInt(_) => Some(CastTy::Int(IntTy::I)),\n-            ty::TyInfer(ty::InferTy::IntVar(_)) => Some(CastTy::Int(IntTy::I)),\n-            ty::TyInfer(ty::InferTy::FloatVar(_)) => Some(CastTy::Float),\n-            ty::TyUint(u) => Some(CastTy::Int(IntTy::U(u))),\n-            ty::TyFloat(_) => Some(CastTy::Float),\n-            ty::TyAdt(d,_) if d.is_enum() && d.is_payloadfree() =>\n+            ty::Bool => Some(CastTy::Int(IntTy::Bool)),\n+            ty::Char => Some(CastTy::Int(IntTy::Char)),\n+            ty::Int(_) => Some(CastTy::Int(IntTy::I)),\n+            ty::Infer(ty::InferTy::IntVar(_)) => Some(CastTy::Int(IntTy::I)),\n+            ty::Infer(ty::InferTy::FloatVar(_)) => Some(CastTy::Float),\n+            ty::Uint(u) => Some(CastTy::Int(IntTy::U(u))),\n+            ty::Float(_) => Some(CastTy::Float),\n+            ty::Adt(d,_) if d.is_enum() && d.is_payloadfree() =>\n                 Some(CastTy::Int(IntTy::CEnum)),\n-            ty::TyRawPtr(mt) => Some(CastTy::Ptr(mt)),\n-            ty::TyRef(_, ty, mutbl) => Some(CastTy::RPtr(ty::TypeAndMut { ty, mutbl })),\n-            ty::TyFnPtr(..) => Some(CastTy::FnPtr),\n+            ty::RawPtr(mt) => Some(CastTy::Ptr(mt)),\n+            ty::Ref(_, ty, mutbl) => Some(CastTy::RPtr(ty::TypeAndMut { ty, mutbl })),\n+            ty::FnPtr(..) => Some(CastTy::FnPtr),\n             _ => None,\n         }\n     }"}, {"sha": "cc3e8a458a01fe698d75f0697d8cbcce447742e5", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -37,7 +37,7 @@ pub trait EncodableWithShorthand: Clone + Eq + Hash {\n }\n \n impl<'tcx> EncodableWithShorthand for Ty<'tcx> {\n-    type Variant = ty::TypeVariants<'tcx>;\n+    type Variant = ty::TyKind<'tcx>;\n     fn variant(&self) -> &Self::Variant {\n         &self.sty\n     }\n@@ -164,7 +164,7 @@ pub fn decode_ty<'a, 'tcx, D>(decoder: &mut D) -> Result<Ty<'tcx>, D::Error>\n         })\n     } else {\n         let tcx = decoder.tcx();\n-        Ok(tcx.mk_ty(ty::TypeVariants::decode(decoder)?))\n+        Ok(tcx.mk_ty(ty::TyKind::decode(decoder)?))\n     }\n }\n \n@@ -212,7 +212,7 @@ pub fn decode_region<'a, 'tcx, D>(decoder: &mut D) -> Result<ty::Region<'tcx>, D\n \n #[inline]\n pub fn decode_ty_slice<'a, 'tcx, D>(decoder: &mut D)\n-                                    -> Result<&'tcx ty::Slice<Ty<'tcx>>, D::Error>\n+                                    -> Result<&'tcx ty::List<Ty<'tcx>>, D::Error>\n     where D: TyDecoder<'a, 'tcx>,\n           'tcx: 'a,\n {\n@@ -232,7 +232,7 @@ pub fn decode_adt_def<'a, 'tcx, D>(decoder: &mut D)\n \n #[inline]\n pub fn decode_existential_predicate_slice<'a, 'tcx, D>(decoder: &mut D)\n-    -> Result<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>, D::Error>\n+    -> Result<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>, D::Error>\n     where D: TyDecoder<'a, 'tcx>,\n           'tcx: 'a,\n {\n@@ -366,10 +366,10 @@ macro_rules! implement_ty_decoder {\n                 }\n             }\n \n-            impl<$($typaram),*> SpecializedDecoder<&'tcx ty::Slice<ty::Ty<'tcx>>>\n+            impl<$($typaram),*> SpecializedDecoder<&'tcx ty::List<ty::Ty<'tcx>>>\n             for $DecoderName<$($typaram),*> {\n                 fn specialized_decode(&mut self)\n-                                      -> Result<&'tcx ty::Slice<ty::Ty<'tcx>>, Self::Error> {\n+                                      -> Result<&'tcx ty::List<ty::Ty<'tcx>>, Self::Error> {\n                     decode_ty_slice(self)\n                 }\n             }\n@@ -381,10 +381,10 @@ macro_rules! implement_ty_decoder {\n                 }\n             }\n \n-            impl<$($typaram),*> SpecializedDecoder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>\n+            impl<$($typaram),*> SpecializedDecoder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>\n                 for $DecoderName<$($typaram),*> {\n                 fn specialized_decode(&mut self)\n-                    -> Result<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>, Self::Error> {\n+                    -> Result<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>, Self::Error> {\n                     decode_existential_predicate_slice(self)\n                 }\n             }"}, {"sha": "0545a88f36bdc28bd34e0cf3b3d19db6865495a0", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 113, "deletions": 113, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -38,12 +38,12 @@ use ty::ReprOptions;\n use traits;\n use traits::{Clause, Clauses, Goal, Goals};\n use ty::{self, Ty, TypeAndMut};\n-use ty::{TyS, TypeVariants, Slice};\n+use ty::{TyS, TyKind, List};\n use ty::{AdtKind, AdtDef, ClosureSubsts, GeneratorSubsts, Region, Const};\n use ty::{PolyFnSig, InferTy, ParamTy, ProjectionTy, ExistentialPredicate, Predicate};\n use ty::RegionKind;\n use ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n-use ty::TypeVariants::*;\n+use ty::TyKind::*;\n use ty::GenericParamDefKind;\n use ty::layout::{LayoutDetails, TargetDataLayout};\n use ty::query;\n@@ -135,15 +135,15 @@ pub struct CtxtInterners<'tcx> {\n     /// Specifically use a speedy hash algorithm for these hash sets,\n     /// they're accessed quite often.\n     type_: InternedSet<'tcx, TyS<'tcx>>,\n-    type_list: InternedSet<'tcx, Slice<Ty<'tcx>>>,\n+    type_list: InternedSet<'tcx, List<Ty<'tcx>>>,\n     substs: InternedSet<'tcx, Substs<'tcx>>,\n-    canonical_var_infos: InternedSet<'tcx, Slice<CanonicalVarInfo>>,\n+    canonical_var_infos: InternedSet<'tcx, List<CanonicalVarInfo>>,\n     region: InternedSet<'tcx, RegionKind>,\n-    existential_predicates: InternedSet<'tcx, Slice<ExistentialPredicate<'tcx>>>,\n-    predicates: InternedSet<'tcx, Slice<Predicate<'tcx>>>,\n+    existential_predicates: InternedSet<'tcx, List<ExistentialPredicate<'tcx>>>,\n+    predicates: InternedSet<'tcx, List<Predicate<'tcx>>>,\n     const_: InternedSet<'tcx, Const<'tcx>>,\n-    clauses: InternedSet<'tcx, Slice<Clause<'tcx>>>,\n-    goals: InternedSet<'tcx, Slice<Goal<'tcx>>>,\n+    clauses: InternedSet<'tcx, List<Clause<'tcx>>>,\n+    goals: InternedSet<'tcx, List<Goal<'tcx>>>,\n }\n \n impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n@@ -167,7 +167,7 @@ impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n     fn intern_ty(\n         local: &CtxtInterners<'tcx>,\n         global: &CtxtInterners<'gcx>,\n-        st: TypeVariants<'tcx>\n+        st: TyKind<'tcx>\n     ) -> Ty<'tcx> {\n         let flags = super::flags::FlagComputation::for_sty(&st);\n \n@@ -803,7 +803,7 @@ impl<'tcx> CommonTypes<'tcx> {\n     fn new(interners: &CtxtInterners<'tcx>) -> CommonTypes<'tcx> {\n         // Ensure our type representation does not grow\n         #[cfg(target_pointer_width = \"64\")]\n-        assert!(mem::size_of::<ty::TypeVariants>() <= 24);\n+        assert!(mem::size_of::<ty::TyKind>() <= 24);\n         #[cfg(target_pointer_width = \"64\")]\n         assert!(mem::size_of::<ty::TyS>() <= 32);\n \n@@ -817,24 +817,24 @@ impl<'tcx> CommonTypes<'tcx> {\n             &*r\n         };\n         CommonTypes {\n-            bool: mk(TyBool),\n-            char: mk(TyChar),\n-            never: mk(TyNever),\n-            err: mk(TyError),\n-            isize: mk(TyInt(ast::IntTy::Isize)),\n-            i8: mk(TyInt(ast::IntTy::I8)),\n-            i16: mk(TyInt(ast::IntTy::I16)),\n-            i32: mk(TyInt(ast::IntTy::I32)),\n-            i64: mk(TyInt(ast::IntTy::I64)),\n-            i128: mk(TyInt(ast::IntTy::I128)),\n-            usize: mk(TyUint(ast::UintTy::Usize)),\n-            u8: mk(TyUint(ast::UintTy::U8)),\n-            u16: mk(TyUint(ast::UintTy::U16)),\n-            u32: mk(TyUint(ast::UintTy::U32)),\n-            u64: mk(TyUint(ast::UintTy::U64)),\n-            u128: mk(TyUint(ast::UintTy::U128)),\n-            f32: mk(TyFloat(ast::FloatTy::F32)),\n-            f64: mk(TyFloat(ast::FloatTy::F64)),\n+            bool: mk(Bool),\n+            char: mk(Char),\n+            never: mk(Never),\n+            err: mk(Error),\n+            isize: mk(Int(ast::IntTy::Isize)),\n+            i8: mk(Int(ast::IntTy::I8)),\n+            i16: mk(Int(ast::IntTy::I16)),\n+            i32: mk(Int(ast::IntTy::I32)),\n+            i64: mk(Int(ast::IntTy::I64)),\n+            i128: mk(Int(ast::IntTy::I128)),\n+            usize: mk(Uint(ast::UintTy::Usize)),\n+            u8: mk(Uint(ast::UintTy::U8)),\n+            u16: mk(Uint(ast::UintTy::U16)),\n+            u32: mk(Uint(ast::UintTy::U32)),\n+            u64: mk(Uint(ast::UintTy::U64)),\n+            u128: mk(Uint(ast::UintTy::U128)),\n+            f32: mk(Float(ast::FloatTy::F32)),\n+            f64: mk(Float(ast::FloatTy::F64)),\n \n             re_empty: mk_region(RegionKind::ReEmpty),\n             re_static: mk_region(RegionKind::ReStatic),\n@@ -1540,7 +1540,7 @@ impl<'gcx: 'tcx, 'tcx> GlobalCtxt<'gcx> {\n /// None is returned if the value or one of the components is not part\n /// of the provided context.\n /// For Ty, None can be returned if either the type interner doesn't\n-/// contain the TypeVariants key or if the address of the interned\n+/// contain the TyKind key or if the address of the interned\n /// pointer differs. The latter case is possible if a primitive type,\n /// e.g. `()` or `u8`, was interned in a different context.\n pub trait Lift<'tcx>: fmt::Debug {\n@@ -1593,12 +1593,12 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Goal<'a> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for &'a Slice<Goal<'a>> {\n-    type Lifted = &'tcx Slice<Goal<'tcx>>;\n+impl<'a, 'tcx> Lift<'tcx> for &'a List<Goal<'a>> {\n+    type Lifted = &'tcx List<Goal<'tcx>>;\n     fn lift_to_tcx<'b, 'gcx>(\n         &self,\n         tcx: TyCtxt<'b, 'gcx, 'tcx>,\n-    ) -> Option<&'tcx Slice<Goal<'tcx>>> {\n+    ) -> Option<&'tcx List<Goal<'tcx>>> {\n         if tcx.interners.arena.in_arena(*self as *const _) {\n             return Some(unsafe { mem::transmute(*self) });\n         }\n@@ -1611,12 +1611,12 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Slice<Goal<'a>> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for &'a Slice<Clause<'a>> {\n-    type Lifted = &'tcx Slice<Clause<'tcx>>;\n+impl<'a, 'tcx> Lift<'tcx> for &'a List<Clause<'a>> {\n+    type Lifted = &'tcx List<Clause<'tcx>>;\n     fn lift_to_tcx<'b, 'gcx>(\n         &self,\n         tcx: TyCtxt<'b, 'gcx, 'tcx>,\n-    ) -> Option<&'tcx Slice<Clause<'tcx>>> {\n+    ) -> Option<&'tcx List<Clause<'tcx>>> {\n         if tcx.interners.arena.in_arena(*self as *const _) {\n             return Some(unsafe { mem::transmute(*self) });\n         }\n@@ -1648,7 +1648,7 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n     type Lifted = &'tcx Substs<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx Substs<'tcx>> {\n         if self.len() == 0 {\n-            return Some(Slice::empty());\n+            return Some(List::empty());\n         }\n         if tcx.interners.arena.in_arena(&self[..] as *const _) {\n             return Some(unsafe { mem::transmute(*self) });\n@@ -1662,12 +1662,12 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for &'a Slice<Ty<'a>> {\n-    type Lifted = &'tcx Slice<Ty<'tcx>>;\n+impl<'a, 'tcx> Lift<'tcx> for &'a List<Ty<'a>> {\n+    type Lifted = &'tcx List<Ty<'tcx>>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n-                             -> Option<&'tcx Slice<Ty<'tcx>>> {\n+                             -> Option<&'tcx List<Ty<'tcx>>> {\n         if self.len() == 0 {\n-            return Some(Slice::empty());\n+            return Some(List::empty());\n         }\n         if tcx.interners.arena.in_arena(*self as *const _) {\n             return Some(unsafe { mem::transmute(*self) });\n@@ -1681,12 +1681,12 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Slice<Ty<'a>> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for &'a Slice<ExistentialPredicate<'a>> {\n-    type Lifted = &'tcx Slice<ExistentialPredicate<'tcx>>;\n+impl<'a, 'tcx> Lift<'tcx> for &'a List<ExistentialPredicate<'a>> {\n+    type Lifted = &'tcx List<ExistentialPredicate<'tcx>>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n-        -> Option<&'tcx Slice<ExistentialPredicate<'tcx>>> {\n+        -> Option<&'tcx List<ExistentialPredicate<'tcx>>> {\n         if self.is_empty() {\n-            return Some(Slice::empty());\n+            return Some(List::empty());\n         }\n         if tcx.interners.arena.in_arena(*self as *const _) {\n             return Some(unsafe { mem::transmute(*self) });\n@@ -1700,12 +1700,12 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Slice<ExistentialPredicate<'a>> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for &'a Slice<Predicate<'a>> {\n-    type Lifted = &'tcx Slice<Predicate<'tcx>>;\n+impl<'a, 'tcx> Lift<'tcx> for &'a List<Predicate<'a>> {\n+    type Lifted = &'tcx List<Predicate<'tcx>>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n-        -> Option<&'tcx Slice<Predicate<'tcx>>> {\n+        -> Option<&'tcx List<Predicate<'tcx>>> {\n         if self.is_empty() {\n-            return Some(Slice::empty());\n+            return Some(List::empty());\n         }\n         if tcx.interners.arena.in_arena(*self as *const _) {\n             return Some(unsafe { mem::transmute(*self) });\n@@ -1719,11 +1719,11 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Slice<Predicate<'a>> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for &'a Slice<CanonicalVarInfo> {\n-    type Lifted = &'tcx Slice<CanonicalVarInfo>;\n+impl<'a, 'tcx> Lift<'tcx> for &'a List<CanonicalVarInfo> {\n+    type Lifted = &'tcx List<CanonicalVarInfo>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         if self.len() == 0 {\n-            return Some(Slice::empty());\n+            return Some(List::empty());\n         }\n         if tcx.interners.arena.in_arena(*self as *const _) {\n             return Some(unsafe { mem::transmute(*self) });\n@@ -2035,9 +2035,9 @@ macro_rules! sty_debug_print {\n \n                 for &Interned(t) in tcx.interners.type_.borrow().iter() {\n                     let variant = match t.sty {\n-                        ty::TyBool | ty::TyChar | ty::TyInt(..) | ty::TyUint(..) |\n-                            ty::TyFloat(..) | ty::TyStr | ty::TyNever => continue,\n-                        ty::TyError => /* unimportant */ continue,\n+                        ty::Bool | ty::Char | ty::Int(..) | ty::Uint(..) |\n+                            ty::Float(..) | ty::Str | ty::Never => continue,\n+                        ty::Error => /* unimportant */ continue,\n                         $(ty::$variant(..) => &mut $variant,)*\n                     };\n                     let region = t.flags.intersects(ty::TypeFlags::HAS_RE_INFER);\n@@ -2076,9 +2076,9 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     pub fn print_debug_stats(self) {\n         sty_debug_print!(\n             self,\n-            TyAdt, TyArray, TySlice, TyRawPtr, TyRef, TyFnDef, TyFnPtr,\n-            TyGenerator, TyGeneratorWitness, TyDynamic, TyClosure, TyTuple,\n-            TyParam, TyInfer, TyProjection, TyAnon, TyForeign);\n+            Adt, Array, Slice, RawPtr, Ref, FnDef, FnPtr,\n+            Generator, GeneratorWitness, Dynamic, Closure, Tuple,\n+            Param, Infer, Projection, Anon, Foreign);\n \n         println!(\"Substs interner: #{}\", self.interners.substs.borrow().len());\n         println!(\"Region interner: #{}\", self.interners.region.borrow().len());\n@@ -2107,34 +2107,34 @@ impl<'tcx> Hash for Interned<'tcx, TyS<'tcx>> {\n     }\n }\n \n-impl<'tcx: 'lcx, 'lcx> Borrow<TypeVariants<'lcx>> for Interned<'tcx, TyS<'tcx>> {\n-    fn borrow<'a>(&'a self) -> &'a TypeVariants<'lcx> {\n+impl<'tcx: 'lcx, 'lcx> Borrow<TyKind<'lcx>> for Interned<'tcx, TyS<'tcx>> {\n+    fn borrow<'a>(&'a self) -> &'a TyKind<'lcx> {\n         &self.0.sty\n     }\n }\n \n-// NB: An Interned<Slice<T>> compares and hashes as its elements.\n-impl<'tcx, T: PartialEq> PartialEq for Interned<'tcx, Slice<T>> {\n-    fn eq(&self, other: &Interned<'tcx, Slice<T>>) -> bool {\n+// NB: An Interned<List<T>> compares and hashes as its elements.\n+impl<'tcx, T: PartialEq> PartialEq for Interned<'tcx, List<T>> {\n+    fn eq(&self, other: &Interned<'tcx, List<T>>) -> bool {\n         self.0[..] == other.0[..]\n     }\n }\n \n-impl<'tcx, T: Eq> Eq for Interned<'tcx, Slice<T>> {}\n+impl<'tcx, T: Eq> Eq for Interned<'tcx, List<T>> {}\n \n-impl<'tcx, T: Hash> Hash for Interned<'tcx, Slice<T>> {\n+impl<'tcx, T: Hash> Hash for Interned<'tcx, List<T>> {\n     fn hash<H: Hasher>(&self, s: &mut H) {\n         self.0[..].hash(s)\n     }\n }\n \n-impl<'tcx: 'lcx, 'lcx> Borrow<[Ty<'lcx>]> for Interned<'tcx, Slice<Ty<'tcx>>> {\n+impl<'tcx: 'lcx, 'lcx> Borrow<[Ty<'lcx>]> for Interned<'tcx, List<Ty<'tcx>>> {\n     fn borrow<'a>(&'a self) -> &'a [Ty<'lcx>] {\n         &self.0[..]\n     }\n }\n \n-impl<'tcx: 'lcx, 'lcx> Borrow<[CanonicalVarInfo]> for Interned<'tcx, Slice<CanonicalVarInfo>> {\n+impl<'tcx: 'lcx, 'lcx> Borrow<[CanonicalVarInfo]> for Interned<'tcx, List<CanonicalVarInfo>> {\n     fn borrow<'a>(&'a self) -> &'a [CanonicalVarInfo] {\n         &self.0[..]\n     }\n@@ -2153,14 +2153,14 @@ impl<'tcx> Borrow<RegionKind> for Interned<'tcx, RegionKind> {\n }\n \n impl<'tcx: 'lcx, 'lcx> Borrow<[ExistentialPredicate<'lcx>]>\n-    for Interned<'tcx, Slice<ExistentialPredicate<'tcx>>> {\n+    for Interned<'tcx, List<ExistentialPredicate<'tcx>>> {\n     fn borrow<'a>(&'a self) -> &'a [ExistentialPredicate<'lcx>] {\n         &self.0[..]\n     }\n }\n \n impl<'tcx: 'lcx, 'lcx> Borrow<[Predicate<'lcx>]>\n-    for Interned<'tcx, Slice<Predicate<'tcx>>> {\n+    for Interned<'tcx, List<Predicate<'tcx>>> {\n     fn borrow<'a>(&'a self) -> &'a [Predicate<'lcx>] {\n         &self.0[..]\n     }\n@@ -2173,14 +2173,14 @@ impl<'tcx: 'lcx, 'lcx> Borrow<Const<'lcx>> for Interned<'tcx, Const<'tcx>> {\n }\n \n impl<'tcx: 'lcx, 'lcx> Borrow<[Clause<'lcx>]>\n-for Interned<'tcx, Slice<Clause<'tcx>>> {\n+for Interned<'tcx, List<Clause<'tcx>>> {\n     fn borrow<'a>(&'a self) -> &'a [Clause<'lcx>] {\n         &self.0[..]\n     }\n }\n \n impl<'tcx: 'lcx, 'lcx> Borrow<[Goal<'lcx>]>\n-for Interned<'tcx, Slice<Goal<'tcx>>> {\n+for Interned<'tcx, List<Goal<'tcx>>> {\n     fn borrow<'a>(&'a self) -> &'a [Goal<'lcx>] {\n         &self.0[..]\n     }\n@@ -2274,9 +2274,9 @@ macro_rules! slice_interners {\n     ($($field:ident: $method:ident($ty:ident)),+) => (\n         $(intern_method!( 'tcx, $field: $method(\n             &[$ty<'tcx>],\n-            |a, v| Slice::from_arena(a, v),\n+            |a, v| List::from_arena(a, v),\n             Deref::deref,\n-            |xs: &[$ty]| xs.iter().any(keep_local)) -> Slice<$ty<'tcx>>);)+\n+            |xs: &[$ty]| xs.iter().any(keep_local)) -> List<$ty<'tcx>>);)+\n     )\n }\n \n@@ -2298,10 +2298,10 @@ intern_method! {\n     'tcx,\n     canonical_var_infos: _intern_canonical_var_infos(\n         &[CanonicalVarInfo],\n-        |a, v| Slice::from_arena(a, v),\n+        |a, v| List::from_arena(a, v),\n         Deref::deref,\n         |_xs: &[CanonicalVarInfo]| -> bool { false }\n-    ) -> Slice<CanonicalVarInfo>\n+    ) -> List<CanonicalVarInfo>\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n@@ -2323,7 +2323,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn coerce_closure_fn_ty(self, sig: PolyFnSig<'tcx>) -> Ty<'tcx> {\n         let converted_sig = sig.map_bound(|s| {\n             let params_iter = match s.inputs()[0].sty {\n-                ty::TyTuple(params) => {\n+                ty::Tuple(params) => {\n                     params.into_iter().cloned()\n                 }\n                 _ => bug!(),\n@@ -2340,7 +2340,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_fn_ptr(converted_sig)\n     }\n \n-    pub fn mk_ty(&self, st: TypeVariants<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_ty(&self, st: TyKind<'tcx>) -> Ty<'tcx> {\n         CtxtInterners::intern_ty(&self.interners, &self.global_interners, st)\n     }\n \n@@ -2374,7 +2374,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_str(self) -> Ty<'tcx> {\n-        self.mk_ty(TyStr)\n+        self.mk_ty(Str)\n     }\n \n     pub fn mk_static_str(self) -> Ty<'tcx> {\n@@ -2383,11 +2383,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn mk_adt(self, def: &'tcx AdtDef, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n         // take a copy of substs so that we own the vectors inside\n-        self.mk_ty(TyAdt(def, substs))\n+        self.mk_ty(Adt(def, substs))\n     }\n \n     pub fn mk_foreign(self, def_id: DefId) -> Ty<'tcx> {\n-        self.mk_ty(TyForeign(def_id))\n+        self.mk_ty(Foreign(def_id))\n     }\n \n     pub fn mk_box(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n@@ -2406,15 +2406,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n         });\n-        self.mk_ty(TyAdt(adt_def, substs))\n+        self.mk_ty(Adt(adt_def, substs))\n     }\n \n     pub fn mk_ptr(self, tm: TypeAndMut<'tcx>) -> Ty<'tcx> {\n-        self.mk_ty(TyRawPtr(tm))\n+        self.mk_ty(RawPtr(tm))\n     }\n \n     pub fn mk_ref(self, r: Region<'tcx>, tm: TypeAndMut<'tcx>) -> Ty<'tcx> {\n-        self.mk_ty(TyRef(r, tm.ty, tm.mutbl))\n+        self.mk_ty(Ref(r, tm.ty, tm.mutbl))\n     }\n \n     pub fn mk_mut_ref(self, r: Region<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n@@ -2438,19 +2438,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_array(self, ty: Ty<'tcx>, n: u64) -> Ty<'tcx> {\n-        self.mk_ty(TyArray(ty, ty::Const::from_usize(self, n)))\n+        self.mk_ty(Array(ty, ty::Const::from_usize(self, n)))\n     }\n \n     pub fn mk_slice(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.mk_ty(TySlice(ty))\n+        self.mk_ty(Slice(ty))\n     }\n \n     pub fn intern_tup(self, ts: &[Ty<'tcx>]) -> Ty<'tcx> {\n-        self.mk_ty(TyTuple(self.intern_type_list(ts)))\n+        self.mk_ty(Tuple(self.intern_type_list(ts)))\n     }\n \n     pub fn mk_tup<I: InternAs<[Ty<'tcx>], Ty<'tcx>>>(self, iter: I) -> I::Output {\n-        iter.intern_with(|ts| self.mk_ty(TyTuple(self.intern_type_list(ts))))\n+        iter.intern_with(|ts| self.mk_ty(Tuple(self.intern_type_list(ts))))\n     }\n \n     pub fn mk_nil(self) -> Ty<'tcx> {\n@@ -2466,51 +2466,51 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_bool(self) -> Ty<'tcx> {\n-        self.mk_ty(TyBool)\n+        self.mk_ty(Bool)\n     }\n \n     pub fn mk_fn_def(self, def_id: DefId,\n                      substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n-        self.mk_ty(TyFnDef(def_id, substs))\n+        self.mk_ty(FnDef(def_id, substs))\n     }\n \n     pub fn mk_fn_ptr(self, fty: PolyFnSig<'tcx>) -> Ty<'tcx> {\n-        self.mk_ty(TyFnPtr(fty))\n+        self.mk_ty(FnPtr(fty))\n     }\n \n     pub fn mk_dynamic(\n         self,\n-        obj: ty::Binder<&'tcx Slice<ExistentialPredicate<'tcx>>>,\n+        obj: ty::Binder<&'tcx List<ExistentialPredicate<'tcx>>>,\n         reg: ty::Region<'tcx>\n     ) -> Ty<'tcx> {\n-        self.mk_ty(TyDynamic(obj, reg))\n+        self.mk_ty(Dynamic(obj, reg))\n     }\n \n     pub fn mk_projection(self,\n                          item_def_id: DefId,\n                          substs: &'tcx Substs<'tcx>)\n         -> Ty<'tcx> {\n-            self.mk_ty(TyProjection(ProjectionTy {\n+            self.mk_ty(Projection(ProjectionTy {\n                 item_def_id,\n                 substs,\n             }))\n         }\n \n     pub fn mk_closure(self, closure_id: DefId, closure_substs: ClosureSubsts<'tcx>)\n                                           -> Ty<'tcx> {\n-        self.mk_ty(TyClosure(closure_id, closure_substs))\n+        self.mk_ty(Closure(closure_id, closure_substs))\n     }\n \n     pub fn mk_generator(self,\n                         id: DefId,\n                         generator_substs: GeneratorSubsts<'tcx>,\n                         movability: hir::GeneratorMovability)\n                         -> Ty<'tcx> {\n-        self.mk_ty(TyGenerator(id, generator_substs, movability))\n+        self.mk_ty(Generator(id, generator_substs, movability))\n     }\n \n-    pub fn mk_generator_witness(self, types: ty::Binder<&'tcx Slice<Ty<'tcx>>>) -> Ty<'tcx> {\n-        self.mk_ty(TyGeneratorWitness(types))\n+    pub fn mk_generator_witness(self, types: ty::Binder<&'tcx List<Ty<'tcx>>>) -> Ty<'tcx> {\n+        self.mk_ty(GeneratorWitness(types))\n     }\n \n     pub fn mk_var(self, v: TyVid) -> Ty<'tcx> {\n@@ -2526,13 +2526,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_infer(self, it: InferTy) -> Ty<'tcx> {\n-        self.mk_ty(TyInfer(it))\n+        self.mk_ty(Infer(it))\n     }\n \n     pub fn mk_ty_param(self,\n                     index: u32,\n                     name: InternedString) -> Ty<'tcx> {\n-        self.mk_ty(TyParam(ParamTy { idx: index, name: name }))\n+        self.mk_ty(Param(ParamTy { idx: index, name: name }))\n     }\n \n     pub fn mk_self_type(self) -> Ty<'tcx> {\n@@ -2549,64 +2549,64 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_anon(self, def_id: DefId, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n-        self.mk_ty(TyAnon(def_id, substs))\n+        self.mk_ty(Anon(def_id, substs))\n     }\n \n     pub fn intern_existential_predicates(self, eps: &[ExistentialPredicate<'tcx>])\n-        -> &'tcx Slice<ExistentialPredicate<'tcx>> {\n+        -> &'tcx List<ExistentialPredicate<'tcx>> {\n         assert!(!eps.is_empty());\n         assert!(eps.windows(2).all(|w| w[0].stable_cmp(self, &w[1]) != Ordering::Greater));\n         self._intern_existential_predicates(eps)\n     }\n \n     pub fn intern_predicates(self, preds: &[Predicate<'tcx>])\n-        -> &'tcx Slice<Predicate<'tcx>> {\n+        -> &'tcx List<Predicate<'tcx>> {\n         // FIXME consider asking the input slice to be sorted to avoid\n         // re-interning permutations, in which case that would be asserted\n         // here.\n         if preds.len() == 0 {\n             // The macro-generated method below asserts we don't intern an empty slice.\n-            Slice::empty()\n+            List::empty()\n         } else {\n             self._intern_predicates(preds)\n         }\n     }\n \n-    pub fn intern_type_list(self, ts: &[Ty<'tcx>]) -> &'tcx Slice<Ty<'tcx>> {\n+    pub fn intern_type_list(self, ts: &[Ty<'tcx>]) -> &'tcx List<Ty<'tcx>> {\n         if ts.len() == 0 {\n-            Slice::empty()\n+            List::empty()\n         } else {\n             self._intern_type_list(ts)\n         }\n     }\n \n-    pub fn intern_substs(self, ts: &[Kind<'tcx>]) -> &'tcx Slice<Kind<'tcx>> {\n+    pub fn intern_substs(self, ts: &[Kind<'tcx>]) -> &'tcx List<Kind<'tcx>> {\n         if ts.len() == 0 {\n-            Slice::empty()\n+            List::empty()\n         } else {\n             self._intern_substs(ts)\n         }\n     }\n \n     pub fn intern_canonical_var_infos(self, ts: &[CanonicalVarInfo]) -> CanonicalVarInfos<'gcx> {\n         if ts.len() == 0 {\n-            Slice::empty()\n+            List::empty()\n         } else {\n             self.global_tcx()._intern_canonical_var_infos(ts)\n         }\n     }\n \n     pub fn intern_clauses(self, ts: &[Clause<'tcx>]) -> Clauses<'tcx> {\n         if ts.len() == 0 {\n-            Slice::empty()\n+            List::empty()\n         } else {\n             self._intern_clauses(ts)\n         }\n     }\n \n     pub fn intern_goals(self, ts: &[Goal<'tcx>]) -> Goals<'tcx> {\n         if ts.len() == 0 {\n-            Slice::empty()\n+            List::empty()\n         } else {\n             self._intern_goals(ts)\n         }\n@@ -2629,24 +2629,24 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_existential_predicates<I: InternAs<[ExistentialPredicate<'tcx>],\n-                                     &'tcx Slice<ExistentialPredicate<'tcx>>>>(self, iter: I)\n+                                     &'tcx List<ExistentialPredicate<'tcx>>>>(self, iter: I)\n                                      -> I::Output {\n         iter.intern_with(|xs| self.intern_existential_predicates(xs))\n     }\n \n     pub fn mk_predicates<I: InternAs<[Predicate<'tcx>],\n-                                     &'tcx Slice<Predicate<'tcx>>>>(self, iter: I)\n+                                     &'tcx List<Predicate<'tcx>>>>(self, iter: I)\n                                      -> I::Output {\n         iter.intern_with(|xs| self.intern_predicates(xs))\n     }\n \n     pub fn mk_type_list<I: InternAs<[Ty<'tcx>],\n-                        &'tcx Slice<Ty<'tcx>>>>(self, iter: I) -> I::Output {\n+                        &'tcx List<Ty<'tcx>>>>(self, iter: I) -> I::Output {\n         iter.intern_with(|xs| self.intern_type_list(xs))\n     }\n \n     pub fn mk_substs<I: InternAs<[Kind<'tcx>],\n-                     &'tcx Slice<Kind<'tcx>>>>(self, iter: I) -> I::Output {\n+                     &'tcx List<Kind<'tcx>>>>(self, iter: I) -> I::Output {\n         iter.intern_with(|xs| self.intern_substs(xs))\n     }\n "}, {"sha": "aa6ee420a2162a4b41b93a2bfad48d7773b68612", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -51,7 +51,7 @@ pub enum TypeError<'tcx> {\n     CyclicTy(Ty<'tcx>),\n     ProjectionMismatched(ExpectedFound<DefId>),\n     ProjectionBoundsLength(ExpectedFound<usize>),\n-    ExistentialMismatch(ExpectedFound<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>),\n+    ExistentialMismatch(ExpectedFound<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>),\n \n     OldStyleLUB(Box<TypeError<'tcx>>),\n }\n@@ -175,21 +175,21 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n     pub fn sort_string(&self, tcx: TyCtxt<'a, 'gcx, 'lcx>) -> String {\n         match self.sty {\n-            ty::TyBool | ty::TyChar | ty::TyInt(_) |\n-            ty::TyUint(_) | ty::TyFloat(_) | ty::TyStr | ty::TyNever => self.to_string(),\n-            ty::TyTuple(ref tys) if tys.is_empty() => self.to_string(),\n+            ty::Bool | ty::Char | ty::Int(_) |\n+            ty::Uint(_) | ty::Float(_) | ty::Str | ty::Never => self.to_string(),\n+            ty::Tuple(ref tys) if tys.is_empty() => self.to_string(),\n \n-            ty::TyAdt(def, _) => format!(\"{} `{}`\", def.descr(), tcx.item_path_str(def.did)),\n-            ty::TyForeign(def_id) => format!(\"extern type `{}`\", tcx.item_path_str(def_id)),\n-            ty::TyArray(_, n) => {\n+            ty::Adt(def, _) => format!(\"{} `{}`\", def.descr(), tcx.item_path_str(def.did)),\n+            ty::Foreign(def_id) => format!(\"extern type `{}`\", tcx.item_path_str(def_id)),\n+            ty::Array(_, n) => {\n                 match n.assert_usize(tcx) {\n                     Some(n) => format!(\"array of {} elements\", n),\n                     None => \"array\".to_string(),\n                 }\n             }\n-            ty::TySlice(_) => \"slice\".to_string(),\n-            ty::TyRawPtr(_) => \"*-ptr\".to_string(),\n-            ty::TyRef(region, ty, mutbl) => {\n+            ty::Slice(_) => \"slice\".to_string(),\n+            ty::RawPtr(_) => \"*-ptr\".to_string(),\n+            ty::Ref(region, ty, mutbl) => {\n                 let tymut = ty::TypeAndMut { ty, mutbl };\n                 let tymut_string = tymut.to_string();\n                 if tymut_string == \"_\" ||         //unknown type name,\n@@ -204,33 +204,33 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n                     format!(\"&{}\", tymut_string)\n                 }\n             }\n-            ty::TyFnDef(..) => \"fn item\".to_string(),\n-            ty::TyFnPtr(_) => \"fn pointer\".to_string(),\n-            ty::TyDynamic(ref inner, ..) => {\n+            ty::FnDef(..) => \"fn item\".to_string(),\n+            ty::FnPtr(_) => \"fn pointer\".to_string(),\n+            ty::Dynamic(ref inner, ..) => {\n                 inner.principal().map_or_else(|| \"trait\".to_string(),\n                     |p| format!(\"trait {}\", tcx.item_path_str(p.def_id())))\n             }\n-            ty::TyClosure(..) => \"closure\".to_string(),\n-            ty::TyGenerator(..) => \"generator\".to_string(),\n-            ty::TyGeneratorWitness(..) => \"generator witness\".to_string(),\n-            ty::TyTuple(..) => \"tuple\".to_string(),\n-            ty::TyInfer(ty::TyVar(_)) => \"inferred type\".to_string(),\n-            ty::TyInfer(ty::IntVar(_)) => \"integral variable\".to_string(),\n-            ty::TyInfer(ty::FloatVar(_)) => \"floating-point variable\".to_string(),\n-            ty::TyInfer(ty::CanonicalTy(_)) |\n-            ty::TyInfer(ty::FreshTy(_)) => \"skolemized type\".to_string(),\n-            ty::TyInfer(ty::FreshIntTy(_)) => \"skolemized integral type\".to_string(),\n-            ty::TyInfer(ty::FreshFloatTy(_)) => \"skolemized floating-point type\".to_string(),\n-            ty::TyProjection(_) => \"associated type\".to_string(),\n-            ty::TyParam(ref p) => {\n+            ty::Closure(..) => \"closure\".to_string(),\n+            ty::Generator(..) => \"generator\".to_string(),\n+            ty::GeneratorWitness(..) => \"generator witness\".to_string(),\n+            ty::Tuple(..) => \"tuple\".to_string(),\n+            ty::Infer(ty::TyVar(_)) => \"inferred type\".to_string(),\n+            ty::Infer(ty::IntVar(_)) => \"integral variable\".to_string(),\n+            ty::Infer(ty::FloatVar(_)) => \"floating-point variable\".to_string(),\n+            ty::Infer(ty::CanonicalTy(_)) |\n+            ty::Infer(ty::FreshTy(_)) => \"skolemized type\".to_string(),\n+            ty::Infer(ty::FreshIntTy(_)) => \"skolemized integral type\".to_string(),\n+            ty::Infer(ty::FreshFloatTy(_)) => \"skolemized floating-point type\".to_string(),\n+            ty::Projection(_) => \"associated type\".to_string(),\n+            ty::Param(ref p) => {\n                 if p.is_self() {\n                     \"Self\".to_string()\n                 } else {\n                     \"type parameter\".to_string()\n                 }\n             }\n-            ty::TyAnon(..) => \"anonymized type\".to_string(),\n-            ty::TyError => \"type error\".to_string(),\n+            ty::Anon(..) => \"anonymized type\".to_string(),\n+            ty::Error => \"type error\".to_string(),\n         }\n     }\n }\n@@ -251,7 +251,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     db.help(\"consider boxing your closure and/or using it as a trait object\");\n                 }\n                 match (&values.found.sty, &values.expected.sty) { // Issue #53280\n-                    (ty::TyInfer(ty::IntVar(_)), ty::TyFloat(_)) => {\n+                    (ty::Infer(ty::IntVar(_)), ty::Float(_)) => {\n                         if let Ok(snippet) = self.sess.source_map().span_to_snippet(sp) {\n                             if snippet.chars().all(|c| c.is_digit(10) || c == '-' || c == '_') {\n                                 db.span_suggestion_with_applicability("}, {"sha": "567d1c668f7c7d2fbb4e43828043399dc689fdc0", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -68,42 +68,42 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                      -> Option<SimplifiedType>\n {\n     match ty.sty {\n-        ty::TyBool => Some(BoolSimplifiedType),\n-        ty::TyChar => Some(CharSimplifiedType),\n-        ty::TyInt(int_type) => Some(IntSimplifiedType(int_type)),\n-        ty::TyUint(uint_type) => Some(UintSimplifiedType(uint_type)),\n-        ty::TyFloat(float_type) => Some(FloatSimplifiedType(float_type)),\n-        ty::TyAdt(def, _) => Some(AdtSimplifiedType(def.did)),\n-        ty::TyStr => Some(StrSimplifiedType),\n-        ty::TyArray(..) | ty::TySlice(_) => Some(ArraySimplifiedType),\n-        ty::TyRawPtr(_) => Some(PtrSimplifiedType),\n-        ty::TyDynamic(ref trait_info, ..) => {\n+        ty::Bool => Some(BoolSimplifiedType),\n+        ty::Char => Some(CharSimplifiedType),\n+        ty::Int(int_type) => Some(IntSimplifiedType(int_type)),\n+        ty::Uint(uint_type) => Some(UintSimplifiedType(uint_type)),\n+        ty::Float(float_type) => Some(FloatSimplifiedType(float_type)),\n+        ty::Adt(def, _) => Some(AdtSimplifiedType(def.did)),\n+        ty::Str => Some(StrSimplifiedType),\n+        ty::Array(..) | ty::Slice(_) => Some(ArraySimplifiedType),\n+        ty::RawPtr(_) => Some(PtrSimplifiedType),\n+        ty::Dynamic(ref trait_info, ..) => {\n             trait_info.principal().map(|p| TraitSimplifiedType(p.def_id()))\n         }\n-        ty::TyRef(_, ty, _) => {\n+        ty::Ref(_, ty, _) => {\n             // since we introduce auto-refs during method lookup, we\n             // just treat &T and T as equivalent from the point of\n             // view of possibly unifying\n             simplify_type(tcx, ty, can_simplify_params)\n         }\n-        ty::TyFnDef(def_id, _) |\n-        ty::TyClosure(def_id, _) => {\n+        ty::FnDef(def_id, _) |\n+        ty::Closure(def_id, _) => {\n             Some(ClosureSimplifiedType(def_id))\n         }\n-        ty::TyGenerator(def_id, _, _) => {\n+        ty::Generator(def_id, _, _) => {\n             Some(GeneratorSimplifiedType(def_id))\n         }\n-        ty::TyGeneratorWitness(ref tys) => {\n+        ty::GeneratorWitness(ref tys) => {\n             Some(GeneratorWitnessSimplifiedType(tys.skip_binder().len()))\n         }\n-        ty::TyNever => Some(NeverSimplifiedType),\n-        ty::TyTuple(ref tys) => {\n+        ty::Never => Some(NeverSimplifiedType),\n+        ty::Tuple(ref tys) => {\n             Some(TupleSimplifiedType(tys.len()))\n         }\n-        ty::TyFnPtr(ref f) => {\n+        ty::FnPtr(ref f) => {\n             Some(FunctionSimplifiedType(f.skip_binder().inputs().len()))\n         }\n-        ty::TyProjection(_) | ty::TyParam(_) => {\n+        ty::Projection(_) | ty::Param(_) => {\n             if can_simplify_params {\n                 // In normalized types, projections don't unify with\n                 // anything. when lazy normalization happens, this\n@@ -115,13 +115,13 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                 None\n             }\n         }\n-        ty::TyAnon(def_id, _) => {\n+        ty::Anon(def_id, _) => {\n             Some(AnonSimplifiedType(def_id))\n         }\n-        ty::TyForeign(def_id) => {\n+        ty::Foreign(def_id) => {\n             Some(ForeignSimplifiedType(def_id))\n         }\n-        ty::TyInfer(_) | ty::TyError => None,\n+        ty::Infer(_) | ty::Error => None,\n     }\n }\n "}, {"sha": "b9371ec39ccdad00a79543eef173301e341bcabd", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -28,7 +28,7 @@ impl FlagComputation {\n         }\n     }\n \n-    pub fn for_sty(st: &ty::TypeVariants) -> FlagComputation {\n+    pub fn for_sty(st: &ty::TyKind) -> FlagComputation {\n         let mut result = FlagComputation::new();\n         result.add_sty(st);\n         result\n@@ -67,30 +67,30 @@ impl FlagComputation {\n         }\n     }\n \n-    fn add_sty(&mut self, st: &ty::TypeVariants) {\n+    fn add_sty(&mut self, st: &ty::TyKind) {\n         match st {\n-            &ty::TyBool |\n-            &ty::TyChar |\n-            &ty::TyInt(_) |\n-            &ty::TyFloat(_) |\n-            &ty::TyUint(_) |\n-            &ty::TyNever |\n-            &ty::TyStr |\n-            &ty::TyForeign(..) => {\n+            &ty::Bool |\n+            &ty::Char |\n+            &ty::Int(_) |\n+            &ty::Float(_) |\n+            &ty::Uint(_) |\n+            &ty::Never |\n+            &ty::Str |\n+            &ty::Foreign(..) => {\n             }\n \n-            // You might think that we could just return TyError for\n-            // any type containing TyError as a component, and get\n+            // You might think that we could just return Error for\n+            // any type containing Error as a component, and get\n             // rid of the TypeFlags::HAS_TY_ERR flag -- likewise for ty_bot (with\n             // the exception of function types that return bot).\n             // But doing so caused sporadic memory corruption, and\n             // neither I (tjc) nor nmatsakis could figure out why,\n             // so we're doing it this way.\n-            &ty::TyError => {\n+            &ty::Error => {\n                 self.add_flags(TypeFlags::HAS_TY_ERR)\n             }\n \n-            &ty::TyParam(ref p) => {\n+            &ty::Param(ref p) => {\n                 self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES);\n                 if p.is_self() {\n                     self.add_flags(TypeFlags::HAS_SELF);\n@@ -99,25 +99,25 @@ impl FlagComputation {\n                 }\n             }\n \n-            &ty::TyGenerator(_, ref substs, _) => {\n+            &ty::Generator(_, ref substs, _) => {\n                 self.add_flags(TypeFlags::HAS_TY_CLOSURE);\n                 self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES);\n                 self.add_substs(&substs.substs);\n             }\n \n-            &ty::TyGeneratorWitness(ref ts) => {\n+            &ty::GeneratorWitness(ref ts) => {\n                 let mut computation = FlagComputation::new();\n                 computation.add_tys(&ts.skip_binder()[..]);\n                 self.add_bound_computation(&computation);\n             }\n \n-            &ty::TyClosure(_, ref substs) => {\n+            &ty::Closure(_, ref substs) => {\n                 self.add_flags(TypeFlags::HAS_TY_CLOSURE);\n                 self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES);\n                 self.add_substs(&substs.substs);\n             }\n \n-            &ty::TyInfer(infer) => {\n+            &ty::Infer(infer) => {\n                 self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES); // it might, right?\n                 self.add_flags(TypeFlags::HAS_TY_INFER);\n                 match infer {\n@@ -136,11 +136,11 @@ impl FlagComputation {\n                 }\n             }\n \n-            &ty::TyAdt(_, substs) => {\n+            &ty::Adt(_, substs) => {\n                 self.add_substs(substs);\n             }\n \n-            &ty::TyProjection(ref data) => {\n+            &ty::Projection(ref data) => {\n                 // currently we can't normalize projections that\n                 // include bound regions, so track those separately.\n                 if !data.has_escaping_regions() {\n@@ -150,12 +150,12 @@ impl FlagComputation {\n                 self.add_projection_ty(data);\n             }\n \n-            &ty::TyAnon(_, substs) => {\n+            &ty::Anon(_, substs) => {\n                 self.add_flags(TypeFlags::HAS_PROJECTION);\n                 self.add_substs(substs);\n             }\n \n-            &ty::TyDynamic(ref obj, r) => {\n+            &ty::Dynamic(ref obj, r) => {\n                 let mut computation = FlagComputation::new();\n                 for predicate in obj.skip_binder().iter() {\n                     match *predicate {\n@@ -172,33 +172,33 @@ impl FlagComputation {\n                 self.add_region(r);\n             }\n \n-            &ty::TyArray(tt, len) => {\n+            &ty::Array(tt, len) => {\n                 self.add_ty(tt);\n                 self.add_const(len);\n             }\n \n-            &ty::TySlice(tt) => {\n+            &ty::Slice(tt) => {\n                 self.add_ty(tt)\n             }\n \n-            &ty::TyRawPtr(ref m) => {\n+            &ty::RawPtr(ref m) => {\n                 self.add_ty(m.ty);\n             }\n \n-            &ty::TyRef(r, ty, _) => {\n+            &ty::Ref(r, ty, _) => {\n                 self.add_region(r);\n                 self.add_ty(ty);\n             }\n \n-            &ty::TyTuple(ref ts) => {\n+            &ty::Tuple(ref ts) => {\n                 self.add_tys(&ts[..]);\n             }\n \n-            &ty::TyFnDef(_, substs) => {\n+            &ty::FnDef(_, substs) => {\n                 self.add_substs(substs);\n             }\n \n-            &ty::TyFnPtr(f) => {\n+            &ty::FnPtr(f) => {\n                 self.add_fn_sig(f);\n             }\n         }"}, {"sha": "26010c3d5f55c0b3b87652734c0a3596ba89aeb7", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -771,7 +771,7 @@ impl<'tcx> TypeVisitor<'tcx> for LateBoundRegionsCollector {\n         // in the normalized form\n         if self.just_constrained {\n             match t.sty {\n-                ty::TyProjection(..) | ty::TyAnon(..) => { return false; }\n+                ty::Projection(..) | ty::Anon(..) => { return false; }\n                 _ => { }\n             }\n         }"}, {"sha": "ef5b2236200322bf7c34ee921899058b2e67030f", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -13,7 +13,7 @@ use ty::context::TyCtxt;\n use ty::{AdtDef, VariantDef, FieldDef, Ty, TyS};\n use ty::{DefId, Substs};\n use ty::{AdtKind, Visibility};\n-use ty::TypeVariants::*;\n+use ty::TyKind::*;\n \n pub use self::def_id_forest::DefIdForest;\n \n@@ -226,7 +226,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest\n     {\n         match self.sty {\n-            TyAdt(def, substs) => {\n+            Adt(def, substs) => {\n                 {\n                     let substs_set = visited.entry(def.did).or_default();\n                     if !substs_set.insert(substs) {\n@@ -255,21 +255,21 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n                 ret\n             },\n \n-            TyNever => DefIdForest::full(tcx),\n-            TyTuple(ref tys) => {\n+            Never => DefIdForest::full(tcx),\n+            Tuple(ref tys) => {\n                 DefIdForest::union(tcx, tys.iter().map(|ty| {\n                     ty.uninhabited_from(visited, tcx)\n                 }))\n             },\n-            TyArray(ty, len) => {\n+            Array(ty, len) => {\n                 match len.assert_usize(tcx) {\n                     // If the array is definitely non-empty, it's uninhabited if\n                     // the type of its elements is uninhabited.\n                     Some(n) if n != 0 => ty.uninhabited_from(visited, tcx),\n                     _ => DefIdForest::empty()\n                 }\n             }\n-            TyRef(_, ty, _) => {\n+            Ref(_, ty, _) => {\n                 ty.uninhabited_from(visited, tcx)\n             }\n "}, {"sha": "68996f52b867a27adf6fd88dd9c2c264c8a35baa", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -194,7 +194,7 @@ impl<'a, 'b, 'tcx> Instance<'tcx> {\n             );\n \n             let def = match item_type.sty {\n-                ty::TyFnDef(..) if {\n+                ty::FnDef(..) if {\n                     let f = item_type.fn_sig(tcx);\n                     f.abi() == Abi::RustIntrinsic ||\n                         f.abi() == Abi::PlatformIntrinsic"}, {"sha": "e38bb411a14f97bf4531ffd85b7a2272b69a3a03", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -299,22 +299,22 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // impl on `Foo`, but fallback to `<Foo>::bar` if self-type is\n         // anything other than a simple path.\n         match self_ty.sty {\n-            ty::TyAdt(adt_def, substs) => {\n+            ty::Adt(adt_def, substs) => {\n                 if substs.types().next().is_none() { // ignore regions\n                     self.push_item_path(buffer, adt_def.did);\n                 } else {\n                     buffer.push(&format!(\"<{}>\", self_ty));\n                 }\n             }\n \n-            ty::TyForeign(did) => self.push_item_path(buffer, did),\n+            ty::Foreign(did) => self.push_item_path(buffer, did),\n \n-            ty::TyBool |\n-            ty::TyChar |\n-            ty::TyInt(_) |\n-            ty::TyUint(_) |\n-            ty::TyFloat(_) |\n-            ty::TyStr => {\n+            ty::Bool |\n+            ty::Char |\n+            ty::Int(_) |\n+            ty::Uint(_) |\n+            ty::Float(_) |\n+            ty::Str => {\n                 buffer.push(&self_ty.to_string());\n             }\n \n@@ -357,40 +357,40 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n /// decisions and we may want to adjust it later.\n pub fn characteristic_def_id_of_type(ty: Ty) -> Option<DefId> {\n     match ty.sty {\n-        ty::TyAdt(adt_def, _) => Some(adt_def.did),\n+        ty::Adt(adt_def, _) => Some(adt_def.did),\n \n-        ty::TyDynamic(data, ..) => data.principal().map(|p| p.def_id()),\n+        ty::Dynamic(data, ..) => data.principal().map(|p| p.def_id()),\n \n-        ty::TyArray(subty, _) |\n-        ty::TySlice(subty) => characteristic_def_id_of_type(subty),\n+        ty::Array(subty, _) |\n+        ty::Slice(subty) => characteristic_def_id_of_type(subty),\n \n-        ty::TyRawPtr(mt) => characteristic_def_id_of_type(mt.ty),\n+        ty::RawPtr(mt) => characteristic_def_id_of_type(mt.ty),\n \n-        ty::TyRef(_, ty, _) => characteristic_def_id_of_type(ty),\n+        ty::Ref(_, ty, _) => characteristic_def_id_of_type(ty),\n \n-        ty::TyTuple(ref tys) => tys.iter()\n+        ty::Tuple(ref tys) => tys.iter()\n                                    .filter_map(|ty| characteristic_def_id_of_type(ty))\n                                    .next(),\n \n-        ty::TyFnDef(def_id, _) |\n-        ty::TyClosure(def_id, _) |\n-        ty::TyGenerator(def_id, _, _) |\n-        ty::TyForeign(def_id) => Some(def_id),\n-\n-        ty::TyBool |\n-        ty::TyChar |\n-        ty::TyInt(_) |\n-        ty::TyUint(_) |\n-        ty::TyStr |\n-        ty::TyFnPtr(_) |\n-        ty::TyProjection(_) |\n-        ty::TyParam(_) |\n-        ty::TyAnon(..) |\n-        ty::TyInfer(_) |\n-        ty::TyError |\n-        ty::TyGeneratorWitness(..) |\n-        ty::TyNever |\n-        ty::TyFloat(_) => None,\n+        ty::FnDef(def_id, _) |\n+        ty::Closure(def_id, _) |\n+        ty::Generator(def_id, _, _) |\n+        ty::Foreign(def_id) => Some(def_id),\n+\n+        ty::Bool |\n+        ty::Char |\n+        ty::Int(_) |\n+        ty::Uint(_) |\n+        ty::Str |\n+        ty::FnPtr(_) |\n+        ty::Projection(_) |\n+        ty::Param(_) |\n+        ty::Anon(..) |\n+        ty::Infer(_) |\n+        ty::Error |\n+        ty::GeneratorWitness(..) |\n+        ty::Never |\n+        ty::Float(_) => None,\n     }\n }\n "}, {"sha": "d485b9b32d4310fa4c19f91034160ec3a79fe991", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -470,33 +470,33 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n \n         Ok(match ty.sty {\n             // Basic scalars.\n-            ty::TyBool => {\n+            ty::Bool => {\n                 tcx.intern_layout(LayoutDetails::scalar(self, Scalar {\n                     value: Int(I8, false),\n                     valid_range: 0..=1\n                 }))\n             }\n-            ty::TyChar => {\n+            ty::Char => {\n                 tcx.intern_layout(LayoutDetails::scalar(self, Scalar {\n                     value: Int(I32, false),\n                     valid_range: 0..=0x10FFFF\n                 }))\n             }\n-            ty::TyInt(ity) => {\n+            ty::Int(ity) => {\n                 scalar(Int(Integer::from_attr(dl, attr::SignedInt(ity)), true))\n             }\n-            ty::TyUint(ity) => {\n+            ty::Uint(ity) => {\n                 scalar(Int(Integer::from_attr(dl, attr::UnsignedInt(ity)), false))\n             }\n-            ty::TyFloat(fty) => scalar(Float(fty)),\n-            ty::TyFnPtr(_) => {\n+            ty::Float(fty) => scalar(Float(fty)),\n+            ty::FnPtr(_) => {\n                 let mut ptr = scalar_unit(Pointer);\n                 ptr.valid_range = 1..=*ptr.valid_range.end();\n                 tcx.intern_layout(LayoutDetails::scalar(self, ptr))\n             }\n \n             // The never type.\n-            ty::TyNever => {\n+            ty::Never => {\n                 tcx.intern_layout(LayoutDetails {\n                     variants: Variants::Single { index: 0 },\n                     fields: FieldPlacement::Union(0),\n@@ -507,8 +507,8 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             }\n \n             // Potentially-fat pointers.\n-            ty::TyRef(_, pointee, _) |\n-            ty::TyRawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n+            ty::Ref(_, pointee, _) |\n+            ty::RawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n                 let mut data_ptr = scalar_unit(Pointer);\n                 if !ty.is_unsafe_ptr() {\n                     data_ptr.valid_range = 1..=*data_ptr.valid_range.end();\n@@ -521,13 +521,13 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n \n                 let unsized_part = tcx.struct_tail(pointee);\n                 let metadata = match unsized_part.sty {\n-                    ty::TyForeign(..) => {\n+                    ty::Foreign(..) => {\n                         return Ok(tcx.intern_layout(LayoutDetails::scalar(self, data_ptr)));\n                     }\n-                    ty::TySlice(_) | ty::TyStr => {\n+                    ty::Slice(_) | ty::Str => {\n                         scalar_unit(Int(dl.ptr_sized_integer(), false))\n                     }\n-                    ty::TyDynamic(..) => {\n+                    ty::Dynamic(..) => {\n                         let mut vtable = scalar_unit(Pointer);\n                         vtable.valid_range = 1..=*vtable.valid_range.end();\n                         vtable\n@@ -540,7 +540,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             }\n \n             // Arrays and slices.\n-            ty::TyArray(element, mut count) => {\n+            ty::Array(element, mut count) => {\n                 if count.has_projections() {\n                     count = tcx.normalize_erasing_regions(param_env, count);\n                     if count.has_projections() {\n@@ -564,7 +564,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     size\n                 })\n             }\n-            ty::TySlice(element) => {\n+            ty::Slice(element) => {\n                 let element = self.layout_of(element)?;\n                 tcx.intern_layout(LayoutDetails {\n                     variants: Variants::Single { index: 0 },\n@@ -577,7 +577,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     size: Size::ZERO\n                 })\n             }\n-            ty::TyStr => {\n+            ty::Str => {\n                 tcx.intern_layout(LayoutDetails {\n                     variants: Variants::Single { index: 0 },\n                     fields: FieldPlacement::Array {\n@@ -591,10 +591,10 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             }\n \n             // Odd unit types.\n-            ty::TyFnDef(..) => {\n+            ty::FnDef(..) => {\n                 univariant(&[], &ReprOptions::default(), StructKind::AlwaysSized)?\n             }\n-            ty::TyDynamic(..) | ty::TyForeign(..) => {\n+            ty::Dynamic(..) | ty::Foreign(..) => {\n                 let mut unit = univariant_uninterned(&[], &ReprOptions::default(),\n                   StructKind::AlwaysSized)?;\n                 match unit.abi {\n@@ -605,21 +605,21 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             }\n \n             // Tuples, generators and closures.\n-            ty::TyGenerator(def_id, ref substs, _) => {\n+            ty::Generator(def_id, ref substs, _) => {\n                 let tys = substs.field_tys(def_id, tcx);\n                 univariant(&tys.map(|ty| self.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n                     &ReprOptions::default(),\n                     StructKind::AlwaysSized)?\n             }\n \n-            ty::TyClosure(def_id, ref substs) => {\n+            ty::Closure(def_id, ref substs) => {\n                 let tys = substs.upvar_tys(def_id, tcx);\n                 univariant(&tys.map(|ty| self.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n                     &ReprOptions::default(),\n                     StructKind::AlwaysSized)?\n             }\n \n-            ty::TyTuple(tys) => {\n+            ty::Tuple(tys) => {\n                 let kind = if tys.len() == 0 {\n                     StructKind::AlwaysSized\n                 } else {\n@@ -631,7 +631,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             }\n \n             // SIMD vector types.\n-            ty::TyAdt(def, ..) if def.repr.simd() => {\n+            ty::Adt(def, ..) if def.repr.simd() => {\n                 let element = self.layout_of(ty.simd_type(tcx))?;\n                 let count = ty.simd_size(tcx) as u64;\n                 assert!(count > 0);\n@@ -664,7 +664,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             }\n \n             // ADTs.\n-            ty::TyAdt(def, substs) => {\n+            ty::Adt(def, substs) => {\n                 // Cache the field layouts.\n                 let variants = def.variants.iter().map(|v| {\n                     v.fields.iter().map(|field| {\n@@ -1103,17 +1103,17 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             }\n \n             // Types with no meaningful known layout.\n-            ty::TyProjection(_) | ty::TyAnon(..) => {\n+            ty::Projection(_) | ty::Anon(..) => {\n                 let normalized = tcx.normalize_erasing_regions(param_env, ty);\n                 if ty == normalized {\n                     return Err(LayoutError::Unknown(ty));\n                 }\n                 tcx.layout_raw(param_env.and(normalized))?\n             }\n-            ty::TyGeneratorWitness(..) | ty::TyInfer(_) => {\n+            ty::GeneratorWitness(..) | ty::Infer(_) => {\n                 bug!(\"LayoutDetails::compute: unexpected type `{}`\", ty)\n             }\n-            ty::TyParam(_) | ty::TyError => {\n+            ty::Param(_) | ty::Error => {\n                 return Err(LayoutError::Unknown(ty));\n             }\n         })\n@@ -1153,12 +1153,12 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n         };\n \n         let adt_def = match layout.ty.sty {\n-            ty::TyAdt(ref adt_def, _) => {\n+            ty::Adt(ref adt_def, _) => {\n                 debug!(\"print-type-size t: `{:?}` process adt\", layout.ty);\n                 adt_def\n             }\n \n-            ty::TyClosure(..) => {\n+            ty::Closure(..) => {\n                 debug!(\"print-type-size t: `{:?}` record closure\", layout.ty);\n                 record(DataTypeKind::Closure, false, None, vec![]);\n                 return;\n@@ -1294,12 +1294,12 @@ impl<'a, 'tcx> SizeSkeleton<'tcx> {\n         };\n \n         match ty.sty {\n-            ty::TyRef(_, pointee, _) |\n-            ty::TyRawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n+            ty::Ref(_, pointee, _) |\n+            ty::RawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n                 let non_zero = !ty.is_unsafe_ptr();\n                 let tail = tcx.struct_tail(pointee);\n                 match tail.sty {\n-                    ty::TyParam(_) | ty::TyProjection(_) => {\n+                    ty::Param(_) | ty::Projection(_) => {\n                         debug_assert!(tail.has_param_types() || tail.has_self_ty());\n                         Ok(SizeSkeleton::Pointer {\n                             non_zero,\n@@ -1314,7 +1314,7 @@ impl<'a, 'tcx> SizeSkeleton<'tcx> {\n                 }\n             }\n \n-            ty::TyAdt(def, substs) => {\n+            ty::Adt(def, substs) => {\n                 // Only newtypes and enums w/ nullable pointer optimization.\n                 if def.is_union() || def.variants.is_empty() || def.variants.len() > 2 {\n                     return Err(err);\n@@ -1373,7 +1373,7 @@ impl<'a, 'tcx> SizeSkeleton<'tcx> {\n                 }\n             }\n \n-            ty::TyProjection(_) | ty::TyAnon(..) => {\n+            ty::Projection(_) | ty::Anon(..) => {\n                 let normalized = tcx.normalize_erasing_regions(param_env, ty);\n                 if ty == normalized {\n                     Err(err)\n@@ -1552,7 +1552,7 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n                 });\n \n                 let fields = match this.ty.sty {\n-                    ty::TyAdt(def, _) => def.variants[variant_index].fields.len(),\n+                    ty::Adt(def, _) => def.variants[variant_index].fields.len(),\n                     _ => bug!()\n                 };\n                 let tcx = cx.tcx();\n@@ -1582,23 +1582,23 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n     fn field(this: TyLayout<'tcx>, cx: C, i: usize) -> C::TyLayout {\n         let tcx = cx.tcx();\n         cx.layout_of(match this.ty.sty {\n-            ty::TyBool |\n-            ty::TyChar |\n-            ty::TyInt(_) |\n-            ty::TyUint(_) |\n-            ty::TyFloat(_) |\n-            ty::TyFnPtr(_) |\n-            ty::TyNever |\n-            ty::TyFnDef(..) |\n-            ty::TyGeneratorWitness(..) |\n-            ty::TyForeign(..) |\n-            ty::TyDynamic(..) => {\n+            ty::Bool |\n+            ty::Char |\n+            ty::Int(_) |\n+            ty::Uint(_) |\n+            ty::Float(_) |\n+            ty::FnPtr(_) |\n+            ty::Never |\n+            ty::FnDef(..) |\n+            ty::GeneratorWitness(..) |\n+            ty::Foreign(..) |\n+            ty::Dynamic(..) => {\n                 bug!(\"TyLayout::field_type({:?}): not applicable\", this)\n             }\n \n             // Potentially-fat pointers.\n-            ty::TyRef(_, pointee, _) |\n-            ty::TyRawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n+            ty::Ref(_, pointee, _) |\n+            ty::RawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n                 assert!(i < this.fields.count());\n \n                 // Reuse the fat *T type as its own thin pointer data field.\n@@ -1619,9 +1619,9 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n                 }\n \n                 match tcx.struct_tail(pointee).sty {\n-                    ty::TySlice(_) |\n-                    ty::TyStr => tcx.types.usize,\n-                    ty::TyDynamic(data, _) => {\n+                    ty::Slice(_) |\n+                    ty::Str => tcx.types.usize,\n+                    ty::Dynamic(data, _) => {\n                         let trait_def_id = data.principal().unwrap().def_id();\n                         let num_fns: u64 = crate::traits::supertrait_def_ids(tcx, trait_def_id)\n                             .map(|trait_def_id| {\n@@ -1646,28 +1646,28 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n             }\n \n             // Arrays and slices.\n-            ty::TyArray(element, _) |\n-            ty::TySlice(element) => element,\n-            ty::TyStr => tcx.types.u8,\n+            ty::Array(element, _) |\n+            ty::Slice(element) => element,\n+            ty::Str => tcx.types.u8,\n \n             // Tuples, generators and closures.\n-            ty::TyClosure(def_id, ref substs) => {\n+            ty::Closure(def_id, ref substs) => {\n                 substs.upvar_tys(def_id, tcx).nth(i).unwrap()\n             }\n \n-            ty::TyGenerator(def_id, ref substs, _) => {\n+            ty::Generator(def_id, ref substs, _) => {\n                 substs.field_tys(def_id, tcx).nth(i).unwrap()\n             }\n \n-            ty::TyTuple(tys) => tys[i],\n+            ty::Tuple(tys) => tys[i],\n \n             // SIMD vector types.\n-            ty::TyAdt(def, ..) if def.repr.simd() => {\n+            ty::Adt(def, ..) if def.repr.simd() => {\n                 this.ty.simd_type(tcx)\n             }\n \n             // ADTs.\n-            ty::TyAdt(def, substs) => {\n+            ty::Adt(def, substs) => {\n                 match this.variants {\n                     Variants::Single { index } => {\n                         def.variants[index].fields[i].ty(tcx, substs)\n@@ -1686,8 +1686,8 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n                 }\n             }\n \n-            ty::TyProjection(_) | ty::TyAnon(..) | ty::TyParam(_) |\n-            ty::TyInfer(_) | ty::TyError => {\n+            ty::Projection(_) | ty::Anon(..) | ty::Param(_) |\n+            ty::Infer(_) | ty::Error => {\n                 bug!(\"TyLayout::field_type: unexpected type `{}`\", this.ty)\n             }\n         })\n@@ -1749,7 +1749,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n         // Locals variables which live across yields are stored\n         // in the generator type as fields. These may be uninitialized\n         // so we don't look for niches there.\n-        if let ty::TyGenerator(..) = layout.ty.sty {\n+        if let ty::Generator(..) = layout.ty.sty {\n             return Ok(None);\n         }\n "}, {"sha": "8d5006d17b3abe875827916ba5e57f5007259e82", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 67, "deletions": 66, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -65,7 +65,7 @@ pub use self::sty::{Binder, CanonicalVar, DebruijnIndex, INNERMOST};\n pub use self::sty::{FnSig, GenSig, PolyFnSig, PolyGenSig};\n pub use self::sty::{InferTy, ParamTy, ProjectionTy, ExistentialPredicate};\n pub use self::sty::{ClosureSubsts, GeneratorSubsts, UpvarSubsts, TypeAndMut};\n-pub use self::sty::{TraitRef, TypeVariants, PolyTraitRef};\n+pub use self::sty::{TraitRef, TyKind, PolyTraitRef};\n pub use self::sty::{ExistentialTraitRef, PolyExistentialTraitRef};\n pub use self::sty::{ExistentialProjection, PolyExistentialProjection, Const};\n pub use self::sty::{BoundRegion, EarlyBoundRegion, FreeRegion, Region};\n@@ -74,7 +74,7 @@ pub use self::sty::{TyVid, IntVid, FloatVid, RegionVid};\n pub use self::sty::BoundRegion::*;\n pub use self::sty::InferTy::*;\n pub use self::sty::RegionKind::*;\n-pub use self::sty::TypeVariants::*;\n+pub use self::sty::TyKind::*;\n \n pub use self::binding::BindingMode;\n pub use self::binding::BindingMode::*;\n@@ -450,7 +450,7 @@ bitflags! {\n         const HAS_FREE_LOCAL_NAMES    = 1 << 10;\n \n         // Present if the type belongs in a local type context.\n-        // Only set for TyInfer other than Fresh.\n+        // Only set for Infer other than Fresh.\n         const KEEP_IN_LOCAL_TCX  = 1 << 11;\n \n         // Is there a projection that does not involve a bound region?\n@@ -490,7 +490,7 @@ bitflags! {\n }\n \n pub struct TyS<'tcx> {\n-    pub sty: TypeVariants<'tcx>,\n+    pub sty: TyKind<'tcx>,\n     pub flags: TypeFlags,\n \n     /// This is a kind of confusing thing: it stores the smallest\n@@ -542,29 +542,29 @@ impl<'tcx> Hash for TyS<'tcx> {\n impl<'tcx> TyS<'tcx> {\n     pub fn is_primitive_ty(&self) -> bool {\n         match self.sty {\n-            TypeVariants::TyBool |\n-                TypeVariants::TyChar |\n-                TypeVariants::TyInt(_) |\n-                TypeVariants::TyUint(_) |\n-                TypeVariants::TyFloat(_) |\n-                TypeVariants::TyInfer(InferTy::IntVar(_)) |\n-                TypeVariants::TyInfer(InferTy::FloatVar(_)) |\n-                TypeVariants::TyInfer(InferTy::FreshIntTy(_)) |\n-                TypeVariants::TyInfer(InferTy::FreshFloatTy(_)) => true,\n-            TypeVariants::TyRef(_, x, _) => x.is_primitive_ty(),\n+            TyKind::Bool |\n+                TyKind::Char |\n+                TyKind::Int(_) |\n+                TyKind::Uint(_) |\n+                TyKind::Float(_) |\n+                TyKind::Infer(InferTy::IntVar(_)) |\n+                TyKind::Infer(InferTy::FloatVar(_)) |\n+                TyKind::Infer(InferTy::FreshIntTy(_)) |\n+                TyKind::Infer(InferTy::FreshFloatTy(_)) => true,\n+            TyKind::Ref(_, x, _) => x.is_primitive_ty(),\n             _ => false,\n         }\n     }\n \n     pub fn is_suggestable(&self) -> bool {\n         match self.sty {\n-            TypeVariants::TyAnon(..) |\n-            TypeVariants::TyFnDef(..) |\n-            TypeVariants::TyFnPtr(..) |\n-            TypeVariants::TyDynamic(..) |\n-            TypeVariants::TyClosure(..) |\n-            TypeVariants::TyInfer(..) |\n-            TypeVariants::TyProjection(..) => false,\n+            TyKind::Anon(..) |\n+            TyKind::FnDef(..) |\n+            TyKind::FnPtr(..) |\n+            TyKind::Dynamic(..) |\n+            TyKind::Closure(..) |\n+            TyKind::Infer(..) |\n+            TyKind::Projection(..) => false,\n             _ => true,\n         }\n     }\n@@ -596,27 +596,28 @@ impl<'tcx> serialize::UseSpecializedDecodable for Ty<'tcx> {}\n pub type CanonicalTy<'gcx> = Canonical<'gcx, Ty<'gcx>>;\n \n extern {\n-    /// A dummy type used to force Slice to by unsized without requiring fat pointers\n-    type OpaqueSliceContents;\n+    /// A dummy type used to force List to by unsized without requiring fat pointers\n+    type OpaqueListContents;\n }\n \n /// A wrapper for slices with the additional invariant\n /// that the slice is interned and no other slice with\n /// the same contents can exist in the same context.\n /// This means we can use pointer for both\n /// equality comparisons and hashing.\n+/// Note: `Slice` was already taken by the `Ty`.\n #[repr(C)]\n-pub struct Slice<T> {\n+pub struct List<T> {\n     len: usize,\n     data: [T; 0],\n-    opaque: OpaqueSliceContents,\n+    opaque: OpaqueListContents,\n }\n \n-unsafe impl<T: Sync> Sync for Slice<T> {}\n+unsafe impl<T: Sync> Sync for List<T> {}\n \n-impl<T: Copy> Slice<T> {\n+impl<T: Copy> List<T> {\n     #[inline]\n-    fn from_arena<'tcx>(arena: &'tcx SyncDroplessArena, slice: &[T]) -> &'tcx Slice<T> {\n+    fn from_arena<'tcx>(arena: &'tcx SyncDroplessArena, slice: &[T]) -> &'tcx List<T> {\n         assert!(!mem::needs_drop::<T>());\n         assert!(mem::size_of::<T>() != 0);\n         assert!(slice.len() != 0);\n@@ -633,7 +634,7 @@ impl<T: Copy> Slice<T> {\n             size,\n             cmp::max(mem::align_of::<T>(), mem::align_of::<usize>()));\n         unsafe {\n-            let result = &mut *(mem.as_mut_ptr() as *mut Slice<T>);\n+            let result = &mut *(mem.as_mut_ptr() as *mut List<T>);\n             // Write the length\n             result.len = slice.len();\n \n@@ -646,51 +647,51 @@ impl<T: Copy> Slice<T> {\n     }\n }\n \n-impl<T: fmt::Debug> fmt::Debug for Slice<T> {\n+impl<T: fmt::Debug> fmt::Debug for List<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         (**self).fmt(f)\n     }\n }\n \n-impl<T: Encodable> Encodable for Slice<T> {\n+impl<T: Encodable> Encodable for List<T> {\n     #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         (**self).encode(s)\n     }\n }\n \n-impl<T> Ord for Slice<T> where T: Ord {\n-    fn cmp(&self, other: &Slice<T>) -> Ordering {\n+impl<T> Ord for List<T> where T: Ord {\n+    fn cmp(&self, other: &List<T>) -> Ordering {\n         if self == other { Ordering::Equal } else {\n             <[T] as Ord>::cmp(&**self, &**other)\n         }\n     }\n }\n \n-impl<T> PartialOrd for Slice<T> where T: PartialOrd {\n-    fn partial_cmp(&self, other: &Slice<T>) -> Option<Ordering> {\n+impl<T> PartialOrd for List<T> where T: PartialOrd {\n+    fn partial_cmp(&self, other: &List<T>) -> Option<Ordering> {\n         if self == other { Some(Ordering::Equal) } else {\n             <[T] as PartialOrd>::partial_cmp(&**self, &**other)\n         }\n     }\n }\n \n-impl<T: PartialEq> PartialEq for Slice<T> {\n+impl<T: PartialEq> PartialEq for List<T> {\n     #[inline]\n-    fn eq(&self, other: &Slice<T>) -> bool {\n+    fn eq(&self, other: &List<T>) -> bool {\n         ptr::eq(self, other)\n     }\n }\n-impl<T: Eq> Eq for Slice<T> {}\n+impl<T: Eq> Eq for List<T> {}\n \n-impl<T> Hash for Slice<T> {\n+impl<T> Hash for List<T> {\n     #[inline]\n     fn hash<H: Hasher>(&self, s: &mut H) {\n-        (self as *const Slice<T>).hash(s)\n+        (self as *const List<T>).hash(s)\n     }\n }\n \n-impl<T> Deref for Slice<T> {\n+impl<T> Deref for List<T> {\n     type Target = [T];\n     #[inline(always)]\n     fn deref(&self) -> &[T] {\n@@ -700,7 +701,7 @@ impl<T> Deref for Slice<T> {\n     }\n }\n \n-impl<'a, T> IntoIterator for &'a Slice<T> {\n+impl<'a, T> IntoIterator for &'a List<T> {\n     type Item = &'a T;\n     type IntoIter = <&'a [T] as IntoIterator>::IntoIter;\n     #[inline(always)]\n@@ -709,17 +710,17 @@ impl<'a, T> IntoIterator for &'a Slice<T> {\n     }\n }\n \n-impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Slice<Ty<'tcx>> {}\n+impl<'tcx> serialize::UseSpecializedDecodable for &'tcx List<Ty<'tcx>> {}\n \n-impl<T> Slice<T> {\n+impl<T> List<T> {\n     #[inline(always)]\n-    pub fn empty<'a>() -> &'a Slice<T> {\n+    pub fn empty<'a>() -> &'a List<T> {\n         #[repr(align(64), C)]\n         struct EmptySlice([u8; 64]);\n         static EMPTY_SLICE: EmptySlice = EmptySlice([0; 64]);\n         assert!(mem::align_of::<T>() <= 64);\n         unsafe {\n-            &*(&EMPTY_SLICE as *const _ as *const Slice<T>)\n+            &*(&EMPTY_SLICE as *const _ as *const List<T>)\n         }\n     }\n }\n@@ -1556,7 +1557,7 @@ pub struct ParamEnv<'tcx> {\n     /// Obligations that the caller must satisfy. This is basically\n     /// the set of bounds on the in-scope type parameters, translated\n     /// into Obligations, and elaborated and normalized.\n-    pub caller_bounds: &'tcx Slice<ty::Predicate<'tcx>>,\n+    pub caller_bounds: &'tcx List<ty::Predicate<'tcx>>,\n \n     /// Typically, this is `Reveal::UserFacing`, but during codegen we\n     /// want `Reveal::All` -- note that this is always paired with an\n@@ -1570,7 +1571,7 @@ impl<'tcx> ParamEnv<'tcx> {\n     /// Trait`) are left hidden, so this is suitable for ordinary\n     /// type-checking.\n     pub fn empty() -> Self {\n-        Self::new(ty::Slice::empty(), Reveal::UserFacing)\n+        Self::new(List::empty(), Reveal::UserFacing)\n     }\n \n     /// Construct a trait environment with no where clauses in scope\n@@ -1581,11 +1582,11 @@ impl<'tcx> ParamEnv<'tcx> {\n     /// NB. If you want to have predicates in scope, use `ParamEnv::new`,\n     /// or invoke `param_env.with_reveal_all()`.\n     pub fn reveal_all() -> Self {\n-        Self::new(ty::Slice::empty(), Reveal::All)\n+        Self::new(List::empty(), Reveal::All)\n     }\n \n     /// Construct a trait environment with the given set of predicates.\n-    pub fn new(caller_bounds: &'tcx ty::Slice<ty::Predicate<'tcx>>,\n+    pub fn new(caller_bounds: &'tcx List<ty::Predicate<'tcx>>,\n                reveal: Reveal)\n                -> Self {\n         ty::ParamEnv { caller_bounds, reveal }\n@@ -1603,7 +1604,7 @@ impl<'tcx> ParamEnv<'tcx> {\n \n     /// Returns this same environment but with no caller bounds.\n     pub fn without_caller_bounds(self) -> Self {\n-        ty::ParamEnv { caller_bounds: ty::Slice::empty(), ..self }\n+        ty::ParamEnv { caller_bounds: List::empty(), ..self }\n     }\n \n     /// Creates a suitable environment in which to perform trait\n@@ -2229,30 +2230,30 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                                ty: Ty<'tcx>)\n                                -> Vec<Ty<'tcx>> {\n         let result = match ty.sty {\n-            TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n-            TyRawPtr(..) | TyRef(..) | TyFnDef(..) | TyFnPtr(_) |\n-            TyArray(..) | TyClosure(..) | TyGenerator(..) | TyNever => {\n+            Bool | Char | Int(..) | Uint(..) | Float(..) |\n+            RawPtr(..) | Ref(..) | FnDef(..) | FnPtr(_) |\n+            Array(..) | Closure(..) | Generator(..) | Never => {\n                 vec![]\n             }\n \n-            TyStr |\n-            TyDynamic(..) |\n-            TySlice(_) |\n-            TyForeign(..) |\n-            TyError |\n-            TyGeneratorWitness(..) => {\n+            Str |\n+            Dynamic(..) |\n+            Slice(_) |\n+            Foreign(..) |\n+            Error |\n+            GeneratorWitness(..) => {\n                 // these are never sized - return the target type\n                 vec![ty]\n             }\n \n-            TyTuple(ref tys) => {\n+            Tuple(ref tys) => {\n                 match tys.last() {\n                     None => vec![],\n                     Some(ty) => self.sized_constraint_for_ty(tcx, ty)\n                 }\n             }\n \n-            TyAdt(adt, substs) => {\n+            Adt(adt, substs) => {\n                 // recursive case\n                 let adt_tys = adt.sized_constraint(tcx);\n                 debug!(\"sized_constraint_for_ty({:?}) intermediate = {:?}\",\n@@ -2263,13 +2264,13 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                     .collect()\n             }\n \n-            TyProjection(..) | TyAnon(..) => {\n+            Projection(..) | Anon(..) => {\n                 // must calculate explicitly.\n                 // FIXME: consider special-casing always-Sized projections\n                 vec![ty]\n             }\n \n-            TyParam(..) => {\n+            Param(..) => {\n                 // perf hack: if there is a `T: Sized` bound, then\n                 // we know that `T` is Sized and do not need to check\n                 // it on the impl.\n@@ -2290,7 +2291,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                 }\n             }\n \n-            TyInfer(..) => {\n+            Infer(..) => {\n                 bug!(\"unexpected type `{:?}` in sized_constraint_for_ty\",\n                      ty)\n             }\n@@ -2832,7 +2833,7 @@ fn associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n ///     - a type parameter or projection whose Sizedness can't be known\n ///     - a tuple of type parameters or projections, if there are multiple\n ///       such.\n-///     - a TyError, if a type contained itself. The representability\n+///     - a Error, if a type contained itself. The representability\n ///       check should catch this case.\n fn adt_sized_constraint<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   def_id: DefId)"}, {"sha": "5171bfb7e06083e62e1bd58216e5effd65ce7a67", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -72,14 +72,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // in the `subtys` iterator (e.g., when encountering a\n         // projection).\n         match ty.sty {\n-            ty::TyClosure(def_id, ref substs) => {\n+            ty::Closure(def_id, ref substs) => {\n \n                 for upvar_ty in substs.upvar_tys(def_id, *self) {\n                     self.compute_components(upvar_ty, out);\n                 }\n             }\n \n-            ty::TyGenerator(def_id, ref substs, _) => {\n+            ty::Generator(def_id, ref substs, _) => {\n                 // Same as the closure case\n                 for upvar_ty in substs.upvar_tys(def_id, *self) {\n                     self.compute_components(upvar_ty, out);\n@@ -90,11 +90,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             // All regions are bound inside a witness\n-            ty::TyGeneratorWitness(..) => (),\n+            ty::GeneratorWitness(..) => (),\n \n             // OutlivesTypeParameterEnv -- the actual checking that `X:'a`\n             // is implied by the environment is done in regionck.\n-            ty::TyParam(p) => {\n+            ty::Param(p) => {\n                 out.push(Component::Param(p));\n             }\n \n@@ -106,7 +106,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             // trait-ref. Therefore, if we see any higher-ranke regions,\n             // we simply fallback to the most restrictive rule, which\n             // requires that `Pi: 'a` for all `i`.\n-            ty::TyProjection(ref data) => {\n+            ty::Projection(ref data) => {\n                 if !data.has_escaping_regions() {\n                     // best case: no escaping regions, so push the\n                     // projection and skip the subtree (thus generating no\n@@ -127,7 +127,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             // We assume that inference variables are fully resolved.\n             // So, if we encounter an inference variable, just record\n             // the unresolved variable as a component.\n-            ty::TyInfer(infer_ty) => {\n+            ty::Infer(infer_ty) => {\n                 out.push(Component::UnresolvedInferenceVariable(infer_ty));\n             }\n \n@@ -137,25 +137,25 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             // the type and then visits the types that are lexically\n             // contained within. (The comments refer to relevant rules\n             // from RFC1214.)\n-            ty::TyBool |            // OutlivesScalar\n-            ty::TyChar |            // OutlivesScalar\n-            ty::TyInt(..) |         // OutlivesScalar\n-            ty::TyUint(..) |        // OutlivesScalar\n-            ty::TyFloat(..) |       // OutlivesScalar\n-            ty::TyNever |           // ...\n-            ty::TyAdt(..) |         // OutlivesNominalType\n-            ty::TyAnon(..) |        // OutlivesNominalType (ish)\n-            ty::TyForeign(..) |     // OutlivesNominalType\n-            ty::TyStr |             // OutlivesScalar (ish)\n-            ty::TyArray(..) |       // ...\n-            ty::TySlice(..) |       // ...\n-            ty::TyRawPtr(..) |      // ...\n-            ty::TyRef(..) |         // OutlivesReference\n-            ty::TyTuple(..) |       // ...\n-            ty::TyFnDef(..) |       // OutlivesFunction (*)\n-            ty::TyFnPtr(_) |        // OutlivesFunction (*)\n-            ty::TyDynamic(..) |       // OutlivesObject, OutlivesFragment (*)\n-            ty::TyError => {\n+            ty::Bool |            // OutlivesScalar\n+            ty::Char |            // OutlivesScalar\n+            ty::Int(..) |         // OutlivesScalar\n+            ty::Uint(..) |        // OutlivesScalar\n+            ty::Float(..) |       // OutlivesScalar\n+            ty::Never |           // ...\n+            ty::Adt(..) |         // OutlivesNominalType\n+            ty::Anon(..) |        // OutlivesNominalType (ish)\n+            ty::Foreign(..) |     // OutlivesNominalType\n+            ty::Str |             // OutlivesScalar (ish)\n+            ty::Array(..) |       // ...\n+            ty::Slice(..) |       // ...\n+            ty::RawPtr(..) |      // ...\n+            ty::Ref(..) |         // OutlivesReference\n+            ty::Tuple(..) |       // ...\n+            ty::FnDef(..) |       // OutlivesFunction (*)\n+            ty::FnPtr(_) |        // OutlivesFunction (*)\n+            ty::Dynamic(..) |       // OutlivesObject, OutlivesFragment (*)\n+            ty::Error => {\n                 // (*) Bare functions and traits are both binders. In the\n                 // RFC, this means we would add the bound regions to the\n                 // \"bound regions list\".  In our representation, no such"}, {"sha": "d72e48c04fed4ed5ea0bb98e6c15ee05b6b0a2d0", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -316,7 +316,7 @@ impl<'tcx> Relate<'tcx> for ty::ExistentialTraitRef<'tcx> {\n }\n \n #[derive(Debug, Clone)]\n-struct GeneratorWitness<'tcx>(&'tcx ty::Slice<Ty<'tcx>>);\n+struct GeneratorWitness<'tcx>(&'tcx ty::List<Ty<'tcx>>);\n \n TupleStructTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for GeneratorWitness<'tcx> {\n@@ -363,50 +363,50 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n     let b_sty = &b.sty;\n     debug!(\"super_tys: a_sty={:?} b_sty={:?}\", a_sty, b_sty);\n     match (a_sty, b_sty) {\n-        (&ty::TyInfer(_), _) |\n-        (_, &ty::TyInfer(_)) =>\n+        (&ty::Infer(_), _) |\n+        (_, &ty::Infer(_)) =>\n         {\n             // The caller should handle these cases!\n             bug!(\"var types encountered in super_relate_tys\")\n         }\n \n-        (&ty::TyError, _) | (_, &ty::TyError) =>\n+        (&ty::Error, _) | (_, &ty::Error) =>\n         {\n             Ok(tcx.types.err)\n         }\n \n-        (&ty::TyNever, _) |\n-        (&ty::TyChar, _) |\n-        (&ty::TyBool, _) |\n-        (&ty::TyInt(_), _) |\n-        (&ty::TyUint(_), _) |\n-        (&ty::TyFloat(_), _) |\n-        (&ty::TyStr, _)\n+        (&ty::Never, _) |\n+        (&ty::Char, _) |\n+        (&ty::Bool, _) |\n+        (&ty::Int(_), _) |\n+        (&ty::Uint(_), _) |\n+        (&ty::Float(_), _) |\n+        (&ty::Str, _)\n             if a == b =>\n         {\n             Ok(a)\n         }\n \n-        (&ty::TyParam(ref a_p), &ty::TyParam(ref b_p))\n+        (&ty::Param(ref a_p), &ty::Param(ref b_p))\n             if a_p.idx == b_p.idx =>\n         {\n             Ok(a)\n         }\n \n-        (&ty::TyAdt(a_def, a_substs), &ty::TyAdt(b_def, b_substs))\n+        (&ty::Adt(a_def, a_substs), &ty::Adt(b_def, b_substs))\n             if a_def == b_def =>\n         {\n             let substs = relation.relate_item_substs(a_def.did, a_substs, b_substs)?;\n             Ok(tcx.mk_adt(a_def, substs))\n         }\n \n-        (&ty::TyForeign(a_id), &ty::TyForeign(b_id))\n+        (&ty::Foreign(a_id), &ty::Foreign(b_id))\n             if a_id == b_id =>\n         {\n             Ok(tcx.mk_foreign(a_id))\n         }\n \n-        (&ty::TyDynamic(ref a_obj, ref a_region), &ty::TyDynamic(ref b_obj, ref b_region)) => {\n+        (&ty::Dynamic(ref a_obj, ref a_region), &ty::Dynamic(ref b_obj, ref b_region)) => {\n             let region_bound = relation.with_cause(Cause::ExistentialRegionBound,\n                                                        |relation| {\n                                                            relation.relate_with_variance(\n@@ -417,18 +417,18 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             Ok(tcx.mk_dynamic(relation.relate(a_obj, b_obj)?, region_bound))\n         }\n \n-        (&ty::TyGenerator(a_id, a_substs, movability),\n-         &ty::TyGenerator(b_id, b_substs, _))\n+        (&ty::Generator(a_id, a_substs, movability),\n+         &ty::Generator(b_id, b_substs, _))\n             if a_id == b_id =>\n         {\n-            // All TyGenerator types with the same id represent\n+            // All Generator types with the same id represent\n             // the (anonymous) type of the same generator expression. So\n             // all of their regions should be equated.\n             let substs = relation.relate(&a_substs, &b_substs)?;\n             Ok(tcx.mk_generator(a_id, substs, movability))\n         }\n \n-        (&ty::TyGeneratorWitness(a_types), &ty::TyGeneratorWitness(b_types)) =>\n+        (&ty::GeneratorWitness(a_types), &ty::GeneratorWitness(b_types)) =>\n         {\n             // Wrap our types with a temporary GeneratorWitness struct\n             // inside the binder so we can related them\n@@ -439,24 +439,24 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             Ok(tcx.mk_generator_witness(types))\n         }\n \n-        (&ty::TyClosure(a_id, a_substs),\n-         &ty::TyClosure(b_id, b_substs))\n+        (&ty::Closure(a_id, a_substs),\n+         &ty::Closure(b_id, b_substs))\n             if a_id == b_id =>\n         {\n-            // All TyClosure types with the same id represent\n+            // All Closure types with the same id represent\n             // the (anonymous) type of the same closure expression. So\n             // all of their regions should be equated.\n             let substs = relation.relate(&a_substs, &b_substs)?;\n             Ok(tcx.mk_closure(a_id, substs))\n         }\n \n-        (&ty::TyRawPtr(ref a_mt), &ty::TyRawPtr(ref b_mt)) =>\n+        (&ty::RawPtr(ref a_mt), &ty::RawPtr(ref b_mt)) =>\n         {\n             let mt = relation.relate(a_mt, b_mt)?;\n             Ok(tcx.mk_ptr(mt))\n         }\n \n-        (&ty::TyRef(a_r, a_ty, a_mutbl), &ty::TyRef(b_r, b_ty, b_mutbl)) =>\n+        (&ty::Ref(a_r, a_ty, a_mutbl), &ty::Ref(b_r, b_ty, b_mutbl)) =>\n         {\n             let r = relation.relate_with_variance(ty::Contravariant, &a_r, &b_r)?;\n             let a_mt = ty::TypeAndMut { ty: a_ty, mutbl: a_mutbl };\n@@ -465,7 +465,7 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             Ok(tcx.mk_ref(r, mt))\n         }\n \n-        (&ty::TyArray(a_t, sz_a), &ty::TyArray(b_t, sz_b)) =>\n+        (&ty::Array(a_t, sz_a), &ty::Array(b_t, sz_b)) =>\n         {\n             let t = relation.relate(&a_t, &b_t)?;\n             assert_eq!(sz_a.ty, tcx.types.usize);\n@@ -514,26 +514,26 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             match (to_u64(sz_a), to_u64(sz_b)) {\n                 (Ok(sz_a_u64), Ok(sz_b_u64)) => {\n                     if sz_a_u64 == sz_b_u64 {\n-                        Ok(tcx.mk_ty(ty::TyArray(t, sz_a)))\n+                        Ok(tcx.mk_ty(ty::Array(t, sz_a)))\n                     } else {\n                         Err(TypeError::FixedArraySize(\n                             expected_found(relation, &sz_a_u64, &sz_b_u64)))\n                     }\n                 }\n-                // We reported an error or will ICE, so we can return TyError.\n+                // We reported an error or will ICE, so we can return Error.\n                 (Err(ErrorReported), _) | (_, Err(ErrorReported)) => {\n                     Ok(tcx.types.err)\n                 }\n             }\n         }\n \n-        (&ty::TySlice(a_t), &ty::TySlice(b_t)) =>\n+        (&ty::Slice(a_t), &ty::Slice(b_t)) =>\n         {\n             let t = relation.relate(&a_t, &b_t)?;\n             Ok(tcx.mk_slice(t))\n         }\n \n-        (&ty::TyTuple(as_), &ty::TyTuple(bs)) =>\n+        (&ty::Tuple(as_), &ty::Tuple(bs)) =>\n         {\n             if as_.len() == bs.len() {\n                 Ok(tcx.mk_tup(as_.iter().zip(bs).map(|(a, b)| relation.relate(a, b)))?)\n@@ -545,26 +545,26 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             }\n         }\n \n-        (&ty::TyFnDef(a_def_id, a_substs), &ty::TyFnDef(b_def_id, b_substs))\n+        (&ty::FnDef(a_def_id, a_substs), &ty::FnDef(b_def_id, b_substs))\n             if a_def_id == b_def_id =>\n         {\n             let substs = relation.relate_item_substs(a_def_id, a_substs, b_substs)?;\n             Ok(tcx.mk_fn_def(a_def_id, substs))\n         }\n \n-        (&ty::TyFnPtr(a_fty), &ty::TyFnPtr(b_fty)) =>\n+        (&ty::FnPtr(a_fty), &ty::FnPtr(b_fty)) =>\n         {\n             let fty = relation.relate(&a_fty, &b_fty)?;\n             Ok(tcx.mk_fn_ptr(fty))\n         }\n \n-        (&ty::TyProjection(ref a_data), &ty::TyProjection(ref b_data)) =>\n+        (&ty::Projection(ref a_data), &ty::Projection(ref b_data)) =>\n         {\n             let projection_ty = relation.relate(a_data, b_data)?;\n             Ok(tcx.mk_projection(projection_ty.item_def_id, projection_ty.substs))\n         }\n \n-        (&ty::TyAnon(a_def_id, a_substs), &ty::TyAnon(b_def_id, b_substs))\n+        (&ty::Anon(a_def_id, a_substs), &ty::Anon(b_def_id, b_substs))\n             if a_def_id == b_def_id =>\n         {\n             let substs = relate_substs(relation, None, a_substs, b_substs)?;\n@@ -578,7 +578,7 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n     }\n }\n \n-impl<'tcx> Relate<'tcx> for &'tcx ty::Slice<ty::ExistentialPredicate<'tcx>> {\n+impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n     fn relate<'a, 'gcx, R>(relation: &mut R,\n                            a: &Self,\n                            b: &Self)"}, {"sha": "09ec6c79139415aae83a84ed7d74e95325cf37fb", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -735,7 +735,7 @@ BraceStructTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for ty::ParamEnv<'tcx> { reveal, caller_bounds }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<ty::ExistentialPredicate<'tcx>> {\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let v = self.iter().map(|p| p.fold_with(folder)).collect::<AccumulateVec<[_; 8]>>();\n         folder.tcx().intern_existential_predicates(&v)\n@@ -754,7 +754,7 @@ EnumTypeFoldableImpl! {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<Ty<'tcx>> {\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<Ty<'tcx>> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let v = self.iter().map(|t| t.fold_with(folder)).collect::<AccumulateVec<[_; 8]>>();\n         folder.tcx().intern_type_list(&v)\n@@ -836,33 +836,33 @@ impl<'tcx> TypeFoldable<'tcx> for interpret::GlobalId<'tcx> {\n impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let sty = match self.sty {\n-            ty::TyRawPtr(tm) => ty::TyRawPtr(tm.fold_with(folder)),\n-            ty::TyArray(typ, sz) => ty::TyArray(typ.fold_with(folder), sz.fold_with(folder)),\n-            ty::TySlice(typ) => ty::TySlice(typ.fold_with(folder)),\n-            ty::TyAdt(tid, substs) => ty::TyAdt(tid, substs.fold_with(folder)),\n-            ty::TyDynamic(ref trait_ty, ref region) =>\n-                ty::TyDynamic(trait_ty.fold_with(folder), region.fold_with(folder)),\n-            ty::TyTuple(ts) => ty::TyTuple(ts.fold_with(folder)),\n-            ty::TyFnDef(def_id, substs) => {\n-                ty::TyFnDef(def_id, substs.fold_with(folder))\n+            ty::RawPtr(tm) => ty::RawPtr(tm.fold_with(folder)),\n+            ty::Array(typ, sz) => ty::Array(typ.fold_with(folder), sz.fold_with(folder)),\n+            ty::Slice(typ) => ty::Slice(typ.fold_with(folder)),\n+            ty::Adt(tid, substs) => ty::Adt(tid, substs.fold_with(folder)),\n+            ty::Dynamic(ref trait_ty, ref region) =>\n+                ty::Dynamic(trait_ty.fold_with(folder), region.fold_with(folder)),\n+            ty::Tuple(ts) => ty::Tuple(ts.fold_with(folder)),\n+            ty::FnDef(def_id, substs) => {\n+                ty::FnDef(def_id, substs.fold_with(folder))\n             }\n-            ty::TyFnPtr(f) => ty::TyFnPtr(f.fold_with(folder)),\n-            ty::TyRef(ref r, ty, mutbl) => {\n-                ty::TyRef(r.fold_with(folder), ty.fold_with(folder), mutbl)\n+            ty::FnPtr(f) => ty::FnPtr(f.fold_with(folder)),\n+            ty::Ref(ref r, ty, mutbl) => {\n+                ty::Ref(r.fold_with(folder), ty.fold_with(folder), mutbl)\n             }\n-            ty::TyGenerator(did, substs, movability) => {\n-                ty::TyGenerator(\n+            ty::Generator(did, substs, movability) => {\n+                ty::Generator(\n                     did,\n                     substs.fold_with(folder),\n                     movability)\n             }\n-            ty::TyGeneratorWitness(types) => ty::TyGeneratorWitness(types.fold_with(folder)),\n-            ty::TyClosure(did, substs) => ty::TyClosure(did, substs.fold_with(folder)),\n-            ty::TyProjection(ref data) => ty::TyProjection(data.fold_with(folder)),\n-            ty::TyAnon(did, substs) => ty::TyAnon(did, substs.fold_with(folder)),\n-            ty::TyBool | ty::TyChar | ty::TyStr | ty::TyInt(_) |\n-            ty::TyUint(_) | ty::TyFloat(_) | ty::TyError | ty::TyInfer(_) |\n-            ty::TyParam(..) | ty::TyNever | ty::TyForeign(..) => return self\n+            ty::GeneratorWitness(types) => ty::GeneratorWitness(types.fold_with(folder)),\n+            ty::Closure(did, substs) => ty::Closure(did, substs.fold_with(folder)),\n+            ty::Projection(ref data) => ty::Projection(data.fold_with(folder)),\n+            ty::Anon(did, substs) => ty::Anon(did, substs.fold_with(folder)),\n+            ty::Bool | ty::Char | ty::Str | ty::Int(_) |\n+            ty::Uint(_) | ty::Float(_) | ty::Error | ty::Infer(_) |\n+            ty::Param(..) | ty::Never | ty::Foreign(..) => return self\n         };\n \n         if self.sty == sty {\n@@ -878,26 +878,26 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         match self.sty {\n-            ty::TyRawPtr(ref tm) => tm.visit_with(visitor),\n-            ty::TyArray(typ, sz) => typ.visit_with(visitor) || sz.visit_with(visitor),\n-            ty::TySlice(typ) => typ.visit_with(visitor),\n-            ty::TyAdt(_, substs) => substs.visit_with(visitor),\n-            ty::TyDynamic(ref trait_ty, ref reg) =>\n+            ty::RawPtr(ref tm) => tm.visit_with(visitor),\n+            ty::Array(typ, sz) => typ.visit_with(visitor) || sz.visit_with(visitor),\n+            ty::Slice(typ) => typ.visit_with(visitor),\n+            ty::Adt(_, substs) => substs.visit_with(visitor),\n+            ty::Dynamic(ref trait_ty, ref reg) =>\n                 trait_ty.visit_with(visitor) || reg.visit_with(visitor),\n-            ty::TyTuple(ts) => ts.visit_with(visitor),\n-            ty::TyFnDef(_, substs) => substs.visit_with(visitor),\n-            ty::TyFnPtr(ref f) => f.visit_with(visitor),\n-            ty::TyRef(r, ty, _) => r.visit_with(visitor) || ty.visit_with(visitor),\n-            ty::TyGenerator(_did, ref substs, _) => {\n+            ty::Tuple(ts) => ts.visit_with(visitor),\n+            ty::FnDef(_, substs) => substs.visit_with(visitor),\n+            ty::FnPtr(ref f) => f.visit_with(visitor),\n+            ty::Ref(r, ty, _) => r.visit_with(visitor) || ty.visit_with(visitor),\n+            ty::Generator(_did, ref substs, _) => {\n                 substs.visit_with(visitor)\n             }\n-            ty::TyGeneratorWitness(ref types) => types.visit_with(visitor),\n-            ty::TyClosure(_did, ref substs) => substs.visit_with(visitor),\n-            ty::TyProjection(ref data) => data.visit_with(visitor),\n-            ty::TyAnon(_, ref substs) => substs.visit_with(visitor),\n-            ty::TyBool | ty::TyChar | ty::TyStr | ty::TyInt(_) |\n-            ty::TyUint(_) | ty::TyFloat(_) | ty::TyError | ty::TyInfer(_) |\n-            ty::TyParam(..) | ty::TyNever | ty::TyForeign(..) => false,\n+            ty::GeneratorWitness(ref types) => types.visit_with(visitor),\n+            ty::Closure(_did, ref substs) => substs.visit_with(visitor),\n+            ty::Projection(ref data) => data.visit_with(visitor),\n+            ty::Anon(_, ref substs) => substs.visit_with(visitor),\n+            ty::Bool | ty::Char | ty::Str | ty::Int(_) |\n+            ty::Uint(_) | ty::Float(_) | ty::Error | ty::Infer(_) |\n+            ty::Param(..) | ty::Never | ty::Foreign(..) => false,\n         }\n     }\n \n@@ -1010,7 +1010,7 @@ BraceStructTypeFoldableImpl! {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<ty::Predicate<'tcx>> {\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Predicate<'tcx>> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let v = self.iter().map(|p| p.fold_with(folder)).collect::<AccumulateVec<[_; 8]>>();\n         folder.tcx().intern_predicates(&v)"}, {"sha": "7c7ee9b330ecccce65f1e55853b91c57f33cb5d5", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 132, "deletions": 132, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! This module contains TypeVariants and its major components\n+//! This module contains TyKind and its major components\n \n use hir::def_id::DefId;\n \n@@ -18,7 +18,7 @@ use polonius_engine::Atom;\n use rustc_data_structures::indexed_vec::Idx;\n use ty::subst::{Substs, Subst, Kind, UnpackedKind};\n use ty::{self, AdtDef, TypeFlags, Ty, TyCtxt, TypeFoldable};\n-use ty::{Slice, TyS, ParamEnvAnd, ParamEnv};\n+use ty::{List, TyS, ParamEnvAnd, ParamEnv};\n use util::captures::Captures;\n use mir::interpret::{Scalar, Pointer};\n \n@@ -33,7 +33,7 @@ use serialize;\n use hir;\n \n use self::InferTy::*;\n-use self::TypeVariants::*;\n+use self::TyKind::*;\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct TypeAndMut<'tcx> {\n@@ -82,98 +82,98 @@ impl BoundRegion {\n /// NB: If you change this, you'll probably want to change the corresponding\n /// AST structure in libsyntax/ast.rs as well.\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n-pub enum TypeVariants<'tcx> {\n+pub enum TyKind<'tcx> {\n     /// The primitive boolean type. Written as `bool`.\n-    TyBool,\n+    Bool,\n \n     /// The primitive character type; holds a Unicode scalar value\n     /// (a non-surrogate code point).  Written as `char`.\n-    TyChar,\n+    Char,\n \n     /// A primitive signed integer type. For example, `i32`.\n-    TyInt(ast::IntTy),\n+    Int(ast::IntTy),\n \n     /// A primitive unsigned integer type. For example, `u32`.\n-    TyUint(ast::UintTy),\n+    Uint(ast::UintTy),\n \n     /// A primitive floating-point type. For example, `f64`.\n-    TyFloat(ast::FloatTy),\n+    Float(ast::FloatTy),\n \n     /// Structures, enumerations and unions.\n     ///\n-    /// Substs here, possibly against intuition, *may* contain `TyParam`s.\n+    /// Substs here, possibly against intuition, *may* contain `Param`s.\n     /// That is, even after substitution it is possible that there are type\n-    /// variables. This happens when the `TyAdt` corresponds to an ADT\n+    /// variables. This happens when the `Adt` corresponds to an ADT\n     /// definition and not a concrete use of it.\n-    TyAdt(&'tcx AdtDef, &'tcx Substs<'tcx>),\n+    Adt(&'tcx AdtDef, &'tcx Substs<'tcx>),\n \n-    TyForeign(DefId),\n+    Foreign(DefId),\n \n     /// The pointee of a string slice. Written as `str`.\n-    TyStr,\n+    Str,\n \n     /// An array with the given length. Written as `[T; n]`.\n-    TyArray(Ty<'tcx>, &'tcx ty::Const<'tcx>),\n+    Array(Ty<'tcx>, &'tcx ty::Const<'tcx>),\n \n     /// The pointee of an array slice.  Written as `[T]`.\n-    TySlice(Ty<'tcx>),\n+    Slice(Ty<'tcx>),\n \n     /// A raw pointer. Written as `*mut T` or `*const T`\n-    TyRawPtr(TypeAndMut<'tcx>),\n+    RawPtr(TypeAndMut<'tcx>),\n \n     /// A reference; a pointer with an associated lifetime. Written as\n     /// `&'a mut T` or `&'a T`.\n-    TyRef(Region<'tcx>, Ty<'tcx>, hir::Mutability),\n+    Ref(Region<'tcx>, Ty<'tcx>, hir::Mutability),\n \n     /// The anonymous type of a function declaration/definition. Each\n     /// function has a unique type.\n-    TyFnDef(DefId, &'tcx Substs<'tcx>),\n+    FnDef(DefId, &'tcx Substs<'tcx>),\n \n     /// A pointer to a function.  Written as `fn() -> i32`.\n-    TyFnPtr(PolyFnSig<'tcx>),\n+    FnPtr(PolyFnSig<'tcx>),\n \n     /// A trait, defined with `trait`.\n-    TyDynamic(Binder<&'tcx Slice<ExistentialPredicate<'tcx>>>, ty::Region<'tcx>),\n+    Dynamic(Binder<&'tcx List<ExistentialPredicate<'tcx>>>, ty::Region<'tcx>),\n \n     /// The anonymous type of a closure. Used to represent the type of\n     /// `|a| a`.\n-    TyClosure(DefId, ClosureSubsts<'tcx>),\n+    Closure(DefId, ClosureSubsts<'tcx>),\n \n     /// The anonymous type of a generator. Used to represent the type of\n     /// `|a| yield a`.\n-    TyGenerator(DefId, GeneratorSubsts<'tcx>, hir::GeneratorMovability),\n+    Generator(DefId, GeneratorSubsts<'tcx>, hir::GeneratorMovability),\n \n     /// A type representin the types stored inside a generator.\n     /// This should only appear in GeneratorInteriors.\n-    TyGeneratorWitness(Binder<&'tcx Slice<Ty<'tcx>>>),\n+    GeneratorWitness(Binder<&'tcx List<Ty<'tcx>>>),\n \n     /// The never type `!`\n-    TyNever,\n+    Never,\n \n     /// A tuple type.  For example, `(i32, bool)`.\n-    TyTuple(&'tcx Slice<Ty<'tcx>>),\n+    Tuple(&'tcx List<Ty<'tcx>>),\n \n     /// The projection of an associated type.  For example,\n     /// `<T as Trait<..>>::N`.\n-    TyProjection(ProjectionTy<'tcx>),\n+    Projection(ProjectionTy<'tcx>),\n \n     /// Anonymized (`impl Trait`) type found in a return type.\n     /// The DefId comes either from\n     /// * the `impl Trait` ast::Ty node,\n     /// * or the `existential type` declaration\n     /// The substitutions are for the generics of the function in question.\n     /// After typeck, the concrete type can be found in the `types` map.\n-    TyAnon(DefId, &'tcx Substs<'tcx>),\n+    Anon(DefId, &'tcx Substs<'tcx>),\n \n     /// A type parameter; for example, `T` in `fn f<T>(x: T) {}\n-    TyParam(ParamTy),\n+    Param(ParamTy),\n \n     /// A type variable used during type-checking.\n-    TyInfer(InferTy),\n+    Infer(InferTy),\n \n     /// A placeholder for a type which could not be computed; this is\n     /// propagated to avoid useless error messages.\n-    TyError,\n+    Error,\n }\n \n /// A closure can be modeled as a struct that looks like:\n@@ -348,7 +348,7 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     /// If you have an inference context, use `infcx.closure_sig()`.\n     pub fn closure_sig(self, def_id: DefId, tcx: TyCtxt<'_, 'tcx, 'tcx>) -> ty::PolyFnSig<'tcx> {\n         match self.closure_sig_ty(def_id, tcx).sty {\n-            ty::TyFnPtr(sig) => sig,\n+            ty::FnPtr(sig) => sig,\n             ref t => bug!(\"closure_sig_ty is not a fn-ptr: {:?}\", t),\n         }\n     }\n@@ -536,9 +536,9 @@ impl<'a, 'gcx, 'tcx> Binder<ExistentialPredicate<'tcx>> {\n     }\n }\n \n-impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Slice<ExistentialPredicate<'tcx>> {}\n+impl<'tcx> serialize::UseSpecializedDecodable for &'tcx List<ExistentialPredicate<'tcx>> {}\n \n-impl<'tcx> Slice<ExistentialPredicate<'tcx>> {\n+impl<'tcx> List<ExistentialPredicate<'tcx>> {\n     pub fn principal(&self) -> Option<ExistentialTraitRef<'tcx>> {\n         match self.get(0) {\n             Some(&ExistentialPredicate::Trait(tr)) => Some(tr),\n@@ -568,7 +568,7 @@ impl<'tcx> Slice<ExistentialPredicate<'tcx>> {\n     }\n }\n \n-impl<'tcx> Binder<&'tcx Slice<ExistentialPredicate<'tcx>>> {\n+impl<'tcx> Binder<&'tcx List<ExistentialPredicate<'tcx>>> {\n     pub fn principal(&self) -> Option<PolyExistentialTraitRef<'tcx>> {\n         self.skip_binder().principal().map(Binder::bind)\n     }\n@@ -918,7 +918,7 @@ impl<'tcx> PolyGenSig<'tcx> {\n /// - `variadic` indicates whether this is a variadic function. (only true for foreign fns)\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct FnSig<'tcx> {\n-    pub inputs_and_output: &'tcx Slice<Ty<'tcx>>,\n+    pub inputs_and_output: &'tcx List<Ty<'tcx>>,\n     pub variadic: bool,\n     pub unsafety: hir::Unsafety,\n     pub abi: abi::Abi,\n@@ -943,7 +943,7 @@ impl<'tcx> PolyFnSig<'tcx> {\n     pub fn input(&self, index: usize) -> ty::Binder<Ty<'tcx>> {\n         self.map_bound_ref(|fn_sig| fn_sig.inputs()[index])\n     }\n-    pub fn inputs_and_output(&self) -> ty::Binder<&'tcx Slice<Ty<'tcx>>> {\n+    pub fn inputs_and_output(&self) -> ty::Binder<&'tcx List<Ty<'tcx>>> {\n         self.map_bound_ref(|fn_sig| fn_sig.inputs_and_output)\n     }\n     pub fn output(&self) -> ty::Binder<Ty<'tcx>> {\n@@ -1058,7 +1058,7 @@ pub type Region<'tcx> = &'tcx RegionKind;\n /// the likes of `liberate_late_bound_regions`. The distinction exists\n /// because higher-ranked lifetimes aren't supported in all places. See [1][2].\n ///\n-/// Unlike TyParam-s, bound regions are not supposed to exist \"in the wild\"\n+/// Unlike Param-s, bound regions are not supposed to exist \"in the wild\"\n /// outside their binder, e.g. in types passed to type inference, and\n /// should first be substituted (by skolemized regions, free regions,\n /// or region variables).\n@@ -1469,67 +1469,67 @@ impl RegionKind {\n impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     pub fn is_nil(&self) -> bool {\n         match self.sty {\n-            TyTuple(ref tys) => tys.is_empty(),\n+            Tuple(ref tys) => tys.is_empty(),\n             _ => false,\n         }\n     }\n \n     pub fn is_never(&self) -> bool {\n         match self.sty {\n-            TyNever => true,\n+            Never => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_primitive(&self) -> bool {\n         match self.sty {\n-            TyBool | TyChar | TyInt(_) | TyUint(_) | TyFloat(_) => true,\n+            Bool | Char | Int(_) | Uint(_) | Float(_) => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_ty_var(&self) -> bool {\n         match self.sty {\n-            TyInfer(TyVar(_)) => true,\n+            Infer(TyVar(_)) => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_ty_infer(&self) -> bool {\n         match self.sty {\n-            TyInfer(_) => true,\n+            Infer(_) => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_phantom_data(&self) -> bool {\n-        if let TyAdt(def, _) = self.sty {\n+        if let Adt(def, _) = self.sty {\n             def.is_phantom_data()\n         } else {\n             false\n         }\n     }\n \n-    pub fn is_bool(&self) -> bool { self.sty == TyBool }\n+    pub fn is_bool(&self) -> bool { self.sty == Bool }\n \n     pub fn is_param(&self, index: u32) -> bool {\n         match self.sty {\n-            ty::TyParam(ref data) => data.idx == index,\n+            ty::Param(ref data) => data.idx == index,\n             _ => false,\n         }\n     }\n \n     pub fn is_self(&self) -> bool {\n         match self.sty {\n-            TyParam(ref p) => p.is_self(),\n+            Param(ref p) => p.is_self(),\n             _ => false,\n         }\n     }\n \n     pub fn is_slice(&self) -> bool {\n         match self.sty {\n-            TyRawPtr(TypeAndMut { ty, .. }) | TyRef(_, ty, _) => match ty.sty {\n-                TySlice(_) | TyStr => true,\n+            RawPtr(TypeAndMut { ty, .. }) | Ref(_, ty, _) => match ty.sty {\n+                Slice(_) | Str => true,\n                 _ => false,\n             },\n             _ => false\n@@ -1539,22 +1539,22 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     #[inline]\n     pub fn is_simd(&self) -> bool {\n         match self.sty {\n-            TyAdt(def, _) => def.repr.simd(),\n+            Adt(def, _) => def.repr.simd(),\n             _ => false,\n         }\n     }\n \n     pub fn sequence_element_type(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         match self.sty {\n-            TyArray(ty, _) | TySlice(ty) => ty,\n-            TyStr => tcx.mk_mach_uint(ast::UintTy::U8),\n+            Array(ty, _) | Slice(ty) => ty,\n+            Str => tcx.mk_mach_uint(ast::UintTy::U8),\n             _ => bug!(\"sequence_element_type called on non-sequence value: {}\", self),\n         }\n     }\n \n     pub fn simd_type(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         match self.sty {\n-            TyAdt(def, substs) => {\n+            Adt(def, substs) => {\n                 def.non_enum_variant().fields[0].ty(tcx, substs)\n             }\n             _ => bug!(\"simd_type called on invalid type\")\n@@ -1563,79 +1563,79 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn simd_size(&self, _cx: TyCtxt) -> usize {\n         match self.sty {\n-            TyAdt(def, _) => def.non_enum_variant().fields.len(),\n+            Adt(def, _) => def.non_enum_variant().fields.len(),\n             _ => bug!(\"simd_size called on invalid type\")\n         }\n     }\n \n     pub fn is_region_ptr(&self) -> bool {\n         match self.sty {\n-            TyRef(..) => true,\n+            Ref(..) => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_mutable_pointer(&self) -> bool {\n         match self.sty {\n-            TyRawPtr(TypeAndMut { mutbl: hir::Mutability::MutMutable, .. }) |\n-            TyRef(_, _, hir::Mutability::MutMutable) => true,\n+            RawPtr(TypeAndMut { mutbl: hir::Mutability::MutMutable, .. }) |\n+            Ref(_, _, hir::Mutability::MutMutable) => true,\n             _ => false\n         }\n     }\n \n     pub fn is_unsafe_ptr(&self) -> bool {\n         match self.sty {\n-            TyRawPtr(_) => return true,\n+            RawPtr(_) => return true,\n             _ => return false,\n         }\n     }\n \n     pub fn is_box(&self) -> bool {\n         match self.sty {\n-            TyAdt(def, _) => def.is_box(),\n+            Adt(def, _) => def.is_box(),\n             _ => false,\n         }\n     }\n \n     /// panics if called on any type other than `Box<T>`\n     pub fn boxed_ty(&self) -> Ty<'tcx> {\n         match self.sty {\n-            TyAdt(def, substs) if def.is_box() => substs.type_at(0),\n+            Adt(def, substs) if def.is_box() => substs.type_at(0),\n             _ => bug!(\"`boxed_ty` is called on non-box type {:?}\", self),\n         }\n     }\n \n     /// A scalar type is one that denotes an atomic datum, with no sub-components.\n-    /// (A TyRawPtr is scalar because it represents a non-managed pointer, so its\n+    /// (A RawPtr is scalar because it represents a non-managed pointer, so its\n     /// contents are abstract to rustc.)\n     pub fn is_scalar(&self) -> bool {\n         match self.sty {\n-            TyBool | TyChar | TyInt(_) | TyFloat(_) | TyUint(_) |\n-            TyInfer(IntVar(_)) | TyInfer(FloatVar(_)) |\n-            TyFnDef(..) | TyFnPtr(_) | TyRawPtr(_) => true,\n+            Bool | Char | Int(_) | Float(_) | Uint(_) |\n+            Infer(IntVar(_)) | Infer(FloatVar(_)) |\n+            FnDef(..) | FnPtr(_) | RawPtr(_) => true,\n             _ => false\n         }\n     }\n \n     /// Returns true if this type is a floating point type and false otherwise.\n     pub fn is_floating_point(&self) -> bool {\n         match self.sty {\n-            TyFloat(_) |\n-            TyInfer(FloatVar(_)) => true,\n+            Float(_) |\n+            Infer(FloatVar(_)) => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_trait(&self) -> bool {\n         match self.sty {\n-            TyDynamic(..) => true,\n+            Dynamic(..) => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_enum(&self) -> bool {\n         match self.sty {\n-            TyAdt(adt_def, _) => {\n+            Adt(adt_def, _) => {\n                 adt_def.is_enum()\n             }\n             _ => false,\n@@ -1644,51 +1644,51 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn is_closure(&self) -> bool {\n         match self.sty {\n-            TyClosure(..) => true,\n+            Closure(..) => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_generator(&self) -> bool {\n         match self.sty {\n-            TyGenerator(..) => true,\n+            Generator(..) => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_integral(&self) -> bool {\n         match self.sty {\n-            TyInfer(IntVar(_)) | TyInt(_) | TyUint(_) => true,\n+            Infer(IntVar(_)) | Int(_) | Uint(_) => true,\n             _ => false\n         }\n     }\n \n     pub fn is_fresh_ty(&self) -> bool {\n         match self.sty {\n-            TyInfer(FreshTy(_)) => true,\n+            Infer(FreshTy(_)) => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_fresh(&self) -> bool {\n         match self.sty {\n-            TyInfer(FreshTy(_)) => true,\n-            TyInfer(FreshIntTy(_)) => true,\n-            TyInfer(FreshFloatTy(_)) => true,\n+            Infer(FreshTy(_)) => true,\n+            Infer(FreshIntTy(_)) => true,\n+            Infer(FreshFloatTy(_)) => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_char(&self) -> bool {\n         match self.sty {\n-            TyChar => true,\n+            Char => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_fp(&self) -> bool {\n         match self.sty {\n-            TyInfer(FloatVar(_)) | TyFloat(_) => true,\n+            Infer(FloatVar(_)) | Float(_) => true,\n             _ => false\n         }\n     }\n@@ -1699,22 +1699,22 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn is_signed(&self) -> bool {\n         match self.sty {\n-            TyInt(_) => true,\n+            Int(_) => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_machine(&self) -> bool {\n         match self.sty {\n-            TyInt(ast::IntTy::Isize) | TyUint(ast::UintTy::Usize) => false,\n-            TyInt(..) | TyUint(..) | TyFloat(..) => true,\n+            Int(ast::IntTy::Isize) | Uint(ast::UintTy::Usize) => false,\n+            Int(..) | Uint(..) | Float(..) => true,\n             _ => false,\n         }\n     }\n \n     pub fn has_concrete_skeleton(&self) -> bool {\n         match self.sty {\n-            TyParam(_) | TyInfer(_) | TyError => false,\n+            Param(_) | Infer(_) | Error => false,\n             _ => true,\n         }\n     }\n@@ -1725,53 +1725,53 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     /// Some types---notably unsafe ptrs---can only be dereferenced explicitly.\n     pub fn builtin_deref(&self, explicit: bool) -> Option<TypeAndMut<'tcx>> {\n         match self.sty {\n-            TyAdt(def, _) if def.is_box() => {\n+            Adt(def, _) if def.is_box() => {\n                 Some(TypeAndMut {\n                     ty: self.boxed_ty(),\n                     mutbl: hir::MutImmutable,\n                 })\n             },\n-            TyRef(_, ty, mutbl) => Some(TypeAndMut { ty, mutbl }),\n-            TyRawPtr(mt) if explicit => Some(mt),\n+            Ref(_, ty, mutbl) => Some(TypeAndMut { ty, mutbl }),\n+            RawPtr(mt) if explicit => Some(mt),\n             _ => None,\n         }\n     }\n \n     /// Returns the type of `ty[i]`.\n     pub fn builtin_index(&self) -> Option<Ty<'tcx>> {\n         match self.sty {\n-            TyArray(ty, _) | TySlice(ty) => Some(ty),\n+            Array(ty, _) | Slice(ty) => Some(ty),\n             _ => None,\n         }\n     }\n \n     pub fn fn_sig(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> PolyFnSig<'tcx> {\n         match self.sty {\n-            TyFnDef(def_id, substs) => {\n+            FnDef(def_id, substs) => {\n                 tcx.fn_sig(def_id).subst(tcx, substs)\n             }\n-            TyFnPtr(f) => f,\n+            FnPtr(f) => f,\n             _ => bug!(\"Ty::fn_sig() called on non-fn type: {:?}\", self)\n         }\n     }\n \n     pub fn is_fn(&self) -> bool {\n         match self.sty {\n-            TyFnDef(..) | TyFnPtr(_) => true,\n+            FnDef(..) | FnPtr(_) => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_impl_trait(&self) -> bool {\n         match self.sty {\n-            TyAnon(..) => true,\n+            Anon(..) => true,\n             _ => false,\n         }\n     }\n \n     pub fn ty_adt_def(&self) -> Option<&'tcx AdtDef> {\n         match self.sty {\n-            TyAdt(adt, _) => Some(adt),\n+            Adt(adt, _) => Some(adt),\n             _ => None,\n         }\n     }\n@@ -1781,44 +1781,44 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     /// ignores late-bound regions binders.\n     pub fn regions(&self) -> Vec<ty::Region<'tcx>> {\n         match self.sty {\n-            TyRef(region, _, _) => {\n+            Ref(region, _, _) => {\n                 vec![region]\n             }\n-            TyDynamic(ref obj, region) => {\n+            Dynamic(ref obj, region) => {\n                 let mut v = vec![region];\n                 if let Some(p) = obj.principal() {\n                     v.extend(p.skip_binder().substs.regions());\n                 }\n                 v\n             }\n-            TyAdt(_, substs) | TyAnon(_, substs) => {\n+            Adt(_, substs) | Anon(_, substs) => {\n                 substs.regions().collect()\n             }\n-            TyClosure(_, ClosureSubsts { ref substs }) |\n-            TyGenerator(_, GeneratorSubsts { ref substs }, _) => {\n+            Closure(_, ClosureSubsts { ref substs }) |\n+            Generator(_, GeneratorSubsts { ref substs }, _) => {\n                 substs.regions().collect()\n             }\n-            TyProjection(ref data) => {\n+            Projection(ref data) => {\n                 data.substs.regions().collect()\n             }\n-            TyFnDef(..) |\n-            TyFnPtr(_) |\n-            TyGeneratorWitness(..) |\n-            TyBool |\n-            TyChar |\n-            TyInt(_) |\n-            TyUint(_) |\n-            TyFloat(_) |\n-            TyStr |\n-            TyArray(..) |\n-            TySlice(_) |\n-            TyRawPtr(_) |\n-            TyNever |\n-            TyTuple(..) |\n-            TyForeign(..) |\n-            TyParam(_) |\n-            TyInfer(_) |\n-            TyError => {\n+            FnDef(..) |\n+            FnPtr(_) |\n+            GeneratorWitness(..) |\n+            Bool |\n+            Char |\n+            Int(_) |\n+            Uint(_) |\n+            Float(_) |\n+            Str |\n+            Array(..) |\n+            Slice(_) |\n+            RawPtr(_) |\n+            Never |\n+            Tuple(..) |\n+            Foreign(..) |\n+            Param(_) |\n+            Infer(_) |\n+            Error => {\n                 vec![]\n             }\n         }\n@@ -1838,16 +1838,16 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     /// is complete, that type variable will be unified.\n     pub fn to_opt_closure_kind(&self) -> Option<ty::ClosureKind> {\n         match self.sty {\n-            TyInt(int_ty) => match int_ty {\n+            Int(int_ty) => match int_ty {\n                 ast::IntTy::I8 => Some(ty::ClosureKind::Fn),\n                 ast::IntTy::I16 => Some(ty::ClosureKind::FnMut),\n                 ast::IntTy::I32 => Some(ty::ClosureKind::FnOnce),\n                 _ => bug!(\"cannot convert type `{:?}` to a closure kind\", self),\n             },\n \n-            TyInfer(_) => None,\n+            Infer(_) => None,\n \n-            TyError => Some(ty::ClosureKind::Fn),\n+            Error => Some(ty::ClosureKind::Fn),\n \n             _ => bug!(\"cannot convert type `{:?}` to a closure kind\", self),\n         }\n@@ -1859,31 +1859,31 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     /// `false` means nothing -- could be sized, might not be.\n     pub fn is_trivially_sized(&self, tcx: TyCtxt<'_, '_, 'tcx>) -> bool {\n         match self.sty {\n-            ty::TyInfer(ty::IntVar(_)) | ty::TyInfer(ty::FloatVar(_)) |\n-            ty::TyUint(_) | ty::TyInt(_) | ty::TyBool | ty::TyFloat(_) |\n-            ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyRawPtr(..) |\n-            ty::TyChar | ty::TyRef(..) | ty::TyGenerator(..) |\n-            ty::TyGeneratorWitness(..) | ty::TyArray(..) | ty::TyClosure(..) |\n-            ty::TyNever | ty::TyError =>\n+            ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_)) |\n+            ty::Uint(_) | ty::Int(_) | ty::Bool | ty::Float(_) |\n+            ty::FnDef(..) | ty::FnPtr(_) | ty::RawPtr(..) |\n+            ty::Char | ty::Ref(..) | ty::Generator(..) |\n+            ty::GeneratorWitness(..) | ty::Array(..) | ty::Closure(..) |\n+            ty::Never | ty::Error =>\n                 true,\n \n-            ty::TyStr | ty::TySlice(_) | ty::TyDynamic(..) | ty::TyForeign(..) =>\n+            ty::Str | ty::Slice(_) | ty::Dynamic(..) | ty::Foreign(..) =>\n                 false,\n \n-            ty::TyTuple(tys) =>\n+            ty::Tuple(tys) =>\n                 tys.iter().all(|ty| ty.is_trivially_sized(tcx)),\n \n-            ty::TyAdt(def, _substs) =>\n+            ty::Adt(def, _substs) =>\n                 def.sized_constraint(tcx).is_empty(),\n \n-            ty::TyProjection(_) | ty::TyParam(_) | ty::TyAnon(..) => false,\n+            ty::Projection(_) | ty::Param(_) | ty::Anon(..) => false,\n \n-            ty::TyInfer(ty::TyVar(_)) => false,\n+            ty::Infer(ty::TyVar(_)) => false,\n \n-            ty::TyInfer(ty::CanonicalTy(_)) |\n-            ty::TyInfer(ty::FreshTy(_)) |\n-            ty::TyInfer(ty::FreshIntTy(_)) |\n-            ty::TyInfer(ty::FreshFloatTy(_)) =>\n+            ty::Infer(ty::CanonicalTy(_)) |\n+            ty::Infer(ty::FreshTy(_)) |\n+            ty::Infer(ty::FreshIntTy(_)) |\n+            ty::Infer(ty::FreshFloatTy(_)) =>\n                 bug!(\"is_trivially_sized applied to unexpected type: {:?}\", self),\n         }\n     }"}, {"sha": "0e85c68b8b1deeb0732bdb7f259198a0ac9cd57c", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -11,7 +11,7 @@\n // Type substitutions.\n \n use hir::def_id::DefId;\n-use ty::{self, Lift, Slice, Ty, TyCtxt};\n+use ty::{self, Lift, List, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n use serialize::{self, Encodable, Encoder, Decodable, Decoder};\n@@ -177,7 +177,7 @@ impl<'tcx> Decodable for Kind<'tcx> {\n }\n \n /// A substitution mapping generic parameters to new values.\n-pub type Substs<'tcx> = Slice<Kind<'tcx>>;\n+pub type Substs<'tcx> = List<Kind<'tcx>>;\n \n impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     /// Creates a Substs that maps each generic parameter to itself.\n@@ -449,7 +449,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n         self.ty_stack_depth += 1;\n \n         let t1 = match t.sty {\n-            ty::TyParam(p) => {\n+            ty::Param(p) => {\n                 self.ty_for_param(p, t)\n             }\n             _ => {"}, {"sha": "938cdf3048b1c47d9d87750919e0a0464844df54", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -19,7 +19,7 @@ use traits::{self, ObligationCause};\n use ty::{self, Ty, TyCtxt, GenericParamDefKind, TypeFoldable};\n use ty::subst::{Substs, UnpackedKind};\n use ty::query::TyCtxtAt;\n-use ty::TypeVariants::*;\n+use ty::TyKind::*;\n use ty::layout::{Integer, IntegerExt};\n use util::common::ErrorReported;\n use middle::lang_items;\n@@ -41,7 +41,7 @@ pub struct Discr<'tcx> {\n impl<'tcx> fmt::Display for Discr<'tcx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         match self.ty.sty {\n-            ty::TyInt(ity) => {\n+            ty::Int(ity) => {\n                 let bits = ty::tls::with(|tcx| {\n                     Integer::from_attr(tcx, SignedInt(ity)).size().bits()\n                 });\n@@ -62,8 +62,8 @@ impl<'tcx> Discr<'tcx> {\n     }\n     pub fn checked_add<'a, 'gcx>(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, n: u128) -> (Self, bool) {\n         let (int, signed) = match self.ty.sty {\n-            TyInt(ity) => (Integer::from_attr(tcx, SignedInt(ity)), true),\n-            TyUint(uty) => (Integer::from_attr(tcx, UnsignedInt(uty)), false),\n+            Int(ity) => (Integer::from_attr(tcx, SignedInt(ity)), true),\n+            Uint(uty) => (Integer::from_attr(tcx, UnsignedInt(uty)), false),\n             _ => bug!(\"non integer discriminant\"),\n         };\n \n@@ -193,11 +193,11 @@ impl<'tcx> ty::ParamEnv<'tcx> {\n             let (adt, substs) = match self_type.sty {\n                 // These types used to have a builtin impl.\n                 // Now libcore provides that impl.\n-                ty::TyUint(_) | ty::TyInt(_) | ty::TyBool | ty::TyFloat(_) |\n-                ty::TyChar | ty::TyRawPtr(..) | ty::TyNever |\n-                ty::TyRef(_, _, hir::MutImmutable) => return Ok(()),\n+                ty::Uint(_) | ty::Int(_) | ty::Bool | ty::Float(_) |\n+                ty::Char | ty::RawPtr(..) | ty::Never |\n+                ty::Ref(_, _, hir::MutImmutable) => return Ok(()),\n \n-                ty::TyAdt(adt, substs) => (adt, substs),\n+                ty::Adt(adt, substs) => (adt, substs),\n \n                 _ => return Err(CopyImplementationError::NotAnAdt),\n             };\n@@ -258,10 +258,10 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn has_error_field(self, ty: Ty<'tcx>) -> bool {\n         match ty.sty {\n-            ty::TyAdt(def, substs) => {\n+            ty::Adt(def, substs) => {\n                 for field in def.all_fields() {\n                     let field_ty = field.ty(self, substs);\n-                    if let TyError = field_ty.sty {\n+                    if let Error = field_ty.sty {\n                         return true;\n                     }\n                 }\n@@ -277,7 +277,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn struct_tail(self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n         loop {\n             match ty.sty {\n-                ty::TyAdt(def, substs) => {\n+                ty::Adt(def, substs) => {\n                     if !def.is_struct() {\n                         break;\n                     }\n@@ -287,7 +287,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n \n-                ty::TyTuple(tys) => {\n+                ty::Tuple(tys) => {\n                     if let Some((&last_ty, _)) = tys.split_last() {\n                         ty = last_ty;\n                     } else {\n@@ -315,7 +315,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let (mut a, mut b) = (source, target);\n         loop {\n             match (&a.sty, &b.sty) {\n-                (&TyAdt(a_def, a_substs), &TyAdt(b_def, b_substs))\n+                (&Adt(a_def, a_substs), &Adt(b_def, b_substs))\n                         if a_def == b_def && a_def.is_struct() => {\n                     if let Some(f) = a_def.non_enum_variant().fields.last() {\n                         a = f.ty(self, a_substs);\n@@ -324,7 +324,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                         break;\n                     }\n                 },\n-                (&TyTuple(a_tys), &TyTuple(b_tys))\n+                (&Tuple(a_tys), &Tuple(b_tys))\n                         if a_tys.len() == b_tys.len() => {\n                     if let Some(a_last) = a_tys.last() {\n                         a = a_last;\n@@ -487,12 +487,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // parameters marked as pure.\n \n         let impl_substs = match self.type_of(impl_def_id).sty {\n-            ty::TyAdt(def_, substs) if def_ == def => substs,\n+            ty::Adt(def_, substs) if def_ == def => substs,\n             _ => bug!()\n         };\n \n         let item_substs = match self.type_of(def.did).sty {\n-            ty::TyAdt(def_, substs) if def_ == def => substs,\n+            ty::Adt(def_, substs) if def_ == def => substs,\n             _ => bug!()\n         };\n \n@@ -503,7 +503,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                         !impl_generics.region_param(ebr, self).pure_wrt_drop\n                     }\n                     UnpackedKind::Type(&ty::TyS {\n-                        sty: ty::TypeVariants::TyParam(ref pt), ..\n+                        sty: ty::Param(ref pt), ..\n                     }) => {\n                         !impl_generics.type_param(pt, self).pure_wrt_drop\n                     }\n@@ -697,18 +697,18 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n             -> Representability\n         {\n             match ty.sty {\n-                TyTuple(ref ts) => {\n+                Tuple(ref ts) => {\n                     // Find non representable\n                     fold_repr(ts.iter().map(|ty| {\n                         is_type_structurally_recursive(tcx, sp, seen, representable_cache, ty)\n                     }))\n                 }\n                 // Fixed-length vectors.\n                 // FIXME(#11924) Behavior undecided for zero-length vectors.\n-                TyArray(ty, _) => {\n+                Array(ty, _) => {\n                     is_type_structurally_recursive(tcx, sp, seen, representable_cache, ty)\n                 }\n-                TyAdt(def, substs) => {\n+                Adt(def, substs) => {\n                     // Find non representable fields with their spans\n                     fold_repr(def.all_fields().map(|field| {\n                         let ty = field.ty(tcx, substs);\n@@ -723,7 +723,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                         }\n                     }))\n                 }\n-                TyClosure(..) => {\n+                Closure(..) => {\n                     // this check is run on type definitions, so we don't expect\n                     // to see closure types\n                     bug!(\"requires check invoked on inapplicable type: {:?}\", ty)\n@@ -734,7 +734,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n \n         fn same_struct_or_enum<'tcx>(ty: Ty<'tcx>, def: &'tcx ty::AdtDef) -> bool {\n             match ty.sty {\n-                TyAdt(ty_def, _) => {\n+                Adt(ty_def, _) => {\n                      ty_def == def\n                 }\n                 _ => false\n@@ -743,7 +743,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n \n         fn same_type<'tcx>(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n             match (&a.sty, &b.sty) {\n-                (&TyAdt(did_a, substs_a), &TyAdt(did_b, substs_b)) => {\n+                (&Adt(did_a, substs_a), &Adt(did_b, substs_b)) => {\n                     if did_a != did_b {\n                         return false;\n                     }\n@@ -785,7 +785,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n             ty: Ty<'tcx>) -> Representability\n         {\n             match ty.sty {\n-                TyAdt(def, _) => {\n+                Adt(def, _) => {\n                     {\n                         // Iterate through stack of previously seen types.\n                         let mut iter = seen.iter();\n@@ -924,16 +924,16 @@ fn needs_drop_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     match ty.sty {\n         // Fast-path for primitive types\n-        ty::TyInfer(ty::FreshIntTy(_)) | ty::TyInfer(ty::FreshFloatTy(_)) |\n-        ty::TyBool | ty::TyInt(_) | ty::TyUint(_) | ty::TyFloat(_) | ty::TyNever |\n-        ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyChar | ty::TyGeneratorWitness(..) |\n-        ty::TyRawPtr(_) | ty::TyRef(..) | ty::TyStr => false,\n+        ty::Infer(ty::FreshIntTy(_)) | ty::Infer(ty::FreshFloatTy(_)) |\n+        ty::Bool | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Never |\n+        ty::FnDef(..) | ty::FnPtr(_) | ty::Char | ty::GeneratorWitness(..) |\n+        ty::RawPtr(_) | ty::Ref(..) | ty::Str => false,\n \n         // Foreign types can never have destructors\n-        ty::TyForeign(..) => false,\n+        ty::Foreign(..) => false,\n \n         // `ManuallyDrop` doesn't have a destructor regardless of field types.\n-        ty::TyAdt(def, _) if Some(def.did) == tcx.lang_items().manually_drop() => false,\n+        ty::Adt(def, _) if Some(def.did) == tcx.lang_items().manually_drop() => false,\n \n         // Issue #22536: We first query type_moves_by_default.  It sees a\n         // normalized version of the type, and therefore will definitely\n@@ -951,30 +951,30 @@ fn needs_drop_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // (see above), it is sound to treat it as having a destructor.\n \n         // User destructors are the only way to have concrete drop types.\n-        ty::TyAdt(def, _) if def.has_dtor(tcx) => true,\n+        ty::Adt(def, _) if def.has_dtor(tcx) => true,\n \n         // Can refer to a type which may drop.\n         // FIXME(eddyb) check this against a ParamEnv.\n-        ty::TyDynamic(..) | ty::TyProjection(..) | ty::TyParam(_) |\n-        ty::TyAnon(..) | ty::TyInfer(_) | ty::TyError => true,\n+        ty::Dynamic(..) | ty::Projection(..) | ty::Param(_) |\n+        ty::Anon(..) | ty::Infer(_) | ty::Error => true,\n \n         // Structural recursion.\n-        ty::TyArray(ty, _) | ty::TySlice(ty) => needs_drop(ty),\n+        ty::Array(ty, _) | ty::Slice(ty) => needs_drop(ty),\n \n-        ty::TyClosure(def_id, ref substs) => substs.upvar_tys(def_id, tcx).any(needs_drop),\n+        ty::Closure(def_id, ref substs) => substs.upvar_tys(def_id, tcx).any(needs_drop),\n \n         // Pessimistically assume that all generators will require destructors\n         // as we don't know if a destructor is a noop or not until after the MIR\n         // state transformation pass\n-        ty::TyGenerator(..) => true,\n+        ty::Generator(..) => true,\n \n-        ty::TyTuple(ref tys) => tys.iter().cloned().any(needs_drop),\n+        ty::Tuple(ref tys) => tys.iter().cloned().any(needs_drop),\n \n         // unions don't have destructors because of the child types,\n         // only if they manually implement `Drop` (handled above).\n-        ty::TyAdt(def, _) if def.is_union() => false,\n+        ty::Adt(def, _) if def.is_union() => false,\n \n-        ty::TyAdt(def, substs) =>\n+        ty::Adt(def, substs) =>\n             def.variants.iter().any(\n                 |variant| variant.fields.iter().any(\n                     |field| needs_drop(field.ty(tcx, substs)))),\n@@ -1025,13 +1025,13 @@ impl<'tcx> ExplicitSelf<'tcx> {\n \n         match self_arg_ty.sty {\n             _ if is_self_ty(self_arg_ty) => ByValue,\n-            ty::TyRef(region, ty, mutbl) if is_self_ty(ty) => {\n+            ty::Ref(region, ty, mutbl) if is_self_ty(ty) => {\n                 ByReference(region, mutbl)\n             }\n-            ty::TyRawPtr(ty::TypeAndMut { ty, mutbl }) if is_self_ty(ty) => {\n+            ty::RawPtr(ty::TypeAndMut { ty, mutbl }) if is_self_ty(ty) => {\n                 ByRawPointer(mutbl)\n             }\n-            ty::TyAdt(def, _) if def.is_box() && is_self_ty(self_arg_ty.boxed_ty()) => {\n+            ty::Adt(def, _) if def.is_box() && is_self_ty(self_arg_ty.boxed_ty()) => {\n                 ByBox\n             }\n             _ => Other"}, {"sha": "e2df7c32f587b51e686916e70d524a37b7f4e7f8", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -81,27 +81,27 @@ pub fn walk_shallow<'tcx>(ty: Ty<'tcx>) -> AccIntoIter<TypeWalkerArray<'tcx>> {\n // types as they are written).\n fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n     match parent_ty.sty {\n-        ty::TyBool | ty::TyChar | ty::TyInt(_) | ty::TyUint(_) | ty::TyFloat(_) |\n-        ty::TyStr | ty::TyInfer(_) | ty::TyParam(_) | ty::TyNever | ty::TyError |\n-        ty::TyForeign(..) => {\n+        ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) |\n+        ty::Str | ty::Infer(_) | ty::Param(_) | ty::Never | ty::Error |\n+        ty::Foreign(..) => {\n         }\n-        ty::TyArray(ty, len) => {\n+        ty::Array(ty, len) => {\n             push_const(stack, len);\n             stack.push(ty);\n         }\n-        ty::TySlice(ty) => {\n+        ty::Slice(ty) => {\n             stack.push(ty);\n         }\n-        ty::TyRawPtr(ref mt) => {\n+        ty::RawPtr(ref mt) => {\n             stack.push(mt.ty);\n         }\n-        ty::TyRef(_, ty, _) => {\n+        ty::Ref(_, ty, _) => {\n             stack.push(ty);\n         }\n-        ty::TyProjection(ref data) => {\n+        ty::Projection(ref data) => {\n             stack.extend(data.substs.types().rev());\n         }\n-        ty::TyDynamic(ref obj, ..) => {\n+        ty::Dynamic(ref obj, ..) => {\n             stack.extend(obj.iter().rev().flat_map(|predicate| {\n                 let (substs, opt_ty) = match *predicate.skip_binder() {\n                     ty::ExistentialPredicate::Trait(tr) => (tr.substs, None),\n@@ -115,25 +115,25 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n                 substs.types().rev().chain(opt_ty)\n             }));\n         }\n-        ty::TyAdt(_, substs) | ty::TyAnon(_, substs) => {\n+        ty::Adt(_, substs) | ty::Anon(_, substs) => {\n             stack.extend(substs.types().rev());\n         }\n-        ty::TyClosure(_, ref substs) => {\n+        ty::Closure(_, ref substs) => {\n             stack.extend(substs.substs.types().rev());\n         }\n-        ty::TyGenerator(_, ref substs, _) => {\n+        ty::Generator(_, ref substs, _) => {\n             stack.extend(substs.substs.types().rev());\n         }\n-        ty::TyGeneratorWitness(ts) => {\n+        ty::GeneratorWitness(ts) => {\n             stack.extend(ts.skip_binder().iter().cloned().rev());\n         }\n-        ty::TyTuple(ts) => {\n+        ty::Tuple(ts) => {\n             stack.extend(ts.iter().cloned().rev());\n         }\n-        ty::TyFnDef(_, substs) => {\n+        ty::FnDef(_, substs) => {\n             stack.extend(substs.types().rev());\n         }\n-        ty::TyFnPtr(sig) => {\n+        ty::FnPtr(sig) => {\n             stack.push(sig.skip_binder().output());\n             stack.extend(sig.skip_binder().inputs().iter().cloned().rev());\n         }"}, {"sha": "fc55d8f34a23fcff64a51de751dd0e2b53450892", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -248,54 +248,54 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n         let param_env = self.param_env;\n         while let Some(ty) = subtys.next() {\n             match ty.sty {\n-                ty::TyBool |\n-                ty::TyChar |\n-                ty::TyInt(..) |\n-                ty::TyUint(..) |\n-                ty::TyFloat(..) |\n-                ty::TyError |\n-                ty::TyStr |\n-                ty::TyGeneratorWitness(..) |\n-                ty::TyNever |\n-                ty::TyParam(_) |\n-                ty::TyForeign(..) => {\n+                ty::Bool |\n+                ty::Char |\n+                ty::Int(..) |\n+                ty::Uint(..) |\n+                ty::Float(..) |\n+                ty::Error |\n+                ty::Str |\n+                ty::GeneratorWitness(..) |\n+                ty::Never |\n+                ty::Param(_) |\n+                ty::Foreign(..) => {\n                     // WfScalar, WfParameter, etc\n                 }\n \n-                ty::TySlice(subty) => {\n+                ty::Slice(subty) => {\n                     self.require_sized(subty, traits::SliceOrArrayElem);\n                 }\n \n-                ty::TyArray(subty, len) => {\n+                ty::Array(subty, len) => {\n                     self.require_sized(subty, traits::SliceOrArrayElem);\n                     assert_eq!(len.ty, self.infcx.tcx.types.usize);\n                     self.compute_const(len);\n                 }\n \n-                ty::TyTuple(ref tys) => {\n+                ty::Tuple(ref tys) => {\n                     if let Some((_last, rest)) = tys.split_last() {\n                         for elem in rest {\n                             self.require_sized(elem, traits::TupleElem);\n                         }\n                     }\n                 }\n \n-                ty::TyRawPtr(_) => {\n+                ty::RawPtr(_) => {\n                     // simple cases that are WF if their type args are WF\n                 }\n \n-                ty::TyProjection(data) => {\n+                ty::Projection(data) => {\n                     subtys.skip_current_subtree(); // subtree handled by compute_projection\n                     self.compute_projection(data);\n                 }\n \n-                ty::TyAdt(def, substs) => {\n+                ty::Adt(def, substs) => {\n                     // WfNominalType\n                     let obligations = self.nominal_obligations(def.did, substs);\n                     self.out.extend(obligations);\n                 }\n \n-                ty::TyRef(r, rty, _) => {\n+                ty::Ref(r, rty, _) => {\n                     // WfReference\n                     if !r.has_escaping_regions() && !rty.has_escaping_regions() {\n                         let cause = self.cause(traits::ReferenceOutlivesReferent(ty));\n@@ -309,7 +309,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     }\n                 }\n \n-                ty::TyGenerator(..) => {\n+                ty::Generator(..) => {\n                     // Walk ALL the types in the generator: this will\n                     // include the upvar types as well as the yield\n                     // type. Note that this is mildly distinct from\n@@ -319,7 +319,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     // generators don't take arguments.\n                 }\n \n-                ty::TyClosure(def_id, substs) => {\n+                ty::Closure(def_id, substs) => {\n                     // Only check the upvar types for WF, not the rest\n                     // of the types within. This is needed because we\n                     // capture the signature and it may not be WF\n@@ -355,12 +355,12 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     }\n                 }\n \n-                ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n+                ty::FnDef(..) | ty::FnPtr(_) => {\n                     // let the loop iterate into the argument/return\n                     // types appearing in the fn signature\n                 }\n \n-                ty::TyAnon(did, substs) => {\n+                ty::Anon(did, substs) => {\n                     // all of the requirements on type parameters\n                     // should've been checked by the instantiation\n                     // of whatever returned this exact `impl Trait`.\n@@ -372,7 +372,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     }\n                 }\n \n-                ty::TyDynamic(data, r) => {\n+                ty::Dynamic(data, r) => {\n                     // WfObject\n                     //\n                     // Here, we defer WF checking due to higher-ranked\n@@ -408,9 +408,9 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                 //    register a pending obligation and keep\n                 //    moving. (Goal is that an \"inductive hypothesis\"\n                 //    is satisfied to ensure termination.)\n-                ty::TyInfer(_) => {\n+                ty::Infer(_) => {\n                     let ty = self.infcx.shallow_resolve(ty);\n-                    if let ty::TyInfer(_) = ty.sty { // not yet resolved...\n+                    if let ty::Infer(_) = ty.sty { // not yet resolved...\n                         if ty == ty0 { // ...this is the type we started from! no progress.\n                             return false;\n                         }\n@@ -423,7 +423,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     } else {\n                         // Yes, resolved, proceed with the\n                         // result. Should never return false because\n-                        // `ty` is not a TyInfer.\n+                        // `ty` is not a Infer.\n                         assert!(self.compute(ty));\n                     }\n                 }\n@@ -453,7 +453,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n     }\n \n     fn from_object_ty(&mut self, ty: Ty<'tcx>,\n-                      data: ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>,\n+                      data: ty::Binder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>,\n                       region: ty::Region<'tcx>) {\n         // Imagine a type like this:\n         //\n@@ -513,7 +513,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n /// `ty::required_region_bounds`, see that for more information.\n pub fn object_region_bounds<'a, 'gcx, 'tcx>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    existential_predicates: ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>)\n+    existential_predicates: ty::Binder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>)\n     -> Vec<ty::Region<'tcx>>\n {\n     // Since we don't actually *know* the self type for an object,"}, {"sha": "0f15c75c2fb36115bdc221e7033ed82b4ab43843", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -14,11 +14,11 @@ use mir::interpret::ConstValue;\n use middle::region::{self, BlockRemainder};\n use ty::subst::{self, Subst};\n use ty::{BrAnon, BrEnv, BrFresh, BrNamed};\n-use ty::{TyBool, TyChar, TyAdt};\n-use ty::{TyError, TyStr, TyArray, TySlice, TyFloat, TyFnDef, TyFnPtr};\n-use ty::{TyParam, TyRawPtr, TyRef, TyNever, TyTuple};\n-use ty::{TyClosure, TyGenerator, TyGeneratorWitness, TyForeign, TyProjection, TyAnon};\n-use ty::{TyDynamic, TyInt, TyUint, TyInfer};\n+use ty::{Bool, Char, Adt};\n+use ty::{Error, Str, Array, Slice, Float, FnDef, FnPtr};\n+use ty::{Param, RawPtr, Ref, Never, Tuple};\n+use ty::{Closure, Generator, GeneratorWitness, Foreign, Projection, Anon};\n+use ty::{Dynamic, Int, Uint, Infer};\n use ty::{self, RegionVid, Ty, TyCtxt, TypeFoldable, GenericParamCount, GenericParamDefKind};\n use util::nodemap::FxHashSet;\n \n@@ -371,7 +371,7 @@ impl PrintContext {\n \n         if !verbose && fn_trait_kind.is_some() && projections.len() == 1 {\n             let projection_ty = projections[0].ty;\n-            if let TyTuple(ref args) = substs.type_at(1).sty {\n+            if let Tuple(ref args) = substs.type_at(1).sty {\n                 return self.fn_sig(f, args, false, projection_ty);\n             }\n         }\n@@ -586,7 +586,7 @@ impl<'a, T: Print> Print for &'a T {\n }\n \n define_print! {\n-    ('tcx) &'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>, (self, f, cx) {\n+    ('tcx) &'tcx ty::List<ty::ExistentialPredicate<'tcx>>, (self, f, cx) {\n         display {\n             // Generate the main trait ref, including associated types.\n             ty::tls::with(|tcx| {\n@@ -672,7 +672,7 @@ impl<'tcx> fmt::Debug for ty::UpvarBorrow<'tcx> {\n }\n \n define_print! {\n-    ('tcx) &'tcx ty::Slice<Ty<'tcx>>, (self, f, cx) {\n+    ('tcx) &'tcx ty::List<Ty<'tcx>>, (self, f, cx) {\n         display {\n             write!(f, \"{{\")?;\n             let mut tys = self.iter();\n@@ -993,7 +993,7 @@ impl fmt::Debug for ty::FloatVarValue {\n \n define_print_multi! {\n     [\n-    ('tcx) ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>,\n+    ('tcx) ty::Binder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>,\n     ('tcx) ty::Binder<ty::TraitRef<'tcx>>,\n     ('tcx) ty::Binder<ty::FnSig<'tcx>>,\n     ('tcx) ty::Binder<ty::TraitPredicate<'tcx>>,\n@@ -1029,22 +1029,22 @@ define_print! {\n }\n \n define_print! {\n-    ('tcx) ty::TypeVariants<'tcx>, (self, f, cx) {\n+    ('tcx) ty::TyKind<'tcx>, (self, f, cx) {\n         display {\n             match *self {\n-                TyBool => write!(f, \"bool\"),\n-                TyChar => write!(f, \"char\"),\n-                TyInt(t) => write!(f, \"{}\", t.ty_to_string()),\n-                TyUint(t) => write!(f, \"{}\", t.ty_to_string()),\n-                TyFloat(t) => write!(f, \"{}\", t.ty_to_string()),\n-                TyRawPtr(ref tm) => {\n+                Bool => write!(f, \"bool\"),\n+                Char => write!(f, \"char\"),\n+                Int(t) => write!(f, \"{}\", t.ty_to_string()),\n+                Uint(t) => write!(f, \"{}\", t.ty_to_string()),\n+                Float(t) => write!(f, \"{}\", t.ty_to_string()),\n+                RawPtr(ref tm) => {\n                     write!(f, \"*{} \", match tm.mutbl {\n                         hir::MutMutable => \"mut\",\n                         hir::MutImmutable => \"const\",\n                     })?;\n                     tm.ty.print(f, cx)\n                 }\n-                TyRef(r, ty, mutbl) => {\n+                Ref(r, ty, mutbl) => {\n                     write!(f, \"&\")?;\n                     let s = r.print_to_string(cx);\n                     if s != \"'_\" {\n@@ -1055,8 +1055,8 @@ define_print! {\n                     }\n                     ty::TypeAndMut { ty, mutbl }.print(f, cx)\n                 }\n-                TyNever => write!(f, \"!\"),\n-                TyTuple(ref tys) => {\n+                Never => write!(f, \"!\"),\n+                Tuple(ref tys) => {\n                     write!(f, \"(\")?;\n                     let mut tys = tys.iter();\n                     if let Some(&ty) = tys.next() {\n@@ -1070,7 +1070,7 @@ define_print! {\n                     }\n                     write!(f, \")\")\n                 }\n-                TyFnDef(def_id, substs) => {\n+                FnDef(def_id, substs) => {\n                     ty::tls::with(|tcx| {\n                         let mut sig = tcx.fn_sig(def_id);\n                         if let Some(substs) = tcx.lift(&substs) {\n@@ -1081,14 +1081,14 @@ define_print! {\n                     cx.parameterized(f, substs, def_id, &[])?;\n                     write!(f, \"}}\")\n                 }\n-                TyFnPtr(ref bare_fn) => {\n+                FnPtr(ref bare_fn) => {\n                     bare_fn.print(f, cx)\n                 }\n-                TyInfer(infer_ty) => write!(f, \"{}\", infer_ty),\n-                TyError => write!(f, \"[type error]\"),\n-                TyParam(ref param_ty) => write!(f, \"{}\", param_ty),\n-                TyAdt(def, substs) => cx.parameterized(f, substs, def.did, &[]),\n-                TyDynamic(data, r) => {\n+                Infer(infer_ty) => write!(f, \"{}\", infer_ty),\n+                Error => write!(f, \"[type error]\"),\n+                Param(ref param_ty) => write!(f, \"{}\", param_ty),\n+                Adt(def, substs) => cx.parameterized(f, substs, def.did, &[]),\n+                Dynamic(data, r) => {\n                     let r = r.print_to_string(cx);\n                     if !r.is_empty() {\n                         write!(f, \"(\")?;\n@@ -1101,11 +1101,11 @@ define_print! {\n                         Ok(())\n                     }\n                 }\n-                TyForeign(def_id) => parameterized(f, subst::Substs::empty(), def_id, &[]),\n-                TyProjection(ref data) => data.print(f, cx),\n-                TyAnon(def_id, substs) => {\n+                Foreign(def_id) => parameterized(f, subst::Substs::empty(), def_id, &[]),\n+                Projection(ref data) => data.print(f, cx),\n+                Anon(def_id, substs) => {\n                     if cx.is_verbose {\n-                        return write!(f, \"TyAnon({:?}, {:?})\", def_id, substs);\n+                        return write!(f, \"Anon({:?}, {:?})\", def_id, substs);\n                     }\n \n                     ty::tls::with(|tcx| {\n@@ -1154,8 +1154,8 @@ define_print! {\n                         Ok(())\n                     })\n                 }\n-                TyStr => write!(f, \"str\"),\n-                TyGenerator(did, substs, movability) => ty::tls::with(|tcx| {\n+                Str => write!(f, \"str\"),\n+                Generator(did, substs, movability) => ty::tls::with(|tcx| {\n                     let upvar_tys = substs.upvar_tys(did, tcx);\n                     let witness = substs.witness(did, tcx);\n                     if movability == hir::GeneratorMovability::Movable {\n@@ -1193,10 +1193,10 @@ define_print! {\n \n                     print!(f, cx, write(\" \"), print(witness), write(\"]\"))\n                 }),\n-                TyGeneratorWitness(types) => {\n+                GeneratorWitness(types) => {\n                     ty::tls::with(|tcx| cx.in_binder(f, tcx, &types, tcx.lift(&types)))\n                 }\n-                TyClosure(did, substs) => ty::tls::with(|tcx| {\n+                Closure(did, substs) => ty::tls::with(|tcx| {\n                     let upvar_tys = substs.upvar_tys(did, tcx);\n                     write!(f, \"[closure\")?;\n \n@@ -1233,7 +1233,7 @@ define_print! {\n \n                     write!(f, \"]\")\n                 }),\n-                TyArray(ty, sz) => {\n+                Array(ty, sz) => {\n                     print!(f, cx, write(\"[\"), print(ty), write(\"; \"))?;\n                     match sz.val {\n                         ConstValue::Unevaluated(_def_id, _substs) => {\n@@ -1245,7 +1245,7 @@ define_print! {\n                     }\n                     write!(f, \"]\")\n                 }\n-                TySlice(ty) => {\n+                Slice(ty) => {\n                     print!(f, cx, write(\"[\"), print(ty), write(\"]\"))\n                 }\n             }"}, {"sha": "847d37be89933c79607f15b837833af74ac358af", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -843,7 +843,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             }\n             LpExtend(ref lp_base, _, LpInterior(_, InteriorField(_))) => {\n                 match lp_base.to_type().sty {\n-                    ty::TyAdt(def, _) if def.has_dtor(self.tcx()) => {\n+                    ty::Adt(def, _) if def.has_dtor(self.tcx()) => {\n                         // In the case where the owner implements drop, then\n                         // the path must be initialized to prevent a case of\n                         // partial reinitialization"}, {"sha": "5c165fbad6943be5f3a815467348c2b7405e8480", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -191,14 +191,14 @@ fn check_and_get_illegal_move_origin<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         Categorization::Interior(ref b, mc::InteriorField(_)) |\n         Categorization::Interior(ref b, mc::InteriorElement(Kind::Pattern)) => {\n             match b.ty.sty {\n-                ty::TyAdt(def, _) => {\n+                ty::Adt(def, _) => {\n                     if def.has_dtor(bccx.tcx) {\n                         Some(cmt.clone())\n                     } else {\n                         check_and_get_illegal_move_origin(bccx, b)\n                     }\n                 }\n-                ty::TySlice(..) => Some(cmt.clone()),\n+                ty::Slice(..) => Some(cmt.clone()),\n                 _ => {\n                     check_and_get_illegal_move_origin(bccx, b)\n                 }"}, {"sha": "31778668e6da0c34e4f74d0b3a471e5e37bde8f5", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -154,7 +154,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &'a BorrowckCtxt<'a, 'tcx>,\n         Categorization::Downcast(ref b, _) |\n         Categorization::Interior(ref b, mc::InteriorField(_)) => {\n             match b.ty.sty {\n-                ty::TyAdt(def, _) if def.has_dtor(bccx.tcx) => {\n+                ty::Adt(def, _) if def.has_dtor(bccx.tcx) => {\n                     bccx.cannot_move_out_of_interior_of_drop(\n                         move_from.span, b.ty, Origin::Ast)\n                 }"}, {"sha": "d9784cc2177fde18003c252b9760e512d341b224", "filename": "src/librustc_borrowck/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -104,7 +104,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                 let result = self.restrict(&cmt_base);\n                 // Borrowing one union field automatically borrows all its fields.\n                 match base_ty.sty {\n-                    ty::TyAdt(adt_def, _) if adt_def.is_union() => match result {\n+                    ty::Adt(adt_def, _) if adt_def.is_union() => match result {\n                         RestrictionResult::Safe => RestrictionResult::Safe,\n                         RestrictionResult::SafeIf(base_lp, mut base_vec) => {\n                             for (i, field) in adt_def.non_enum_variant().fields.iter().enumerate() {"}, {"sha": "a3ca329b92d7f5dcc1ae23707c6f147e456f0685", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -697,7 +697,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                                              Some(nl.to_string()),\n                                                              Origin::Ast);\n                 let need_note = match lp.ty.sty {\n-                    ty::TypeVariants::TyClosure(id, _) => {\n+                    ty::Closure(id, _) => {\n                         let node_id = self.tcx.hir.as_local_node_id(id).unwrap();\n                         let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n                         if let Some((span, name)) = self.tables.closure_kind_origins().get(hir_id) {"}, {"sha": "d9f223daf609179059a4ece46abc09e885162564", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -329,7 +329,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n         // all parent union fields, moves do not propagate upwards automatically.\n         let mut lp = orig_lp.clone();\n         while let LpExtend(ref base_lp, mutbl, lp_elem) = lp.clone().kind {\n-            if let (&ty::TyAdt(adt_def, _), LpInterior(opt_variant_id, interior))\n+            if let (&ty::Adt(adt_def, _), LpInterior(opt_variant_id, interior))\n                     = (&base_lp.ty.sty, lp_elem) {\n                 if adt_def.is_union() {\n                     for (i, field) in adt_def.non_enum_variant().fields.iter().enumerate() {\n@@ -381,7 +381,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n                           span: Span) {\n         // Assigning to one union field automatically assigns to all its fields.\n         if let LpExtend(ref base_lp, mutbl, LpInterior(opt_variant_id, interior)) = lp.kind {\n-            if let ty::TyAdt(adt_def, _) = base_lp.ty.sty {\n+            if let ty::Adt(adt_def, _) = base_lp.ty.sty {\n                 if adt_def.is_union() {\n                     for (i, field) in adt_def.non_enum_variant().fields.iter().enumerate() {\n                         let field ="}, {"sha": "684f2b358858f935387d082d6b0b26607a796cb1", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -364,7 +364,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n             assert!(!sig.variadic && extra_args.is_empty());\n \n             match sig.inputs().last().unwrap().sty {\n-                ty::TyTuple(ref tupled_arguments) => {\n+                ty::Tuple(ref tupled_arguments) => {\n                     inputs = &sig.inputs()[0..sig.inputs().len() - 1];\n                     tupled_arguments\n                 }"}, {"sha": "009c6da9d8d15a35f0bf60cbf96cb09834940e52", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -166,12 +166,12 @@ pub fn compare_simd_types(\n     op: hir::BinOpKind\n ) -> &'ll Value {\n     let signed = match t.sty {\n-        ty::TyFloat(_) => {\n+        ty::Float(_) => {\n             let cmp = bin_op_to_fcmp_predicate(op);\n             return bx.sext(bx.fcmp(cmp, lhs, rhs), ret_ty);\n         },\n-        ty::TyUint(_) => false,\n-        ty::TyInt(_) => true,\n+        ty::Uint(_) => false,\n+        ty::Int(_) => true,\n         _ => bug!(\"compare_simd_types: invalid SIMD type\"),\n     };\n \n@@ -197,16 +197,16 @@ pub fn unsized_info(\n ) -> &'ll Value {\n     let (source, target) = cx.tcx.struct_lockstep_tails(source, target);\n     match (&source.sty, &target.sty) {\n-        (&ty::TyArray(_, len), &ty::TySlice(_)) => {\n+        (&ty::Array(_, len), &ty::Slice(_)) => {\n             C_usize(cx, len.unwrap_usize(cx.tcx))\n         }\n-        (&ty::TyDynamic(..), &ty::TyDynamic(..)) => {\n+        (&ty::Dynamic(..), &ty::Dynamic(..)) => {\n             // For now, upcasts are limited to changes in marker\n             // traits, and hence never actually require an actual\n             // change to the vtable.\n             old_info.expect(\"unsized_info: missing old info for trait upcast\")\n         }\n-        (_, &ty::TyDynamic(ref data, ..)) => {\n+        (_, &ty::Dynamic(ref data, ..)) => {\n             let vtable_ptr = cx.layout_of(cx.tcx.mk_mut_ptr(target))\n                 .field(cx, abi::FAT_PTR_EXTRA);\n             consts::ptrcast(meth::get_vtable(cx, source, data.principal()),\n@@ -227,23 +227,23 @@ pub fn unsize_thin_ptr(\n ) -> (&'ll Value, &'ll Value) {\n     debug!(\"unsize_thin_ptr: {:?} => {:?}\", src_ty, dst_ty);\n     match (&src_ty.sty, &dst_ty.sty) {\n-        (&ty::TyRef(_, a, _),\n-         &ty::TyRef(_, b, _)) |\n-        (&ty::TyRef(_, a, _),\n-         &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) |\n-        (&ty::TyRawPtr(ty::TypeAndMut { ty: a, .. }),\n-         &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) => {\n+        (&ty::Ref(_, a, _),\n+         &ty::Ref(_, b, _)) |\n+        (&ty::Ref(_, a, _),\n+         &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) |\n+        (&ty::RawPtr(ty::TypeAndMut { ty: a, .. }),\n+         &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) => {\n             assert!(bx.cx.type_is_sized(a));\n             let ptr_ty = bx.cx.layout_of(b).llvm_type(bx.cx).ptr_to();\n             (bx.pointercast(src, ptr_ty), unsized_info(bx.cx, a, b, None))\n         }\n-        (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n+        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n             let (a, b) = (src_ty.boxed_ty(), dst_ty.boxed_ty());\n             assert!(bx.cx.type_is_sized(a));\n             let ptr_ty = bx.cx.layout_of(b).llvm_type(bx.cx).ptr_to();\n             (bx.pointercast(src, ptr_ty), unsized_info(bx.cx, a, b, None))\n         }\n-        (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) => {\n+        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n             assert_eq!(def_a, def_b);\n \n             let src_layout = bx.cx.layout_of(src_ty);\n@@ -299,16 +299,16 @@ pub fn coerce_unsized_into(\n         OperandValue::Pair(base, info).store(bx, dst);\n     };\n     match (&src_ty.sty, &dst_ty.sty) {\n-        (&ty::TyRef(..), &ty::TyRef(..)) |\n-        (&ty::TyRef(..), &ty::TyRawPtr(..)) |\n-        (&ty::TyRawPtr(..), &ty::TyRawPtr(..)) => {\n+        (&ty::Ref(..), &ty::Ref(..)) |\n+        (&ty::Ref(..), &ty::RawPtr(..)) |\n+        (&ty::RawPtr(..), &ty::RawPtr(..)) => {\n             coerce_ptr()\n         }\n-        (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n+        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n             coerce_ptr()\n         }\n \n-        (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) => {\n+        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n             assert_eq!(def_a, def_b);\n \n             for i in 0..def_a.variants[0].fields.len() {"}, {"sha": "53bb02ddd99d947887ad4a555fb4330114df511e", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -413,10 +413,10 @@ pub fn ty_fn_sig<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                            -> ty::PolyFnSig<'tcx>\n {\n     match ty.sty {\n-        ty::TyFnDef(..) |\n-        // Shims currently have type TyFnPtr. Not sure this should remain.\n-        ty::TyFnPtr(_) => ty.fn_sig(cx.tcx),\n-        ty::TyClosure(def_id, substs) => {\n+        ty::FnDef(..) |\n+        // Shims currently have type FnPtr. Not sure this should remain.\n+        ty::FnPtr(_) => ty.fn_sig(cx.tcx),\n+        ty::Closure(def_id, substs) => {\n             let tcx = cx.tcx;\n             let sig = substs.closure_sig(def_id, tcx);\n \n@@ -429,7 +429,7 @@ pub fn ty_fn_sig<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 sig.abi\n             ))\n         }\n-        ty::TyGenerator(def_id, substs, _) => {\n+        ty::Generator(def_id, substs, _) => {\n             let tcx = cx.tcx;\n             let sig = substs.poly_sig(def_id, cx.tcx);\n "}, {"sha": "6f09ebb382697e6fa0a66014bf7c03d40a712149", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -250,7 +250,7 @@ fn check_and_apply_linkage(\n         // static and call it a day. Some linkages (like weak) will make it such\n         // that the static actually has a null value.\n         let llty2 = match ty.sty {\n-            ty::TyRawPtr(ref mt) => cx.layout_of(mt.ty).llvm_type(cx),\n+            ty::RawPtr(ref mt) => cx.layout_of(mt.ty).llvm_type(cx),\n             _ => {\n                 if span.is_some() {\n                     cx.sess().span_fatal(span.unwrap(), \"must have type `*const T` or `*mut T`\")"}, {"sha": "9547f4a190e7896d721cda285efb8217b05fc674", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -434,8 +434,8 @@ impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n \n         let tail = self.tcx.struct_tail(ty);\n         match tail.sty {\n-            ty::TyForeign(..) => false,\n-            ty::TyStr | ty::TySlice(..) | ty::TyDynamic(..) => true,\n+            ty::Foreign(..) => false,\n+            ty::Str | ty::Slice(..) | ty::Dynamic(..) => true,\n             _ => bug!(\"unexpected unsized tail: {:?}\", tail.sty),\n         }\n     }"}, {"sha": "c7a515016c01b0260679032b3bf40665df868e20", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -309,7 +309,7 @@ fn fixed_vec_metadata(\n     let (size, align) = cx.size_and_align_of(array_or_slice_type);\n \n     let upper_bound = match array_or_slice_type.sty {\n-        ty::TyArray(_, len) => {\n+        ty::Array(_, len) => {\n             len.unwrap_usize(cx.tcx) as c_longlong\n         }\n         _ => -1\n@@ -396,7 +396,7 @@ fn subroutine_type_metadata(\n     let signature_metadata: Vec<_> = iter::once(\n         // return type\n         match signature.output().sty {\n-            ty::TyTuple(ref tys) if tys.is_empty() => None,\n+            ty::Tuple(ref tys) if tys.is_empty() => None,\n             _ => Some(type_metadata(cx, signature.output(), span))\n         }\n     ).chain(\n@@ -435,7 +435,7 @@ fn trait_pointer_metadata(\n     // But it does not describe the trait's methods.\n \n     let containing_scope = match trait_type.sty {\n-        ty::TyDynamic(ref data, ..) => if let Some(principal) = data.principal() {\n+        ty::Dynamic(ref data, ..) => if let Some(principal) = data.principal() {\n             let def_id = principal.def_id();\n             Some(get_namespace_for_item(cx, def_id))\n         } else {\n@@ -534,13 +534,13 @@ pub fn type_metadata(\n \n     let ptr_metadata = |ty: Ty<'tcx>| {\n         match ty.sty {\n-            ty::TySlice(typ) => {\n+            ty::Slice(typ) => {\n                 Ok(vec_slice_metadata(cx, t, typ, unique_type_id, usage_site_span))\n             }\n-            ty::TyStr => {\n+            ty::Str => {\n                 Ok(vec_slice_metadata(cx, t, cx.tcx.types.u8, unique_type_id, usage_site_span))\n             }\n-            ty::TyDynamic(..) => {\n+            ty::Dynamic(..) => {\n                 Ok(MetadataCreationResult::new(\n                     trait_pointer_metadata(cx, ty, Some(t), unique_type_id),\n                     false))\n@@ -562,48 +562,48 @@ pub fn type_metadata(\n     };\n \n     let MetadataCreationResult { metadata, already_stored_in_typemap } = match t.sty {\n-        ty::TyNever    |\n-        ty::TyBool     |\n-        ty::TyChar     |\n-        ty::TyInt(_)   |\n-        ty::TyUint(_)  |\n-        ty::TyFloat(_) => {\n+        ty::Never    |\n+        ty::Bool     |\n+        ty::Char     |\n+        ty::Int(_)   |\n+        ty::Uint(_)  |\n+        ty::Float(_) => {\n             MetadataCreationResult::new(basic_type_metadata(cx, t), false)\n         }\n-        ty::TyTuple(ref elements) if elements.is_empty() => {\n+        ty::Tuple(ref elements) if elements.is_empty() => {\n             MetadataCreationResult::new(basic_type_metadata(cx, t), false)\n         }\n-        ty::TyArray(typ, _) |\n-        ty::TySlice(typ) => {\n+        ty::Array(typ, _) |\n+        ty::Slice(typ) => {\n             fixed_vec_metadata(cx, unique_type_id, t, typ, usage_site_span)\n         }\n-        ty::TyStr => {\n+        ty::Str => {\n             fixed_vec_metadata(cx, unique_type_id, t, cx.tcx.types.i8, usage_site_span)\n         }\n-        ty::TyDynamic(..) => {\n+        ty::Dynamic(..) => {\n             MetadataCreationResult::new(\n                         trait_pointer_metadata(cx, t, None, unique_type_id),\n             false)\n         }\n-        ty::TyForeign(..) => {\n+        ty::Foreign(..) => {\n             MetadataCreationResult::new(\n                         foreign_type_metadata(cx, t, unique_type_id),\n             false)\n         }\n-        ty::TyRawPtr(ty::TypeAndMut{ty, ..}) |\n-        ty::TyRef(_, ty, _) => {\n+        ty::RawPtr(ty::TypeAndMut{ty, ..}) |\n+        ty::Ref(_, ty, _) => {\n             match ptr_metadata(ty) {\n                 Ok(res) => res,\n                 Err(metadata) => return metadata,\n             }\n         }\n-        ty::TyAdt(def, _) if def.is_box() => {\n+        ty::Adt(def, _) if def.is_box() => {\n             match ptr_metadata(t.boxed_ty()) {\n                 Ok(res) => res,\n                 Err(metadata) => return metadata,\n             }\n         }\n-        ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n+        ty::FnDef(..) | ty::FnPtr(_) => {\n             let fn_metadata = subroutine_type_metadata(cx,\n                                                        unique_type_id,\n                                                        t.fn_sig(cx.tcx),\n@@ -619,15 +619,15 @@ pub fn type_metadata(\n             MetadataCreationResult::new(pointer_type_metadata(cx, t, fn_metadata), false)\n \n         }\n-        ty::TyClosure(def_id, substs) => {\n+        ty::Closure(def_id, substs) => {\n             let upvar_tys : Vec<_> = substs.upvar_tys(def_id, cx.tcx).collect();\n             prepare_tuple_metadata(cx,\n                                    t,\n                                    &upvar_tys,\n                                    unique_type_id,\n                                    usage_site_span).finalize(cx)\n         }\n-        ty::TyGenerator(def_id, substs,  _) => {\n+        ty::Generator(def_id, substs,  _) => {\n             let upvar_tys : Vec<_> = substs.field_tys(def_id, cx.tcx).map(|t| {\n                 cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), t)\n             }).collect();\n@@ -637,7 +637,7 @@ pub fn type_metadata(\n                                    unique_type_id,\n                                    usage_site_span).finalize(cx)\n         }\n-        ty::TyAdt(def, ..) => match def.adt_kind() {\n+        ty::Adt(def, ..) => match def.adt_kind() {\n             AdtKind::Struct => {\n                 prepare_struct_metadata(cx,\n                                         t,\n@@ -658,7 +658,7 @@ pub fn type_metadata(\n                                     usage_site_span).finalize(cx)\n             }\n         },\n-        ty::TyTuple(ref elements) => {\n+        ty::Tuple(ref elements) => {\n             prepare_tuple_metadata(cx,\n                                    t,\n                                    &elements[..],\n@@ -765,18 +765,18 @@ fn basic_type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {\n     debug!(\"basic_type_metadata: {:?}\", t);\n \n     let (name, encoding) = match t.sty {\n-        ty::TyNever => (\"!\", DW_ATE_unsigned),\n-        ty::TyTuple(ref elements) if elements.is_empty() =>\n+        ty::Never => (\"!\", DW_ATE_unsigned),\n+        ty::Tuple(ref elements) if elements.is_empty() =>\n             (\"()\", DW_ATE_unsigned),\n-        ty::TyBool => (\"bool\", DW_ATE_boolean),\n-        ty::TyChar => (\"char\", DW_ATE_unsigned_char),\n-        ty::TyInt(int_ty) => {\n+        ty::Bool => (\"bool\", DW_ATE_boolean),\n+        ty::Char => (\"char\", DW_ATE_unsigned_char),\n+        ty::Int(int_ty) => {\n             (int_ty.ty_to_string(), DW_ATE_signed)\n         },\n-        ty::TyUint(uint_ty) => {\n+        ty::Uint(uint_ty) => {\n             (uint_ty.ty_to_string(), DW_ATE_unsigned)\n         },\n-        ty::TyFloat(float_ty) => {\n+        ty::Float(float_ty) => {\n             (float_ty.ty_to_string(), DW_ATE_float)\n         },\n         _ => bug!(\"debuginfo::basic_type_metadata - t is invalid type\")\n@@ -1009,7 +1009,7 @@ fn prepare_struct_metadata(\n     let struct_name = compute_debuginfo_type_name(cx, struct_type, false);\n \n     let (struct_def_id, variant) = match struct_type.sty {\n-        ty::TyAdt(def, _) => (def.did, def.non_enum_variant()),\n+        ty::Adt(def, _) => (def.did, def.non_enum_variant()),\n         _ => bug!(\"prepare_struct_metadata on a non-ADT\")\n     };\n \n@@ -1126,7 +1126,7 @@ fn prepare_union_metadata(\n     let union_name = compute_debuginfo_type_name(cx, union_type, false);\n \n     let (union_def_id, variant) = match union_type.sty {\n-        ty::TyAdt(def, _) => (def.did, def.non_enum_variant()),\n+        ty::Adt(def, _) => (def.did, def.non_enum_variant()),\n         _ => bug!(\"prepare_union_metadata on a non-ADT\")\n     };\n "}, {"sha": "99919a940b40511dcd605cea460440d5a1a9e05a", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -323,7 +323,7 @@ pub fn create_function_debug_context(\n \n         // Return type -- llvm::DIBuilder wants this at index 0\n         signature.push(match sig.output().sty {\n-            ty::TyTuple(ref tys) if tys.is_empty() => None,\n+            ty::Tuple(ref tys) if tys.is_empty() => None,\n             _ => Some(type_metadata(cx, sig.output(), syntax_pos::DUMMY_SP))\n         });\n \n@@ -347,7 +347,7 @@ pub fn create_function_debug_context(\n             // already inaccurate due to ABI adjustments (see #42800).\n             signature.extend(inputs.iter().map(|&t| {\n                 let t = match t.sty {\n-                    ty::TyArray(ct, _)\n+                    ty::Array(ct, _)\n                         if (ct == cx.tcx.types.u8) || cx.layout_of(ct).is_zst() => {\n                         cx.tcx.mk_imm_ptr(ct)\n                     }\n@@ -362,7 +362,7 @@ pub fn create_function_debug_context(\n         }\n \n         if sig.abi == Abi::RustCall && !sig.inputs().is_empty() {\n-            if let ty::TyTuple(args) = sig.inputs()[sig.inputs().len() - 1].sty {\n+            if let ty::Tuple(args) = sig.inputs()[sig.inputs().len() - 1].sty {\n                 signature.extend(\n                     args.iter().map(|argument_type| {\n                         Some(type_metadata(cx, argument_type, syntax_pos::DUMMY_SP))\n@@ -460,7 +460,7 @@ pub fn create_function_debug_context(\n                 // Only \"class\" methods are generally understood by LLVM,\n                 // so avoid methods on other types (e.g. `<*mut T>::null`).\n                 match impl_self_ty.sty {\n-                    ty::TyAdt(def, ..) if !def.is_box() => {\n+                    ty::Adt(def, ..) if !def.is_box() => {\n                         Some(type_metadata(cx, impl_self_ty, syntax_pos::DUMMY_SP))\n                     }\n                     _ => None"}, {"sha": "a08b964cd721d6b1d3a6ec7fe95f7850e0416fd3", "filename": "src/librustc_codegen_llvm/debuginfo/type_names.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -41,19 +41,19 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     let cpp_like_names = cx.sess().target.target.options.is_like_msvc;\n \n     match t.sty {\n-        ty::TyBool => output.push_str(\"bool\"),\n-        ty::TyChar => output.push_str(\"char\"),\n-        ty::TyStr => output.push_str(\"str\"),\n-        ty::TyNever => output.push_str(\"!\"),\n-        ty::TyInt(int_ty) => output.push_str(int_ty.ty_to_string()),\n-        ty::TyUint(uint_ty) => output.push_str(uint_ty.ty_to_string()),\n-        ty::TyFloat(float_ty) => output.push_str(float_ty.ty_to_string()),\n-        ty::TyForeign(def_id) => push_item_name(cx, def_id, qualified, output),\n-        ty::TyAdt(def, substs) => {\n+        ty::Bool => output.push_str(\"bool\"),\n+        ty::Char => output.push_str(\"char\"),\n+        ty::Str => output.push_str(\"str\"),\n+        ty::Never => output.push_str(\"!\"),\n+        ty::Int(int_ty) => output.push_str(int_ty.ty_to_string()),\n+        ty::Uint(uint_ty) => output.push_str(uint_ty.ty_to_string()),\n+        ty::Float(float_ty) => output.push_str(float_ty.ty_to_string()),\n+        ty::Foreign(def_id) => push_item_name(cx, def_id, qualified, output),\n+        ty::Adt(def, substs) => {\n             push_item_name(cx, def.did, qualified, output);\n             push_type_params(cx, substs, output);\n         },\n-        ty::TyTuple(component_types) => {\n+        ty::Tuple(component_types) => {\n             output.push('(');\n             for &component_type in component_types {\n                 push_debuginfo_type_name(cx, component_type, true, output);\n@@ -65,7 +65,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             }\n             output.push(')');\n         },\n-        ty::TyRawPtr(ty::TypeAndMut { ty: inner_type, mutbl } ) => {\n+        ty::RawPtr(ty::TypeAndMut { ty: inner_type, mutbl } ) => {\n             if !cpp_like_names {\n                 output.push('*');\n             }\n@@ -80,7 +80,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 output.push('*');\n             }\n         },\n-        ty::TyRef(_, inner_type, mutbl) => {\n+        ty::Ref(_, inner_type, mutbl) => {\n             if !cpp_like_names {\n                 output.push('&');\n             }\n@@ -94,13 +94,13 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 output.push('*');\n             }\n         },\n-        ty::TyArray(inner_type, len) => {\n+        ty::Array(inner_type, len) => {\n             output.push('[');\n             push_debuginfo_type_name(cx, inner_type, true, output);\n             output.push_str(&format!(\"; {}\", len.unwrap_usize(cx.tcx)));\n             output.push(']');\n         },\n-        ty::TySlice(inner_type) => {\n+        ty::Slice(inner_type) => {\n             if cpp_like_names {\n                 output.push_str(\"slice<\");\n             } else {\n@@ -115,7 +115,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 output.push(']');\n             }\n         },\n-        ty::TyDynamic(ref trait_data, ..) => {\n+        ty::Dynamic(ref trait_data, ..) => {\n             if let Some(principal) = trait_data.principal() {\n                 let principal = cx.tcx.normalize_erasing_late_bound_regions(\n                     ty::ParamEnv::reveal_all(),\n@@ -125,7 +125,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 push_type_params(cx, principal.substs, output);\n             }\n         },\n-        ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n+        ty::FnDef(..) | ty::FnPtr(_) => {\n             let sig = t.fn_sig(cx.tcx);\n             if sig.unsafety() == hir::Unsafety::Unsafe {\n                 output.push_str(\"unsafe \");\n@@ -165,18 +165,18 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 push_debuginfo_type_name(cx, sig.output(), true, output);\n             }\n         },\n-        ty::TyClosure(..) => {\n+        ty::Closure(..) => {\n             output.push_str(\"closure\");\n         }\n-        ty::TyGenerator(..) => {\n+        ty::Generator(..) => {\n             output.push_str(\"generator\");\n         }\n-        ty::TyError |\n-        ty::TyInfer(_) |\n-        ty::TyProjection(..) |\n-        ty::TyAnon(..) |\n-        ty::TyGeneratorWitness(..) |\n-        ty::TyParam(_) => {\n+        ty::Error |\n+        ty::Infer(_) |\n+        ty::Projection(..) |\n+        ty::Anon(..) |\n+        ty::GeneratorWitness(..) |\n+        ty::Param(_) => {\n             bug!(\"debuginfo: Trying to create type name for \\\n                 unexpected type: {:?}\", t);\n         }"}, {"sha": "ff33cec043729eaacffd4a1dddce437e147da263", "filename": "src/librustc_codegen_llvm/glue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_llvm%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_llvm%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fglue.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -35,12 +35,12 @@ pub fn size_and_align_of_dst(bx: &Builder<'_, 'll, 'tcx>, t: Ty<'tcx>, info: Opt\n         return (size, align);\n     }\n     match t.sty {\n-        ty::TyDynamic(..) => {\n+        ty::Dynamic(..) => {\n             // load size/align from vtable\n             let vtable = info.unwrap();\n             (meth::SIZE.get_usize(bx, vtable), meth::ALIGN.get_usize(bx, vtable))\n         }\n-        ty::TySlice(_) | ty::TyStr => {\n+        ty::Slice(_) | ty::Str => {\n             let unit = t.sequence_element_type(bx.tcx());\n             // The info in this case is the length of the str, so the size is that\n             // times the unit size.\n@@ -81,7 +81,7 @@ pub fn size_and_align_of_dst(bx: &Builder<'_, 'll, 'tcx>, t: Ty<'tcx>, info: Opt\n             let size = bx.add(sized_size, unsized_size);\n \n             // Packed types ignore the alignment of their fields.\n-            if let ty::TyAdt(def, _) = t.sty {\n+            if let ty::Adt(def, _) = t.sty {\n                 if def.repr.packed() {\n                     unsized_align = sized_align;\n                 }"}, {"sha": "5d00e0807991e1d6607571237c0a8e7be911cb70", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -98,7 +98,7 @@ pub fn codegen_intrinsic_call(\n     let tcx = cx.tcx;\n \n     let (def_id, substs) = match callee_ty.sty {\n-        ty::TyFnDef(def_id, substs) => (def_id, substs),\n+        ty::FnDef(def_id, substs) => (def_id, substs),\n         _ => bug!(\"expected fn item type, found {}\", callee_ty)\n     };\n \n@@ -1149,7 +1149,7 @@ fn generic_simd_intrinsic(\n                  m_len, v_len\n         );\n         match m_elem_ty.sty {\n-            ty::TyInt(_) => {},\n+            ty::Int(_) => {},\n             _ => {\n                 return_error!(\"mask element type is `{}`, expected `i_`\", m_elem_ty);\n             }\n@@ -1191,7 +1191,7 @@ fn generic_simd_intrinsic(\n             }\n         }\n         let ety = match in_elem.sty {\n-            ty::TyFloat(f) if f.bit_width() == 32 => {\n+            ty::Float(f) if f.bit_width() == 32 => {\n                 if in_len < 2 || in_len > 16 {\n                     return_error!(\n                         \"unsupported floating-point vector `{}` with length `{}` \\\n@@ -1200,15 +1200,15 @@ fn generic_simd_intrinsic(\n                 }\n                 \"f32\"\n             },\n-            ty::TyFloat(f) if f.bit_width() == 64 => {\n+            ty::Float(f) if f.bit_width() == 64 => {\n                 if in_len < 2 || in_len > 8 {\n                     return_error!(\"unsupported floating-point vector `{}` with length `{}` \\\n                                    out-of-range [2, 8]\",\n                                   in_ty, in_len);\n                 }\n                 \"f64\"\n             },\n-            ty::TyFloat(f) => {\n+            ty::Float(f) => {\n                 return_error!(\"unsupported element type `{}` of floating-point vector `{}`\",\n                               f, in_ty);\n             },\n@@ -1288,9 +1288,9 @@ fn generic_simd_intrinsic(\n     fn llvm_vector_str(elem_ty: ty::Ty, vec_len: usize, no_pointers: usize) -> String {\n         let p0s: String = \"p0\".repeat(no_pointers);\n         match elem_ty.sty {\n-            ty::TyInt(v) => format!(\"v{}{}i{}\", vec_len, p0s, v.bit_width().unwrap()),\n-            ty::TyUint(v) => format!(\"v{}{}i{}\", vec_len, p0s, v.bit_width().unwrap()),\n-            ty::TyFloat(v) => format!(\"v{}{}f{}\", vec_len, p0s, v.bit_width()),\n+            ty::Int(v) => format!(\"v{}{}i{}\", vec_len, p0s, v.bit_width().unwrap()),\n+            ty::Uint(v) => format!(\"v{}{}i{}\", vec_len, p0s, v.bit_width().unwrap()),\n+            ty::Float(v) => format!(\"v{}{}f{}\", vec_len, p0s, v.bit_width()),\n             _ => unreachable!(),\n         }\n     }\n@@ -1299,9 +1299,9 @@ fn generic_simd_intrinsic(\n                       mut no_pointers: usize) -> &'ll Type {\n         // FIXME: use cx.layout_of(ty).llvm_type() ?\n         let mut elem_ty = match elem_ty.sty {\n-            ty::TyInt(v) => Type::int_from_ty(cx, v),\n-            ty::TyUint(v) => Type::uint_from_ty(cx, v),\n-            ty::TyFloat(v) => Type::float_from_ty(cx, v),\n+            ty::Int(v) => Type::int_from_ty(cx, v),\n+            ty::Uint(v) => Type::uint_from_ty(cx, v),\n+            ty::Float(v) => Type::float_from_ty(cx, v),\n             _ => unreachable!(),\n         };\n         while no_pointers > 0 {\n@@ -1343,23 +1343,23 @@ fn generic_simd_intrinsic(\n         // This counts how many pointers\n         fn ptr_count(t: ty::Ty) -> usize {\n             match t.sty {\n-                ty::TyRawPtr(p) => 1 + ptr_count(p.ty),\n+                ty::RawPtr(p) => 1 + ptr_count(p.ty),\n                 _ => 0,\n             }\n         }\n \n         // Non-ptr type\n         fn non_ptr(t: ty::Ty) -> ty::Ty {\n             match t.sty {\n-                ty::TyRawPtr(p) => non_ptr(p.ty),\n+                ty::RawPtr(p) => non_ptr(p.ty),\n                 _ => t,\n             }\n         }\n \n         // The second argument must be a simd vector with an element type that's a pointer\n         // to the element type of the first argument\n         let (pointer_count, underlying_ty) = match arg_tys[1].simd_type(tcx).sty {\n-            ty::TyRawPtr(p) if p.ty == in_elem => (ptr_count(arg_tys[1].simd_type(tcx)),\n+            ty::RawPtr(p) if p.ty == in_elem => (ptr_count(arg_tys[1].simd_type(tcx)),\n                                                    non_ptr(arg_tys[1].simd_type(tcx))),\n             _ => {\n                 require!(false, \"expected element type `{}` of second argument `{}` \\\n@@ -1376,7 +1376,7 @@ fn generic_simd_intrinsic(\n \n         // The element type of the third argument must be a signed integer type of any width:\n         match arg_tys[2].simd_type(tcx).sty {\n-            ty::TyInt(_) => (),\n+            ty::Int(_) => (),\n             _ => {\n                 require!(false, \"expected element type `{}` of third argument `{}` \\\n                                  to be a signed integer type\",\n@@ -1439,23 +1439,23 @@ fn generic_simd_intrinsic(\n         // This counts how many pointers\n         fn ptr_count(t: ty::Ty) -> usize {\n             match t.sty {\n-                ty::TyRawPtr(p) => 1 + ptr_count(p.ty),\n+                ty::RawPtr(p) => 1 + ptr_count(p.ty),\n                 _ => 0,\n             }\n         }\n \n         // Non-ptr type\n         fn non_ptr(t: ty::Ty) -> ty::Ty {\n             match t.sty {\n-                ty::TyRawPtr(p) => non_ptr(p.ty),\n+                ty::RawPtr(p) => non_ptr(p.ty),\n                 _ => t,\n             }\n         }\n \n         // The second argument must be a simd vector with an element type that's a pointer\n         // to the element type of the first argument\n         let (pointer_count, underlying_ty) = match arg_tys[1].simd_type(tcx).sty {\n-            ty::TyRawPtr(p) if p.ty == in_elem && p.mutbl == hir::MutMutable\n+            ty::RawPtr(p) if p.ty == in_elem && p.mutbl == hir::MutMutable\n                 => (ptr_count(arg_tys[1].simd_type(tcx)),\n                     non_ptr(arg_tys[1].simd_type(tcx))),\n             _ => {\n@@ -1473,7 +1473,7 @@ fn generic_simd_intrinsic(\n \n         // The element type of the third argument must be a signed integer type of any width:\n         match arg_tys[2].simd_type(tcx).sty {\n-            ty::TyInt(_) => (),\n+            ty::Int(_) => (),\n             _ => {\n                 require!(false, \"expected element type `{}` of third argument `{}` \\\n                                  to be a signed integer type\",\n@@ -1522,7 +1522,7 @@ fn generic_simd_intrinsic(\n                          \"expected return type `{}` (element of input `{}`), found `{}`\",\n                          in_elem, in_ty, ret_ty);\n                 return match in_elem.sty {\n-                    ty::TyInt(_) | ty::TyUint(_) => {\n+                    ty::Int(_) | ty::Uint(_) => {\n                         let r = bx.$integer_reduce(args[0].immediate());\n                         if $ordered {\n                             // if overflow occurs, the result is the\n@@ -1536,7 +1536,7 @@ fn generic_simd_intrinsic(\n                             Ok(bx.$integer_reduce(args[0].immediate()))\n                         }\n                     },\n-                    ty::TyFloat(f) => {\n+                    ty::Float(f) => {\n                         // ordered arithmetic reductions take an accumulator\n                         let acc = if $ordered {\n                             let acc = args[1].immediate();\n@@ -1597,13 +1597,13 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                          \"expected return type `{}` (element of input `{}`), found `{}`\",\n                          in_elem, in_ty, ret_ty);\n                 return match in_elem.sty {\n-                    ty::TyInt(_i) => {\n+                    ty::Int(_i) => {\n                         Ok(bx.$int_red(args[0].immediate(), true))\n                     },\n-                    ty::TyUint(_u) => {\n+                    ty::Uint(_u) => {\n                         Ok(bx.$int_red(args[0].immediate(), false))\n                     },\n-                    ty::TyFloat(_f) => {\n+                    ty::Float(_f) => {\n                         Ok(bx.$float_red(args[0].immediate()))\n                     }\n                     _ => {\n@@ -1632,7 +1632,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                     args[0].immediate()\n                 } else {\n                     match in_elem.sty {\n-                        ty::TyInt(_) | ty::TyUint(_) => {},\n+                        ty::Int(_) | ty::Uint(_) => {},\n                         _ => {\n                             return_error!(\"unsupported {} from `{}` with element `{}` to `{}`\",\n                                           $name, in_ty, in_elem, ret_ty)\n@@ -1645,7 +1645,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                     bx.trunc(args[0].immediate(), i1xn)\n                 };\n                 return match in_elem.sty {\n-                    ty::TyInt(_) | ty::TyUint(_) => {\n+                    ty::Int(_) | ty::Uint(_) => {\n                         let r = bx.$red(input);\n                         Ok(\n                             if !$boolean {\n@@ -1688,15 +1688,15 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n         let (in_style, in_width) = match in_elem.sty {\n             // vectors of pointer-sized integers should've been\n             // disallowed before here, so this unwrap is safe.\n-            ty::TyInt(i) => (Style::Int(true), i.bit_width().unwrap()),\n-            ty::TyUint(u) => (Style::Int(false), u.bit_width().unwrap()),\n-            ty::TyFloat(f) => (Style::Float, f.bit_width()),\n+            ty::Int(i) => (Style::Int(true), i.bit_width().unwrap()),\n+            ty::Uint(u) => (Style::Int(false), u.bit_width().unwrap()),\n+            ty::Float(f) => (Style::Float, f.bit_width()),\n             _ => (Style::Unsupported, 0)\n         };\n         let (out_style, out_width) = match out_elem.sty {\n-            ty::TyInt(i) => (Style::Int(true), i.bit_width().unwrap()),\n-            ty::TyUint(u) => (Style::Int(false), u.bit_width().unwrap()),\n-            ty::TyFloat(f) => (Style::Float, f.bit_width()),\n+            ty::Int(i) => (Style::Int(true), i.bit_width().unwrap()),\n+            ty::Uint(u) => (Style::Int(false), u.bit_width().unwrap()),\n+            ty::Float(f) => (Style::Float, f.bit_width()),\n             _ => (Style::Unsupported, 0)\n         };\n \n@@ -1757,18 +1757,18 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n         }\n     }\n     arith! {\n-        simd_add: TyUint, TyInt => add, TyFloat => fadd;\n-        simd_sub: TyUint, TyInt => sub, TyFloat => fsub;\n-        simd_mul: TyUint, TyInt => mul, TyFloat => fmul;\n-        simd_div: TyUint => udiv, TyInt => sdiv, TyFloat => fdiv;\n-        simd_rem: TyUint => urem, TyInt => srem, TyFloat => frem;\n-        simd_shl: TyUint, TyInt => shl;\n-        simd_shr: TyUint => lshr, TyInt => ashr;\n-        simd_and: TyUint, TyInt => and;\n-        simd_or: TyUint, TyInt => or;\n-        simd_xor: TyUint, TyInt => xor;\n-        simd_fmax: TyFloat => maxnum;\n-        simd_fmin: TyFloat => minnum;\n+        simd_add: Uint, Int => add, Float => fadd;\n+        simd_sub: Uint, Int => sub, Float => fsub;\n+        simd_mul: Uint, Int => mul, Float => fmul;\n+        simd_div: Uint => udiv, Int => sdiv, Float => fdiv;\n+        simd_rem: Uint => urem, Int => srem, Float => frem;\n+        simd_shl: Uint, Int => shl;\n+        simd_shr: Uint => lshr, Int => ashr;\n+        simd_and: Uint, Int => and;\n+        simd_or: Uint, Int => or;\n+        simd_xor: Uint, Int => xor;\n+        simd_fmax: Float => maxnum;\n+        simd_fmin: Float => minnum;\n     }\n     span_bug!(span, \"unknown SIMD intrinsic\");\n }\n@@ -1779,15 +1779,15 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n // stuffs.\n fn int_type_width_signed(ty: Ty, cx: &CodegenCx) -> Option<(u64, bool)> {\n     match ty.sty {\n-        ty::TyInt(t) => Some((match t {\n+        ty::Int(t) => Some((match t {\n             ast::IntTy::Isize => cx.tcx.sess.target.isize_ty.bit_width().unwrap() as u64,\n             ast::IntTy::I8 => 8,\n             ast::IntTy::I16 => 16,\n             ast::IntTy::I32 => 32,\n             ast::IntTy::I64 => 64,\n             ast::IntTy::I128 => 128,\n         }, true)),\n-        ty::TyUint(t) => Some((match t {\n+        ty::Uint(t) => Some((match t {\n             ast::UintTy::Usize => cx.tcx.sess.target.usize_ty.bit_width().unwrap() as u64,\n             ast::UintTy::U8 => 8,\n             ast::UintTy::U16 => 16,\n@@ -1801,9 +1801,9 @@ fn int_type_width_signed(ty: Ty, cx: &CodegenCx) -> Option<(u64, bool)> {\n \n // Returns the width of a float TypeVariant\n // Returns None if the type is not a float\n-fn float_type_width<'tcx>(sty: &ty::TypeVariants<'tcx>) -> Option<u64> {\n+fn float_type_width<'tcx>(sty: &ty::TyKind<'tcx>) -> Option<u64> {\n     match *sty {\n-        ty::TyFloat(t) => Some(t.bit_width() as u64),\n+        ty::Float(t) => Some(t.bit_width() as u64),\n         _ => None,\n     }\n }"}, {"sha": "0206744eb2b6b2daabc4f60f67cdb95a99d4f51f", "filename": "src/librustc_codegen_llvm/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -131,7 +131,7 @@ impl Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'll, 'tcx> {\n                 func: mir::Operand::Constant(ref c),\n                 ref args, ..\n             } => match c.ty.sty {\n-                ty::TyFnDef(did, _) => Some((did, args)),\n+                ty::FnDef(did, _) => Some((did, args)),\n                 _ => None,\n             },\n             _ => None,"}, {"sha": "a534b4e478fb793e4f96496e4621287c25eb0a24", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -296,7 +296,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                     &args1[..]\n                 };\n                 let (drop_fn, fn_ty) = match ty.sty {\n-                    ty::TyDynamic(..) => {\n+                    ty::Dynamic(..) => {\n                         let fn_ty = drop_fn.ty(bx.cx.tcx);\n                         let sig = common::ty_fn_sig(bx.cx, fn_ty);\n                         let sig = bx.tcx().normalize_erasing_late_bound_regions(\n@@ -417,14 +417,14 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                 let callee = self.codegen_operand(&bx, func);\n \n                 let (instance, mut llfn) = match callee.layout.ty.sty {\n-                    ty::TyFnDef(def_id, substs) => {\n+                    ty::FnDef(def_id, substs) => {\n                         (Some(ty::Instance::resolve(bx.cx.tcx,\n                                                     ty::ParamEnv::reveal_all(),\n                                                     def_id,\n                                                     substs).unwrap()),\n                          None)\n                     }\n-                    ty::TyFnPtr(_) => {\n+                    ty::FnPtr(_) => {\n                         (None, Some(callee.immediate()))\n                     }\n                     _ => bug!(\"{} is not callable\", callee.layout.ty)"}, {"sha": "2657543b2d167c477af34597873c56b41a8926e2", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -182,7 +182,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n             .and_then(|c| {\n                 let field_ty = c.ty.builtin_index().unwrap();\n                 let fields = match c.ty.sty {\n-                    ty::TyArray(_, n) => n.unwrap_usize(bx.tcx()),\n+                    ty::Array(_, n) => n.unwrap_usize(bx.tcx()),\n                     ref other => bug!(\"invalid simd shuffle type: {}\", other),\n                 };\n                 let values: Result<Vec<_>, Lrc<_>> = (0..fields).map(|field| {"}, {"sha": "9e65144bd60a1fd87fd6ff425fd76a676fe34a42", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -467,7 +467,7 @@ fn arg_local_refs(\n \n             let arg_ty = fx.monomorphize(&arg_decl.ty);\n             let tupled_arg_tys = match arg_ty.sty {\n-                ty::TyTuple(ref tys) => tys,\n+                ty::Tuple(ref tys) => tys,\n                 _ => bug!(\"spread argument isn't a tuple?!\")\n             };\n \n@@ -592,14 +592,14 @@ fn arg_local_refs(\n \n             // Or is it the closure environment?\n             let (closure_layout, env_ref) = match arg.layout.ty.sty {\n-                ty::TyRawPtr(ty::TypeAndMut { ty, .. }) |\n-                ty::TyRef(_, ty, _)  => (bx.cx.layout_of(ty), true),\n+                ty::RawPtr(ty::TypeAndMut { ty, .. }) |\n+                ty::Ref(_, ty, _)  => (bx.cx.layout_of(ty), true),\n                 _ => (arg.layout, false)\n             };\n \n             let (def_id, upvar_substs) = match closure_layout.ty.sty {\n-                ty::TyClosure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs)),\n-                ty::TyGenerator(def_id, substs, _) => (def_id, UpvarSubsts::Generator(substs)),\n+                ty::Closure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs)),\n+                ty::Generator(def_id, substs, _) => (def_id, UpvarSubsts::Generator(substs)),\n                 _ => bug!(\"upvar_decls with non-closure arg0 type `{}`\", closure_layout.ty)\n             };\n             let upvar_tys = upvar_substs.upvar_tys(def_id, tcx);\n@@ -639,7 +639,7 @@ fn arg_local_refs(\n                 // a pointer in an alloca for debuginfo atm.\n                 let mut ops = if env_ref || env_alloca { &ops[..] } else { &ops[1..] };\n \n-                let ty = if let (true, &ty::TyRef(_, ty, _)) = (decl.by_ref, &ty.sty) {\n+                let ty = if let (true, &ty::Ref(_, ty, _)) = (decl.by_ref, &ty.sty) {\n                     ty\n                 } else {\n                     ops = &ops[..ops.len() - 1];"}, {"sha": "ce3292eaa426d0db301ffc021f1aa32e17c96b26", "filename": "src/librustc_codegen_llvm/mir/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -211,8 +211,8 @@ impl PlaceRef<'ll, 'tcx> {\n                 return simple();\n             }\n             _ if !field.is_unsized() => return simple(),\n-            ty::TySlice(..) | ty::TyStr | ty::TyForeign(..) => return simple(),\n-            ty::TyAdt(def, _) => {\n+            ty::Slice(..) | ty::Str | ty::Foreign(..) => return simple(),\n+            ty::Adt(def, _) => {\n                 if def.repr.packed() {\n                     // FIXME(eddyb) generalize the adjustment when we\n                     // start supporting packing to larger alignments."}, {"sha": "25f32360815e7c429d2abc55609e5b09a65a2e2e", "filename": "src/librustc_codegen_llvm/mir/rvalue.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -214,7 +214,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                 let val = match *kind {\n                     mir::CastKind::ReifyFnPointer => {\n                         match operand.layout.ty.sty {\n-                            ty::TyFnDef(def_id, substs) => {\n+                            ty::FnDef(def_id, substs) => {\n                                 if bx.cx.tcx.has_attr(def_id, \"rustc_args_required_const\") {\n                                     bug!(\"reifying a fn ptr that requires \\\n                                           const arguments\");\n@@ -229,7 +229,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                     }\n                     mir::CastKind::ClosureFnPointer => {\n                         match operand.layout.ty.sty {\n-                            ty::TyClosure(def_id, substs) => {\n+                            ty::Closure(def_id, substs) => {\n                                 let instance = monomorphize::resolve_closure(\n                                     bx.cx.tcx, def_id, substs, ty::ClosureKind::FnOnce);\n                                 OperandValue::Immediate(callee::get_fn(bx.cx, instance))\n@@ -545,7 +545,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n         // because codegen_place() panics if Local is operand.\n         if let mir::Place::Local(index) = *place {\n             if let LocalRef::Operand(Some(op)) = self.locals[index] {\n-                if let ty::TyArray(_, n) = op.layout.ty.sty {\n+                if let ty::Array(_, n) = op.layout.ty.sty {\n                     let n = n.unwrap_usize(bx.cx.tcx);\n                     return common::C_usize(bx.cx, n);\n                 }\n@@ -753,60 +753,60 @@ enum OverflowOp {\n fn get_overflow_intrinsic(oop: OverflowOp, bx: &Builder<'_, 'll, '_>, ty: Ty) -> &'ll Value {\n     use syntax::ast::IntTy::*;\n     use syntax::ast::UintTy::*;\n-    use rustc::ty::{TyInt, TyUint};\n+    use rustc::ty::{Int, Uint};\n \n     let tcx = bx.tcx();\n \n     let new_sty = match ty.sty {\n-        TyInt(Isize) => TyInt(tcx.sess.target.isize_ty),\n-        TyUint(Usize) => TyUint(tcx.sess.target.usize_ty),\n-        ref t @ TyUint(_) | ref t @ TyInt(_) => t.clone(),\n+        Int(Isize) => Int(tcx.sess.target.isize_ty),\n+        Uint(Usize) => Uint(tcx.sess.target.usize_ty),\n+        ref t @ Uint(_) | ref t @ Int(_) => t.clone(),\n         _ => panic!(\"tried to get overflow intrinsic for op applied to non-int type\")\n     };\n \n     let name = match oop {\n         OverflowOp::Add => match new_sty {\n-            TyInt(I8) => \"llvm.sadd.with.overflow.i8\",\n-            TyInt(I16) => \"llvm.sadd.with.overflow.i16\",\n-            TyInt(I32) => \"llvm.sadd.with.overflow.i32\",\n-            TyInt(I64) => \"llvm.sadd.with.overflow.i64\",\n-            TyInt(I128) => \"llvm.sadd.with.overflow.i128\",\n-\n-            TyUint(U8) => \"llvm.uadd.with.overflow.i8\",\n-            TyUint(U16) => \"llvm.uadd.with.overflow.i16\",\n-            TyUint(U32) => \"llvm.uadd.with.overflow.i32\",\n-            TyUint(U64) => \"llvm.uadd.with.overflow.i64\",\n-            TyUint(U128) => \"llvm.uadd.with.overflow.i128\",\n+            Int(I8) => \"llvm.sadd.with.overflow.i8\",\n+            Int(I16) => \"llvm.sadd.with.overflow.i16\",\n+            Int(I32) => \"llvm.sadd.with.overflow.i32\",\n+            Int(I64) => \"llvm.sadd.with.overflow.i64\",\n+            Int(I128) => \"llvm.sadd.with.overflow.i128\",\n+\n+            Uint(U8) => \"llvm.uadd.with.overflow.i8\",\n+            Uint(U16) => \"llvm.uadd.with.overflow.i16\",\n+            Uint(U32) => \"llvm.uadd.with.overflow.i32\",\n+            Uint(U64) => \"llvm.uadd.with.overflow.i64\",\n+            Uint(U128) => \"llvm.uadd.with.overflow.i128\",\n \n             _ => unreachable!(),\n         },\n         OverflowOp::Sub => match new_sty {\n-            TyInt(I8) => \"llvm.ssub.with.overflow.i8\",\n-            TyInt(I16) => \"llvm.ssub.with.overflow.i16\",\n-            TyInt(I32) => \"llvm.ssub.with.overflow.i32\",\n-            TyInt(I64) => \"llvm.ssub.with.overflow.i64\",\n-            TyInt(I128) => \"llvm.ssub.with.overflow.i128\",\n-\n-            TyUint(U8) => \"llvm.usub.with.overflow.i8\",\n-            TyUint(U16) => \"llvm.usub.with.overflow.i16\",\n-            TyUint(U32) => \"llvm.usub.with.overflow.i32\",\n-            TyUint(U64) => \"llvm.usub.with.overflow.i64\",\n-            TyUint(U128) => \"llvm.usub.with.overflow.i128\",\n+            Int(I8) => \"llvm.ssub.with.overflow.i8\",\n+            Int(I16) => \"llvm.ssub.with.overflow.i16\",\n+            Int(I32) => \"llvm.ssub.with.overflow.i32\",\n+            Int(I64) => \"llvm.ssub.with.overflow.i64\",\n+            Int(I128) => \"llvm.ssub.with.overflow.i128\",\n+\n+            Uint(U8) => \"llvm.usub.with.overflow.i8\",\n+            Uint(U16) => \"llvm.usub.with.overflow.i16\",\n+            Uint(U32) => \"llvm.usub.with.overflow.i32\",\n+            Uint(U64) => \"llvm.usub.with.overflow.i64\",\n+            Uint(U128) => \"llvm.usub.with.overflow.i128\",\n \n             _ => unreachable!(),\n         },\n         OverflowOp::Mul => match new_sty {\n-            TyInt(I8) => \"llvm.smul.with.overflow.i8\",\n-            TyInt(I16) => \"llvm.smul.with.overflow.i16\",\n-            TyInt(I32) => \"llvm.smul.with.overflow.i32\",\n-            TyInt(I64) => \"llvm.smul.with.overflow.i64\",\n-            TyInt(I128) => \"llvm.smul.with.overflow.i128\",\n-\n-            TyUint(U8) => \"llvm.umul.with.overflow.i8\",\n-            TyUint(U16) => \"llvm.umul.with.overflow.i16\",\n-            TyUint(U32) => \"llvm.umul.with.overflow.i32\",\n-            TyUint(U64) => \"llvm.umul.with.overflow.i64\",\n-            TyUint(U128) => \"llvm.umul.with.overflow.i128\",\n+            Int(I8) => \"llvm.smul.with.overflow.i8\",\n+            Int(I16) => \"llvm.smul.with.overflow.i16\",\n+            Int(I32) => \"llvm.smul.with.overflow.i32\",\n+            Int(I64) => \"llvm.smul.with.overflow.i64\",\n+            Int(I128) => \"llvm.smul.with.overflow.i128\",\n+\n+            Uint(U8) => \"llvm.umul.with.overflow.i8\",\n+            Uint(U16) => \"llvm.umul.with.overflow.i16\",\n+            Uint(U32) => \"llvm.umul.with.overflow.i32\",\n+            Uint(U64) => \"llvm.umul.with.overflow.i64\",\n+            Uint(U128) => \"llvm.umul.with.overflow.i128\",\n \n             _ => unreachable!(),\n         },"}, {"sha": "e6907030ae6352e59ac6c48df0926838bbab49fc", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -56,19 +56,19 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     }\n \n     let name = match layout.ty.sty {\n-        ty::TyClosure(..) |\n-        ty::TyGenerator(..) |\n-        ty::TyAdt(..) |\n+        ty::Closure(..) |\n+        ty::Generator(..) |\n+        ty::Adt(..) |\n         // FIXME(eddyb) producing readable type names for trait objects can result\n         // in problematically distinct types due to HRTB and subtyping (see #47638).\n-        // ty::TyDynamic(..) |\n-        ty::TyForeign(..) |\n-        ty::TyStr => {\n+        // ty::Dynamic(..) |\n+        ty::Foreign(..) |\n+        ty::Str => {\n             let mut name = String::with_capacity(32);\n             let printer = DefPathBasedNames::new(cx.tcx, true, true);\n             printer.push_type_name(layout.ty, &mut name);\n             match (&layout.ty.sty, &layout.variants) {\n-                (&ty::TyAdt(def, _), &layout::Variants::Single { index }) => {\n+                (&ty::Adt(def, _), &layout::Variants::Single { index }) => {\n                     if def.is_enum() && !def.variants.is_empty() {\n                         write!(&mut name, \"::{}\", def.variants[index].name).unwrap();\n                     }\n@@ -252,14 +252,14 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                 return llty;\n             }\n             let llty = match self.ty.sty {\n-                ty::TyRef(_, ty, _) |\n-                ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n+                ty::Ref(_, ty, _) |\n+                ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n                     cx.layout_of(ty).llvm_type(cx).ptr_to()\n                 }\n-                ty::TyAdt(def, _) if def.is_box() => {\n+                ty::Adt(def, _) if def.is_box() => {\n                     cx.layout_of(self.ty.boxed_ty()).llvm_type(cx).ptr_to()\n                 }\n-                ty::TyFnPtr(sig) => {\n+                ty::FnPtr(sig) => {\n                     let sig = cx.tcx.normalize_erasing_late_bound_regions(\n                         ty::ParamEnv::reveal_all(),\n                         &sig,\n@@ -344,11 +344,11 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         // HACK(eddyb) special-case fat pointers until LLVM removes\n         // pointee types, to avoid bitcasting every `OperandRef::deref`.\n         match self.ty.sty {\n-            ty::TyRef(..) |\n-            ty::TyRawPtr(_) => {\n+            ty::Ref(..) |\n+            ty::RawPtr(_) => {\n                 return self.field(cx, index).llvm_type(cx);\n             }\n-            ty::TyAdt(def, _) if def.is_box() => {\n+            ty::Adt(def, _) if def.is_box() => {\n                 let ptr_ty = cx.tcx.mk_mut_ptr(self.ty.boxed_ty());\n                 return cx.layout_of(ptr_ty).scalar_pair_element_llvm_type(cx, index, immediate);\n             }\n@@ -410,7 +410,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n \n         let mut result = None;\n         match self.ty.sty {\n-            ty::TyRawPtr(mt) if offset.bytes() == 0 => {\n+            ty::RawPtr(mt) if offset.bytes() == 0 => {\n                 let (size, align) = cx.size_and_align_of(mt.ty);\n                 result = Some(PointeeInfo {\n                     size,\n@@ -419,7 +419,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                 });\n             }\n \n-            ty::TyRef(_, ty, mt) if offset.bytes() == 0 => {\n+            ty::Ref(_, ty, mt) if offset.bytes() == 0 => {\n                 let (size, align) = cx.size_and_align_of(ty);\n \n                 let kind = match mt {\n@@ -497,7 +497,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n \n                 // FIXME(eddyb) This should be for `ptr::Unique<T>`, not `Box<T>`.\n                 if let Some(ref mut pointee) = result {\n-                    if let ty::TyAdt(def, _) = self.ty.sty {\n+                    if let ty::Adt(def, _) = self.ty.sty {\n                         if def.is_box() && offset.bytes() == 0 {\n                             pointee.safe = Some(PointerKind::UniqueOwned);\n                         }"}, {"sha": "33ce06217a46e80e7d012bac4d7728876b1b9892", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -171,7 +171,7 @@ fn get_symbol_hash<'a, 'tcx>(\n         // If this is a function, we hash the signature as well.\n         // This is not *strictly* needed, but it may help in some\n         // situations, see the `run-make/a-b-a-linker-guard` test.\n-        if let ty::TyFnDef(..) = item_type.sty {\n+        if let ty::FnDef(..) = item_type.sty {\n             item_type.fn_sig(tcx).hash_stable(&mut hcx, &mut hasher);\n         }\n "}, {"sha": "c26d8555214c1cfbb894fc04d2a57f20bd0e4322", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -1320,7 +1320,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n         let msg = \"mutating transmuted &mut T from &T may cause undefined behavior, \\\n                    consider instead using an UnsafeCell\";\n         match get_transmute_from_to(cx, expr) {\n-            Some((&ty::TyRef(_, _, from_mt), &ty::TyRef(_, _, to_mt))) => {\n+            Some((&ty::Ref(_, _, from_mt), &ty::Ref(_, _, to_mt))) => {\n                 if to_mt == hir::Mutability::MutMutable &&\n                    from_mt == hir::Mutability::MutImmutable {\n                     cx.span_lint(MUTABLE_TRANSMUTES, expr.span, msg);\n@@ -1332,7 +1332,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n         fn get_transmute_from_to<'a, 'tcx>\n             (cx: &LateContext<'a, 'tcx>,\n              expr: &hir::Expr)\n-             -> Option<(&'tcx ty::TypeVariants<'tcx>, &'tcx ty::TypeVariants<'tcx>)> {\n+             -> Option<(&'tcx ty::TyKind<'tcx>, &'tcx ty::TyKind<'tcx>)> {\n             let def = if let hir::ExprKind::Path(ref qpath) = expr.node {\n                 cx.tables.qpath_def(qpath, expr.hir_id)\n             } else {"}, {"sha": "d9f6e7de5b5e406cdce6748190c4b8ad08233caa", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -84,7 +84,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n             }\n             hir::ExprKind::Lit(ref lit) => {\n                 match cx.tables.node_id_to_type(e.hir_id).sty {\n-                    ty::TyInt(t) => {\n+                    ty::Int(t) => {\n                         match lit.node {\n                             ast::LitKind::Int(v, ast::LitIntType::Signed(_)) |\n                             ast::LitKind::Int(v, ast::LitIntType::Unsuffixed) => {\n@@ -104,7 +104,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                                         report_bin_hex_error(\n                                             cx,\n                                             e,\n-                                            ty::TyInt(t),\n+                                            ty::Int(t),\n                                             repr_str,\n                                             v,\n                                             negative,\n@@ -122,7 +122,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                             _ => bug!(),\n                         };\n                     }\n-                    ty::TyUint(t) => {\n+                    ty::Uint(t) => {\n                         let uint_type = if let ast::UintTy::Usize = t {\n                             cx.sess().target.usize_ty\n                         } else {\n@@ -139,7 +139,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                             let parent_id = cx.tcx.hir.get_parent_node(e.id);\n                             if let hir_map::NodeExpr(parent_expr) = cx.tcx.hir.get(parent_id) {\n                                 if let hir::ExprKind::Cast(..) = parent_expr.node {\n-                                    if let ty::TyChar = cx.tables.expr_ty(parent_expr).sty {\n+                                    if let ty::Char = cx.tables.expr_ty(parent_expr).sty {\n                                         let mut err = cx.struct_span_lint(\n                                                              OVERFLOWING_LITERALS,\n                                                              parent_expr.span,\n@@ -159,7 +159,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                                 report_bin_hex_error(\n                                     cx,\n                                     e,\n-                                    ty::TyUint(t),\n+                                    ty::Uint(t),\n                                     repr_str,\n                                     lit_val,\n                                     false,\n@@ -173,7 +173,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                             );\n                         }\n                     }\n-                    ty::TyFloat(t) => {\n+                    ty::Float(t) => {\n                         let is_infinite = match lit.node {\n                             ast::LitKind::Float(v, _) |\n                             ast::LitKind::FloatUnsuffixed(v) => {\n@@ -256,7 +256,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n             // the comparison\n             let norm_binop = if swap { rev_binop(binop) } else { binop };\n             match cx.tables.node_id_to_type(expr.hir_id).sty {\n-                ty::TyInt(int_ty) => {\n+                ty::Int(int_ty) => {\n                     let (min, max) = int_ty_range(int_ty);\n                     let lit_val: i128 = match lit.node {\n                         hir::ExprKind::Lit(ref li) => {\n@@ -270,7 +270,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                     };\n                     is_valid(norm_binop, lit_val, min, max)\n                 }\n-                ty::TyUint(uint_ty) => {\n+                ty::Uint(uint_ty) => {\n                     let (min, max) :(u128, u128) = uint_ty_range(uint_ty);\n                     let lit_val: u128 = match lit.node {\n                         hir::ExprKind::Lit(ref li) => {\n@@ -321,7 +321,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n         //\n         // No suggestion for: `isize`, `usize`.\n         fn get_type_suggestion<'a>(\n-            t: &ty::TypeVariants,\n+            t: &ty::TyKind,\n             val: u128,\n             negative: bool,\n         ) -> Option<String> {\n@@ -348,13 +348,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                 }\n             }\n             match t {\n-                &ty::TyInt(i) => find_fit!(i, val, negative,\n+                &ty::Int(i) => find_fit!(i, val, negative,\n                               I8 => [U8] => [I16, I32, I64, I128],\n                               I16 => [U16] => [I32, I64, I128],\n                               I32 => [U32] => [I64, I128],\n                               I64 => [U64] => [I128],\n                               I128 => [U128] => []),\n-                &ty::TyUint(u) => find_fit!(u, val, negative,\n+                &ty::Uint(u) => find_fit!(u, val, negative,\n                               U8 => [U8, U16, U32, U64, U128] => [],\n                               U16 => [U16, U32, U64, U128] => [],\n                               U32 => [U32, U64, U128] => [],\n@@ -367,19 +367,19 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n         fn report_bin_hex_error(\n             cx: &LateContext,\n             expr: &hir::Expr,\n-            ty: ty::TypeVariants,\n+            ty: ty::TyKind,\n             repr_str: String,\n             val: u128,\n             negative: bool,\n         ) {\n             let (t, actually) = match ty {\n-                ty::TyInt(t) => {\n+                ty::Int(t) => {\n                     let ity = attr::IntType::SignedInt(t);\n                     let bits = layout::Integer::from_attr(cx.tcx, ity).size().bits();\n                     let actually = (val << (128 - bits)) as i128 >> (128 - bits);\n                     (format!(\"{:?}\", t), actually.to_string())\n                 }\n-                ty::TyUint(t) => {\n+                ty::Uint(t) => {\n                     let ity = attr::IntType::UnsignedInt(t);\n                     let bits = layout::Integer::from_attr(cx.tcx, ity).size().bits();\n                     let actually = (val << (128 - bits)) >> (128 - bits);\n@@ -460,10 +460,10 @@ fn is_repr_nullable_ptr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         if def.variants[data_idx].fields.len() == 1 {\n             match def.variants[data_idx].fields[0].ty(tcx, substs).sty {\n-                ty::TyFnPtr(_) => {\n+                ty::FnPtr(_) => {\n                     return true;\n                 }\n-                ty::TyRef(..) => {\n+                ty::Ref(..) => {\n                     return true;\n                 }\n                 _ => {}\n@@ -492,7 +492,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         }\n \n         match ty.sty {\n-            ty::TyAdt(def, substs) => {\n+            ty::Adt(def, substs) => {\n                 if def.is_phantom_data() {\n                     return FfiPhantom(ty);\n                 }\n@@ -633,51 +633,51 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 }\n             }\n \n-            ty::TyChar => FfiUnsafe {\n+            ty::Char => FfiUnsafe {\n                 ty: ty,\n                 reason: \"the `char` type has no C equivalent\",\n                 help: Some(\"consider using `u32` or `libc::wchar_t` instead\"),\n             },\n \n-            ty::TyInt(ast::IntTy::I128) | ty::TyUint(ast::UintTy::U128) => FfiUnsafe {\n+            ty::Int(ast::IntTy::I128) | ty::Uint(ast::UintTy::U128) => FfiUnsafe {\n                 ty: ty,\n                 reason: \"128-bit integers don't currently have a known stable ABI\",\n                 help: None,\n             },\n \n             // Primitive types with a stable representation.\n-            ty::TyBool | ty::TyInt(..) | ty::TyUint(..) | ty::TyFloat(..) | ty::TyNever => FfiSafe,\n+            ty::Bool | ty::Int(..) | ty::Uint(..) | ty::Float(..) | ty::Never => FfiSafe,\n \n-            ty::TySlice(_) => FfiUnsafe {\n+            ty::Slice(_) => FfiUnsafe {\n                 ty: ty,\n                 reason: \"slices have no C equivalent\",\n                 help: Some(\"consider using a raw pointer instead\"),\n             },\n \n-            ty::TyDynamic(..) => FfiUnsafe {\n+            ty::Dynamic(..) => FfiUnsafe {\n                 ty: ty,\n                 reason: \"trait objects have no C equivalent\",\n                 help: None,\n             },\n \n-            ty::TyStr => FfiUnsafe {\n+            ty::Str => FfiUnsafe {\n                 ty: ty,\n                 reason: \"string slices have no C equivalent\",\n                 help: Some(\"consider using `*const u8` and a length instead\"),\n             },\n \n-            ty::TyTuple(..) => FfiUnsafe {\n+            ty::Tuple(..) => FfiUnsafe {\n                 ty: ty,\n                 reason: \"tuples have unspecified layout\",\n                 help: Some(\"consider using a struct instead\"),\n             },\n \n-            ty::TyRawPtr(ty::TypeAndMut { ty, .. }) |\n-            ty::TyRef(_, ty, _) => self.check_type_for_ffi(cache, ty),\n+            ty::RawPtr(ty::TypeAndMut { ty, .. }) |\n+            ty::Ref(_, ty, _) => self.check_type_for_ffi(cache, ty),\n \n-            ty::TyArray(ty, _) => self.check_type_for_ffi(cache, ty),\n+            ty::Array(ty, _) => self.check_type_for_ffi(cache, ty),\n \n-            ty::TyFnPtr(sig) => {\n+            ty::FnPtr(sig) => {\n                 match sig.abi() {\n                     Abi::Rust | Abi::RustIntrinsic | Abi::PlatformIntrinsic | Abi::RustCall => {\n                         return FfiUnsafe {\n@@ -712,17 +712,17 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 FfiSafe\n             }\n \n-            ty::TyForeign(..) => FfiSafe,\n-\n-            ty::TyParam(..) |\n-            ty::TyInfer(..) |\n-            ty::TyError |\n-            ty::TyClosure(..) |\n-            ty::TyGenerator(..) |\n-            ty::TyGeneratorWitness(..) |\n-            ty::TyProjection(..) |\n-            ty::TyAnon(..) |\n-            ty::TyFnDef(..) => bug!(\"Unexpected type in foreign function\"),\n+            ty::Foreign(..) => FfiSafe,\n+\n+            ty::Param(..) |\n+            ty::Infer(..) |\n+            ty::Error |\n+            ty::Closure(..) |\n+            ty::Generator(..) |\n+            ty::GeneratorWitness(..) |\n+            ty::Projection(..) |\n+            ty::Anon(..) |\n+            ty::FnDef(..) => bug!(\"Unexpected type in foreign function\"),\n         }\n     }\n \n@@ -746,7 +746,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 if let Some(s) = help {\n                     diag.help(s);\n                 }\n-                if let ty::TyAdt(def, _) = unsafe_ty.sty {\n+                if let ty::Adt(def, _) = unsafe_ty.sty {\n                     if let Some(sp) = self.cx.tcx.hir.span_if_local(def.did) {\n                         diag.span_note(sp, \"type defined here\");\n                     }"}, {"sha": "7a9d18676cf6c9d2e405a819d4de8aeaea599fd6", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -60,9 +60,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n \n         let t = cx.tables.expr_ty(&expr);\n         let ty_warned = match t.sty {\n-            ty::TyTuple(ref tys) if tys.is_empty() => return,\n-            ty::TyNever => return,\n-            ty::TyAdt(def, _) => {\n+            ty::Tuple(ref tys) if tys.is_empty() => return,\n+            ty::Never => return,\n+            ty::Adt(def, _) => {\n                 if def.variants.is_empty() {\n                     return;\n                 } else {"}, {"sha": "f1e7e3de67d049b15b8d3f2c4bc82cec6e00e3f5", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -429,7 +429,7 @@ impl<'tcx> EntryKind<'tcx> {\n             EntryKind::Trait(_) => Def::Trait(did),\n             EntryKind::Enum(..) => Def::Enum(did),\n             EntryKind::MacroDef(_) => Def::Macro(did, MacroKind::Bang),\n-            EntryKind::ForeignType => Def::TyForeign(did),\n+            EntryKind::ForeignType => Def::ForeignTy(did),\n \n             EntryKind::ForeignMod |\n             EntryKind::GlobalAsm |"}, {"sha": "44d8d4a727769906b75d0430071a31d96fbcecf4", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -1342,15 +1342,15 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n         let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n         let kind = match tables.node_id_to_type(hir_id).sty {\n-            ty::TyGenerator(def_id, ..) => {\n+            ty::Generator(def_id, ..) => {\n                 let layout = self.tcx.generator_layout(def_id);\n                 let data = GeneratorData {\n                     layout: layout.clone(),\n                 };\n                 EntryKind::Generator(self.lazy(&data))\n             }\n \n-            ty::TyClosure(def_id, substs) => {\n+            ty::Closure(def_id, substs) => {\n                 let sig = substs.closure_sig(def_id, self.tcx);\n                 let data = ClosureData { sig: self.lazy(&sig) };\n                 EntryKind::Closure(self.lazy(&data))\n@@ -1865,7 +1865,7 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n pub fn get_repr_options<'a, 'tcx, 'gcx>(tcx: &TyCtxt<'a, 'tcx, 'gcx>, did: DefId) -> ReprOptions {\n     let ty = tcx.type_of(did);\n     match ty.sty {\n-        ty::TyAdt(ref def, _) => return def.repr,\n+        ty::Adt(ref def, _) => return def.repr,\n         _ => bug!(\"{} is not an ADT\", ty),\n     }\n }"}, {"sha": "f1df135f7ee8357a4bd05bc294b4c53d6523fe93", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -134,7 +134,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             if let Some(ty) = self.retrieve_type_for_place(place) {\n                 let needs_note = match ty.sty {\n-                    ty::TypeVariants::TyClosure(id, _) => {\n+                    ty::Closure(id, _) => {\n                         let tables = self.tcx.typeck_tables_of(id);\n                         let node_id = self.tcx.hir.as_local_node_id(id).unwrap();\n                         let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n@@ -834,19 +834,19 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             self.describe_field_from_ty(&ty.boxed_ty(), field)\n         } else {\n             match ty.sty {\n-                ty::TyAdt(def, _) => if def.is_enum() {\n+                ty::Adt(def, _) => if def.is_enum() {\n                     field.index().to_string()\n                 } else {\n                     def.non_enum_variant().fields[field.index()]\n                         .ident\n                         .to_string()\n                 },\n-                ty::TyTuple(_) => field.index().to_string(),\n-                ty::TyRef(_, ty, _) | ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n+                ty::Tuple(_) => field.index().to_string(),\n+                ty::Ref(_, ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n                     self.describe_field_from_ty(&ty, field)\n                 }\n-                ty::TyArray(ty, _) | ty::TySlice(ty) => self.describe_field_from_ty(&ty, field),\n-                ty::TyClosure(def_id, _) | ty::TyGenerator(def_id, _, _) => {\n+                ty::Array(ty, _) | ty::Slice(ty) => self.describe_field_from_ty(&ty, field),\n+                ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n                     // Convert the def-id into a node-id. node-ids are only valid for\n                     // the local code in the current crate, so this returns an `Option` in case\n                     // the closure comes from another crate. But in that case we wouldn't"}, {"sha": "f4071e02f558087e9c2a506918a529cb8118c291", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -935,22 +935,22 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             // individual fields instead. This way if `foo` has a\n             // destructor but `bar` does not, we will only check for\n             // borrows of `x.foo` and not `x.bar`. See #47703.\n-            ty::TyAdt(def, substs) if def.is_struct() && !def.has_dtor(self.tcx) => {\n+            ty::Adt(def, substs) if def.is_struct() && !def.has_dtor(self.tcx) => {\n                 def.all_fields()\n                     .map(|field| field.ty(gcx, substs))\n                     .enumerate()\n                     .for_each(|field| drop_field(self, field));\n             }\n             // Same as above, but for tuples.\n-            ty::TyTuple(tys) => {\n+            ty::Tuple(tys) => {\n                 tys.iter()\n                     .cloned()\n                     .enumerate()\n                     .for_each(|field| drop_field(self, field));\n             }\n             // Closures also have disjoint fields, but they are only\n             // directly accessed in the body of the closure.\n-            ty::TyClosure(def, substs)\n+            ty::Closure(def, substs)\n                 if *drop_place == Place::Local(Local::new(1))\n                     && !self.mir.upvar_decls.is_empty() =>\n             {\n@@ -961,7 +961,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n             // Generators also have disjoint fields, but they are only\n             // directly accessed in the body of the generator.\n-            ty::TyGenerator(def, substs, _)\n+            ty::Generator(def, substs, _)\n                 if *drop_place == Place::Local(Local::new(1))\n                     && !self.mir.upvar_decls.is_empty() =>\n             {\n@@ -978,7 +978,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             // the base case below, we would have a Deep Write due to\n             // the box being `needs_drop`, and that Deep Write would\n             // touch `&mut` data in the box.\n-            ty::TyAdt(def, _) if def.is_box() => {\n+            ty::Adt(def, _) if def.is_box() => {\n                 // When/if we add a `&own T` type, this action would\n                 // be like running the destructor of the `&own T`.\n                 // (And the owner of backing storage referenced by the\n@@ -1818,7 +1818,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             // be already initialized\n                             let tcx = self.tcx;\n                             match base.ty(self.mir, tcx).to_ty(tcx).sty {\n-                                ty::TyAdt(def, _) if def.has_dtor(tcx) => {\n+                                ty::Adt(def, _) if def.has_dtor(tcx) => {\n \n                                     // FIXME: analogous code in\n                                     // check_loans.rs first maps\n@@ -2062,7 +2062,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                         // Check the kind of deref to decide\n                         match base_ty.sty {\n-                            ty::TyRef(_, _, mutbl) => {\n+                            ty::Ref(_, _, mutbl) => {\n                                 match mutbl {\n                                     // Shared borrowed data is never mutable\n                                     hir::MutImmutable => Err(place),\n@@ -2086,7 +2086,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     }\n                                 }\n                             }\n-                            ty::TyRawPtr(tnm) => {\n+                            ty::RawPtr(tnm) => {\n                                 match tnm.mutbl {\n                                     // `*const` raw pointers are not mutable\n                                     hir::MutImmutable => return Err(place),"}, {"sha": "497e8e07853fbdb7e3992244b44d4f4b2e949115", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -261,10 +261,10 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                             .any(|p| p.is_upvar_field_projection(self.mir, &self.tcx)\n                                  .is_some());\n                         match ty.sty {\n-                            ty::TyArray(..) | ty::TySlice(..) => self\n+                            ty::Array(..) | ty::Slice(..) => self\n                                 .tcx\n                                 .cannot_move_out_of_interior_noncopy(span, ty, None, origin),\n-                            ty::TyClosure(def_id, closure_substs)\n+                            ty::Closure(def_id, closure_substs)\n                                 if !self.mir.upvar_decls.is_empty() && is_upvar_field_projection\n                             => {\n                                 let closure_kind_ty ="}, {"sha": "f233a17597a5468f5a88d72c4266889640a2e2fe", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -312,26 +312,26 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cg, 'cx, 'tcx, 'gcx> {\n             // individual fields instead. This way if `foo` has a\n             // destructor but `bar` does not, we will only check for\n             // borrows of `x.foo` and not `x.bar`. See #47703.\n-            ty::TyAdt(def, substs) if def.is_struct() && !def.has_dtor(self.infcx.tcx) => {\n+            ty::Adt(def, substs) if def.is_struct() && !def.has_dtor(self.infcx.tcx) => {\n                 def.all_fields()\n                     .map(|field| field.ty(gcx, substs))\n                     .enumerate()\n                     .for_each(|field| drop_field(self, field));\n             }\n             // Same as above, but for tuples.\n-            ty::TyTuple(tys) => {\n+            ty::Tuple(tys) => {\n                 tys.iter().cloned().enumerate()\n                     .for_each(|field| drop_field(self, field));\n             }\n             // Closures and generators also have disjoint fields, but they are only\n             // directly accessed in the body of the closure/generator.\n-            ty::TyGenerator(def, substs, ..)\n+            ty::Generator(def, substs, ..)\n                 if *drop_place == Place::Local(Local::new(1)) && !self.mir.upvar_decls.is_empty()\n             => {\n                 substs.upvar_tys(def, self.infcx.tcx).enumerate()\n                     .for_each(|field| drop_field(self, field));\n             }\n-            ty::TyClosure(def, substs)\n+            ty::Closure(def, substs)\n                 if *drop_place == Place::Local(Local::new(1)) && !self.mir.upvar_decls.is_empty()\n                 => {\n                     substs.upvar_tys(def, self.infcx.tcx).enumerate()"}, {"sha": "6177194ab914d5817d69e9ef1fa0f159b2bb0d6d", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -376,7 +376,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 //     &\n                 //     - let's call the lifetime of this reference `'1`\n                 (\n-                    ty::TyRef(region, referent_ty, _),\n+                    ty::Ref(region, referent_ty, _),\n                     hir::TyKind::Rptr(_lifetime, referent_hir_ty),\n                 ) => {\n                     if region.to_region_vid() == needle_fr {\n@@ -403,7 +403,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n                 // Match up something like `Foo<'1>`\n                 (\n-                    ty::TyAdt(_adt_def, substs),\n+                    ty::Adt(_adt_def, substs),\n                     hir::TyKind::Path(hir::QPath::Resolved(None, path)),\n                 ) => {\n                     if let Some(last_segment) = path.segments.last() {\n@@ -423,16 +423,16 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // The following cases don't have lifetimes, so we\n                 // just worry about trying to match up the rustc type\n                 // with the HIR types:\n-                (ty::TyTuple(elem_tys), hir::TyKind::Tup(elem_hir_tys)) => {\n+                (ty::Tuple(elem_tys), hir::TyKind::Tup(elem_hir_tys)) => {\n                     search_stack.extend(elem_tys.iter().cloned().zip(elem_hir_tys));\n                 }\n \n-                (ty::TySlice(elem_ty), hir::TyKind::Slice(elem_hir_ty))\n-                | (ty::TyArray(elem_ty, _), hir::TyKind::Array(elem_hir_ty, _)) => {\n+                (ty::Slice(elem_ty), hir::TyKind::Slice(elem_hir_ty))\n+                | (ty::Array(elem_ty, _), hir::TyKind::Array(elem_hir_ty, _)) => {\n                     search_stack.push((elem_ty, elem_hir_ty));\n                 }\n \n-                (ty::TyRawPtr(mut_ty), hir::TyKind::Ptr(mut_hir_ty)) => {\n+                (ty::RawPtr(mut_ty), hir::TyKind::Ptr(mut_hir_ty)) => {\n                     search_stack.push((mut_ty.ty, &mut_hir_ty.ty));\n                 }\n "}, {"sha": "2fb5861dff44453d4018d75dea29eddd4e0f9d00", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -37,7 +37,7 @@ use rustc::mir::*;\n use rustc::traits::query::type_op;\n use rustc::traits::query::{Fallible, NoSolution};\n use rustc::ty::fold::TypeFoldable;\n-use rustc::ty::{self, CanonicalTy, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TypeVariants};\n+use rustc::ty::{self, CanonicalTy, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TyKind};\n use rustc_errors::Diagnostic;\n use std::fmt;\n use std::rc::Rc;\n@@ -320,7 +320,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         // constraints on `'a` and `'b`. These constraints\n         // would be lost if we just look at the normalized\n         // value.\n-        if let ty::TyFnDef(def_id, substs) = constant.literal.ty.sty {\n+        if let ty::FnDef(def_id, substs) = constant.literal.ty.sty {\n             let tcx = self.tcx();\n             let type_checker = &mut self.cx;\n \n@@ -483,7 +483,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             }\n             ProjectionElem::Subslice { from, to } => PlaceTy::Ty {\n                 ty: match base_ty.sty {\n-                    ty::TyArray(inner, size) => {\n+                    ty::Array(inner, size) => {\n                         let size = size.unwrap_usize(tcx);\n                         let min_size = (from as u64) + (to as u64);\n                         if let Some(rest_size) = size.checked_sub(min_size) {\n@@ -497,12 +497,12 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                             )\n                         }\n                     }\n-                    ty::TySlice(..) => base_ty,\n+                    ty::Slice(..) => base_ty,\n                     _ => span_mirbug_and_err!(self, place, \"slice of non-array {:?}\", base_ty),\n                 },\n             },\n             ProjectionElem::Downcast(adt_def1, index) => match base_ty.sty {\n-                ty::TyAdt(adt_def, substs) if adt_def.is_enum() && adt_def == adt_def1 => {\n+                ty::Adt(adt_def, substs) if adt_def.is_enum() && adt_def == adt_def1 => {\n                     if index >= adt_def.variants.len() {\n                         PlaceTy::Ty {\n                             ty: span_mirbug_and_err!(\n@@ -578,16 +578,16 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 variant_index,\n             } => (&adt_def.variants[variant_index], substs),\n             PlaceTy::Ty { ty } => match ty.sty {\n-                ty::TyAdt(adt_def, substs) if !adt_def.is_enum() => (&adt_def.variants[0], substs),\n-                ty::TyClosure(def_id, substs) => {\n+                ty::Adt(adt_def, substs) if !adt_def.is_enum() => (&adt_def.variants[0], substs),\n+                ty::Closure(def_id, substs) => {\n                     return match substs.upvar_tys(def_id, tcx).nth(field.index()) {\n                         Some(ty) => Ok(ty),\n                         None => Err(FieldAccessError::OutOfRange {\n                             field_count: substs.upvar_tys(def_id, tcx).count(),\n                         }),\n                     }\n                 }\n-                ty::TyGenerator(def_id, substs, _) => {\n+                ty::Generator(def_id, substs, _) => {\n                     // Try pre-transform fields first (upvars and current state)\n                     if let Some(ty) = substs.pre_transforms_tys(def_id, tcx).nth(field.index()) {\n                         return Ok(ty);\n@@ -602,7 +602,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                         }),\n                     };\n                 }\n-                ty::TyTuple(tys) => {\n+                ty::Tuple(tys) => {\n                     return match tys.get(field.index()) {\n                         Some(&ty) => Ok(ty),\n                         None => Err(FieldAccessError::OutOfRange {\n@@ -917,7 +917,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             } => {\n                 let place_type = place.ty(mir, tcx).to_ty(tcx);\n                 let adt = match place_type.sty {\n-                    TypeVariants::TyAdt(adt, _) if adt.is_enum() => adt,\n+                    TyKind::Adt(adt, _) if adt.is_enum() => adt,\n                     _ => {\n                         span_bug!(\n                             stmt.source_info.span,\n@@ -1032,7 +1032,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 let func_ty = func.ty(mir, tcx);\n                 debug!(\"check_terminator: call, func_ty={:?}\", func_ty);\n                 let sig = match func_ty.sty {\n-                    ty::TyFnDef(..) | ty::TyFnPtr(_) => func_ty.fn_sig(tcx),\n+                    ty::FnDef(..) | ty::FnPtr(_) => func_ty.fn_sig(tcx),\n                     _ => {\n                         span_mirbug!(self, term, \"call to non-function {:?}\", func_ty);\n                         return;\n@@ -1472,7 +1472,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n                 CastKind::ClosureFnPointer => {\n                     let sig = match op.ty(mir, tcx).sty {\n-                        ty::TyClosure(def_id, substs) => {\n+                        ty::Closure(def_id, substs) => {\n                             substs.closure_sig_ty(def_id, tcx).fn_sig(tcx)\n                         }\n                         _ => bug!(),\n@@ -1650,7 +1650,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n                     debug!(\"add_reborrow_constraint - base_ty = {:?}\", base_ty);\n                     match base_ty.sty {\n-                        ty::TyRef(ref_region, _, mutbl) => {\n+                        ty::Ref(ref_region, _, mutbl) => {\n                             constraints.outlives_constraints.push(OutlivesConstraint {\n                                 sup: ref_region.to_region_vid(),\n                                 sub: borrow_region.to_region_vid(),\n@@ -1697,11 +1697,11 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                                 }\n                             }\n                         }\n-                        ty::TyRawPtr(..) => {\n+                        ty::RawPtr(..) => {\n                             // deref of raw pointer, guaranteed to be valid\n                             break;\n                         }\n-                        ty::TyAdt(def, _) if def.is_box() => {\n+                        ty::Adt(def, _) if def.is_box() => {\n                             // deref of `Box`, need the base to be valid - propagate\n                         }\n                         _ => bug!(\"unexpected deref ty {:?} in {:?}\", base_ty, borrowed_place),"}, {"sha": "deb972ee04611058d6bb339bcde1b6f248ec2988", "filename": "src/librustc_mir/borrow_check/nll/type_check/relate_tys.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -36,7 +36,7 @@ pub(super) fn sub_types<'tcx>(\n         ty::Variance::Covariant,\n         locations,\n         borrowck_context,\n-        ty::Slice::empty(),\n+        ty::List::empty(),\n     ).relate(&a, &b)?;\n     Ok(())\n }\n@@ -54,7 +54,7 @@ pub(super) fn eq_types<'tcx>(\n         ty::Variance::Invariant,\n         locations,\n         borrowck_context,\n-        ty::Slice::empty(),\n+        ty::List::empty(),\n     ).relate(&a, &b)?;\n     Ok(())\n }\n@@ -325,7 +325,7 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx>\n     fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n         // Watch out for the case that we are matching a `?T` against the\n         // right-hand side.\n-        if let ty::TyInfer(ty::CanonicalTy(var)) = a.sty {\n+        if let ty::Infer(ty::CanonicalTy(var)) = a.sty {\n             self.equate_var(var, b.into())?;\n             Ok(a)\n         } else {"}, {"sha": "8112b71b127527f1a9d38a1bb67875a840bdcd2e", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -64,7 +64,7 @@ pub struct UniversalRegions<'tcx> {\n \n     /// The \"defining\" type for this function, with all universal\n     /// regions instantiated.  For a closure or generator, this is the\n-    /// closure type, but for a top-level function it's the `TyFnDef`.\n+    /// closure type, but for a top-level function it's the `FnDef`.\n     pub defining_ty: DefiningTy<'tcx>,\n \n     /// The return type of this function, with all regions replaced by\n@@ -437,11 +437,11 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n                     .replace_free_regions_with_nll_infer_vars(FR, &defining_ty);\n \n                 match defining_ty.sty {\n-                    ty::TyClosure(def_id, substs) => DefiningTy::Closure(def_id, substs),\n-                    ty::TyGenerator(def_id, substs, movability) => {\n+                    ty::Closure(def_id, substs) => DefiningTy::Closure(def_id, substs),\n+                    ty::Generator(def_id, substs, movability) => {\n                         DefiningTy::Generator(def_id, substs, movability)\n                     }\n-                    ty::TyFnDef(def_id, substs) => DefiningTy::FnDef(def_id, substs),\n+                    ty::FnDef(def_id, substs) => DefiningTy::FnDef(def_id, substs),\n                     _ => span_bug!(\n                         tcx.def_span(self.mir_def_id),\n                         \"expected defining type for `{:?}`: `{:?}`\",\n@@ -506,7 +506,7 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n         &self,\n         indices: &UniversalRegionIndices<'tcx>,\n         defining_ty: DefiningTy<'tcx>,\n-    ) -> ty::Binder<&'tcx ty::Slice<Ty<'tcx>>> {\n+    ) -> ty::Binder<&'tcx ty::List<Ty<'tcx>>> {\n         let tcx = self.infcx.tcx;\n         match defining_ty {\n             DefiningTy::Closure(def_id, substs) => {\n@@ -524,7 +524,7 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n                         let (&output, tuplized_inputs) = inputs_and_output.split_last().unwrap();\n                         assert_eq!(tuplized_inputs.len(), 1, \"multiple closure inputs\");\n                         let inputs = match tuplized_inputs[0].sty {\n-                            ty::TyTuple(inputs) => inputs,\n+                            ty::Tuple(inputs) => inputs,\n                             _ => bug!(\"closure inputs not a tuple: {:?}\", tuplized_inputs[0]),\n                         };\n "}, {"sha": "2b4a1553e1a893d3054e048105b3b1937493fe03", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -54,7 +54,7 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n                         // original path into a new variable and\n                         // borrowed *that* one, leaving the original\n                         // path unborrowed.\n-                        ty::TyRawPtr(..) | ty::TyRef(_, _, hir::MutImmutable) => true,\n+                        ty::RawPtr(..) | ty::Ref(_, _, hir::MutImmutable) => true,\n                         _ => proj.base.ignore_borrow(tcx, mir),\n                     }\n                 }"}, {"sha": "f791735690922aaf81404a684cad5c3b88e9b7a4", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -170,7 +170,7 @@ fn place_components_conflict<'gcx, 'tcx>(\n                         debug!(\"places_conflict: shallow access behind ptr\");\n                         return false;\n                     }\n-                    (ProjectionElem::Deref, ty::TyRef(_, _, hir::MutImmutable), _) => {\n+                    (ProjectionElem::Deref, ty::Ref(_, _, hir::MutImmutable), _) => {\n                         // the borrow goes through a dereference of a shared reference.\n                         //\n                         // I'm not sure why we are tracking these borrows - shared\n@@ -329,7 +329,7 @@ fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n         }\n         (Place::Promoted(p1), Place::Promoted(p2)) => {\n             if p1.0 == p2.0 {\n-                if let ty::TyArray(_, size) = p1.1.sty {\n+                if let ty::Array(_, size) = p1.1.sty {\n                     if size.unwrap_usize(tcx) == 0 {\n                         // Ignore conflicts with promoted [T; 0].\n                         debug!(\"place_element_conflict: IGNORE-LEN-0-PROMOTED\");\n@@ -366,7 +366,7 @@ fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n                     } else {\n                         let ty = pi1.base.ty(mir, tcx).to_ty(tcx);\n                         match ty.sty {\n-                            ty::TyAdt(def, _) if def.is_union() => {\n+                            ty::Adt(def, _) if def.is_union() => {\n                                 // Different fields of a union, we are basically stuck.\n                                 debug!(\"place_element_conflict: STUCK-UNION\");\n                                 Overlap::Arbitrary"}, {"sha": "8dcc1143306212079b1b8178a4254c4da22bc9ba", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -155,8 +155,8 @@ impl<'cx, 'gcx, 'tcx> Iterator for Prefixes<'cx, 'gcx, 'tcx> {\n \n             let ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n             match ty.sty {\n-                ty::TyRawPtr(_) |\n-                ty::TyRef(\n+                ty::RawPtr(_) |\n+                ty::Ref(\n                     _, /*rgn*/\n                     _, /*ty*/\n                     hir::MutImmutable\n@@ -166,7 +166,7 @@ impl<'cx, 'gcx, 'tcx> Iterator for Prefixes<'cx, 'gcx, 'tcx> {\n                     return Some(cursor);\n                 }\n \n-                ty::TyRef(\n+                ty::Ref(\n                     _, /*rgn*/\n                     _, /*ty*/\n                     hir::MutMutable,\n@@ -175,7 +175,7 @@ impl<'cx, 'gcx, 'tcx> Iterator for Prefixes<'cx, 'gcx, 'tcx> {\n                     return Some(cursor);\n                 }\n \n-                ty::TyAdt(..) if ty.is_box() => {\n+                ty::Adt(..) if ty.is_box() => {\n                     self.next = Some(&proj.base);\n                     return Some(cursor);\n                 }"}, {"sha": "2b05e2c023a5c7295cf359984a1a498896705bbf", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -216,7 +216,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // FIXME(canndrew): This is_never should probably be an is_uninhabited\n                 let diverges = expr.ty.is_never();\n                 let intrinsic = match ty.sty {\n-                    ty::TyFnDef(def_id, _)  => {\n+                    ty::FnDef(def_id, _)  => {\n                         let f = ty.fn_sig(this.hir.tcx());\n                         if f.abi() == Abi::RustIntrinsic ||\n                            f.abi() == Abi::PlatformIntrinsic {"}, {"sha": "15a983635f7ae6992dc40f141e3b8c1abdaf75c0", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -227,7 +227,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n \n             TestKind::SwitchInt { switch_ty, ref options, indices: _ } => {\n-                let (ret, terminator) = if switch_ty.sty == ty::TyBool {\n+                let (ret, terminator) = if switch_ty.sty == ty::Bool {\n                     assert!(options.len() > 0 && options.len() <= 2);\n                     let (true_bb, false_bb) = (self.cfg.start_new_block(),\n                                                self.cfg.start_new_block());\n@@ -272,8 +272,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     // array, so we can call `<[u8]>::eq` rather than having to find an\n                     // `<[u8; N]>::eq`.\n                     let unsize = |ty: Ty<'tcx>| match ty.sty {\n-                        ty::TyRef(region, rty, _) => match rty.sty {\n-                            ty::TyArray(inner_ty, n) => Some((region, inner_ty, n)),\n+                        ty::Ref(region, rty, _) => match rty.sty {\n+                            ty::Array(inner_ty, n) => Some((region, inner_ty, n)),\n                             _ => None,\n                         },\n                         _ => None,"}, {"sha": "179bc2426ab4a2e2a4911b82bfbfec47e1eff571", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -67,13 +67,13 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n             let ty = tcx.type_of(tcx.hir.local_def_id(id));\n             let mut abi = fn_sig.abi;\n             let implicit_argument = match ty.sty {\n-                ty::TyClosure(..) => {\n+                ty::Closure(..) => {\n                     // HACK(eddyb) Avoid having RustCall on closures,\n                     // as it adds unnecessary (and wrong) auto-tupling.\n                     abi = Abi::Rust;\n                     Some(ArgInfo(liberated_closure_env_ty(tcx, id, body_id), None, None, None))\n                 }\n-                ty::TyGenerator(..) => {\n+                ty::Generator(..) => {\n                     let gen_ty = tcx.body_tables(body_id).node_id_to_type(fn_hir_id);\n                     Some(ArgInfo(gen_ty, None, None, None))\n                 }\n@@ -115,7 +115,7 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n \n             let (yield_ty, return_ty) = if body.is_generator {\n                 let gen_sig = match ty.sty {\n-                    ty::TyGenerator(gen_def_id, gen_substs, ..) =>\n+                    ty::Generator(gen_def_id, gen_substs, ..) =>\n                         gen_substs.sig(gen_def_id, tcx),\n                     _ =>\n                         span_bug!(tcx.hir.span(id), \"generator w/o generator type: {:?}\", ty),\n@@ -241,7 +241,7 @@ fn liberated_closure_env_ty<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     let closure_ty = tcx.body_tables(body_id).node_id_to_type(closure_expr_hir_id);\n \n     let (closure_def_id, closure_substs) = match closure_ty.sty {\n-        ty::TyClosure(closure_def_id, closure_substs) => (closure_def_id, closure_substs),\n+        ty::Closure(closure_def_id, closure_substs) => (closure_def_id, closure_substs),\n         _ => bug!(\"closure expr does not have closure type: {:?}\", closure_ty)\n     };\n "}, {"sha": "7af1daae4cad50602142cbab1a96dc5a80725102", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -61,17 +61,17 @@ fn place_contents_drop_state_cannot_differ<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx,\n                                                             place: &mir::Place<'tcx>) -> bool {\n     let ty = place.ty(mir, tcx).to_ty(tcx);\n     match ty.sty {\n-        ty::TyArray(..) => {\n+        ty::Array(..) => {\n             debug!(\"place_contents_drop_state_cannot_differ place: {:?} ty: {:?} => false\",\n                    place, ty);\n             false\n         }\n-        ty::TySlice(..) | ty::TyRef(..) | ty::TyRawPtr(..) => {\n+        ty::Slice(..) | ty::Ref(..) | ty::RawPtr(..) => {\n             debug!(\"place_contents_drop_state_cannot_differ place: {:?} ty: {:?} refd => true\",\n                    place, ty);\n             true\n         }\n-        ty::TyAdt(def, _) if (def.has_dtor(tcx) && !def.is_box()) || def.is_union() => {\n+        ty::Adt(def, _) if (def.has_dtor(tcx) && !def.is_box()) || def.is_union() => {\n             debug!(\"place_contents_drop_state_cannot_differ place: {:?} ty: {:?} Drop => true\",\n                    place, ty);\n             true"}, {"sha": "2148363c79712ee7ab17c0ae86c5cfaaef903491", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -134,19 +134,19 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n         let tcx = self.builder.tcx;\n         let place_ty = proj.base.ty(mir, tcx).to_ty(tcx);\n         match place_ty.sty {\n-            ty::TyRef(..) | ty::TyRawPtr(..) =>\n+            ty::Ref(..) | ty::RawPtr(..) =>\n                 return Err(MoveError::cannot_move_out_of(\n                     self.loc,\n                     BorrowedContent { target_place: place.clone() })),\n-            ty::TyAdt(adt, _) if adt.has_dtor(tcx) && !adt.is_box() =>\n+            ty::Adt(adt, _) if adt.has_dtor(tcx) && !adt.is_box() =>\n                 return Err(MoveError::cannot_move_out_of(self.loc,\n                                                          InteriorOfTypeWithDestructor {\n                     container_ty: place_ty\n                 })),\n             // move out of union - always move the entire union\n-            ty::TyAdt(adt, _) if adt.is_union() =>\n+            ty::Adt(adt, _) if adt.is_union() =>\n                 return Err(MoveError::UnionMove { path: base }),\n-            ty::TySlice(_) =>\n+            ty::Slice(_) =>\n                 return Err(MoveError::cannot_move_out_of(\n                     self.loc,\n                     InteriorOfSliceOrArray {\n@@ -155,7 +155,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n                             _ => false\n                         },\n                     })),\n-            ty::TyArray(..) => match proj.elem {\n+            ty::Array(..) => match proj.elem {\n                 ProjectionElem::Index(..) =>\n                     return Err(MoveError::cannot_move_out_of(\n                         self.loc,"}, {"sha": "04a3b5c115f22ae44b96f84abaaef4273cc0ee01", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -284,7 +284,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         hir::ExprKind::AddrOf(mutbl, ref expr) => {\n             let region = match expr_ty.sty {\n-                ty::TyRef(r, _, _) => r,\n+                ty::Ref(r, _, _) => r,\n                 _ => span_bug!(expr.span, \"type of & not region\"),\n             };\n             ExprKind::Borrow {\n@@ -418,7 +418,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         hir::ExprKind::Struct(ref qpath, ref fields, ref base) => {\n             match expr_ty.sty {\n-                ty::TyAdt(adt, substs) => {\n+                ty::Adt(adt, substs) => {\n                     match adt.adt_kind() {\n                         AdtKind::Struct | AdtKind::Union => {\n                             ExprKind::Adt {\n@@ -472,8 +472,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprKind::Closure(..) => {\n             let closure_ty = cx.tables().expr_ty(expr);\n             let (def_id, substs, movability) = match closure_ty.sty {\n-                ty::TyClosure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs), None),\n-                ty::TyGenerator(def_id, substs, movability) => {\n+                ty::Closure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs), None),\n+                ty::Generator(def_id, substs, movability) => {\n                     (def_id, UpvarSubsts::Generator(substs), Some(movability))\n                 }\n                 _ => {\n@@ -775,7 +775,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             match cx.tables().node_id_to_type(expr.hir_id).sty {\n                 // A unit struct/variant which is used as a value.\n                 // We return a completely different ExprKind here to account for this special case.\n-                ty::TyAdt(adt_def, substs) => {\n+                ty::Adt(adt_def, substs) => {\n                     ExprKind::Adt {\n                         adt_def,\n                         variant_index: adt_def.variant_index_with_id(def_id),\n@@ -827,7 +827,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             });\n             let region = cx.tcx.mk_region(region);\n \n-            let self_expr = if let ty::TyClosure(_, closure_substs) = closure_ty.sty {\n+            let self_expr = if let ty::Closure(_, closure_substs) = closure_ty.sty {\n                 match cx.infcx.closure_kind(closure_def_id, closure_substs).unwrap() {\n                     ty::ClosureKind::Fn => {\n                         let ref_closure_ty = cx.tcx.mk_ref(region,\n@@ -977,7 +977,7 @@ fn overloaded_place<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     // same region and mutability as the receiver. This holds for\n     // `Deref(Mut)::Deref(_mut)` and `Index(Mut)::index(_mut)`.\n     let (region, mutbl) = match recv_ty.sty {\n-        ty::TyRef(region, _, mutbl) => (region, mutbl),\n+        ty::Ref(region, _, mutbl) => (region, mutbl),\n         _ => span_bug!(expr.span, \"overloaded_place: receiver is not a reference\"),\n     };\n     let ref_ty = cx.tcx.mk_ref(region, ty::TypeAndMut {"}, {"sha": "ef21348cd3ca1347dec536ab67b38a8bf6a237f8", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -188,7 +188,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             }\n             LitKind::FloatUnsuffixed(n) => {\n                 let fty = match ty.sty {\n-                    ty::TyFloat(fty) => fty,\n+                    ty::Float(fty) => fty,\n                     _ => bug!()\n                 };\n                 parse_float(n, fty)"}, {"sha": "e9d65caf08743ac486b4624c8b3d516e53af04da", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -206,7 +206,7 @@ struct LiteralExpander;\n impl<'tcx> PatternFolder<'tcx> for LiteralExpander {\n     fn fold_pattern(&mut self, pat: &Pattern<'tcx>) -> Pattern<'tcx> {\n         match (&pat.ty.sty, &*pat.kind) {\n-            (&ty::TyRef(_, rty, _), &PatternKind::Constant { ref value }) => {\n+            (&ty::Ref(_, rty, _), &PatternKind::Constant { ref value }) => {\n                 Pattern {\n                     ty: pat.ty,\n                     span: pat.span,\n@@ -381,14 +381,14 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n \n     fn is_non_exhaustive_enum(&self, ty: Ty<'tcx>) -> bool {\n         match ty.sty {\n-            ty::TyAdt(adt_def, ..) => adt_def.is_enum() && adt_def.is_non_exhaustive(),\n+            ty::Adt(adt_def, ..) => adt_def.is_enum() && adt_def.is_non_exhaustive(),\n             _ => false,\n         }\n     }\n \n     fn is_local(&self, ty: Ty<'tcx>) -> bool {\n         match ty.sty {\n-            ty::TyAdt(adt_def, ..) => adt_def.did.is_local(),\n+            ty::Adt(adt_def, ..) => adt_def.did.is_local(),\n             _ => false,\n         }\n     }\n@@ -548,16 +548,16 @@ impl<'tcx> Witness<'tcx> {\n             let mut pats = self.0.drain((len - arity) as usize..).rev();\n \n             match ty.sty {\n-                ty::TyAdt(..) |\n-                ty::TyTuple(..) => {\n+                ty::Adt(..) |\n+                ty::Tuple(..) => {\n                     let pats = pats.enumerate().map(|(i, p)| {\n                         FieldPattern {\n                             field: Field::new(i),\n                             pattern: p\n                         }\n                     }).collect();\n \n-                    if let ty::TyAdt(adt, substs) = ty.sty {\n+                    if let ty::Adt(adt, substs) = ty.sty {\n                         if adt.is_enum() {\n                             PatternKind::Variant {\n                                 adt_def: adt,\n@@ -573,11 +573,11 @@ impl<'tcx> Witness<'tcx> {\n                     }\n                 }\n \n-                ty::TyRef(..) => {\n+                ty::Ref(..) => {\n                     PatternKind::Deref { subpattern: pats.nth(0).unwrap() }\n                 }\n \n-                ty::TySlice(_) | ty::TyArray(..) => {\n+                ty::Slice(_) | ty::Array(..) => {\n                     PatternKind::Slice {\n                         prefix: pats.collect(),\n                         slice: None,\n@@ -619,12 +619,12 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     debug!(\"all_constructors({:?})\", pcx.ty);\n     let exhaustive_integer_patterns = cx.tcx.features().exhaustive_integer_patterns;\n     let ctors = match pcx.ty.sty {\n-        ty::TyBool => {\n+        ty::Bool => {\n             [true, false].iter().map(|&b| {\n                 ConstantValue(ty::Const::from_bool(cx.tcx, b))\n             }).collect()\n         }\n-        ty::TyArray(ref sub_ty, len) if len.assert_usize(cx.tcx).is_some() => {\n+        ty::Array(ref sub_ty, len) if len.assert_usize(cx.tcx).is_some() => {\n             let len = len.unwrap_usize(cx.tcx);\n             if len != 0 && cx.is_uninhabited(sub_ty) {\n                 vec![]\n@@ -633,21 +633,21 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n             }\n         }\n         // Treat arrays of a constant but unknown length like slices.\n-        ty::TyArray(ref sub_ty, _) |\n-        ty::TySlice(ref sub_ty) => {\n+        ty::Array(ref sub_ty, _) |\n+        ty::Slice(ref sub_ty) => {\n             if cx.is_uninhabited(sub_ty) {\n                 vec![Slice(0)]\n             } else {\n                 (0..pcx.max_slice_length+1).map(|length| Slice(length)).collect()\n             }\n         }\n-        ty::TyAdt(def, substs) if def.is_enum() => {\n+        ty::Adt(def, substs) if def.is_enum() => {\n             def.variants.iter()\n                 .filter(|v| !cx.is_variant_uninhabited(v, substs))\n                 .map(|v| Variant(v.did))\n                 .collect()\n         }\n-        ty::TyChar if exhaustive_integer_patterns => {\n+        ty::Char if exhaustive_integer_patterns => {\n             let endpoint = |c: char| {\n                 let ty = ty::ParamEnv::empty().and(cx.tcx.types.char);\n                 ty::Const::from_bits(cx.tcx, c as u128, ty)\n@@ -658,7 +658,7 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                 ConstantRange(endpoint('\\u{E000}'), endpoint('\\u{10FFFF}'), RangeEnd::Included),\n             ]\n         }\n-        ty::TyInt(ity) if exhaustive_integer_patterns => {\n+        ty::Int(ity) if exhaustive_integer_patterns => {\n             // FIXME(49937): refactor these bit manipulations into interpret.\n             let bits = Integer::from_attr(cx.tcx, SignedInt(ity)).size().bits() as u128;\n             let min = 1u128 << (bits - 1);\n@@ -668,7 +668,7 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                                ty::Const::from_bits(cx.tcx, max as u128, ty),\n                                RangeEnd::Included)]\n         }\n-        ty::TyUint(uty) if exhaustive_integer_patterns => {\n+        ty::Uint(uty) if exhaustive_integer_patterns => {\n             // FIXME(49937): refactor these bit manipulations into interpret.\n             let bits = Integer::from_attr(cx.tcx, UnsignedInt(uty)).size().bits() as u128;\n             let max = !0u128 >> (128 - bits);\n@@ -861,7 +861,7 @@ impl<'tcx> IntRange<'tcx> {\n     // The return value of `signed_bias` should be XORed with an endpoint to encode/decode it.\n     fn signed_bias(tcx: TyCtxt<'_, 'tcx, 'tcx>, ty: Ty<'tcx>) -> u128 {\n         match ty.sty {\n-            ty::TyInt(ity) => {\n+            ty::Int(ity) => {\n                 let bits = Integer::from_attr(tcx, SignedInt(ity)).size().bits() as u128;\n                 1u128 << (bits - 1)\n             }\n@@ -1243,7 +1243,7 @@ fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt,\n         PatternKind::Constant { value } => Some(vec![ConstantValue(value)]),\n         PatternKind::Range { lo, hi, end } => Some(vec![ConstantRange(lo, hi, end)]),\n         PatternKind::Array { .. } => match pcx.ty.sty {\n-            ty::TyArray(_, length) => Some(vec![\n+            ty::Array(_, length) => Some(vec![\n                 Slice(length.unwrap_usize(cx.tcx))\n             ]),\n             _ => span_bug!(pat.span, \"bad ty {:?} for array pattern\", pcx.ty)\n@@ -1267,14 +1267,14 @@ fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt,\n fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> u64 {\n     debug!(\"constructor_arity({:#?}, {:?})\", ctor, ty);\n     match ty.sty {\n-        ty::TyTuple(ref fs) => fs.len() as u64,\n-        ty::TySlice(..) | ty::TyArray(..) => match *ctor {\n+        ty::Tuple(ref fs) => fs.len() as u64,\n+        ty::Slice(..) | ty::Array(..) => match *ctor {\n             Slice(length) => length,\n             ConstantValue(_) => 0,\n             _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty)\n         },\n-        ty::TyRef(..) => 1,\n-        ty::TyAdt(adt, _) => {\n+        ty::Ref(..) => 1,\n+        ty::Adt(adt, _) => {\n             adt.variants[ctor.variant_index_for_adt(adt)].fields.len() as u64\n         }\n         _ => 0\n@@ -1291,14 +1291,14 @@ fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n {\n     debug!(\"constructor_sub_pattern_tys({:#?}, {:?})\", ctor, ty);\n     match ty.sty {\n-        ty::TyTuple(ref fs) => fs.into_iter().map(|t| *t).collect(),\n-        ty::TySlice(ty) | ty::TyArray(ty, _) => match *ctor {\n+        ty::Tuple(ref fs) => fs.into_iter().map(|t| *t).collect(),\n+        ty::Slice(ty) | ty::Array(ty, _) => match *ctor {\n             Slice(length) => (0..length).map(|_| ty).collect(),\n             ConstantValue(_) => vec![],\n             _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty)\n         },\n-        ty::TyRef(_, rty, _) => vec![rty],\n-        ty::TyAdt(adt, substs) => {\n+        ty::Ref(_, rty, _) => vec![rty],\n+        ty::Adt(adt, substs) => {\n             if adt.is_box() {\n                 // Use T as the sub pattern type of Box<T>.\n                 vec![substs.type_at(0)]\n@@ -1382,7 +1382,7 @@ fn slice_pat_covered_by_constructor<'tcx>(\n fn should_treat_range_exhaustively(tcx: TyCtxt<'_, 'tcx, 'tcx>, ctor: &Constructor<'tcx>) -> bool {\n     if tcx.features().exhaustive_integer_patterns {\n         if let ConstantValue(value) | ConstantRange(value, _, _) = ctor {\n-            if let ty::TyChar | ty::TyInt(_) | ty::TyUint(_) = value.ty.sty {\n+            if let ty::Char | ty::Int(_) | ty::Uint(_) = value.ty.sty {\n                 return true;\n             }\n         }"}, {"sha": "604cc61a17ecb17073f104a7eb8167793291ddc4", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -258,8 +258,8 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n     fn conservative_is_uninhabited(&self, scrutinee_ty: Ty<'tcx>) -> bool {\n         // \"rustc-1.0-style\" uncontentious uninhabitableness check\n         match scrutinee_ty.sty {\n-            ty::TyNever => true,\n-            ty::TyAdt(def, _) => def.variants.is_empty(),\n+            ty::Never => true,\n+            ty::Adt(def, _) => def.variants.is_empty(),\n             _ => false\n         }\n     }\n@@ -315,7 +315,7 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchVisitor, pat: &Pat) {\n                     return true;\n                 }\n                 let pat_ty = cx.tables.pat_ty(p);\n-                if let ty::TyAdt(edef, _) = pat_ty.sty {\n+                if let ty::Adt(edef, _) = pat_ty.sty {\n                     if edef.is_enum() && edef.variants.iter().any(|variant| {\n                         variant.name == ident.name && variant.ctor_kind == CtorKind::Const\n                     }) {"}, {"sha": "384ee0079dc84c70ec55b11169a9a8e63d18a143", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -148,7 +148,7 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n                     PatternKind::Variant { adt_def, variant_index, .. } => {\n                         Some(&adt_def.variants[variant_index])\n                     }\n-                    _ => if let ty::TyAdt(adt, _) = self.ty.sty {\n+                    _ => if let ty::Adt(adt, _) = self.ty.sty {\n                         if !adt.is_enum() {\n                             Some(&adt.variants[0])\n                         } else {\n@@ -165,7 +165,7 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n                 if let Some(variant) = variant {\n                     write!(f, \"{}\", variant.name)?;\n \n-                    // Only for TyAdt we can have `S {...}`,\n+                    // Only for Adt we can have `S {...}`,\n                     // which we handle separately here.\n                     if variant.ctor_kind == CtorKind::Fictive {\n                         write!(f, \" {{ \")?;\n@@ -216,8 +216,8 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n             }\n             PatternKind::Deref { ref subpattern } => {\n                 match self.ty.sty {\n-                    ty::TyAdt(def, _) if def.is_box() => write!(f, \"box \")?,\n-                    ty::TyRef(_, _, mutbl) => {\n+                    ty::Adt(def, _) if def.is_box() => write!(f, \"box \")?,\n+                    ty::Ref(_, _, mutbl) => {\n                         write!(f, \"&\")?;\n                         if mutbl == hir::MutMutable {\n                             write!(f, \"mut \")?;\n@@ -413,7 +413,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n             PatKind::Slice(ref prefix, ref slice, ref suffix) => {\n                 match ty.sty {\n-                    ty::TyRef(_, ty, _) =>\n+                    ty::Ref(_, ty, _) =>\n                         PatternKind::Deref {\n                             subpattern: Pattern {\n                                 ty,\n@@ -422,10 +422,10 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                                     pat.span, ty, prefix, slice, suffix))\n                             },\n                         },\n-                    ty::TySlice(..) |\n-                    ty::TyArray(..) =>\n+                    ty::Slice(..) |\n+                    ty::Array(..) =>\n                         self.slice_or_array_pattern(pat.span, ty, prefix, slice, suffix),\n-                    ty::TyError => { // Avoid ICE\n+                    ty::Error => { // Avoid ICE\n                         return Pattern { span: pat.span, ty, kind: Box::new(PatternKind::Wild) };\n                     }\n                     ref sty =>\n@@ -438,7 +438,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n             PatKind::Tuple(ref subpatterns, ddpos) => {\n                 match ty.sty {\n-                    ty::TyTuple(ref tys) => {\n+                    ty::Tuple(ref tys) => {\n                         let subpatterns =\n                             subpatterns.iter()\n                                        .enumerate_and_adjust(tys.len(), ddpos)\n@@ -450,7 +450,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n                         PatternKind::Leaf { subpatterns: subpatterns }\n                     }\n-                    ty::TyError => { // Avoid ICE (#50577)\n+                    ty::Error => { // Avoid ICE (#50577)\n                         return Pattern { span: pat.span, ty, kind: Box::new(PatternKind::Wild) };\n                     }\n                     ref sty => span_bug!(pat.span, \"unexpected type for tuple pattern: {:?}\", sty),\n@@ -460,8 +460,8 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             PatKind::Binding(_, id, ident, ref sub) => {\n                 let var_ty = self.tables.node_id_to_type(pat.hir_id);\n                 let region = match var_ty.sty {\n-                    ty::TyRef(r, _, _) => Some(r),\n-                    ty::TyError => { // Avoid ICE\n+                    ty::Ref(r, _, _) => Some(r),\n+                    ty::Error => { // Avoid ICE\n                         return Pattern { span: pat.span, ty, kind: Box::new(PatternKind::Wild) };\n                     }\n                     _ => None,\n@@ -484,7 +484,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 // A ref x pattern is the same node used for x, and as such it has\n                 // x's type, which is &T, where we want T (the type being matched).\n                 if let ty::BindByReference(_) = bm {\n-                    if let ty::TyRef(_, rty, _) = ty.sty {\n+                    if let ty::Ref(_, rty, _) = ty.sty {\n                         ty = rty;\n                     } else {\n                         bug!(\"`ref {}` has wrong type {}\", ident, ty);\n@@ -504,8 +504,8 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             PatKind::TupleStruct(ref qpath, ref subpatterns, ddpos) => {\n                 let def = self.tables.qpath_def(qpath, pat.hir_id);\n                 let adt_def = match ty.sty {\n-                    ty::TyAdt(adt_def, _) => adt_def,\n-                    ty::TyError => { // Avoid ICE (#50585)\n+                    ty::Adt(adt_def, _) => adt_def,\n+                    ty::Error => { // Avoid ICE (#50585)\n                         return Pattern { span: pat.span, ty, kind: Box::new(PatternKind::Wild) };\n                     }\n                     _ => span_bug!(pat.span,\n@@ -608,12 +608,12 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             self.flatten_nested_slice_patterns(prefix, slice, suffix);\n \n         match ty.sty {\n-            ty::TySlice(..) => {\n+            ty::Slice(..) => {\n                 // matching a slice or fixed-length array\n                 PatternKind::Slice { prefix: prefix, slice: slice, suffix: suffix }\n             }\n \n-            ty::TyArray(_, len) => {\n+            ty::Array(_, len) => {\n                 // fixed-length array\n                 let len = len.unwrap_usize(self.tcx);\n                 assert!(len >= prefix.len() as u64 + suffix.len() as u64);\n@@ -640,9 +640,9 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 let adt_def = self.tcx.adt_def(enum_id);\n                 if adt_def.is_enum() {\n                     let substs = match ty.sty {\n-                        ty::TyAdt(_, substs) |\n-                        ty::TyFnDef(_, substs) => substs,\n-                        ty::TyError => {  // Avoid ICE (#50585)\n+                        ty::Adt(_, substs) |\n+                        ty::FnDef(_, substs) => substs,\n+                        ty::Error => {  // Avoid ICE (#50585)\n                             return PatternKind::Wild;\n                         }\n                         _ => bug!(\"inappropriate type for def: {:?}\", ty.sty),\n@@ -811,7 +811,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             }).collect::<Vec<_>>()\n         };\n         let kind = match cv.ty.sty {\n-            ty::TyFloat(_) => {\n+            ty::Float(_) => {\n                 let id = self.tcx.hir.hir_to_node_id(id);\n                 self.tcx.lint_node(\n                     ::rustc::lint::builtin::ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n@@ -823,20 +823,20 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     value: cv,\n                 }\n             },\n-            ty::TyAdt(adt_def, _) if adt_def.is_union() => {\n+            ty::Adt(adt_def, _) if adt_def.is_union() => {\n                 // Matching on union fields is unsafe, we can't hide it in constants\n                 self.tcx.sess.span_err(span, \"cannot use unions in constant patterns\");\n                 PatternKind::Wild\n             }\n-            ty::TyAdt(adt_def, _) if !self.tcx.has_attr(adt_def.did, \"structural_match\") => {\n+            ty::Adt(adt_def, _) if !self.tcx.has_attr(adt_def.did, \"structural_match\") => {\n                 let msg = format!(\"to use a constant of type `{}` in a pattern, \\\n                                     `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n                                     self.tcx.item_path_str(adt_def.did),\n                                     self.tcx.item_path_str(adt_def.did));\n                 self.tcx.sess.span_err(span, &msg);\n                 PatternKind::Wild\n             },\n-            ty::TyAdt(adt_def, substs) if adt_def.is_enum() => {\n+            ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n                 let variant_index = const_variant_index(\n                     self.tcx, self.param_env, instance, cv\n                 ).expect(\"const_variant_index failed\");\n@@ -851,18 +851,18 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     subpatterns,\n                 }\n             },\n-            ty::TyAdt(adt_def, _) => {\n+            ty::Adt(adt_def, _) => {\n                 let struct_var = adt_def.non_enum_variant();\n                 PatternKind::Leaf {\n                     subpatterns: adt_subpatterns(struct_var.fields.len(), None),\n                 }\n             }\n-            ty::TyTuple(fields) => {\n+            ty::Tuple(fields) => {\n                 PatternKind::Leaf {\n                     subpatterns: adt_subpatterns(fields.len(), None),\n                 }\n             }\n-            ty::TyArray(_, n) => {\n+            ty::Array(_, n) => {\n                 PatternKind::Array {\n                     prefix: (0..n.unwrap_usize(self.tcx))\n                         .map(|i| adt_subpattern(i as usize, None))\n@@ -1073,17 +1073,17 @@ pub fn compare_const_vals<'a, 'tcx>(\n     if let (Some(a), Some(b)) = (a.to_bits(tcx, ty), b.to_bits(tcx, ty)) {\n         use ::rustc_apfloat::Float;\n         return match ty.value.sty {\n-            ty::TyFloat(ast::FloatTy::F32) => {\n+            ty::Float(ast::FloatTy::F32) => {\n                 let l = ::rustc_apfloat::ieee::Single::from_bits(a);\n                 let r = ::rustc_apfloat::ieee::Single::from_bits(b);\n                 l.partial_cmp(&r)\n             },\n-            ty::TyFloat(ast::FloatTy::F64) => {\n+            ty::Float(ast::FloatTy::F64) => {\n                 let l = ::rustc_apfloat::ieee::Double::from_bits(a);\n                 let r = ::rustc_apfloat::ieee::Double::from_bits(b);\n                 l.partial_cmp(&r)\n             },\n-            ty::TyInt(_) => {\n+            ty::Int(_) => {\n                 let layout = tcx.layout_of(ty).ok()?;\n                 assert!(layout.abi.is_signed());\n                 let a = sign_extend(a, layout.size);\n@@ -1094,8 +1094,8 @@ pub fn compare_const_vals<'a, 'tcx>(\n         }\n     }\n \n-    if let ty::TyRef(_, rty, _) = ty.value.sty {\n-        if let ty::TyStr = rty.sty {\n+    if let ty::Ref(_, rty, _) = ty.value.sty {\n+        if let ty::Str = rty.sty {\n             match (a.val, b.val) {\n                 (\n                     ConstValue::ScalarPair(\n@@ -1170,11 +1170,11 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n                 Unsigned(UintTy),\n             }\n             let ity = match ty.sty {\n-                ty::TyInt(IntTy::Isize) => Int::Signed(tcx.sess.target.isize_ty),\n-                ty::TyInt(other) => Int::Signed(other),\n-                ty::TyUint(UintTy::Usize) => Int::Unsigned(tcx.sess.target.usize_ty),\n-                ty::TyUint(other) => Int::Unsigned(other),\n-                ty::TyError => { // Avoid ICE (#51963)\n+                ty::Int(IntTy::Isize) => Int::Signed(tcx.sess.target.isize_ty),\n+                ty::Int(other) => Int::Signed(other),\n+                ty::Uint(UintTy::Usize) => Int::Unsigned(tcx.sess.target.usize_ty),\n+                ty::Uint(other) => Int::Unsigned(other),\n+                ty::Error => { // Avoid ICE (#51963)\n                     return Err(LitToConstError::Propagated);\n                 }\n                 _ => bug!(\"literal integer type with bad type ({:?})\", ty.sty),\n@@ -1211,7 +1211,7 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n         }\n         LitKind::FloatUnsuffixed(n) => {\n             let fty = match ty.sty {\n-                ty::TyFloat(fty) => fty,\n+                ty::Float(fty) => fty,\n                 _ => bug!()\n             };\n             parse_float(n, fty, neg).map_err(|_| LitToConstError::UnparseableFloat)?"}, {"sha": "0c5dbf9a0f63e8c642753df59f5efee3022cc345", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -15,9 +15,9 @@ use super::{EvalContext, Machine, PlaceTy, OpTy, Value};\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     fn type_is_fat_ptr(&self, ty: Ty<'tcx>) -> bool {\n         match ty.sty {\n-            ty::TyRawPtr(ty::TypeAndMut { ty, .. }) |\n-            ty::TyRef(_, ty, _) => !self.type_is_sized(ty),\n-            ty::TyAdt(def, _) if def.is_box() => !self.type_is_sized(ty.boxed_ty()),\n+            ty::RawPtr(ty::TypeAndMut { ty, .. }) |\n+            ty::Ref(_, ty, _) => !self.type_is_sized(ty),\n+            ty::Adt(def, _) if def.is_box() => !self.type_is_sized(ty.boxed_ty()),\n             _ => false,\n         }\n     }\n@@ -80,7 +80,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             ReifyFnPointer => {\n                 // The src operand does not matter, just its type\n                 match src_layout.ty.sty {\n-                    ty::TyFnDef(def_id, substs) => {\n+                    ty::FnDef(def_id, substs) => {\n                         if self.tcx.has_attr(def_id, \"rustc_args_required_const\") {\n                             bug!(\"reifying a fn ptr that requires \\\n                                     const arguments\");\n@@ -101,7 +101,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             UnsafeFnPointer => {\n                 let src = self.read_value(src)?;\n                 match dest.layout.ty.sty {\n-                    ty::TyFnPtr(_) => {\n+                    ty::FnPtr(_) => {\n                         // No change to value\n                         self.write_value(*src, dest)?;\n                     }\n@@ -112,7 +112,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             ClosureFnPointer => {\n                 // The src operand does not matter, just its type\n                 match src_layout.ty.sty {\n-                    ty::TyClosure(def_id, substs) => {\n+                    ty::Closure(def_id, substs) => {\n                         let substs = self.tcx.subst_and_normalize_erasing_regions(\n                             self.substs(),\n                             ty::ParamEnv::reveal_all(),\n@@ -141,7 +141,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         src_layout: TyLayout<'tcx>,\n         dest_layout: TyLayout<'tcx>,\n     ) -> EvalResult<'tcx, Scalar> {\n-        use rustc::ty::TypeVariants::*;\n+        use rustc::ty::TyKind::*;\n         trace!(\"Casting {:?}: {:?} to {:?}\", val, src_layout.ty, dest_layout.ty);\n \n         match val {\n@@ -152,7 +152,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     \"Unexpected value of size {} before casting\", size);\n \n                 let res = match src_layout.ty.sty {\n-                    TyFloat(fty) => self.cast_from_float(bits, fty, dest_layout.ty)?,\n+                    Float(fty) => self.cast_from_float(bits, fty, dest_layout.ty)?,\n                     _ => self.cast_from_int(bits, src_layout, dest_layout)?,\n                 };\n \n@@ -184,40 +184,40 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             v\n         };\n         trace!(\"cast_from_int: {}, {}, {}\", v, src_layout.ty, dest_layout.ty);\n-        use rustc::ty::TypeVariants::*;\n+        use rustc::ty::TyKind::*;\n         match dest_layout.ty.sty {\n-            TyInt(_) | TyUint(_) => {\n+            Int(_) | Uint(_) => {\n                 let v = self.truncate(v, dest_layout);\n                 Ok(Scalar::Bits {\n                     bits: v,\n                     size: dest_layout.size.bytes() as u8,\n                 })\n             }\n \n-            TyFloat(FloatTy::F32) if signed => Ok(Scalar::Bits {\n+            Float(FloatTy::F32) if signed => Ok(Scalar::Bits {\n                 bits: Single::from_i128(v as i128).value.to_bits(),\n                 size: 4,\n             }),\n-            TyFloat(FloatTy::F64) if signed => Ok(Scalar::Bits {\n+            Float(FloatTy::F64) if signed => Ok(Scalar::Bits {\n                 bits: Double::from_i128(v as i128).value.to_bits(),\n                 size: 8,\n             }),\n-            TyFloat(FloatTy::F32) => Ok(Scalar::Bits {\n+            Float(FloatTy::F32) => Ok(Scalar::Bits {\n                 bits: Single::from_u128(v).value.to_bits(),\n                 size: 4,\n             }),\n-            TyFloat(FloatTy::F64) => Ok(Scalar::Bits {\n+            Float(FloatTy::F64) => Ok(Scalar::Bits {\n                 bits: Double::from_u128(v).value.to_bits(),\n                 size: 8,\n             }),\n \n-            TyChar => {\n+            Char => {\n                 assert_eq!(v as u8 as u128, v);\n                 Ok(Scalar::Bits { bits: v, size: 4 })\n             },\n \n             // No alignment check needed for raw pointers.  But we have to truncate to target ptr size.\n-            TyRawPtr(_) => {\n+            RawPtr(_) => {\n                 Ok(Scalar::Bits {\n                     bits: self.memory.truncate_to_ptr(v).0 as u128,\n                     size: self.memory.pointer_size().bytes() as u8,\n@@ -230,11 +230,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     }\n \n     fn cast_from_float(&self, bits: u128, fty: FloatTy, dest_ty: Ty<'tcx>) -> EvalResult<'tcx, Scalar> {\n-        use rustc::ty::TypeVariants::*;\n+        use rustc::ty::TyKind::*;\n         use rustc_apfloat::FloatConvert;\n         match dest_ty.sty {\n             // float -> uint\n-            TyUint(t) => {\n+            Uint(t) => {\n                 let width = t.bit_width().unwrap_or(self.memory.pointer_size().bits() as usize);\n                 let v = match fty {\n                     FloatTy::F32 => Single::from_bits(bits).to_u128(width).value,\n@@ -247,7 +247,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 })\n             },\n             // float -> int\n-            TyInt(t) => {\n+            Int(t) => {\n                 let width = t.bit_width().unwrap_or(self.memory.pointer_size().bits() as usize);\n                 let v = match fty {\n                     FloatTy::F32 => Single::from_bits(bits).to_i128(width).value,\n@@ -263,25 +263,25 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 })\n             },\n             // f64 -> f32\n-            TyFloat(FloatTy::F32) if fty == FloatTy::F64 => {\n+            Float(FloatTy::F32) if fty == FloatTy::F64 => {\n                 Ok(Scalar::Bits {\n                     bits: Single::to_bits(Double::from_bits(bits).convert(&mut false).value),\n                     size: 4,\n                 })\n             },\n             // f32 -> f64\n-            TyFloat(FloatTy::F64) if fty == FloatTy::F32 => {\n+            Float(FloatTy::F64) if fty == FloatTy::F32 => {\n                 Ok(Scalar::Bits {\n                     bits: Double::to_bits(Single::from_bits(bits).convert(&mut false).value),\n                     size: 8,\n                 })\n             },\n             // identity cast\n-            TyFloat(FloatTy:: F64) => Ok(Scalar::Bits {\n+            Float(FloatTy:: F64) => Ok(Scalar::Bits {\n                 bits,\n                 size: 8,\n             }),\n-            TyFloat(FloatTy:: F32) => Ok(Scalar::Bits {\n+            Float(FloatTy:: F32) => Ok(Scalar::Bits {\n                 bits,\n                 size: 4,\n             }),\n@@ -290,13 +290,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     }\n \n     fn cast_from_ptr(&self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Scalar> {\n-        use rustc::ty::TypeVariants::*;\n+        use rustc::ty::TyKind::*;\n         match ty.sty {\n             // Casting to a reference or fn pointer is not permitted by rustc, no need to support it here.\n-            TyRawPtr(_) |\n-            TyInt(IntTy::Isize) |\n-            TyUint(UintTy::Usize) => Ok(ptr.into()),\n-            TyInt(_) | TyUint(_) => err!(ReadPointerAsBytes),\n+            RawPtr(_) |\n+            Int(IntTy::Isize) |\n+            Uint(UintTy::Usize) => Ok(ptr.into()),\n+            Int(_) | Uint(_) => err!(ReadPointerAsBytes),\n             _ => err!(Unimplemented(format!(\"ptr to {:?} cast\", ty))),\n         }\n     }\n@@ -313,19 +313,19 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         let (src_pointee_ty, dest_pointee_ty) = self.tcx.struct_lockstep_tails(sty, dty);\n \n         match (&src_pointee_ty.sty, &dest_pointee_ty.sty) {\n-            (&ty::TyArray(_, length), &ty::TySlice(_)) => {\n+            (&ty::Array(_, length), &ty::Slice(_)) => {\n                 let ptr = self.read_value(src)?.to_scalar_ptr()?;\n                 // u64 cast is from usize to u64, which is always good\n                 let val = Value::new_slice(ptr, length.unwrap_usize(self.tcx.tcx), self.tcx.tcx);\n                 self.write_value(val, dest)\n             }\n-            (&ty::TyDynamic(..), &ty::TyDynamic(..)) => {\n+            (&ty::Dynamic(..), &ty::Dynamic(..)) => {\n                 // For now, upcasts are limited to changes in marker\n                 // traits, and hence never actually require an actual\n                 // change to the vtable.\n                 self.copy_op(src, dest)\n             }\n-            (_, &ty::TyDynamic(ref data, _)) => {\n+            (_, &ty::Dynamic(ref data, _)) => {\n                 // Initial cast from sized to dyn trait\n                 let trait_ref = data.principal().unwrap().with_self_ty(\n                     *self.tcx,\n@@ -348,13 +348,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         dest: PlaceTy<'tcx>,\n     ) -> EvalResult<'tcx> {\n         match (&src.layout.ty.sty, &dest.layout.ty.sty) {\n-            (&ty::TyRef(_, s, _), &ty::TyRef(_, d, _)) |\n-            (&ty::TyRef(_, s, _), &ty::TyRawPtr(TypeAndMut { ty: d, .. })) |\n-            (&ty::TyRawPtr(TypeAndMut { ty: s, .. }),\n-             &ty::TyRawPtr(TypeAndMut { ty: d, .. })) => {\n+            (&ty::Ref(_, s, _), &ty::Ref(_, d, _)) |\n+            (&ty::Ref(_, s, _), &ty::RawPtr(TypeAndMut { ty: d, .. })) |\n+            (&ty::RawPtr(TypeAndMut { ty: s, .. }),\n+             &ty::RawPtr(TypeAndMut { ty: d, .. })) => {\n                 self.unsize_into_ptr(src, dest, s, d)\n             }\n-            (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) => {\n+            (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n                 assert_eq!(def_a, def_b);\n                 if def_a.is_box() || def_b.is_box() {\n                     if !def_a.is_box() || !def_b.is_box() {"}, {"sha": "9a6f1199421d6445dc25af9b8909f8b13810dedc", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -457,7 +457,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             let layout = mplace.layout;\n             assert!(layout.is_unsized());\n             match layout.ty.sty {\n-                ty::TyAdt(..) | ty::TyTuple(..) => {\n+                ty::Adt(..) | ty::Tuple(..) => {\n                     // First get the size of all statically known fields.\n                     // Don't use type_of::sizing_type_of because that expects t to be sized,\n                     // and it also rounds up to alignment, which we want to avoid,\n@@ -506,7 +506,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n                     Ok((size.abi_align(align), align))\n                 }\n-                ty::TyDynamic(..) => {\n+                ty::Dynamic(..) => {\n                     let vtable = match mplace.extra {\n                         PlaceExtra::Vtable(vtable) => vtable,\n                         _ => bug!(\"Expected vtable\"),\n@@ -515,7 +515,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                     self.read_size_and_align_from_vtable(vtable)\n                 }\n \n-                ty::TySlice(_) | ty::TyStr => {\n+                ty::Slice(_) | ty::Str => {\n                     let len = match mplace.extra {\n                         PlaceExtra::Length(len) => len,\n                         _ => bug!(\"Expected length\"),"}, {"sha": "a8e5525b2e1c0f22efc9b34f0b5e74f42cffbc3a", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -169,7 +169,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             }\n         }\n \n-        if let ty::TyFloat(fty) = left_layout.ty.sty {\n+        if let ty::Float(fty) = left_layout.ty.sty {\n             macro_rules! float_math {\n                 ($ty:path, $size:expr) => {{\n                     let l = <$ty>::from_bits(l);\n@@ -267,12 +267,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n         let result_bytes = match (un_op, &layout.ty.sty) {\n \n-            (Not, ty::TyBool) => !val.to_bool()? as u128,\n+            (Not, ty::Bool) => !val.to_bool()? as u128,\n \n             (Not, _) => !bytes,\n \n-            (Neg, ty::TyFloat(FloatTy::F32)) => Single::to_bits(-Single::from_bits(bytes)),\n-            (Neg, ty::TyFloat(FloatTy::F64)) => Double::to_bits(-Double::from_bits(bytes)),\n+            (Neg, ty::Float(FloatTy::F32)) => Single::to_bits(-Single::from_bits(bytes)),\n+            (Neg, ty::Float(FloatTy::F64)) => Double::to_bits(-Double::from_bits(bytes)),\n \n             (Neg, _) if bytes == (1 << (size.bits() - 1)) => return err!(OverflowNeg),\n             (Neg, _) => (-(bytes as i128)) as u128,"}, {"sha": "1795548d81c773a510be41cb97b09dd718f02ffd", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -236,15 +236,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         let pointee_type = val.layout.ty.builtin_deref(true).unwrap().ty;\n         let layout = self.layout_of(pointee_type)?;\n         let mplace = match self.tcx.struct_tail(pointee_type).sty {\n-            ty::TyDynamic(..) => {\n+            ty::Dynamic(..) => {\n                 let (ptr, vtable) = val.to_scalar_dyn_trait()?;\n                 MemPlace {\n                     ptr,\n                     align: layout.align,\n                     extra: PlaceExtra::Vtable(vtable),\n                 }\n             }\n-            ty::TyStr | ty::TySlice(_) => {\n+            ty::Str | ty::Slice(_) => {\n                 let (ptr, len) = val.to_scalar_slice(self)?;\n                 MemPlace {\n                     ptr,\n@@ -358,9 +358,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         // Compute extra and new layout\n         let inner_len = len - to - from;\n         let (extra, ty) = match base.layout.ty.sty {\n-            ty::TyArray(inner, _) =>\n+            ty::Array(inner, _) =>\n                 (PlaceExtra::None, self.tcx.mk_array(inner, inner_len)),\n-            ty::TySlice(..) =>\n+            ty::Slice(..) =>\n                 (PlaceExtra::Length(inner_len), base.layout.ty),\n             _ =>\n                 bug!(\"cannot subslice non-array type: `{:?}`\", base.layout.ty),"}, {"sha": "0bddd7147b9986609c5173516944018c116034e6", "filename": "src/librustc_mir/interpret/terminator/drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -20,7 +20,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         let place = self.force_allocation(place)?;\n \n         let (instance, place) = match place.layout.ty.sty {\n-            ty::TyDynamic(..) => {\n+            ty::Dynamic(..) => {\n                 // Dropping a trait object.\n                 let vtable = match place.extra {\n                     PlaceExtra::Vtable(vtable) => vtable,"}, {"sha": "913b88fc8eb48acccc34a88d3b3043a5be7dd9aa", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -72,12 +72,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n                 let func = self.eval_operand(func, None)?;\n                 let (fn_def, sig) = match func.layout.ty.sty {\n-                    ty::TyFnPtr(sig) => {\n+                    ty::FnPtr(sig) => {\n                         let fn_ptr = self.read_scalar(func)?.to_ptr()?;\n                         let instance = self.memory.get_fn(fn_ptr)?;\n                         let instance_ty = instance.ty(*self.tcx);\n                         match instance_ty.sty {\n-                            ty::TyFnDef(..) => {\n+                            ty::FnDef(..) => {\n                                 let real_sig = instance_ty.fn_sig(*self.tcx);\n                                 let sig = self.tcx.normalize_erasing_late_bound_regions(\n                                     ty::ParamEnv::reveal_all(),\n@@ -95,7 +95,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                         }\n                         (instance, sig)\n                     }\n-                    ty::TyFnDef(def_id, substs) => (\n+                    ty::FnDef(def_id, substs) => (\n                         self.resolve(def_id, substs)?,\n                         func.layout.ty.fn_sig(*self.tcx),\n                     ),\n@@ -198,8 +198,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 // Permit changing the pointer type of raw pointers and references as well as\n                 // mutability of raw pointers.\n                 // TODO: Should not be allowed when fat pointers are involved.\n-                (&ty::TyRawPtr(_), &ty::TyRawPtr(_)) => true,\n-                (&ty::TyRef(_, _, _), &ty::TyRef(_, _, _)) => {\n+                (&ty::RawPtr(_), &ty::RawPtr(_)) => true,\n+                (&ty::Ref(_, _, _), &ty::Ref(_, _, _)) => {\n                     ty.is_mutable_pointer() == real_ty.is_mutable_pointer()\n                 }\n                 // rule out everything else\n@@ -233,7 +233,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     // Second argument must be a tuple matching the argument list of sig\n                     let snd_ty = real_sig.inputs_and_output[1];\n                     match snd_ty.sty {\n-                        ty::TyTuple(tys) if sig.inputs().len() == tys.len() =>\n+                        ty::Tuple(tys) if sig.inputs().len() == tys.len() =>\n                             if sig.inputs().iter().zip(tys).all(|(ty, real_ty)| check_ty_compat(ty, real_ty)) {\n                                 return Ok(true)\n                             },\n@@ -339,7 +339,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n                         // unpack and write all other args\n                         let layout = args[1].layout;\n-                        if let ty::TyTuple(_) = layout.ty.sty {\n+                        if let ty::Tuple(_) = layout.ty.sty {\n                             if layout.is_zst() {\n                                 // Nothing to do, no need to unpack zsts\n                                 return Ok(());"}, {"sha": "a446a534624ba911dea5a70819d6bdea23a3f347", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -139,7 +139,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         // char gets a special treatment, because its number space is not contiguous so `TyLayout`\n         // has no special checks for chars\n         match ty.sty {\n-            ty::TyChar => {\n+            ty::Char => {\n                 debug_assert_eq!(size.bytes(), 4);\n                 if ::std::char::from_u32(bits as u32).is_none() {\n                     return validation_failure!(\n@@ -323,23 +323,23 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     fn aggregate_field_path_elem(&self, ty: Ty<'tcx>, variant: usize, field: usize) -> PathElem {\n         match ty.sty {\n             // generators and closures.\n-            ty::TyClosure(def_id, _) | ty::TyGenerator(def_id, _, _) => {\n+            ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n                 let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n                 let freevar = self.tcx.with_freevars(node_id, |fv| fv[field]);\n                 PathElem::ClosureVar(self.tcx.hir.name(freevar.var_id()))\n             }\n \n             // tuples\n-            ty::TyTuple(_) => PathElem::TupleElem(field),\n+            ty::Tuple(_) => PathElem::TupleElem(field),\n \n             // enums\n-            ty::TyAdt(def, ..) if def.is_enum() => {\n+            ty::Adt(def, ..) if def.is_enum() => {\n                 let variant = &def.variants[variant];\n                 PathElem::Field(variant.fields[field].ident.name)\n             }\n \n             // other ADTs\n-            ty::TyAdt(def, _) => PathElem::Field(def.non_enum_variant().fields[field].ident.name),\n+            ty::Adt(def, _) => PathElem::Field(def.non_enum_variant().fields[field].ident.name),\n \n             // nothing else has an aggregate layout\n             _ => bug!(\"aggregate_field_path_elem: got non-aggregate type {:?}\", ty),"}, {"sha": "a1dbf9ddb035616de84731f926aec105b38ccbee", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -571,7 +571,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                     &source_ty,\n                 );\n                 match source_ty.sty {\n-                    ty::TyClosure(def_id, substs) => {\n+                    ty::Closure(def_id, substs) => {\n                         let instance = monomorphize::resolve_closure(\n                             self.tcx, def_id, substs, ty::ClosureKind::FnOnce);\n                         if should_monomorphize_locally(self.tcx, &instance) {\n@@ -680,7 +680,7 @@ fn visit_fn_use<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           is_direct_call: bool,\n                           output: &mut Vec<MonoItem<'tcx>>)\n {\n-    if let ty::TyFnDef(def_id, substs) = ty.sty {\n+    if let ty::FnDef(def_id, substs) = ty.sty {\n         let instance = ty::Instance::resolve(tcx,\n                                              ty::ParamEnv::reveal_all(),\n                                              def_id,\n@@ -838,8 +838,8 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n             let tail = tcx.struct_tail(ty);\n             match tail.sty {\n-                ty::TyForeign(..) => false,\n-                ty::TyStr | ty::TySlice(..) | ty::TyDynamic(..) => true,\n+                ty::Foreign(..) => false,\n+                ty::Str | ty::Slice(..) | ty::Dynamic(..) => true,\n                 _ => bug!(\"unexpected unsized tail: {:?}\", tail.sty),\n             }\n         };\n@@ -851,20 +851,20 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     };\n \n     match (&source_ty.sty, &target_ty.sty) {\n-        (&ty::TyRef(_, a, _),\n-         &ty::TyRef(_, b, _)) |\n-        (&ty::TyRef(_, a, _),\n-         &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) |\n-        (&ty::TyRawPtr(ty::TypeAndMut { ty: a, .. }),\n-         &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) => {\n+        (&ty::Ref(_, a, _),\n+         &ty::Ref(_, b, _)) |\n+        (&ty::Ref(_, a, _),\n+         &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) |\n+        (&ty::RawPtr(ty::TypeAndMut { ty: a, .. }),\n+         &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) => {\n             ptr_vtable(a, b)\n         }\n-        (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n+        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n             ptr_vtable(source_ty.boxed_ty(), target_ty.boxed_ty())\n         }\n \n-        (&ty::TyAdt(source_adt_def, source_substs),\n-         &ty::TyAdt(target_adt_def, target_substs)) => {\n+        (&ty::Adt(source_adt_def, source_substs),\n+         &ty::Adt(target_adt_def, target_substs)) => {\n             assert_eq!(source_adt_def, target_adt_def);\n \n             let kind =\n@@ -906,7 +906,7 @@ fn create_mono_items_for_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     assert!(!trait_ty.needs_subst() && !trait_ty.has_escaping_regions() &&\n             !impl_ty.needs_subst() && !impl_ty.has_escaping_regions());\n \n-    if let ty::TyDynamic(ref trait_ty, ..) = trait_ty.sty {\n+    if let ty::Dynamic(ref trait_ty, ..) = trait_ty.sty {\n         if let Some(principal) = trait_ty.principal() {\n             let poly_trait_ref = principal.with_self_ty(tcx, impl_ty);\n             assert!(!poly_trait_ref.has_escaping_regions());"}, {"sha": "3187a91e225970d8edaecfa20b51d3d96ba7dfb9", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -257,29 +257,29 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n \n     pub fn push_type_name(&self, t: Ty<'tcx>, output: &mut String) {\n         match t.sty {\n-            ty::TyBool              => output.push_str(\"bool\"),\n-            ty::TyChar              => output.push_str(\"char\"),\n-            ty::TyStr               => output.push_str(\"str\"),\n-            ty::TyNever             => output.push_str(\"!\"),\n-            ty::TyInt(ast::IntTy::Isize)    => output.push_str(\"isize\"),\n-            ty::TyInt(ast::IntTy::I8)    => output.push_str(\"i8\"),\n-            ty::TyInt(ast::IntTy::I16)   => output.push_str(\"i16\"),\n-            ty::TyInt(ast::IntTy::I32)   => output.push_str(\"i32\"),\n-            ty::TyInt(ast::IntTy::I64)   => output.push_str(\"i64\"),\n-            ty::TyInt(ast::IntTy::I128)   => output.push_str(\"i128\"),\n-            ty::TyUint(ast::UintTy::Usize)   => output.push_str(\"usize\"),\n-            ty::TyUint(ast::UintTy::U8)   => output.push_str(\"u8\"),\n-            ty::TyUint(ast::UintTy::U16)  => output.push_str(\"u16\"),\n-            ty::TyUint(ast::UintTy::U32)  => output.push_str(\"u32\"),\n-            ty::TyUint(ast::UintTy::U64)  => output.push_str(\"u64\"),\n-            ty::TyUint(ast::UintTy::U128)  => output.push_str(\"u128\"),\n-            ty::TyFloat(ast::FloatTy::F32) => output.push_str(\"f32\"),\n-            ty::TyFloat(ast::FloatTy::F64) => output.push_str(\"f64\"),\n-            ty::TyAdt(adt_def, substs) => {\n+            ty::Bool              => output.push_str(\"bool\"),\n+            ty::Char              => output.push_str(\"char\"),\n+            ty::Str               => output.push_str(\"str\"),\n+            ty::Never             => output.push_str(\"!\"),\n+            ty::Int(ast::IntTy::Isize)    => output.push_str(\"isize\"),\n+            ty::Int(ast::IntTy::I8)    => output.push_str(\"i8\"),\n+            ty::Int(ast::IntTy::I16)   => output.push_str(\"i16\"),\n+            ty::Int(ast::IntTy::I32)   => output.push_str(\"i32\"),\n+            ty::Int(ast::IntTy::I64)   => output.push_str(\"i64\"),\n+            ty::Int(ast::IntTy::I128)   => output.push_str(\"i128\"),\n+            ty::Uint(ast::UintTy::Usize)   => output.push_str(\"usize\"),\n+            ty::Uint(ast::UintTy::U8)   => output.push_str(\"u8\"),\n+            ty::Uint(ast::UintTy::U16)  => output.push_str(\"u16\"),\n+            ty::Uint(ast::UintTy::U32)  => output.push_str(\"u32\"),\n+            ty::Uint(ast::UintTy::U64)  => output.push_str(\"u64\"),\n+            ty::Uint(ast::UintTy::U128)  => output.push_str(\"u128\"),\n+            ty::Float(ast::FloatTy::F32) => output.push_str(\"f32\"),\n+            ty::Float(ast::FloatTy::F64) => output.push_str(\"f64\"),\n+            ty::Adt(adt_def, substs) => {\n                 self.push_def_path(adt_def.did, output);\n                 self.push_type_params(substs, iter::empty(), output);\n             },\n-            ty::TyTuple(component_types) => {\n+            ty::Tuple(component_types) => {\n                 output.push('(');\n                 for &component_type in component_types {\n                     self.push_type_name(component_type, output);\n@@ -291,7 +291,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n                 }\n                 output.push(')');\n             },\n-            ty::TyRawPtr(ty::TypeAndMut { ty: inner_type, mutbl } ) => {\n+            ty::RawPtr(ty::TypeAndMut { ty: inner_type, mutbl } ) => {\n                 output.push('*');\n                 match mutbl {\n                     hir::MutImmutable => output.push_str(\"const \"),\n@@ -300,36 +300,36 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n \n                 self.push_type_name(inner_type, output);\n             },\n-            ty::TyRef(_, inner_type, mutbl) => {\n+            ty::Ref(_, inner_type, mutbl) => {\n                 output.push('&');\n                 if mutbl == hir::MutMutable {\n                     output.push_str(\"mut \");\n                 }\n \n                 self.push_type_name(inner_type, output);\n             },\n-            ty::TyArray(inner_type, len) => {\n+            ty::Array(inner_type, len) => {\n                 output.push('[');\n                 self.push_type_name(inner_type, output);\n                 write!(output, \"; {}\", len.unwrap_usize(self.tcx)).unwrap();\n                 output.push(']');\n             },\n-            ty::TySlice(inner_type) => {\n+            ty::Slice(inner_type) => {\n                 output.push('[');\n                 self.push_type_name(inner_type, output);\n                 output.push(']');\n             },\n-            ty::TyDynamic(ref trait_data, ..) => {\n+            ty::Dynamic(ref trait_data, ..) => {\n                 if let Some(principal) = trait_data.principal() {\n                     self.push_def_path(principal.def_id(), output);\n                     self.push_type_params(principal.skip_binder().substs,\n                         trait_data.projection_bounds(),\n                         output);\n                 }\n             },\n-            ty::TyForeign(did) => self.push_def_path(did, output),\n-            ty::TyFnDef(..) |\n-            ty::TyFnPtr(_) => {\n+            ty::Foreign(did) => self.push_def_path(did, output),\n+            ty::FnDef(..) |\n+            ty::FnPtr(_) => {\n                 let sig = t.fn_sig(self.tcx);\n                 if sig.unsafety() == hir::Unsafety::Unsafe {\n                     output.push_str(\"unsafe \");\n@@ -373,19 +373,19 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n                     self.push_type_name(sig.output(), output);\n                 }\n             },\n-            ty::TyGenerator(def_id, GeneratorSubsts { ref substs }, _) |\n-            ty::TyClosure(def_id, ClosureSubsts { ref substs }) => {\n+            ty::Generator(def_id, GeneratorSubsts { ref substs }, _) |\n+            ty::Closure(def_id, ClosureSubsts { ref substs }) => {\n                 self.push_def_path(def_id, output);\n                 let generics = self.tcx.generics_of(self.tcx.closure_base_def_id(def_id));\n                 let substs = substs.truncate_to(self.tcx, generics);\n                 self.push_type_params(substs, iter::empty(), output);\n             }\n-            ty::TyError |\n-            ty::TyInfer(_) |\n-            ty::TyProjection(..) |\n-            ty::TyParam(_) |\n-            ty::TyGeneratorWitness(_) |\n-            ty::TyAnon(..) => {\n+            ty::Error |\n+            ty::Infer(_) |\n+            ty::Projection(..) |\n+            ty::Param(_) |\n+            ty::GeneratorWitness(_) |\n+            ty::Anon(..) => {\n                 bug!(\"DefPathBasedNames: Trying to create type name for \\\n                                          unexpected type: {:?}\", t);\n             }"}, {"sha": "765a47e729e6834aa5e245a9b5bb5fc4adb6728f", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -165,7 +165,7 @@ fn build_drop_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"build_drop_shim(def_id={:?}, ty={:?})\", def_id, ty);\n \n     // Check if this is a generator, if so, return the drop glue for it\n-    if let Some(&ty::TyS { sty: ty::TyGenerator(gen_def_id, substs, _), .. }) = ty {\n+    if let Some(&ty::TyS { sty: ty::Generator(gen_def_id, substs, _), .. }) = ty {\n         let mir = &**tcx.optimized_mir(gen_def_id).generator_drop.as_ref().unwrap();\n         return mir.subst(tcx, substs.substs);\n     }\n@@ -301,17 +301,17 @@ fn build_clone_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     match self_ty.sty {\n         _ if is_copy => builder.copy_shim(),\n-        ty::TyArray(ty, len) => {\n+        ty::Array(ty, len) => {\n             let len = len.unwrap_usize(tcx);\n             builder.array_shim(dest, src, ty, len)\n         }\n-        ty::TyClosure(def_id, substs) => {\n+        ty::Closure(def_id, substs) => {\n             builder.tuple_like_shim(\n                 dest, src,\n                 substs.upvar_tys(def_id, tcx)\n             )\n         }\n-        ty::TyTuple(tys) => builder.tuple_like_shim(dest, src, tys.iter().cloned()),\n+        ty::Tuple(tys) => builder.tuple_like_shim(dest, src, tys.iter().cloned()),\n         _ => {\n             bug!(\"clone shim for `{:?}` which is not `Copy` and is not an aggregate\", self_ty)\n         }\n@@ -821,7 +821,7 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n     let sig = gcx.normalize_erasing_regions(param_env, sig);\n \n     let (adt_def, substs) = match sig.output().sty {\n-        ty::TyAdt(adt_def, substs) => (adt_def, substs),\n+        ty::Adt(adt_def, substs) => (adt_def, substs),\n         _ => bug!(\"unexpected type for ADT ctor {:?}\", sig.output())\n     };\n "}, {"sha": "9061b34ae4445a49e47b935e45e0c1ca0a78de90", "filename": "src/librustc_mir/transform/add_validation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -45,7 +45,7 @@ fn place_context<'a, 'tcx, D>(\n                     // A Deref projection may restrict the context, this depends on the type\n                     // being deref'd.\n                     let context = match ty.sty {\n-                        ty::TyRef(re, _, mutbl) => {\n+                        ty::Ref(re, _, mutbl) => {\n                             let re = match re {\n                                 &RegionKind::ReScope(ce) => Some(ce),\n                                 &RegionKind::ReErased =>\n@@ -54,12 +54,12 @@ fn place_context<'a, 'tcx, D>(\n                             };\n                             (re, mutbl)\n                         }\n-                        ty::TyRawPtr(_) =>\n+                        ty::RawPtr(_) =>\n                             // There is no guarantee behind even a mutable raw pointer,\n                             // no write locks are acquired there, so we also don't want to\n                             // release any.\n                             (None, hir::MutImmutable),\n-                        ty::TyAdt(adt, _) if adt.is_box() => (None, hir::MutMutable),\n+                        ty::Adt(adt, _) if adt.is_box() => (None, hir::MutMutable),\n                         _ => bug!(\"Deref on a non-pointer type {:?}\", ty),\n                     };\n                     // \"Intersect\" this restriction with proj.base."}, {"sha": "5d284981c70afda49338ac299f872c3e2feeb832", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -179,13 +179,13 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 }\n                 let base_ty = base.ty(self.mir, self.tcx).to_ty(self.tcx);\n                 match base_ty.sty {\n-                    ty::TyRawPtr(..) => {\n+                    ty::RawPtr(..) => {\n                         self.require_unsafe(\"dereference of raw pointer\",\n                             \"raw pointers may be NULL, dangling or unaligned; they can violate \\\n                              aliasing rules and cause data races: all of these are undefined \\\n                              behavior\")\n                     }\n-                    ty::TyAdt(adt, _) => {\n+                    ty::Adt(adt, _) => {\n                         if adt.is_union() {\n                             if context == PlaceContext::Store ||\n                                 context == PlaceContext::AsmOutput ||"}, {"sha": "4a9b6b7f6e833930e877db7f2add4148f1e9b48a", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -493,7 +493,7 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // MIR types\n     let allowed_upvars = tcx.erase_regions(&upvars);\n     let allowed = match interior.sty {\n-        ty::TyGeneratorWitness(s) => tcx.erase_late_bound_regions(&s),\n+        ty::GeneratorWitness(s) => tcx.erase_late_bound_regions(&s),\n         _ => bug!(),\n     };\n \n@@ -863,7 +863,7 @@ impl MirPass for StateTransform {\n \n         // Get the interior types and substs which typeck computed\n         let (upvars, interior, movable) = match gen_ty.sty {\n-            ty::TyGenerator(_, substs, movability) => {\n+            ty::Generator(_, substs, movability) => {\n                 (substs.upvar_tys(def_id, tcx).collect(),\n                  substs.witness(def_id, tcx),\n                  movability == hir::GeneratorMovability::Movable)"}, {"sha": "31e437ce2281acb9b1dc6556f8b336cca8374091", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -95,7 +95,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                 let terminator = bb_data.terminator();\n                 if let TerminatorKind::Call {\n                     func: Operand::Constant(ref f), .. } = terminator.kind {\n-                        if let ty::TyFnDef(callee_def_id, substs) = f.ty.sty {\n+                        if let ty::FnDef(callee_def_id, substs) = f.ty.sty {\n                             if let Some(instance) = Instance::resolve(self.tcx,\n                                                                       param_env,\n                                                                       callee_def_id,\n@@ -158,7 +158,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                     let terminator = bb_data.terminator();\n                     if let TerminatorKind::Call {\n                         func: Operand::Constant(ref f), .. } = terminator.kind {\n-                        if let ty::TyFnDef(callee_def_id, substs) = f.ty.sty {\n+                        if let ty::FnDef(callee_def_id, substs) = f.ty.sty {\n                             // Don't inline the same function multiple times.\n                             if callsite.callee != callee_def_id {\n                                 callsites.push_back(CallSite {\n@@ -314,7 +314,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                 }\n \n                 TerminatorKind::Call {func: Operand::Constant(ref f), .. } => {\n-                    if let ty::TyFnDef(def_id, _) = f.ty.sty {\n+                    if let ty::FnDef(def_id, _) = f.ty.sty {\n                         // Don't give intrinsics the extra penalty for calls\n                         let f = tcx.fn_sig(def_id);\n                         if f.abi() == Abi::RustIntrinsic || f.abi() == Abi::PlatformIntrinsic {\n@@ -538,7 +538,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n             assert!(args.next().is_none());\n \n             let tuple = Place::Local(tuple);\n-            let tuple_tys = if let ty::TyTuple(s) = tuple.ty(caller_mir, tcx).to_ty(tcx).sty {\n+            let tuple_tys = if let ty::Tuple(s) = tuple.ty(caller_mir, tcx).to_ty(tcx).sty {\n                 s\n             } else {\n                 bug!(\"Closure arguments are not passed as a tuple\");"}, {"sha": "4cf4a8f23a443f63ddd85d37b229683cb0ba82dc", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -12,7 +12,7 @@\n \n use rustc::mir::{Constant, Location, Place, Mir, Operand, ProjectionElem, Rvalue, Local};\n use rustc::mir::visit::{MutVisitor, Visitor};\n-use rustc::ty::{TyCtxt, TypeVariants};\n+use rustc::ty::{TyCtxt, TyKind};\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::Idx;\n use std::mem;\n@@ -100,7 +100,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for OptimizationFinder<'b, 'a, 'tcx> {\n \n         if let Rvalue::Len(ref place) = *rvalue {\n             let place_ty = place.ty(&self.mir.local_decls, self.tcx).to_ty(self.tcx);\n-            if let TypeVariants::TyArray(_, len) = place_ty.sty {\n+            if let TyKind::Array(_, len) = place_ty.sty {\n                 let span = self.mir.source_info(location).span;\n                 let ty = self.tcx.types.usize;\n                 let constant = Constant { span, ty, literal: len };"}, {"sha": "8ed5600400b516e09f2abf3ef66cbdc2cf36b7b5", "filename": "src/librustc_mir/transform/lower_128bit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -13,7 +13,7 @@\n use rustc::hir::def_id::DefId;\n use rustc::middle::lang_items::LangItem;\n use rustc::mir::*;\n-use rustc::ty::{Slice, Ty, TyCtxt, TypeVariants};\n+use rustc::ty::{List, Ty, TyCtxt, TyKind};\n use rustc_data_structures::indexed_vec::{Idx};\n use transform::{MirPass, MirSource};\n use syntax;\n@@ -114,7 +114,7 @@ impl Lower128Bit {\n                         source_info,\n                         kind: TerminatorKind::Call {\n                             func: Operand::function_handle(tcx, call_did,\n-                                Slice::empty(), source_info.span),\n+                                List::empty(), source_info.span),\n                             args: vec![lhs, rhs],\n                             destination: Some((place, bb)),\n                             cleanup: None,\n@@ -190,8 +190,8 @@ impl RhsKind {\n \n fn sign_of_128bit(ty: Ty) -> Option<bool> {\n     match ty.sty {\n-        TypeVariants::TyInt(syntax::ast::IntTy::I128) => Some(true),\n-        TypeVariants::TyUint(syntax::ast::UintTy::U128) => Some(false),\n+        TyKind::Int(syntax::ast::IntTy::I128) => Some(true),\n+        TyKind::Uint(syntax::ast::UintTy::U128) => Some(false),\n         _ => None,\n     }\n }"}, {"sha": "a56399eecd38ef057c2273bf2a5b357a52077c3c", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -495,7 +495,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                                 this.add(Qualif::NOT_CONST);\n                             } else {\n                                 let base_ty = proj.base.ty(this.mir, this.tcx).to_ty(this.tcx);\n-                                if let ty::TyRawPtr(_) = base_ty.sty {\n+                                if let ty::RawPtr(_) = base_ty.sty {\n                                     if !this.tcx.sess.features_untracked().const_raw_ptr_deref {\n                                         emit_feature_err(\n                                             &this.tcx.sess.parse_sess, \"const_raw_ptr_deref\",\n@@ -591,7 +591,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n             if let Place::Projection(ref proj) = *place {\n                 if let ProjectionElem::Deref = proj.elem {\n                     let base_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n-                    if let ty::TyRef(..) = base_ty.sty {\n+                    if let ty::Ref(..) = base_ty.sty {\n                         is_reborrow = true;\n                     }\n                 }\n@@ -638,10 +638,10 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     if self.mode == Mode::StaticMut {\n                         // Inside a `static mut`, &mut [...] is also allowed.\n                         match ty.sty {\n-                            ty::TyArray(..) | ty::TySlice(_) => forbidden_mut = false,\n+                            ty::Array(..) | ty::Slice(_) => forbidden_mut = false,\n                             _ => {}\n                         }\n-                    } else if let ty::TyArray(_, len) = ty.sty {\n+                    } else if let ty::Array(_, len) = ty.sty {\n                         // FIXME(eddyb) the `self.mode == Mode::Fn` condition\n                         // seems unnecessary, given that this is merely a ZST.\n                         if len.unwrap_usize(self.tcx) == 0 && self.mode == Mode::Fn {\n@@ -745,7 +745,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n             }\n \n             Rvalue::BinaryOp(op, ref lhs, _) => {\n-                if let ty::TyRawPtr(_) = lhs.ty(self.mir, self.tcx).sty {\n+                if let ty::RawPtr(_) = lhs.ty(self.mir, self.tcx).sty {\n                     assert!(op == BinOp::Eq || op == BinOp::Ne ||\n                             op == BinOp::Le || op == BinOp::Lt ||\n                             op == BinOp::Ge || op == BinOp::Gt ||\n@@ -809,7 +809,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n             let fn_ty = func.ty(self.mir, self.tcx);\n             let mut callee_def_id = None;\n             let (mut is_shuffle, mut is_const_fn) = (false, None);\n-            if let ty::TyFnDef(def_id, _) = fn_ty.sty {\n+            if let ty::FnDef(def_id, _) = fn_ty.sty {\n                 callee_def_id = Some(def_id);\n                 match self.tcx.fn_sig(def_id).abi() {\n                     Abi::RustIntrinsic |"}, {"sha": "2147cc2a41a078f70065f9ea023c2aa649ceec96", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -229,7 +229,7 @@ fn is_rustc_peek<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if let Some(mir::Terminator { ref kind, source_info, .. }) = *terminator {\n         if let mir::TerminatorKind::Call { func: ref oper, ref args, .. } = *kind {\n             if let mir::Operand::Constant(ref func) = *oper {\n-                if let ty::TyFnDef(def_id, _) = func.ty.sty {\n+                if let ty::FnDef(def_id, _) = func.ty.sty {\n                     let abi = tcx.fn_sig(def_id).abi();\n                     let name = tcx.item_name(def_id);\n                     if abi == Abi::RustIntrinsic &&  name == \"rustc_peek\" {"}, {"sha": "78464b2a104ec301501e6d14d7f482ec8c47b619", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -80,7 +80,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UniformArrayMoveOutVisitor<'a, 'tcx> {\n                     // no need to transformation\n                 } else {\n                     let place_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n-                    if let ty::TyArray(item_ty, const_size) = place_ty.sty {\n+                    if let ty::Array(item_ty, const_size) = place_ty.sty {\n                         if let Some(size) = const_size.assert_usize(self.tcx) {\n                             assert!(size <= u32::max_value() as u64,\n                                     \"uniform array move out doesn't supported\n@@ -202,7 +202,7 @@ impl MirPass for RestoreSubsliceArrayMoveOut {\n                         let opt_src_place = items.first().and_then(|x| *x).map(|x| x.2);\n                         let opt_size = opt_src_place.and_then(|src_place| {\n                             let src_ty = src_place.ty(mir, tcx).to_ty(tcx);\n-                            if let ty::TyArray(_, ref size_o) = src_ty.sty {\n+                            if let ty::Array(_, ref size_o) = src_ty.sty {\n                                 size_o.assert_usize(tcx)\n                             } else {\n                                 None"}, {"sha": "8717bd08ae4a5ba90c39340e3ecdf61649e4e687", "filename": "src/librustc_mir/util/alignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Futil%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Futil%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Falignment.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -59,7 +59,7 @@ fn is_within_packed<'a, 'tcx, L>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             ProjectionElem::Field(..) => {\n                 let ty = base.ty(local_decls, tcx).to_ty(tcx);\n                 match ty.sty {\n-                    ty::TyAdt(def, _) if def.repr.packed() => {\n+                    ty::Adt(def, _) if def.repr.packed() => {\n                         return true\n                     }\n                     _ => {}"}, {"sha": "1c5e1e406911a9063a21a26c0b538dfe034b2e51", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -425,8 +425,8 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         o: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let type_name = match (&ty.sty, is_index) {\n-            (&ty::TyArray(_, _), Some(true)) | (&ty::TyArray(_, _), None) => \"array\",\n-            (&ty::TySlice(_), _) => \"slice\",\n+            (&ty::Array(_, _), Some(true)) | (&ty::Array(_, _), None) => \"array\",\n+            (&ty::Slice(_), _) => \"slice\",\n             _ => span_bug!(move_from_span, \"this path should not cause illegal move\"),\n         };\n         let mut err = struct_span_err!("}, {"sha": "45e405cb55e32df7651c00f3f54fc237b8fa78f2", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -787,7 +787,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     fn open_drop<'a>(&mut self) -> BasicBlock {\n         let ty = self.place_ty(self.place);\n         match ty.sty {\n-            ty::TyClosure(def_id, substs) => {\n+            ty::Closure(def_id, substs) => {\n                 let tys : Vec<_> = substs.upvar_tys(def_id, self.tcx()).collect();\n                 self.open_drop_for_tuple(&tys)\n             }\n@@ -797,30 +797,30 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             // This should only happen for the self argument on the resume function.\n             // It effetively only contains upvars until the generator transformation runs.\n             // See librustc_mir/transform/generator.rs for more details.\n-            ty::TyGenerator(def_id, substs, _) => {\n+            ty::Generator(def_id, substs, _) => {\n                 let tys : Vec<_> = substs.upvar_tys(def_id, self.tcx()).collect();\n                 self.open_drop_for_tuple(&tys)\n             }\n-            ty::TyTuple(tys) => {\n+            ty::Tuple(tys) => {\n                 self.open_drop_for_tuple(tys)\n             }\n-            ty::TyAdt(def, substs) => {\n+            ty::Adt(def, substs) => {\n                 if def.is_box() {\n                     self.open_drop_for_box(def, substs)\n                 } else {\n                     self.open_drop_for_adt(def, substs)\n                 }\n             }\n-            ty::TyDynamic(..) => {\n+            ty::Dynamic(..) => {\n                 let unwind = self.unwind; // FIXME(#43234)\n                 let succ = self.succ;\n                 self.complete_drop(Some(DropFlagMode::Deep), succ, unwind)\n             }\n-            ty::TyArray(ety, size) => {\n+            ty::Array(ety, size) => {\n                 let size = size.assert_usize(self.tcx());\n                 self.open_drop_for_array(ety, size)\n             },\n-            ty::TySlice(ety) => self.open_drop_for_array(ety, None),\n+            ty::Slice(ety) => self.open_drop_for_array(ety, None),\n \n             _ => bug!(\"open drop from non-ADT `{:?}`\", ty)\n         }"}, {"sha": "fca1c7f27ab37a590274385579ca5b7cf94a2efe", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -328,7 +328,7 @@ fn check_expr_kind<'a, 'tcx>(\n     e: &'tcx hir::Expr, node_ty: Ty<'tcx>) -> Promotability {\n \n     let ty_result = match node_ty.sty {\n-        ty::TyAdt(def, _) if def.has_dtor(v.tcx) => {\n+        ty::Adt(def, _) if def.has_dtor(v.tcx) => {\n             NotPromotable\n         }\n         _ => Promotable\n@@ -356,7 +356,7 @@ fn check_expr_kind<'a, 'tcx>(\n                 return NotPromotable;\n             }\n             match v.tables.node_id_to_type(lhs.hir_id).sty {\n-                ty::TyRawPtr(_) => {\n+                ty::RawPtr(_) => {\n                     assert!(op.node == hir::BinOpKind::Eq || op.node == hir::BinOpKind::Ne ||\n                         op.node == hir::BinOpKind::Le || op.node == hir::BinOpKind::Lt ||\n                         op.node == hir::BinOpKind::Ge || op.node == hir::BinOpKind::Gt);\n@@ -494,7 +494,7 @@ fn check_expr_kind<'a, 'tcx>(\n                 Some(ref expr) => { struct_result = struct_result & v.check_expr(&expr); },\n                 None => {},\n             }\n-            if let ty::TyAdt(adt, ..) = v.tables.expr_ty(e).sty {\n+            if let ty::Adt(adt, ..) = v.tables.expr_ty(e).sty {\n                 // unsafe_cell_type doesn't necessarily exist with no_core\n                 if Some(adt.did) == v.tcx.lang_items().unsafe_cell_type() {\n                     return NotPromotable;"}, {"sha": "dd536d673cf4d154249f7771322ade2f3d133c2e", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -89,11 +89,11 @@ struct ReachEverythingInTheInterfaceVisitor<'b, 'a: 'b, 'tcx: 'a> {\n impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n     fn item_ty_level(&self, item_def_id: DefId) -> Option<AccessLevel> {\n         let ty_def_id = match self.tcx.type_of(item_def_id).sty {\n-            ty::TyAdt(adt, _) => adt.did,\n-            ty::TyForeign(did) => did,\n-            ty::TyDynamic(ref obj, ..) if obj.principal().is_some() =>\n+            ty::Adt(adt, _) => adt.did,\n+            ty::Foreign(did) => did,\n+            ty::Dynamic(ref obj, ..) if obj.principal().is_some() =>\n                 obj.principal().unwrap().def_id(),\n-            ty::TyProjection(ref proj) => proj.trait_ref(self.tcx).def_id,\n+            ty::Projection(ref proj) => proj.trait_ref(self.tcx).def_id,\n             _ => return Some(AccessLevel::Public)\n         };\n         if let Some(node_id) = self.tcx.hir.as_local_node_id(ty_def_id) {\n@@ -443,7 +443,7 @@ impl<'b, 'a, 'tcx> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n     fn ty(&mut self) -> &mut Self {\n         let ty = self.ev.tcx.type_of(self.item_def_id);\n         ty.visit_with(self);\n-        if let ty::TyFnDef(def_id, _) = ty.sty {\n+        if let ty::FnDef(def_id, _) = ty.sty {\n             if def_id == self.item_def_id {\n                 self.ev.tcx.fn_sig(def_id).visit_with(self);\n             }\n@@ -470,14 +470,14 @@ impl<'b, 'a, 'tcx> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n impl<'b, 'a, 'tcx> TypeVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n         let ty_def_id = match ty.sty {\n-            ty::TyAdt(adt, _) => Some(adt.did),\n-            ty::TyForeign(did) => Some(did),\n-            ty::TyDynamic(ref obj, ..) => obj.principal().map(|p| p.def_id()),\n-            ty::TyProjection(ref proj) => Some(proj.item_def_id),\n-            ty::TyFnDef(def_id, ..) |\n-            ty::TyClosure(def_id, ..) |\n-            ty::TyGenerator(def_id, ..) |\n-            ty::TyAnon(def_id, _) => Some(def_id),\n+            ty::Adt(adt, _) => Some(adt.did),\n+            ty::Foreign(did) => Some(did),\n+            ty::Dynamic(ref obj, ..) => obj.principal().map(|p| p.def_id()),\n+            ty::Projection(ref proj) => Some(proj.item_def_id),\n+            ty::FnDef(def_id, ..) |\n+            ty::Closure(def_id, ..) |\n+            ty::Generator(def_id, ..) |\n+            ty::Anon(def_id, _) => Some(def_id),\n             _ => None\n         };\n \n@@ -896,15 +896,15 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n impl<'a, 'tcx> TypeVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n         match ty.sty {\n-            ty::TyAdt(&ty::AdtDef { did: def_id, .. }, ..) |\n-            ty::TyFnDef(def_id, ..) |\n-            ty::TyForeign(def_id) => {\n+            ty::Adt(&ty::AdtDef { did: def_id, .. }, ..) |\n+            ty::FnDef(def_id, ..) |\n+            ty::Foreign(def_id) => {\n                 if !self.item_is_accessible(def_id) {\n                     let msg = format!(\"type `{}` is private\", ty);\n                     self.tcx.sess.span_err(self.span, &msg);\n                     return true;\n                 }\n-                if let ty::TyFnDef(..) = ty.sty {\n+                if let ty::FnDef(..) = ty.sty {\n                     if self.tcx.fn_sig(def_id).visit_with(self) {\n                         return true;\n                     }\n@@ -919,7 +919,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n                     }\n                 }\n             }\n-            ty::TyDynamic(ref predicates, ..) => {\n+            ty::Dynamic(ref predicates, ..) => {\n                 let is_private = predicates.skip_binder().iter().any(|predicate| {\n                     let def_id = match *predicate {\n                         ty::ExistentialPredicate::Trait(trait_ref) => trait_ref.def_id,\n@@ -935,13 +935,13 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n                     return true;\n                 }\n             }\n-            ty::TyProjection(ref proj) => {\n+            ty::Projection(ref proj) => {\n                 let tcx = self.tcx;\n                 if self.check_trait_ref(proj.trait_ref(tcx)) {\n                     return true;\n                 }\n             }\n-            ty::TyAnon(def_id, ..) => {\n+            ty::Anon(def_id, ..) => {\n                 for predicate in &self.tcx.predicates_of(def_id).predicates {\n                     let trait_ref = match *predicate {\n                         ty::Predicate::Trait(ref poly_trait_predicate) => {\n@@ -964,9 +964,9 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n                             return true;\n                         }\n                         for subst in trait_ref.substs.iter() {\n-                            // Skip repeated `TyAnon`s to avoid infinite recursion.\n+                            // Skip repeated `Anon`s to avoid infinite recursion.\n                             if let UnpackedKind::Type(ty) = subst.unpack() {\n-                                if let ty::TyAnon(def_id, ..) = ty.sty {\n+                                if let ty::Anon(def_id, ..) = ty.sty {\n                                     if !self.visited_anon_tys.insert(def_id) {\n                                         continue;\n                                     }\n@@ -1388,7 +1388,7 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n     fn ty(&mut self) -> &mut Self {\n         let ty = self.tcx.type_of(self.item_def_id);\n         ty.visit_with(self);\n-        if let ty::TyFnDef(def_id, _) = ty.sty {\n+        if let ty::FnDef(def_id, _) = ty.sty {\n             if def_id == self.item_def_id {\n                 self.tcx.fn_sig(def_id).visit_with(self);\n             }\n@@ -1434,10 +1434,10 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n impl<'a, 'tcx: 'a> TypeVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n         let ty_def_id = match ty.sty {\n-            ty::TyAdt(adt, _) => Some(adt.did),\n-            ty::TyForeign(did) => Some(did),\n-            ty::TyDynamic(ref obj, ..) => obj.principal().map(|p| p.def_id()),\n-            ty::TyProjection(ref proj) => {\n+            ty::Adt(adt, _) => Some(adt.did),\n+            ty::Foreign(did) => Some(did),\n+            ty::Dynamic(ref obj, ..) => obj.principal().map(|p| p.def_id()),\n+            ty::Projection(ref proj) => {\n                 if self.required_visibility == ty::Visibility::Invisible {\n                     // Conservatively approximate the whole type alias as public without\n                     // recursing into its components when determining impl publicity."}, {"sha": "80f6c263e199969648d80321edbe79fb49ad4612", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -656,7 +656,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 (Def::Static(self.definitions.local_def_id(item.id), m), ValueNS)\n             }\n             ForeignItemKind::Ty => {\n-                (Def::TyForeign(self.definitions.local_def_id(item.id)), TypeNS)\n+                (Def::ForeignTy(self.definitions.local_def_id(item.id)), TypeNS)\n             }\n             ForeignItemKind::Macro(_) => unreachable!(),\n         };\n@@ -692,7 +692,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                                              span);\n                 self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, expansion));\n             }\n-            Def::Variant(..) | Def::TyAlias(..) | Def::TyForeign(..) => {\n+            Def::Variant(..) | Def::TyAlias(..) | Def::ForeignTy(..) => {\n                 self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, expansion));\n             }\n             Def::Fn(..) | Def::Static(..) | Def::Const(..) | Def::VariantCtor(..) => {"}, {"sha": "3241459f64fd8e9c1a51484ad81dca3ba426c2ec", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -35,7 +35,7 @@ use self::TypeParameters::*;\n use self::RibKind::*;\n \n use rustc::hir::map::{Definitions, DefCollector};\n-use rustc::hir::{self, PrimTy, TyBool, TyChar, TyFloat, TyInt, TyUint, TyStr};\n+use rustc::hir::{self, PrimTy, Bool, Char, Float, Int, Uint, Str};\n use rustc::middle::cstore::CrateStore;\n use rustc::session::Session;\n use rustc::lint;\n@@ -539,7 +539,7 @@ impl<'a> PathSource<'a> {\n                 Def::Trait(..) | Def::TyAlias(..) | Def::AssociatedTy(..) |\n                 Def::PrimTy(..) | Def::TyParam(..) | Def::SelfTy(..) |\n                 Def::Existential(..) |\n-                Def::TyForeign(..) => true,\n+                Def::ForeignTy(..) => true,\n                 _ => false,\n             },\n             PathSource::Trait(AliasPossibility::No) => match def {\n@@ -1280,23 +1280,23 @@ impl PrimitiveTypeTable {\n     fn new() -> PrimitiveTypeTable {\n         let mut table = PrimitiveTypeTable { primitive_types: FxHashMap() };\n \n-        table.intern(\"bool\", TyBool);\n-        table.intern(\"char\", TyChar);\n-        table.intern(\"f32\", TyFloat(FloatTy::F32));\n-        table.intern(\"f64\", TyFloat(FloatTy::F64));\n-        table.intern(\"isize\", TyInt(IntTy::Isize));\n-        table.intern(\"i8\", TyInt(IntTy::I8));\n-        table.intern(\"i16\", TyInt(IntTy::I16));\n-        table.intern(\"i32\", TyInt(IntTy::I32));\n-        table.intern(\"i64\", TyInt(IntTy::I64));\n-        table.intern(\"i128\", TyInt(IntTy::I128));\n-        table.intern(\"str\", TyStr);\n-        table.intern(\"usize\", TyUint(UintTy::Usize));\n-        table.intern(\"u8\", TyUint(UintTy::U8));\n-        table.intern(\"u16\", TyUint(UintTy::U16));\n-        table.intern(\"u32\", TyUint(UintTy::U32));\n-        table.intern(\"u64\", TyUint(UintTy::U64));\n-        table.intern(\"u128\", TyUint(UintTy::U128));\n+        table.intern(\"bool\", Bool);\n+        table.intern(\"char\", Char);\n+        table.intern(\"f32\", Float(FloatTy::F32));\n+        table.intern(\"f64\", Float(FloatTy::F64));\n+        table.intern(\"isize\", Int(IntTy::Isize));\n+        table.intern(\"i8\", Int(IntTy::I8));\n+        table.intern(\"i16\", Int(IntTy::I16));\n+        table.intern(\"i32\", Int(IntTy::I32));\n+        table.intern(\"i64\", Int(IntTy::I64));\n+        table.intern(\"i128\", Int(IntTy::I128));\n+        table.intern(\"str\", Str);\n+        table.intern(\"usize\", Uint(UintTy::Usize));\n+        table.intern(\"u8\", Uint(UintTy::U8));\n+        table.intern(\"u16\", Uint(UintTy::U16));\n+        table.intern(\"u32\", Uint(UintTy::U32));\n+        table.intern(\"u64\", Uint(UintTy::U64));\n+        table.intern(\"u128\", Uint(UintTy::U128));\n         table\n     }\n \n@@ -3900,7 +3900,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 }\n             }\n             // Add primitive types to the mix\n-            if filter_fn(Def::PrimTy(TyBool)) {\n+            if filter_fn(Def::PrimTy(Bool)) {\n                 names.extend(\n                     self.primitive_type_table.primitive_types.iter().map(|(name, _)| name)\n                 )"}, {"sha": "9facd39ebea214cbff7c878cf59f3850b2386d26", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -534,7 +534,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     pub fn get_expr_data(&self, expr: &ast::Expr) -> Option<Data> {\n         let hir_node = self.tcx.hir.expect_expr(expr.id);\n         let ty = self.tables.expr_ty_adjusted_opt(&hir_node);\n-        if ty.is_none() || ty.unwrap().sty == ty::TyError {\n+        if ty.is_none() || ty.unwrap().sty == ty::Error {\n             return None;\n         }\n         match expr.node {\n@@ -551,7 +551,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     }\n                 };\n                 match self.tables.expr_ty_adjusted(&hir_node).sty {\n-                    ty::TyAdt(def, _) if !def.is_enum() => {\n+                    ty::Adt(def, _) if !def.is_enum() => {\n                         let variant = &def.non_enum_variant();\n                         let index = self.tcx.find_field_index(ident, variant).unwrap();\n                         let sub_span = self.span_utils.span_for_last_ident(expr.span);\n@@ -563,7 +563,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                             ref_id: id_from_def_id(variant.fields[index].did),\n                         }));\n                     }\n-                    ty::TyTuple(..) => None,\n+                    ty::Tuple(..) => None,\n                     _ => {\n                         debug!(\"Expected struct or union type, found {:?}\", ty);\n                         None\n@@ -572,7 +572,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             }\n             ast::ExprKind::Struct(ref path, ..) => {\n                 match self.tables.expr_ty_adjusted(&hir_node).sty {\n-                    ty::TyAdt(def, _) if !def.is_enum() => {\n+                    ty::Adt(def, _) if !def.is_enum() => {\n                         let sub_span = self.span_utils.span_for_last_ident(path.span);\n                         filter!(self.span_utils, sub_span, path.span, None);\n                         let span = self.span_from_span(sub_span.unwrap());\n@@ -674,7 +674,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     hir::QPath::Resolved(_, ref path) => path.def,\n                     hir::QPath::TypeRelative(..) => {\n                         let ty = hir_ty_to_ty(self.tcx, ty);\n-                        if let ty::TyProjection(proj) = ty.sty {\n+                        if let ty::Projection(proj) = ty.sty {\n                             return HirDef::AssociatedTy(proj.item_def_id);\n                         }\n                         HirDef::Err\n@@ -747,7 +747,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             HirDef::Union(def_id) |\n             HirDef::Enum(def_id) |\n             HirDef::TyAlias(def_id) |\n-            HirDef::TyForeign(def_id) |\n+            HirDef::ForeignTy(def_id) |\n             HirDef::TraitAlias(def_id) |\n             HirDef::AssociatedExistential(def_id) |\n             HirDef::AssociatedTy(def_id) |"}, {"sha": "4227144e204fbbf9bf7eef356830de21dd9e8c06", "filename": "src/librustc_traits/chalk_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_traits%2Fchalk_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_traits%2Fchalk_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -237,7 +237,7 @@ impl context::ContextOps<ChalkArenas<'gcx>> for ChalkContext<'cx, 'gcx> {\n //                    _ => false,\n //                },\n //                Kind::Type(ty) => match ty.sty {\n-//                    ty::TyInfer(ty::InferTy::CanonicalTy(cvar1)) => cvar == cvar1,\n+//                    ty::Infer(ty::InferTy::CanonicalTy(cvar1)) => cvar == cvar1,\n //                    _ => false,\n //                },\n //            })"}, {"sha": "a27a447ad4b0959d3b8101d69a18444347344c9d", "filename": "src/librustc_traits/dropck_outlives.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_traits%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_traits%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fdropck_outlives.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -119,11 +119,11 @@ fn dropck_outlives<'tcx>(\n                         match ty.sty {\n                             // All parameters live for the duration of the\n                             // function.\n-                            ty::TyParam(..) => {}\n+                            ty::Param(..) => {}\n \n                             // A projection that we couldn't resolve - it\n                             // might have a destructor.\n-                            ty::TyProjection(..) | ty::TyAnon(..) => {\n+                            ty::Projection(..) | ty::Anon(..) => {\n                                 result.kinds.push(ty.into());\n                             }\n \n@@ -173,39 +173,39 @@ fn dtorck_constraint_for_ty<'a, 'gcx, 'tcx>(\n     }\n \n     let result = match ty.sty {\n-        ty::TyBool\n-        | ty::TyChar\n-        | ty::TyInt(_)\n-        | ty::TyUint(_)\n-        | ty::TyFloat(_)\n-        | ty::TyStr\n-        | ty::TyNever\n-        | ty::TyForeign(..)\n-        | ty::TyRawPtr(..)\n-        | ty::TyRef(..)\n-        | ty::TyFnDef(..)\n-        | ty::TyFnPtr(_)\n-        | ty::TyGeneratorWitness(..) => {\n+        ty::Bool\n+        | ty::Char\n+        | ty::Int(_)\n+        | ty::Uint(_)\n+        | ty::Float(_)\n+        | ty::Str\n+        | ty::Never\n+        | ty::Foreign(..)\n+        | ty::RawPtr(..)\n+        | ty::Ref(..)\n+        | ty::FnDef(..)\n+        | ty::FnPtr(_)\n+        | ty::GeneratorWitness(..) => {\n             // these types never have a destructor\n             Ok(DtorckConstraint::empty())\n         }\n \n-        ty::TyArray(ety, _) | ty::TySlice(ety) => {\n+        ty::Array(ety, _) | ty::Slice(ety) => {\n             // single-element containers, behave like their element\n             dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ety)\n         }\n \n-        ty::TyTuple(tys) => tys\n+        ty::Tuple(tys) => tys\n             .iter()\n             .map(|ty| dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ty))\n             .collect(),\n \n-        ty::TyClosure(def_id, substs) => substs\n+        ty::Closure(def_id, substs) => substs\n             .upvar_tys(def_id, tcx)\n             .map(|ty| dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ty))\n             .collect(),\n \n-        ty::TyGenerator(def_id, substs, _movability) => {\n+        ty::Generator(def_id, substs, _movability) => {\n             // rust-lang/rust#49918: types can be constructed, stored\n             // in the interior, and sit idle when generator yields\n             // (and is subsequently dropped).\n@@ -216,7 +216,7 @@ fn dtorck_constraint_for_ty<'a, 'gcx, 'tcx>(\n             // its interior).\n             //\n             // However, the interior's representation uses things like\n-            // TyGeneratorWitness that explicitly assume they are not\n+            // GeneratorWitness that explicitly assume they are not\n             // traversed in such a manner. So instead, we will\n             // simplify things for now by treating all generators as\n             // if they were like trait objects, where its upvars must\n@@ -242,7 +242,7 @@ fn dtorck_constraint_for_ty<'a, 'gcx, 'tcx>(\n             Ok(constraint)\n         }\n \n-        ty::TyAdt(def, substs) => {\n+        ty::Adt(def, substs) => {\n             let DtorckConstraint {\n                 dtorck_types,\n                 outlives,\n@@ -259,20 +259,20 @@ fn dtorck_constraint_for_ty<'a, 'gcx, 'tcx>(\n \n         // Objects must be alive in order for their destructor\n         // to be called.\n-        ty::TyDynamic(..) => Ok(DtorckConstraint {\n+        ty::Dynamic(..) => Ok(DtorckConstraint {\n             outlives: vec![ty.into()],\n             dtorck_types: vec![],\n             overflows: vec![],\n         }),\n \n         // Types that can't be resolved. Pass them forward.\n-        ty::TyProjection(..) | ty::TyAnon(..) | ty::TyParam(..) => Ok(DtorckConstraint {\n+        ty::Projection(..) | ty::Anon(..) | ty::Param(..) => Ok(DtorckConstraint {\n             outlives: vec![],\n             dtorck_types: vec![ty],\n             overflows: vec![],\n         }),\n \n-        ty::TyInfer(..) | ty::TyError => {\n+        ty::Infer(..) | ty::Error => {\n             // By the time this code runs, all type variables ought to\n             // be fully resolved.\n             Err(NoSolution)"}, {"sha": "9fd3b318ec14038ef7ff1bf9c5b81b5badcc1125", "filename": "src/librustc_traits/lowering.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_traits%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_traits%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -17,7 +17,7 @@ use rustc::traits::{\n     WhereClause,\n };\n use rustc::ty::query::Providers;\n-use rustc::ty::{self, Slice, TyCtxt};\n+use rustc::ty::{self, List, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n use std::mem;\n use syntax::ast;\n@@ -162,7 +162,7 @@ crate fn program_clauses_for<'a, 'tcx>(\n         DefPathData::AssocTypeInImpl(..) => program_clauses_for_associated_type_value(tcx, def_id),\n         DefPathData::AssocTypeInTrait(..) => program_clauses_for_associated_type_def(tcx, def_id),\n         DefPathData::TypeNs(..) => program_clauses_for_type_def(tcx, def_id),\n-        _ => Slice::empty(),\n+        _ => List::empty(),\n     }\n }\n \n@@ -319,7 +319,7 @@ fn program_clauses_for_trait<'a, 'tcx>(\n \n fn program_clauses_for_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Clauses<'tcx> {\n     if let ImplPolarity::Negative = tcx.impl_polarity(def_id) {\n-        return Slice::empty();\n+        return List::empty();\n     }\n \n     // Rule Implemented-From-Impl (see rustc guide)"}, {"sha": "a528c8e9b4f96d26932851085cf648d88b9a6b9f", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -108,7 +108,7 @@ struct GenericArgMismatchErrorCode {\n /// Dummy type used for the `Self` of a `TraitRef` created for converting\n /// a trait object, and which gets removed in `ExistentialTraitRef`.\n /// This type must not appear anywhere in other converted types.\n-const TRAIT_OBJECT_DUMMY_SELF: ty::TypeVariants<'static> = ty::TyInfer(ty::FreshTy(0));\n+const TRAIT_OBJECT_DUMMY_SELF: ty::TyKind<'static> = ty::Infer(ty::FreshTy(0));\n \n impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n     pub fn ast_region_to_region(&self,\n@@ -1239,8 +1239,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                     Err(ErrorReported) => return (tcx.types.err, Def::Err),\n                 }\n             }\n-            (&ty::TyParam(_), Def::SelfTy(Some(param_did), None)) |\n-            (&ty::TyParam(_), Def::TyParam(param_did)) => {\n+            (&ty::Param(_), Def::SelfTy(Some(param_did), None)) |\n+            (&ty::Param(_), Def::TyParam(param_did)) => {\n                 match self.find_bound_for_assoc_item(param_did, assoc_name, span) {\n                     Ok(bound) => bound,\n                     Err(ErrorReported) => return (tcx.types.err, Def::Err),\n@@ -1387,7 +1387,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 )\n             }\n             Def::Enum(did) | Def::TyAlias(did) | Def::Struct(did) |\n-            Def::Union(did) | Def::TyForeign(did) => {\n+            Def::Union(did) | Def::ForeignTy(did) => {\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(path.segments.split_last().unwrap().1);\n                 self.ast_path_to_ty(span, did, path.segments.last().unwrap())\n@@ -1438,12 +1438,12 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(&path.segments);\n                 match prim_ty {\n-                    hir::TyBool => tcx.types.bool,\n-                    hir::TyChar => tcx.types.char,\n-                    hir::TyInt(it) => tcx.mk_mach_int(it),\n-                    hir::TyUint(uit) => tcx.mk_mach_uint(uit),\n-                    hir::TyFloat(ft) => tcx.mk_mach_float(ft),\n-                    hir::TyStr => tcx.mk_str()\n+                    hir::Bool => tcx.types.bool,\n+                    hir::Char => tcx.types.char,\n+                    hir::Int(it) => tcx.mk_mach_int(it),\n+                    hir::Uint(uit) => tcx.mk_mach_uint(uit),\n+                    hir::Float(ft) => tcx.mk_mach_float(ft),\n+                    hir::Str => tcx.mk_str()\n                 }\n             }\n             Def::Err => {\n@@ -1474,7 +1474,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             }\n             hir::TyKind::Rptr(ref region, ref mt) => {\n                 let r = self.ast_region_to_region(region, None);\n-                debug!(\"TyRef r={:?}\", r);\n+                debug!(\"Ref r={:?}\", r);\n                 let t = self.ast_ty_to_ty(&mt.ty);\n                 tcx.mk_ref(r, ty::TypeAndMut {ty: t, mutbl: mt.mutbl})\n             }\n@@ -1513,7 +1513,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 let length_def_id = tcx.hir.local_def_id(length.id);\n                 let substs = Substs::identity_for_item(tcx, length_def_id);\n                 let length = ty::Const::unevaluated(tcx, length_def_id, substs, tcx.types.usize);\n-                let array_ty = tcx.mk_ty(ty::TyArray(self.ast_ty_to_ty(&ty), length));\n+                let array_ty = tcx.mk_ty(ty::Array(self.ast_ty_to_ty(&ty), length));\n                 self.normalize_ty(ast_ty.span, array_ty)\n             }\n             hir::TyKind::Typeof(ref _e) => {\n@@ -1525,7 +1525,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 tcx.types.err\n             }\n             hir::TyKind::Infer => {\n-                // TyInfer also appears as the type of arguments or return\n+                // Infer also appears as the type of arguments or return\n                 // values in a ExprKind::Closure, or as\n                 // the type of local variables. Both of these cases are\n                 // handled specially and will not descend into this routine.\n@@ -1666,7 +1666,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n     /// we return `None`.\n     fn compute_object_lifetime_bound(&self,\n         span: Span,\n-        existential_predicates: ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>)\n+        existential_predicates: ty::Binder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>)\n         -> Option<ty::Region<'tcx>> // if None, use the default\n     {\n         let tcx = self.tcx();"}, {"sha": "ae68584f2446f617cf0c4440f273059049ead174", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -53,7 +53,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             PatKind::Lit(ref lt) => {\n                 let ty = self.check_expr(lt);\n                 match ty.sty {\n-                    ty::TypeVariants::TyRef(..) => false,\n+                    ty::Ref(..) => false,\n                     _ => true,\n                 }\n             }\n@@ -74,7 +74,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             // Peel off as many `&` or `&mut` from the discriminant as possible. For example,\n             // for `match &&&mut Some(5)` the loop runs three times, aborting when it reaches\n-            // the `Some(5)` which is not of type TyRef.\n+            // the `Some(5)` which is not of type Ref.\n             //\n             // For each ampersand peeled off, update the binding mode and push the original\n             // type into the adjustments vector.\n@@ -84,8 +84,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             expected = loop {\n                 debug!(\"inspecting {:?} with type {:?}\", exp_ty, exp_ty.sty);\n                 match exp_ty.sty {\n-                    ty::TypeVariants::TyRef(_, inner_ty, inner_mutability) => {\n-                        debug!(\"current discriminant is TyRef, inserting implicit deref\");\n+                    ty::Ref(_, inner_ty, inner_mutability) => {\n+                        debug!(\"current discriminant is Ref, inserting implicit deref\");\n                         // Preserve the reference type. We'll need it later during HAIR lowering.\n                         pat_adjustments.push(exp_ty);\n \n@@ -150,8 +150,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if let hir::ExprKind::Lit(ref lt) = lt.node {\n                     if let ast::LitKind::ByteStr(_) = lt.node {\n                         let expected_ty = self.structurally_resolved_type(pat.span, expected);\n-                        if let ty::TyRef(_, r_ty, _) = expected_ty.sty {\n-                            if let ty::TySlice(_) = r_ty.sty {\n+                        if let ty::Ref(_, r_ty, _) = expected_ty.sty {\n+                            if let ty::Slice(_) = r_ty.sty {\n                                 pat_ty = tcx.mk_imm_ref(tcx.types.re_static,\n                                                          tcx.mk_slice(tcx.types.u8))\n                             }\n@@ -285,7 +285,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let mut expected_len = elements.len();\n                 if ddpos.is_some() {\n                     // Require known type only when `..` is present\n-                    if let ty::TyTuple(ref tys) =\n+                    if let ty::Tuple(ref tys) =\n                             self.structurally_resolved_type(pat.span, expected).sty {\n                         expected_len = tys.len();\n                     }\n@@ -297,7 +297,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     //       from all tuple elements isn't trivial.\n                     TypeVariableOrigin::TypeInference(pat.span)));\n                 let element_tys = tcx.mk_type_list(element_tys_iter);\n-                let pat_ty = tcx.mk_ty(ty::TyTuple(element_tys));\n+                let pat_ty = tcx.mk_ty(ty::Tuple(element_tys));\n                 self.demand_eqtype(pat.span, expected, pat_ty);\n                 for (i, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n                     self.check_pat_walk(elem, &element_tys[i], def_bm, true);\n@@ -333,7 +333,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // hack detailed in (*) below.\n                     debug!(\"check_pat_walk: expected={:?}\", expected);\n                     let (rptr_ty, inner_ty) = match expected.sty {\n-                        ty::TyRef(_, r_ty, r_mutbl) if r_mutbl == mutbl => {\n+                        ty::Ref(_, r_ty, r_mutbl) if r_mutbl == mutbl => {\n                             (expected, r_ty)\n                         }\n                         _ => {\n@@ -375,7 +375,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             PatKind::Slice(ref before, ref slice, ref after) => {\n                 let expected_ty = self.structurally_resolved_type(pat.span, expected);\n                 let (inner_ty, slice_ty) = match expected_ty.sty {\n-                    ty::TyArray(inner_ty, size) => {\n+                    ty::Array(inner_ty, size) => {\n                         let size = size.unwrap_usize(tcx);\n                         let min_len = before.len() as u64 + after.len() as u64;\n                         if slice.is_none() {\n@@ -400,16 +400,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             (inner_ty, tcx.types.err)\n                         }\n                     }\n-                    ty::TySlice(inner_ty) => (inner_ty, expected_ty),\n+                    ty::Slice(inner_ty) => (inner_ty, expected_ty),\n                     _ => {\n                         if !expected_ty.references_error() {\n                             let mut err = struct_span_err!(\n                                 tcx.sess, pat.span, E0529,\n                                 \"expected an array or slice, found `{}`\",\n                                 expected_ty);\n-                            if let ty::TyRef(_, ty, _) = expected_ty.sty {\n+                            if let ty::Ref(_, ty, _) = expected_ty.sty {\n                                 match ty.sty {\n-                                    ty::TyArray(..) | ty::TySlice(..) => {\n+                                    ty::Array(..) | ty::Slice(..) => {\n                                         err.help(\"the semantics of slice patterns changed \\\n                                                   recently; see issue #23121\");\n                                     }\n@@ -493,7 +493,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn check_dereferencable(&self, span: Span, expected: Ty<'tcx>, inner: &hir::Pat) -> bool {\n         if let PatKind::Binding(..) = inner.node {\n             if let Some(mt) = self.shallow_resolve(expected).builtin_deref(true) {\n-                if let ty::TyDynamic(..) = mt.ty.sty {\n+                if let ty::Dynamic(..) = mt.ty.sty {\n                     // This is \"x = SomeTrait\" being reduced from\n                     // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n                     let type_str = self.ty_to_string(expected);\n@@ -818,7 +818,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         if subpats.len() == variant.fields.len() ||\n                 subpats.len() < variant.fields.len() && ddpos.is_some() {\n             let substs = match pat_ty.sty {\n-                ty::TyAdt(_, substs) => substs,\n+                ty::Adt(_, substs) => substs,\n                 ref ty => bug!(\"unexpected pattern type {:?}\", ty),\n             };\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(variant.fields.len(), ddpos) {\n@@ -854,7 +854,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         let tcx = self.tcx;\n \n         let (substs, adt) = match adt_ty.sty {\n-            ty::TyAdt(adt, substs) => (substs, adt),\n+            ty::Adt(adt, substs) => (substs, adt),\n             _ => span_bug!(span, \"struct pattern is not an ADT\")\n         };\n         let kind_name = adt.variant_descr();"}, {"sha": "743a2390ec43d5a9fcac17d62f0e0f4f689c0646", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -177,7 +177,7 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n                 self.fcx.try_overloaded_deref(self.span, source, needs)\n                     .and_then(|InferOk { value: method, obligations: o }| {\n                         obligations.extend(o);\n-                        if let ty::TyRef(region, _, mutbl) = method.sig.output().sty {\n+                        if let ty::Ref(region, _, mutbl) = method.sig.output().sty {\n                             Some(OverloadedDeref {\n                                 region,\n                                 mutbl,"}, {"sha": "462bde2ab4f13612d1c25fcd03738bd559859d01", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -95,13 +95,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // If the callee is a bare function or a closure, then we're all set.\n         match adjusted_ty.sty {\n-            ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n+            ty::FnDef(..) | ty::FnPtr(_) => {\n                 let adjustments = autoderef.adjust_steps(Needs::None);\n                 self.apply_adjustments(callee_expr, adjustments);\n                 return Some(CallStep::Builtin(adjusted_ty));\n             }\n \n-            ty::TyClosure(def_id, substs) => {\n+            ty::Closure(def_id, substs) => {\n                 assert_eq!(def_id.krate, LOCAL_CRATE);\n \n                 // Check whether this is a call to a closure where we\n@@ -135,7 +135,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // over the top. The simplest fix by far is to just ignore\n             // this case and deref again, so we wind up with\n             // `FnMut::call_mut(&mut *x, ())`.\n-            ty::TyRef(..) if autoderef.step_count() == 0 => {\n+            ty::Ref(..) if autoderef.step_count() == 0 => {\n                 return None;\n             }\n \n@@ -175,7 +175,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     let method = self.register_infer_ok_obligations(ok);\n                     let mut autoref = None;\n                     if borrow {\n-                        if let ty::TyRef(region, _, mutbl) = method.sig.inputs()[0].sty {\n+                        if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].sty {\n                             let mutbl = match mutbl {\n                                 hir::MutImmutable => AutoBorrowMutability::Immutable,\n                                 hir::MutMutable => AutoBorrowMutability::Mutable {\n@@ -206,13 +206,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             expected: Expectation<'tcx>)\n                             -> Ty<'tcx> {\n         let (fn_sig, def_span) = match callee_ty.sty {\n-            ty::TyFnDef(def_id, _) => {\n+            ty::FnDef(def_id, _) => {\n                 (callee_ty.fn_sig(self.tcx), self.tcx.hir.span_if_local(def_id))\n             }\n-            ty::TyFnPtr(sig) => (sig, None),\n+            ty::FnPtr(sig) => (sig, None),\n             ref t => {\n                 let mut unit_variant = None;\n-                if let &ty::TyAdt(adt_def, ..) = t {\n+                if let &ty::Adt(adt_def, ..) = t {\n                     if adt_def.is_enum() {\n                         if let hir::ExprKind::Call(ref expr, _) = call_expr.node {\n                             unit_variant = Some(self.tcx.hir.node_to_pretty_string(expr.id))"}, {"sha": "52e5e57f74759a64f9a18fffe86fe1b6db13048c", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -103,10 +103,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         Ok(match t.sty {\n-            ty::TySlice(_) | ty::TyStr => Some(PointerKind::Length),\n-            ty::TyDynamic(ref tty, ..) =>\n+            ty::Slice(_) | ty::Str => Some(PointerKind::Length),\n+            ty::Dynamic(ref tty, ..) =>\n                 Some(PointerKind::Vtable(tty.principal().map(|p| p.def_id()))),\n-            ty::TyAdt(def, substs) if def.is_struct() => {\n+            ty::Adt(def, substs) if def.is_struct() => {\n                 match def.non_enum_variant().fields.last() {\n                     None => Some(PointerKind::Thin),\n                     Some(f) => {\n@@ -115,25 +115,25 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n-            ty::TyTuple(fields) => match fields.last() {\n+            ty::Tuple(fields) => match fields.last() {\n                 None => Some(PointerKind::Thin),\n                 Some(f) => self.pointer_kind(f, span)?\n             },\n \n             // Pointers to foreign types are thin, despite being unsized\n-            ty::TyForeign(..) => Some(PointerKind::Thin),\n+            ty::Foreign(..) => Some(PointerKind::Thin),\n             // We should really try to normalize here.\n-            ty::TyProjection(ref pi) => Some(PointerKind::OfProjection(pi)),\n-            ty::TyAnon(def_id, substs) => Some(PointerKind::OfAnon(def_id, substs)),\n-            ty::TyParam(ref p) => Some(PointerKind::OfParam(p)),\n+            ty::Projection(ref pi) => Some(PointerKind::OfProjection(pi)),\n+            ty::Anon(def_id, substs) => Some(PointerKind::OfAnon(def_id, substs)),\n+            ty::Param(ref p) => Some(PointerKind::OfParam(p)),\n             // Insufficient type information.\n-            ty::TyInfer(_) => None,\n+            ty::Infer(_) => None,\n \n-            ty::TyBool | ty::TyChar | ty::TyInt(..) | ty::TyUint(..) |\n-            ty::TyFloat(_) | ty::TyArray(..) | ty::TyGeneratorWitness(..) |\n-            ty::TyRawPtr(_) | ty::TyRef(..) | ty::TyFnDef(..) |\n-            ty::TyFnPtr(..) | ty::TyClosure(..) | ty::TyGenerator(..) |\n-            ty::TyAdt(..) | ty::TyNever | ty::TyError => {\n+            ty::Bool | ty::Char | ty::Int(..) | ty::Uint(..) |\n+            ty::Float(_) | ty::Array(..) | ty::GeneratorWitness(..) |\n+            ty::RawPtr(_) | ty::Ref(..) | ty::FnDef(..) |\n+            ty::FnPtr(..) | ty::Closure(..) | ty::Generator(..) |\n+            ty::Adt(..) | ty::Never | ty::Error => {\n                 self.tcx.sess.delay_span_bug(\n                     span, &format!(\"`{:?}` should be sized but is not?\", t));\n                 return Err(ErrorReported);\n@@ -199,7 +199,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         // cases now. We do a more thorough check at the end, once\n         // inference is more completely known.\n         match cast_ty.sty {\n-            ty::TyDynamic(..) | ty::TySlice(..) => {\n+            ty::Dynamic(..) | ty::Slice(..) => {\n                 check.report_cast_to_unsized_type(fcx);\n                 Err(ErrorReported)\n             }\n@@ -319,7 +319,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                                          fcx.resolve_type_vars_if_possible(&self.expr_ty),\n                                          tstr);\n         match self.expr_ty.sty {\n-            ty::TyRef(_, _, mt) => {\n+            ty::Ref(_, _, mt) => {\n                 let mtstr = match mt {\n                     hir::MutMutable => \"mut \",\n                     hir::MutImmutable => \"\",\n@@ -343,7 +343,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                                tstr);\n                 }\n             }\n-            ty::TyAdt(def, ..) if def.is_box() => {\n+            ty::Adt(def, ..) if def.is_box() => {\n                 match fcx.tcx.sess.source_map().span_to_snippet(self.cast_span) {\n                     Ok(s) => {\n                         err.span_suggestion(self.cast_span,\n@@ -429,7 +429,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n             (Some(t_from), Some(t_cast)) => (t_from, t_cast),\n             // Function item types may need to be reified before casts.\n             (None, Some(t_cast)) => {\n-                if let ty::TyFnDef(..) = self.expr_ty.sty {\n+                if let ty::FnDef(..) = self.expr_ty.sty {\n                     // Attempt a coercion to a fn pointer type.\n                     let f = self.expr_ty.fn_sig(fcx.tcx);\n                     let res = fcx.try_coerce(self.expr,\n@@ -477,12 +477,12 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n             (RPtr(p), Int(_)) |\n             (RPtr(p), Float) => {\n                 match p.ty.sty {\n-                    ty::TypeVariants::TyInt(_) |\n-                    ty::TypeVariants::TyUint(_) |\n-                    ty::TypeVariants::TyFloat(_) => {\n+                    ty::Int(_) |\n+                    ty::Uint(_) |\n+                    ty::Float(_) => {\n                         Err(CastError::NeedDeref)\n                     }\n-                    ty::TypeVariants::TyInfer(t) => {\n+                    ty::Infer(t) => {\n                         match t {\n                             ty::InferTy::IntVar(_) |\n                             ty::InferTy::FloatVar(_) => Err(CastError::NeedDeref),\n@@ -583,7 +583,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         // array-ptr-cast.\n \n         if m_expr.mutbl == hir::MutImmutable && m_cast.mutbl == hir::MutImmutable {\n-            if let ty::TyArray(ety, _) = m_expr.ty.sty {\n+            if let ty::Array(ety, _) = m_expr.ty.sty {\n                 // Due to the limitations of LLVM global constants,\n                 // region pointers end up pointing at copies of\n                 // vector elements instead of the original values."}, {"sha": "a283e032e0e023a11654a66d81575c0300a236bf", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -190,7 +190,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         );\n \n         match expected_ty.sty {\n-            ty::TyDynamic(ref object_type, ..) => {\n+            ty::Dynamic(ref object_type, ..) => {\n                 let sig = object_type\n                     .projection_bounds()\n                     .filter_map(|pb| {\n@@ -203,8 +203,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     .and_then(|p| self.tcx.lang_items().fn_trait_kind(p.def_id()));\n                 (sig, kind)\n             }\n-            ty::TyInfer(ty::TyVar(vid)) => self.deduce_expectations_from_obligations(vid),\n-            ty::TyFnPtr(sig) => {\n+            ty::Infer(ty::TyVar(vid)) => self.deduce_expectations_from_obligations(vid),\n+            ty::FnPtr(sig) => {\n                 let expected_sig = ExpectedSig {\n                     cause_span: None,\n                     sig: sig.skip_binder().clone(),\n@@ -269,9 +269,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                     // NB: This predicate is created by breaking down a\n                     // `ClosureType: FnFoo()` predicate, where\n-                    // `ClosureType` represents some `TyClosure`. It can't\n+                    // `ClosureType` represents some `Closure`. It can't\n                     // possibly be referring to the current closure,\n-                    // because we haven't produced the `TyClosure` for\n+                    // because we haven't produced the `Closure` for\n                     // this closure yet; this is exactly why the other\n                     // code is looking for a self type of a unresolved\n                     // inference variable.\n@@ -317,7 +317,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         );\n \n         let input_tys = match arg_param_ty.sty {\n-            ty::TyTuple(tys) => tys.into_iter(),\n+            ty::Tuple(tys) => tys.into_iter(),\n             _ => {\n                 return None;\n             }\n@@ -353,7 +353,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             trait_ref, self_ty\n         );\n         match self_ty.sty {\n-            ty::TyInfer(ty::TyVar(v)) if expected_vid == v => Some(trait_ref),\n+            ty::Infer(ty::TyVar(v)) if expected_vid == v => Some(trait_ref),\n             _ => None,\n         }\n     }"}, {"sha": "763adb007c3a4d791e8fbea3a4ad5bc702f26e60", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -210,11 +210,11 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         // Note: does not attempt to resolve type variables we encounter.\n         // See above for details.\n         match b.sty {\n-            ty::TyRawPtr(mt_b) => {\n+            ty::RawPtr(mt_b) => {\n                 return self.coerce_unsafe_ptr(a, b, mt_b.mutbl);\n             }\n \n-            ty::TyRef(r_b, ty, mutbl) => {\n+            ty::Ref(r_b, ty, mutbl) => {\n                 let mt_b = ty::TypeAndMut { ty, mutbl };\n                 return self.coerce_borrowed_pointer(a, b, r_b, mt_b);\n             }\n@@ -223,20 +223,20 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         }\n \n         match a.sty {\n-            ty::TyFnDef(..) => {\n+            ty::FnDef(..) => {\n                 // Function items are coercible to any closure\n                 // type; function pointers are not (that would\n                 // require double indirection).\n                 // Additionally, we permit coercion of function\n                 // items to drop the unsafe qualifier.\n                 self.coerce_from_fn_item(a, b)\n             }\n-            ty::TyFnPtr(a_f) => {\n+            ty::FnPtr(a_f) => {\n                 // We permit coercion of fn pointers to drop the\n                 // unsafe qualifier.\n                 self.coerce_from_fn_pointer(a, a_f, b)\n             }\n-            ty::TyClosure(def_id_a, substs_a) => {\n+            ty::Closure(def_id_a, substs_a) => {\n                 // Non-capturing closures are coercible to\n                 // function pointers\n                 self.coerce_closure_to_fn(a, def_id_a, substs_a, b)\n@@ -267,7 +267,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         // yield.\n \n         let (r_a, mt_a) = match a.sty {\n-            ty::TyRef(r_a, ty, mutbl) => {\n+            ty::Ref(r_a, ty, mutbl) => {\n                 let mt_a = ty::TypeAndMut { ty, mutbl };\n                 coerce_mutbls(mt_a.mutbl, mt_b.mutbl)?;\n                 (r_a, mt_a)\n@@ -429,7 +429,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         // Now apply the autoref. We have to extract the region out of\n         // the final ref type we got.\n         let r_borrow = match ty.sty {\n-            ty::TyRef(r_borrow, _, _) => r_borrow,\n+            ty::Ref(r_borrow, _, _) => r_borrow,\n             _ => span_bug!(span, \"expected a ref type, got {:?}\", ty),\n         };\n         let mutbl = match mt_b.mutbl {\n@@ -473,7 +473,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n         // Handle reborrows before selecting `Source: CoerceUnsized<Target>`.\n         let reborrow = match (&source.sty, &target.sty) {\n-            (&ty::TyRef(_, ty_a, mutbl_a), &ty::TyRef(_, _, mutbl_b)) => {\n+            (&ty::Ref(_, ty_a, mutbl_a), &ty::Ref(_, _, mutbl_b)) => {\n                 coerce_mutbls(mutbl_a, mutbl_b)?;\n \n                 let coercion = Coercion(self.cause.span);\n@@ -498,7 +498,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                     })\n                 }))\n             }\n-            (&ty::TyRef(_, ty_a, mt_a), &ty::TyRawPtr(ty::TypeAndMut { mutbl: mt_b, .. })) => {\n+            (&ty::Ref(_, ty_a, mt_a), &ty::RawPtr(ty::TypeAndMut { mutbl: mt_b, .. })) => {\n                 coerce_mutbls(mt_a, mt_b)?;\n \n                 Some((Adjustment {\n@@ -562,7 +562,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 ty::Predicate::Trait(ref tr) if traits.contains(&tr.def_id()) => {\n                     if unsize_did == tr.def_id() {\n                         let sty = &tr.skip_binder().input_types().nth(1).unwrap().sty;\n-                        if let ty::TyTuple(..) = sty {\n+                        if let ty::Tuple(..) = sty {\n                             debug!(\"coerce_unsized: found unsized tuple coercion\");\n                             has_unsized_tuple_coercion = true;\n                         }\n@@ -619,7 +619,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         where F: FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>>,\n               G: FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>>\n     {\n-        if let ty::TyFnPtr(fn_ty_b) = b.sty {\n+        if let ty::FnPtr(fn_ty_b) = b.sty {\n             match (fn_ty_a.unsafety(), fn_ty_b.unsafety()) {\n                 (hir::Unsafety::Normal, hir::Unsafety::Unsafe) => {\n                     let unsafe_a = self.tcx.safe_to_unsafe_fn_ty(fn_ty_a);\n@@ -659,7 +659,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         debug!(\"coerce_from_fn_item(a={:?}, b={:?})\", a, b);\n \n         match b.sty {\n-            ty::TyFnPtr(_) => {\n+            ty::FnPtr(_) => {\n                 let a_sig = a.fn_sig(self.tcx);\n                 let InferOk { value: a_sig, mut obligations } =\n                     self.normalize_associated_types_in_as_infer_ok(self.cause.span, &a_sig);\n@@ -699,7 +699,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n         let node_id_a = self.tcx.hir.as_local_node_id(def_id_a).unwrap();\n         match b.sty {\n-            ty::TyFnPtr(_) if self.tcx.with_freevars(node_id_a, |v| v.is_empty()) => {\n+            ty::FnPtr(_) if self.tcx.with_freevars(node_id_a, |v| v.is_empty()) => {\n                 // We coerce the closure, which has fn type\n                 //     `extern \"rust-call\" fn((arg0,arg1,...)) -> _`\n                 // to\n@@ -722,8 +722,8 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         debug!(\"coerce_unsafe_ptr(a={:?}, b={:?})\", a, b);\n \n         let (is_ref, mt_a) = match a.sty {\n-            ty::TyRef(_, ty, mutbl) => (true, ty::TypeAndMut { ty, mutbl }),\n-            ty::TyRawPtr(mt) => (false, mt),\n+            ty::Ref(_, ty, mutbl) => (true, ty::TypeAndMut { ty, mutbl }),\n+            ty::RawPtr(mt) => (false, mt),\n             _ => {\n                 return self.unify_and(a, b, identity);\n             }\n@@ -811,7 +811,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Special-case that coercion alone cannot handle:\n         // Two function item types of differing IDs or Substs.\n-        if let (&ty::TyFnDef(..), &ty::TyFnDef(..)) = (&prev_ty.sty, &new_ty.sty) {\n+        if let (&ty::FnDef(..), &ty::FnDef(..)) = (&prev_ty.sty, &new_ty.sty) {\n             // Don't reify if the function types have a LUB, i.e. they\n             // are the same function and their parameters have a LUB.\n             let lub_ty = self.commit_if_ok(|_| {\n@@ -881,7 +881,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(_, mutbl_adj)), .. }\n                 ] => {\n                     match self.node_ty(expr.hir_id).sty {\n-                        ty::TyRef(_, _, mt_orig) => {\n+                        ty::Ref(_, _, mt_orig) => {\n                             let mutbl_adj: hir::Mutability = mutbl_adj.into();\n                             // Reborrow that we can safely ignore, because\n                             // the next adjustment can only be a Deref"}, {"sha": "7dc57c710bf26f34e0841f7bbfc34bc11b89ff32", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -114,7 +114,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // If the expected type is an enum with any variants whose sole\n         // field is of the found type, suggest such variants. See Issue\n         // #42764.\n-        if let ty::TyAdt(expected_adt, substs) = expected.sty {\n+        if let ty::Adt(expected_adt, substs) = expected.sty {\n             let mut compatible_variants = vec![];\n             for variant in &expected_adt.variants {\n                 if variant.fields.len() == 1 {\n@@ -259,9 +259,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         match (&expected.sty, &checked_ty.sty) {\n-            (&ty::TyRef(_, exp, _), &ty::TyRef(_, check, _)) => match (&exp.sty, &check.sty) {\n-                (&ty::TyStr, &ty::TyArray(arr, _)) |\n-                (&ty::TyStr, &ty::TySlice(arr)) if arr == self.tcx.types.u8 => {\n+            (&ty::Ref(_, exp, _), &ty::Ref(_, check, _)) => match (&exp.sty, &check.sty) {\n+                (&ty::Str, &ty::Array(arr, _)) |\n+                (&ty::Str, &ty::Slice(arr)) if arr == self.tcx.types.u8 => {\n                     if let hir::ExprKind::Lit(_) = expr.node {\n                         if let Ok(src) = cm.span_to_snippet(sp) {\n                             if src.starts_with(\"b\\\"\") {\n@@ -272,8 +272,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         }\n                     }\n                 },\n-                (&ty::TyArray(arr, _), &ty::TyStr) |\n-                (&ty::TySlice(arr), &ty::TyStr) if arr == self.tcx.types.u8 => {\n+                (&ty::Array(arr, _), &ty::Str) |\n+                (&ty::Slice(arr), &ty::Str) if arr == self.tcx.types.u8 => {\n                     if let hir::ExprKind::Lit(_) = expr.node {\n                         if let Ok(src) = cm.span_to_snippet(sp) {\n                             if src.starts_with(\"\\\"\") {\n@@ -286,7 +286,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 _ => {}\n             },\n-            (&ty::TyRef(_, _, mutability), _) => {\n+            (&ty::Ref(_, _, mutability), _) => {\n                 // Check if it can work when put into a ref. For example:\n                 //\n                 // ```\n@@ -325,7 +325,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n-            (_, &ty::TyRef(_, checked, _)) => {\n+            (_, &ty::Ref(_, checked, _)) => {\n                 // We have `&T`, check if what was expected was `T`. If so,\n                 // we may want to suggest adding a `*`, or removing\n                 // a `&`.\n@@ -418,7 +418,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                           if needs_paren { \")\" } else { \"\" });\n \n             match (&expected_ty.sty, &checked_ty.sty) {\n-                (&ty::TyInt(ref exp), &ty::TyInt(ref found)) => {\n+                (&ty::Int(ref exp), &ty::Int(ref found)) => {\n                     match (found.bit_width(), exp.bit_width()) {\n                         (Some(found), Some(exp)) if found > exp => {\n                             if can_cast {\n@@ -444,7 +444,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                     true\n                 }\n-                (&ty::TyUint(ref exp), &ty::TyUint(ref found)) => {\n+                (&ty::Uint(ref exp), &ty::Uint(ref found)) => {\n                     match (found.bit_width(), exp.bit_width()) {\n                         (Some(found), Some(exp)) if found > exp => {\n                             if can_cast {\n@@ -470,7 +470,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                     true\n                 }\n-                (&ty::TyInt(ref exp), &ty::TyUint(ref found)) => {\n+                (&ty::Int(ref exp), &ty::Uint(ref found)) => {\n                     if can_cast {\n                         match (found.bit_width(), exp.bit_width()) {\n                             (Some(found), Some(exp)) if found > exp - 1 => {\n@@ -506,7 +506,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                     true\n                 }\n-                (&ty::TyUint(ref exp), &ty::TyInt(ref found)) => {\n+                (&ty::Uint(ref exp), &ty::Int(ref found)) => {\n                     if can_cast {\n                         match (found.bit_width(), exp.bit_width()) {\n                             (Some(found), Some(exp)) if found - 1 > exp => {\n@@ -542,7 +542,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                     true\n                 }\n-                (&ty::TyFloat(ref exp), &ty::TyFloat(ref found)) => {\n+                (&ty::Float(ref exp), &ty::Float(ref found)) => {\n                     if found.bit_width() < exp.bit_width() {\n                         err.span_suggestion(expr.span,\n                                             &format!(\"{} in a lossless way\",\n@@ -556,7 +556,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                     true\n                 }\n-                (&ty::TyUint(_), &ty::TyFloat(_)) | (&ty::TyInt(_), &ty::TyFloat(_)) => {\n+                (&ty::Uint(_), &ty::Float(_)) | (&ty::Int(_), &ty::Float(_)) => {\n                     if can_cast {\n                         err.span_suggestion(expr.span,\n                                             &format!(\"{}, rounding the float towards zero\",\n@@ -568,7 +568,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                     true\n                 }\n-                (&ty::TyFloat(ref exp), &ty::TyUint(ref found)) => {\n+                (&ty::Float(ref exp), &ty::Uint(ref found)) => {\n                     // if `found` is `None` (meaning found is `usize`), don't suggest `.into()`\n                     if exp.bit_width() > found.bit_width().unwrap_or(256) {\n                         err.span_suggestion(expr.span,\n@@ -586,7 +586,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                     true\n                 }\n-                (&ty::TyFloat(ref exp), &ty::TyInt(ref found)) => {\n+                (&ty::Float(ref exp), &ty::Int(ref found)) => {\n                     // if `found` is `None` (meaning found is `isize`), don't suggest `.into()`\n                     if exp.bit_width() > found.bit_width().unwrap_or(256) {\n                         err.span_suggestion(expr.span,"}, {"sha": "9d3cbf910e05958f3633f0d6c02fe9af944b1471", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -45,7 +45,7 @@ pub fn check_drop_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let dtor_self_type = tcx.type_of(drop_impl_did);\n     let dtor_predicates = tcx.predicates_of(drop_impl_did);\n     match dtor_self_type.sty {\n-        ty::TyAdt(adt_def, self_to_impl_substs) => {\n+        ty::Adt(adt_def, self_to_impl_substs) => {\n             ensure_drop_params_and_item_params_correspond(tcx,\n                                                           drop_impl_did,\n                                                           dtor_self_type,"}, {"sha": "23872ddf2f64b8c836d12fdd4fbbfc31012e5611", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -463,35 +463,35 @@ fn match_intrinsic_type_to_type<'a, 'tcx>(\n \n     match *expected {\n         Void => match t.sty {\n-            ty::TyTuple(ref v) if v.is_empty() => {},\n+            ty::Tuple(ref v) if v.is_empty() => {},\n             _ => simple_error(&format!(\"`{}`\", t), \"()\"),\n         },\n         // (The width we pass to LLVM doesn't concern the type checker.)\n         Integer(signed, bits, _llvm_width) => match (signed, bits, &t.sty) {\n-            (true,  8,  &ty::TyInt(ast::IntTy::I8)) |\n-            (false, 8,  &ty::TyUint(ast::UintTy::U8)) |\n-            (true,  16, &ty::TyInt(ast::IntTy::I16)) |\n-            (false, 16, &ty::TyUint(ast::UintTy::U16)) |\n-            (true,  32, &ty::TyInt(ast::IntTy::I32)) |\n-            (false, 32, &ty::TyUint(ast::UintTy::U32)) |\n-            (true,  64, &ty::TyInt(ast::IntTy::I64)) |\n-            (false, 64, &ty::TyUint(ast::UintTy::U64)) |\n-            (true,  128, &ty::TyInt(ast::IntTy::I128)) |\n-            (false, 128, &ty::TyUint(ast::UintTy::U128)) => {},\n+            (true,  8,  &ty::Int(ast::IntTy::I8)) |\n+            (false, 8,  &ty::Uint(ast::UintTy::U8)) |\n+            (true,  16, &ty::Int(ast::IntTy::I16)) |\n+            (false, 16, &ty::Uint(ast::UintTy::U16)) |\n+            (true,  32, &ty::Int(ast::IntTy::I32)) |\n+            (false, 32, &ty::Uint(ast::UintTy::U32)) |\n+            (true,  64, &ty::Int(ast::IntTy::I64)) |\n+            (false, 64, &ty::Uint(ast::UintTy::U64)) |\n+            (true,  128, &ty::Int(ast::IntTy::I128)) |\n+            (false, 128, &ty::Uint(ast::UintTy::U128)) => {},\n             _ => simple_error(&format!(\"`{}`\", t),\n                               &format!(\"`{}{n}`\",\n                                        if signed {\"i\"} else {\"u\"},\n                                        n = bits)),\n         },\n         Float(bits) => match (bits, &t.sty) {\n-            (32, &ty::TyFloat(ast::FloatTy::F32)) |\n-            (64, &ty::TyFloat(ast::FloatTy::F64)) => {},\n+            (32, &ty::Float(ast::FloatTy::F32)) |\n+            (64, &ty::Float(ast::FloatTy::F64)) => {},\n             _ => simple_error(&format!(\"`{}`\", t),\n                               &format!(\"`f{n}`\", n = bits)),\n         },\n         Pointer(ref inner_expected, ref _llvm_type, const_) => {\n             match t.sty {\n-                ty::TyRawPtr(ty::TypeAndMut { ty, mutbl }) => {\n+                ty::RawPtr(ty::TypeAndMut { ty, mutbl }) => {\n                     if (mutbl == hir::MutImmutable) != const_ {\n                         simple_error(&format!(\"`{}`\", t),\n                                      if const_ {\"const pointer\"} else {\"mut pointer\"})\n@@ -537,7 +537,7 @@ fn match_intrinsic_type_to_type<'a, 'tcx>(\n         }\n         Aggregate(_flatten, ref expected_contents) => {\n             match t.sty {\n-                ty::TyTuple(contents) => {\n+                ty::Tuple(contents) => {\n                     if contents.len() != expected_contents.len() {\n                         simple_error(&format!(\"tuple with length {}\", contents.len()),\n                                      &format!(\"tuple with length {}\", expected_contents.len()));"}, {"sha": "6057c18663a6e7f6fcc74153fa265b7117c2f418", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -293,7 +293,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             .include_raw_pointers()\n             .filter_map(|(ty, _)| {\n                 match ty.sty {\n-                    ty::TyDynamic(ref data, ..) => data.principal().map(|p| closure(self, ty, p)),\n+                    ty::Dynamic(ref data, ..) => data.principal().map(|p| closure(self, ty, p)),\n                     _ => None,\n                 }\n             })\n@@ -479,7 +479,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                     if let Adjust::Deref(Some(ref mut deref)) = adjustment.kind {\n                         if let Some(ok) = self.try_overloaded_deref(expr.span, source, needs) {\n                             let method = self.register_infer_ok_obligations(ok);\n-                            if let ty::TyRef(region, _, mutbl) = method.sig.output().sty {\n+                            if let ty::Ref(region, _, mutbl) = method.sig.output().sty {\n                                 *deref = OverloadedDeref {\n                                     region,\n                                     mutbl,\n@@ -538,7 +538,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         debug!(\"convert_place_op_to_mutable: method={:?}\", method);\n         self.write_method_call(expr.hir_id, method);\n \n-        let (region, mutbl) = if let ty::TyRef(r, _, mutbl) = method.sig.inputs()[0].sty {\n+        let (region, mutbl) = if let ty::Ref(r, _, mutbl) = method.sig.inputs()[0].sty {\n             (r, mutbl)\n         } else {\n             span_bug!(expr.span, \"input to place op is not a ref?\");\n@@ -605,7 +605,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             })\n             .any(|trait_pred| {\n                 match trait_pred.skip_binder().self_ty().sty {\n-                    ty::TyDynamic(..) => true,\n+                    ty::Dynamic(..) => true,\n                     _ => false,\n                 }\n             })"}, {"sha": "85a437283fa681e66c18de97c7cb2d5f959f958d", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -314,7 +314,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     from_unsafe_deref: reached_raw_pointer,\n                     unsize: false,\n                 };\n-                if let ty::TyRawPtr(_) = ty.sty {\n+                if let ty::RawPtr(_) = ty.sty {\n                     // all the subsequent steps will be from_unsafe_deref\n                     reached_raw_pointer = true;\n                 }\n@@ -324,7 +324,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let final_ty = autoderef.maybe_ambiguous_final_ty();\n         match final_ty.sty {\n-            ty::TyInfer(ty::TyVar(_)) => {\n+            ty::Infer(ty::TyVar(_)) => {\n                 // Ended in an inference variable. If we are doing\n                 // a real method lookup, this is a hard error because it's\n                 // possible that there will be multiple applicable methods.\n@@ -356,7 +356,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // just ignore it.\n                 }\n             }\n-            ty::TyArray(elem_ty, _) => {\n+            ty::Array(elem_ty, _) => {\n                 let dereferences = steps.len() - 1;\n \n                 steps.push(CandidateStep {\n@@ -368,7 +368,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     unsize: true,\n                 });\n             }\n-            ty::TyError => return None,\n+            ty::Error => return None,\n             _ => (),\n         }\n \n@@ -450,33 +450,33 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         let lang_items = self.tcx.lang_items();\n \n         match self_ty.sty {\n-            ty::TyDynamic(ref data, ..) => {\n+            ty::Dynamic(ref data, ..) => {\n                 if let Some(p) = data.principal() {\n                     self.assemble_inherent_candidates_from_object(self_ty, p);\n                     self.assemble_inherent_impl_candidates_for_type(p.def_id());\n                 }\n             }\n-            ty::TyAdt(def, _) => {\n+            ty::Adt(def, _) => {\n                 self.assemble_inherent_impl_candidates_for_type(def.did);\n             }\n-            ty::TyForeign(did) => {\n+            ty::Foreign(did) => {\n                 self.assemble_inherent_impl_candidates_for_type(did);\n             }\n-            ty::TyParam(p) => {\n+            ty::Param(p) => {\n                 self.assemble_inherent_candidates_from_param(self_ty, p);\n             }\n-            ty::TyChar => {\n+            ty::Char => {\n                 let lang_def_id = lang_items.char_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyStr => {\n+            ty::Str => {\n                 let lang_def_id = lang_items.str_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n \n                 let lang_def_id = lang_items.str_alloc_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TySlice(_) => {\n+            ty::Slice(_) => {\n                 let lang_def_id = lang_items.slice_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n \n@@ -489,70 +489,70 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 let lang_def_id = lang_items.slice_u8_alloc_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n+            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n                 let lang_def_id = lang_items.const_ptr_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n+            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n                 let lang_def_id = lang_items.mut_ptr_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyInt(ast::IntTy::I8) => {\n+            ty::Int(ast::IntTy::I8) => {\n                 let lang_def_id = lang_items.i8_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyInt(ast::IntTy::I16) => {\n+            ty::Int(ast::IntTy::I16) => {\n                 let lang_def_id = lang_items.i16_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyInt(ast::IntTy::I32) => {\n+            ty::Int(ast::IntTy::I32) => {\n                 let lang_def_id = lang_items.i32_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyInt(ast::IntTy::I64) => {\n+            ty::Int(ast::IntTy::I64) => {\n                 let lang_def_id = lang_items.i64_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyInt(ast::IntTy::I128) => {\n+            ty::Int(ast::IntTy::I128) => {\n                 let lang_def_id = lang_items.i128_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyInt(ast::IntTy::Isize) => {\n+            ty::Int(ast::IntTy::Isize) => {\n                 let lang_def_id = lang_items.isize_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyUint(ast::UintTy::U8) => {\n+            ty::Uint(ast::UintTy::U8) => {\n                 let lang_def_id = lang_items.u8_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyUint(ast::UintTy::U16) => {\n+            ty::Uint(ast::UintTy::U16) => {\n                 let lang_def_id = lang_items.u16_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyUint(ast::UintTy::U32) => {\n+            ty::Uint(ast::UintTy::U32) => {\n                 let lang_def_id = lang_items.u32_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyUint(ast::UintTy::U64) => {\n+            ty::Uint(ast::UintTy::U64) => {\n                 let lang_def_id = lang_items.u64_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyUint(ast::UintTy::U128) => {\n+            ty::Uint(ast::UintTy::U128) => {\n                 let lang_def_id = lang_items.u128_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyUint(ast::UintTy::Usize) => {\n+            ty::Uint(ast::UintTy::Usize) => {\n                 let lang_def_id = lang_items.usize_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyFloat(ast::FloatTy::F32) => {\n+            ty::Float(ast::FloatTy::F32) => {\n                 let lang_def_id = lang_items.f32_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n \n                 let lang_def_id = lang_items.f32_runtime_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyFloat(ast::FloatTy::F64) => {\n+            ty::Float(ast::FloatTy::F64) => {\n                 let lang_def_id = lang_items.f64_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n \n@@ -652,7 +652,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 match *predicate {\n                     ty::Predicate::Trait(ref trait_predicate) => {\n                         match trait_predicate.skip_binder().trait_ref.self_ty().sty {\n-                            ty::TyParam(ref p) if *p == param_ty => {\n+                            ty::Param(ref p) if *p == param_ty => {\n                                 Some(trait_predicate.to_poly_trait_ref())\n                             }\n                             _ => None,\n@@ -919,7 +919,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 pick.autoderefs = step.autoderefs;\n \n                 // Insert a `&*` or `&mut *` if this is a reference type:\n-                if let ty::TyRef(_, _, mutbl) = step.self_ty.sty {\n+                if let ty::Ref(_, _, mutbl) = step.self_ty.sty {\n                     pick.autoderefs += 1;\n                     pick.autoref = Some(mutbl);\n                 }"}, {"sha": "0bef176b499a46532cd92d89f348bfc7b6508c9b", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -32,7 +32,7 @@ use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::hir;\n use rustc::hir::print;\n use rustc::infer::type_variable::TypeVariableOrigin;\n-use rustc::ty::TyAdt;\n+use rustc::ty::Adt;\n \n use std::cmp::Ordering;\n \n@@ -45,9 +45,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         match ty.sty {\n             // Not all of these (e.g. unsafe fns) implement FnOnce\n             // so we look for these beforehand\n-            ty::TyClosure(..) |\n-            ty::TyFnDef(..) |\n-            ty::TyFnPtr(_) => true,\n+            ty::Closure(..) |\n+            ty::FnDef(..) |\n+            ty::FnPtr(_) => true,\n             // If it's not a simple function, look for things which implement FnOnce\n             _ => {\n                 let fn_once = match tcx.lang_items().require(FnOnceTraitLangItem) {\n@@ -199,7 +199,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let item_kind = if is_method {\n                     \"method\"\n                 } else if actual.is_enum() {\n-                    if let TyAdt(ref adt_def, _) = actual.sty {\n+                    if let Adt(ref adt_def, _) = actual.sty {\n                         let names = adt_def.variants.iter().map(|s| &s.name);\n                         suggestion = find_best_match_for_name(names,\n                                                               &item_name.as_str(),\n@@ -338,7 +338,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if let Some(expr) = rcvr_expr {\n                     for (ty, _) in self.autoderef(span, rcvr_ty) {\n                         match ty.sty {\n-                            ty::TyAdt(def, substs) if !def.is_enum() => {\n+                            ty::Adt(def, substs) if !def.is_enum() => {\n                                 let variant = &def.non_enum_variant();\n                                 if let Some(index) = self.tcx.find_field_index(item_name, variant) {\n                                     let field = &variant.fields[index];\n@@ -638,13 +638,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             -> bool {\n         fn is_local(ty: Ty) -> bool {\n             match ty.sty {\n-                ty::TyAdt(def, _) => def.did.is_local(),\n-                ty::TyForeign(did) => did.is_local(),\n+                ty::Adt(def, _) => def.did.is_local(),\n+                ty::Foreign(did) => did.is_local(),\n \n-                ty::TyDynamic(ref tr, ..) => tr.principal()\n+                ty::Dynamic(ref tr, ..) => tr.principal()\n                     .map_or(false, |p| p.def_id().is_local()),\n \n-                ty::TyParam(_) => true,\n+                ty::Param(_) => true,\n \n                 // everything else (primitive types etc.) is effectively\n                 // non-local (there are \"edge\" cases, e.g. (LocalType,), but"}, {"sha": "0dcc799ebb2e282d9c0e4dbc0c4a256536dc5bc9", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -214,7 +214,7 @@ pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // Anonymized types found in explicit return types and their\n     // associated fresh inference variable. Writeback resolves these\n     // variables to get the concrete type, which can be used to\n-    // deanonymize TyAnon, after typeck is done with all functions.\n+    // deanonymize Anon, after typeck is done with all functions.\n     anon_types: RefCell<DefIdMap<AnonTypeDecl<'tcx>>>,\n \n     /// Each type parameter has an implicit region bound that\n@@ -311,7 +311,7 @@ impl<'a, 'gcx, 'tcx> Expectation<'tcx> {\n     /// for examples of where this comes up,.\n     fn rvalue_hint(fcx: &FnCtxt<'a, 'gcx, 'tcx>, ty: Ty<'tcx>) -> Expectation<'tcx> {\n         match fcx.tcx.struct_tail(ty).sty {\n-            ty::TySlice(_) | ty::TyStr | ty::TyDynamic(..) => {\n+            ty::Slice(_) | ty::Str | ty::Dynamic(..) => {\n                 ExpectRvalueLikeUnsized(ty)\n             }\n             _ => ExpectHasType(ty)\n@@ -1137,7 +1137,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     if let Some(panic_impl_did) = fcx.tcx.lang_items().panic_impl() {\n         if panic_impl_did == fcx.tcx.hir.local_def_id(fn_id) {\n             if let Some(panic_info_did) = fcx.tcx.lang_items().panic_info() {\n-                if declared_ret_ty.sty != ty::TyNever {\n+                if declared_ret_ty.sty != ty::Never {\n                     fcx.tcx.sess.span_err(\n                         decl.output.span(),\n                         \"return type should be `!`\",\n@@ -1148,8 +1148,8 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                 let span = fcx.tcx.hir.span(fn_id);\n                 if inputs.len() == 1 {\n                     let arg_is_panic_info = match inputs[0].sty {\n-                        ty::TyRef(region, ty, mutbl) => match ty.sty {\n-                            ty::TyAdt(ref adt, _) => {\n+                        ty::Ref(region, ty, mutbl) => match ty.sty {\n+                            ty::Adt(ref adt, _) => {\n                                 adt.did == panic_info_did &&\n                                     mutbl == hir::Mutability::MutImmutable &&\n                                     *region != RegionKind::ReStatic\n@@ -1190,7 +1190,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     if let Some(alloc_error_handler_did) = fcx.tcx.lang_items().oom() {\n         if alloc_error_handler_did == fcx.tcx.hir.local_def_id(fn_id) {\n             if let Some(alloc_layout_did) = fcx.tcx.lang_items().alloc_layout() {\n-                if declared_ret_ty.sty != ty::TyNever {\n+                if declared_ret_ty.sty != ty::Never {\n                     fcx.tcx.sess.span_err(\n                         decl.output.span(),\n                         \"return type should be `!`\",\n@@ -1201,7 +1201,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                 let span = fcx.tcx.hir.span(fn_id);\n                 if inputs.len() == 1 {\n                     let arg_is_alloc_layout = match inputs[0].sty {\n-                        ty::TyAdt(ref adt, _) => {\n+                        ty::Adt(ref adt, _) => {\n                             adt.did == alloc_layout_did\n                         },\n                         _ => false,\n@@ -1633,7 +1633,7 @@ fn check_representable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n pub fn check_simd<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId) {\n     let t = tcx.type_of(def_id);\n     match t.sty {\n-        ty::TyAdt(def, substs) if def.is_struct() => {\n+        ty::Adt(def, substs) if def.is_struct() => {\n             let fields = &def.non_enum_variant().fields;\n             if fields.is_empty() {\n                 span_err!(tcx.sess, sp, E0075, \"SIMD vector cannot be empty\");\n@@ -1647,7 +1647,7 @@ pub fn check_simd<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId\n                 return;\n             }\n             match e.sty {\n-                ty::TyParam(_) => { /* struct<T>(T, T, T, T) is ok */ }\n+                ty::Param(_) => { /* struct<T>(T, T, T, T) is ok */ }\n                 _ if e.is_machine()  => { /* struct(u8, u8, u8, u8) is ok */ }\n                 _ => {\n                     span_err!(tcx.sess, sp, E0077,\n@@ -1693,7 +1693,7 @@ fn check_packed_inner<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         return false;\n     }\n     match t.sty {\n-        ty::TyAdt(def, substs) if def.is_struct() || def.is_union() => {\n+        ty::Adt(def, substs) if def.is_struct() || def.is_union() => {\n             if tcx.adt_def(def.did).repr.align > 0 {\n                 return true;\n             }\n@@ -1702,7 +1702,7 @@ fn check_packed_inner<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             for field in &def.non_enum_variant().fields {\n                 let f = field.ty(tcx, substs);\n                 match f.sty {\n-                    ty::TyAdt(def, _) => {\n+                    ty::Adt(def, _) => {\n                         if check_packed_inner(tcx, def.did, stack) {\n                             return true;\n                         }\n@@ -1982,7 +1982,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn resolve_type_vars_with_obligations(&self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n         debug!(\"resolve_type_vars_with_obligations(ty={:?})\", ty);\n \n-        // No TyInfer()? Nothing needs doing.\n+        // No Infer()? Nothing needs doing.\n         if !ty.has_infer_types() {\n             debug!(\"resolve_type_vars_with_obligations: ty={:?}\", ty);\n             return ty;\n@@ -2331,7 +2331,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // feature(never_type) is enabled, unconstrained ints with i32,\n     // unconstrained floats with f64.\n     // Fallback becomes very dubious if we have encountered type-checking errors.\n-    // In that case, fallback to TyError.\n+    // In that case, fallback to Error.\n     // The return value indicates whether fallback has occurred.\n     fn fallback_if_possible(&self, ty: Ty<'tcx>) -> bool {\n         use rustc::ty::error::UnconstrainedNumeric::Neither;\n@@ -2481,7 +2481,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let mut self_ty = adjusted_ty;\n             if unsize {\n                 // We only unsize arrays here.\n-                if let ty::TyArray(element_ty, _) = adjusted_ty.sty {\n+                if let ty::Array(element_ty, _) = adjusted_ty.sty {\n                     self_ty = self.tcx.mk_slice(element_ty);\n                 } else {\n                     continue;\n@@ -2500,7 +2500,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let method = self.register_infer_ok_obligations(ok);\n \n                 let mut adjustments = autoderef.adjust_steps(needs);\n-                if let ty::TyRef(region, _, r_mutbl) = method.sig.inputs()[0].sty {\n+                if let ty::Ref(region, _, r_mutbl) = method.sig.inputs()[0].sty {\n                     let mutbl = match r_mutbl {\n                         hir::MutImmutable => AutoBorrowMutability::Immutable,\n                         hir::MutMutable => AutoBorrowMutability::Mutable {\n@@ -2694,15 +2694,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let formal_tys = if tuple_arguments == TupleArguments {\n             let tuple_type = self.structurally_resolved_type(sp, fn_inputs[0]);\n             match tuple_type.sty {\n-                ty::TyTuple(arg_types) if arg_types.len() != args.len() => {\n+                ty::Tuple(arg_types) if arg_types.len() != args.len() => {\n                     param_count_error(arg_types.len(), args.len(), \"E0057\", false, false);\n                     expected_arg_tys = &[];\n                     self.err_args(args.len())\n                 }\n-                ty::TyTuple(arg_types) => {\n+                ty::Tuple(arg_types) => {\n                     expected_arg_tys = match expected_arg_tys.get(0) {\n                         Some(&ty) => match ty.sty {\n-                            ty::TyTuple(ref tys) => &tys,\n+                            ty::Tuple(ref tys) => &tys,\n                             _ => &[]\n                         },\n                         None => &[]\n@@ -2831,16 +2831,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // in C but we just error out instead and require explicit casts.\n                 let arg_ty = self.structurally_resolved_type(arg.span, arg_ty);\n                 match arg_ty.sty {\n-                    ty::TyFloat(ast::FloatTy::F32) => {\n+                    ty::Float(ast::FloatTy::F32) => {\n                         variadic_error(tcx.sess, arg.span, arg_ty, \"c_double\");\n                     }\n-                    ty::TyInt(ast::IntTy::I8) | ty::TyInt(ast::IntTy::I16) | ty::TyBool => {\n+                    ty::Int(ast::IntTy::I8) | ty::Int(ast::IntTy::I16) | ty::Bool => {\n                         variadic_error(tcx.sess, arg.span, arg_ty, \"c_int\");\n                     }\n-                    ty::TyUint(ast::UintTy::U8) | ty::TyUint(ast::UintTy::U16) => {\n+                    ty::Uint(ast::UintTy::U8) | ty::Uint(ast::UintTy::U16) => {\n                         variadic_error(tcx.sess, arg.span, arg_ty, \"c_uint\");\n                     }\n-                    ty::TyFnDef(..) => {\n+                    ty::FnDef(..) => {\n                         let ptr_ty = self.tcx.mk_fn_ptr(arg_ty.fn_sig(self.tcx));\n                         let ptr_ty = self.resolve_type_vars_if_possible(&ptr_ty);\n                         variadic_error(tcx.sess, arg.span, arg_ty, &ptr_ty.to_string());\n@@ -2876,10 +2876,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             ast::LitKind::Int(_, ast::LitIntType::Unsuffixed) => {\n                 let opt_ty = expected.to_option(self).and_then(|ty| {\n                     match ty.sty {\n-                        ty::TyInt(_) | ty::TyUint(_) => Some(ty),\n-                        ty::TyChar => Some(tcx.types.u8),\n-                        ty::TyRawPtr(..) => Some(tcx.types.usize),\n-                        ty::TyFnDef(..) | ty::TyFnPtr(_) => Some(tcx.types.usize),\n+                        ty::Int(_) | ty::Uint(_) => Some(ty),\n+                        ty::Char => Some(tcx.types.u8),\n+                        ty::RawPtr(..) => Some(tcx.types.usize),\n+                        ty::FnDef(..) | ty::FnPtr(_) => Some(tcx.types.usize),\n                         _ => None\n                     }\n                 });\n@@ -2890,7 +2890,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             ast::LitKind::FloatUnsuffixed(_) => {\n                 let opt_ty = expected.to_option(self).and_then(|ty| {\n                     match ty.sty {\n-                        ty::TyFloat(_) => Some(ty),\n+                        ty::Float(_) => Some(ty),\n                         _ => None\n                     }\n                 });\n@@ -3179,7 +3179,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let mut autoderef = self.autoderef(expr.span, expr_t);\n         while let Some((base_t, _)) = autoderef.next() {\n             match base_t.sty {\n-                ty::TyAdt(base_def, substs) if !base_def.is_enum() => {\n+                ty::Adt(base_def, substs) if !base_def.is_enum() => {\n                     debug!(\"struct named {:?}\",  base_t);\n                     let (ident, def_scope) =\n                         self.tcx.adjust_ident(field, base_def.did, self.body_id);\n@@ -3201,7 +3201,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         private_candidate = Some((base_def.did, field_ty));\n                     }\n                 }\n-                ty::TyTuple(ref tys) => {\n+                ty::Tuple(ref tys) => {\n                     let fstr = field.as_str();\n                     if let Ok(index) = fstr.parse::<usize>() {\n                         if fstr == index.to_string() {\n@@ -3246,7 +3246,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let mut err = self.no_such_field_err(field.span, field, expr_t);\n \n                 match expr_t.sty {\n-                    ty::TyAdt(def, _) if !def.is_enum() => {\n+                    ty::Adt(def, _) if !def.is_enum() => {\n                         if let Some(suggested_field_name) =\n                             Self::suggest_field_name(def.non_enum_variant(),\n                                                      &field.as_str(), vec![]) {\n@@ -3262,7 +3262,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 }\n                             };\n                     }\n-                    ty::TyRawPtr(..) => {\n+                    ty::RawPtr(..) => {\n                         let base = self.tcx.hir.node_to_pretty_string(base.id);\n                         let msg = format!(\"`{}` is a native pointer; try dereferencing it\", base);\n                         let suggestion = format!(\"(*{}).{}\", base, field);\n@@ -3336,7 +3336,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let mut err = self.type_error_struct_with_diag(\n             field.ident.span,\n             |actual| match ty.sty {\n-                ty::TyAdt(adt, ..) if adt.is_enum() => {\n+                ty::Adt(adt, ..) if adt.is_enum() => {\n                     struct_span_err!(self.tcx.sess, field.ident.span, E0559,\n                                     \"{} `{}::{}` has no field named `{}`\",\n                                     kind_name, actual, variant.name, field.ident)\n@@ -3357,7 +3357,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                            format!(\"field does not exist - did you mean `{}`?\", field_name));\n         } else {\n             match ty.sty {\n-                ty::TyAdt(adt, ..) => {\n+                ty::Adt(adt, ..) => {\n                     if adt.is_enum() {\n                         err.span_label(field.ident.span,\n                                        format!(\"`{}::{}` does not have this field\",\n@@ -3395,7 +3395,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.demand_eqtype(span, adt_ty_hint, adt_ty);\n \n         let (substs, adt_kind, kind_name) = match &adt_ty.sty{\n-            &ty::TyAdt(adt, substs) => {\n+            &ty::Adt(adt, substs) => {\n                 (substs, adt.adt_kind(), adt.variant_descr())\n             }\n             _ => span_bug!(span, \"non-ADT passed to check_expr_struct_fields\")\n@@ -3520,7 +3520,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n             Def::Variant(..) => {\n                 match ty.sty {\n-                    ty::TyAdt(adt, substs) => {\n+                    ty::Adt(adt, substs) => {\n                         Some((adt.variant_of_def(def), adt.did, substs))\n                     }\n                     _ => bug!(\"unexpected type: {:?}\", ty.sty)\n@@ -3529,7 +3529,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Def::Struct(..) | Def::Union(..) | Def::TyAlias(..) |\n             Def::AssociatedTy(..) | Def::SelfTy(..) => {\n                 match ty.sty {\n-                    ty::TyAdt(adt, substs) if !adt.is_enum() => {\n+                    ty::Adt(adt, substs) if !adt.is_enum() => {\n                         Some((adt.non_enum_variant(), adt.did, substs))\n                     }\n                     _ => None,\n@@ -3578,7 +3578,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         // Prohibit struct expressions when non exhaustive flag is set.\n-        if let ty::TyAdt(adt, _) = struct_ty.sty {\n+        if let ty::Adt(adt, _) = struct_ty.sty {\n             if !adt.did.is_local() && adt.is_non_exhaustive() {\n                 span_err!(self.tcx.sess, expr.span, E0639,\n                           \"cannot create non-exhaustive {} using struct expression\",\n@@ -3595,7 +3595,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             if !error_happened {\n                 self.check_expr_has_type_or_error(base_expr, struct_ty);\n                 match struct_ty.sty {\n-                    ty::TyAdt(adt, substs) if adt.is_struct() => {\n+                    ty::Adt(adt, substs) if adt.is_struct() => {\n                         let fru_field_types = adt.non_enum_variant().fields.iter().map(|f| {\n                             self.normalize_associated_types_in(expr.span, &f.ty(self.tcx, substs))\n                         }).collect();\n@@ -3625,7 +3625,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// strict, _|_ can appear in the type of an expression that does not,\n     /// itself, diverge: for example, fn() -> _|_.)\n     /// Note that inspecting a type's structure *directly* may expose the fact\n-    /// that there are actually multiple representations for `TyError`, so avoid\n+    /// that there are actually multiple representations for `Error`, so avoid\n     /// that when err needs to be handled differently.\n     fn check_expr_with_expectation_and_needs(&self,\n                                                    expr: &'gcx hir::Expr,\n@@ -3684,7 +3684,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             hir::ExprKind::Box(ref subexpr) => {\n                 let expected_inner = expected.to_option(self).map_or(NoExpectation, |ty| {\n                     match ty.sty {\n-                        ty::TyAdt(def, _) if def.is_box()\n+                        ty::Adt(def, _) if def.is_box()\n                             => Expectation::rvalue_hint(self, ty.boxed_ty()),\n                         _ => NoExpectation\n                     }\n@@ -3728,7 +3728,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             } else if let Some(ok) = self.try_overloaded_deref(\n                                     expr.span, oprnd_t, needs) {\n                                 let method = self.register_infer_ok_obligations(ok);\n-                                if let ty::TyRef(region, _, mutbl) = method.sig.inputs()[0].sty {\n+                                if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].sty {\n                                     let mutbl = match mutbl {\n                                         hir::MutImmutable => AutoBorrowMutability::Immutable,\n                                         hir::MutMutable => AutoBorrowMutability::Mutable {\n@@ -3755,7 +3755,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         hir::UnNot => {\n                             let result = self.check_user_unop(expr, oprnd_t, unop);\n                             // If it's builtin, we can reuse the type, this helps inference.\n-                            if !(oprnd_t.is_integral() || oprnd_t.sty == ty::TyBool) {\n+                            if !(oprnd_t.is_integral() || oprnd_t.sty == ty::Bool) {\n                                 oprnd_t = result;\n                             }\n                         }\n@@ -3773,7 +3773,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             hir::ExprKind::AddrOf(mutbl, ref oprnd) => {\n                 let hint = expected.only_has_type(self).map_or(NoExpectation, |ty| {\n                     match ty.sty {\n-                        ty::TyRef(_, ty, _) | ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n+                        ty::Ref(_, ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n                             if self.is_place_expr(&oprnd) {\n                                 // Places may legitimately have unsized types.\n                                 // For example, dereferences of a fat pointer and\n@@ -4086,7 +4086,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             hir::ExprKind::Array(ref args) => {\n                 let uty = expected.to_option(self).and_then(|uty| {\n                     match uty.sty {\n-                        ty::TyArray(ty, _) | ty::TySlice(ty) => Some(ty),\n+                        ty::Array(ty, _) | ty::Slice(ty) => Some(ty),\n                         _ => None\n                     }\n                 });\n@@ -4133,7 +4133,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let uty = match expected {\n                     ExpectHasType(uty) => {\n                         match uty.sty {\n-                            ty::TyArray(ty, _) | ty::TySlice(ty) => Some(ty),\n+                            ty::Array(ty, _) | ty::Slice(ty) => Some(ty),\n                             _ => None\n                         }\n                     }\n@@ -4165,7 +4165,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if element_ty.references_error() {\n                     tcx.types.err\n                 } else if let Ok(count) = count {\n-                    tcx.mk_ty(ty::TyArray(t, count))\n+                    tcx.mk_ty(ty::Array(t, count))\n                 } else {\n                     tcx.types.err\n                 }\n@@ -4174,7 +4174,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let flds = expected.only_has_type(self).and_then(|ty| {\n                     let ty = self.resolve_type_vars_with_obligations(ty);\n                     match ty.sty {\n-                        ty::TyTuple(ref flds) => Some(&flds[..]),\n+                        ty::Tuple(ref flds) => Some(&flds[..]),\n                         _ => None\n                     }\n                 });\n@@ -4228,7 +4228,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                    \"cannot index into a value of type `{}`\",\n                                                    base_t);\n                             // Try to give some advice about indexing tuples.\n-                            if let ty::TyTuple(..) = base_t.sty {\n+                            if let ty::Tuple(..) = base_t.sty {\n                                 let mut needs_note = true;\n                                 // If the index is an integer, we can show the actual\n                                 // fixed expression:\n@@ -5020,7 +5020,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             // If no type arguments were provided, we have to infer them.\n                             // This case also occurs as a result of some malformed input, e.g.\n                             // a lifetime argument being given instead of a type paramter.\n-                            // Using inference instead of `TyError` gives better error messages.\n+                            // Using inference instead of `Error` gives better error messages.\n                             self.var_for_def(span, param)\n                         }\n                     }\n@@ -5155,10 +5155,10 @@ pub fn check_bounds_are_used<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut types_used = vec![false; own_counts.types];\n \n     for leaf_ty in ty.walk() {\n-        if let ty::TyParam(ty::ParamTy { idx, .. }) = leaf_ty.sty {\n+        if let ty::Param(ty::ParamTy { idx, .. }) = leaf_ty.sty {\n             debug!(\"Found use of ty param num {}\", idx);\n             types_used[idx as usize - own_counts.lifetimes] = true;\n-        } else if let ty::TyError = leaf_ty.sty {\n+        } else if let ty::Error = leaf_ty.sty {\n             // If there is already another error, do not emit\n             // an error for not using a type Parameter.\n             assert!(tcx.sess.err_count() > 0);"}, {"sha": "b7cf6819e21803638ad4ba85f77b54e865354374", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -13,7 +13,7 @@\n use super::{FnCtxt, Needs};\n use super::method::MethodCallee;\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::TypeVariants::{TyRef, TyAdt, TyStr, TyUint, TyNever, TyTuple, TyChar, TyArray};\n+use rustc::ty::TyKind::{Ref, Adt, Str, Uint, Never, Tuple, Char, Array};\n use rustc::ty::adjustment::{Adjustment, Adjust, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::infer::type_variable::TypeVariableOrigin;\n use errors;\n@@ -204,7 +204,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Ok(method) => {\n                 let by_ref_binop = !op.node.is_by_value();\n                 if is_assign == IsAssign::Yes || by_ref_binop {\n-                    if let ty::TyRef(region, _, mutbl) = method.sig.inputs()[0].sty {\n+                    if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].sty {\n                         let mutbl = match mutbl {\n                             hir::MutImmutable => AutoBorrowMutability::Immutable,\n                             hir::MutMutable => AutoBorrowMutability::Mutable {\n@@ -221,7 +221,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n                 if by_ref_binop {\n-                    if let ty::TyRef(region, _, mutbl) = method.sig.inputs()[1].sty {\n+                    if let ty::Ref(region, _, mutbl) = method.sig.inputs()[1].sty {\n                         let mutbl = match mutbl {\n                             hir::MutImmutable => AutoBorrowMutability::Immutable,\n                             hir::MutMutable => AutoBorrowMutability::Mutable {\n@@ -265,7 +265,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     format!(\"cannot use `{}=` on type `{}`\",\n                                     op.node.as_str(), lhs_ty));\n                             let mut suggested_deref = false;\n-                            if let TyRef(_, mut rty, _) = lhs_ty.sty {\n+                            if let Ref(_, mut rty, _) = lhs_ty.sty {\n                                 if {\n                                     !self.infcx.type_moves_by_default(self.param_env,\n                                                                         rty,\n@@ -276,7 +276,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                             .is_ok()\n                                 } {\n                                     if let Ok(lstring) = source_map.span_to_snippet(lhs_expr.span) {\n-                                        while let TyRef(_, rty_inner, _) = rty.sty {\n+                                        while let Ref(_, rty_inner, _) = rty.sty {\n                                             rty = rty_inner;\n                                         }\n                                         let msg = &format!(\n@@ -311,7 +311,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     // This has nothing here because it means we did string\n                                     // concatenation (e.g. \"Hello \" += \"World!\"). This means\n                                     // we don't want the note in the else clause to be emitted\n-                                } else if let ty::TyParam(_) = lhs_ty.sty {\n+                                } else if let ty::Param(_) = lhs_ty.sty {\n                                     // FIXME: point to span of param\n                                     err.note(&format!(\n                                         \"`{}` might need a bound for `{}`\",\n@@ -333,7 +333,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                             op.node.as_str(),\n                                             lhs_ty);\n                             let mut suggested_deref = false;\n-                            if let TyRef(_, mut rty, _) = lhs_ty.sty {\n+                            if let Ref(_, mut rty, _) = lhs_ty.sty {\n                                 if {\n                                     !self.infcx.type_moves_by_default(self.param_env,\n                                                                         rty,\n@@ -344,7 +344,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                             .is_ok()\n                                 } {\n                                     if let Ok(lstring) = source_map.span_to_snippet(lhs_expr.span) {\n-                                        while let TyRef(_, rty_inner, _) = rty.sty {\n+                                        while let Ref(_, rty_inner, _) = rty.sty {\n                                             rty = rty_inner;\n                                         }\n                                         let msg = &format!(\n@@ -385,7 +385,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     // This has nothing here because it means we did string\n                                     // concatenation (e.g. \"Hello \" + \"World!\"). This means\n                                     // we don't want the note in the else clause to be emitted\n-                                } else if let ty::TyParam(_) = lhs_ty.sty {\n+                                } else if let ty::Param(_) = lhs_ty.sty {\n                                     // FIXME: point to span of param\n                                     err.note(&format!(\n                                         \"`{}` might need a bound for `{}`\",\n@@ -429,8 +429,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // If this function returns true it means a note was printed, so we don't need\n         // to print the normal \"implementation of `std::ops::Add` might be missing\" note\n         match (&lhs_ty.sty, &rhs_ty.sty) {\n-            (&TyRef(_, l_ty, _), &TyRef(_, r_ty, _))\n-            if l_ty.sty == TyStr && r_ty.sty == TyStr => {\n+            (&Ref(_, l_ty, _), &Ref(_, r_ty, _))\n+            if l_ty.sty == Str && r_ty.sty == Str => {\n                 if !is_assign {\n                     err.span_label(expr.span,\n                                    \"`+` can't be used to concatenate two `&str` strings\");\n@@ -443,8 +443,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 true\n             }\n-            (&TyRef(_, l_ty, _), &TyAdt(..))\n-            if l_ty.sty == TyStr && &format!(\"{:?}\", rhs_ty) == \"std::string::String\" => {\n+            (&Ref(_, l_ty, _), &Adt(..))\n+            if l_ty.sty == Str && &format!(\"{:?}\", rhs_ty) == \"std::string::String\" => {\n                 err.span_label(expr.span,\n                     \"`+` can't be used to concatenate a `&str` with a `String`\");\n                 match (\n@@ -489,11 +489,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     err.span_label(ex.span, format!(\"cannot apply unary \\\n                                                     operator `{}`\", op.as_str()));\n                     match actual.sty {\n-                        TyUint(_) if op == hir::UnNeg => {\n+                        Uint(_) if op == hir::UnNeg => {\n                             err.note(\"unsigned values cannot be negated\");\n                         },\n-                        TyStr | TyNever | TyChar | TyTuple(_) | TyArray(_,_) => {},\n-                        TyRef(_, ref lty, _) if lty.sty == TyStr => {},\n+                        Str | Never | Char | Tuple(_) | Array(_,_) => {},\n+                        Ref(_, ref lty, _) if lty.sty == Str => {},\n                         _ => {\n                             let missing_trait = match op {\n                                 hir::UnNeg => \"std::ops::Neg\","}, {"sha": "867864b3853d067c2556d6f90b003085248646b7", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -589,7 +589,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 // For overloaded derefs, base_ty is the input to `Deref::deref`,\n                 // but it's a reference type uing the same region as the output.\n                 let base_ty = self.resolve_expr_type_adjusted(base);\n-                if let ty::TyRef(r_ptr, _, _) = base_ty.sty {\n+                if let ty::Ref(r_ptr, _, _) = base_ty.sty {\n                     self.mk_subregion_due_to_dereference(expr.span, expr_region, r_ptr);\n                 }\n \n@@ -702,22 +702,22 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                from_ty,\n                to_ty);\n         match (&from_ty.sty, &to_ty.sty) {\n-            /*From:*/ (&ty::TyRef(from_r, from_ty, _),\n-            /*To:  */  &ty::TyRef(to_r, to_ty, _)) => {\n+            /*From:*/ (&ty::Ref(from_r, from_ty, _),\n+            /*To:  */  &ty::Ref(to_r, to_ty, _)) => {\n                 // Target cannot outlive source, naturally.\n                 self.sub_regions(infer::Reborrow(cast_expr.span), to_r, from_r);\n                 self.walk_cast(cast_expr, from_ty, to_ty);\n             }\n \n             /*From:*/ (_,\n-            /*To:  */  &ty::TyDynamic(.., r)) => {\n+            /*To:  */  &ty::Dynamic(.., r)) => {\n                 // When T is existentially quantified as a trait\n                 // `Foo+'to`, it must outlive the region bound `'to`.\n                 self.type_must_outlive(infer::RelateObjectBound(cast_expr.span), from_ty, r);\n             }\n \n-            /*From:*/ (&ty::TyAdt(from_def, _),\n-            /*To:  */  &ty::TyAdt(to_def, _)) if from_def.is_box() && to_def.is_box() => {\n+            /*From:*/ (&ty::Adt(from_def, _),\n+            /*To:  */  &ty::Adt(to_def, _)) if from_def.is_box() && to_def.is_box() => {\n                 self.walk_cast(cast_expr, from_ty.boxed_ty(), to_ty.boxed_ty());\n             }\n \n@@ -736,7 +736,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn constrain_callee(&mut self, callee_expr: &hir::Expr) {\n         let callee_ty = self.resolve_node_type(callee_expr.hir_id);\n         match callee_ty.sty {\n-            ty::TyFnDef(..) | ty::TyFnPtr(_) => { }\n+            ty::FnDef(..) | ty::FnPtr(_) => { }\n             _ => {\n                 // this should not happen, but it does if the program is\n                 // erroneous\n@@ -914,9 +914,9 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                self.ty_to_string(indexed_ty));\n \n         let r_index_expr = ty::ReScope(region::Scope::Node(index_expr.hir_id.local_id));\n-        if let ty::TyRef(r_ptr, r_ty, _) = indexed_ty.sty {\n+        if let ty::Ref(r_ptr, r_ty, _) = indexed_ty.sty {\n             match r_ty.sty {\n-                ty::TySlice(_) | ty::TyStr => {\n+                ty::Slice(_) | ty::Str => {\n                     self.sub_regions(infer::IndexSlice(index_expr.span),\n                                      self.tcx.mk_region(r_index_expr), r_ptr);\n                 }\n@@ -1089,7 +1089,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                id, mutbl, cmt_borrowed);\n \n         let rptr_ty = self.resolve_node_type(id);\n-        if let ty::TyRef(r, _, _) = rptr_ty.sty {\n+        if let ty::Ref(r, _, _) = rptr_ty.sty {\n             debug!(\"rptr_ty={}\",  rptr_ty);\n             self.link_region(span, r, ty::BorrowKind::from_mutbl(mutbl), cmt_borrowed);\n         }"}, {"sha": "41df937980ff3430e69f29a35bd1a3b03a421a8d", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -109,9 +109,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Extract the type of the closure.\n         let (closure_def_id, substs) = match self.node_ty(closure_hir_id).sty {\n-            ty::TyClosure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs)),\n-            ty::TyGenerator(def_id, substs, _) => (def_id, UpvarSubsts::Generator(substs)),\n-            ty::TyError => {\n+            ty::Closure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs)),\n+            ty::Generator(def_id, substs, _) => (def_id, UpvarSubsts::Generator(substs)),\n+            ty::Error => {\n                 // #51714: skip analysis when we have already encountered type errors\n                 return;\n             }"}, {"sha": "99e0e8775b0cddf413dd35f6780265fe2ecb28d6", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -454,7 +454,7 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(\n         impl<'tcx> ty::fold::TypeVisitor<'tcx> for CountParams {\n             fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n                 match t.sty {\n-                    ty::TyParam(p) => {\n+                    ty::Param(p) => {\n                         self.params.insert(p.idx);\n                         t.super_visit_with(self)\n                     }\n@@ -576,7 +576,7 @@ fn check_existential_types<'a, 'fcx, 'gcx, 'tcx>(\n     ty.fold_with(&mut ty::fold::BottomUpFolder {\n         tcx: fcx.tcx,\n         fldop: |ty| {\n-            if let ty::TyAnon(def_id, substs) = ty.sty {\n+            if let ty::Anon(def_id, substs) = ty.sty {\n                 trace!(\"check_existential_types: anon_ty, {:?}, {:?}\", def_id, substs);\n                 let generics = tcx.generics_of(def_id);\n                 // only check named existential types\n@@ -588,7 +588,7 @@ fn check_existential_types<'a, 'fcx, 'gcx, 'tcx>(\n                         for (subst, param) in substs.iter().zip(&generics.params) {\n                             match subst.unpack() {\n                                 ty::subst::UnpackedKind::Type(ty) => match ty.sty {\n-                                    ty::TyParam(..) => {},\n+                                    ty::Param(..) => {},\n                                     // prevent `fn foo() -> Foo<u32>` from being defining\n                                     _ => {\n                                         tcx\n@@ -674,7 +674,7 @@ fn check_existential_types<'a, 'fcx, 'gcx, 'tcx>(\n                         }\n                     }\n                 } // if is_named_existential_type\n-            } // if let TyAnon\n+            } // if let Anon\n             ty\n         },\n         reg_op: |reg| reg,"}, {"sha": "1e147b6c2638d02e11794764314dca09f8a7cfd7", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -174,7 +174,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n \n             match tables.expr_ty_adjusted(&base).sty {\n                 // All valid indexing looks like this\n-                ty::TyRef(_, base_ty, _) => {\n+                ty::Ref(_, base_ty, _) => {\n                     let index_ty = tables.expr_ty_adjusted(&index);\n                     let index_ty = self.fcx.resolve_type_vars_if_possible(&index_ty);\n \n@@ -417,7 +417,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                     fldop: |ty| {\n                         trace!(\"checking type {:?}: {:#?}\", ty, ty.sty);\n                         // find a type parameter\n-                        if let ty::TyParam(..) = ty.sty {\n+                        if let ty::Param(..) = ty.sty {\n                             // look it up in the substitution list\n                             assert_eq!(anon_defn.substs.len(), generics.params.len());\n                             for (subst, param) in anon_defn.substs.iter().zip(&generics.params) {"}, {"sha": "d01e7dbdfefe5904c85afa31e3e4857ade43f0e6", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -55,7 +55,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n \n fn visit_implementation_of_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_did: DefId) {\n     match tcx.type_of(impl_did).sty {\n-        ty::TyAdt(..) => {}\n+        ty::Adt(..) => {}\n         _ => {\n             // Destructors only work on nominal types.\n             if let Some(impl_node_id) = tcx.hir.as_local_node_id(impl_did) {\n@@ -217,23 +217,23 @@ pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n             (mt_a.ty, mt_b.ty, unsize_trait, None)\n         };\n         let (source, target, trait_def_id, kind) = match (&source.sty, &target.sty) {\n-            (&ty::TyRef(r_a, ty_a, mutbl_a), &ty::TyRef(r_b, ty_b, mutbl_b)) => {\n+            (&ty::Ref(r_a, ty_a, mutbl_a), &ty::Ref(r_b, ty_b, mutbl_b)) => {\n                 infcx.sub_regions(infer::RelateObjectBound(span), r_b, r_a);\n                 let mt_a = ty::TypeAndMut { ty: ty_a, mutbl: mutbl_a };\n                 let mt_b = ty::TypeAndMut { ty: ty_b, mutbl: mutbl_b };\n                 check_mutbl(mt_a, mt_b, &|ty| gcx.mk_imm_ref(r_b, ty))\n             }\n \n-            (&ty::TyRef(_, ty_a, mutbl_a), &ty::TyRawPtr(mt_b)) => {\n+            (&ty::Ref(_, ty_a, mutbl_a), &ty::RawPtr(mt_b)) => {\n                 let mt_a = ty::TypeAndMut { ty: ty_a, mutbl: mutbl_a };\n                 check_mutbl(mt_a, mt_b, &|ty| gcx.mk_imm_ptr(ty))\n             }\n \n-            (&ty::TyRawPtr(mt_a), &ty::TyRawPtr(mt_b)) => {\n+            (&ty::RawPtr(mt_a), &ty::RawPtr(mt_b)) => {\n                 check_mutbl(mt_a, mt_b, &|ty| gcx.mk_imm_ptr(ty))\n             }\n \n-            (&ty::TyAdt(def_a, substs_a), &ty::TyAdt(def_b, substs_b)) if def_a.is_struct() &&\n+            (&ty::Adt(def_a, substs_a), &ty::Adt(def_b, substs_b)) if def_a.is_struct() &&\n                                                                           def_b.is_struct() => {\n                 if def_a != def_b {\n                     let source_path = gcx.item_path_str(def_a.did);"}, {"sha": "52e37b8d0ce11fc9b8ace90f4d6d6ef1102db6c0", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -102,176 +102,176 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n         let self_ty = self.tcx.type_of(def_id);\n         let lang_items = self.tcx.lang_items();\n         match self_ty.sty {\n-            ty::TyAdt(def, _) => {\n+            ty::Adt(def, _) => {\n                 self.check_def_id(item, def.did);\n             }\n-            ty::TyForeign(did) => {\n+            ty::Foreign(did) => {\n                 self.check_def_id(item, did);\n             }\n-            ty::TyDynamic(ref data, ..) if data.principal().is_some() => {\n+            ty::Dynamic(ref data, ..) if data.principal().is_some() => {\n                 self.check_def_id(item, data.principal().unwrap().def_id());\n             }\n-            ty::TyChar => {\n+            ty::Char => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.char_impl(),\n                                           None,\n                                           \"char\",\n                                           \"char\",\n                                           item.span);\n             }\n-            ty::TyStr => {\n+            ty::Str => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.str_impl(),\n                                           lang_items.str_alloc_impl(),\n                                           \"str\",\n                                           \"str\",\n                                           item.span);\n             }\n-            ty::TySlice(slice_item) if slice_item == self.tcx.types.u8 => {\n+            ty::Slice(slice_item) if slice_item == self.tcx.types.u8 => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.slice_u8_impl(),\n                                           lang_items.slice_u8_alloc_impl(),\n                                           \"slice_u8\",\n                                           \"[u8]\",\n                                           item.span);\n             }\n-            ty::TySlice(_) => {\n+            ty::Slice(_) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.slice_impl(),\n                                           lang_items.slice_alloc_impl(),\n                                           \"slice\",\n                                           \"[T]\",\n                                           item.span);\n             }\n-            ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n+            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.const_ptr_impl(),\n                                           None,\n                                           \"const_ptr\",\n                                           \"*const T\",\n                                           item.span);\n             }\n-            ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n+            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.mut_ptr_impl(),\n                                           None,\n                                           \"mut_ptr\",\n                                           \"*mut T\",\n                                           item.span);\n             }\n-            ty::TyInt(ast::IntTy::I8) => {\n+            ty::Int(ast::IntTy::I8) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.i8_impl(),\n                                           None,\n                                           \"i8\",\n                                           \"i8\",\n                                           item.span);\n             }\n-            ty::TyInt(ast::IntTy::I16) => {\n+            ty::Int(ast::IntTy::I16) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.i16_impl(),\n                                           None,\n                                           \"i16\",\n                                           \"i16\",\n                                           item.span);\n             }\n-            ty::TyInt(ast::IntTy::I32) => {\n+            ty::Int(ast::IntTy::I32) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.i32_impl(),\n                                           None,\n                                           \"i32\",\n                                           \"i32\",\n                                           item.span);\n             }\n-            ty::TyInt(ast::IntTy::I64) => {\n+            ty::Int(ast::IntTy::I64) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.i64_impl(),\n                                           None,\n                                           \"i64\",\n                                           \"i64\",\n                                           item.span);\n             }\n-            ty::TyInt(ast::IntTy::I128) => {\n+            ty::Int(ast::IntTy::I128) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.i128_impl(),\n                                           None,\n                                           \"i128\",\n                                           \"i128\",\n                                           item.span);\n             }\n-            ty::TyInt(ast::IntTy::Isize) => {\n+            ty::Int(ast::IntTy::Isize) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.isize_impl(),\n                                           None,\n                                           \"isize\",\n                                           \"isize\",\n                                           item.span);\n             }\n-            ty::TyUint(ast::UintTy::U8) => {\n+            ty::Uint(ast::UintTy::U8) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.u8_impl(),\n                                           None,\n                                           \"u8\",\n                                           \"u8\",\n                                           item.span);\n             }\n-            ty::TyUint(ast::UintTy::U16) => {\n+            ty::Uint(ast::UintTy::U16) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.u16_impl(),\n                                           None,\n                                           \"u16\",\n                                           \"u16\",\n                                           item.span);\n             }\n-            ty::TyUint(ast::UintTy::U32) => {\n+            ty::Uint(ast::UintTy::U32) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.u32_impl(),\n                                           None,\n                                           \"u32\",\n                                           \"u32\",\n                                           item.span);\n             }\n-            ty::TyUint(ast::UintTy::U64) => {\n+            ty::Uint(ast::UintTy::U64) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.u64_impl(),\n                                           None,\n                                           \"u64\",\n                                           \"u64\",\n                                           item.span);\n             }\n-            ty::TyUint(ast::UintTy::U128) => {\n+            ty::Uint(ast::UintTy::U128) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.u128_impl(),\n                                           None,\n                                           \"u128\",\n                                           \"u128\",\n                                           item.span);\n             }\n-            ty::TyUint(ast::UintTy::Usize) => {\n+            ty::Uint(ast::UintTy::Usize) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.usize_impl(),\n                                           None,\n                                           \"usize\",\n                                           \"usize\",\n                                           item.span);\n             }\n-            ty::TyFloat(ast::FloatTy::F32) => {\n+            ty::Float(ast::FloatTy::F32) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.f32_impl(),\n                                           lang_items.f32_runtime_impl(),\n                                           \"f32\",\n                                           \"f32\",\n                                           item.span);\n             }\n-            ty::TyFloat(ast::FloatTy::F64) => {\n+            ty::Float(ast::FloatTy::F64) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.f64_impl(),\n                                           lang_items.f64_runtime_impl(),\n                                           \"f64\",\n                                           \"f64\",\n                                           item.span);\n             }\n-            ty::TyError => {\n+            ty::Error => {\n                 return;\n             }\n             _ => {"}, {"sha": "168cf47fb5266e3df036ca3f0a4a76551b93f28b", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -157,7 +157,7 @@ fn check_impl_overlap<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeI\n     tcx.specialization_graph_of(trait_def_id);\n \n     // check for overlap with the automatic `impl Trait for Trait`\n-    if let ty::TyDynamic(ref data, ..) = trait_ref.self_ty().sty {\n+    if let ty::Dynamic(ref data, ..) = trait_ref.self_ty().sty {\n         // This is something like impl Trait1 for Trait2. Illegal\n         // if Trait1 is a supertrait of Trait2 or Trait2 is not object safe.\n "}, {"sha": "f9b89488232d26e5b098b7efffa7bdd1a4faa041", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -114,8 +114,8 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n                    !trait_def_id.is_local() {\n                     let self_ty = trait_ref.self_ty();\n                     let opt_self_def_id = match self_ty.sty {\n-                        ty::TyAdt(self_def, _) => Some(self_def.did),\n-                        ty::TyForeign(did) => Some(did),\n+                        ty::Adt(self_def, _) => Some(self_def.did),\n+                        ty::Foreign(did) => Some(did),\n                         _ => None,\n                     };\n "}, {"sha": "37b0b83ccd0880851c6a523e55575e245e11b396", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -62,11 +62,11 @@ struct ParameterCollector {\n impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n         match t.sty {\n-            ty::TyProjection(..) | ty::TyAnon(..) if !self.include_nonconstraining => {\n+            ty::Projection(..) | ty::Anon(..) if !self.include_nonconstraining => {\n                 // projections are not injective\n                 return false;\n             }\n-            ty::TyParam(data) => {\n+            ty::Param(data) => {\n                 self.parameters.push(Parameter::from(data));\n             }\n             _ => {}"}, {"sha": "eddbac3f5417bc18293750f31fde75675a5bfa06", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -185,7 +185,7 @@ fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let main_def_id = tcx.hir.local_def_id(main_id);\n     let main_t = tcx.type_of(main_def_id);\n     match main_t.sty {\n-        ty::TyFnDef(..) => {\n+        ty::FnDef(..) => {\n             match tcx.hir.find(main_id) {\n                 Some(hir_map::NodeItem(it)) => {\n                     match it.node {\n@@ -257,7 +257,7 @@ fn check_start_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let start_def_id = tcx.hir.local_def_id(start_id);\n     let start_t = tcx.type_of(start_def_id);\n     match start_t.sty {\n-        ty::TyFnDef(..) => {\n+        ty::FnDef(..) => {\n             match tcx.hir.find(start_id) {\n                 Some(hir_map::NodeItem(it)) => {\n                     match it.node {"}, {"sha": "ec36fa0fbc14531572d1a1b8a5cc1ea3313b8782", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -85,7 +85,7 @@ impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n                     // Calculating the predicate requirements necessary\n                     // for item_did.\n                     //\n-                    // For field of type &'a T (reference) or TyAdt\n+                    // For field of type &'a T (reference) or Adt\n                     // (struct/enum/union) there will be outlive\n                     // requirements for adt_def.\n                     let field_ty = self.tcx.type_of(field_def.did);\n@@ -138,16 +138,16 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n             // a predicate requirement of T: 'a (T outlives 'a).\n             //\n             // We also want to calculate potential predicates for the T\n-            ty::TyRef(region, rty, _) => {\n-                debug!(\"TyRef\");\n+            ty::Ref(region, rty, _) => {\n+                debug!(\"Ref\");\n                 insert_outlives_predicate(tcx, rty.into(), region, required_predicates);\n             }\n \n-            // For each TyAdt (struct/enum/union) type `Foo<'a, T>`, we\n+            // For each Adt (struct/enum/union) type `Foo<'a, T>`, we\n             // can load the current set of inferred and explicit\n             // predicates from `global_inferred_outlives` and filter the\n             // ones that are TypeOutlives.\n-            ty::TyAdt(def, substs) => {\n+            ty::Adt(def, substs) => {\n                 // First check the inferred predicates\n                 //\n                 // Example 1:\n@@ -166,7 +166,7 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 // round we will get `U: 'b`. We then apply the substitution\n                 // `['b => 'a, U => T]` and thus get the requirement that `T:\n                 // 'a` holds for `Foo`.\n-                debug!(\"TyAdt\");\n+                debug!(\"Adt\");\n                 if let Some(unsubstituted_predicates) = global_inferred_outlives.get(&def.did) {\n                     for unsubstituted_predicate in unsubstituted_predicates {\n                         // `unsubstituted_predicate` is `U: 'b` in the\n@@ -195,7 +195,7 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 );\n             }\n \n-            ty::TyDynamic(obj, ..) => {\n+            ty::Dynamic(obj, ..) => {\n                 // This corresponds to `dyn Trait<..>`. In this case, we should\n                 // use the explicit predicates as well.\n \n@@ -204,7 +204,7 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 // `dyn Trait` at this stage. Therefore when checking explicit\n                 // predicates in `check_explicit_predicates` we need to ignore\n                 // checking the explicit_map for Self type.\n-                debug!(\"TyDynamic\");\n+                debug!(\"Dynamic\");\n                 debug!(\"field_ty = {}\", &field_ty);\n                 debug!(\"ty in field = {}\", &ty);\n                 if let Some(ex_trait_ref) = obj.principal() {\n@@ -219,10 +219,10 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 }\n             }\n \n-            ty::TyProjection(obj) => {\n+            ty::Projection(obj) => {\n                 // This corresponds to `<T as Foo<'a>>::Bar`. In this case, we should use the\n                 // explicit predicates as well.\n-                debug!(\"TyProjection\");\n+                debug!(\"Projection\");\n                 check_explicit_predicates(\n                     tcx,\n                     &tcx.associated_item(obj.item_def_id).container.id(),"}, {"sha": "a79215497182e252e1072e6ce73a2ecde2a0d3d2", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -152,7 +152,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         let inferred_start = self.terms_cx.inferred_starts[&id];\n         let current_item = &CurrentItem { inferred_start };\n         match tcx.type_of(def_id).sty {\n-            ty::TyAdt(def, _) => {\n+            ty::Adt(def, _) => {\n                 // Not entirely obvious: constraints on structs/enums do not\n                 // affect the variance of their type parameters. See discussion\n                 // in comment at top of module.\n@@ -166,7 +166,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 }\n             }\n \n-            ty::TyFnDef(..) => {\n+            ty::FnDef(..) => {\n                 self.add_constraints_from_sig(current_item,\n                                               tcx.fn_sig(def_id),\n                                               self.covariant);\n@@ -261,52 +261,52 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                variance);\n \n         match ty.sty {\n-            ty::TyBool | ty::TyChar | ty::TyInt(_) | ty::TyUint(_) | ty::TyFloat(_) |\n-            ty::TyStr | ty::TyNever | ty::TyForeign(..) => {\n+            ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) |\n+            ty::Str | ty::Never | ty::Foreign(..) => {\n                 // leaf type -- noop\n             }\n \n-            ty::TyFnDef(..) |\n-            ty::TyGenerator(..) |\n-            ty::TyClosure(..) => {\n+            ty::FnDef(..) |\n+            ty::Generator(..) |\n+            ty::Closure(..) => {\n                 bug!(\"Unexpected closure type in variance computation\");\n             }\n \n-            ty::TyRef(region, ty, mutbl) => {\n+            ty::Ref(region, ty, mutbl) => {\n                 let contra = self.contravariant(variance);\n                 self.add_constraints_from_region(current, region, contra);\n                 self.add_constraints_from_mt(current, &ty::TypeAndMut { ty, mutbl }, variance);\n             }\n \n-            ty::TyArray(typ, _) |\n-            ty::TySlice(typ) => {\n+            ty::Array(typ, _) |\n+            ty::Slice(typ) => {\n                 self.add_constraints_from_ty(current, typ, variance);\n             }\n \n-            ty::TyRawPtr(ref mt) => {\n+            ty::RawPtr(ref mt) => {\n                 self.add_constraints_from_mt(current, mt, variance);\n             }\n \n-            ty::TyTuple(subtys) => {\n+            ty::Tuple(subtys) => {\n                 for &subty in subtys {\n                     self.add_constraints_from_ty(current, subty, variance);\n                 }\n             }\n \n-            ty::TyAdt(def, substs) => {\n+            ty::Adt(def, substs) => {\n                 self.add_constraints_from_substs(current, def.did, substs, variance);\n             }\n \n-            ty::TyProjection(ref data) => {\n+            ty::Projection(ref data) => {\n                 let tcx = self.tcx();\n                 self.add_constraints_from_trait_ref(current, data.trait_ref(tcx), variance);\n             }\n \n-            ty::TyAnon(_, substs) => {\n+            ty::Anon(_, substs) => {\n                 self.add_constraints_from_invariant_substs(current, substs, variance);\n             }\n \n-            ty::TyDynamic(ref data, r) => {\n+            ty::Dynamic(ref data, r) => {\n                 // The type `Foo<T+'a>` is contravariant w/r/t `'a`:\n                 let contra = self.contravariant(variance);\n                 self.add_constraints_from_region(current, r, contra);\n@@ -323,21 +323,21 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 }\n             }\n \n-            ty::TyParam(ref data) => {\n+            ty::Param(ref data) => {\n                 self.add_constraint(current, data.idx, variance);\n             }\n \n-            ty::TyFnPtr(sig) => {\n+            ty::FnPtr(sig) => {\n                 self.add_constraints_from_sig(current, sig, variance);\n             }\n \n-            ty::TyError => {\n+            ty::Error => {\n                 // we encounter this when walking the trait references for object\n-                // types, where we use TyError as the Self type\n+                // types, where we use Error as the Self type\n             }\n \n-            ty::TyGeneratorWitness(..) |\n-            ty::TyInfer(..) => {\n+            ty::GeneratorWitness(..) |\n+            ty::Infer(..) => {\n                 bug!(\"unexpected type encountered in \\\n                       variance inference: {}\",\n                      ty);"}, {"sha": "7116a42cead83b5dacb5a99706b07075e52845dc", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -101,7 +101,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n             debug!(\"id={} variances={:?}\", id, variances);\n \n             // Functions can have unused type parameters: make those invariant.\n-            if let ty::TyFnDef(..) = tcx.type_of(def_id).sty {\n+            if let ty::FnDef(..) = tcx.type_of(def_id).sty {\n                 for variance in &mut variances {\n                     if *variance == ty::Bivariant {\n                         *variance = ty::Invariant;"}, {"sha": "e7e371cd5678569fafbbc64bf074eaf495daf8df", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -83,7 +83,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> BlanketImplFinder <'a, 'tcx, 'rcx, 'cstore> {\n                                              .expect(\"Cannot get impl trait\");\n \n                     match trait_ref.self_ty().sty {\n-                        ty::TypeVariants::TyParam(_) => {},\n+                        ty::Param(_) => {},\n                         _ => return,\n                     }\n "}, {"sha": "cd9f4eb42dfc675008268ad4c3efd39e6952c848", "filename": "src/librustdoc/clean/def_ctor.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustdoc%2Fclean%2Fdef_ctor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustdoc%2Fclean%2Fdef_ctor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fdef_ctor.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -20,24 +20,24 @@ where F: Fn(& dyn Fn(DefId) -> Def) -> Vec<Item> {\n     let ty = cx.tcx.type_of(def_id);\n \n     match ty.sty {\n-        ty::TyAdt(adt, _) => callback(&match adt.adt_kind() {\n+        ty::Adt(adt, _) => callback(&match adt.adt_kind() {\n             AdtKind::Struct => Def::Struct,\n             AdtKind::Enum => Def::Enum,\n             AdtKind::Union => Def::Union,\n         }),\n-        ty::TyInt(_) |\n-        ty::TyUint(_) |\n-        ty::TyFloat(_) |\n-        ty::TyStr |\n-        ty::TyBool |\n-        ty::TyChar => callback(&move |_: DefId| {\n+        ty::Int(_) |\n+        ty::Uint(_) |\n+        ty::Float(_) |\n+        ty::Str |\n+        ty::Bool |\n+        ty::Char => callback(&move |_: DefId| {\n             match ty.sty {\n-                ty::TyInt(x) => Def::PrimTy(hir::TyInt(x)),\n-                ty::TyUint(x) => Def::PrimTy(hir::TyUint(x)),\n-                ty::TyFloat(x) => Def::PrimTy(hir::TyFloat(x)),\n-                ty::TyStr => Def::PrimTy(hir::TyStr),\n-                ty::TyBool => Def::PrimTy(hir::TyBool),\n-                ty::TyChar => Def::PrimTy(hir::TyChar),\n+                ty::Int(x) => Def::PrimTy(hir::Int(x)),\n+                ty::Uint(x) => Def::PrimTy(hir::Uint(x)),\n+                ty::Float(x) => Def::PrimTy(hir::Float(x)),\n+                ty::Str => Def::PrimTy(hir::Str),\n+                ty::Bool => Def::PrimTy(hir::Bool),\n+                ty::Char => Def::PrimTy(hir::Char),\n                 _ => unreachable!(),\n             }\n         }),"}, {"sha": "75d7488d26a75ac67b9ae9c7474293511f1f15bb", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -83,7 +83,7 @@ pub fn try_inline(cx: &DocContext, def: Def, name: ast::Name, visited: &mut FxHa\n             ret.extend(build_impls(cx, did, true));\n             clean::EnumItem(build_enum(cx, did))\n         }\n-        Def::TyForeign(did) => {\n+        Def::ForeignTy(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Foreign);\n             ret.extend(build_impls(cx, did, false));\n             clean::ForeignTypeItem"}, {"sha": "a8bfb3efd33ed9d25bb3a7eaa2aeeedb0f3f555d", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -1077,7 +1077,7 @@ fn external_generic_args(cx: &DocContext, trait_did: Option<DefId>, has_self: bo\n         Some(did) if cx.tcx.lang_items().fn_trait_kind(did).is_some() => {\n             assert_eq!(types.len(), 1);\n             let inputs = match types[0].sty {\n-                ty::TyTuple(ref tys) => tys.iter().map(|t| t.clean(cx)).collect(),\n+                ty::Tuple(ref tys) => tys.iter().map(|t| t.clean(cx)).collect(),\n                 _ => {\n                     return GenericArgs::AngleBracketed {\n                         lifetimes,\n@@ -1089,7 +1089,7 @@ fn external_generic_args(cx: &DocContext, trait_did: Option<DefId>, has_self: bo\n             let output = None;\n             // FIXME(#20299) return type comes from a projection now\n             // match types[1].sty {\n-            //     ty::TyTuple(ref v) if v.is_empty() => None, // -> ()\n+            //     ty::Tuple(ref v) if v.is_empty() => None, // -> ()\n             //     _ => Some(types[1].clean(cx))\n             // };\n             GenericArgs::Parenthesized {\n@@ -1133,9 +1133,9 @@ impl<'a, 'tcx> Clean<GenericBound> for (&'a ty::TraitRef<'tcx>, Vec<TypeBinding>\n         // collect any late bound regions\n         let mut late_bounds = vec![];\n         for ty_s in trait_ref.input_types().skip(1) {\n-            if let ty::TyTuple(ts) = ty_s.sty {\n+            if let ty::Tuple(ts) = ty_s.sty {\n                 for &ty_s in ts {\n-                    if let ty::TyRef(ref reg, _, _) = ty_s.sty {\n+                    if let ty::Ref(ref reg, _, _) = ty_s.sty {\n                         if let &ty::RegionKind::ReLateBound(..) = *reg {\n                             debug!(\"  hit an ReLateBound {:?}\", reg);\n                             if let Some(Lifetime(name)) = reg.clean(cx) {\n@@ -1979,7 +1979,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                     let self_arg_ty = *sig.input(0).skip_binder();\n                     if self_arg_ty == self_ty {\n                         decl.inputs.values[0].type_ = Generic(String::from(\"Self\"));\n-                    } else if let ty::TyRef(_, ty, _) = self_arg_ty.sty {\n+                    } else if let ty::Ref(_, ty, _) = self_arg_ty.sty {\n                         if ty == self_ty {\n                             match decl.inputs.values[0].type_ {\n                                 BorrowedRef{ref mut type_, ..} => {\n@@ -2506,7 +2506,7 @@ impl Clean<Type> for hir::Ty {\n             TyKind::Path(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n                 let mut def = Def::Err;\n                 let ty = hir_ty_to_ty(cx.tcx, self);\n-                if let ty::TyProjection(proj) = ty.sty {\n+                if let ty::Projection(proj) = ty.sty {\n                     def = Def::Trait(proj.trait_ref(cx.tcx).def_id);\n                 }\n                 let trait_path = hir::Path {\n@@ -2545,15 +2545,15 @@ impl Clean<Type> for hir::Ty {\n impl<'tcx> Clean<Type> for Ty<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Type {\n         match self.sty {\n-            ty::TyNever => Never,\n-            ty::TyBool => Primitive(PrimitiveType::Bool),\n-            ty::TyChar => Primitive(PrimitiveType::Char),\n-            ty::TyInt(int_ty) => Primitive(int_ty.into()),\n-            ty::TyUint(uint_ty) => Primitive(uint_ty.into()),\n-            ty::TyFloat(float_ty) => Primitive(float_ty.into()),\n-            ty::TyStr => Primitive(PrimitiveType::Str),\n-            ty::TySlice(ty) => Slice(box ty.clean(cx)),\n-            ty::TyArray(ty, n) => {\n+            ty::Never => Never,\n+            ty::Bool => Primitive(PrimitiveType::Bool),\n+            ty::Char => Primitive(PrimitiveType::Char),\n+            ty::Int(int_ty) => Primitive(int_ty.into()),\n+            ty::Uint(uint_ty) => Primitive(uint_ty.into()),\n+            ty::Float(float_ty) => Primitive(float_ty.into()),\n+            ty::Str => Primitive(PrimitiveType::Str),\n+            ty::Slice(ty) => Slice(box ty.clean(cx)),\n+            ty::Array(ty, n) => {\n                 let mut n = cx.tcx.lift(&n).expect(\"array lift failed\");\n                 if let ConstValue::Unevaluated(def_id, substs) = n.val {\n                     let param_env = cx.tcx.param_env(def_id);\n@@ -2568,15 +2568,15 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 let n = print_const(cx, n);\n                 Array(box ty.clean(cx), n)\n             }\n-            ty::TyRawPtr(mt) => RawPointer(mt.mutbl.clean(cx), box mt.ty.clean(cx)),\n-            ty::TyRef(r, ty, mutbl) => BorrowedRef {\n+            ty::RawPtr(mt) => RawPointer(mt.mutbl.clean(cx), box mt.ty.clean(cx)),\n+            ty::Ref(r, ty, mutbl) => BorrowedRef {\n                 lifetime: r.clean(cx),\n                 mutability: mutbl.clean(cx),\n                 type_: box ty.clean(cx),\n             },\n-            ty::TyFnDef(..) |\n-            ty::TyFnPtr(_) => {\n-                let ty = cx.tcx.lift(self).expect(\"TyFnPtr lift failed\");\n+            ty::FnDef(..) |\n+            ty::FnPtr(_) => {\n+                let ty = cx.tcx.lift(self).expect(\"FnPtr lift failed\");\n                 let sig = ty.fn_sig(cx.tcx);\n                 BareFunction(box BareFunctionDecl {\n                     unsafety: sig.unsafety(),\n@@ -2585,7 +2585,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                     abi: sig.abi(),\n                 })\n             }\n-            ty::TyAdt(def, substs) => {\n+            ty::Adt(def, substs) => {\n                 let did = def.did;\n                 let kind = match def.adt_kind() {\n                     AdtKind::Struct => TypeKind::Struct,\n@@ -2602,7 +2602,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                     is_generic: false,\n                 }\n             }\n-            ty::TyForeign(did) => {\n+            ty::Foreign(did) => {\n                 inline::record_extern_fqn(cx, did, TypeKind::Foreign);\n                 let path = external_path(cx, &cx.tcx.item_name(did).as_str(),\n                                          None, false, vec![], Substs::empty());\n@@ -2613,7 +2613,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                     is_generic: false,\n                 }\n             }\n-            ty::TyDynamic(ref obj, ref reg) => {\n+            ty::Dynamic(ref obj, ref reg) => {\n                 if let Some(principal) = obj.principal() {\n                     let did = principal.def_id();\n                     inline::record_extern_fqn(cx, did, TypeKind::Trait);\n@@ -2657,17 +2657,17 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                     Never\n                 }\n             }\n-            ty::TyTuple(ref t) => Tuple(t.clean(cx)),\n+            ty::Tuple(ref t) => Tuple(t.clean(cx)),\n \n-            ty::TyProjection(ref data) => data.clean(cx),\n+            ty::Projection(ref data) => data.clean(cx),\n \n-            ty::TyParam(ref p) => Generic(p.name.to_string()),\n+            ty::Param(ref p) => Generic(p.name.to_string()),\n \n-            ty::TyAnon(def_id, substs) => {\n+            ty::Anon(def_id, substs) => {\n                 // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n                 // by looking up the projections associated with the def_id.\n                 let predicates_of = cx.tcx.predicates_of(def_id);\n-                let substs = cx.tcx.lift(&substs).expect(\"TyAnon lift failed\");\n+                let substs = cx.tcx.lift(&substs).expect(\"Anon lift failed\");\n                 let bounds = predicates_of.instantiate(cx.tcx, substs);\n                 let mut regions = vec![];\n                 let mut has_sized = false;\n@@ -2717,11 +2717,11 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 ImplTrait(bounds)\n             }\n \n-            ty::TyClosure(..) | ty::TyGenerator(..) => Tuple(vec![]), // FIXME(pcwalton)\n+            ty::Closure(..) | ty::Generator(..) => Tuple(vec![]), // FIXME(pcwalton)\n \n-            ty::TyGeneratorWitness(..) => panic!(\"TyGeneratorWitness\"),\n-            ty::TyInfer(..) => panic!(\"TyInfer\"),\n-            ty::TyError => panic!(\"TyError\"),\n+            ty::GeneratorWitness(..) => panic!(\"GeneratorWitness\"),\n+            ty::Infer(..) => panic!(\"Infer\"),\n+            ty::Error => panic!(\"Error\"),\n         }\n     }\n }\n@@ -3700,12 +3700,12 @@ fn resolve_type(cx: &DocContext,\n \n     let is_generic = match path.def {\n         Def::PrimTy(p) => match p {\n-            hir::TyStr => return Primitive(PrimitiveType::Str),\n-            hir::TyBool => return Primitive(PrimitiveType::Bool),\n-            hir::TyChar => return Primitive(PrimitiveType::Char),\n-            hir::TyInt(int_ty) => return Primitive(int_ty.into()),\n-            hir::TyUint(uint_ty) => return Primitive(uint_ty.into()),\n-            hir::TyFloat(float_ty) => return Primitive(float_ty.into()),\n+            hir::Str => return Primitive(PrimitiveType::Str),\n+            hir::Bool => return Primitive(PrimitiveType::Bool),\n+            hir::Char => return Primitive(PrimitiveType::Char),\n+            hir::Int(int_ty) => return Primitive(int_ty.into()),\n+            hir::Uint(uint_ty) => return Primitive(uint_ty.into()),\n+            hir::Float(float_ty) => return Primitive(float_ty.into()),\n         },\n         Def::SelfTy(..) if path.segments.len() == 1 => {\n             return Generic(keywords::SelfType.name().to_string());\n@@ -3731,7 +3731,7 @@ pub fn register_def(cx: &DocContext, def: Def) -> DefId {\n         Def::Struct(i) => (i, TypeKind::Struct),\n         Def::Union(i) => (i, TypeKind::Union),\n         Def::Mod(i) => (i, TypeKind::Module),\n-        Def::TyForeign(i) => (i, TypeKind::Foreign),\n+        Def::ForeignTy(i) => (i, TypeKind::Foreign),\n         Def::Const(i) => (i, TypeKind::Const),\n         Def::Static(i, _) => (i, TypeKind::Static),\n         Def::Variant(i) => (cx.tcx.parent_def_id(i).expect(\"cannot get parent def id\"),"}, {"sha": "cced30d1a0c205fc0fe19d6e73f6fb68d07f6a10", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -149,7 +149,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> LinkCollector<'a, 'tcx, 'rcx, 'cstore> {\n                         Ok((ty.def, Some(format!(\"{}.{}\", out, item_name))))\n                     } else {\n                         match cx.tcx.type_of(did).sty {\n-                            ty::TyAdt(def, _) => {\n+                            ty::Adt(def, _) => {\n                                 if let Some(item) = if def.is_enum() {\n                                     def.all_fields().find(|item| item.ident.name == item_name)\n                                 } else {\n@@ -567,23 +567,23 @@ fn handle_variant(cx: &DocContext, def: Def) -> Result<(Def, Option<String>), ()\n }\n \n const PRIMITIVES: &[(&str, Def)] = &[\n-    (\"u8\",    Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::U8))),\n-    (\"u16\",   Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::U16))),\n-    (\"u32\",   Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::U32))),\n-    (\"u64\",   Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::U64))),\n-    (\"u128\",  Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::U128))),\n-    (\"usize\", Def::PrimTy(hir::PrimTy::TyUint(syntax::ast::UintTy::Usize))),\n-    (\"i8\",    Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::I8))),\n-    (\"i16\",   Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::I16))),\n-    (\"i32\",   Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::I32))),\n-    (\"i64\",   Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::I64))),\n-    (\"i128\",  Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::I128))),\n-    (\"isize\", Def::PrimTy(hir::PrimTy::TyInt(syntax::ast::IntTy::Isize))),\n-    (\"f32\",   Def::PrimTy(hir::PrimTy::TyFloat(syntax::ast::FloatTy::F32))),\n-    (\"f64\",   Def::PrimTy(hir::PrimTy::TyFloat(syntax::ast::FloatTy::F64))),\n-    (\"str\",   Def::PrimTy(hir::PrimTy::TyStr)),\n-    (\"bool\",  Def::PrimTy(hir::PrimTy::TyBool)),\n-    (\"char\",  Def::PrimTy(hir::PrimTy::TyChar)),\n+    (\"u8\",    Def::PrimTy(hir::PrimTy::Uint(syntax::ast::UintTy::U8))),\n+    (\"u16\",   Def::PrimTy(hir::PrimTy::Uint(syntax::ast::UintTy::U16))),\n+    (\"u32\",   Def::PrimTy(hir::PrimTy::Uint(syntax::ast::UintTy::U32))),\n+    (\"u64\",   Def::PrimTy(hir::PrimTy::Uint(syntax::ast::UintTy::U64))),\n+    (\"u128\",  Def::PrimTy(hir::PrimTy::Uint(syntax::ast::UintTy::U128))),\n+    (\"usize\", Def::PrimTy(hir::PrimTy::Uint(syntax::ast::UintTy::Usize))),\n+    (\"i8\",    Def::PrimTy(hir::PrimTy::Int(syntax::ast::IntTy::I8))),\n+    (\"i16\",   Def::PrimTy(hir::PrimTy::Int(syntax::ast::IntTy::I16))),\n+    (\"i32\",   Def::PrimTy(hir::PrimTy::Int(syntax::ast::IntTy::I32))),\n+    (\"i64\",   Def::PrimTy(hir::PrimTy::Int(syntax::ast::IntTy::I64))),\n+    (\"i128\",  Def::PrimTy(hir::PrimTy::Int(syntax::ast::IntTy::I128))),\n+    (\"isize\", Def::PrimTy(hir::PrimTy::Int(syntax::ast::IntTy::Isize))),\n+    (\"f32\",   Def::PrimTy(hir::PrimTy::Float(syntax::ast::FloatTy::F32))),\n+    (\"f64\",   Def::PrimTy(hir::PrimTy::Float(syntax::ast::FloatTy::F64))),\n+    (\"str\",   Def::PrimTy(hir::PrimTy::Str)),\n+    (\"bool\",  Def::PrimTy(hir::PrimTy::Bool)),\n+    (\"char\",  Def::PrimTy(hir::PrimTy::Char)),\n ];\n \n fn is_primitive(path_str: &str, is_val: bool) -> Option<Def> {"}, {"sha": "15a94b8adfcb27d335d51fdd91630913f8bb73ec", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -267,7 +267,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n                 Def::Struct(did) |\n                 Def::Union(did) |\n                 Def::Enum(did) |\n-                Def::TyForeign(did) |\n+                Def::ForeignTy(did) |\n                 Def::TyAlias(did) if !self_is_hidden => {\n                     self.cx.access_levels.borrow_mut().map.insert(did, AccessLevel::Public);\n                 },"}, {"sha": "87b01ed990036cae7ad8c85acb429c188d31366b", "filename": "src/test/run-pass/auxiliary/issue13507.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue13507.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue13507.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue13507.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -32,43 +32,43 @@ pub mod testtypes {\n         ]\n     }\n \n-    // Tests TyBool\n+    // Tests Bool\n     pub type FooBool = bool;\n \n-    // Tests TyChar\n+    // Tests Char\n     pub type FooChar = char;\n \n-    // Tests TyInt (does not test all variants of IntTy)\n+    // Tests Int (does not test all variants of IntTy)\n     pub type FooInt = isize;\n \n-    // Tests TyUint (does not test all variants of UintTy)\n+    // Tests Uint (does not test all variants of UintTy)\n     pub type FooUint = usize;\n \n-    // Tests TyFloat (does not test all variants of FloatTy)\n+    // Tests Float (does not test all variants of FloatTy)\n     pub type FooFloat = f64;\n \n-    // Tests TyStr\n+    // Tests Str\n     pub type FooStr = str;\n \n-    // Tests TyArray\n+    // Tests Array\n     pub type FooArray = [u8; 1];\n \n-    // Tests TySlice\n+    // Tests Slice\n     pub type FooSlice = [u8];\n \n     // Tests Box (of u8)\n     pub type FooBox = Box<u8>;\n \n-    // Tests TyRawPtr\n+    // Tests RawPtr\n     pub type FooPtr = *const u8;\n \n-    // Tests TyRef\n+    // Tests Ref\n     pub type FooRef = &'static u8;\n \n-    // Tests TyFnPtr\n+    // Tests FnPtr\n     pub type FooFnPtr = fn(u8) -> bool;\n \n-    // Tests TyDynamic\n+    // Tests Dynamic\n     pub trait FooTrait {\n         fn foo_method(&self) -> usize;\n     }\n@@ -85,13 +85,13 @@ pub mod testtypes {\n         VarB(usize, usize)\n     }\n \n-    // Tests TyTuple\n+    // Tests Tuple\n     pub type FooNil = ();\n     pub type FooTuple = (u8, i8, bool);\n \n-    // Skipping TyParam\n+    // Skipping Param\n \n-    // Skipping TyInfer\n+    // Skipping Infer\n \n-    // Skipping TyError\n+    // Skipping Error\n }"}, {"sha": "c95885518ea2f44d7cd83ee98a86e06d27d7e9bd", "filename": "src/test/run-pass/unboxed-closures-unique-type-id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Ftest%2Frun-pass%2Funboxed-closures-unique-type-id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75b0471a8b87c44e0bd953d2a5c36d896128723/src%2Ftest%2Frun-pass%2Funboxed-closures-unique-type-id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-unique-type-id.rs?ref=b75b0471a8b87c44e0bd953d2a5c36d896128723", "patch": "@@ -12,7 +12,7 @@\n //\n //    error: internal compiler error: get_unique_type_id_of_type() -\n //    unexpected type: closure,\n-//    TyClosure(syntax::ast::DefId{krate: 0, node: 66},\n+//    Closure(syntax::ast::DefId{krate: 0, node: 66},\n //    ReScope(63))\n //\n // This is a regression test for issue #17021."}]}