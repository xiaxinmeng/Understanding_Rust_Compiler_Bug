{"sha": "34d1352f0eb7e7511e34b1e7640e854ffaf3f137", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0ZDEzNTJmMGViN2U3NTExZTM0YjFlNzY0MGU4NTRmZmFmM2YxMzc=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-10-17T03:02:23Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-28T02:18:10Z"}, "message": "rustc: encode the optionality of type parameters in HIR paths.", "tree": {"sha": "090943b69607f2ce56b50f523ded1dd0fb23ccd2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/090943b69607f2ce56b50f523ded1dd0fb23ccd2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34d1352f0eb7e7511e34b1e7640e854ffaf3f137", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34d1352f0eb7e7511e34b1e7640e854ffaf3f137", "html_url": "https://github.com/rust-lang/rust/commit/34d1352f0eb7e7511e34b1e7640e854ffaf3f137", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34d1352f0eb7e7511e34b1e7640e854ffaf3f137/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ca50bd4d50b55456e88a8c3ad8fcc9798f57522", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ca50bd4d50b55456e88a8c3ad8fcc9798f57522", "html_url": "https://github.com/rust-lang/rust/commit/9ca50bd4d50b55456e88a8c3ad8fcc9798f57522"}], "stats": {"total": 218, "additions": 112, "deletions": 106}, "files": [{"sha": "264a5722bcd76ad7f8c4f079ee85550769c18c7f", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 67, "deletions": 31, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/34d1352f0eb7e7511e34b1e7640e854ffaf3f137/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d1352f0eb7e7511e34b1e7640e854ffaf3f137/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=34d1352f0eb7e7511e34b1e7640e854ffaf3f137", "patch": "@@ -101,6 +101,14 @@ pub fn lower_crate(sess: &Session,\n     }.lower_crate(krate)\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq)]\n+enum ParamMode {\n+    /// Any path in a type context.\n+    Explicit,\n+    /// The `module::Type` in `module::Type::method` in an expression.\n+    Optional\n+}\n+\n impl<'a> LoweringContext<'a> {\n     fn lower_crate(&mut self, c: &Crate) -> hir::Crate {\n         struct ItemLowerer<'lcx, 'interner: 'lcx> {\n@@ -179,13 +187,14 @@ impl<'a> LoweringContext<'a> {\n         P(Spanned {\n             node: match view_path.node {\n                 ViewPathSimple(ident, ref path) => {\n-                    hir::ViewPathSimple(ident.name, self.lower_path(path))\n+                    hir::ViewPathSimple(ident.name,\n+                                        self.lower_path(path, None, ParamMode::Explicit))\n                 }\n                 ViewPathGlob(ref path) => {\n-                    hir::ViewPathGlob(self.lower_path(path))\n+                    hir::ViewPathGlob(self.lower_path(path, None, ParamMode::Explicit))\n                 }\n                 ViewPathList(ref path, ref path_list_idents) => {\n-                    hir::ViewPathList(self.lower_path(path),\n+                    hir::ViewPathList(self.lower_path(path, None, ParamMode::Explicit),\n                                       path_list_idents.iter()\n                                                       .map(|item| self.lower_path_list_item(item))\n                                                       .collect())\n@@ -256,7 +265,8 @@ impl<'a> LoweringContext<'a> {\n                             position: position,\n                         }\n                     });\n-                    hir::TyPath(qself, self.lower_path(path))\n+                    let path = self.lower_path(path, qself.as_ref(), ParamMode::Explicit);\n+                    hir::TyPath(qself, path)\n                 }\n                 TyKind::ObjectSum(ref ty, ref bounds) => {\n                     hir::TyObjectSum(self.lower_ty(ty), self.lower_bounds(bounds))\n@@ -298,38 +308,56 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_path(&mut self, p: &Path) -> hir::Path {\n+    fn lower_path(&mut self,\n+                  p: &Path,\n+                  qself: Option<&hir::QSelf>,\n+                  param_mode: ParamMode)\n+                  -> hir::Path {\n         hir::Path {\n             global: p.global,\n-            segments: p.segments\n-                       .iter()\n-                       .map(|&PathSegment { identifier, ref parameters }| {\n-                           hir::PathSegment {\n-                               name: identifier.name,\n-                               parameters: self.lower_path_parameters(parameters),\n-                           }\n-                       })\n-                       .collect(),\n+            segments: p.segments.iter().enumerate().map(|(i, segment)| {\n+                let PathSegment { identifier, ref parameters } = *segment;\n+                let param_mode = match (qself, param_mode) {\n+                    (Some(qself), ParamMode::Optional) if i < qself.position => {\n+                        // This segment is part of the trait path in a\n+                        // qualified path - one of `a`, `b` or `Trait`\n+                        // in `<X as a::b::Trait>::T::U::method`.\n+                        ParamMode::Explicit\n+                    }\n+                    _ => param_mode\n+                };\n+                hir::PathSegment {\n+                    name: identifier.name,\n+                    parameters: self.lower_path_parameters(parameters, param_mode),\n+                }\n+            }).collect(),\n             span: p.span,\n         }\n     }\n \n-    fn lower_path_parameters(&mut self, path_parameters: &PathParameters) -> hir::PathParameters {\n+    fn lower_path_parameters(&mut self,\n+                             path_parameters: &PathParameters,\n+                             param_mode: ParamMode)\n+                             -> hir::PathParameters {\n         match *path_parameters {\n-            PathParameters::AngleBracketed(ref data) =>\n-                hir::AngleBracketedParameters(self.lower_angle_bracketed_parameter_data(data)),\n+            PathParameters::AngleBracketed(ref data) => {\n+                let data = self.lower_angle_bracketed_parameter_data(data, param_mode);\n+                hir::AngleBracketedParameters(data)\n+            }\n             PathParameters::Parenthesized(ref data) =>\n                 hir::ParenthesizedParameters(self.lower_parenthesized_parameter_data(data)),\n         }\n     }\n \n     fn lower_angle_bracketed_parameter_data(&mut self,\n-                                            data: &AngleBracketedParameterData)\n+                                            data: &AngleBracketedParameterData,\n+                                            param_mode: ParamMode)\n                                             -> hir::AngleBracketedParameterData {\n         let &AngleBracketedParameterData { ref lifetimes, ref types, ref bindings } = data;\n         hir::AngleBracketedParameterData {\n             lifetimes: self.lower_lifetimes(lifetimes),\n             types: types.iter().map(|ty| self.lower_ty(ty)).collect(),\n+            infer_types: types.is_empty() && param_mode == ParamMode::Optional,\n             bindings: bindings.iter().map(|b| self.lower_ty_binding(b)).collect(),\n         }\n     }\n@@ -493,7 +521,7 @@ impl<'a> LoweringContext<'a> {\n                                                           span}) => {\n                 hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n                     id: id,\n-                    path: self.lower_path(path),\n+                    path: self.lower_path(path, None, ParamMode::Explicit),\n                     ty: self.lower_ty(ty),\n                     span: span,\n                 })\n@@ -523,7 +551,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_trait_ref(&mut self, p: &TraitRef) -> hir::TraitRef {\n         hir::TraitRef {\n-            path: self.lower_path(&p.path),\n+            path: self.lower_path(&p.path, None, ParamMode::Explicit),\n             ref_id: p.ref_id,\n         }\n     }\n@@ -887,17 +915,19 @@ impl<'a> LoweringContext<'a> {\n                 }\n                 PatKind::Lit(ref e) => hir::PatKind::Lit(P(self.lower_expr(e))),\n                 PatKind::TupleStruct(ref path, ref pats, ddpos) => {\n-                    hir::PatKind::TupleStruct(self.lower_path(path),\n-                                        pats.iter().map(|x| self.lower_pat(x)).collect(), ddpos)\n+                    hir::PatKind::TupleStruct(self.lower_path(path, None, ParamMode::Optional),\n+                                              pats.iter().map(|x| self.lower_pat(x)).collect(),\n+                                              ddpos)\n                 }\n-                PatKind::Path(ref opt_qself, ref path) => {\n-                    let opt_qself = opt_qself.as_ref().map(|qself| {\n+                PatKind::Path(ref qself, ref path) => {\n+                    let qself = qself.as_ref().map(|qself| {\n                         hir::QSelf { ty: self.lower_ty(&qself.ty), position: qself.position }\n                     });\n-                    hir::PatKind::Path(opt_qself, self.lower_path(path))\n+                    let path = self.lower_path(path, qself.as_ref(), ParamMode::Optional);\n+                    hir::PatKind::Path(qself, path)\n                 }\n                 PatKind::Struct(ref pth, ref fields, etc) => {\n-                    let pth = self.lower_path(pth);\n+                    let pth = self.lower_path(pth, None, ParamMode::Optional);\n                     let fs = fields.iter()\n                                    .map(|f| {\n                                        Spanned {\n@@ -1236,13 +1266,14 @@ impl<'a> LoweringContext<'a> {\n                     };\n                 }\n                 ExprKind::Path(ref qself, ref path) => {\n-                    let hir_qself = qself.as_ref().map(|&QSelf { ref ty, position }| {\n+                    let qself = qself.as_ref().map(|&QSelf { ref ty, position }| {\n                         hir::QSelf {\n                             ty: self.lower_ty(ty),\n                             position: position,\n                         }\n                     });\n-                    hir::ExprPath(hir_qself, self.lower_path(path))\n+                    let path = self.lower_path(path, qself.as_ref(), ParamMode::Optional);\n+                    hir::ExprPath(qself, path)\n                 }\n                 ExprKind::Break(opt_ident, ref opt_expr) => {\n                     hir::ExprBreak(self.lower_opt_sp_ident(opt_ident),\n@@ -1275,7 +1306,7 @@ impl<'a> LoweringContext<'a> {\n                     hir::ExprInlineAsm(P(hir_asm), outputs, inputs)\n                 }\n                 ExprKind::Struct(ref path, ref fields, ref maybe_expr) => {\n-                    hir::ExprStruct(P(self.lower_path(path)),\n+                    hir::ExprStruct(P(self.lower_path(path, None, ParamMode::Optional)),\n                                     fields.iter().map(|x| self.lower_field(x)).collect(),\n                                     maybe_expr.as_ref().map(|x| P(self.lower_expr(x))))\n                 }\n@@ -1655,8 +1686,12 @@ impl<'a> LoweringContext<'a> {\n         match *v {\n             Visibility::Public => hir::Public,\n             Visibility::Crate(_) => hir::Visibility::Crate,\n-            Visibility::Restricted { ref path, id } =>\n-                hir::Visibility::Restricted { path: P(self.lower_path(path)), id: id },\n+            Visibility::Restricted { ref path, id } => {\n+                hir::Visibility::Restricted {\n+                    path: P(self.lower_path(path, None, ParamMode::Explicit)),\n+                    id: id\n+                }\n+            }\n             Visibility::Inherited => hir::Inherited,\n         }\n     }\n@@ -1949,6 +1984,7 @@ impl<'a> LoweringContext<'a> {\n             parameters: hir::AngleBracketedParameters(hir::AngleBracketedParameterData {\n                 lifetimes: lifetimes,\n                 types: types,\n+                infer_types: true,\n                 bindings: bindings,\n             }),\n         });"}, {"sha": "6f0a3a02380845104df96ce1ef0de7410c40c7ee", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/34d1352f0eb7e7511e34b1e7640e854ffaf3f137/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d1352f0eb7e7511e34b1e7640e854ffaf3f137/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=34d1352f0eb7e7511e34b1e7640e854ffaf3f137", "patch": "@@ -167,6 +167,7 @@ impl PathParameters {\n         AngleBracketedParameters(AngleBracketedParameterData {\n             lifetimes: HirVec::new(),\n             types: HirVec::new(),\n+            infer_types: true,\n             bindings: HirVec::new(),\n         })\n     }\n@@ -241,6 +242,11 @@ pub struct AngleBracketedParameterData {\n     pub lifetimes: HirVec<Lifetime>,\n     /// The type parameters for this path segment, if present.\n     pub types: HirVec<P<Ty>>,\n+    /// Whether to infer remaining type parameters, if any.\n+    /// This only applies to expression and pattern paths, and\n+    /// out of those only the segments with no type parameters\n+    /// to begin with, e.g. `Vec::new` is `<Vec<..>>::new::<..>`.\n+    pub infer_types: bool,\n     /// Bindings (equality constraints) on associated types, if present.\n     /// E.g., `Foo<A=Bar>`.\n     pub bindings: HirVec<TypeBinding>,"}, {"sha": "9934259c5d19106466f809ae053cdb96961c0549", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/34d1352f0eb7e7511e34b1e7640e854ffaf3f137/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d1352f0eb7e7511e34b1e7640e854ffaf3f137/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=34d1352f0eb7e7511e34b1e7640e854ffaf3f137", "patch": "@@ -1696,6 +1696,16 @@ impl<'a> State<'a> {\n                     comma = true;\n                 }\n \n+                // FIXME(eddyb) This would leak into error messages, e.g.:\n+                // \"non-exhaustive patterns: `Some::<..>(_)` not covered\".\n+                if data.infer_types && false {\n+                    if comma {\n+                        self.word_space(\",\")?\n+                    }\n+                    word(&mut self.s, \"..\")?;\n+                    comma = true;\n+                }\n+\n                 for binding in data.bindings.iter() {\n                     if comma {\n                         self.word_space(\",\")?"}, {"sha": "b9b974733409fd67df8389dbe6a2f05a36a2a3ed", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34d1352f0eb7e7511e34b1e7640e854ffaf3f137/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d1352f0eb7e7511e34b1e7640e854ffaf3f137/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=34d1352f0eb7e7511e34b1e7640e854ffaf3f137", "patch": "@@ -1609,6 +1609,7 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                 hir::AngleBracketedParameters(hir::AngleBracketedParameterData {\n                     lifetimes: new_lts.into(),\n                     types: new_types,\n+                    infer_types: data.infer_types,\n                     bindings: new_bindings,\n                })\n             }"}, {"sha": "831426c3f06b67bada3a7fc9cae9bdd4e1dd278a", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 9, "deletions": 50, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/34d1352f0eb7e7511e34b1e7640e854ffaf3f137/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d1352f0eb7e7511e34b1e7640e854ffaf3f137/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=34d1352f0eb7e7511e34b1e7640e854ffaf3f137", "patch": "@@ -149,14 +149,6 @@ pub trait AstConv<'gcx, 'tcx> {\n     fn set_tainted_by_errors(&self);\n }\n \n-#[derive(PartialEq, Eq)]\n-pub enum PathParamMode {\n-    // Any path in a type context.\n-    Explicit,\n-    // The `module::Type` in `module::Type::method` in an expression.\n-    Optional\n-}\n-\n struct ConvertedBinding<'tcx> {\n     item_name: ast::Name,\n     ty: Ty<'tcx>,\n@@ -341,7 +333,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     pub fn ast_path_substs_for_ty(&self,\n         rscope: &RegionScope,\n         span: Span,\n-        param_mode: PathParamMode,\n         def_id: DefId,\n         item_segment: &hir::PathSegment)\n         -> &'tcx Substs<'tcx>\n@@ -367,7 +358,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let (substs, assoc_bindings) =\n             self.create_substs_for_ast_path(rscope,\n                                             span,\n-                                            param_mode,\n                                             def_id,\n                                             &item_segment.parameters,\n                                             None);\n@@ -385,7 +375,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     fn create_substs_for_ast_path(&self,\n         rscope: &RegionScope,\n         span: Span,\n-        param_mode: PathParamMode,\n         def_id: DefId,\n         parameters: &hir::PathParameters,\n         self_ty: Option<Ty<'tcx>>)\n@@ -397,15 +386,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                parameters={:?})\",\n                def_id, self_ty, parameters);\n \n-        let (lifetimes, num_types_provided) = match *parameters {\n+        let (lifetimes, num_types_provided, infer_types) = match *parameters {\n             hir::AngleBracketedParameters(ref data) => {\n-                if param_mode == PathParamMode::Optional && data.types.is_empty() {\n-                    (&data.lifetimes[..], None)\n-                } else {\n-                    (&data.lifetimes[..], Some(data.types.len()))\n-                }\n+                (&data.lifetimes[..], data.types.len(), data.infer_types)\n             }\n-            hir::ParenthesizedParameters(_) => (&[][..], Some(1))\n+            hir::ParenthesizedParameters(_) => (&[][..], 1, false)\n         };\n \n         // If the type is parameterized by this region, then replace this\n@@ -443,9 +428,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         assert_eq!(decl_generics.has_self, self_ty.is_some());\n \n         // Check the number of type parameters supplied by the user.\n-        if let Some(num_provided) = num_types_provided {\n-            let ty_param_defs = &decl_generics.types[self_ty.is_some() as usize..];\n-            check_type_argument_count(tcx, span, num_provided, ty_param_defs);\n+        let ty_param_defs = &decl_generics.types[self_ty.is_some() as usize..];\n+        if !infer_types || num_types_provided > ty_param_defs.len() {\n+            check_type_argument_count(tcx, span, num_types_provided, ty_param_defs);\n         }\n \n         let is_object = self_ty.map_or(false, |ty| ty.sty == TRAIT_OBJECT_DUMMY_SELF);\n@@ -474,7 +459,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n \n             let i = i - self_ty.is_some() as usize - decl_generics.regions.len();\n-            if num_types_provided.map_or(false, |n| i < n) {\n+            if i < num_types_provided {\n                 // A provided type parameter.\n                 match *parameters {\n                     hir::AngleBracketedParameters(ref data) => {\n@@ -488,7 +473,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                         ty\n                     }\n                 }\n-            } else if num_types_provided.is_none() {\n+            } else if infer_types {\n                 // No type parameters were provided, we can infer all.\n                 let ty_var = if !default_needs_object_self(def) {\n                     self.ty_infer_for_def(def, substs, span)\n@@ -664,7 +649,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let trait_def_id = self.trait_def_id(trait_ref);\n         self.ast_path_to_poly_trait_ref(rscope,\n                                         trait_ref.path.span,\n-                                        PathParamMode::Explicit,\n                                         trait_def_id,\n                                         self_ty,\n                                         trait_ref.ref_id,\n@@ -687,7 +671,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let trait_def_id = self.trait_def_id(trait_ref);\n         self.ast_path_to_mono_trait_ref(rscope,\n                                         trait_ref.path.span,\n-                                        PathParamMode::Explicit,\n                                         trait_def_id,\n                                         self_ty,\n                                         trait_ref.path.segments.last().unwrap())\n@@ -710,7 +693,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     fn ast_path_to_poly_trait_ref(&self,\n         rscope: &RegionScope,\n         span: Span,\n-        param_mode: PathParamMode,\n         trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n         path_id: ast::NodeId,\n@@ -729,7 +711,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let (substs, assoc_bindings) =\n             self.create_substs_for_ast_trait_ref(shifted_rscope,\n                                                  span,\n-                                                 param_mode,\n                                                  trait_def_id,\n                                                  self_ty,\n                                                  trait_segment);\n@@ -752,7 +733,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     fn ast_path_to_mono_trait_ref(&self,\n                                   rscope: &RegionScope,\n                                   span: Span,\n-                                  param_mode: PathParamMode,\n                                   trait_def_id: DefId,\n                                   self_ty: Ty<'tcx>,\n                                   trait_segment: &hir::PathSegment)\n@@ -761,7 +741,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let (substs, assoc_bindings) =\n             self.create_substs_for_ast_trait_ref(rscope,\n                                                  span,\n-                                                 param_mode,\n                                                  trait_def_id,\n                                                  self_ty,\n                                                  trait_segment);\n@@ -772,7 +751,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     fn create_substs_for_ast_trait_ref(&self,\n                                        rscope: &RegionScope,\n                                        span: Span,\n-                                       param_mode: PathParamMode,\n                                        trait_def_id: DefId,\n                                        self_ty: Ty<'tcx>,\n                                        trait_segment: &hir::PathSegment)\n@@ -817,7 +795,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         self.create_substs_for_ast_path(rscope,\n                                         span,\n-                                        param_mode,\n                                         trait_def_id,\n                                         &trait_segment.parameters,\n                                         Some(self_ty))\n@@ -929,7 +906,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     fn ast_path_to_ty(&self,\n         rscope: &RegionScope,\n         span: Span,\n-        param_mode: PathParamMode,\n         did: DefId,\n         item_segment: &hir::PathSegment)\n         -> Ty<'tcx>\n@@ -944,7 +920,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         let substs = self.ast_path_substs_for_ty(rscope,\n                                                  span,\n-                                                 param_mode,\n                                                  did,\n                                                  item_segment);\n \n@@ -983,7 +958,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     Def::Trait(trait_def_id) if resolution.depth == 0 => {\n                         self.trait_path_to_object_type(rscope,\n                                                        path.span,\n-                                                       PathParamMode::Explicit,\n                                                        trait_def_id,\n                                                        ty.id,\n                                                        path.segments.last().unwrap(),\n@@ -1055,7 +1029,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     fn trait_path_to_object_type(&self,\n                                  rscope: &RegionScope,\n                                  path_span: Span,\n-                                 param_mode: PathParamMode,\n                                  trait_def_id: DefId,\n                                  trait_path_ref_id: ast::NodeId,\n                                  trait_segment: &hir::PathSegment,\n@@ -1068,7 +1041,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let dummy_self = tcx.mk_ty(TRAIT_OBJECT_DUMMY_SELF);\n         let principal = self.ast_path_to_poly_trait_ref(rscope,\n                                                         path_span,\n-                                                        param_mode,\n                                                         trait_def_id,\n                                                         dummy_self,\n                                                         trait_path_ref_id,\n@@ -1377,7 +1349,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     fn qpath_to_ty(&self,\n                    rscope: &RegionScope,\n                    span: Span,\n-                   param_mode: PathParamMode,\n                    opt_self_ty: Option<Ty<'tcx>>,\n                    trait_def_id: DefId,\n                    trait_segment: &hir::PathSegment,\n@@ -1403,7 +1374,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         let trait_ref = self.ast_path_to_mono_trait_ref(rscope,\n                                                         span,\n-                                                        param_mode,\n                                                         trait_def_id,\n                                                         self_ty,\n                                                         trait_segment);\n@@ -1448,7 +1418,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     fn base_def_to_ty(&self,\n                       rscope: &RegionScope,\n                       span: Span,\n-                      param_mode: PathParamMode,\n                       def: Def,\n                       opt_self_ty: Option<Ty<'tcx>>,\n                       base_path_ref_id: ast::NodeId,\n@@ -1469,7 +1438,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n                 self.trait_path_to_object_type(rscope,\n                                                span,\n-                                               param_mode,\n                                                trait_def_id,\n                                                base_path_ref_id,\n                                                base_segments.last().unwrap(),\n@@ -1478,11 +1446,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n             Def::Enum(did) | Def::TyAlias(did) | Def::Struct(did) | Def::Union(did) => {\n                 tcx.prohibit_type_params(base_segments.split_last().unwrap().1);\n-                self.ast_path_to_ty(rscope,\n-                                    span,\n-                                    param_mode,\n-                                    did,\n-                                    base_segments.last().unwrap())\n+                self.ast_path_to_ty(rscope, span, did, base_segments.last().unwrap())\n             }\n             Def::Variant(did) if permit_variants => {\n                 // Convert \"variant type\" as if it were a real type.\n@@ -1535,7 +1499,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 let trait_did = tcx.parent_def_id(def_id).unwrap();\n                 self.qpath_to_ty(rscope,\n                                  span,\n-                                 param_mode,\n                                  opt_self_ty,\n                                  trait_did,\n                                  &base_segments[base_segments.len()-2],\n@@ -1577,7 +1540,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     pub fn finish_resolving_def_to_ty(&self,\n                                       rscope: &RegionScope,\n                                       span: Span,\n-                                      param_mode: PathParamMode,\n                                       base_def: Def,\n                                       opt_self_ty: Option<Ty<'tcx>>,\n                                       base_path_ref_id: ast::NodeId,\n@@ -1594,7 +1556,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                assoc_segments);\n         let base_ty = self.base_def_to_ty(rscope,\n                                           span,\n-                                          param_mode,\n                                           base_def,\n                                           opt_self_ty,\n                                           base_path_ref_id,\n@@ -1749,7 +1710,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 });\n                 let (ty, def) = self.finish_resolving_def_to_ty(rscope,\n                                                                 ast_ty.span,\n-                                                                PathParamMode::Explicit,\n                                                                 path_res.base_def,\n                                                                 opt_self_ty,\n                                                                 ast_ty.id,\n@@ -2007,7 +1967,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let trait_def_id = self.trait_def_id(trait_ref);\n         self.trait_path_to_object_type(rscope,\n                                        trait_ref.path.span,\n-                                       PathParamMode::Explicit,\n                                        trait_def_id,\n                                        trait_ref.ref_id,\n                                        trait_ref.path.segments.last().unwrap(),"}, {"sha": "ea84786e06b986ffdaf6fdcab8ba62848c07ca9d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 19, "deletions": 25, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/34d1352f0eb7e7511e34b1e7640e854ffaf3f137/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d1352f0eb7e7511e34b1e7640e854ffaf3f137/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=34d1352f0eb7e7511e34b1e7640e854ffaf3f137", "patch": "@@ -80,7 +80,7 @@ pub use self::Expectation::*;\n pub use self::compare_method::{compare_impl_method, compare_const_impl};\n use self::TupleArgumentsFlag::*;\n \n-use astconv::{AstConv, ast_region_to_region, PathParamMode};\n+use astconv::{AstConv, ast_region_to_region};\n use dep_graph::DepNode;\n use fmt_macros::{Parser, Piece, Position};\n use hir::def::{Def, CtorKind, PathResolution};\n@@ -4006,7 +4006,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let path_res = self.tcx.expect_resolution(node_id);\n         let base_ty_end = path.segments.len() - path_res.depth;\n         let (ty, def) = AstConv::finish_resolving_def_to_ty(self, self, path.span,\n-                                                            PathParamMode::Optional,\n                                                             path_res.base_def,\n                                                             None,\n                                                             node_id,\n@@ -4038,7 +4037,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let ty_segments = path.segments.split_last().unwrap().1;\n             let base_ty_end = path.segments.len() - path_res.depth;\n             let (ty, _def) = AstConv::finish_resolving_def_to_ty(self, self, span,\n-                                                                 PathParamMode::Optional,\n                                                                  path_res.base_def,\n                                                                  opt_self_ty,\n                                                                  node_id,\n@@ -4379,11 +4377,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             _ => bug!(\"unexpected definition: {:?}\", def),\n         }\n \n-        // In `<T as Trait<A, B>>::method`, `A` and `B` are mandatory, but\n-        // `opt_self_ty` can also be Some for `Foo::method`, where Foo's\n-        // type parameters are not mandatory.\n-        let require_type_space = opt_self_ty.is_some() && ufcs_associated.is_none();\n-\n         debug!(\"type_segment={:?} fn_segment={:?}\", type_segment, fn_segment);\n \n         // Now that we have categorized what space the parameters for each\n@@ -4414,8 +4407,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // variables. If the user provided some types, we may still need\n         // to add defaults. If the user provided *too many* types, that's\n         // a problem.\n-        self.check_path_parameter_count(span, !require_type_space, &mut type_segment);\n-        self.check_path_parameter_count(span, true, &mut fn_segment);\n+        self.check_path_parameter_count(span, &mut type_segment);\n+        self.check_path_parameter_count(span, &mut fn_segment);\n \n         let (fn_start, has_self) = match (type_segment, fn_segment) {\n             (_, Some((_, generics))) => {\n@@ -4450,7 +4443,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }, |def, substs| {\n             let mut i = def.index as usize;\n \n-            let can_omit = i >= fn_start || !require_type_space;\n             let segment = if i < fn_start {\n                 // Handle Self first, so we can adjust the index to match the AST.\n                 if has_self && i == 0 {\n@@ -4464,22 +4456,23 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 i -= fn_start;\n                 fn_segment\n             };\n-            let types = match segment.map(|(s, _)| &s.parameters) {\n-                Some(&hir::AngleBracketedParameters(ref data)) => &data.types[..],\n+            let (types, infer_types) = match segment.map(|(s, _)| &s.parameters) {\n+                Some(&hir::AngleBracketedParameters(ref data)) => {\n+                    (&data.types[..], data.infer_types)\n+                }\n                 Some(&hir::ParenthesizedParameters(_)) => bug!(),\n-                None => &[]\n+                None => (&[][..], true)\n             };\n \n             // Skip over the lifetimes in the same segment.\n             if let Some((_, generics)) = segment {\n                 i -= generics.regions.len();\n             }\n \n-            let omitted = can_omit && types.is_empty();\n             if let Some(ast_ty) = types.get(i) {\n                 // A provided type parameter.\n                 self.to_ty(ast_ty)\n-            } else if let (false, Some(default)) = (omitted, def.default) {\n+            } else if let (false, Some(default)) = (infer_types, def.default) {\n                 // No type parameter provided, but a default exists.\n                 default.subst_spanned(self.tcx, substs, Some(span))\n             } else {\n@@ -4539,16 +4532,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// Report errors if the provided parameters are too few or too many.\n     fn check_path_parameter_count(&self,\n                                   span: Span,\n-                                  can_omit: bool,\n                                   segment: &mut Option<(&hir::PathSegment, &ty::Generics)>) {\n-        let (lifetimes, types, bindings) = match segment.map(|(s, _)| &s.parameters) {\n-            Some(&hir::AngleBracketedParameters(ref data)) => {\n-                (&data.lifetimes[..], &data.types[..], &data.bindings[..])\n-            }\n-            Some(&hir::ParenthesizedParameters(_)) => {\n-                span_bug!(span, \"parenthesized parameters cannot appear in ExprPath\");\n+        let (lifetimes, types, infer_types, bindings) = {\n+            match segment.map(|(s, _)| &s.parameters) {\n+                Some(&hir::AngleBracketedParameters(ref data)) => {\n+                    (&data.lifetimes[..], &data.types[..], data.infer_types, &data.bindings[..])\n+                }\n+                Some(&hir::ParenthesizedParameters(_)) => {\n+                    span_bug!(span, \"parenthesized parameters cannot appear in ExprPath\");\n+                }\n+                None => (&[][..], &[][..], true, &[][..])\n             }\n-            None => (&[][..], &[][..], &[][..])\n         };\n \n         let count = |n| {\n@@ -4597,7 +4591,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // type parameters, we force instantiate_value_path to\n             // use inference variables instead of the provided types.\n             *segment = None;\n-        } else if !(can_omit && types.len() == 0) && types.len() < required_len {\n+        } else if !infer_types && types.len() < required_len {\n             let adjust = |len| if len > 1 { \"parameters\" } else { \"parameter\" };\n             let required_param_str = adjust(required_len);\n             let actual_param_str = adjust(types.len());"}]}