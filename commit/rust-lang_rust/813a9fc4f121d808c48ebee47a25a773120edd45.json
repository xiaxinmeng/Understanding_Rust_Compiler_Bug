{"sha": "813a9fc4f121d808c48ebee47a25a773120edd45", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxM2E5ZmM0ZjEyMWQ4MDhjNDhlYmVlNDdhMjVhNzczMTIwZWRkNDU=", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2020-01-22T14:20:27Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2020-05-18T13:39:54Z"}, "message": "Add asm! to AST", "tree": {"sha": "46b792cce2c571e81fd72287616ba1cad6cb0351", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46b792cce2c571e81fd72287616ba1cad6cb0351"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/813a9fc4f121d808c48ebee47a25a773120edd45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/813a9fc4f121d808c48ebee47a25a773120edd45", "html_url": "https://github.com/rust-lang/rust/commit/813a9fc4f121d808c48ebee47a25a773120edd45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/813a9fc4f121d808c48ebee47a25a773120edd45/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "989edf6dd908408723003539583643d11cd5b459", "url": "https://api.github.com/repos/rust-lang/rust/commits/989edf6dd908408723003539583643d11cd5b459", "html_url": "https://github.com/rust-lang/rust/commit/989edf6dd908408723003539583643d11cd5b459"}], "stats": {"total": 215, "additions": 214, "deletions": 1}, "files": [{"sha": "5a9a1116e67f2fda3b4eff54f35146db0e1299c4", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/813a9fc4f121d808c48ebee47a25a773120edd45/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/813a9fc4f121d808c48ebee47a25a773120edd45/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=813a9fc4f121d808c48ebee47a25a773120edd45", "patch": "@@ -3631,6 +3631,7 @@ dependencies = [\n  \"rustc_lexer\",\n  \"rustc_macros\",\n  \"rustc_span\",\n+ \"rustc_target\",\n  \"scoped-tls\",\n  \"serialize\",\n  \"smallvec 1.4.0\",\n@@ -3678,6 +3679,7 @@ dependencies = [\n  \"log\",\n  \"rustc_ast\",\n  \"rustc_span\",\n+ \"rustc_target\",\n ]\n \n [[package]]"}, {"sha": "020e6a84d452a99616e8671dd9a8700d8cd373f2", "filename": "src/librustc_ast/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/813a9fc4f121d808c48ebee47a25a773120edd45/src%2Flibrustc_ast%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/813a9fc4f121d808c48ebee47a25a773120edd45/src%2Flibrustc_ast%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2FCargo.toml?ref=813a9fc4f121d808c48ebee47a25a773120edd45", "patch": "@@ -19,3 +19,4 @@ rustc_index = { path = \"../librustc_index\" }\n rustc_lexer = { path = \"../librustc_lexer\" }\n rustc_macros = { path = \"../librustc_macros\" }\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+rustc_target = { path = \"../librustc_target\" }"}, {"sha": "85e9438472a100a2b958dc7c8e915eefc10bdf23", "filename": "src/librustc_ast/ast.rs", "status": "modified", "additions": 56, "deletions": 1, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/813a9fc4f121d808c48ebee47a25a773120edd45/src%2Flibrustc_ast%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/813a9fc4f121d808c48ebee47a25a773120edd45/src%2Flibrustc_ast%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fast.rs?ref=813a9fc4f121d808c48ebee47a25a773120edd45", "patch": "@@ -34,6 +34,7 @@ use rustc_serialize::{self, Decoder, Encoder};\n use rustc_span::source_map::{respan, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n+use rustc_target::asm::{InlineAsmOptions, InlineAsmTemplatePiece};\n \n use std::convert::TryFrom;\n use std::fmt;\n@@ -1121,7 +1122,7 @@ impl Expr {\n             ExprKind::Break(..) => ExprPrecedence::Break,\n             ExprKind::Continue(..) => ExprPrecedence::Continue,\n             ExprKind::Ret(..) => ExprPrecedence::Ret,\n-            ExprKind::LlvmInlineAsm(..) => ExprPrecedence::InlineAsm,\n+            ExprKind::InlineAsm(..) | ExprKind::LlvmInlineAsm(..) => ExprPrecedence::InlineAsm,\n             ExprKind::MacCall(..) => ExprPrecedence::Mac,\n             ExprKind::Struct(..) => ExprPrecedence::Struct,\n             ExprKind::Repeat(..) => ExprPrecedence::Repeat,\n@@ -1250,6 +1251,8 @@ pub enum ExprKind {\n     /// A `return`, with an optional value to be returned.\n     Ret(Option<P<Expr>>),\n \n+    /// Output of the `asm!()` macro.\n+    InlineAsm(InlineAsm),\n     /// Output of the `llvm_asm!()` macro.\n     LlvmInlineAsm(P<LlvmInlineAsm>),\n \n@@ -1864,6 +1867,58 @@ pub enum TraitObjectSyntax {\n     None,\n }\n \n+/// Inline assembly operand explicit register or register class.\n+///\n+/// E.g., `\"eax\"` as in `asm!(\"mov eax, 2\", out(\"eax\") result)`.\n+#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n+pub enum InlineAsmRegOrRegClass {\n+    Reg(Symbol),\n+    RegClass(Symbol),\n+}\n+\n+/// Inline assembly operand.\n+///\n+/// E.g., `out(\"eax\") result` as in `asm!(\"mov eax, 2\", out(\"eax\") result)`.\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+pub enum InlineAsmOperand {\n+    In {\n+        reg: InlineAsmRegOrRegClass,\n+        expr: P<Expr>,\n+    },\n+    Out {\n+        reg: InlineAsmRegOrRegClass,\n+        late: bool,\n+        expr: Option<P<Expr>>,\n+    },\n+    InOut {\n+        reg: InlineAsmRegOrRegClass,\n+        late: bool,\n+        expr: P<Expr>,\n+    },\n+    SplitInOut {\n+        reg: InlineAsmRegOrRegClass,\n+        late: bool,\n+        in_expr: P<Expr>,\n+        out_expr: Option<P<Expr>>,\n+    },\n+    Const {\n+        expr: P<Expr>,\n+    },\n+    Sym {\n+        expr: P<Expr>,\n+    },\n+}\n+\n+/// Inline assembly.\n+///\n+/// E.g., `asm!(\"NOP\");`.\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+pub struct InlineAsm {\n+    pub template: Vec<InlineAsmTemplatePiece>,\n+    pub operands: Vec<(InlineAsmOperand, Span)>,\n+    pub options: InlineAsmOptions,\n+}\n+\n /// Inline assembly dialect.\n ///\n /// E.g., `\"intel\"` as in `llvm_asm!(\"mov eax, 2\" : \"={eax}\"(result) : : : \"intel\")`."}, {"sha": "2c575c3e288617703c75a8c8232082190eb0a544", "filename": "src/librustc_ast/mut_visit.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/813a9fc4f121d808c48ebee47a25a773120edd45/src%2Flibrustc_ast%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/813a9fc4f121d808c48ebee47a25a773120edd45/src%2Flibrustc_ast%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fmut_visit.rs?ref=813a9fc4f121d808c48ebee47a25a773120edd45", "patch": "@@ -1205,6 +1205,27 @@ pub fn noop_visit_expr<T: MutVisitor>(Expr { kind, id, span, attrs }: &mut Expr,\n         ExprKind::Ret(expr) => {\n             visit_opt(expr, |expr| vis.visit_expr(expr));\n         }\n+        ExprKind::InlineAsm(asm) => {\n+            for (op, _) in &mut asm.operands {\n+                match op {\n+                    InlineAsmOperand::In { expr, .. }\n+                    | InlineAsmOperand::InOut { expr, .. }\n+                    | InlineAsmOperand::Const { expr, .. }\n+                    | InlineAsmOperand::Sym { expr, .. } => vis.visit_expr(expr),\n+                    InlineAsmOperand::Out { expr, .. } => {\n+                        if let Some(expr) = expr {\n+                            vis.visit_expr(expr);\n+                        }\n+                    }\n+                    InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n+                        vis.visit_expr(in_expr);\n+                        if let Some(out_expr) = out_expr {\n+                            vis.visit_expr(out_expr);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n         ExprKind::LlvmInlineAsm(asm) => {\n             let LlvmInlineAsm {\n                 asm: _,"}, {"sha": "41c02734442a42fbd5097b54069bd05b23cc331f", "filename": "src/librustc_ast/visit.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/813a9fc4f121d808c48ebee47a25a773120edd45/src%2Flibrustc_ast%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/813a9fc4f121d808c48ebee47a25a773120edd45/src%2Flibrustc_ast%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fvisit.rs?ref=813a9fc4f121d808c48ebee47a25a773120edd45", "patch": "@@ -818,6 +818,27 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n         }\n         ExprKind::MacCall(ref mac) => visitor.visit_mac(mac),\n         ExprKind::Paren(ref subexpression) => visitor.visit_expr(subexpression),\n+        ExprKind::InlineAsm(ref ia) => {\n+            for (op, _) in &ia.operands {\n+                match op {\n+                    InlineAsmOperand::In { expr, .. }\n+                    | InlineAsmOperand::InOut { expr, .. }\n+                    | InlineAsmOperand::Const { expr, .. }\n+                    | InlineAsmOperand::Sym { expr, .. } => visitor.visit_expr(expr),\n+                    InlineAsmOperand::Out { expr, .. } => {\n+                        if let Some(expr) = expr {\n+                            visitor.visit_expr(expr);\n+                        }\n+                    }\n+                    InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n+                        visitor.visit_expr(in_expr);\n+                        if let Some(out_expr) = out_expr {\n+                            visitor.visit_expr(out_expr);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n         ExprKind::LlvmInlineAsm(ref ia) => {\n             for &(_, ref input) in &ia.inputs {\n                 visitor.visit_expr(input)"}, {"sha": "6c076d2c5b866467ec2ed89cb3898cc79d7c889f", "filename": "src/librustc_ast_pretty/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/813a9fc4f121d808c48ebee47a25a773120edd45/src%2Flibrustc_ast_pretty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/813a9fc4f121d808c48ebee47a25a773120edd45/src%2Flibrustc_ast_pretty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2FCargo.toml?ref=813a9fc4f121d808c48ebee47a25a773120edd45", "patch": "@@ -13,3 +13,4 @@ doctest = false\n log = \"0.4\"\n rustc_span = { path = \"../librustc_span\" }\n rustc_ast = { path = \"../librustc_ast\" }\n+rustc_target = { path = \"../librustc_target\" }"}, {"sha": "1f371f15f18ac566fdf2d2556123aa0227afe92a", "filename": "src/librustc_ast_pretty/pprust.rs", "status": "modified", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/813a9fc4f121d808c48ebee47a25a773120edd45/src%2Flibrustc_ast_pretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/813a9fc4f121d808c48ebee47a25a773120edd45/src%2Flibrustc_ast_pretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2Fpprust.rs?ref=813a9fc4f121d808c48ebee47a25a773120edd45", "patch": "@@ -4,6 +4,7 @@ use crate::pp::{self, Breaks};\n use rustc_ast::ast::{self, BlockCheckMode, PatKind, RangeEnd, RangeSyntax};\n use rustc_ast::ast::{Attribute, GenericArg, MacArgs};\n use rustc_ast::ast::{GenericBound, SelfKind, TraitBoundModifier};\n+use rustc_ast::ast::{InlineAsmOperand, InlineAsmRegOrRegClass};\n use rustc_ast::attr;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, BinOpToken, DelimToken, Nonterminal, Token, TokenKind};\n@@ -14,6 +15,7 @@ use rustc_span::edition::Edition;\n use rustc_span::source_map::{SourceMap, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, IdentPrinter, Symbol};\n use rustc_span::{BytePos, FileName, Span};\n+use rustc_target::asm::{InlineAsmOptions, InlineAsmTemplatePiece};\n \n use std::borrow::Cow;\n \n@@ -2014,6 +2016,116 @@ impl<'a> State<'a> {\n                     self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n                 }\n             }\n+            ast::ExprKind::InlineAsm(ref a) => {\n+                enum AsmArg<'a> {\n+                    Template(String),\n+                    Operand(&'a InlineAsmOperand),\n+                    Options(InlineAsmOptions),\n+                }\n+\n+                let mut args = vec![];\n+                args.push(AsmArg::Template(InlineAsmTemplatePiece::to_string(&a.template)));\n+                args.extend(a.operands.iter().map(|(o, _)| AsmArg::Operand(o)));\n+                if !a.options.is_empty() {\n+                    args.push(AsmArg::Options(a.options));\n+                }\n+\n+                self.word(\"asm!\");\n+                self.popen();\n+                self.commasep(Consistent, &args, |s, arg| match arg {\n+                    AsmArg::Template(template) => s.print_string(&template, ast::StrStyle::Cooked),\n+                    AsmArg::Operand(op) => {\n+                        let print_reg_or_class = |s: &mut Self, r: &InlineAsmRegOrRegClass| match r\n+                        {\n+                            InlineAsmRegOrRegClass::Reg(r) => {\n+                                s.print_string(&r.as_str(), ast::StrStyle::Cooked)\n+                            }\n+                            InlineAsmRegOrRegClass::RegClass(r) => s.word(r.to_string()),\n+                        };\n+                        match op {\n+                            InlineAsmOperand::In { reg, expr } => {\n+                                s.word(\"in\");\n+                                s.popen();\n+                                print_reg_or_class(s, reg);\n+                                s.pclose();\n+                                s.space();\n+                                s.print_expr(expr);\n+                            }\n+                            InlineAsmOperand::Out { reg, late, expr } => {\n+                                s.word(if *late { \"lateout\" } else { \"out\" });\n+                                s.popen();\n+                                print_reg_or_class(s, reg);\n+                                s.pclose();\n+                                s.space();\n+                                match expr {\n+                                    Some(expr) => s.print_expr(expr),\n+                                    None => s.word(\"_\"),\n+                                }\n+                            }\n+                            InlineAsmOperand::InOut { reg, late, expr } => {\n+                                s.word(if *late { \"inlateout\" } else { \"inout\" });\n+                                s.popen();\n+                                print_reg_or_class(s, reg);\n+                                s.pclose();\n+                                s.space();\n+                                s.print_expr(expr);\n+                            }\n+                            InlineAsmOperand::SplitInOut { reg, late, in_expr, out_expr } => {\n+                                s.word(if *late { \"inlateout\" } else { \"inout\" });\n+                                s.popen();\n+                                print_reg_or_class(s, reg);\n+                                s.pclose();\n+                                s.space();\n+                                s.print_expr(in_expr);\n+                                s.space();\n+                                s.word_space(\"=>\");\n+                                match out_expr {\n+                                    Some(out_expr) => s.print_expr(out_expr),\n+                                    None => s.word(\"_\"),\n+                                }\n+                            }\n+                            InlineAsmOperand::Const { expr } => {\n+                                s.word(\"const\");\n+                                s.space();\n+                                s.print_expr(expr);\n+                            }\n+                            InlineAsmOperand::Sym { expr } => {\n+                                s.word(\"sym\");\n+                                s.space();\n+                                s.print_expr(expr);\n+                            }\n+                        }\n+                    }\n+                    AsmArg::Options(opts) => {\n+                        s.word(\"options\");\n+                        s.popen();\n+                        let mut options = vec![];\n+                        if opts.contains(InlineAsmOptions::PURE) {\n+                            options.push(\"pure\");\n+                        }\n+                        if opts.contains(InlineAsmOptions::NOMEM) {\n+                            options.push(\"nomem\");\n+                        }\n+                        if opts.contains(InlineAsmOptions::READONLY) {\n+                            options.push(\"readonly\");\n+                        }\n+                        if opts.contains(InlineAsmOptions::PRESERVES_FLAGS) {\n+                            options.push(\"preserves_flags\");\n+                        }\n+                        if opts.contains(InlineAsmOptions::NORETURN) {\n+                            options.push(\"noreturn\");\n+                        }\n+                        if opts.contains(InlineAsmOptions::NOSTACK) {\n+                            options.push(\"nostack\");\n+                        }\n+                        s.commasep(Inconsistent, &options, |s, &opt| {\n+                            s.word(opt);\n+                        });\n+                        s.pclose();\n+                    }\n+                });\n+                self.pclose();\n+            }\n             ast::ExprKind::LlvmInlineAsm(ref a) => {\n                 self.s.word(\"llvm_asm!\");\n                 self.popen();"}]}