{"sha": "532671b8eee37199ae9e41d377a82a910c6e25b1", "node_id": "C_kwDOAAsO6NoAKDUzMjY3MWI4ZWVlMzcxOTlhZTllNDFkMzc3YTgyYTkxMGM2ZTI1YjE", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2022-05-31T19:53:52Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2022-06-01T17:41:50Z"}, "message": "More accurately handle suggestions\n\n* Confirm the path segment being modified is an `enum`\n* Check whether type has type param before suggesting changing `Self`\n* Wording changes\n* Add clarifying comments\n* Suggest removing args from `Self` if the type doesn't have type params", "tree": {"sha": "e4cfb966f79367bb354b779725ee88e66cad0907", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4cfb966f79367bb354b779725ee88e66cad0907"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/532671b8eee37199ae9e41d377a82a910c6e25b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/532671b8eee37199ae9e41d377a82a910c6e25b1", "html_url": "https://github.com/rust-lang/rust/commit/532671b8eee37199ae9e41d377a82a910c6e25b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/532671b8eee37199ae9e41d377a82a910c6e25b1/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b2d80a197453001f9acd40020c1db6c0178c7fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b2d80a197453001f9acd40020c1db6c0178c7fe", "html_url": "https://github.com/rust-lang/rust/commit/9b2d80a197453001f9acd40020c1db6c0178c7fe"}], "stats": {"total": 160, "additions": 106, "deletions": 54}, "files": [{"sha": "4555e31016f91ee7176dd521062528c3875b65d3", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 80, "deletions": 30, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/532671b8eee37199ae9e41d377a82a910c6e25b1/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/532671b8eee37199ae9e41d377a82a910c6e25b1/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=532671b8eee37199ae9e41d377a82a910c6e25b1", "patch": "@@ -1803,52 +1803,84 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         tcx.check_stability(variant_def.def_id, Some(hir_ref_id), span, None);\n                         self.prohibit_generics(slice::from_ref(assoc_segment).iter(), |err| {\n                             err.note(\"enum variants can't have type parameters\");\n-                            let type_name = tcx.opt_item_name(adt_def.did());\n-                            let the_enum = type_name.map(|n| format!(\"enum `{n}`\")).unwrap_or_else(|| \"the enum\".to_string());\n-                            let msg = format!(\"you might have meant to specity type parameters on {the_enum}\");\n+                            let type_name = tcx.item_name(adt_def.did());\n+                            let msg = format!(\n+                                \"you might have meant to specity type parameters on enum \\\n+                                 `{type_name}`\"\n+                            );\n                             let Some(args) = assoc_segment.args else { return; };\n+                            // Get the span of the generics args *including* the leading `::`.\n                             let args_span = assoc_segment.ident.span.shrink_to_hi().to(args.span_ext);\n+                            if tcx.generics_of(adt_def.did()).count() == 0 {\n+                                // FIXME(estebank): we could also verify that the arguments being\n+                                // work for the `enum`, instead of just looking if it takes *any*.\n+                                err.span_suggestion_verbose(\n+                                    args_span,\n+                                    &format!(\"{type_name} doesn't have type parameters\"),\n+                                    String::new(),\n+                                    Applicability::MachineApplicable,\n+                                );\n+                                return;\n+                            }\n                             let Ok(snippet) = tcx.sess.source_map().span_to_snippet(args_span) else {\n                                 err.note(&msg);\n                                 return;\n                             };\n-                            let (qself_sugg_span, is_self) = if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = qself.kind {\n+                            let (qself_sugg_span, is_self) = if let hir::TyKind::Path(\n+                                hir::QPath::Resolved(_, ref path)\n+                            ) = qself.kind {\n                                 // If the path segment already has type params, we want to overwrite\n                                 // them.\n                                 match &path.segments[..] {\n-                                    [.., segment, _] => (\n-                                        segment.ident.span.shrink_to_hi().to(segment.args.map_or(\n-                                            segment.ident.span.shrink_to_hi(),\n+                                    // `segment` is the previous to last element on the path,\n+                                    // which would normally be the `enum` itself, while the last\n+                                    // `_` `PathSegment` corresponds to the variant.\n+                                    [.., hir::PathSegment {\n+                                        ident,\n+                                        args,\n+                                        res: Some(Res::Def(DefKind::Enum, _)),\n+                                        ..\n+                                    }, _] => (\n+                                        // We need to include the `::` in `Type::Variant::<Args>`\n+                                        // to point the span to `::<Args>`, not just `<Args>`.\n+                                        ident.span.shrink_to_hi().to(args.map_or(\n+                                            ident.span.shrink_to_hi(),\n                                             |a| a.span_ext)),\n                                         false,\n                                     ),\n                                     [segment] => (\n+                                        // We need to include the `::` in `Type::Variant::<Args>`\n+                                        // to point the span to `::<Args>`, not just `<Args>`.\n                                         segment.ident.span.shrink_to_hi().to(segment.args.map_or(\n                                             segment.ident.span.shrink_to_hi(),\n                                             |a| a.span_ext)),\n                                         kw::SelfUpper == segment.ident.name,\n                                     ),\n-                                    _ => unreachable!(),\n+                                    _ => {\n+                                        err.note(&msg);\n+                                        return;\n+                                    }\n                                 }\n                             } else {\n                                 err.note(&msg);\n                                 return;\n                             };\n-                            let Some(type_name) = type_name else {\n-                                err.note(&msg);\n-                                return;\n-                            };\n                             let suggestion = vec![\n                                 if is_self {\n                                     // Account for people writing `Self::Variant::<Args>`, where\n-                                    // `Self` is the enum.\n+                                    // `Self` is the enum, and suggest replacing `Self` with the\n+                                    // appropriate type: `Type::<Args>::Variant`.\n                                     (qself.span, format!(\"{type_name}{snippet}\"))\n                                 } else {\n                                     (qself_sugg_span, snippet)\n                                 },\n                                 (args_span, String::new()),\n                             ];\n-                            err.multipart_suggestion_verbose(&msg, suggestion, Applicability::MaybeIncorrect);\n+                            err.multipart_suggestion_verbose(\n+                                &msg,\n+                                suggestion,\n+                                Applicability::MaybeIncorrect,\n+                            );\n                         });\n                         return Ok((qself_ty, DefKind::Variant, variant_def.def_id));\n                     } else {\n@@ -2369,8 +2401,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // Try to evaluate any array length constants.\n                 let ty = tcx.at(span).type_of(def_id);\n                 let span_of_impl = tcx.span_of_impl(def_id);\n-                // TODO: confirm that `def_id`'s type accepts type params at all before suggesting\n-                // using that instead.\n                 self.prohibit_generics(path.segments.iter(), |err| {\n                     let def_id = match *ty.kind() {\n                         ty::Adt(self_def, _) => self_def.did(),\n@@ -2379,32 +2409,52 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n                     let type_name = tcx.item_name(def_id);\n                     let span_of_ty = tcx.def_ident_span(def_id);\n+                    let generics = tcx.generics_of(def_id).count();\n \n-                    let msg = format!(\"the `Self` type is `{ty}`\");\n+                    let msg = format!(\"`Self` is of type `{ty}`\");\n                     if let (Ok(i_sp), Some(t_sp)) = (span_of_impl, span_of_ty) {\n                         let i_sp = tcx.sess.source_map().guess_head_span(i_sp);\n                         let mut span: MultiSpan = vec![t_sp].into();\n                         span.push_span_label(\n                             i_sp,\n-                            &format!(\"`Self` is `{type_name}` in this `impl`\"),\n+                            &format!(\"`Self` is or type `{type_name}` in this `impl`\"),\n+                        );\n+                        let mut postfix = \"\";\n+                        if generics == 0 {\n+                            postfix = \", which doesn't have type parameters\";\n+                        }\n+                        span.push_span_label(\n+                            t_sp,\n+                            &format!(\"`Self` corresponds to this type{postfix}\"),\n                         );\n-                        span.push_span_label(t_sp, \"`Self` corresponds to this type\");\n                         err.span_note(span, &msg);\n                     } else {\n                         err.note(&msg);\n                     }\n                     for segment in path.segments {\n-                        if let Some(_args) = segment.args && segment.ident.name == kw::SelfUpper {\n-                            err.span_suggestion_verbose(\n-                                segment.ident.span,\n-                                format!(\n-                                    \"the `Self` type doesn't accept type parameters, use the \\\n-                                     concrete type's name `{type_name}` instead if you want to \\\n-                                     specify its type parameters\"\n-                                ),\n-                                type_name.to_string(),\n-                                Applicability::MaybeIncorrect,\n-                            );\n+                        if let Some(args) = segment.args && segment.ident.name == kw::SelfUpper {\n+                            if generics == 0 {\n+                                // FIXME(estebank): we could also verify that the arguments being\n+                                // work for the `enum`, instead of just looking if it takes *any*.\n+                                err.span_suggestion_verbose(\n+                                    segment.ident.span.shrink_to_hi().to(args.span_ext),\n+                                    \"the `Self` type doesn't accept type parameters\",\n+                                    String::new(),\n+                                    Applicability::MachineApplicable,\n+                                );\n+                                return;\n+                            } else {\n+                                err.span_suggestion_verbose(\n+                                    segment.ident.span,\n+                                    format!(\n+                                        \"the `Self` type doesn't accept type parameters, use the \\\n+                                        concrete type's name `{type_name}` instead if you want to \\\n+                                        specify its type parameters\"\n+                                    ),\n+                                    type_name.to_string(),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            }\n                         }\n                     }\n                 });"}, {"sha": "bf9fe72d71842e4f1e4f04b69dddbc42a5c55480", "filename": "src/test/ui/structs/struct-path-self.stderr", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/532671b8eee37199ae9e41d377a82a910c6e25b1/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/532671b8eee37199ae9e41d377a82a910c6e25b1/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.stderr?ref=532671b8eee37199ae9e41d377a82a910c6e25b1", "patch": "@@ -34,37 +34,39 @@ error[E0109]: type arguments are not allowed for this type\n LL |         let z = Self::<u8> {};\n    |                        ^^ type argument not allowed\n    |\n-note: the `Self` type is `S`\n+note: `Self` is of type `S`\n   --> $DIR/struct-path-self.rs:1:8\n    |\n LL | struct S;\n-   |        ^ `Self` corresponds to this type\n+   |        ^ `Self` corresponds to this type, which doesn't have type parameters\n ...\n LL | impl Tr for S {\n-   | ------------- `Self` is `S` in this `impl`\n-help: the `Self` type doesn't accept type parameters, use the concrete type's name `S` instead if you want to specify its type parameters\n+   | ------------- `Self` is or type `S` in this `impl`\n+help: the `Self` type doesn't accept type parameters\n    |\n-LL |         let z = S::<u8> {};\n-   |                 ~\n+LL -         let z = Self::<u8> {};\n+LL +         let z = Self {};\n+   | \n \n error[E0109]: type arguments are not allowed for this type\n   --> $DIR/struct-path-self.rs:30:24\n    |\n LL |         let z = Self::<u8> {};\n    |                        ^^ type argument not allowed\n    |\n-note: the `Self` type is `S`\n+note: `Self` is of type `S`\n   --> $DIR/struct-path-self.rs:1:8\n    |\n LL | struct S;\n-   |        ^ `Self` corresponds to this type\n+   |        ^ `Self` corresponds to this type, which doesn't have type parameters\n ...\n LL | impl S {\n-   | ------ `Self` is `S` in this `impl`\n-help: the `Self` type doesn't accept type parameters, use the concrete type's name `S` instead if you want to specify its type parameters\n+   | ------ `Self` is or type `S` in this `impl`\n+help: the `Self` type doesn't accept type parameters\n    |\n-LL |         let z = S::<u8> {};\n-   |                 ~\n+LL -         let z = Self::<u8> {};\n+LL +         let z = Self {};\n+   | \n \n error: aborting due to 6 previous errors\n "}, {"sha": "98c164ff4180ea13841a1fda8f488f3f5955a37b", "filename": "src/test/ui/type-alias-enum-variants/enum-variant-generic-args.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/532671b8eee37199ae9e41d377a82a910c6e25b1/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fenum-variant-generic-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/532671b8eee37199ae9e41d377a82a910c6e25b1/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fenum-variant-generic-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fenum-variant-generic-args.stderr?ref=532671b8eee37199ae9e41d377a82a910c6e25b1", "patch": "@@ -29,14 +29,14 @@ error[E0109]: type arguments are not allowed for this type\n LL |         Self::<()>::TSVariant(());\n    |                ^^ type argument not allowed\n    |\n-note: the `Self` type is `Enum<T>`\n+note: `Self` is of type `Enum<T>`\n   --> $DIR/enum-variant-generic-args.rs:7:6\n    |\n LL | enum Enum<T> { TSVariant(T), SVariant { v: T }, UVariant }\n    |      ^^^^ `Self` corresponds to this type\n ...\n LL | impl<T> Enum<T> {\n-   | --------------- `Self` is `Enum` in this `impl`\n+   | --------------- `Self` is or type `Enum` in this `impl`\n help: the `Self` type doesn't accept type parameters, use the concrete type's name `Enum` instead if you want to specify its type parameters\n    |\n LL |         Enum::<()>::TSVariant(());\n@@ -67,14 +67,14 @@ error[E0109]: type arguments are not allowed for this type\n LL |         Self::<()>::TSVariant::<()>(());\n    |                ^^ type argument not allowed\n    |\n-note: the `Self` type is `Enum<T>`\n+note: `Self` is of type `Enum<T>`\n   --> $DIR/enum-variant-generic-args.rs:7:6\n    |\n LL | enum Enum<T> { TSVariant(T), SVariant { v: T }, UVariant }\n    |      ^^^^ `Self` corresponds to this type\n ...\n LL | impl<T> Enum<T> {\n-   | --------------- `Self` is `Enum` in this `impl`\n+   | --------------- `Self` is or type `Enum` in this `impl`\n help: the `Self` type doesn't accept type parameters, use the concrete type's name `Enum` instead if you want to specify its type parameters\n    |\n LL |         Enum::<()>::TSVariant::<()>(());\n@@ -129,14 +129,14 @@ error[E0109]: type arguments are not allowed for this type\n LL |         Self::<()>::SVariant { v: () };\n    |                ^^ type argument not allowed\n    |\n-note: the `Self` type is `Enum<T>`\n+note: `Self` is of type `Enum<T>`\n   --> $DIR/enum-variant-generic-args.rs:7:6\n    |\n LL | enum Enum<T> { TSVariant(T), SVariant { v: T }, UVariant }\n    |      ^^^^ `Self` corresponds to this type\n ...\n LL | impl<T> Enum<T> {\n-   | --------------- `Self` is `Enum` in this `impl`\n+   | --------------- `Self` is or type `Enum` in this `impl`\n help: the `Self` type doesn't accept type parameters, use the concrete type's name `Enum` instead if you want to specify its type parameters\n    |\n LL |         Enum::<()>::SVariant { v: () };\n@@ -160,14 +160,14 @@ error[E0109]: type arguments are not allowed for this type\n LL |         Self::<()>::SVariant::<()> { v: () };\n    |                ^^ type argument not allowed\n    |\n-note: the `Self` type is `Enum<T>`\n+note: `Self` is of type `Enum<T>`\n   --> $DIR/enum-variant-generic-args.rs:7:6\n    |\n LL | enum Enum<T> { TSVariant(T), SVariant { v: T }, UVariant }\n    |      ^^^^ `Self` corresponds to this type\n ...\n LL | impl<T> Enum<T> {\n-   | --------------- `Self` is `Enum` in this `impl`\n+   | --------------- `Self` is or type `Enum` in this `impl`\n help: the `Self` type doesn't accept type parameters, use the concrete type's name `Enum` instead if you want to specify its type parameters\n    |\n LL |         Enum::<()>::SVariant::<()> { v: () };\n@@ -210,14 +210,14 @@ error[E0109]: type arguments are not allowed for this type\n LL |         Self::<()>::UVariant;\n    |                ^^ type argument not allowed\n    |\n-note: the `Self` type is `Enum<T>`\n+note: `Self` is of type `Enum<T>`\n   --> $DIR/enum-variant-generic-args.rs:7:6\n    |\n LL | enum Enum<T> { TSVariant(T), SVariant { v: T }, UVariant }\n    |      ^^^^ `Self` corresponds to this type\n ...\n LL | impl<T> Enum<T> {\n-   | --------------- `Self` is `Enum` in this `impl`\n+   | --------------- `Self` is or type `Enum` in this `impl`\n help: the `Self` type doesn't accept type parameters, use the concrete type's name `Enum` instead if you want to specify its type parameters\n    |\n LL |         Enum::<()>::UVariant;\n@@ -229,14 +229,14 @@ error[E0109]: type arguments are not allowed for this type\n LL |         Self::<()>::UVariant::<()>;\n    |                ^^ type argument not allowed\n    |\n-note: the `Self` type is `Enum<T>`\n+note: `Self` is of type `Enum<T>`\n   --> $DIR/enum-variant-generic-args.rs:7:6\n    |\n LL | enum Enum<T> { TSVariant(T), SVariant { v: T }, UVariant }\n    |      ^^^^ `Self` corresponds to this type\n ...\n LL | impl<T> Enum<T> {\n-   | --------------- `Self` is `Enum` in this `impl`\n+   | --------------- `Self` is or type `Enum` in this `impl`\n help: the `Self` type doesn't accept type parameters, use the concrete type's name `Enum` instead if you want to specify its type parameters\n    |\n LL |         Enum::<()>::UVariant::<()>;"}]}