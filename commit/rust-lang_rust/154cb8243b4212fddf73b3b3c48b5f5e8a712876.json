{"sha": "154cb8243b4212fddf73b3b3c48b5f5e8a712876", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1NGNiODI0M2I0MjEyZmRkZjczYjNiM2M0OGI1ZjVlOGE3MTI4NzY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-24T11:34:24Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-24T12:39:34Z"}, "message": "Be more explicit about absolute paths at various places", "tree": {"sha": "f4ec79c17c8a9432b2d2cfc615ce8b7205d76ed7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4ec79c17c8a9432b2d2cfc615ce8b7205d76ed7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/154cb8243b4212fddf73b3b3c48b5f5e8a712876", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/154cb8243b4212fddf73b3b3c48b5f5e8a712876", "html_url": "https://github.com/rust-lang/rust/commit/154cb8243b4212fddf73b3b3c48b5f5e8a712876", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/154cb8243b4212fddf73b3b3c48b5f5e8a712876/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dff62def2ea31e7eb0b010c35d60cd53318eab80", "url": "https://api.github.com/repos/rust-lang/rust/commits/dff62def2ea31e7eb0b010c35d60cd53318eab80", "html_url": "https://github.com/rust-lang/rust/commit/dff62def2ea31e7eb0b010c35d60cd53318eab80"}], "stats": {"total": 220, "additions": 126, "deletions": 94}, "files": [{"sha": "91a9325490e9c7f58067c3cbdcefba536c8c5926", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/154cb8243b4212fddf73b3b3c48b5f5e8a712876/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/154cb8243b4212fddf73b3b3c48b5f5e8a712876/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=154cb8243b4212fddf73b3b3c48b5f5e8a712876", "patch": "@@ -1174,6 +1174,7 @@ dependencies = [\n  \"anyhow\",\n  \"cargo_metadata\",\n  \"log\",\n+ \"paths\",\n  \"ra_arena\",\n  \"ra_cfg\",\n  \"ra_db\","}, {"sha": "1b259682d9fa349ebc68ad37f10d37c3f2167850", "filename": "crates/paths/src/lib.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/154cb8243b4212fddf73b3b3c48b5f5e8a712876/crates%2Fpaths%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154cb8243b4212fddf73b3b3c48b5f5e8a712876/crates%2Fpaths%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fpaths%2Fsrc%2Flib.rs?ref=154cb8243b4212fddf73b3b3c48b5f5e8a712876", "patch": "@@ -28,6 +28,12 @@ impl AsRef<Path> for AbsPathBuf {\n     }\n }\n \n+impl AsRef<AbsPath> for AbsPathBuf {\n+    fn as_ref(&self) -> &AbsPath {\n+        self.as_path()\n+    }\n+}\n+\n impl TryFrom<PathBuf> for AbsPathBuf {\n     type Error = PathBuf;\n     fn try_from(path_buf: PathBuf) -> Result<AbsPathBuf, PathBuf> {\n@@ -45,9 +51,19 @@ impl TryFrom<&str> for AbsPathBuf {\n     }\n }\n \n+impl PartialEq<AbsPath> for AbsPathBuf {\n+    fn eq(&self, other: &AbsPath) -> bool {\n+        self.as_path() == other\n+    }\n+}\n+\n impl AbsPathBuf {\n+    pub fn assert(path: PathBuf) -> AbsPathBuf {\n+        AbsPathBuf::try_from(path)\n+            .unwrap_or_else(|path| panic!(\"expected absolute path, got {}\", path.display()))\n+    }\n     pub fn as_path(&self) -> &AbsPath {\n-        AbsPath::new_unchecked(self.0.as_path())\n+        AbsPath::assert(self.0.as_path())\n     }\n     pub fn pop(&mut self) -> bool {\n         self.0.pop()\n@@ -77,15 +93,19 @@ impl<'a> TryFrom<&'a Path> for &'a AbsPath {\n         if !path.is_absolute() {\n             return Err(path);\n         }\n-        Ok(AbsPath::new_unchecked(path))\n+        Ok(AbsPath::assert(path))\n     }\n }\n \n impl AbsPath {\n-    fn new_unchecked(path: &Path) -> &AbsPath {\n+    pub fn assert(path: &Path) -> &AbsPath {\n+        assert!(path.is_absolute());\n         unsafe { &*(path as *const Path as *const AbsPath) }\n     }\n \n+    pub fn parent(&self) -> Option<&AbsPath> {\n+        self.0.parent().map(AbsPath::assert)\n+    }\n     pub fn join(&self, path: impl AsRef<Path>) -> AbsPathBuf {\n         self.as_ref().join(path).try_into().unwrap()\n     }"}, {"sha": "81894701442116b4a21fe8099d54f122ae423feb", "filename": "crates/ra_project_model/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/154cb8243b4212fddf73b3b3c48b5f5e8a712876/crates%2Fra_project_model%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/154cb8243b4212fddf73b3b3c48b5f5e8a712876/crates%2Fra_project_model%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2FCargo.toml?ref=154cb8243b4212fddf73b3b3c48b5f5e8a712876", "patch": "@@ -18,6 +18,7 @@ ra_cfg = { path = \"../ra_cfg\" }\n ra_db = { path = \"../ra_db\" }\n ra_toolchain = { path = \"../ra_toolchain\" }\n ra_proc_macro =  { path = \"../ra_proc_macro\" }\n+paths =  { path = \"../paths\" }\n \n serde = { version = \"1.0.106\", features = [\"derive\"] }\n serde_json = \"1.0.48\""}, {"sha": "8ce63ab3c16beb1caaa8248672eb8b045dd2fb59", "filename": "crates/ra_project_model/src/cargo_workspace.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/154cb8243b4212fddf73b3b3c48b5f5e8a712876/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154cb8243b4212fddf73b3b3c48b5f5e8a712876/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs?ref=154cb8243b4212fddf73b3b3c48b5f5e8a712876", "patch": "@@ -1,14 +1,10 @@\n //! FIXME: write short doc here\n \n-use std::{\n-    ffi::OsStr,\n-    ops,\n-    path::{Path, PathBuf},\n-    process::Command,\n-};\n+use std::{ffi::OsStr, ops, path::Path, process::Command};\n \n use anyhow::{Context, Result};\n use cargo_metadata::{BuildScript, CargoOpt, Message, MetadataCommand, PackageId};\n+use paths::{AbsPath, AbsPathBuf};\n use ra_arena::{Arena, Idx};\n use ra_db::Edition;\n use rustc_hash::FxHashMap;\n@@ -20,11 +16,14 @@ use rustc_hash::FxHashMap;\n /// `CrateGraph`. `CrateGraph` is lower-level: it knows only about the crates,\n /// while this knows about `Packages` & `Targets`: purely cargo-related\n /// concepts.\n+///\n+/// We use absolute paths here, `cargo metadata` guarantees to always produce\n+/// abs paths.\n #[derive(Debug, Clone)]\n pub struct CargoWorkspace {\n     packages: Arena<PackageData>,\n     targets: Arena<TargetData>,\n-    workspace_root: PathBuf,\n+    workspace_root: AbsPathBuf,\n }\n \n impl ops::Index<Package> for CargoWorkspace {\n@@ -80,15 +79,15 @@ pub type Target = Idx<TargetData>;\n pub struct PackageData {\n     pub version: String,\n     pub name: String,\n-    pub manifest: PathBuf,\n+    pub manifest: AbsPathBuf,\n     pub targets: Vec<Target>,\n     pub is_member: bool,\n     pub dependencies: Vec<PackageDependency>,\n     pub edition: Edition,\n     pub features: Vec<String>,\n     pub cfgs: Vec<String>,\n-    pub out_dir: Option<PathBuf>,\n-    pub proc_macro_dylib_path: Option<PathBuf>,\n+    pub out_dir: Option<AbsPathBuf>,\n+    pub proc_macro_dylib_path: Option<AbsPathBuf>,\n }\n \n #[derive(Debug, Clone)]\n@@ -101,7 +100,7 @@ pub struct PackageDependency {\n pub struct TargetData {\n     pub package: Package,\n     pub name: String,\n-    pub root: PathBuf,\n+    pub root: AbsPathBuf,\n     pub kind: TargetKind,\n     pub is_proc_macro: bool,\n }\n@@ -135,7 +134,7 @@ impl TargetKind {\n }\n \n impl PackageData {\n-    pub fn root(&self) -> &Path {\n+    pub fn root(&self) -> &AbsPath {\n         self.manifest.parent().unwrap()\n     }\n }\n@@ -193,7 +192,7 @@ impl CargoWorkspace {\n             let pkg = packages.alloc(PackageData {\n                 name,\n                 version: version.to_string(),\n-                manifest: manifest_path,\n+                manifest: AbsPathBuf::assert(manifest_path),\n                 targets: Vec::new(),\n                 is_member,\n                 edition,\n@@ -210,7 +209,7 @@ impl CargoWorkspace {\n                 let tgt = targets.alloc(TargetData {\n                     package: pkg,\n                     name: meta_tgt.name,\n-                    root: meta_tgt.src_path.clone(),\n+                    root: AbsPathBuf::assert(meta_tgt.src_path.clone()),\n                     kind: TargetKind::new(meta_tgt.kind.as_slice()),\n                     is_proc_macro,\n                 });\n@@ -246,16 +245,17 @@ impl CargoWorkspace {\n             packages[source].features.extend(node.features);\n         }\n \n-        Ok(CargoWorkspace { packages, targets, workspace_root: meta.workspace_root })\n+        let workspace_root = AbsPathBuf::assert(meta.workspace_root);\n+        Ok(CargoWorkspace { packages, targets, workspace_root: workspace_root })\n     }\n \n     pub fn packages<'a>(&'a self) -> impl Iterator<Item = Package> + ExactSizeIterator + 'a {\n         self.packages.iter().map(|(id, _pkg)| id)\n     }\n \n-    pub fn target_by_root(&self, root: &Path) -> Option<Target> {\n+    pub fn target_by_root(&self, root: &AbsPath) -> Option<Target> {\n         self.packages()\n-            .filter_map(|pkg| self[pkg].targets.iter().find(|&&it| self[it].root == root))\n+            .filter_map(|pkg| self[pkg].targets.iter().find(|&&it| &self[it].root == root))\n             .next()\n             .copied()\n     }\n@@ -279,8 +279,8 @@ impl CargoWorkspace {\n \n #[derive(Debug, Clone, Default)]\n pub struct ExternResources {\n-    out_dirs: FxHashMap<PackageId, PathBuf>,\n-    proc_dylib_paths: FxHashMap<PackageId, PathBuf>,\n+    out_dirs: FxHashMap<PackageId, AbsPathBuf>,\n+    proc_dylib_paths: FxHashMap<PackageId, AbsPathBuf>,\n     cfgs: FxHashMap<PackageId, Vec<String>>,\n }\n \n@@ -308,6 +308,7 @@ pub fn load_extern_resources(\n         if let Ok(message) = message {\n             match message {\n                 Message::BuildScriptExecuted(BuildScript { package_id, out_dir, cfgs, .. }) => {\n+                    let out_dir = AbsPathBuf::assert(out_dir);\n                     res.out_dirs.insert(package_id.clone(), out_dir);\n                     res.cfgs.insert(package_id, cfgs);\n                 }\n@@ -317,7 +318,8 @@ pub fn load_extern_resources(\n                         // Skip rmeta file\n                         if let Some(filename) = message.filenames.iter().find(|name| is_dylib(name))\n                         {\n-                            res.proc_dylib_paths.insert(package_id, filename.clone());\n+                            let filename = AbsPathBuf::assert(filename.clone());\n+                            res.proc_dylib_paths.insert(package_id, filename);\n                         }\n                     }\n                 }"}, {"sha": "ac88532f07c4febfcee95497ed0ffe24e1cc9c33", "filename": "crates/ra_project_model/src/lib.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/154cb8243b4212fddf73b3b3c48b5f5e8a712876/crates%2Fra_project_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154cb8243b4212fddf73b3b3c48b5f5e8a712876/crates%2Fra_project_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Flib.rs?ref=154cb8243b4212fddf73b3b3c48b5f5e8a712876", "patch": "@@ -7,11 +7,12 @@ mod sysroot;\n use std::{\n     fs::{read_dir, File, ReadDir},\n     io::{self, BufReader},\n-    path::{Path, PathBuf},\n+    path::Path,\n     process::{Command, Output},\n };\n \n use anyhow::{bail, Context, Result};\n+use paths::{AbsPath, AbsPathBuf};\n use ra_cfg::CfgOptions;\n use ra_db::{CrateGraph, CrateName, Edition, Env, FileId};\n use rustc_hash::{FxHashMap, FxHashSet};\n@@ -29,7 +30,7 @@ pub enum ProjectWorkspace {\n     /// Project workspace was discovered by running `cargo metadata` and `rustc --print sysroot`.\n     Cargo { cargo: CargoWorkspace, sysroot: Sysroot },\n     /// Project workspace was manually specified using a `rust-project.json` file.\n-    Json { project: JsonProject, project_location: PathBuf },\n+    Json { project: JsonProject, project_location: AbsPathBuf },\n }\n \n /// `PackageRoot` describes a package root folder.\n@@ -38,22 +39,22 @@ pub enum ProjectWorkspace {\n #[derive(Debug, Clone)]\n pub struct PackageRoot {\n     /// Path to the root folder\n-    path: PathBuf,\n+    path: AbsPathBuf,\n     /// Is a member of the current workspace\n     is_member: bool,\n-    out_dir: Option<PathBuf>,\n+    out_dir: Option<AbsPathBuf>,\n }\n impl PackageRoot {\n-    pub fn new_member(path: PathBuf) -> PackageRoot {\n+    pub fn new_member(path: AbsPathBuf) -> PackageRoot {\n         Self { path, is_member: true, out_dir: None }\n     }\n-    pub fn new_non_member(path: PathBuf) -> PackageRoot {\n+    pub fn new_non_member(path: AbsPathBuf) -> PackageRoot {\n         Self { path, is_member: false, out_dir: None }\n     }\n-    pub fn path(&self) -> &Path {\n+    pub fn path(&self) -> &AbsPath {\n         &self.path\n     }\n-    pub fn out_dir(&self) -> Option<&Path> {\n+    pub fn out_dir(&self) -> Option<&AbsPath> {\n         self.out_dir.as_deref()\n     }\n     pub fn is_member(&self) -> bool {\n@@ -63,12 +64,12 @@ impl PackageRoot {\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash, Ord, PartialOrd)]\n pub enum ProjectManifest {\n-    ProjectJson(PathBuf),\n-    CargoToml(PathBuf),\n+    ProjectJson(AbsPathBuf),\n+    CargoToml(AbsPathBuf),\n }\n \n impl ProjectManifest {\n-    pub fn from_manifest_file(path: PathBuf) -> Result<ProjectManifest> {\n+    pub fn from_manifest_file(path: AbsPathBuf) -> Result<ProjectManifest> {\n         if path.ends_with(\"rust-project.json\") {\n             return Ok(ProjectManifest::ProjectJson(path));\n         }\n@@ -78,7 +79,7 @@ impl ProjectManifest {\n         bail!(\"project root must point to Cargo.toml or rust-project.json: {}\", path.display())\n     }\n \n-    pub fn discover_single(path: &Path) -> Result<ProjectManifest> {\n+    pub fn discover_single(path: &AbsPath) -> Result<ProjectManifest> {\n         let mut candidates = ProjectManifest::discover(path)?;\n         let res = match candidates.pop() {\n             None => bail!(\"no projects\"),\n@@ -91,23 +92,23 @@ impl ProjectManifest {\n         Ok(res)\n     }\n \n-    pub fn discover(path: &Path) -> io::Result<Vec<ProjectManifest>> {\n+    pub fn discover(path: &AbsPath) -> io::Result<Vec<ProjectManifest>> {\n         if let Some(project_json) = find_in_parent_dirs(path, \"rust-project.json\") {\n             return Ok(vec![ProjectManifest::ProjectJson(project_json)]);\n         }\n         return find_cargo_toml(path)\n             .map(|paths| paths.into_iter().map(ProjectManifest::CargoToml).collect());\n \n-        fn find_cargo_toml(path: &Path) -> io::Result<Vec<PathBuf>> {\n+        fn find_cargo_toml(path: &AbsPath) -> io::Result<Vec<AbsPathBuf>> {\n             match find_in_parent_dirs(path, \"Cargo.toml\") {\n                 Some(it) => Ok(vec![it]),\n                 None => Ok(find_cargo_toml_in_child_dir(read_dir(path)?)),\n             }\n         }\n \n-        fn find_in_parent_dirs(path: &Path, target_file_name: &str) -> Option<PathBuf> {\n+        fn find_in_parent_dirs(path: &AbsPath, target_file_name: &str) -> Option<AbsPathBuf> {\n             if path.ends_with(target_file_name) {\n-                return Some(path.to_owned());\n+                return Some(path.to_path_buf());\n             }\n \n             let mut curr = Some(path);\n@@ -123,17 +124,18 @@ impl ProjectManifest {\n             None\n         }\n \n-        fn find_cargo_toml_in_child_dir(entities: ReadDir) -> Vec<PathBuf> {\n+        fn find_cargo_toml_in_child_dir(entities: ReadDir) -> Vec<AbsPathBuf> {\n             // Only one level down to avoid cycles the easy way and stop a runaway scan with large projects\n             entities\n                 .filter_map(Result::ok)\n                 .map(|it| it.path().join(\"Cargo.toml\"))\n                 .filter(|it| it.exists())\n+                .map(AbsPathBuf::assert)\n                 .collect()\n         }\n     }\n \n-    pub fn discover_all(paths: &[impl AsRef<Path>]) -> Vec<ProjectManifest> {\n+    pub fn discover_all(paths: &[impl AsRef<AbsPath>]) -> Vec<ProjectManifest> {\n         let mut res = paths\n             .iter()\n             .filter_map(|it| ProjectManifest::discover(it.as_ref()).ok())\n@@ -158,15 +160,12 @@ impl ProjectWorkspace {\n                     format!(\"Failed to open json file {}\", project_json.display())\n                 })?;\n                 let reader = BufReader::new(file);\n-                let project_location = match project_json.parent() {\n-                    Some(parent) => PathBuf::from(parent),\n-                    None => PathBuf::new(),\n-                };\n+                let project_location = project_json.parent().unwrap().to_path_buf();\n                 ProjectWorkspace::Json {\n                     project: from_reader(reader).with_context(|| {\n                         format!(\"Failed to deserialize json file {}\", project_json.display())\n                     })?,\n-                    project_location: project_location,\n+                    project_location,\n                 }\n             }\n             ProjectManifest::CargoToml(cargo_toml) => {\n@@ -218,13 +217,13 @@ impl ProjectWorkspace {\n         }\n     }\n \n-    pub fn proc_macro_dylib_paths(&self) -> Vec<PathBuf> {\n+    pub fn proc_macro_dylib_paths(&self) -> Vec<AbsPathBuf> {\n         match self {\n-            ProjectWorkspace::Json { project, .. } => project\n+            ProjectWorkspace::Json { project, project_location } => project\n                 .crates\n                 .iter()\n                 .filter_map(|krate| krate.proc_macro_dylib_path.as_ref())\n-                .cloned()\n+                .map(|it| project_location.join(it))\n                 .collect(),\n             ProjectWorkspace::Cargo { cargo, sysroot: _sysroot } => cargo\n                 .packages()"}, {"sha": "943ff92df87baef960ffde1a25dddaefca1ce775", "filename": "crates/ra_project_model/src/sysroot.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/154cb8243b4212fddf73b3b3c48b5f5e8a712876/crates%2Fra_project_model%2Fsrc%2Fsysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154cb8243b4212fddf73b3b3c48b5f5e8a712876/crates%2Fra_project_model%2Fsrc%2Fsysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fsysroot.rs?ref=154cb8243b4212fddf73b3b3c48b5f5e8a712876", "patch": "@@ -1,15 +1,12 @@\n //! FIXME: write short doc here\n \n-use std::{\n-    env, ops,\n-    path::{Path, PathBuf},\n-    process::Command,\n-};\n+use std::{convert::TryFrom, env, ops, path::Path, process::Command};\n \n-use anyhow::{bail, Result};\n+use anyhow::{bail, format_err, Result};\n use ra_arena::{Arena, Idx};\n \n use crate::output;\n+use paths::{AbsPath, AbsPathBuf};\n \n #[derive(Default, Debug, Clone)]\n pub struct Sysroot {\n@@ -21,7 +18,7 @@ pub type SysrootCrate = Idx<SysrootCrateData>;\n #[derive(Debug, Clone)]\n pub struct SysrootCrateData {\n     pub name: String,\n-    pub root: PathBuf,\n+    pub root: AbsPathBuf,\n     pub deps: Vec<SysrootCrate>,\n }\n \n@@ -53,7 +50,7 @@ impl Sysroot {\n         self.crates.iter().map(|(id, _data)| id)\n     }\n \n-    pub fn discover(cargo_toml: &Path) -> Result<Sysroot> {\n+    pub fn discover(cargo_toml: &AbsPath) -> Result<Sysroot> {\n         let src = get_or_install_rust_src(cargo_toml)?;\n         let mut sysroot = Sysroot { crates: Arena::default() };\n         for name in SYSROOT_CRATES.trim().lines() {\n@@ -86,16 +83,18 @@ impl Sysroot {\n     }\n }\n \n-fn get_or_install_rust_src(cargo_toml: &Path) -> Result<PathBuf> {\n+fn get_or_install_rust_src(cargo_toml: &AbsPath) -> Result<AbsPathBuf> {\n     if let Ok(path) = env::var(\"RUST_SRC_PATH\") {\n-        return Ok(path.into());\n+        let path = AbsPathBuf::try_from(path.as_str())\n+            .map_err(|path| format_err!(\"RUST_SRC_PATH must be absolute: {}\", path.display()))?;\n+        return Ok(path);\n     }\n     let current_dir = cargo_toml.parent().unwrap();\n     let mut rustc = Command::new(ra_toolchain::rustc());\n     rustc.current_dir(current_dir).args(&[\"--print\", \"sysroot\"]);\n     let rustc_output = output(rustc)?;\n     let stdout = String::from_utf8(rustc_output.stdout)?;\n-    let sysroot_path = Path::new(stdout.trim());\n+    let sysroot_path = AbsPath::assert(Path::new(stdout.trim()));\n     let src_path = sysroot_path.join(\"lib/rustlib/src/rust/src\");\n \n     if !src_path.exists() {\n@@ -116,7 +115,7 @@ fn get_or_install_rust_src(cargo_toml: &Path) -> Result<PathBuf> {\n }\n \n impl SysrootCrateData {\n-    pub fn root_dir(&self) -> &Path {\n+    pub fn root_dir(&self) -> &AbsPath {\n         self.root.parent().unwrap()\n     }\n }"}, {"sha": "45204d1a35aeebc7023cd344964f1ced6d370ae2", "filename": "crates/rust-analyzer/src/bin/main.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/154cb8243b4212fddf73b3b3c48b5f5e8a712876/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154cb8243b4212fddf73b3b3c48b5f5e8a712876/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs?ref=154cb8243b4212fddf73b3b3c48b5f5e8a712876", "patch": "@@ -3,23 +3,30 @@\n //! Based on cli flags, either spawns an LSP server, or runs a batch analysis\n mod args;\n \n+use std::convert::TryFrom;\n+\n use lsp_server::Connection;\n use rust_analyzer::{\n     cli,\n     config::{Config, LinkedProject},\n     from_json, Result,\n };\n \n-use crate::args::HelpPrinted;\n+use ra_db::AbsPathBuf;\n use ra_project_model::ProjectManifest;\n \n+use crate::args::HelpPrinted;\n+\n fn main() -> Result<()> {\n     setup_logging()?;\n     let args = match args::Args::parse()? {\n         Ok(it) => it,\n         Err(HelpPrinted) => return Ok(()),\n     };\n     match args.command {\n+        args::Command::RunServer => run_server()?,\n+        args::Command::ProcMacro => ra_proc_macro_srv::cli::run()?,\n+\n         args::Command::Parse { no_dump } => cli::parse(no_dump)?,\n         args::Command::Symbols => cli::symbols()?,\n         args::Command::Highlight { rainbow } => cli::highlight(rainbow)?,\n@@ -41,7 +48,6 @@ fn main() -> Result<()> {\n             load_output_dirs,\n             with_proc_macro,\n         )?,\n-\n         args::Command::Bench { path, what, load_output_dirs, with_proc_macro } => {\n             cli::analysis_bench(\n                 args.verbosity,\n@@ -51,13 +57,9 @@ fn main() -> Result<()> {\n                 with_proc_macro,\n             )?\n         }\n-\n         args::Command::Diagnostics { path, load_output_dirs, with_proc_macro, all } => {\n             cli::diagnostics(path.as_ref(), load_output_dirs, with_proc_macro, all)?\n         }\n-\n-        args::Command::ProcMacro => run_proc_macro_srv()?,\n-        args::Command::RunServer => run_server()?,\n         args::Command::Version => println!(\"rust-analyzer {}\", env!(\"REV\")),\n     }\n     Ok(())\n@@ -70,11 +72,6 @@ fn setup_logging() -> Result<()> {\n     Ok(())\n }\n \n-fn run_proc_macro_srv() -> Result<()> {\n-    ra_proc_macro_srv::cli::run()?;\n-    Ok(())\n-}\n-\n fn run_server() -> Result<()> {\n     log::info!(\"lifecycle: server started\");\n \n@@ -103,14 +100,23 @@ fn run_server() -> Result<()> {\n     }\n \n     let config = {\n-        let mut config = Config::default();\n+        let root_path = match initialize_params\n+            .root_uri\n+            .and_then(|it| it.to_file_path().ok())\n+            .and_then(|it| AbsPathBuf::try_from(it).ok())\n+        {\n+            Some(it) => it,\n+            None => {\n+                let cwd = std::env::current_dir()?;\n+                AbsPathBuf::assert(cwd)\n+            }\n+        };\n+\n+        let mut config = Config::new(root_path);\n         if let Some(value) = &initialize_params.initialization_options {\n             config.update(value);\n         }\n         config.update_caps(&initialize_params.capabilities);\n-        let cwd = std::env::current_dir()?;\n-        config.root_path =\n-            initialize_params.root_uri.and_then(|it| it.to_file_path().ok()).unwrap_or(cwd);\n \n         if config.linked_projects.is_empty() {\n             let workspace_roots = initialize_params\n@@ -119,6 +125,7 @@ fn run_server() -> Result<()> {\n                     workspaces\n                         .into_iter()\n                         .filter_map(|it| it.uri.to_file_path().ok())\n+                        .filter_map(|it| AbsPathBuf::try_from(it).ok())\n                         .collect::<Vec<_>>()\n                 })\n                 .filter(|workspaces| !workspaces.is_empty())"}, {"sha": "e910db6eb5341f9b60d0a2839de65868287c5ea4", "filename": "crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154cb8243b4212fddf73b3b3c48b5f5e8a712876/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154cb8243b4212fddf73b3b3c48b5f5e8a712876/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=154cb8243b4212fddf73b3b3c48b5f5e8a712876", "patch": "@@ -16,7 +16,7 @@ pub fn load_cargo(\n     load_out_dirs_from_check: bool,\n     with_proc_macro: bool,\n ) -> Result<(AnalysisHost, vfs::Vfs)> {\n-    let root = std::env::current_dir()?.join(root);\n+    let root = AbsPathBuf::assert(std::env::current_dir()?.join(root));\n     let root = ProjectManifest::discover_single(&root)?;\n     let ws = ProjectWorkspace::load(\n         root,"}, {"sha": "0be34c43f063f93c215df36fe1d9000115ec5df8", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/154cb8243b4212fddf73b3b3c48b5f5e8a712876/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154cb8243b4212fddf73b3b3c48b5f5e8a712876/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=154cb8243b4212fddf73b3b3c48b5f5e8a712876", "patch": "@@ -11,6 +11,7 @@ use std::{ffi::OsString, path::PathBuf};\n \n use crate::diagnostics::DiagnosticsConfig;\n use lsp_types::ClientCapabilities;\n+use ra_db::AbsPathBuf;\n use ra_flycheck::FlycheckConfig;\n use ra_ide::{AssistConfig, CompletionConfig, HoverConfig, InlayHintsConfig};\n use ra_project_model::{CargoConfig, JsonProject, ProjectManifest};\n@@ -40,7 +41,7 @@ pub struct Config {\n \n     pub with_sysroot: bool,\n     pub linked_projects: Vec<LinkedProject>,\n-    pub root_path: PathBuf,\n+    pub root_path: AbsPathBuf,\n }\n \n #[derive(Debug, Clone)]\n@@ -131,8 +132,8 @@ pub struct ClientCapsConfig {\n     pub hover_actions: bool,\n }\n \n-impl Default for Config {\n-    fn default() -> Self {\n+impl Config {\n+    pub fn new(root_path: AbsPathBuf) -> Self {\n         Config {\n             client_caps: ClientCapsConfig::default(),\n \n@@ -171,18 +172,16 @@ impl Default for Config {\n             lens: LensConfig::default(),\n             hover: HoverConfig::default(),\n             linked_projects: Vec::new(),\n-            root_path: PathBuf::new(),\n+            root_path,\n         }\n     }\n-}\n \n-impl Config {\n     #[rustfmt::skip]\n     pub fn update(&mut self, value: &serde_json::Value) {\n         log::info!(\"Config::update({:#})\", value);\n \n         let client_caps = self.client_caps.clone();\n-        *self = Default::default();\n+        *self = Config::new(self.root_path.clone());\n         self.client_caps = client_caps;\n \n         set(value, \"/withSysroot\", &mut self.with_sysroot);\n@@ -279,9 +278,12 @@ impl Config {\n                 self.linked_projects.clear();\n                 for linked_project in linked_projects {\n                     let linked_project = match linked_project {\n-                        ManifestOrJsonProject::Manifest(it) => match ProjectManifest::from_manifest_file(it) {\n-                            Ok(it) => it.into(),\n-                            Err(_) => continue,\n+                        ManifestOrJsonProject::Manifest(it) => {\n+                            let path = self.root_path.join(it);\n+                            match ProjectManifest::from_manifest_file(path) {\n+                                Ok(it) => it.into(),\n+                                Err(_) => continue,\n+                            }\n                         }\n                         ManifestOrJsonProject::JsonProject(it) => it.into(),\n                     };"}, {"sha": "f18694feb845aea386d64039c033fe2f4c96d953", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/154cb8243b4212fddf73b3b3c48b5f5e8a712876/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154cb8243b4212fddf73b3b3c48b5f5e8a712876/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=154cb8243b4212fddf73b3b3c48b5f5e8a712876", "patch": "@@ -310,11 +310,10 @@ impl ProjectFolders {\n \n             let mut file_set_roots: Vec<VfsPath> = vec![];\n \n-            let path = AbsPathBuf::try_from(path).unwrap();\n             let entry = if root.is_member() {\n-                vfs::loader::Entry::local_cargo_package(path.clone())\n+                vfs::loader::Entry::local_cargo_package(path.to_path_buf())\n             } else {\n-                vfs::loader::Entry::cargo_package_dependency(path.clone())\n+                vfs::loader::Entry::cargo_package_dependency(path.to_path_buf())\n             };\n             res.load.push(entry);\n             if root.is_member() {\n@@ -329,7 +328,7 @@ impl ProjectFolders {\n                 }\n                 file_set_roots.push(out_dir.into());\n             }\n-            file_set_roots.push(path.into());\n+            file_set_roots.push(path.to_path_buf().into());\n \n             if root.is_member() {\n                 local_filesets.push(fsc.len());"}, {"sha": "49f194f7efb6593c1a4a09302ea79d7ddcaf26ef", "filename": "crates/rust-analyzer/tests/heavy_tests/support.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/154cb8243b4212fddf73b3b3c48b5f5e8a712876/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154cb8243b4212fddf73b3b3c48b5f5e8a712876/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs?ref=154cb8243b4212fddf73b3b3c48b5f5e8a712876", "patch": "@@ -17,6 +17,7 @@ use serde_json::{to_string_pretty, Value};\n use tempfile::TempDir;\n use test_utils::{find_mismatch, Fixture};\n \n+use ra_db::AbsPathBuf;\n use ra_project_model::ProjectManifest;\n use rust_analyzer::{\n     config::{ClientCapsConfig, Config, FilesConfig, FilesWatcher, LinkedProject},\n@@ -70,10 +71,11 @@ impl<'a> Project<'a> {\n             fs::write(path.as_path(), entry.text.as_bytes()).unwrap();\n         }\n \n+        let tmp_dir_path = AbsPathBuf::assert(tmp_dir.path().to_path_buf());\n         let mut roots =\n-            self.roots.into_iter().map(|root| tmp_dir.path().join(root)).collect::<Vec<_>>();\n+            self.roots.into_iter().map(|root| tmp_dir_path.join(root)).collect::<Vec<_>>();\n         if roots.is_empty() {\n-            roots.push(tmp_dir.path().to_path_buf());\n+            roots.push(tmp_dir_path.clone());\n         }\n         let linked_projects = roots\n             .into_iter()\n@@ -91,7 +93,7 @@ impl<'a> Project<'a> {\n             with_sysroot: self.with_sysroot,\n             linked_projects,\n             files: FilesConfig { watcher: FilesWatcher::Client, exclude: Vec::new() },\n-            ..Config::default()\n+            ..Config::new(tmp_dir_path)\n         };\n         if let Some(f) = &self.config {\n             f(&mut config)"}]}