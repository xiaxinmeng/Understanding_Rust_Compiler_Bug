{"sha": "6aadc9d18856f8e7ea8038e2c4b2ba0f9507e26a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhYWRjOWQxODg1NmY4ZTdlYTgwMzhlMmM0YjJiYTBmOTUwN2UyNmE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-13T01:54:53Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-24T22:42:00Z"}, "message": "native: Introduce libnative\n\nThis commit introduces a new crate called \"native\" which will be the crate that\nimplements the 1:1 runtime of rust. This currently entails having an\nimplementation of std::rt::Runtime inside of libnative as well as moving all of\nthe native I/O implementations to libnative.\n\nThe current snag is that the start lang item must currently be defined in\nlibnative in order to start running, but this will change in the future.\n\nCool fact about this crate, there are no extra features that are enabled.\n\nNote that this commit does not include any makefile support necessary for\nbuilding libnative, that's all coming in a later commit.", "tree": {"sha": "563ed3086b2bb3ddd683d0cf5d654763895b1201", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/563ed3086b2bb3ddd683d0cf5d654763895b1201"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6aadc9d18856f8e7ea8038e2c4b2ba0f9507e26a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6aadc9d18856f8e7ea8038e2c4b2ba0f9507e26a", "html_url": "https://github.com/rust-lang/rust/commit/6aadc9d18856f8e7ea8038e2c4b2ba0f9507e26a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6aadc9d18856f8e7ea8038e2c4b2ba0f9507e26a/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49e5493587162d53a693ba7e7833edd8f1718e94", "url": "https://api.github.com/repos/rust-lang/rust/commits/49e5493587162d53a693ba7e7833edd8f1718e94", "html_url": "https://github.com/rust-lang/rust/commit/49e5493587162d53a693ba7e7833edd8f1718e94"}], "stats": {"total": 471, "additions": 386, "deletions": 85}, "files": [{"sha": "eaa4403f7bf09cc582cb64583b0510e0c3c6b366", "filename": "src/libnative/io/file.rs", "status": "renamed", "additions": 25, "deletions": 32, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/6aadc9d18856f8e7ea8038e2c4b2ba0f9507e26a/src%2Flibnative%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aadc9d18856f8e7ea8038e2c4b2ba0f9507e26a/src%2Flibnative%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile.rs?ref=6aadc9d18856f8e7ea8038e2c4b2ba0f9507e26a", "patch": "@@ -10,28 +10,21 @@\n \n //! Blocking posix-based file I/O\n \n-#[allow(non_camel_case_types)];\n-\n-use c_str::CString;\n-use io::IoError;\n-use io;\n-use libc::c_int;\n-use libc;\n-use ops::Drop;\n-use option::{Some, None, Option};\n-use os;\n-use path::{Path, GenericPath};\n-use ptr::RawPtr;\n-use result::{Result, Ok, Err};\n-use rt::rtio;\n+use std::c_str::CString;\n+use std::io::IoError;\n+use std::io;\n+use std::libc::c_int;\n+use std::libc;\n+use std::os;\n+use std::rt::rtio;\n+use std::unstable::intrinsics;\n+use std::vec;\n+\n use super::IoResult;\n-use unstable::intrinsics;\n-use vec::ImmutableVector;\n-use vec;\n \n-#[cfg(windows)] use os::win32::{as_utf16_p, fill_utf16_buf_and_decode};\n-#[cfg(windows)] use ptr;\n-#[cfg(windows)] use str;\n+#[cfg(windows)] use std::os::win32::{as_utf16_p, fill_utf16_buf_and_decode};\n+#[cfg(windows)] use std::ptr;\n+#[cfg(windows)] use std::str;\n \n fn keep_going(data: &[u8], f: |*u8, uint| -> i64) -> i64 {\n     #[cfg(windows)] static eintr: int = 0; // doesn't matter\n@@ -490,8 +483,8 @@ pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n     unsafe {\n         #[cfg(not(windows))]\n         unsafe fn get_list(p: &CString) -> IoResult<~[Path]> {\n-            use libc::{dirent_t};\n-            use libc::{opendir, readdir, closedir};\n+            use std::libc::{dirent_t};\n+            use std::libc::{opendir, readdir, closedir};\n             extern {\n                 fn rust_list_dir_val(ptr: *dirent_t) -> *libc::c_char;\n             }\n@@ -517,14 +510,14 @@ pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n \n         #[cfg(windows)]\n         unsafe fn get_list(p: &CString) -> IoResult<~[Path]> {\n-            use libc::consts::os::extra::INVALID_HANDLE_VALUE;\n-            use libc::{wcslen, free};\n-            use libc::funcs::extra::kernel32::{\n+            use std::libc::consts::os::extra::INVALID_HANDLE_VALUE;\n+            use std::libc::{wcslen, free};\n+            use std::libc::funcs::extra::kernel32::{\n                 FindFirstFileW,\n                 FindNextFileW,\n                 FindClose,\n             };\n-            use libc::types::os::arch::extra::HANDLE;\n+            use std::libc::types::os::arch::extra::HANDLE;\n             use os::win32::{\n                 as_utf16_p\n             };\n@@ -906,12 +899,12 @@ pub fn utime(p: &CString, atime: u64, mtime: u64) -> IoResult<()> {\n \n #[cfg(test)]\n mod tests {\n-    use io::native::file::{CFile, FileDesc};\n-    use io;\n-    use libc;\n-    use os;\n-    use result::Ok;\n-    use rt::rtio::RtioFileStream;\n+    use std::io::native::file::{CFile, FileDesc};\n+    use std::io::fs;\n+    use std::io;\n+    use std::libc;\n+    use std::os;\n+    use std::rt::rtio::RtioFileStream;\n \n     #[ignore(cfg(target_os = \"freebsd\"))] // hmm, maybe pipes have a tiny buffer\n     #[test]", "previous_filename": "src/libstd/io/native/file.rs"}, {"sha": "36e3f8af190c0e6cca31d5970d525fd2f60c4b85", "filename": "src/libnative/io/mod.rs", "status": "renamed", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6aadc9d18856f8e7ea8038e2c4b2ba0f9507e26a/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aadc9d18856f8e7ea8038e2c4b2ba0f9507e26a/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=6aadc9d18856f8e7ea8038e2c4b2ba0f9507e26a", "patch": "@@ -21,24 +21,21 @@\n //! play. The only dependencies of these modules are the normal system libraries\n //! that you would find on the respective platform.\n \n-use c_str::CString;\n-use comm::SharedChan;\n-use libc::c_int;\n-use libc;\n-use option::{Option, None, Some};\n-use os;\n-use path::Path;\n-use result::{Result, Ok, Err};\n-use rt::rtio;\n-use rt::rtio::{RtioTcpStream, RtioTcpListener, RtioUdpSocket, RtioUnixListener,\n-               RtioPipe, RtioFileStream, RtioProcess, RtioSignal, RtioTTY,\n-               CloseBehavior, RtioTimer};\n-use io;\n-use io::IoError;\n-use io::net::ip::SocketAddr;\n-use io::process::ProcessConfig;\n-use io::signal::Signum;\n-use ai = io::net::addrinfo;\n+use std::c_str::CString;\n+use std::comm::SharedChan;\n+use std::libc::c_int;\n+use std::libc;\n+use std::os;\n+use std::rt::rtio;\n+use std::rt::rtio::{RtioTcpStream, RtioTcpListener, RtioUdpSocket,\n+                    RtioUnixListener, RtioPipe, RtioFileStream, RtioProcess,\n+                    RtioSignal, RtioTTY, CloseBehavior, RtioTimer};\n+use std::io;\n+use std::io::IoError;\n+use std::io::net::ip::SocketAddr;\n+use std::io::process::ProcessConfig;\n+use std::io::signal::Signum;\n+use ai = std::io::net::addrinfo;\n \n // Local re-exports\n pub use self::file::FileDesc;\n@@ -114,6 +111,9 @@ fn mkerr_winbool(ret: libc::c_int) -> IoResult<()> {\n pub struct IoFactory;\n \n impl rtio::IoFactory for IoFactory {\n+    // all native io factories are the same\n+    fn id(&self) -> uint { 0 }\n+\n     // networking\n     fn tcp_connect(&mut self, _addr: SocketAddr) -> IoResult<~RtioTcpStream> {\n         Err(unimpl())\n@@ -223,6 +223,3 @@ impl rtio::IoFactory for IoFactory {\n         Err(unimpl())\n     }\n }\n-\n-pub static mut NATIVE_IO_FACTORY: IoFactory = IoFactory;\n-", "previous_filename": "src/libstd/io/native/mod.rs"}, {"sha": "2277d408ee4cb91aa7c2a01f0b642ca71458e4bb", "filename": "src/libnative/io/process.rs", "status": "renamed", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/6aadc9d18856f8e7ea8038e2c4b2ba0f9507e26a/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aadc9d18856f8e7ea8038e2c4b2ba0f9507e26a/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=6aadc9d18856f8e7ea8038e2c4b2ba0f9507e26a", "patch": "@@ -8,18 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use io;\n-use libc::{pid_t, c_void, c_int};\n-use libc;\n-use os;\n-use prelude::*;\n-use ptr;\n-use rt::rtio;\n-use super::file;\n-#[cfg(windows)]\n-use cast;\n+use std::cast;\n+use std::io;\n+use std::libc::{pid_t, c_void, c_int};\n+use std::libc;\n+use std::os;\n+use std::ptr;\n+use std::rt::rtio;\n+use p = std::io::process;\n \n-use p = io::process;\n+use super::file;\n \n /**\n  * A value representing a child process.\n@@ -179,22 +177,22 @@ fn spawn_process_os(prog: &str, args: &[~str],\n                     env: Option<~[(~str, ~str)]>,\n                     dir: Option<&Path>,\n                     in_fd: c_int, out_fd: c_int, err_fd: c_int) -> SpawnProcessResult {\n-    use libc::types::os::arch::extra::{DWORD, HANDLE, STARTUPINFO};\n-    use libc::consts::os::extra::{\n+    use std::libc::types::os::arch::extra::{DWORD, HANDLE, STARTUPINFO};\n+    use std::libc::consts::os::extra::{\n         TRUE, FALSE,\n         STARTF_USESTDHANDLES,\n         INVALID_HANDLE_VALUE,\n         DUPLICATE_SAME_ACCESS\n     };\n-    use libc::funcs::extra::kernel32::{\n+    use std::libc::funcs::extra::kernel32::{\n         GetCurrentProcess,\n         DuplicateHandle,\n         CloseHandle,\n         CreateProcessA\n     };\n-    use libc::funcs::extra::msvcrt::get_osfhandle;\n+    use std::libc::funcs::extra::msvcrt::get_osfhandle;\n \n-    use mem;\n+    use std::mem;\n \n     unsafe {\n \n@@ -256,10 +254,10 @@ fn spawn_process_os(prog: &str, args: &[~str],\n             fail!(\"failure in CreateProcess: {}\", *msg);\n         }\n \n-        // We close the thread handle because we don't care about keeping the\n+        // We close the thread handle because std::we don't care about keeping the\n         // thread id valid, and we aren't keeping the thread handle around to be\n         // able to close it later. We don't close the process handle however\n-        // because we want the process id to stay valid at least until the\n+        // because std::we want the process id to stay valid at least until the\n         // calling code closes the process handle.\n         CloseHandle(pi.hThread);\n \n@@ -362,8 +360,8 @@ fn spawn_process_os(prog: &str, args: &[~str],\n                     env: Option<~[(~str, ~str)]>,\n                     dir: Option<&Path>,\n                     in_fd: c_int, out_fd: c_int, err_fd: c_int) -> SpawnProcessResult {\n-    use libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n-    use libc::funcs::bsd44::getdtablesize;\n+    use std::libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n+    use std::libc::funcs::bsd44::getdtablesize;\n \n     mod rustrt {\n         extern {\n@@ -433,7 +431,7 @@ fn spawn_process_os(prog: &str, args: &[~str],\n \n #[cfg(unix)]\n fn with_argv<T>(prog: &str, args: &[~str], cb: |**libc::c_char| -> T) -> T {\n-    use vec;\n+    use std::vec;\n \n     // We can't directly convert `str`s into `*char`s, as someone needs to hold\n     // a reference to the intermediary byte buffers. So first build an array to\n@@ -459,7 +457,7 @@ fn with_argv<T>(prog: &str, args: &[~str], cb: |**libc::c_char| -> T) -> T {\n \n #[cfg(unix)]\n fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: |*c_void| -> T) -> T {\n-    use vec;\n+    use std::vec;\n \n     // On posixy systems we can pass a char** for envp, which is a\n     // null-terminated array of \"k=v\\n\" strings. Like `with_argv`, we have to\n@@ -540,16 +538,16 @@ fn waitpid(pid: pid_t) -> int {\n \n     #[cfg(windows)]\n     fn waitpid_os(pid: pid_t) -> int {\n-        use libc::types::os::arch::extra::DWORD;\n-        use libc::consts::os::extra::{\n+        use std::libc::types::os::arch::extra::DWORD;\n+        use std::libc::consts::os::extra::{\n             SYNCHRONIZE,\n             PROCESS_QUERY_INFORMATION,\n             FALSE,\n             STILL_ACTIVE,\n             INFINITE,\n             WAIT_FAILED\n         };\n-        use libc::funcs::extra::kernel32::{\n+        use std::libc::funcs::extra::kernel32::{\n             OpenProcess,\n             GetExitCodeProcess,\n             CloseHandle,\n@@ -585,7 +583,7 @@ fn waitpid(pid: pid_t) -> int {\n \n     #[cfg(unix)]\n     fn waitpid_os(pid: pid_t) -> int {\n-        use libc::funcs::posix01::wait::*;\n+        use std::libc::funcs::posix01::wait;\n \n         #[cfg(target_os = \"linux\")]\n         #[cfg(target_os = \"android\")]\n@@ -612,7 +610,7 @@ fn waitpid(pid: pid_t) -> int {\n         }\n \n         let mut status = 0 as c_int;\n-        if unsafe { waitpid(pid, &mut status, 0) } == -1 {\n+        if unsafe { wait::waitpid(pid, &mut status, 0) } == -1 {\n             fail!(\"failure in waitpid: {}\", os::last_os_error());\n         }\n ", "previous_filename": "src/libstd/io/native/process.rs"}, {"sha": "4b32511dc42da5fa6bc52332481b732421f9ee47", "filename": "src/libnative/lib.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/6aadc9d18856f8e7ea8038e2c4b2ba0f9507e26a/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aadc9d18856f8e7ea8038e2c4b2ba0f9507e26a/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=6aadc9d18856f8e7ea8038e2c4b2ba0f9507e26a", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The native runtime crate\n+//!\n+//! This crate contains an implementation of 1:1 scheduling for a \"native\"\n+//! runtime. In addition, all I/O provided by this crate is the thread blocking\n+//! version of I/O.\n+\n+#[link(name = \"native\",\n+       package_id = \"native\",\n+       vers = \"0.9-pre\",\n+       uuid = \"535344a7-890f-5a23-e1f3-e0d118805141\",\n+       url = \"https://github.com/mozilla/rust/tree/master/src/native\")];\n+\n+#[license = \"MIT/ASL2\"];\n+#[crate_type = \"rlib\"];\n+#[crate_type = \"dylib\"];\n+\n+// NB this crate explicitly does *not* allow glob imports, please seriously\n+//    consider whether they're needed before adding that feature here.\n+\n+use std::cast;\n+use std::os;\n+use std::rt;\n+use std::task::try;\n+\n+pub mod io;\n+pub mod task;\n+\n+// XXX: this should not exist here\n+#[cfg(stage0)]\n+#[lang = \"start\"]\n+pub fn start(main: *u8, argc: int, argv: **u8) -> int {\n+    rt::init(argc, argv);\n+\n+    // Bootstrap ourselves by installing a local Task and then immediately\n+    // spawning a thread to run 'main'. Always spawn a new thread for main so\n+    // the stack size of 'main' is known (and the bounds can be set\n+    // appropriately).\n+    //\n+    // Once the main task has completed, then we wait for everyone else to exit.\n+    task::run(task::new(), proc() {\n+        let main: extern \"Rust\" fn() = unsafe { cast::transmute(main) };\n+        match do try { main() } {\n+            Ok(()) => { os::set_exit_status(0); }\n+            Err(..) => { os::set_exit_status(rt::DEFAULT_ERROR_CODE); }\n+        }\n+    });\n+    task::wait_for_completion();\n+\n+    unsafe { rt::cleanup(); }\n+    os::get_exit_status()\n+}"}, {"sha": "fa7500ca85e6908388f6009e9e259fab381685e9", "filename": "src/libnative/task.rs", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/6aadc9d18856f8e7ea8038e2c4b2ba0f9507e26a/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aadc9d18856f8e7ea8038e2c4b2ba0f9507e26a/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=6aadc9d18856f8e7ea8038e2c4b2ba0f9507e26a", "patch": "@@ -0,0 +1,257 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Tasks implemented on top of OS threads\n+//!\n+//! This module contains the implementation of the 1:1 threading module required\n+//! by rust tasks. This implements the necessary API traits laid out by std::rt\n+//! in order to spawn new tasks and deschedule the current task.\n+\n+use std::cast;\n+use std::rt::env;\n+use std::rt::local::Local;\n+use std::rt::rtio;\n+use std::rt::task::{Task, BlockedTask};\n+use std::rt::thread::Thread;\n+use std::rt;\n+use std::sync::atomics::{AtomicUint, SeqCst, INIT_ATOMIC_UINT};\n+use std::task::TaskOpts;\n+use std::unstable::mutex::{Mutex, MUTEX_INIT};\n+use std::unstable::stack;\n+\n+use io;\n+use task;\n+\n+static mut THREAD_CNT: AtomicUint = INIT_ATOMIC_UINT;\n+static mut LOCK: Mutex = MUTEX_INIT;\n+\n+/// Waits for all spawned threads to finish completion. This should only be used\n+/// by the main task in order to wait for all other tasks to terminate.\n+///\n+/// This mirrors the same semantics as the green scheduling model.\n+pub fn wait_for_completion() {\n+    static mut someone_waited: bool = false;\n+\n+    unsafe {\n+        LOCK.lock();\n+        assert!(!someone_waited);\n+        someone_waited = true;\n+        while THREAD_CNT.load(SeqCst) > 0 {\n+            LOCK.wait();\n+        }\n+        LOCK.unlock();\n+        LOCK.destroy();\n+    }\n+\n+}\n+\n+// Signal that a thread has finished execution, possibly waking up a blocker\n+// waiting for all threads to have finished.\n+fn signal_done() {\n+    unsafe {\n+        LOCK.lock();\n+        if THREAD_CNT.fetch_sub(1, SeqCst) == 1 {\n+            LOCK.signal();\n+        }\n+        LOCK.unlock();\n+    }\n+}\n+\n+/// Creates a new Task which is ready to execute as a 1:1 task.\n+pub fn new() -> ~Task {\n+    let mut task = ~Task::new();\n+    task.put_runtime(~Ops {\n+        lock: unsafe { Mutex::new() },\n+    } as ~rt::Runtime);\n+    return task;\n+}\n+\n+/// Spawns a new task given the configuration options and a procedure to run\n+/// inside the task.\n+pub fn spawn(opts: TaskOpts, f: proc()) {\n+    // must happen before the spawn, no need to synchronize with a lock.\n+    unsafe { THREAD_CNT.fetch_add(1, SeqCst); }\n+\n+    let TaskOpts {\n+        watched: _watched,\n+        notify_chan, name, stack_size\n+    } = opts;\n+\n+    let mut task = new();\n+    task.name = name;\n+    match notify_chan {\n+        Some(chan) => {\n+            let on_exit = proc(task_result) { chan.send(task_result) };\n+            task.death.on_exit = Some(on_exit);\n+        }\n+        None => {}\n+    }\n+\n+    let stack = stack_size.unwrap_or(env::min_stack());\n+    let task = task;\n+\n+    // Spawning a new OS thread guarantees that __morestack will never get\n+    // triggered, but we must manually set up the actual stack bounds once this\n+    // function starts executing. This raises the lower limit by a bit because\n+    // by the time that this function is executing we've already consumed at\n+    // least a little bit of stack (we don't know the exact byte address at\n+    // which our stack started).\n+    Thread::spawn_stack(stack, proc() {\n+        let something_around_the_top_of_the_stack = 1;\n+        let addr = &something_around_the_top_of_the_stack as *int;\n+        unsafe {\n+            let my_stack = addr as uint;\n+            stack::record_stack_bounds(my_stack - stack + 1024, my_stack);\n+        }\n+\n+        run(task, f);\n+        signal_done();\n+    })\n+}\n+\n+/// Runs a task once, consuming the task. The given procedure is run inside of\n+/// the task.\n+pub fn run(t: ~Task, f: proc()) {\n+    let mut f = Some(f);\n+    t.run(|| { f.take_unwrap()(); });\n+}\n+\n+// This structure is the glue between channels and the 1:1 scheduling mode. This\n+// structure is allocated once per task.\n+struct Ops {\n+    lock: Mutex, // native synchronization\n+}\n+\n+impl rt::Runtime for Ops {\n+    fn yield_now(~self, mut cur_task: ~Task) {\n+        // put the task back in TLS and then invoke the OS thread yield\n+        cur_task.put_runtime(self as ~rt::Runtime);\n+        Local::put(cur_task);\n+        Thread::yield_now();\n+    }\n+\n+    fn maybe_yield(~self, mut cur_task: ~Task) {\n+        // just put the task back in TLS, on OS threads we never need to\n+        // opportunistically yield b/c the OS will do that for us (preemption)\n+        cur_task.put_runtime(self as ~rt::Runtime);\n+        Local::put(cur_task);\n+    }\n+\n+    fn wrap(~self) -> ~Any {\n+        self as ~Any\n+    }\n+\n+    // This function gets a little interesting. There are a few safety and\n+    // ownership violations going on here, but this is all done in the name of\n+    // shared state. Additionally, all of the violations are protected with a\n+    // mutex, so in theory there are no races.\n+    //\n+    // The first thing we need to do is to get a pointer to the task's internal\n+    // mutex. This address will not be changing (because the task is allocated\n+    // on the heap). We must have this handle separately because the task will\n+    // have its ownership transferred to the given closure. We're guaranteed,\n+    // however, that this memory will remain valid because *this* is the current\n+    // task's execution thread.\n+    //\n+    // The next weird part is where ownership of the task actually goes. We\n+    // relinquish it to the `f` blocking function, but upon returning this\n+    // function needs to replace the task back in TLS. There is no communication\n+    // from the wakeup thread back to this thread about the task pointer, and\n+    // there's really no need to. In order to get around this, we cast the task\n+    // to a `uint` which is then used at the end of this function to cast back\n+    // to a `~Task` object. Naturally, this looks like it violates ownership\n+    // semantics in that there may be two `~Task` objects.\n+    //\n+    // The fun part is that the wakeup half of this implementation knows to\n+    // \"forget\" the task on the other end. This means that the awakening half of\n+    // things silently relinquishes ownership back to this thread, but not in a\n+    // way that the compiler can understand. The task's memory is always valid\n+    // for both tasks because these operations are all done inside of a mutex.\n+    //\n+    // You'll also find that if blocking fails (the `f` function hands the\n+    // BlockedTask back to us), we will `cast::forget` the handles. The\n+    // reasoning for this is the same logic as above in that the task silently\n+    // transfers ownership via the `uint`, not through normal compiler\n+    // semantics.\n+    fn deschedule(mut ~self, times: uint, mut cur_task: ~Task,\n+                  f: |BlockedTask| -> Result<(), BlockedTask>) {\n+        let my_lock: *mut Mutex = &mut self.lock as *mut Mutex;\n+        cur_task.put_runtime(self as ~rt::Runtime);\n+\n+        unsafe {\n+            let cur_task_dupe = *cast::transmute::<&~Task, &uint>(&cur_task);\n+            let task = BlockedTask::block(cur_task);\n+\n+            if times == 1 {\n+                (*my_lock).lock();\n+                match f(task) {\n+                    Ok(()) => (*my_lock).wait(),\n+                    Err(task) => { cast::forget(task.wake()); }\n+                }\n+                (*my_lock).unlock();\n+            } else {\n+                let mut iter = task.make_selectable(times);\n+                (*my_lock).lock();\n+                let success = iter.all(|task| {\n+                    match f(task) {\n+                        Ok(()) => true,\n+                        Err(task) => {\n+                            cast::forget(task.wake());\n+                            false\n+                        }\n+                    }\n+                });\n+                if success {\n+                    (*my_lock).wait();\n+                }\n+                (*my_lock).unlock();\n+            }\n+            // re-acquire ownership of the task\n+            cur_task = cast::transmute::<uint, ~Task>(cur_task_dupe);\n+        }\n+\n+        // put the task back in TLS, and everything is as it once was.\n+        Local::put(cur_task);\n+    }\n+\n+    // See the comments on `deschedule` for why the task is forgotten here, and\n+    // why it's valid to do so.\n+    fn reawaken(mut ~self, mut to_wake: ~Task, _can_resched: bool) {\n+        unsafe {\n+            let lock: *mut Mutex = &mut self.lock as *mut Mutex;\n+            to_wake.put_runtime(self as ~rt::Runtime);\n+            cast::forget(to_wake);\n+            (*lock).lock();\n+            (*lock).signal();\n+            (*lock).unlock();\n+        }\n+    }\n+\n+    fn spawn_sibling(~self, mut cur_task: ~Task, opts: TaskOpts, f: proc()) {\n+        cur_task.put_runtime(self as ~rt::Runtime);\n+        Local::put(cur_task);\n+\n+        task::spawn(opts, f);\n+    }\n+\n+    fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>> {\n+        static mut io: io::IoFactory = io::IoFactory;\n+        // Unsafety is from accessing `io`, which is guaranteed to be safe\n+        // because you can't do anything usable with this statically initialized\n+        // unit struct.\n+        Some(unsafe { rtio::LocalIo::new(&mut io as &mut rtio::IoFactory) })\n+    }\n+}\n+\n+impl Drop for Ops {\n+    fn drop(&mut self) {\n+        unsafe { self.lock.destroy() }\n+    }\n+}"}, {"sha": "0852c4cadb6212adc5ed79a3227e38fb71b63cbf", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6aadc9d18856f8e7ea8038e2c4b2ba0f9507e26a/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aadc9d18856f8e7ea8038e2c4b2ba0f9507e26a/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=6aadc9d18856f8e7ea8038e2c4b2ba0f9507e26a", "patch": "@@ -164,9 +164,6 @@ requests are implemented by descheduling the running task and\n performing an asynchronous request; the task is only resumed once the\n asynchronous request completes.\n \n-For blocking (but possibly more efficient) implementations, look\n-in the `io::native` module.\n-\n # Error Handling\n \n I/O is an area where nearly every operation can result in unexpected\n@@ -349,8 +346,6 @@ pub mod timer;\n /// Buffered I/O wrappers\n pub mod buffered;\n \n-pub mod native;\n-\n /// Signal handling\n pub mod signal;\n "}]}