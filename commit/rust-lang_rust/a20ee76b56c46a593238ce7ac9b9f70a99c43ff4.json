{"sha": "a20ee76b56c46a593238ce7ac9b9f70a99c43ff4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyMGVlNzZiNTZjNDZhNTkzMjM4Y2U3YWM5YjlmNzBhOTljNDNmZjQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-04-20T18:52:31Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-05-02T15:47:09Z"}, "message": "revamp MultiSpan and introduce new snippet code\n\nMultiSpan model is now:\n\n- set of primary spans\n- set of span+label pairs\n\nPrimary spans render with `^^^`, secondary spans with `---`.\n\nLabels are placed next to the `^^^` or `---` marker as appropriate.", "tree": {"sha": "c912cbe4ba262d7f74d5589011848698284fa0ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c912cbe4ba262d7f74d5589011848698284fa0ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a20ee76b56c46a593238ce7ac9b9f70a99c43ff4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a20ee76b56c46a593238ce7ac9b9f70a99c43ff4", "html_url": "https://github.com/rust-lang/rust/commit/a20ee76b56c46a593238ce7ac9b9f70a99c43ff4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a20ee76b56c46a593238ce7ac9b9f70a99c43ff4/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1a575cb077d2070cc4527fa43bf9ef790f89f04", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1a575cb077d2070cc4527fa43bf9ef790f89f04", "html_url": "https://github.com/rust-lang/rust/commit/e1a575cb077d2070cc4527fa43bf9ef790f89f04"}], "stats": {"total": 1563, "additions": 1428, "deletions": 135}, "files": [{"sha": "228af27f4b10a35825c05652519510baedacba3b", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 83, "deletions": 135, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/a20ee76b56c46a593238ce7ac9b9f70a99c43ff4/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a20ee76b56c46a593238ce7ac9b9f70a99c43ff4/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=a20ee76b56c46a593238ce7ac9b9f70a99c43ff4", "patch": "@@ -32,8 +32,6 @@ use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n use ast::Name;\n \n-use errors::emitter::MAX_HIGHLIGHT_LINES;\n-\n // _____________________________________________________________________________\n // Pos, BytePos, CharPos\n //\n@@ -51,7 +49,7 @@ pub struct BytePos(pub u32);\n /// A character offset. Because of multibyte utf8 characters, a byte offset\n /// is not equivalent to a character offset. The CodeMap will convert BytePos\n /// values to CharPos values as necessary.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord, Debug)]\n pub struct CharPos(pub usize);\n \n // FIXME: Lots of boilerplate in these impls, but so far my attempts to fix\n@@ -132,13 +130,29 @@ pub struct Span {\n     pub expn_id: ExpnId\n }\n \n-/// Spans are converted to MultiSpans just before error reporting, either automatically,\n-/// generated by line grouping, or manually constructed.\n-/// In the latter case care should be taken to ensure that spans are ordered, disjoint,\n-/// and point into the same FileMap.\n+/// A collection of spans. Spans have two orthogonal attributes:\n+///\n+/// - they can be *primary spans*. In this case they are the locus of\n+///   the error, and would be rendered with `^^^`.\n+/// - they can have a *label*. In this case, the label is written next\n+///   to the mark in the snippet when we render.\n #[derive(Clone)]\n pub struct MultiSpan {\n-    pub spans: Vec<Span>\n+    primary_spans: Vec<Span>,\n+    span_labels: Vec<(Span, String)>,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct SpanLabel {\n+    /// the span we are going to include in the final snippet\n+    pub span: Span,\n+\n+    /// is this a primary span? This is the \"locus\" of the message,\n+    /// and is indicated with a `^^^^` underline, versus `----`\n+    pub is_primary: bool,\n+\n+    /// what label should we attach to this span (if any)?\n+    pub label: Option<String>,\n }\n \n pub const DUMMY_SP: Span = Span { lo: BytePos(0), hi: BytePos(0), expn_id: NO_EXPANSION };\n@@ -276,97 +290,76 @@ pub fn original_sp(cm: &CodeMap, sp: Span, enclosing_sp: Span) -> Span {\n \n impl MultiSpan {\n     pub fn new() -> MultiSpan {\n-        MultiSpan { spans: Vec::new() }\n+        MultiSpan {\n+            primary_spans: vec![],\n+            span_labels: vec![]\n+        }\n     }\n \n-    pub fn to_span_bounds(&self) -> Span {\n-        assert!(!self.spans.is_empty());\n-        let Span { lo, expn_id, .. } = *self.spans.first().unwrap();\n-        let Span { hi, .. } = *self.spans.last().unwrap();\n-        Span { lo: lo, hi: hi, expn_id: expn_id }\n+    pub fn from_span(primary_span: Span) -> MultiSpan {\n+        MultiSpan {\n+            primary_spans: vec![primary_span],\n+            span_labels: vec![]\n+        }\n     }\n \n-    /// Merges or inserts the given span into itself.\n-    pub fn push_merge(&mut self, mut sp: Span) {\n-        let mut idx_merged = None;\n-\n-        for idx in 0.. {\n-            let cur = match self.spans.get(idx) {\n-                Some(s) => *s,\n-                None => break,\n-            };\n-            // Try to merge with a contained Span\n-            if let Some(union) = cur.merge(sp) {\n-                self.spans[idx] = union;\n-                sp = union;\n-                idx_merged = Some(idx);\n-                break;\n-            }\n-            // Or insert into the first sorted position\n-            if sp.hi <= cur.lo {\n-                self.spans.insert(idx, sp);\n-                idx_merged = Some(idx);\n-                break;\n-            }\n-        }\n-        if let Some(idx) = idx_merged {\n-            // Merge with spans trailing the insertion/merging position\n-            while (idx + 1) < self.spans.len() {\n-                if let Some(union) = self.spans[idx + 1].merge(sp) {\n-                    self.spans[idx] = union;\n-                    self.spans.remove(idx + 1);\n-                } else {\n-                    break;\n-                }\n-            }\n-        } else {\n-            self.spans.push(sp);\n+    pub fn from_spans(vec: Vec<Span>) -> MultiSpan {\n+        MultiSpan {\n+            primary_spans: vec,\n+            span_labels: vec![]\n         }\n     }\n \n-    /// Inserts the given span into itself, for use with `end_highlight_lines`.\n-    pub fn push_trim(&mut self, mut sp: Span) {\n-        let mut prev = mk_sp(BytePos(0), BytePos(0));\n+    pub fn push_primary_span(&mut self, span: Span) {\n+        self.primary_spans.push(span);\n+    }\n \n-        if let Some(first) = self.spans.get_mut(0) {\n-            if first.lo > sp.lo {\n-                // Prevent us here from spanning fewer lines\n-                // because of trimming the start of the span\n-                // (this should not be visible, because this method ought\n-                // to not be used in conjunction with `highlight_lines`)\n-                first.lo = sp.lo;\n-            }\n+    pub fn push_span_label(&mut self, span: Span, label: String) {\n+        self.span_labels.push((span, label));\n+    }\n+\n+    /// Selects the first primary span (if any)\n+    pub fn primary_span(&self) -> Option<Span> {\n+        self.primary_spans.first().cloned()\n+    }\n+\n+    /// Returns all primary spans.\n+    pub fn primary_spans(&self) -> &[Span] {\n+        &self.primary_spans\n+    }\n+\n+    /// Returns the strings to highlight. If we have an explicit set,\n+    /// return those, otherwise just give back an (unlabeled) version\n+    /// of the primary span.\n+    pub fn span_labels(&self) -> Vec<SpanLabel> {\n+        let is_primary = |span| self.primary_spans.contains(&span);\n+        let mut span_labels = vec![];\n+\n+        for &(span, ref label) in &self.span_labels {\n+            span_labels.push(SpanLabel {\n+                span: span,\n+                is_primary: is_primary(span),\n+                label: Some(label.clone())\n+            });\n         }\n \n-        for idx in 0.. {\n-            if let Some(sp_trim) = sp.trim_start(prev) {\n-                // Implies `sp.hi > prev.hi`\n-                let cur = match self.spans.get(idx) {\n-                    Some(s) => *s,\n-                    None => {\n-                        sp = sp_trim;\n-                        break;\n-                    }\n-                };\n-                // `cur` may overlap with `sp_trim`\n-                if let Some(cur_trim) = cur.trim_start(sp_trim) {\n-                    // Implies `sp.hi < cur.hi`\n-                    self.spans.insert(idx, sp_trim);\n-                    self.spans[idx + 1] = cur_trim;\n-                    return;\n-                } else if sp.hi == cur.hi {\n-                    return;\n-                }\n-                prev = cur;\n+        for &span in &self.primary_spans {\n+            if !span_labels.iter().any(|sl| sl.span == span) {\n+                span_labels.push(SpanLabel {\n+                    span: span,\n+                    is_primary: true,\n+                    label: None\n+                });\n             }\n         }\n-        self.spans.push(sp);\n+\n+        span_labels\n     }\n }\n \n impl From<Span> for MultiSpan {\n     fn from(span: Span) -> MultiSpan {\n-        MultiSpan { spans: vec![span] }\n+        MultiSpan::from_span(span)\n     }\n }\n \n@@ -929,6 +922,10 @@ impl CodeMap {\n     }\n \n     pub fn span_to_string(&self, sp: Span) -> String {\n+        if sp == COMMAND_LINE_SP {\n+            return \"<command line option>\".to_string();\n+        }\n+\n         if self.files.borrow().is_empty() && sp.source_equal(&DUMMY_SP) {\n             return \"no-location\".to_string();\n         }\n@@ -1099,12 +1096,16 @@ impl CodeMap {\n     }\n \n     pub fn span_to_lines(&self, sp: Span) -> FileLinesResult {\n+        debug!(\"span_to_lines(sp={:?})\", sp);\n+\n         if sp.lo > sp.hi {\n             return Err(SpanLinesError::IllFormedSpan(sp));\n         }\n \n         let lo = self.lookup_char_pos(sp.lo);\n+        debug!(\"span_to_lines: lo={:?}\", lo);\n         let hi = self.lookup_char_pos(sp.hi);\n+        debug!(\"span_to_lines: hi={:?}\", hi);\n \n         if lo.file.start_pos != hi.file.start_pos {\n             return Err(SpanLinesError::DistinctSources(DistinctSources {\n@@ -1184,59 +1185,6 @@ impl CodeMap {\n         }\n     }\n \n-    /// Groups and sorts spans by lines into `MultiSpan`s, where `push` adds them to their group,\n-    /// specifying the unification behaviour for overlapping spans.\n-    /// Spans overflowing a line are put into their own one-element-group.\n-    pub fn custom_group_spans<F>(&self, mut spans: Vec<Span>, push: F) -> Vec<MultiSpan>\n-        where F: Fn(&mut MultiSpan, Span)\n-    {\n-        spans.sort_by(|a, b| a.lo.cmp(&b.lo));\n-        let mut groups = Vec::<MultiSpan>::new();\n-        let mut overflowing = vec![];\n-        let mut prev_expn = ExpnId(!2u32);\n-        let mut prev_file = !0usize;\n-        let mut prev_line = !0usize;\n-        let mut err_size = 0;\n-\n-        for sp in spans {\n-            let line = self.lookup_char_pos(sp.lo).line;\n-            let line_hi = self.lookup_char_pos(sp.hi).line;\n-            if line != line_hi {\n-                overflowing.push(sp.into());\n-                continue\n-            }\n-            let file = self.lookup_filemap_idx(sp.lo);\n-\n-            if err_size < MAX_HIGHLIGHT_LINES && sp.expn_id == prev_expn && file == prev_file {\n-                // `push` takes care of sorting, trimming, and merging\n-                push(&mut groups.last_mut().unwrap(), sp);\n-                if line != prev_line {\n-                    err_size += 1;\n-                }\n-            } else {\n-                groups.push(sp.into());\n-                err_size = 1;\n-            }\n-            prev_expn = sp.expn_id;\n-            prev_file = file;\n-            prev_line = line;\n-        }\n-        groups.extend(overflowing);\n-        groups\n-    }\n-\n-    /// Groups and sorts spans by lines into `MultiSpan`s, merging overlapping spans.\n-    /// Spans overflowing a line are put into their own one-element-group.\n-    pub fn group_spans(&self, spans: Vec<Span>) -> Vec<MultiSpan> {\n-        self.custom_group_spans(spans, |msp, sp| msp.push_merge(sp))\n-    }\n-\n-    /// Like `group_spans`, but trims overlapping spans instead of\n-    /// merging them (for use with `end_highlight_lines`)\n-    pub fn end_group_spans(&self, spans: Vec<Span>) -> Vec<MultiSpan> {\n-        self.custom_group_spans(spans, |msp, sp| msp.push_trim(sp))\n-    }\n-\n     pub fn get_filemap(&self, filename: &str) -> Rc<FileMap> {\n         for fm in self.files.borrow().iter() {\n             if filename == fm.name {"}, {"sha": "cd8f705ab2e5fa0b00685705f7dd49c90b3557ea", "filename": "src/libsyntax/errors/snippet/mod.rs", "status": "added", "additions": 821, "deletions": 0, "changes": 821, "blob_url": "https://github.com/rust-lang/rust/blob/a20ee76b56c46a593238ce7ac9b9f70a99c43ff4/src%2Flibsyntax%2Ferrors%2Fsnippet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a20ee76b56c46a593238ce7ac9b9f70a99c43ff4/src%2Flibsyntax%2Ferrors%2Fsnippet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Fsnippet%2Fmod.rs?ref=a20ee76b56c46a593238ce7ac9b9f70a99c43ff4", "patch": "@@ -0,0 +1,821 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Code for annotating snippets.\n+\n+use codemap::{CharPos, CodeMap, FileMap, LineInfo, Span};\n+use std::cmp;\n+use std::rc::Rc;\n+use std::mem;\n+use std::ops::Range;\n+\n+#[cfg(test)]\n+mod test;\n+\n+pub struct SnippetData {\n+    codemap: Rc<CodeMap>,\n+    files: Vec<FileInfo>,\n+}\n+\n+pub struct FileInfo {\n+    file: Rc<FileMap>,\n+\n+    /// The \"primary file\", if any, gets a `-->` marker instead of\n+    /// `>>>`, and has a line-number/column printed and not just a\n+    /// filename.  It appears first in the listing. It is known to\n+    /// contain at least one primary span, though primary spans (which\n+    /// are designated with `^^^`) may also occur in other files.\n+    primary_span: Option<Span>,\n+\n+    lines: Vec<Line>,\n+}\n+\n+struct Line {\n+    line_index: usize,\n+    annotations: Vec<Annotation>,\n+}\n+\n+#[derive(Clone, PartialOrd, Ord, PartialEq, Eq)]\n+struct Annotation {\n+    /// Start column, 0-based indexing -- counting *characters*, not\n+    /// utf-8 bytes. Note that it is important that this field goes\n+    /// first, so that when we sort, we sort orderings by start\n+    /// column.\n+    start_col: usize,\n+\n+    /// End column within the line.\n+    end_col: usize,\n+\n+    /// Is this annotation derived from primary span\n+    is_primary: bool,\n+\n+    /// Optional label to display adjacent to the annotation.\n+    label: Option<String>,\n+}\n+\n+#[derive(Debug)]\n+pub struct RenderedLine {\n+    pub text: Vec<StyledString>,\n+    pub kind: RenderedLineKind,\n+}\n+\n+#[derive(Debug)]\n+pub struct StyledString {\n+    pub text: String,\n+    pub style: Style,\n+}\n+\n+#[derive(Debug)]\n+pub struct StyledBuffer {\n+    text: Vec<Vec<char>>,\n+    styles: Vec<Vec<Style>>\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+pub enum Style {\n+    FileNameStyle,\n+    LineAndColumn,\n+    LineNumber,\n+    Quotation,\n+    UnderlinePrimary,\n+    UnderlineSecondary,\n+    LabelPrimary,\n+    LabelSecondary,\n+    NoStyle,\n+}\n+use self::Style::*;\n+\n+#[derive(Debug, Clone)]\n+pub enum RenderedLineKind {\n+    PrimaryFileName,\n+    OtherFileName,\n+    SourceText {\n+        file: Rc<FileMap>,\n+        line_index: usize,\n+    },\n+    Annotations,\n+    Elision,\n+}\n+use self::RenderedLineKind::*;\n+\n+impl SnippetData {\n+    pub fn new(codemap: Rc<CodeMap>,\n+               primary_span: Option<Span>) // (*)\n+               -> Self {\n+        // (*) The primary span indicates the file that must appear\n+        // first, and which will have a line number etc in its\n+        // name. Outside of tests, this is always `Some`, but for many\n+        // tests it's not relevant to test this portion of the logic,\n+        // and it's tedious to pick a primary span (read: tedious to\n+        // port older tests that predate the existence of a primary\n+        // span).\n+\n+        debug!(\"SnippetData::new(primary_span={:?})\", primary_span);\n+\n+        let mut data = SnippetData {\n+            codemap: codemap.clone(),\n+            files: vec![]\n+        };\n+        if let Some(primary_span) = primary_span {\n+            let lo = codemap.lookup_char_pos(primary_span.lo);\n+            data.files.push(\n+                FileInfo {\n+                    file: lo.file,\n+                    primary_span: Some(primary_span),\n+                    lines: vec![],\n+                });\n+        }\n+        data\n+    }\n+\n+    pub fn push(&mut self, span: Span, is_primary: bool, label: Option<String>) {\n+        debug!(\"SnippetData::push(span={:?}, is_primary={}, label={:?})\",\n+               span, is_primary, label);\n+\n+        let file_lines = match self.codemap.span_to_lines(span) {\n+            Ok(file_lines) => file_lines,\n+            Err(_) => {\n+                // ignore unprintable spans completely.\n+                return;\n+            }\n+        };\n+\n+        self.file(&file_lines.file)\n+            .push_lines(&file_lines.lines, is_primary, label);\n+    }\n+\n+    fn file(&mut self, file_map: &Rc<FileMap>) -> &mut FileInfo {\n+        let index = self.files.iter().position(|f| f.file.name == file_map.name);\n+        if let Some(index) = index {\n+            return &mut self.files[index];\n+        }\n+\n+        self.files.push(\n+            FileInfo {\n+                file: file_map.clone(),\n+                lines: vec![],\n+                primary_span: None,\n+            });\n+        self.files.last_mut().unwrap()\n+    }\n+\n+    pub fn render_lines(&self) -> Vec<RenderedLine> {\n+        debug!(\"SnippetData::render_lines()\");\n+\n+        let mut rendered_lines: Vec<_> =\n+            self.files.iter()\n+                      .flat_map(|f| f.render_file_lines(&self.codemap))\n+                      .collect();\n+        prepend_prefixes(&mut rendered_lines);\n+        trim_lines(&mut rendered_lines);\n+        rendered_lines\n+    }\n+}\n+\n+pub trait StringSource {\n+    fn make_string(self) -> String;\n+}\n+\n+impl StringSource for String {\n+    fn make_string(self) -> String {\n+        self\n+    }\n+}\n+\n+impl StringSource for Vec<char> {\n+    fn make_string(self) -> String {\n+        self.into_iter().collect()\n+    }\n+}\n+\n+impl<S> From<(S, Style, RenderedLineKind)> for RenderedLine\n+    where S: StringSource\n+{\n+    fn from((text, style, kind): (S, Style, RenderedLineKind)) -> Self {\n+        RenderedLine {\n+            text: vec![StyledString {\n+                text: text.make_string(),\n+                style: style,\n+            }],\n+            kind: kind,\n+        }\n+    }\n+}\n+\n+impl<S1,S2> From<(S1, Style, S2, Style, RenderedLineKind)> for RenderedLine\n+    where S1: StringSource, S2: StringSource\n+{\n+    fn from(tuple: (S1, Style, S2, Style, RenderedLineKind))\n+            -> Self {\n+        let (text1, style1, text2, style2, kind) = tuple;\n+        RenderedLine {\n+            text: vec![\n+                StyledString {\n+                    text: text1.make_string(),\n+                    style: style1,\n+                },\n+                StyledString {\n+                    text: text2.make_string(),\n+                    style: style2,\n+                }\n+            ],\n+            kind: kind,\n+        }\n+    }\n+}\n+\n+impl RenderedLine {\n+    fn trim_last(&mut self) {\n+        if !self.text.is_empty() {\n+            let last_text = &mut self.text.last_mut().unwrap().text;\n+            let len = last_text.trim_right().len();\n+            last_text.truncate(len);\n+        }\n+    }\n+}\n+\n+impl RenderedLineKind {\n+    fn prefix(&self) -> StyledString {\n+        match *self {\n+            SourceText { file: _, line_index } =>\n+                StyledString {\n+                    text: format!(\"{}\", line_index + 1),\n+                    style: LineNumber,\n+                },\n+            Elision =>\n+                StyledString {\n+                    text: String::from(\"...\"),\n+                    style: LineNumber,\n+                },\n+            PrimaryFileName |\n+            OtherFileName |\n+            Annotations =>\n+                StyledString {\n+                    text: String::from(\"\"),\n+                    style: LineNumber,\n+                },\n+        }\n+    }\n+}\n+\n+impl StyledBuffer {\n+    fn new() -> StyledBuffer {\n+        StyledBuffer { text: vec![], styles: vec![] }\n+    }\n+\n+    fn render(&self, source_kind: RenderedLineKind) -> Vec<RenderedLine> {\n+        let mut output: Vec<RenderedLine> = vec![];\n+        let mut styled_vec: Vec<StyledString> = vec![];\n+\n+        for (row, row_style) in self.text.iter().zip(&self.styles) {\n+            let mut current_style = NoStyle;\n+            let mut current_text = String::new();\n+\n+            for (&c, &s) in row.iter().zip(row_style) {\n+                if s != current_style {\n+                    if !current_text.is_empty() {\n+                        styled_vec.push(StyledString { text: current_text, style: current_style });\n+                    }\n+                    current_style = s;\n+                    current_text = String::new();\n+                }\n+                current_text.push(c);\n+            }\n+            if !current_text.is_empty() {\n+                styled_vec.push(StyledString { text: current_text, style: current_style });\n+            }\n+\n+            if output.is_empty() {\n+                //We know our first output line is source and the rest are highlights and labels\n+                output.push(RenderedLine { text: styled_vec, kind: source_kind.clone() });\n+            } else {\n+                output.push(RenderedLine { text: styled_vec, kind: Annotations });\n+            }\n+            styled_vec = vec![];\n+        }\n+\n+        output\n+    }\n+\n+    fn putc(&mut self, line: usize, col: usize, chr: char, style: Style) {\n+        while line >= self.text.len() {\n+            self.text.push(vec![]);\n+            self.styles.push(vec![]);\n+        }\n+\n+        if col < self.text[line].len() {\n+            self.text[line][col] = chr;\n+            self.styles[line][col] = style;\n+        } else {\n+            while self.text[line].len() < col {\n+                self.text[line].push(' ');\n+                self.styles[line].push(NoStyle);\n+            }\n+            self.text[line].push(chr);\n+            self.styles[line].push(style);\n+        }\n+    }\n+\n+    fn puts(&mut self, line: usize, col: usize, string: &str, style: Style) {\n+        let mut n = col;\n+        for c in string.chars() {\n+            self.putc(line, n, c, style);\n+            n += 1;\n+        }\n+    }\n+\n+    fn set_style(&mut self, line: usize, col: usize, style: Style) {\n+        if self.styles.len() > line && self.styles[line].len() > col {\n+            self.styles[line][col] = style;\n+        }\n+    }\n+\n+    fn append(&mut self, line: usize, string: &str, style: Style) {\n+        if line >= self.text.len() {\n+            self.puts(line, 0, string, style);\n+        } else {\n+            let col = self.text[line].len();\n+            self.puts(line, col, string, style);\n+        }\n+    }\n+}\n+\n+impl FileInfo {\n+    fn push_lines(&mut self,\n+                  lines: &[LineInfo],\n+                  is_primary: bool,\n+                  label: Option<String>) {\n+        assert!(lines.len() > 0);\n+\n+        // If a span covers multiple lines, just put the label on the\n+        // first one. This is a sort of arbitrary choice and not\n+        // obviously correct.\n+        let (line0, remaining_lines) = lines.split_first().unwrap();\n+        let index = self.ensure_source_line(line0.line_index);\n+        self.lines[index].push_annotation(line0.start_col,\n+                                          line0.end_col,\n+                                          is_primary,\n+                                          label);\n+        for line in remaining_lines {\n+            if line.end_col > line.start_col {\n+                let index = self.ensure_source_line(line.line_index);\n+                self.lines[index].push_annotation(line.start_col,\n+                                                  line.end_col,\n+                                                  is_primary,\n+                                                  None);\n+            }\n+        }\n+    }\n+\n+    /// Ensure that we have a `Line` struct corresponding to\n+    /// `line_index` in the file. If we already have some other lines,\n+    /// then this will add the intervening lines to ensure that we\n+    /// have a complete snippet. (Note that when we finally display,\n+    /// some of those lines may be elided.)\n+    fn ensure_source_line(&mut self, line_index: usize) -> usize {\n+        if self.lines.is_empty() {\n+            self.lines.push(Line::new(line_index));\n+            return 0;\n+        }\n+\n+        // Find the range of lines we have thus far.\n+        let first_line_index = self.lines.first().unwrap().line_index;\n+        let last_line_index = self.lines.last().unwrap().line_index;\n+        assert!(first_line_index <= last_line_index);\n+\n+        // If the new line is lower than all the lines we have thus\n+        // far, then insert the new line and any intervening lines at\n+        // the front. In a silly attempt at micro-optimization, we\n+        // don't just call `insert` repeatedly, but instead make a new\n+        // (empty) vector, pushing the new lines onto it, and then\n+        // appending the old vector.\n+        if line_index < first_line_index {\n+            let lines = mem::replace(&mut self.lines, vec![]);\n+            self.lines.extend(\n+                (line_index .. first_line_index)\n+                    .map(|line| Line::new(line))\n+                    .chain(lines));\n+            return 0;\n+        }\n+\n+        // If the new line comes after the ones we have so far, insert\n+        // lines for it.\n+        if line_index > last_line_index {\n+            self.lines.extend(\n+                (last_line_index+1 .. line_index+1)\n+                    .map(|line| Line::new(line)));\n+            return self.lines.len() - 1;\n+        }\n+\n+        // Otherwise it should already exist.\n+        return line_index - first_line_index;\n+    }\n+\n+    fn render_file_lines(&self, codemap: &Rc<CodeMap>) -> Vec<RenderedLine> {\n+        // Group our lines by those with annotations and those without\n+        let mut lines_iter = self.lines.iter().peekable();\n+\n+        let mut line_groups = vec![];\n+\n+        loop {\n+            match lines_iter.next() {\n+                None => break,\n+                Some(line) if line.annotations.is_empty() => {\n+                    // Collect unannotated group\n+                    let mut unannotated_group : Vec<&Line> = vec![];\n+\n+                    unannotated_group.push(line);\n+\n+                    loop {\n+                        let next_line =\n+                            match lines_iter.peek() {\n+                                None => break,\n+                                Some(x) if !x.annotations.is_empty() => break,\n+                                Some(x) => x.clone()\n+                            };\n+\n+                        unannotated_group.push(next_line);\n+                        lines_iter.next();\n+                    }\n+\n+                    line_groups.push((false, unannotated_group));\n+                }\n+                Some(line) => {\n+                    // Collect annotated group\n+                    let mut annotated_group : Vec<&Line> = vec![];\n+\n+                    annotated_group.push(line);\n+\n+                    loop {\n+                        let next_line =\n+                            match lines_iter.peek() {\n+                                None => break,\n+                                Some(x) if x.annotations.is_empty() => break,\n+                                Some(x) => x.clone()\n+                            };\n+\n+                        annotated_group.push(next_line);\n+                        lines_iter.next();\n+                    }\n+\n+                    line_groups.push((true, annotated_group));\n+                }\n+            }\n+        }\n+\n+        let mut output = vec![];\n+\n+        // First insert the name of the file.\n+        match self.primary_span {\n+            Some(span) => {\n+                let lo = codemap.lookup_char_pos(span.lo);\n+                output.push(RenderedLine {\n+                    text: vec![StyledString {\n+                        text: lo.file.name.clone(),\n+                        style: FileNameStyle,\n+                    }, StyledString {\n+                        text: format!(\":{}:{}\", lo.line, lo.col.0 + 1),\n+                        style: LineAndColumn,\n+                    }],\n+                    kind: PrimaryFileName,\n+                });\n+            }\n+            None => {\n+                output.push(RenderedLine {\n+                    text: vec![StyledString {\n+                        text: self.file.name.clone(),\n+                        style: FileNameStyle,\n+                    }],\n+                    kind: OtherFileName,\n+                });\n+            }\n+        }\n+\n+        for &(is_annotated, ref group) in line_groups.iter() {\n+            if is_annotated {\n+                let mut annotation_ends_at_eol = false;\n+                let mut prev_ends_at_eol = false;\n+                let mut elide_unlabeled_region = false;\n+\n+                for group_line in group.iter() {\n+                    let source_string_len =\n+                        self.file.get_line(group_line.line_index)\n+                                 .map(|s| s.len())\n+                                 .unwrap_or(0);\n+\n+                    for annotation in &group_line.annotations {\n+                        if annotation.end_col == source_string_len {\n+                            annotation_ends_at_eol = true;\n+                        }\n+                    }\n+\n+                    let is_single_unlabeled_annotated_line =\n+                        if group_line.annotations.len() == 1 {\n+                            if let Some(annotation) = group_line.annotations.first() {\n+                                match annotation.label {\n+                                    Some(_) => false,\n+                                    None => annotation.start_col == 0 &&\n+                                            annotation.end_col == source_string_len\n+                                }\n+                            } else {\n+                                false\n+                            }\n+                        } else {\n+                            false\n+                        };\n+\n+                    if prev_ends_at_eol && is_single_unlabeled_annotated_line {\n+                        if !elide_unlabeled_region {\n+                            output.push(RenderedLine::from((String::new(),\n+                                NoStyle, Elision)));\n+                            elide_unlabeled_region = true;\n+                            prev_ends_at_eol = true;\n+                        }\n+                        continue;\n+                    }\n+\n+                    let mut v = self.render_line(group_line);\n+                    output.append(&mut v);\n+\n+                    prev_ends_at_eol = annotation_ends_at_eol;\n+                }\n+            } else {\n+                if group.len() > 1 {\n+                    output.push(RenderedLine::from((String::new(), NoStyle, Elision)));\n+                } else {\n+                    let mut v: Vec<RenderedLine> =\n+                        group.iter().flat_map(|line| self.render_line(line)).collect();\n+                    output.append(&mut v);\n+                }\n+            }\n+        }\n+\n+        output\n+    }\n+\n+    fn render_line(&self, line: &Line) -> Vec<RenderedLine> {\n+        let source_string = self.file.get_line(line.line_index)\n+                                     .unwrap_or(\"\");\n+        let source_kind = SourceText {\n+            file: self.file.clone(),\n+            line_index: line.line_index,\n+        };\n+\n+        let mut styled_buffer = StyledBuffer::new();\n+\n+        // First create the source line we will highlight.\n+        styled_buffer.append(0, &source_string, Quotation);\n+\n+        if line.annotations.is_empty() {\n+            return styled_buffer.render(source_kind);\n+        }\n+\n+        // We want to display like this:\n+        //\n+        //      vec.push(vec.pop().unwrap());\n+        //      ---      ^^^               _ previous borrow ends here\n+        //      |        |\n+        //      |        error occurs here\n+        //      previous borrow of `vec` occurs here\n+        //\n+        // But there are some weird edge cases to be aware of:\n+        //\n+        //      vec.push(vec.pop().unwrap());\n+        //      --------                    - previous borrow ends here\n+        //      ||\n+        //      |this makes no sense\n+        //      previous borrow of `vec` occurs here\n+        //\n+        // For this reason, we group the lines into \"highlight lines\"\n+        // and \"annotations lines\", where the highlight lines have the `~`.\n+\n+        //let mut highlight_line = Self::whitespace(&source_string);\n+\n+        // Sort the annotations by (start, end col)\n+        let mut annotations = line.annotations.clone();\n+        annotations.sort();\n+\n+        // Next, create the highlight line.\n+        for annotation in &annotations {\n+            for p in annotation.start_col .. annotation.end_col {\n+                if annotation.is_primary {\n+                    styled_buffer.putc(1, p, '^', UnderlinePrimary);\n+                    styled_buffer.set_style(0, p, UnderlinePrimary);\n+                } else {\n+                    styled_buffer.putc(1, p, '-', UnderlineSecondary);\n+                }\n+            }\n+        }\n+\n+        // Now we are going to write labels in. To start, we'll exclude\n+        // the annotations with no labels.\n+        let (labeled_annotations, unlabeled_annotations): (Vec<_>, _) =\n+            annotations.into_iter()\n+                       .partition(|a| a.label.is_some());\n+\n+        // If there are no annotations that need text, we're done.\n+        if labeled_annotations.is_empty() {\n+            return styled_buffer.render(source_kind);\n+        }\n+\n+        // Now add the text labels. We try, when possible, to stick the rightmost\n+        // annotation at the end of the highlight line:\n+        //\n+        //      vec.push(vec.pop().unwrap());\n+        //      ---      ---               - previous borrow ends here\n+        //\n+        // But sometimes that's not possible because one of the other\n+        // annotations overlaps it. For example, from the test\n+        // `span_overlap_label`, we have the following annotations\n+        // (written on distinct lines for clarity):\n+        //\n+        //      fn foo(x: u32) {\n+        //      --------------\n+        //             -\n+        //\n+        // In this case, we can't stick the rightmost-most label on\n+        // the highlight line, or we would get:\n+        //\n+        //      fn foo(x: u32) {\n+        //      -------- x_span\n+        //      |\n+        //      fn_span\n+        //\n+        // which is totally weird. Instead we want:\n+        //\n+        //      fn foo(x: u32) {\n+        //      --------------\n+        //      |      |\n+        //      |      x_span\n+        //      fn_span\n+        //\n+        // which is...less weird, at least. In fact, in general, if\n+        // the rightmost span overlaps with any other span, we should\n+        // use the \"hang below\" version, so we can at least make it\n+        // clear where the span *starts*.\n+        let mut labeled_annotations = &labeled_annotations[..];\n+        match labeled_annotations.split_last().unwrap() {\n+            (last, previous) => {\n+                if previous.iter()\n+                           .chain(&unlabeled_annotations)\n+                           .all(|a| !overlaps(a, last))\n+                {\n+                    // append the label afterwards; we keep it in a separate\n+                    // string\n+                    let highlight_label: String = format!(\" {}\", last.label.as_ref().unwrap());\n+                    if last.is_primary {\n+                        styled_buffer.append(1, &highlight_label, LabelPrimary);\n+                    } else {\n+                        styled_buffer.append(1, &highlight_label, LabelSecondary);\n+                    }\n+                    labeled_annotations = previous;\n+                }\n+            }\n+        }\n+\n+        // If that's the last annotation, we're done\n+        if labeled_annotations.is_empty() {\n+            return styled_buffer.render(source_kind);\n+        }\n+\n+        for (index, annotation) in labeled_annotations.iter().enumerate() {\n+            // Leave:\n+            // - 1 extra line\n+            // - One line for each thing that comes after\n+            let comes_after = labeled_annotations.len() - index - 1;\n+            let blank_lines = 3 + comes_after;\n+\n+            // For each blank line, draw a `|` at our column. The\n+            // text ought to be long enough for this.\n+            for index in 2..blank_lines {\n+                if annotation.is_primary {\n+                    styled_buffer.putc(index, annotation.start_col, '|', UnderlinePrimary);\n+                } else {\n+                    styled_buffer.putc(index, annotation.start_col, '|', UnderlineSecondary);\n+                }\n+            }\n+\n+            if annotation.is_primary {\n+                styled_buffer.puts(blank_lines, annotation.start_col,\n+                    annotation.label.as_ref().unwrap(), LabelPrimary);\n+            } else {\n+                styled_buffer.puts(blank_lines, annotation.start_col,\n+                    annotation.label.as_ref().unwrap(), LabelSecondary);\n+            }\n+        }\n+\n+        styled_buffer.render(source_kind)\n+    }\n+}\n+\n+fn prepend_prefixes(rendered_lines: &mut [RenderedLine]) {\n+    let prefixes: Vec<_> =\n+        rendered_lines.iter()\n+                      .map(|rl| rl.kind.prefix())\n+                      .collect();\n+\n+    // find the max amount of spacing we need; add 1 to\n+    // p.text.len() to leave space between the prefix and the\n+    // source text\n+    let padding_len =\n+        prefixes.iter()\n+                .map(|p| if p.text.len() == 0 { 0 } else { p.text.len() + 1 })\n+                .max()\n+                .unwrap_or(0);\n+\n+    // Ensure we insert at least one character of padding, so that the\n+    // `-->` arrows can fit etc.\n+    let padding_len = cmp::max(padding_len, 1);\n+\n+    for (mut prefix, line) in prefixes.into_iter().zip(rendered_lines) {\n+        let extra_spaces = (prefix.text.len() .. padding_len).map(|_| ' ');\n+        prefix.text.extend(extra_spaces);\n+        match line.kind {\n+            RenderedLineKind::Elision => {\n+                line.text.insert(0, prefix);\n+            }\n+            RenderedLineKind::PrimaryFileName => {\n+                //   --> filename\n+                // 22 |>\n+                //   ^\n+                //   padding_len\n+                let dashes = (0..padding_len - 1).map(|_| ' ')\n+                                                 .chain(Some('-'))\n+                                                 .chain(Some('-'))\n+                                                 .chain(Some('>'))\n+                                                 .chain(Some(' '));\n+                line.text.insert(0, StyledString {text: dashes.collect(),\n+                                                  style: LineNumber})\n+            }\n+            RenderedLineKind::OtherFileName => {\n+                // >>>>> filename\n+                // 22 |>\n+                //   ^\n+                //   padding_len\n+                let dashes = (0..padding_len + 2).map(|_| '>')\n+                                                 .chain(Some(' '));\n+                line.text.insert(0, StyledString {text: dashes.collect(),\n+                                                  style: LineNumber})\n+            }\n+            _ => {\n+                line.text.insert(0, prefix);\n+                line.text.insert(1, StyledString {text: String::from(\"|> \"),\n+                                                  style: LineNumber})\n+            }\n+        }\n+    }\n+}\n+\n+fn trim_lines(rendered_lines: &mut [RenderedLine]) {\n+    for line in rendered_lines {\n+        while !line.text.is_empty() {\n+            line.trim_last();\n+            if line.text.last().unwrap().text.is_empty() {\n+                line.text.pop();\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+}\n+\n+impl Line {\n+    fn new(line_index: usize) -> Line {\n+        Line {\n+            line_index: line_index,\n+            annotations: vec![]\n+        }\n+    }\n+\n+    fn push_annotation(&mut self,\n+                       start: CharPos,\n+                       end: CharPos,\n+                       is_primary: bool,\n+                       label: Option<String>) {\n+        self.annotations.push(Annotation {\n+            start_col: start.0,\n+            end_col: end.0,\n+            is_primary: is_primary,\n+            label: label,\n+        });\n+    }\n+}\n+\n+fn overlaps(a1: &Annotation,\n+            a2: &Annotation)\n+            -> bool\n+{\n+    between(a1.start_col, a2.start_col .. a2.end_col) ||\n+        between(a2.start_col, a1.start_col .. a1.end_col)\n+}\n+\n+fn between(v: usize, range: Range<usize>) -> bool {\n+    v >= range.start && v < range.end\n+}"}, {"sha": "44ece285b1b238617a538b648be4ae0a5a600fed", "filename": "src/libsyntax/errors/snippet/test.rs", "status": "added", "additions": 524, "deletions": 0, "changes": 524, "blob_url": "https://github.com/rust-lang/rust/blob/a20ee76b56c46a593238ce7ac9b9f70a99c43ff4/src%2Flibsyntax%2Ferrors%2Fsnippet%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a20ee76b56c46a593238ce7ac9b9f70a99c43ff4/src%2Flibsyntax%2Ferrors%2Fsnippet%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Fsnippet%2Ftest.rs?ref=a20ee76b56c46a593238ce7ac9b9f70a99c43ff4", "patch": "@@ -0,0 +1,524 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Code for testing annotated snippets.\n+\n+use codemap::{BytePos, CodeMap, FileMap, NO_EXPANSION, Span};\n+use std::rc::Rc;\n+use super::{RenderedLine, SnippetData};\n+\n+/// Returns the span corresponding to the `n`th occurrence of\n+/// `substring` in `source_text`.\n+trait CodeMapExtension {\n+    fn span_substr(&self,\n+                   file: &Rc<FileMap>,\n+                   source_text: &str,\n+                   substring: &str,\n+                   n: usize)\n+                   -> Span;\n+}\n+\n+impl CodeMapExtension for CodeMap {\n+    fn span_substr(&self,\n+                   file: &Rc<FileMap>,\n+                   source_text: &str,\n+                   substring: &str,\n+                   n: usize)\n+                   -> Span\n+    {\n+        println!(\"span_substr(file={:?}/{:?}, substring={:?}, n={})\",\n+                 file.name, file.start_pos, substring, n);\n+        let mut i = 0;\n+        let mut hi = 0;\n+        loop {\n+            let offset = source_text[hi..].find(substring).unwrap_or_else(|| {\n+                panic!(\"source_text `{}` does not have {} occurrences of `{}`, only {}\",\n+                       source_text, n, substring, i);\n+            });\n+            let lo = hi + offset;\n+            hi = lo + substring.len();\n+            if i == n {\n+                let span = Span {\n+                    lo: BytePos(lo as u32 + file.start_pos.0),\n+                    hi: BytePos(hi as u32 + file.start_pos.0),\n+                    expn_id: NO_EXPANSION,\n+                };\n+                assert_eq!(&self.span_to_snippet(span).unwrap()[..],\n+                           substring);\n+                return span;\n+            }\n+            i += 1;\n+        }\n+    }\n+}\n+\n+fn splice(start: Span, end: Span) -> Span {\n+    Span {\n+        lo: start.lo,\n+        hi: end.hi,\n+        expn_id: NO_EXPANSION,\n+    }\n+}\n+\n+fn make_string(lines: &[RenderedLine]) -> String {\n+    lines.iter()\n+         .flat_map(|rl| {\n+             rl.text.iter()\n+                    .map(|s| &s.text[..])\n+                    .chain(Some(\"\\n\"))\n+         })\n+         .collect()\n+}\n+\n+#[test]\n+fn one_line() {\n+    let file_text = r#\"\n+fn foo() {\n+    vec.push(vec.pop().unwrap());\n+}\n+\"#;\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", file_text);\n+    let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 0);\n+    let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 1);\n+    let span_semi = cm.span_substr(&foo, file_text, \";\", 0);\n+\n+    let mut snippet = SnippetData::new(cm, None);\n+    snippet.push(span_vec0, false, Some(format!(\"previous borrow of `vec` occurs here\")));\n+    snippet.push(span_vec1, false, Some(format!(\"error occurs here\")));\n+    snippet.push(span_semi, false, Some(format!(\"previous borrow ends here\")));\n+\n+    let lines = snippet.render_lines();\n+    println!(\"{:#?}\", lines);\n+\n+    let text: String = make_string(&lines);\n+\n+    println!(\"text=\\n{}\", text);\n+    assert_eq!(&text[..], &r#\"\n+>>>> foo.rs\n+3 |>     vec.push(vec.pop().unwrap());\n+  |>     ---      ---                - previous borrow ends here\n+  |>     |        |\n+  |>     |        error occurs here\n+  |>     previous borrow of `vec` occurs here\n+\"#[1..]);\n+}\n+\n+#[test]\n+fn two_files() {\n+    let file_text_foo = r#\"\n+fn foo() {\n+    vec.push(vec.pop().unwrap());\n+}\n+\"#;\n+\n+    let file_text_bar = r#\"\n+fn bar() {\n+    // these blank links here\n+    // serve to ensure that the line numbers\n+    // from bar.rs\n+    // require more digits\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    vec.push();\n+\n+    // this line will get elided\n+\n+    vec.pop().unwrap());\n+}\n+\"#;\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo_map = cm.new_filemap_and_lines(\"foo.rs\", file_text_foo);\n+    let span_foo_vec0 = cm.span_substr(&foo_map, file_text_foo, \"vec\", 0);\n+    let span_foo_vec1 = cm.span_substr(&foo_map, file_text_foo, \"vec\", 1);\n+    let span_foo_semi = cm.span_substr(&foo_map, file_text_foo, \";\", 0);\n+\n+    let bar_map = cm.new_filemap_and_lines(\"bar.rs\", file_text_bar);\n+    let span_bar_vec0 = cm.span_substr(&bar_map, file_text_bar, \"vec\", 0);\n+    let span_bar_vec1 = cm.span_substr(&bar_map, file_text_bar, \"vec\", 1);\n+    let span_bar_semi = cm.span_substr(&bar_map, file_text_bar, \";\", 0);\n+\n+    let mut snippet = SnippetData::new(cm, Some(span_foo_vec1));\n+    snippet.push(span_foo_vec0, false, Some(format!(\"a\")));\n+    snippet.push(span_foo_vec1, true, Some(format!(\"b\")));\n+    snippet.push(span_foo_semi, false, Some(format!(\"c\")));\n+    snippet.push(span_bar_vec0, false, Some(format!(\"d\")));\n+    snippet.push(span_bar_vec1, false, Some(format!(\"e\")));\n+    snippet.push(span_bar_semi, false, Some(format!(\"f\")));\n+\n+    let lines = snippet.render_lines();\n+    println!(\"{:#?}\", lines);\n+\n+    let text: String = make_string(&lines);\n+\n+    println!(\"text=\\n{}\", text);\n+\n+    // Note that the `|>` remain aligned across both files:\n+    assert_eq!(&text[..], &r#\"\n+   --> foo.rs:3:14\n+3   |>     vec.push(vec.pop().unwrap());\n+    |>     ---      ^^^                - c\n+    |>     |        |\n+    |>     |        b\n+    |>     a\n+>>>>>> bar.rs\n+17  |>     vec.push();\n+    |>     ---       - f\n+    |>     |\n+    |>     d\n+...\n+21  |>     vec.pop().unwrap());\n+    |>     --- e\n+\"#[1..]);\n+}\n+\n+#[test]\n+fn multi_line() {\n+    let file_text = r#\"\n+fn foo() {\n+    let name = find_id(&data, 22).unwrap();\n+\n+    // Add one more item we forgot to the vector. Silly us.\n+    data.push(Data { name: format!(\"Hera\"), id: 66 });\n+\n+    // Print everything out.\n+    println!(\"Name: {:?}\", name);\n+    println!(\"Data: {:?}\", data);\n+}\n+\"#;\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", file_text);\n+    let span_data0 = cm.span_substr(&foo, file_text, \"data\", 0);\n+    let span_data1 = cm.span_substr(&foo, file_text, \"data\", 1);\n+    let span_rbrace = cm.span_substr(&foo, file_text, \"}\", 3);\n+\n+    let mut snippet = SnippetData::new(cm, None);\n+    snippet.push(span_data0, false, Some(format!(\"immutable borrow begins here\")));\n+    snippet.push(span_data1, false, Some(format!(\"mutable borrow occurs here\")));\n+    snippet.push(span_rbrace, false, Some(format!(\"immutable borrow ends here\")));\n+\n+    let lines = snippet.render_lines();\n+    println!(\"{:#?}\", lines);\n+\n+    let text: String = make_string(&lines);\n+\n+    println!(\"text=\\n{}\", text);\n+    assert_eq!(&text[..], &r#\"\n+>>>>>> foo.rs\n+3   |>     let name = find_id(&data, 22).unwrap();\n+    |>                         ---- immutable borrow begins here\n+...\n+6   |>     data.push(Data { name: format!(\"Hera\"), id: 66 });\n+    |>     ---- mutable borrow occurs here\n+...\n+11  |> }\n+    |> - immutable borrow ends here\n+\"#[1..]);\n+}\n+\n+#[test]\n+fn overlapping() {\n+    let file_text = r#\"\n+fn foo() {\n+    vec.push(vec.pop().unwrap());\n+}\n+\"#;\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", file_text);\n+    let span0 = cm.span_substr(&foo, file_text, \"vec.push\", 0);\n+    let span1 = cm.span_substr(&foo, file_text, \"vec\", 0);\n+    let span2 = cm.span_substr(&foo, file_text, \"ec.push\", 0);\n+    let span3 = cm.span_substr(&foo, file_text, \"unwrap\", 0);\n+\n+    let mut snippet = SnippetData::new(cm, None);\n+    snippet.push(span0, false, Some(format!(\"A\")));\n+    snippet.push(span1, false, Some(format!(\"B\")));\n+    snippet.push(span2, false, Some(format!(\"C\")));\n+    snippet.push(span3, false, Some(format!(\"D\")));\n+\n+    let lines = snippet.render_lines();\n+    println!(\"{:#?}\", lines);\n+    let text: String = make_string(&lines);\n+\n+    println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n+    assert_eq!(&text[..], &r#\"\n+>>>> foo.rs\n+3 |>     vec.push(vec.pop().unwrap());\n+  |>     --------           ------ D\n+  |>     ||\n+  |>     |C\n+  |>     A\n+  |>     B\n+\"#[1..]);\n+}\n+\n+#[test]\n+fn one_line_out_of_order() {\n+    let file_text = r#\"\n+fn foo() {\n+    vec.push(vec.pop().unwrap());\n+}\n+\"#;\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", file_text);\n+    let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 0);\n+    let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 1);\n+    let span_semi = cm.span_substr(&foo, file_text, \";\", 0);\n+\n+    // intentionally don't push the snippets left to right\n+    let mut snippet = SnippetData::new(cm, None);\n+    snippet.push(span_vec1, false, Some(format!(\"error occurs here\")));\n+    snippet.push(span_vec0, false, Some(format!(\"previous borrow of `vec` occurs here\")));\n+    snippet.push(span_semi, false, Some(format!(\"previous borrow ends here\")));\n+\n+    let lines = snippet.render_lines();\n+    println!(\"{:#?}\", lines);\n+    let text: String = make_string(&lines);\n+\n+    println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n+    assert_eq!(&text[..], &r#\"\n+>>>> foo.rs\n+3 |>     vec.push(vec.pop().unwrap());\n+  |>     ---      ---                - previous borrow ends here\n+  |>     |        |\n+  |>     |        error occurs here\n+  |>     previous borrow of `vec` occurs here\n+\"#[1..]);\n+}\n+\n+#[test]\n+fn elide_unnecessary_lines() {\n+    let file_text = r#\"\n+fn foo() {\n+    let mut vec = vec![0, 1, 2];\n+    let mut vec2 = vec;\n+    vec2.push(3);\n+    vec2.push(4);\n+    vec2.push(5);\n+    vec2.push(6);\n+    vec.push(7);\n+}\n+\"#;\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", file_text);\n+    let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 3);\n+    let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 8);\n+\n+    let mut snippet = SnippetData::new(cm, None);\n+    snippet.push(span_vec0, false, Some(format!(\"`vec` moved here because it \\\n+        has type `collections::vec::Vec<i32>`\")));\n+    snippet.push(span_vec1, false, Some(format!(\"use of moved value: `vec`\")));\n+\n+    let lines = snippet.render_lines();\n+    println!(\"{:#?}\", lines);\n+    let text: String = make_string(&lines);\n+    println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n+    assert_eq!(&text[..], &r#\"\n+>>>>>> foo.rs\n+4   |>     let mut vec2 = vec;\n+    |>                    --- `vec` moved here because it has type `collections::vec::Vec<i32>`\n+...\n+9   |>     vec.push(7);\n+    |>     --- use of moved value: `vec`\n+\"#[1..]);\n+}\n+\n+#[test]\n+fn spans_without_labels() {\n+    let file_text = r#\"\n+fn foo() {\n+    let mut vec = vec![0, 1, 2];\n+    let mut vec2 = vec;\n+    vec2.push(3);\n+    vec2.push(4);\n+    vec2.push(5);\n+    vec2.push(6);\n+    vec.push(7);\n+}\n+\"#;\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", file_text);\n+\n+    let mut snippet = SnippetData::new(cm.clone(), None);\n+    for i in 0..4 {\n+        let span_veci = cm.span_substr(&foo, file_text, \"vec\", i);\n+        snippet.push(span_veci, false, None);\n+    }\n+\n+    let lines = snippet.render_lines();\n+    let text: String = make_string(&lines);\n+    println!(\"text=&r#\\\"\\n{}\\n\\\"#[1..]\", text);\n+    assert_eq!(text, &r#\"\n+>>>> foo.rs\n+3 |>     let mut vec = vec![0, 1, 2];\n+  |>             ---   ---\n+4 |>     let mut vec2 = vec;\n+  |>             ---    ---\n+\"#[1..]);\n+}\n+\n+#[test]\n+fn span_long_selection() {\n+    let file_text = r#\"\n+impl SomeTrait for () {\n+    fn foo(x: u32) {\n+        // impl 1\n+        // impl 2\n+        // impl 3\n+    }\n+}\n+\"#;\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", file_text);\n+\n+    let mut snippet = SnippetData::new(cm.clone(), None);\n+    let fn_span = cm.span_substr(&foo, file_text, \"fn\", 0);\n+    let rbrace_span = cm.span_substr(&foo, file_text, \"}\", 0);\n+    snippet.push(splice(fn_span, rbrace_span), false, None);\n+    let lines = snippet.render_lines();\n+    let text: String = make_string(&lines);\n+    println!(\"r#\\\"\\n{}\\\"\", text);\n+    assert_eq!(text, &r#\"\n+>>>>>> foo.rs\n+3   |>     fn foo(x: u32) {\n+    |>     ----------------\n+...\n+\"#[1..]);\n+}\n+\n+#[test]\n+fn span_overlap_label() {\n+    // Test that we don't put `x_span` to the right of its highlight,\n+    // since there is another highlight that overlaps it.\n+\n+    let file_text = r#\"\n+    fn foo(x: u32) {\n+    }\n+}\n+\"#;\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", file_text);\n+\n+    let mut snippet = SnippetData::new(cm.clone(), None);\n+    let fn_span = cm.span_substr(&foo, file_text, \"fn foo(x: u32)\", 0);\n+    let x_span = cm.span_substr(&foo, file_text, \"x\", 0);\n+    snippet.push(fn_span, false, Some(format!(\"fn_span\")));\n+    snippet.push(x_span, false, Some(format!(\"x_span\")));\n+    let lines = snippet.render_lines();\n+    let text: String = make_string(&lines);\n+    println!(\"r#\\\"\\n{}\\\"\", text);\n+    assert_eq!(text, &r#\"\n+>>>> foo.rs\n+2 |>     fn foo(x: u32) {\n+  |>     --------------\n+  |>     |      |\n+  |>     |      x_span\n+  |>     fn_span\n+\"#[1..]);\n+}\n+\n+#[test]\n+fn span_overlap_label2() {\n+    // Test that we don't put `x_span` to the right of its highlight,\n+    // since there is another highlight that overlaps it. In this\n+    // case, the overlap is only at the beginning, but it's still\n+    // better to show the beginning more clearly.\n+\n+    let file_text = r#\"\n+    fn foo(x: u32) {\n+    }\n+}\n+\"#;\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", file_text);\n+\n+    let mut snippet = SnippetData::new(cm.clone(), None);\n+    let fn_span = cm.span_substr(&foo, file_text, \"fn foo(x\", 0);\n+    let x_span = cm.span_substr(&foo, file_text, \"x: u32)\", 0);\n+    snippet.push(fn_span, false, Some(format!(\"fn_span\")));\n+    snippet.push(x_span, false, Some(format!(\"x_span\")));\n+    let lines = snippet.render_lines();\n+    let text: String = make_string(&lines);\n+    println!(\"r#\\\"\\n{}\\\"\", text);\n+    assert_eq!(text, &r#\"\n+>>>> foo.rs\n+2 |>     fn foo(x: u32) {\n+  |>     --------------\n+  |>     |      |\n+  |>     |      x_span\n+  |>     fn_span\n+\"#[1..]);\n+}\n+\n+#[test]\n+fn span_overlap_label3() {\n+    // Test that we don't put `x_span` to the right of its highlight,\n+    // since there is another highlight that overlaps it. In this\n+    // case, the overlap is only at the beginning, but it's still\n+    // better to show the beginning more clearly.\n+\n+    let file_text = r#\"\n+    fn foo() {\n+       let closure = || {\n+           inner\n+       };\n+    }\n+}\n+\"#;\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", file_text);\n+\n+    let mut snippet = SnippetData::new(cm.clone(), None);\n+\n+    let closure_span = {\n+        let closure_start_span = cm.span_substr(&foo, file_text, \"||\", 0);\n+        let closure_end_span = cm.span_substr(&foo, file_text, \"}\", 0);\n+        splice(closure_start_span, closure_end_span)\n+    };\n+\n+    let inner_span = cm.span_substr(&foo, file_text, \"inner\", 0);\n+\n+    snippet.push(closure_span, false, Some(format!(\"foo\")));\n+    snippet.push(inner_span, false, Some(format!(\"bar\")));\n+\n+    let lines = snippet.render_lines();\n+    let text: String = make_string(&lines);\n+    println!(\"r#\\\"\\n{}\\\"\", text);\n+    assert_eq!(text, &r#\"\n+>>>> foo.rs\n+3 |>        let closure = || {\n+  |>                      ---- foo\n+4 |>            inner\n+  |> ----------------\n+  |>            |\n+  |>            bar\n+5 |>        };\n+  |> --------\n+\"#[1..]);\n+}"}]}