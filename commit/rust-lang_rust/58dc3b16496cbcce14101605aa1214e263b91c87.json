{"sha": "58dc3b16496cbcce14101605aa1214e263b91c87", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4ZGMzYjE2NDk2Y2JjY2UxNDEwMTYwNWFhMTIxNGUyNjNiOTFjODc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-09-19T20:01:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-19T20:01:19Z"}, "message": "Merge #1877\n\n1877: Replace usages of bump_any with bump r=matklad a=kjeremy\n\nFixes #1854 \n\nCo-authored-by: kjeremy <kjeremy@gmail.com>", "tree": {"sha": "fc95ce3365f3adc3f289e188eaa8a590a253eb7e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc95ce3365f3adc3f289e188eaa8a590a253eb7e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58dc3b16496cbcce14101605aa1214e263b91c87", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdg96PCRBK7hj4Ov3rIwAAdHIIAHC9pFtWXTfzvSULx2+6gZfy\nkiXxzRqSvZjWuZ6ITVWM0PGfiO/pwH3djXQUuVYf8ArfNC2XSCFp0d/XasMZcNZu\nx3SJj25DcT6QOiN0V0GqF/6LxKhsfn2/Y+uHs3l4dZYs1qclrD5LHKdAHB8W64c0\ng0TlOSyYu6RRSTk0UoI635RIwfgkP6tJls8doxhyBdpI7oTSQgarRwG+qrHeqM7L\nrO2SK7Nr2cup1batwwNFY2Pgi6Mnj5xb6JuJbpTXRpJttcdGvkLO7C7tBlQ3jApd\nkETdqTJRXnU42PdspeqpVc3NE0Spa0cpC8L3oLEVCH4Pa2au0vulU8hEiNAI0ZE=\n=vqG7\n-----END PGP SIGNATURE-----\n", "payload": "tree fc95ce3365f3adc3f289e188eaa8a590a253eb7e\nparent cd9b222ba0555424d73d549eac43d9aaf1765d7d\nparent 883edd002eaddc138a402918d0d765278e9bc2c9\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1568923279 +0000\ncommitter GitHub <noreply@github.com> 1568923279 +0000\n\nMerge #1877\n\n1877: Replace usages of bump_any with bump r=matklad a=kjeremy\n\nFixes #1854 \n\nCo-authored-by: kjeremy <kjeremy@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58dc3b16496cbcce14101605aa1214e263b91c87", "html_url": "https://github.com/rust-lang/rust/commit/58dc3b16496cbcce14101605aa1214e263b91c87", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58dc3b16496cbcce14101605aa1214e263b91c87/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd9b222ba0555424d73d549eac43d9aaf1765d7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd9b222ba0555424d73d549eac43d9aaf1765d7d", "html_url": "https://github.com/rust-lang/rust/commit/cd9b222ba0555424d73d549eac43d9aaf1765d7d"}, {"sha": "883edd002eaddc138a402918d0d765278e9bc2c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/883edd002eaddc138a402918d0d765278e9bc2c9", "html_url": "https://github.com/rust-lang/rust/commit/883edd002eaddc138a402918d0d765278e9bc2c9"}], "stats": {"total": 174, "additions": 87, "deletions": 87}, "files": [{"sha": "e2355aff9a5dc09576641e771610adc8d876fa40", "filename": "crates/ra_parser/src/grammar.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/58dc3b16496cbcce14101605aa1214e263b91c87/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dc3b16496cbcce14101605aa1214e263b91c87/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar.rs?ref=58dc3b16496cbcce14101605aa1214e263b91c87", "patch": "@@ -212,7 +212,7 @@ fn opt_visibility(p: &mut Parser) -> bool {\n         // fn foo() { crate::foo(); }\n         T![crate] if !p.nth_at(1, T![::]) => {\n             let m = p.start();\n-            p.bump_any();\n+            p.bump(T![crate]);\n             m.complete(p, VISIBILITY);\n         }\n         _ => return false,\n@@ -223,7 +223,7 @@ fn opt_visibility(p: &mut Parser) -> bool {\n fn opt_alias(p: &mut Parser) {\n     if p.at(T![as]) {\n         let m = p.start();\n-        p.bump_any();\n+        p.bump(T![as]);\n         if !p.eat(T![_]) {\n             name(p);\n         }\n@@ -234,7 +234,7 @@ fn opt_alias(p: &mut Parser) {\n fn abi(p: &mut Parser) {\n     assert!(p.at(T![extern]));\n     let abi = p.start();\n-    p.bump_any();\n+    p.bump(T![extern]);\n     match p.current() {\n         STRING | RAW_STRING => p.bump_any(),\n         _ => (),\n@@ -257,7 +257,7 @@ fn opt_fn_ret_type(p: &mut Parser) -> bool {\n fn name_r(p: &mut Parser, recovery: TokenSet) {\n     if p.at(IDENT) {\n         let m = p.start();\n-        p.bump_any();\n+        p.bump(IDENT);\n         m.complete(p, NAME);\n     } else {\n         p.err_recover(\"expected a name\", recovery);\n@@ -271,11 +271,11 @@ fn name(p: &mut Parser) {\n fn name_ref(p: &mut Parser) {\n     if p.at(IDENT) {\n         let m = p.start();\n-        p.bump_any();\n+        p.bump(IDENT);\n         m.complete(p, NAME_REF);\n     } else if p.at(T![self]) {\n         let m = p.start();\n-        p.bump_any();\n+        p.bump(T![self]);\n         m.complete(p, T![self]);\n     } else {\n         p.err_and_bump(\"expected identifier\");\n@@ -296,7 +296,7 @@ fn error_block(p: &mut Parser, message: &str) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n     p.error(message);\n-    p.bump_any();\n+    p.bump(T!['{']);\n     expressions::expr_block_contents(p);\n     p.eat(T!['}']);\n     m.complete(p, ERROR);"}, {"sha": "1cfd301b5ded096f7a62db131e04ab5477b0c8d3", "filename": "crates/ra_parser/src/grammar/attributes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/58dc3b16496cbcce14101605aa1214e263b91c87/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dc3b16496cbcce14101605aa1214e263b91c87/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fattributes.rs?ref=58dc3b16496cbcce14101605aa1214e263b91c87", "patch": "@@ -15,11 +15,11 @@ pub(super) fn outer_attributes(p: &mut Parser) {\n fn attribute(p: &mut Parser, inner: bool) {\n     let attr = p.start();\n     assert!(p.at(T![#]));\n-    p.bump_any();\n+    p.bump(T![#]);\n \n     if inner {\n         assert!(p.at(T![!]));\n-        p.bump_any();\n+        p.bump(T![!]);\n     }\n \n     if p.at(T!['[']) {"}, {"sha": "80b085280d9c2a497f75a3e68b4902a06a8e296f", "filename": "crates/ra_parser/src/grammar/expressions.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/58dc3b16496cbcce14101605aa1214e263b91c87/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dc3b16496cbcce14101605aa1214e263b91c87/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=58dc3b16496cbcce14101605aa1214e263b91c87", "patch": "@@ -43,7 +43,7 @@ pub(crate) fn block(p: &mut Parser) {\n pub(crate) fn naked_block(p: &mut Parser) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n-    p.bump_any();\n+    p.bump(T!['{']);\n     expr_block_contents(p);\n     p.expect(T!['}']);\n     m.complete(p, BLOCK);\n@@ -150,7 +150,7 @@ pub(super) fn stmt(p: &mut Parser, with_semi: StmtWithSemi) {\n     // }\n     fn let_stmt(p: &mut Parser, m: Marker, with_semi: StmtWithSemi) {\n         assert!(p.at(T![let]));\n-        p.bump_any();\n+        p.bump(T![let]);\n         patterns::pattern(p);\n         if p.at(T![:]) {\n             types::ascription(p);\n@@ -195,7 +195,7 @@ pub(crate) fn expr_block_contents(p: &mut Parser) {\n         // }\n \n         if p.at(T![;]) {\n-            p.bump_any();\n+            p.bump(T![;]);\n             continue;\n         }\n \n@@ -297,7 +297,7 @@ fn lhs(p: &mut Parser, r: Restrictions) -> Option<(CompletedMarker, BlockLike)>\n         // }\n         T![&] => {\n             m = p.start();\n-            p.bump_any();\n+            p.bump(T![&]);\n             p.eat(T![mut]);\n             REF_EXPR\n         }\n@@ -438,7 +438,7 @@ fn call_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n fn index_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n     assert!(p.at(T!['[']));\n     let m = lhs.precede(p);\n-    p.bump_any();\n+    p.bump(T!['[']);\n     expr(p);\n     p.expect(T![']']);\n     m.complete(p, INDEX_EXPR)\n@@ -478,7 +478,7 @@ fn method_call_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n fn field_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n     assert!(p.at(T![.]));\n     let m = lhs.precede(p);\n-    p.bump_any();\n+    p.bump(T![.]);\n     if p.at(IDENT) || p.at(INT_NUMBER) {\n         name_ref_or_index(p)\n     } else if p.at(FLOAT_NUMBER) {\n@@ -497,7 +497,7 @@ fn field_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n fn try_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n     assert!(p.at(T![?]));\n     let m = lhs.precede(p);\n-    p.bump_any();\n+    p.bump(T![?]);\n     m.complete(p, TRY_EXPR)\n }\n \n@@ -511,7 +511,7 @@ fn try_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n fn cast_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n     assert!(p.at(T![as]));\n     let m = lhs.precede(p);\n-    p.bump_any();\n+    p.bump(T![as]);\n     // Use type_no_bounds(), because cast expressions are not\n     // allowed to have bounds.\n     types::type_no_bounds(p);\n@@ -521,7 +521,7 @@ fn cast_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n fn arg_list(p: &mut Parser) {\n     assert!(p.at(T!['(']));\n     let m = p.start();\n-    p.bump_any();\n+    p.bump(T!['(']);\n     while !p.at(T![')']) && !p.at(EOF) {\n         if !p.at_ts(EXPR_FIRST) {\n             p.error(\"expected expression\");\n@@ -570,7 +570,7 @@ fn path_expr(p: &mut Parser, r: Restrictions) -> (CompletedMarker, BlockLike) {\n pub(crate) fn record_field_list(p: &mut Parser) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n-    p.bump_any();\n+    p.bump(T!['{']);\n     while !p.at(EOF) && !p.at(T!['}']) {\n         match p.current() {\n             // test record_literal_field_with_attr"}, {"sha": "6c7fdc2cd48cd0156552015e264f1d52272a490b", "filename": "crates/ra_parser/src/grammar/expressions/atom.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/58dc3b16496cbcce14101605aa1214e263b91c87/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dc3b16496cbcce14101605aa1214e263b91c87/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs?ref=58dc3b16496cbcce14101605aa1214e263b91c87", "patch": "@@ -101,14 +101,14 @@ pub(super) fn atom_expr(p: &mut Parser, r: Restrictions) -> Option<(CompletedMar\n         }\n         T![async] if la == T!['{'] || (la == T![move] && p.nth(2) == T!['{']) => {\n             let m = p.start();\n-            p.bump_any();\n+            p.bump(T![async]);\n             p.eat(T![move]);\n             block_expr(p, Some(m))\n         }\n         T![match] => match_expr(p),\n         T![unsafe] if la == T!['{'] => {\n             let m = p.start();\n-            p.bump_any();\n+            p.bump(T![unsafe]);\n             block_expr(p, Some(m))\n         }\n         T!['{'] => {\n@@ -180,7 +180,7 @@ fn tuple_expr(p: &mut Parser) -> CompletedMarker {\n fn array_expr(p: &mut Parser) -> CompletedMarker {\n     assert!(p.at(T!['[']));\n     let m = p.start();\n-    p.bump_any();\n+    p.bump(T!['[']);\n     if p.eat(T![']']) {\n         return m.complete(p, ARRAY_EXPR);\n     }\n@@ -262,11 +262,11 @@ fn lambda_expr(p: &mut Parser) -> CompletedMarker {\n fn if_expr(p: &mut Parser) -> CompletedMarker {\n     assert!(p.at(T![if]));\n     let m = p.start();\n-    p.bump_any();\n+    p.bump(T![if]);\n     cond(p);\n     block(p);\n     if p.at(T![else]) {\n-        p.bump_any();\n+        p.bump(T![else]);\n         if p.at(T![if]) {\n             if_expr(p);\n         } else {\n@@ -285,7 +285,7 @@ fn if_expr(p: &mut Parser) -> CompletedMarker {\n fn label(p: &mut Parser) {\n     assert!(p.at(LIFETIME) && p.nth(1) == T![:]);\n     let m = p.start();\n-    p.bump_any();\n+    p.bump(LIFETIME);\n     p.bump_any();\n     m.complete(p, LABEL);\n }\n@@ -297,7 +297,7 @@ fn label(p: &mut Parser) {\n fn loop_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n     assert!(p.at(T![loop]));\n     let m = m.unwrap_or_else(|| p.start());\n-    p.bump_any();\n+    p.bump(T![loop]);\n     block(p);\n     m.complete(p, LOOP_EXPR)\n }\n@@ -310,7 +310,7 @@ fn loop_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n fn while_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n     assert!(p.at(T![while]));\n     let m = m.unwrap_or_else(|| p.start());\n-    p.bump_any();\n+    p.bump(T![while]);\n     cond(p);\n     block(p);\n     m.complete(p, WHILE_EXPR)\n@@ -323,7 +323,7 @@ fn while_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n fn for_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n     assert!(p.at(T![for]));\n     let m = m.unwrap_or_else(|| p.start());\n-    p.bump_any();\n+    p.bump(T![for]);\n     patterns::pattern(p);\n     p.expect(T![in]);\n     expr_no_struct(p);\n@@ -357,7 +357,7 @@ fn cond(p: &mut Parser) {\n fn match_expr(p: &mut Parser) -> CompletedMarker {\n     assert!(p.at(T![match]));\n     let m = p.start();\n-    p.bump_any();\n+    p.bump(T![match]);\n     expr_no_struct(p);\n     if p.at(T!['{']) {\n         match_arm_list(p);\n@@ -453,7 +453,7 @@ fn match_arm(p: &mut Parser) -> BlockLike {\n fn match_guard(p: &mut Parser) -> CompletedMarker {\n     assert!(p.at(T![if]));\n     let m = p.start();\n-    p.bump_any();\n+    p.bump(T![if]);\n     expr(p);\n     m.complete(p, MATCH_GUARD)\n }\n@@ -479,7 +479,7 @@ pub(super) fn block_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n fn return_expr(p: &mut Parser) -> CompletedMarker {\n     assert!(p.at(T![return]));\n     let m = p.start();\n-    p.bump_any();\n+    p.bump(T![return]);\n     if p.at_ts(EXPR_FIRST) {\n         expr(p);\n     }\n@@ -496,7 +496,7 @@ fn return_expr(p: &mut Parser) -> CompletedMarker {\n fn continue_expr(p: &mut Parser) -> CompletedMarker {\n     assert!(p.at(T![continue]));\n     let m = p.start();\n-    p.bump_any();\n+    p.bump(T![continue]);\n     p.eat(LIFETIME);\n     m.complete(p, CONTINUE_EXPR)\n }\n@@ -513,7 +513,7 @@ fn continue_expr(p: &mut Parser) -> CompletedMarker {\n fn break_expr(p: &mut Parser, r: Restrictions) -> CompletedMarker {\n     assert!(p.at(T![break]));\n     let m = p.start();\n-    p.bump_any();\n+    p.bump(T![break]);\n     p.eat(LIFETIME);\n     // test break_ambiguity\n     // fn foo(){\n@@ -535,7 +535,7 @@ fn break_expr(p: &mut Parser, r: Restrictions) -> CompletedMarker {\n fn try_block_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n     assert!(p.at(T![try]));\n     let m = m.unwrap_or_else(|| p.start());\n-    p.bump_any();\n+    p.bump(T![try]);\n     block(p);\n     m.complete(p, TRY_EXPR)\n }\n@@ -549,7 +549,7 @@ fn try_block_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n fn box_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n     assert!(p.at(T![box]));\n     let m = m.unwrap_or_else(|| p.start());\n-    p.bump_any();\n+    p.bump(T![box]);\n     if p.at_ts(EXPR_FIRST) {\n         expr(p);\n     }"}, {"sha": "4c67a5c2e218b3dd43efec1f0e8e65d94ee3ccf5", "filename": "crates/ra_parser/src/grammar/items.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/58dc3b16496cbcce14101605aa1214e263b91c87/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dc3b16496cbcce14101605aa1214e263b91c87/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs?ref=58dc3b16496cbcce14101605aa1214e263b91c87", "patch": "@@ -64,7 +64,7 @@ pub(super) fn item_or_macro(p: &mut Parser, stop_on_r_curly: bool, flavor: ItemF\n         } else if p.at(T!['}']) && !stop_on_r_curly {\n             let e = p.start();\n             p.error(\"unmatched `}`\");\n-            p.bump_any();\n+            p.bump(T!['}']);\n             e.complete(p, ERROR);\n         } else if !p.at(EOF) && !p.at(T!['}']) {\n             p.err_and_bump(\"expected an item\");\n@@ -276,9 +276,9 @@ fn items_without_modifiers(p: &mut Parser, m: Marker) -> Result<(), Marker> {\n \n fn extern_crate_item(p: &mut Parser, m: Marker) {\n     assert!(p.at(T![extern]));\n-    p.bump_any();\n+    p.bump(T![extern]);\n     assert!(p.at(T![crate]));\n-    p.bump_any();\n+    p.bump(T![crate]);\n     name_ref(p);\n     opt_alias(p);\n     p.expect(T![;]);\n@@ -288,15 +288,15 @@ fn extern_crate_item(p: &mut Parser, m: Marker) {\n pub(crate) fn extern_item_list(p: &mut Parser) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n-    p.bump_any();\n+    p.bump(T!['{']);\n     mod_contents(p, true);\n     p.expect(T!['}']);\n     m.complete(p, EXTERN_ITEM_LIST);\n }\n \n fn fn_def(p: &mut Parser, flavor: ItemFlavor) {\n     assert!(p.at(T![fn]));\n-    p.bump_any();\n+    p.bump(T![fn]);\n \n     name_r(p, ITEM_RECOVERY_SET);\n     // test function_type_params\n@@ -323,7 +323,7 @@ fn fn_def(p: &mut Parser, flavor: ItemFlavor) {\n     // test fn_decl\n     // trait T { fn foo(); }\n     if p.at(T![;]) {\n-        p.bump_any();\n+        p.bump(T![;]);\n     } else {\n         expressions::block(p)\n     }\n@@ -333,7 +333,7 @@ fn fn_def(p: &mut Parser, flavor: ItemFlavor) {\n // type Foo = Bar;\n fn type_def(p: &mut Parser, m: Marker) {\n     assert!(p.at(T![type]));\n-    p.bump_any();\n+    p.bump(T![type]);\n \n     name(p);\n \n@@ -357,7 +357,7 @@ fn type_def(p: &mut Parser, m: Marker) {\n \n pub(crate) fn mod_item(p: &mut Parser, m: Marker) {\n     assert!(p.at(T![mod]));\n-    p.bump_any();\n+    p.bump(T![mod]);\n \n     name(p);\n     if p.at(T!['{']) {\n@@ -371,7 +371,7 @@ pub(crate) fn mod_item(p: &mut Parser, m: Marker) {\n pub(crate) fn mod_item_list(p: &mut Parser) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n-    p.bump_any();\n+    p.bump(T!['{']);\n     mod_contents(p, true);\n     p.expect(T!['}']);\n     m.complete(p, ITEM_LIST);"}, {"sha": "310260689ebd5b4ee396ca3aeeb703ece55d280e", "filename": "crates/ra_parser/src/grammar/items/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58dc3b16496cbcce14101605aa1214e263b91c87/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dc3b16496cbcce14101605aa1214e263b91c87/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fconsts.rs?ref=58dc3b16496cbcce14101605aa1214e263b91c87", "patch": "@@ -10,7 +10,7 @@ pub(super) fn const_def(p: &mut Parser, m: Marker) {\n \n fn const_or_static(p: &mut Parser, m: Marker, kw: SyntaxKind, def: SyntaxKind) {\n     assert!(p.at(kw));\n-    p.bump_any();\n+    p.bump(kw);\n     p.eat(T![mut]); // FIXME: validator to forbid const mut\n \n     // Allow `_` in place of an identifier in a `const`."}, {"sha": "bede3b6927c9e2f75890203f76f0a3d515d92fd9", "filename": "crates/ra_parser/src/grammar/items/nominal.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/58dc3b16496cbcce14101605aa1214e263b91c87/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fnominal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dc3b16496cbcce14101605aa1214e263b91c87/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fnominal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fnominal.rs?ref=58dc3b16496cbcce14101605aa1214e263b91c87", "patch": "@@ -11,7 +11,7 @@ pub(super) fn struct_def(p: &mut Parser, m: Marker, kind: SyntaxKind) {\n             type_params::opt_where_clause(p);\n             match p.current() {\n                 T![;] => {\n-                    p.bump_any();\n+                    p.bump(T![;]);\n                 }\n                 T!['{'] => record_field_def_list(p),\n                 _ => {\n@@ -21,7 +21,7 @@ pub(super) fn struct_def(p: &mut Parser, m: Marker, kind: SyntaxKind) {\n             }\n         }\n         T![;] if kind == T![struct] => {\n-            p.bump_any();\n+            p.bump(T![;]);\n         }\n         T!['{'] => record_field_def_list(p),\n         T!['('] if kind == T![struct] => {\n@@ -44,7 +44,7 @@ pub(super) fn struct_def(p: &mut Parser, m: Marker, kind: SyntaxKind) {\n \n pub(super) fn enum_def(p: &mut Parser, m: Marker) {\n     assert!(p.at(T![enum]));\n-    p.bump_any();\n+    p.bump(T![enum]);\n     name_r(p, ITEM_RECOVERY_SET);\n     type_params::opt_type_param_list(p);\n     type_params::opt_where_clause(p);\n@@ -59,7 +59,7 @@ pub(super) fn enum_def(p: &mut Parser, m: Marker) {\n pub(crate) fn enum_variant_list(p: &mut Parser) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n-    p.bump_any();\n+    p.bump(T!['{']);\n     while !p.at(EOF) && !p.at(T!['}']) {\n         if p.at(T!['{']) {\n             error_block(p, \"expected enum variant\");\n@@ -73,7 +73,7 @@ pub(crate) fn enum_variant_list(p: &mut Parser) {\n                 T!['{'] => record_field_def_list(p),\n                 T!['('] => tuple_field_def_list(p),\n                 T![=] => {\n-                    p.bump_any();\n+                    p.bump(T![=]);\n                     expressions::expr(p);\n                 }\n                 _ => (),\n@@ -94,7 +94,7 @@ pub(crate) fn enum_variant_list(p: &mut Parser) {\n pub(crate) fn record_field_def_list(p: &mut Parser) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n-    p.bump_any();\n+    p.bump(T!['{']);\n     while !p.at(T!['}']) && !p.at(EOF) {\n         if p.at(T!['{']) {\n             error_block(p, \"expected field\");"}, {"sha": "3742fd197f2c29930ba9f065a6d54b6ed9f001f5", "filename": "crates/ra_parser/src/grammar/items/traits.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/58dc3b16496cbcce14101605aa1214e263b91c87/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dc3b16496cbcce14101605aa1214e263b91c87/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs?ref=58dc3b16496cbcce14101605aa1214e263b91c87", "patch": "@@ -5,7 +5,7 @@ use super::*;\n // trait X<U: Debug + Display>: Hash + Clone where U: Copy {}\n pub(super) fn trait_def(p: &mut Parser) {\n     assert!(p.at(T![trait]));\n-    p.bump_any();\n+    p.bump(T![trait]);\n     name_r(p, ITEM_RECOVERY_SET);\n     type_params::opt_type_param_list(p);\n     if p.at(T![:]) {\n@@ -29,7 +29,7 @@ pub(super) fn trait_def(p: &mut Parser) {\n pub(crate) fn trait_item_list(p: &mut Parser) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n-    p.bump_any();\n+    p.bump(T!['{']);\n     while !p.at(EOF) && !p.at(T!['}']) {\n         if p.at(T!['{']) {\n             error_block(p, \"expected an item\");\n@@ -45,7 +45,7 @@ pub(crate) fn trait_item_list(p: &mut Parser) {\n // impl Foo {}\n pub(super) fn impl_block(p: &mut Parser) {\n     assert!(p.at(T![impl]));\n-    p.bump_any();\n+    p.bump(T![impl]);\n     if choose_type_params_over_qpath(p) {\n         type_params::opt_type_param_list(p);\n     }\n@@ -78,7 +78,7 @@ pub(super) fn impl_block(p: &mut Parser) {\n pub(crate) fn impl_item_list(p: &mut Parser) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n-    p.bump_any();\n+    p.bump(T!['{']);\n     // test impl_inner_attributes\n     // enum F{}\n     // impl F {"}, {"sha": "2af2ad3157d63f41c9d487d795d982aae9d1d436", "filename": "crates/ra_parser/src/grammar/items/use_item.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/58dc3b16496cbcce14101605aa1214e263b91c87/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fuse_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dc3b16496cbcce14101605aa1214e263b91c87/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fuse_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fuse_item.rs?ref=58dc3b16496cbcce14101605aa1214e263b91c87", "patch": "@@ -2,7 +2,7 @@ use super::*;\n \n pub(super) fn use_item(p: &mut Parser, m: Marker) {\n     assert!(p.at(T![use]));\n-    p.bump_any();\n+    p.bump(T![use]);\n     use_tree(p);\n     p.expect(T![;]);\n     m.complete(p, USE_ITEM);\n@@ -84,7 +84,7 @@ fn use_tree(p: &mut Parser) {\n                     p.bump(T![::]);\n                     match p.current() {\n                         T![*] => {\n-                            p.bump_any();\n+                            p.bump(T![*]);\n                         }\n                         // test use_tree_list_after_path\n                         // use crate::{Item};\n@@ -114,7 +114,7 @@ fn use_tree(p: &mut Parser) {\n pub(crate) fn use_tree_list(p: &mut Parser) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n-    p.bump_any();\n+    p.bump(T!['{']);\n     while !p.at(EOF) && !p.at(T!['}']) {\n         use_tree(p);\n         if !p.at(T!['}']) {"}, {"sha": "efc3292438d73891f0fc51a3e5a5adb61f0c70ad", "filename": "crates/ra_parser/src/grammar/params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58dc3b16496cbcce14101605aa1214e263b91c87/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fparams.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dc3b16496cbcce14101605aa1214e263b91c87/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fparams.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fparams.rs?ref=58dc3b16496cbcce14101605aa1214e263b91c87", "patch": "@@ -39,7 +39,7 @@ fn list_(p: &mut Parser, flavor: Flavor) {\n     let (bra, ket) = if flavor.type_required() { (T!['('], T![')']) } else { (T![|], T![|]) };\n     assert!(p.at(bra));\n     let m = p.start();\n-    p.bump_any();\n+    p.bump(bra);\n     if flavor.type_required() {\n         // test self_param_outer_attr\n         // fn f(#[must_use] self) {}"}, {"sha": "a4ffd69601992e44d6f713e0675d0f5fd0386831", "filename": "crates/ra_parser/src/grammar/patterns.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/58dc3b16496cbcce14101605aa1214e263b91c87/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dc3b16496cbcce14101605aa1214e263b91c87/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs?ref=58dc3b16496cbcce14101605aa1214e263b91c87", "patch": "@@ -106,7 +106,7 @@ fn literal_pat(p: &mut Parser) -> CompletedMarker {\n     assert!(is_literal_pat_start(p));\n     let m = p.start();\n     if p.at(T![-]) {\n-        p.bump_any();\n+        p.bump(T![-]);\n     }\n     expressions::literal(p);\n     m.complete(p, LITERAL_PAT)\n@@ -146,7 +146,7 @@ fn path_pat(p: &mut Parser) -> CompletedMarker {\n // }\n fn tuple_pat_fields(p: &mut Parser) {\n     assert!(p.at(T!['(']));\n-    p.bump_any();\n+    p.bump(T!['(']);\n     pat_list(p, T![')']);\n     p.expect(T![')']);\n }\n@@ -161,7 +161,7 @@ fn tuple_pat_fields(p: &mut Parser) {\n fn record_field_pat_list(p: &mut Parser) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n-    p.bump_any();\n+    p.bump(T!['{']);\n     while !p.at(EOF) && !p.at(T!['}']) {\n         match p.current() {\n             // A trailing `..` is *not* treated as a DOT_DOT_PAT.\n@@ -200,7 +200,7 @@ fn record_field_pat(p: &mut Parser) {\n fn placeholder_pat(p: &mut Parser) -> CompletedMarker {\n     assert!(p.at(T![_]));\n     let m = p.start();\n-    p.bump_any();\n+    p.bump(T![_]);\n     m.complete(p, PLACEHOLDER_PAT)\n }\n \n@@ -245,7 +245,7 @@ fn dot_dot_pat(p: &mut Parser) -> CompletedMarker {\n fn ref_pat(p: &mut Parser) -> CompletedMarker {\n     assert!(p.at(T![&]));\n     let m = p.start();\n-    p.bump_any();\n+    p.bump(T![&]);\n     p.eat(T![mut]);\n     pattern(p);\n     m.complete(p, REF_PAT)\n@@ -269,7 +269,7 @@ fn tuple_pat(p: &mut Parser) -> CompletedMarker {\n fn slice_pat(p: &mut Parser) -> CompletedMarker {\n     assert!(p.at(T!['[']));\n     let m = p.start();\n-    p.bump_any();\n+    p.bump(T!['[']);\n     pat_list(p, T![']']);\n     p.expect(T![']']);\n     m.complete(p, SLICE_PAT)\n@@ -318,7 +318,7 @@ fn bind_pat(p: &mut Parser, with_at: bool) -> CompletedMarker {\n fn box_pat(p: &mut Parser) -> CompletedMarker {\n     assert!(p.at(T![box]));\n     let m = p.start();\n-    p.bump_any();\n+    p.bump(T![box]);\n     pattern(p);\n     m.complete(p, BOX_PAT)\n }"}, {"sha": "8e97fe03c0ed63c6718d1b901b4ce74952cb7799", "filename": "crates/ra_parser/src/grammar/type_args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58dc3b16496cbcce14101605aa1214e263b91c87/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dc3b16496cbcce14101605aa1214e263b91c87/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_args.rs?ref=58dc3b16496cbcce14101605aa1214e263b91c87", "patch": "@@ -29,7 +29,7 @@ fn type_arg(p: &mut Parser) {\n     let m = p.start();\n     match p.current() {\n         LIFETIME => {\n-            p.bump_any();\n+            p.bump(LIFETIME);\n             m.complete(p, LIFETIME_ARG);\n         }\n         // test associated_type_bounds"}, {"sha": "7071c70eaf997c2ae3e57b41457e6d864b3c2881", "filename": "crates/ra_parser/src/grammar/type_params.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/58dc3b16496cbcce14101605aa1214e263b91c87/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dc3b16496cbcce14101605aa1214e263b91c87/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_params.rs?ref=58dc3b16496cbcce14101605aa1214e263b91c87", "patch": "@@ -10,7 +10,7 @@ pub(super) fn opt_type_param_list(p: &mut Parser) {\n fn type_param_list(p: &mut Parser) {\n     assert!(p.at(T![<]));\n     let m = p.start();\n-    p.bump_any();\n+    p.bump(T![<]);\n \n     while !p.at(EOF) && !p.at(T![>]) {\n         let m = p.start();\n@@ -38,7 +38,7 @@ fn type_param_list(p: &mut Parser) {\n \n fn lifetime_param(p: &mut Parser, m: Marker) {\n     assert!(p.at(LIFETIME));\n-    p.bump_any();\n+    p.bump(LIFETIME);\n     if p.at(T![:]) {\n         lifetime_bounds(p);\n     }\n@@ -54,7 +54,7 @@ fn type_param(p: &mut Parser, m: Marker) {\n     // test type_param_default\n     // struct S<T = i32>;\n     if p.at(T![=]) {\n-        p.bump_any();\n+        p.bump(T![=]);\n         types::type_(p)\n     }\n     m.complete(p, TYPE_PARAM);\n@@ -64,15 +64,15 @@ fn type_param(p: &mut Parser, m: Marker) {\n // struct S<T: 'a + ?Sized + (Copy)>;\n pub(super) fn bounds(p: &mut Parser) {\n     assert!(p.at(T![:]));\n-    p.bump_any();\n+    p.bump(T![:]);\n     bounds_without_colon(p);\n }\n \n fn lifetime_bounds(p: &mut Parser) {\n     assert!(p.at(T![:]));\n-    p.bump_any();\n+    p.bump(T![:]);\n     while p.at(LIFETIME) {\n-        p.bump_any();\n+        p.bump(LIFETIME);\n         if !p.eat(T![+]) {\n             break;\n         }\n@@ -99,7 +99,7 @@ fn type_bound(p: &mut Parser) -> bool {\n     let has_paren = p.eat(T!['(']);\n     p.eat(T![?]);\n     match p.current() {\n-        LIFETIME => p.bump_any(),\n+        LIFETIME => p.bump(LIFETIME),\n         T![for] => types::for_type(p),\n         _ if paths::is_use_path_start(p) => types::path_type_(p, false),\n         _ => {\n@@ -128,7 +128,7 @@ pub(super) fn opt_where_clause(p: &mut Parser) {\n         return;\n     }\n     let m = p.start();\n-    p.bump_any();\n+    p.bump(T![where]);\n \n     while is_where_predicate(p) {\n         where_predicate(p);\n@@ -166,7 +166,7 @@ fn where_predicate(p: &mut Parser) {\n     let m = p.start();\n     match p.current() {\n         LIFETIME => {\n-            p.bump_any();\n+            p.bump(LIFETIME);\n             if p.at(T![:]) {\n                 bounds(p);\n             } else {"}, {"sha": "bd3829f41859c060ba12840b56819af35171fe6f", "filename": "crates/ra_parser/src/grammar/types.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/58dc3b16496cbcce14101605aa1214e263b91c87/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dc3b16496cbcce14101605aa1214e263b91c87/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftypes.rs?ref=58dc3b16496cbcce14101605aa1214e263b91c87", "patch": "@@ -44,7 +44,7 @@ pub(super) fn ascription(p: &mut Parser) {\n fn paren_or_tuple_type(p: &mut Parser) {\n     assert!(p.at(T!['(']));\n     let m = p.start();\n-    p.bump_any();\n+    p.bump(T!['(']);\n     let mut n_types: u32 = 0;\n     let mut trailing_comma: bool = false;\n     while !p.at(EOF) && !p.at(T![')']) {\n@@ -79,14 +79,14 @@ fn paren_or_tuple_type(p: &mut Parser) {\n fn never_type(p: &mut Parser) {\n     assert!(p.at(T![!]));\n     let m = p.start();\n-    p.bump_any();\n+    p.bump(T![!]);\n     m.complete(p, NEVER_TYPE);\n }\n \n fn pointer_type(p: &mut Parser) {\n     assert!(p.at(T![*]));\n     let m = p.start();\n-    p.bump_any();\n+    p.bump(T![*]);\n \n     match p.current() {\n         // test pointer_type_mut\n@@ -110,21 +110,21 @@ fn pointer_type(p: &mut Parser) {\n fn array_or_slice_type(p: &mut Parser) {\n     assert!(p.at(T!['[']));\n     let m = p.start();\n-    p.bump_any();\n+    p.bump(T!['[']);\n \n     type_(p);\n     let kind = match p.current() {\n         // test slice_type\n         // type T = [()];\n         T![']'] => {\n-            p.bump_any();\n+            p.bump(T![']']);\n             SLICE_TYPE\n         }\n \n         // test array_type\n         // type T = [(); 92];\n         T![;] => {\n-            p.bump_any();\n+            p.bump(T![;]);\n             expressions::expr(p);\n             p.expect(T![']']);\n             ARRAY_TYPE\n@@ -146,7 +146,7 @@ fn array_or_slice_type(p: &mut Parser) {\n fn reference_type(p: &mut Parser) {\n     assert!(p.at(T![&]));\n     let m = p.start();\n-    p.bump_any();\n+    p.bump(T![&]);\n     p.eat(LIFETIME);\n     p.eat(T![mut]);\n     type_no_bounds(p);\n@@ -158,7 +158,7 @@ fn reference_type(p: &mut Parser) {\n fn placeholder_type(p: &mut Parser) {\n     assert!(p.at(T![_]));\n     let m = p.start();\n-    p.bump_any();\n+    p.bump(T![_]);\n     m.complete(p, PLACEHOLDER_TYPE);\n }\n \n@@ -193,7 +193,7 @@ fn fn_pointer_type(p: &mut Parser) {\n \n pub(super) fn for_binder(p: &mut Parser) {\n     assert!(p.at(T![for]));\n-    p.bump_any();\n+    p.bump(T![for]);\n     if p.at(T![<]) {\n         type_params::opt_type_param_list(p);\n     } else {\n@@ -224,7 +224,7 @@ pub(super) fn for_type(p: &mut Parser) {\n fn impl_trait_type(p: &mut Parser) {\n     assert!(p.at(T![impl]));\n     let m = p.start();\n-    p.bump_any();\n+    p.bump(T![impl]);\n     type_params::bounds_without_colon(p);\n     m.complete(p, IMPL_TRAIT_TYPE);\n }\n@@ -234,7 +234,7 @@ fn impl_trait_type(p: &mut Parser) {\n fn dyn_trait_type(p: &mut Parser) {\n     assert!(p.at(T![dyn ]));\n     let m = p.start();\n-    p.bump_any();\n+    p.bump(T![dyn ]);\n     type_params::bounds_without_colon(p);\n     m.complete(p, DYN_TRAIT_TYPE);\n }"}]}