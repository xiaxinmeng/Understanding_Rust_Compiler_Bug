{"sha": "e8d152d2f49df58eeaa006875bafb160fe10da7f", "node_id": "C_kwDOAAsO6NoAKGU4ZDE1MmQyZjQ5ZGY1OGVlYWEwMDY4NzViYWZiMTYwZmUxMGRhN2Y", "commit": {"author": {"name": "Alan Egerton", "email": "eggyal@gmail.com", "date": "2023-02-09T19:11:03Z"}, "committer": {"name": "Alan Egerton", "email": "eggyal@gmail.com", "date": "2023-02-13T10:24:47Z"}, "message": "Move TypeVisitableExt from ir module", "tree": {"sha": "95ce0d70b75993463d0a6a75ef6a5cd983bcb1e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95ce0d70b75993463d0a6a75ef6a5cd983bcb1e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8d152d2f49df58eeaa006875bafb160fe10da7f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQJFBAABCAAvFiEEvrRBFuOXsbT1OVTHfUwvbCISJTIFAmPqD+8RHGVnZ3lhbEBn\nbWFpbC5jb20ACgkQfUwvbCISJTK96xAAywgE1hjcLqkkGgV0Xc/vh8Dnn2h+aYeo\nirt8eFFITUOpazceXH2j67Jna+kXe37oQwBakU189jsgB5/YiJDK3VGdXvDH8aV2\n8htJi/4oEYnFafnoMssMzuIE7RSoevSc8VfYdfc3WQizydXqK74te68Rk8Rn5Qje\nnuV9Gj6dnAttF75kbavflJ9q5nv7aZlObzootxlA7ol4Ju2/CRgXQyYO6jkImlTl\nlcfuze31r4T8XvU3ccxnMemFW+AuPpYCSZNGXLQy8KDBZzjH1H+LnrDi5O/4r/O7\nN+cBLCBrS9TcWkDEJOmPe0scENDeBEsqtlir8RGmNH2FSI1O2L/cPu6pXbhLAgWD\nIOAnLendl33J3NxwkhUxl/N2JuyeWKHrEmZU/whNBLv5VoSffQ1DCbaUPmeSH/Ou\nwNUcVo2CN4CcMJCAVR5r8ilfrZlb92AZRgaW3UtAS27wRmUck7ve+VYpnbkPMANH\nvJ3OrJVgbY1bGQnNIX9Pe4QmByn2bMvuTuXDs5MMJ7b3My/twbILLRvb1GKYJPaU\n/PU/4RIaIyH2s0OJpoF9tSiecGFUEiP1qKPIzNJk0XpQRgCWbXpuzg+LGw8TjigE\n6NZr3yQOfA2X1jxjLiI3HS9ODdiOTPd/YaA8i6CtS4OBEiYtkZnihCluQr4u6Wlx\nh0ED+ZuAYNM=\n=M8uF\n-----END PGP SIGNATURE-----", "payload": "tree 95ce0d70b75993463d0a6a75ef6a5cd983bcb1e6\nparent b409329c624b9e3bbd7d8e07697e2e9f861a45b6\nauthor Alan Egerton <eggyal@gmail.com> 1675969863 +0000\ncommitter Alan Egerton <eggyal@gmail.com> 1676283887 +0000\n\nMove TypeVisitableExt from ir module\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8d152d2f49df58eeaa006875bafb160fe10da7f", "html_url": "https://github.com/rust-lang/rust/commit/e8d152d2f49df58eeaa006875bafb160fe10da7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8d152d2f49df58eeaa006875bafb160fe10da7f/comments", "author": {"login": "eggyal", "id": 3089613, "node_id": "MDQ6VXNlcjMwODk2MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3089613?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eggyal", "html_url": "https://github.com/eggyal", "followers_url": "https://api.github.com/users/eggyal/followers", "following_url": "https://api.github.com/users/eggyal/following{/other_user}", "gists_url": "https://api.github.com/users/eggyal/gists{/gist_id}", "starred_url": "https://api.github.com/users/eggyal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eggyal/subscriptions", "organizations_url": "https://api.github.com/users/eggyal/orgs", "repos_url": "https://api.github.com/users/eggyal/repos", "events_url": "https://api.github.com/users/eggyal/events{/privacy}", "received_events_url": "https://api.github.com/users/eggyal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eggyal", "id": 3089613, "node_id": "MDQ6VXNlcjMwODk2MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3089613?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eggyal", "html_url": "https://github.com/eggyal", "followers_url": "https://api.github.com/users/eggyal/followers", "following_url": "https://api.github.com/users/eggyal/following{/other_user}", "gists_url": "https://api.github.com/users/eggyal/gists{/gist_id}", "starred_url": "https://api.github.com/users/eggyal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eggyal/subscriptions", "organizations_url": "https://api.github.com/users/eggyal/orgs", "repos_url": "https://api.github.com/users/eggyal/repos", "events_url": "https://api.github.com/users/eggyal/events{/privacy}", "received_events_url": "https://api.github.com/users/eggyal/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b409329c624b9e3bbd7d8e07697e2e9f861a45b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/b409329c624b9e3bbd7d8e07697e2e9f861a45b6", "html_url": "https://github.com/rust-lang/rust/commit/b409329c624b9e3bbd7d8e07697e2e9f861a45b6"}], "stats": {"total": 257, "additions": 127, "deletions": 130}, "files": [{"sha": "c217c6cf59c9ee26e5cbeb0696f7b83b0d2a09e4", "filename": "compiler/rustc_middle/src/ty/visit.rs", "status": "modified", "additions": 127, "deletions": 130, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/e8d152d2f49df58eeaa006875bafb160fe10da7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8d152d2f49df58eeaa006875bafb160fe10da7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs?ref=e8d152d2f49df58eeaa006875bafb160fe10da7f", "patch": "@@ -39,24 +39,22 @@\n //! - u.visit_with(visitor)\n //! ```\n use crate::ty::{self, flags::FlagComputation, Binder, Ty, TyCtxt, TypeFlags};\n+use rustc_errors::ErrorGuaranteed;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sso::SsoHashSet;\n use std::ops::ControlFlow;\n \n-pub trait TypeVisitable<'tcx> = ir::TypeVisitable<'tcx> + ir::TypeVisitableExt<'tcx>;\n+pub trait TypeVisitable<'tcx> = ir::TypeVisitable<'tcx> + TypeVisitableExt<'tcx>;\n pub trait TypeSuperVisitable<'tcx> = ir::TypeSuperVisitable<'tcx>;\n pub trait TypeVisitor<'tcx> = ir::TypeVisitor<'tcx>;\n \n pub mod ir {\n-    use crate::ty::{self, Binder, Ty, TypeFlags};\n-    use rustc_errors::ErrorGuaranteed;\n+    use crate::ty::{self, Binder, Ty};\n \n     use std::fmt;\n     use std::ops::ControlFlow;\n \n-    use super::{FoundFlags, HasEscapingVarsVisitor, HasTypeFlagsVisitor};\n-\n     /// This trait is implemented for every type that can be visited,\n     /// providing the skeleton of the traversal.\n     ///\n@@ -76,131 +74,6 @@ pub mod ir {\n         fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy>;\n     }\n \n-    pub trait TypeVisitableExt<'tcx>: TypeVisitable<'tcx> {\n-        /// Returns `true` if `self` has any late-bound regions that are either\n-        /// bound by `binder` or bound by some binder outside of `binder`.\n-        /// If `binder` is `ty::INNERMOST`, this indicates whether\n-        /// there are any late-bound regions that appear free.\n-        fn has_vars_bound_at_or_above(&self, binder: ty::DebruijnIndex) -> bool {\n-            self.visit_with(&mut HasEscapingVarsVisitor { outer_index: binder }).is_break()\n-        }\n-\n-        /// Returns `true` if this type has any regions that escape `binder` (and\n-        /// hence are not bound by it).\n-        fn has_vars_bound_above(&self, binder: ty::DebruijnIndex) -> bool {\n-            self.has_vars_bound_at_or_above(binder.shifted_in(1))\n-        }\n-\n-        /// Return `true` if this type has regions that are not a part of the type.\n-        /// For example, `for<'a> fn(&'a i32)` return `false`, while `fn(&'a i32)`\n-        /// would return `true`. The latter can occur when traversing through the\n-        /// former.\n-        ///\n-        /// See [`HasEscapingVarsVisitor`] for more information.\n-        fn has_escaping_bound_vars(&self) -> bool {\n-            self.has_vars_bound_at_or_above(ty::INNERMOST)\n-        }\n-\n-        fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-            let res = self.visit_with(&mut HasTypeFlagsVisitor { flags }).break_value()\n-                == Some(FoundFlags);\n-            trace!(?self, ?flags, ?res, \"has_type_flags\");\n-            res\n-        }\n-        fn has_projections(&self) -> bool {\n-            self.has_type_flags(TypeFlags::HAS_PROJECTION)\n-        }\n-        fn has_opaque_types(&self) -> bool {\n-            self.has_type_flags(TypeFlags::HAS_TY_OPAQUE)\n-        }\n-        fn has_generators(&self) -> bool {\n-            self.has_type_flags(TypeFlags::HAS_TY_GENERATOR)\n-        }\n-        fn references_error(&self) -> bool {\n-            self.has_type_flags(TypeFlags::HAS_ERROR)\n-        }\n-        fn error_reported(&self) -> Result<(), ErrorGuaranteed> {\n-            if self.references_error() {\n-                if let Some(reported) = ty::tls::with(|tcx| tcx.sess.is_compilation_going_to_fail())\n-                {\n-                    Err(reported)\n-                } else {\n-                    bug!(\"expect tcx.sess.is_compilation_going_to_fail return `Some`\");\n-                }\n-            } else {\n-                Ok(())\n-            }\n-        }\n-        fn has_non_region_param(&self) -> bool {\n-            self.has_type_flags(TypeFlags::NEEDS_SUBST - TypeFlags::HAS_RE_PARAM)\n-        }\n-        fn has_infer_regions(&self) -> bool {\n-            self.has_type_flags(TypeFlags::HAS_RE_INFER)\n-        }\n-        fn has_infer_types(&self) -> bool {\n-            self.has_type_flags(TypeFlags::HAS_TY_INFER)\n-        }\n-        fn has_non_region_infer(&self) -> bool {\n-            self.has_type_flags(TypeFlags::NEEDS_INFER - TypeFlags::HAS_RE_INFER)\n-        }\n-        fn needs_infer(&self) -> bool {\n-            self.has_type_flags(TypeFlags::NEEDS_INFER)\n-        }\n-        fn has_placeholders(&self) -> bool {\n-            self.has_type_flags(\n-                TypeFlags::HAS_RE_PLACEHOLDER\n-                    | TypeFlags::HAS_TY_PLACEHOLDER\n-                    | TypeFlags::HAS_CT_PLACEHOLDER,\n-            )\n-        }\n-        fn needs_subst(&self) -> bool {\n-            self.has_type_flags(TypeFlags::NEEDS_SUBST)\n-        }\n-        /// \"Free\" regions in this context means that it has any region\n-        /// that is not (a) erased or (b) late-bound.\n-        fn has_free_regions(&self) -> bool {\n-            self.has_type_flags(TypeFlags::HAS_FREE_REGIONS)\n-        }\n-\n-        fn has_erased_regions(&self) -> bool {\n-            self.has_type_flags(TypeFlags::HAS_RE_ERASED)\n-        }\n-\n-        /// True if there are any un-erased free regions.\n-        fn has_erasable_regions(&self) -> bool {\n-            self.has_type_flags(TypeFlags::HAS_FREE_REGIONS)\n-        }\n-\n-        /// Indicates whether this value references only 'global'\n-        /// generic parameters that are the same regardless of what fn we are\n-        /// in. This is used for caching.\n-        fn is_global(&self) -> bool {\n-            !self.has_type_flags(TypeFlags::HAS_FREE_LOCAL_NAMES)\n-        }\n-\n-        /// True if there are any late-bound regions\n-        fn has_late_bound_regions(&self) -> bool {\n-            self.has_type_flags(TypeFlags::HAS_RE_LATE_BOUND)\n-        }\n-        /// True if there are any late-bound non-region variables\n-        fn has_non_region_late_bound(&self) -> bool {\n-            self.has_type_flags(TypeFlags::HAS_LATE_BOUND - TypeFlags::HAS_RE_LATE_BOUND)\n-        }\n-        /// True if there are any late-bound variables\n-        fn has_late_bound_vars(&self) -> bool {\n-            self.has_type_flags(TypeFlags::HAS_LATE_BOUND)\n-        }\n-\n-        /// Indicates whether this value still has parameters/placeholders/inference variables\n-        /// which could be replaced later, in a way that would change the results of `impl`\n-        /// specialization.\n-        fn still_further_specializable(&self) -> bool {\n-            self.has_type_flags(TypeFlags::STILL_FURTHER_SPECIALIZABLE)\n-        }\n-    }\n-\n-    impl<'tcx, T: TypeVisitable<'tcx>> TypeVisitableExt<'tcx> for T {}\n-\n     pub trait TypeSuperVisitable<'tcx>: TypeVisitable<'tcx> {\n         /// Provides a default visit for a type of interest. This should only be\n         /// called within `TypeVisitor` methods, when a non-custom traversal is\n@@ -245,6 +118,130 @@ pub mod ir {\n     }\n }\n \n+pub trait TypeVisitableExt<'tcx>: ir::TypeVisitable<'tcx> {\n+    /// Returns `true` if `self` has any late-bound regions that are either\n+    /// bound by `binder` or bound by some binder outside of `binder`.\n+    /// If `binder` is `ty::INNERMOST`, this indicates whether\n+    /// there are any late-bound regions that appear free.\n+    fn has_vars_bound_at_or_above(&self, binder: ty::DebruijnIndex) -> bool {\n+        self.visit_with(&mut HasEscapingVarsVisitor { outer_index: binder }).is_break()\n+    }\n+\n+    /// Returns `true` if this type has any regions that escape `binder` (and\n+    /// hence are not bound by it).\n+    fn has_vars_bound_above(&self, binder: ty::DebruijnIndex) -> bool {\n+        self.has_vars_bound_at_or_above(binder.shifted_in(1))\n+    }\n+\n+    /// Return `true` if this type has regions that are not a part of the type.\n+    /// For example, `for<'a> fn(&'a i32)` return `false`, while `fn(&'a i32)`\n+    /// would return `true`. The latter can occur when traversing through the\n+    /// former.\n+    ///\n+    /// See [`HasEscapingVarsVisitor`] for more information.\n+    fn has_escaping_bound_vars(&self) -> bool {\n+        self.has_vars_bound_at_or_above(ty::INNERMOST)\n+    }\n+\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        let res =\n+            self.visit_with(&mut HasTypeFlagsVisitor { flags }).break_value() == Some(FoundFlags);\n+        trace!(?self, ?flags, ?res, \"has_type_flags\");\n+        res\n+    }\n+    fn has_projections(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_PROJECTION)\n+    }\n+    fn has_opaque_types(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_TY_OPAQUE)\n+    }\n+    fn has_generators(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_TY_GENERATOR)\n+    }\n+    fn references_error(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_ERROR)\n+    }\n+    fn error_reported(&self) -> Result<(), ErrorGuaranteed> {\n+        if self.references_error() {\n+            if let Some(reported) = ty::tls::with(|tcx| tcx.sess.is_compilation_going_to_fail()) {\n+                Err(reported)\n+            } else {\n+                bug!(\"expect tcx.sess.is_compilation_going_to_fail return `Some`\");\n+            }\n+        } else {\n+            Ok(())\n+        }\n+    }\n+    fn has_non_region_param(&self) -> bool {\n+        self.has_type_flags(TypeFlags::NEEDS_SUBST - TypeFlags::HAS_RE_PARAM)\n+    }\n+    fn has_infer_regions(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_RE_INFER)\n+    }\n+    fn has_infer_types(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_TY_INFER)\n+    }\n+    fn has_non_region_infer(&self) -> bool {\n+        self.has_type_flags(TypeFlags::NEEDS_INFER - TypeFlags::HAS_RE_INFER)\n+    }\n+    fn needs_infer(&self) -> bool {\n+        self.has_type_flags(TypeFlags::NEEDS_INFER)\n+    }\n+    fn has_placeholders(&self) -> bool {\n+        self.has_type_flags(\n+            TypeFlags::HAS_RE_PLACEHOLDER\n+                | TypeFlags::HAS_TY_PLACEHOLDER\n+                | TypeFlags::HAS_CT_PLACEHOLDER,\n+        )\n+    }\n+    fn needs_subst(&self) -> bool {\n+        self.has_type_flags(TypeFlags::NEEDS_SUBST)\n+    }\n+    /// \"Free\" regions in this context means that it has any region\n+    /// that is not (a) erased or (b) late-bound.\n+    fn has_free_regions(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_FREE_REGIONS)\n+    }\n+\n+    fn has_erased_regions(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_RE_ERASED)\n+    }\n+\n+    /// True if there are any un-erased free regions.\n+    fn has_erasable_regions(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_FREE_REGIONS)\n+    }\n+\n+    /// Indicates whether this value references only 'global'\n+    /// generic parameters that are the same regardless of what fn we are\n+    /// in. This is used for caching.\n+    fn is_global(&self) -> bool {\n+        !self.has_type_flags(TypeFlags::HAS_FREE_LOCAL_NAMES)\n+    }\n+\n+    /// True if there are any late-bound regions\n+    fn has_late_bound_regions(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_RE_LATE_BOUND)\n+    }\n+    /// True if there are any late-bound non-region variables\n+    fn has_non_region_late_bound(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_LATE_BOUND - TypeFlags::HAS_RE_LATE_BOUND)\n+    }\n+    /// True if there are any late-bound variables\n+    fn has_late_bound_vars(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_LATE_BOUND)\n+    }\n+\n+    /// Indicates whether this value still has parameters/placeholders/inference variables\n+    /// which could be replaced later, in a way that would change the results of `impl`\n+    /// specialization.\n+    fn still_further_specializable(&self) -> bool {\n+        self.has_type_flags(TypeFlags::STILL_FURTHER_SPECIALIZABLE)\n+    }\n+}\n+\n+impl<'tcx, T: ir::TypeVisitable<'tcx>> TypeVisitableExt<'tcx> for T {}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Region folder\n "}]}