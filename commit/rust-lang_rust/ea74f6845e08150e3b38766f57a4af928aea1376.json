{"sha": "ea74f6845e08150e3b38766f57a4af928aea1376", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhNzRmNjg0NWUwODE1MGUzYjM4NzY2ZjU3YTRhZjkyOGFlYTEzNzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-29T07:12:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-29T07:12:37Z"}, "message": "auto merge of #6083 : jbclements/rust/parser-cleanup, r=jbclements\n\nr? @pcwalton\r\n\r\nA month's worth of parser cleanup here. Much of this is new comments and renaming. A number of these commits also remove unneeded code.  Probably the biggest refactor here is splitting \"parse_item_or_view_item\" into two functions; it turns out that the only overlap between items in foreign modules and items in regular modules was macros, so this refactor should make things substantially easier for future maintenance.", "tree": {"sha": "7f595ee292241ed3520742a968e3f5077c687fd5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f595ee292241ed3520742a968e3f5077c687fd5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea74f6845e08150e3b38766f57a4af928aea1376", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea74f6845e08150e3b38766f57a4af928aea1376", "html_url": "https://github.com/rust-lang/rust/commit/ea74f6845e08150e3b38766f57a4af928aea1376", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea74f6845e08150e3b38766f57a4af928aea1376/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "html_url": "https://github.com/rust-lang/rust/commit/7b7a0fc235cd2e0782302cd6fb83634e190b15b7"}, {"sha": "cce13c18fe2f5c6dcd46f91a264cd99aa77f9135", "url": "https://api.github.com/repos/rust-lang/rust/commits/cce13c18fe2f5c6dcd46f91a264cd99aa77f9135", "html_url": "https://github.com/rust-lang/rust/commit/cce13c18fe2f5c6dcd46f91a264cd99aa77f9135"}], "stats": {"total": 1434, "additions": 889, "deletions": 545}, "files": [{"sha": "2e64c0c45bffeb18099b6070eaeb9fcd4a44cce6", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea74f6845e08150e3b38766f57a4af928aea1376/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea74f6845e08150e3b38766f57a4af928aea1376/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=ea74f6845e08150e3b38766f57a4af928aea1376", "patch": "@@ -149,7 +149,7 @@ pub fn parse_input(sess: Session, cfg: ast::crate_cfg, input: &input)\n     -> @ast::crate {\n     match *input {\n       file_input(ref file) => {\n-        parse::parse_crate_from_file_using_tts(&(*file), cfg, sess.parse_sess)\n+        parse::parse_crate_from_file(&(*file), cfg, sess.parse_sess)\n       }\n       str_input(ref src) => {\n         // FIXME (#2319): Don't really want to box the source string"}, {"sha": "433809b9db291377d7b80be692a4a7c5a793f22a", "filename": "src/librustdoc/attr_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea74f6845e08150e3b38766f57a4af928aea1376/src%2Flibrustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea74f6845e08150e3b38766f57a4af928aea1376/src%2Flibrustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_parser.rs?ref=ea74f6845e08150e3b38766f57a4af928aea1376", "patch": "@@ -79,7 +79,7 @@ mod test {\n \n         let parse_sess = syntax::parse::new_parse_sess(None);\n         let parser = parse::new_parser_from_source_str(\n-            parse_sess, ~[], ~\"-\", codemap::FssNone, @source);\n+            parse_sess, ~[], ~\"-\", @source);\n \n         parser.parse_outer_attributes()\n     }"}, {"sha": "bcee2992e5ab9fb976d701926f444fe46195cac6", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea74f6845e08150e3b38766f57a4af928aea1376/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea74f6845e08150e3b38766f57a4af928aea1376/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=ea74f6845e08150e3b38766f57a4af928aea1376", "patch": "@@ -66,7 +66,7 @@ fn test_make_dir_rwx() {\n fn test_install_valid() {\n     let ctxt = fake_ctxt();\n     let temp_pkg_id = fake_pkg();\n-    let temp_workspace() = mk_temp_workspace();\n+    let temp_workspace = mk_temp_workspace();\n     // should have test, bench, lib, and main\n     ctxt.install(&temp_workspace, temp_pkg_id);\n     // Check that all files exist"}, {"sha": "c28d369e7f8ad671c0de48ad3b23963d637595a9", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ea74f6845e08150e3b38766f57a4af928aea1376/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea74f6845e08150e3b38766f57a4af928aea1376/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=ea74f6845e08150e3b38766f57a4af928aea1376", "patch": "@@ -355,6 +355,10 @@ pub fn operator_prec(op: ast::binop) -> uint {\n   }\n }\n \n+/// Precedence of the `as` operator, which is a binary operator\n+/// not appearing in the prior table.\n+pub static as_prec: uint = 11u;\n+\n pub fn dtor_ty() -> @ast::Ty {\n     @ast::Ty {id: 0, node: ty_nil, span: dummy_sp()}\n }\n@@ -756,7 +760,6 @@ mod test {\n         assert_eq!(refold_test_sc(3,&t),test_sc);\n     }\n \n-\n     // extend a syntax context with a sequence of marks given\n     // in a vector. v[0] will be the outermost mark.\n     fn unfold_marks(mrks:~[Mrk],tail:SyntaxContext,table: &mut SCTable) -> SyntaxContext {"}, {"sha": "2d6d74b5c1e324867a5d0d1e3cfed0d5b066f6fb", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea74f6845e08150e3b38766f57a4af928aea1376/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea74f6845e08150e3b38766f57a4af928aea1376/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=ea74f6845e08150e3b38766f57a4af928aea1376", "patch": "@@ -461,9 +461,7 @@ impl <K: Eq + Hash + IterBytes ,V: Copy> MapChain<K,V>{\n \n     // ugh: can't get this to compile with mut because of the\n     // lack of flow sensitivity.\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n+    #[cfg(not(stage0))]\n     fn get_map<'a>(&'a self) -> &'a HashMap<K,@V> {\n         match *self {\n             BaseMapChain (~ref map) => map,"}, {"sha": "6cf7bba600ec03f760e6854c5bcaec9c9bc42f64", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea74f6845e08150e3b38766f57a4af928aea1376/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea74f6845e08150e3b38766f57a4af928aea1376/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=ea74f6845e08150e3b38766f57a4af928aea1376", "patch": "@@ -69,9 +69,7 @@ impl<T> OptVec<T> {\n         }\n     }\n \n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n+    #[cfg(not(stage0))]\n     fn get<'a>(&'a self, i: uint) -> &'a T {\n         match *self {\n             Empty => fail!(fmt!(\"Invalid index %u\", i)),"}, {"sha": "cc580155d70cfd26f736c0f900270386fe6affcf", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ea74f6845e08150e3b38766f57a4af928aea1376/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea74f6845e08150e3b38766f57a4af928aea1376/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=ea74f6845e08150e3b38766f57a4af928aea1376", "patch": "@@ -62,12 +62,14 @@ impl parser_attr for Parser {\n         return attrs;\n     }\n \n+    // matches attribute = # attribute_naked\n     fn parse_attribute(&self, style: ast::attr_style) -> ast::attribute {\n         let lo = self.span.lo;\n         self.expect(&token::POUND);\n         return self.parse_attribute_naked(style, lo);\n     }\n \n+    // matches attribute_naked = [ meta_item ]\n     fn parse_attribute_naked(&self, style: ast::attr_style, lo: BytePos) ->\n         ast::attribute {\n         self.expect(&token::LBRACKET);\n@@ -86,6 +88,7 @@ impl parser_attr for Parser {\n     // is an inner attribute of the containing item or an outer attribute of\n     // the first contained item until we see the semi).\n \n+    // matches inner_attrs* outer_attr?\n     // you can make the 'next' field an Option, but the result is going to be\n     // more useful as a vector.\n     fn parse_inner_attrs_and_next(&self) ->\n@@ -134,6 +137,9 @@ impl parser_attr for Parser {\n         (inner_attrs, next_outer_attrs)\n     }\n \n+    // matches meta_item = IDENT\n+    // | IDENT = lit\n+    // | IDENT meta_seq\n     fn parse_meta_item(&self) -> @ast::meta_item {\n         let lo = self.span.lo;\n         let name = self.id_to_str(self.parse_ident());\n@@ -156,6 +162,7 @@ impl parser_attr for Parser {\n         }\n     }\n \n+    // matches meta_seq = ( COMMASEP(meta_item) )\n     fn parse_meta_seq(&self) -> ~[@ast::meta_item] {\n         copy self.parse_seq(\n             &token::LPAREN,"}, {"sha": "e04914c0f1e83f4d0aabe94ee2df7109fc133e87", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ea74f6845e08150e3b38766f57a4af928aea1376/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea74f6845e08150e3b38766f57a4af928aea1376/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=ea74f6845e08150e3b38766f57a4af928aea1376", "patch": "@@ -15,6 +15,13 @@\n use ast;\n use codemap;\n \n+// does this expression require a semicolon to be treated\n+// as a statement? The negation of this: 'can this expression\n+// be used as a statement without a semicolon' -- is used\n+// as an early-bail-out in the parser so that, for instance,\n+// 'if true {...} else {...}\n+//  |x| 5 '\n+// isn't parsed as (if true {...} else {...} | x) | 5\n pub fn expr_requires_semi_to_be_stmt(e: @ast::expr) -> bool {\n     match e.node {\n       ast::expr_if(*)\n@@ -40,6 +47,9 @@ pub fn expr_is_simple_block(e: @ast::expr) -> bool {\n     }\n }\n \n+// this statement requires a semicolon after it.\n+// note that in one case (stmt_semi), we've already\n+// seen the semicolon, and thus don't need another.\n pub fn stmt_ends_with_semi(stmt: &ast::stmt) -> bool {\n     return match stmt.node {\n         ast::stmt_decl(d, _) => {"}, {"sha": "4e29c3dcf183b4bd738e5bd74fe132d8211791ad", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea74f6845e08150e3b38766f57a4af928aea1376/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea74f6845e08150e3b38766f57a4af928aea1376/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=ea74f6845e08150e3b38766f57a4af928aea1376", "patch": "@@ -309,6 +309,8 @@ pub struct lit {\n     pos: BytePos\n }\n \n+// it appears this function is called only from pprust... that's\n+// probably not a good thing.\n pub fn gather_comments_and_literals(span_diagnostic:\n                                     @diagnostic::span_handler,\n                                     path: ~str,"}, {"sha": "60d6ce504fd9aa9b554cf422ac1d9a814d4eadfa", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ea74f6845e08150e3b38766f57a4af928aea1376/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea74f6845e08150e3b38766f57a4af928aea1376/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=ea74f6845e08150e3b38766f57a4af928aea1376", "patch": "@@ -225,20 +225,12 @@ pub fn is_whitespace(c: char) -> bool {\n     return c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\n }\n \n-fn may_begin_ident(c: char) -> bool { return is_alpha(c) || c == '_'; }\n-\n fn in_range(c: char, lo: char, hi: char) -> bool {\n     return lo <= c && c <= hi\n }\n \n-fn is_alpha(c: char) -> bool {\n-    return in_range(c, 'a', 'z') || in_range(c, 'A', 'Z');\n-}\n-\n fn is_dec_digit(c: char) -> bool { return in_range(c, '0', '9'); }\n \n-fn is_alnum(c: char) -> bool { return is_alpha(c) || is_dec_digit(c); }\n-\n fn is_hex_digit(c: char) -> bool {\n     return in_range(c, '0', '9') || in_range(c, 'a', 'f') ||\n             in_range(c, 'A', 'F');\n@@ -294,6 +286,8 @@ fn consume_any_line_comment(rdr: @mut StringReader)\n         }\n     } else if rdr.curr == '#' {\n         if nextch(rdr) == '!' {\n+            // I guess this is the only way to figure out if\n+            // we're at the beginning of the file...\n             let cmap = @CodeMap::new();\n             (*cmap).files.push(rdr.filemap);\n             let loc = cmap.lookup_char_pos_adj(rdr.last_pos);\n@@ -444,8 +438,7 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n         }\n     }\n     let mut is_float = false;\n-    if rdr.curr == '.' && !(is_alpha(nextch(rdr)) || nextch(rdr) == '_' ||\n-                            nextch(rdr) == '.') {\n+    if rdr.curr == '.' && !(ident_start(nextch(rdr)) || nextch(rdr) == '.') {\n         is_float = true;\n         bump(rdr);\n         let dec_part = scan_digits(rdr, 10u);"}, {"sha": "d27d788e23a953ebde9cbec7387a69449dcdba65", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 382, "deletions": 114, "changes": 496, "blob_url": "https://github.com/rust-lang/rust/blob/ea74f6845e08150e3b38766f57a4af928aea1376/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea74f6845e08150e3b38766f57a4af928aea1376/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=ea74f6845e08150e3b38766f57a4af928aea1376", "patch": "@@ -13,7 +13,7 @@\n \n use ast::node_id;\n use ast;\n-use codemap::{span, CodeMap};\n+use codemap::{span, CodeMap, FileMap, FileSubstr};\n use codemap;\n use diagnostic::{span_handler, mk_span_handler, mk_handler, Emitter};\n use parse::attr::parser_attr;\n@@ -22,7 +22,7 @@ use parse::parser::Parser;\n use parse::token::{ident_interner, mk_ident_interner};\n \n use core::io;\n-use core::option::{None, Option};\n+use core::option::{None, Option, Some};\n use core::path::Path;\n use core::result::{Err, Ok, Result};\n \n@@ -36,9 +36,6 @@ pub mod attr;\n /// Common routines shared by parser mods\n pub mod common;\n \n-/// Functions dealing with operator precedence\n-pub mod prec;\n-\n /// Routines the parser uses to classify AST nodes\n pub mod classify;\n \n@@ -82,31 +79,15 @@ pub fn new_parse_sess_special_handler(sh: @span_handler,\n // uses a HOF to parse anything, and <source> includes file and\n // source_str.\n \n-// this appears to be the main entry point for rust parsing by\n-// rustc and crate:\n pub fn parse_crate_from_file(\n     input: &Path,\n     cfg: ast::crate_cfg,\n     sess: @mut ParseSess\n ) -> @ast::crate {\n-    let p = new_parser_from_file(sess, /*bad*/ copy cfg, input);\n-    p.parse_crate_mod(/*bad*/ copy cfg)\n-    // why is there no p.abort_if_errors here?\n-}\n-\n-pub fn parse_crate_from_file_using_tts(\n-    input: &Path,\n-    cfg: ast::crate_cfg,\n-    sess: @mut ParseSess\n-) -> @ast::crate {\n-    let p = new_parser_from_file(sess, /*bad*/ copy cfg, input);\n-    let tts = p.parse_all_token_trees();\n-    new_parser_from_tts(sess,cfg,tts).parse_crate_mod(/*bad*/ copy cfg)\n+    new_parser_from_file(sess, /*bad*/ copy cfg, input).parse_crate_mod()\n     // why is there no p.abort_if_errors here?\n }\n \n-\n-\n pub fn parse_crate_from_source_str(\n     name: ~str,\n     source: @~str,\n@@ -117,10 +98,9 @@ pub fn parse_crate_from_source_str(\n         sess,\n         /*bad*/ copy cfg,\n         /*bad*/ copy name,\n-        codemap::FssNone,\n         source\n     );\n-    maybe_aborted(p.parse_crate_mod(/*bad*/ copy cfg),p)\n+    maybe_aborted(p.parse_crate_mod(),p)\n }\n \n pub fn parse_expr_from_source_str(\n@@ -133,7 +113,6 @@ pub fn parse_expr_from_source_str(\n         sess,\n         cfg,\n         /*bad*/ copy name,\n-        codemap::FssNone,\n         source\n     );\n     maybe_aborted(p.parse_expr(), p)\n@@ -150,7 +129,6 @@ pub fn parse_item_from_source_str(\n         sess,\n         cfg,\n         /*bad*/ copy name,\n-        codemap::FssNone,\n         source\n     );\n     maybe_aborted(p.parse_item(attrs),p)\n@@ -166,7 +144,6 @@ pub fn parse_meta_from_source_str(\n         sess,\n         cfg,\n         /*bad*/ copy name,\n-        codemap::FssNone,\n         source\n     );\n     maybe_aborted(p.parse_meta_item(),p)\n@@ -183,7 +160,6 @@ pub fn parse_stmt_from_source_str(\n         sess,\n         cfg,\n         /*bad*/ copy name,\n-        codemap::FssNone,\n         source\n     );\n     maybe_aborted(p.parse_stmt(attrs),p)\n@@ -199,21 +175,26 @@ pub fn parse_tts_from_source_str(\n         sess,\n         cfg,\n         /*bad*/ copy name,\n-        codemap::FssNone,\n         source\n     );\n     *p.quote_depth += 1u;\n+    // right now this is re-creating the token trees from ... token trees.\n     maybe_aborted(p.parse_all_token_trees(),p)\n }\n \n+// given a function and parsing information (source str,\n+// filename, crate cfg, and sess), create a parser,\n+// apply the function, and check that the parser\n+// consumed all of the input before returning the function's\n+// result.\n pub fn parse_from_source_str<T>(\n     f: &fn(&Parser) -> T,\n     name: ~str, ss: codemap::FileSubstr,\n     source: @~str,\n     cfg: ast::crate_cfg,\n     sess: @mut ParseSess\n ) -> T {\n-    let p = new_parser_from_source_str(\n+    let p = new_parser_from_source_substr(\n         sess,\n         cfg,\n         name,\n@@ -227,6 +208,7 @@ pub fn parse_from_source_str<T>(\n     maybe_aborted(r,p)\n }\n \n+// return the next unused node id.\n pub fn next_node_id(sess: @mut ParseSess) -> node_id {\n     let rv = sess.next_id;\n     sess.next_id += 1;\n@@ -235,39 +217,24 @@ pub fn next_node_id(sess: @mut ParseSess) -> node_id {\n     return rv;\n }\n \n+// Create a new parser from a source string\n pub fn new_parser_from_source_str(sess: @mut ParseSess,\n                                   cfg: ast::crate_cfg,\n                                   name: ~str,\n-                                  ss: codemap::FileSubstr,\n                                   source: @~str)\n                                -> Parser {\n-    let filemap = sess.cm.new_filemap_w_substr(name, ss, source);\n-    let srdr = lexer::new_string_reader(\n-        copy sess.span_diagnostic,\n-        filemap,\n-        sess.interner\n-    );\n-    Parser(sess, cfg, srdr as @reader)\n+    filemap_to_parser(sess,string_to_filemap(sess,source,name),cfg)\n }\n \n-/// Read the entire source file, return a parser\n-/// that draws from that string\n-pub fn new_parser_result_from_file(\n-    sess: @mut ParseSess,\n-    cfg: ast::crate_cfg,\n-    path: &Path\n-) -> Result<Parser, ~str> {\n-    match io::read_whole_file_str(path) {\n-        Ok(src) => {\n-            let filemap = sess.cm.new_filemap(path.to_str(), @src);\n-            let srdr = lexer::new_string_reader(copy sess.span_diagnostic,\n-                                                filemap,\n-                                                sess.interner);\n-            Ok(Parser(sess, cfg, srdr as @reader))\n-\n-        }\n-        Err(e) => Err(e)\n-    }\n+// Create a new parser from a source string where the origin\n+// is specified as a substring of another file.\n+pub fn new_parser_from_source_substr(sess: @mut ParseSess,\n+                                  cfg: ast::crate_cfg,\n+                                  name: ~str,\n+                                  ss: codemap::FileSubstr,\n+                                  source: @~str)\n+                               -> Parser {\n+    filemap_to_parser(sess,substring_to_filemap(sess,source,name,ss),cfg)\n }\n \n /// Create a new parser, handling errors as appropriate\n@@ -277,35 +244,85 @@ pub fn new_parser_from_file(\n     cfg: ast::crate_cfg,\n     path: &Path\n ) -> Parser {\n-    match new_parser_result_from_file(sess, cfg, path) {\n-        Ok(parser) => parser,\n-        Err(e) => {\n-            sess.span_diagnostic.handler().fatal(e)\n-        }\n-    }\n+    filemap_to_parser(sess,file_to_filemap(sess,path,None),cfg)\n }\n \n-/// Create a new parser based on a span from an existing parser. Handles\n-/// error messages correctly when the file does not exist.\n+/// Given a session, a crate config, a path, and a span, add\n+/// the file at the given path to the codemap, and return a parser.\n+/// On an error, use the given span as the source of the problem.\n pub fn new_sub_parser_from_file(\n     sess: @mut ParseSess,\n     cfg: ast::crate_cfg,\n     path: &Path,\n     sp: span\n ) -> Parser {\n-    match new_parser_result_from_file(sess, cfg, path) {\n-        Ok(parser) => parser,\n+    filemap_to_parser(sess,file_to_filemap(sess,path,Some(sp)),cfg)\n+}\n+\n+/// Given a filemap and config, return a parser\n+pub fn filemap_to_parser(sess: @mut ParseSess,\n+                         filemap: @FileMap,\n+                         cfg: ast::crate_cfg) -> Parser {\n+    tts_to_parser(sess,filemap_to_tts(sess,filemap),cfg)\n+}\n+\n+// must preserve old name for now, because quote! from the *existing*\n+// compiler expands into it\n+pub fn new_parser_from_tts(sess: @mut ParseSess,\n+                     cfg: ast::crate_cfg,\n+                     tts: ~[ast::token_tree]) -> Parser {\n+    tts_to_parser(sess,tts,cfg)\n+}\n+\n+\n+// base abstractions\n+\n+/// Given a session and a path and an optional span (for error reporting),\n+/// add the path to the session's codemap and return the new filemap.\n+pub fn file_to_filemap(sess: @mut ParseSess, path: &Path, spanopt: Option<span>)\n+    -> @FileMap {\n+    match io::read_whole_file_str(path) {\n+        Ok(src) => string_to_filemap(sess, @src, path.to_str()),\n         Err(e) => {\n-            sess.span_diagnostic.span_fatal(sp, e)\n+            match spanopt {\n+                Some(span) => sess.span_diagnostic.span_fatal(span, e),\n+                None => sess.span_diagnostic.handler().fatal(e)\n+            }\n         }\n     }\n }\n \n-pub fn new_parser_from_tts(\n-    sess: @mut ParseSess,\n-    cfg: ast::crate_cfg,\n-    tts: ~[ast::token_tree]\n-) -> Parser {\n+// given a session and a string, add the string to\n+// the session's codemap and return the new filemap\n+pub fn string_to_filemap(sess: @mut ParseSess, source: @~str, path: ~str)\n+    -> @FileMap {\n+    sess.cm.new_filemap(path, source)\n+}\n+\n+// given a session and a string and a path and a FileSubStr, add\n+// the string to the CodeMap and return the new FileMap\n+pub fn substring_to_filemap(sess: @mut ParseSess, source: @~str, path: ~str,\n+                           filesubstr: FileSubstr) -> @FileMap {\n+    sess.cm.new_filemap_w_substr(path,filesubstr,source)\n+}\n+\n+// given a filemap, produce a sequence of token-trees\n+pub fn filemap_to_tts(sess: @mut ParseSess, filemap: @FileMap)\n+    -> ~[ast::token_tree] {\n+    // it appears to me that the cfg doesn't matter here... indeed,\n+    // parsing tt's probably shouldn't require a parser at all.\n+    let cfg = ~[];\n+    let srdr = lexer::new_string_reader(copy sess.span_diagnostic,\n+                                        filemap,\n+                                        sess.interner);\n+    let p1 = Parser(sess, cfg, srdr as @reader);\n+    p1.parse_all_token_trees()\n+}\n+\n+// given tts and cfg, produce a parser\n+pub fn tts_to_parser(sess: @mut ParseSess,\n+                     tts: ~[ast::token_tree],\n+                     cfg: ast::crate_cfg) -> Parser {\n     let trdr = lexer::new_tt_reader(\n         copy sess.span_diagnostic,\n         sess.interner,\n@@ -329,8 +346,77 @@ mod test {\n     use std::serialize::Encodable;\n     use std;\n     use core::io;\n+    use core::option::Option;\n+    use core::option::Some;\n     use core::option::None;\n+    use core::int;\n+    use core::num::NumCast;\n+    use core::path::Path;\n+    use codemap::{dummy_sp, CodeMap, span, BytePos, spanned};\n+    use opt_vec;\n     use ast;\n+    use abi;\n+    use ast_util::mk_ident;\n+    use parse::parser::Parser;\n+    use parse::token::{ident_interner, mk_ident_interner, mk_fresh_ident_interner};\n+    use diagnostic::{span_handler, mk_span_handler, mk_handler, Emitter};\n+\n+    // add known names to interner for testing\n+    fn mk_testing_interner() -> @ident_interner {\n+        let i = mk_fresh_ident_interner();\n+        // baby hack; in order to put the identifiers\n+        // 'a' and 'b' at known locations, we're going\n+        // to fill up the interner to length 100. If\n+        // the # of preloaded items on the interner\n+        // ever gets larger than 100, we'll have to\n+        // adjust this number (say, to 200) and\n+        // change the numbers in the identifier\n+        // test cases below.\n+\n+        assert!(i.len() < 100);\n+        for int::range(0,100-((i.len()).to_int())) |_dc| {\n+            i.gensym(@~\"dontcare\");\n+        }\n+        i.intern(@~\"a\");\n+        i.intern(@~\"b\");\n+        i.intern(@~\"c\");\n+        i.intern(@~\"d\");\n+        i.intern(@~\"return\");\n+        assert!(i.get(ast::ident{repr:101,ctxt:0}) == @~\"b\");\n+        i\n+    }\n+\n+    // make a parse_sess that's closed over a\n+    // testing interner (where a -> 100, b -> 101)\n+    fn mk_testing_parse_sess() -> @mut ParseSess {\n+        let interner = mk_testing_interner();\n+        let cm = @CodeMap::new();\n+        @mut ParseSess {\n+            cm: cm,\n+            next_id: 1,\n+            span_diagnostic: mk_span_handler(mk_handler(None), cm),\n+            interner: interner,\n+        }\n+    }\n+\n+    // map a string to tts, using a made-up filename: return both the token_trees\n+    // and the ParseSess\n+    fn string_to_tts_t (source_str : @~str) -> (~[ast::token_tree],@mut ParseSess) {\n+        let ps = mk_testing_parse_sess();\n+        (filemap_to_tts(ps,string_to_filemap(ps,source_str,~\"bogofile\")),ps)\n+    }\n+\n+    // map a string to tts, return the tt without its parsesess\n+    fn string_to_tts_only(source_str : @~str) -> ~[ast::token_tree] {\n+        let (tts,ps) = string_to_tts_t(source_str);\n+        tts\n+    }\n+\n+    // map string to parser (via tts)\n+    fn string_to_parser(source_str: @~str) -> Parser {\n+        let ps = mk_testing_parse_sess();\n+        new_parser_from_source_str(ps,~[],~\"bogofile\",source_str)\n+    }\n \n     #[test] fn to_json_str<E : Encodable<std::json::Encoder>>(val: @E) -> ~str {\n         do io::with_str_writer |writer| {\n@@ -339,49 +425,71 @@ mod test {\n     }\n \n     fn string_to_crate (source_str : @~str) -> @ast::crate {\n-        parse_crate_from_source_str(\n-            ~\"bogofile\",\n-            source_str,\n-            ~[],\n-            new_parse_sess(None))\n+        string_to_parser(source_str).parse_crate_mod()\n     }\n \n-    fn string_to_tt_to_crate (source_str : @~str) -> @ast::crate {\n-        let tts = parse_tts_from_source_str(\n-            ~\"bogofile\",\n-           source_str,\n-           ~[],\n-           new_parse_sess(None));\n-        new_parser_from_tts(new_parse_sess(None),~[],tts)\n-            .parse_crate_mod(~[])\n+    fn string_to_expr (source_str : @~str) -> @ast::expr {\n+        string_to_parser(source_str).parse_expr()\n     }\n \n-    // make sure that parsing from TTs produces the same result\n-    // as parsing from strings\n-    #[test] fn tts_produce_the_same_result () {\n-        let source_str = @~\"fn foo (x : int) { x; }\";\n-        assert_eq!(string_to_tt_to_crate(source_str),\n-                     string_to_crate(source_str));\n+    fn string_to_item (source_str : @~str) -> Option<@ast::item> {\n+        string_to_parser(source_str).parse_item(~[])\n     }\n \n-    // check the contents of the tt manually:\n-    #[test] fn alltts () {\n-        let source_str = @~\"fn foo (x : int) { x; }\";\n-        let tts = parse_tts_from_source_str(\n-            ~\"bogofile\",\n-            source_str,\n-            ~[],\n-            new_parse_sess(None));\n-        assert_eq!(\n-            to_json_str(@tts),\n-            ~\"[\\\n+    fn string_to_stmt (source_str : @~str) -> @ast::stmt {\n+        string_to_parser(source_str).parse_stmt(~[])\n+    }\n+\n+    // produce a codemap::span\n+    fn sp (a: uint, b: uint) -> span {\n+        span{lo:BytePos(a),hi:BytePos(b),expn_info:None}\n+    }\n+\n+    // convert a vector of uints to a vector of ast::idents\n+    fn ints_to_idents(ids: ~[uint]) -> ~[ast::ident] {\n+        ids.map(|u| mk_ident(*u))\n+    }\n+\n+    #[test] fn path_exprs_1 () {\n+        assert_eq!(string_to_expr(@~\"a\"),\n+                   @ast::expr{id:1,\n+                              callee_id:2,\n+                              node:ast::expr_path(@ast::Path {span:sp(0,1),\n+                                                              global:false,\n+                                                              idents:~[mk_ident(100)],\n+                                                              rp:None,\n+                                                              types:~[]}),\n+                              span:sp(0,1)})\n+    }\n+\n+    #[test] fn path_exprs_2 () {\n+        assert_eq!(string_to_expr(@~\"::a::b\"),\n+                   @ast::expr{id:1,\n+                               callee_id:2,\n+                               node:ast::expr_path(@ast::Path {span:sp(0,6),\n+                                                               global:true,\n+                                                               idents:ints_to_idents(~[100,101]),\n+                                                               rp:None,\n+                                                               types:~[]}),\n+                              span:sp(0,6)})\n+    }\n+\n+    #[should_fail]\n+    #[test] fn bad_path_expr_1() {\n+        string_to_expr(@~\"::abc::def::return\");\n+    }\n+\n+    #[test] fn string_to_tts_1 () {\n+        let (tts,ps) = string_to_tts_t(@~\"fn a (b : int) { b; }\");\n+        assert_eq!(to_json_str(@tts),\n+                   ~\"[\\\n                 [\\\"tt_tok\\\",null,[\\\"IDENT\\\",\\\"fn\\\",false]],\\\n-                [\\\"tt_tok\\\",null,[\\\"IDENT\\\",\\\"foo\\\",false]],\\\n+                [\\\"tt_tok\\\",null,[\\\"IDENT\\\",\\\"a\\\",false]],\\\n                 [\\\n                     \\\"tt_delim\\\",\\\n                     [\\\n                         [\\\"tt_tok\\\",null,\\\"LPAREN\\\"],\\\n-                        [\\\"tt_tok\\\",null,[\\\"IDENT\\\",\\\"x\\\",false]],\\\n+                        [\\\"tt_tok\\\",null,[\\\"IDENT\\\",\\\"b\\\",false]],\\\n                         [\\\"tt_tok\\\",null,\\\"COLON\\\"],\\\n                         [\\\"tt_tok\\\",null,[\\\"IDENT\\\",\\\"int\\\",false]],\\\n                         [\\\"tt_tok\\\",null,\\\"RPAREN\\\"]\\\n@@ -391,21 +499,181 @@ mod test {\n                     \\\"tt_delim\\\",\\\n                     [\\\n                         [\\\"tt_tok\\\",null,\\\"LBRACE\\\"],\\\n-                        [\\\"tt_tok\\\",null,[\\\"IDENT\\\",\\\"x\\\",false]],\\\n+                        [\\\"tt_tok\\\",null,[\\\"IDENT\\\",\\\"b\\\",false]],\\\n                         [\\\"tt_tok\\\",null,\\\"SEMI\\\"],\\\n                         [\\\"tt_tok\\\",null,\\\"RBRACE\\\"]\\\n                     ]\\\n                 ]\\\n             ]\"\n-        );\n-        let ast1 = new_parser_from_tts(new_parse_sess(None),~[],tts)\n-            .parse_item(~[]);\n-        let ast2 = parse_item_from_source_str(\n-            ~\"bogofile\",\n-            @~\"fn foo (x : int) { x; }\",\n-            ~[],~[],\n-            new_parse_sess(None));\n-        assert_eq!(ast1,ast2);\n+                  );\n+    }\n+\n+    #[test] fn ret_expr() {\n+        assert_eq!(string_to_expr(@~\"return d\"),\n+                   @ast::expr{id:3,\n+                              callee_id:4,\n+                              node:ast::expr_ret(\n+                                  Some(@ast::expr{id:1,callee_id:2,\n+                                                  node:ast::expr_path(\n+                                                      @ast::Path{span:sp(7,8),\n+                                                                 global:false,\n+                                                                 idents:~[mk_ident(103)],\n+                                                                 rp:None,\n+                                                                 types:~[]\n+                                                                }),\n+                                                  span:sp(7,8)})),\n+                              span:sp(0,8)})\n+    }\n+\n+    #[test] fn parse_stmt_1 () {\n+        assert_eq!(string_to_stmt(@~\"b;\"),\n+                   @spanned{\n+                       node: ast::stmt_expr(@ast::expr{\n+                           id: 1,\n+                           callee_id: 2,\n+                           node: ast::expr_path(\n+                               @ast::Path{\n+                                   span:sp(0,1),\n+                                   global:false,\n+                                   idents:~[mk_ident(101)],\n+                                   rp:None,\n+                                   types: ~[]}),\n+                           span: sp(0,1)},\n+                                            3), // fixme\n+                       span: sp(0,1)})\n+\n+    }\n+\n+    fn parser_done(p: Parser){\n+        assert_eq!(*p.token,token::EOF);\n+    }\n+\n+    #[test] fn parse_ident_pat () {\n+        let parser = string_to_parser(@~\"b\");\n+        assert_eq!(parser.parse_pat(false),\n+                   @ast::pat{id:1, // fixme\n+                             node: ast::pat_ident(ast::bind_by_copy,\n+                                                  @ast::Path{\n+                                                      span:sp(0,1),\n+                                                      global:false,\n+                                                      idents:~[mk_ident(101)],\n+                                                      rp: None,\n+                                                      types: ~[]},\n+                                                  None // no idea\n+                                                 ),\n+                             span: sp(0,1)});\n+        parser_done(parser);\n+    }\n+\n+    #[test] fn parse_arg () {\n+        let parser = string_to_parser(@~\"b : int\");\n+        assert_eq!(parser.parse_arg_general(true),\n+                   ast::arg{\n+                       mode: ast::infer(1),\n+                       is_mutbl: false,\n+                       ty: @ast::Ty{id:4, // fixme\n+                                    node: ast::ty_path(@ast::Path{\n+                                        span:sp(4,4), // this is bizarre...\n+                                        // check this in the original parser?\n+                                        global:false,\n+                                        idents:~[mk_ident(105)],\n+                                        rp: None,\n+                                        types: ~[]},\n+                                                       3),\n+                                    span:sp(4,7)},\n+                       pat: @ast::pat{id:2,\n+                                      node: ast::pat_ident(ast::bind_by_copy,\n+                                                           @ast::Path{\n+                                                               span:sp(0,1),\n+                                                               global:false,\n+                                                               idents:~[mk_ident(101)],\n+                                                               rp: None,\n+                                                               types: ~[]},\n+                                                           None // no idea\n+                                                          ),\n+                                      span: sp(0,3)}, // really?\n+                       id: 5 // fixme\n+                   })\n+    }\n+\n+    // check the contents of the tt manually:\n+    #[test] fn parse_fundecl () {\n+        // this test depends on the intern order of \"fn\" and \"int\", and on the\n+        // assignment order of the node_ids.\n+        assert_eq!(string_to_item(@~\"fn a (b : int) { b; }\"),\n+                  Some(\n+                      @ast::item{ident:mk_ident(100),\n+                            attrs:~[],\n+                            id: 11, // fixme\n+                            node: ast::item_fn(ast::fn_decl{\n+                                inputs: ~[ast::arg{\n+                                    mode: ast::infer(1),\n+                                    is_mutbl: false,\n+                                    ty: @ast::Ty{id:4, // fixme\n+                                                node: ast::ty_path(@ast::Path{\n+                                        span:sp(10,13),\n+                                        global:false,\n+                                        idents:~[mk_ident(106)],\n+                                        rp: None,\n+                                        types: ~[]},\n+                                                       3),\n+                                                span:sp(10,13)},\n+                                    pat: @ast::pat{id:2, // fixme\n+                                                   node: ast::pat_ident(\n+                                                       ast::bind_by_copy,\n+                                                       @ast::Path{\n+                                                           span:sp(6,7),\n+                                                           global:false,\n+                                                           idents:~[mk_ident(101)],\n+                                                           rp: None,\n+                                                           types: ~[]},\n+                                                       None // no idea\n+                                                   ),\n+                                                  span: sp(6,9)}, // bleah.\n+                                    id: 5 // fixme\n+                                }],\n+                                output: @ast::Ty{id:6, // fixme\n+                                                 node: ast::ty_nil,\n+                                                 span:sp(15,15)}, // not sure\n+                                cf: ast::return_val\n+                            },\n+                                    ast::impure_fn,\n+                                    abi::AbiSet::Rust(),\n+                                    ast::Generics{ // no idea on either of these:\n+                                        lifetimes: opt_vec::Empty,\n+                                        ty_params: opt_vec::Empty,\n+                                    },\n+                                    spanned{\n+                                        span: sp(15,21),\n+                                        node: ast::blk_{\n+                                            view_items: ~[],\n+                                            stmts: ~[@spanned{\n+                                                node: ast::stmt_semi(@ast::expr{\n+                                                    id: 7,\n+                                                    callee_id: 8,\n+                                                    node: ast::expr_path(\n+                                                        @ast::Path{\n+                                                            span:sp(17,18),\n+                                                            global:false,\n+                                                            idents:~[mk_ident(101)],\n+                                                            rp:None,\n+                                                            types: ~[]}),\n+                                                    span: sp(17,18)},\n+                                                                     9), // fixme\n+                                                span: sp(17,18)}],\n+                                            expr: None,\n+                                            id: 10, // fixme\n+                                            rules: ast::default_blk // no idea\n+                                        }}),\n+                            vis: ast::inherited,\n+                            span: sp(0,21)}));\n+    }\n+\n+\n+    #[test] fn parse_exprs () {\n+        // just make sure that they parse....\n+        string_to_expr(@~\"3 + 4\");\n+        string_to_expr(@~\"a::z.froob(b,@(987+3))\");\n     }\n }\n "}, {"sha": "ce21e0f672d454d14b1cf666352f3ffa2a6e2953", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea74f6845e08150e3b38766f57a4af928aea1376/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea74f6845e08150e3b38766f57a4af928aea1376/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=ea74f6845e08150e3b38766f57a4af928aea1376", "patch": "@@ -259,7 +259,7 @@ pub impl Parser {\n     fn try_parse_obsolete_struct_ctor(&self) -> bool {\n         if self.eat_obsolete_ident(\"new\") {\n             self.obsolete(*self.last_span, ObsoleteStructCtor);\n-            self.parse_fn_decl(|p| p.parse_arg());\n+            self.parse_fn_decl();\n             self.parse_block();\n             true\n         } else {\n@@ -288,7 +288,7 @@ pub impl Parser {\n             self.eat_keyword(&~\"priv\");\n             self.bump();\n             while *self.token != token::RBRACE {\n-                self.parse_single_class_item(ast::private);\n+                self.parse_single_struct_field(ast::private);\n             }\n             self.bump();\n             true"}, {"sha": "30275436c065f6560113901118b7a7453ff799e5", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 368, "deletions": 308, "changes": 676, "blob_url": "https://github.com/rust-lang/rust/blob/ea74f6845e08150e3b38766f57a4af928aea1376/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea74f6845e08150e3b38766f57a4af928aea1376/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ea74f6845e08150e3b38766f57a4af928aea1376", "patch": "@@ -58,7 +58,7 @@ use ast::{view_item_, view_item_extern_mod, view_item_use};\n use ast::{view_path, view_path_glob, view_path_list, view_path_simple};\n use ast::visibility;\n use ast;\n-use ast_util::{ident_to_path, operator_prec};\n+use ast_util::{as_prec, ident_to_path, operator_prec};\n use ast_util;\n use codemap::{span, BytePos, spanned, mk_sp};\n use codemap;\n@@ -82,9 +82,8 @@ use parse::obsolete::ObsoleteMode;\n use parse::obsolete::{ObsoleteLifetimeNotation, ObsoleteConstManagedPointer};\n use parse::obsolete::{ObsoletePurity, ObsoleteStaticMethod};\n use parse::obsolete::{ObsoleteConstItem, ObsoleteFixedLengthVectorType};\n-use parse::prec::{as_prec, token_to_binop};\n use parse::token::{can_begin_expr, is_ident, is_ident_or_path};\n-use parse::token::{is_plain_ident, INTERPOLATED, special_idents};\n+use parse::token::{is_plain_ident, INTERPOLATED, special_idents, token_to_binop};\n use parse::token;\n use parse::{new_sub_parser_from_file, next_node_id, ParseSess};\n use opt_vec;\n@@ -99,7 +98,6 @@ use core::vec;\n enum restriction {\n     UNRESTRICTED,\n     RESTRICT_STMT_EXPR,\n-    RESTRICT_NO_CALL_EXPRS,\n     RESTRICT_NO_BAR_OP,\n     RESTRICT_NO_BAR_OR_DOUBLEBAR_OP,\n }\n@@ -369,7 +367,7 @@ pub impl Parser {\n \n         let opt_abis = self.parse_opt_abis();\n         let abis = opt_abis.get_or_default(AbiSet::Rust());\n-        let purity = self.parse_purity();\n+        let purity = self.parse_unsafety();\n         self.expect_keyword(&~\"fn\");\n         let (decl, lifetimes) = self.parse_ty_fn_decl();\n         return ty_bare_fn(@TyBareFn {\n@@ -403,7 +401,7 @@ pub impl Parser {\n         // At this point, the allocation type and lifetime bound have been\n         // parsed.\n \n-        let purity = self.parse_purity();\n+        let purity = self.parse_unsafety();\n         let onceness = parse_onceness(self);\n         self.expect_keyword(&~\"fn\");\n \n@@ -428,7 +426,8 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_purity(&self) -> purity {\n+    // looks like this should be called parse_unsafety\n+    fn parse_unsafety(&self) -> purity {\n         if self.eat_keyword(&~\"pure\") {\n             self.obsolete(*self.last_span, ObsoletePurity);\n             return impure_fn;\n@@ -474,6 +473,7 @@ pub impl Parser {\n         (decl, lifetimes)\n     }\n \n+    // parse the methods in a trait declaration\n     fn parse_trait_methods(&self) -> ~[trait_method] {\n         do self.parse_unspanned_seq(\n             &token::LBRACE,\n@@ -521,7 +521,7 @@ pub impl Parser {\n               token::LBRACE => {\n                 debug!(\"parse_trait_methods(): parsing provided method\");\n                 let (inner_attrs, body) =\n-                    p.parse_inner_attrs_and_block(true);\n+                    p.parse_inner_attrs_and_block();\n                 let attrs = vec::append(attrs, inner_attrs);\n                 provided(@ast::method {\n                     ident: ident,\n@@ -559,6 +559,7 @@ pub impl Parser {\n     }\n \n     // parse [mut/const/imm] ID : TY\n+    // now used only by obsolete record syntax parser...\n     fn parse_ty_field(&self) -> ty_field {\n         let lo = self.span.lo;\n         let mutbl = self.parse_mutability();\n@@ -763,6 +764,7 @@ pub impl Parser {\n         return ty_rptr(opt_lifetime, mt);\n     }\n \n+    // parse an optional mode.\n     fn parse_arg_mode(&self) -> mode {\n         if self.eat(&token::BINOP(token::MINUS)) {\n             self.obsolete(*self.span, ObsoleteMode);\n@@ -829,10 +831,12 @@ pub impl Parser {\n                   ty: t, pat: pat, id: self.get_id() }\n     }\n \n+    // parse a single function argument\n     fn parse_arg(&self) -> arg_or_capture_item {\n         either::Left(self.parse_arg_general(true))\n     }\n \n+    // parse an argument in a lambda header e.g. |arg, arg|\n     fn parse_fn_block_arg(&self) -> arg_or_capture_item {\n         let m = self.parse_arg_mode();\n         let is_mutbl = self.eat_keyword(&~\"mut\");\n@@ -869,6 +873,7 @@ pub impl Parser {\n         }\n     }\n \n+    // matches token_lit = LIT_INT | ...\n     fn lit_from_token(&self, tok: &token::Token) -> lit_ {\n         match *tok {\n             token::LIT_INT(i, it) => lit_int(i, it),\n@@ -883,6 +888,7 @@ pub impl Parser {\n         }\n     }\n \n+    // matches lit = true | false | token_lit\n     fn parse_lit(&self) -> lit {\n         let lo = self.span.lo;\n         let lit = if self.eat_keyword(&~\"true\") {\n@@ -898,30 +904,45 @@ pub impl Parser {\n         codemap::spanned { node: lit, span: mk_sp(lo, self.last_span.hi) }\n     }\n \n-    // parse a path that doesn't have type parameters attached\n-    fn parse_path_without_tps(&self)\n-        -> @ast::Path {\n-        maybe_whole!(self, nt_path);\n+    // parse a path into a vector of idents, whether the path starts\n+    // with ::, and a span.\n+    fn parse_path(&self) -> (~[ast::ident],bool,span) {\n+        let lo = self.span.lo;\n+        let is_global = self.eat(&token::MOD_SEP);\n+        let (ids,span{lo:_,hi,expn_info}) = self.parse_path_non_global();\n+        (ids,is_global,span{lo:lo,hi:hi,expn_info:expn_info})\n+    }\n+\n+    // parse a path beginning with an identifier into a vector of idents and a span\n+    fn parse_path_non_global(&self) -> (~[ast::ident],span) {\n         let lo = self.span.lo;\n-        let global = self.eat(&token::MOD_SEP);\n         let mut ids = ~[];\n+        // must be at least one to begin:\n+        ids.push(self.parse_ident());\n         loop {\n-            // if there's a ::< coming, stop processing\n-            // the path.\n-            let is_not_last =\n-                self.look_ahead(2u) != token::LT\n-                && self.look_ahead(1u) == token::MOD_SEP;\n-\n-            if is_not_last {\n-                ids.push(self.parse_ident());\n-                self.expect(&token::MOD_SEP);\n-            } else {\n-                ids.push(self.parse_ident());\n-                break;\n+            match *self.token {\n+                token::MOD_SEP => {\n+                    match self.look_ahead(1u) {\n+                        token::IDENT(id,_) => {\n+                            self.bump();\n+                            ids.push(self.parse_ident());\n+                        }\n+                        _ => break\n+                    }\n+                }\n+                _ => break\n             }\n         }\n-        @ast::Path { span: mk_sp(lo, self.last_span.hi),\n-                     global: global,\n+        (ids, mk_sp(lo, self.last_span.hi))\n+    }\n+\n+    // parse a path that doesn't have type parameters attached\n+    fn parse_path_without_tps(&self)\n+        -> @ast::Path {\n+        maybe_whole!(self, nt_path);\n+        let (ids,is_global,sp) = self.parse_path();\n+        @ast::Path { span: sp,\n+                     global: is_global,\n                      idents: ids,\n                      rp: None,\n                      types: ~[] }\n@@ -1054,6 +1075,9 @@ pub impl Parser {\n         }\n     }\n \n+    // matches lifetimes = ( lifetime ) | ( lifetime , lifetimes )\n+    // actually, it matches the empty one too, but putting that in there\n+    // messes up the grammar....\n     fn parse_lifetimes(&self) -> OptVec<ast::Lifetime> {\n         /*!\n          *\n@@ -1079,7 +1103,8 @@ pub impl Parser {\n                 token::GT => { return res; }\n                 token::BINOP(token::SHR) => { return res; }\n                 _ => {\n-                    self.fatal(~\"expected `,` or `>` after lifetime name\");\n+                    self.fatal(fmt!(\"expected `,` or `>` after lifetime name, got: %?\",\n+                                    *self.token));\n                 }\n             }\n         }\n@@ -1101,11 +1126,12 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_field(&self, sep: token::Token) -> field {\n+    // parse ident COLON expr\n+    fn parse_field(&self) -> field {\n         let lo = self.span.lo;\n         let m = self.parse_mutability();\n         let i = self.parse_ident();\n-        self.expect(&sep);\n+        self.expect(&token::COLON);\n         let e = self.parse_expr();\n         spanned(lo, e.span.hi, ast::field_ { mutbl: m, ident: i, expr: e })\n     }\n@@ -1158,7 +1184,7 @@ pub impl Parser {\n             self.bump();\n             // (e) is parenthesized e\n             // (e,) is a tuple with only one field, e\n-            let mut one_tuple = false;\n+            let mut trailing_comma = false;\n             if *self.token == token::RPAREN {\n                 hi = self.span.hi;\n                 self.bump();\n@@ -1172,13 +1198,13 @@ pub impl Parser {\n                     es.push(self.parse_expr());\n                 }\n                 else {\n-                    one_tuple = true;\n+                    trailing_comma = true;\n                 }\n             }\n             hi = self.span.hi;\n             self.expect(&token::RPAREN);\n \n-            return if es.len() == 1 && !one_tuple {\n+            return if es.len() == 1 && !trailing_comma {\n                 self.mk_expr(lo, self.span.hi, expr_paren(es[0]))\n             }\n             else {\n@@ -1246,6 +1272,7 @@ pub impl Parser {\n             }\n             hi = self.span.hi;\n         } else if self.eat_keyword(&~\"__log\") {\n+            // LOG expression\n             self.expect(&token::LPAREN);\n             let lvl = self.parse_expr();\n             self.expect(&token::COMMA);\n@@ -1254,19 +1281,22 @@ pub impl Parser {\n             hi = self.span.hi;\n             self.expect(&token::RPAREN);\n         } else if self.eat_keyword(&~\"return\") {\n+            // RETURN expression\n             if can_begin_expr(&*self.token) {\n                 let e = self.parse_expr();\n                 hi = e.span.hi;\n                 ex = expr_ret(Some(e));\n             } else { ex = expr_ret(None); }\n         } else if self.eat_keyword(&~\"break\") {\n+            // BREAK expression\n             if is_ident(&*self.token) {\n                 ex = expr_break(Some(self.parse_ident()));\n             } else {\n                 ex = expr_break(None);\n             }\n             hi = self.span.hi;\n         } else if self.eat_keyword(&~\"copy\") {\n+            // COPY expression\n             let e = self.parse_expr();\n             ex = expr_copy(e);\n             hi = e.span.hi;\n@@ -1277,6 +1307,7 @@ pub impl Parser {\n \n             // `!`, as an operator, is prefix, so we know this isn't that\n             if *self.token == token::NOT {\n+                // MACRO INVOCATION expression\n                 self.bump();\n                 match *self.token {\n                     token::LPAREN | token::LBRACE => {}\n@@ -1301,7 +1332,7 @@ pub impl Parser {\n                     let mut fields = ~[];\n                     let mut base = None;\n \n-                    fields.push(self.parse_field(token::COLON));\n+                    fields.push(self.parse_field());\n                     while *self.token != token::RBRACE {\n                         if self.try_parse_obsolete_with() {\n                             break;\n@@ -1318,7 +1349,7 @@ pub impl Parser {\n                             // Accept an optional trailing comma.\n                             break;\n                         }\n-                        fields.push(self.parse_field(token::COLON));\n+                        fields.push(self.parse_field());\n                     }\n \n                     hi = pth.span.hi;\n@@ -1331,6 +1362,7 @@ pub impl Parser {\n             hi = pth.span.hi;\n             ex = expr_path(pth);\n         } else {\n+            // other literal expression\n             let lit = self.parse_lit();\n             hi = lit.span.hi;\n             ex = expr_lit(@lit);\n@@ -1339,6 +1371,7 @@ pub impl Parser {\n         return self.mk_expr(lo, hi, ex);\n     }\n \n+    // parse a block or unsafe block\n     fn parse_block_expr(\n         &self,\n         lo: BytePos,\n@@ -1349,16 +1382,12 @@ pub impl Parser {\n         return self.mk_expr(blk.span.lo, blk.span.hi, expr_block(blk));\n     }\n \n-    // parse a.b or a(13) or just a\n+    // parse a.b or a(13) or a[4] or just a\n     fn parse_dot_or_call_expr(&self) -> @expr {\n         let b = self.parse_bottom_expr();\n         self.parse_dot_or_call_expr_with(b)\n     }\n \n-    fn permits_call(&self) -> bool {\n-        return *self.restriction != RESTRICT_NO_CALL_EXPRS;\n-    }\n-\n     fn parse_dot_or_call_expr_with(&self, e0: @expr) -> @expr {\n         let mut e = e0;\n         let lo = e.span.lo;\n@@ -1379,7 +1408,7 @@ pub impl Parser {\n \n                     // expr.f() method call\n                     match *self.token {\n-                        token::LPAREN if self.permits_call() => {\n+                        token::LPAREN => {\n                             let es = self.parse_unspanned_seq(\n                                 &token::LPAREN,\n                                 &token::RPAREN,\n@@ -1403,7 +1432,7 @@ pub impl Parser {\n             if self.expr_is_complete(e) { break; }\n             match *self.token {\n               // expr(...)\n-              token::LPAREN if self.permits_call() => {\n+              token::LPAREN => {\n                 let es = self.parse_unspanned_seq(\n                     &token::LPAREN,\n                     &token::RPAREN,\n@@ -1771,10 +1800,10 @@ pub impl Parser {\n         let lo = self.span.lo;\n         let lhs = self.parse_binops();\n         match *self.token {\n-            token::EQ => {\n-                self.bump();\n-                let rhs = self.parse_expr();\n-                self.mk_expr(lo, rhs.span.hi, expr_assign(lhs, rhs))\n+          token::EQ => {\n+              self.bump();\n+              let rhs = self.parse_expr();\n+              self.mk_expr(lo, rhs.span.hi, expr_assign(lhs, rhs))\n           }\n           token::BINOPEQ(op) => {\n               self.bump();\n@@ -1815,6 +1844,7 @@ pub impl Parser {\n         }\n     }\n \n+    // parse an 'if' expression ('if' token already eaten)\n     fn parse_if_expr(&self) -> @expr {\n         let lo = self.last_span.lo;\n         let cond = self.parse_expr();\n@@ -1829,7 +1859,7 @@ pub impl Parser {\n         self.mk_expr(lo, hi, expr_if(cond, thn, els))\n     }\n \n-    // `|args| { ... }` like in `do` expressions\n+    // `|args| { ... }` or `{ ...}` like in `do` expressions\n     fn parse_lambda_block_expr(&self) -> @expr {\n         self.parse_lambda_expr_(\n             || {\n@@ -1863,6 +1893,9 @@ pub impl Parser {\n                                 || self.parse_expr())\n     }\n \n+    // parse something of the form |args| expr\n+    // this is used both in parsing a lambda expr\n+    // and in parsing a block expr as e.g. in for...\n     fn parse_lambda_expr_(\n         &self,\n         parse_decl: &fn() -> fn_decl,\n@@ -1893,6 +1926,9 @@ pub impl Parser {\n         }\n     }\n \n+    // parse a 'for' or 'do'.\n+    // the 'for' and 'do' expressions parse as calls, but look like\n+    // function calls followed by a closure expression.\n     fn parse_sugary_call_expr(&self, keyword: ~str,\n                               sugar: CallSugar,\n                               ctor: &fn(v: @expr) -> expr_) -> @expr {\n@@ -1953,7 +1989,7 @@ pub impl Parser {\n     fn parse_while_expr(&self) -> @expr {\n         let lo = self.last_span.lo;\n         let cond = self.parse_expr();\n-        let body = self.parse_block_no_value();\n+        let body = self.parse_block();\n         let hi = body.span.hi;\n         return self.mk_expr(lo, hi, expr_while(cond, body));\n     }\n@@ -1981,7 +2017,7 @@ pub impl Parser {\n             }\n \n             let lo = self.last_span.lo;\n-            let body = self.parse_block_no_value();\n+            let body = self.parse_block();\n             let hi = body.span.hi;\n             return self.mk_expr(lo, hi, expr_loop(body, opt_ident));\n         } else {\n@@ -2079,6 +2115,7 @@ pub impl Parser {\n         }\n     }\n \n+    // parse patterns, separated by '|' s\n     fn parse_pats(&self) -> ~[@pat] {\n         let mut pats = ~[];\n         loop {\n@@ -2133,6 +2170,7 @@ pub impl Parser {\n         (before, slice, after)\n     }\n \n+    // parse the fields of a struct-like pattern\n     fn parse_pat_fields(&self, refutable: bool) -> (~[ast::field_pat], bool) {\n         let mut fields = ~[];\n         let mut etc = false;\n@@ -2176,14 +2214,19 @@ pub impl Parser {\n         return (fields, etc);\n     }\n \n+    // parse a pattern. The 'refutable' argument\n+    // appears to control whether the binding_mode\n+    // 'bind_infer' or 'bind_by_copy' is used.\n     fn parse_pat(&self, refutable: bool) -> @pat {\n         maybe_whole!(self, nt_pat);\n \n         let lo = self.span.lo;\n         let mut hi = self.span.hi;\n         let pat;\n         match *self.token {\n+            // parse _\n           token::UNDERSCORE => { self.bump(); pat = pat_wild; }\n+            // parse @pat\n           token::AT => {\n             self.bump();\n             let sub = self.parse_pat(refutable);\n@@ -2207,6 +2250,7 @@ pub impl Parser {\n             };\n           }\n           token::TILDE => {\n+            // parse ~pat\n             self.bump();\n             let sub = self.parse_pat(refutable);\n             hi = sub.span.hi;\n@@ -2229,6 +2273,7 @@ pub impl Parser {\n             };\n           }\n           token::BINOP(token::AND) => {\n+              // parse &pat\n               let lo = self.span.lo;\n               self.bump();\n               let sub = self.parse_pat(refutable);\n@@ -2259,6 +2304,7 @@ pub impl Parser {\n             pat = pat_wild;\n           }\n           token::LPAREN => {\n+            // parse (pat,pat,pat,...) as tuple\n             self.bump();\n             if *self.token == token::RPAREN {\n                 hi = self.span.hi;\n@@ -2283,6 +2329,7 @@ pub impl Parser {\n             }\n           }\n           token::LBRACKET => {\n+            // parse [pat,pat,...] as vector pattern\n             self.bump();\n             let (before, slice, after) =\n                 self.parse_pat_vec_elements(refutable);\n@@ -2295,6 +2342,7 @@ pub impl Parser {\n                 || self.is_keyword(&~\"true\")\n                 || self.is_keyword(&~\"false\")\n             {\n+                // parse an expression pattern or exp .. exp\n                 let val = self.parse_expr_res(RESTRICT_NO_BAR_OP);\n                 if self.eat(&token::DOTDOT) {\n                     let end = self.parse_expr_res(RESTRICT_NO_BAR_OP);\n@@ -2303,34 +2351,39 @@ pub impl Parser {\n                     pat = pat_lit(val);\n                 }\n             } else if self.eat_keyword(&~\"ref\") {\n+                // parse ref pat\n                 let mutbl = self.parse_mutability();\n                 pat = self.parse_pat_ident(refutable, bind_by_ref(mutbl));\n             } else if self.eat_keyword(&~\"copy\") {\n+                // parse copy pat\n                 pat = self.parse_pat_ident(refutable, bind_by_copy);\n             } else {\n                 // XXX---refutable match bindings should work same as let\n                 let binding_mode =\n                     if refutable {bind_infer} else {bind_by_copy};\n \n-                let cannot_be_enum_or_struct;\n+                let can_be_enum_or_struct;\n                 match self.look_ahead(1) {\n                     token::LPAREN | token::LBRACKET | token::LT |\n                     token::LBRACE | token::MOD_SEP =>\n-                        cannot_be_enum_or_struct = false,\n+                        can_be_enum_or_struct = true,\n                     _ =>\n-                        cannot_be_enum_or_struct = true\n+                        can_be_enum_or_struct = false\n                 }\n \n-                if is_plain_ident(&*self.token) && cannot_be_enum_or_struct {\n+                if is_plain_ident(&*self.token) && !can_be_enum_or_struct {\n                     let name = self.parse_path_without_tps();\n                     let sub;\n                     if self.eat(&token::AT) {\n+                        // parse foo @ pat\n                         sub = Some(self.parse_pat(refutable));\n                     } else {\n+                        // or just foo\n                         sub = None;\n                     };\n                     pat = pat_ident(binding_mode, name, sub);\n                 } else {\n+                    // parse an enum pat\n                     let enum_path = self.parse_path_with_tps(true);\n                     match *self.token {\n                         token::LBRACE => {\n@@ -2342,14 +2395,13 @@ pub impl Parser {\n                         }\n                         _ => {\n                             let mut args: ~[@pat] = ~[];\n-                            let mut star_pat = false;\n                             match *self.token {\n                               token::LPAREN => match self.look_ahead(1u) {\n                                 token::BINOP(token::STAR) => {\n                                     // This is a \"top constructor only\" pat\n                                       self.bump(); self.bump();\n-                                      star_pat = true;\n                                       self.expect(&token::RPAREN);\n+                                      pat = pat_enum(enum_path, None);\n                                   }\n                                 _ => {\n                                     args = self.parse_unspanned_seq(\n@@ -2360,23 +2412,21 @@ pub impl Parser {\n                                         ),\n                                         |p| p.parse_pat(refutable)\n                                     );\n+                                    pat = pat_enum(enum_path, Some(args));\n                                   }\n                               },\n-                              _ => ()\n-                            }\n-                            // at this point, we're not sure whether it's a\n-                            // enum or a bind\n-                            if star_pat {\n-                                pat = pat_enum(enum_path, None);\n-                            }\n-                            else if vec::is_empty(args) &&\n-                                vec::len(enum_path.idents) == 1u {\n-                                pat = pat_ident(binding_mode,\n-                                                enum_path,\n-                                                None);\n-                            }\n-                            else {\n-                                pat = pat_enum(enum_path, Some(args));\n+                              _ => {\n+                                  if vec::len(enum_path.idents)==1u {\n+                                      // it could still be either an enum\n+                                      // or an identifier pattern, resolve\n+                                      // will sort it out:\n+                                      pat = pat_ident(binding_mode,\n+                                                      enum_path,\n+                                                      None);\n+                                  } else {\n+                                      pat = pat_enum(enum_path, Some(args));\n+                                  }\n+                              }\n                             }\n                         }\n                     }\n@@ -2388,13 +2438,16 @@ pub impl Parser {\n         @ast::pat { id: self.get_id(), node: pat, span: mk_sp(lo, hi) }\n     }\n \n+    // used by the copy foo and ref foo patterns to give a good\n+    // error message when parsing mistakes like ref foo(a,b)\n     fn parse_pat_ident(&self, refutable: bool,\n                        binding_mode: ast::binding_mode) -> ast::pat_ {\n         if !is_plain_ident(&*self.token) {\n             self.span_fatal(\n                 *self.last_span,\n                 ~\"expected identifier, found path\");\n         }\n+        // why a path here, and not just an identifier?\n         let name = self.parse_path_without_tps();\n         let sub = if self.eat(&token::AT) {\n             Some(self.parse_pat(refutable))\n@@ -2416,8 +2469,7 @@ pub impl Parser {\n     }\n \n     // parse a local variable declaration\n-    fn parse_local(&self, is_mutbl: bool,\n-                   allow_init: bool) -> @local {\n+    fn parse_local(&self, is_mutbl: bool) -> @local {\n         let lo = self.span.lo;\n         let pat = self.parse_pat(false);\n         let mut ty = @Ty {\n@@ -2426,7 +2478,7 @@ pub impl Parser {\n             span: mk_sp(lo, lo),\n         };\n         if self.eat(&token::COLON) { ty = self.parse_ty(false); }\n-        let init = if allow_init { self.parse_initializer() } else { None };\n+        let init = self.parse_initializer();\n         @spanned(\n             lo,\n             self.last_span.hi,\n@@ -2440,18 +2492,19 @@ pub impl Parser {\n         )\n     }\n \n+    // parse a \"let\" stmt\n     fn parse_let(&self) -> @decl {\n         let is_mutbl = self.eat_keyword(&~\"mut\");\n         let lo = self.span.lo;\n-        let mut locals = ~[self.parse_local(is_mutbl, true)];\n+        let mut locals = ~[self.parse_local(is_mutbl)];\n         while self.eat(&token::COMMA) {\n-            locals.push(self.parse_local(is_mutbl, true));\n+            locals.push(self.parse_local(is_mutbl));\n         }\n         return @spanned(lo, self.last_span.hi, decl_local(locals));\n     }\n \n-    /* assumes \"let\" token has already been consumed */\n-    fn parse_instance_var(&self, pr: visibility) -> @struct_field {\n+    // parse a structure field\n+    fn parse_name_and_ty(&self, pr: visibility) -> @struct_field {\n         let mut is_mutbl = struct_immutable;\n         let lo = self.span.lo;\n         if self.eat_keyword(&~\"mut\") {\n@@ -2470,6 +2523,7 @@ pub impl Parser {\n         })\n     }\n \n+    // parse a statement. may include decl\n     fn parse_stmt(&self, first_item_attrs: ~[attribute]) -> @stmt {\n         maybe_whole!(self, nt_stmt);\n \n@@ -2489,6 +2543,11 @@ pub impl Parser {\n         } else if is_ident(&*self.token)\n             && !self.is_any_keyword(&copy *self.token)\n             && self.look_ahead(1) == token::NOT {\n+            // parse a macro invocation. Looks like there's serious\n+            // overlap here; if this clause doesn't catch it (and it\n+            // won't, for brace-delimited macros) it will fall through\n+            // to the macro clause of parse_item_or_view_item. This\n+            // could use some cleanup, it appears to me.\n \n             check_expected_item(self, first_item_attrs);\n \n@@ -2530,7 +2589,7 @@ pub impl Parser {\n                                          self.parse_outer_attributes());\n \n             match self.parse_item_or_view_item(/*bad*/ copy item_attrs,\n-                                               true, false, false) {\n+                                                           false) {\n               iovi_item(i) => {\n                 let hi = i.span.hi;\n                 let decl = @spanned(lo, hi, decl_item(i));\n@@ -2554,52 +2613,41 @@ pub impl Parser {\n         }\n     }\n \n+    // is this expression a successfully-parsed statement?\n     fn expr_is_complete(&self, e: @expr) -> bool {\n         return *self.restriction == RESTRICT_STMT_EXPR &&\n             !classify::expr_requires_semi_to_be_stmt(e);\n     }\n \n+    // parse a block. No inner attrs are allowed.\n     fn parse_block(&self) -> blk {\n-        // disallow inner attrs:\n-        let (attrs, blk) = self.parse_inner_attrs_and_block(false);\n-        assert!(vec::is_empty(attrs));\n-        return blk;\n+        maybe_whole!(self, nt_block);\n+\n+        let lo = self.span.lo;\n+        if self.eat_keyword(&~\"unsafe\") {\n+            self.obsolete(copy *self.span, ObsoleteUnsafeBlock);\n+        }\n+        self.expect(&token::LBRACE);\n+\n+        return self.parse_block_tail_(lo, default_blk, ~[]);\n     }\n \n-    // I claim the existence of the 'parse_attrs' flag strongly\n-    // suggests a name-change or refactoring for this function.\n-    fn parse_inner_attrs_and_block(&self, parse_attrs: bool)\n+    // parse a block. Inner attrs are allowed.\n+    fn parse_inner_attrs_and_block(&self)\n         -> (~[attribute], blk) {\n \n         maybe_whole!(pair_empty self, nt_block);\n \n-        fn maybe_parse_inner_attrs_and_next(p: &Parser, parse_attrs: bool) ->\n-            (~[attribute], ~[attribute]) {\n-            if parse_attrs {\n-                p.parse_inner_attrs_and_next()\n-            } else {\n-                (~[], ~[])\n-            }\n-        }\n-\n         let lo = self.span.lo;\n         if self.eat_keyword(&~\"unsafe\") {\n             self.obsolete(copy *self.span, ObsoleteUnsafeBlock);\n         }\n         self.expect(&token::LBRACE);\n-        let (inner, next) =\n-            maybe_parse_inner_attrs_and_next(self, parse_attrs);\n+        let (inner, next) = self.parse_inner_attrs_and_next();\n \n         (inner, self.parse_block_tail_(lo, default_blk, next))\n     }\n \n-    fn parse_block_no_value(&self) -> blk {\n-        // We parse blocks that cannot have a value the same as any other\n-        // block; the type checker will make sure that the tail expression (if\n-        // any) has unit type.\n-        return self.parse_block();\n-    }\n-\n     // Precondition: already parsed the '{' or '#{'\n     // I guess that also means \"already parsed the 'impure'\" if\n     // necessary, and this should take a qualifier.\n@@ -2620,7 +2668,7 @@ pub impl Parser {\n             items: items,\n             _\n         } = self.parse_items_and_view_items(first_item_attrs,\n-                                            IMPORTS_AND_ITEMS_ALLOWED, false);\n+                                            false, false);\n \n         for items.each |item| {\n             let decl = @spanned(item.span.lo, item.span.hi, decl_item(*item));\n@@ -2739,6 +2787,9 @@ pub impl Parser {\n         if self.eat_keyword(&~\"once\") { ast::Once } else { ast::Many }\n     }\n \n+    // matches optbounds = ( ( : ( boundseq )? )? )\n+    // where   boundseq  = ( bound + boundseq ) | bound\n+    // and     bound     = 'static | ty\n     fn parse_optional_ty_param_bounds(&self) -> @OptVec<TyParamBound> {\n         if !self.eat(&token::COLON) {\n             return @opt_vec::Empty;\n@@ -2799,6 +2850,7 @@ pub impl Parser {\n         return @result;\n     }\n \n+    // matches typaram = IDENT optbounds\n     fn parse_ty_param(&self) -> TyParam {\n         let ident = self.parse_ident();\n         let bounds = self.parse_optional_ty_param_bounds();\n@@ -2842,15 +2894,16 @@ pub impl Parser {\n         (lifetimes, opt_vec::take_vec(result))\n     }\n \n-    fn parse_fn_decl(&self, parse_arg_fn: &fn(&Parser) -> arg_or_capture_item)\n+    // parse the argument list and result type of a function declaration\n+    fn parse_fn_decl(&self)\n         -> fn_decl\n     {\n         let args_or_capture_items: ~[arg_or_capture_item] =\n             self.parse_unspanned_seq(\n                 &token::LPAREN,\n                 &token::RPAREN,\n                 seq_sep_trailing_disallowed(token::COMMA),\n-                parse_arg_fn\n+                |p| p.parse_arg()\n             );\n \n         let inputs = either::lefts(args_or_capture_items);\n@@ -2883,6 +2936,8 @@ pub impl Parser {\n         self.bump();\n     }\n \n+    // parse the argument list and result type of a function\n+    // that may have a self type.\n     fn parse_fn_decl_with_self(\n         &self,\n         parse_arg_fn:\n@@ -3030,6 +3085,7 @@ pub impl Parser {\n         (spanned(lo, hi, self_ty), fn_decl)\n     }\n \n+    // parse the |arg, arg| header on a lambda\n     fn parse_fn_block_decl(&self) -> fn_decl {\n         let inputs_captures = {\n             if self.eat(&token::OROR) {\n@@ -3056,6 +3112,7 @@ pub impl Parser {\n         }\n     }\n \n+    // parse the name and optional generic types of a function header.\n     fn parse_fn_header(&self) -> (ident, ast::Generics) {\n         let id = self.parse_ident();\n         let generics = self.parse_generics();\n@@ -3073,15 +3130,17 @@ pub impl Parser {\n                      span: mk_sp(lo, hi) }\n     }\n \n+    // parse an item-position function declaration.\n     fn parse_item_fn(&self, purity: purity, abis: AbiSet) -> item_info {\n         let (ident, generics) = self.parse_fn_header();\n-        let decl = self.parse_fn_decl(|p| p.parse_arg());\n-        let (inner_attrs, body) = self.parse_inner_attrs_and_block(true);\n+        let decl = self.parse_fn_decl();\n+        let (inner_attrs, body) = self.parse_inner_attrs_and_block();\n         (ident,\n          item_fn(decl, purity, abis, generics, body),\n          Some(inner_attrs))\n     }\n \n+    // parse a method in a trait impl\n     fn parse_method(&self) -> @method {\n         let attrs = self.parse_outer_attributes();\n         let lo = self.span.lo;\n@@ -3094,7 +3153,7 @@ pub impl Parser {\n             p.parse_arg()\n         };\n \n-        let (inner_attrs, body) = self.parse_inner_attrs_and_block(true);\n+        let (inner_attrs, body) = self.parse_inner_attrs_and_block();\n         let hi = body.span.hi;\n         let attrs = vec::append(attrs, inner_attrs);\n         @ast::method {\n@@ -3227,7 +3286,7 @@ pub impl Parser {\n             is_tuple_like = false;\n             fields = ~[];\n             while *self.token != token::RBRACE {\n-                match self.parse_class_item() {\n+                match self.parse_struct_decl_field() {\n                   dtor_decl(ref blk, ref attrs, s) => {\n                       match the_dtor {\n                         Some((_, _, s_first)) => {\n@@ -3310,12 +3369,13 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_single_class_item(&self, vis: visibility) -> @struct_field {\n+    // parse a structure field declaration\n+    fn parse_single_struct_field(&self, vis: visibility) -> @struct_field {\n         if self.eat_obsolete_ident(\"let\") {\n             self.obsolete(*self.last_span, ObsoleteLet);\n         }\n \n-        let a_var = self.parse_instance_var(vis);\n+        let a_var = self.parse_name_and_ty(vis);\n         match *self.token {\n             token::SEMI => {\n                 self.obsolete(copy *self.span, ObsoleteFieldTerminator);\n@@ -3329,7 +3389,7 @@ pub impl Parser {\n                 self.span_fatal(\n                     copy *self.span,\n                     fmt!(\n-                        \"expected `;`, `,`, or '}' but found `%s`\",\n+                        \"expected `,`, or '}' but found `%s`\",\n                         self.this_token_to_str()\n                     )\n                 );\n@@ -3338,13 +3398,8 @@ pub impl Parser {\n         a_var\n     }\n \n-    fn parse_dtor(&self, attrs: ~[attribute]) -> class_contents {\n-        let lo = self.last_span.lo;\n-        let body = self.parse_block();\n-        dtor_decl(body, attrs, mk_sp(lo, self.last_span.hi))\n-    }\n-\n-    fn parse_class_item(&self) -> class_contents {\n+    // parse an element of a struct definition\n+    fn parse_struct_decl_field(&self) -> class_contents {\n \n         if self.try_parse_obsolete_priv_section() {\n             return members(~[]);\n@@ -3353,25 +3408,28 @@ pub impl Parser {\n         let attrs = self.parse_outer_attributes();\n \n         if self.eat_keyword(&~\"priv\") {\n-            return members(~[self.parse_single_class_item(private)])\n+            return members(~[self.parse_single_struct_field(private)])\n         }\n \n         if self.eat_keyword(&~\"pub\") {\n-           return members(~[self.parse_single_class_item(public)]);\n+           return members(~[self.parse_single_struct_field(public)]);\n         }\n \n         if self.try_parse_obsolete_struct_ctor() {\n             return members(~[]);\n         }\n \n         if self.eat_keyword(&~\"drop\") {\n-           return self.parse_dtor(attrs);\n+            let lo = self.last_span.lo;\n+            let body = self.parse_block();\n+            return dtor_decl(body, attrs, mk_sp(lo, self.last_span.hi))\n         }\n         else {\n-           return members(~[self.parse_single_class_item(inherited)]);\n+           return members(~[self.parse_single_struct_field(inherited)]);\n         }\n     }\n \n+    // parse visiility: PUB, PRIV, or nothing\n     fn parse_visibility(&self) -> visibility {\n         if self.eat_keyword(&~\"pub\") { public }\n         else if self.eat_keyword(&~\"priv\") { private }\n@@ -3399,14 +3457,12 @@ pub impl Parser {\n             items: starting_items,\n             _\n         } = self.parse_items_and_view_items(first_item_attrs,\n-                                            VIEW_ITEMS_AND_ITEMS_ALLOWED,\n-                                            true);\n+                                            true, true);\n         let mut items: ~[@item] = starting_items;\n         let attrs_remaining_len = attrs_remaining.len();\n \n-        // looks like this code depends on the invariant that\n-        // outer attributes can't occur on view items (or macros\n-        // invocations?)\n+        // don't think this other loop is even necessary....\n+\n         let mut first = true;\n         while *self.token != term {\n             let mut attrs = self.parse_outer_attributes();\n@@ -3418,9 +3474,7 @@ pub impl Parser {\n                    attrs);\n             match self.parse_item_or_view_item(\n                 /*bad*/ copy attrs,\n-                true,\n-                false,\n-                true\n+                true // macros allowed\n             ) {\n               iovi_item(item) => items.push(item),\n               iovi_view_item(view_item) => {\n@@ -3525,6 +3579,7 @@ pub impl Parser {\n         self.mod_path_stack.pop();\n     }\n \n+    // read a module from a source file.\n     fn eval_src_mod(&self, id: ast::ident,\n                     outer_attrs: ~[ast::attribute],\n                     id_sp: span) -> (ast::item_, ~[ast::attribute]) {\n@@ -3582,12 +3637,13 @@ pub impl Parser {\n         }\n     }\n \n+    // parse a function declaration from a foreign module\n     fn parse_item_foreign_fn(&self,  attrs: ~[attribute]) -> @foreign_item {\n         let lo = self.span.lo;\n         let vis = self.parse_visibility();\n         let purity = self.parse_fn_purity();\n         let (ident, generics) = self.parse_fn_header();\n-        let decl = self.parse_fn_decl(|p| p.parse_arg());\n+        let decl = self.parse_fn_decl();\n         let hi = self.span.hi;\n         self.expect(&token::SEMI);\n         @ast::foreign_item { ident: ident,\n@@ -3598,6 +3654,7 @@ pub impl Parser {\n                              vis: vis }\n     }\n \n+    // parse a const definition from a foreign module\n     fn parse_item_foreign_const(&self, vis: ast::visibility,\n                                 attrs: ~[attribute]) -> @foreign_item {\n         let lo = self.span.lo;\n@@ -3622,6 +3679,7 @@ pub impl Parser {\n                              vis: vis }\n     }\n \n+    // parse safe/unsafe and fn\n     fn parse_fn_purity(&self) -> purity {\n         if self.eat_keyword(&~\"fn\") { impure_fn }\n         else if self.eat_keyword(&~\"pure\") {\n@@ -3636,45 +3694,30 @@ pub impl Parser {\n         else { self.unexpected(); }\n     }\n \n-    fn parse_foreign_item(&self, attrs: ~[attribute]) -> @foreign_item {\n-        let vis = self.parse_visibility();\n-        if self.is_keyword(&~\"const\") || self.is_keyword(&~\"static\") {\n-            self.parse_item_foreign_const(vis, attrs)\n-        } else {\n-            self.parse_item_foreign_fn(attrs)\n-        }\n-    }\n \n+    // at this point, this is essentially a wrapper for\n+    // parse_foreign_items.\n     fn parse_foreign_mod_items(&self, sort: ast::foreign_mod_sort,\n                                abis: AbiSet,\n                                first_item_attrs: ~[attribute])\n                             -> foreign_mod {\n-        // Shouldn't be any view items since we've already parsed an item attr\n         let ParsedItemsAndViewItems {\n             attrs_remaining: attrs_remaining,\n             view_items: view_items,\n             items: _,\n             foreign_items: foreign_items\n-        } = self.parse_items_and_view_items(first_item_attrs,\n-                                            FOREIGN_ITEMS_ALLOWED,\n-                                            true);\n-\n-        let mut items: ~[@foreign_item] = foreign_items;\n+        } = self.parse_foreign_items(first_item_attrs, true);\n         let mut initial_attrs = attrs_remaining;\n-        while *self.token != token::RBRACE {\n-            let attrs = vec::append(initial_attrs,\n-                                    self.parse_outer_attributes());\n-            initial_attrs = ~[];\n-            items.push(self.parse_foreign_item(attrs));\n-        }\n+        assert!(*self.token == token::RBRACE);\n         ast::foreign_mod {\n             sort: sort,\n             abis: abis,\n             view_items: view_items,\n-            items: items\n+            items: foreign_items\n         }\n     }\n \n+    // parse extern foo; or extern mod foo { ... } or extern { ... }\n     fn parse_item_foreign_mod(&self,\n                               lo: BytePos,\n                               opt_abis: Option<AbiSet>,\n@@ -3744,15 +3787,9 @@ pub impl Parser {\n         })\n     }\n \n-    fn parse_type_decl(&self) -> (BytePos, ident) {\n-        let lo = self.last_span.lo;\n-        let id = self.parse_ident();\n-        (lo, id)\n-    }\n-\n     // parse type Foo = Bar;\n     fn parse_item_type(&self) -> item_info {\n-        let (_, ident) = self.parse_type_decl();\n+        let ident = self.parse_ident();\n         self.parse_region_param();\n         let tps = self.parse_generics();\n         self.expect(&token::EQ);\n@@ -3769,11 +3806,13 @@ pub impl Parser {\n         }\n     }\n \n+    // parse a structure-like enum variant definition\n+    // this should probably be renamed or refactored...\n     fn parse_struct_def(&self) -> @struct_def {\n         let mut the_dtor: Option<(blk, ~[attribute], codemap::span)> = None;\n         let mut fields: ~[@struct_field] = ~[];\n         while *self.token != token::RBRACE {\n-            match self.parse_class_item() {\n+            match self.parse_struct_decl_field() {\n                 dtor_decl(ref blk, ref attrs, s) => {\n                     match the_dtor {\n                         Some((_, _, s_first)) => {\n@@ -3812,6 +3851,7 @@ pub impl Parser {\n         };\n     }\n \n+    // parse the part of an \"enum\" decl following the '{'\n     fn parse_enum_def(&self, _generics: &ast::Generics) -> enum_def {\n         let mut variants = ~[];\n         let mut all_nullary = true, have_disr = false;\n@@ -3821,7 +3861,7 @@ pub impl Parser {\n \n             let vis = self.parse_visibility();\n \n-            let ident, needs_comma, kind;\n+            let ident, kind;\n             let mut args = ~[], disr_expr = None;\n             ident = self.parse_ident();\n             if self.eat(&token::LBRACE) {\n@@ -3850,7 +3890,6 @@ pub impl Parser {\n             } else {\n                 kind = tuple_variant_kind(~[]);\n             }\n-            needs_comma = true;\n \n             let vr = ast::variant_ {\n                 name: ident,\n@@ -3862,7 +3901,7 @@ pub impl Parser {\n             };\n             variants.push(spanned(vlo, self.last_span.hi, vr));\n \n-            if needs_comma && !self.eat(&token::COMMA) { break; }\n+            if !self.eat(&token::COMMA) { break; }\n         }\n         self.expect(&token::RBRACE);\n         if (have_disr && !all_nullary) {\n@@ -3873,6 +3912,7 @@ pub impl Parser {\n         ast::enum_def { variants: variants }\n     }\n \n+    // parse an \"enum\" declaration\n     fn parse_item_enum(&self) -> item_info {\n         let id = self.parse_ident();\n         self.parse_region_param();\n@@ -3938,6 +3978,7 @@ pub impl Parser {\n         }\n     }\n \n+    // parse a string as an ABI spec on an extern type or module\n     fn parse_opt_abis(&self) -> Option<AbiSet> {\n         match *self.token {\n             token::LIT_STR(s) => {\n@@ -3983,31 +4024,53 @@ pub impl Parser {\n \n     // parse one of the items or view items allowed by the\n     // flags; on failure, return iovi_none.\n+    // NB: this function no longer parses the items inside an\n+    // extern mod.\n     fn parse_item_or_view_item(\n         &self,\n         attrs: ~[attribute],\n-        items_allowed: bool,\n-        foreign_items_allowed: bool,\n         macros_allowed: bool\n     ) -> item_or_view_item {\n-        assert!(items_allowed != foreign_items_allowed);\n-\n         maybe_whole!(iovi self, nt_item);\n         let lo = self.span.lo;\n \n-        let visibility;\n-        if self.eat_keyword(&~\"pub\") {\n-            visibility = public;\n-        } else if self.eat_keyword(&~\"priv\") {\n-            visibility = private;\n-        } else {\n-            visibility = inherited;\n+        let visibility = self.parse_visibility();\n+\n+        // must be a view item:\n+        if self.eat_keyword(&~\"use\") {\n+            // USE ITEM (iovi_view_item)\n+            let view_item = self.parse_use();\n+            self.expect(&token::SEMI);\n+            return iovi_view_item(@ast::view_item {\n+                node: view_item,\n+                attrs: attrs,\n+                vis: visibility,\n+                span: mk_sp(lo, self.last_span.hi)\n+            });\n         }\n+        // either a view item or an item:\n+        if self.eat_keyword(&~\"extern\") {\n+            let opt_abis = self.parse_opt_abis();\n \n-        if items_allowed &&\n-                (self.is_keyword(&~\"const\") ||\n-                (self.is_keyword(&~\"static\") &&\n-                    !self.token_is_keyword(&~\"fn\", &self.look_ahead(1)))) {\n+            if self.eat_keyword(&~\"fn\") {\n+                // EXTERN FUNCTION ITEM\n+                let abis = opt_abis.get_or_default(AbiSet::C());\n+                let (ident, item_, extra_attrs) =\n+                    self.parse_item_fn(extern_fn, abis);\n+                return iovi_item(self.mk_item(lo, self.last_span.hi, ident,\n+                                              item_, visibility,\n+                                              maybe_append(attrs,\n+                                                           extra_attrs)));\n+            } else  {\n+                // EXTERN MODULE ITEM (iovi_view_item)\n+                return self.parse_item_foreign_mod(lo, opt_abis, visibility, attrs,\n+                                                   true);\n+            }\n+        }\n+        // the rest are all guaranteed to be items:\n+        if (self.is_keyword(&~\"const\") ||\n+            (self.is_keyword(&~\"static\") &&\n+             !self.token_is_keyword(&~\"fn\", &self.look_ahead(1)))) {\n             // CONST / STATIC ITEM\n             if self.is_keyword(&~\"const\") {\n                 self.obsolete(*self.span, ObsoleteConstItem);\n@@ -4018,13 +4081,7 @@ pub impl Parser {\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if foreign_items_allowed &&\n-                (self.is_keyword(&~\"const\") || self.is_keyword(&~\"static\")) {\n-            // FOREIGN CONST ITEM\n-            let item = self.parse_item_foreign_const(visibility, attrs);\n-            return iovi_foreign_item(item);\n-        }\n-        if items_allowed && self.is_keyword(&~\"fn\") &&\n+        if self.is_keyword(&~\"fn\") &&\n             !self.fn_expr_lookahead(self.look_ahead(1u)) {\n             // FUNCTION ITEM\n             self.bump();\n@@ -4034,7 +4091,7 @@ pub impl Parser {\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if items_allowed && self.eat_keyword(&~\"pure\") {\n+        if self.eat_keyword(&~\"pure\") {\n             // PURE FUNCTION ITEM (obsolete)\n             self.obsolete(*self.last_span, ObsoletePurity);\n             self.expect_keyword(&~\"fn\");\n@@ -4044,16 +4101,9 @@ pub impl Parser {\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if foreign_items_allowed &&\n-            (self.is_keyword(&~\"fn\") || self.is_keyword(&~\"pure\") ||\n-             self.is_keyword(&~\"unsafe\")) {\n-            // FOREIGN FUNCTION ITEM (no items allowed)\n-                let item = self.parse_item_foreign_fn(attrs);\n-                return iovi_foreign_item(item);\n-        }\n-        if items_allowed && self.is_keyword(&~\"unsafe\")\n+        if self.is_keyword(&~\"unsafe\")\n             && self.look_ahead(1u) != token::LBRACE {\n-            // UNSAFE FUNCTION ITEM (where items are allowed)\n+            // UNSAFE FUNCTION ITEM\n             self.bump();\n             self.expect_keyword(&~\"fn\");\n             let (ident, item_, extra_attrs) =\n@@ -4062,85 +4112,85 @@ pub impl Parser {\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if self.eat_keyword(&~\"extern\") {\n-            let opt_abis = self.parse_opt_abis();\n-\n-            if items_allowed && self.eat_keyword(&~\"fn\") {\n-                // EXTERN FUNCTION ITEM\n-                let abis = opt_abis.get_or_default(AbiSet::C());\n-                let (ident, item_, extra_attrs) =\n-                    self.parse_item_fn(extern_fn, abis);\n-                return iovi_item(self.mk_item(lo, self.last_span.hi, ident,\n-                                              item_, visibility,\n-                                              maybe_append(attrs,\n-                                                           extra_attrs)));\n-            }\n-            if !foreign_items_allowed {\n-                // EXTERN MODULE ITEM\n-                return self.parse_item_foreign_mod(lo, opt_abis, visibility, attrs,\n-                                                   items_allowed);\n-            }\n-        }\n-        if items_allowed && !foreign_items_allowed &&\n-                self.eat_keyword(&~\"mod\") {\n+        if self.eat_keyword(&~\"mod\") {\n             // MODULE ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_mod(attrs);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if items_allowed && !foreign_items_allowed &&\n-                self.eat_keyword(&~\"type\") {\n+        if self.eat_keyword(&~\"type\") {\n             // TYPE ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_type();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if items_allowed && !foreign_items_allowed &&\n-                self.eat_keyword(&~\"enum\") {\n+        if self.eat_keyword(&~\"enum\") {\n             // ENUM ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_enum();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if items_allowed && !foreign_items_allowed &&\n-                self.eat_keyword(&~\"trait\") {\n+        if self.eat_keyword(&~\"trait\") {\n             // TRAIT ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_trait();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if items_allowed && !foreign_items_allowed &&\n-                self.eat_keyword(&~\"impl\") {\n+        if self.eat_keyword(&~\"impl\") {\n             // IMPL ITEM\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_impl(visibility);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if items_allowed && !foreign_items_allowed &&\n-                self.eat_keyword(&~\"struct\") {\n+        if self.eat_keyword(&~\"struct\") {\n             // STRUCT ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_struct();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if !foreign_items_allowed && self.eat_keyword(&~\"use\") {\n-            // USE ITEM\n-            let view_item = self.parse_use();\n-            self.expect(&token::SEMI);\n-            return iovi_view_item(@ast::view_item {\n-                node: view_item,\n-                attrs: attrs,\n-                vis: visibility,\n-                span: mk_sp(lo, self.last_span.hi)\n-            });\n+        self.parse_macro_use_or_failure(attrs,macros_allowed,lo,visibility)\n+    }\n+\n+    // parse a foreign item; on failure, return iovi_none.\n+    fn parse_foreign_item(\n+        &self,\n+        attrs: ~[attribute],\n+        macros_allowed: bool\n+    ) -> item_or_view_item {\n+        maybe_whole!(iovi self, nt_item);\n+        let lo = self.span.lo;\n+\n+        let visibility = self.parse_visibility();\n+\n+        if (self.is_keyword(&~\"const\") || self.is_keyword(&~\"static\")) {\n+            // FOREIGN CONST ITEM\n+            let item = self.parse_item_foreign_const(visibility, attrs);\n+            return iovi_foreign_item(item);\n         }\n+        if (self.is_keyword(&~\"fn\") || self.is_keyword(&~\"pure\") ||\n+             self.is_keyword(&~\"unsafe\")) {\n+            // FOREIGN FUNCTION ITEM\n+                let item = self.parse_item_foreign_fn(attrs);\n+                return iovi_foreign_item(item);\n+        }\n+        self.parse_macro_use_or_failure(attrs,macros_allowed,lo,visibility)\n+    }\n+\n+    // this is the fall-through for parsing items.\n+    fn parse_macro_use_or_failure(\n+        &self,\n+        attrs: ~[attribute],\n+        macros_allowed: bool,\n+        lo : BytePos,\n+        visibility : visibility\n+    ) -> item_or_view_item {\n         if macros_allowed && !self.is_any_keyword(&copy *self.token)\n                 && self.look_ahead(1) == token::NOT\n                 && (is_plain_ident(&self.look_ahead(2))\n@@ -4197,7 +4247,7 @@ pub impl Parser {\n     }\n \n     fn parse_item(&self, attrs: ~[attribute]) -> Option<@ast::item> {\n-        match self.parse_item_or_view_item(attrs, true, false, true) {\n+        match self.parse_item_or_view_item(attrs, true) {\n             iovi_none =>\n                 None,\n             iovi_view_item(_) =>\n@@ -4209,6 +4259,7 @@ pub impl Parser {\n         }\n     }\n \n+    // parse, e.g., \"use a::b::{z,y}\"\n     fn parse_use(&self) -> view_item_ {\n         return view_item_use(self.parse_view_paths());\n     }\n@@ -4353,101 +4404,73 @@ pub impl Parser {\n \n     // Parses a sequence of items. Stops when it finds program\n     // text that can't be parsed as an item\n-    // - mod_items uses VIEW_ITEMS_AND_ITEMS_ALLOWED\n-    // - block_tail_ uses IMPORTS_AND_ITEMS_ALLOWED\n-    // - foreign_mod_items uses FOREIGN_ITEMS_ALLOWED\n+    // - mod_items uses extern_mod_allowed = true\n+    // - block_tail_ uses extern_mod_allowed = false\n     fn parse_items_and_view_items(&self, first_item_attrs: ~[attribute],\n-                                  mode: view_item_parse_mode,\n+                                  mut extern_mod_allowed: bool,\n                                   macros_allowed: bool)\n                                 -> ParsedItemsAndViewItems {\n         let mut attrs = vec::append(first_item_attrs,\n                                     self.parse_outer_attributes());\n-\n-        let items_allowed = match mode {\n-            VIEW_ITEMS_AND_ITEMS_ALLOWED | IMPORTS_AND_ITEMS_ALLOWED => true,\n-            FOREIGN_ITEMS_ALLOWED => false\n-        };\n-        let foreign_items_allowed = match mode {\n-            FOREIGN_ITEMS_ALLOWED => true,\n-            VIEW_ITEMS_AND_ITEMS_ALLOWED | IMPORTS_AND_ITEMS_ALLOWED => false\n-        };\n-\n         // First, parse view items.\n-        let mut (view_items, items, foreign_items) = (~[], ~[], ~[]);\n+        let mut (view_items, items) = (~[], ~[]);\n         let mut done = false;\n-        if mode != FOREIGN_ITEMS_ALLOWED {\n-            let mut extern_mod_allowed = match mode {\n-                VIEW_ITEMS_AND_ITEMS_ALLOWED => true,\n-                IMPORTS_AND_ITEMS_ALLOWED => false,\n-                FOREIGN_ITEMS_ALLOWED => {\n-                    self.bug(~\"couldn't get here with FOREIGN_ITEMS_ALLOWED\")\n+        // I think this code would probably read better as a single\n+        // loop with a mutable three-state-variable (for extern mods,\n+        // view items, and regular items) ... except that because\n+        // of macros, I'd like to delay that entire check until later.\n+        loop {\n+            match self.parse_item_or_view_item(/*bad*/ copy attrs,\n+                                                           macros_allowed) {\n+                iovi_none => {\n+                    done = true;\n+                    break;\n                 }\n-            };\n-\n-            loop {\n-                match self.parse_item_or_view_item(/*bad*/ copy attrs,\n-                                                   items_allowed,\n-                                                   foreign_items_allowed,\n-                                                   macros_allowed) {\n-                    iovi_none => {\n-                        done = true;\n-                        break;\n-                    }\n-                    iovi_view_item(view_item) => {\n-                        match view_item.node {\n-                            view_item_use(*) => {\n-                                // `extern mod` must precede `use`.\n-                                extern_mod_allowed = false;\n-                            }\n-                            view_item_extern_mod(*)\n-                                    if !extern_mod_allowed => {\n-                                self.span_err(view_item.span,\n-                                              ~\"\\\"extern mod\\\" \\\n-                                                declarations are not \\\n-                                                allowed here\");\n-                            }\n-                            view_item_extern_mod(*) => {}\n+                iovi_view_item(view_item) => {\n+                    match view_item.node {\n+                        view_item_use(*) => {\n+                            // `extern mod` must precede `use`.\n+                            extern_mod_allowed = false;\n                         }\n-                        view_items.push(view_item);\n-                    }\n-                    iovi_item(item) => {\n-                        assert!(items_allowed);\n-                        items.push(item);\n-                        attrs = self.parse_outer_attributes();\n-                        break;\n-                    }\n-                    iovi_foreign_item(foreign_item) => {\n-                        assert!(foreign_items_allowed);\n-                        foreign_items.push(foreign_item);\n-                        attrs = self.parse_outer_attributes();\n-                        break;\n+                        view_item_extern_mod(*)\n+                        if !extern_mod_allowed => {\n+                            self.span_err(view_item.span,\n+                                          ~\"\\\"extern mod\\\" \\\n+                                            declarations are not \\\n+                                            allowed here\");\n+                        }\n+                        view_item_extern_mod(*) => {}\n                     }\n+                    view_items.push(view_item);\n+                }\n+                iovi_item(item) => {\n+                    items.push(item);\n+                    attrs = self.parse_outer_attributes();\n+                    break;\n+                }\n+                iovi_foreign_item(_) => {\n+                    fail!();\n                 }\n-                attrs = self.parse_outer_attributes();\n             }\n+            attrs = self.parse_outer_attributes();\n         }\n \n         // Next, parse items.\n         if !done {\n             loop {\n                 match self.parse_item_or_view_item(/*bad*/ copy attrs,\n-                                                   items_allowed,\n-                                                   foreign_items_allowed,\n                                                    macros_allowed) {\n                     iovi_none => break,\n                     iovi_view_item(view_item) => {\n                         self.span_err(view_item.span,\n                                       ~\"`use` and `extern mod` declarations \\\n                                         must precede items\");\n-                        view_items.push(view_item);\n                     }\n                     iovi_item(item) => {\n-                        assert!(items_allowed);\n                         items.push(item)\n                     }\n-                    iovi_foreign_item(foreign_item) => {\n-                        assert!(foreign_items_allowed);\n-                        foreign_items.push(foreign_item);\n+                    iovi_foreign_item(_) => {\n+                        fail!();\n                     }\n                 }\n                 attrs = self.parse_outer_attributes();\n@@ -4458,12 +4481,49 @@ pub impl Parser {\n             attrs_remaining: attrs,\n             view_items: view_items,\n             items: items,\n+            foreign_items: ~[]\n+        }\n+    }\n+\n+    // Parses a sequence of foreign items. Stops when it finds program\n+    // text that can't be parsed as an item\n+    fn parse_foreign_items(&self, first_item_attrs: ~[attribute],\n+                           macros_allowed: bool)\n+        -> ParsedItemsAndViewItems {\n+        let mut attrs = vec::append(first_item_attrs,\n+                                    self.parse_outer_attributes());\n+        let mut foreign_items = ~[];\n+        loop {\n+            match self.parse_foreign_item(/*bad*/ copy attrs, macros_allowed) {\n+                iovi_none => break,\n+                iovi_view_item(view_item) => {\n+                    // I think this can't occur:\n+                    self.span_err(view_item.span,\n+                                  ~\"`use` and `extern mod` declarations \\\n+                                    must precede items\");\n+                }\n+                iovi_item(_) => {\n+                    // FIXME #5668: this will occur for a macro invocation:\n+                    fail!();\n+                }\n+                iovi_foreign_item(foreign_item) => {\n+                    foreign_items.push(foreign_item);\n+                }\n+            }\n+            attrs = self.parse_outer_attributes();\n+        }\n+\n+        ParsedItemsAndViewItems {\n+            attrs_remaining: attrs,\n+            view_items: ~[],\n+            items: ~[],\n             foreign_items: foreign_items\n         }\n     }\n \n-    // Parses a source module as a crate\n-    fn parse_crate_mod(&self, _cfg: crate_cfg) -> @crate {\n+    // Parses a source module as a crate. This is the main\n+    // entry point for the parser.\n+    fn parse_crate_mod(&self) -> @crate {\n         let lo = self.span.lo;\n         // parse the crate's inner attrs, maybe (oops) one\n         // of the attrs of an item:"}, {"sha": "5f37c922c1e10f49e518091d0dfe4a4403ae0409", "filename": "src/libsyntax/parse/prec.rs", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibsyntax%2Fparse%2Fprec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7a0fc235cd2e0782302cd6fb83634e190b15b7/src%2Flibsyntax%2Fparse%2Fprec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fprec.rs?ref=7b7a0fc235cd2e0782302cd6fb83634e190b15b7", "patch": "@@ -1,52 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use ast;\n-use ast::*;\n-use parse::token::*;\n-use parse::token::Token;\n-\n-/// Unary operators have higher precedence than binary\n-pub static unop_prec: uint = 100u;\n-\n-/**\n- * Precedence of the `as` operator, which is a binary operator\n- * but is not represented in the precedence table.\n- */\n-pub static as_prec: uint = 11u;\n-\n-/**\n- * Maps a token to a record specifying the corresponding binary\n- * operator and its precedence\n- */\n-pub fn token_to_binop(tok: Token) -> Option<ast::binop> {\n-  match tok {\n-      BINOP(STAR)    => Some(mul),\n-      BINOP(SLASH)   => Some(quot),\n-      BINOP(PERCENT) => Some(rem),\n-      // 'as' sits between here with 11\n-      BINOP(PLUS)    => Some(add),\n-      BINOP(MINUS)   => Some(subtract),\n-      BINOP(SHL)     => Some(shl),\n-      BINOP(SHR)     => Some(shr),\n-      BINOP(AND)     => Some(bitand),\n-      BINOP(CARET)   => Some(bitxor),\n-      BINOP(OR)      => Some(bitor),\n-      LT             => Some(lt),\n-      LE             => Some(le),\n-      GE             => Some(ge),\n-      GT             => Some(gt),\n-      EQEQ           => Some(eq),\n-      NE             => Some(ne),\n-      ANDAND         => Some(and),\n-      OROR           => Some(or),\n-      _              => None\n-  }\n-}"}, {"sha": "0327a3b80da87967f34524d4870d3eceb23c761b", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 85, "deletions": 49, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/ea74f6845e08150e3b38766f57a4af928aea1376/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea74f6845e08150e3b38766f57a4af928aea1376/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=ea74f6845e08150e3b38766f57a4af928aea1376", "patch": "@@ -364,6 +364,34 @@ impl<'self> to_bytes::IterBytes for StringRef<'self> {\n     }\n }\n \n+/**\n+ * Maps a token to a record specifying the corresponding binary\n+ * operator\n+ */\n+pub fn token_to_binop(tok: Token) -> Option<ast::binop> {\n+  match tok {\n+      BINOP(STAR)    => Some(ast::mul),\n+      BINOP(SLASH)   => Some(ast::quot),\n+      BINOP(PERCENT) => Some(ast::rem),\n+      BINOP(PLUS)    => Some(ast::add),\n+      BINOP(MINUS)   => Some(ast::subtract),\n+      BINOP(SHL)     => Some(ast::shl),\n+      BINOP(SHR)     => Some(ast::shr),\n+      BINOP(AND)     => Some(ast::bitand),\n+      BINOP(CARET)   => Some(ast::bitxor),\n+      BINOP(OR)      => Some(ast::bitor),\n+      LT             => Some(ast::lt),\n+      LE             => Some(ast::le),\n+      GE             => Some(ast::ge),\n+      GT             => Some(ast::gt),\n+      EQEQ           => Some(ast::eq),\n+      NE             => Some(ast::ne),\n+      ANDAND         => Some(ast::and),\n+      OROR           => Some(ast::or),\n+      _              => None\n+  }\n+}\n+\n pub struct ident_interner {\n     priv interner: Interner<@~str>,\n }\n@@ -390,60 +418,68 @@ pub impl ident_interner {\n     }\n }\n \n+// return a fresh interner, preloaded with special identifiers.\n+// EFFECT: stores this interner in TLS\n+pub fn mk_fresh_ident_interner() -> @ident_interner {\n+    // the indices here must correspond to the numbers in\n+    // special_idents.\n+    let init_vec = ~[\n+        @~\"_\",                  // 0\n+        @~\"anon\",               // 1\n+        @~\"drop\",               // 2\n+        @~\"\",                   // 3\n+        @~\"unary\",              // 4\n+        @~\"!\",                  // 5\n+        @~\"[]\",                 // 6\n+        @~\"unary-\",             // 7\n+        @~\"__extensions__\",     // 8\n+        @~\"self\",               // 9\n+        @~\"item\",               // 10\n+        @~\"block\",              // 11\n+        @~\"stmt\",               // 12\n+        @~\"pat\",                // 13\n+        @~\"expr\",               // 14\n+        @~\"ty\",                 // 15\n+        @~\"ident\",              // 16\n+        @~\"path\",               // 17\n+        @~\"tt\",                 // 18\n+        @~\"matchers\",           // 19\n+        @~\"str\",                // 20\n+        @~\"TyVisitor\",          // 21\n+        @~\"arg\",                // 22\n+        @~\"descrim\",            // 23\n+        @~\"__rust_abi\",         // 24\n+        @~\"__rust_stack_shim\",  // 25\n+        @~\"TyDesc\",             // 26\n+        @~\"dtor\",               // 27\n+        @~\"main\",               // 28\n+        @~\"<opaque>\",           // 29\n+        @~\"blk\",                // 30\n+        @~\"static\",             // 31\n+        @~\"intrinsic\",          // 32\n+        @~\"__foreign_mod__\",    // 33\n+        @~\"__field__\",          // 34\n+        @~\"C\",                  // 35\n+        @~\"Self\",               // 36\n+    ];\n+\n+    let rv = @ident_interner {\n+        interner: interner::Interner::prefill(init_vec)\n+    };\n+    unsafe {\n+        task::local_data::local_data_set(interner_key!(), @rv);\n+    }\n+    rv\n+}\n+\n+// if an interner exists in TLS, return it. Otherwise, prepare a\n+// fresh one.\n pub fn mk_ident_interner() -> @ident_interner {\n     unsafe {\n         match task::local_data::local_data_get(interner_key!()) {\n             Some(interner) => *interner,\n             None => {\n-                // the indices here must correspond to the numbers in\n-                // special_idents.\n-                let init_vec = ~[\n-                    @~\"_\",                  // 0\n-                    @~\"anon\",               // 1\n-                    @~\"drop\",               // 2\n-                    @~\"\",                   // 3\n-                    @~\"unary\",              // 4\n-                    @~\"!\",                  // 5\n-                    @~\"[]\",                 // 6\n-                    @~\"unary-\",             // 7\n-                    @~\"__extensions__\",     // 8\n-                    @~\"self\",               // 9\n-                    @~\"item\",               // 10\n-                    @~\"block\",              // 11\n-                    @~\"stmt\",               // 12\n-                    @~\"pat\",                // 13\n-                    @~\"expr\",               // 14\n-                    @~\"ty\",                 // 15\n-                    @~\"ident\",              // 16\n-                    @~\"path\",               // 17\n-                    @~\"tt\",                 // 18\n-                    @~\"matchers\",           // 19\n-                    @~\"str\",                // 20\n-                    @~\"TyVisitor\",          // 21\n-                    @~\"arg\",                // 22\n-                    @~\"descrim\",            // 23\n-                    @~\"__rust_abi\",         // 24\n-                    @~\"__rust_stack_shim\",  // 25\n-                    @~\"TyDesc\",             // 26\n-                    @~\"dtor\",               // 27\n-                    @~\"main\",               // 28\n-                    @~\"<opaque>\",           // 29\n-                    @~\"blk\",                // 30\n-                    @~\"static\",             // 31\n-                    @~\"intrinsic\",          // 32\n-                    @~\"__foreign_mod__\",    // 33\n-                    @~\"__field__\",          // 34\n-                    @~\"C\",                  // 35\n-                    @~\"Self\",               // 36\n-                ];\n-\n-                let rv = @ident_interner {\n-                    interner: interner::Interner::prefill(init_vec)\n-                };\n-\n-                task::local_data::local_data_set(interner_key!(), @rv);\n-\n-                rv\n+                mk_fresh_ident_interner()\n             }\n         }\n     }"}, {"sha": "a401d9eb8ace77fdcbd06de7796ea0e1ae3f76e8", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ea74f6845e08150e3b38766f57a4af928aea1376/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/ea74f6845e08150e3b38766f57a4af928aea1376/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=ea74f6845e08150e3b38766f57a4af928aea1376", "patch": "@@ -8,6 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+/*! This module contains the Rust parser. It maps source text\n+ *  to token trees and to ASTs. It contains code for expanding\n+ *  macros.\n+ */\n+\n #[link(name = \"syntax\",\n        vers = \"0.7-pre\",\n        uuid = \"9311401b-d6ea-4cd9-a1d9-61f89499c645\")];"}, {"sha": "9eb98341112f266993c4cb6161a8e92147ef861a", "filename": "src/test/compile-fail/enums-pats-not-idents.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ea74f6845e08150e3b38766f57a4af928aea1376/src%2Ftest%2Fcompile-fail%2Fenums-pats-not-idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea74f6845e08150e3b38766f57a4af928aea1376/src%2Ftest%2Fcompile-fail%2Fenums-pats-not-idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenums-pats-not-idents.rs?ref=ea74f6845e08150e3b38766f57a4af928aea1376", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//error-pattern:unresolved enum variant\n+\n+fn main() {\n+    // a bug in the parser is allowing this:\n+    let a() = 13;\n+}"}]}