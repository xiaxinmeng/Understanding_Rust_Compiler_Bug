{"sha": "049bee09e93919a986c9911c1ef944e467773a84", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0OWJlZTA5ZTkzOTE5YTk4NmM5OTExYzFlZjk0NGU0Njc3NzNhODQ=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2018-10-13T13:23:23Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2018-10-20T22:11:30Z"}, "message": "Use more accurate `ConstraintCategory`s\n\nAdds UseAsConst and UseAsStatic to replace Return in consts/statics.\nDon't report the arguments to an overloaded operator as CallArguments.\nAlso don't report \"escaping data\" in these items.", "tree": {"sha": "f95759ade8f24cc76058745f633d7d3aea8b935b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f95759ade8f24cc76058745f633d7d3aea8b935b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/049bee09e93919a986c9911c1ef944e467773a84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/049bee09e93919a986c9911c1ef944e467773a84", "html_url": "https://github.com/rust-lang/rust/commit/049bee09e93919a986c9911c1ef944e467773a84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/049bee09e93919a986c9911c1ef944e467773a84/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2c24873b110365c88ca3154d4538610829614f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2c24873b110365c88ca3154d4538610829614f7", "html_url": "https://github.com/rust-lang/rust/commit/a2c24873b110365c88ca3154d4538610829614f7"}], "stats": {"total": 61, "additions": 55, "deletions": 6}, "files": [{"sha": "4f68569c60032a278ada9a43b259ded1d0ac7d8a", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/049bee09e93919a986c9911c1ef944e467773a84/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/049bee09e93919a986c9911c1ef944e467773a84/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=049bee09e93919a986c9911c1ef944e467773a84", "patch": "@@ -557,6 +557,8 @@ impl_stable_hash_for!(struct mir::ClosureOutlivesRequirement<'tcx> {\n \n impl_stable_hash_for!(enum mir::ConstraintCategory {\n     Return,\n+    UseAsConst,\n+    UseAsStatic,\n     TypeAnnotation,\n     Cast,\n     ClosureBounds,"}, {"sha": "62b5327ae4692237d33e0b3899dd54ae0c811c69", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/049bee09e93919a986c9911c1ef944e467773a84/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/049bee09e93919a986c9911c1ef944e467773a84/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=049bee09e93919a986c9911c1ef944e467773a84", "patch": "@@ -2725,6 +2725,8 @@ pub struct ClosureOutlivesRequirement<'tcx> {\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub enum ConstraintCategory {\n     Return,\n+    UseAsConst,\n+    UseAsStatic,\n     TypeAnnotation,\n     Cast,\n "}, {"sha": "4139c03e4106a9cc334eea33af6db468406ba815", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/049bee09e93919a986c9911c1ef944e467773a84/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/049bee09e93919a986c9911c1ef944e467773a84/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=049bee09e93919a986c9911c1ef944e467773a84", "patch": "@@ -40,6 +40,8 @@ impl ConstraintDescription for ConstraintCategory {\n         match self {\n             ConstraintCategory::Assignment => \"assignment \",\n             ConstraintCategory::Return => \"returning this value \",\n+            ConstraintCategory::UseAsConst => \"using this value as a constant \",\n+            ConstraintCategory::UseAsStatic => \"using this value as a static \",\n             ConstraintCategory::Cast => \"cast \",\n             ConstraintCategory::CallArgument => \"argument \",\n             ConstraintCategory::TypeAnnotation => \"type annotation \",\n@@ -375,12 +377,18 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let outlived_fr_name_and_span =\n             self.get_var_name_and_span_for_region(infcx.tcx, mir, outlived_fr);\n \n-        let escapes_from = if infcx.tcx.is_closure(mir_def_id) { \"closure\" } else { \"function\" };\n+        let escapes_from = match self.universal_regions.defining_ty {\n+            DefiningTy::Closure(..) => \"closure\",\n+            DefiningTy::Generator(..) => \"generator\",\n+            DefiningTy::FnDef(..) => \"function\",\n+            DefiningTy::Const(..) => \"const\"\n+        };\n \n         // Revert to the normal error in these cases.\n         // Assignments aren't \"escapes\" in function items.\n         if (fr_name_and_span.is_none() && outlived_fr_name_and_span.is_none())\n             || (category == ConstraintCategory::Assignment && escapes_from == \"function\")\n+            || escapes_from == \"const\"\n         {\n             return self.report_general_error(mir, infcx, mir_def_id,\n                                              fr, true, outlived_fr, false,"}, {"sha": "6d152fc87bd33bbda96a5bf8e8de204ad5a8c2c1", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 42, "deletions": 5, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/049bee09e93919a986c9911c1ef944e467773a84/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/049bee09e93919a986c9911c1ef944e467773a84/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=049bee09e93919a986c9911c1ef944e467773a84", "patch": "@@ -23,7 +23,7 @@ use borrow_check::nll::renumber;\n use borrow_check::nll::type_check::free_region_relations::{\n     CreateResult, UniversalRegionRelations,\n };\n-use borrow_check::nll::universal_regions::UniversalRegions;\n+use borrow_check::nll::universal_regions::{DefiningTy, UniversalRegions};\n use borrow_check::nll::ToRegionVid;\n use dataflow::move_paths::MoveData;\n use dataflow::FlowAtLocation;\n@@ -1209,7 +1209,21 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 // of lowering. Assignments to other sorts of places *are* interesting\n                 // though.\n                 let category = match *place {\n-                    Place::Local(RETURN_PLACE) => ConstraintCategory::Return,\n+                    Place::Local(RETURN_PLACE) => if let Some(BorrowCheckContext {\n+                        universal_regions: UniversalRegions {\n+                            defining_ty: DefiningTy::Const(def_id, _),\n+                            ..\n+                        },\n+                        ..\n+                    }) = self.borrowck_context {\n+                        if tcx.is_static(*def_id).is_some() {\n+                            ConstraintCategory::UseAsStatic\n+                        } else {\n+                            ConstraintCategory::UseAsConst\n+                        }\n+                    } else {\n+                        ConstraintCategory::Return\n+                    }\n                     Place::Local(l) if !mir.local_decls[l].is_user_variable.is_some() => {\n                         ConstraintCategory::Boring\n                     }\n@@ -1391,6 +1405,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 ref func,\n                 ref args,\n                 ref destination,\n+                from_hir_call,\n                 ..\n             } => {\n                 let func_ty = func.ty(mir, tcx);\n@@ -1435,7 +1450,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     }\n                 }\n \n-                self.check_call_inputs(mir, term, &sig, args, term_location);\n+                self.check_call_inputs(mir, term, &sig, args, term_location, from_hir_call);\n             }\n             TerminatorKind::Assert {\n                 ref cond, ref msg, ..\n@@ -1493,7 +1508,23 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             Some((ref dest, _target_block)) => {\n                 let dest_ty = dest.ty(mir, tcx).to_ty(tcx);\n                 let category = match *dest {\n-                    Place::Local(RETURN_PLACE) => ConstraintCategory::Return,\n+                    Place::Local(RETURN_PLACE) => {\n+                        if let Some(BorrowCheckContext {\n+                            universal_regions: UniversalRegions {\n+                                defining_ty: DefiningTy::Const(def_id, _),\n+                                ..\n+                            },\n+                            ..\n+                        }) = self.borrowck_context {\n+                            if tcx.is_static(*def_id).is_some() {\n+                                ConstraintCategory::UseAsStatic\n+                            } else {\n+                                ConstraintCategory::UseAsConst\n+                            }\n+                        } else {\n+                            ConstraintCategory::Return\n+                        }\n+                    },\n                     Place::Local(l) if !mir.local_decls[l].is_user_variable.is_some() => {\n                         ConstraintCategory::Boring\n                     }\n@@ -1538,18 +1569,24 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         sig: &ty::FnSig<'tcx>,\n         args: &[Operand<'tcx>],\n         term_location: Location,\n+        from_hir_call: bool,\n     ) {\n         debug!(\"check_call_inputs({:?}, {:?})\", sig, args);\n         if args.len() < sig.inputs().len() || (args.len() > sig.inputs().len() && !sig.variadic) {\n             span_mirbug!(self, term, \"call to {:?} with wrong # of args\", sig);\n         }\n         for (n, (fn_arg, op_arg)) in sig.inputs().iter().zip(args).enumerate() {\n             let op_arg_ty = op_arg.ty(mir, self.tcx());\n+            let category = if from_hir_call {\n+                ConstraintCategory::CallArgument\n+            } else {\n+                ConstraintCategory::Boring\n+            };\n             if let Err(terr) = self.sub_types(\n                 op_arg_ty,\n                 fn_arg,\n                 term_location.to_locations(),\n-                ConstraintCategory::CallArgument,\n+                category,\n             ) {\n                 span_mirbug!(\n                     self,"}]}