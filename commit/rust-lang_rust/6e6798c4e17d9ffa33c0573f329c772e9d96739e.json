{"sha": "6e6798c4e17d9ffa33c0573f329c772e9d96739e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlNjc5OGM0ZTE3ZDlmZmEzM2MwNTczZjMyOWM3NzJlOWQ5NjczOWU=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-03-27T01:35:18Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-03-27T01:35:18Z"}, "message": "Bulk-edit mutable -> mut.", "tree": {"sha": "64d4a01e7ed41092983f623b9b0fe0e5abc25200", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64d4a01e7ed41092983f623b9b0fe0e5abc25200"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e6798c4e17d9ffa33c0573f329c772e9d96739e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e6798c4e17d9ffa33c0573f329c772e9d96739e", "html_url": "https://github.com/rust-lang/rust/commit/6e6798c4e17d9ffa33c0573f329c772e9d96739e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e6798c4e17d9ffa33c0573f329c772e9d96739e/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34283ce7e840cbec4ec5704616614dbccdc08e81", "url": "https://api.github.com/repos/rust-lang/rust/commits/34283ce7e840cbec4ec5704616614dbccdc08e81", "html_url": "https://github.com/rust-lang/rust/commit/34283ce7e840cbec4ec5704616614dbccdc08e81"}], "stats": {"total": 1544, "additions": 772, "deletions": 772}, "files": [{"sha": "2b4a389e2f82040a615f0a07bb72d02a813c5dd4", "filename": "doc/keywords.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/doc%2Fkeywords.txt", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/doc%2Fkeywords.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fkeywords.txt?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -8,7 +8,7 @@ else export\n f32 f64 fail false float fn for\n i16 i32 i64 i8 if import in int\n let log loop\n-mod mutable\n+mod mut\n native note\n obj  \n prove pure"}, {"sha": "626351e236c446061850bff0f1d16cfaf6ca5395", "filename": "doc/lib/codemirror-rust.js", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/doc%2Flib%2Fcodemirror-rust.js", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/doc%2Flib%2Fcodemirror-rust.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Flib%2Fcodemirror-rust.js?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -218,14 +218,14 @@ CodeMirror.defineMode(\"rust\", function() {\n       if (content == \"|\") return cont(blockvars, poplex, pushlex(\"}\", \"block\"), block);\n       if (content == \"||\") return cont(poplex, pushlex(\"}\", \"block\"), block);\n     }\n-    if (content == \"mutable\" || (content.match(/^\\w+$/) && cx.stream.peek() == \":\"\n+    if (content == \"mut\" || (content.match(/^\\w+$/) && cx.stream.peek() == \":\"\n                                  && !cx.stream.match(\"::\", false)))\n       return pass(record_of(expression));\n     return pass(block);\n   }\n   function record_of(comb) {\n     function ro(type) {\n-      if (content == \"mutable\" || content == \"with\") {cx.marked = \"keyword\"; return cont(ro);}\n+      if (content == \"mut\" || content == \"with\") {cx.marked = \"keyword\"; return cont(ro);}\n       if (content.match(/^\\w*$/)) {cx.marked = \"variable\"; return cont(ro);}\n       if (type == \":\") return cont(comb, ro);\n       if (type == \"}\") return cont();\n@@ -317,7 +317,7 @@ CodeMirror.defineMode(\"rust\", function() {\n   }\n   function rtype(type) {\n     if (type == \"name\") {cx.marked = \"variable-3\"; return cont(rtypemaybeparam); }\n-    if (content == \"mutable\") {cx.marked = \"keyword\"; return cont(rtype);}\n+    if (content == \"mut\") {cx.marked = \"keyword\"; return cont(rtype);}\n     if (type == \"atom\") return cont(rtypemaybeparam);\n     if (type == \"op\" || type == \"obj\") return cont(rtype);\n     if (type == \"fn\") return cont(fntype);"}, {"sha": "224f4c099f60d749eb4274ebfb7de84196887cf3", "filename": "doc/rust.md", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -217,7 +217,7 @@ else enum export\n fail false fn for\n if iface impl import\n let log loop\n-mod mutable\n+mod mut\n native\n pure\n resource ret\n@@ -1527,13 +1527,13 @@ rec_expr : '{' ident ':' expr\n A _[record](#record-types) expression_ is one or more comma-separated\n name-value pairs enclosed by braces. A fieldname can be any identifier\n (including keywords), and is separated from its value expression by a\n-colon. To indicate that a field is mutable, the `mutable` keyword is\n+colon. To indicate that a field is mutable, the `mut` keyword is\n written before its name.\n \n ~~~~\n {x: 10f, y: 20f};\n {name: \"Joe\", age: 35u, score: 100_000};\n-{ident: \"X\", mutable count: 0u};\n+{ident: \"X\", mut count: 0u};\n ~~~~\n \n The order of the fields in a record expression is significant, and\n@@ -1586,19 +1586,19 @@ expression on the left of the dot.\n ### Vector expressions\n \n ~~~~~~~~{.ebnf .gram}\n-vec_expr : '[' \"mutable\" ? [ expr [ ',' expr ] * ] ? ']'\n+vec_expr : '[' \"mut\" ? [ expr [ ',' expr ] * ] ? ']'\n ~~~~~~~~\n \n A _[vector](#vector-types) expression_ is written by enclosing zero or\n more comma-separated expressions of uniform type in square brackets.\n-The keyword `mutable` can be written after the opening bracket to\n+The keyword `mut` can be written after the opening bracket to\n indicate that the elements of the resulting vector may be mutated.\n When no mutability is specified, the vector is immutable.\n \n ~~~~\n [1, 2, 3, 4];\n [\"a\", \"b\", \"c\", \"d\"];\n-[mutable 0u8, 0u8, 0u8, 0u8];\n+[mut 0u8, 0u8, 0u8, 0u8];\n ~~~~\n \n ### Index expressions\n@@ -1622,7 +1622,7 @@ task in a _failing state_.\n # task::run(builder) {||\n \n [1, 2, 3, 4][0];\n-[mutable 'x', 'y'][1] = 'z';\n+[mut 'x', 'y'][1] = 'z';\n [\"a\", \"b\"][10]; // fails\n \n # }\n@@ -1904,11 +1904,11 @@ argument to a function to be copied and passed by value.\n An example of a copy expression:\n \n ~~~~\n-fn mutate(vec: [mutable int]) {\n+fn mutate(vec: [mut int]) {\n    vec[0] = 10;\n }\n \n-let v = [mutable 1,2,3];\n+let v = [mut 1,2,3];\n \n mutate(copy v);   // Pass a copy\n "}, {"sha": "d2a9e0cecc3ff4a1e5730800474abebb0e92886e", "filename": "doc/tutorial.md", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -366,7 +366,7 @@ more detail later on (the `T`s here stand for any other type):\n `[T]`\n   : Vector type.\n \n-`[mutable T]`\n+`[mut T]`\n   : Mutable vector type.\n \n `(T1, T2)`\n@@ -994,10 +994,10 @@ Fields that you want to mutate must be explicitly marked as such. For\n example...\n \n ~~~~\n-type stack = {content: [int], mutable head: uint};\n+type stack = {content: [int], mut head: uint};\n ~~~~\n \n-With such a type, you can do `mystack.head += 1u`. If `mutable` were\n+With such a type, you can do `mystack.head += 1u`. If `mut` were\n omitted from the type, such an assignment would result in a type\n error.\n \n@@ -1240,12 +1240,12 @@ become the sole owner of the box.\n \n ### Mutability\n \n-All pointer types have a mutable variant, written `@mutable TYPE` or\n-`~mutable TYPE`. Given such a pointer, you can write to its contents\n+All pointer types have a mutable variant, written `@mut TYPE` or\n+`~mut TYPE`. Given such a pointer, you can write to its contents\n by combining the dereference operator with a mutating action.\n \n ~~~~\n-fn increase_contents(pt: @mutable int) {\n+fn increase_contents(pt: @mut int) {\n     *pt += 1;\n }\n ~~~~\n@@ -1268,9 +1268,9 @@ if myvec[1] { io::println(\"boom\"); }\n ~~~~\n \n By default, vectors are immutable\u2014you can not replace their elements.\n-The type written as `[mutable TYPE]` is a vector with mutable\n-elements. Mutable vector literals are written `[mutable]` (empty) or\n-`[mutable 1, 2, 3]` (with elements).\n+The type written as `[mut TYPE]` is a vector with mutable\n+elements. Mutable vector literals are written `[mut]` (empty) or\n+`[mut 1, 2, 3]` (with elements).\n \n The `+` operator means concatenation when applied to vector types.\n Growing a vector in Rust is not as inefficient as it looks :\n@@ -1398,7 +1398,7 @@ to pessimistically assume a value will get mutated, even though it is\n not sure.\n \n ~~~~\n-fn for_each(v: [mutable @int], iter: fn(@int)) {\n+fn for_each(v: [mut @int], iter: fn(@int)) {\n    for elt in v { iter(elt); }\n }\n ~~~~\n@@ -1413,15 +1413,15 @@ reference count is considered cheap enough to not warn about it).\n ## The copy operator\n \n If the `for_each` function given above were to take a vector of\n-`{mutable a: int}` instead of `@int`, it would not be able to\n+`{mut a: int}` instead of `@int`, it would not be able to\n implicitly copy, since if the `iter` function changes a copy of a\n mutable record, the changes won't be visible in the record itself. If\n we *do* want to allow copies there, we have to explicitly allow it\n with the `copy` operator:\n \n ~~~~\n-type mutrec = {mutable x: int};\n-fn for_each(v: [mutable mutrec], iter: fn(mutrec)) {\n+type mutrec = {mut x: int};\n+fn for_each(v: [mut mutrec], iter: fn(mutrec)) {\n    for elt in v { iter(copy elt); }\n }\n ~~~~\n@@ -1529,7 +1529,7 @@ Generic `type` and `enum` declarations follow the same pattern:\n ~~~~\n type circular_buf<T> = {start: uint,\n                         end: uint,\n-                        buf: [mutable T]};\n+                        buf: [mut T]};\n \n enum option<T> { some(T), none }\n ~~~~\n@@ -2315,14 +2315,14 @@ microsecond-resolution timer.\n \n ~~~~\n use std;\n-type timeval = {mutable tv_sec: uint,\n-                mutable tv_usec: uint};\n+type timeval = {mut tv_sec: uint,\n+                mut tv_usec: uint};\n #[nolink]\n native mod libc {\n     fn gettimeofday(tv: *timeval, tz: *()) -> i32;\n }\n fn unix_time_in_microseconds() -> u64 unsafe {\n-    let x = {mutable tv_sec: 0u, mutable tv_usec: 0u};\n+    let x = {mut tv_sec: 0u, mut tv_usec: 0u};\n     libc::gettimeofday(ptr::addr_of(x), ptr::null());\n     ret (x.tv_sec as u64) * 1000_000_u64 + (x.tv_usec as u64);\n }"}, {"sha": "51edc90589acd86a86717410f4014978e213ce2a", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -43,7 +43,7 @@ type source = {\n     sig: option<str>,\n     key: option<str>,\n     keyfp: option<str>,\n-    mutable packages: [package]\n+    mut packages: [package]\n };\n \n type cargo = {\n@@ -117,10 +117,10 @@ fn load_pkg(filename: str) -> option<pkg> {\n     let handler = diagnostic::mk_handler(none);\n     let sess = @{\n         cm: cm,\n-        mutable next_id: 1,\n+        mut next_id: 1,\n         span_diagnostic: diagnostic::mk_span_handler(handler, cm),\n-        mutable chpos: 0u,\n-        mutable byte_pos: 0u\n+        mut chpos: 0u,\n+        mut byte_pos: 0u\n     };\n     let c = parser::parse_crate_from_crate_file(filename, [], sess);\n \n@@ -214,7 +214,7 @@ fn parse_source(name: str, j: json::json) -> source {\n                 _ { none }\n             };\n             ret { name: name, url: url, sig: sig, key: key, keyfp: keyfp,\n-                  mutable packages: [] };\n+                  mut packages: [] };\n         }\n         _ { fail \"Needed dict value in source.\"; }\n     };"}, {"sha": "bbac28ec8449b5993b5e5765549154915057260e", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -119,7 +119,7 @@ fn safe_to_steal_ty(t: @ast::ty, tm: test_mode) -> bool {\n \n // Not type-parameterized: https://github.com/mozilla/rust/issues/898 (FIXED)\n fn stash_expr_if(c: fn@(@ast::expr, test_mode)->bool,\n-                 es: @mutable [ast::expr],\n+                 es: @mut [ast::expr],\n                  e: @ast::expr,\n                  tm: test_mode) {\n     if c(e, tm) {\n@@ -128,7 +128,7 @@ fn stash_expr_if(c: fn@(@ast::expr, test_mode)->bool,\n }\n \n fn stash_ty_if(c: fn@(@ast::ty, test_mode)->bool,\n-               es: @mutable [ast::ty],\n+               es: @mut [ast::ty],\n                e: @ast::ty,\n                tm: test_mode) {\n     if c(e, tm) {\n@@ -139,8 +139,8 @@ fn stash_ty_if(c: fn@(@ast::ty, test_mode)->bool,\n type stolen_stuff = {exprs: [ast::expr], tys: [ast::ty]};\n \n fn steal(crate: ast::crate, tm: test_mode) -> stolen_stuff {\n-    let exprs = @mutable [];\n-    let tys = @mutable [];\n+    let exprs = @mut [];\n+    let tys = @mut [];\n     let v = visit::mk_simple_visitor(@{\n         visit_expr: bind stash_expr_if(safe_to_steal_expr, exprs, _, tm),\n         visit_ty: bind stash_ty_if(safe_to_steal_ty, tys, _, tm)\n@@ -176,8 +176,8 @@ fn safe_to_replace_ty(t: ast::ty_, _tm: test_mode) -> bool {\n // Replace the |i|th expr (in fold order) of |crate| with |newexpr|.\n fn replace_expr_in_crate(crate: ast::crate, i: uint, newexpr: ast::expr, tm: test_mode) ->\n    ast::crate {\n-    let j: @mutable uint = @mutable 0u;\n-    fn fold_expr_rep(j_: @mutable uint, i_: uint, newexpr_: ast::expr_,\n+    let j: @mut uint = @mut 0u;\n+    fn fold_expr_rep(j_: @mut uint, i_: uint, newexpr_: ast::expr_,\n                      original: ast::expr_, fld: fold::ast_fold, tm_: test_mode) ->\n        ast::expr_ {\n         *j_ += 1u;\n@@ -199,8 +199,8 @@ fn replace_expr_in_crate(crate: ast::crate, i: uint, newexpr: ast::expr, tm: tes\n // Replace the |i|th ty (in fold order) of |crate| with |newty|.\n fn replace_ty_in_crate(crate: ast::crate, i: uint, newty: ast::ty, tm: test_mode) ->\n    ast::crate {\n-    let j: @mutable uint = @mutable 0u;\n-    fn fold_ty_rep(j_: @mutable uint, i_: uint, newty_: ast::ty_,\n+    let j: @mut uint = @mut 0u;\n+    fn fold_ty_rep(j_: @mut uint, i_: uint, newty_: ast::ty_,\n                      original: ast::ty_, fld: fold::ast_fold, tm_: test_mode) ->\n        ast::ty_ {\n         *j_ += 1u;\n@@ -403,10 +403,10 @@ fn parse_and_print(code: @str) -> str {\n     let handler = diagnostic::mk_handler(none);\n     let sess = @{\n         cm: cm,\n-        mutable next_id: 1,\n+        mut next_id: 1,\n         span_diagnostic: diagnostic::mk_span_handler(handler, cm),\n-        mutable chpos: 0u,\n-        mutable byte_pos: 0u\n+        mut chpos: 0u,\n+        mut byte_pos: 0u\n     };\n     write_file(filename, *code);\n     let crate = parser::parse_crate_from_source_str(\n@@ -422,8 +422,8 @@ fn parse_and_print(code: @str) -> str {\n }\n \n fn has_raw_pointers(c: ast::crate) -> bool {\n-    let has_rp = @mutable false;\n-    fn visit_ty(flag: @mutable bool, t: @ast::ty) {\n+    let has_rp = @mut false;\n+    fn visit_ty(flag: @mut bool, t: @ast::ty) {\n         alt t.node {\n           ast::ty_ptr(_) { *flag = true; }\n           _ { }\n@@ -549,10 +549,10 @@ fn check_variants(files: [str], cx: context) {\n         let handler = diagnostic::mk_handler(none);\n         let sess = @{\n             cm: cm,\n-            mutable next_id: 1,\n+            mut next_id: 1,\n             span_diagnostic: diagnostic::mk_span_handler(handler, cm),\n-            mutable chpos: 0u,\n-            mutable byte_pos: 0u\n+            mut chpos: 0u,\n+            mut byte_pos: 0u\n         };\n         let crate =\n             parser::parse_crate_from_source_str("}, {"sha": "a20e7651627b80b56516f1d112bd2c3f22d93f1b", "filename": "src/fuzzer/rand_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ffuzzer%2Frand_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ffuzzer%2Frand_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Frand_util.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -12,7 +12,7 @@ fn choice<T: copy>(r : rand::rng, v : [T]) -> T { assert vec::len(v) != 0u; v[un\n fn unlikely(r : rand::rng, n : uint) -> bool { under(r, n) == 0u }\n \n // shuffle a vec in place\n-fn shuffle<T>(r : rand::rng, &v : [mutable T]) {\n+fn shuffle<T>(r : rand::rng, &v : [mut T]) {\n     let i = vec::len(v);\n     while i >= 2u {\n         // Loop invariant: elements with index >= i have been locked in place.\n@@ -73,7 +73,7 @@ fn main()\n     log(error, choice(r, [10, 20, 30]));\n     log(error, if unlikely(r, 5u) { \"unlikely\" } else { \"likely\" });\n \n-    let a = [mutable 1, 2, 3];\n+    let a = [mut 1, 2, 3];\n     shuffle(r, a);\n     log(error, a);\n "}, {"sha": "ba11138d9ae536bede8c2640727c27017640d685", "filename": "src/libcore/future.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibcore%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibcore%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -24,7 +24,7 @@ export spawn;\n \n #[doc = \"The future type\"]\n enum future<A> = {\n-    mutable v: either<@A, fn@() -> A>\n+    mut v: either<@A, fn@() -> A>\n };\n \n #[doc = \"Methods on the `future` type\"]\n@@ -52,7 +52,7 @@ fn from_value<A>(+val: A) -> future<A> {\n     \"];\n \n     future({\n-        mutable v: either::left(@val)\n+        mut v: either::left(@val)\n     })\n }\n \n@@ -79,7 +79,7 @@ fn from_fn<A>(f: fn@() -> A) -> future<A> {\n     \"];\n \n     future({\n-        mutable v: either::right(f)\n+        mut v: either::right(f)\n     })\n }\n "}, {"sha": "4525fade3b83a53aac4c1ed89e9bf9952060340f", "filename": "src/libcore/io.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -174,10 +174,10 @@ fn convert_whence(whence: seek_style) -> i32 {\n \n impl of reader for *libc::FILE {\n     fn read_bytes(len: uint) -> [u8] unsafe {\n-        let mut buf : [mutable u8] = [mutable];\n+        let mut buf : [mut u8] = [mut];\n         vec::reserve(buf, len);\n         vec::as_mut_buf(buf) {|b|\n-            let read = libc::fread(b as *mutable c_void, 1u,\n+            let read = libc::fread(b as *mut c_void, 1u,\n                                    len, self);\n             vec::unsafe::set_len(buf, read);\n         }\n@@ -237,7 +237,7 @@ fn file_reader(path: str) -> result<reader, str> {\n // Byte buffer readers\n \n // TODO: const u8, but this fails with rustboot.\n-type byte_buf = {buf: [u8], mutable pos: uint, len: uint};\n+type byte_buf = {buf: [u8], mut pos: uint, len: uint};\n \n impl of reader for byte_buf {\n     fn read_bytes(len: uint) -> [u8] {\n@@ -268,7 +268,7 @@ fn bytes_reader(bytes: [u8]) -> reader {\n }\n \n fn bytes_reader_between(bytes: [u8], start: uint, end: uint) -> reader {\n-    {buf: bytes, mutable pos: start, len: end} as reader\n+    {buf: bytes, mut pos: start, len: end} as reader\n }\n \n fn with_bytes_reader<t>(bytes: [u8], f: fn(reader) -> t) -> t {\n@@ -514,14 +514,14 @@ fn stderr() -> writer { fd_writer(libc::STDERR_FILENO as c_int, false) }\n fn print(s: str) { stdout().write_str(s); }\n fn println(s: str) { stdout().write_line(s); }\n \n-type mem_buffer = @{mutable buf: [mutable u8],\n-                    mutable pos: uint};\n+type mem_buffer = @{mut buf: [mut u8],\n+                    mut pos: uint};\n \n impl of writer for mem_buffer {\n     fn write(v: [const u8]) {\n         // Fast path.\n         if self.pos == vec::len(self.buf) {\n-            for b: u8 in v { self.buf += [mutable b]; }\n+            for b: u8 in v { self.buf += [mut b]; }\n             self.pos += vec::len(v);\n             ret;\n         }\n@@ -531,7 +531,7 @@ impl of writer for mem_buffer {\n         while vpos < vlen {\n             let b = v[vpos];\n             if self.pos == vec::len(self.buf) {\n-                self.buf += [mutable b];\n+                self.buf += [mut b];\n             } else { self.buf[self.pos] = b; }\n             self.pos += 1u;\n             vpos += 1u;\n@@ -547,7 +547,7 @@ impl of writer for mem_buffer {\n }\n \n fn mem_buffer() -> mem_buffer {\n-    @{mutable buf: [mutable], mutable pos: 0u}\n+    @{mut buf: [mut], mut pos: 0u}\n }\n fn mem_buffer_writer(b: mem_buffer) -> writer { b as writer }\n fn mem_buffer_buf(b: mem_buffer) -> [u8] { vec::from_mut(b.buf) }"}, {"sha": "9b04de10f481f725d3375323f87176865ac8a7fe", "filename": "src/libcore/libc.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibcore%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibcore%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flibc.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -346,17 +346,17 @@ mod types {\n                 type LPCWSTR = *WCHAR;\n                 type LPCSTR = *CHAR;\n \n-                type LPWSTR = *mutable WCHAR;\n-                type LPSTR = *mutable CHAR;\n+                type LPWSTR = *mut WCHAR;\n+                type LPSTR = *mut CHAR;\n \n                 // Not really, but opaque to us.\n                 type LPSECURITY_ATTRIBUTES = LPVOID;\n \n-                type LPVOID = *mutable c_void;\n-                type LPWORD = *mutable WORD;\n+                type LPVOID = *mut c_void;\n+                type LPWORD = *mut WORD;\n \n                 type LRESULT = LONG_PTR;\n-                type PBOOL = *mutable BOOL;\n+                type PBOOL = *mut BOOL;\n                 type WCHAR = wchar_t;\n                 type WORD = u16;\n             }\n@@ -757,7 +757,7 @@ mod funcs {\n             fn setbuf(stream: *FILE, buf: *c_char);\n             // Omitted: printf and scanf variants.\n             fn fgetc(stream: *FILE) -> c_int;\n-            fn fgets(buf: *mutable c_char, n: c_int,\n+            fn fgets(buf: *mut c_char, n: c_int,\n                      stream: *FILE) -> *c_char;\n             fn fputc(c: c_int, stream: *FILE) -> c_int;\n             fn fputs(s: *c_char, stream: *FILE) -> *c_char;\n@@ -769,7 +769,7 @@ mod funcs {\n             // Omitted: putc, putchar (might be macros).\n             fn puts(s: *c_char) -> c_int;\n             fn ungetc(c: c_int, stream: *FILE) -> c_int;\n-            fn fread(ptr: *mutable c_void, size: size_t,\n+            fn fread(ptr: *mut c_void, size: size_t,\n                      nobj: size_t, stream: *FILE) -> size_t;\n             fn fwrite(ptr: *c_void, size: size_t,\n                       nobj: size_t, stream: *FILE) -> size_t;\n@@ -933,11 +933,11 @@ mod funcs {\n             fn lseek(fd: c_int, offset: c_long, origin: c_int) -> c_long;\n \n             #[link_name = \"_pipe\"]\n-            fn pipe(fds: *mutable c_int, psize: c_uint,\n+            fn pipe(fds: *mut c_int, psize: c_uint,\n                     textmode: c_int) -> c_int;\n \n             #[link_name = \"_read\"]\n-            fn read(fd: c_int, buf: *mutable c_void, count: c_uint) -> c_int;\n+            fn read(fd: c_int, buf: *mut c_void, count: c_uint) -> c_int;\n \n             #[link_name = \"_rmdir\"]\n             fn rmdir(path: *c_char) -> c_int;\n@@ -1013,7 +1013,7 @@ mod funcs {\n             fn getegid() -> gid_t;\n             fn geteuid() -> uid_t;\n             fn getgid() -> gid_t ;\n-            fn getgroups(ngroups_max: c_int, groups: *mutable gid_t) -> c_int;\n+            fn getgroups(ngroups_max: c_int, groups: *mut gid_t) -> c_int;\n             fn getlogin() -> *c_char;\n             fn getopt(argc: c_int, argv: **c_char, optstr: *c_char) -> c_int;\n             fn getpgrp() -> pid_t;\n@@ -1025,8 +1025,8 @@ mod funcs {\n             fn lseek(fd: c_int, offset: off_t, whence: c_int) -> off_t;\n             fn pathconf(path: *c_char, name: c_int) -> c_long;\n             fn pause() -> c_int;\n-            fn pipe(fds: *mutable c_int) -> c_int;\n-            fn read(fd: c_int, buf: *mutable c_void,\n+            fn pipe(fds: *mut c_int) -> c_int;\n+            fn read(fd: c_int, buf: *mut c_void,\n                     count: size_t) -> ssize_t;\n             fn rmdir(path: *c_char) -> c_int;\n             fn setgid(gid: gid_t) -> c_int;\n@@ -1050,7 +1050,7 @@ mod funcs {\n         #[nolink]\n         #[abi = \"cdecl\"]\n         native mod unistd {\n-            fn readlink(path: *c_char, buf: *mutable c_char,\n+            fn readlink(path: *c_char, buf: *mut c_char,\n                         bufsz: size_t) -> ssize_t;\n \n             fn fsync(fd: c_int) -> c_int;\n@@ -1067,7 +1067,7 @@ mod funcs {\n         #[nolink]\n         #[abi = \"cdecl\"]\n         native mod wait {\n-            fn waitpid(pid: pid_t, status: *mutable c_int,\n+            fn waitpid(pid: pid_t, status: *mut c_int,\n                        options: c_int) -> pid_t;\n         }\n     }\n@@ -1096,15 +1096,15 @@ mod funcs {\n     native mod bsd44 {\n \n         fn sysctl(name: *c_int, namelen: c_uint,\n-                  oldp: *mutable c_void, oldlenp: *mutable size_t,\n+                  oldp: *mut c_void, oldlenp: *mut size_t,\n                   newp: *c_void, newlen: size_t) -> c_int;\n \n         fn sysctlbyname(name: *c_char,\n-                        oldp: *mutable c_void, oldlenp: *mutable size_t,\n+                        oldp: *mut c_void, oldlenp: *mut size_t,\n                         newp: *c_void, newlen: size_t) -> c_int;\n \n-        fn sysctlnametomib(name: *c_char, mibp: *mutable c_int,\n-                           sizep: *mutable size_t) -> c_int;\n+        fn sysctlnametomib(name: *c_char, mibp: *mut c_int,\n+                           sizep: *mut size_t) -> c_int;\n     }\n \n \n@@ -1118,8 +1118,8 @@ mod funcs {\n     #[nolink]\n     #[abi = \"cdecl\"]\n     native mod extra {\n-        fn _NSGetExecutablePath(buf: *mutable c_char,\n-                                bufsize: *mutable u32) -> c_int;\n+        fn _NSGetExecutablePath(buf: *mut c_char,\n+                                bufsize: *mut u32) -> c_int;\n     }\n \n     #[cfg(target_os = \"freebsd\")]"}, {"sha": "748683121d5b92c71f90b7a39c102963cefe480c", "filename": "src/libcore/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -109,10 +109,10 @@ fn test_unwrap_str() {\n \n #[test]\n fn test_unwrap_resource() {\n-    resource r(i: @mutable int) {\n+    resource r(i: @mut int) {\n         *i += 1;\n     }\n-    let i = @mutable 0;\n+    let i = @mut 0;\n     {\n         let x = r(i);\n         let opt = some(x);"}, {"sha": "c69da22aa6ff829176501fdbb09dad3b66a6f549", "filename": "src/libcore/os.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -61,7 +61,7 @@ fn as_c_charp<T>(s: str, f: fn(*c_char) -> T) -> T {\n     str::as_c_str(s) {|b| f(b as *c_char) }\n }\n \n-fn fill_charp_buf(f: fn(*mutable c_char, size_t) -> bool)\n+fn fill_charp_buf(f: fn(*mut c_char, size_t) -> bool)\n     -> option<str> {\n     let buf = vec::to_mut(vec::from_elem(tmpbuf_sz, 0u8 as c_char));\n     vec::as_mut_buf(buf) { |b|\n@@ -77,7 +77,7 @@ fn fill_charp_buf(f: fn(*mutable c_char, size_t) -> bool)\n mod win32 {\n     import dword = libc::types::os::arch::extra::DWORD;\n \n-    fn fill_utf16_buf_and_decode(f: fn(*mutable u16, dword) -> dword)\n+    fn fill_utf16_buf_and_decode(f: fn(*mut u16, dword) -> dword)\n         -> option<str> {\n \n         // FIXME: remove these when export globs work properly.\n@@ -241,8 +241,8 @@ fn waitpid(pid: pid_t) -> c_int {\n #[cfg(target_os = \"freebsd\")]\n #[cfg(target_os = \"macos\")]\n fn pipe() -> {in: c_int, out: c_int} {\n-    let fds = {mutable in: 0 as c_int,\n-               mutable out: 0 as c_int };\n+    let fds = {mut in: 0 as c_int,\n+               mut out: 0 as c_int };\n     assert (libc::pipe(ptr::mut_addr_of(fds.in)) == (0 as c_int));\n     ret {in: fds.in, out: fds.out};\n }\n@@ -258,8 +258,8 @@ fn pipe() -> {in: c_int, out: c_int} {\n     // understand. Here we explicitly make the pipe non-inheritable, which\n     // means to pass it to a subprocess they need to be duplicated first, as\n     // in rust_run_program.\n-    let fds = { mutable in: 0 as c_int,\n-               mutable out: 0 as c_int };\n+    let fds = { mut in: 0 as c_int,\n+               mut out: 0 as c_int };\n     let res = libc::pipe(ptr::mut_addr_of(fds.in),\n                          1024 as c_uint,\n                          (O_BINARY | O_NOINHERIT) as c_int);\n@@ -294,7 +294,7 @@ fn self_exe_path() -> option<path> {\n                        KERN_PROC as c_int,\n                        KERN_PROC_PATHNAME as c_int, -1 as c_int];\n             sysctl(vec::unsafe::to_ptr(mib), vec::len(mib) as c_uint,\n-                   buf as *mutable c_void, ptr::mut_addr_of(sz),\n+                   buf as *mut c_void, ptr::mut_addr_of(sz),\n                    ptr::null(), 0u as size_t) == (0 as c_int)\n         }\n     }"}, {"sha": "a7bcfe5c9a8e0db5307a43110014807f3fc1ebbf", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -28,9 +28,9 @@ native mod rusti {\n #[inline(always)]\n fn addr_of<T>(val: T) -> *T { rusti::addr_of(val) }\n \n-#[doc = \"Get an unsafe mutable pointer to a value\"]\n+#[doc = \"Get an unsafe mut pointer to a value\"]\n #[inline(always)]\n-fn mut_addr_of<T>(val: T) -> *mutable T unsafe {\n+fn mut_addr_of<T>(val: T) -> *mut T unsafe {\n     unsafe::reinterpret_cast(rusti::addr_of(val))\n }\n \n@@ -40,10 +40,10 @@ fn offset<T>(ptr: *T, count: uint) -> *T unsafe {\n     (ptr as uint + count * sys::size_of::<T>()) as *T\n }\n \n-#[doc = \"Calculate the offset from a mutable pointer\"]\n+#[doc = \"Calculate the offset from a mut pointer\"]\n #[inline(always)]\n-fn mut_offset<T>(ptr: *mutable T, count: uint) -> *mutable T {\n-    (ptr as uint + count * sys::size_of::<T>()) as *mutable T\n+fn mut_offset<T>(ptr: *mut T, count: uint) -> *mut T {\n+    (ptr as uint + count * sys::size_of::<T>()) as *mut T\n }\n \n \n@@ -77,16 +77,16 @@ unsafe fn memmove<T>(dst: *T, src: *T, count: uint)  {\n \n #[test]\n fn test() unsafe {\n-    type pair = {mutable fst: int, mutable snd: int};\n-    let p = {mutable fst: 10, mutable snd: 20};\n-    let pptr: *mutable pair = mut_addr_of(p);\n-    let iptr: *mutable int = unsafe::reinterpret_cast(pptr);\n+    type pair = {mut fst: int, mut snd: int};\n+    let p = {mut fst: 10, mut snd: 20};\n+    let pptr: *mut pair = mut_addr_of(p);\n+    let iptr: *mut int = unsafe::reinterpret_cast(pptr);\n     assert (*iptr == 10);;\n     *iptr = 30;\n     assert (*iptr == 30);\n     assert (p.fst == 30);;\n \n-    *pptr = {mutable fst: 50, mutable snd: 60};\n+    *pptr = {mut fst: 50, mut snd: 60};\n     assert (*iptr == 50);\n     assert (p.fst == 50);\n     assert (p.snd == 60);"}, {"sha": "e0812b2117dcd1db2d3365bd8c549ef54dd03c83", "filename": "src/libcore/run.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -198,10 +198,10 @@ fn start_program(prog: str, args: [str]) -> program {\n     libc::close(pipe_err.out);\n \n     type prog_repr = {pid: pid_t,\n-                      mutable in_fd: c_int,\n+                      mut in_fd: c_int,\n                       out_file: *libc::FILE,\n                       err_file: *libc::FILE,\n-                      mutable finished: bool};\n+                      mut finished: bool};\n \n     fn close_repr_input(r: prog_repr) {\n         let invalid_fd = -1i32;\n@@ -233,10 +233,10 @@ fn start_program(prog: str, args: [str]) -> program {\n         fn destroy() { destroy_repr(*self); }\n     }\n     let repr = {pid: pid,\n-                mutable in_fd: pipe_input.out,\n+                mut in_fd: pipe_input.out,\n                 out_file: os::fdopen(pipe_output.in),\n                 err_file: os::fdopen(pipe_err.in),\n-                mutable finished: false};\n+                mut finished: false};\n     ret prog_res(repr) as program;\n }\n "}, {"sha": "dcd784fb2a3278c9a35322d5f9a006ed4420243d", "filename": "src/libcore/task.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -157,8 +157,8 @@ Provides detailed control over the properties and behavior of new tasks.\n // the run function move them in.\n enum task_builder {\n     task_builder_({\n-        mutable opts: task_opts,\n-        mutable gen_body: fn@(+fn~()) -> fn~(),\n+        mut opts: task_opts,\n+        mut gen_body: fn@(+fn~()) -> fn~(),\n         can_not_copy: option<comm::port<()>>\n     })\n }\n@@ -187,8 +187,8 @@ fn task_builder() -> task_builder {\n     let body_identity = fn@(+body: fn~()) -> fn~() { body };\n \n     task_builder_({\n-        mutable opts: default_task_opts(),\n-        mutable gen_body: body_identity,\n+        mut opts: default_task_opts(),\n+        mut gen_body: body_identity,\n         can_not_copy: none\n     })\n }"}, {"sha": "0f19a6c64ffe1d83542a0cec1cbc1a1a2c306ff7", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -150,15 +150,15 @@ fn from_elem<T: copy>(n_elts: uint, t: T) -> [T] {\n     ret v;\n }\n \n-#[doc = \"Produces a mutable vector from an immutable vector.\"]\n-fn to_mut<T>(+v: [T]) -> [mutable T] unsafe {\n+#[doc = \"Produces a mut vector from an immutable vector.\"]\n+fn to_mut<T>(+v: [T]) -> [mut T] unsafe {\n     let r = ::unsafe::reinterpret_cast(v);\n     ::unsafe::forget(v);\n     r\n }\n \n-#[doc = \"Produces an immutable vector from a mutable vector.\"]\n-fn from_mut<T>(+v: [mutable T]) -> [T] unsafe {\n+#[doc = \"Produces an immutable vector from a mut vector.\"]\n+fn from_mut<T>(+v: [mut T]) -> [T] unsafe {\n     let r = ::unsafe::reinterpret_cast(v);\n     ::unsafe::forget(v);\n     r\n@@ -396,7 +396,7 @@ Sets the element at position `index` to `val`. If `index` is past the end\n of the vector, expands the vector by replicating `initval` to fill the\n intervening space.\n \"]\n-fn grow_set<T: copy>(&v: [mutable T], index: uint, initval: T, val: T) {\n+fn grow_set<T: copy>(&v: [mut T], index: uint, initval: T, val: T) {\n     if index >= len(v) { grow(v, index - len(v) + 1u, initval); }\n     v[index] = val;\n }\n@@ -729,12 +729,12 @@ Swaps two elements in a vector\n * a - The index of the first element\n * b - The index of the second element\n \"]\n-fn swap<T>(v: [mutable T], a: uint, b: uint) {\n+fn swap<T>(v: [mut T], a: uint, b: uint) {\n     v[a] <-> v[b];\n }\n \n #[doc = \"Reverse the order of elements in a vector, in place\"]\n-fn reverse<T>(v: [mutable T]) {\n+fn reverse<T>(v: [mut T]) {\n     let mut i: uint = 0u;\n     let ln = len::<T>(v);\n     while i < ln / 2u { v[i] <-> v[ln - i - 1u]; i += 1u; }\n@@ -890,8 +890,8 @@ fn as_buf<E,T>(v: [const E], f: fn(*E) -> T) -> T unsafe {\n     let buf = unsafe::to_ptr(v); f(buf)\n }\n \n-fn as_mut_buf<E,T>(v: [mutable E], f: fn(*mutable E) -> T) -> T unsafe {\n-    let buf = unsafe::to_ptr(v) as *mutable E; f(buf)\n+fn as_mut_buf<E,T>(v: [mut E], f: fn(*mut E) -> T) -> T unsafe {\n+    let buf = unsafe::to_ptr(v) as *mut E; f(buf)\n }\n \n #[doc = \"An extension implementation providing a `len` method\"]\n@@ -905,7 +905,7 @@ impl vec_len<T> for [const T] {\n mod unsafe {\n     // FIXME: This should have crate visibility\n     #[doc = \"The internal representation of a vector\"]\n-    type vec_repr = {mutable fill: uint, mutable alloc: uint, data: u8};\n+    type vec_repr = {mut fill: uint, mut alloc: uint, data: u8};\n \n     #[doc = \"\n     Constructs a vector from an unsafe pointer to a buffer\n@@ -1212,7 +1212,7 @@ mod tests {\n \n     #[test]\n     fn test_grow_set() {\n-        let mut v = [mutable 1, 2, 3];\n+        let mut v = [mut 1, 2, 3];\n         grow_set(v, 4u, 4, 5);\n         assert (len(v) == 5u);\n         assert (v[0] == 1);\n@@ -1619,7 +1619,7 @@ mod tests {\n \n     #[test]\n     fn reverse_and_reversed() {\n-        let v: [mutable int] = [mutable 10, 20];\n+        let v: [mut int] = [mut 10, 20];\n         assert (v[0] == 10);\n         assert (v[1] == 20);\n         reverse(v);\n@@ -1634,13 +1634,13 @@ mod tests {\n \n         let v4 = reversed::<int>([]);\n         assert (v4 == []);\n-        let v3: [mutable int] = [mutable];\n+        let v3: [mut int] = [mut];\n         reverse::<int>(v3);\n     }\n \n     #[test]\n     fn reversed_mut() {\n-        let v2 = reversed::<int>([mutable 10, 20]);\n+        let v2 = reversed::<int>([mut 10, 20]);\n         assert (v2[0] == 20);\n         assert (v2[1] == 10);\n     }"}, {"sha": "37df940f6fbd2f3eb9eac1efab95582beb4686d7", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -22,7 +22,7 @@ export eq_vec;\n //        for the case where nbits <= 32.\n \n #[doc = \"The bitvector type\"]\n-type bitv = @{storage: [mutable uint], nbits: uint};\n+type bitv = @{storage: [mut uint], nbits: uint};\n \n const uint_bits: uint = 32u + (1u << 32u >> 27u);\n "}, {"sha": "ce89f323cdc76da43b47b2c6e6f2401a7c678b9d", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -4,7 +4,7 @@ Library to interface with chunks of memory allocated in C.\n It is often desirable to safely interface with memory allocated from C,\n encapsulating the unsafety into allocation and destruction time.  Indeed,\n allocating memory externally is currently the only way to give Rust shared\n-mutable state with C programs that keep their own references; vectors are\n+mut state with C programs that keep their own references; vectors are\n unsuitable because they could be reallocated or moved at any time, and\n importing C memory into a vector takes a one-time snapshot of the memory.\n \n@@ -38,7 +38,7 @@ Wrapped in a enum for opacity; FIXME #818 when it is possible to have\n truly opaque types, this should be revisited.\n \"]\n enum c_vec<T> {\n-    c_vec_({ base: *mutable T, len: uint, rsrc: @dtor_res})\n+    c_vec_({ base: *mut T, len: uint, rsrc: @dtor_res})\n }\n \n resource dtor_res(dtor: option<fn@()>) {\n@@ -60,7 +60,7 @@ Create a `c_vec` from a native buffer with a given length.\n * base - A native pointer to a buffer\n * len - The number of elements in the buffer\n \"]\n-unsafe fn c_vec<T>(base: *mutable T, len: uint) -> c_vec<T> {\n+unsafe fn c_vec<T>(base: *mut T, len: uint) -> c_vec<T> {\n     ret c_vec_({\n         base: base,\n         len: len,\n@@ -79,7 +79,7 @@ and a function to run upon destruction.\n * dtor - A function to run when the value is destructed, useful\n          for freeing the buffer, etc.\n \"]\n-unsafe fn c_vec_with_dtor<T>(base: *mutable T, len: uint, dtor: fn@())\n+unsafe fn c_vec_with_dtor<T>(base: *mut T, len: uint, dtor: fn@())\n   -> c_vec<T> {\n     ret c_vec_({\n         base: base,\n@@ -122,7 +122,7 @@ fn len<T>(t: c_vec<T>) -> uint {\n }\n \n #[doc = \"Returns a pointer to the first element of the vector\"]\n-unsafe fn ptr<T>(t: c_vec<T>) -> *mutable T {\n+unsafe fn ptr<T>(t: c_vec<T>) -> *mut T {\n     ret (*t).base;\n }\n \n@@ -135,7 +135,7 @@ mod tests {\n \n         assert mem as int != 0;\n \n-        ret unsafe { c_vec_with_dtor(mem as *mutable u8, n,\n+        ret unsafe { c_vec_with_dtor(mem as *mut u8, n,\n                                      bind free(mem)) };\n     }\n "}, {"sha": "8a894a4b8f3510f431b18cdb5bf60c17fc6cd1ba", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -23,30 +23,30 @@ fn create<T: copy>() -> t<T> {\n       * Grow is only called on full elts, so nelts is also len(elts), unlike\n       * elsewhere.\n       */\n-    fn grow<T: copy>(nelts: uint, lo: uint, elts: [mutable cell<T>]) ->\n-       [mutable cell<T>] {\n+    fn grow<T: copy>(nelts: uint, lo: uint, elts: [mut cell<T>]) ->\n+       [mut cell<T>] {\n         assert (nelts == vec::len(elts));\n-        let mut rv = [mutable];\n+        let mut rv = [mut];\n \n         let mut i = 0u;\n         let nalloc = uint::next_power_of_two(nelts + 1u);\n         while i < nalloc {\n             if i < nelts {\n-                rv += [mutable elts[(lo + i) % nelts]];\n-            } else { rv += [mutable none]; }\n+                rv += [mut elts[(lo + i) % nelts]];\n+            } else { rv += [mut none]; }\n             i += 1u;\n         }\n \n         ret rv;\n     }\n-    fn get<T: copy>(elts: [mutable cell<T>], i: uint) -> T {\n+    fn get<T: copy>(elts: [mut cell<T>], i: uint) -> T {\n         ret alt elts[i] { some(t) { t } _ { fail } };\n     }\n \n-    type repr<T> = {mutable nelts: uint,\n-                    mutable lo: uint,\n-                    mutable hi: uint,\n-                    mutable elts: [mutable cell<T>]};\n+    type repr<T> = {mut nelts: uint,\n+                    mut lo: uint,\n+                    mut hi: uint,\n+                    mut elts: [mut cell<T>]};\n \n     impl <T: copy> of t<T> for repr<T> {\n         fn size() -> uint { ret self.nelts; }\n@@ -102,10 +102,10 @@ fn create<T: copy>() -> t<T> {\n     }\n \n     let repr: repr<T> = {\n-        mutable nelts: 0u,\n-        mutable lo: 0u,\n-        mutable hi: 0u,\n-        mutable elts: vec::to_mut(vec::from_elem(initial_capacity, none))\n+        mut nelts: 0u,\n+        mut lo: 0u,\n+        mut hi: 0u,\n+        mut elts: vec::to_mut(vec::from_elem(initial_capacity, none))\n     };\n     repr as t::<T>\n }"}, {"sha": "91a9c244011e81f004f5bca5f2f356eb29932f15", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -149,7 +149,7 @@ fn doc_as_i32(d: doc) -> i32 { doc_as_u32(d) as i32 }\n fn doc_as_i64(d: doc) -> i64 { doc_as_u64(d) as i64 }\n \n // ebml writing\n-type writer = {writer: io::writer, mutable size_positions: [uint]};\n+type writer = {writer: io::writer, mut size_positions: [uint]};\n \n fn write_sized_vuint(w: io::writer, n: uint, size: uint) {\n     let buf: [u8] = alt size {\n@@ -178,7 +178,7 @@ fn write_vuint(w: io::writer, n: uint) {\n \n fn writer(w: io::writer) -> writer {\n     let size_positions: [uint] = [];\n-    ret {writer: w, mutable size_positions: size_positions};\n+    ret {writer: w, mut size_positions: size_positions};\n }\n \n // TODO: Provide a function to write the standard ebml header.\n@@ -361,11 +361,11 @@ impl serializer of serialization::serializer for ebml::writer {\n     fn emit_tup_elt(_idx: uint, f: fn()) { f() }\n }\n \n-type ebml_deserializer = {mutable parent: ebml::doc,\n-                          mutable pos: uint};\n+type ebml_deserializer = {mut parent: ebml::doc,\n+                          mut pos: uint};\n \n fn ebml_deserializer(d: ebml::doc) -> ebml_deserializer {\n-    {mutable parent: d, mutable pos: d.start}\n+    {mut parent: d, mut pos: d.start}\n }\n \n impl deserializer of serialization::deserializer for ebml_deserializer {"}, {"sha": "3d921fb4d9d3555c404551388c01f3b33f62c2a9", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -114,7 +114,7 @@ enum optval { val(str), given, }\n The result of checking command line arguments. Contains a vector\n of matches and a vector of free strings.\n \"]\n-type match = {opts: [opt], vals: [mutable [optval]], free: [str]};\n+type match = {opts: [opt], vals: [mut [optval]], free: [str]};\n \n fn is_arg(arg: str) -> bool {\n     ret str::len(arg) > 1u && arg[0] == '-' as u8;"}, {"sha": "b9931ba3f860775caef8618f9e19496e48b25881", "filename": "src/libstd/json.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -109,9 +109,9 @@ fn to_str(j: json) -> str {\n \n type parser = {\n     rdr: io::reader,\n-    mutable ch: char,\n-    mutable line: uint,\n-    mutable col: uint,\n+    mut ch: char,\n+    mut line: uint,\n+    mut col: uint,\n };\n \n impl parser for parser {\n@@ -458,9 +458,9 @@ impl parser for parser {\n fn from_reader(rdr: io::reader) -> result<json, error> {\n     let parser = {\n         rdr: rdr,\n-        mutable ch: rdr.read_char(),\n-        mutable line: 1u,\n-        mutable col: 1u,\n+        mut ch: rdr.read_char(),\n+        mut line: 1u,\n+        mut col: 1u,\n     };\n \n     parser.parse()"}, {"sha": "bf2f51cf82d95b8bb6307970cdc16c688b2c556b", "filename": "src/libstd/list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -164,7 +164,7 @@ mod tests {\n \n     #[test]\n     fn test_from_vec_mut() {\n-        let l = from_vec([mutable 0, 1, 2]);\n+        let l = from_vec([mut 0, 1, 2]);\n \n         assert (head(l) == 0);\n "}, {"sha": "a35b51be900cf4ace603e78f138c08b4e222a7d2", "filename": "src/libstd/map.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -71,8 +71,8 @@ mod chained {\n     type entry<K, V> = {\n         hash: uint,\n         key: K,\n-        mutable value: V,\n-        mutable next: chain<K, V>\n+        mut value: V,\n+        mut next: chain<K, V>\n     };\n \n     enum chain<K, V> {\n@@ -81,8 +81,8 @@ mod chained {\n     }\n \n     type t<K, V> = @{\n-        mutable count: uint,\n-        mutable chains: [mutable chain<K,V>],\n+        mut count: uint,\n+        mut chains: [mut chain<K,V>],\n         hasher: hashfn<K>,\n         eqer: eqfn<K>\n     };\n@@ -152,8 +152,8 @@ mod chained {\n             tbl.chains[idx] = present(@{\n                 hash: hash,\n                 key: k,\n-                mutable value: v,\n-                mutable next: old_chain});\n+                mut value: v,\n+                mut next: old_chain});\n             ret true;\n           }\n           found_first(_, entry) {\n@@ -203,7 +203,7 @@ mod chained {\n         }\n     }\n \n-    fn chains<K: copy, V: copy>(nchains: uint) -> [mutable chain<K,V>] {\n+    fn chains<K: copy, V: copy>(nchains: uint) -> [mut chain<K,V>] {\n         ret vec::to_mut(vec::from_elem(nchains, absent));\n     }\n \n@@ -286,8 +286,8 @@ mod chained {\n \n     fn mk<K: copy, V: copy>(hasher: hashfn<K>, eqer: eqfn<K>) -> t<K,V> {\n         let initial_capacity: uint = 32u; // 2^5\n-        let slf: t<K, V> = @{mutable count: 0u,\n-                             mutable chains: chains(initial_capacity),\n+        let slf: t<K, V> = @{mut count: 0u,\n+                             mut chains: chains(initial_capacity),\n                              hasher: hasher,\n                              eqer: eqer};\n         slf"}, {"sha": "735d273faa302d2b669bf6376a5e35d26d6a4a9d", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -154,7 +154,7 @@ rope remains balanced. However, this function does not take any further\n measure to ensure that the result is balanced.\n \"]\n fn concat(v: [rope]) -> rope {\n-    //Copy `v` into a mutable vector\n+    //Copy `v` into a mut vector\n     let mut len = vec::len(v);\n     if len == 0u { ret node::empty; }\n     let ropes = vec::to_mut(vec::from_elem(len, v[0]));\n@@ -752,7 +752,7 @@ mod node {\n     * forest - The forest. This vector is progressively rewritten during\n                execution and should be discarded as meaningless afterwards.\n     \"]\n-    fn tree_from_forest_destructive(forest: [mutable @node]) -> @node {\n+    fn tree_from_forest_destructive(forest: [mut @node]) -> @node {\n         let mut i = 0u;\n         let mut len = vec::len(forest);\n         while len > 1u {\n@@ -861,12 +861,12 @@ mod node {\n     fn bal(node: @node) -> option<@node> {\n         if height(node) < hint_max_node_height { ret option::none; }\n         //1. Gather all leaves as a forest\n-        let mut forest = [mutable];\n+        let mut forest = [mut];\n         let it = leaf_iterator::start(node);\n         loop {\n             alt (leaf_iterator::next(it)) {\n               option::none   { break; }\n-              option::some(x) { forest += [mutable @leaf(x)]; }\n+              option::some(x) { forest += [mut @leaf(x)]; }\n             }\n         }\n         //2. Rebuild tree from forest\n@@ -1117,20 +1117,20 @@ mod node {\n \n     mod leaf_iterator {\n         type t = {\n-            stack:            [mutable @node],\n-            mutable stackpos: int\n+            stack:            [mut @node],\n+            mut stackpos: int\n         };\n \n         fn empty() -> t {\n-            let stack : [mutable @node] = [mutable];\n-            ret {stack: stack, mutable stackpos: -1}\n+            let stack : [mut @node] = [mut];\n+            ret {stack: stack, mut stackpos: -1}\n         }\n \n         fn start(node: @node) -> t {\n             let stack = vec::to_mut(vec::from_elem(height(node)+1u, node));\n             ret {\n                 stack:             stack,\n-                mutable stackpos:  0\n+                mut stackpos:  0\n             }\n         }\n \n@@ -1157,23 +1157,23 @@ mod node {\n     mod char_iterator {\n         type t = {\n             leaf_iterator: leaf_iterator::t,\n-            mutable leaf:  option<leaf>,\n-            mutable leaf_byte_pos: uint\n+            mut leaf:  option<leaf>,\n+            mut leaf_byte_pos: uint\n         };\n \n         fn start(node: @node) -> t {\n             ret {\n                 leaf_iterator: leaf_iterator::start(node),\n-                mutable leaf:          option::none,\n-                mutable leaf_byte_pos: 0u\n+                mut leaf:          option::none,\n+                mut leaf_byte_pos: 0u\n             }\n         }\n \n         fn empty() -> t {\n             ret {\n                 leaf_iterator: leaf_iterator::empty(),\n-                mutable leaf:  option::none,\n-                mutable leaf_byte_pos: 0u\n+                mut leaf:  option::none,\n+                mut leaf_byte_pos: 0u\n             }\n         }\n \n@@ -1242,8 +1242,8 @@ mod tests {\n         alt(r) {\n           node::empty { ret \"\" }\n           node::content(x) {\n-            let str = @mutable \"\";\n-            fn aux(str: @mutable str, node: @node::node) unsafe {\n+            let str = @mut \"\";\n+            fn aux(str: @mut str, node: @node::node) unsafe {\n                 alt(*node) {\n                   node::leaf(x) {\n                     *str += str::slice(\n@@ -1280,7 +1280,7 @@ mod tests {\n \n     #[test]\n     fn of_string2() {\n-        let buf = @ mutable \"1234567890\";\n+        let buf = @ mut \"1234567890\";\n         let mut i = 0;\n         while i < 10 { *buf = *buf + *buf; i+=1;}\n         let sample = @*buf;\n@@ -1313,7 +1313,7 @@ mod tests {\n \n     #[test]\n     fn iter1() {\n-        let buf = @ mutable \"1234567890\";\n+        let buf = @ mut \"1234567890\";\n         let mut i = 0;\n         while i < 10 { *buf = *buf + *buf; i+=1;}\n         let sample = @*buf;\n@@ -1334,7 +1334,7 @@ mod tests {\n     #[test]\n     fn bal1() {\n         let init = @ \"1234567890\";\n-        let buf  = @ mutable * init;\n+        let buf  = @ mut * init;\n         let mut i = 0;\n         while i < 8 { *buf = *buf + *buf; i+=1;}\n         let sample = @*buf;"}, {"sha": "8e5f0cb122ae451655140bf3a706849ac9f0e9b7", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -52,13 +52,13 @@ const k3: u32 = 0xCA62C1D6u32;\n #[doc = \"Construct a `sha` object\"]\n fn sha1() -> sha1 {\n     type sha1state =\n-        {h: [mutable u32],\n-         mutable len_low: u32,\n-         mutable len_high: u32,\n-         msg_block: [mutable u8],\n-         mutable msg_block_idx: uint,\n-         mutable computed: bool,\n-         work_buf: [mutable u32]};\n+        {h: [mut u32],\n+         mut len_low: u32,\n+         mut len_high: u32,\n+         msg_block: [mut u8],\n+         mut msg_block_idx: uint,\n+         mut computed: bool,\n+         work_buf: [mut u32]};\n \n     fn add_input(st: sha1state, msg: [u8]) {\n         // FIXME: Should be typestate precondition\n@@ -244,11 +244,11 @@ fn sha1() -> sha1 {\n     }\n     let st = {\n         h: vec::to_mut(vec::from_elem(digest_buf_len, 0u32)),\n-        mutable len_low: 0u32,\n-        mutable len_high: 0u32,\n+        mut len_low: 0u32,\n+        mut len_high: 0u32,\n         msg_block: vec::to_mut(vec::from_elem(msg_block_len, 0u8)),\n-        mutable msg_block_idx: 0u,\n-        mutable computed: false,\n+        mut msg_block_idx: 0u,\n+        mut computed: false,\n         work_buf: vec::to_mut(vec::from_elem(work_buf_len, 0u32))\n     };\n     let sh = st as sha1;"}, {"sha": "a088cd52f68a0a696d0305a71a9f7e6478e80e7e", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -7,12 +7,12 @@ import core::option::{some, none};\n \n // FIXME: Should not be @; there's a bug somewhere in rustc that requires this\n // to be.\n-type smallintmap<T: copy> = @{mutable v: [mutable option<T>]};\n+type smallintmap<T: copy> = @{mut v: [mut option<T>]};\n \n #[doc = \"Create a smallintmap\"]\n fn mk<T: copy>() -> smallintmap<T> {\n-    let v: [mutable option<T>] = [mutable];\n-    ret @{mutable v: v};\n+    let v: [mut option<T>] = [mut];\n+    ret @{mut v: v};\n }\n \n #[doc = \""}, {"sha": "8385158e93a706b21216ce8b931b0f4038fcb7e5", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -51,7 +51,7 @@ fn merge_sort<T: copy>(le: le<T>, v: [const T]) -> [T] {\n     }\n }\n \n-fn part<T: copy>(compare_func: le<T>, arr: [mutable T], left: uint,\n+fn part<T: copy>(compare_func: le<T>, arr: [mut T], left: uint,\n                 right: uint, pivot: uint) -> uint {\n     let pivot_value = arr[pivot];\n     arr[pivot] <-> arr[right];\n@@ -68,7 +68,7 @@ fn part<T: copy>(compare_func: le<T>, arr: [mutable T], left: uint,\n     ret storage_index;\n }\n \n-fn qsort<T: copy>(compare_func: le<T>, arr: [mutable T], left: uint,\n+fn qsort<T: copy>(compare_func: le<T>, arr: [mut T], left: uint,\n              right: uint) {\n     if right > left {\n         let pivot = (left + right) / 2u;\n@@ -82,18 +82,18 @@ fn qsort<T: copy>(compare_func: le<T>, arr: [mutable T], left: uint,\n }\n \n #[doc = \"\n-Quicksort. Sorts a mutable vector in place.\n+Quicksort. Sorts a mut vector in place.\n \n Has worst case O(n^2) performance, average case O(n log n).\n This is an unstable sort.\n \"]\n-fn quick_sort<T: copy>(compare_func: le<T>, arr: [mutable T]) {\n+fn quick_sort<T: copy>(compare_func: le<T>, arr: [mut T]) {\n     if len::<T>(arr) == 0u { ret; }\n     qsort::<T>(compare_func, arr, 0u, len::<T>(arr) - 1u);\n }\n \n fn qsort3<T: copy>(compare_func_lt: le<T>, compare_func_eq: le<T>,\n-                  arr: [mutable T], left: int, right: int) {\n+                  arr: [mut T], left: int, right: int) {\n     if right <= left { ret; }\n     let v: T = arr[right];\n     let mut i: int = left - 1;\n@@ -142,7 +142,7 @@ fn qsort3<T: copy>(compare_func_lt: le<T>, compare_func_eq: le<T>,\n \n // FIXME: This should take lt and eq types\n #[doc = \"\n-Fancy quicksort. Sorts a mutable vector in place.\n+Fancy quicksort. Sorts a mut vector in place.\n \n Based on algorithm presented by [Sedgewick and Bentley]\n (http://www.cs.princeton.edu/~rs/talks/QuicksortIsOptimal.pdf).\n@@ -152,15 +152,15 @@ According to these slides this is the algorithm of choice for\n This is an unstable sort.\n \"]\n fn quick_sort3<T: copy>(compare_func_lt: le<T>, compare_func_eq: le<T>,\n-                       arr: [mutable T]) {\n+                       arr: [mut T]) {\n     if len::<T>(arr) == 0u { ret; }\n     qsort3::<T>(compare_func_lt, compare_func_eq, arr, 0,\n                 (len::<T>(arr) as int) - 1);\n }\n \n #[cfg(test)]\n mod test_qsort3 {\n-    fn check_sort(v1: [mutable int], v2: [mutable int]) {\n+    fn check_sort(v1: [mut int], v2: [mut int]) {\n         let len = vec::len::<int>(v1);\n         fn lt(&&a: int, &&b: int) -> bool { ret a < b; }\n         fn equal(&&a: int, &&b: int) -> bool { ret a == b; }\n@@ -178,32 +178,32 @@ mod test_qsort3 {\n     #[test]\n     fn test() {\n         {\n-            let v1 = [mutable 3, 7, 4, 5, 2, 9, 5, 8];\n-            let v2 = [mutable 2, 3, 4, 5, 5, 7, 8, 9];\n+            let v1 = [mut 3, 7, 4, 5, 2, 9, 5, 8];\n+            let v2 = [mut 2, 3, 4, 5, 5, 7, 8, 9];\n             check_sort(v1, v2);\n         }\n         {\n-            let v1 = [mutable 1, 1, 1];\n-            let v2 = [mutable 1, 1, 1];\n+            let v1 = [mut 1, 1, 1];\n+            let v2 = [mut 1, 1, 1];\n             check_sort(v1, v2);\n         }\n         {\n-            let v1: [mutable int] = [mutable];\n-            let v2: [mutable int] = [mutable];\n+            let v1: [mut int] = [mut];\n+            let v2: [mut int] = [mut];\n             check_sort(v1, v2);\n         }\n-        { let v1 = [mutable 9]; let v2 = [mutable 9]; check_sort(v1, v2); }\n+        { let v1 = [mut 9]; let v2 = [mut 9]; check_sort(v1, v2); }\n         {\n-            let v1 = [mutable 9, 3, 3, 3, 9];\n-            let v2 = [mutable 3, 3, 3, 9, 9];\n+            let v1 = [mut 9, 3, 3, 3, 9];\n+            let v2 = [mut 3, 3, 3, 9, 9];\n             check_sort(v1, v2);\n         }\n     }\n }\n \n #[cfg(test)]\n mod test_qsort {\n-    fn check_sort(v1: [mutable int], v2: [mutable int]) {\n+    fn check_sort(v1: [mut int], v2: [mut int]) {\n         let len = vec::len::<int>(v1);\n         fn leual(&&a: int, &&b: int) -> bool { ret a <= b; }\n         let f = leual;\n@@ -219,32 +219,32 @@ mod test_qsort {\n     #[test]\n     fn test() {\n         {\n-            let v1 = [mutable 3, 7, 4, 5, 2, 9, 5, 8];\n-            let v2 = [mutable 2, 3, 4, 5, 5, 7, 8, 9];\n+            let v1 = [mut 3, 7, 4, 5, 2, 9, 5, 8];\n+            let v2 = [mut 2, 3, 4, 5, 5, 7, 8, 9];\n             check_sort(v1, v2);\n         }\n         {\n-            let v1 = [mutable 1, 1, 1];\n-            let v2 = [mutable 1, 1, 1];\n+            let v1 = [mut 1, 1, 1];\n+            let v2 = [mut 1, 1, 1];\n             check_sort(v1, v2);\n         }\n         {\n-            let v1: [mutable int] = [mutable];\n-            let v2: [mutable int] = [mutable];\n+            let v1: [mut int] = [mut];\n+            let v2: [mut int] = [mut];\n             check_sort(v1, v2);\n         }\n-        { let v1 = [mutable 9]; let v2 = [mutable 9]; check_sort(v1, v2); }\n+        { let v1 = [mut 9]; let v2 = [mut 9]; check_sort(v1, v2); }\n         {\n-            let v1 = [mutable 9, 3, 3, 3, 9];\n-            let v2 = [mutable 3, 3, 3, 9, 9];\n+            let v1 = [mut 9, 3, 3, 3, 9];\n+            let v2 = [mut 3, 3, 3, 9, 9];\n             check_sort(v1, v2);\n         }\n     }\n \n     // Regression test for #750\n     #[test]\n     fn test_simple() {\n-        let names = [mutable 2, 1, 3];\n+        let names = [mut 2, 1, 3];\n \n         let expected = [1, 2, 3];\n \n@@ -294,7 +294,7 @@ mod tests {\n     #[test]\n     fn test_merge_sort_mutable() {\n         fn le(&&a: int, &&b: int) -> bool { ret a <= b; }\n-        let v1 = [mutable 3, 2, 1];\n+        let v1 = [mut 3, 2, 1];\n         let v2 = merge_sort(le, v1);\n         assert v2 == [1, 2, 3];\n     }"}, {"sha": "5847dea1e4ed5a975e41200cf024527ff7097964", "filename": "src/libstd/test.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -88,11 +88,11 @@ enum test_result { tr_ok, tr_failed, tr_ignored, }\n type console_test_state =\n     @{out: io::writer,\n       use_color: bool,\n-      mutable total: uint,\n-      mutable passed: uint,\n-      mutable failed: uint,\n-      mutable ignored: uint,\n-      mutable failures: [test_desc]};\n+      mut total: uint,\n+      mut passed: uint,\n+      mut failed: uint,\n+      mut ignored: uint,\n+      mut failures: [test_desc]};\n \n // A simple console test runner\n fn run_tests_console(opts: test_opts,\n@@ -131,11 +131,11 @@ fn run_tests_console(opts: test_opts,\n     let st =\n         @{out: io::stdout(),\n           use_color: use_color(),\n-          mutable total: 0u,\n-          mutable passed: 0u,\n-          mutable failed: 0u,\n-          mutable ignored: 0u,\n-          mutable failures: []};\n+          mut total: 0u,\n+          mut passed: 0u,\n+          mut failed: 0u,\n+          mut ignored: 0u,\n+          mut failures: []};\n \n     run_tests(opts, tests, bind callback(_, st));\n \n@@ -210,11 +210,11 @@ fn should_sort_failures_before_printing_them() {\n     let st =\n         @{out: writer,\n           use_color: false,\n-          mutable total: 0u,\n-          mutable passed: 0u,\n-          mutable failed: 0u,\n-          mutable ignored: 0u,\n-          mutable failures: [test_b, test_a]};\n+          mut total: 0u,\n+          mut passed: 0u,\n+          mut failed: 0u,\n+          mut ignored: 0u,\n+          mut failures: [test_b, test_a]};\n \n     print_failures(st);\n "}, {"sha": "ebf532ab19d502f037869e9aa77049adb7f70d56", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -15,17 +15,17 @@ export insert;\n export find;\n export traverse;\n \n-type treemap<K, V> = @mutable tree_node<K, V>;\n+type treemap<K, V> = @mut tree_node<K, V>;\n \n enum tree_node<K, V> { empty, node(@K, @V, treemap<K, V>, treemap<K, V>) }\n \n #[doc = \"Create a treemap\"]\n-fn treemap<K, V>() -> treemap<K, V> { @mutable empty }\n+fn treemap<K, V>() -> treemap<K, V> { @mut empty }\n \n #[doc = \"Insert a value into the map\"]\n fn insert<K: copy, V: copy>(m: treemap<K, V>, k: K, v: V) {\n     alt m {\n-      @empty { *m = node(@k, @v, @mutable empty, @mutable empty); }\n+      @empty { *m = node(@k, @v, @mut empty, @mut empty); }\n       @node(@kk, _, _, _) {\n \n         // We have to name left and right individually, because\n@@ -114,8 +114,8 @@ mod tests {\n         insert(m, 2, ());\n         insert(m, 1, ());\n \n-        let n = @mutable 0;\n-        fn t(n: @mutable int, &&k: int, &&_v: ()) {\n+        let n = @mut 0;\n+        fn t(n: @mut int, &&k: int, &&_v: ()) {\n             assert (*n == k); *n += 1;\n         }\n         traverse(m, bind t(n, _, _));"}, {"sha": "555c0a0f2127e6d18abf612eb7562e08752d5e5c", "filename": "src/libstd/ufind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibstd%2Fufind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Flibstd%2Fufind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fufind.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -8,13 +8,13 @@ import option::{some, none};\n // than the node itself.\n type node = option<uint>;\n \n-type ufind = {mutable nodes: [mutable node]};\n+type ufind = {mut nodes: [mut node]};\n \n-fn make() -> ufind { ret {mutable nodes: [mutable]}; }\n+fn make() -> ufind { ret {mut nodes: [mut]}; }\n \n fn make_set(ufnd: ufind) -> uint {\n     let idx = vec::len(ufnd.nodes);\n-    ufnd.nodes += [mutable none::<uint>];\n+    ufnd.nodes += [mut none::<uint>];\n     ret idx;\n }\n "}, {"sha": "d76d0447b111f7896c9569740a9ddd1dbc1c4cae", "filename": "src/rustc/driver/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fdriver%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fdriver%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdiagnostic.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -37,7 +37,7 @@ iface handler {\n }\n \n type handler_t = @{\n-    mutable err_count: uint,\n+    mut err_count: uint,\n     _emit: emitter\n };\n \n@@ -127,7 +127,7 @@ fn mk_handler(emitter: option<emitter>) -> handler {\n     };\n \n     @{\n-        mutable err_count: 0u,\n+        mut err_count: 0u,\n         _emit: emit\n     } as handler\n }"}, {"sha": "349c29a6f85f15dd55b4e7b6a0f78908a461e58f", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -479,17 +479,17 @@ fn build_session_(\n       cstore: cstore,\n       parse_sess: @{\n           cm: codemap,\n-          mutable next_id: 1,\n+          mut next_id: 1,\n           span_diagnostic: span_diagnostic_handler,\n-          mutable chpos: 0u,\n-          mutable byte_pos: 0u\n+          mut chpos: 0u,\n+          mut byte_pos: 0u\n       },\n       codemap: codemap,\n       // For a library crate, this is always none\n-      mutable main_fn: none,\n+      mut main_fn: none,\n       span_diagnostic: span_diagnostic_handler,\n       filesearch: filesearch,\n-      mutable building_library: false,\n+      mut building_library: false,\n       working_dir: os::getcwd()}\n }\n "}, {"sha": "d604db38e15b37770e1e91723613fbed44111290", "filename": "src/rustc/driver/session.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fsession.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -56,10 +56,10 @@ type session = @{targ_cfg: @config,\n                  parse_sess: parse_sess,\n                  codemap: codemap::codemap,\n                  // For a library crate, this is always none\n-                 mutable main_fn: option<(node_id, codemap::span)>,\n+                 mut main_fn: option<(node_id, codemap::span)>,\n                  span_diagnostic: diagnostic::span_handler,\n                  filesearch: filesearch::filesearch,\n-                 mutable building_library: bool,\n+                 mut building_library: bool,\n                  working_dir: str};\n \n impl session for session {"}, {"sha": "0230baefdc13eaf2a8d45144a2e65486b2a858c0", "filename": "src/rustc/front/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fattr.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -198,8 +198,8 @@ fn sort_meta_items(items: [@ast::meta_item]) -> [@ast::meta_item] {\n     }\n \n     // This is sort of stupid here, converting to a vec of mutables and back\n-    let mut v: [mutable @ast::meta_item] = [mutable];\n-    for mi: @ast::meta_item in items { v += [mutable mi]; }\n+    let mut v: [mut @ast::meta_item] = [mut];\n+    for mi: @ast::meta_item in items { v += [mut mi]; }\n \n     std::sort::quick_sort(lteq, v);\n "}, {"sha": "d39936c10ccc5da2d8df72c3122762fc4a2106c5", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -19,8 +19,8 @@ type test = {span: span, path: [ast::ident], ignore: bool, should_fail: bool};\n type test_ctxt =\n     @{sess: session::session,\n       crate: @ast::crate,\n-      mutable path: [ast::ident],\n-      mutable testfns: [test]};\n+      mut path: [ast::ident],\n+      mut testfns: [test]};\n \n // Traverse the crate, collecting all the test functions, eliding any\n // existing main functions, and synthesizing a main test harness\n@@ -39,8 +39,8 @@ fn generate_test_harness(sess: session::session,\n     let cx: test_ctxt =\n         @{sess: sess,\n           crate: crate,\n-          mutable path: [],\n-          mutable testfns: []};\n+          mut path: [],\n+          mut testfns: []};\n \n     let precursor =\n         {fold_crate: fold::wrap(bind fold_crate(cx, _, _)),"}, {"sha": "51c97ef261e5e1166294d9f16a43d65b04e51262", "filename": "src/rustc/metadata/astencode.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmetadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmetadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fastencode.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -234,8 +234,8 @@ fn visit_ids(item: ast::inlined_item, vfn: fn@(ast::node_id)) {\n }\n \n fn compute_id_range(item: ast::inlined_item) -> id_range {\n-    let min = @mutable int::max_value;\n-    let max = @mutable int::min_value;\n+    let min = @mut int::max_value;\n+    let max = @mut int::min_value;\n     visit_ids(item) {|id|\n         *min = int::min(*min, id);\n         *max = int::max(*max, id + 1);\n@@ -684,7 +684,7 @@ fn encode_side_tables_for_ii(ecx: @e::encode_ctxt,\n     ebml_w.wr_tag(c::tag_table as uint) {||\n         visit_ids(ii, fn@(id: ast::node_id) {\n             // Note: this will cause a copy of ebml_w, which is bad as\n-            // it has mutable fields.  But I believe it's harmless since\n+            // it has mut fields.  But I believe it's harmless since\n             // we generate balanced EBML.\n             encode_side_tables_for_id(ecx, ebml_w, id)\n         });\n@@ -943,10 +943,10 @@ fn new_parse_sess() -> parser::parse_sess {\n     let handler = diagnostic::mk_handler(option::none);\n     let sess = @{\n         cm: cm,\n-        mutable next_id: 1,\n+        mut next_id: 1,\n         span_diagnostic: diagnostic::mk_span_handler(handler, cm),\n-        mutable chpos: 0u,\n-        mutable byte_pos: 0u\n+        mut chpos: 0u,\n+        mut byte_pos: 0u\n     };\n     ret sess;\n }"}, {"sha": "fa74efbc19c349bf170cb31a86530a9737a9b0e4", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -21,7 +21,7 @@ export list_file_metadata;\n fn read_crates(sess: session::session, crate: ast::crate) {\n     let e = @{sess: sess,\n               crate_cache: std::map::str_hash::<int>(),\n-              mutable next_crate_num: 1};\n+              mut next_crate_num: 1};\n     let v =\n         visit::mk_simple_visitor(@{visit_view_item:\n                                        bind visit_view_item(e, _),\n@@ -32,7 +32,7 @@ fn read_crates(sess: session::session, crate: ast::crate) {\n \n type env = @{sess: session::session,\n              crate_cache: hashmap<str, int>,\n-             mutable next_crate_num: ast::crate_num};\n+             mut next_crate_num: ast::crate_num};\n \n fn visit_view_item(e: env, i: @ast::view_item) {\n     alt i.node {"}, {"sha": "36f2c28e74fb83ddf1b8fa60aafb85f43b8a6806", "filename": "src/rustc/metadata/cstore.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcstore.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -53,9 +53,9 @@ type cstore_private =\n     @{metas: map::hashmap<ast::crate_num, crate_metadata>,\n       use_crate_map: use_crate_map,\n       mod_path_map: mod_path_map,\n-      mutable used_crate_files: [str],\n-      mutable used_libraries: [str],\n-      mutable used_link_args: [str]};\n+      mut used_crate_files: [str],\n+      mut used_libraries: [str],\n+      mut used_link_args: [str]};\n \n // Map from node_id's of local use statements to crate numbers\n type use_crate_map = map::hashmap<ast::node_id, ast::crate_num>;\n@@ -70,9 +70,9 @@ fn mk_cstore() -> cstore {\n     ret private(@{metas: meta_cache,\n                   use_crate_map: crate_map,\n                   mod_path_map: mod_path_map,\n-                  mutable used_crate_files: [],\n-                  mutable used_libraries: [],\n-                  mutable used_link_args: []});\n+                  mut used_crate_files: [],\n+                  mut used_libraries: [],\n+                  mut used_link_args: []});\n }\n \n fn get_crate_data(cstore: cstore, cnum: ast::crate_num) -> crate_metadata {"}, {"sha": "a573d0214dc683eb337d40bfbdb9dda7c2305b7e", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -283,7 +283,7 @@ fn encode_parent_item(ebml_w: ebml::writer, id: def_id) {\n \n fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                             id: node_id, variants: [variant],\n-                            path: ast_map::path, index: @mutable [entry<int>],\n+                            path: ast_map::path, index: @mut [entry<int>],\n                             ty_params: [ty_param]) {\n     let mut disr_val = 0;\n     let mut i = 0;\n@@ -362,9 +362,9 @@ fn encode_privacy(ebml_w: ebml::writer, privacy: privacy) {\n fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                          id: node_id, path: ast_map::path,\n                          items: [@class_item],\n-                         global_index: @mutable[entry<int>])\n+                         global_index: @mut[entry<int>])\n  -> [entry<int>] {\n-    let index = @mutable [];\n+    let index = @mut [];\n     let tcx = ecx.ccx.tcx;\n     for ci in items {\n      /* We encode both private and public fields -- need to include\n@@ -466,14 +466,14 @@ fn should_inline(attrs: [attribute]) -> bool {\n \n \n fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n-                        index: @mutable [entry<int>], path: ast_map::path) {\n+                        index: @mut [entry<int>], path: ast_map::path) {\n \n     let tcx = ecx.ccx.tcx;\n     let must_write = alt item.node { item_enum(_, _) { true } _ { false } };\n     if !must_write && !ecx.ccx.reachable.contains_key(item.id) { ret; }\n \n     fn add_to_index_(item: @item, ebml_w: ebml::writer,\n-                     index: @mutable [entry<int>]) {\n+                     index: @mut [entry<int>]) {\n         *index += [{val: item.id, pos: ebml_w.writer.tell()}];\n     }\n     let add_to_index = bind add_to_index_(item, ebml_w, index);\n@@ -678,7 +678,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n \n fn encode_info_for_native_item(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                                nitem: @native_item,\n-                               index: @mutable [entry<int>],\n+                               index: @mut [entry<int>],\n                                path: ast_map::path, abi: native_abi) {\n     if !ecx.ccx.reachable.contains_key(nitem.id) { ret; }\n     *index += [{val: nitem.id, pos: ebml_w.writer.tell()}];\n@@ -704,7 +704,7 @@ fn encode_info_for_native_item(ecx: @encode_ctxt, ebml_w: ebml::writer,\n \n fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                          crate: @crate) -> [entry<int>] {\n-    let index = @mutable [];\n+    let index = @mut [];\n     ebml_w.start_tag(tag_items_data);\n     *index += [{val: crate_node_id, pos: ebml_w.writer.tell()}];\n     encode_info_for_mod(ecx, ebml_w, crate.node.module,\n@@ -752,15 +752,15 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n \n fn create_index<T: copy>(index: [entry<T>], hash_fn: fn@(T) -> uint) ->\n    [@[entry<T>]] {\n-    let mut buckets: [@mutable [entry<T>]] = [];\n-    uint::range(0u, 256u) {|_i| buckets += [@mutable []]; };\n+    let mut buckets: [@mut [entry<T>]] = [];\n+    uint::range(0u, 256u) {|_i| buckets += [@mut []]; };\n     for elt: entry<T> in index {\n         let h = hash_fn(elt.val);\n         *buckets[h % 256u] += [elt];\n     }\n \n     let mut buckets_frozen = [];\n-    for bucket: @mutable [entry<T>] in buckets {\n+    for bucket: @mut [entry<T>] in buckets {\n         buckets_frozen += [@*bucket];\n     }\n     ret buckets_frozen;\n@@ -901,9 +901,9 @@ fn encode_crate_deps(ebml_w: ebml::writer, cstore: cstore::cstore) {\n         type numname = {crate: crate_num, ident: str};\n \n         // Pull the cnums and names out of cstore\n-        let mut pairs: [mutable numname] = [mutable];\n+        let mut pairs: [mut numname] = [mut];\n         cstore::iter_crate_data(cstore) {|key, val|\n-            pairs += [mutable {crate: key, ident: val.name}];\n+            pairs += [mut {crate: key, ident: val.name}];\n         };\n \n         // Sort by cnum\n@@ -919,7 +919,7 @@ fn encode_crate_deps(ebml_w: ebml::writer, cstore: cstore::cstore) {\n \n         // Return just the names\n         fn name(kv: numname) -> str { kv.ident }\n-        // mutable -> immutable hack for vec::map\n+        // mut -> immutable hack for vec::map\n         let immpairs = vec::slice(pairs, 0u, vec::len(pairs));\n         ret vec::map(immpairs, name);\n     }"}, {"sha": "920a4d71a46681befcce353db8c72c4d01d25b4f", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -17,7 +17,7 @@ export parse_bounds_data;\n // Callback to translate defs to strs or back:\n type conv_did = fn(ast::def_id) -> ast::def_id;\n \n-type pstate = {data: @[u8], crate: int, mutable pos: uint, tcx: ty::ctxt};\n+type pstate = {data: @[u8], crate: int, mut pos: uint, tcx: ty::ctxt};\n \n fn peek(st: @pstate) -> char {\n     st.data[st.pos] as char\n@@ -52,7 +52,7 @@ fn parse_ident_(st: @pstate, is_last: fn@(char) -> bool) ->\n \n fn parse_ty_data(data: @[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n                  conv: conv_did) -> ty::t {\n-    let st = @{data: data, crate: crate_num, mutable pos: pos, tcx: tcx};\n+    let st = @{data: data, crate: crate_num, mut pos: pos, tcx: tcx};\n     parse_ty(st, conv)\n }\n \n@@ -416,7 +416,7 @@ fn parse_def_id(buf: [u8]) -> ast::def_id {\n fn parse_bounds_data(data: @[u8], start: uint,\n                      crate_num: int, tcx: ty::ctxt, conv: conv_did)\n     -> @[ty::param_bound] {\n-    let st = @{data: data, crate: crate_num, mutable pos: start, tcx: tcx};\n+    let st = @{data: data, crate: crate_num, mut pos: start, tcx: tcx};\n     parse_bounds(st, conv)\n }\n "}, {"sha": "32e5ef9152468b4de701012e21b4a7afd32447c4", "filename": "src/rustc/middle/alias.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Falias.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -30,11 +30,11 @@ type binding = @{node_id: node_id,\n                  root_var: option<node_id>,\n                  local_id: uint,\n                  unsafe_tys: [unsafe_ty],\n-                 mutable copied: copied};\n+                 mut copied: copied};\n \n // FIXME it may be worthwhile to use a linked list of bindings instead\n type scope = {bs: [binding],\n-              invalid: @mutable list<@invalid>};\n+              invalid: @mut list<@invalid>};\n \n fn mk_binding(cx: ctx, id: node_id, span: span, root_var: option<node_id>,\n               unsafe_tys: [unsafe_ty]) -> binding {\n@@ -45,7 +45,7 @@ fn mk_binding(cx: ctx, id: node_id, span: span, root_var: option<node_id>,\n     ret @{node_id: id, span: span, root_var: root_var,\n           local_id: local_id_of_node(cx, id),\n           unsafe_tys: unsafe_tys,\n-          mutable copied: not_copied};\n+          mut copied: not_copied};\n }\n \n enum local_info { local(uint), }\n@@ -56,20 +56,20 @@ type ref_map = std::map::hashmap<node_id, node_id>;\n type ctx = {tcx: ty::ctxt,\n             copy_map: copy_map,\n             ref_map: ref_map,\n-            mutable silent: bool};\n+            mut silent: bool};\n \n fn check_crate(tcx: ty::ctxt, crate: @ast::crate) -> (copy_map, ref_map) {\n     // Stores information about function arguments that's otherwise not easily\n     // available.\n     let cx = @{tcx: tcx,\n                copy_map: std::map::int_hash(),\n                ref_map: std::map::int_hash(),\n-               mutable silent: false};\n+               mut silent: false};\n     let v = @{visit_fn: bind visit_fn(cx, _, _, _, _, _, _, _),\n               visit_expr: bind visit_expr(cx, _, _, _),\n               visit_block: bind visit_block(cx, _, _, _)\n               with *visit::default_visitor::<scope>()};\n-    let sc = {bs: [], invalid: @mutable list::nil};\n+    let sc = {bs: [], invalid: @mut list::nil};\n     visit::visit_crate(*crate, sc, visit::mk_vt(v));\n     tcx.sess.abort_if_errors();\n     ret (cx.copy_map, cx.ref_map);\n@@ -89,7 +89,7 @@ fn visit_fn(cx: @ctx, _fk: visit::fn_kind, decl: ast::fn_decl,\n         check_loop(*cx, sc) {|| v.visit_block(body, sc, v);}\n       }\n       ast::proto_box | ast::proto_uniq | ast::proto_bare {\n-        let sc = {bs: [], invalid: @mutable list::nil};\n+        let sc = {bs: [], invalid: @mut list::nil};\n         v.visit_block(body, sc, v);\n       }\n     }\n@@ -242,7 +242,7 @@ fn check_call(cx: ctx, sc: scope, f: @ast::expr, args: [@ast::expr])\n                        root_var: root_var,\n                        local_id: 0u,\n                        unsafe_tys: unsafe_set(root.mutbl),\n-                       mutable copied: arg_copied}];\n+                       mut copied: arg_copied}];\n         i += 1u;\n     }\n     let f_may_close =\n@@ -291,7 +291,7 @@ fn check_call(cx: ctx, sc: scope, f: @ast::expr, args: [@ast::expr])\n         }\n         j += 1u;\n     }\n-    // Ensure we're not passing a root by mutable alias.\n+    // Ensure we're not passing a root by mut alias.\n \n     for {node: node, arg: arg} in mut_roots {\n         let mut i = 0u;\n@@ -301,7 +301,7 @@ fn check_call(cx: ctx, sc: scope, f: @ast::expr, args: [@ast::expr])\n                   some(root) {\n                     if node == root && cant_copy(cx, b) {\n                         err(cx, args[arg].span,\n-                            \"passing a mutable reference to a \\\n+                            \"passing a mut reference to a \\\n                              variable that roots another reference\");\n                         break;\n                     }\n@@ -327,7 +327,7 @@ fn check_alt(cx: ctx, input: @ast::expr, arms: [ast::arm], sc: scope,\n         let pat_id_map = pat_util::pat_id_map(cx.tcx.def_map, a.pats[0]);\n         type info = {\n             id: node_id,\n-            mutable unsafe_tys: [unsafe_ty],\n+            mut unsafe_tys: [unsafe_ty],\n             span: span};\n         let mut binding_info: [info] = [];\n         for pat in a.pats {\n@@ -338,7 +338,7 @@ fn check_alt(cx: ctx, input: @ast::expr, arms: [ast::arm], sc: scope,\n                   none {\n                       binding_info += [\n                           {id: canon_id,\n-                           mutable unsafe_tys: unsafe_set(proot.mutbl),\n+                           mut unsafe_tys: unsafe_set(proot.mutbl),\n                            span: proot.span}];\n                   }\n                 }\n@@ -359,7 +359,7 @@ fn check_for(cx: ctx, local: @ast::local, seq: @ast::expr, blk: ast::blk,\n              sc: scope, v: vt<scope>) {\n     let root = expr_root(cx, seq, false);\n \n-    // If this is a mutable vector, don't allow it to be touched.\n+    // If this is a mut vector, don't allow it to be touched.\n     let seq_t = ty::expr_ty(cx.tcx, seq);\n     let mut cur_mutbl = root.mutbl;\n     alt ty::get(seq_t).struct {\n@@ -522,7 +522,7 @@ fn ty_can_unsafely_include(cx: ctx, needle: unsafe_ty, haystack: ty::t,\n           ty::ty_fn(_) | ty::ty_iface(_, _) { ret true; }\n           // A type param may include everything, but can only be\n           // treated as opaque downstream, and is thus safe unless we\n-          // saw mutable fields, in which case the whole thing can be\n+          // saw mut fields, in which case the whole thing can be\n           // overwritten.\n           ty::ty_param(_, _) { ret mutbl; }\n           _ { ret false; }"}, {"sha": "3b9a868776b73c2665050aaf9d99fe6a73d8c2ab", "filename": "src/rustc/middle/ast_map.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fast_map.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -40,8 +40,8 @@ enum ast_node {\n }\n \n type map = std::map::hashmap<node_id, ast_node>;\n-type ctx = {map: map, mutable path: path,\n-            mutable local_id: uint, sess: session};\n+type ctx = {map: map, mut path: path,\n+            mut local_id: uint, sess: session};\n type vt = visit::vt<ctx>;\n \n fn extend(cx: ctx, elt: str) -> @path {\n@@ -63,8 +63,8 @@ fn mk_ast_map_visitor() -> vt {\n \n fn map_crate(sess: session, c: crate) -> map {\n     let cx = {map: std::map::int_hash(),\n-              mutable path: [],\n-              mutable local_id: 0u,\n+              mut path: [],\n+              mut local_id: 0u,\n               sess: sess};\n     visit::visit_crate(c, cx, mk_ast_map_visitor());\n     ret cx.map;\n@@ -81,8 +81,8 @@ fn map_decoded_item(sess: session, map: map, path: path, ii: inlined_item) {\n     // even if we did I think it only needs an ordering between local\n     // variables that are simultaneously in scope).\n     let cx = {map: map,\n-              mutable path: path,\n-              mutable local_id: 0u,\n+              mut path: path,\n+              mut local_id: 0u,\n               sess: sess};\n     let v = mk_ast_map_visitor();\n "}, {"sha": "c0719e47ad32022d4f3885afea4b91d60d050d30", "filename": "src/rustc/middle/block_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Fblock_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Fblock_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fblock_use.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -2,10 +2,10 @@ import syntax::visit;\n import syntax::ast::*;\n import driver::session::session;\n \n-type ctx = {tcx: ty::ctxt, mutable allow_block: bool};\n+type ctx = {tcx: ty::ctxt, mut allow_block: bool};\n \n fn check_crate(tcx: ty::ctxt, crate: @crate) {\n-    let cx = {tcx: tcx, mutable allow_block: false};\n+    let cx = {tcx: tcx, mut allow_block: false};\n     let v = visit::mk_vt(@{visit_expr: visit_expr\n                            with *visit::default_visitor()});\n     visit::visit_crate(*crate, cx, v);"}, {"sha": "eacb5fef32ca28a859cd9641f41373ad83f4d018", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -101,8 +101,8 @@ fn check_exhaustive(tcx: ty::ctxt, sp: span, pats: [@pat]) {\n         vec::iter(cols) {|col| check_exhaustive(tcx, sp, col); }\n       }\n       ty::ty_rec(fs) {\n-        let cols = vec::from_elem(fs.len(), {mutable wild: false,\n-                                            mutable pats: []});\n+        let cols = vec::from_elem(fs.len(), {mut wild: false,\n+                                            mut pats: []});\n         for p in pats {\n             alt raw_pat(p).node {\n               pat_rec(sub, _) {\n@@ -156,7 +156,7 @@ fn check_exhaustive_enum(tcx: ty::ctxt, enum_id: def_id, sp: span,\n                          pats: [@pat]) {\n     let variants = enum_variants(tcx, enum_id);\n     let columns_by_variant = vec::map(*variants, {|v|\n-        {mutable seen: false,\n+        {mut seen: false,\n          cols: vec::to_mut(vec::from_elem(v.args.len(), []))}\n     });\n "}, {"sha": "727cbac4f23409c46c612afaea390774b01af6af", "filename": "src/rustc/middle/freevars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ffreevars.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -34,7 +34,7 @@ type freevar_map = hashmap<ast::node_id, freevar_info>;\n fn collect_freevars(def_map: resolve::def_map, blk: ast::blk)\n     -> freevar_info {\n     let seen = int_hash();\n-    let refs = @mutable [];\n+    let refs = @mut [];\n \n     fn ignore_item(_i: @ast::item, &&_depth: int, _v: visit::vt<int>) { }\n "}, {"sha": "71419128eb1f9fd51ec0270f2106427ff586bb2b", "filename": "src/rustc/middle/infer.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Finfer.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -424,8 +424,8 @@ impl unify_methods for infer_ctxt {\n \n         alt b.mutbl {\n           ast::m_mutbl {\n-            // If supertype is mutable, subtype must match exactly\n-            // (i.e., invariant if mutable):\n+            // If supertype is mut, subtype must match exactly\n+            // (i.e., invariant if mut):\n             self.eq_tys(a.ty, b.ty)\n           }\n           ast::m_imm | ast::m_const {\n@@ -751,7 +751,7 @@ impl resolve_methods for infer_ctxt {\n         }\n     }\n \n-    fn subst_vars(unresolved: @mutable option<int>,\n+    fn subst_vars(unresolved: @mut option<int>,\n                   vars_seen: std::list::list<int>,\n                   vid: int) -> ty::t {\n         // Should really return a fixup_result instead of a t, but fold_ty\n@@ -785,7 +785,7 @@ impl resolve_methods for infer_ctxt {\n     }\n \n     fn fixup_vars(typ: ty::t) -> fres<ty::t> {\n-        let unresolved = @mutable none::<int>;\n+        let unresolved = @mut none::<int>;\n         let rty =\n             ty::fold_ty(self.tcx,\n                         ty::fm_var(\n@@ -802,7 +802,7 @@ impl resolve_methods for infer_ctxt {\n         }\n     }\n \n-    fn subst_regions(unresolved: @mutable option<int>,\n+    fn subst_regions(unresolved: @mut option<int>,\n                      regions_seen: std::list::list<int>,\n                      rid: int) -> ty::region {\n         // Should really return a fixup_result instead of a t, but fold_ty\n@@ -826,7 +826,7 @@ impl resolve_methods for infer_ctxt {\n     }\n \n     fn fixup_regions(typ: ty::t) -> fres<ty::t> {\n-        let unresolved = @mutable none::<int>;\n+        let unresolved = @mut none::<int>;\n         let rty = ty::fold_ty(self.tcx, ty::fm_rptr({ |region, _under_rptr|\n             alt region {\n               ty::re_var(rid) {\n@@ -1346,8 +1346,8 @@ impl of combine for glb {\n                mt_to_str(tcx, b));\n \n         alt (a.mutbl, b.mutbl) {\n-          // If one side or both is mutable, then the GLB must use\n-          // the precise type from the mutable side.\n+          // If one side or both is mut, then the GLB must use\n+          // the precise type from the mut side.\n           (ast::m_mutbl, ast::m_const) {\n             self.infcx().tys(a.ty, b.ty).then {||\n                 ok({ty: a.ty, mutbl: ast::m_mutbl})"}, {"sha": "aaa452a89c27f2ccdfe817bbf3c3c098d8c8ce57", "filename": "src/rustc/middle/last_use.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Flast_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Flast_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flast_use.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -38,7 +38,7 @@ enum block_type { func, lp, }\n \n enum use { var_use(node_id), close_over(node_id), }\n type set = [{def: node_id, uses: list<use>}];\n-type bl = @{type: block_type, mutable second: bool, mutable exits: [set]};\n+type bl = @{type: block_type, mut second: bool, mut exits: [set]};\n \n enum use_id { path(node_id), close(node_id, node_id) }\n fn hash_use_id(id: use_id) -> uint {\n@@ -51,8 +51,8 @@ type ctx = {last_uses: std::map::hashmap<use_id, bool>,\n             ref_map: alias::ref_map,\n             tcx: ty::ctxt,\n             // The current set of local last uses\n-            mutable current: set,\n-            mutable blocks: list<bl>};\n+            mut current: set,\n+            mut blocks: list<bl>};\n \n fn find_last_uses(c: @crate, def_map: resolve::def_map,\n                   ref_map: alias::ref_map, tcx: ty::ctxt)\n@@ -66,8 +66,8 @@ fn find_last_uses(c: @crate, def_map: resolve::def_map,\n               def_map: def_map,\n               ref_map: ref_map,\n               tcx: tcx,\n-              mutable current: [],\n-              mutable blocks: nil};\n+              mut current: [],\n+              mut blocks: nil};\n     visit::visit_crate(*c, cx, v);\n     let mini_table = std::map::int_hash();\n     cx.last_uses.items {|key, val|\n@@ -268,7 +268,7 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n }\n \n fn visit_block(tp: block_type, cx: ctx, visit: fn()) {\n-    let local = @{type: tp, mutable second: false, mutable exits: []};\n+    let local = @{type: tp, mut second: false, mut exits: []};\n     cx.blocks = cons(local, @cx.blocks);\n     visit();\n     local.second = true;"}, {"sha": "092afcdbedde3a4ca073b8282e290ee8e6dcc1e9", "filename": "src/rustc/middle/mutbl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Fmutbl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Fmutbl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fmutbl.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -131,7 +131,7 @@ fn mk_err(cx: @ctx, span: syntax::codemap::span, msg: msg, name: str) {\n     cx.tcx.sess.span_err(span, alt msg {\n       msg_assign { \"assigning to \" + name }\n       msg_move_out { \"moving out of \" + name }\n-      msg_mutbl_ref { \"passing \" + name + \" by mutable reference\" }\n+      msg_mutbl_ref { \"passing \" + name + \" by mut reference\" }\n     });\n }\n \n@@ -254,7 +254,7 @@ fn check_bind(cx: @ctx, f: @expr, args: [option<@expr>]) {\n         alt arg {\n           some(expr) {\n             let o_msg = alt ty::resolved_mode(cx.tcx, arg_ts[i].mode) {\n-              by_mutbl_ref { some(\"by mutable reference\") }\n+              by_mutbl_ref { some(\"by mut reference\") }\n               by_move { some(\"by move\") }\n               _ { none }\n             };"}, {"sha": "712ccbf02aff93adc4bdb57577e07d4d489ef599", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -35,7 +35,7 @@ enum scope {\n     scope_fn_expr(ast::fn_decl, node_id, [ast::ty_param]),\n     scope_native_item(@ast::native_item),\n     scope_loop(@ast::local), // there's only 1 decl per loop.\n-    scope_block(ast::blk, @mutable uint, @mutable uint),\n+    scope_block(ast::blk, @mut uint, @mut uint),\n     scope_arm(ast::arm),\n     scope_method(node_id, [ast::ty_param]),\n }\n@@ -104,8 +104,8 @@ type glob_imp_def = {def: def, path: @ast::view_path};\n type indexed_mod = {\n     m: option<ast::_mod>,\n     index: mod_index,\n-    mutable glob_imports: [glob_imp_def],\n-    mutable globbed_exports: [ident],\n+    mut glob_imports: [glob_imp_def],\n+    mut globbed_exports: [ident],\n     glob_imported_names: hashmap<str, glob_import_state>,\n     path: str\n };\n@@ -127,19 +127,19 @@ type env =\n      def_map: def_map,\n      ast_map: ast_map::map,\n      imports: hashmap<node_id, import_state>,\n-     mutable exp_map: exp_map,\n+     mut exp_map: exp_map,\n      mod_map: hashmap<node_id, @indexed_mod>,\n      block_map: hashmap<node_id, [glob_imp_def]>,\n      ext_map: ext_map,\n      impl_map: impl_map,\n      impl_cache: impl_cache,\n      ext_cache: ext_hash,\n-     used_imports: {mutable track: bool,\n-                    mutable data: [node_id]},\n-     mutable reported: [{ident: str, sc: scope}],\n-     mutable ignored_imports: [node_id],\n-     mutable current_tp: option<uint>,\n-     mutable resolve_unexported: bool,\n+     used_imports: {mut track: bool,\n+                    mut data: [node_id]},\n+     mut reported: [{ident: str, sc: scope}],\n+     mut ignored_imports: [node_id],\n+     mut current_tp: option<uint>,\n+     mut resolve_unexported: bool,\n      sess: session};\n \n \n@@ -171,18 +171,18 @@ fn create_env(sess: session, amap: ast_map::map) -> @env {\n       def_map: int_hash(),\n       ast_map: amap,\n       imports: int_hash(),\n-      mutable exp_map: int_hash(),\n+      mut exp_map: int_hash(),\n       mod_map: int_hash(),\n       block_map: int_hash(),\n       ext_map: new_def_hash(),\n       impl_map: int_hash(),\n       impl_cache: new_def_hash(),\n       ext_cache: new_ext_hash(),\n-      used_imports: {mutable track: false, mutable data:  []},\n-      mutable reported: [],\n-      mutable ignored_imports: [],\n-      mutable current_tp: none,\n-      mutable resolve_unexported: false,\n+      used_imports: {mut track: false, mut data:  []},\n+      mut reported: [],\n+      mut ignored_imports: [],\n+      mut current_tp: none,\n+      mut resolve_unexported: false,\n       sess: sess}\n }\n \n@@ -268,17 +268,17 @@ fn map_crate(e: @env, c: @ast::crate) {\n             e.mod_map.insert(i.id,\n                              @{m: some(md),\n                                index: index_mod(md),\n-                               mutable glob_imports: [],\n-                               mutable globbed_exports: [],\n+                               mut glob_imports: [],\n+                               mut globbed_exports: [],\n                                glob_imported_names: str_hash(),\n                                path: path_from_scope(sc, i.ident)});\n           }\n           ast::item_native_mod(nmd) {\n             e.mod_map.insert(i.id,\n                              @{m: none::<ast::_mod>,\n                                index: index_nmod(nmd),\n-                               mutable glob_imports: [],\n-                               mutable globbed_exports: [],\n+                               mut glob_imports: [],\n+                               mut globbed_exports: [],\n                                glob_imported_names: str_hash(),\n                                path: path_from_scope(sc, i.ident)});\n           }\n@@ -336,8 +336,8 @@ fn map_crate(e: @env, c: @ast::crate) {\n     e.mod_map.insert(ast::crate_node_id,\n                      @{m: some(c.node.module),\n                        index: index_mod(c.node.module),\n-                       mutable glob_imports: [],\n-                       mutable globbed_exports: [],\n+                       mut glob_imports: [],\n+                       mut globbed_exports: [],\n                        glob_imported_names: str_hash(),\n                        path: \"\"});\n \n@@ -580,7 +580,7 @@ fn visit_fn_with_scope(e: @env, fk: visit::fn_kind, decl: ast::fn_decl,\n }\n \n fn visit_block_with_scope(b: ast::blk, sc: scopes, v: vt<scopes>) {\n-    let pos = @mutable 0u, loc = @mutable 0u;\n+    let pos = @mut 0u, loc = @mut 0u;\n     let block_sc = cons(scope_block(b, pos, loc), @sc);\n     for vi in b.node.view_items { v.visit_view_item(vi, block_sc, v); }\n     for stmt in b.node.stmts {\n@@ -594,7 +594,7 @@ fn visit_block_with_scope(b: ast::blk, sc: scopes, v: vt<scopes>) {\n fn visit_decl_with_scope(d: @decl, sc: scopes, v: vt<scopes>) {\n     let loc_pos = alt list::head(sc) {\n       scope_block(_, _, pos) { pos }\n-      _ { @mutable 0u }\n+      _ { @mut 0u }\n     };\n     alt d.node {\n       decl_local(locs) {\n@@ -1894,11 +1894,11 @@ fn check_ty(e: @env, ty: @ast::ty, &&x: (), v: vt<()>) {\n     visit::visit_ty(ty, x, v);\n }\n \n-type checker = @{mutable seen: [ident], kind: str, sess: session};\n+type checker = @{mut seen: [ident], kind: str, sess: session};\n \n fn checker(e: env, kind: str) -> checker {\n     let seen: [ident] = [];\n-    ret @{mutable seen: seen, kind: kind, sess: e.sess};\n+    ret @{mut seen: seen, kind: kind, sess: e.sess};\n }\n \n fn check_name(ch: checker, sp: span, name: ident) {"}, {"sha": "352949109238b3260f83cb6ae8bd3770706b4877", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -640,9 +640,9 @@ fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: [ast::arm],\n     let mk_fail = alt mode {\n       ast::alt_check {\n         // Cached fail-on-fallthrough block\n-        let fail_cx = @mutable none;\n+        let fail_cx = @mut none;\n         fn mk_fail(bcx: block, sp: span,\n-                   done: @mutable option<BasicBlockRef>) -> BasicBlockRef {\n+                   done: @mut option<BasicBlockRef>) -> BasicBlockRef {\n             alt *done { some(bb) { ret bb; } _ { } }\n             let fail_cx = sub_block(bcx, \"case_fallthrough\");\n             trans_fail(fail_cx, some(sp), \"non-exhaustive match failure\");;"}, {"sha": "808a500814e65ffcae69fd322a9c8366d3411534", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -56,7 +56,7 @@ import std::smallintmap;\n // destination of a computation's value.\n \n enum dest {\n-    by_val(@mutable ValueRef),\n+    by_val(@mut ValueRef),\n     save_in(ValueRef),\n     ignore,\n }\n@@ -69,8 +69,8 @@ fn dest_str(ccx: @crate_ctxt, d: dest) -> str {\n     }\n }\n \n-fn empty_dest_cell() -> @mutable ValueRef {\n-    ret @mutable llvm::LLVMGetUndef(T_nil());\n+fn empty_dest_cell() -> @mut ValueRef {\n+    ret @mut llvm::LLVMGetUndef(T_nil());\n }\n \n fn dup_for_join(dest: dest) -> dest {\n@@ -454,9 +454,9 @@ fn declare_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n           tydesc: gvar,\n           size: llsize,\n           align: llalign,\n-          mutable take_glue: none,\n-          mutable drop_glue: none,\n-          mutable free_glue: none};\n+          mut take_glue: none,\n+          mut drop_glue: none,\n+          mut free_glue: none};\n     log(debug, \"--- declare_tydesc \" + ty_to_str(ccx.tcx, t));\n     ret info;\n }\n@@ -3516,11 +3516,11 @@ fn new_block(cx: fn_ctxt, parent: block_parent, kind: block_kind,\n         llvm::LLVMAppendBasicBlock(cx.llfn, buf)\n     });\n     let bcx = @{llbb: llbb,\n-                mutable terminated: false,\n-                mutable unreachable: false,\n+                mut terminated: false,\n+                mut unreachable: false,\n                 parent: parent,\n                 kind: kind,\n-                mutable block_span: block_span,\n+                mut block_span: block_span,\n                 fcx: cx};\n     alt parent {\n       parent_some(cx) {\n@@ -3532,8 +3532,8 @@ fn new_block(cx: fn_ctxt, parent: block_parent, kind: block_kind,\n }\n \n fn simple_block_scope() -> block_kind {\n-    block_scope({is_loop: none, mutable cleanups: [],\n-                 mutable cleanup_paths: [], mutable landing_pad: none})\n+    block_scope({is_loop: none, mut cleanups: [],\n+                 mut cleanup_paths: [], mut landing_pad: none})\n }\n \n // Use this when you're at the top block of a function or the like.\n@@ -3552,9 +3552,9 @@ fn loop_scope_block(bcx: block, _cont: loop_cont,\n     -> block {\n     ret new_block(bcx.fcx, parent_some(bcx), block_scope({\n         is_loop: some({cnt: _cont, brk: _break}),\n-        mutable cleanups: [],\n-        mutable cleanup_paths: [],\n-        mutable landing_pad: none\n+        mut cleanups: [],\n+        mut cleanup_paths: [],\n+        mut landing_pad: none\n     }), n, some(sp));\n }\n \n@@ -3566,11 +3566,11 @@ fn sub_block(bcx: block, n: str) -> block {\n \n fn raw_block(fcx: fn_ctxt, llbb: BasicBlockRef) -> block {\n     ret @{llbb: llbb,\n-          mutable terminated: false,\n-          mutable unreachable: false,\n+          mut terminated: false,\n+          mut unreachable: false,\n           parent: parent_none,\n           kind: block_non_scope,\n-          mutable block_span: none,\n+          mut block_span: none,\n           fcx: fcx};\n }\n \n@@ -3775,11 +3775,11 @@ fn new_fn_ctxt_w_id(ccx: @crate_ctxt, path: path,\n     ret @{llfn: llfndecl,\n           llenv: llvm::LLVMGetParam(llfndecl, 1u as c_uint),\n           llretptr: llvm::LLVMGetParam(llfndecl, 0u as c_uint),\n-          mutable llstaticallocas: llbbs.sa,\n-          mutable llloadenv: llbbs.ca,\n-          mutable llreturn: llbbs.rt,\n-          mutable llself: none,\n-          mutable personality: none,\n+          mut llstaticallocas: llbbs.sa,\n+          mut llloadenv: llbbs.ca,\n+          mut llreturn: llbbs.rt,\n+          mut llself: none,\n+          mut personality: none,\n           llargs: int_hash::<local_val>(),\n           lllocals: int_hash::<local_val>(),\n           llupvars: int_hash::<ValueRef>(),\n@@ -4766,7 +4766,7 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           exp_map: emap,\n           reachable: reachable,\n           item_symbols: int_hash::<str>(),\n-          mutable main_fn: none::<ValueRef>,\n+          mut main_fn: none::<ValueRef>,\n           link_meta: link_meta,\n           enum_sizes: ty::new_ty_hash(),\n           discrims: ast_util::new_def_id_hash::<ValueRef>(),\n@@ -4786,13 +4786,13 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           tcx: tcx,\n           maps: maps,\n           stats:\n-              {mutable n_static_tydescs: 0u,\n-               mutable n_glues_created: 0u,\n-               mutable n_null_glues: 0u,\n-               mutable n_real_glues: 0u,\n-               llvm_insn_ctxt: @mutable [],\n+              {mut n_static_tydescs: 0u,\n+               mut n_glues_created: 0u,\n+               mut n_null_glues: 0u,\n+               mut n_real_glues: 0u,\n+               llvm_insn_ctxt: @mut [],\n                llvm_insns: str_hash(),\n-               fn_times: @mutable []},\n+               fn_times: @mut []},\n           upcalls:\n               upcall::declare_upcalls(targ_cfg, tn, tydesc_type,\n                                       llmod),\n@@ -4806,7 +4806,7 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           crate_map: crate_map,\n           dbg_cx: dbg_cx,\n           class_ctors: int_hash::<int>(),\n-          mutable do_not_commit_warning_issued: false};\n+          mut do_not_commit_warning_issued: false};\n \n \n     {"}, {"sha": "f68495b756120ea165b9f3c66978e1e1eb554f1b", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -22,7 +22,7 @@ import ast_map::path;\n \n type namegen = fn@(str) -> str;\n fn new_namegen() -> namegen {\n-    let i = @mutable 0;\n+    let i = @mut 0;\n     ret fn@(prefix: str) -> str { *i += 1; prefix + int::str(*i) };\n }\n \n@@ -31,9 +31,9 @@ type tydesc_info =\n      tydesc: ValueRef,\n      size: ValueRef,\n      align: ValueRef,\n-     mutable take_glue: option<ValueRef>,\n-     mutable drop_glue: option<ValueRef>,\n-     mutable free_glue: option<ValueRef>};\n+     mut take_glue: option<ValueRef>,\n+     mut drop_glue: option<ValueRef>,\n+     mut free_glue: option<ValueRef>};\n \n /*\n  * A note on nomenclature of linking: \"upcall\", \"extern\" and \"native\".\n@@ -52,13 +52,13 @@ type tydesc_info =\n  */\n \n type stats =\n-    {mutable n_static_tydescs: uint,\n-     mutable n_glues_created: uint,\n-     mutable n_null_glues: uint,\n-     mutable n_real_glues: uint,\n-     llvm_insn_ctxt: @mutable [str],\n+    {mut n_static_tydescs: uint,\n+     mut n_glues_created: uint,\n+     mut n_null_glues: uint,\n+     mut n_real_glues: uint,\n+     llvm_insn_ctxt: @mut [str],\n      llvm_insns: hashmap<str, uint>,\n-     fn_times: @mutable [{ident: str, time: int}]};\n+     fn_times: @mut [{ident: str, time: int}]};\n \n resource BuilderRef_res(B: BuilderRef) { llvm::LLVMDisposeBuilder(B); }\n \n@@ -85,7 +85,7 @@ type crate_ctxt = {\n      exp_map: resolve::exp_map,\n      reachable: reachable::map,\n      item_symbols: hashmap<ast::node_id, str>,\n-     mutable main_fn: option<ValueRef>,\n+     mut main_fn: option<ValueRef>,\n      link_meta: link::link_meta,\n      enum_sizes: hashmap<ty::t, uint>,\n      discrims: hashmap<ast::def_id, ValueRef>,\n@@ -122,7 +122,7 @@ type crate_ctxt = {\n      // Mapping from class constructors to parent class --\n      // used in base::trans_closure\n      class_ctors: hashmap<ast::node_id, ast::node_id>,\n-     mutable do_not_commit_warning_issued: bool};\n+     mut do_not_commit_warning_issued: bool};\n \n // Types used for llself.\n type val_self_pair = {v: ValueRef, t: ty::t};\n@@ -152,19 +152,19 @@ type fn_ctxt = @{\n     // the function, due to LLVM's quirks.\n     // A block for all the function's static allocas, so that LLVM\n     // will coalesce them into a single alloca call.\n-    mutable llstaticallocas: BasicBlockRef,\n+    mut llstaticallocas: BasicBlockRef,\n     // A block containing code that copies incoming arguments to space\n     // already allocated by code in one of the llallocas blocks.\n     // (LLVM requires that arguments be copied to local allocas before\n     // allowing most any operation to be performed on them.)\n-    mutable llloadenv: BasicBlockRef,\n-    mutable llreturn: BasicBlockRef,\n+    mut llloadenv: BasicBlockRef,\n+    mut llreturn: BasicBlockRef,\n     // The 'self' value currently in use in this function, if there\n     // is one.\n-    mutable llself: option<val_self_pair>,\n+    mut llself: option<val_self_pair>,\n     // The a value alloca'd for calls to upcalls.rust_personality. Used when\n     // outputting the resume instruction.\n-    mutable personality: option<ValueRef>,\n+    mut personality: option<ValueRef>,\n \n     // Maps arguments to allocas created for them in llallocas.\n     llargs: hashmap<ast::node_id, local_val>,\n@@ -294,12 +294,12 @@ type scope_info = {\n     // A list of functions that must be run at when leaving this\n     // block, cleaning up any variables that were introduced in the\n     // block.\n-    mutable cleanups: [cleanup],\n+    mut cleanups: [cleanup],\n     // Existing cleanup paths that may be reused, indexed by destination and\n     // cleared when the set of cleanups changes.\n-    mutable cleanup_paths: [cleanup_path],\n+    mut cleanup_paths: [cleanup_path],\n     // Unwinding landing pad. Also cleared when cleanups change.\n-    mutable landing_pad: option<BasicBlockRef>,\n+    mut landing_pad: option<BasicBlockRef>,\n };\n \n // Basic block context.  We create a block context for each basic block\n@@ -314,14 +314,14 @@ type block = @{\n     // instructions into that block by way of this block context.\n     // The block pointing to this one in the function's digraph.\n     llbb: BasicBlockRef,\n-    mutable terminated: bool,\n-    mutable unreachable: bool,\n+    mut terminated: bool,\n+    mut unreachable: bool,\n     parent: block_parent,\n     // The 'kind' of basic block this is.\n     kind: block_kind,\n     // The source span where the block came from, if it is a block that\n     // actually appears in the source code.\n-    mutable block_span: option<span>,\n+    mut block_span: option<span>,\n     // The function context for the function to which this block is\n     // attached.\n     fcx: fn_ctxt"}, {"sha": "cbca8f63a52c4450cfbe0b6753022eeb354d9eea", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -366,8 +366,8 @@ type struct_ctxt = {\n     file: ValueRef,\n     name: str,\n     line: int,\n-    mutable members: [ValueRef],\n-    mutable total_size: int,\n+    mut members: [ValueRef],\n+    mut total_size: int,\n     align: int\n };\n \n@@ -382,8 +382,8 @@ fn create_structure(file: @metadata<file_md>, name: str, line: int)\n     let cx = @{file: file.node,\n                name: name,\n                line: line,\n-               mutable members: [],\n-               mutable total_size: 0,\n+               mut members: [],\n+               mut total_size: 0,\n                align: 64 //XXX different alignment per arch?\n               };\n     ret cx;"}, {"sha": "a81caf11b36109490d7895cdfb7fcb3125ae6cbd", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -23,10 +23,10 @@ import ty_ctxt = middle::ty::ctxt;\n type res_info = {did: ast::def_id, tps: [ty::t]};\n \n type ctxt =\n-    {mutable next_tag_id: u16,\n+    {mut next_tag_id: u16,\n      pad: u16,\n      tag_id_to_index: hashmap<ast::def_id, u16>,\n-     mutable tag_order: [ast::def_id],\n+     mut tag_order: [ast::def_id],\n      resources: interner::interner<res_info>,\n      llshapetablesty: TypeRef,\n      llshapetables: ValueRef};\n@@ -126,8 +126,8 @@ fn largest_variants(ccx: @crate_ctxt, tag_id: ast::def_id) -> [uint] {\n     }\n \n     // Initialize the candidate set to contain all variants.\n-    let mut candidates = [mutable];\n-    for variant in *variants { candidates += [mutable true]; }\n+    let mut candidates = [mut];\n+    for variant in *variants { candidates += [mut true]; }\n \n     // Do a pairwise comparison among all variants still in the candidate set.\n     // Throw out any variant that we know has size and alignment at least as\n@@ -269,10 +269,10 @@ fn mk_ctxt(llmod: ModuleRef) -> ctxt {\n         lib::llvm::llvm::LLVMAddGlobal(llmod, llshapetablesty, buf)\n     });\n \n-    ret {mutable next_tag_id: 0u16,\n+    ret {mut next_tag_id: 0u16,\n          pad: 0u16,\n          tag_id_to_index: common::new_def_hash(),\n-         mutable tag_order: [],\n+         mut tag_order: [],\n          resources: interner::mk(hash_res_info, {|a, b| a == b}),\n          llshapetablesty: llshapetablesty,\n          llshapetables: llshapetables};"}, {"sha": "61b09f0e01ccde0c11f7092b50eec83860811fc8", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -29,7 +29,7 @@ const use_repr: uint = 1u; // Dependency on size/alignment and take/drop glue\n const use_tydesc: uint = 2u; // Takes the tydesc, or compares\n \n type ctx = {ccx: @crate_ctxt,\n-            uses: [mutable type_uses]};\n+            uses: [mut type_uses]};\n \n fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n     -> [type_uses] {"}, {"sha": "3693f22d6e28244e51fd8b224a58fe9c3834e727", "filename": "src/rustc/middle/tstate/annotate.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -7,11 +7,11 @@ import aux::{num_constraints, get_fn_info, crate_ctxt, add_node};\n import ann::empty_ann;\n import pat_util::pat_binding_ids;\n \n-fn collect_ids_expr(e: @expr, rs: @mutable [node_id]) { *rs += [e.id]; }\n+fn collect_ids_expr(e: @expr, rs: @mut [node_id]) { *rs += [e.id]; }\n \n-fn collect_ids_block(b: blk, rs: @mutable [node_id]) { *rs += [b.node.id]; }\n+fn collect_ids_block(b: blk, rs: @mut [node_id]) { *rs += [b.node.id]; }\n \n-fn collect_ids_stmt(s: @stmt, rs: @mutable [node_id]) {\n+fn collect_ids_stmt(s: @stmt, rs: @mut [node_id]) {\n     alt s.node {\n       stmt_decl(_, id) | stmt_expr(_, id) | stmt_semi(_, id) {\n         log(debug, \"node_id \" + int::str(id));\n@@ -22,11 +22,11 @@ fn collect_ids_stmt(s: @stmt, rs: @mutable [node_id]) {\n     }\n }\n \n-fn collect_ids_local(tcx: ty::ctxt, l: @local, rs: @mutable [node_id]) {\n+fn collect_ids_local(tcx: ty::ctxt, l: @local, rs: @mut [node_id]) {\n     *rs += pat_binding_ids(tcx.def_map, l.node.pat);\n }\n \n-fn node_ids_in_fn(tcx: ty::ctxt, body: blk, rs: @mutable [node_id]) {\n+fn node_ids_in_fn(tcx: ty::ctxt, body: blk, rs: @mut [node_id]) {\n     let collect_ids =\n         visit::mk_simple_visitor(@{visit_expr: bind collect_ids_expr(_, rs),\n                                    visit_block: bind collect_ids_block(_, rs),\n@@ -45,7 +45,7 @@ fn init_vecs(ccx: crate_ctxt, node_ids: [node_id], len: uint) {\n }\n \n fn visit_fn(ccx: crate_ctxt, num_constraints: uint, body: blk) {\n-    let node_ids: @mutable [node_id] = @mutable [];\n+    let node_ids: @mut [node_id] = @mut [];\n     node_ids_in_fn(ccx.tcx, body, node_ids);\n     let node_id_vec = *node_ids;\n     init_vecs(ccx, node_id_vec, num_constraints);"}, {"sha": "c568d1f0cfee563b1ee401251beb8900e6da22e9", "filename": "src/rustc/middle/tstate/auxiliary.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -200,9 +200,9 @@ type constr_arg_use = spanned<constr_arg_general_<inst>>;\n enum constraint {\n     cinit(uint, span, ident),\n \n-    // FIXME: really only want it to be mutable during collect_locals.\n+    // FIXME: really only want it to be mut during collect_locals.\n     // freeze it after that.\n-    cpred(@path, @mutable [pred_args]),\n+    cpred(@path, @mut [pred_args]),\n }\n \n // An ninit variant has a node_id because it refers to a local var.\n@@ -261,7 +261,7 @@ type fn_info =\n      cf: ret_style,\n      i_return: tsconstr,\n      i_diverge: tsconstr,\n-     used_vars: @mutable [node_id]};\n+     used_vars: @mut [node_id]};\n \n fn tsconstr_to_def_id(t: tsconstr) -> def_id {\n     alt t { ninit(id, _) { local_def(id) } npred(_, id, _) { id } }\n@@ -275,7 +275,7 @@ fn tsconstr_to_node_id(t: tsconstr) -> node_id {\n }\n \n /* mapping from node ID to typestate annotation */\n-type node_ann_table = @mutable [mutable ts_ann];\n+type node_ann_table = @mut [mut ts_ann];\n \n \n /* mapping from function name to fn_info map */\n@@ -483,8 +483,8 @@ fn pure_exp(ccx: crate_ctxt, id: node_id, p: prestate) -> bool {\n fn num_constraints(m: fn_info) -> uint { ret m.num_constraints; }\n \n fn new_crate_ctxt(cx: ty::ctxt) -> crate_ctxt {\n-    let na: [mutable ts_ann] = [mutable];\n-    ret {tcx: cx, node_anns: @mutable na, fm: int_hash::<fn_info>()};\n+    let na: [mut ts_ann] = [mut];\n+    ret {tcx: cx, node_anns: @mut na, fm: int_hash::<fn_info>()};\n }\n \n /* Use e's type to determine whether it returns.\n@@ -549,7 +549,7 @@ fn constraints(fcx: fn_ctxt) -> [norm_constraint] {\n // FIXME\n // Would rather take an immutable vec as an argument,\n // should freeze it at some earlier point.\n-fn match_args(fcx: fn_ctxt, occs: @mutable [pred_args],\n+fn match_args(fcx: fn_ctxt, occs: @mut [pred_args],\n               occ: [@constr_arg_use]) -> uint {\n     #debug(\"match_args: looking at %s\",\n            constr_args_to_str(fn@(i: inst) -> str { ret i.ident; }, occ));\n@@ -995,7 +995,7 @@ fn args_mention<T>(args: [@constr_arg_use],\n fn use_var(fcx: fn_ctxt, v: node_id) { *fcx.enclosing.used_vars += [v]; }\n \n // FIXME: This should be a function in vec::.\n-fn vec_contains(v: @mutable [node_id], i: node_id) -> bool {\n+fn vec_contains(v: @mut [node_id], i: node_id) -> bool {\n     for d: node_id in *v { if d == i { ret true; } }\n     ret false;\n }"}, {"sha": "90099df649272035715319311170fbc4a733fb59", "filename": "src/rustc/middle/tstate/collect_locals.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -10,7 +10,7 @@ import driver::session::session;\n import aux::*;\n import std::map::hashmap;\n \n-type ctxt = {cs: @mutable [sp_constr], tcx: ty::ctxt};\n+type ctxt = {cs: @mut [sp_constr], tcx: ty::ctxt};\n \n fn collect_local(loc: @local, cx: ctxt, v: visit::vt<ctxt>) {\n     pat_bindings(cx.tcx.def_map, loc.node.pat) {|p_id, _s, id|\n@@ -46,7 +46,7 @@ fn find_locals(tcx: ty::ctxt,\n                f_body: blk,\n                sp: span,\n                id: node_id) -> ctxt {\n-    let cx: ctxt = {cs: @mutable [], tcx: tcx};\n+    let cx: ctxt = {cs: @mut [], tcx: tcx};\n     let visitor = visit::default_visitor::<ctxt>();\n     let visitor =\n         @{visit_local: collect_local,\n@@ -78,8 +78,8 @@ fn add_constraint(tcx: ty::ctxt, c: sp_constr, next: uint, tbl: constr_map) ->\n             }\n           }\n           none {\n-            let rslt: @mutable [pred_args] =\n-                @mutable [respan(c.span, {args: args, bit_num: next})];\n+            let rslt: @mut [pred_args] =\n+                @mut [respan(c.span, {args: args, bit_num: next})];\n             tbl.insert(d_id, cpred(p, rslt));\n           }\n         }\n@@ -141,7 +141,7 @@ fn mk_fn_info(ccx: crate_ctxt,\n     next = add_constraint(cx.tcx, respan(f_sp, diverges_constr), next,\n                           res_map);\n \n-    let v: @mutable [node_id] = @mutable [];\n+    let v: @mut [node_id] = @mut [];\n     let rslt =\n         {constrs: res_map,\n          num_constraints: next,"}, {"sha": "a2796c942445927878e3d3d04093d3e3187d354b", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -186,7 +186,7 @@ enum borrowing {\n \n type ctxt =\n     @{interner: hashmap<intern_key, t_box>,\n-      mutable next_id: uint,\n+      mut next_id: uint,\n       sess: session::session,\n       def_map: resolve::def_map,\n       region_map: @middle::region::region_map,\n@@ -373,7 +373,7 @@ fn mk_ctxt(s: session::session, dm: resolve::def_map, amap: ast_map::map,\n             option::maybe(k.o_def_id, 0u, ast_util::hash_def_id)\n     }, {|&&a, &&b| a == b});\n     @{interner: interner,\n-      mutable next_id: 0u,\n+      mut next_id: 0u,\n       sess: s,\n       def_map: dm,\n       region_map: region_map,\n@@ -1027,7 +1027,7 @@ fn type_structurally_contains(cx: ctxt, ty: t, test: fn(sty) -> bool) ->\n }\n \n // Returns true for noncopyable types and types where a copy of a value can be\n-// distinguished from the value itself. I.e. types with mutable content that's\n+// distinguished from the value itself. I.e. types with mut content that's\n // not shared through a pointer.\n fn type_allows_implicit_copy(cx: ctxt, ty: t) -> bool {\n     ret !type_structurally_contains(cx, ty, {|sty|\n@@ -2064,7 +2064,7 @@ fn class_field_tys(items: [@class_item]) -> [field_ty] {\n fn class_items_as_fields(cx:ctxt, did: ast::def_id) -> [field] {\n     let mut rslt = [];\n     for f in lookup_class_fields(cx, did) {\n-       // consider all instance vars mutable, because the\n+       // consider all instance vars mut, because the\n        // constructor may mutate all vars\n       rslt += [{ident: f.ident, mt: {ty: lookup_field_type(cx, did, f.id),\n                   mutbl: m_mutbl}}];"}, {"sha": "3fb2c67509a7d50532493963239927819668df82", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -51,7 +51,7 @@ type ty_table = hashmap<ast::def_id, ty::t>;\n // Used for typechecking the methods of an impl\n enum self_info { self_impl(ty::t) }\n \n-type crate_ctxt = {mutable self_infos: [self_info],\n+type crate_ctxt = {mut self_infos: [self_info],\n                    impl_map: resolve::impl_map,\n                    method_map: method_map,\n                    vtable_map: vtable_map,\n@@ -75,7 +75,7 @@ type fn_ctxt =\n      proto: ast::proto,\n      infcx: infer::infer_ctxt,\n      locals: hashmap<ast::node_id, int>,\n-     next_var_id: @mutable int,\n+     next_var_id: @mut int,\n      ccx: @crate_ctxt};\n \n \n@@ -1244,13 +1244,13 @@ mod demand {\n             ty_param_substs_0: [ty::t]) ->\n        ty_param_substs_and_ty {\n \n-        let mut ty_param_substs: [mutable ty::t] = [mutable];\n+        let mut ty_param_substs: [mut ty::t] = [mut];\n         let mut ty_param_subst_var_ids: [int] = [];\n         for ty_param_subst: ty::t in ty_param_substs_0 {\n             // Generate a type variable and unify it with the type parameter\n             // substitution. We will then pull out these type variables.\n             let t_0 = next_ty_var(fcx);\n-            ty_param_substs += [mutable t_0];\n+            ty_param_substs += [mut t_0];\n             ty_param_subst_var_ids += [ty::ty_var_id(t_0)];\n             simple(fcx, sp, ty_param_subst, t_0);\n         }\n@@ -1383,7 +1383,7 @@ mod writeback {\n     type wb_ctxt =\n         // As soon as we hit an error we have to stop resolving\n         // the entire function\n-        {fcx: @fn_ctxt, mutable success: bool};\n+        {fcx: @fn_ctxt, mut success: bool};\n     type wb_vt = visit::vt<wb_ctxt>;\n \n     fn visit_stmt(s: @ast::stmt, wbcx: wb_ctxt, v: wb_vt) {\n@@ -1461,7 +1461,7 @@ mod writeback {\n     }\n \n     fn resolve_type_vars_in_expr(fcx: @fn_ctxt, e: @ast::expr) -> bool {\n-        let wbcx = {fcx: fcx, mutable success: true};\n+        let wbcx = {fcx: fcx, mut success: true};\n         let visit =\n             visit::mk_vt(@{visit_item: visit_item,\n                            visit_stmt: visit_stmt,\n@@ -1475,7 +1475,7 @@ mod writeback {\n     }\n \n     fn resolve_type_vars_in_block(fcx: @fn_ctxt, blk: ast::blk) -> bool {\n-        let wbcx = {fcx: fcx, mutable success: true};\n+        let wbcx = {fcx: fcx, mut success: true};\n         let visit =\n             visit::mk_vt(@{visit_item: visit_item,\n                            visit_stmt: visit_stmt,\n@@ -1536,7 +1536,7 @@ fn check_intrinsic_type(tcx: ty::ctxt, it: @ast::native_item) {\n type gather_result =\n     {infcx: infer::infer_ctxt,\n      locals: hashmap<ast::node_id, int>,\n-     next_var_id: @mutable int};\n+     next_var_id: @mut int};\n \n // Used only as a helper for check_fn.\n fn gather_locals(ccx: @crate_ctxt,\n@@ -1548,7 +1548,7 @@ fn gather_locals(ccx: @crate_ctxt,\n       none {\n         {infcx: infer::new_infer_ctxt(ccx.tcx),\n          locals: int_hash::<int>(),\n-         nvi: @mutable 0}\n+         nvi: @mut 0}\n       }\n       some(fcx) {\n         {infcx: fcx.infcx,\n@@ -2544,7 +2544,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             // const versions of the vectors in L and R.  Next, let T be a\n             // fresh type variable where TL <: T and TR <: T.  Then the result\n             // type is a fresh type variable T1 where T1 <: [const T].  This\n-            // allows the result to be either a mutable or immutable vector,\n+            // allows the result to be either a mut or immutable vector,\n             // depending on external demands.\n             let const_vec_t =\n                 ty::mk_vec(tcx, {ty: next_ty_var(fcx),\n@@ -3370,7 +3370,7 @@ fn check_const(ccx: @crate_ctxt, _sp: span, e: @ast::expr, id: ast::node_id) {\n           proto: ast::proto_box,\n           infcx: infer::new_infer_ctxt(ccx.tcx),\n           locals: int_hash::<int>(),\n-          next_var_id: @mutable 0,\n+          next_var_id: @mut 0,\n           ccx: ccx};\n     check_expr(fcx, e);\n     let cty = expr_ty(fcx.ccx.tcx, e);\n@@ -3389,7 +3389,7 @@ fn check_enum_variants(ccx: @crate_ctxt, sp: span, vs: [ast::variant],\n           proto: ast::proto_box,\n           infcx: infer::new_infer_ctxt(ccx.tcx),\n           locals: int_hash::<int>(),\n-          next_var_id: @mutable 0,\n+          next_var_id: @mut 0,\n           ccx: ccx};\n     let mut disr_vals: [int] = [];\n     let mut disr_val = 0;\n@@ -3950,7 +3950,7 @@ fn check_crate(tcx: ty::ctxt, impl_map: resolve::impl_map,\n                crate: @ast::crate) -> (method_map, vtable_map) {\n     collect::collect_item_types(tcx, crate);\n \n-    let ccx = @{mutable self_infos: [],\n+    let ccx = @{mut self_infos: [],\n                 impl_map: impl_map,\n                 method_map: std::map::int_hash(),\n                 vtable_map: std::map::int_hash(),"}, {"sha": "217977e96588eb960cae39bf309bb2f58e0754fe", "filename": "src/rustc/syntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fast.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -86,7 +86,7 @@ enum def {\n     // first def_id is for parent class\n     def_class_field(def_id, def_id),\n     // No purity allowed for now, I guess\n-    // (simpler this way, b/c presumably methods read mutable state)\n+    // (simpler this way, b/c presumably methods read mut state)\n     def_class_method(def_id, def_id),\n     def_region(node_id)\n }"}, {"sha": "a1a117201fb29aae99682bfcffc38ce238ce1784", "filename": "src/rustc/syntax/codemap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fcodemap.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -16,21 +16,21 @@ enum file_substr {\n \n type filemap =\n     @{name: filename, substr: file_substr, src: @str,\n-      start_pos: file_pos, mutable lines: [file_pos]};\n+      start_pos: file_pos, mut lines: [file_pos]};\n \n-type codemap = @{mutable files: [filemap]};\n+type codemap = @{mut files: [filemap]};\n \n type loc = {file: filemap, line: uint, col: uint};\n \n-fn new_codemap() -> codemap { @{mutable files: [] } }\n+fn new_codemap() -> codemap { @{mut files: [] } }\n \n fn new_filemap_w_substr(filename: filename, substr: file_substr,\n                         src: @str,\n                         start_pos_ch: uint, start_pos_byte: uint)\n    -> filemap {\n     ret @{name: filename, substr: substr, src: src,\n           start_pos: {ch: start_pos_ch, byte: start_pos_byte},\n-          mutable lines: [{ch: start_pos_ch, byte: start_pos_byte}]};\n+          mut lines: [{ch: start_pos_ch, byte: start_pos_byte}]};\n }\n \n fn new_filemap(filename: filename, src: @str,"}, {"sha": "86f13822c6e63c06f43f165d0921ef3ac8427e53", "filename": "src/rustc/syntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fext%2Fbase.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -67,7 +67,7 @@ fn mk_ctxt(session: driver::session::session,\n     type ctxt_repr = {session: driver::session::session,\n                       parse_sess: parser::parse_sess,\n                       cfg: ast::crate_cfg,\n-                      mutable backtrace: expn_info};\n+                      mut backtrace: expn_info};\n     impl of ext_ctxt for ctxt_repr {\n         fn session() -> driver::session::session { self.session }\n         fn codemap() -> codemap { self.parse_sess.cm }\n@@ -122,7 +122,7 @@ fn mk_ctxt(session: driver::session::session,\n         session: session,\n         parse_sess: parse_sess,\n         cfg: cfg,\n-        mutable backtrace: none\n+        mut backtrace: none\n     };\n     ret imp as ext_ctxt\n }"}, {"sha": "50d70ffa8d0020c54716dbb61a2760bc1dbad2d7", "filename": "src/rustc/syntax/ext/qquote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fext%2Fqquote.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -13,7 +13,7 @@ import io::*;\n import codemap::span;\n \n type aq_ctxt = @{lo: uint,\n-                 mutable gather: [{lo: uint, hi: uint,\n+                 mut gather: [{lo: uint, hi: uint,\n                                    e: @ast::expr,\n                                    constr: str}]};\n enum fragment {\n@@ -99,7 +99,7 @@ fn gather_anti_quotes<N: qq_helper>(lo: uint, node: N) -> aq_ctxt\n     let v = @{visit_expr: visit_aq_expr,\n               visit_ty: visit_aq_ty\n               with *default_visitor()};\n-    let cx = @{lo:lo, mutable gather: []};\n+    let cx = @{lo:lo, mut gather: []};\n     node.visit(cx, mk_vt(v));\n     // FIXME: Maybe this is an overkill (merge_sort), it might be better\n     //   to just keep the gather array in sorted order ..."}, {"sha": "dfc7d5314fc6b6322f03e304c6f48a680b27f2e9", "filename": "src/rustc/syntax/ext/simplext.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fext%2Fsimplext.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -136,7 +136,7 @@ fn compose_sels(s1: selector, s2: selector) -> selector {\n \n type binders =\n     {real_binders: hashmap<ident, selector>,\n-     mutable literal_ast_matchers: [selector]};\n+     mut literal_ast_matchers: [selector]};\n type bindings = hashmap<ident, arb_depth<matchable>>;\n \n fn acumm_bindings(_cx: ext_ctxt, _b_dest: bindings, _b_src: bindings) { }\n@@ -148,7 +148,7 @@ fn acumm_bindings(_cx: ext_ctxt, _b_dest: bindings, _b_src: bindings) { }\n fn pattern_to_selectors(cx: ext_ctxt, e: @expr) -> binders {\n     let res: binders =\n         {real_binders: str_hash::<selector>(),\n-         mutable literal_ast_matchers: []};\n+         mut literal_ast_matchers: []};\n     //this oughta return binders instead, but macro args are a sequence of\n     //expressions, rather than a single expression\n     fn trivial_selector(m: matchable) -> match_result { ret some(leaf(m)); }\n@@ -183,7 +183,7 @@ fn use_selectors_to_bind(b: binders, e: @expr) -> option<bindings> {\n /* use the bindings on the body to generate the expanded code */\n \n fn transcribe(cx: ext_ctxt, b: bindings, body: @expr) -> @expr {\n-    let idx_path: @mutable [uint] = @mutable [];\n+    let idx_path: @mut [uint] = @mut [];\n     fn new_id(_old: node_id, cx: ext_ctxt) -> node_id { ret cx.next_id(); }\n     fn new_span(cx: ext_ctxt, sp: span) -> span {\n         /* this discards information in the case of macro-defining macros */\n@@ -208,7 +208,7 @@ fn transcribe(cx: ext_ctxt, b: bindings, body: @expr) -> @expr {\n \n \n /* helper: descend into a matcher */\n-fn follow(m: arb_depth<matchable>, idx_path: @mutable [uint]) ->\n+fn follow(m: arb_depth<matchable>, idx_path: @mut [uint]) ->\n    arb_depth<matchable> {\n     let mut res: arb_depth<matchable> = m;\n     for idx: uint in *idx_path {\n@@ -221,7 +221,7 @@ fn follow(m: arb_depth<matchable>, idx_path: @mutable [uint]) ->\n }\n \n fn follow_for_trans(cx: ext_ctxt, mmaybe: option<arb_depth<matchable>>,\n-                    idx_path: @mutable [uint]) -> option<matchable> {\n+                    idx_path: @mut [uint]) -> option<matchable> {\n     alt mmaybe {\n       none { ret none }\n       some(m) {\n@@ -258,7 +258,7 @@ fn free_vars(b: bindings, e: @expr, it: fn(ident)) {\n \n \n /* handle sequences (anywhere in the AST) of exprs, either real or ...ed */\n-fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n+fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mut [uint],\n                     recur: fn@(&&@expr) -> @expr, exprs: [@expr]) -> [@expr] {\n     alt elts_to_ell(cx, exprs) {\n       {pre: pre, rep: repeat_me_maybe, post: post} {\n@@ -320,7 +320,7 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n \n \n // substitute, in a position that's required to be an ident\n-fn transcribe_ident(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n+fn transcribe_ident(cx: ext_ctxt, b: bindings, idx_path: @mut [uint],\n                     &&i: ident, _fld: ast_fold) -> ident {\n     ret alt follow_for_trans(cx, b.find(i), idx_path) {\n           some(match_ident(a_id)) { a_id.node }\n@@ -330,7 +330,7 @@ fn transcribe_ident(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n }\n \n \n-fn transcribe_path(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n+fn transcribe_path(cx: ext_ctxt, b: bindings, idx_path: @mut [uint],\n                    p: path_, s:span, _fld: ast_fold) -> (path_, span) {\n     // Don't substitute into qualified names.\n     if vec::len(p.types) > 0u || vec::len(p.idents) != 1u { ret (p, s); }\n@@ -345,7 +345,7 @@ fn transcribe_path(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n }\n \n \n-fn transcribe_expr(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n+fn transcribe_expr(cx: ext_ctxt, b: bindings, idx_path: @mut [uint],\n                    e: ast::expr_, s: span, fld: ast_fold,\n                    orig: fn@(ast::expr_, span, ast_fold)->(ast::expr_, span))\n     -> (ast::expr_, span)\n@@ -373,7 +373,7 @@ fn transcribe_expr(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n         }\n }\n \n-fn transcribe_type(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n+fn transcribe_type(cx: ext_ctxt, b: bindings, idx_path: @mut [uint],\n                    t: ast::ty_, s: span, fld: ast_fold,\n                    orig: fn@(ast::ty_, span, ast_fold) -> (ast::ty_, span))\n     -> (ast::ty_, span)\n@@ -399,7 +399,7 @@ fn transcribe_type(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n /* for parsing reasons, syntax variables bound to blocks must be used like\n `{v}` */\n \n-fn transcribe_block(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n+fn transcribe_block(cx: ext_ctxt, b: bindings, idx_path: @mut [uint],\n                     blk: blk_, s: span, fld: ast_fold,\n                     orig: fn@(blk_, span, ast_fold) -> (blk_, span))\n     -> (blk_, span)"}, {"sha": "4630b99eda6d84a546185a4245637110bec5c93f", "filename": "src/rustc/syntax/fold.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Ffold.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -15,7 +15,7 @@ export noop_fold_block;\n export wrap;\n export fold_ty_param;\n \n-type ast_fold = @mutable a_f;\n+type ast_fold = @mut a_f;\n \n // We may eventually want to be able to fold over type parameters, too\n \n@@ -602,9 +602,9 @@ fn default_ast_fold() -> @ast_fold_precursor {\n \n fn make_fold(afp: ast_fold_precursor) -> ast_fold {\n     // FIXME: Have to bind all the bare functions into shared functions\n-    // because @mutable is invariant with respect to its contents\n+    // because @mut is invariant with respect to its contents\n     let result: ast_fold =\n-        @mutable {fold_crate: bind nf_crate_dummy(_),\n+        @mut {fold_crate: bind nf_crate_dummy(_),\n                   fold_crate_directive: bind nf_crate_directive_dummy(_),\n                   fold_view_item: bind nf_view_item_dummy(_),\n                   fold_native_item: bind nf_native_item_dummy(_),"}, {"sha": "5613b736d069de0919ff7dba1ffe96139f3c3c95", "filename": "src/rustc/syntax/parse/lexer.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fparse%2Flexer.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -8,11 +8,11 @@ type reader = @{\n     span_diagnostic: diagnostic::span_handler,\n     src: @str,\n     len: uint,\n-    mutable col: uint,\n-    mutable pos: uint,\n-    mutable curr: char,\n-    mutable chpos: uint,\n-    mutable strs: [str],\n+    mut col: uint,\n+    mut pos: uint,\n+    mut curr: char,\n+    mut chpos: uint,\n+    mut strs: [str],\n     filemap: codemap::filemap,\n     interner: @interner::interner<str>\n };\n@@ -63,8 +63,8 @@ fn new_reader(cm: codemap::codemap,\n     let r = @{cm: cm,\n               span_diagnostic: span_diagnostic,\n               src: filemap.src, len: str::len(*filemap.src),\n-              mutable col: 0u, mutable pos: 0u, mutable curr: -1 as char,\n-              mutable chpos: filemap.start_pos.ch, mutable strs: [],\n+              mut col: 0u, mut pos: 0u, mut curr: -1 as char,\n+              mut chpos: filemap.start_pos.ch, mut strs: [],\n               filemap: filemap, interner: itr};\n     if r.pos < r.len {\n         let next = str::char_range_at(*r.src, r.pos);"}, {"sha": "78d8d2b6133ad63d24afae898ef5a99e3e84a822", "filename": "src/rustc/syntax/parse/parser.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fparse%2Fparser.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -21,11 +21,11 @@ enum file_type { CRATE_FILE, SOURCE_FILE, }\n \n type parse_sess = @{\n     cm: codemap::codemap,\n-    mutable next_id: node_id,\n+    mut next_id: node_id,\n     span_diagnostic: diagnostic::span_handler,\n     // these two must be kept up to date\n-    mutable chpos: uint,\n-    mutable byte_pos: uint\n+    mut chpos: uint,\n+    mut byte_pos: uint\n };\n \n fn next_node_id(sess: parse_sess) -> node_id {\n@@ -40,11 +40,11 @@ type parser = @{\n     sess: parse_sess,\n     cfg: ast::crate_cfg,\n     file_type: file_type,\n-    mutable token: token::token,\n-    mutable span: span,\n-    mutable last_span: span,\n-    mutable buffer: [{tok: token::token, span: span}],\n-    mutable restriction: restriction,\n+    mut token: token::token,\n+    mut span: span,\n+    mut last_span: span,\n+    mut buffer: [{tok: token::token, span: span}],\n+    mut restriction: restriction,\n     reader: reader,\n     precs: @[op_spec],\n     bad_expr_words: hashmap<str, ()>\n@@ -130,11 +130,11 @@ fn new_parser(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader,\n     @{sess: sess,\n       cfg: cfg,\n       file_type: ftype,\n-      mutable token: tok0.tok,\n-      mutable span: span0,\n-      mutable last_span: span0,\n-      mutable buffer: [],\n-      mutable restriction: UNRESTRICTED,\n+      mut token: tok0.tok,\n+      mut span: span0,\n+      mut last_span: span0,\n+      mut buffer: [],\n+      mut restriction: UNRESTRICTED,\n       reader: rdr,\n       precs: prec_table(),\n       bad_expr_words: bad_expr_word_table()}\n@@ -149,7 +149,7 @@ fn bad_expr_word_table() -> hashmap<str, ()> {\n                  \"class\", \"const\", \"cont\", \"copy\", \"crust\", \"do\", \"else\",\n                  \"enum\", \"export\", \"fail\", \"fn\", \"for\", \"if\",  \"iface\",\n                  \"impl\", \"import\", \"let\", \"log\", \"loop\", \"mod\", \"mut\",\n-                 \"mutable\", \"native\", \"pure\", \"resource\", \"ret\", \"trait\",\n+                 \"mut\", \"native\", \"pure\", \"resource\", \"ret\", \"trait\",\n                  \"type\", \"unchecked\", \"unsafe\", \"while\", \"new\"] {\n         words.insert(word, ());\n     }\n@@ -735,7 +735,7 @@ fn parse_path_and_ty_param_substs(p: parser, colons: bool) -> @ast::path {\n }\n \n fn parse_mutability(p: parser) -> ast::mutability {\n-    if eat_word(p, \"mutable\") {\n+    if eat_word(p, \"mut\") {\n         ast::m_mutbl\n     } else if eat_word(p, \"mut\") {\n         ast::m_mutbl\n@@ -831,7 +831,7 @@ fn parse_bottom_expr(p: parser) -> pexpr {\n         ret mk_pexpr(p, lo, hi, ast::expr_tup(es));\n     } else if p.token == token::LBRACE {\n         p.bump();\n-        if is_word(p, \"mut\") || is_word(p, \"mutable\") ||\n+        if is_word(p, \"mut\") ||\n                is_plain_ident(p) && p.look_ahead(1u) == token::COLON {\n             let mut fields = [parse_field(p, token::COLON)];\n             let mut base = none;\n@@ -1660,7 +1660,7 @@ fn parse_let(p: parser) -> @ast::decl {\n fn parse_instance_var(p:parser) -> (ast::class_member, codemap::span) {\n     let mut is_mutbl = ast::class_immutable;\n     let lo = p.span.lo;\n-    if eat_word(p, \"mut\") || eat_word(p, \"mutable\") {\n+    if eat_word(p, \"mut\") {\n             is_mutbl = ast::class_mutable;\n     }\n     if !is_plain_ident(p) {"}, {"sha": "f116bab4fe48a95935e8920d0cb04ca629ea72fc", "filename": "src/rustc/syntax/print/pp.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fprint%2Fpp.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -70,7 +70,7 @@ fn tok_str(t: token) -> str {\n     }\n }\n \n-fn buf_str(toks: [mutable token], szs: [mutable int], left: uint, right: uint,\n+fn buf_str(toks: [mut token], szs: [mut int], left: uint, right: uint,\n            lim: uint) -> str {\n     let n = vec::len(toks);\n     assert (n == vec::len(szs));\n@@ -99,26 +99,26 @@ fn mk_printer(out: io::writer, linewidth: uint) -> printer {\n     // fall behind.\n     let n: uint = 3u * linewidth;\n     #debug(\"mk_printer %u\", linewidth);\n-    let token: [mutable token] = vec::to_mut(vec::from_elem(n, EOF));\n-    let size: [mutable int] = vec::to_mut(vec::from_elem(n, 0));\n-    let scan_stack: [mutable uint] = vec::to_mut(vec::from_elem(n, 0u));\n+    let token: [mut token] = vec::to_mut(vec::from_elem(n, EOF));\n+    let size: [mut int] = vec::to_mut(vec::from_elem(n, 0));\n+    let scan_stack: [mut uint] = vec::to_mut(vec::from_elem(n, 0u));\n     let print_stack: [print_stack_elt] = [];\n     @{out: out,\n       buf_len: n,\n-      mutable margin: linewidth as int,\n-      mutable space: linewidth as int,\n-      mutable left: 0u,\n-      mutable right: 0u,\n-      mutable token: token,\n-      mutable size: size,\n-      mutable left_total: 0,\n-      mutable right_total: 0,\n-      mutable scan_stack: scan_stack,\n-      mutable scan_stack_empty: true,\n-      mutable top: 0u,\n-      mutable bottom: 0u,\n-      mutable print_stack: print_stack,\n-      mutable pending_indentation: 0}\n+      mut margin: linewidth as int,\n+      mut space: linewidth as int,\n+      mut left: 0u,\n+      mut right: 0u,\n+      mut token: token,\n+      mut size: size,\n+      mut left_total: 0,\n+      mut right_total: 0,\n+      mut scan_stack: scan_stack,\n+      mut scan_stack_empty: true,\n+      mut top: 0u,\n+      mut bottom: 0u,\n+      mut print_stack: print_stack,\n+      mut pending_indentation: 0}\n }\n \n \n@@ -202,28 +202,28 @@ fn mk_printer(out: io::writer, linewidth: uint) -> printer {\n type printer = @{\n     out: io::writer,\n     buf_len: uint,\n-    mutable margin: int, // width of lines we're constrained to\n-    mutable space: int, // number of spaces left on line\n-    mutable left: uint, // index of left side of input stream\n-    mutable right: uint, // index of right side of input stream\n-    mutable token: [mutable token], // ring-buffr stream goes through\n-    mutable size: [mutable int], // ring-buffer of calculated sizes\n-    mutable left_total: int, // running size of stream \"...left\"\n-    mutable right_total: int, // running size of stream \"...right\"\n+    mut margin: int, // width of lines we're constrained to\n+    mut space: int, // number of spaces left on line\n+    mut left: uint, // index of left side of input stream\n+    mut right: uint, // index of right side of input stream\n+    mut token: [mut token], // ring-buffr stream goes through\n+    mut size: [mut int], // ring-buffer of calculated sizes\n+    mut left_total: int, // running size of stream \"...left\"\n+    mut right_total: int, // running size of stream \"...right\"\n     // pseudo-stack, really a ring too. Holds the\n     // primary-ring-buffers index of the BEGIN that started the\n     // current block, possibly with the most recent BREAK after that\n     // BEGIN (if there is any) on top of it. Stuff is flushed off the\n     // bottom as it becomes irrelevant due to the primary ring-buffer\n     // advancing.\n-    mutable scan_stack: [mutable uint],\n-    mutable scan_stack_empty: bool, // top==bottom disambiguator\n-    mutable top: uint, // index of top of scan_stack\n-    mutable bottom: uint, // index of bottom of scan_stack\n+    mut scan_stack: [mut uint],\n+    mut scan_stack_empty: bool, // top==bottom disambiguator\n+    mut top: uint, // index of top of scan_stack\n+    mut bottom: uint, // index of bottom of scan_stack\n     // stack of blocks-in-progress being flushed by print\n-    mutable print_stack: [print_stack_elt],\n+    mut print_stack: [print_stack_elt],\n     // buffered indentation to avoid writing trailing whitespace\n-    mutable pending_indentation: int\n+    mut pending_indentation: int\n };\n \n impl printer for printer {"}, {"sha": "071441fe8e879f8565e4501750bd81c750e34c20", "filename": "src/rustc/syntax/print/pprust.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fprint%2Fpprust.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -24,9 +24,9 @@ type ps =\n       cm: option<codemap>,\n       comments: option<[lexer::cmnt]>,\n       literals: option<[lexer::lit]>,\n-      mutable cur_cmnt: uint,\n-      mutable cur_lit: uint,\n-      mutable boxes: [pp::breaks],\n+      mut cur_cmnt: uint,\n+      mut cur_lit: uint,\n+      mut boxes: [pp::breaks],\n       ann: pp_ann};\n \n fn ibox(s: ps, u: uint) { s.boxes += [pp::inconsistent]; pp::ibox(s.s, u); }\n@@ -39,9 +39,9 @@ fn rust_printer(writer: io::writer) -> ps {\n           cm: none::<codemap>,\n           comments: none::<[lexer::cmnt]>,\n           literals: none::<[lexer::lit]>,\n-          mutable cur_cmnt: 0u,\n-          mutable cur_lit: 0u,\n-          mutable boxes: boxes,\n+          mut cur_cmnt: 0u,\n+          mut cur_lit: 0u,\n+          mut boxes: boxes,\n           ann: no_ann()};\n }\n \n@@ -64,9 +64,9 @@ fn print_crate(cm: codemap, span_diagnostic: diagnostic::span_handler,\n           cm: some(cm),\n           comments: some(r.cmnts),\n           literals: some(r.lits),\n-          mutable cur_cmnt: 0u,\n-          mutable cur_lit: 0u,\n-          mutable boxes: boxes,\n+          mut cur_cmnt: 0u,\n+          mut cur_lit: 0u,\n+          mut boxes: boxes,\n           ann: ann};\n     print_crate_(s, crate);\n }\n@@ -518,7 +518,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n                  ast::instance_var(nm, t, mt, _) {\n                     word_nbsp(s, \"let\");\n                     alt mt {\n-                      ast::class_mutable { word_nbsp(s, \"mutable\"); }\n+                      ast::class_mutable { word_nbsp(s, \"mut\"); }\n                       _ {}\n                     }\n                     word(s.s, nm);\n@@ -818,7 +818,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         ibox(s, indent_unit);\n         word(s.s, \"[\");\n         if mutbl == ast::m_mutbl {\n-            word(s.s, \"mutable\");\n+            word(s.s, \"mut\");\n             if vec::len(exprs) > 0u { nbsp(s); }\n         }\n         commasep_exprs(s, inconsistent, exprs);\n@@ -828,7 +828,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n       ast::expr_rec(fields, wth) {\n         fn print_field(s: ps, field: ast::field) {\n             ibox(s, indent_unit);\n-            if field.node.mutbl == ast::m_mutbl { word_nbsp(s, \"mutable\"); }\n+            if field.node.mutbl == ast::m_mutbl { word_nbsp(s, \"mut\"); }\n             word(s.s, field.node.ident);\n             word_space(s, \":\");\n             print_expr(s, field.node.expr);\n@@ -1135,7 +1135,7 @@ fn print_decl(s: ps, decl: @ast::decl) {\n         ibox(s, indent_unit);\n         word_nbsp(s, \"let\");\n \n-        // if any are mutable, all are mutable\n+        // if any are mut, all are mut\n         if vec::any(locs) {|l| l.node.is_mutbl } {\n             assert vec::all(locs) {|l| l.node.is_mutbl };\n             word_nbsp(s, \"mut\");\n@@ -1493,7 +1493,7 @@ fn print_op_maybe_parens(s: ps, expr: @ast::expr, outer_prec: int) {\n \n fn print_mutability(s: ps, mutbl: ast::mutability) {\n     alt mutbl {\n-      ast::m_mutbl { word_nbsp(s, \"mutable\"); }\n+      ast::m_mutbl { word_nbsp(s, \"mut\"); }\n       ast::m_const { word_nbsp(s, \"const\"); }\n       ast::m_imm {/* nothing */ }\n     }"}, {"sha": "99a032aae9450c8c749ea94d5d04a687ceebec8d", "filename": "src/rustc/syntax/util/interner.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Fsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Futil%2Finterner.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -6,13 +6,13 @@ import std::map::{hashmap, hashfn, eqfn};\n \n type interner<T> =\n     {map: hashmap<T, uint>,\n-     mutable vect: [T],\n+     mut vect: [T],\n      hasher: hashfn<T>,\n      eqer: eqfn<T>};\n \n fn mk<T: copy>(hasher: hashfn<T>, eqer: eqfn<T>) -> interner<T> {\n     let m = map::hashmap::<T, uint>(hasher, eqer);\n-    ret {map: m, mutable vect: [], hasher: hasher, eqer: eqer};\n+    ret {map: m, mut vect: [], hasher: hasher, eqer: eqer};\n }\n \n fn intern<T: copy>(itr: interner<T>, val: T) -> uint {"}, {"sha": "1a6b7b0ccf956a1a1b02cf5d06cf4b875d727237", "filename": "src/rustc/util/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fcommon.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -68,8 +68,8 @@ fn log_stmt_err(st: ast::stmt) {\n }\n \n fn has_nonlocal_exits(b: ast::blk) -> bool {\n-    let has_exits = @mutable false;\n-    fn visit_expr(flag: @mutable bool, e: @ast::expr) {\n+    let has_exits = @mut false;\n+    fn visit_expr(flag: @mut bool, e: @ast::expr) {\n         alt e.node {\n           ast::expr_break { *flag = true; }\n           ast::expr_cont { *flag = true; }\n@@ -85,8 +85,8 @@ fn has_nonlocal_exits(b: ast::blk) -> bool {\n \n /* FIXME: copy/paste, yuck */\n fn may_break(b: ast::blk) -> bool {\n-    let has_exits = @mutable false;\n-    fn visit_expr(flag: @mutable bool, e: @ast::expr) {\n+    let has_exits = @mut false;\n+    fn visit_expr(flag: @mut bool, e: @ast::expr) {\n         alt e.node {\n           ast::expr_break { *flag = true; }\n           _ { }"}, {"sha": "9bed75107fb5f6870857b369bf4c42dc728e6a9d", "filename": "src/rustdoc/astsrv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fastsrv.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -104,7 +104,7 @@ fn exec<T:send>(\n }\n \n fn build_ctxt(sess: session::session, ast: @ast::crate,\n-              ignore_errors: @mutable bool) -> ctxt {\n+              ignore_errors: @mut bool) -> ctxt {\n \n     import rustc::front::config;\n \n@@ -125,7 +125,7 @@ fn build_ctxt(sess: session::session, ast: @ast::crate,\n \n // FIXME: this whole structure should not be duplicated here. makes it\n // painful to add or remove options.\n-fn build_session() -> (session::session, @mutable bool) {\n+fn build_session() -> (session::session, @mut bool) {\n     let sopts: @session::options = @{\n         crate_type: session::lib_crate,\n         static: false,\n@@ -163,7 +163,7 @@ fn build_session() -> (session::session, @mutable bool) {\n type error_handlers = {\n     emitter: diagnostic::emitter,\n     span_handler: diagnostic::span_handler,\n-    ignore_errors: @mutable bool\n+    ignore_errors: @mut bool\n };\n \n // Build a custom error handler that will allow us to ignore non-fatal\n@@ -174,7 +174,7 @@ fn build_error_handlers(\n \n     type diagnostic_handler = {\n         inner: diagnostic::handler,\n-        ignore_errors: @mutable bool\n+        ignore_errors: @mut bool\n     };\n \n     impl of diagnostic::handler for diagnostic_handler {\n@@ -197,7 +197,7 @@ fn build_error_handlers(\n         }\n     }\n \n-    let ignore_errors = @mutable false;\n+    let ignore_errors = @mut false;\n     let emitter = fn@(cmsp: option<(codemap::codemap, codemap::span)>,\n                        msg: str, lvl: diagnostic::level) {\n         if !(*ignore_errors) {"}, {"sha": "d410e3d3ab86fee4da5a04bf6cb395ca0e614063", "filename": "src/rustdoc/attr_parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_parser.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -29,10 +29,10 @@ mod test {\n         let handler = diagnostic::mk_handler(none);\n         let parse_sess = @{\n             cm: cm,\n-            mutable next_id: 0,\n+            mut next_id: 0,\n             span_diagnostic: diagnostic::mk_span_handler(handler, cm),\n-            mutable chpos: 0u,\n-            mutable byte_pos: 0u\n+            mut chpos: 0u,\n+            mut byte_pos: 0u\n         };\n         let parser = parser::new_parser_from_source_str(\n             parse_sess, [], \"-\", codemap::fss_none, @source);"}, {"sha": "a52b3271886184045bd152bd1aca6fef59a3d4c7", "filename": "src/rustdoc/parse.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustdoc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustdoc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fparse.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -14,10 +14,10 @@ fn new_parse_sess() -> parser::parse_sess {\n     let handler = diagnostic::mk_handler(none);\n     let sess = @{\n         cm: cm,\n-        mutable next_id: 1,\n+        mut next_id: 1,\n         span_diagnostic: diagnostic::mk_span_handler(handler, cm),\n-        mutable chpos: 0u,\n-        mutable byte_pos: 0u\n+        mut chpos: 0u,\n+        mut byte_pos: 0u\n     };\n     ret sess;\n }"}, {"sha": "e92845712a2507591d9284e896bdd1570a4e0737", "filename": "src/rustdoc/path_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustdoc%2Fpath_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustdoc%2Fpath_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fpath_pass.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -11,13 +11,13 @@ fn mk_pass() -> pass {\n \n type ctxt = {\n     srv: astsrv::srv,\n-    mutable path: [str]\n+    mut path: [str]\n };\n \n fn run(srv: astsrv::srv, doc: doc::doc) -> doc::doc {\n     let ctxt = {\n         srv: srv,\n-        mutable path: []\n+        mut path: []\n     };\n     let fold = fold::fold({\n         fold_item: fold_item,"}, {"sha": "11f7119c95d76ac8e2557a659fc9ceb1b23f0fad", "filename": "src/rustdoc/rustdoc", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustdoc%2Frustdoc", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Frustdoc%2Frustdoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e"}, {"sha": "cda361c1be970ae4fcef426a485fc58ef223cef2", "filename": "src/test/auxiliary/cci_class.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fauxiliary%2Fcci_class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fauxiliary%2Fcci_class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -2,7 +2,7 @@ mod kitties {\n \n class cat {\n   priv {\n-    let mutable meows : uint;\n+    let mut meows : uint;\n   }\n \n   let how_hungry : int;"}, {"sha": "0bb398839d165c4ef0a1a74c93a196dbbf519785", "filename": "src/test/auxiliary/cci_class_2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fauxiliary%2Fcci_class_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fauxiliary%2Fcci_class_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_2.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -2,7 +2,7 @@ mod kitties {\n \n class cat {\n   priv {\n-    let mutable meows : uint;\n+    let mut meows : uint;\n   }\n \n   let how_hungry : int;"}, {"sha": "a30233c8135b8e565a80f038fe3374e4451366ce", "filename": "src/test/auxiliary/cci_class_3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fauxiliary%2Fcci_class_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fauxiliary%2Fcci_class_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_3.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -2,7 +2,7 @@ mod kitties {\n \n class cat {\n   priv {\n-    let mutable meows : uint;\n+    let mut meows : uint;\n   }\n \n   let how_hungry : int;"}, {"sha": "4bebf081e2305db08bae7805431915e48706dab6", "filename": "src/test/auxiliary/cci_class_4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -2,7 +2,7 @@ mod kitties {\n \n class cat {\n   priv {\n-    let mutable meows : uint;\n+    let mut meows : uint;\n     fn meow() {\n       #error(\"Meow\");\n       meows += 1u;"}, {"sha": "6dc4d76cf5248a15e1648d6b68d82eb6628a8dd7", "filename": "src/test/auxiliary/cci_class_5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fauxiliary%2Fcci_class_5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fauxiliary%2Fcci_class_5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_5.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -2,7 +2,7 @@ mod kitties {\n \n class cat {\n   priv {\n-    let mutable meows : uint;\n+    let mut meows : uint;\n     fn nap() { uint::range(1u, 10000u) {|_i|}}\n   }\n "}, {"sha": "9ce1561d4d0fb2645f026bd17f9c79f3f57b2923", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -13,7 +13,7 @@ import str;\n \n fn LINE_LENGTH() -> uint { ret 60u; }\n \n-type myrandom = @{mutable last: u32};\n+type myrandom = @{mut last: u32};\n \n fn myrandom_next(r: myrandom, mx: u32) -> u32 {\n     r.last = (r.last * 3877u32 + 29573u32) % 139968u32;\n@@ -44,7 +44,7 @@ fn select_random(r: u32, genelist: [aminoacids]) -> char {\n \n fn make_random_fasta(id: str, desc: str, genelist: [aminoacids], n: int) {\n     log(debug, \">\" + id + \" \" + desc);\n-    let rng = @{mutable last: std::rand::rng().next()};\n+    let rng = @{mut last: std::rand::rng().next()};\n     let mut op: str = \"\";\n     uint::range(0u, n as uint) {|_i|\n         str::push_char(op, select_random(myrandom_next(rng, 100u32),"}, {"sha": "bf493d579e10c13d590df0ef29e29d0928834d3b", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -136,61 +136,61 @@ mod Body {\n     const DAYS_PER_YEAR: float = 365.24;\n \n     type props =\n-        {mutable x: float,\n-         mutable y: float,\n-         mutable z: float,\n-         mutable vx: float,\n-         mutable vy: float,\n-         mutable vz: float,\n+        {mut x: float,\n+         mut y: float,\n+         mut z: float,\n+         mut vx: float,\n+         mut vy: float,\n+         mut vz: float,\n          mass: float};\n \n     fn jupiter() -> Body::props {\n-        ret {mutable x: 4.84143144246472090e+00,\n-             mutable y: -1.16032004402742839e+00,\n-             mutable z: -1.03622044471123109e-01,\n-             mutable vx: 1.66007664274403694e-03 * DAYS_PER_YEAR,\n-             mutable vy: 7.69901118419740425e-03 * DAYS_PER_YEAR,\n-             mutable vz: -6.90460016972063023e-05 * DAYS_PER_YEAR,\n+        ret {mut x: 4.84143144246472090e+00,\n+             mut y: -1.16032004402742839e+00,\n+             mut z: -1.03622044471123109e-01,\n+             mut vx: 1.66007664274403694e-03 * DAYS_PER_YEAR,\n+             mut vy: 7.69901118419740425e-03 * DAYS_PER_YEAR,\n+             mut vz: -6.90460016972063023e-05 * DAYS_PER_YEAR,\n              mass: 9.54791938424326609e-04 * SOLAR_MASS};\n     }\n \n     fn saturn() -> Body::props {\n-        ret {mutable x: 8.34336671824457987e+00,\n-             mutable y: 4.12479856412430479e+00,\n-             mutable z: -4.03523417114321381e-01,\n-             mutable vx: -2.76742510726862411e-03 * DAYS_PER_YEAR,\n-             mutable vy: 4.99852801234917238e-03 * DAYS_PER_YEAR,\n-             mutable vz: 2.30417297573763929e-05 * DAYS_PER_YEAR,\n+        ret {mut x: 8.34336671824457987e+00,\n+             mut y: 4.12479856412430479e+00,\n+             mut z: -4.03523417114321381e-01,\n+             mut vx: -2.76742510726862411e-03 * DAYS_PER_YEAR,\n+             mut vy: 4.99852801234917238e-03 * DAYS_PER_YEAR,\n+             mut vz: 2.30417297573763929e-05 * DAYS_PER_YEAR,\n              mass: 2.85885980666130812e-04 * SOLAR_MASS};\n     }\n \n     fn uranus() -> Body::props {\n-        ret {mutable x: 1.28943695621391310e+01,\n-             mutable y: -1.51111514016986312e+01,\n-             mutable z: -2.23307578892655734e-01,\n-             mutable vx: 2.96460137564761618e-03 * DAYS_PER_YEAR,\n-             mutable vy: 2.37847173959480950e-03 * DAYS_PER_YEAR,\n-             mutable vz: -2.96589568540237556e-05 * DAYS_PER_YEAR,\n+        ret {mut x: 1.28943695621391310e+01,\n+             mut y: -1.51111514016986312e+01,\n+             mut z: -2.23307578892655734e-01,\n+             mut vx: 2.96460137564761618e-03 * DAYS_PER_YEAR,\n+             mut vy: 2.37847173959480950e-03 * DAYS_PER_YEAR,\n+             mut vz: -2.96589568540237556e-05 * DAYS_PER_YEAR,\n              mass: 4.36624404335156298e-05 * SOLAR_MASS};\n     }\n \n     fn neptune() -> Body::props {\n-        ret {mutable x: 1.53796971148509165e+01,\n-             mutable y: -2.59193146099879641e+01,\n-             mutable z: 1.79258772950371181e-01,\n-             mutable vx: 2.68067772490389322e-03 * DAYS_PER_YEAR,\n-             mutable vy: 1.62824170038242295e-03 * DAYS_PER_YEAR,\n-             mutable vz: -9.51592254519715870e-05 * DAYS_PER_YEAR,\n+        ret {mut x: 1.53796971148509165e+01,\n+             mut y: -2.59193146099879641e+01,\n+             mut z: 1.79258772950371181e-01,\n+             mut vx: 2.68067772490389322e-03 * DAYS_PER_YEAR,\n+             mut vy: 1.62824170038242295e-03 * DAYS_PER_YEAR,\n+             mut vz: -9.51592254519715870e-05 * DAYS_PER_YEAR,\n              mass: 5.15138902046611451e-05 * SOLAR_MASS};\n     }\n \n     fn sun() -> Body::props {\n-        ret {mutable x: 0.0,\n-             mutable y: 0.0,\n-             mutable z: 0.0,\n-             mutable vx: 0.0,\n-             mutable vy: 0.0,\n-             mutable vz: 0.0,\n+        ret {mut x: 0.0,\n+             mut y: 0.0,\n+             mut z: 0.0,\n+             mut vx: 0.0,\n+             mut vy: 0.0,\n+             mut vz: 0.0,\n              mass: SOLAR_MASS};\n     }\n "}, {"sha": "b9a0b80ebf951dd95ebfa206938f818ec2af4a64", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -6,7 +6,7 @@ fn eval_A(i: uint, j: uint) -> float {\n     1.0/(((i+j)*(i+j+1u)/2u+i+1u) as float)\n }\n \n-fn eval_A_times_u(u: [const float], Au: [mutable float]) {\n+fn eval_A_times_u(u: [const float], Au: [mut float]) {\n     let N = vec::len(u);\n     let mut i = 0u;\n     while i < N {\n@@ -20,7 +20,7 @@ fn eval_A_times_u(u: [const float], Au: [mutable float]) {\n     }\n }\n \n-fn eval_At_times_u(u: [const float], Au: [mutable float]) {\n+fn eval_At_times_u(u: [const float], Au: [mut float]) {\n     let N = vec::len(u);\n     let mut i = 0u;\n     while i < N {\n@@ -34,7 +34,7 @@ fn eval_At_times_u(u: [const float], Au: [mutable float]) {\n     }\n }\n \n-fn eval_AtA_times_u(u: [const float], AtAu: [mutable float]) {\n+fn eval_AtA_times_u(u: [const float], AtAu: [mut float]) {\n     let v = vec::to_mut(vec::from_elem(vec::len(u), 0.0));\n     eval_A_times_u(u, v);\n     eval_At_times_u(v, AtAu);"}, {"sha": "974c813675100905cf853b10537e93c10477d1da", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -22,7 +22,7 @@ import io::{writer_util, reader_util};\n export grid_t, read_grid, solve_grid, write_grid;\n \n // internal type of sudoku grids\n-type grid = [[mutable u8]];\n+type grid = [[mut u8]];\n \n // exported type of sudoku grids\n enum grid_t { grid_ctor(grid), }"}, {"sha": "20ffd613240ec366da606d5d6c45796fad4b2fe1", "filename": "src/test/bench/task-perf-word-count.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -103,10 +103,10 @@ mod map_reduce {\n \n         send(out, chan(p));\n \n-        let state = @{mutable ref_count: 0, mutable is_done: false};\n+        let state = @{mut ref_count: 0, mut is_done: false};\n \n-        fn get(p: port<reduce_proto>, state: @{mutable ref_count: int,\n-                                               mutable is_done: bool})\n+        fn get(p: port<reduce_proto>, state: @{mut ref_count: int,\n+                                               mut is_done: bool})\n             -> option<int> {\n             while !state.is_done || state.ref_count > 0 {\n                 alt recv(p) {"}, {"sha": "aea25979d9b2b91de042f2c4a065b24d42d59876", "filename": "src/test/compile-fail/assign-to-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Fassign-to-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Fassign-to-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassign-to-method.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,7 +1,7 @@\n // error-pattern:assigning to immutable field\n class cat {\n   priv {\n-    let mutable meows : uint;\n+    let mut meows : uint;\n   }\n \n   let how_hungry : int;"}, {"sha": "db38c4ad28962c33714f5d639f48d22d8a551d6f", "filename": "src/test/compile-fail/mutable-huh-variance-box.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-box.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,10 +1,10 @@\n // error-pattern: mismatched types\n \n fn main() {\n-    let v = @mutable [0];\n+    let v = @mut [0];\n \n-    fn f(&&v: @mutable [const int]) {\n-        *v = [mutable 3]\n+    fn f(&&v: @mut [const int]) {\n+        *v = [mut 3]\n     }\n \n     f(v);"}, {"sha": "7de97e59173ddf9b7fdb0e74dc0a1eb03110379b", "filename": "src/test/compile-fail/mutable-huh-variance-deep.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-deep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-deep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-deep.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,9 +1,9 @@\n // error-pattern: mismatched types\n \n fn main() {\n-    let v = [mutable @mutable ~mutable [0]];\n+    let v = [mut @mut ~mut [0]];\n \n-    fn f(&&v: [mutable @mutable ~mutable [const int]]) {\n+    fn f(&&v: [mut @mut ~mut [const int]]) {\n     }\n \n     f(v);"}, {"sha": "852b474eebb5dfe64373499ba88372ba1be6dd87", "filename": "src/test/compile-fail/mutable-huh-variance-ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-ptr.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -4,11 +4,11 @@ use std;\n \n fn main() {\n     let a = [0];\n-    let v: *mutable [int] = ptr::mut_addr_of(a);\n+    let v: *mut [int] = ptr::mut_addr_of(a);\n \n-    fn f(&&v: *mutable [const int]) {\n+    fn f(&&v: *mut [const int]) {\n         unsafe {\n-            *v = [mutable 3]\n+            *v = [mut 3]\n         }\n     }\n "}, {"sha": "78143f7fbc6721724e419de7aaef7c43b15270f1", "filename": "src/test/compile-fail/mutable-huh-variance-rec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-rec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-rec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-rec.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,10 +1,10 @@\n // error-pattern: mismatched types\n \n fn main() {\n-    let v = {mutable g: [0]};\n+    let v = {mut g: [0]};\n \n-    fn f(&&v: {mutable g: [const int]}) {\n-        v.g = [mutable 3]\n+    fn f(&&v: {mut g: [const int]}) {\n+        v.g = [mut 3]\n     }\n \n     f(v);"}, {"sha": "cd8d2ca6f106ea26df4f1c6bb0701ffb987346d3", "filename": "src/test/compile-fail/mutable-huh-variance-unique.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-unique.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,10 +1,10 @@\n // error-pattern: mismatched types\n \n fn main() {\n-    let v = ~mutable [0];\n+    let v = ~mut [0];\n \n-    fn f(&&v: ~mutable [const int]) {\n-        *v = [mutable 3]\n+    fn f(&&v: ~mut [const int]) {\n+        *v = [mut 3]\n     }\n \n     f(v);"}, {"sha": "3519127ab1bc07e9ac4573f794cff6a2756d3bb7", "filename": "src/test/compile-fail/mutable-huh-variance-vec1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec1.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -2,10 +2,10 @@ fn main() {\n     // Note: explicit type annot is required here\n     // because otherwise the inference gets smart\n     // and assigns a type of [mut [const int]].\n-    let v: [mut [int]] = [mutable [0]];\n+    let v: [mut [int]] = [mut [0]];\n \n-    fn f(&&v: [mutable [const int]]) {\n-        v[0] = [mutable 3]\n+    fn f(&&v: [mut [const int]]) {\n+        v[0] = [mut 3]\n     }\n \n     f(v); //! ERROR (values differ in mutability)"}, {"sha": "09c3565e8b20c8bb145164976d334fb2776a9c66", "filename": "src/test/compile-fail/mutable-huh-variance-vec2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec2.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -2,9 +2,9 @@ fn main() {\n     // Note: explicit type annot is required here\n     // because otherwise the inference gets smart\n     // and assigns a type of [mut [const int]].\n-    let v: [mut [mut int]] = [mutable [mutable 0]];\n+    let v: [mut [mut int]] = [mut [mut 0]];\n \n-    fn f(&&v: [mutable [const int]]) {\n+    fn f(&&v: [mut [const int]]) {\n         v[0] = [3]\n     }\n "}, {"sha": "97b6ccabdfd219d2e827fb2e22d1488574617ce5", "filename": "src/test/compile-fail/mutable-huh-variance-vec3.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec3.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -2,10 +2,10 @@ fn main() {\n     // Note: explicit type annot is required here\n     // because otherwise the inference gets smart\n     // and assigns a type of [mut [const int]].\n-    let v: [mut[mut[int]]] = [mutable [mutable [0]]];\n+    let v: [mut[mut[int]]] = [mut [mut [0]]];\n \n-    fn f(&&v: [mutable [mutable [const int]]]) {\n-        v[0][1] = [mutable 3]\n+    fn f(&&v: [mut [mut [const int]]]) {\n+        v[0][1] = [mut 3]\n     }\n \n     f(v); //! ERROR (values differ in mutability)"}, {"sha": "1a07b3f1de0e09a058ade143289db424ab92efc3", "filename": "src/test/compile-fail/pinned-deep-copy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Fpinned-deep-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Fpinned-deep-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpinned-deep-copy.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,11 +1,11 @@\n // error-pattern: copying a noncopyable value\n \n-resource r(i: @mutable int) {\n+resource r(i: @mut int) {\n     *i = *i + 1;\n }\n \n fn main() {\n-    let i = @mutable 0;\n+    let i = @mut 0;\n     {\n         // Can't do this copy\n         let x = ~~~{y: r(i)};"}, {"sha": "c0fb997d14c0bb89afbfbe7990ca74d75ba8d45d", "filename": "src/test/compile-fail/private-class-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Fprivate-class-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Fprivate-class-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-class-field.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,7 +1,7 @@\n // error-pattern:no public field or method with that name\n class cat {\n   priv {\n-    let mutable meows : uint;\n+    let mut meows : uint;\n   }\n \n   let how_hungry : int;"}, {"sha": "7e45660deb7164bf89f343a4a212d4d1adf97745", "filename": "src/test/compile-fail/private-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Fprivate-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Fprivate-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-method.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,7 +1,7 @@\n // error-pattern:attempted access of field nap on type\n class cat {\n   priv {\n-    let mutable meows : uint;\n+    let mut meows : uint;\n     fn nap() { uint::range(1u, 10000u) {|_i|}}\n   }\n "}, {"sha": "04c88a3d1030ec5543e1353fca04010631bac1c6", "filename": "src/test/compile-fail/unique-mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Funique-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Funique-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-mut.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,4 +1,4 @@\n //error-pattern:mismatched types\n fn main() {\n-    let i: ~int = ~mutable 0;\n+    let i: ~int = ~mut 0;\n }\n\\ No newline at end of file"}, {"sha": "045a22fa8e0340e4e8dafa88d300d8143ee8ca49", "filename": "src/test/compile-fail/unique-vec-res.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,6 +1,6 @@\n // error-pattern: copying a noncopyable value\n \n-resource r(i: @mutable int) {\n+resource r(i: @mut int) {\n     *i = *i + 1;\n }\n \n@@ -9,8 +9,8 @@ fn f<T>(+i: [T], +j: [T]) {\n }\n \n fn main() {\n-    let i1 = @mutable 0;\n-    let i2 = @mutable 1;\n+    let i1 = @mut 0;\n+    let i2 = @mut 1;\n     let r1 <- [~r(i1)];\n     let r2 <- [~r(i2)];\n     f(r1, r2);"}, {"sha": "ac20aeec931fbb3b1301baea4e8f6984c3768330", "filename": "src/test/compile-fail/unsafe-alias-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Funsafe-alias-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Funsafe-alias-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-alias-2.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,8 +1,8 @@\n // error-pattern:invalidate reference x\n \n-fn whoknows(x: @mutable {mutable x: int}) { x.x = 10; }\n+fn whoknows(x: @mut {mut x: int}) { x.x = 10; }\n \n fn main() {\n-    let box = @mutable {mutable x: 1};\n+    let box = @mut {mut x: 1};\n     alt *box { x { whoknows(box); log(error, x); } }\n }"}, {"sha": "0b13c5b5305a15621e9cacd11e41a129a154a62e", "filename": "src/test/compile-fail/unsafe-alias.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Funsafe-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Funsafe-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-alias.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,10 +1,10 @@\n // error-pattern:may alias with argument\n \n-fn foo(x: {mutable x: int}, f: fn@()) { log(debug, x); }\n+fn foo(x: {mut x: int}, f: fn@()) { log(debug, x); }\n \n-fn whoknows(x: @mutable {mutable x: int}) { *x = {mutable x: 10}; }\n+fn whoknows(x: @mut {mut x: int}) { *x = {mut x: 10}; }\n \n fn main() {\n-    let box = @mutable {mutable x: 1};\n+    let box = @mut {mut x: 1};\n     foo(*box, bind whoknows(box));\n }"}, {"sha": "92aa4ac00a4cf20ac901e057a03933664ca15ac2", "filename": "src/test/compile-fail/unsafe-alt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Funsafe-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Funsafe-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-alt.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,8 +1,8 @@\n // error-pattern:invalidate reference i\n \n-enum foo { left({mutable x: int}), right(bool) }\n+enum foo { left({mut x: int}), right(bool) }\n \n fn main() {\n-    let x = left({mutable x: 10});\n+    let x = left({mut x: 10});\n     alt x { left(i) { x = right(false); log(debug, i); } _ { } }\n }"}, {"sha": "a4e54d33fe724475779e3829d27fa06dddfd99e4", "filename": "src/test/compile-fail/unsafe-for.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Funsafe-for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Funsafe-for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-for.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,6 +1,6 @@\n // error-pattern:invalidate reference x\n \n fn main() {\n-    let v: [mutable {mutable x: int}] = [mutable {mutable x: 1}];\n-    for x in v { v[0] = {mutable x: 2}; log(debug, x); }\n+    let v: [mut {mut x: int}] = [mut {mut x: 1}];\n+    for x in v { v[0] = {mut x: 2}; log(debug, x); }\n }"}, {"sha": "1767eb3983cdfb34dcdf216f68a03ff7fe0fac74", "filename": "src/test/compile-fail/unsafe-mutable-alias.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Funsafe-mutable-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fcompile-fail%2Funsafe-mutable-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-mutable-alias.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,8 +1,8 @@\n-// error-pattern:mutable reference to a variable that roots another reference\n+// error-pattern:mut reference to a variable that roots another reference\n \n-fn f(a: {mutable x: int}, &b: {mutable x: int}) -> int {\n+fn f(a: {mut x: int}, &b: {mut x: int}) -> int {\n     b.x += 1;\n     ret a.x + b.x;\n }\n \n-fn main() { let i = {mutable x: 4}; log(debug, f(i, i)); }\n+fn main() { let i = {mut x: 4}; log(debug, f(i, i)); }"}, {"sha": "4157515b41c0ce7f2c2a591b691e5366a295542f", "filename": "src/test/pretty/block-disambig.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fpretty%2Fblock-disambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Fpretty%2Fblock-disambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fblock-disambig.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -7,7 +7,7 @@ fn test1() { let val = @0; { } *val; }\n fn test2() -> int { let val = @0; { } *val }\n \n fn test3() {\n-    let regs = @{mutable eax: 0};\n+    let regs = @{mut eax: 0};\n     alt check true { true { } }\n     (*regs).eax = 1;\n }\n@@ -36,10 +36,10 @@ fn test8() -> int {\n     }\n }\n \n-fn test9() { let regs = @mutable 0; alt check true { true { } } *regs += 1; }\n+fn test9() { let regs = @mut 0; alt check true { true { } } *regs += 1; }\n \n fn test10() -> int {\n-    let regs = @mutable [0];\n+    let regs = @mut [0];\n     alt check true { true { } }\n     (*regs)[0]\n }"}, {"sha": "34d08570be43b51f2fa6ae4e533fcd657da57977", "filename": "src/test/run-fail/unwind-misc-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -6,7 +6,7 @@ import std::map::hashmap;\n import uint;\n \n fn main() {\n-    let count = @mutable 0u;\n+    let count = @mut 0u;\n     fn hash(&&s: [@str]) -> uint {\n         if (vec::len(s) > 0u && str::eq(*s[0], \"boom\")) { fail; }\n         ret 10u;"}, {"sha": "641aceb9b16b53cf18bcdf4ee14ac8196faf412b", "filename": "src/test/run-pass/alignment-gep-tup-like-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -5,11 +5,11 @@ type pair<A,B> = {\n enum rec<A> = _rec<A>;\n type _rec<A> = {\n     val: A,\n-    mutable rec: option<@rec<A>>\n+    mut rec: option<@rec<A>>\n };\n \n fn make_cycle<A:copy>(a: A) {\n-    let g: @rec<A> = @rec({val: a, mutable rec: none});\n+    let g: @rec<A> = @rec({val: a, mut rec: none});\n     g.rec = some(g);\n }\n "}, {"sha": "1bad14183828aef60d60f25d3770ab890d276cbd", "filename": "src/test/run-pass/alloca-from-derived-tydesc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Falloca-from-derived-tydesc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Falloca-from-derived-tydesc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falloca-from-derived-tydesc.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,7 +1,7 @@\n enum option<T> { some(T), none, }\n \n-type r<T> = {mutable v: [option<T>]};\n+type r<T> = {mut v: [option<T>]};\n \n fn f<T>() -> [T] { ret []; }\n \n-fn main() { let r: r<int> = {mutable v: []}; r.v = f(); }\n+fn main() { let r: r<int> = {mut v: []}; r.v = f(); }"}, {"sha": "bffa76efa302a121f49e5c26064f11c9c96a0c68", "filename": "src/test/run-pass/alt-implicit-copy-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Falt-implicit-copy-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Falt-implicit-copy-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-implicit-copy-unique.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n-    let x = ~{mutable a: ~10, b: ~20};\n+    let x = ~{mut a: ~10, b: ~20};\n     alt x {\n       ~{a, b} { assert *a == 10; (*x).a = ~30; assert *a == 10; }\n     }"}, {"sha": "43de34e87a83e98622e06fbf9cc46b03ad70466b", "filename": "src/test/run-pass/alt-implicit-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Falt-implicit-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Falt-implicit-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-implicit-copy.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n-    let x = @{mutable a: @10, b: @20};\n+    let x = @{mut a: @10, b: @20};\n     alt x {\n       @{a, b} { assert *a == 10; (*x).a = @30; assert *a == 10; }\n     }"}, {"sha": "2f17efd32793520c63ecf968ba2fd38f6f113b7f", "filename": "src/test/run-pass/argument-passing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fargument-passing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fargument-passing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fargument-passing.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,4 +1,4 @@\n-fn f1(a: {mutable x: int}, &b: int, -c: int) -> int {\n+fn f1(a: {mut x: int}, &b: int, -c: int) -> int {\n     let r = a.x + b + c;\n     a.x = 0;\n     b = 10;\n@@ -9,7 +9,7 @@ fn f1(a: {mutable x: int}, &b: int, -c: int) -> int {\n fn f2(a: int, f: fn(int)) -> int { f(1); ret a; }\n \n fn main() {\n-    let mut a = {mutable x: 1}, b = 2, c = 3;\n+    let mut a = {mut x: 1}, b = 2, c = 3;\n     assert (f1(a, b, c) == 6);\n     assert (a.x == 0);\n     assert (b == 10);"}, {"sha": "f1769b0fb5039c15c3e8bd62fec952f23b46a01d", "filename": "src/test/run-pass/class-methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fclass-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fclass-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-methods.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,6 +1,6 @@\n class cat {\n   priv {\n-    let mutable meows : uint;\n+    let mut meows : uint;\n   }\n \n   let how_hungry : int;"}, {"sha": "dff5a035d987d6934c0cee600166b731dc5d5207", "filename": "src/test/run-pass/classes-simple-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fclasses-simple-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fclasses-simple-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclasses-simple-method.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,6 +1,6 @@\n class cat {\n   priv {\n-    let mutable meows : uint;\n+    let mut meows : uint;\n   }\n \n   let how_hungry : int;"}, {"sha": "bb0384f902e9cbd20f02717e34fb8c521e399f54", "filename": "src/test/run-pass/classes-simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fclasses-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fclasses-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclasses-simple.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,6 +1,6 @@\n class cat {\n   priv {\n-    let mutable meows : uint;\n+    let mut meows : uint;\n   }\n \n   let how_hungry : int;"}, {"sha": "0117519089a63c1b4bc731d7445d1fdc33447534", "filename": "src/test/run-pass/classes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fclasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fclasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclasses.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,6 +1,6 @@\n class cat {\n   priv {\n-    let mutable meows : uint;\n+    let mut meows : uint;\n     fn meow() {\n       #error(\"Meow\");\n       meows += 1u;"}, {"sha": "2f6716253926bbf659ba4665c7a1edf412428d1a", "filename": "src/test/run-pass/cycle-collection.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fcycle-collection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fcycle-collection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcycle-collection.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,10 +1,10 @@\n enum taggy {\n-    cons(@mutable taggy),\n+    cons(@mut taggy),\n     nil,\n }\n \n fn f() {\n-    let box = @mutable nil;\n+    let box = @mut nil;\n     *box = cons(box);\n }\n "}, {"sha": "406e73f545c9df5ab2db95ac6052347a1cd35906", "filename": "src/test/run-pass/cycle-collection2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fcycle-collection2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fcycle-collection2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcycle-collection2.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,10 +1,10 @@\n-type foo = { mutable z : fn@() };\n+type foo = { mut z : fn@() };\n \n fn nop() { }\n fn nop_foo(_x : @foo) { }\n \n fn main() {\n-    let w = @{ mutable z: bind nop() };\n+    let w = @{ mut z: bind nop() };\n     let x = bind nop_foo(w);\n     w.z = x;\n }\n\\ No newline at end of file"}, {"sha": "833fb3aafc53f424e41c67bee5a87d76cd19bb68", "filename": "src/test/run-pass/cycle-collection4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fcycle-collection4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fcycle-collection4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcycle-collection4.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,10 +1,10 @@\n-type foo = { mutable z : fn@() };\n+type foo = { mut z : fn@() };\n \n fn nop() { }\n fn nop_foo(_y: [int], _x : @foo) { }\n \n fn main() {\n-    let w = @{ mutable z: bind nop() };\n+    let w = @{ mut z: bind nop() };\n     let x = bind nop_foo([], w);\n     w.z = x;\n }\n\\ No newline at end of file"}, {"sha": "e64bdd16bf43293137d61716449e7dd0bb57d531", "filename": "src/test/run-pass/cycle-collection5.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fcycle-collection5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fcycle-collection5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcycle-collection5.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,12 +1,12 @@\n-type foo = { mutable z : fn@() };\n+type foo = { mut z : fn@() };\n \n fn nop() { }\n fn nop_foo(_y: @int, _x : @foo) { }\n \n fn o() -> @int { @10 }\n \n fn main() {\n-    let w = @{ mutable z: bind nop() };\n+    let w = @{ mut z: bind nop() };\n     let x = bind nop_foo(o(), w);\n     w.z = x;\n }\n\\ No newline at end of file"}, {"sha": "07c2e91d539ea60de7500323cedfe152c88ee059", "filename": "src/test/run-pass/deref-lval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fderef-lval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fderef-lval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderef-lval.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,3 +1,3 @@\n \n \n-fn main() { let x = @mutable 5; *x = 1000; log(debug, *x); }\n+fn main() { let x = @mut 5; *x = 1000; log(debug, *x); }"}, {"sha": "eaec2ab31d546e4228a9837082089e7d941dbf76", "filename": "src/test/run-pass/empty-mutable-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fempty-mutable-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fempty-mutable-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fempty-mutable-vec.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,3 +1,3 @@\n \n \n-fn main() { let v: [mutable int] = [mutable]; }\n+fn main() { let v: [mut int] = [mut]; }"}, {"sha": "279e916b75ad2d3f93f1854e6a329a99ae10d828", "filename": "src/test/run-pass/expr-copy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fexpr-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fexpr-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-copy.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,9 +1,9 @@\n-fn f(arg: {mutable a: int}) {\n+fn f(arg: {mut a: int}) {\n     arg.a = 100;\n }\n \n fn main() {\n-    let x = {mutable a: 10};\n+    let x = {mut a: 10};\n     f(x);\n     assert x.a == 100;\n     x.a = 20;"}, {"sha": "6890bb12789d6ccf8cfeef802ff8a5665fb81c91", "filename": "src/test/run-pass/exterior.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fexterior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fexterior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexterior.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -2,12 +2,12 @@\n \n \n // -*- rust -*-\n-type point = {x: int, y: int, mutable z: int};\n+type point = {x: int, y: int, mut z: int};\n \n fn f(p: @point) { assert (p.z == 12); p.z = 13; assert (p.z == 13); }\n \n fn main() {\n-    let a: point = {x: 10, y: 11, mutable z: 12};\n+    let a: point = {x: 10, y: 11, mut z: 12};\n     let b: @point = @a;\n     assert (b.z == 12);\n     f(b);"}, {"sha": "572556370a7a26bd52ef4f6484f0cbc6d467ad45", "filename": "src/test/run-pass/for-implicit-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Ffor-implicit-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Ffor-implicit-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffor-implicit-copy.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n-    let x = [@{mutable a: @10, b: @20}];\n+    let x = [@{mut a: @10, b: @20}];\n     for @{a, b} in x {\n         assert *a == 10;\n         (*x[0]).a = @30;"}, {"sha": "3cc0a5a82f1a3f9feb8ab703f00486aee5484e1e", "filename": "src/test/run-pass/foreach-nested.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fforeach-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fforeach-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-nested.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -5,7 +5,7 @@\n fn two(it: fn(int)) { it(0); it(1); }\n \n fn main() {\n-    let a: [mutable int] = [mutable -1, -1, -1, -1];\n+    let a: [mut int] = [mut -1, -1, -1, -1];\n     let mut p: int = 0;\n     two {|i|\n         two {|j| a[p] = 10 * i + j; p += 1; };"}, {"sha": "b771eca4be80e3d23f9e847d237f72a18abb256d", "filename": "src/test/run-pass/iface-cast.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fiface-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fiface-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiface-cast.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -2,8 +2,8 @@\n \n enum Tree = TreeR;\n type TreeR = @{\n-    mutable left: option<Tree>,\n-    mutable right: option<Tree>,\n+    mut left: option<Tree>,\n+    mut right: option<Tree>,\n     val: to_str\n };\n \n@@ -36,11 +36,11 @@ impl of to_str for Tree {\n fn foo<T: to_str>(x: T) -> str { x.to_str() }\n \n fn main() {\n-    let t1 = Tree(@{mutable left: none,\n-                    mutable right: none,\n+    let t1 = Tree(@{mut left: none,\n+                    mut right: none,\n                     val: 1 as to_str });\n-    let t2 = Tree(@{mutable left: some(t1),\n-                    mutable right: some(t1),\n+    let t2 = Tree(@{mut left: some(t1),\n+                    mut right: some(t1),\n                     val: 2 as to_str });\n     let expected = \"[2, some([1, none, none]), some([1, none, none])]\";\n     assert t2.to_str() == expected;"}, {"sha": "c7609973a04aa7ab4be6bdd9b22a49e5ccee7e08", "filename": "src/test/run-pass/init-res-into-things.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Finit-res-into-things.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Finit-res-into-things.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finit-res-into-things.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,20 +1,20 @@\n // Resources can't be copied, but storing into data structures counts\n // as a move unless the stored thing is used afterwards.\n \n-resource r(i: @mutable int) {\n+resource r(i: @mut int) {\n     *i = *i + 1;\n }\n \n fn test_box() {\n-    let i = @mutable 0;\n+    let i = @mut 0;\n     {\n         let a <- @r(i);\n     }\n     assert *i == 1;\n }\n \n fn test_rec() {\n-    let i = @mutable 0;\n+    let i = @mut 0;\n     {\n         let a <- {x: r(i)};\n     }\n@@ -26,31 +26,31 @@ fn test_tag() {\n         t0(r),\n     }\n \n-    let i = @mutable 0;\n+    let i = @mut 0;\n     {\n         let a <- t0(r(i));\n     }\n     assert *i == 1;\n }\n \n fn test_tup() {\n-    let i = @mutable 0;\n+    let i = @mut 0;\n     {\n         let a <- (r(i), 0);\n     }\n     assert *i == 1;\n }\n \n fn test_unique() {\n-    let i = @mutable 0;\n+    let i = @mut 0;\n     {\n         let a <- ~r(i);\n     }\n     assert *i == 1;\n }\n \n fn test_box_rec() {\n-    let i = @mutable 0;\n+    let i = @mut 0;\n     {\n         let a <- @{\n             x: r(i)"}, {"sha": "3de02c5679d4ad8ed6819de83e23a6172a72b03d", "filename": "src/test/run-pass/issue-979.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fissue-979.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fissue-979.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-979.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,9 +1,9 @@\n-resource r(b: @mutable int) {\n+resource r(b: @mut int) {\n     *b += 1;\n }\n \n fn main() {\n-    let b = @mutable 0;\n+    let b = @mut 0;\n     {\n         let p = some(r(b));\n     }"}, {"sha": "41702fbee97ed386c4ee03e484403fdfa693b4ca", "filename": "src/test/run-pass/issue-980.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fissue-980.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fissue-980.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-980.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -4,10 +4,10 @@ enum maybe_pointy {\n }\n \n type pointy = {\n-    mutable x : maybe_pointy\n+    mut x : maybe_pointy\n };\n \n fn main() {\n-    let m = @{ mutable x : no_pointy };\n+    let m = @{ mut x : no_pointy };\n     m.x = yes_pointy(m);\n }"}, {"sha": "36b93774c86f78387c5ba7ee78ecb3a819baacfa", "filename": "src/test/run-pass/lambda-infer-unresolved.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Flambda-infer-unresolved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Flambda-infer-unresolved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flambda-infer-unresolved.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,7 +1,7 @@\n // This should typecheck even though the type of e is not fully\n // resolved when we finish typechecking the fn@.\n fn main() {\n-    let e = @{mutable refs: [], n: 0};\n+    let e = @{mut refs: [], n: 0};\n     let f = fn@ () { log(error, e.n); };\n     e.refs += [1];\n }"}, {"sha": "3e202e84b8120d1ca629f2220ec8cb83c5b1cf3b", "filename": "src/test/run-pass/log-linearized.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Flog-linearized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Flog-linearized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flog-linearized.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -5,11 +5,11 @@ enum option<T> {\n     some(T),\n }\n \n-type smallintmap<T> = @{mutable v: [mutable option<T>]};\n+type smallintmap<T> = @{mut v: [mut option<T>]};\n \n fn mk<T>() -> smallintmap<T> {\n-    let v: [mutable option<T>] = [mutable];\n-    ret @{mutable v: v};\n+    let v: [mut option<T>] = [mut];\n+    ret @{mut v: v};\n }\n \n fn f<T,U>() {"}, {"sha": "c66de1b33676c8b1da3e778b49bb6abce6b3b4ed", "filename": "src/test/run-pass/maybe-mutable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fmaybe-mutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fmaybe-mutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmaybe-mutable.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -11,6 +11,6 @@ fn len(v: [const int]) -> uint {\n fn main() {\n     let v0 = [1, 2, 3, 4, 5];\n     log(debug, len(v0));\n-    let v1 = [mutable 1, 2, 3, 4, 5];\n+    let v1 = [mut 1, 2, 3, 4, 5];\n     log(debug, len(v1));\n }"}, {"sha": "3c7a5007f37c770de99da19645220a4838ec7ac2", "filename": "src/test/run-pass/mlist-cycle.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fmlist-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fmlist-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmlist-cycle.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -2,14 +2,14 @@\n // -*- rust -*-\n use std;\n \n-type cell = {mutable c: @list};\n+type cell = {mut c: @list};\n \n enum list { link(@cell), nil, }\n \n fn main() {\n-    let first: @cell = @{mutable c: @nil()};\n-    let second: @cell = @{mutable c: @link(first)};\n+    let first: @cell = @{mut c: @nil()};\n+    let second: @cell = @{mut c: @link(first)};\n     first._0 = @link(second);\n     sys.rustrt.gc();\n-    let third: @cell = @{mutable c: @nil()};\n+    let third: @cell = @{mut c: @nil()};\n }\n\\ No newline at end of file"}, {"sha": "31cfab18ddcb2fe354f11f783c9e965d0e606e09", "filename": "src/test/run-pass/mutable-huh-variance-vec1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fmutable-huh-variance-vec1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fmutable-huh-variance-vec1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmutable-huh-variance-vec1.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -4,7 +4,7 @@ fn main() {\n     let v = [[0]];\n \n     // This is ok because the outer vec is covariant with respect\n-    // to the inner vec. If the outer vec was mutable then we\n+    // to the inner vec. If the outer vec was mut then we\n     // couldn't do this.\n     fn f(&&v: [[const int]]) {\n     }"}, {"sha": "7815554cdabe24489eec40a87bacd6c1ad2dec05", "filename": "src/test/run-pass/mutable-huh-variance-vec2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fmutable-huh-variance-vec2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fmutable-huh-variance-vec2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmutable-huh-variance-vec2.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -4,7 +4,7 @@ fn main() {\n     let v = [[0]];\n \n     // This is ok because the outer vec is covariant with respect\n-    // to the inner vec. If the outer vec was mutable then we\n+    // to the inner vec. If the outer vec was mut then we\n     // couldn't do this.\n     fn f(&&v: [const [const int]]) {\n     }"}, {"sha": "2b1433d8a65aa7d83ce6556d9913a6fd8f58bd34", "filename": "src/test/run-pass/mutable-vec-drop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fmutable-vec-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fmutable-vec-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmutable-vec-drop.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,6 +1,6 @@\n \n fn main() {\n     // This just tests whether the vec leaks its members.\n-    let pvec: [mutable @{a: int, b: int}] =\n-        [mutable @{a: 1, b: 2}, @{a: 3, b: 4}, @{a: 5, b: 6}];\n+    let pvec: [mut @{a: int, b: int}] =\n+        [mut @{a: 1, b: 2}, @{a: 3, b: 4}, @{a: 5, b: 6}];\n }"}, {"sha": "d58cb896a602c77b165df958d7691654e757c71c", "filename": "src/test/run-pass/nested-patterns.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fnested-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fnested-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnested-patterns.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -3,10 +3,10 @@ fn main() {\n         x@{a, b: @20} { assert x.a == 10; assert a == 10; }\n         {b, _} { fail; }\n     }\n-    let x@{b, _} = {a: 10, b: {mutable c: 20}};\n+    let x@{b, _} = {a: 10, b: {mut c: 20}};\n     x.b.c = 30;\n     assert b.c == 20;\n-    let y@{d, _} = {a: 10, d: {mutable c: 20}};\n+    let y@{d, _} = {a: 10, d: {mut c: 20}};\n     y.d.c = 30;\n     assert d.c == 20;\n }"}, {"sha": "f2f7c795252b2cd2f216b9738caedc0050101d52", "filename": "src/test/run-pass/private-class-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fprivate-class-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fprivate-class-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprivate-class-field.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,6 +1,6 @@\n class cat {\n   priv {\n-    let mutable meows : uint;\n+    let mut meows : uint;\n   }\n \n   let how_hungry : int;"}, {"sha": "2cc75e1ec3c82aaebeecfb1644081692832e4add", "filename": "src/test/run-pass/private-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fprivate-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fprivate-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprivate-method.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,6 +1,6 @@\n class cat {\n   priv {\n-    let mutable meows : uint;\n+    let mut meows : uint;\n     fn nap() { uint::range(1u, 10u) {|_i|}}\n   }\n "}, {"sha": "de70e2c67d120eab07b5df6b960bb8ab8f9c013c", "filename": "src/test/run-pass/qquote.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fqquote.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -17,10 +17,10 @@ fn new_parse_sess() -> parser::parse_sess {\n     let handler = diagnostic::mk_handler(option::none);\n     let sess = @{\n         cm: cm,\n-        mutable next_id: 1,\n+        mut next_id: 1,\n         span_diagnostic: diagnostic::mk_span_handler(handler, cm),\n-        mutable chpos: 0u,\n-        mutable byte_pos: 0u\n+        mut chpos: 0u,\n+        mut byte_pos: 0u\n     };\n     ret sess;\n }"}, {"sha": "36500898f79ac85bbb05ba3f1d7af8ebfb560f8a", "filename": "src/test/run-pass/regions-simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fregions-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fregions-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-simple.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,6 +1,6 @@\n fn main() {\n     let x: int = 3;\n-    let y: &mutable int = &mutable x;\n+    let y: &mut int = &mut x;\n     *y = 5;\n     log (debug, *y);\n }"}, {"sha": "5f8d3a2319d3c7aeb796388a31523b540d919d42", "filename": "src/test/run-pass/resource-assign-is-not-copy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fresource-assign-is-not-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fresource-assign-is-not-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-assign-is-not-copy.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,7 +1,7 @@\n-resource r(i: @mutable int) { *i += 1; }\n+resource r(i: @mut int) { *i += 1; }\n \n fn main() {\n-    let i = @mutable 0;\n+    let i = @mut 0;\n     // Even though these look like copies, they are guaranteed not to be\n     {\n         let a = r(i);"}, {"sha": "a575d17d2f6017069f2b934214abf4ae568a4832", "filename": "src/test/run-pass/resource-destruct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fresource-destruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fresource-destruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-destruct.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,9 +1,9 @@\n-resource shrinky_pointer(i: @mutable int) { *i -= 1; }\n+resource shrinky_pointer(i: @mut int) { *i -= 1; }\n \n fn look_at(pt: shrinky_pointer) -> int { ret **pt; }\n \n fn main() {\n-    let my_total = @mutable 10;\n+    let my_total = @mut 10;\n     { let pt <- shrinky_pointer(my_total); assert (look_at(pt) == 10); }\n     assert (*my_total == 9);\n }"}, {"sha": "08e546749dc26f01ad905d51ee7c9b8e4473804a", "filename": "src/test/run-pass/resource-generic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fresource-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fresource-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-generic.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -3,8 +3,8 @@ resource finish<T>(arg: {val: T, fin: native fn(T)}) {\n }\n \n fn main() {\n-    let box = @mutable 10;\n-    fn dec_box(&&i: @mutable int) { *i -= 1; }\n+    let box = @mut 10;\n+    fn dec_box(&&i: @mut int) { *i -= 1; }\n \n     { let i <- finish({val: box, fin: dec_box}); }\n     assert (*box == 9);"}, {"sha": "f5a0afe94796879304642cb4ff50d00eab552c11", "filename": "src/test/run-pass/resource-in-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fresource-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fresource-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-in-struct.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,7 +1,7 @@\n // Ensures that putting resources inside structual types keeps\n // working.\n \n-type closable = @mutable bool;\n+type closable = @mut bool;\n \n resource close_res(i: closable) { *i = false; }\n \n@@ -10,7 +10,7 @@ enum option<T> { none, some(T), }\n fn sink(res: option<close_res>) { }\n \n fn main() {\n-    let c = @mutable true;\n+    let c = @mut true;\n     sink(none);\n     sink(some(close_res(c)));\n     assert (!*c);"}, {"sha": "96e06e65c70a1f5789cf7d08fa4e79065867a5ec", "filename": "src/test/run-pass/sendfn-deep-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fsendfn-deep-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fsendfn-deep-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsendfn-deep-copy.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -8,7 +8,7 @@ fn main() { test05(); }\n fn mk_counter<A:copy>() -> fn~(A) -> (A,uint) {\n     // The only reason that the counter is generic is so that it closes\n     // over both a type descriptor and some data.\n-    let v = [mutable 0u];\n+    let v = [mut 0u];\n     ret fn~(a: A) -> (A,uint) {\n         let n = v[0];\n         v[0] = n + 1u;"}, {"sha": "f94205f4a9f6fb73c762735ec50a9bd7cb1f7d26", "filename": "src/test/run-pass/swap-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fswap-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fswap-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fswap-2.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,7 +1,7 @@\n-fn swap<T>(v: [mutable T], i: int, j: int) { v[i] <-> v[j]; }\n+fn swap<T>(v: [mut T], i: int, j: int) { v[i] <-> v[j]; }\n \n fn main() {\n-    let a: [mutable int] = [mutable 0, 1, 2, 3, 4, 5, 6];\n+    let a: [mut int] = [mut 0, 1, 2, 3, 4, 5, 6];\n     swap(a, 2, 4);\n     assert (a[2] == 4);\n     assert (a[4] == 2);"}, {"sha": "f84645c1dbf505bdc6bff23a1b9a1d92367dd8cd", "filename": "src/test/run-pass/task-killjoin-rsrc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -8,7 +8,7 @@ import task;\n \n fn joinable(f: fn()) -> (task::task, comm::port<bool>) {\n     resource notify(data: (comm::chan<bool>,\n-                           @mutable bool)) {\n+                           @mut bool)) {\n         let (c, v) = data;\n         #error[\"notify: task=%d v=%x unwinding=%b b=%b\",\n                task::get_task(),\n@@ -19,7 +19,7 @@ fn joinable(f: fn()) -> (task::task, comm::port<bool>) {\n     }\n     fn wrapper(pair: (comm::chan<bool>, fn())) {\n         let (c, f) = pair;\n-        let b = @mutable false;\n+        let b = @mut false;\n         #error[\"wrapper: task=%d allocated v=%x\",\n                task::get_task(),\n                ptr::addr_of(*b) as uint];"}, {"sha": "b2990d3d1017461b7a885281df47730d7dea0171", "filename": "src/test/run-pass/uniq-cc-generic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -4,7 +4,7 @@ enum maybe_pointy {\n }\n \n type pointy = {\n-    mutable a : maybe_pointy,\n+    mut a : maybe_pointy,\n     d : fn~() -> uint,\n };\n \n@@ -14,7 +14,7 @@ fn make_uniq_closure<A:send>(a: A) -> fn~() -> uint {\n \n fn empty_pointy() -> @pointy {\n     ret @{\n-        mutable a : none,\n+        mut a : none,\n         d : make_uniq_closure(\"hi\")\n     }\n }"}, {"sha": "f238e3e4e9f7a4c65e2ce9852904bac679747c9d", "filename": "src/test/run-pass/uniq-cc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Funiq-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Funiq-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiq-cc.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -4,14 +4,14 @@ enum maybe_pointy {\n }\n \n type pointy = {\n-    mutable a : maybe_pointy,\n+    mut a : maybe_pointy,\n     c : ~int,\n     d : fn~()->(),\n };\n \n fn empty_pointy() -> @pointy {\n     ret @{\n-        mutable a : none,\n+        mut a : none,\n         c : ~22,\n         d : fn~()->(){},\n     }"}, {"sha": "2c152c9805ca53a7a9b0a89a52efa25963015040", "filename": "src/test/run-pass/unique-assign-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Funique-assign-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Funique-assign-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-assign-copy.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n-    let i = ~mutable 1;\n+    let i = ~mut 1;\n     // Should be a copy\n     let mut j;\n     j = i;"}, {"sha": "ab8df403a77bf17199fad48700439575ccc32c85", "filename": "src/test/run-pass/unique-decl-init-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Funique-decl-init-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Funique-decl-init-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-decl-init-copy.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n-    let i = ~mutable 1;\n+    let i = ~mut 1;\n     // Should be a copy\n     let j = i;\n     *i = 2;"}, {"sha": "1a9eb581c2428a1b2f9fbdc23db5598a17920bbe", "filename": "src/test/run-pass/unique-in-vec-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Funique-in-vec-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Funique-in-vec-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-in-vec-copy.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n-    let a = [~mutable 10];\n+    let a = [~mut 10];\n     let b = a;\n \n     assert *a[0] == 10;"}, {"sha": "fd991c20503d4cf42671e3f93fc8124895c0b318", "filename": "src/test/run-pass/unique-mutable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Funique-mutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Funique-mutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-mutable.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n-    let i = ~mutable 0;\n+    let i = ~mut 0;\n     *i = 1;\n     assert *i == 1;\n }\n\\ No newline at end of file"}, {"sha": "ff94532f9c5946a25fb2f4c052cb9b31e18a0229", "filename": "src/test/run-pass/unique-pinned-nocopy-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Funique-pinned-nocopy-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Funique-pinned-nocopy-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-pinned-nocopy-2.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -1,9 +1,9 @@\n-resource r(i: @mutable int) {\n+resource r(i: @mut int) {\n     *i = *i + 1;\n }\n \n fn main() {\n-    let i = @mutable 0;\n+    let i = @mut 0;\n     {\n         let j = ~r(i);\n     }"}, {"sha": "0640bacbfe4246a8d46463526ce2af86a11d15eb", "filename": "src/test/run-pass/weird-exprs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fweird-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fweird-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fweird-exprs.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -8,8 +8,8 @@ fn funny() {\n }\n \n fn what() {\n-    fn the(x: @mutable bool) { ret while !*x { *x = true; }; }\n-    let i = @mutable false;\n+    fn the(x: @mut bool) { ret while !*x { *x = true; }; }\n+    let i = @mut false;\n     let dont = bind the(i);\n     dont();\n     assert (*i);"}, {"sha": "9dba2e2adfdcbe6a183415e9e7f72303e8a905ad", "filename": "src/test/run-pass/writealias.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fwritealias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6798c4e17d9ffa33c0573f329c772e9d96739e/src%2Ftest%2Frun-pass%2Fwritealias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwritealias.rs?ref=6e6798c4e17d9ffa33c0573f329c772e9d96739e", "patch": "@@ -2,12 +2,12 @@\n \n \n // -*- rust -*-\n-type point = {x: int, y: int, mutable z: int};\n+type point = {x: int, y: int, mut z: int};\n \n fn f(&p: point) { p.z = 13; }\n \n fn main() {\n-    let mut x: point = {x: 10, y: 11, mutable z: 12};\n+    let mut x: point = {x: 10, y: 11, mut z: 12};\n     f(x);\n     assert (x.z == 13);\n }"}]}