{"sha": "040735c110026bbd494a23c86182ebda201d720b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0MDczNWMxMTAwMjZiYmQ0OTRhMjNjODYxODJlYmRhMjAxZDcyMGI=", "commit": {"author": {"name": "Ryan Levick", "email": "ryan.levick@gmail.com", "date": "2021-01-05T09:07:50Z"}, "committer": {"name": "Ryan Levick", "email": "me@ryanlevick.com", "date": "2021-03-03T10:22:16Z"}, "message": "First version of noop-lint", "tree": {"sha": "d022539550c7bd531cf70ce7324e0e51a560e52d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d022539550c7bd531cf70ce7324e0e51a560e52d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/040735c110026bbd494a23c86182ebda201d720b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/040735c110026bbd494a23c86182ebda201d720b", "html_url": "https://github.com/rust-lang/rust/commit/040735c110026bbd494a23c86182ebda201d720b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/040735c110026bbd494a23c86182ebda201d720b/comments", "author": {"login": "rylev", "id": 1327285, "node_id": "MDQ6VXNlcjEzMjcyODU=", "avatar_url": "https://avatars.githubusercontent.com/u/1327285?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rylev", "html_url": "https://github.com/rylev", "followers_url": "https://api.github.com/users/rylev/followers", "following_url": "https://api.github.com/users/rylev/following{/other_user}", "gists_url": "https://api.github.com/users/rylev/gists{/gist_id}", "starred_url": "https://api.github.com/users/rylev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rylev/subscriptions", "organizations_url": "https://api.github.com/users/rylev/orgs", "repos_url": "https://api.github.com/users/rylev/repos", "events_url": "https://api.github.com/users/rylev/events{/privacy}", "received_events_url": "https://api.github.com/users/rylev/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rylev", "id": 1327285, "node_id": "MDQ6VXNlcjEzMjcyODU=", "avatar_url": "https://avatars.githubusercontent.com/u/1327285?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rylev", "html_url": "https://github.com/rylev", "followers_url": "https://api.github.com/users/rylev/followers", "following_url": "https://api.github.com/users/rylev/following{/other_user}", "gists_url": "https://api.github.com/users/rylev/gists{/gist_id}", "starred_url": "https://api.github.com/users/rylev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rylev/subscriptions", "organizations_url": "https://api.github.com/users/rylev/orgs", "repos_url": "https://api.github.com/users/rylev/repos", "events_url": "https://api.github.com/users/rylev/events{/privacy}", "received_events_url": "https://api.github.com/users/rylev/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbca5689a5a0c63c6c5fda22bb0678164b52fec3", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbca5689a5a0c63c6c5fda22bb0678164b52fec3", "html_url": "https://github.com/rust-lang/rust/commit/cbca5689a5a0c63c6c5fda22bb0678164b52fec3"}], "stats": {"total": 77, "additions": 77, "deletions": 0}, "files": [{"sha": "b0c22154c0b5b41d3127cb5a54b1d6cee6b9fe3b", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/040735c110026bbd494a23c86182ebda201d720b/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040735c110026bbd494a23c86182ebda201d720b/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=040735c110026bbd494a23c86182ebda201d720b", "patch": "@@ -57,6 +57,7 @@ mod methods;\n mod non_ascii_idents;\n mod non_fmt_panic;\n mod nonstandard_style;\n+mod noop_method_call;\n mod passes;\n mod redundant_semicolon;\n mod traits;\n@@ -83,6 +84,7 @@ use methods::*;\n use non_ascii_idents::*;\n use non_fmt_panic::NonPanicFmt;\n use nonstandard_style::*;\n+use noop_method_call::*;\n use redundant_semicolon::*;\n use traits::*;\n use types::*;\n@@ -170,6 +172,7 @@ macro_rules! late_lint_passes {\n                 DropTraitConstraints: DropTraitConstraints,\n                 TemporaryCStringAsPtr: TemporaryCStringAsPtr,\n                 NonPanicFmt: NonPanicFmt,\n+                NoopMethodCall: NoopMethodCall,\n             ]\n         );\n     };"}, {"sha": "098c50d5abe19a841af3df236e70d9810bd3d5cf", "filename": "compiler/rustc_lint/src/noop_method_call.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/040735c110026bbd494a23c86182ebda201d720b/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040735c110026bbd494a23c86182ebda201d720b/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs?ref=040735c110026bbd494a23c86182ebda201d720b", "patch": "@@ -0,0 +1,71 @@\n+use crate::context::LintContext;\n+use crate::rustc_middle::ty::TypeFoldable;\n+use crate::LateContext;\n+use crate::LateLintPass;\n+use rustc_hir::def::DefKind;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_middle::ty;\n+use rustc_span::symbol::sym;\n+\n+declare_lint! {\n+    /// The `noop_method_call` lint detects specific calls to noop methods\n+    /// such as a calling `<&T as Clone>::clone` where `T: !Clone`.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// # #![allow(unused)]\n+    /// struct Foo;\n+    /// let foo = &Foo;\n+    /// let clone: &Foo = foo.clone();\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Some method calls are noops meaning that they do nothing. Usually such methods\n+    /// are the result of blanket implementations that happen to create some method invocations\n+    /// that end up not doing anything. For instance, `Clone` is implemented on all `&T`, but\n+    /// calling `clone` on a `&T` where `T` does not implement clone, actually doesn't do anything\n+    /// as references are copy. This lint detects these calls and warns the user about them.\n+    pub NOOP_METHOD_CALL,\n+    Warn,\n+    \"detects the use of well-known noop methods\"\n+}\n+\n+declare_lint_pass!(NoopMethodCall => [NOOP_METHOD_CALL]);\n+\n+impl<'tcx> LateLintPass<'tcx> for NoopMethodCall {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        // We only care about method calls\n+        if let ExprKind::MethodCall(..) = expr.kind {\n+            // Get the `DefId` only when dealing with an `AssocFn`\n+            if let Some((DefKind::AssocFn, did)) =\n+                cx.typeck_results().type_dependent_def(expr.hir_id)\n+            {\n+                // Check that we're dealing with a trait method\n+                if let Some(trait_id) = cx.tcx.trait_of_item(did) {\n+                    let substs = cx.typeck_results().node_substs(expr.hir_id);\n+                    // We can't resolve on types that recursively require monomorphization,\n+                    // so check that we don't need to perfom substitution\n+                    if !substs.needs_subst() {\n+                        let param_env = cx.tcx.param_env(trait_id);\n+                        // Resolve the trait method instance\n+                        if let Ok(Some(i)) = ty::Instance::resolve(cx.tcx, param_env, did, substs) {\n+                            // Check that it implements the noop diagnostic\n+                            if cx.tcx.is_diagnostic_item(sym::ref_clone_method, i.def_id()) {\n+                                let span = expr.span;\n+\n+                                cx.struct_span_lint(NOOP_METHOD_CALL, span, |lint| {\n+                                    let message = \"Call to noop method\";\n+                                    lint.build(&message).emit()\n+                                });\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "2207deb8fb5a0f9ecfe928fa173a9130fa727440", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/040735c110026bbd494a23c86182ebda201d720b/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040735c110026bbd494a23c86182ebda201d720b/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=040735c110026bbd494a23c86182ebda201d720b", "patch": "@@ -915,6 +915,7 @@ symbols! {\n         receiver,\n         recursion_limit,\n         reexport_test_harness_main,\n+        ref_clone_method,\n         reference,\n         reflect,\n         reg,"}, {"sha": "12f0f9629a31fc9d343eba8a3c8acb041d8d7035", "filename": "library/core/src/clone.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/040735c110026bbd494a23c86182ebda201d720b/library%2Fcore%2Fsrc%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040735c110026bbd494a23c86182ebda201d720b/library%2Fcore%2Fsrc%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fclone.rs?ref=040735c110026bbd494a23c86182ebda201d720b", "patch": "@@ -104,6 +104,7 @@\n /// [impls]: #implementors\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"clone\"]\n+#[rustc_diagnostic_item = \"Clone\"]\n pub trait Clone: Sized {\n     /// Returns a copy of the value.\n     ///\n@@ -221,6 +222,7 @@ mod impls {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<T: ?Sized> Clone for &T {\n         #[inline]\n+        #[rustc_diagnostic_item = \"ref_clone_method\"]\n         fn clone(&self) -> Self {\n             *self\n         }"}]}