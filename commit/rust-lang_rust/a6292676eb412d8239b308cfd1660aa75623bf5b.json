{"sha": "a6292676eb412d8239b308cfd1660aa75623bf5b", "node_id": "C_kwDOAAsO6NoAKGE2MjkyNjc2ZWI0MTJkODIzOWIzMDhjZmQxNjYwYWE3NTYyM2JmNWI", "commit": {"author": {"name": "David Lattimore", "email": "dvdlttmr@gmail.com", "date": "2023-03-21T10:48:03Z"}, "committer": {"name": "David Lattimore", "email": "dvdlttmr@gmail.com", "date": "2023-04-11T01:07:48Z"}, "message": "Preserve argument indexes when inlining MIR\n\nWe store argument indexes on VarDebugInfo. Unlike the previous method of\nrelying on the variable index to know whether a variable is an argument,\nthis survives MIR inlining.\n\nWe also no longer check if var.source_info.scope is the outermost scope.\nWhen a function gets inlined, the arguments to the inner function will\nno longer be in the outermost scope. What we care about though is\nwhether they were in the outermost scope prior to inlining, which we\nknow by whether we assigned an argument index.", "tree": {"sha": "ed8daa1d079b24605de44a1cd3b2c4ea7b18236d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed8daa1d079b24605de44a1cd3b2c4ea7b18236d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6292676eb412d8239b308cfd1660aa75623bf5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6292676eb412d8239b308cfd1660aa75623bf5b", "html_url": "https://github.com/rust-lang/rust/commit/a6292676eb412d8239b308cfd1660aa75623bf5b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6292676eb412d8239b308cfd1660aa75623bf5b/comments", "author": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7cd6f55323c15c9e8eed6361777d04e33ba7c429", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cd6f55323c15c9e8eed6361777d04e33ba7c429", "html_url": "https://github.com/rust-lang/rust/commit/7cd6f55323c15c9e8eed6361777d04e33ba7c429"}], "stats": {"total": 74, "additions": 67, "deletions": 7}, "files": [{"sha": "d049bafb821bd4d24d412a69f255280caceab0fd", "filename": "compiler/rustc_codegen_ssa/src/mir/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a6292676eb412d8239b308cfd1660aa75623bf5b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6292676eb412d8239b308cfd1660aa75623bf5b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs?ref=a6292676eb412d8239b308cfd1660aa75623bf5b", "patch": "@@ -442,11 +442,10 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let (var_ty, var_kind) = match var.value {\n                     mir::VarDebugInfoContents::Place(place) => {\n                         let var_ty = self.monomorphized_place_ty(place.as_ref());\n-                        let var_kind = if self.mir.local_kind(place.local) == mir::LocalKind::Arg\n+                        let var_kind = if let Some(arg_index) = var.argument_index\n                             && place.projection.is_empty()\n-                            && var.source_info.scope == mir::OUTERMOST_SOURCE_SCOPE\n                         {\n-                            let arg_index = place.local.index() - 1;\n+                            let arg_index = arg_index as usize;\n                             if target_is_msvc {\n                                 // ScalarPair parameters are spilled to the stack so they need to\n                                 // be marked as a `LocalVariable` for MSVC debuggers to visualize\n@@ -455,13 +454,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                 if let Abi::ScalarPair(_, _) = var_ty_layout.abi {\n                                     VariableKind::LocalVariable\n                                 } else {\n-                                    VariableKind::ArgumentVariable(arg_index + 1)\n+                                    VariableKind::ArgumentVariable(arg_index)\n                                 }\n                             } else {\n                                 // FIXME(eddyb) shouldn't `ArgumentVariable` indices be\n                                 // offset in closures to account for the hidden environment?\n-                                // Also, is this `+ 1` needed at all?\n-                                VariableKind::ArgumentVariable(arg_index + 1)\n+                                VariableKind::ArgumentVariable(arg_index)\n                             }\n                         } else {\n                             VariableKind::LocalVariable"}, {"sha": "ad69082a70bacc14d733ed544aa4e882a0a8c66c", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a6292676eb412d8239b308cfd1660aa75623bf5b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6292676eb412d8239b308cfd1660aa75623bf5b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=a6292676eb412d8239b308cfd1660aa75623bf5b", "patch": "@@ -1115,6 +1115,11 @@ pub struct VarDebugInfo<'tcx> {\n \n     /// Where the data for this user variable is to be found.\n     pub value: VarDebugInfoContents<'tcx>,\n+\n+    /// When present, indicates what argument number this variable is in the function that it\n+    /// originated from (starting from 1). Note, if MIR inlining is enabled, then this is the\n+    /// argument number in the original function before it was inlined.\n+    pub argument_index: Option<u16>,\n }\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "0a9fcd898b93e691a9c880e73f44ca29ceb25393", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6292676eb412d8239b308cfd1660aa75623bf5b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6292676eb412d8239b308cfd1660aa75623bf5b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=a6292676eb412d8239b308cfd1660aa75623bf5b", "patch": "@@ -832,6 +832,7 @@ macro_rules! make_mir_visitor {\n                     name: _,\n                     source_info,\n                     value,\n+                    argument_index: _,\n                 } = var_debug_info;\n \n                 self.visit_source_info(source_info);"}, {"sha": "4926ff85de38d0beac9c65c17aa3c41195529366", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6292676eb412d8239b308cfd1660aa75623bf5b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6292676eb412d8239b308cfd1660aa75623bf5b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=a6292676eb412d8239b308cfd1660aa75623bf5b", "patch": "@@ -2242,6 +2242,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             name,\n             source_info: debug_source_info,\n             value: VarDebugInfoContents::Place(for_arm_body.into()),\n+            argument_index: None,\n         });\n         let locals = if has_guard.0 {\n             let ref_for_guard = self.local_decls.push(LocalDecl::<'tcx> {\n@@ -2260,6 +2261,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 name,\n                 source_info: debug_source_info,\n                 value: VarDebugInfoContents::Place(ref_for_guard.into()),\n+                argument_index: None,\n             });\n             LocalsForNode::ForGuard { ref_for_guard, for_arm_body }\n         } else {"}, {"sha": "bc50bcbc3d07dcb3ab67eafd6724b313840c7537", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6292676eb412d8239b308cfd1660aa75623bf5b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6292676eb412d8239b308cfd1660aa75623bf5b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=a6292676eb412d8239b308cfd1660aa75623bf5b", "patch": "@@ -811,6 +811,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     name,\n                     source_info: SourceInfo::outermost(captured_place.var_ident.span),\n                     value: VarDebugInfoContents::Place(use_place),\n+                    argument_index: None,\n                 });\n \n                 let capture = Capture { captured_place, use_place, mutability };\n@@ -827,7 +828,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         expr: &Expr<'tcx>,\n     ) -> BlockAnd<()> {\n         // Allocate locals for the function arguments\n-        for param in arguments.iter() {\n+        for (argument_index, param) in arguments.iter().enumerate() {\n             let source_info =\n                 SourceInfo::outermost(param.pat.as_ref().map_or(self.fn_span, |pat| pat.span));\n             let arg_local =\n@@ -839,6 +840,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     name,\n                     source_info,\n                     value: VarDebugInfoContents::Place(arg_local.into()),\n+                    argument_index: Some(argument_index as u16 + 1),\n                 });\n             }\n         }"}, {"sha": "4c4423721fb8c9f7eb04f742b36baebfe528b680", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a6292676eb412d8239b308cfd1660aa75623bf5b/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6292676eb412d8239b308cfd1660aa75623bf5b/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=a6292676eb412d8239b308cfd1660aa75623bf5b", "patch": "@@ -1556,6 +1556,13 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n         body.arg_count = 2; // self, resume arg\n         body.spread_arg = None;\n \n+        // The original arguments to the function are no longer arguments, mark them as such.\n+        // Otherwise they'll conflict with our new arguments, which although they don't have\n+        // argument_index set, will get emitted as unnamed arguments.\n+        for var in &mut body.var_debug_info {\n+            var.argument_index = None;\n+        }\n+\n         body.generator.as_mut().unwrap().yield_ty = None;\n         body.generator.as_mut().unwrap().generator_layout = Some(layout);\n "}, {"sha": "e3d8caa49d45c4c808c23cf0fafebbc480f4c76a", "filename": "tests/codegen/inline-function-args-debug-info.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a6292676eb412d8239b308cfd1660aa75623bf5b/tests%2Fcodegen%2Finline-function-args-debug-info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6292676eb412d8239b308cfd1660aa75623bf5b/tests%2Fcodegen%2Finline-function-args-debug-info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Finline-function-args-debug-info.rs?ref=a6292676eb412d8239b308cfd1660aa75623bf5b", "patch": "@@ -0,0 +1,20 @@\n+// This test checks that debug information includes function argument indexes even if the function\n+// gets inlined by MIR inlining. Without function argument indexes, `info args` in gdb won't show\n+// arguments and their values for the current function.\n+\n+// compile-flags: -Zinline-mir=yes -Cdebuginfo=2 --edition=2021\n+\n+#![crate_type = \"lib\"]\n+\n+pub fn outer_function(x: usize, y: usize) -> usize {\n+    inner_function(x, y) + 1\n+}\n+\n+#[inline]\n+fn inner_function(aaaa: usize, bbbb: usize) -> usize {\n+    // CHECK: !DILocalVariable(name: \"aaaa\", arg: 1\n+    // CHECK-SAME: line: 14\n+    // CHECK: !DILocalVariable(name: \"bbbb\", arg: 2\n+    // CHECK-SAME: line: 14\n+    aaaa + bbbb\n+}"}, {"sha": "937723ca743e9dd2f7c2036888a3b0a93492ac51", "filename": "tests/ui/async-await/task-context-arg.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a6292676eb412d8239b308cfd1660aa75623bf5b/tests%2Fui%2Fasync-await%2Ftask-context-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6292676eb412d8239b308cfd1660aa75623bf5b/tests%2Fui%2Fasync-await%2Ftask-context-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Ftask-context-arg.rs?ref=a6292676eb412d8239b308cfd1660aa75623bf5b", "patch": "@@ -0,0 +1,25 @@\n+// Checks that we don't get conflicting arguments in our debug info with a particular async function\n+// structure.\n+\n+// edition:2021\n+// compile-flags: -Cdebuginfo=2\n+// build-pass\n+\n+#![crate_type = \"lib\"]\n+\n+use std::future::Future;\n+\n+// The compiler produces a closure as part of this function. That closure initially takes an\n+// argument _task_context. Later, when the MIR for that closure is transformed into a generator\n+// state machine, _task_context is demoted to not be an argument, but just part of an unnamed\n+// argument. If we emit debug info saying that both _task_context and the unnamed argument are both\n+// argument number 2, then LLVM will fail with \"conflicting debug info for argument\". See\n+// https://github.com/rust-lang/rust/pull/109466#issuecomment-1500879195 for details.\n+async fn recv_unit() {\n+    std::future::ready(()).await;\n+}\n+\n+pub fn poll_recv() {\n+    // This box is necessary in order to reproduce the problem.\n+    let _: Box<dyn Future<Output = ()>> = Box::new(recv_unit());\n+}"}]}