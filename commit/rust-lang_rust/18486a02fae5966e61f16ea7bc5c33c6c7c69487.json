{"sha": "18486a02fae5966e61f16ea7bc5c33c6c7c69487", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4NDg2YTAyZmFlNTk2NmU2MWYxNmVhN2JjNWMzM2M2YzdjNjk0ODc=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-13T10:46:05Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-13T10:46:05Z"}, "message": "indexing infra", "tree": {"sha": "11b0c792cd8c233cb6a55208f86a0c812457ecd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11b0c792cd8c233cb6a55208f86a0c812457ecd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18486a02fae5966e61f16ea7bc5c33c6c7c69487", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18486a02fae5966e61f16ea7bc5c33c6c7c69487", "html_url": "https://github.com/rust-lang/rust/commit/18486a02fae5966e61f16ea7bc5c33c6c7c69487", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18486a02fae5966e61f16ea7bc5c33c6c7c69487/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be742a587704f27f4e503c50f549aa9ec1527fcc", "url": "https://api.github.com/repos/rust-lang/rust/commits/be742a587704f27f4e503c50f549aa9ec1527fcc", "html_url": "https://github.com/rust-lang/rust/commit/be742a587704f27f4e503c50f549aa9ec1527fcc"}], "stats": {"total": 283, "additions": 223, "deletions": 60}, "files": [{"sha": "9748fd57885e6facfe483c387534d45887cf3750", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/18486a02fae5966e61f16ea7bc5c33c6c7c69487/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/18486a02fae5966e61f16ea7bc5c33c6c7c69487/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=18486a02fae5966e61f16ea7bc5c33c6c7c69487", "patch": "@@ -1,2 +1,3 @@\n [workspace]\n members = [ \"crates/*\" ]\n+exclude = [ \"crates/indxr\" ]"}, {"sha": "8563ba73cd8ba0b382f5e3dd44195259e7bd355f", "filename": "code/package.json", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/18486a02fae5966e61f16ea7bc5c33c6c7c69487/code%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/18486a02fae5966e61f16ea7bc5c33c6c7c69487/code%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/code%2Fpackage.json?ref=18486a02fae5966e61f16ea7bc5c33c6c7c69487", "patch": "@@ -44,6 +44,38 @@\n         \"key\": \"ctrl+w\",\n         \"when\": \"editorTextFocus && editorLangId == rust\"\n       }\n+    ],\n+    \"problemMatchers\": [\n+      {\n+        \"name\": \"rustc\",\n+        \"fileLocation\": [\n+          \"relative\",\n+          \"${workspaceRoot}\"\n+        ],\n+        \"pattern\": [\n+          {\n+            \"regexp\": \"^(warning|warn|error)(\\\\[(.*)\\\\])?: (.*)$\",\n+            \"severity\": 1,\n+            \"message\": 4,\n+            \"code\": 3\n+          },\n+          {\n+            \"regexp\": \"^([\\\\s->=]*(.*):(\\\\d*):(\\\\d*)|.*)$\",\n+            \"file\": 2,\n+            \"line\": 3,\n+            \"column\": 4\n+          },\n+          {\n+            \"regexp\": \"^.*$\"\n+          },\n+          {\n+            \"regexp\": \"^([\\\\s->=]*(.*):(\\\\d*):(\\\\d*)|.*)$\",\n+            \"file\": 2,\n+            \"line\": 3,\n+            \"column\": 4\n+          }\n+        ]\n+      }\n     ]\n   }\n }"}, {"sha": "dd0c29f1467017c9821c26000f6e1ed67181c4d6", "filename": "code/src/extension.ts", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/18486a02fae5966e61f16ea7bc5c33c6c7c69487/code%2Fsrc%2Fextension.ts", "raw_url": "https://github.com/rust-lang/rust/raw/18486a02fae5966e61f16ea7bc5c33c6c7c69487/code%2Fsrc%2Fextension.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/code%2Fsrc%2Fextension.ts?ref=18486a02fae5966e61f16ea7bc5c33c6c7c69487", "patch": "@@ -61,8 +61,9 @@ export function deactivate(): Thenable<void> {\n \n function startServer() {\n     let run: lc.Executable = {\n-        command: \"m\",\n-        // args: [\"run\", \"--package\", \"m\"],\n+        command: \"cargo\",\n+        args: [\"run\", \"--package\", \"m\"],\n+        // command: \"m\",\n         options: { cwd: \".\" }\n     }\n     let serverOptions: lc.ServerOptions = {"}, {"sha": "e4df3de2e0729767e07f19a3b3645787c06db104", "filename": "crates/libanalysis/src/lib.rs", "status": "modified", "additions": 32, "deletions": 46, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/18486a02fae5966e61f16ea7bc5c33c6c7c69487/crates%2Flibanalysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18486a02fae5966e61f16ea7bc5c33c6c7c69487/crates%2Flibanalysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Flib.rs?ref=18486a02fae5966e61f16ea7bc5c33c6c7c69487", "patch": "@@ -1,3 +1,4 @@\n+#[macro_use]\n extern crate failure;\n extern crate parking_lot;\n #[macro_use]\n@@ -9,12 +10,10 @@ extern crate libeditor;\n use once_cell::sync::OnceCell;\n \n use std::{\n-    fs,\n     sync::Arc,\n     collections::hash_map::HashMap,\n     path::{PathBuf, Path},\n };\n-use parking_lot::RwLock;\n use libsyntax2::ast;\n use libeditor::LineIndex;\n \n@@ -40,22 +39,27 @@ impl WorldState {\n         World { data: self.data.clone() }\n     }\n \n-    pub fn change_overlay(&mut self, path: PathBuf, text: Option<String>) {\n+    pub fn change_file(&mut self, path: PathBuf, text: Option<String>) {\n+        self.change_files(::std::iter::once((path, text)));\n+    }\n+\n+    pub fn change_files(&mut self, changes: impl Iterator<Item=(PathBuf, Option<String>)>) {\n         let data = self.data_mut();\n-        data.file_map.get_mut().remove(&path);\n-        if let Some(text) = text {\n-            data.mem_map.insert(path, Arc::new(text));\n-        } else {\n-            data.mem_map.remove(&path);\n+        for (path, text) in changes {\n+            data.file_map.remove(&path);\n+            if let Some(text) = text {\n+                let file_data = FileData::new(text);\n+                data.file_map.insert(path, Arc::new(file_data));\n+            } else {\n+                data.file_map.remove(&path);\n+            }\n         }\n     }\n \n     fn data_mut(&mut self) -> &mut WorldData {\n         if Arc::get_mut(&mut self.data).is_none() {\n-            let file_map = self.data.file_map.read().clone();\n             self.data = Arc::new(WorldData {\n-                mem_map: self.data.mem_map.clone(),\n-                file_map: RwLock::new(file_map),\n+                file_map: self.data.file_map.clone(),\n             });\n         }\n         Arc::get_mut(&mut self.data).unwrap()\n@@ -69,7 +73,7 @@ impl World {\n         let syntax = data.syntax\n             .get_or_init(|| {\n                 trace!(\"parsing: {}\", path.display());\n-                ast::File::parse(self.file_text(path, &data))\n+                ast::File::parse(&data.text)\n             }).clone();\n         Ok(syntax)\n     }\n@@ -79,56 +83,38 @@ impl World {\n         let index = data.lines\n             .get_or_init(|| {\n                 trace!(\"calc line index: {}\", path.display());\n-                LineIndex::new(self.file_text(path, &data))\n+                LineIndex::new(&data.text)\n             });\n         Ok(index.clone())\n     }\n \n-    fn file_text<'a>(&'a self, path: &Path, file_data: &'a FileData) -> &'a str {\n-        match file_data.text.as_ref() {\n-            Some(text) => text.as_str(),\n-            None => self.data.mem_map[path].as_str()\n-        }\n-    }\n-\n     fn file_data(&self, path: &Path) -> Result<Arc<FileData>> {\n-        {\n-            let guard = self.data.file_map.read();\n-            if let Some(data) = guard.get(path) {\n-                return Ok(data.clone());\n-            }\n+        match self.data.file_map.get(path) {\n+            Some(data) => Ok(data.clone()),\n+            None => bail!(\"unknown file: {}\", path.display()),\n         }\n-\n-        let text = if self.data.mem_map.contains_key(path) {\n-            None\n-        } else {\n-            trace!(\"loading file from disk: {}\", path.display());\n-            Some(fs::read_to_string(path)?)\n-        };\n-        let res = {\n-            let mut guard = self.data.file_map.write();\n-            guard.entry(path.to_owned())\n-                .or_insert_with(|| Arc::new(FileData {\n-                    text,\n-                    syntax: OnceCell::new(),\n-                    lines: OnceCell::new(),\n-                }))\n-                .clone()\n-        };\n-        Ok(res)\n     }\n }\n \n \n #[derive(Default, Debug)]\n struct WorldData {\n-    mem_map: HashMap<PathBuf, Arc<String>>,\n-    file_map: RwLock<HashMap<PathBuf, Arc<FileData>>>,\n+    file_map: HashMap<PathBuf, Arc<FileData>>,\n }\n \n #[derive(Debug)]\n struct FileData {\n-    text: Option<String>,\n+    text: String,\n     syntax: OnceCell<ast::File>,\n     lines: OnceCell<LineIndex>,\n }\n+\n+impl FileData {\n+    fn new(text: String) -> FileData {\n+        FileData {\n+            text,\n+            syntax: OnceCell::new(),\n+            lines: OnceCell::new(),\n+        }\n+    }\n+}"}, {"sha": "0ad193b8a185b46c1058c22b6e00c7029918da2c", "filename": "crates/server/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/18486a02fae5966e61f16ea7bc5c33c6c7c69487/crates%2Fserver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/18486a02fae5966e61f16ea7bc5c33c6c7c69487/crates%2Fserver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2FCargo.toml?ref=18486a02fae5966e61f16ea7bc5c33c6c7c69487", "patch": "@@ -15,6 +15,7 @@ flexi_logger = \"0.9.1\"\n log = \"0.4.3\"\n url_serde = \"0.2.0\"\n languageserver-types = \"0.49.0\"\n+walkdir = \"2.2.0\"\n text_unit = { version = \"0.1.2\", features = [\"serde\"] }\n \n libsyntax2 = { path = \"../libsyntax2\" }"}, {"sha": "8dca3218399a59b2d4cebfcc969daa036802c781", "filename": "crates/server/src/main.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/18486a02fae5966e61f16ea7bc5c33c6c7c69487/crates%2Fserver%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18486a02fae5966e61f16ea7bc5c33c6c7c69487/crates%2Fserver%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fmain.rs?ref=18486a02fae5966e61f16ea7bc5c33c6c7c69487", "patch": "@@ -13,6 +13,7 @@ extern crate threadpool;\n extern crate log;\n extern crate url_serde;\n extern crate flexi_logger;\n+extern crate walkdir;\n extern crate libeditor;\n extern crate libanalysis;\n extern crate libsyntax2;\n@@ -24,6 +25,9 @@ mod dispatch;\n mod util;\n mod conv;\n mod main_loop;\n+mod vfs;\n+\n+use std::path::PathBuf;\n \n use threadpool::ThreadPool;\n use crossbeam_channel::bounded;\n@@ -114,13 +118,29 @@ fn initialized(io: &mut Io) -> Result<()> {\n     {\n         let mut world = WorldState::new();\n         let mut pool = ThreadPool::new(4);\n-        let (sender, receiver) = bounded::<Task>(16);\n+        let (task_sender, task_receiver) = bounded::<Task>(16);\n+        let (fs_events_receiver, watcher) = vfs::watch(vec![\n+            PathBuf::from(\"./\")\n+        ]);\n         info!(\"lifecycle: handshake finished, server ready to serve requests\");\n-        let res = main_loop::main_loop(io, &mut world, &mut pool, sender, receiver.clone());\n+        let res = main_loop::main_loop(\n+            io,\n+            &mut world,\n+            &mut pool,\n+            task_sender,\n+            task_receiver.clone(),\n+            fs_events_receiver,\n+        );\n+\n         info!(\"waiting for background jobs to finish...\");\n-        receiver.for_each(drop);\n+        task_receiver.for_each(drop);\n         pool.join();\n         info!(\"...background jobs have finished\");\n+\n+        info!(\"waiting for file watcher to finish...\");\n+        watcher.stop()?;\n+        info!(\"...file watcher has finished\");\n+\n         res\n     }?;\n "}, {"sha": "f954e632cadd67bafb17a451673bd8538f81f852", "filename": "crates/server/src/main_loop/mod.rs", "status": "modified", "additions": 52, "deletions": 9, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/18486a02fae5966e61f16ea7bc5c33c6c7c69487/crates%2Fserver%2Fsrc%2Fmain_loop%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18486a02fae5966e61f16ea7bc5c33c6c7c69487/crates%2Fserver%2Fsrc%2Fmain_loop%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fmain_loop%2Fmod.rs?ref=18486a02fae5966e61f16ea7bc5c33c6c7c69487", "patch": "@@ -1,6 +1,9 @@\n mod handlers;\n \n-use std::collections::HashSet;\n+use std::{\n+    path::PathBuf,\n+    collections::{HashSet, HashMap},\n+};\n \n use threadpool::ThreadPool;\n use crossbeam_channel::{Sender, Receiver};\n@@ -13,6 +16,7 @@ use {\n     Task, Result,\n     io::{Io, RawMsg, RawRequest, RawNotification},\n     util::FilePath,\n+    vfs::{FileEvent, FileEventKind},\n     main_loop::handlers::{\n         handle_syntax_tree,\n         handle_extend_selection,\n@@ -28,31 +32,43 @@ pub(super) fn main_loop(\n     io: &mut Io,\n     world: &mut WorldState,\n     pool: &mut ThreadPool,\n-    sender: Sender<Task>,\n-    receiver: Receiver<Task>,\n+    task_sender: Sender<Task>,\n+    task_receiver: Receiver<Task>,\n+    fs_events_receiver: Receiver<Vec<FileEvent>>,\n ) -> Result<()> {\n     info!(\"server initialized, serving requests\");\n     let mut next_request_id = 0;\n     let mut pending_requests: HashSet<u64> = HashSet::new();\n+    let mut mem_map: HashMap<PathBuf, Option<String>> = HashMap::new();\n+    let mut fs_events_receiver = Some(&fs_events_receiver);\n     loop {\n         enum Event {\n             Msg(RawMsg),\n             Task(Task),\n+            Fs(Vec<FileEvent>),\n             ReceiverDead,\n+            FsWatcherDead,\n         }\n         let event = select! {\n             recv(io.receiver(), msg) => match msg {\n                 Some(msg) => Event::Msg(msg),\n                 None => Event::ReceiverDead,\n             },\n-            recv(receiver, task) => Event::Task(task.unwrap()),\n+            recv(task_receiver, task) => Event::Task(task.unwrap()),\n+            recv(fs_events_receiver, events) => match events {\n+                Some(events) => Event::Fs(events),\n+                None => Event::FsWatcherDead,\n+            }\n         };\n \n         match event {\n             Event::ReceiverDead => {\n                 io.cleanup_receiver()?;\n                 unreachable!();\n             }\n+            Event::FsWatcherDead => {\n+                fs_events_receiver = None;\n+            }\n             Event::Task(task) => {\n                 match task {\n                     Task::Request(mut request) => {\n@@ -70,15 +86,36 @@ pub(super) fn main_loop(\n                 }\n                 continue;\n             }\n+            Event::Fs(events) => {\n+                trace!(\"fs change, {} events\", events.len());\n+                let changes = events.into_iter()\n+                    .map(|event| {\n+                        let text = match event.kind {\n+                            FileEventKind::Add(text) => Some(text),\n+                            FileEventKind::Remove => None,\n+                        };\n+                        (event.path, text)\n+                    })\n+                    .filter_map(|(path, text)| {\n+                        if mem_map.contains_key(path.as_path()) {\n+                            mem_map.insert(path, text);\n+                            None\n+                        } else {\n+                            Some((path, text))\n+                        }\n+                    });\n+\n+                world.change_files(changes);\n+            }\n             Event::Msg(msg) => {\n                 match msg {\n                     RawMsg::Request(req) => {\n-                        if !on_request(io, world, pool, &sender, req)? {\n+                        if !on_request(io, world, pool, &task_sender, req)? {\n                             return Ok(());\n                         }\n                     }\n                     RawMsg::Notification(not) => {\n-                        on_notification(io, world, pool, &sender, not)?\n+                        on_notification(io, world, pool, &task_sender, not, &mut mem_map)?\n                     }\n                     RawMsg::Response(resp) => {\n                         if !pending_requests.remove(&resp.id) {\n@@ -160,11 +197,13 @@ fn on_notification(\n     pool: &ThreadPool,\n     sender: &Sender<Task>,\n     not: RawNotification,\n+    mem_map: &mut HashMap<PathBuf, Option<String>>,\n ) -> Result<()> {\n     let mut not = Some(not);\n     dispatch::handle_notification::<req::DidOpenTextDocument, _>(&mut not, |params| {\n         let path = params.text_document.file_path()?;\n-        world.change_overlay(path, Some(params.text_document.text));\n+        mem_map.insert(path.clone(), None);\n+        world.change_file(path, Some(params.text_document.text));\n         update_file_notifications_on_threadpool(\n             pool, world.snapshot(), sender.clone(), params.text_document.uri,\n         );\n@@ -175,15 +214,19 @@ fn on_notification(\n         let text = params.content_changes.pop()\n             .ok_or_else(|| format_err!(\"empty changes\"))?\n             .text;\n-        world.change_overlay(path, Some(text));\n+        world.change_file(path, Some(text));\n         update_file_notifications_on_threadpool(\n             pool, world.snapshot(), sender.clone(), params.text_document.uri,\n         );\n         Ok(())\n     })?;\n     dispatch::handle_notification::<req::DidCloseTextDocument, _>(&mut not, |params| {\n         let path = params.text_document.file_path()?;\n-        world.change_overlay(path, None);\n+        let text = match mem_map.remove(&path) {\n+            Some(text) => text,\n+            None => bail!(\"unmatched close notification\"),\n+        };\n+        world.change_file(path, text);\n         let not = req::PublishDiagnosticsParams {\n             uri: params.text_document.uri,\n             diagnostics: Vec::new(),"}, {"sha": "a5c3674940b4327577ec5712de2892d273ce0fb6", "filename": "crates/server/src/vfs.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/18486a02fae5966e61f16ea7bc5c33c6c7c69487/crates%2Fserver%2Fsrc%2Fvfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18486a02fae5966e61f16ea7bc5c33c6c7c69487/crates%2Fserver%2Fsrc%2Fvfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fvfs.rs?ref=18486a02fae5966e61f16ea7bc5c33c6c7c69487", "patch": "@@ -0,0 +1,79 @@\n+use std::{\n+    path::PathBuf,\n+    thread,\n+    fs,\n+};\n+\n+use crossbeam_channel::{Sender, Receiver, bounded};\n+use drop_bomb::DropBomb;\n+use walkdir::WalkDir;\n+\n+use Result;\n+\n+\n+pub struct FileEvent {\n+    pub path: PathBuf,\n+    pub kind: FileEventKind,\n+}\n+\n+pub enum FileEventKind {\n+    Add(String),\n+    #[allow(unused)]\n+    Remove,\n+}\n+\n+pub struct Watcher {\n+    thread: thread::JoinHandle<()>,\n+    bomb: DropBomb,\n+}\n+\n+impl Watcher {\n+    pub fn stop(mut self) -> Result<()> {\n+        self.bomb.defuse();\n+        self.thread.join()\n+            .map_err(|_| format_err!(\"file watcher died\"))\n+    }\n+}\n+\n+pub fn watch(roots: Vec<PathBuf>) -> (Receiver<Vec<FileEvent>>, Watcher) {\n+    let (sender, receiver) = bounded(16);\n+    let thread = thread::spawn(move || run(roots, sender));\n+    (receiver, Watcher {\n+        thread,\n+        bomb: DropBomb::new(\"Watcher should be stopped explicitly\"),\n+    })\n+}\n+\n+fn run(roots: Vec<PathBuf>, sender: Sender<Vec<FileEvent>>) {\n+    for root in roots {\n+        let mut events = Vec::new();\n+        for entry in WalkDir::new(root.as_path()) {\n+            let entry = match entry {\n+                Ok(entry) => entry,\n+                Err(e) => {\n+                    warn!(\"watcher error: {}\", e);\n+                    continue;\n+                }\n+            };\n+            if !entry.file_type().is_file() {\n+                continue;\n+            }\n+            let path = entry.path();\n+            if path.extension().and_then(|os| os.to_str()) != Some(\"rs\") {\n+                continue;\n+            }\n+            let text = match fs::read_to_string(path) {\n+                Ok(text) => text,\n+                Err(e) => {\n+                    warn!(\"watcher error: {}\", e);\n+                    continue;\n+                }\n+            };\n+            events.push(FileEvent {\n+                path: path.to_owned(),\n+                kind: FileEventKind::Add(text),\n+            })\n+        }\n+        sender.send(events)\n+    }\n+}"}]}