{"sha": "4c315666dd7c2ac2d207b00ad2b5b5ca309a627f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjMzE1NjY2ZGQ3YzJhYzJkMjA3YjAwYWQyYjViNWNhMzA5YTYyN2Y=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-07-06T03:03:50Z"}, "committer": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-07-06T03:21:59Z"}, "message": "Forwarding functions.  Lots of progress toward #539, #540, #543.", "tree": {"sha": "46457743be71742cd924e4366dd86839bb4bb262", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46457743be71742cd924e4366dd86839bb4bb262"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c315666dd7c2ac2d207b00ad2b5b5ca309a627f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c315666dd7c2ac2d207b00ad2b5b5ca309a627f", "html_url": "https://github.com/rust-lang/rust/commit/4c315666dd7c2ac2d207b00ad2b5b5ca309a627f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c315666dd7c2ac2d207b00ad2b5b5ca309a627f/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "993e47175fcf8ae109d1ea7cdc27b6b9edb85e74", "url": "https://api.github.com/repos/rust-lang/rust/commits/993e47175fcf8ae109d1ea7cdc27b6b9edb85e74", "html_url": "https://github.com/rust-lang/rust/commit/993e47175fcf8ae109d1ea7cdc27b6b9edb85e74"}], "stats": {"total": 566, "additions": 473, "deletions": 93}, "files": [{"sha": "7e3d1aa9d7600e3f4b07e28d7bfb4758ee2f5db9", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 432, "deletions": 76, "changes": 508, "blob_url": "https://github.com/rust-lang/rust/blob/4c315666dd7c2ac2d207b00ad2b5b5ca309a627f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c315666dd7c2ac2d207b00ad2b5b5ca309a627f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=4c315666dd7c2ac2d207b00ad2b5b5ca309a627f", "patch": "@@ -6959,22 +6959,10 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n     }\n \n     // Get the type of the eventual entire anonymous object, possibly with\n-    // extensions.\n+    // extensions.  NB: This type includes both inner and outer methods.\n     auto outer_obj_ty = ty::node_id_to_type(ccx.tcx, type_id);\n     auto llouter_obj_ty = type_of(ccx, sp, outer_obj_ty);\n \n-    // Allocate the object that we're going to return.  It's a two-word pair\n-    // containing a vtable pointer and a body pointer.\n-    auto pair = alloca(bcx, llouter_obj_ty);\n-\n-    // Grab onto the first and second elements of the pair.\n-    // abi::obj_field_vtbl and abi::obj_field_box simply specify words 0 and 1\n-    // of 'pair'.\n-    auto pair_vtbl =\n-        bcx.build.GEP(pair, [C_int(0), C_int(abi::obj_field_vtbl)]);\n-    auto pair_box =\n-        bcx.build.GEP(pair, [C_int(0), C_int(abi::obj_field_box)]);\n-\n     // Create a vtable for the anonymous object.\n \n     // create_vtbl() wants an ast::_obj and all we have is an ast::anon_obj,\n@@ -6989,25 +6977,34 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n         methods = anon_obj.methods,\n         dtor = none[@ast::method]);\n \n-\n-    // If with_obj (the object being extended) exists, translate it, producing\n-    // a result.\n-    let ty::t with_obj_ty = ty::mk_type(ccx.tcx);\n+    let result with_obj_val;\n+    let ty::t with_obj_ty;\n     let TypeRef llwith_obj_ty;\n     auto vtbl;\n     alt (anon_obj.with_obj) {\n         case (none) { \n-            // If there's no with_obj -- that is, if we aren't extending our\n-            // object with any fields -- then we just pass the outer object to\n-            // create_vtbl().  This vtable won't need to have any forwarding\n-            // slots.\n+            // If there's no with_obj -- that is, if we're just adding new\n+            // fields rather than extending an existing object -- then we just\n+            // pass the outer object to create_vtbl().  Our vtable won't need\n+            // to have any forwarding slots.\n+\n+            // We need a dummy with_obj_ty for setting up the object body\n+            // later.\n+            with_obj_ty = ty::mk_type(ccx.tcx);\n+\n+            // This seems a little strange, because it'll come into\n+            // create_vtbl() with no \"additional methods\".  What's happening\n+            // is that, since *all* of the methods are \"additional\", we can\n+            // get away with acting like none of them are.\n             vtbl = create_vtbl(bcx.fcx.lcx, llouter_obj_ty, outer_obj_ty,\n-                               wrapper_obj, ty_params, none);\n+                               wrapper_obj, ty_params, none,\n+                               additional_field_tys);\n         }\n         case (some(?e)) {\n+            // If with_obj (the object being extended) exists, translate it.\n             // Translating with_obj returns a ValueRef (pointer to a 2-word\n             // value) wrapped in a result.\n-            trans_expr(bcx, e);\n+            with_obj_val = trans_expr(bcx, e);\n \n             // TODO: What makes more sense to get the type of an expr --\n             // calling ty::expr_ty(ccx.tcx, e) on it or calling\n@@ -7017,20 +7014,39 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n \n             llwith_obj_ty = type_of(ccx, sp, with_obj_ty);\n \n-            // If there's a with_obj, we pass it as the main argument to\n-            // create_vtbl(), but we're also passing along the additional\n-            // methods as the last argument.  Part of what create_vtbl() will\n-            // do is take the set difference of methods defined on the\n-            // original and methods being added.  For every method defined on\n-            // the original that does *not* have one with a matching name and\n-            // type being added, we'll need to create a forwarding slot.  And,\n-            // of course, we need to create a normal vtable entry for every\n-            // method being added.\n-            vtbl = create_vtbl(bcx.fcx.lcx, llwith_obj_ty, with_obj_ty,\n+            // If there's a with_obj, we pass its type along to create_vtbl().\n+            // Part of what create_vtbl() will do is take the set difference\n+            // of methods defined on the original and methods being added.\n+            // For every method defined on the original that does *not* have\n+            // one with a matching name and type being added, we'll need to\n+            // create a forwarding slot.  And, of course, we need to create a\n+            // normal vtable entry for every method being added.\n+            vtbl = create_vtbl(bcx.fcx.lcx, llouter_obj_ty, outer_obj_ty,\n                                wrapper_obj, ty_params, \n-                               some(anon_obj.methods));\n+                               some(tup(with_obj_ty, llwith_obj_ty)),\n+                               additional_field_tys);\n         }\n     }\n+    \n+    // Allocate the object that we're going to return.  It's a two-word pair\n+    // containing a vtable pointer and a body pointer.\n+    auto pair = \n+        alloca(bcx, \n+               T_struct([val_ty(vtbl),\n+                         T_obj_ptr(ccx.tn,\n+                                   vec::len[ast::ty_param](ty_params))]));\n+\n+    // Take care of cleanups.\n+    auto t = node_id_type(ccx, type_id);\n+    find_scope_cx(bcx).cleanups += [clean(bind drop_ty(_, pair, t))];\n+\n+    // Grab onto the first and second elements of the pair.\n+    // abi::obj_field_vtbl and abi::obj_field_box simply specify words 0 and 1\n+    // of 'pair'.\n+    auto pair_vtbl =\n+        bcx.build.GEP(pair, [C_int(0), C_int(abi::obj_field_vtbl)]);\n+    auto pair_box =\n+        bcx.build.GEP(pair, [C_int(0), C_int(abi::obj_field_box)]);\n \n     bcx.build.Store(vtbl, pair_vtbl);\n \n@@ -7040,11 +7056,10 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n     let TypeRef llbox_ty = T_opaque_obj_ptr(ccx.tn);\n \n     if (vec::len[ast::ty_param](ty_params) == 0u &&\n-            vec::len[ast::anon_obj_field](additional_fields) == 0u) {\n-        // If the object we're translating has no fields or type parameters,\n-        // there's not much to do.\n-\n-        // Store null into pair, if no args or typarams.\n+        vec::len[ast::anon_obj_field](additional_fields) == 0u &&\n+        anon_obj.with_obj == none) {\n+        // If the object we're translating has no fields or type parameters\n+        // and no with_obj, there's not much to do.\n         bcx.build.Store(C_null(llbox_ty), pair_box);\n     } else {\n \n@@ -7164,18 +7179,23 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n             i += 1;\n         }\n \n-        // Copy a pointer to the with_obj into the object's body.  (TODO: Is\n-        // it necessary to use GEP_tup_like here?)\n+        // Copy a pointer to the with_obj into the object's body.\n         auto body_with_obj =\n             GEP_tup_like(bcx, body_ty, body.val,\n                          [0, abi::obj_body_elt_with_obj]);\n         bcx = body_with_obj.bcx;\n+        bcx = copy_val(bcx, INIT, body_with_obj.val,\n+                       with_obj_val.val,\n+                       with_obj_ty).bcx;\n \n         // Store box ptr in outer pair.\n         auto p = bcx.build.PointerCast(box.val, llbox_ty);\n         bcx.build.Store(p, pair_box);\n     }\n \n+    // Cast the final object to how we want its type to appear.\n+    pair = bcx.build.PointerCast(pair, T_ptr(llouter_obj_ty));\n+\n     // Return the object we built.\n     ret rslt(bcx, pair);\n }\n@@ -7775,13 +7795,247 @@ fn trans_fn(@local_ctxt cx, &span sp, &ast::_fn f, ValueRef llfndecl,\n     finish_fn(fcx, lltop);\n }\n \n+// process_fwding_mthd: Create the forwarding function that appears in a\n+// vtable slot for method calls that \"fall through\" to an inner object.  A\n+// helper function for create_vtbl.\n+fn process_fwding_mthd(@local_ctxt cx, @ty::method m, TypeRef llself_ty,\n+                       ty::t self_ty, &vec[ast::ty_param] ty_params,\n+                       tup(ty::t, TypeRef) with_obj_ty_tup,\n+                       ty::t[] additional_field_tys) -> ValueRef {\n+\n+    // NB: self_ty (and llself_ty) is the type of the outer object;\n+    // with_obj_ty (and llwith_obj_ty) is the type of the inner object.\n+\n+    // The method m is being called on the outer object, but the outer object\n+    // doesn't have that method; only the inner object does.  So what we have\n+    // to do is synthesize that method on the outer object.  It has to take\n+    // all the same arguments as the method on the inner object does, then\n+    // call m with those arguments on the inner object, and then return the\n+    // value returned from that call.  It's like an eta-expansion around m,\n+    // except we also have to pass the inner object that m should be called\n+    // on.  That object won't exist until run-time, but we know its type\n+    // statically.\n+\n+    // Unpack the tuple.\n+    let ty::t with_obj_ty = with_obj_ty_tup._0;\n+    // TODO: We don't actually need both halves of this.\n+\n+    // Create a fake span for functions that expect it.  Shouldn't matter what\n+    // it is, since this isn't user-written code.  (Possibly better: have\n+    // create_vtable take a span argument and pass it in here?)\n+    let span fake_span = rec(lo=0u,hi=0u);\n+\n+    // Create a local context that's aware of the name of the method we're\n+    // creating.\n+    let @local_ctxt mcx =\n+        @rec(path=cx.path + [\"method\", m.ident] with *cx);\n+\n+    // Make up a name for the forwarding function.\n+    let str s = mangle_internal_name_by_path_and_seq(mcx.ccx, mcx.path,\n+                                                     \"forwarding_fn\");\n+\n+    // Get the forwarding function's type and declare it.\n+    let TypeRef llforwarding_fn_ty =\n+        type_of_fn_full(\n+            cx.ccx, fake_span, m.proto, \n+            some[TypeRef](llself_ty), m.inputs, m.output,\n+            vec::len[ast::ty_param](ty_params));\n+    let ValueRef llforwarding_fn =\n+        decl_internal_fastcall_fn(cx.ccx.llmod, s, llforwarding_fn_ty);\n+\n+    // Create a new function context and block context for the forwarding\n+    // function, holding onto a pointer to the first block.\n+    auto fcx = new_fn_ctxt(cx, fake_span, llforwarding_fn);\n+    auto bcx = new_top_block_ctxt(fcx);\n+    auto lltop = bcx.llbb;\n+\n+    // The outer object will arrive in the forwarding function via the llenv\n+    // argument.  Put it in an alloca so that we can GEP into it later.\n+    auto llself_obj_ptr = alloca(bcx, llself_ty);\n+    bcx.build.Store(fcx.llenv, llself_obj_ptr);\n+\n+    // The 'llretptr' that will arrive in the forwarding function we're\n+    // creating also needs to be the correct size.  Cast it to the size of the\n+    // method's return type, if necessary.\n+    auto llretptr = fcx.llretptr;\n+    if (ty::type_has_dynamic_size(cx.ccx.tcx, m.output)) {\n+        llretptr = bcx.build.PointerCast(llretptr, \n+                                         T_typaram_ptr(cx.ccx.tn));\n+    }\n+\n+    // Now, we have to get the the with_obj's vtbl out of the self_obj.  This\n+    // is a multi-step process:\n+    \n+    // First, grab the box out of the self_obj.  It contains a refcount and a\n+    // body.\n+    auto llself_obj_box =\n+        bcx.build.GEP(llself_obj_ptr, [C_int(0), \n+                                       C_int(abi::obj_field_box)]);\n+    llself_obj_box = bcx.build.Load(llself_obj_box);\n+\n+    // Now, reach into the box and grab the body.\n+    auto llself_obj_body =\n+        bcx.build.GEP(llself_obj_box, [C_int(0), \n+                                       C_int(abi::box_rc_field_body)]);\n+\n+    // Now, we need to figure out exactly what type the body is supposed to be\n+    // cast to.\n+\n+    // NB: This next part is almost flat-out copypasta from trans_anon_obj.\n+    // It would be great to factor this out.\n+\n+    // Synthesize a tuple type for fields: [field, ...]\n+    let ty::t fields_ty = ty::mk_imm_tup(cx.ccx.tcx, additional_field_tys);\n+\n+    // Tydescs are run-time instantiations of typarams.  We're not\n+    // actually supporting typarams for anon objs yet, but let's\n+    // create space for them in case we ever want them.\n+    let ty::t tydesc_ty = ty::mk_type(cx.ccx.tcx);\n+    let ty::t[] tps = ~[];\n+    for (ast::ty_param tp in ty_params) {\n+        tps += ~[tydesc_ty];\n+    }\n+    // Synthesize a tuple type for typarams: [typaram, ...]\n+    let ty::t typarams_ty = ty::mk_imm_tup(cx.ccx.tcx, tps);\n+\n+    // Tuple type for body: \n+    // [tydesc_ty, [typaram, ...], [field, ...], with_obj]\n+    let ty::t body_ty =\n+        ty::mk_imm_tup(cx.ccx.tcx, ~[tydesc_ty, typarams_ty,\n+                                     fields_ty, with_obj_ty]);\n+\n+    // And cast to that type.\n+    llself_obj_body = bcx.build.PointerCast(llself_obj_body,\n+                                            T_ptr(type_of(cx.ccx,\n+                                                          fake_span,\n+                                                          body_ty)));\n+\n+    // Now, reach into the body and grab the with_obj.\n+    auto llwith_obj =\n+        GEP_tup_like(bcx,\n+                     body_ty,\n+                     llself_obj_body,\n+                     [0, abi::obj_body_elt_with_obj]);\n+    bcx = llwith_obj.bcx;\n+\n+    // And, now, somewhere in with_obj is a vtable with an entry for the\n+    // method we want.  First, pick out the vtable, and then pluck that\n+    // method's entry out of the vtable so that the forwarding function can\n+    // call it.\n+    auto llwith_obj_vtbl =\n+        bcx.build.GEP(llwith_obj.val, [C_int(0), C_int(abi::obj_field_vtbl)]);\n+    llwith_obj_vtbl = bcx.build.Load(llwith_obj_vtbl);\n+\n+    // Get the index of the method we want.\n+    let uint ix = 0u;\n+    alt (ty::struct(bcx.fcx.lcx.ccx.tcx, with_obj_ty)) {\n+        case (ty::ty_obj(?methods)) {\n+            ix = ty::method_idx(cx.ccx.sess, fake_span, m.ident, methods);\n+        }\n+        case (_) {\n+            // Shouldn't happen.\n+            cx.ccx.sess.bug(\"process_fwding_mthd(): non-object type passed \"\n+                            + \"as with_obj_ty\");\n+        }\n+    }\n+\n+    // Pick out the original method from the vtable.  The +1 is because slot\n+    // #0 contains the destructor.\n+    auto llorig_mthd = bcx.build.GEP(llwith_obj_vtbl, \n+                                     [C_int(0), C_int(ix + 1u as int)]);\n+\n+    // Set up the original method to be called.\n+    auto orig_mthd_ty = ty::method_ty_to_fn_ty(cx.ccx.tcx, *m);\n+    auto llwith_obj_ty_real = val_ty(llwith_obj.val);\n+    auto llorig_mthd_ty =\n+        type_of_fn_full(bcx.fcx.lcx.ccx, fake_span,\n+                        ty::ty_fn_proto(bcx.fcx.lcx.ccx.tcx, orig_mthd_ty),\n+                        some[TypeRef](llwith_obj_ty_real), \n+                        m.inputs,\n+                        m.output,\n+                        vec::len[ast::ty_param](ty_params));\n+    // TODO: can we leave out one of these T_ptrs and then get rid of the\n+    // Load?\n+    llorig_mthd = bcx.build.PointerCast(llorig_mthd, \n+                                        T_ptr(llorig_mthd_ty));\n+\n+    // Set up the three implicit arguments to the original method we'll need\n+    // to call.\n+    let vec[ValueRef] llorig_mthd_args = [llretptr, fcx.lltaskptr, \n+                                          llwith_obj.val];\n+\n+    // Copy the explicit arguments that are being passed into the forwarding\n+    // function (they're in fcx.llargs) to llorig_mthd_args.\n+    \n+    let uint a = 3u; // retptr, task ptr, env come first\n+    let ValueRef passed_arg = llvm::LLVMGetParam(llforwarding_fn, a);\n+    for (ty::arg arg in m.inputs) {\n+        if (arg.mode == ty::mo_val) {\n+            passed_arg = load_if_immediate(bcx, passed_arg, arg.ty);\n+        } \n+        llorig_mthd_args += [passed_arg];\n+        a += 1u;\n+    }\n+\n+    // And, finally, call the original method.\n+    bcx.build.FastCall(llorig_mthd, llorig_mthd_args);\n+\n+    bcx.build.RetVoid();\n+    finish_fn(fcx, lltop);\n+\n+    ret llforwarding_fn;\n+}\n+\n+// process_normal_mthd: Create the contents of a normal vtable slot.  A helper\n+// function for create_vtbl.\n+fn process_normal_mthd(@local_ctxt cx, @ast::method m, TypeRef llself_ty, \n+                       ty::t self_ty, &vec[ast::ty_param] ty_params) \n+    -> ValueRef {\n+\n+    auto llfnty = T_nil();\n+    alt (ty::struct(cx.ccx.tcx, node_id_type(cx.ccx, m.node.id))){\n+        case (ty::ty_fn(?proto, ?inputs, ?output, _, _)) {\n+            llfnty =\n+                type_of_fn_full(\n+                    cx.ccx, m.span, proto, \n+                    some[TypeRef](llself_ty), inputs, output,\n+                    vec::len[ast::ty_param](ty_params));\n+        }\n+    }\n+    let @local_ctxt mcx =\n+        @rec(path=cx.path + [\"method\", m.node.ident] with *cx);\n+    let str s = mangle_internal_name_by_path(mcx.ccx, mcx.path);\n+    let ValueRef llfn =\n+        decl_internal_fastcall_fn(cx.ccx.llmod, s, llfnty);\n+ \n+    // Every method on an object gets its node_id inserted into the\n+    // crate-wide item_ids map, together with the ValueRef that points to\n+    // where that method's definition will be in the executable.\n+    cx.ccx.item_ids.insert(m.node.id, llfn);\n+    cx.ccx.item_symbols.insert(m.node.id, s);\n+    trans_fn(mcx, m.span, m.node.meth, llfn,\n+             some[ty_self_pair](tup(llself_ty, self_ty)), \n+             ty_params, m.node.id);\n+\n+    ret llfn;\n+}\n+\n // Create a vtable for an object being translated.  Returns a pointer into\n // read-only memory.\n fn create_vtbl(@local_ctxt cx, TypeRef llself_ty, ty::t self_ty,\n                &ast::_obj ob, &vec[ast::ty_param] ty_params,\n-               option::t[vec[@ast::method]] additional_methods) -> ValueRef {\n-    // FIXME (issue #539): Implement forwarding slots.\n-    \n+               option::t[tup(ty::t, TypeRef)] with_obj_ty_tup,\n+               ty::t[] additional_field_tys) -> ValueRef {\n+\n+    // Used only inside create_vtbl to distinguish different kinds of slots\n+    // we'll have to create.\n+    tag vtbl_mthd {\n+        // Normal methods are complete AST nodes, but for forwarding methods,\n+        // the only information we'll have about them is their type.\n+        normal_mthd(@ast::method);\n+        fwding_mthd(@ty::method);\n+    }\n+\n     auto dtor = C_null(T_ptr(T_i8()));\n     alt (ob.dtor) {\n         case (some(?d)) {\n@@ -7790,39 +8044,140 @@ fn create_vtbl(@local_ctxt cx, TypeRef llself_ty, ty::t self_ty,\n         }\n         case (none) { }\n     }\n-    let vec[ValueRef] methods = [dtor];\n-    fn meth_lteq(&@ast::method a, &@ast::method b) -> bool {\n-        ret str::lteq(a.node.ident, b.node.ident);\n-    }\n-    auto meths =\n-        std::sort::merge_sort[@ast::method](bind meth_lteq(_, _), ob.methods);\n-    for (@ast::method m in meths) {\n-        auto llfnty = T_nil();\n-        alt (ty::struct(cx.ccx.tcx, node_id_type(cx.ccx, m.node.id))) {\n-            case (ty::ty_fn(?proto, ?inputs, ?output, _, _)) {\n-                llfnty =\n-                    type_of_fn_full(cx.ccx, m.span, proto,\n-                                    some[TypeRef](llself_ty), inputs, output,\n-                                    vec::len[ast::ty_param](ty_params));\n+\n+    let vec[ValueRef] llmethods = [dtor];\n+    let vec[vtbl_mthd] meths = [];\n+\n+    alt (with_obj_ty_tup) {\n+        case (none) {\n+            // If there's no with_obj, then we don't need any forwarding\n+            // slots.  Just use the object's regular methods.\n+            for (@ast::method m in ob.methods) {\n+                meths += [normal_mthd(m)];\n+            }\n+        }\n+        case (some(?with_obj_ty_tup)) {\n+            // Handle forwarding slots.\n+\n+            // If this vtable is being created for an extended object, then\n+            // the vtable needs to contain 'forwarding slots' for methods that\n+            // were on the original object and are not being overloaded by the\n+            // extended one.  So, to find the set of methods that we need\n+            // forwarding slots for, we need to take the set difference of\n+            // with_obj_methods (methods on the original object) and\n+            // ob.methods (methods on the object being added).\n+\n+            // If we're here, then with_obj_ty and llwith_obj_ty are the type\n+            // of the inner object, and \"ob\" is the wrapper object.  We need\n+            // to take apart with_obj_ty (it had better have an object type\n+            // with methods!) and put those original methods onto the list of\n+            // methods we need forwarding methods for.\n+\n+            // Gather up methods on the original object in 'meths'.\n+            alt (ty::struct(cx.ccx.tcx, with_obj_ty_tup._0)) {\n+                case (ty::ty_obj(?with_obj_methods)) {\n+                    for (ty::method m in with_obj_methods) {\n+                        meths += [fwding_mthd(@m)];\n+                    } \n+                }\n+                case (_) {\n+                    // Shouldn't happen.\n+                    cx.ccx.sess.bug(\"create_vtbl(): trying to extend a \"\n+                                    + \"non-object\");\n+                }\n+            }\n+\n+            // Now, filter out any methods that are being replaced.\n+            fn filtering_fn(&vtbl_mthd m, vec[vtbl_mthd] addtl_meths) ->\n+                option::t[vtbl_mthd] {\n+\n+                let option::t[vtbl_mthd] rslt;\n+                if (std::vec::member[vtbl_mthd](m, addtl_meths)) {\n+                    rslt = none;\n+                } else {\n+                    rslt = some(m);\n+                }\n+                ret rslt;\n+            }\n+\n+            // NB: addtl_meths is just like ob.methods except that it's of\n+            // type vec[vtbl_mthd], not vec[@ast::method].\n+            let vec[vtbl_mthd] addtl_meths = [];\n+            for (@ast::method m in ob.methods) {\n+                addtl_meths += [normal_mthd(m)];\n+            }\n+            auto f = bind filtering_fn(_, addtl_meths);\n+\n+            // Filter out any methods that we don't need forwarding slots for\n+            // (namely, those that are being replaced).\n+            meths = std::vec::filter_map[vtbl_mthd, vtbl_mthd](f, meths);\n+            \n+            // And now add the additional ones (both replacements and entirely\n+            // new ones).\n+            meths += addtl_meths;\n+        }\n+    } \n+    \n+    // Sort all the methods.\n+    fn vtbl_mthd_lteq(&vtbl_mthd a, &vtbl_mthd b) -> bool {\n+        alt (a) {\n+            case (normal_mthd(?ma)) {\n+                alt (b) {\n+                    case (normal_mthd(?mb)) {\n+                        ret str::lteq(ma.node.ident, mb.node.ident);\n+                    }\n+                    case (fwding_mthd(?mb)) {\n+                        ret str::lteq(ma.node.ident, mb.ident);\n+                    }\n+                }\n+            }\n+            case (fwding_mthd(?ma)) {\n+                alt (b) {\n+                    case (normal_mthd(?mb)) {\n+                        ret str::lteq(ma.ident, mb.node.ident);\n+                    }\n+                    case (fwding_mthd(?mb)) {\n+                        ret str::lteq(ma.ident, mb.ident);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    meths = std::sort::merge_sort[vtbl_mthd] (bind vtbl_mthd_lteq(_, _), \n+                                              meths);\n+\n+    // Now that we have our list of methods, we can process them in order.\n+    for (vtbl_mthd m in meths) {\n+        alt (m) {\n+            case (normal_mthd(?nm)) {\n+                llmethods += [process_normal_mthd(cx, nm, llself_ty, self_ty,\n+                                                  ty_params)];\n+            }\n+            // If we have to process a forwarding method, then we need to know\n+            // about the with_obj's type as well as the outer object's type.\n+            case (fwding_mthd(?fm)) {\n+                alt (with_obj_ty_tup) {\n+                    case (none) {\n+                        // This shouldn't happen; if we're trying to process a\n+                        // forwarding method, then we should always have a\n+                        // with_obj_ty_tup.\n+                        cx.ccx.sess.bug(\"create_vtbl(): trying to create \"\n+                                        + \"forwarding method without a type \"\n+                                        + \"of object to forward to\");\n+                    }\n+                    case (some(?t)) {\n+                        llmethods += [process_fwding_mthd(\n+                                cx, fm, llself_ty, \n+                                self_ty, ty_params,\n+                                t,\n+                                additional_field_tys)];\n+                    }\n+                }\n             }\n         }\n-        let @local_ctxt mcx =\n-            @rec(path=cx.path + [\"method\", m.node.ident] with *cx);\n-        let str s = mangle_internal_name_by_path(mcx.ccx, mcx.path);\n-        let ValueRef llfn =\n-            decl_internal_fastcall_fn(cx.ccx.llmod, s, llfnty);\n-\n-        // Every method on an object gets its node_id inserted into the\n-        // crate-wide item_ids map, together with the ValueRef that points to\n-        // where that method's definition will be in the executable.\n-        cx.ccx.item_ids.insert(m.node.id, llfn);\n-        cx.ccx.item_symbols.insert(m.node.id, s);\n-        trans_fn(mcx, m.span, m.node.meth, llfn,\n-                 some[ty_self_pair](tup(llself_ty, self_ty)), ty_params,\n-                 m.node.id);\n-        methods += [llfn];\n-    }\n-    auto vtbl = C_struct(methods);\n+    }\n+    \n+    auto vtbl = C_struct(llmethods);\n     auto vtbl_name = mangle_internal_name_by_path(cx.ccx, cx.path + [\"vtbl\"]);\n     auto gvar =\n         llvm::LLVMAddGlobal(cx.ccx.llmod, val_ty(vtbl), str::buf(vtbl_name));\n@@ -7910,7 +8265,8 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::node_id ctor_id,\n     // It will be located in the read-only memory of the executable we're\n     // creating and will contain ValueRefs for all of this object's methods.\n     // create_vtbl returns a pointer to the vtable, which we store.\n-    auto vtbl = create_vtbl(cx, llself_ty, self_ty, ob, ty_params, none);\n+    auto vtbl = create_vtbl(cx, llself_ty, self_ty, ob, ty_params, none, ~[]);\n+\n     bcx.build.Store(vtbl, pair_vtbl);\n \n     // Next we have to take care of the other half of the pair we're"}, {"sha": "54ce0ffffc9f42170a70bd1d8244558dccf840c7", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 41, "deletions": 17, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/4c315666dd7c2ac2d207b00ad2b5b5ca309a627f/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c315666dd7c2ac2d207b00ad2b5b5ca309a627f/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=4c315666dd7c2ac2d207b00ad2b5b5ca309a627f", "patch": "@@ -2116,6 +2116,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                     write::ty_only_fixup(fcx, id, fields.(ix).mt.ty);\n                 }\n                 case (ty::ty_obj(?methods)) {\n+                    // log_err \"checking method_idx 1...\";\n                     let uint ix =\n                         ty::method_idx(fcx.ccx.tcx.sess, expr.span, field,\n                                        methods);\n@@ -2227,18 +2228,6 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                                              fields),\n                                     this_obj=di));\n \n-            // Typecheck 'with_obj', if it exists.\n-            alt (anon_obj.with_obj) {\n-                case (none) { }\n-                case (some(?e)) {\n-                    // This had better have object type.  TODO: report an\n-                    // error if the user is trying to extend a non-object\n-                    // with_obj.\n-\n-                    check_expr(fcx, e);\n-                }\n-            }\n-\n             // FIXME: These next three functions are largely ripped off from\n             // similar ones in collect::.  Is there a better way to do this?\n             fn ty_of_arg(@crate_ctxt ccx, &ast::arg a) -> ty::arg {\n@@ -2262,15 +2251,50 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                         inputs=inputs, output=output, cf=m.node.meth.decl.cf,\n                         constrs=out_constrs);\n             }\n-            fn get_anon_obj_method_types(@crate_ctxt ccx,\n+            fn get_anon_obj_method_types(@fn_ctxt fcx,\n                                          &ast::anon_obj anon_obj) ->\n                vec[ty::method] {\n-                ret vec::map[@ast::method,\n-                             method](bind ty_of_method(ccx, _),\n-                                     anon_obj.methods);\n+\n+                let vec[ty::method] methods = [];\n+\n+                // Outer methods.\n+                methods += vec::map[@ast::method,\n+                                    method](bind ty_of_method(fcx.ccx, _),\n+                                            anon_obj.methods);\n+\n+                // Inner methods.\n+\n+                // Typecheck 'with_obj'.  If it exists, it had better have\n+                // object type.\n+                let vec[ty::method] with_obj_methods = [];\n+                alt (anon_obj.with_obj) {\n+                    case (none) { }\n+                    case (some(?e)) {\n+                        check_expr(fcx, e);\n+                        auto with_obj_ty = expr_ty(fcx.ccx.tcx, e);\n+\n+                        alt (structure_of(fcx, e.span, with_obj_ty)) {\n+                            case (ty::ty_obj(?ms)) {\n+                                with_obj_methods = ms;\n+                            }\n+                            case (_) {\n+                                // The user is trying to extend a non-object.\n+                                fcx.ccx.tcx.sess.span_fatal(\n+                                    e.span,\n+                                    syntax::print::pprust::expr_to_str(e) + \n+                                    \" does not have object type\");\n+                            }\n+                        }\n+                    }\n+                }\n+                methods += with_obj_methods;\n+\n+                ret methods;\n             }\n-            auto method_types = get_anon_obj_method_types(fcx.ccx, anon_obj);\n+\n+            auto method_types = get_anon_obj_method_types(fcx, anon_obj);\n             auto ot = ty::mk_obj(fcx.ccx.tcx, ty::sort_methods(method_types));\n+\n             write::ty_only_fixup(fcx, id, ot);\n             // Write the methods into the node type table.  (This happens in\n             // collect::convert for regular objects.)"}]}