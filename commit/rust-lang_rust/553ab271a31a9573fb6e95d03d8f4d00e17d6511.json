{"sha": "553ab271a31a9573fb6e95d03d8f4d00e17d6511", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1M2FiMjcxYTMxYTk1NzNmYjZlOTVkMDNkOGY0ZDAwZTE3ZDY1MTE=", "commit": {"author": {"name": "Arcterus", "email": "Arcterus@mail.com", "date": "2014-12-06T10:35:26Z"}, "committer": {"name": "Arcterus", "email": "Arcterus@mail.com", "date": "2014-12-09T15:40:21Z"}, "message": "serialize: base64: allow LF in addition to CRLF and optimize slightly\n\nIt is useful to have configurable newlines in base64 as the standard\nleaves that for the implementation to decide.  GNU `base64` apparently\nuses LF, which meant in `uutils` we had to manually convert the CRLF to\nLF.  This made the program very slow for large inputs.\n\n[breaking-change]", "tree": {"sha": "ef60f079e656c31961eef9bb891a847d93393ea2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef60f079e656c31961eef9bb891a847d93393ea2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/553ab271a31a9573fb6e95d03d8f4d00e17d6511", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/553ab271a31a9573fb6e95d03d8f4d00e17d6511", "html_url": "https://github.com/rust-lang/rust/commit/553ab271a31a9573fb6e95d03d8f4d00e17d6511", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/553ab271a31a9573fb6e95d03d8f4d00e17d6511/comments", "author": {"login": "Arcterus", "id": 829813, "node_id": "MDQ6VXNlcjgyOTgxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/829813?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Arcterus", "html_url": "https://github.com/Arcterus", "followers_url": "https://api.github.com/users/Arcterus/followers", "following_url": "https://api.github.com/users/Arcterus/following{/other_user}", "gists_url": "https://api.github.com/users/Arcterus/gists{/gist_id}", "starred_url": "https://api.github.com/users/Arcterus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Arcterus/subscriptions", "organizations_url": "https://api.github.com/users/Arcterus/orgs", "repos_url": "https://api.github.com/users/Arcterus/repos", "events_url": "https://api.github.com/users/Arcterus/events{/privacy}", "received_events_url": "https://api.github.com/users/Arcterus/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Arcterus", "id": 829813, "node_id": "MDQ6VXNlcjgyOTgxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/829813?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Arcterus", "html_url": "https://github.com/Arcterus", "followers_url": "https://api.github.com/users/Arcterus/followers", "following_url": "https://api.github.com/users/Arcterus/following{/other_user}", "gists_url": "https://api.github.com/users/Arcterus/gists{/gist_id}", "starred_url": "https://api.github.com/users/Arcterus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Arcterus/subscriptions", "organizations_url": "https://api.github.com/users/Arcterus/orgs", "repos_url": "https://api.github.com/users/Arcterus/repos", "events_url": "https://api.github.com/users/Arcterus/events{/privacy}", "received_events_url": "https://api.github.com/users/Arcterus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cafe2966770ff377aad6dd9fd808e68055587c58", "url": "https://api.github.com/repos/rust-lang/rust/commits/cafe2966770ff377aad6dd9fd808e68055587c58", "html_url": "https://github.com/rust-lang/rust/commit/cafe2966770ff377aad6dd9fd808e68055587c58"}], "stats": {"total": 94, "additions": 64, "deletions": 30}, "files": [{"sha": "1cb8fdd025d38c049a61538c424b55e353820f8f", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 63, "deletions": 29, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/553ab271a31a9573fb6e95d03d8f4d00e17d6511/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553ab271a31a9573fb6e95d03d8f4d00e17d6511/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=553ab271a31a9573fb6e95d03d8f4d00e17d6511", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -14,6 +14,7 @@\n \n pub use self::FromBase64Error::*;\n pub use self::CharacterSet::*;\n+pub use self::Newline::*;\n \n use std::fmt;\n use std::error;\n@@ -28,10 +29,22 @@ pub enum CharacterSet {\n \n impl Copy for CharacterSet {}\n \n+/// Available newline types\n+pub enum Newline {\n+    /// A linefeed (i.e. Unix-style newline)\n+    LF,\n+    /// A carriage return and a linefeed (i.e. Windows-style newline)\n+    CRLF\n+}\n+\n+impl Copy for Newline {}\n+\n /// Contains configuration parameters for `to_base64`.\n pub struct Config {\n     /// Character set to use\n     pub char_set: CharacterSet,\n+    /// Newline to use\n+    pub newline: Newline,\n     /// True to pad output with `=` characters\n     pub pad: bool,\n     /// `Some(len)` to wrap lines at `len`, `None` to disable line wrapping\n@@ -42,15 +55,15 @@ impl Copy for Config {}\n \n /// Configuration for RFC 4648 standard base64 encoding\n pub static STANDARD: Config =\n-    Config {char_set: Standard, pad: true, line_length: None};\n+    Config {char_set: Standard, newline: CRLF, pad: true, line_length: None};\n \n /// Configuration for RFC 4648 base64url encoding\n pub static URL_SAFE: Config =\n-    Config {char_set: UrlSafe, pad: false, line_length: None};\n+    Config {char_set: UrlSafe, newline: CRLF, pad: false, line_length: None};\n \n /// Configuration for RFC 2045 MIME base64 encoding\n pub static MIME: Config =\n-    Config {char_set: Standard, pad: true, line_length: Some(76)};\n+    Config {char_set: Standard, newline: CRLF, pad: true, line_length: Some(76)};\n \n static STANDARD_CHARS: &'static[u8] = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n                                         abcdefghijklmnopqrstuvwxyz\\\n@@ -87,24 +100,29 @@ impl ToBase64 for [u8] {\n             UrlSafe => URLSAFE_CHARS\n         };\n \n-        let mut v = Vec::new();\n+        // In general, this Vec only needs (4/3) * self.len() memory, but\n+        // addition is faster than multiplication and division.\n+        let mut v = Vec::with_capacity(self.len() + self.len());\n         let mut i = 0;\n         let mut cur_length = 0;\n         let len = self.len();\n-        while i < len - (len % 3) {\n-            match config.line_length {\n-                Some(line_length) =>\n-                    if cur_length >= line_length {\n-                        v.push(b'\\r');\n-                        v.push(b'\\n');\n-                        cur_length = 0;\n-                    },\n-                None => ()\n+        let mod_len = len % 3;\n+        let cond_len = len - mod_len;\n+        while i < cond_len {\n+            let (first, second, third) = (self[i], self[i + 1], self[i + 2]);\n+            if let Some(line_length) = config.line_length {\n+                if cur_length >= line_length {\n+                    v.push_all(match config.newline {\n+                        LF => b\"\\n\",\n+                        CRLF => b\"\\r\\n\"\n+                    });\n+                    cur_length = 0;\n+                }\n             }\n \n-            let n = (self[i] as u32) << 16 |\n-                    (self[i + 1] as u32) << 8 |\n-                    (self[i + 2] as u32);\n+            let n = (first  as u32) << 16 |\n+                    (second as u32) << 8 |\n+                    (third  as u32);\n \n             // This 24-bit number gets separated into four 6-bit numbers.\n             v.push(bytes[((n >> 18) & 63) as uint]);\n@@ -116,20 +134,20 @@ impl ToBase64 for [u8] {\n             i += 3;\n         }\n \n-        if len % 3 != 0 {\n-            match config.line_length {\n-                Some(line_length) =>\n-                    if cur_length >= line_length {\n-                        v.push(b'\\r');\n-                        v.push(b'\\n');\n-                    },\n-                None => ()\n+        if mod_len != 0 {\n+            if let Some(line_length) = config.line_length {\n+                if cur_length >= line_length {\n+                    v.push_all(match config.newline {\n+                        LF => b\"\\n\",\n+                        CRLF => b\"\\r\\n\"\n+                    });\n+                }\n             }\n         }\n \n         // Heh, would be cool if we knew this was exhaustive\n         // (the dream of bounded integer types)\n-        match len % 3 {\n+        match mod_len {\n             0 => (),\n             1 => {\n                 let n = (self[i] as u32) << 16;\n@@ -232,7 +250,7 @@ impl FromBase64 for str {\n \n impl FromBase64 for [u8] {\n     fn from_base64(&self) -> Result<Vec<u8>, FromBase64Error> {\n-        let mut r = Vec::new();\n+        let mut r = Vec::with_capacity(self.len());\n         let mut buf: u32 = 0;\n         let mut modulus = 0i;\n \n@@ -288,7 +306,7 @@ impl FromBase64 for [u8] {\n mod tests {\n     extern crate test;\n     use self::test::Bencher;\n-    use base64::{Config, FromBase64, ToBase64, STANDARD, URL_SAFE};\n+    use base64::{Config, FromBase64, ToBase64, STANDARD, URL_SAFE, LF};\n \n     #[test]\n     fn test_to_base64_basic() {\n@@ -302,14 +320,26 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_to_base64_line_break() {\n+    fn test_to_base64_crlf_line_break() {\n         assert!(![0u8, ..1000].to_base64(Config {line_length: None, ..STANDARD})\n                               .contains(\"\\r\\n\"));\n         assert_eq!(\"foobar\".as_bytes().to_base64(Config {line_length: Some(4),\n                                                          ..STANDARD}),\n                    \"Zm9v\\r\\nYmFy\");\n     }\n \n+    #[test]\n+    fn test_to_base64_lf_line_break() {\n+        assert!(![0u8, ..1000].to_base64(Config {line_length: None, newline: LF,\n+                                                 ..STANDARD})\n+                              .as_slice()\n+                              .contains(\"\\n\"));\n+        assert_eq!(\"foobar\".as_bytes().to_base64(Config {line_length: Some(4),\n+                                                         newline: LF,\n+                                                         ..STANDARD}),\n+                   \"Zm9v\\nYmFy\".to_string());\n+    }\n+\n     #[test]\n     fn test_to_base64_padding() {\n         assert_eq!(\"f\".as_bytes().to_base64(Config {pad: false, ..STANDARD}), \"Zg\");\n@@ -344,6 +374,10 @@ mod tests {\n                    b\"foobar\");\n         assert_eq!(\"Zm9vYg==\\r\\n\".from_base64().unwrap(),\n                    b\"foob\");\n+        assert_eq!(\"Zm9v\\nYmFy\".from_base64().unwrap(),\n+                   b\"foobar\");\n+        assert_eq!(\"Zm9vYg==\\n\".from_base64().unwrap(),\n+                   b\"foob\");\n     }\n \n     #[test]"}, {"sha": "1cff4c334e7430d1d8827e6e89281e0c862dc934", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/553ab271a31a9573fb6e95d03d8f4d00e17d6511/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553ab271a31a9573fb6e95d03d8f4d00e17d6511/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=553ab271a31a9573fb6e95d03d8f4d00e17d6511", "patch": "@@ -23,7 +23,7 @@ Core encoding and decoding interfaces.\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![allow(unknown_features)]\n-#![feature(macro_rules, default_type_params, phase, slicing_syntax, globs)]\n+#![feature(macro_rules, default_type_params, phase, slicing_syntax, globs, if_let)]\n \n // test harness access\n #[cfg(test)]"}]}