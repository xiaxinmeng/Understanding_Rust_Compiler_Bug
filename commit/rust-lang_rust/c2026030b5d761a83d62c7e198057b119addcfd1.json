{"sha": "c2026030b5d761a83d62c7e198057b119addcfd1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyMDI2MDMwYjVkNzYxYTgzZDYyYzdlMTk4MDU3YjExOWFkZGNmZDE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-01-31T11:09:21Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-02-13T14:16:36Z"}, "message": "parser: remove `Option<Vec<Attribute>>` in `ItemInfo`.", "tree": {"sha": "728b70f30172c95b24f5f8529a02999cf82780d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/728b70f30172c95b24f5f8529a02999cf82780d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2026030b5d761a83d62c7e198057b119addcfd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2026030b5d761a83d62c7e198057b119addcfd1", "html_url": "https://github.com/rust-lang/rust/commit/c2026030b5d761a83d62c7e198057b119addcfd1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2026030b5d761a83d62c7e198057b119addcfd1/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20ba6875e695dd985ba7f8974cc10c665f687670", "url": "https://api.github.com/repos/rust-lang/rust/commits/20ba6875e695dd985ba7f8974cc10c665f687670", "html_url": "https://github.com/rust-lang/rust/commit/20ba6875e695dd985ba7f8974cc10c665f687670"}], "stats": {"total": 109, "additions": 50, "deletions": 59}, "files": [{"sha": "745d125b58c8ff041726c7873eb5b73377d313a7", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 49, "deletions": 58, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/c2026030b5d761a83d62c7e198057b119addcfd1/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2026030b5d761a83d62c7e198057b119addcfd1/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=c2026030b5d761a83d62c7e198057b119addcfd1", "patch": "@@ -22,7 +22,7 @@ use syntax::tokenstream::{DelimSpan, TokenStream, TokenTree};\n use log::debug;\n use std::mem;\n \n-pub(super) type ItemInfo = (Ident, ItemKind, Option<Vec<Attribute>>);\n+pub(super) type ItemInfo = (Ident, ItemKind);\n \n impl<'a> Parser<'a> {\n     pub fn parse_item(&mut self) -> PResult<'a, Option<P<Item>>> {\n@@ -85,8 +85,8 @@ impl<'a> Parser<'a> {\n         let lo = self.token.span;\n         let vis = self.parse_visibility(FollowedByType::No)?;\n \n-        if let Some(info) = self.parse_item_kind(&mut attrs, macros_allowed, lo, &vis)? {\n-            return Ok(Some(self.mk_item_with_info(attrs, lo, vis, info)));\n+        if let Some((ident, kind)) = self.parse_item_kind(&mut attrs, macros_allowed, lo, &vis)? {\n+            return Ok(Some(self.mk_item(lo.to(self.prev_span), ident, kind, vis, attrs)));\n         }\n \n         // FAILURE TO PARSE ITEM\n@@ -118,18 +118,18 @@ impl<'a> Parser<'a> {\n             // USE ITEM\n             let tree = self.parse_use_tree()?;\n             self.expect_semi()?;\n-            (Ident::invalid(), ItemKind::Use(P(tree)), None)\n+            (Ident::invalid(), ItemKind::Use(P(tree)))\n         } else if self.check_fn_front_matter() {\n             // FUNCTION ITEM\n             let (ident, sig, generics, body) = self.parse_fn(&mut false, attrs, |_| true)?;\n-            (ident, ItemKind::Fn(sig, generics, body), None)\n+            (ident, ItemKind::Fn(sig, generics, body))\n         } else if self.eat_keyword(kw::Extern) {\n             if self.eat_keyword(kw::Crate) {\n                 // EXTERN CRATE\n                 self.parse_item_extern_crate()?\n             } else {\n                 // EXTERN BLOCK\n-                self.parse_item_foreign_mod()?\n+                self.parse_item_foreign_mod(attrs)?\n             }\n         } else if self.is_static_global() {\n             // STATIC ITEM\n@@ -156,7 +156,7 @@ impl<'a> Parser<'a> {\n         {\n             // UNSAFE TRAIT ITEM\n             let unsafety = self.parse_unsafety();\n-            self.parse_item_trait(lo, unsafety)?\n+            self.parse_item_trait(attrs, lo, unsafety)?\n         } else if self.check_keyword(kw::Impl)\n             || self.check_keyword(kw::Unsafe) && self.is_keyword_ahead(1, &[kw::Impl])\n             || self.check_keyword(kw::Default) && self.is_keyword_ahead(1, &[kw::Impl, kw::Unsafe])\n@@ -165,22 +165,22 @@ impl<'a> Parser<'a> {\n             let defaultness = self.parse_defaultness();\n             let unsafety = self.parse_unsafety();\n             self.expect_keyword(kw::Impl)?;\n-            self.parse_item_impl(unsafety, defaultness)?\n+            self.parse_item_impl(attrs, unsafety, defaultness)?\n         } else if self.eat_keyword(kw::Mod) {\n             // MODULE ITEM\n             self.parse_item_mod(attrs)?\n         } else if self.eat_keyword(kw::Type) {\n             // TYPE ITEM\n             let (ident, ty, generics) = self.parse_type_alias()?;\n-            (ident, ItemKind::TyAlias(ty, generics), None)\n+            (ident, ItemKind::TyAlias(ty, generics))\n         } else if self.eat_keyword(kw::Enum) {\n             // ENUM ITEM\n             self.parse_item_enum()?\n         } else if self.check_keyword(kw::Trait)\n             || (self.check_keyword(kw::Auto) && self.is_keyword_ahead(1, &[kw::Trait]))\n         {\n             // TRAIT ITEM\n-            self.parse_item_trait(lo, Unsafe::No)?\n+            self.parse_item_trait(attrs, lo, Unsafe::No)?\n         } else if self.eat_keyword(kw::Struct) {\n             // STRUCT ITEM\n             self.parse_item_struct()?\n@@ -306,26 +306,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub(super) fn mk_item_with_info(\n-        &self,\n-        attrs: Vec<Attribute>,\n-        lo: Span,\n-        vis: Visibility,\n-        info: ItemInfo,\n-    ) -> P<Item> {\n-        let (ident, item, extra_attrs) = info;\n-        let span = lo.to(self.prev_span);\n-        let attrs = Self::maybe_append(attrs, extra_attrs);\n-        self.mk_item(span, ident, item, vis, attrs)\n-    }\n-\n-    fn maybe_append<T>(mut lhs: Vec<T>, mut rhs: Option<Vec<T>>) -> Vec<T> {\n-        if let Some(ref mut rhs) = rhs {\n-            lhs.append(rhs);\n-        }\n-        lhs\n-    }\n-\n     /// Parses an item macro, e.g., `item!();`.\n     fn parse_item_macro(&mut self, vis: &Visibility) -> PResult<'a, ItemInfo> {\n         self.complain_if_pub_macro(&vis.node, vis.span);\n@@ -339,7 +319,7 @@ impl<'a> Parser<'a> {\n         }\n \n         let mac = Mac { path, args, prior_type_ascription: self.last_type_ascription };\n-        Ok((Ident::invalid(), ItemKind::Mac(mac), None))\n+        Ok((Ident::invalid(), ItemKind::Mac(mac)))\n     }\n \n     /// Emits an expected-item-after-attributes error.\n@@ -428,16 +408,21 @@ impl<'a> Parser<'a> {\n \n     /// Parses an implementation item, `impl` keyword is already parsed.\n     ///\n-    ///    impl<'a, T> TYPE { /* impl items */ }\n-    ///    impl<'a, T> TRAIT for TYPE { /* impl items */ }\n-    ///    impl<'a, T> !TRAIT for TYPE { /* impl items */ }\n-    ///    impl<'a, T> const TRAIT for TYPE { /* impl items */ }\n+    /// ```\n+    /// impl<'a, T> TYPE { /* impl items */ }\n+    /// impl<'a, T> TRAIT for TYPE { /* impl items */ }\n+    /// impl<'a, T> !TRAIT for TYPE { /* impl items */ }\n+    /// impl<'a, T> const TRAIT for TYPE { /* impl items */ }\n+    /// ```\n     ///\n     /// We actually parse slightly more relaxed grammar for better error reporting and recovery.\n-    ///   `impl` GENERICS `const`? `!`? TYPE `for`? (TYPE | `..`) (`where` PREDICATES)? `{` BODY `}`\n-    ///   `impl` GENERICS `const`? `!`? TYPE (`where` PREDICATES)? `{` BODY `}`\n+    /// ```\n+    /// \"impl\" GENERICS \"const\"? \"!\"? TYPE \"for\"? (TYPE | \"..\") (\"where\" PREDICATES)? \"{\" BODY \"}\"\n+    /// \"impl\" GENERICS \"const\"? \"!\"? TYPE (\"where\" PREDICATES)? \"{\" BODY \"}\"\n+    /// ```\n     fn parse_item_impl(\n         &mut self,\n+        attrs: &mut Vec<Attribute>,\n         unsafety: Unsafe,\n         defaultness: Defaultness,\n     ) -> PResult<'a, ItemInfo> {\n@@ -492,7 +477,7 @@ impl<'a> Parser<'a> {\n \n         generics.where_clause = self.parse_where_clause()?;\n \n-        let (impl_items, attrs) = self.parse_item_list(|p, at_end| p.parse_impl_item(at_end))?;\n+        let impl_items = self.parse_item_list(attrs, |p, at_end| p.parse_impl_item(at_end))?;\n \n         let item_kind = match ty_second {\n             Some(ty_second) => {\n@@ -545,15 +530,16 @@ impl<'a> Parser<'a> {\n             }\n         };\n \n-        Ok((Ident::invalid(), item_kind, Some(attrs)))\n+        Ok((Ident::invalid(), item_kind))\n     }\n \n     fn parse_item_list<T>(\n         &mut self,\n+        attrs: &mut Vec<Attribute>,\n         mut parse_item: impl FnMut(&mut Parser<'a>, &mut bool) -> PResult<'a, T>,\n-    ) -> PResult<'a, (Vec<T>, Vec<Attribute>)> {\n+    ) -> PResult<'a, Vec<T>> {\n         self.expect(&token::OpenDelim(token::Brace))?;\n-        let attrs = self.parse_inner_attributes()?;\n+        attrs.append(&mut self.parse_inner_attributes()?);\n \n         let mut items = Vec::new();\n         while !self.eat(&token::CloseDelim(token::Brace)) {\n@@ -572,7 +558,7 @@ impl<'a> Parser<'a> {\n                 }\n             }\n         }\n-        Ok((items, attrs))\n+        Ok(items)\n     }\n \n     /// Recover on a doc comment before `}`.\n@@ -624,7 +610,12 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses `auto? trait Foo { ... }` or `trait Foo = Bar;`.\n-    fn parse_item_trait(&mut self, lo: Span, unsafety: Unsafe) -> PResult<'a, ItemInfo> {\n+    fn parse_item_trait(\n+        &mut self,\n+        attrs: &mut Vec<Attribute>,\n+        lo: Span,\n+        unsafety: Unsafe,\n+    ) -> PResult<'a, ItemInfo> {\n         // Parse optional `auto` prefix.\n         let is_auto = if self.eat_keyword(kw::Auto) { IsAuto::Yes } else { IsAuto::No };\n \n@@ -662,12 +653,12 @@ impl<'a> Parser<'a> {\n \n             self.sess.gated_spans.gate(sym::trait_alias, whole_span);\n \n-            Ok((ident, ItemKind::TraitAlias(tps, bounds), None))\n+            Ok((ident, ItemKind::TraitAlias(tps, bounds)))\n         } else {\n             // It's a normal trait.\n             tps.where_clause = self.parse_where_clause()?;\n-            let (items, attrs) = self.parse_item_list(|p, at_end| p.parse_trait_item(at_end))?;\n-            Ok((ident, ItemKind::Trait(is_auto, unsafety, tps, bounds, items), Some(attrs)))\n+            let items = self.parse_item_list(attrs, |p, at_end| p.parse_trait_item(at_end))?;\n+            Ok((ident, ItemKind::Trait(is_auto, unsafety, tps, bounds, items)))\n         }\n     }\n \n@@ -854,7 +845,7 @@ impl<'a> Parser<'a> {\n             (orig_name, None)\n         };\n         self.expect_semi()?;\n-        Ok((item_name, ItemKind::ExternCrate(orig_name), None))\n+        Ok((item_name, ItemKind::ExternCrate(orig_name)))\n     }\n \n     fn parse_crate_name_with_dashes(&mut self) -> PResult<'a, ast::Ident> {\n@@ -905,11 +896,11 @@ impl<'a> Parser<'a> {\n     /// extern \"C\" {}\n     /// extern {}\n     /// ```\n-    fn parse_item_foreign_mod(&mut self) -> PResult<'a, ItemInfo> {\n+    fn parse_item_foreign_mod(&mut self, attrs: &mut Vec<Attribute>) -> PResult<'a, ItemInfo> {\n         let abi = self.parse_abi(); // ABI?\n-        let (items, attrs) = self.parse_item_list(|p, at_end| p.parse_foreign_item(at_end))?;\n+        let items = self.parse_item_list(attrs, |p, at_end| p.parse_foreign_item(at_end))?;\n         let module = ast::ForeignMod { abi, items };\n-        Ok((Ident::invalid(), ItemKind::ForeignMod(module), Some(attrs)))\n+        Ok((Ident::invalid(), ItemKind::ForeignMod(module)))\n     }\n \n     /// Parses a foreign item (one in an `extern { ... }` block).\n@@ -1016,7 +1007,7 @@ impl<'a> Parser<'a> {\n             Some(m) => ItemKind::Static(ty, m, e),\n             None => ItemKind::Const(ty, e),\n         };\n-        Ok((id, item, None))\n+        Ok((id, item))\n     }\n \n     /// We were supposed to parse `:` but instead, we're already at `=`.\n@@ -1069,7 +1060,7 @@ impl<'a> Parser<'a> {\n \n         let enum_definition =\n             EnumDef { variants: variants.into_iter().filter_map(|v| v).collect() };\n-        Ok((id, ItemKind::Enum(enum_definition, generics), None))\n+        Ok((id, ItemKind::Enum(enum_definition, generics)))\n     }\n \n     fn parse_enum_variant(&mut self) -> PResult<'a, Option<Variant>> {\n@@ -1163,7 +1154,7 @@ impl<'a> Parser<'a> {\n             return Err(err);\n         };\n \n-        Ok((class_name, ItemKind::Struct(vdata, generics), None))\n+        Ok((class_name, ItemKind::Struct(vdata, generics)))\n     }\n \n     /// Parses `union Foo { ... }`.\n@@ -1187,7 +1178,7 @@ impl<'a> Parser<'a> {\n             return Err(err);\n         };\n \n-        Ok((class_name, ItemKind::Union(vdata, generics), None))\n+        Ok((class_name, ItemKind::Union(vdata, generics)))\n     }\n \n     pub(super) fn is_union_item(&self) -> bool {\n@@ -1369,7 +1360,7 @@ impl<'a> Parser<'a> {\n         };\n \n         self.sess.gated_spans.gate(sym::decl_macro, lo.to(self.prev_span));\n-        Ok((ident, ItemKind::MacroDef(ast::MacroDef { body, legacy: false }), None))\n+        Ok((ident, ItemKind::MacroDef(ast::MacroDef { body, legacy: false })))\n     }\n \n     /// Is this unambiguously the start of a `macro_rules! foo` item defnition?\n@@ -1391,7 +1382,7 @@ impl<'a> Parser<'a> {\n             self.report_invalid_macro_expansion_item();\n         }\n \n-        Ok((ident, ItemKind::MacroDef(ast::MacroDef { body, legacy: true }), None))\n+        Ok((ident, ItemKind::MacroDef(ast::MacroDef { body, legacy: true })))\n     }\n \n     pub(super) fn eat_macro_def(\n@@ -1400,14 +1391,14 @@ impl<'a> Parser<'a> {\n         vis: &Visibility,\n         lo: Span,\n     ) -> PResult<'a, Option<P<Item>>> {\n-        let info = if self.eat_keyword(kw::Macro) {\n+        let (ident, kind) = if self.eat_keyword(kw::Macro) {\n             self.parse_item_decl_macro(lo)?\n         } else if self.is_macro_rules_item() {\n             self.parse_item_macro_rules(vis)?\n         } else {\n             return Ok(None);\n         };\n-        Ok(Some(self.mk_item_with_info(attrs.to_vec(), lo, vis.clone(), info)))\n+        Ok(Some(self.mk_item(lo.to(self.prev_span), ident, kind, vis.clone(), attrs.to_vec())))\n     }\n \n     fn complain_if_pub_macro(&self, vis: &VisibilityKind, sp: Span) {"}, {"sha": "754923ae55e29683494143a914bcbf3086b15af2", "filename": "src/librustc_parse/parser/module.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2026030b5d761a83d62c7e198057b119addcfd1/src%2Flibrustc_parse%2Fparser%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2026030b5d761a83d62c7e198057b119addcfd1/src%2Flibrustc_parse%2Fparser%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmodule.rs?ref=c2026030b5d761a83d62c7e198057b119addcfd1", "patch": "@@ -67,7 +67,7 @@ impl<'a> Parser<'a> {\n             (module, inner_attrs)\n         };\n         attrs.append(&mut inner_attrs);\n-        Ok((id, ItemKind::Mod(module), None))\n+        Ok((id, ItemKind::Mod(module)))\n     }\n \n     /// Given a termination token, parses all of the items in a module."}]}