{"sha": "07f807d01f191ced1d7f4857c73fc57fbe31f421", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3ZjgwN2QwMWYxOTFjZWQxZDdmNDg1N2M3M2ZjNTdmYmUzMWY0MjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-15T21:05:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-15T21:05:16Z"}, "message": "Auto merge of #24330 - pnkfelix:issue-24267, r=nikomatsakis\n\nExtend rustc::middle::dataflow to allow filtering kills from flow-exits.\r\n\r\nFix borrowck analysis so that it will not treat a break that pops through an assignment\r\n```rust\r\nx = { ... break; ... }\r\n```\r\nas a kill of the \"moved-out\" bit for `x`.\r\n\r\nFix #24267.\r\n\r\n[breaking-change], but really, its only breaking code that was already buggy.", "tree": {"sha": "aef3faf7fd71fc8001954d0bf3f11f11ddc04685", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aef3faf7fd71fc8001954d0bf3f11f11ddc04685"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07f807d01f191ced1d7f4857c73fc57fbe31f421", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07f807d01f191ced1d7f4857c73fc57fbe31f421", "html_url": "https://github.com/rust-lang/rust/commit/07f807d01f191ced1d7f4857c73fc57fbe31f421", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07f807d01f191ced1d7f4857c73fc57fbe31f421/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce27d024ff16d297ce5e5bfb7cce11810e9c9b5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce27d024ff16d297ce5e5bfb7cce11810e9c9b5e", "html_url": "https://github.com/rust-lang/rust/commit/ce27d024ff16d297ce5e5bfb7cce11810e9c9b5e"}, {"sha": "77bf827968d90594643ad0641161540ed1763730", "url": "https://api.github.com/repos/rust-lang/rust/commits/77bf827968d90594643ad0641161540ed1763730", "html_url": "https://github.com/rust-lang/rust/commit/77bf827968d90594643ad0641161540ed1763730"}], "stats": {"total": 131, "additions": 108, "deletions": 23}, "files": [{"sha": "41b4495c5f08a82b40277b4666bc8ec275dc0414", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 63, "deletions": 17, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/07f807d01f191ced1d7f4857c73fc57fbe31f421/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07f807d01f191ced1d7f4857c73fc57fbe31f421/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=07f807d01f191ced1d7f4857c73fc57fbe31f421", "patch": "@@ -64,8 +64,14 @@ pub struct DataFlowContext<'a, 'tcx: 'a, O> {\n     /// bits generated as we exit the cfg node. Updated by `add_gen()`.\n     gens: Vec<usize>,\n \n-    /// bits killed as we exit the cfg node. Updated by `add_kill()`.\n-    kills: Vec<usize>,\n+    /// bits killed as we exit the cfg node, or non-locally jump over\n+    /// it. Updated by `add_kill(KillFrom::ScopeEnd)`.\n+    scope_kills: Vec<usize>,\n+\n+    /// bits killed as we exit the cfg node directly; if it is jumped\n+    /// over, e.g. via `break`, the kills are not reflected in the\n+    /// jump's effects. Updated by `add_kill(KillFrom::Execution)`.\n+    action_kills: Vec<usize>,\n \n     /// bits that are valid on entry to the cfg node. Updated by\n     /// `propagate()`.\n@@ -130,15 +136,23 @@ impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O\n                 \"\".to_string()\n             };\n \n-            let kills = &self.kills[start .. end];\n-            let kills_str = if kills.iter().any(|&u| u != 0) {\n-                format!(\" kill: {}\", bits_to_string(kills))\n+            let action_kills = &self.action_kills[start .. end];\n+            let action_kills_str = if action_kills.iter().any(|&u| u != 0) {\n+                format!(\" action_kill: {}\", bits_to_string(action_kills))\n+            } else {\n+                \"\".to_string()\n+            };\n+\n+            let scope_kills = &self.scope_kills[start .. end];\n+            let scope_kills_str = if scope_kills.iter().any(|&u| u != 0) {\n+                format!(\" scope_kill: {}\", bits_to_string(scope_kills))\n             } else {\n                 \"\".to_string()\n             };\n \n-            try!(ps.synth_comment(format!(\"id {}: {}{}{}\", id, entry_str,\n-                                          gens_str, kills_str)));\n+            try!(ps.synth_comment(\n+                format!(\"id {}: {}{}{}{}\", id, entry_str,\n+                        gens_str, action_kills_str, scope_kills_str)));\n             try!(pp::space(&mut ps.s));\n         }\n         Ok(())\n@@ -187,6 +201,25 @@ fn build_nodeid_to_index(decl: Option<&ast::FnDecl>,\n     }\n }\n \n+/// Flag used by `add_kill` to indicate whether the provided kill\n+/// takes effect only when control flows directly through the node in\n+/// question, or if the kill's effect is associated with any\n+/// control-flow directly through or indirectly over the node.\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub enum KillFrom {\n+    /// A `ScopeEnd` kill is one that takes effect when any control\n+    /// flow goes over the node. A kill associated with the end of the\n+    /// scope of a variable declaration `let x;` is an example of a\n+    /// `ScopeEnd` kill.\n+    ScopeEnd,\n+\n+    /// An `Execution` kill is one that takes effect only when control\n+    /// flow goes through the node to completion. A kill associated\n+    /// with an assignment statement `x = expr;` is an example of an\n+    /// `Execution` kill.\n+    Execution,\n+}\n+\n impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n     pub fn new(tcx: &'a ty::ctxt<'tcx>,\n                analysis_name: &'static str,\n@@ -206,8 +239,10 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n         let entry = if oper.initial_value() { usize::MAX } else {0};\n \n-        let gens: Vec<_> = repeat(0).take(num_nodes * words_per_id).collect();\n-        let kills: Vec<_> = repeat(0).take(num_nodes * words_per_id).collect();\n+        let zeroes: Vec<_> = repeat(0).take(num_nodes * words_per_id).collect();\n+        let gens: Vec<_> = zeroes.clone();\n+        let kills1: Vec<_> = zeroes.clone();\n+        let kills2: Vec<_> = zeroes;\n         let on_entry: Vec<_> = repeat(entry).take(num_nodes * words_per_id).collect();\n \n         let nodeid_to_index = build_nodeid_to_index(decl, cfg);\n@@ -220,7 +255,8 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n             bits_per_id: bits_per_id,\n             oper: oper,\n             gens: gens,\n-            kills: kills,\n+            action_kills: kills1,\n+            scope_kills: kills2,\n             on_entry: on_entry\n         }\n     }\n@@ -240,7 +276,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         }\n     }\n \n-    pub fn add_kill(&mut self, id: ast::NodeId, bit: usize) {\n+    pub fn add_kill(&mut self, kind: KillFrom, id: ast::NodeId, bit: usize) {\n         //! Indicates that `id` kills `bit`\n         debug!(\"{} add_kill(id={}, bit={})\",\n                self.analysis_name, id, bit);\n@@ -250,7 +286,10 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         let indices = get_cfg_indices(id, &self.nodeid_to_index);\n         for &cfgidx in indices {\n             let (start, end) = self.compute_id_range(cfgidx);\n-            let kills = &mut self.kills[start.. end];\n+            let kills = match kind {\n+                KillFrom::Execution => &mut self.action_kills[start.. end],\n+                KillFrom::ScopeEnd =>  &mut self.scope_kills[start.. end],\n+            };\n             set_bit(kills, bit);\n         }\n     }\n@@ -264,7 +303,9 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         let (start, end) = self.compute_id_range(cfgidx);\n         let gens = &self.gens[start.. end];\n         bitwise(bits, gens, &Union);\n-        let kills = &self.kills[start.. end];\n+        let kills = &self.action_kills[start.. end];\n+        bitwise(bits, kills, &Subtract);\n+        let kills = &self.scope_kills[start.. end];\n         bitwise(bits, kills, &Subtract);\n \n         debug!(\"{} apply_gen_kill(cfgidx={:?}, bits={}) [after]\",\n@@ -278,7 +319,8 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n         assert!(start < self.gens.len());\n         assert!(end <= self.gens.len());\n-        assert!(self.gens.len() == self.kills.len());\n+        assert!(self.gens.len() == self.action_kills.len());\n+        assert!(self.gens.len() == self.scope_kills.len());\n         assert!(self.gens.len() == self.on_entry.len());\n \n         (start, end)\n@@ -412,7 +454,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         cfg.graph.each_edge(|_edge_index, edge| {\n             let flow_exit = edge.source();\n             let (start, end) = self.compute_id_range(flow_exit);\n-            let mut orig_kills = self.kills[start.. end].to_vec();\n+            let mut orig_kills = self.scope_kills[start.. end].to_vec();\n \n             let mut changed = false;\n             for &node_id in &edge.data.exiting_scopes {\n@@ -421,8 +463,12 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                     Some(indices) => {\n                         for &cfg_idx in indices {\n                             let (start, end) = self.compute_id_range(cfg_idx);\n-                            let kills = &self.kills[start.. end];\n+                            let kills = &self.scope_kills[start.. end];\n                             if bitwise(&mut orig_kills, kills, &Union) {\n+                                debug!(\"scope exits: scope id={} \\\n+                                        (node={:?} of {:?}) added killset: {}\",\n+                                       node_id, cfg_idx, indices,\n+                                       bits_to_string(kills));\n                                 changed = true;\n                             }\n                         }\n@@ -436,7 +482,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n             }\n \n             if changed {\n-                let bits = &mut self.kills[start.. end];\n+                let bits = &mut self.scope_kills[start.. end];\n                 debug!(\"{} add_kills_from_flow_exits flow_exit={:?} bits={} [before]\",\n                        self.analysis_name, flow_exit, mut_bits_to_string(bits));\n                 bits.clone_from_slice(&orig_kills[..]);"}, {"sha": "502321d07598cf2e058f49956a7fc529a3838048", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07f807d01f191ced1d7f4857c73fc57fbe31f421/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07f807d01f191ced1d7f4857c73fc57fbe31f421/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=07f807d01f191ced1d7f4857c73fc57fbe31f421", "patch": "@@ -24,6 +24,7 @@ use rustc::middle::cfg;\n use rustc::middle::dataflow::DataFlowContext;\n use rustc::middle::dataflow::BitwiseOperator;\n use rustc::middle::dataflow::DataFlowOperator;\n+use rustc::middle::dataflow::KillFrom;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::region;\n@@ -167,7 +168,7 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n                              all_loans.len());\n     for (loan_idx, loan) in all_loans.iter().enumerate() {\n         loan_dfcx.add_gen(loan.gen_scope.node_id(), loan_idx);\n-        loan_dfcx.add_kill(loan.kill_scope.node_id(), loan_idx);\n+        loan_dfcx.add_kill(KillFrom::ScopeEnd, loan.kill_scope.node_id(), loan_idx);\n     }\n     loan_dfcx.add_kills_from_flow_exits(cfg);\n     loan_dfcx.propagate(cfg, body);"}, {"sha": "1180717140e6d467af01ae4e4e21999f5ce62db7", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/07f807d01f191ced1d7f4857c73fc57fbe31f421/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07f807d01f191ced1d7f4857c73fc57fbe31f421/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=07f807d01f191ced1d7f4857c73fc57fbe31f421", "patch": "@@ -18,6 +18,7 @@ use rustc::middle::cfg;\n use rustc::middle::dataflow::DataFlowContext;\n use rustc::middle::dataflow::BitwiseOperator;\n use rustc::middle::dataflow::DataFlowOperator;\n+use rustc::middle::dataflow::KillFrom;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::ty;\n use rustc::util::nodemap::{FnvHashMap, NodeSet};\n@@ -473,11 +474,13 @@ impl<'tcx> MoveData<'tcx> {\n \n         for (i, assignment) in self.var_assignments.borrow().iter().enumerate() {\n             dfcx_assign.add_gen(assignment.id, i);\n-            self.kill_moves(assignment.path, assignment.id, dfcx_moves);\n+            self.kill_moves(assignment.path, assignment.id,\n+                            KillFrom::Execution, dfcx_moves);\n         }\n \n         for assignment in &*self.path_assignments.borrow() {\n-            self.kill_moves(assignment.path, assignment.id, dfcx_moves);\n+            self.kill_moves(assignment.path, assignment.id,\n+                            KillFrom::Execution, dfcx_moves);\n         }\n \n         // Kill all moves related to a variable `x` when\n@@ -487,7 +490,8 @@ impl<'tcx> MoveData<'tcx> {\n                 LpVar(..) | LpUpvar(..) | LpDowncast(..) => {\n                     let kill_scope = path.loan_path.kill_scope(tcx);\n                     let path = *self.path_map.borrow().get(&path.loan_path).unwrap();\n-                    self.kill_moves(path, kill_scope.node_id(), dfcx_moves);\n+                    self.kill_moves(path, kill_scope.node_id(),\n+                                    KillFrom::ScopeEnd, dfcx_moves);\n                 }\n                 LpExtend(..) => {}\n             }\n@@ -500,7 +504,9 @@ impl<'tcx> MoveData<'tcx> {\n             match lp.kind {\n                 LpVar(..) | LpUpvar(..) | LpDowncast(..) => {\n                     let kill_scope = lp.kill_scope(tcx);\n-                    dfcx_assign.add_kill(kill_scope.node_id(), assignment_index);\n+                    dfcx_assign.add_kill(KillFrom::ScopeEnd,\n+                                         kill_scope.node_id(),\n+                                         assignment_index);\n                 }\n                 LpExtend(..) => {\n                     tcx.sess.bug(\"var assignment for non var path\");\n@@ -568,6 +574,7 @@ impl<'tcx> MoveData<'tcx> {\n     fn kill_moves(&self,\n                   path: MovePathIndex,\n                   kill_id: ast::NodeId,\n+                  kill_kind: KillFrom,\n                   dfcx_moves: &mut MoveDataFlow) {\n         // We can only perform kills for paths that refer to a unique location,\n         // since otherwise we may kill a move from one location with an\n@@ -576,7 +583,9 @@ impl<'tcx> MoveData<'tcx> {\n         let loan_path = self.path_loan_path(path);\n         if loan_path_is_precise(&*loan_path) {\n             self.each_applicable_move(path, |move_index| {\n-                dfcx_moves.add_kill(kill_id, move_index.get());\n+                debug!(\"kill_moves add_kill {:?} kill_id={} move_index={}\",\n+                       kill_kind, kill_id, move_index.get());\n+                dfcx_moves.add_kill(kill_kind, kill_id, move_index.get());\n                 true\n             });\n         }"}, {"sha": "4aca6bf38e1c49f637fe56c0c97ab788ec2dad63", "filename": "src/test/compile-fail/issue-24267-flow-exit.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/07f807d01f191ced1d7f4857c73fc57fbe31f421/src%2Ftest%2Fcompile-fail%2Fissue-24267-flow-exit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07f807d01f191ced1d7f4857c73fc57fbe31f421/src%2Ftest%2Fcompile-fail%2Fissue-24267-flow-exit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-24267-flow-exit.rs?ref=07f807d01f191ced1d7f4857c73fc57fbe31f421", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Ensure that we reject code when a nonlocal exit (`break`,\n+// `continue`) causes us to pop over a needed assignment.\n+\n+pub fn main() {\n+    foo1();\n+    foo2();\n+}\n+\n+pub fn foo1() {\n+    let x: i32;\n+    loop { x = break; }\n+    println!(\"{}\", x); //~ ERROR use of possibly uninitialized variable: `x`\n+}\n+\n+pub fn foo2() {\n+    let x: i32;\n+    for _ in 0..10 { x = continue; }\n+    println!(\"{}\", x); //~ ERROR use of possibly uninitialized variable: `x`\n+}"}]}