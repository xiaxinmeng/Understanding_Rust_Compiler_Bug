{"sha": "08646c6c2c167d4c04897660dc524623d349bdb1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4NjQ2YzZjMmMxNjdkNGMwNDg5NzY2MGRjNTI0NjIzZDM0OWJkYjE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-12-16T21:34:43Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-12-17T14:34:54Z"}, "message": "miri: use separate Pointer and Align instead of PtrAndAlign.", "tree": {"sha": "4de5db7e0a7e7bf0f2c38e5e00d81c5d7bd84867", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4de5db7e0a7e7bf0f2c38e5e00d81c5d7bd84867"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08646c6c2c167d4c04897660dc524623d349bdb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08646c6c2c167d4c04897660dc524623d349bdb1", "html_url": "https://github.com/rust-lang/rust/commit/08646c6c2c167d4c04897660dc524623d349bdb1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08646c6c2c167d4c04897660dc524623d349bdb1/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff080d389dac079b3c7c8a7ad88b99660b05afa0", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff080d389dac079b3c7c8a7ad88b99660b05afa0", "html_url": "https://github.com/rust-lang/rust/commit/ff080d389dac079b3c7c8a7ad88b99660b05afa0"}], "stats": {"total": 290, "additions": 113, "deletions": 177}, "files": [{"sha": "6785e06ae35eb5bb03ad5428a0006bfddc06cd6c", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08646c6c2c167d4c04897660dc524623d349bdb1/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08646c6c2c167d4c04897660dc524623d349bdb1/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=08646c6c2c167d4c04897660dc524623d349bdb1", "patch": "@@ -10,7 +10,7 @@ mod value;\n \n pub use self::error::{EvalError, EvalResult, EvalErrorKind};\n \n-pub use self::value::{PrimVal, PrimValKind, Value, Pointer, PtrAndAlign, bytes_to_f32, bytes_to_f64};\n+pub use self::value::{PrimVal, PrimValKind, Value, Pointer, bytes_to_f32, bytes_to_f64};\n \n use std::collections::BTreeMap;\n use ty::layout::HasDataLayout;"}, {"sha": "0bfff2a80e6783bdf2f9a517f317cc5e3b799146", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/08646c6c2c167d4c04897660dc524623d349bdb1/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08646c6c2c167d4c04897660dc524623d349bdb1/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=08646c6c2c167d4c04897660dc524623d349bdb1", "patch": "@@ -6,24 +6,6 @@ use super::{EvalResult, MemoryPointer, PointerArithmetic};\n use syntax::ast::FloatTy;\n use rustc_const_math::ConstFloat;\n \n-#[derive(Copy, Clone, Debug)]\n-pub struct PtrAndAlign {\n-    pub ptr: Pointer,\n-    pub align: Align,\n-}\n-\n-impl PtrAndAlign {\n-    pub fn to_ptr<'tcx>(self) -> EvalResult<'tcx, MemoryPointer> {\n-        self.ptr.to_ptr()\n-    }\n-    pub fn offset<'tcx, C: HasDataLayout>(self, i: u64, cx: C) -> EvalResult<'tcx, Self> {\n-        Ok(PtrAndAlign {\n-            ptr: self.ptr.offset(i, cx)?,\n-            align: self.align,\n-        })\n-    }\n-}\n-\n pub fn bytes_to_f32(bits: u128) -> ConstFloat {\n     ConstFloat {\n         bits,\n@@ -49,7 +31,7 @@ pub fn bytes_to_f64(bits: u128) -> ConstFloat {\n /// operations and fat pointers. This idea was taken from rustc's trans.\n #[derive(Clone, Copy, Debug)]\n pub enum Value {\n-    ByRef(PtrAndAlign),\n+    ByRef(Pointer, Align),\n     ByVal(PrimVal),\n     ByValPair(PrimVal, PrimVal),\n }"}, {"sha": "15840bffbdee8419dd7a3185f2c6e906b16f9639", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 38, "deletions": 60, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/08646c6c2c167d4c04897660dc524623d349bdb1/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08646c6c2c167d4c04897660dc524623d349bdb1/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=08646c6c2c167d4c04897660dc524623d349bdb1", "patch": "@@ -12,8 +12,8 @@ use rustc_data_structures::indexed_vec::Idx;\n use syntax::ast::Mutability;\n use syntax::codemap::Span;\n \n-use rustc::mir::interpret::{EvalResult, EvalError, EvalErrorKind, GlobalId, Value, Pointer, PrimVal, PtrAndAlign};\n-use super::{Place, PlaceExtra, EvalContext, StackPopCleanup, ValTy, HasMemory};\n+use rustc::mir::interpret::{EvalResult, EvalError, EvalErrorKind, GlobalId, Value, Pointer, PrimVal};\n+use super::{Place, EvalContext, StackPopCleanup, ValTy};\n \n use rustc_const_math::ConstInt;\n \n@@ -357,11 +357,9 @@ pub fn const_eval_provider<'a, 'tcx>(\n             (_, Err(err)) => Err(err),\n             (Ok((miri_val, miri_ty)), Ok(ctfe)) => {\n                 let mut ecx = mk_eval_cx(tcx, instance, key.param_env).unwrap();\n-                let miri_ptr = PtrAndAlign {\n-                    ptr: miri_val,\n-                    align: ecx.layout_of(miri_ty).unwrap().align\n-                };\n-                check_ctfe_against_miri(&mut ecx, miri_ptr, miri_ty, ctfe.val);\n+                let layout = ecx.layout_of(miri_ty).unwrap();\n+                let miri_place = Place::from_primval_ptr(miri_val, layout.align);\n+                check_ctfe_against_miri(&mut ecx, miri_place, miri_ty, ctfe.val);\n                 Ok(ctfe)\n             }\n         }\n@@ -372,60 +370,49 @@ pub fn const_eval_provider<'a, 'tcx>(\n \n fn check_ctfe_against_miri<'a, 'tcx>(\n     ecx: &mut EvalContext<'a, 'tcx, CompileTimeEvaluator>,\n-    miri_val: PtrAndAlign,\n+    miri_place: Place,\n     miri_ty: Ty<'tcx>,\n     ctfe: ConstVal<'tcx>,\n ) {\n     use rustc::middle::const_val::ConstAggregate::*;\n     use rustc_const_math::ConstFloat;\n     use rustc::ty::TypeVariants::*;\n+    let miri_val = ValTy {\n+        value: ecx.read_place(miri_place).unwrap(),\n+        ty: miri_ty\n+    };\n     match miri_ty.sty {\n         TyInt(int_ty) => {\n-            let value = ecx.read_with_align(miri_val.align, |ectx| {\n-                ectx.try_read_value(miri_val.ptr, miri_ty)\n-            });\n-            let prim = get_prim(ecx, value);\n+            let prim = get_prim(ecx, miri_val);\n             let c = ConstInt::new_signed_truncating(prim as i128,\n                                                     int_ty,\n                                                     ecx.tcx.sess.target.isize_ty);\n             let c = ConstVal::Integral(c);\n             assert_eq!(c, ctfe, \"miri evaluated to {:?}, but ctfe yielded {:?}\", c, ctfe);\n         },\n         TyUint(uint_ty) => {\n-            let value = ecx.read_with_align(miri_val.align, |ectx| {\n-                ectx.try_read_value(miri_val.ptr, miri_ty)\n-            });\n-            let prim = get_prim(ecx, value);\n+            let prim = get_prim(ecx, miri_val);\n             let c = ConstInt::new_unsigned_truncating(prim,\n                                                      uint_ty,\n                                                      ecx.tcx.sess.target.usize_ty);\n             let c = ConstVal::Integral(c);\n             assert_eq!(c, ctfe, \"miri evaluated to {:?}, but ctfe yielded {:?}\", c, ctfe);\n         },\n         TyFloat(ty) => {\n-            let value = ecx.read_with_align(miri_val.align, |ectx| {\n-                ectx.try_read_value(miri_val.ptr, miri_ty)\n-            });\n-            let prim = get_prim(ecx, value);\n+            let prim = get_prim(ecx, miri_val);\n             let f = ConstVal::Float(ConstFloat { bits: prim, ty });\n             assert_eq!(f, ctfe, \"miri evaluated to {:?}, but ctfe yielded {:?}\", f, ctfe);\n         },\n         TyBool => {\n-            let value = ecx.read_with_align(miri_val.align, |ectx| {\n-                ectx.try_read_value(miri_val.ptr, miri_ty)\n-            });\n-            let bits = get_prim(ecx, value);\n+            let bits = get_prim(ecx, miri_val);\n             if bits > 1 {\n                 bug!(\"miri evaluated to {}, but expected a bool {:?}\", bits, ctfe);\n             }\n             let b = ConstVal::Bool(bits == 1);\n             assert_eq!(b, ctfe, \"miri evaluated to {:?}, but ctfe yielded {:?}\", b, ctfe);\n         },\n         TyChar => {\n-            let value = ecx.read_with_align(miri_val.align, |ectx| {\n-                ectx.try_read_value(miri_val.ptr, miri_ty)\n-            });\n-            let bits = get_prim(ecx, value);\n+            let bits = get_prim(ecx, miri_val);\n             if let Some(cm) = ::std::char::from_u32(bits as u32) {\n                 assert_eq!(\n                     ConstVal::Char(cm), ctfe,\n@@ -436,10 +423,8 @@ fn check_ctfe_against_miri<'a, 'tcx>(\n             }\n         },\n         TyStr => {\n-            let value = ecx.read_with_align(miri_val.align, |ectx| {\n-                ectx.try_read_value(miri_val.ptr, miri_ty)\n-            });\n-            if let Ok(Some(Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::Bytes(len)))) = value {\n+            let value = ecx.follow_by_ref_value(miri_val.value, miri_val.ty);\n+            if let Ok(Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::Bytes(len))) = value {\n                 let bytes = ecx\n                     .memory\n                     .read_bytes(ptr.into(), len as u64)\n@@ -463,7 +448,6 @@ fn check_ctfe_against_miri<'a, 'tcx>(\n         },\n         TyArray(elem_ty, n) => {\n             let n = n.val.to_const_int().unwrap().to_u64().unwrap();\n-            let size = ecx.layout_of(elem_ty).unwrap().size.bytes();\n             let vec: Vec<(ConstVal, Ty<'tcx>)> = match ctfe {\n                 ConstVal::ByteStr(arr) => arr.data.iter().map(|&b| {\n                     (ConstVal::Integral(ConstInt::U8(b)), ecx.tcx.types.u8)\n@@ -476,10 +460,12 @@ fn check_ctfe_against_miri<'a, 'tcx>(\n                 },\n                 _ => bug!(\"miri produced {:?}, but ctfe yielded {:?}\", miri_ty, ctfe),\n             };\n+            let layout = ecx.layout_of(miri_ty).unwrap();\n             for (i, elem) in vec.into_iter().enumerate() {\n                 assert!((i as u64) < n);\n-                let ptr = miri_val.offset(size * i as u64, &ecx).unwrap();\n-                check_ctfe_against_miri(ecx, ptr, elem_ty, elem.0);\n+                let (field_place, _) =\n+                    ecx.place_field(miri_place, Field::new(i), layout).unwrap();\n+                check_ctfe_against_miri(ecx, field_place, elem_ty, elem.0);\n             }\n         },\n         TyTuple(..) => {\n@@ -489,22 +475,22 @@ fn check_ctfe_against_miri<'a, 'tcx>(\n             };\n             let layout = ecx.layout_of(miri_ty).unwrap();\n             for (i, elem) in vec.into_iter().enumerate() {\n-                let offset = layout.fields.offset(i);\n-                let ptr = miri_val.offset(offset.bytes(), &ecx).unwrap();\n-                check_ctfe_against_miri(ecx, ptr, elem.ty, elem.val);\n+                let (field_place, _) =\n+                    ecx.place_field(miri_place, Field::new(i), layout).unwrap();\n+                check_ctfe_against_miri(ecx, field_place, elem.ty, elem.val);\n             }\n         },\n         TyAdt(def, _) => {\n-            let (struct_variant, extra) = if def.is_enum() {\n-                let discr = ecx.read_discriminant_value(\n-                    Place::Ptr { ptr: miri_val, extra: PlaceExtra::None },\n-                    miri_ty).unwrap();\n+            let mut miri_place = miri_place;\n+            let struct_variant = if def.is_enum() {\n+                let discr = ecx.read_discriminant_value(miri_place, miri_ty).unwrap();\n                 let variant = def.discriminants(ecx.tcx).position(|variant_discr| {\n                     variant_discr.to_u128_unchecked() == discr\n                 }).expect(\"miri produced invalid enum discriminant\");\n-                (&def.variants[variant], PlaceExtra::DowncastVariant(variant))\n+                miri_place = ecx.place_downcast(miri_place, variant).unwrap();\n+                &def.variants[variant]\n             } else {\n-                (def.struct_variant(), PlaceExtra::None)\n+                def.struct_variant()\n             };\n             let vec = match ctfe {\n                 ConstVal::Aggregate(Struct(v)) => v,\n@@ -518,12 +504,9 @@ fn check_ctfe_against_miri<'a, 'tcx>(\n             let layout = ecx.layout_of(miri_ty).unwrap();\n             for &(name, elem) in vec.into_iter() {\n                 let field = struct_variant.fields.iter().position(|f| f.name == name).unwrap();\n-                let (place, _) = ecx.place_field(\n-                    Place::Ptr { ptr: miri_val, extra },\n-                    Field::new(field),\n-                    layout,\n-                ).unwrap();\n-                check_ctfe_against_miri(ecx, place.to_ptr_align(), elem.ty, elem.val);\n+                let (field_place, _) =\n+                    ecx.place_field(miri_place, Field::new(field), layout).unwrap();\n+                check_ctfe_against_miri(ecx, field_place, elem.ty, elem.val);\n             }\n         },\n         TySlice(_) => bug!(\"miri produced a slice?\"),\n@@ -543,11 +526,9 @@ fn check_ctfe_against_miri<'a, 'tcx>(\n         // should be fine\n         TyFnDef(..) => {}\n         TyFnPtr(_) => {\n-            let value = ecx.read_with_align(miri_val.align, |ectx| {\n-                ectx.try_read_value(miri_val.ptr, miri_ty)\n-            });\n+            let value = ecx.value_to_primval(miri_val);\n             let ptr = match value {\n-                Ok(Some(Value::ByVal(PrimVal::Ptr(ptr)))) => ptr,\n+                Ok(PrimVal::Ptr(ptr)) => ptr,\n                 value => bug!(\"expected fn ptr, got {:?}\", value),\n             };\n             let inst = ecx.memory.get_fn(ptr).unwrap();\n@@ -569,13 +550,10 @@ fn check_ctfe_against_miri<'a, 'tcx>(\n \n fn get_prim<'a, 'tcx>(\n     ecx: &mut EvalContext<'a, 'tcx, CompileTimeEvaluator>,\n-    res: Result<Option<Value>, EvalError<'tcx>>,\n+    val: ValTy<'tcx>,\n ) -> u128 {\n-    match res {\n-        Ok(Some(Value::ByVal(prim))) => unwrap_miri(ecx, prim.to_bytes()),\n-        Err(err) => unwrap_miri(ecx, Err(err)),\n-        val => bug!(\"got {:?}\", val),\n-    }\n+    let res = ecx.value_to_primval(val).and_then(|prim| prim.to_bytes());\n+    unwrap_miri(ecx, res)\n }\n \n fn unwrap_miri<'a, 'tcx, T>("}, {"sha": "bc0d82399b597127ce833aaf123753ac9bbc2346", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 20, "deletions": 38, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/08646c6c2c167d4c04897660dc524623d349bdb1/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08646c6c2c167d4c04897660dc524623d349bdb1/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=08646c6c2c167d4c04897660dc524623d349bdb1", "patch": "@@ -13,7 +13,7 @@ use rustc_data_structures::indexed_vec::Idx;\n use syntax::codemap::{self, DUMMY_SP};\n use syntax::ast::Mutability;\n use rustc::mir::interpret::{\n-    PtrAndAlign, GlobalId, Value, Pointer, PrimVal, PrimValKind,\n+    GlobalId, Value, Pointer, PrimVal, PrimValKind,\n     EvalError, EvalResult, EvalErrorKind, MemoryPointer,\n };\n \n@@ -498,7 +498,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     }\n \n     pub fn deallocate_local(&mut self, local: Option<Value>) -> EvalResult<'tcx> {\n-        if let Some(Value::ByRef(ptr)) = local {\n+        if let Some(Value::ByRef(ptr, _align)) = local {\n             trace!(\"deallocating local\");\n             let ptr = ptr.to_ptr()?;\n             self.memory.dump_alloc(ptr.alloc_id);\n@@ -637,12 +637,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 let src = self.eval_place(place)?;\n                 // We ignore the alignment of the place here -- special handling for packed structs ends\n                 // at the `&` operator.\n-                let (ptr, extra) = self.force_allocation(src)?.to_ptr_align_extra();\n+                let (ptr, _align, extra) = self.force_allocation(src)?.to_ptr_align_extra();\n \n                 let val = match extra {\n-                    PlaceExtra::None => ptr.ptr.to_value(),\n-                    PlaceExtra::Length(len) => ptr.ptr.to_value_with_len(len),\n-                    PlaceExtra::Vtable(vtable) => ptr.ptr.to_value_with_vtable(vtable),\n+                    PlaceExtra::None => ptr.to_value(),\n+                    PlaceExtra::Length(len) => ptr.to_value_with_len(len),\n+                    PlaceExtra::Vtable(vtable) => ptr.to_value_with_vtable(vtable),\n                     PlaceExtra::DowncastVariant(..) => {\n                         bug!(\"attempted to take a reference to an enum downcast place\")\n                     }\n@@ -951,10 +951,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     }\n \n     pub fn read_global_as_value(&self, gid: GlobalId, layout: TyLayout) -> Value {\n-        Value::ByRef(PtrAndAlign {\n-            ptr: self.tcx.interpret_interner.borrow().get_cached(gid).expect(\"global not cached\"),\n-            align: layout.align\n-        })\n+        Value::ByRef(self.tcx.interpret_interner.borrow().get_cached(gid).expect(\"global not cached\"),\n+                     layout.align)\n     }\n \n     fn copy(&mut self, src: Pointer, dest: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx> {\n@@ -972,9 +970,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 // -1 since we don't store the return value\n                 match self.stack[frame].locals[local.index() - 1] {\n                     None => return err!(DeadLocal),\n-                    Some(Value::ByRef(ptr)) => {\n+                    Some(Value::ByRef(ptr, align)) => {\n                         Place::Ptr {\n                             ptr,\n+                            align,\n                             extra: PlaceExtra::None,\n                         }\n                     }\n@@ -984,10 +983,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         let layout = self.layout_of(ty)?;\n                         let ptr = self.alloc_ptr(ty)?;\n                         self.stack[frame].locals[local.index() - 1] =\n-                            Some(Value::ByRef(PtrAndAlign {\n-                                ptr: ptr.into(),\n-                                align: layout.align\n-                            })); // it stays live\n+                            Some(Value::ByRef(ptr.into(), layout.align)); // it stays live\n                         self.write_value_to_ptr(val, ptr.into(), ty)?;\n                         Place::from_ptr(ptr, layout.align)\n                     }\n@@ -1005,7 +1001,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, Value> {\n         match value {\n-            Value::ByRef(PtrAndAlign { ptr, align }) => {\n+            Value::ByRef(ptr, align) => {\n                 self.read_with_align(align, |ectx| ectx.read_value(ptr, ty))\n             }\n             other => Ok(other),\n@@ -1061,10 +1057,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         // correct if we never look at this data with the wrong type.\n \n         match dest {\n-            Place::Ptr {\n-                ptr: PtrAndAlign { ptr, align },\n-                extra,\n-            } => {\n+            Place::Ptr { ptr, align, extra } => {\n                 assert_eq!(extra, PlaceExtra::None);\n                 self.write_with_align_mut(align,\n                     |ectx| ectx.write_value_to_ptr(src_val, ptr, dest_ty))\n@@ -1090,11 +1083,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         old_dest_val: Value,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n-        if let Value::ByRef(PtrAndAlign {\n-                                ptr: dest_ptr,\n-                                align,\n-                            }) = old_dest_val\n-        {\n+        if let Value::ByRef(dest_ptr, align) = old_dest_val {\n             // If the value is already `ByRef` (that is, backed by an `Allocation`),\n             // then we must write the new value into this allocation, because there may be\n             // other pointers into the allocation. These other pointers are logically\n@@ -1106,11 +1095,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 ectx.write_value_to_ptr(src_val, dest_ptr, dest_ty)\n             })?;\n \n-        } else if let Value::ByRef(PtrAndAlign {\n-                                       ptr: src_ptr,\n-                                       align,\n-                                   }) = src_val\n-        {\n+        } else if let Value::ByRef(src_ptr, align) = src_val {\n             // If the value is not `ByRef`, then we know there are no pointers to it\n             // and we can simply overwrite the `Value` in the locals array directly.\n             //\n@@ -1129,10 +1114,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     let dest_ptr = ectx.alloc_ptr(dest_ty)?.into();\n                     ectx.copy(src_ptr, dest_ptr, dest_ty)?;\n                     let layout = ectx.layout_of(dest_ty)?;\n-                    write_dest(ectx, Value::ByRef(PtrAndAlign {\n-                        ptr: dest_ptr,\n-                        align: layout.align\n-                    }))?;\n+                    write_dest(ectx, Value::ByRef(dest_ptr, layout.align))?;\n                 }\n                 Ok(())\n             })?;\n@@ -1153,7 +1135,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     ) -> EvalResult<'tcx> {\n         trace!(\"write_value_to_ptr: {:#?}\", value);\n         match value {\n-            Value::ByRef(PtrAndAlign { ptr, align }) => {\n+            Value::ByRef(ptr, align) => {\n                 self.read_with_align_mut(align, |ectx| ectx.copy(ptr, dest, dest_ty))\n             }\n             Value::ByVal(primval) => {\n@@ -1485,7 +1467,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         continue;\n                     }\n                     let (src_f_value, src_field) = match src {\n-                        Value::ByRef(PtrAndAlign { ptr, align }) => {\n+                        Value::ByRef(ptr, align) => {\n                             let src_place = Place::from_primval_ptr(ptr, align);\n                             let (src_f_place, src_field) =\n                                 self.place_field(src_place, mir::Field::new(i), src_layout)?;\n@@ -1537,7 +1519,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     Err(err) => {\n                         panic!(\"Failed to access local: {:?}\", err);\n                     }\n-                    Ok(Value::ByRef(PtrAndAlign { ptr, align })) => {\n+                    Ok(Value::ByRef(ptr, align)) => {\n                         match ptr.into_inner_primval() {\n                             PrimVal::Ptr(ptr) => {\n                                 write!(msg, \" by align({}) ref:\", align.abi()).unwrap();\n@@ -1566,7 +1548,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 trace!(\"{}\", msg);\n                 self.memory.dump_allocs(allocs);\n             }\n-            Place::Ptr { ptr: PtrAndAlign { ptr, align }, .. } => {\n+            Place::Ptr { ptr, align, .. } => {\n                 match ptr.into_inner_primval() {\n                     PrimVal::Ptr(ptr) => {\n                         trace!(\"by align({}) ref:\", align.abi());"}, {"sha": "807b75a9e59942701fb7ca89f13189aed9e2eb78", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/08646c6c2c167d4c04897660dc524623d349bdb1/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08646c6c2c167d4c04897660dc524623d349bdb1/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=08646c6c2c167d4c04897660dc524623d349bdb1", "patch": "@@ -7,7 +7,7 @@ use rustc::ty::{Instance, TyCtxt};\n use rustc::ty::layout::{self, Align, TargetDataLayout};\n use syntax::ast::Mutability;\n \n-use rustc::mir::interpret::{MemoryPointer, AllocId, Allocation, AccessKind, UndefMask, PtrAndAlign, Value, Pointer,\n+use rustc::mir::interpret::{MemoryPointer, AllocId, Allocation, AccessKind, UndefMask, Value, Pointer,\n                             EvalResult, PrimVal, EvalErrorKind};\n \n use super::{EvalContext, Machine};\n@@ -1046,7 +1046,7 @@ pub trait HasMemory<'a, 'tcx: 'a, M: Machine<'tcx>> {\n         value: Value,\n     ) -> EvalResult<'tcx, Pointer> {\n         Ok(match value {\n-            Value::ByRef(PtrAndAlign { ptr, align }) => {\n+            Value::ByRef(ptr, align) => {\n                 self.memory().read_with_align(align, |mem| mem.read_ptr_sized_unsigned(ptr.to_ptr()?))?\n             }\n             Value::ByVal(ptr) |\n@@ -1059,10 +1059,7 @@ pub trait HasMemory<'a, 'tcx: 'a, M: Machine<'tcx>> {\n         value: Value,\n     ) -> EvalResult<'tcx, (Pointer, MemoryPointer)> {\n         match value {\n-            Value::ByRef(PtrAndAlign {\n-                      ptr: ref_ptr,\n-                      align,\n-                  }) => {\n+            Value::ByRef(ref_ptr, align) => {\n                 self.memory().read_with_align(align, |mem| {\n                     let ptr = mem.read_ptr_sized_unsigned(ref_ptr.to_ptr()?)?.into();\n                     let vtable = mem.read_ptr_sized_unsigned(\n@@ -1084,10 +1081,7 @@ pub trait HasMemory<'a, 'tcx: 'a, M: Machine<'tcx>> {\n         value: Value,\n     ) -> EvalResult<'tcx, (Pointer, u64)> {\n         match value {\n-            Value::ByRef(PtrAndAlign {\n-                      ptr: ref_ptr,\n-                      align,\n-                  }) => {\n+            Value::ByRef(ref_ptr, align) => {\n                 self.memory().read_with_align(align, |mem| {\n                     let ptr = mem.read_ptr_sized_unsigned(ref_ptr.to_ptr()?)?.into();\n                     let len = mem.read_ptr_sized_unsigned("}, {"sha": "097f769adcf1f3ac92b07068aee9c3badd7eadbe", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 39, "deletions": 40, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/08646c6c2c167d4c04897660dc524623d349bdb1/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08646c6c2c167d4c04897660dc524623d349bdb1/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=08646c6c2c167d4c04897660dc524623d349bdb1", "patch": "@@ -2,9 +2,8 @@ use rustc::mir;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, Align, LayoutOf, TyLayout};\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc::mir::interpret::{GlobalId, PtrAndAlign};\n \n-use rustc::mir::interpret::{Value, PrimVal, EvalResult, Pointer, MemoryPointer};\n+use rustc::mir::interpret::{GlobalId, Value, PrimVal, EvalResult, Pointer, MemoryPointer};\n use super::{EvalContext, Machine, ValTy};\n use interpret::memory::HasMemory;\n \n@@ -15,7 +14,8 @@ pub enum Place {\n         /// An place may have an invalid (integral or undef) pointer,\n         /// since it might be turned back into a reference\n         /// before ever being dereferenced.\n-        ptr: PtrAndAlign,\n+        ptr: Pointer,\n+        align: Align,\n         extra: PlaceExtra,\n     },\n \n@@ -40,7 +40,8 @@ impl<'tcx> Place {\n \n     pub fn from_primval_ptr(ptr: Pointer, align: Align) -> Self {\n         Place::Ptr {\n-            ptr: PtrAndAlign { ptr, align },\n+            ptr,\n+            align,\n             extra: PlaceExtra::None,\n         }\n     }\n@@ -49,23 +50,23 @@ impl<'tcx> Place {\n         Self::from_primval_ptr(ptr.into(), align)\n     }\n \n-    pub fn to_ptr_align_extra(self) -> (PtrAndAlign, PlaceExtra) {\n+    pub fn to_ptr_align_extra(self) -> (Pointer, Align, PlaceExtra) {\n         match self {\n-            Place::Ptr { ptr, extra } => (ptr, extra),\n+            Place::Ptr { ptr, align, extra } => (ptr, align, extra),\n             _ => bug!(\"to_ptr_and_extra: expected Place::Ptr, got {:?}\", self),\n \n         }\n     }\n \n-    pub fn to_ptr_align(self) -> PtrAndAlign {\n-        let (ptr, _extra) = self.to_ptr_align_extra();\n-        ptr\n+    pub fn to_ptr_align(self) -> (Pointer, Align) {\n+        let (ptr, align, _extra) = self.to_ptr_align_extra();\n+        (ptr, align)\n     }\n \n     pub fn to_ptr(self) -> EvalResult<'tcx, MemoryPointer> {\n         // At this point, we forget about the alignment information -- the place has been turned into a reference,\n         // and no matter where it came from, it now must be aligned.\n-        self.to_ptr_align().to_ptr()\n+        self.to_ptr_align().0.to_ptr()\n     }\n \n     pub(super) fn elem_ty_and_len(self, ty: Ty<'tcx>) -> (Ty<'tcx>, u64) {\n@@ -169,9 +170,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n     pub fn read_place(&self, place: Place) -> EvalResult<'tcx, Value> {\n         match place {\n-            Place::Ptr { ptr, extra } => {\n+            Place::Ptr { ptr, align, extra } => {\n                 assert_eq!(extra, PlaceExtra::None);\n-                Ok(Value::ByRef(ptr))\n+                Ok(Value::ByRef(ptr, align))\n             }\n             Place::Local { frame, local } => self.stack[frame].get_local(local),\n         }\n@@ -194,10 +195,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 };\n                 let layout = self.layout_of(self.place_ty(mir_place))?;\n                 Place::Ptr {\n-                    ptr: PtrAndAlign {\n-                        ptr: self.tcx.interpret_interner.borrow().get_cached(gid).expect(\"uncached global\"),\n-                        align: layout.align\n-                    },\n+                    ptr: self.tcx.interpret_interner.borrow().get_cached(gid).expect(\"uncached global\"),\n+                    align: layout.align,\n                     extra: PlaceExtra::None,\n                 }\n             }\n@@ -233,8 +232,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         let offset = base_layout.fields.offset(field_index);\n \n         // Do not allocate in trivial cases\n-        let (base_ptr, base_extra) = match base {\n-            Place::Ptr { ptr, extra } => (ptr, extra),\n+        let (base_ptr, base_align, base_extra) = match base {\n+            Place::Ptr { ptr, align, extra } => (ptr, align, extra),\n             Place::Local { frame, local } => {\n                 match (&self.stack[frame].get_local(local)?, &base_layout.abi) {\n                     // in case the field covers the entire type, just return the value\n@@ -253,16 +252,15 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             PlaceExtra::Vtable(tab) => {\n                 let (_, align) = self.size_and_align_of_dst(\n                     base_layout.ty,\n-                    base_ptr.ptr.to_value_with_vtable(tab),\n+                    base_ptr.to_value_with_vtable(tab),\n                 )?;\n                 offset.abi_align(align).bytes()\n             }\n             _ => offset.bytes(),\n         };\n \n-        let mut ptr = base_ptr.offset(offset, &self)?;\n-        ptr.align = ptr.align.min(base_layout.align).min(field.align);\n-\n+        let ptr = base_ptr.offset(offset, &self)?;\n+        let align = base_align.min(base_layout.align).min(field.align);\n         let extra = if !field.is_unsized() {\n             PlaceExtra::None\n         } else {\n@@ -277,7 +275,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             base_extra\n         };\n \n-        Ok((Place::Ptr { ptr, extra }, field))\n+        Ok((Place::Ptr { ptr, align, extra }, field))\n     }\n \n     pub fn val_to_place(&self, val: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Place> {\n@@ -286,14 +284,16 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             ty::TyDynamic(..) => {\n                 let (ptr, vtable) = self.into_ptr_vtable_pair(val)?;\n                 Place::Ptr {\n-                    ptr: PtrAndAlign { ptr, align: layout.align },\n+                    ptr,\n+                    align: layout.align,\n                     extra: PlaceExtra::Vtable(vtable),\n                 }\n             }\n             ty::TyStr | ty::TySlice(_) => {\n                 let (ptr, len) = self.into_slice(val)?;\n                 Place::Ptr {\n-                    ptr: PtrAndAlign { ptr, align: layout.align },\n+                    ptr,\n+                    align: layout.align,\n                     extra: PlaceExtra::Length(len),\n                 }\n             }\n@@ -309,7 +309,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     ) -> EvalResult<'tcx, Place> {\n         // Taking the outer type here may seem odd; it's needed because for array types, the outer type gives away the length.\n         let base = self.force_allocation(base)?;\n-        let base_ptr = base.to_ptr_align();\n+        let (base_ptr, align) = base.to_ptr_align();\n \n         let (elem_ty, len) = base.elem_ty_and_len(outer_ty);\n         let elem_size = self.layout_of(elem_ty)?.size.bytes();\n@@ -322,6 +322,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         let ptr = base_ptr.offset(n * elem_size, &*self)?;\n         Ok(Place::Ptr {\n             ptr,\n+            align,\n             extra: PlaceExtra::None,\n         })\n     }\n@@ -333,9 +334,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     ) -> EvalResult<'tcx, Place> {\n         // FIXME(solson)\n         let base = self.force_allocation(base)?;\n-        let ptr = base.to_ptr_align();\n+        let (ptr, align) = base.to_ptr_align();\n         let extra = PlaceExtra::DowncastVariant(variant);\n-        Ok(Place::Ptr { ptr, extra })\n+        Ok(Place::Ptr { ptr, align, extra })\n     }\n \n     pub fn eval_place_projection(\n@@ -345,14 +346,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         proj_elem: &mir::ProjectionElem<'tcx, mir::Local, Ty<'tcx>>,\n     ) -> EvalResult<'tcx, Place> {\n         use rustc::mir::ProjectionElem::*;\n-        let (ptr, extra) = match *proj_elem {\n+        match *proj_elem {\n             Field(field, _) => {\n                 let layout = self.layout_of(base_ty)?;\n-                return Ok(self.place_field(base, field, layout)?.0);\n+                Ok(self.place_field(base, field, layout)?.0)\n             }\n \n             Downcast(_, variant) => {\n-                return self.place_downcast(base, variant);\n+                self.place_downcast(base, variant)\n             }\n \n             Deref => {\n@@ -367,14 +368,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n                 trace!(\"deref to {} on {:?}\", pointee_type, val);\n \n-                return self.val_to_place(val, pointee_type);\n+                self.val_to_place(val, pointee_type)\n             }\n \n             Index(local) => {\n                 let value = self.frame().get_local(local)?;\n                 let ty = self.tcx.types.usize;\n                 let n = self.value_to_primval(ValTy { value, ty })?.to_u64()?;\n-                return self.place_index(base, base_ty, n);\n+                self.place_index(base, base_ty, n)\n             }\n \n             ConstantIndex {\n@@ -384,7 +385,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             } => {\n                 // FIXME(solson)\n                 let base = self.force_allocation(base)?;\n-                let base_ptr = base.to_ptr_align();\n+                let (base_ptr, align) = base.to_ptr_align();\n \n                 let (elem_ty, n) = base.elem_ty_and_len(base_ty);\n                 let elem_size = self.layout_of(elem_ty)?.size.bytes();\n@@ -397,13 +398,13 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 };\n \n                 let ptr = base_ptr.offset(index * elem_size, &self)?;\n-                (ptr, PlaceExtra::None)\n+                Ok(Place::Ptr { ptr, align, extra: PlaceExtra::None })\n             }\n \n             Subslice { from, to } => {\n                 // FIXME(solson)\n                 let base = self.force_allocation(base)?;\n-                let base_ptr = base.to_ptr_align();\n+                let (base_ptr, align) = base.to_ptr_align();\n \n                 let (elem_ty, n) = base.elem_ty_and_len(base_ty);\n                 let elem_size = self.layout_of(elem_ty)?.size.bytes();\n@@ -415,11 +416,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 } else {\n                     PlaceExtra::Length(n - u64::from(to) - u64::from(from))\n                 };\n-                (ptr, extra)\n+                Ok(Place::Ptr { ptr, align, extra })\n             }\n-        };\n-\n-        Ok(Place::Ptr { ptr, extra })\n+        }\n     }\n \n     pub fn place_ty(&self, place: &mir::Place<'tcx>) -> Ty<'tcx> {"}, {"sha": "c5942712b87ddfb8f7e95373ee1279964c35cdcd", "filename": "src/librustc_mir/interpret/terminator/drop.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/08646c6c2c167d4c04897660dc524623d349bdb1/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08646c6c2c167d4c04897660dc524623d349bdb1/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs?ref=08646c6c2c167d4c04897660dc524623d349bdb1", "patch": "@@ -21,16 +21,19 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         let val = match self.force_allocation(place)? {\n             Place::Ptr {\n                 ptr,\n+                align: _,\n                 extra: PlaceExtra::Vtable(vtable),\n-            } => ptr.ptr.to_value_with_vtable(vtable),\n+            } => ptr.to_value_with_vtable(vtable),\n             Place::Ptr {\n                 ptr,\n+                align: _,\n                 extra: PlaceExtra::Length(len),\n-            } => ptr.ptr.to_value_with_len(len),\n+            } => ptr.to_value_with_len(len),\n             Place::Ptr {\n                 ptr,\n+                align: _,\n                 extra: PlaceExtra::None,\n-            } => ptr.ptr.to_value(),\n+            } => ptr.to_value(),\n             _ => bug!(\"force_allocation broken\"),\n         };\n         self.drop(val, instance, ty, span, target)"}, {"sha": "0c43490e1fd78a4ab44fc7b48fd4a58795794801", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/08646c6c2c167d4c04897660dc524623d349bdb1/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08646c6c2c167d4c04897660dc524623d349bdb1/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=08646c6c2c167d4c04897660dc524623d349bdb1", "patch": "@@ -4,7 +4,7 @@ use rustc::ty::layout::LayoutOf;\n use syntax::codemap::Span;\n use syntax::abi::Abi;\n \n-use rustc::mir::interpret::{PtrAndAlign, EvalResult, PrimVal, Value};\n+use rustc::mir::interpret::{EvalResult, PrimVal, Value};\n use super::{EvalContext, eval_context,\n             Place, Machine, ValTy};\n \n@@ -327,14 +327,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         if let ty::TyTuple(..) = args[1].ty.sty {\n                             if self.frame().mir.args_iter().count() == layout.fields.count() + 1 {\n                                 match args[1].value {\n-                                    Value::ByRef(PtrAndAlign { ptr, align }) => {\n+                                    Value::ByRef(ptr, align) => {\n                                         for (i, arg_local) in arg_locals.enumerate() {\n                                             let field = layout.field(&self, i)?;\n                                             let offset = layout.fields.offset(i).bytes();\n-                                            let arg = Value::ByRef(PtrAndAlign {\n-                                                ptr: ptr.offset(offset, &self)?,\n-                                                align: align.min(field.align)\n-                                            });\n+                                            let arg = Value::ByRef(ptr.offset(offset, &self)?,\n+                                                                   align.min(field.align));\n                                             let dest =\n                                                 self.eval_place(&mir::Place::Local(arg_local))?;\n                                             trace!("}]}