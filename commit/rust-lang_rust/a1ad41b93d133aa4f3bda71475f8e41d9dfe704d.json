{"sha": "a1ad41b93d133aa4f3bda71475f8e41d9dfe704d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExYWQ0MWI5M2QxMzNhYTRmM2JkYTcxNDc1ZjhlNDFkOWRmZTcwNGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-28T12:21:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-28T12:21:46Z"}, "message": "auto merge of #13791 : lifthrasiir/rust/mod-inner-span, r=huonw\n\nThis PR is primarily motivated by (and fixes) #12926.\r\n\r\nWe currently only have a span for the individual item itself and not for the referred contents. This normally does not cause a problem since both are located in the same file; it *is* possible that the contained statement or item is located in the other file (the syntax extension can do that), but even in that case the syntax extension should be located in the same file as the item. The module item (i.e. `mod foo;`) is the only exception here, and thus warrants a special treatment.\r\n\r\nRustdoc would now distinguish `mod foo;` from `mod foo {...}` by checking if the span for the module item and module contents is in different files. If it's the case, we'd prefer module contents over module item. There are alternative strategies, but as noted above we will have some corner cases if we don't record the contents span explicitly.", "tree": {"sha": "a8cdfdaf2359e39d80de4045ca7f1143f7767b43", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8cdfdaf2359e39d80de4045ca7f1143f7767b43"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1ad41b93d133aa4f3bda71475f8e41d9dfe704d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1ad41b93d133aa4f3bda71475f8e41d9dfe704d", "html_url": "https://github.com/rust-lang/rust/commit/a1ad41b93d133aa4f3bda71475f8e41d9dfe704d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1ad41b93d133aa4f3bda71475f8e41d9dfe704d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a19a82d119ca51ed872ed207bed396cdf4a3283", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a19a82d119ca51ed872ed207bed396cdf4a3283", "html_url": "https://github.com/rust-lang/rust/commit/7a19a82d119ca51ed872ed207bed396cdf4a3283"}, {"sha": "c8a29c4c595e76b71372a2e40d359ac1ddd8aec8", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8a29c4c595e76b71372a2e40d359ac1ddd8aec8", "html_url": "https://github.com/rust-lang/rust/commit/c8a29c4c595e76b71372a2e40d359ac1ddd8aec8"}], "stats": {"total": 72, "additions": 58, "deletions": 14}, "files": [{"sha": "4fc33c2ad9b14036b8427b1daaf90190088aa24f", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1ad41b93d133aa4f3bda71475f8e41d9dfe704d/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1ad41b93d133aa4f3bda71475f8e41d9dfe704d/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=a1ad41b93d133aa4f3bda71475f8e41d9dfe704d", "patch": "@@ -70,6 +70,7 @@ fn fold_mod(cx: &mut Context, m: &ast::Mod) -> ast::Mod {\n         filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n     }).collect();\n     ast::Mod {\n+        inner: m.inner,\n         view_items: filtered_view_items,\n         items: flattened_items\n     }"}, {"sha": "b5797b2571d3dfa19250d31e9b900654241a9f14", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1ad41b93d133aa4f3bda71475f8e41d9dfe704d/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1ad41b93d133aa4f3bda71475f8e41d9dfe704d/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=a1ad41b93d133aa4f3bda71475f8e41d9dfe704d", "patch": "@@ -143,6 +143,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n         }\n \n         let mod_nomain = ast::Mod {\n+            inner: m.inner,\n             view_items: m.view_items.clone(),\n             items: m.items.iter().map(|i| nomain(&self.cx, *i)).collect(),\n         };\n@@ -335,6 +336,7 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::Item {\n     )).unwrap();\n \n     let testmod = ast::Mod {\n+        inner: DUMMY_SP,\n         view_items: view_items,\n         items: vec!(mainfn, tests),\n     };"}, {"sha": "cabfb05cb6f2fc0f478b56a27404bf744747a071", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a1ad41b93d133aa4f3bda71475f8e41d9dfe704d/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1ad41b93d133aa4f3bda71475f8e41d9dfe704d/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=a1ad41b93d133aa4f3bda71475f8e41d9dfe704d", "patch": "@@ -227,10 +227,27 @@ impl Clean<Item> for doctree::Module {\n             self.view_items.clean().move_iter().collect(),\n             self.macros.clean().move_iter().collect()\n         );\n+\n+        // determine if we should display the inner contents or\n+        // the outer `mod` item for the source code.\n+        let where = {\n+            let ctxt = local_data::get(super::ctxtkey, |x| *x.unwrap());\n+            let cm = ctxt.sess().codemap();\n+            let outer = cm.lookup_char_pos(self.where_outer.lo);\n+            let inner = cm.lookup_char_pos(self.where_inner.lo);\n+            if outer.file.start_pos == inner.file.start_pos {\n+                // mod foo { ... }\n+                self.where_outer\n+            } else {\n+                // mod foo; (and a separate FileMap for the contents)\n+                self.where_inner\n+            }\n+        };\n+\n         Item {\n             name: Some(name),\n             attrs: self.attrs.clean(),\n-            source: self.where.clean(),\n+            source: where.clean(),\n             visibility: self.vis.clean(),\n             id: self.id,\n             inner: ModuleItem(Module {"}, {"sha": "ac846482f9f262a50dde26a6b5dba347ce157f3b", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a1ad41b93d133aa4f3bda71475f8e41d9dfe704d/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1ad41b93d133aa4f3bda71475f8e41d9dfe704d/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=a1ad41b93d133aa4f3bda71475f8e41d9dfe704d", "patch": "@@ -19,7 +19,8 @@ use syntax::ast::{Ident, NodeId};\n pub struct Module {\n     pub name: Option<Ident>,\n     pub attrs: Vec<ast::Attribute>,\n-    pub where: Span,\n+    pub where_outer: Span,\n+    pub where_inner: Span,\n     pub structs: Vec<Struct>,\n     pub enums: Vec<Enum>,\n     pub fns: Vec<Function>,\n@@ -42,7 +43,8 @@ impl Module {\n             name       : name,\n             id: 0,\n             vis: ast::Inherited,\n-            where: syntax::codemap::DUMMY_SP,\n+            where_outer: syntax::codemap::DUMMY_SP,\n+            where_inner: syntax::codemap::DUMMY_SP,\n             attrs      : Vec::new(),\n             structs    : Vec::new(),\n             enums      : Vec::new(),"}, {"sha": "6e764c03e9097b8d57c28b0846dc79ad13416935", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a1ad41b93d133aa4f3bda71475f8e41d9dfe704d/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1ad41b93d133aa4f3bda71475f8e41d9dfe704d/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=a1ad41b93d133aa4f3bda71475f8e41d9dfe704d", "patch": "@@ -118,7 +118,8 @@ impl<'a> RustdocVisitor<'a> {\n         for item in m.view_items.iter() {\n             self.visit_view_item(item, &mut om);\n         }\n-        om.where = span;\n+        om.where_outer = span;\n+        om.where_inner = m.inner;\n         om.attrs = attrs;\n         om.vis = vis;\n         om.id = id;"}, {"sha": "45f753d0e98327f6dd38f5f6a776d71df627c443", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a1ad41b93d133aa4f3bda71475f8e41d9dfe704d/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1ad41b93d133aa4f3bda71475f8e41d9dfe704d/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=a1ad41b93d133aa4f3bda71475f8e41d9dfe704d", "patch": "@@ -921,8 +921,12 @@ pub struct Method {\n \n #[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct Mod {\n-    pub view_items: Vec<ViewItem> ,\n-    pub items: Vec<@Item> ,\n+    /// A span from the first token past `{` to the last token until `}`.\n+    /// For `mod foo;`, the inner span ranges from the first token\n+    /// to the last token in the external file.\n+    pub inner: Span,\n+    pub view_items: Vec<ViewItem>,\n+    pub items: Vec<@Item>,\n }\n \n #[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n@@ -1165,7 +1169,15 @@ mod test {\n     fn check_asts_encodable() {\n         use std::io;\n         let e = Crate {\n-            module: Mod {view_items: Vec::new(), items: Vec::new()},\n+            module: Mod {\n+                inner: Span {\n+                    lo: BytePos(11),\n+                    hi: BytePos(19),\n+                    expn_info: None,\n+                },\n+                view_items: Vec::new(),\n+                items: Vec::new(),\n+            },\n             attrs: Vec::new(),\n             config: Vec::new(),\n             span: Span {"}, {"sha": "457cb4b79bf94d3c1f0bfc0994e526717fd2bbae", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a1ad41b93d133aa4f3bda71475f8e41d9dfe704d/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1ad41b93d133aa4f3bda71475f8e41d9dfe704d/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=a1ad41b93d133aa4f3bda71475f8e41d9dfe704d", "patch": "@@ -220,7 +220,7 @@ pub trait AstBuilder {\n                         generics: Generics) -> @ast::Item;\n     fn item_struct(&self, span: Span, name: Ident, struct_def: ast::StructDef) -> @ast::Item;\n \n-    fn item_mod(&self, span: Span,\n+    fn item_mod(&self, span: Span, inner_span: Span,\n                 name: Ident, attrs: Vec<ast::Attribute> ,\n                 vi: Vec<ast::ViewItem> , items: Vec<@ast::Item> ) -> @ast::Item;\n \n@@ -898,7 +898,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.item(span, name, Vec::new(), ast::ItemStruct(@struct_def, generics))\n     }\n \n-    fn item_mod(&self, span: Span, name: Ident,\n+    fn item_mod(&self, span: Span, inner_span: Span, name: Ident,\n                 attrs: Vec<ast::Attribute> ,\n                 vi: Vec<ast::ViewItem> ,\n                 items: Vec<@ast::Item> ) -> @ast::Item {\n@@ -907,6 +907,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             name,\n             attrs,\n             ast::ItemMod(ast::Mod {\n+                inner: inner_span,\n                 view_items: vi,\n                 items: items,\n             })"}, {"sha": "47ef23b82d2e2801992ddb7b1e2c0a8c5d4b5036", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1ad41b93d133aa4f3bda71475f8e41d9dfe704d/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1ad41b93d133aa4f3bda71475f8e41d9dfe704d/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=a1ad41b93d133aa4f3bda71475f8e41d9dfe704d", "patch": "@@ -652,6 +652,7 @@ pub fn noop_fold_type_method<T: Folder>(m: &TypeMethod, fld: &mut T) -> TypeMeth\n \n pub fn noop_fold_mod<T: Folder>(m: &Mod, folder: &mut T) -> Mod {\n     ast::Mod {\n+        inner: folder.new_span(m.inner),\n         view_items: m.view_items\n                      .iter()\n                      .map(|x| folder.fold_view_item(x)).collect(),"}, {"sha": "8e6d6719bb91a0b39c568c1dae50ca85a187223b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a1ad41b93d133aa4f3bda71475f8e41d9dfe704d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1ad41b93d133aa4f3bda71475f8e41d9dfe704d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=a1ad41b93d133aa4f3bda71475f8e41d9dfe704d", "patch": "@@ -4036,7 +4036,8 @@ impl<'a> Parser<'a> {\n     // attributes (of length 0 or 1), parse all of the items in a module\n     fn parse_mod_items(&mut self,\n                        term: token::Token,\n-                       first_item_attrs: Vec<Attribute> )\n+                       first_item_attrs: Vec<Attribute>,\n+                       inner_lo: BytePos)\n                        -> Mod {\n         // parse all of the items up to closing or an attribute.\n         // view items are legal here.\n@@ -4081,7 +4082,11 @@ impl<'a> Parser<'a> {\n             self.span_err(self.last_span, \"expected item after attributes\");\n         }\n \n-        ast::Mod { view_items: view_items, items: items }\n+        ast::Mod {\n+            inner: mk_sp(inner_lo, self.span.lo),\n+            view_items: view_items,\n+            items: items\n+        }\n     }\n \n     fn parse_item_const(&mut self) -> ItemInfo {\n@@ -4107,8 +4112,9 @@ impl<'a> Parser<'a> {\n         } else {\n             self.push_mod_path(id, outer_attrs);\n             self.expect(&token::LBRACE);\n+            let mod_inner_lo = self.span.lo;\n             let (inner, next) = self.parse_inner_attrs_and_next();\n-            let m = self.parse_mod_items(token::RBRACE, next);\n+            let m = self.parse_mod_items(token::RBRACE, next, mod_inner_lo);\n             self.expect(&token::RBRACE);\n             self.pop_mod_path();\n             (id, ItemMod(m), Some(inner))\n@@ -4197,10 +4203,11 @@ impl<'a> Parser<'a> {\n                                      self.cfg.clone(),\n                                      &path,\n                                      id_sp);\n+        let mod_inner_lo = p0.span.lo;\n         let (inner, next) = p0.parse_inner_attrs_and_next();\n         let mod_attrs = outer_attrs.append(inner.as_slice());\n         let first_item_outer_attrs = next;\n-        let m0 = p0.parse_mod_items(token::EOF, first_item_outer_attrs);\n+        let m0 = p0.parse_mod_items(token::EOF, first_item_outer_attrs, mod_inner_lo);\n         self.sess.included_mod_stack.borrow_mut().pop();\n         return (ast::ItemMod(m0), mod_attrs);\n     }\n@@ -5061,7 +5068,7 @@ impl<'a> Parser<'a> {\n         let (inner, next) = self.parse_inner_attrs_and_next();\n         let first_item_outer_attrs = next;\n         // parse the items inside the crate:\n-        let m = self.parse_mod_items(token::EOF, first_item_outer_attrs);\n+        let m = self.parse_mod_items(token::EOF, first_item_outer_attrs, lo);\n \n         ast::Crate {\n             module: m,"}]}