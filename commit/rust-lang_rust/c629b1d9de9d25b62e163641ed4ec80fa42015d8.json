{"sha": "c629b1d9de9d25b62e163641ed4ec80fa42015d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2MjliMWQ5ZGU5ZDI1YjYyZTE2MzY0MWVkNGVjODBmYTQyMDE1ZDg=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-12-05T11:49:34Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-12-07T02:59:36Z"}, "message": "std::str: Add examples to the StrSlice trait.\n\nFixes #10819.", "tree": {"sha": "652008fe73d31ebb07d2dffc0a5081ba7f4df726", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/652008fe73d31ebb07d2dffc0a5081ba7f4df726"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c629b1d9de9d25b62e163641ed4ec80fa42015d8", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c629b1d9de9d25b62e163641ed4ec80fa42015d8", "html_url": "https://github.com/rust-lang/rust/commit/c629b1d9de9d25b62e163641ed4ec80fa42015d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c629b1d9de9d25b62e163641ed4ec80fa42015d8/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa4455e4c76598fcf6de84de14f050a700a2a14e", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa4455e4c76598fcf6de84de14f050a700a2a14e", "html_url": "https://github.com/rust-lang/rust/commit/aa4455e4c76598fcf6de84de14f050a700a2a14e"}], "stats": {"total": 363, "additions": 321, "deletions": 42}, "files": [{"sha": "0fbf9d92595979a265fa19ee805b0faa4be30b67", "filename": "src/libstd/str.rs", "status": "modified", "additions": 321, "deletions": 42, "changes": 363, "blob_url": "https://github.com/rust-lang/rust/blob/c629b1d9de9d25b62e163641ed4ec80fa42015d8/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c629b1d9de9d25b62e163641ed4ec80fa42015d8/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=c629b1d9de9d25b62e163641ed4ec80fa42015d8", "patch": "@@ -1398,12 +1398,28 @@ pub trait StrSlice<'self> {\n     ///\n     /// let v: ~[&str] = \"abc1def2ghi\".split(|c: char| c.is_digit()).collect();\n     /// assert_eq!(v, ~[\"abc\", \"def\", \"ghi\"]);\n+    ///\n+    /// let v: ~[&str] = \"lionXXtigerXleopard\".split('X').collect();\n+    /// assert_eq!(v, ~[\"lion\", \"\", \"tiger\", \"leopard\"]);\n     /// ```\n     fn split<Sep: CharEq>(&self, sep: Sep) -> CharSplitIterator<'self, Sep>;\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by `sep`, restricted to splitting at most `count`\n     /// times.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: ~[&str] = \"Mary had a little lambda\".splitn(' ', 2).collect();\n+    /// assert_eq!(v, ~[\"Mary\", \"had\", \"a little lambda\"]);\n+    ///\n+    /// let v: ~[&str] = \"abc1def2ghi\".splitn(|c: char| c.is_digit(), 1).collect();\n+    /// assert_eq!(v, ~[\"abc\", \"def2ghi\"]);\n+    ///\n+    /// let v: ~[&str] = \"lionXXtigerXleopard\".splitn('X', 2).collect();\n+    /// assert_eq!(v, ~[\"lion\", \"\", \"tigerXleopard\"]);\n+    /// ```\n     fn splitn<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitNIterator<'self, Sep>;\n \n     /// An iterator over substrings of `self`, separated by characters\n@@ -1417,95 +1433,266 @@ pub trait StrSlice<'self> {\n     /// ```rust\n     /// let v: ~[&str] = \"A.B.\".split_terminator('.').collect();\n     /// assert_eq!(v, ~[\"A\", \"B\"]);\n+    ///\n+    /// let v: ~[&str] = \"A..B..\".split_terminator('.').collect();\n+    /// assert_eq!(v, ~[\"A\", \"\", \"B\", \"\"]);\n     /// ```\n     fn split_terminator<Sep: CharEq>(&self, sep: Sep) -> CharSplitIterator<'self, Sep>;\n \n     /// An iterator over substrings of `self`, separated by characters\n-    /// matched by `sep`, in reverse order\n+    /// matched by `sep`, in reverse order.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n     /// let v: ~[&str] = \"Mary had a little lamb\".rsplit(' ').collect();\n     /// assert_eq!(v, ~[\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n+    ///\n+    /// let v: ~[&str] = \"abc1def2ghi\".rsplit(|c: char| c.is_digit()).collect();\n+    /// assert_eq!(v, ~[\"ghi\", \"def\", \"abc\"]);\n+    ///\n+    /// let v: ~[&str] = \"lionXXtigerXleopard\".rsplit('X').collect();\n+    /// assert_eq!(v, ~[\"leopard\", \"tiger\", \"\", \"lion\"]);\n     /// ```\n     fn rsplit<Sep: CharEq>(&self, sep: Sep) -> CharRSplitIterator<'self, Sep>;\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by `sep`, starting from the end of the string.\n     /// Restricted to splitting at most `count` times.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: ~[&str] = \"Mary had a little lamb\".rsplitn(' ', 2).collect();\n+    /// assert_eq!(v, ~[\"lamb\", \"little\", \"Mary had a\"]);\n+    ///\n+    /// let v: ~[&str] = \"abc1def2ghi\".rsplitn(|c: char| c.is_digit(), 1).collect();\n+    /// assert_eq!(v, ~[\"ghi\", \"abc1def\"]);\n+    ///\n+    /// let v: ~[&str] = \"lionXXtigerXleopard\".rsplitn('X', 2).collect();\n+    /// assert_eq!(v, ~[\"leopard\", \"tiger\", \"lionX\"]);\n+    /// ```\n     fn rsplitn<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitNIterator<'self, Sep>;\n \n-    /// An iterator over the start and end indices of each match of\n-    /// `sep` within `self`.\n+    /// An iterator over the start and end indices of the disjoint\n+    /// matches of `sep` within `self`.\n+    ///\n+    /// That is, each returned value `(start, end)` satisfies\n+    /// `self.slice(start, end) == sep`. For matches of `sep` within\n+    /// `self` that overlap, only the indicies corresponding to the\n+    /// first match are returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: ~[(uint, uint)] = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n+    /// assert_eq!(v, ~[(0,3), (6,9), (12,15)]);\n+    ///\n+    /// let v: ~[(uint, uint)] = \"1abcabc2\".split_str(\"abc\").collect();\n+    /// assert_eq!(v, ~[(1,4), (4,7)]);\n+    ///\n+    /// let v: ~[(uint, uint)] = \"ababa\".split_str(\"aba\").collect();\n+    /// assert_eq!(v, ~[(0, 3)]); // only the first `aba`\n+    /// ```\n     fn match_indices(&self, sep: &'self str) -> MatchesIndexIterator<'self>;\n \n     /// An iterator over the substrings of `self` separated by `sep`.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n-    /// let v: ~[&str] = \"abcXXXabcYYYabc\".split_str(\"abc\").collect()\n-    /// assert_eq!(v, [\"\", \"XXX\", \"YYY\", \"\"]);\n+    /// let v: ~[&str] = \"abcXXXabcYYYabc\".split_str(\"abc\").collect();\n+    /// assert_eq!(v, ~[\"\", \"XXX\", \"YYY\", \"\"]);\n+    ///\n+    /// let v: ~[&str] = \"1abcabc2\".split_str(\"abc\").collect();\n+    /// assert_eq!(v, ~[\"1\", \"\", \"2\"]);\n     /// ```\n     fn split_str(&self, &'self str) -> StrSplitIterator<'self>;\n \n     /// An iterator over the lines of a string (subsequences separated\n-    /// by `\\n`).\n+    /// by `\\n`). This does not include the empty string after a\n+    /// trailing `\\n`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let four_lines = \"foo\\nbar\\n\\nbaz\\n\";\n+    /// let v: ~[&str] = four_lines.lines().collect();\n+    /// assert_eq!(v, ~[\"foo\", \"bar\", \"\", \"baz\"]);\n+    /// ```\n     fn lines(&self) -> CharSplitIterator<'self, char>;\n \n     /// An iterator over the lines of a string, separated by either\n-    /// `\\n` or (`\\r\\n`).\n+    /// `\\n` or `\\r\\n`. As with `.lines()`, this does not include an\n+    /// empty trailing line.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let four_lines = \"foo\\r\\nbar\\n\\r\\nbaz\\n\";\n+    /// let v: ~[&str] = four_lines.lines_any().collect();\n+    /// assert_eq!(v, ~[\"foo\", \"bar\", \"\", \"baz\"]);\n+    /// ```\n     fn lines_any(&self) -> AnyLineIterator<'self>;\n \n     /// An iterator over the words of a string (subsequences separated\n-    /// by any sequence of whitespace).\n+    /// by any sequence of whitespace). Sequences of whitespace are\n+    /// collapsed, so empty \"words\" are not included.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let some_words = \" Mary   had\\ta little  \\n\\t lamb\";\n+    /// let v: ~[&str] = some_words.words().collect();\n+    /// assert_eq!(v, ~[\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n+    /// ```\n     fn words(&self) -> WordIterator<'self>;\n \n-    /// An Iterator over the string in Unicode Normalization Form D (canonical decomposition)\n+    /// An Iterator over the string in Unicode Normalization Form D\n+    /// (canonical decomposition).\n     fn nfd_chars(&self) -> NormalizationIterator<'self>;\n \n-    /// An Iterator over the string in Unicode Normalization Form KD (compatibility decomposition)\n+    /// An Iterator over the string in Unicode Normalization Form KD\n+    /// (compatibility decomposition).\n     fn nfkd_chars(&self) -> NormalizationIterator<'self>;\n \n-    /// Returns true if the string contains only whitespace\n+    /// Returns true if the string contains only whitespace.\n+    ///\n+    /// Whitespace characters are determined by `char::is_whitespace`.\n     ///\n-    /// Whitespace characters are determined by `char::is_whitespace`\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// assert!(\" \\t\\n\".is_whitespace());\n+    /// assert!(\"\".is_whitespace());\n+    ///\n+    /// assert!( !\"abc.is_whitespace());\n+    /// ```\n     fn is_whitespace(&self) -> bool;\n \n-    /// Returns true if the string contains only alphanumerics\n+    /// Returns true if the string contains only alphanumerics.\n+    ///\n+    /// Alphanumeric characters are determined by `char::is_alphanumeric`.\n+    ///\n+    /// # Example\n     ///\n-    /// Alphanumeric characters are determined by `char::is_alphanumeric`\n+    /// ```rust\n+    /// assert!(\"L\u00f6we\u8001\u864eL\u00e9opard123\".is_alphanumeric());\n+    /// assert!(\"\".is_alphanumeric());\n+    ///\n+    /// assert!( !\" &*~\".is_alphanumeric());\n+    /// ```\n     fn is_alphanumeric(&self) -> bool;\n \n-    /// Returns the number of characters that a string holds\n+    /// Returns the number of Unicode code points (`char`) that a\n+    /// string holds.\n+    ///\n+    /// This does not perform any normalization, and is `O(n)`, since\n+    /// UTF-8 is a variable width encoding of code points.\n+    ///\n+    /// *Warning*: The number of code points in a string does not directly\n+    /// correspond to the number of visible characters or width of the\n+    /// visible text due to composing characters, and double- and\n+    /// zero-width ones.\n+    ///\n+    /// See also `.len()` for the byte length.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// // composed forms of `\u00f6` and `\u00e9`\n+    /// let c = \"L\u00f6we \u8001\u864e L\u00e9opard\"; // German, Simplified Chinese, French\n+    /// // decomposed forms of `\u00f6` and `\u00e9`\n+    /// let d = \"Lo\\u0308we \u8001\u864e Le\\u0301opard\";\n+    ///\n+    /// assert_eq!(c.char_len(), 15);\n+    /// assert_eq!(d.char_len(), 17);\n+    ///\n+    /// assert_eq!(c.len(), 21);\n+    /// assert_eq!(d.len(), 23);\n+    ///\n+    /// // the two strings *look* the same\n+    /// println(c);\n+    /// println(d);\n+    /// ```\n     fn char_len(&self) -> uint;\n \n     /// Returns a slice of the given string from the byte range\n-    /// [`begin`..`end`)\n+    /// [`begin`..`end`).\n+    ///\n+    /// This operation is `O(1)`.\n+    ///\n+    /// Fails when `begin` and `end` do not point to valid characters\n+    /// or point beyond the last character of the string.\n     ///\n-    /// Fails when `begin` and `end` do not point to valid characters or\n-    /// beyond the last character of the string\n+    /// See also `slice_to` and `slice_from` for slicing prefixes and\n+    /// suffixes of strings, and `slice_chars` for slicing based on\n+    /// code point counts.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// assert_eq!(s.slice(0, 1), \"L\");\n+    ///\n+    /// assert_eq!(s.slice(1, 9), \"\u00f6we \u8001\"));\n+    ///\n+    /// // these will fail:\n+    /// // byte 2 lies within `\u00f6`:\n+    /// // s.slice(2, 3);\n+    ///\n+    /// // byte 8 lies within `\u8001`\n+    /// // s.slice(1, 8);\n+    ///\n+    /// // byte 100 is outside the string\n+    /// // s.slice(3, 100);\n+    /// ```\n     fn slice(&self, begin: uint, end: uint) -> &'self str;\n \n     /// Returns a slice of the string from `begin` to its end.\n     ///\n+    /// Equivalent to `self.slice(begin, self.len())`.\n+    ///\n     /// Fails when `begin` does not point to a valid character, or is\n     /// out of bounds.\n+    ///\n+    /// See also `slice`, `slice_to` and `slice_chars`.\n     fn slice_from(&self, begin: uint) -> &'self str;\n \n     /// Returns a slice of the string from the beginning to byte\n     /// `end`.\n     ///\n+    /// Equivalent to `self.slice(0, end)`.\n+    ///\n     /// Fails when `end` does not point to a valid character, or is\n     /// out of bounds.\n+    ///\n+    /// See also `slice`, `slice_from` and `slice_chars`.\n     fn slice_to(&self, end: uint) -> &'self str;\n \n-    /// Returns a slice of the string from the char range\n+    /// Returns a slice of the string from the character range\n     /// [`begin`..`end`).\n     ///\n+    /// That is, start at the `begin`-th code point of the string and\n+    /// continue to the `end`-th code point. This does not detect or\n+    /// handle edge cases such as leaving a combining character as the\n+    /// first code point of the string.\n+    ///\n+    /// Due to the design of UTF-8, this operation is `O(end -\n+    /// begin)`. See `slice`, `slice_to` and `slice_from` for `O(1)`\n+    /// variants that use byte indices rather than code point\n+    /// indices.\n+    ///\n     /// Fails if `begin` > `end` or the either `begin` or `end` are\n     /// beyond the last character of the string.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// assert_eq!(s.slice_chars(0, 4), \"L\u00f6we\");\n+    /// assert_eq!(s.slice_chars(6, 8), \"\u8001\u864e\");\n+    /// ```\n     fn slice_chars(&self, begin: uint, end: uint) -> &'self str;\n \n     /// Returns true if `needle` is a prefix of the string.\n@@ -1514,19 +1701,19 @@ pub trait StrSlice<'self> {\n     /// Returns true if `needle` is a suffix of the string.\n     fn ends_with(&self, needle: &str) -> bool;\n \n-    /// Escape each char in `s` with char::escape_default.\n+    /// Escape each char in `s` with `char::escape_default`.\n     fn escape_default(&self) -> ~str;\n \n-    /// Escape each char in `s` with char::escape_unicode.\n+    /// Escape each char in `s` with `char::escape_unicode`.\n     fn escape_unicode(&self) -> ~str;\n \n-    /// Returns a string with leading and trailing whitespace removed\n+    /// Returns a string with leading and trailing whitespace removed.\n     fn trim(&self) -> &'self str;\n \n-    /// Returns a string with leading whitespace removed\n+    /// Returns a string with leading whitespace removed.\n     fn trim_left(&self) -> &'self str;\n \n-    /// Returns a string with trailing whitespace removed\n+    /// Returns a string with trailing whitespace removed.\n     fn trim_right(&self) -> &'self str;\n \n     /// Returns a string with characters that match `to_trim` removed.\n@@ -1574,32 +1761,67 @@ pub trait StrSlice<'self> {\n     /// ```\n     fn trim_right_chars<C: CharEq>(&self, to_trim: &C) -> &'self str;\n \n-    /// Replace all occurrences of one string with another\n+    /// Replace all occurrences of one string with another.\n     ///\n     /// # Arguments\n     ///\n-    /// * from - The string to replace\n-    /// * to - The replacement string\n+    /// * `from` - The string to replace\n+    /// * `to` - The replacement string\n     ///\n     /// # Return value\n     ///\n-    /// The original string with all occurances of `from` replaced with `to`\n+    /// The original string with all occurances of `from` replaced with `to`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = ~\"Do you know the muffin man,\n+    /// The muffin man, the muffin man, ...\";\n+    ///\n+    /// assert_eq!(s.replace(\"muffin man\", \"little lamb\"),\n+    ///            ~\"Do you know the little lamb,\n+    /// The little lamb, the little lamb, ...\");\n+    ///\n+    /// // not found, so no change.\n+    /// assert_eq!(s.replace(\"cookie monster\", \"little lamb\"), s);\n+    /// ```\n     fn replace(&self, from: &str, to: &str) -> ~str;\n \n-    /// Copy a slice into a new owned str\n+    /// Copy a slice into a new owned str.\n     fn to_owned(&self) -> ~str;\n \n-    /// Copy a slice into a new managed str\n+    /// Copy a slice into a new managed str.\n     fn to_managed(&self) -> @str;\n \n     /// Converts to a vector of `u16` encoded as UTF-16.\n     fn to_utf16(&self) -> ~[u16];\n \n-    /// Copy a slice into a new `SendStr`\n+    /// Copy a slice into a new `SendStr`.\n     fn to_send_str(&self) -> SendStr;\n \n-    /// Returns false if the index points into the middle of a multi-byte\n-    /// character sequence.\n+    /// Check that `index`-th byte lies at the start and/or end of a\n+    /// UTF-8 code point sequence.\n+    ///\n+    /// The start and end of the string (when `index == self.len()`)\n+    /// are considered to be boundaries.\n+    ///\n+    /// Fails if `index` is greater than `self.len()`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// assert!(s.is_char_boundary(0));\n+    /// // start of `\u8001`\n+    /// assert!(s.is_char_boundary(6));\n+    /// assert!(s.is_char_boundary(s.len()));\n+    ///\n+    /// // second byte of `\u00f6`\n+    /// assert!(!s.is_char_boundary(2));\n+    ///\n+    /// // third byte of `\u8001`\n+    /// assert!(!s.is_char_boundary(8));\n+    /// ```\n     fn is_char_boundary(&self, index: uint) -> bool;\n \n     /// Pluck a character out of a string and return the index of the next\n@@ -1610,17 +1832,21 @@ pub trait StrSlice<'self> {\n     ///\n     /// # Example\n     ///\n+    /// This example manually iterate through the characters of a\n+    /// string; this should normally by done by `.chars()` or\n+    /// `.char_indices`.\n+    ///\n     /// ```rust\n     /// let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n-    /// let i = 0u;\n+    /// let mut i = 0u;\n     /// while i < s.len() {\n     ///     let CharRange {ch, next} = s.char_range_at(i);\n     ///     println!(\"{}: {}\", i, ch);\n     ///     i = next;\n     /// }\n     /// ```\n     ///\n-    /// # Example output\n+    /// ## Output\n     ///\n     /// ```\n     /// 0: \u4e2d\n@@ -1667,20 +1893,52 @@ pub trait StrSlice<'self> {\n     /// Work with the byte buffer of a string as a byte slice.\n     fn as_bytes(&self) -> &'self [u8];\n \n-    /// Returns the byte index of the first character of `self` that matches `search`\n+    /// Returns the byte index of the first character of `self` that\n+    /// matches `search`.\n     ///\n     /// # Return value\n     ///\n     /// `Some` containing the byte index of the last matching character\n     /// or `None` if there is no match\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.find('L'), Some(0));\n+    /// assert_eq!(s.find('\u00e9'), Some(14));\n+    ///\n+    /// // the first space\n+    /// assert_eq!(s.find(|c: char| c.is_whitespace()), Some(5));\n+    ///\n+    /// // neither are found\n+    /// assert_eq!(s.find(&['1', '2']), None);\n+    /// ```\n     fn find<C: CharEq>(&self, search: C) -> Option<uint>;\n \n-    /// Returns the byte index of the last character of `self` that matches `search`\n+    /// Returns the byte index of the last character of `self` that\n+    /// matches `search`.\n     ///\n     /// # Return value\n     ///\n     /// `Some` containing the byte index of the last matching character\n-    /// or `None` if there is no match\n+    /// or `None` if there is no match.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.rfind('L'), Some(13));\n+    /// assert_eq!(s.rfind('\u00e9'), Some(14));\n+    ///\n+    /// // the second space\n+    /// assert_eq!(s.rfind(|c: char| c.is_whitespace()), Some(12));\n+    ///\n+    /// // searches for an occurrence of either `1` or `2`, but neither are found\n+    /// assert_eq!(s.rfind(&['1', '2']), None);\n+    /// ```\n     fn rfind<C: CharEq>(&self, search: C) -> Option<uint>;\n \n     /// Returns the byte index of the first matching substring\n@@ -1692,7 +1950,16 @@ pub trait StrSlice<'self> {\n     /// # Return value\n     ///\n     /// `Some` containing the byte index of the first matching substring\n-    /// or `None` if there is no match\n+    /// or `None` if there is no match.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.find_str(\"\u8001\u864e L\"), Some(6));\n+    /// assert_eq!(s.find_str(\"muffin man\"), None);\n+    /// ```\n     fn find_str(&self, &str) -> Option<uint>;\n \n     /// Given a string, make a new string with repeated copies of it.\n@@ -1705,7 +1972,20 @@ pub trait StrSlice<'self> {\n     ///\n     /// # Failure\n     ///\n-    /// If the string does not contain any characters\n+    /// If the string does not contain any characters.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// let (c, s1) = s.shift_slice_char();\n+    /// assert_eq!(c, 'L');\n+    /// assert_eq!(s1, \"\u00f6we \u8001\u864e L\u00e9opard\");\n+    ///\n+    /// let (c, s2) = s1.shift_slice_char();\n+    /// assert_eq!(c, '\u00f6');\n+    /// assert_eq!(s2, \"we \u8001\u864e L\u00e9opard\");\n+    /// ```\n     fn slice_shift_char(&self) -> (char, &'self str);\n \n     /// Levenshtein Distance between two strings.\n@@ -1719,8 +1999,7 @@ pub trait StrSlice<'self> {\n     ///\n     /// ```rust\n     /// let string = \"a\\nb\\nc\";\n-    /// let mut lines = ~[];\n-    /// for line in string.lines() { lines.push(line) }\n+    /// let lines: ~[&str] = string.lines().collect();\n     ///\n     /// assert!(string.subslice_offset(lines[0]) == 0); // &\"a\"\n     /// assert!(string.subslice_offset(lines[1]) == 2); // &\"b\""}]}