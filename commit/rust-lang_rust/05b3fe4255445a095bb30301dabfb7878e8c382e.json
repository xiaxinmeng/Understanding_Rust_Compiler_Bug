{"sha": "05b3fe4255445a095bb30301dabfb7878e8c382e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1YjNmZTQyNTU0NDVhMDk1YmIzMDMwMWRhYmZiNzg3OGU4YzM4MmU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-02-03T12:48:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-03T12:48:13Z"}, "message": "Merge #7537\n\n7537: Fix spelling mistakes in docs/dev r=Veykril a=Veykril\n\nAlso adds a line for `crates/cfg` and `crates/stdx` to the architecture.\r\n\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "bf5314dd20eb90e5b68872f11a5e0e269bcc8fe4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf5314dd20eb90e5b68872f11a5e0e269bcc8fe4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05b3fe4255445a095bb30301dabfb7878e8c382e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgGpuNCRBK7hj4Ov3rIwAAdHIIADTprT4TEc2zMs4TSpBeyBNF\nR6MlKgqwTIlzZoRPnkcZScJgG9glP3gqA0lXBPiFtz1aO1C6l6HTlKXvoV8O2oLC\ngoCr1gaL3mWP0itn5TGdGisuAt8zw7ru9yEz5uGNyxnxG/Od1KtqZ47OgeHFZpaO\nbWYY6bpVZnNh8ijyI+Ip3meHBOscGg0t76fBreUkNVDEr8qfV17mJDupqPN6B+m4\nOJ8/ELa3TJ79kzpDluKXR0y/zHguZDHvsJujmr1mIXUqa3wA8rk8sNzphKh2erfu\nOOoJIyLcZUXSJWYVYnMFqiVex6DQNvzEomdc9WiGAmjhi7lTOTwRGsNmvTLVWCw=\n=Gq3c\n-----END PGP SIGNATURE-----\n", "payload": "tree bf5314dd20eb90e5b68872f11a5e0e269bcc8fe4\nparent 81a9ad3672d547b2f5d265766bbb6c79909fb2da\nparent f82ce500a9c72a4153850f15e17b60388e95b2af\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1612356493 +0000\ncommitter GitHub <noreply@github.com> 1612356493 +0000\n\nMerge #7537\n\n7537: Fix spelling mistakes in docs/dev r=Veykril a=Veykril\n\nAlso adds a line for `crates/cfg` and `crates/stdx` to the architecture.\r\n\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05b3fe4255445a095bb30301dabfb7878e8c382e", "html_url": "https://github.com/rust-lang/rust/commit/05b3fe4255445a095bb30301dabfb7878e8c382e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05b3fe4255445a095bb30301dabfb7878e8c382e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81a9ad3672d547b2f5d265766bbb6c79909fb2da", "url": "https://api.github.com/repos/rust-lang/rust/commits/81a9ad3672d547b2f5d265766bbb6c79909fb2da", "html_url": "https://github.com/rust-lang/rust/commit/81a9ad3672d547b2f5d265766bbb6c79909fb2da"}, {"sha": "f82ce500a9c72a4153850f15e17b60388e95b2af", "url": "https://api.github.com/repos/rust-lang/rust/commits/f82ce500a9c72a4153850f15e17b60388e95b2af", "html_url": "https://github.com/rust-lang/rust/commit/f82ce500a9c72a4153850f15e17b60388e95b2af"}], "stats": {"total": 58, "additions": 31, "deletions": 27}, "files": [{"sha": "e97e082fc88263b94191219503eda1536aa69b53", "filename": "docs/dev/architecture.md", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/05b3fe4255445a095bb30301dabfb7878e8c382e/docs%2Fdev%2Farchitecture.md", "raw_url": "https://github.com/rust-lang/rust/raw/05b3fe4255445a095bb30301dabfb7878e8c382e/docs%2Fdev%2Farchitecture.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Farchitecture.md?ref=05b3fe4255445a095bb30301dabfb7878e8c382e", "patch": "@@ -115,7 +115,7 @@ This is important because it is possible to useful tooling using only syntax tre\n Without semantic information, you don't need to be able to _build_ code, which makes the tooling more robust.\n See also https://web.stanford.edu/~mlfbrown/paper.pdf.\n You can view the `syntax` crate as an entry point to rust-analyzer.\n-`sytax` crate is an **API Boundary**.\n+`syntax` crate is an **API Boundary**.\n \n **Architecture Invariant:** syntax tree is a value type.\n The tree is fully determined by the contents of its syntax nodes, it doesn't need global context (like an interner) and doesn't store semantic info.\n@@ -198,14 +198,14 @@ It is an **API Boundary**.\n If you want to use IDE parts of rust-analyzer via LSP, custom flatbuffers-based protocol or just as a library in your text editor, this is the right API.\n \n **Architecture Invariant:** `ide` crate's API is build out of POD types with public fields.\n-The API uses editor's terminology, it talks about offsets and string labels rathe than in terms of definitions or types.\n+The API uses editor's terminology, it talks about offsets and string labels rather than in terms of definitions or types.\n It is effectively the view in MVC and viewmodel in [MVVM](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel).\n All arguments and return types are conceptually serializable.\n In particular, syntax tress and and hir types are generally absent from the API (but are used heavily in the implementation).\n Shout outs to LSP developers for popularizing the idea that \"UI\" is a good place to draw a boundary at.\n \n `ide` is also the first crate which has the notion of change over time.\n-`AnalysisHost` is a state to which you can transactonally `apply_change`.\n+`AnalysisHost` is a state to which you can transactionally `apply_change`.\n `Analysis` is an immutable snapshot of the state.\n \n Internally, `ide` is split across several crates. `ide_assists`, `ide_completion` and `ide_ssr` implement large isolated features.\n@@ -254,6 +254,10 @@ A single `rust-analyzer` process can serve many projects, so it is important tha\n These crates implement macros as token tree -> token tree transforms.\n They are independent from the rest of the code.\n \n+### `crates/cfg`\n+\n+This crate is responsible for parsing, evaluation and general definition of `cfg` attributes.\n+\n ### `crates/vfs`, `crates/vfs-notify`\n \n These crates implement a virtual fils system.\n@@ -265,7 +269,8 @@ For this reason, all path APIs generally take some existing path as a \"file syst\n \n ### `crates/stdx`\n \n-This crate contains various non-rust-analyzer specific utils, which could have been in std.\n+This crate contains various non-rust-analyzer specific utils, which could have been in std, as well\n+as copies of unstable std items we would like to make use of already, like `std::str::split_once`.\n \n ### `crates/profile`\n \n@@ -285,7 +290,7 @@ There are tests to check that the generated code is fresh.\n \n In particular, we generate:\n \n-* API for working with syntax trees (`syntax::ast`, the `ungrammar` crate).\n+* API for working with syntax trees (`syntax::ast`, the [`ungrammar`](https://github.com/rust-analyzer/ungrammar) crate).\n * Various sections of the manual:\n \n     * features"}, {"sha": "b2defa737b51b543366cad0ca31d16bca0c58d49", "filename": "docs/dev/lsp-extensions.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05b3fe4255445a095bb30301dabfb7878e8c382e/docs%2Fdev%2Flsp-extensions.md", "raw_url": "https://github.com/rust-lang/rust/raw/05b3fe4255445a095bb30301dabfb7878e8c382e/docs%2Fdev%2Flsp-extensions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Flsp-extensions.md?ref=05b3fe4255445a095bb30301dabfb7878e8c382e", "patch": "@@ -238,7 +238,7 @@ As proper cursor positioning is raison-d'etat for `onEnter`, it uses `SnippetTex\n * How to deal with synchronicity of the request?\n   One option is to require the client to block until the server returns the response.\n   Another option is to do a OT-style merging of edits from client and server.\n-  A third option is to do a record-replay: client applies heuristic on enter immediatelly, then applies all user's keypresses.\n+  A third option is to do a record-replay: client applies heuristic on enter immediately, then applies all user's keypresses.\n   When the server is ready with the response, the client rollbacks all the changes and applies the recorded actions on top of the correct response.\n * How to deal with multiple carets?\n * Should we extend this to arbitrary typed events and not just `onEnter`?"}, {"sha": "0482bc19027e97d3d50c0ddd7c248b9d19a69365", "filename": "docs/dev/style.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/05b3fe4255445a095bb30301dabfb7878e8c382e/docs%2Fdev%2Fstyle.md", "raw_url": "https://github.com/rust-lang/rust/raw/05b3fe4255445a095bb30301dabfb7878e8c382e/docs%2Fdev%2Fstyle.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Fstyle.md?ref=05b3fe4255445a095bb30301dabfb7878e8c382e", "patch": "@@ -159,7 +159,7 @@ Express function preconditions in types and force the caller to provide them (ra\n \n ```rust\n // GOOD\n-fn frbonicate(walrus: Walrus) {\n+fn frobnicate(walrus: Walrus) {\n     ...\n }\n \n@@ -374,15 +374,15 @@ Avoid making a lot of code type parametric, *especially* on the boundaries betwe\n \n ```rust\n // GOOD\n-fn frbonicate(f: impl FnMut()) {\n+fn frobnicate(f: impl FnMut()) {\n     frobnicate_impl(&mut f)\n }\n fn frobnicate_impl(f: &mut dyn FnMut()) {\n     // lots of code\n }\n \n // BAD\n-fn frbonicate(f: impl FnMut()) {\n+fn frobnicate(f: impl FnMut()) {\n     // lots of code\n }\n ```\n@@ -391,11 +391,11 @@ Avoid `AsRef` polymorphism, it pays back only for widely used libraries:\n \n ```rust\n // GOOD\n-fn frbonicate(f: &Path) {\n+fn frobnicate(f: &Path) {\n }\n \n // BAD\n-fn frbonicate(f: impl AsRef<Path>) {\n+fn frobnicate(f: impl AsRef<Path>) {\n }\n ```\n \n@@ -705,7 +705,7 @@ fn foo() -> Option<Bar> {\n }\n ```\n \n-**Rationale:** reduce congnitive stack usage.\n+**Rationale:** reduce cognitive stack usage.\n \n ## Comparisons\n "}, {"sha": "737cc7a729773330a76d2fc4aac9147e6924ba3d", "filename": "docs/dev/syntax.md", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/05b3fe4255445a095bb30301dabfb7878e8c382e/docs%2Fdev%2Fsyntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/05b3fe4255445a095bb30301dabfb7878e8c382e/docs%2Fdev%2Fsyntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Fsyntax.md?ref=05b3fe4255445a095bb30301dabfb7878e8c382e", "patch": "@@ -92,19 +92,18 @@ FN@0..17\n     R_PAREN@5..6 \")\"\n   WHITESPACE@6..7 \" \"\n   BLOCK_EXPR@7..17\n-    BLOCK@7..17\n-      L_CURLY@7..8 \"{\"\n-      WHITESPACE@8..9 \" \"\n-      BIN_EXPR@9..15\n-        LITERAL@9..11\n-          INT_NUMBER@9..11 \"90\"\n-        WHITESPACE@11..12 \" \"\n-        PLUS@12..13 \"+\"\n-        WHITESPACE@13..14 \" \"\n-        LITERAL@14..15\n-          INT_NUMBER@14..15 \"2\"\n-      WHITESPACE@15..16 \" \"\n-      R_CURLY@16..17 \"}\"\n+    L_CURLY@7..8 \"{\"\n+    WHITESPACE@8..9 \" \"\n+    BIN_EXPR@9..15\n+      LITERAL@9..11\n+        INT_NUMBER@9..11 \"90\"\n+      WHITESPACE@11..12 \" \"\n+      PLUS@12..13 \"+\"\n+      WHITESPACE@13..14 \" \"\n+      LITERAL@14..15\n+        INT_NUMBER@14..15 \"2\"\n+    WHITESPACE@15..16 \" \"\n+    R_CURLY@16..17 \"}\"\n ```\n \n #### Optimizations\n@@ -387,7 +386,7 @@ trait HasVisibility: AstNode {\n     fn visibility(&self) -> Option<Visibility>;\n }\n \n-impl HasVisbility for FnDef {\n+impl HasVisibility for FnDef {\n     fn visibility(&self) -> Option<Visibility> {\n         self.syntax.children().find_map(Visibility::cast)\n     }\n@@ -527,7 +526,7 @@ In practice, incremental reparsing doesn't actually matter much for IDE use-case\n \n ### Parsing Algorithm\n \n-We use a boring hand-crafted recursive descent + pratt combination, with a special effort of continuting the parsing if an error is detected.\n+We use a boring hand-crafted recursive descent + pratt combination, with a special effort of continuing the parsing if an error is detected.\n \n ### Parser Recap\n "}]}