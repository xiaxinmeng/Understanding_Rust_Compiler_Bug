{"sha": "7a76fe76f756895b8cda1e10398f2268656a2e0f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhNzZmZTc2Zjc1Njg5NWI4Y2RhMWUxMDM5OGYyMjY4NjU2YTJlMGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-07T03:54:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-07T03:54:25Z"}, "message": "Auto merge of #66175 - JohnTitor:rollup-ihqk5vn, r=JohnTitor\n\nRollup of 12 pull requests\n\nSuccessful merges:\n\n - #65794 (gate rustc_on_unimplemented under rustc_attrs)\n - #65945 (Optimize long-linker-command-line test)\n - #66044 (Improve uninit/zeroed lint)\n - #66076 (HIR docs: mention how to resolve method paths)\n - #66084 (Do not require extra LLVM backends for `x.py test` to pass)\n - #66111 (improve from_raw_parts docs)\n - #66114 (Improve std::thread::Result documentation)\n - #66117 (Fixed PhantomData markers in Arc and Rc)\n - #66146 (Remove unused parameters in `__thread_local_inner`)\n - #66147 (Miri: Refactor to_scalar_ptr out of existence)\n - #66162 (Fix broken link in README)\n - #66171 (Update link on CONTRIBUTING.md)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "a630f58f51bc8e94ffe1eb7eed1a2806d91843b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a630f58f51bc8e94ffe1eb7eed1a2806d91843b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a76fe76f756895b8cda1e10398f2268656a2e0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a76fe76f756895b8cda1e10398f2268656a2e0f", "html_url": "https://github.com/rust-lang/rust/commit/7a76fe76f756895b8cda1e10398f2268656a2e0f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a76fe76f756895b8cda1e10398f2268656a2e0f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "caf018714189db0b15f9f803adfcb4572ab7a988", "url": "https://api.github.com/repos/rust-lang/rust/commits/caf018714189db0b15f9f803adfcb4572ab7a988", "html_url": "https://github.com/rust-lang/rust/commit/caf018714189db0b15f9f803adfcb4572ab7a988"}, {"sha": "b59d16600628fc9b9c82eb0140c74325a44e262a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b59d16600628fc9b9c82eb0140c74325a44e262a", "html_url": "https://github.com/rust-lang/rust/commit/b59d16600628fc9b9c82eb0140c74325a44e262a"}], "stats": {"total": 653, "additions": 318, "deletions": 335}, "files": [{"sha": "bd1d49fb24dc3a8ee0d80ee915d7b66164efe527", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -105,7 +105,7 @@ contributions to the compiler and the standard library. It also lists some\n really useful commands to the build system (`./x.py`), which could save you a\n lot of time.\n \n-[rustcguidebuild]: https://rust-lang.github.io/rustc-guide/how-to-build-and-run.html\n+[rustcguidebuild]: https://rust-lang.github.io/rustc-guide/building/how-to-build-and-run.html\n \n ## Pull Requests\n [pull-requests]: #pull-requests"}, {"sha": "61d3c9e1157203f0c4ed5165608d92294eaca808", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -21,7 +21,7 @@ The Rust build system has a Python script called `x.py` to bootstrap building\n the compiler. More information about it may be found by running `./x.py --help`\n or reading the [rustc guide][rustcguidebuild].\n \n-[rustcguidebuild]: https://rust-lang.github.io/rustc-guide/how-to-build-and-run.html\n+[rustcguidebuild]: https://rust-lang.github.io/rustc-guide/building/how-to-build-and-run.html\n \n ### Building on *nix\n 1. Make sure you have installed the dependencies:"}, {"sha": "8db241e4b4ebf7f0e67713dc0240b112745a83c0", "filename": "src/doc/unstable-book/src/language-features/on-unimplemented.md", "status": "removed", "additions": 0, "deletions": 154, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fon-unimplemented.md", "raw_url": "https://github.com/rust-lang/rust/raw/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fon-unimplemented.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fon-unimplemented.md?ref=caf018714189db0b15f9f803adfcb4572ab7a988", "patch": "@@ -1,154 +0,0 @@\n-# `on_unimplemented`\n-\n-The tracking issue for this feature is: [#29628]\n-\n-[#29628]: https://github.com/rust-lang/rust/issues/29628\n-\n-------------------------\n-\n-The `on_unimplemented` feature provides the `#[rustc_on_unimplemented]`\n-attribute, which allows trait definitions to add specialized notes to error\n-messages when an implementation was expected but not found. You can refer\n-to the trait's generic arguments by name and to the resolved type using\n-`Self`.\n-\n-For example:\n-\n-```rust,compile_fail\n-#![feature(on_unimplemented)]\n-\n-#[rustc_on_unimplemented=\"an iterator over elements of type `{A}` \\\n-    cannot be built from a collection of type `{Self}`\"]\n-trait MyIterator<A> {\n-    fn next(&mut self) -> A;\n-}\n-\n-fn iterate_chars<I: MyIterator<char>>(i: I) {\n-    // ...\n-}\n-\n-fn main() {\n-    iterate_chars(&[1, 2, 3][..]);\n-}\n-```\n-\n-When the user compiles this, they will see the following;\n-\n-```txt\n-error[E0277]: the trait bound `&[{integer}]: MyIterator<char>` is not satisfied\n-  --> <anon>:14:5\n-   |\n-14 |     iterate_chars(&[1, 2, 3][..]);\n-   |     ^^^^^^^^^^^^^ an iterator over elements of type `char` cannot be built from a collection of type `&[{integer}]`\n-   |\n-   = help: the trait `MyIterator<char>` is not implemented for `&[{integer}]`\n-   = note: required by `iterate_chars`\n-```\n-\n-`on_unimplemented` also supports advanced filtering for better targeting\n-of messages, as well as modifying specific parts of the error message. You\n-target the text of:\n-\n- - the main error message (`message`)\n- - the label (`label`)\n- - an extra note (`note`)\n-\n-For example, the following attribute\n-\n-```rust,compile_fail\n-#[rustc_on_unimplemented(\n-    message=\"message\",\n-    label=\"label\",\n-    note=\"note\"\n-)]\n-trait MyIterator<A> {\n-    fn next(&mut self) -> A;\n-}\n-```\n-\n-Would generate the following output:\n-\n-```text\n-error[E0277]: message\n-  --> <anon>:14:5\n-   |\n-14 |     iterate_chars(&[1, 2, 3][..]);\n-   |     ^^^^^^^^^^^^^ label\n-   |\n-   = note: note\n-   = help: the trait `MyIterator<char>` is not implemented for `&[{integer}]`\n-   = note: required by `iterate_chars`\n-```\n-\n-To allow more targeted error messages, it is possible to filter the\n-application of these fields based on a variety of attributes when using\n-`on`:\n-\n- - `crate_local`: whether the code causing the trait bound to not be\n-   fulfilled is part of the user's crate. This is used to avoid suggesting\n-   code changes that would require modifying a dependency.\n- - Any of the generic arguments that can be substituted in the text can be\n-   referred by name as well for filtering, like `Rhs=\"i32\"`, except for\n-   `Self`.\n- - `_Self`: to filter only on a particular calculated trait resolution, like\n-   `Self=\"std::iter::Iterator<char>\"`. This is needed because `Self` is a\n-   keyword which cannot appear in attributes.\n- - `direct`: user-specified rather than derived obligation.\n- - `from_method`: usable both as boolean (whether the flag is present, like\n-   `crate_local`) or matching against a particular method. Currently used\n-   for `try`.\n- - `from_desugaring`: usable both as boolean (whether the flag is present)\n-   or matching against a particular desugaring. The desugaring is identified\n-   with its variant name in the `DesugaringKind` enum.\n-\n-For example, the `Iterator` trait can be annotated in the following way:\n-\n-```rust,compile_fail\n-#[rustc_on_unimplemented(\n-    on(\n-        _Self=\"&str\",\n-        note=\"call `.chars()` or `.as_bytes()` on `{Self}\"\n-    ),\n-    message=\"`{Self}` is not an iterator\",\n-    label=\"`{Self}` is not an iterator\",\n-    note=\"maybe try calling `.iter()` or a similar method\"\n-)]\n-pub trait Iterator {}\n-```\n-\n-Which would produce the following outputs:\n-\n-```text\n-error[E0277]: `Foo` is not an iterator\n- --> src/main.rs:4:16\n-  |\n-4 |     for foo in Foo {}\n-  |                ^^^ `Foo` is not an iterator\n-  |\n-  = note: maybe try calling `.iter()` or a similar method\n-  = help: the trait `std::iter::Iterator` is not implemented for `Foo`\n-  = note: required by `std::iter::IntoIterator::into_iter`\n-\n-error[E0277]: `&str` is not an iterator\n- --> src/main.rs:5:16\n-  |\n-5 |     for foo in \"\" {}\n-  |                ^^ `&str` is not an iterator\n-  |\n-  = note: call `.chars()` or `.bytes() on `&str`\n-  = help: the trait `std::iter::Iterator` is not implemented for `&str`\n-  = note: required by `std::iter::IntoIterator::into_iter`\n-```\n-\n-If you need to filter on multiple attributes, you can use `all`, `any` or\n-`not` in the following way:\n-\n-```rust,compile_fail\n-#[rustc_on_unimplemented(\n-    on(\n-        all(_Self=\"&str\", T=\"std::string::String\"),\n-        note=\"you can coerce a `{T}` into a `{Self}` by writing `&*variable`\"\n-    )\n-)]\n-pub trait From<T>: Sized { /* ... */ }\n-```"}, {"sha": "a0c9263673d74e4a743cbfc89f47ca6ac9bc0d14", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -90,7 +90,7 @@ impl<T> Clone for Iter<'_, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> {\n     // We do *not* exclusively own the entire list here, references to node's `element`\n-    // have been handed out by the iterator!  So be careful when using this; the methods\n+    // have been handed out by the iterator! So be careful when using this; the methods\n     // called must be aware that there can be aliasing pointers to `element`.\n     list: &'a mut LinkedList<T>,\n     head: Option<NonNull<Node<T>>>,"}, {"sha": "ddfa6797a5754639a94fae573fe72739732781d9", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -116,7 +116,7 @@\n #![feature(unsize)]\n #![feature(unsized_locals)]\n #![feature(allocator_internals)]\n-#![feature(on_unimplemented)]\n+#![cfg_attr(bootstrap, feature(on_unimplemented))]\n #![feature(rustc_const_unstable)]\n #![feature(slice_partition_dedup)]\n #![feature(maybe_uninit_extra, maybe_uninit_slice)]"}, {"sha": "a11f9e8c145799c707f009cbbf0552230fd2bd5f", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -280,7 +280,7 @@ struct RcBox<T: ?Sized> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Rc<T: ?Sized> {\n     ptr: NonNull<RcBox<T>>,\n-    phantom: PhantomData<T>,\n+    phantom: PhantomData<RcBox<T>>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "f7dff4c21f7c4343bdb79759ecf7a4755d38b720", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -687,7 +687,7 @@ impl String {\n     /// checked:\n     ///\n     /// * The memory at `ptr` needs to have been previously allocated by the\n-    ///   same allocator the standard library uses.\n+    ///   same allocator the standard library uses, with a required alignment of exactly 1.\n     /// * `length` needs to be less than or equal to `capacity`.\n     /// * `capacity` needs to be the correct value.\n     ///"}, {"sha": "4b10f089c2950f3ad4213e686e60ac1ba456628d", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -195,7 +195,7 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Arc<T: ?Sized> {\n     ptr: NonNull<ArcInner<T>>,\n-    phantom: PhantomData<T>,\n+    phantom: PhantomData<ArcInner<T>>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "817c04d0af924db10119d86dd9765ae28cb739d3", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -137,9 +137,11 @@\n //! use std::cell::Cell;\n //! use std::ptr::NonNull;\n //! use std::intrinsics::abort;\n+//! use std::marker::PhantomData;\n //!\n //! struct Rc<T: ?Sized> {\n-//!     ptr: NonNull<RcBox<T>>\n+//!     ptr: NonNull<RcBox<T>>,\n+//!     phantom: PhantomData<RcBox<T>>,\n //! }\n //!\n //! struct RcBox<T: ?Sized> {\n@@ -151,7 +153,10 @@\n //! impl<T: ?Sized> Clone for Rc<T> {\n //!     fn clone(&self) -> Rc<T> {\n //!         self.inc_strong();\n-//!         Rc { ptr: self.ptr }\n+//!         Rc {\n+//!             ptr: self.ptr,\n+//!             phantom: PhantomData,\n+//!         }\n //!     }\n //! }\n //!"}, {"sha": "ca431627147a8a8ff519fdcf4aec0bab2ae66bd7", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -89,7 +89,7 @@\n #![feature(nll)]\n #![feature(exhaustive_patterns)]\n #![feature(no_core)]\n-#![feature(on_unimplemented)]\n+#![cfg_attr(bootstrap, feature(on_unimplemented))]\n #![feature(optin_builtin_traits)]\n #![feature(prelude_import)]\n #![feature(repr_simd, platform_intrinsics)]"}, {"sha": "03093139bc2f956a1577bb0bbf972afdbab344e9", "filename": "src/libcore/mem/maybe_uninit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -440,6 +440,7 @@ impl<T> MaybeUninit<T> {\n     /// ```\n     #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n     #[inline(always)]\n+    #[cfg_attr(all(not(bootstrap)), rustc_diagnostic_item = \"assume_init\")]\n     pub unsafe fn assume_init(self) -> T {\n         intrinsics::panic_if_uninhabited::<T>();\n         ManuallyDrop::into_inner(self.value)"}, {"sha": "1a13ac465f4363761b45f8b480f00c02c7d816ec", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -18,6 +18,10 @@\n //! * A [null] pointer is *never* valid, not even for accesses of [size zero][zst].\n //! * All pointers (except for the null pointer) are valid for all operations of\n //!   [size zero][zst].\n+//! * For a pointer to be valid, it is necessary, but not always sufficient, that the pointer\n+//!   be *dereferencable*: the memory range of the given size starting at the pointer must all be\n+//!   within the bounds of a single allocated object. Note that in Rust,\n+//!   every (stack-allocated) variable is considered a separate allocated object.\n //! * All accesses performed by functions in this module are *non-atomic* in the sense\n //!   of [atomic operations] used to synchronize between threads. This means it is\n //!   undefined behavior to perform two concurrent accesses to the same location from different\n@@ -221,10 +225,15 @@ pub(crate) struct FatPtr<T> {\n     pub(crate) len: usize,\n }\n \n-/// Forms a slice from a pointer and a length.\n+/// Forms a raw slice from a pointer and a length.\n ///\n /// The `len` argument is the number of **elements**, not the number of bytes.\n ///\n+/// This function is safe, but actually using the return value is unsafe.\n+/// See the documentation of [`from_raw_parts`] for slice safety requirements.\n+///\n+/// [`from_raw_parts`]: ../../std/slice/fn.from_raw_parts.html\n+///\n /// # Examples\n ///\n /// ```rust\n@@ -243,12 +252,16 @@ pub fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n     unsafe { Repr { raw: FatPtr { data, len } }.rust }\n }\n \n-/// Performs the same functionality as [`from_raw_parts`], except that a\n-/// mutable slice is returned.\n+/// Performs the same functionality as [`slice_from_raw_parts`], except that a\n+/// raw mutable slice is returned, as opposed to a raw immutable slice.\n ///\n-/// See the documentation of [`from_raw_parts`] for more details.\n+/// See the documentation of [`slice_from_raw_parts`] for more details.\n ///\n-/// [`from_raw_parts`]: ../../std/slice/fn.from_raw_parts.html\n+/// This function is safe, but actually using the return value is unsafe.\n+/// See the documentation of [`from_raw_parts_mut`] for slice safety requirements.\n+///\n+/// [`slice_from_raw_parts`]: fn.slice_from_raw_parts.html\n+/// [`from_raw_parts_mut`]: ../../std/slice/fn.from_raw_parts_mut.html\n #[inline]\n #[unstable(feature = \"slice_from_raw_parts\", reason = \"recently added\", issue = \"36925\")]\n pub fn slice_from_raw_parts_mut<T>(data: *mut T, len: usize) -> *mut [T] {"}, {"sha": "7655b2f8065324ecce6d63f67bcd0a2802a6f017", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 42, "deletions": 18, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -5272,18 +5272,24 @@ unsafe impl<'a, T> TrustedRandomAccess for RChunksExactMut<'a, T> {\n ///\n /// # Safety\n ///\n-/// This function is unsafe as there is no guarantee that the given pointer is\n-/// valid for `len` elements, nor whether the lifetime inferred is a suitable\n-/// lifetime for the returned slice.\n+/// Behavior is undefined if any of the following conditions are violated:\n ///\n-/// `data` must be non-null and aligned, even for zero-length slices. One\n-/// reason for this is that enum layout optimizations may rely on references\n-/// (including slices of any length) being aligned and non-null to distinguish\n-/// them from other data. You can obtain a pointer that is usable as `data`\n-/// for zero-length slices using [`NonNull::dangling()`].\n+/// * `data` must be [valid] for reads for `len * mem::size_of::<T>()` many bytes,\n+///   and it must be properly aligned. This means in particular:\n ///\n-/// The total size of the slice must be no larger than `isize::MAX` **bytes**\n-/// in memory. See the safety documentation of [`pointer::offset`].\n+///     * The entire memory range of this slice must be contained within a single allocated object!\n+///       Slices can never span across multiple allocated objects.\n+///     * `data` must be non-null and aligned even for zero-length slices. One\n+///       reason for this is that enum layout optimizations may rely on references\n+///       (including slices of any length) being aligned and non-null to distinguish\n+///       them from other data. You can obtain a pointer that is usable as `data`\n+///       for zero-length slices using [`NonNull::dangling()`].\n+///\n+/// * The memory referenced by the returned slice must not be mutated for the duration\n+///   of lifetime `'a`, except inside an `UnsafeCell`.\n+///\n+/// * The total size `len * mem::size_of::<T>()` of the slice must be no larger than `isize::MAX`.\n+///   See the safety documentation of [`pointer::offset`].\n ///\n /// # Caveat\n ///\n@@ -5305,35 +5311,53 @@ unsafe impl<'a, T> TrustedRandomAccess for RChunksExactMut<'a, T> {\n /// assert_eq!(slice[0], 42);\n /// ```\n ///\n+/// [valid]: ../../std/ptr/index.html#safety\n /// [`NonNull::dangling()`]: ../../std/ptr/struct.NonNull.html#method.dangling\n /// [`pointer::offset`]: ../../std/primitive.pointer.html#method.offset\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n     debug_assert!(is_aligned_and_not_null(data), \"attempt to create unaligned or null slice\");\n     debug_assert!(mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize,\n-                  \"attempt to create slice covering half the address space\");\n+                  \"attempt to create slice covering at least half the address space\");\n     &*ptr::slice_from_raw_parts(data, len)\n }\n \n /// Performs the same functionality as [`from_raw_parts`], except that a\n /// mutable slice is returned.\n ///\n-/// This function is unsafe for the same reasons as [`from_raw_parts`], as well\n-/// as not being able to provide a non-aliasing guarantee of the returned\n-/// mutable slice. `data` must be non-null and aligned even for zero-length\n-/// slices as with [`from_raw_parts`]. The total size of the slice must be no\n-/// larger than `isize::MAX` **bytes** in memory.\n+/// # Safety\n+///\n+/// Behavior is undefined if any of the following conditions are violated:\n+///\n+/// * `data` must be [valid] for writes for `len * mem::size_of::<T>()` many bytes,\n+///   and it must be properly aligned. This means in particular:\n ///\n-/// See the documentation of [`from_raw_parts`] for more details.\n+///     * The entire memory range of this slice must be contained within a single allocated object!\n+///       Slices can never span across multiple allocated objects.\n+///     * `data` must be non-null and aligned even for zero-length slices. One\n+///       reason for this is that enum layout optimizations may rely on references\n+///       (including slices of any length) being aligned and non-null to distinguish\n+///       them from other data. You can obtain a pointer that is usable as `data`\n+///       for zero-length slices using [`NonNull::dangling()`].\n ///\n+/// * The memory referenced by the returned slice must not be accessed through any other pointer\n+///   (not derived from the return value) for the duration of lifetime `'a`.\n+///   Both read and write accesses are forbidden.\n+///\n+/// * The total size `len * mem::size_of::<T>()` of the slice must be no larger than `isize::MAX`.\n+///   See the safety documentation of [`pointer::offset`].\n+///\n+/// [valid]: ../../std/ptr/index.html#safety\n+/// [`NonNull::dangling()`]: ../../std/ptr/struct.NonNull.html#method.dangling\n+/// [`pointer::offset`]: ../../std/primitive.pointer.html#method.offset\n /// [`from_raw_parts`]: ../../std/slice/fn.from_raw_parts.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn from_raw_parts_mut<'a, T>(data: *mut T, len: usize) -> &'a mut [T] {\n     debug_assert!(is_aligned_and_not_null(data), \"attempt to create unaligned or null slice\");\n     debug_assert!(mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize,\n-                  \"attempt to create slice covering half the address space\");\n+                  \"attempt to create slice covering at least half the address space\");\n     &mut *ptr::slice_from_raw_parts_mut(data, len)\n }\n "}, {"sha": "18d98efebd42f6878be43612199b84295defee0f", "filename": "src/librustc/error_codes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibrustc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibrustc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ferror_codes.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -607,7 +607,7 @@ position that needs that trait. For example, when the following code is\n compiled:\n \n ```compile_fail\n-#![feature(on_unimplemented)]\n+#![feature(rustc_attrs)]\n \n fn foo<T: Index<u8>>(x: T){}\n \n@@ -639,7 +639,7 @@ position that needs that trait. For example, when the following code is\n compiled:\n \n ```compile_fail\n-#![feature(on_unimplemented)]\n+#![feature(rustc_attrs)]\n \n fn foo<T: Index<u8>>(x: T){}\n \n@@ -669,7 +669,7 @@ position that needs that trait. For example, when the following code is\n compiled:\n \n ```compile_fail\n-#![feature(on_unimplemented)]\n+#![feature(rustc_attrs)]\n \n fn foo<T: Index<u8>>(x: T){}\n "}, {"sha": "d6f7ba6b9734e0fc545a931795239a623c6510c5", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -1616,6 +1616,11 @@ pub enum ExprKind {\n     /// and the remaining elements are the rest of the arguments.\n     /// Thus, `x.foo::<Bar, Baz>(a, b, c, d)` is represented as\n     /// `ExprKind::MethodCall(PathSegment { foo, [Bar, Baz] }, [x, a, b, c, d])`.\n+    ///\n+    /// To resolve the called method to a `DefId`, call [`type_dependent_def_id`] with\n+    /// the `hir_id` of the `MethodCall` node itself.\n+    ///\n+    /// [`type_dependent_def_id`]: ../ty/struct.TypeckTables.html#method.type_dependent_def_id\n     MethodCall(P<PathSegment>, Span, HirVec<Expr>),\n     /// A tuple (e.g., `(a, b, c, d)`).\n     Tup(HirVec<Expr>),\n@@ -1698,6 +1703,10 @@ pub enum ExprKind {\n }\n \n /// Represents an optionally `Self`-qualified value/type path or associated extension.\n+///\n+/// To resolve the path to a `DefId`, call [`qpath_res`].\n+///\n+/// [`qpath_res`]: ../ty/struct.TypeckTables.html#method.qpath_res\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum QPath {\n     /// Path to a definition, optionally \"fully-qualified\" with a `Self`"}, {"sha": "d789fb0de109304748ef35e75039489fa54cdac1", "filename": "src/librustc/infer/region_constraints/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibrustc%2Finfer%2Fregion_constraints%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibrustc%2Finfer%2Fregion_constraints%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2FREADME.md?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -1,3 +1,3 @@\n For info on how the current borrowck works, see the [rustc guide].\n \n-[rustc guide]: https://rust-lang.github.io/rustc-guide/mir/borrowck.html\n+[rustc guide]: https://rust-lang.github.io/rustc-guide/borrow_check.html"}, {"sha": "721baad25639fabce505077c9ccd57fb6b9bc0ce", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -699,6 +699,9 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n \n     /// Check if a `DefId`'s path matches the given absolute type path usage.\n     ///\n+    /// Anonymous scopes such as `extern` imports are matched with `kw::Invalid`;\n+    /// inherent `impl` blocks are matched with the name of the type.\n+    ///\n     /// # Examples\n     ///\n     /// ```rust,ignore (no context or def id available)"}, {"sha": "867f5f76b59bcd34e4a8a5551bdbc07b5e3fb135", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -1909,8 +1909,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n             // `Invalid` represents the empty string and matches that.\n             const TRANSMUTE_PATH: &[Symbol] =\n                 &[sym::core, sym::intrinsics, kw::Invalid, sym::transmute];\n+            const MU_ZEROED_PATH: &[Symbol] =\n+                &[sym::core, sym::mem, sym::maybe_uninit, sym::MaybeUninit, sym::zeroed];\n+            const MU_UNINIT_PATH: &[Symbol] =\n+                &[sym::core, sym::mem, sym::maybe_uninit, sym::MaybeUninit, sym::uninit];\n \n             if let hir::ExprKind::Call(ref path_expr, ref args) = expr.kind {\n+                // Find calls to `mem::{uninitialized,zeroed}` methods.\n                 if let hir::ExprKind::Path(ref qpath) = path_expr.kind {\n                     let def_id = cx.tables.qpath_res(qpath, path_expr.hir_id).opt_def_id()?;\n \n@@ -1925,8 +1930,23 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n                             return Some(InitKind::Zeroed);\n                         }\n                     }\n-                    // FIXME: Also detect `MaybeUninit::zeroed().assume_init()` and\n-                    // `MaybeUninit::uninit().assume_init()`.\n+                }\n+            } else if let hir::ExprKind::MethodCall(_, _, ref args) = expr.kind {\n+                // Find problematic calls to `MaybeUninit::assume_init`.\n+                let def_id = cx.tables.type_dependent_def_id(expr.hir_id)?;\n+                if cx.tcx.is_diagnostic_item(sym::assume_init, def_id) {\n+                    // This is a call to *some* method named `assume_init`.\n+                    // See if the `self` parameter is one of the dangerous constructors.\n+                    if let hir::ExprKind::Call(ref path_expr, _) = args[0].kind {\n+                        if let hir::ExprKind::Path(ref qpath) = path_expr.kind {\n+                            let def_id = cx.tables.qpath_res(qpath, path_expr.hir_id).opt_def_id()?;\n+                            if cx.match_def_path(def_id, MU_ZEROED_PATH) {\n+                                return Some(InitKind::Zeroed);\n+                            } else if cx.match_def_path(def_id, MU_UNINIT_PATH) {\n+                                return Some(InitKind::Uninit);\n+                            }\n+                        }\n+                    }\n                 }\n             }\n \n@@ -1947,6 +1967,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n                 Adt(..) if ty.is_box() => Some((format!(\"`Box` must be non-null\"), None)),\n                 FnPtr(..) => Some((format!(\"Function pointers must be non-null\"), None)),\n                 Never => Some((format!(\"The never type (`!`) has no valid value\"), None)),\n+                RawPtr(tm) if matches!(tm.ty.kind, Dynamic(..)) => // raw ptr to dyn Trait\n+                    Some((format!(\"The vtable of a wide raw pointer must be non-null\"), None)),\n                 // Primitive types with other constraints.\n                 Bool if init == InitKind::Uninit =>\n                     Some((format!(\"Booleans must be `true` or `false`\"), None)),"}, {"sha": "a47980c5ead3091b1bd92fddb86da17ddcd2d099", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -15,6 +15,7 @@\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(nll)]\n+#![feature(matches_macro)]\n \n #![recursion_limit=\"256\"]\n "}, {"sha": "2037305580ad33a23dd9c60a8ca4550cd7f3f9b1", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -260,7 +260,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         match (&src_pointee_ty.kind, &dest_pointee_ty.kind) {\n             (&ty::Array(_, length), &ty::Slice(_)) => {\n-                let ptr = self.read_immediate(src)?.to_scalar_ptr()?;\n+                let ptr = self.read_immediate(src)?.to_scalar()?;\n                 // u64 cast is from usize to u64, which is always good\n                 let val = Immediate::new_slice(\n                     ptr,\n@@ -279,7 +279,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             (_, &ty::Dynamic(ref data, _)) => {\n                 // Initial cast from sized to dyn trait\n                 let vtable = self.get_vtable(src_pointee_ty, data.principal())?;\n-                let ptr = self.read_immediate(src)?.to_scalar_ptr()?;\n+                let ptr = self.read_immediate(src)?.to_scalar()?;\n                 let val = Immediate::new_dyn_trait(ptr, vtable);\n                 self.write_immediate(val, dest)\n             }"}, {"sha": "2171ceaa452c88f9134901485a9ced9f9f9c3900", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -192,20 +192,18 @@ for\n         let ty = mplace.layout.ty;\n         if let ty::Ref(_, referenced_ty, mutability) = ty.kind {\n             let value = self.ecx.read_immediate(mplace.into())?;\n+            let mplace = self.ecx.ref_to_mplace(value)?;\n             // Handle trait object vtables\n-            if let Ok(meta) = value.to_meta() {\n-                if let ty::Dynamic(..) =\n-                    self.ecx.tcx.struct_tail_erasing_lifetimes(\n-                        referenced_ty, self.ecx.param_env).kind\n-                {\n-                    if let Ok(vtable) = meta.unwrap().to_ptr() {\n-                        // explitly choose `Immutable` here, since vtables are immutable, even\n-                        // if the reference of the fat pointer is mutable\n-                        self.intern_shallow(vtable.alloc_id, Mutability::Immutable, None)?;\n-                    }\n+            if let ty::Dynamic(..) =\n+                self.ecx.tcx.struct_tail_erasing_lifetimes(\n+                    referenced_ty, self.ecx.param_env).kind\n+            {\n+                if let Ok(vtable) = mplace.meta.unwrap().to_ptr() {\n+                    // explitly choose `Immutable` here, since vtables are immutable, even\n+                    // if the reference of the fat pointer is mutable\n+                    self.intern_shallow(vtable.alloc_id, Mutability::Immutable, None)?;\n                 }\n             }\n-            let mplace = self.ecx.ref_to_mplace(value)?;\n             // Check if we have encountered this pointer+layout combination before.\n             // Only recurse for allocation-backed pointers.\n             if let Scalar::Ptr(ptr) = mplace.ptr {\n@@ -230,7 +228,7 @@ for\n                             ty::Array(_, n)\n                                 if n.eval_usize(self.ecx.tcx.tcx, self.ecx.param_env) == 0 => {}\n                             ty::Slice(_)\n-                                if value.to_meta().unwrap().unwrap().to_usize(self.ecx)? == 0 => {}\n+                                if mplace.meta.unwrap().to_usize(self.ecx)? == 0 => {}\n                             _ => bug!(\"const qualif failed to prevent mutable references\"),\n                         }\n                     },"}, {"sha": "d80ad3848d20a79cc1bbfa11840be546154476f4", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -82,26 +82,6 @@ impl<'tcx, Tag> Immediate<Tag> {\n             Immediate::ScalarPair(a, b) => Ok((a.not_undef()?, b.not_undef()?))\n         }\n     }\n-\n-    /// Converts the immediate into a pointer (or a pointer-sized integer).\n-    /// Throws away the second half of a ScalarPair!\n-    #[inline]\n-    pub fn to_scalar_ptr(self) -> InterpResult<'tcx, Scalar<Tag>> {\n-        match self {\n-            Immediate::Scalar(ptr) |\n-            Immediate::ScalarPair(ptr, _) => ptr.not_undef(),\n-        }\n-    }\n-\n-    /// Converts the value into its metadata.\n-    /// Throws away the first half of a ScalarPair!\n-    #[inline]\n-    pub fn to_meta(self) -> InterpResult<'tcx, Option<Scalar<Tag>>> {\n-        Ok(match self {\n-            Immediate::Scalar(_) => None,\n-            Immediate::ScalarPair(_, meta) => Some(meta.not_undef()?),\n-        })\n-    }\n }\n \n // ScalarPair needs a type to interpret, so we often have an immediate and a type together"}, {"sha": "36e58d356d1004b732d078b2bb5853f13a2a8666", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -287,17 +287,23 @@ where\n         &self,\n         val: ImmTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n-        let pointee_type = val.layout.ty.builtin_deref(true).unwrap().ty;\n+        let pointee_type = val.layout.ty.builtin_deref(true)\n+            .expect(\"`ref_to_mplace` called on non-ptr type\")\n+            .ty;\n         let layout = self.layout_of(pointee_type)?;\n+        let (ptr, meta) = match *val {\n+            Immediate::Scalar(ptr) => (ptr.not_undef()?, None),\n+            Immediate::ScalarPair(ptr, meta) => (ptr.not_undef()?, Some(meta.not_undef()?)),\n+        };\n \n         let mplace = MemPlace {\n-            ptr: val.to_scalar_ptr()?,\n+            ptr,\n             // We could use the run-time alignment here. For now, we do not, because\n             // the point of tracking the alignment here is to make sure that the *static*\n             // alignment information emitted with the loads is correct. The run-time\n             // alignment can only be more restrictive.\n             align: layout.align.abi,\n-            meta: val.to_meta()?,\n+            meta,\n         };\n         Ok(MPlaceTy { mplace, layout })\n     }"}, {"sha": "8cb2f6c3462cc94083b5a342de4304805db95a29", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 15, "deletions": 29, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -388,44 +388,31 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 }\n             }\n             ty::RawPtr(..) => {\n-                // Check pointer part.\n-                if self.ref_tracking_for_consts.is_some() {\n-                    // Integers/floats in CTFE: For consistency with integers, we do not\n-                    // accept undef.\n-                    let _ptr = try_validation!(value.to_scalar_ptr(),\n-                        \"undefined address in raw pointer\", self.path);\n-                } else {\n-                    // Remain consistent with `usize`: Accept anything.\n-                }\n-\n-                // Check metadata.\n-                let meta = try_validation!(value.to_meta(),\n-                    \"uninitialized data in wide pointer metadata\", self.path);\n-                let layout = self.ecx.layout_of(value.layout.ty.builtin_deref(true).unwrap().ty)?;\n-                if layout.is_unsized() {\n-                    self.check_wide_ptr_meta(meta, layout)?;\n+                // We are conservative with undef for integers, but try to\n+                // actually enforce our current rules for raw pointers.\n+                let place = try_validation!(self.ecx.ref_to_mplace(value),\n+                    \"undefined pointer\", self.path);\n+                if place.layout.is_unsized() {\n+                    self.check_wide_ptr_meta(place.meta, place.layout)?;\n                 }\n             }\n             _ if ty.is_box() || ty.is_region_ptr() => {\n                 // Handle wide pointers.\n                 // Check metadata early, for better diagnostics\n-                let ptr = try_validation!(value.to_scalar_ptr(),\n-                    \"undefined address in pointer\", self.path);\n-                let meta = try_validation!(value.to_meta(),\n-                    \"uninitialized data in wide pointer metadata\", self.path);\n-                let layout = self.ecx.layout_of(value.layout.ty.builtin_deref(true).unwrap().ty)?;\n-                if layout.is_unsized() {\n-                    self.check_wide_ptr_meta(meta, layout)?;\n+                let place = try_validation!(self.ecx.ref_to_mplace(value),\n+                    \"undefined pointer\", self.path);\n+                if place.layout.is_unsized() {\n+                    self.check_wide_ptr_meta(place.meta, place.layout)?;\n                 }\n                 // Make sure this is dereferencable and all.\n-                let (size, align) = self.ecx.size_and_align_of(meta, layout)?\n+                let (size, align) = self.ecx.size_and_align_of(place.meta, place.layout)?\n                     // for the purpose of validity, consider foreign types to have\n                     // alignment and size determined by the layout (size will be 0,\n                     // alignment should take attributes into account).\n-                    .unwrap_or_else(|| (layout.size, layout.align.abi));\n+                    .unwrap_or_else(|| (place.layout.size, place.layout.align.abi));\n                 let ptr: Option<_> = match\n                     self.ecx.memory.check_ptr_access_align(\n-                        ptr,\n+                        place.ptr,\n                         size,\n                         Some(align),\n                         CheckInAllocMsg::InboundsTest,\n@@ -435,7 +422,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     Err(err) => {\n                         info!(\n                             \"{:?} did not pass access check for size {:?}, align {:?}\",\n-                            ptr, size, align\n+                            place.ptr, size, align\n                         );\n                         match err.kind {\n                             err_unsup!(InvalidNullPointerUsage) =>\n@@ -459,7 +446,6 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 };\n                 // Recursive checking\n                 if let Some(ref mut ref_tracking) = self.ref_tracking_for_consts {\n-                    let place = self.ecx.ref_to_mplace(value)?;\n                     if let Some(ptr) = ptr { // not a ZST\n                         // Skip validation entirely for some external statics\n                         let alloc_kind = self.ecx.tcx.alloc_map.lock().get(ptr.alloc_id);\n@@ -627,7 +613,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 // reject it.  However, that's good: We don't inherently want\n                 // to reject those pointers, we just do not have the machinery to\n                 // talk about parts of a pointer.\n-                // We also accept undef, for consistency with the type-based checks.\n+                // We also accept undef, for consistency with the slow path.\n                 match self.ecx.memory.get(ptr.alloc_id)?.check_bytes(\n                     self.ecx,\n                     ptr,"}, {"sha": "927fd2a6b0bc6f2005dc8cd739124acb8c15505a", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -284,7 +284,7 @@\n #![feature(never_type)]\n #![feature(nll)]\n #![cfg_attr(bootstrap, feature(non_exhaustive))]\n-#![feature(on_unimplemented)]\n+#![cfg_attr(bootstrap, feature(on_unimplemented))]\n #![feature(optin_builtin_traits)]\n #![feature(panic_info_message)]\n #![feature(panic_internals)]"}, {"sha": "46453b47fca8dcc6077d3dbcd5ac22cb049dac8f", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -149,7 +149,7 @@ macro_rules! thread_local {\n #[allow_internal_unstable(thread_local_internals, cfg_target_thread_local, thread_local)]\n #[allow_internal_unsafe]\n macro_rules! __thread_local_inner {\n-    (@key $(#[$attr:meta])* $vis:vis $name:ident, $t:ty, $init:expr) => {\n+    (@key $t:ty, $init:expr) => {\n         {\n             #[inline]\n             fn __init() -> $t { $init }\n@@ -184,7 +184,7 @@ macro_rules! __thread_local_inner {\n     };\n     ($(#[$attr:meta])* $vis:vis $name:ident, $t:ty, $init:expr) => {\n         $(#[$attr])* $vis const $name: $crate::thread::LocalKey<$t> =\n-            $crate::__thread_local_inner!(@key $(#[$attr])* $vis $name, $t, $init);\n+            $crate::__thread_local_inner!(@key $t, $init);\n     }\n }\n "}, {"sha": "0c632d2afbdd4b449a80113133c052d71a92ea49", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -1271,6 +1271,18 @@ impl fmt::Debug for Thread {\n ///\n /// Indicates the manner in which a thread exited.\n ///\n+/// The value contained in the `Result::Err` variant\n+/// is the value the thread panicked with;\n+/// that is, the argument the `panic!` macro was called with.\n+/// Unlike with normal errors, this value doesn't implement\n+/// the [`Error`](crate::error::Error) trait.\n+///\n+/// Thus, a sensible way to handle a thread panic is to either:\n+/// 1. `unwrap` the `Result<T>`, propagating the panic\n+/// 2. or in case the thread is intended to be a subsystem boundary\n+/// that is supposed to isolate system-level failures,\n+/// match on the `Err` variant and handle the panic in an appropriate way.\n+///\n /// A thread that completes without panicking is considered to exit successfully.\n ///\n /// # Examples"}, {"sha": "1e77eaaae881d1a029abfc93d49e246989c2f2b5", "filename": "src/libsyntax/feature_gate/active.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibsyntax%2Ffeature_gate%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibsyntax%2Ffeature_gate%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Factive.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -134,9 +134,6 @@ declare_features! (\n     /// Allows using `rustc_*` attributes (RFC 572).\n     (active, rustc_attrs, \"1.0.0\", Some(29642), None),\n \n-    /// Allows using `#[on_unimplemented(..)]` on traits.\n-    (active, on_unimplemented, \"1.0.0\", Some(29628), None),\n-\n     /// Allows using the `box $expr` syntax.\n     (active, box_syntax, \"1.0.0\", Some(49733), None),\n "}, {"sha": "b32a887c6b2a2e456275b260fbec240f5588f2ac", "filename": "src/libsyntax/feature_gate/builtin_attrs.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -166,7 +166,7 @@ macro_rules! experimental {\n }\n \n const IMPL_DETAIL: &str = \"internal implementation detail\";\n-const INTERAL_UNSTABLE: &str = \"this is an internal attribute that will never be stable\";\n+const INTERNAL_UNSTABLE: &str = \"this is an internal attribute that will never be stable\";\n \n pub type BuiltinAttribute = (Symbol, AttributeType, AttributeTemplate, AttributeGate);\n \n@@ -418,14 +418,14 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         linkage, Whitelisted, template!(NameValueStr: \"external|internal|...\"),\n         \"the `linkage` attribute is experimental and not portable across platforms\",\n     ),\n-    rustc_attr!(rustc_std_internal_symbol, Whitelisted, template!(Word), INTERAL_UNSTABLE),\n+    rustc_attr!(rustc_std_internal_symbol, Whitelisted, template!(Word), INTERNAL_UNSTABLE),\n \n     // ==========================================================================\n     // Internal attributes, Macro related:\n     // ==========================================================================\n \n     rustc_attr!(rustc_builtin_macro, Whitelisted, template!(Word), IMPL_DETAIL),\n-    rustc_attr!(rustc_proc_macro_decls, Normal, template!(Word), INTERAL_UNSTABLE),\n+    rustc_attr!(rustc_proc_macro_decls, Normal, template!(Word), INTERNAL_UNSTABLE),\n     rustc_attr!(\n         rustc_macro_transparency, Whitelisted,\n         template!(NameValueStr: \"transparent|semitransparent|opaque\"),\n@@ -436,25 +436,24 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // Internal attributes, Diagnostics related:\n     // ==========================================================================\n \n-    gated!(\n+    rustc_attr!(\n         rustc_on_unimplemented, Whitelisted,\n         template!(\n             List: r#\"/*opt*/ message = \"...\", /*opt*/ label = \"...\", /*opt*/ note = \"...\"\"#,\n             NameValueStr: \"message\"\n         ),\n-        on_unimplemented,\n-        experimental!(rustc_on_unimplemented),\n+        INTERNAL_UNSTABLE\n     ),\n     // Whitelists \"identity-like\" conversion methods to suggest on type mismatch.\n-    rustc_attr!(rustc_conversion_suggestion, Whitelisted, template!(Word), INTERAL_UNSTABLE),\n+    rustc_attr!(rustc_conversion_suggestion, Whitelisted, template!(Word), INTERNAL_UNSTABLE),\n \n     // ==========================================================================\n     // Internal attributes, Const related:\n     // ==========================================================================\n \n     rustc_attr!(rustc_promotable, Whitelisted, template!(Word), IMPL_DETAIL),\n     rustc_attr!(rustc_allow_const_fn_ptr, Whitelisted, template!(Word), IMPL_DETAIL),\n-    rustc_attr!(rustc_args_required_const, Whitelisted, template!(List: \"N\"), INTERAL_UNSTABLE),\n+    rustc_attr!(rustc_args_required_const, Whitelisted, template!(List: \"N\"), INTERNAL_UNSTABLE),\n \n     // ==========================================================================\n     // Internal attributes, Layout related:"}, {"sha": "c7b931a6f7021e1fa6c53a8b0071066c830af31b", "filename": "src/libsyntax/feature_gate/removed.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibsyntax%2Ffeature_gate%2Fremoved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibsyntax%2Ffeature_gate%2Fremoved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fremoved.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -99,6 +99,9 @@ declare_features! (\n     /// + `__register_diagnostic`\n     /// +`__build_diagnostic_array`\n     (removed, rustc_diagnostic_macros, \"1.38.0\", None, None, None),\n+    /// Allows using `#[on_unimplemented(..)]` on traits.\n+    /// (Moved to `rustc_attrs`.)\n+    (removed, on_unimplemented, \"1.40.0\", None, None, None),\n \n     // -------------------------------------------------------------------------\n     // feature-group-end: removed features"}, {"sha": "64ea82e1bdc53cb592cf1f6b50916b895fef9534", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -148,6 +148,7 @@ symbols! {\n         associated_type_bounds,\n         associated_type_defaults,\n         associated_types,\n+        assume_init,\n         async_await,\n         async_closure,\n         attr,\n@@ -417,6 +418,8 @@ symbols! {\n         match_beginning_vert,\n         match_default_bindings,\n         may_dangle,\n+        maybe_uninit,\n+        MaybeUninit,\n         mem,\n         member_constraints,\n         message,\n@@ -709,6 +712,7 @@ symbols! {\n         underscore_imports,\n         underscore_lifetimes,\n         uniform_paths,\n+        uninit,\n         uninitialized,\n         universal_impl_trait,\n         unmarked_api,"}, {"sha": "8aeee5859d0adedcf8be1436101ebe03aa35e840", "filename": "src/test/codegen/abi-efiapi.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Ftest%2Fcodegen%2Fabi-efiapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Ftest%2Fcodegen%2Fabi-efiapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fabi-efiapi.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -1,14 +1,12 @@\n // Checks if the correct annotation for the efiapi ABI is passed to llvm.\n \n-// revisions:x86_64 i686 aarch64 arm riscv\n+// revisions:x86_64 i686 arm\n \n // min-llvm-version 9.0\n \n //[x86_64] compile-flags: --target x86_64-unknown-uefi\n //[i686] compile-flags: --target i686-unknown-linux-musl\n-//[aarch64] compile-flags: --target aarch64-unknown-none\n //[arm] compile-flags: --target armv7r-none-eabi\n-//[riscv] compile-flags: --target riscv64gc-unknown-none-elf\n // compile-flags: -C no-prepopulate-passes\n \n #![crate_type = \"lib\"]\n@@ -24,8 +22,6 @@ trait Copy { }\n \n //x86_64: define win64cc void @has_efiapi\n //i686: define void @has_efiapi\n-//aarch64: define void @has_efiapi\n //arm: define void @has_efiapi\n-//riscv: define void @has_efiapi\n #[no_mangle]\n pub extern \"efiapi\" fn has_efiapi() {}"}, {"sha": "fa52ca90b105f5a53fdea7ba53d95191399a2faf", "filename": "src/test/incremental/issue-59523-on-implemented-is-not-unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Ftest%2Fincremental%2Fissue-59523-on-implemented-is-not-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Ftest%2Fincremental%2Fissue-59523-on-implemented-is-not-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-59523-on-implemented-is-not-unused.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -5,7 +5,7 @@\n // revisions: cfail1 cfail2\n // build-pass (FIXME(62277): could be check-pass?)\n \n-#![feature(on_unimplemented)]\n+#![feature(rustc_attrs)]\n #![deny(unused_attributes)]\n \n #[rustc_on_unimplemented = \"invalid\"]"}, {"sha": "96fb16b1fcc8f4457208f9e0599f13c2980b13a8", "filename": "src/test/run-make-fulldeps/long-linker-command-lines/foo.rs", "status": "modified", "additions": 44, "deletions": 29, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Ftest%2Frun-make-fulldeps%2Flong-linker-command-lines%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Ftest%2Frun-make-fulldeps%2Flong-linker-command-lines%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Flong-linker-command-lines%2Ffoo.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -7,12 +7,43 @@\n // Eventually we should see an argument that looks like `@` as we switch from\n // passing literal arguments to passing everything in the file.\n \n+use std::collections::HashSet;\n use std::env;\n use std::fs::{self, File};\n-use std::io::{BufWriter, Write, Read};\n-use std::path::PathBuf;\n+use std::io::{BufWriter, Write};\n+use std::path::{Path, PathBuf};\n use std::process::Command;\n \n+fn write_test_case(file: &Path, n: usize) -> HashSet<String> {\n+    let mut libs = HashSet::new();\n+    let mut f = BufWriter::new(File::create(&file).unwrap());\n+    let mut prefix = String::new();\n+    for _ in 0..n {\n+        prefix.push_str(\"foo\");\n+    }\n+    for i in 0..n {\n+        writeln!(f, \"#[link(name = \\\"S{}{}S\\\")]\", prefix, i).unwrap();\n+        libs.insert(format!(\"{}{}\", prefix, i));\n+    }\n+    writeln!(f, \"extern {{}}\\nfn main() {{}}\").unwrap();\n+    f.into_inner().unwrap();\n+\n+    libs\n+}\n+\n+fn read_linker_args(path: &Path) -> String {\n+    let contents = fs::read(path).unwrap();\n+    if cfg!(target_env = \"msvc\") {\n+        let mut i = contents.chunks(2).map(|c| {\n+            c[0] as u16 | ((c[1] as u16) << 8)\n+        });\n+        assert_eq!(i.next(), Some(0xfeff), \"Expected UTF-16 BOM\");\n+        String::from_utf16(&i.collect::<Vec<u16>>()).unwrap()\n+    } else {\n+        String::from_utf8(contents).unwrap()\n+    }\n+}\n+\n fn main() {\n     let tmpdir = PathBuf::from(env::var_os(\"TMPDIR\").unwrap());\n     let ok = tmpdir.join(\"ok\");\n@@ -29,16 +60,7 @@ fn main() {\n     for i in (1..).map(|i| i * 100) {\n         println!(\"attempt: {}\", i);\n         let file = tmpdir.join(\"bar.rs\");\n-        let mut f = BufWriter::new(File::create(&file).unwrap());\n-        let mut lib_name = String::new();\n-        for _ in 0..i {\n-            lib_name.push_str(\"foo\");\n-        }\n-        for j in 0..i {\n-            writeln!(f, \"#[link(name = \\\"{}{}\\\")]\", lib_name, j).unwrap();\n-        }\n-        writeln!(f, \"extern {{}}\\nfn main() {{}}\").unwrap();\n-        f.into_inner().unwrap();\n+        let mut expected_libs = write_test_case(&file, i);\n \n         drop(fs::remove_file(&ok));\n         let output = Command::new(&rustc)\n@@ -67,25 +89,18 @@ fn main() {\n             continue\n         }\n \n-        let mut contents = Vec::new();\n-        File::open(&ok).unwrap().read_to_end(&mut contents).unwrap();\n-\n-        for j in 0..i {\n-            let exp = format!(\"{}{}\", lib_name, j);\n-            let exp = if cfg!(target_env = \"msvc\") {\n-                let mut out = Vec::with_capacity(exp.len() * 2);\n-                for c in exp.encode_utf16() {\n-                    // encode in little endian\n-                    out.push(c as u8);\n-                    out.push((c >> 8) as u8);\n-                }\n-                out\n-            } else {\n-                exp.into_bytes()\n-            };\n-            assert!(contents.windows(exp.len()).any(|w| w == &exp[..]));\n+        let linker_args = read_linker_args(&ok);\n+        for mut arg in linker_args.split('S') {\n+            expected_libs.remove(arg);\n         }\n \n+        assert!(\n+            expected_libs.is_empty(),\n+            \"expected but missing libraries: {:#?}\\nlinker arguments: \\n{}\",\n+            expected_libs,\n+            linker_args,\n+        );\n+\n         break\n     }\n }"}, {"sha": "85fb8ac2a4a367edea8a8413d676f38ebbf22101", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -42,7 +42,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:107:1\n    |\n LL | const SLICE_LENGTH_UNINIT: &[u8] = unsafe { SliceTransmute { addr: 42 }.slice};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized data in wide pointer metadata\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered undefined pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n@@ -90,7 +90,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:133:1\n    |\n LL | const RAW_SLICE_LENGTH_UNINIT: *const [u8] = unsafe { SliceTransmute { addr: 42 }.raw_slice};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized data in wide pointer metadata\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered undefined pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "bec1531c5338fbe25aea382d0be356a688bac15b", "filename": "src/test/ui/feature-gates/feature-gate-on-unimplemented.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-on-unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caf018714189db0b15f9f803adfcb4572ab7a988/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-on-unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-on-unimplemented.rs?ref=caf018714189db0b15f9f803adfcb4572ab7a988", "patch": "@@ -1,9 +0,0 @@\n-// Test that `#[rustc_on_unimplemented]` is gated by `on_unimplemented` feature\n-// gate.\n-\n-#[rustc_on_unimplemented = \"test error `{Self}` with `{Bar}`\"]\n-//~^ ERROR the `#[rustc_on_unimplemented]` attribute is an experimental feature\n-trait Foo<Bar>\n-{}\n-\n-fn main() {}"}, {"sha": "473be434a7524931c374fe960c661e17176f3ded", "filename": "src/test/ui/lint/uninitialized-zeroed.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -67,6 +67,9 @@ fn main() {\n         let _val: NonNull<i32> = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n         let _val: NonNull<i32> = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n \n+        let _val: *const dyn Send = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: *const dyn Send = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n         // Things that can be zero, but not uninit.\n         let _val: bool = mem::zeroed();\n         let _val: bool = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n@@ -82,10 +85,16 @@ fn main() {\n         let _val: &'static [i32] = mem::transmute((0usize, 0usize)); //~ ERROR: does not permit zero-initialization\n         let _val: NonZeroU32 = mem::transmute(0); //~ ERROR: does not permit zero-initialization\n \n+        // `MaybeUninit` cases\n+        let _val: NonNull<i32> = MaybeUninit::zeroed().assume_init(); //~ ERROR: does not permit zero-initialization\n+        let _val: NonNull<i32> = MaybeUninit::uninit().assume_init(); //~ ERROR: does not permit being left uninitialized\n+        let _val: bool = MaybeUninit::uninit().assume_init(); //~ ERROR: does not permit being left uninitialized\n+\n         // Some more types that should work just fine.\n         let _val: Option<&'static i32> = mem::zeroed();\n         let _val: Option<fn()> = mem::zeroed();\n         let _val: MaybeUninit<&'static i32> = mem::zeroed();\n         let _val: i32 = mem::zeroed();\n+        let _val: bool = MaybeUninit::zeroed().assume_init();\n     }\n }"}, {"sha": "e12b1897ade1b667bdec9f10d152601c7020129b", "filename": "src/test/ui/lint/uninitialized-zeroed.stderr", "status": "modified", "additions": 62, "deletions": 7, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -307,8 +307,30 @@ LL |         let _val: NonNull<i32> = mem::uninitialized();\n    |\n    = note: std::ptr::NonNull<i32> must be non-null\n \n+error: the type `*const dyn std::marker::Send` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:70:37\n+   |\n+LL |         let _val: *const dyn Send = mem::zeroed();\n+   |                                     ^^^^^^^^^^^^^\n+   |                                     |\n+   |                                     this code causes undefined behavior when executed\n+   |                                     help: use `MaybeUninit<T>` instead\n+   |\n+   = note: The vtable of a wide raw pointer must be non-null\n+\n+error: the type `*const dyn std::marker::Send` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:71:37\n+   |\n+LL |         let _val: *const dyn Send = mem::uninitialized();\n+   |                                     ^^^^^^^^^^^^^^^^^^^^\n+   |                                     |\n+   |                                     this code causes undefined behavior when executed\n+   |                                     help: use `MaybeUninit<T>` instead\n+   |\n+   = note: The vtable of a wide raw pointer must be non-null\n+\n error: the type `bool` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:72:26\n+  --> $DIR/uninitialized-zeroed.rs:75:26\n    |\n LL |         let _val: bool = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n@@ -319,7 +341,7 @@ LL |         let _val: bool = mem::uninitialized();\n    = note: Booleans must be `true` or `false`\n \n error: the type `Wrap<char>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:75:32\n+  --> $DIR/uninitialized-zeroed.rs:78:32\n    |\n LL |         let _val: Wrap<char> = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n@@ -334,7 +356,7 @@ LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `NonBig` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:78:28\n+  --> $DIR/uninitialized-zeroed.rs:81:28\n    |\n LL |         let _val: NonBig = mem::uninitialized();\n    |                            ^^^^^^^^^^^^^^^^^^^^\n@@ -345,7 +367,7 @@ LL |         let _val: NonBig = mem::uninitialized();\n    = note: NonBig must be initialized inside its custom valid range\n \n error: the type `&'static i32` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:81:34\n+  --> $DIR/uninitialized-zeroed.rs:84:34\n    |\n LL |         let _val: &'static i32 = mem::transmute(0usize);\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^\n@@ -356,7 +378,7 @@ LL |         let _val: &'static i32 = mem::transmute(0usize);\n    = note: References must be non-null\n \n error: the type `&'static [i32]` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:82:36\n+  --> $DIR/uninitialized-zeroed.rs:85:36\n    |\n LL |         let _val: &'static [i32] = mem::transmute((0usize, 0usize));\n    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -367,7 +389,7 @@ LL |         let _val: &'static [i32] = mem::transmute((0usize, 0usize));\n    = note: References must be non-null\n \n error: the type `std::num::NonZeroU32` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:83:32\n+  --> $DIR/uninitialized-zeroed.rs:86:32\n    |\n LL |         let _val: NonZeroU32 = mem::transmute(0);\n    |                                ^^^^^^^^^^^^^^^^^\n@@ -377,5 +399,38 @@ LL |         let _val: NonZeroU32 = mem::transmute(0);\n    |\n    = note: std::num::NonZeroU32 must be non-null\n \n-error: aborting due to 30 previous errors\n+error: the type `std::ptr::NonNull<i32>` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:89:34\n+   |\n+LL |         let _val: NonNull<i32> = MaybeUninit::zeroed().assume_init();\n+   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                  |\n+   |                                  this code causes undefined behavior when executed\n+   |                                  help: use `MaybeUninit<T>` instead\n+   |\n+   = note: std::ptr::NonNull<i32> must be non-null\n+\n+error: the type `std::ptr::NonNull<i32>` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:90:34\n+   |\n+LL |         let _val: NonNull<i32> = MaybeUninit::uninit().assume_init();\n+   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                  |\n+   |                                  this code causes undefined behavior when executed\n+   |                                  help: use `MaybeUninit<T>` instead\n+   |\n+   = note: std::ptr::NonNull<i32> must be non-null\n+\n+error: the type `bool` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:91:26\n+   |\n+LL |         let _val: bool = MaybeUninit::uninit().assume_init();\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                          |\n+   |                          this code causes undefined behavior when executed\n+   |                          help: use `MaybeUninit<T>` instead\n+   |\n+   = note: Booleans must be `true` or `false`\n+\n+error: aborting due to 35 previous errors\n "}, {"sha": "f05436b8c048a438f8eedecfd362536b92b10c2f", "filename": "src/test/ui/on-unimplemented/bad-annotation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Ftest%2Fui%2Fon-unimplemented%2Fbad-annotation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Ftest%2Fui%2Fon-unimplemented%2Fbad-annotation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fon-unimplemented%2Fbad-annotation.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -1,6 +1,6 @@\n // ignore-tidy-linelength\n \n-#![feature(on_unimplemented)]\n+#![feature(rustc_attrs)]\n \n #![allow(unused)]\n "}, {"sha": "77c0ea17269f0e07ee29bff5d4dd8f51c63c370e", "filename": "src/test/ui/on-unimplemented/expected-comma-found-token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Ftest%2Fui%2Fon-unimplemented%2Fexpected-comma-found-token.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Ftest%2Fui%2Fon-unimplemented%2Fexpected-comma-found-token.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fon-unimplemented%2Fexpected-comma-found-token.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -2,7 +2,7 @@\n // access to the variable, whether that mutable access be used\n // for direct assignment or for taking mutable ref. Issue #6801.\n \n-#![feature(on_unimplemented)]\n+#![feature(rustc_attrs)]\n \n #[rustc_on_unimplemented(\n     message=\"the message\""}, {"sha": "3cc50e3499a09c3f8f36dbfadb887343fe7b6e87", "filename": "src/test/ui/on-unimplemented/feature-gate-on-unimplemented.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Ftest%2Fui%2Fon-unimplemented%2Ffeature-gate-on-unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Ftest%2Fui%2Fon-unimplemented%2Ffeature-gate-on-unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fon-unimplemented%2Ffeature-gate-on-unimplemented.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -0,0 +1,8 @@\n+// Test that `#[rustc_on_unimplemented]` is gated by `rustc_attrs` feature gate.\n+\n+#[rustc_on_unimplemented = \"test error `{Self}` with `{Bar}`\"]\n+//~^ ERROR this is an internal attribute that will never be stable\n+trait Foo<Bar>\n+{}\n+\n+fn main() {}"}, {"sha": "ec1eaff52bd7d7fc165f6d81f066ad5dfad1e669", "filename": "src/test/ui/on-unimplemented/feature-gate-on-unimplemented.stderr", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Ftest%2Fui%2Fon-unimplemented%2Ffeature-gate-on-unimplemented.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Ftest%2Fui%2Fon-unimplemented%2Ffeature-gate-on-unimplemented.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fon-unimplemented%2Ffeature-gate-on-unimplemented.stderr?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -1,11 +1,11 @@\n-error[E0658]: the `#[rustc_on_unimplemented]` attribute is an experimental feature\n-  --> $DIR/feature-gate-on-unimplemented.rs:4:1\n+error[E0658]: this is an internal attribute that will never be stable\n+  --> $DIR/feature-gate-on-unimplemented.rs:3:1\n    |\n LL | #[rustc_on_unimplemented = \"test error `{Self}` with `{Bar}`\"]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/29628\n-   = help: add `#![feature(on_unimplemented)]` to the crate attributes to enable\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n+   = help: add `#![feature(rustc_attrs)]` to the crate attributes to enable\n \n error: aborting due to previous error\n ", "previous_filename": "src/test/ui/feature-gates/feature-gate-on-unimplemented.stderr"}, {"sha": "b74957ebcd406b8a9b918de6d0a3443b1a13e798", "filename": "src/test/ui/on-unimplemented/multiple-impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Ftest%2Fui%2Fon-unimplemented%2Fmultiple-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Ftest%2Fui%2Fon-unimplemented%2Fmultiple-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fon-unimplemented%2Fmultiple-impls.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -1,6 +1,6 @@\n // Test if the on_unimplemented message override works\n \n-#![feature(on_unimplemented)]\n+#![feature(rustc_attrs)]\n \n \n struct Foo<T>(T);"}, {"sha": "ab3e67d01fe44ea75a5ae75937a88068f2fe95a1", "filename": "src/test/ui/on-unimplemented/on-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Ftest%2Fui%2Fon-unimplemented%2Fon-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Ftest%2Fui%2Fon-unimplemented%2Fon-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fon-unimplemented%2Fon-impl.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -1,6 +1,6 @@\n // Test if the on_unimplemented message override works\n \n-#![feature(on_unimplemented)]\n+#![feature(rustc_attrs)]\n \n \n #[rustc_on_unimplemented = \"invalid\"]"}, {"sha": "556813cd4795f6e31ed13240e3bbd89b32d85104", "filename": "src/test/ui/on-unimplemented/on-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Ftest%2Fui%2Fon-unimplemented%2Fon-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a76fe76f756895b8cda1e10398f2268656a2e0f/src%2Ftest%2Fui%2Fon-unimplemented%2Fon-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fon-unimplemented%2Fon-trait.rs?ref=7a76fe76f756895b8cda1e10398f2268656a2e0f", "patch": "@@ -1,6 +1,6 @@\n // ignore-tidy-linelength\n \n-#![feature(on_unimplemented)]\n+#![feature(rustc_attrs)]\n \n pub mod Bar {\n   #[rustc_on_unimplemented = \"test error `{Self}` with `{Bar}` `{Baz}` `{Quux}` in `{Foo}`\"]"}]}