{"sha": "daf1b29f298ec7e5c345764554e6d03ac65134de", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhZjFiMjlmMjk4ZWM3ZTVjMzQ1NzY0NTU0ZTZkMDNhYzY1MTM0ZGU=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-07-09T13:32:25Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-07-10T11:13:22Z"}, "message": "Properly case indent_unit constant", "tree": {"sha": "e264aa0acabaf8230e0cb463013a605f3eda009f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e264aa0acabaf8230e0cb463013a605f3eda009f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/daf1b29f298ec7e5c345764554e6d03ac65134de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/daf1b29f298ec7e5c345764554e6d03ac65134de", "html_url": "https://github.com/rust-lang/rust/commit/daf1b29f298ec7e5c345764554e6d03ac65134de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/daf1b29f298ec7e5c345764554e6d03ac65134de/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cab453250a3ceae5cf0cf7eac836c03b37e4ca8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/cab453250a3ceae5cf0cf7eac836c03b37e4ca8e", "html_url": "https://github.com/rust-lang/rust/commit/cab453250a3ceae5cf0cf7eac836c03b37e4ca8e"}], "stats": {"total": 53, "additions": 26, "deletions": 27}, "files": [{"sha": "9fb85410fc77aa4e5f2b9d253b8dea0cccfc0441", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf1b29f298ec7e5c345764554e6d03ac65134de/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf1b29f298ec7e5c345764554e6d03ac65134de/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=daf1b29f298ec7e5c345764554e6d03ac65134de", "patch": "@@ -1213,7 +1213,7 @@ impl<'a> print::State<'a> {\n             Node::Arm(a)          => self.print_arm(&a),\n             Node::Block(a)        => {\n                 // containing cbox, will be closed by print-block at }\n-                self.cbox(print::indent_unit);\n+                self.cbox(print::INDENT_UNIT);\n                 // head-ibox, will be closed by print-block after {\n                 self.ibox(0);\n                 self.print_block(&a)"}, {"sha": "dd5d8ebde1c8c57e1c327d8782850021289bfa30", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/daf1b29f298ec7e5c345764554e6d03ac65134de/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf1b29f298ec7e5c345764554e6d03ac65134de/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=daf1b29f298ec7e5c345764554e6d03ac65134de", "patch": "@@ -96,8 +96,7 @@ impl<'a> PrintState<'a> for State<'a> {\n     }\n }\n \n-#[allow(non_upper_case_globals)]\n-pub const indent_unit: usize = 4;\n+pub const INDENT_UNIT: usize = 4;\n \n /// Requires you to pass an input filename and reader so that\n /// it can scan the input text for comments to copy forward.\n@@ -168,7 +167,7 @@ impl<'a> State<'a> {\n     pub fn head<S: Into<Cow<'static, str>>>(&mut self, w: S) {\n         let w = w.into();\n         // outer-box is consistent\n-        self.cbox(indent_unit);\n+        self.cbox(INDENT_UNIT);\n         // head-box is inconsistent\n         self.ibox(w.len() + 1);\n         // keyword that starts the head\n@@ -196,7 +195,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn bclose(&mut self, span: syntax_pos::Span) {\n-        self.bclose_maybe_open(span, indent_unit, true)\n+        self.bclose_maybe_open(span, INDENT_UNIT, true)\n     }\n \n     pub fn space_if_not_bol(&mut self) {\n@@ -732,7 +731,7 @@ impl<'a> State<'a> {\n             self.space_if_not_bol();\n             self.maybe_print_comment(v.span.lo());\n             self.print_outer_attributes(&v.node.attrs);\n-            self.ibox(indent_unit);\n+            self.ibox(INDENT_UNIT);\n             self.print_variant(v);\n             self.s.word(\",\");\n             self.end();\n@@ -919,10 +918,10 @@ impl<'a> State<'a> {\n         decl: impl Fn(&mut Self)\n     ) {\n         self.space_if_not_bol();\n-        self.ibox(indent_unit);\n+        self.ibox(INDENT_UNIT);\n         self.word_nbsp(\"let\");\n \n-        self.ibox(indent_unit);\n+        self.ibox(INDENT_UNIT);\n         decl(self);\n         self.end();\n \n@@ -964,7 +963,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_block_unclosed(&mut self, blk: &hir::Block) {\n-        self.print_block_unclosed_indent(blk, indent_unit)\n+        self.print_block_unclosed_indent(blk, INDENT_UNIT)\n     }\n \n     pub fn print_block_unclosed_indent(&mut self,\n@@ -978,7 +977,7 @@ impl<'a> State<'a> {\n                                   blk: &hir::Block,\n                                   attrs: &[ast::Attribute])\n                                   {\n-        self.print_block_maybe_unclosed(blk, indent_unit, attrs, true)\n+        self.print_block_maybe_unclosed(blk, INDENT_UNIT, attrs, true)\n     }\n \n     pub fn print_block_maybe_unclosed(&mut self,\n@@ -1055,15 +1054,15 @@ impl<'a> State<'a> {\n     }\n \n     fn print_expr_vec(&mut self, exprs: &[hir::Expr]) {\n-        self.ibox(indent_unit);\n+        self.ibox(INDENT_UNIT);\n         self.s.word(\"[\");\n         self.commasep_exprs(Inconsistent, exprs);\n         self.s.word(\"]\");\n         self.end()\n     }\n \n     fn print_expr_repeat(&mut self, element: &hir::Expr, count: &hir::AnonConst) {\n-        self.ibox(indent_unit);\n+        self.ibox(INDENT_UNIT);\n         self.s.word(\"[\");\n         self.print_expr(element);\n         self.word_space(\";\");\n@@ -1082,7 +1081,7 @@ impl<'a> State<'a> {\n         self.commasep_cmnt(Consistent,\n                            &fields[..],\n                            |s, field| {\n-                               s.ibox(indent_unit);\n+                               s.ibox(INDENT_UNIT);\n                                if !field.is_shorthand {\n                                     s.print_ident(field.ident);\n                                     s.word_space(\":\");\n@@ -1093,7 +1092,7 @@ impl<'a> State<'a> {\n                            |f| f.span);\n         match *wth {\n             Some(ref expr) => {\n-                self.ibox(indent_unit);\n+                self.ibox(INDENT_UNIT);\n                 if !fields.is_empty() {\n                     self.s.word(\",\");\n                     self.s.space();\n@@ -1198,7 +1197,7 @@ impl<'a> State<'a> {\n     pub fn print_expr(&mut self, expr: &hir::Expr) {\n         self.maybe_print_comment(expr.span.lo());\n         self.print_outer_attributes(&expr.attrs);\n-        self.ibox(indent_unit);\n+        self.ibox(INDENT_UNIT);\n         self.ann.pre(self, AnnNode::Expr(expr));\n         match expr.node {\n             hir::ExprKind::Box(ref expr) => {\n@@ -1250,7 +1249,7 @@ impl<'a> State<'a> {\n             }\n             hir::ExprKind::DropTemps(ref init) => {\n                 // Print `{`:\n-                self.cbox(indent_unit);\n+                self.cbox(INDENT_UNIT);\n                 self.ibox(0);\n                 self.bopen();\n \n@@ -1264,7 +1263,7 @@ impl<'a> State<'a> {\n                 self.print_ident(temp);\n \n                 // Print `}`:\n-                self.bclose_maybe_open(expr.span, indent_unit, true);\n+                self.bclose_maybe_open(expr.span, INDENT_UNIT, true);\n             }\n             hir::ExprKind::Loop(ref blk, opt_label, _) => {\n                 if let Some(label) = opt_label {\n@@ -1276,7 +1275,7 @@ impl<'a> State<'a> {\n                 self.print_block(&blk);\n             }\n             hir::ExprKind::Match(ref expr, ref arms, _) => {\n-                self.cbox(indent_unit);\n+                self.cbox(INDENT_UNIT);\n                 self.ibox(4);\n                 self.word_nbsp(\"match\");\n                 self.print_expr_as_cond(&expr);\n@@ -1308,7 +1307,7 @@ impl<'a> State<'a> {\n                     self.word_space(\":\");\n                 }\n                 // containing cbox, will be closed by print-block at }\n-                self.cbox(indent_unit);\n+                self.cbox(INDENT_UNIT);\n                 // head-box, will be closed by print-block after {\n                 self.ibox(0);\n                 self.print_block(&blk);\n@@ -1678,7 +1677,7 @@ impl<'a> State<'a> {\n                 self.commasep_cmnt(Consistent,\n                                    &fields[..],\n                                    |s, f| {\n-                                       s.cbox(indent_unit);\n+                                       s.cbox(INDENT_UNIT);\n                                        if !f.node.is_shorthand {\n                                            s.print_ident(f.node.ident);\n                                            s.word_nbsp(\":\");\n@@ -1787,7 +1786,7 @@ impl<'a> State<'a> {\n         if arm.attrs.is_empty() {\n             self.s.space();\n         }\n-        self.cbox(indent_unit);\n+        self.cbox(INDENT_UNIT);\n         self.ann.pre(self, AnnNode::Arm(arm));\n         self.ibox(0);\n         self.print_outer_attributes(&arm.attrs);\n@@ -1820,7 +1819,7 @@ impl<'a> State<'a> {\n                     self.word_space(\":\");\n                 }\n                 // the block will close the pattern's ibox\n-                self.print_block_unclosed_indent(&blk, indent_unit);\n+                self.print_block_unclosed_indent(&blk, INDENT_UNIT);\n \n                 // If it is a user-provided unsafe block, print a comma after it\n                 if let hir::UnsafeBlock(hir::UserProvided) = blk.rules {\n@@ -1859,7 +1858,7 @@ impl<'a> State<'a> {\n         // Make sure we aren't supplied *both* `arg_names` and `body_id`.\n         assert!(arg_names.is_empty() || body_id.is_none());\n         self.commasep(Inconsistent, &decl.inputs, |s, ty| {\n-            s.ibox(indent_unit);\n+            s.ibox(INDENT_UNIT);\n             if let Some(arg_name) = arg_names.get(i) {\n                 s.s.word(arg_name.as_str().to_string());\n                 s.s.word(\":\");\n@@ -1886,7 +1885,7 @@ impl<'a> State<'a> {\n         self.s.word(\"|\");\n         let mut i = 0;\n         self.commasep(Inconsistent, &decl.inputs, |s, ty| {\n-            s.ibox(indent_unit);\n+            s.ibox(INDENT_UNIT);\n \n             s.ann.nested(s, Nested::BodyArgPat(body_id, i));\n             i += 1;\n@@ -2085,7 +2084,7 @@ impl<'a> State<'a> {\n         }\n \n         self.space_if_not_bol();\n-        self.ibox(indent_unit);\n+        self.ibox(INDENT_UNIT);\n         self.word_space(\"->\");\n         match decl.output {\n             hir::DefaultReturn(..) => unreachable!(),\n@@ -2107,7 +2106,7 @@ impl<'a> State<'a> {\n                        generic_params: &[hir::GenericParam],\n                        arg_names: &[ast::Ident])\n                        {\n-        self.ibox(indent_unit);\n+        self.ibox(INDENT_UNIT);\n         if !generic_params.is_empty() {\n             self.s.word(\"for\");\n             self.print_generic_params(generic_params);"}, {"sha": "94849728a9319777b1059e457f7d5ada866695f7", "filename": "src/librustc_borrowck/dataflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf1b29f298ec7e5c345764554e6d03ac65134de/src%2Flibrustc_borrowck%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf1b29f298ec7e5c345764554e6d03ac65134de/src%2Flibrustc_borrowck%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdataflow.rs?ref=daf1b29f298ec7e5c345764554e6d03ac65134de", "patch": "@@ -529,7 +529,7 @@ impl<'tcx, O: DataFlowOperator + Clone + 'static> DataFlowContext<'tcx, O> {\n \n         debug!(\"Dataflow result for {}:\", self.analysis_name);\n         debug!(\"{}\", pprust::to_string(self, |s| {\n-            s.cbox(pprust::indent_unit);\n+            s.cbox(pprust::INDENT_UNIT);\n             s.ibox(0);\n             s.print_expr(&body.value)\n         }));"}]}