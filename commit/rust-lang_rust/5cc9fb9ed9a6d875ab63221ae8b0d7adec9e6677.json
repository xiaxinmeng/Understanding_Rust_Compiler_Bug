{"sha": "5cc9fb9ed9a6d875ab63221ae8b0d7adec9e6677", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjYzlmYjllZDlhNmQ4NzVhYjYzMjIxYWU4YjBkN2FkZWM5ZTY2Nzc=", "commit": {"author": {"name": "Jonathan Turner", "email": "jonathandturner@users.noreply.github.com", "date": "2016-09-27T00:29:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-27T00:29:48Z"}, "message": "Rollup merge of #36669 - jseyfried:refactor_tok_result, r=nrc\n\nUnify `TokResult` and `ResultAnyMacro`\n\nFixes #36641.\nr? @nrc", "tree": {"sha": "6da7565b922a39c4caaa9a450fbdc84a832ab724", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6da7565b922a39c4caaa9a450fbdc84a832ab724"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5cc9fb9ed9a6d875ab63221ae8b0d7adec9e6677", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5cc9fb9ed9a6d875ab63221ae8b0d7adec9e6677", "html_url": "https://github.com/rust-lang/rust/commit/5cc9fb9ed9a6d875ab63221ae8b0d7adec9e6677", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5cc9fb9ed9a6d875ab63221ae8b0d7adec9e6677/comments", "author": {"login": "jonathandturner", "id": 111457284, "node_id": "O_kgDOBqS0BA", "avatar_url": "https://avatars.githubusercontent.com/u/111457284?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonathandturner", "html_url": "https://github.com/jonathandturner", "followers_url": "https://api.github.com/users/jonathandturner/followers", "following_url": "https://api.github.com/users/jonathandturner/following{/other_user}", "gists_url": "https://api.github.com/users/jonathandturner/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonathandturner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonathandturner/subscriptions", "organizations_url": "https://api.github.com/users/jonathandturner/orgs", "repos_url": "https://api.github.com/users/jonathandturner/repos", "events_url": "https://api.github.com/users/jonathandturner/events{/privacy}", "received_events_url": "https://api.github.com/users/jonathandturner/received_events", "type": "Organization", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96577e4871bde61ea818be225e85b9662784b26d", "url": "https://api.github.com/repos/rust-lang/rust/commits/96577e4871bde61ea818be225e85b9662784b26d", "html_url": "https://github.com/rust-lang/rust/commit/96577e4871bde61ea818be225e85b9662784b26d"}, {"sha": "df0e4bf911aecfa660dc2ad90573734dcd485e43", "url": "https://api.github.com/repos/rust-lang/rust/commits/df0e4bf911aecfa660dc2ad90573734dcd485e43", "html_url": "https://github.com/rust-lang/rust/commit/df0e4bf911aecfa660dc2ad90573734dcd485e43"}], "stats": {"total": 383, "additions": 103, "deletions": 280}, "files": [{"sha": "495ad176542c10f73c905fc9500d8d54ee3c5a02", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 142, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/5cc9fb9ed9a6d875ab63221ae8b0d7adec9e6677/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cc9fb9ed9a6d875ab63221ae8b0d7adec9e6677/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=5cc9fb9ed9a6d875ab63221ae8b0d7adec9e6677", "patch": "@@ -18,8 +18,7 @@ use errors::DiagnosticBuilder;\n use ext::expand::{self, Invocation, Expansion};\n use ext::hygiene::Mark;\n use fold::{self, Folder};\n-use parse;\n-use parse::parser::{self, Parser};\n+use parse::{self, parser};\n use parse::token;\n use parse::token::{InternedString, str_to_ident};\n use ptr::P;\n@@ -188,146 +187,6 @@ impl<F> AttrProcMacro for F\n     }\n }\n \n-pub struct TokResult<'a> {\n-    pub parser: Parser<'a>,\n-    pub span: Span,\n-}\n-\n-impl<'a> TokResult<'a> {\n-    // There is quite a lot of overlap here with ParserAnyMacro in ext/tt/macro_rules.rs\n-    // We could probably share more code.\n-    // FIXME(#36641) Unify TokResult and ParserAnyMacro.\n-    fn ensure_complete_parse(&mut self, allow_semi: bool) {\n-        let macro_span = &self.span;\n-        self.parser.ensure_complete_parse(allow_semi, |parser| {\n-            let token_str = parser.this_token_to_string();\n-            let msg = format!(\"macro expansion ignores token `{}` and any following\", token_str);\n-            let span = parser.span;\n-            parser.diagnostic()\n-                  .struct_span_err(span, &msg)\n-                  .span_note(*macro_span, \"caused by the macro expansion here\")\n-                  .emit();\n-        });\n-    }\n-}\n-\n-impl<'a> MacResult for TokResult<'a> {\n-    fn make_items(mut self: Box<Self>) -> Option<SmallVector<P<ast::Item>>> {\n-        if self.parser.sess.span_diagnostic.has_errors() {\n-            return Some(SmallVector::zero());\n-        }\n-\n-        let mut items = SmallVector::zero();\n-        loop {\n-            match self.parser.parse_item() {\n-                Ok(Some(item)) => items.push(item),\n-                Ok(None) => {\n-                    self.ensure_complete_parse(false);\n-                    return Some(items);\n-                }\n-                Err(mut e) => {\n-                    e.emit();\n-                    return Some(SmallVector::zero());\n-                }\n-            }\n-        }\n-    }\n-\n-    fn make_impl_items(mut self: Box<Self>) -> Option<SmallVector<ast::ImplItem>> {\n-        let mut items = SmallVector::zero();\n-        loop {\n-            if self.parser.token == token::Eof {\n-                break;\n-            }\n-            match self.parser.parse_impl_item() {\n-                Ok(item) => items.push(item),\n-                Err(mut e) => {\n-                    e.emit();\n-                    return Some(SmallVector::zero());\n-                }\n-            }\n-        }\n-        self.ensure_complete_parse(false);\n-        Some(items)\n-    }\n-\n-    fn make_trait_items(mut self: Box<Self>) -> Option<SmallVector<ast::TraitItem>> {\n-        let mut items = SmallVector::zero();\n-        loop {\n-            if self.parser.token == token::Eof {\n-                break;\n-            }\n-            match self.parser.parse_trait_item() {\n-                Ok(item) => items.push(item),\n-                Err(mut e) => {\n-                    e.emit();\n-                    return Some(SmallVector::zero());\n-                }\n-            }\n-        }\n-        self.ensure_complete_parse(false);\n-        Some(items)\n-    }\n-\n-    fn make_expr(mut self: Box<Self>) -> Option<P<ast::Expr>> {\n-        match self.parser.parse_expr() {\n-            Ok(e) => {\n-                self.ensure_complete_parse(true);\n-                Some(e)\n-            }\n-            Err(mut e) => {\n-                e.emit();\n-                Some(DummyResult::raw_expr(self.span))\n-            }\n-        }\n-    }\n-\n-    fn make_pat(mut self: Box<Self>) -> Option<P<ast::Pat>> {\n-        match self.parser.parse_pat() {\n-            Ok(e) => {\n-                self.ensure_complete_parse(false);\n-                Some(e)\n-            }\n-            Err(mut e) => {\n-                e.emit();\n-                Some(P(DummyResult::raw_pat(self.span)))\n-            }\n-        }\n-    }\n-\n-    fn make_stmts(mut self: Box<Self>) -> Option<SmallVector<ast::Stmt>> {\n-        let mut stmts = SmallVector::zero();\n-        loop {\n-            if self.parser.token == token::Eof {\n-                break;\n-            }\n-            match self.parser.parse_full_stmt(false) {\n-                Ok(Some(stmt)) => stmts.push(stmt),\n-                Ok(None) => { /* continue */ }\n-                Err(mut e) => {\n-                    e.emit();\n-                    return Some(SmallVector::zero());\n-                }\n-            }\n-        }\n-        self.ensure_complete_parse(false);\n-        Some(stmts)\n-    }\n-\n-    fn make_ty(mut self: Box<Self>) -> Option<P<ast::Ty>> {\n-        match self.parser.parse_ty() {\n-            Ok(e) => {\n-                self.ensure_complete_parse(false);\n-                Some(e)\n-            }\n-            Err(mut e) => {\n-                e.emit();\n-                Some(DummyResult::raw_ty(self.span))\n-            }\n-        }\n-    }\n-}\n-\n /// Represents a thing that maps token trees to Macro Results\n pub trait TTMacroExpander {\n     fn expand<'cx>(&self,"}, {"sha": "7c43f1f3076988afb454cea4d6b27cb09cbb4c2c", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 86, "deletions": 22, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/5cc9fb9ed9a6d875ab63221ae8b0d7adec9e6677/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cc9fb9ed9a6d875ab63221ae8b0d7adec9e6677/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=5cc9fb9ed9a6d875ab63221ae8b0d7adec9e6677", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ast::{Block, Crate, Ident, Mac_, PatKind};\n-use ast::{MacStmtStyle, StmtKind, ItemKind};\n+use ast::{Name, MacStmtStyle, StmtKind, ItemKind};\n use ast;\n use ext::hygiene::Mark;\n use ext::placeholders::{placeholder, PlaceholderExpander};\n@@ -21,9 +21,9 @@ use ext::base::*;\n use feature_gate::{self, Features};\n use fold;\n use fold::*;\n-use parse::{ParseSess, lexer};\n+use parse::{ParseSess, PResult, lexer};\n use parse::parser::Parser;\n-use parse::token::{intern, keywords};\n+use parse::token::{self, intern, keywords};\n use print::pprust;\n use ptr::P;\n use tokenstream::{TokenTree, TokenStream};\n@@ -38,12 +38,12 @@ macro_rules! expansions {\n     ($($kind:ident: $ty:ty [$($vec:ident, $ty_elt:ty)*], $kind_name:expr, .$make:ident,\n             $(.$fold:ident)*  $(lift .$fold_elt:ident)*,\n             $(.$visit:ident)*  $(lift .$visit_elt:ident)*;)*) => {\n-        #[derive(Copy, Clone)]\n+        #[derive(Copy, Clone, PartialEq, Eq)]\n         pub enum ExpansionKind { OptExpr, $( $kind, )*  }\n         pub enum Expansion { OptExpr(Option<P<ast::Expr>>), $( $kind($ty), )* }\n \n         impl ExpansionKind {\n-            fn name(self) -> &'static str {\n+            pub fn name(self) -> &'static str {\n                 match self {\n                     ExpansionKind::OptExpr => \"expression\",\n                     $( ExpansionKind::$kind => $kind_name, )*\n@@ -106,6 +106,12 @@ macro_rules! expansions {\n                 self.expand(Expansion::$kind(SmallVector::one(node))).$make()\n             })*)*\n         }\n+\n+        impl<'a> MacResult for ::ext::tt::macro_rules::ParserAnyMacro<'a> {\n+            $(fn $make(self: Box<::ext::tt::macro_rules::ParserAnyMacro<'a>>) -> Option<$ty> {\n+                Some(self.make(ExpansionKind::$kind).$make())\n+            })*\n+        }\n     }\n }\n \n@@ -293,10 +299,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         };\n \n         attr::mark_used(&attr);\n+        let name = intern(&attr.name());\n         self.cx.bt_push(ExpnInfo {\n             call_site: attr.span,\n             callee: NameAndSpan {\n-                format: MacroAttribute(intern(&attr.name())),\n+                format: MacroAttribute(name),\n                 span: Some(attr.span),\n                 allow_internal_unstable: false,\n             }\n@@ -319,14 +326,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 let item_toks = TokenStream::from_tts(tts_for_item(&item, &self.cx.parse_sess));\n \n                 let tok_result = mac.expand(self.cx, attr.span, attr_toks, item_toks);\n-                let parser = self.cx.new_parser_from_tts(&tok_result.to_tts());\n-                let result = Box::new(TokResult { parser: parser, span: attr.span });\n-\n-                kind.make_from(result).unwrap_or_else(|| {\n-                    let msg = format!(\"macro could not be expanded into {} position\", kind.name());\n-                    self.cx.span_err(attr.span, &msg);\n-                    kind.dummy(attr.span)\n-                })\n+                self.parse_expansion(tok_result, kind, name, attr.span)\n             }\n             _ => unreachable!(),\n         }\n@@ -423,14 +423,9 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     },\n                 });\n \n-\n-                let tok_result = expandfun.expand(self.cx,\n-                                                  span,\n-                                                  TokenStream::from_tts(marked_tts));\n-                let parser = self.cx.new_parser_from_tts(&tok_result.to_tts());\n-                let result = Box::new(TokResult { parser: parser, span: span });\n-                // FIXME better span info.\n-                kind.make_from(result).map(|i| i.fold_with(&mut ChangeSpan { span: span }))\n+                let toks = TokenStream::from_tts(marked_tts);\n+                let tok_result = expandfun.expand(self.cx, span, toks);\n+                Some(self.parse_expansion(tok_result, kind, extname, span))\n             }\n         };\n \n@@ -448,6 +443,75 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             expn_id: Some(self.cx.backtrace()),\n         })\n     }\n+\n+    fn parse_expansion(&mut self, toks: TokenStream, kind: ExpansionKind, name: Name, span: Span)\n+                       -> Expansion {\n+        let mut parser = self.cx.new_parser_from_tts(&toks.to_tts());\n+        let expansion = match parser.parse_expansion(kind, false) {\n+            Ok(expansion) => expansion,\n+            Err(mut err) => {\n+                err.emit();\n+                return kind.dummy(span);\n+            }\n+        };\n+        parser.ensure_complete_parse(name, kind.name(), span);\n+        // FIXME better span info\n+        expansion.fold_with(&mut ChangeSpan { span: span })\n+    }\n+}\n+\n+impl<'a> Parser<'a> {\n+    pub fn parse_expansion(&mut self, kind: ExpansionKind, macro_legacy_warnings: bool)\n+                           -> PResult<'a, Expansion> {\n+        Ok(match kind {\n+            ExpansionKind::Items => {\n+                let mut items = SmallVector::zero();\n+                while let Some(item) = self.parse_item()? {\n+                    items.push(item);\n+                }\n+                Expansion::Items(items)\n+            }\n+            ExpansionKind::TraitItems => {\n+                let mut items = SmallVector::zero();\n+                while self.token != token::Eof {\n+                    items.push(self.parse_trait_item()?);\n+                }\n+                Expansion::TraitItems(items)\n+            }\n+            ExpansionKind::ImplItems => {\n+                let mut items = SmallVector::zero();\n+                while self.token != token::Eof {\n+                    items.push(self.parse_impl_item()?);\n+                }\n+                Expansion::ImplItems(items)\n+            }\n+            ExpansionKind::Stmts => {\n+                let mut stmts = SmallVector::zero();\n+                while self.token != token::Eof {\n+                    if let Some(stmt) = self.parse_full_stmt(macro_legacy_warnings)? {\n+                        stmts.push(stmt);\n+                    }\n+                }\n+                Expansion::Stmts(stmts)\n+            }\n+            ExpansionKind::Expr => Expansion::Expr(self.parse_expr()?),\n+            ExpansionKind::OptExpr => Expansion::OptExpr(Some(self.parse_expr()?)),\n+            ExpansionKind::Ty => Expansion::Ty(self.parse_ty()?),\n+            ExpansionKind::Pat => Expansion::Pat(self.parse_pat()?),\n+        })\n+    }\n+\n+    pub fn ensure_complete_parse(&mut self, macro_name: ast::Name, kind_name: &str, span: Span) {\n+        if self.token != token::Eof {\n+            let msg = format!(\"macro expansion ignores token `{}` and any following\",\n+                              self.this_token_to_string());\n+            let mut err = self.diagnostic().struct_span_err(self.span, &msg);\n+            let msg = format!(\"caused by the macro expansion here; the usage \\\n+                               of `{}!` is likely invalid in {} context\",\n+                               macro_name, kind_name);\n+            err.span_note(span, &msg).emit();\n+        }\n+    }\n }\n \n struct InvocationCollector<'a, 'b: 'a> {"}, {"sha": "d222de2dd36c6c4cc8739960c0277108d26d430a", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 16, "deletions": 105, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/5cc9fb9ed9a6d875ab63221ae8b0d7adec9e6677/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cc9fb9ed9a6d875ab63221ae8b0d7adec9e6677/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=5cc9fb9ed9a6d875ab63221ae8b0d7adec9e6677", "patch": "@@ -12,6 +12,7 @@ use {ast, attr};\n use syntax_pos::{Span, DUMMY_SP};\n use ext::base::{DummyResult, ExtCtxt, MacEager, MacResult, SyntaxExtension};\n use ext::base::{IdentMacroExpander, NormalTT, TTMacroExpander};\n+use ext::expand::{Expansion, ExpansionKind};\n use ext::placeholders;\n use ext::tt::macro_parser::{Success, Error, Failure};\n use ext::tt::macro_parser::{MatchedSeq, MatchedNonterminal};\n@@ -22,18 +23,14 @@ use parse::parser::{Parser, Restrictions};\n use parse::token::{self, gensym_ident, NtTT, Token};\n use parse::token::Token::*;\n use print;\n-use ptr::P;\n use tokenstream::{self, TokenTree};\n \n-use util::small_vector::SmallVector;\n-\n-use std::cell::RefCell;\n use std::collections::{HashMap};\n use std::collections::hash_map::{Entry};\n use std::rc::Rc;\n \n-struct ParserAnyMacro<'a> {\n-    parser: RefCell<Parser<'a>>,\n+pub struct ParserAnyMacro<'a> {\n+    parser: Parser<'a>,\n \n     /// Span of the expansion site of the macro this parser is for\n     site_span: Span,\n@@ -42,106 +39,20 @@ struct ParserAnyMacro<'a> {\n }\n \n impl<'a> ParserAnyMacro<'a> {\n-    /// Make sure we don't have any tokens left to parse, so we don't\n-    /// silently drop anything. `allow_semi` is so that \"optional\"\n-    /// semicolons at the end of normal expressions aren't complained\n-    /// about e.g. the semicolon in `macro_rules! kapow { () => {\n-    /// panic!(); } }` doesn't get picked up by .parse_expr(), but it's\n-    /// allowed to be there.\n-    fn ensure_complete_parse(&self, allow_semi: bool, context: &str) {\n-        let mut parser = self.parser.borrow_mut();\n-        parser.ensure_complete_parse(allow_semi, |parser| {\n-            let token_str = parser.this_token_to_string();\n-            let msg = format!(\"macro expansion ignores token `{}` and any \\\n-                               following\",\n-                              token_str);\n-            let span = parser.span;\n-            let mut err = parser.diagnostic().struct_span_err(span, &msg);\n-            let msg = format!(\"caused by the macro expansion here; the usage \\\n-                               of `{}!` is likely invalid in {} context\",\n-                               self.macro_ident, context);\n-            err.span_note(self.site_span, &msg)\n-               .emit();\n-        });\n-    }\n-}\n-\n-impl<'a> MacResult for ParserAnyMacro<'a> {\n-    fn make_expr(self: Box<ParserAnyMacro<'a>>) -> Option<P<ast::Expr>> {\n-        let ret = panictry!(self.parser.borrow_mut().parse_expr());\n-        self.ensure_complete_parse(true, \"expression\");\n-        Some(ret)\n-    }\n-    fn make_pat(self: Box<ParserAnyMacro<'a>>) -> Option<P<ast::Pat>> {\n-        let ret = panictry!(self.parser.borrow_mut().parse_pat());\n-        self.ensure_complete_parse(false, \"pattern\");\n-        Some(ret)\n-    }\n-    fn make_items(self: Box<ParserAnyMacro<'a>>) -> Option<SmallVector<P<ast::Item>>> {\n-        let mut ret = SmallVector::zero();\n-        while let Some(item) = panictry!(self.parser.borrow_mut().parse_item()) {\n-            ret.push(item);\n-        }\n-        self.ensure_complete_parse(false, \"item\");\n-        Some(ret)\n-    }\n-\n-    fn make_impl_items(self: Box<ParserAnyMacro<'a>>)\n-                       -> Option<SmallVector<ast::ImplItem>> {\n-        let mut ret = SmallVector::zero();\n-        loop {\n-            let mut parser = self.parser.borrow_mut();\n-            match parser.token {\n-                token::Eof => break,\n-                _ => ret.push(panictry!(parser.parse_impl_item()))\n-            }\n-        }\n-        self.ensure_complete_parse(false, \"item\");\n-        Some(ret)\n-    }\n-\n-    fn make_trait_items(self: Box<ParserAnyMacro<'a>>)\n-                       -> Option<SmallVector<ast::TraitItem>> {\n-        let mut ret = SmallVector::zero();\n-        loop {\n-            let mut parser = self.parser.borrow_mut();\n-            match parser.token {\n-                token::Eof => break,\n-                _ => ret.push(panictry!(parser.parse_trait_item()))\n-            }\n+    pub fn make(mut self: Box<ParserAnyMacro<'a>>, kind: ExpansionKind) -> Expansion {\n+        let ParserAnyMacro { site_span, macro_ident, ref mut parser } = *self;\n+        let expansion = panictry!(parser.parse_expansion(kind, true));\n+\n+        // We allow semicolons at the end of expressions -- e.g. the semicolon in\n+        // `macro_rules! m { () => { panic!(); } }` isn't parsed by `.parse_expr()`,\n+        // but `m!()` is allowed in expression positions (c.f. issue #34706).\n+        if kind == ExpansionKind::Expr && parser.token == token::Semi {\n+            parser.bump();\n         }\n-        self.ensure_complete_parse(false, \"item\");\n-        Some(ret)\n-    }\n-\n-\n-    fn make_stmts(self: Box<ParserAnyMacro<'a>>)\n-                 -> Option<SmallVector<ast::Stmt>> {\n-        let mut ret = SmallVector::zero();\n-        loop {\n-            let mut parser = self.parser.borrow_mut();\n-            match parser.token {\n-                token::Eof => break,\n-                _ => match parser.parse_full_stmt(true) {\n-                    Ok(maybe_stmt) => match maybe_stmt {\n-                        Some(stmt) => ret.push(stmt),\n-                        None => (),\n-                    },\n-                    Err(mut e) => {\n-                        e.emit();\n-                        break;\n-                    }\n-                }\n-            }\n-        }\n-        self.ensure_complete_parse(false, \"statement\");\n-        Some(ret)\n-    }\n \n-    fn make_ty(self: Box<ParserAnyMacro<'a>>) -> Option<P<ast::Ty>> {\n-        let ret = panictry!(self.parser.borrow_mut().parse_ty());\n-        self.ensure_complete_parse(false, \"type\");\n-        Some(ret)\n+        // Make sure we don't have any tokens left to parse so we don't silently drop anything.\n+        parser.ensure_complete_parse(macro_ident.name, kind.name(), site_span);\n+        expansion\n     }\n }\n \n@@ -219,7 +130,7 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                 // Let the context choose how to interpret the result.\n                 // Weird, but useful for X-macros.\n                 return Box::new(ParserAnyMacro {\n-                    parser: RefCell::new(p),\n+                    parser: p,\n \n                     // Pass along the original expansion site and the name of the macro\n                     // so we can print a useful error message if the parse of the expanded"}, {"sha": "d5ed1d157e47abbd0e1a1e19970c8d9022054e00", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5cc9fb9ed9a6d875ab63221ae8b0d7adec9e6677/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cc9fb9ed9a6d875ab63221ae8b0d7adec9e6677/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5cc9fb9ed9a6d875ab63221ae8b0d7adec9e6677", "patch": "@@ -6141,15 +6141,4 @@ impl<'a> Parser<'a> {\n             _ =>  Err(self.fatal(\"expected string literal\"))\n         }\n     }\n-\n-    pub fn ensure_complete_parse<F>(&mut self, allow_semi: bool, on_err: F)\n-        where F: FnOnce(&Parser)\n-    {\n-        if allow_semi && self.token == token::Semi {\n-            self.bump();\n-        }\n-        if self.token != token::Eof {\n-            on_err(self);\n-        }\n-    }\n }"}]}