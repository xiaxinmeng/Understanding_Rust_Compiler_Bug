{"sha": "7f2398e557d4b75cbf83dc88b6740e83a8d20910", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmMjM5OGU1NTdkNGI3NWNiZjgzZGM4OGI2NzQwZTgzYThkMjA5MTA=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-01T21:00:50Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-01T21:00:58Z"}, "message": "Implement structured compare for rec, tup, tag. Un-XFAIL structured-compare.rs.", "tree": {"sha": "a08b4bedc27ad217829dffb0797021d1f117004e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a08b4bedc27ad217829dffb0797021d1f117004e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f2398e557d4b75cbf83dc88b6740e83a8d20910", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f2398e557d4b75cbf83dc88b6740e83a8d20910", "html_url": "https://github.com/rust-lang/rust/commit/7f2398e557d4b75cbf83dc88b6740e83a8d20910", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f2398e557d4b75cbf83dc88b6740e83a8d20910/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f239ecb5f2e46cb4c938b6bd481ec75fe137e414", "url": "https://api.github.com/repos/rust-lang/rust/commits/f239ecb5f2e46cb4c938b6bd481ec75fe137e414", "html_url": "https://github.com/rust-lang/rust/commit/f239ecb5f2e46cb4c938b6bd481ec75fe137e414"}], "stats": {"total": 77, "additions": 55, "deletions": 22}, "files": [{"sha": "2be8be48338a06cdc14c42cc4e1eeb5db15d06c0", "filename": "src/Makefile", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7f2398e557d4b75cbf83dc88b6740e83a8d20910/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/7f2398e557d4b75cbf83dc88b6740e83a8d20910/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=7f2398e557d4b75cbf83dc88b6740e83a8d20910", "patch": "@@ -505,7 +505,6 @@ TEST_XFAILS_RUSTC := $(CONST_TAG_XFAILS) \\\n                         spawn.rs \\\n                         str-append.rs \\\n                         str-concat.rs \\\n-                        structured-compare.rs \\\n                         syntax-extension-fmt.rs \\\n                         syntax-extension-shell.rs \\\n                         task-comm-0.rs \\"}, {"sha": "9a650da58760f7a5d85d39e23acb423b08c26d68", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 55, "deletions": 21, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/7f2398e557d4b75cbf83dc88b6740e83a8d20910/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2398e557d4b75cbf83dc88b6740e83a8d20910/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=7f2398e557d4b75cbf83dc88b6740e83a8d20910", "patch": "@@ -1583,24 +1583,30 @@ fn iter_structural_ty_full(@block_ctxt cx,\n             auto llunion_b_ptr = cx.build.GEP(bv, vec(C_int(0), C_int(1)));\n             auto lldiscrim_b = cx.build.Load(lldiscrim_b_ptr);\n \n-            auto unr_cx = new_sub_block_ctxt(cx, \"tag-iter-unr\");\n+            // NB: we must hit the discriminant first so that structural\n+            // comparison know not to proceed when the discriminants differ.\n+            auto bcx = cx;\n+            bcx = f(bcx, lldiscrim_a, lldiscrim_b,\n+                    plain_ty(ty.ty_int)).bcx;\n+\n+            auto unr_cx = new_sub_block_ctxt(bcx, \"tag-iter-unr\");\n             unr_cx.build.Unreachable();\n \n-            auto llswitch = cx.build.Switch(lldiscrim_a, unr_cx.llbb,\n+            auto llswitch = bcx.build.Switch(lldiscrim_a, unr_cx.llbb,\n                                              n_variants);\n \n-            auto next_cx = new_sub_block_ctxt(cx, \"tag-iter-next\");\n+            auto next_cx = new_sub_block_ctxt(bcx, \"tag-iter-next\");\n \n             auto i = 0u;\n             for (ast.variant variant in variants) {\n-                auto variant_cx = new_sub_block_ctxt(cx,\n+                auto variant_cx = new_sub_block_ctxt(bcx,\n                                                      \"tag-iter-variant-\" +\n                                                      _uint.to_str(i, 10u));\n                 llvm.LLVMAddCase(llswitch, C_int(i as int), variant_cx.llbb);\n \n                 if (_vec.len[ast.variant_arg](variant.args) > 0u) {\n                     // N-ary variant.\n-                    auto llvarty = type_of_variant(cx.fcx.ccx, variants.(i));\n+                    auto llvarty = type_of_variant(bcx.fcx.ccx, variants.(i));\n \n                     auto fn_ty = ty.ann_to_type(variants.(i).ann);\n                     alt (fn_ty.struct) {\n@@ -1611,7 +1617,7 @@ fn iter_structural_ty_full(@block_ctxt cx,\n                             auto llvarp_b = variant_cx.build.\n                                 TruncOrBitCast(llunion_b_ptr, T_ptr(llvarty));\n \n-                            auto ty_params = tag_ty_params(cx.fcx.ccx, tid);\n+                            auto ty_params = tag_ty_params(bcx.fcx.ccx, tid);\n \n                             auto j = 0u;\n                             for (ty.arg a in args) {\n@@ -2023,37 +2029,65 @@ fn trans_compare(@block_ctxt cx, ast.binop op, @ty.t t,\n         auto next = new_sub_block_ctxt(cx, \"structural compare end\");\n         cx.build.Br(scx.llbb);\n \n-        // Start with the assumptioin that our predicate holds.\n+        /*\n+         * We're doing lexicographic comparison here. We start with the\n+         * assumption that the two input elements are equal. Depending on\n+         * operator, this means that the result is either true or false;\n+         * equality produces 'true' for ==, <= and >=. It produces 'false' for\n+         * !=, < and >.\n+         *\n+         * We then move one element at a time through the structure checking\n+         * for pairwise element equality. If we have equality, our assumption\n+         * about overall sequence equality is not modified, so we have to move\n+         * to the next element.\n+         *\n+         * If we do not have pairwise element equality, we have reached an\n+         * element that 'decides' the lexicographic comparison. So we exit the\n+         * loop with a flag that indicates the true/false sense of that\n+         * decision, by testing the element again with the operator we're\n+         * interested in.\n+         *\n+         * When we're lucky, LLVM should be able to fold some of these two\n+         * tests together (as they're applied to the same operands and in some\n+         * cases are sometimes redundant). But we don't bother trying to\n+         * optimize combinations like that, at this level.\n+         */\n+\n         auto flag = scx.build.Alloca(T_i1());\n-        scx.build.Store(C_integral(1, T_i1()), flag);\n \n-        // Attempt to prove otherwise by assuming true, comparing each element\n-        // and writing 0 + early-exiting if any comparisons fail.\n+        alt (op) {\n+            // ==, <= and >= default to true if they find == all the way.\n+            case (ast.eq) { scx.build.Store(C_integral(1, T_i1()), flag); }\n+            case (ast.le) { scx.build.Store(C_integral(1, T_i1()), flag); }\n+            case (ast.ge) { scx.build.Store(C_integral(1, T_i1()), flag); }\n+            case (_) {\n+                // ==, <= and >= default to false if they find == all the way.\n+                scx.build.Store(C_integral(0, T_i1()), flag);\n+            }\n+        }\n \n-        fn inner(@block_ctxt next_cx,\n+        fn inner(@block_ctxt last_cx,\n                  ValueRef flag,\n                  ast.binop op,\n                  @block_ctxt cx,\n                  ValueRef av,\n                  ValueRef bv,\n                  @ty.t t) -> result {\n-            // Compare av op bv\n+\n             auto cnt_cx = new_sub_block_ctxt(cx, \"continue comparison\");\n             auto stop_cx = new_sub_block_ctxt(cx, \"stop comparison\");\n \n-            auto r = trans_compare(cx, op, t, av, bv);\n-\n-            // if true, then carry on, else write 0 to flag, branch to 'next'.\n-            r.bcx.build.CondBr(r.val, cnt_cx.llbb, stop_cx.llbb);\n-            stop_cx.build.Store(C_integral(0, T_i1()), flag);\n-            stop_cx.build.Br(next_cx.llbb);\n+            // First 'eq' comparison: if so, continue to next elts.\n+            auto eq_r = trans_compare(cx, ast.eq, t, av, bv);\n+            eq_r.bcx.build.CondBr(eq_r.val, cnt_cx.llbb, stop_cx.llbb);\n \n+            // Second 'op' comparison: find out how this elt-pair decides.\n+            auto stop_r = trans_compare(stop_cx, op, t, av, bv);\n+            stop_r.bcx.build.Store(stop_r.val, flag);\n+            stop_r.bcx.build.Br(last_cx.llbb);\n             ret res(cnt_cx, C_nil());\n         }\n \n-        // FIXME: this is wrong for tag types; need to confirm discriminants\n-        // are equal before blindly walking over elements.\n-\n         auto r = iter_structural_ty_full(scx, lhs, rhs, t,\n                                          bind inner(next, flag, op,\n                                                     _, _, _, _));"}]}