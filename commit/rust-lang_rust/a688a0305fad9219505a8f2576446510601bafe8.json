{"sha": "a688a0305fad9219505a8f2576446510601bafe8", "node_id": "C_kwDOAAsO6NoAKGE2ODhhMDMwNWZhZDkyMTk1MDVhOGYyNTc2NDQ2NTEwNjAxYmFmZTg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-08T03:50:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-08T03:50:07Z"}, "message": "Auto merge of #99505 - joboet:futex_once, r=thomcc\n\nstd: use futex in `Once`\n\nNow that we have efficient locks, let's optimize the rest of `sync` as well. This PR adds a futex-based implementation for `Once`, which drastically simplifies the implementation compared to the generic version, which is provided as fallback for platforms without futex (Windows only supports them on newer versions, so it uses the fallback for now).\n\nInstead of storing a linked list of waiters, the new implementation adds another state (`QUEUED`), which is set when there are waiting threads. These now use `futex_wait` on that state and are woken by the running thread when it finishes and notices the `QUEUED` state, thereby avoiding unnecessary calls to `futex_wake_all`.", "tree": {"sha": "477131afebff9e0b0b8bbbd8476a01b5126d061e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/477131afebff9e0b0b8bbbd8476a01b5126d061e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a688a0305fad9219505a8f2576446510601bafe8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a688a0305fad9219505a8f2576446510601bafe8", "html_url": "https://github.com/rust-lang/rust/commit/a688a0305fad9219505a8f2576446510601bafe8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a688a0305fad9219505a8f2576446510601bafe8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eed7f2f58bd44d32ac30e48425eb4bede7ea84f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/eed7f2f58bd44d32ac30e48425eb4bede7ea84f7", "html_url": "https://github.com/rust-lang/rust/commit/eed7f2f58bd44d32ac30e48425eb4bede7ea84f7"}, {"sha": "5d0211dc0307f41476768cc482d2df92c639c38e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d0211dc0307f41476768cc482d2df92c639c38e", "html_url": "https://github.com/rust-lang/rust/commit/5d0211dc0307f41476768cc482d2df92c639c38e"}], "stats": {"total": 772, "additions": 483, "deletions": 289}, "files": [{"sha": "0f25417d6b5d057e0b96b2b9977c4bb3b7d7cbf9", "filename": "library/std/src/sync/once.rs", "status": "modified", "additions": 23, "deletions": 289, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/a688a0305fad9219505a8f2576446510601bafe8/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a688a0305fad9219505a8f2576446510601bafe8/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs?ref=a688a0305fad9219505a8f2576446510601bafe8", "patch": "@@ -3,99 +3,12 @@\n //! This primitive is meant to be used to run one-time initialization. An\n //! example use case would be for initializing an FFI library.\n \n-// A \"once\" is a relatively simple primitive, and it's also typically provided\n-// by the OS as well (see `pthread_once` or `InitOnceExecuteOnce`). The OS\n-// primitives, however, tend to have surprising restrictions, such as the Unix\n-// one doesn't allow an argument to be passed to the function.\n-//\n-// As a result, we end up implementing it ourselves in the standard library.\n-// This also gives us the opportunity to optimize the implementation a bit which\n-// should help the fast path on call sites. Consequently, let's explain how this\n-// primitive works now!\n-//\n-// So to recap, the guarantees of a Once are that it will call the\n-// initialization closure at most once, and it will never return until the one\n-// that's running has finished running. This means that we need some form of\n-// blocking here while the custom callback is running at the very least.\n-// Additionally, we add on the restriction of **poisoning**. Whenever an\n-// initialization closure panics, the Once enters a \"poisoned\" state which means\n-// that all future calls will immediately panic as well.\n-//\n-// So to implement this, one might first reach for a `Mutex`, but those cannot\n-// be put into a `static`. It also gets a lot harder with poisoning to figure\n-// out when the mutex needs to be deallocated because it's not after the closure\n-// finishes, but after the first successful closure finishes.\n-//\n-// All in all, this is instead implemented with atomics and lock-free\n-// operations! Whee! Each `Once` has one word of atomic state, and this state is\n-// CAS'd on to determine what to do. There are four possible state of a `Once`:\n-//\n-// * Incomplete - no initialization has run yet, and no thread is currently\n-//                using the Once.\n-// * Poisoned - some thread has previously attempted to initialize the Once, but\n-//              it panicked, so the Once is now poisoned. There are no other\n-//              threads currently accessing this Once.\n-// * Running - some thread is currently attempting to run initialization. It may\n-//             succeed, so all future threads need to wait for it to finish.\n-//             Note that this state is accompanied with a payload, described\n-//             below.\n-// * Complete - initialization has completed and all future calls should finish\n-//              immediately.\n-//\n-// With 4 states we need 2 bits to encode this, and we use the remaining bits\n-// in the word we have allocated as a queue of threads waiting for the thread\n-// responsible for entering the RUNNING state. This queue is just a linked list\n-// of Waiter nodes which is monotonically increasing in size. Each node is\n-// allocated on the stack, and whenever the running closure finishes it will\n-// consume the entire queue and notify all waiters they should try again.\n-//\n-// You'll find a few more details in the implementation, but that's the gist of\n-// it!\n-//\n-// Atomic orderings:\n-// When running `Once` we deal with multiple atomics:\n-// `Once.state_and_queue` and an unknown number of `Waiter.signaled`.\n-// * `state_and_queue` is used (1) as a state flag, (2) for synchronizing the\n-//   result of the `Once`, and (3) for synchronizing `Waiter` nodes.\n-//     - At the end of the `call_inner` function we have to make sure the result\n-//       of the `Once` is acquired. So every load which can be the only one to\n-//       load COMPLETED must have at least Acquire ordering, which means all\n-//       three of them.\n-//     - `WaiterQueue::Drop` is the only place that may store COMPLETED, and\n-//       must do so with Release ordering to make the result available.\n-//     - `wait` inserts `Waiter` nodes as a pointer in `state_and_queue`, and\n-//       needs to make the nodes available with Release ordering. The load in\n-//       its `compare_exchange` can be Relaxed because it only has to compare\n-//       the atomic, not to read other data.\n-//     - `WaiterQueue::Drop` must see the `Waiter` nodes, so it must load\n-//       `state_and_queue` with Acquire ordering.\n-//     - There is just one store where `state_and_queue` is used only as a\n-//       state flag, without having to synchronize data: switching the state\n-//       from INCOMPLETE to RUNNING in `call_inner`. This store can be Relaxed,\n-//       but the read has to be Acquire because of the requirements mentioned\n-//       above.\n-// * `Waiter.signaled` is both used as a flag, and to protect a field with\n-//   interior mutability in `Waiter`. `Waiter.thread` is changed in\n-//   `WaiterQueue::Drop` which then sets `signaled` with Release ordering.\n-//   After `wait` loads `signaled` with Acquire and sees it is true, it needs to\n-//   see the changes to drop the `Waiter` struct correctly.\n-// * There is one place where the two atomics `Once.state_and_queue` and\n-//   `Waiter.signaled` come together, and might be reordered by the compiler or\n-//   processor. Because both use Acquire ordering such a reordering is not\n-//   allowed, so no need for SeqCst.\n-\n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests;\n \n-use crate::cell::Cell;\n use crate::fmt;\n-use crate::marker;\n use crate::panic::{RefUnwindSafe, UnwindSafe};\n-use crate::ptr;\n-use crate::sync::atomic::{AtomicBool, AtomicPtr, Ordering};\n-use crate::thread::{self, Thread};\n-\n-type Masked = ();\n+use crate::sys_common::once as sys;\n \n /// A synchronization primitive which can be used to run a one-time global\n /// initialization. Useful for one-time initialization for FFI or related\n@@ -114,19 +27,9 @@ type Masked = ();\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Once {\n-    // `state_and_queue` is actually a pointer to a `Waiter` with extra state\n-    // bits, so we add the `PhantomData` appropriately.\n-    state_and_queue: AtomicPtr<Masked>,\n-    _marker: marker::PhantomData<*const Waiter>,\n+    inner: sys::Once,\n }\n \n-// The `PhantomData` of a raw pointer removes these two auto traits, but we\n-// enforce both below in the implementation so this should be safe to add.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl Sync for Once {}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl Send for Once {}\n-\n #[stable(feature = \"sync_once_unwind_safe\", since = \"1.59.0\")]\n impl UnwindSafe for Once {}\n \n@@ -136,10 +39,8 @@ impl RefUnwindSafe for Once {}\n /// State yielded to [`Once::call_once_force()`]\u2019s closure parameter. The state\n /// can be used to query the poison status of the [`Once`].\n #[stable(feature = \"once_poison\", since = \"1.51.0\")]\n-#[derive(Debug)]\n pub struct OnceState {\n-    poisoned: bool,\n-    set_state_on_drop_to: Cell<*mut Masked>,\n+    pub(crate) inner: sys::OnceState,\n }\n \n /// Initialization value for static [`Once`] values.\n@@ -159,49 +60,14 @@ pub struct OnceState {\n )]\n pub const ONCE_INIT: Once = Once::new();\n \n-// Four states that a Once can be in, encoded into the lower bits of\n-// `state_and_queue` in the Once structure.\n-const INCOMPLETE: usize = 0x0;\n-const POISONED: usize = 0x1;\n-const RUNNING: usize = 0x2;\n-const COMPLETE: usize = 0x3;\n-\n-// Mask to learn about the state. All other bits are the queue of waiters if\n-// this is in the RUNNING state.\n-const STATE_MASK: usize = 0x3;\n-\n-// Representation of a node in the linked list of waiters, used while in the\n-// RUNNING state.\n-// Note: `Waiter` can't hold a mutable pointer to the next thread, because then\n-// `wait` would both hand out a mutable reference to its `Waiter` node, and keep\n-// a shared reference to check `signaled`. Instead we hold shared references and\n-// use interior mutability.\n-#[repr(align(4))] // Ensure the two lower bits are free to use as state bits.\n-struct Waiter {\n-    thread: Cell<Option<Thread>>,\n-    signaled: AtomicBool,\n-    next: *const Waiter,\n-}\n-\n-// Head of a linked list of waiters.\n-// Every node is a struct on the stack of a waiting thread.\n-// Will wake up the waiters when it gets dropped, i.e. also on panic.\n-struct WaiterQueue<'a> {\n-    state_and_queue: &'a AtomicPtr<Masked>,\n-    set_state_on_drop_to: *mut Masked,\n-}\n-\n impl Once {\n     /// Creates a new `Once` value.\n     #[inline]\n     #[stable(feature = \"once_new\", since = \"1.2.0\")]\n     #[rustc_const_stable(feature = \"const_once_new\", since = \"1.32.0\")]\n     #[must_use]\n     pub const fn new() -> Once {\n-        Once {\n-            state_and_queue: AtomicPtr::new(ptr::invalid_mut(INCOMPLETE)),\n-            _marker: marker::PhantomData,\n-        }\n+        Once { inner: sys::Once::new() }\n     }\n \n     /// Performs an initialization routine once and only once. The given closure\n@@ -261,19 +127,20 @@ impl Once {\n     /// This is similar to [poisoning with mutexes][poison].\n     ///\n     /// [poison]: struct.Mutex.html#poisoning\n+    #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[track_caller]\n     pub fn call_once<F>(&self, f: F)\n     where\n         F: FnOnce(),\n     {\n         // Fast path check\n-        if self.is_completed() {\n+        if self.inner.is_completed() {\n             return;\n         }\n \n         let mut f = Some(f);\n-        self.call_inner(false, &mut |_| f.take().unwrap()());\n+        self.inner.call(false, &mut |_| f.take().unwrap()());\n     }\n \n     /// Performs the same function as [`call_once()`] except ignores poisoning.\n@@ -320,18 +187,19 @@ impl Once {\n     /// // once any success happens, we stop propagating the poison\n     /// INIT.call_once(|| {});\n     /// ```\n+    #[inline]\n     #[stable(feature = \"once_poison\", since = \"1.51.0\")]\n     pub fn call_once_force<F>(&self, f: F)\n     where\n         F: FnOnce(&OnceState),\n     {\n         // Fast path check\n-        if self.is_completed() {\n+        if self.inner.is_completed() {\n             return;\n         }\n \n         let mut f = Some(f);\n-        self.call_inner(true, &mut |p| f.take().unwrap()(p));\n+        self.inner.call(true, &mut |p| f.take().unwrap()(p));\n     }\n \n     /// Returns `true` if some [`call_once()`] call has completed\n@@ -378,119 +246,7 @@ impl Once {\n     #[stable(feature = \"once_is_completed\", since = \"1.43.0\")]\n     #[inline]\n     pub fn is_completed(&self) -> bool {\n-        // An `Acquire` load is enough because that makes all the initialization\n-        // operations visible to us, and, this being a fast path, weaker\n-        // ordering helps with performance. This `Acquire` synchronizes with\n-        // `Release` operations on the slow path.\n-        self.state_and_queue.load(Ordering::Acquire).addr() == COMPLETE\n-    }\n-\n-    // This is a non-generic function to reduce the monomorphization cost of\n-    // using `call_once` (this isn't exactly a trivial or small implementation).\n-    //\n-    // Additionally, this is tagged with `#[cold]` as it should indeed be cold\n-    // and it helps let LLVM know that calls to this function should be off the\n-    // fast path. Essentially, this should help generate more straight line code\n-    // in LLVM.\n-    //\n-    // Finally, this takes an `FnMut` instead of a `FnOnce` because there's\n-    // currently no way to take an `FnOnce` and call it via virtual dispatch\n-    // without some allocation overhead.\n-    #[cold]\n-    #[track_caller]\n-    fn call_inner(&self, ignore_poisoning: bool, init: &mut dyn FnMut(&OnceState)) {\n-        let mut state_and_queue = self.state_and_queue.load(Ordering::Acquire);\n-        loop {\n-            match state_and_queue.addr() {\n-                COMPLETE => break,\n-                POISONED if !ignore_poisoning => {\n-                    // Panic to propagate the poison.\n-                    panic!(\"Once instance has previously been poisoned\");\n-                }\n-                POISONED | INCOMPLETE => {\n-                    // Try to register this thread as the one RUNNING.\n-                    let exchange_result = self.state_and_queue.compare_exchange(\n-                        state_and_queue,\n-                        ptr::invalid_mut(RUNNING),\n-                        Ordering::Acquire,\n-                        Ordering::Acquire,\n-                    );\n-                    if let Err(old) = exchange_result {\n-                        state_and_queue = old;\n-                        continue;\n-                    }\n-                    // `waiter_queue` will manage other waiting threads, and\n-                    // wake them up on drop.\n-                    let mut waiter_queue = WaiterQueue {\n-                        state_and_queue: &self.state_and_queue,\n-                        set_state_on_drop_to: ptr::invalid_mut(POISONED),\n-                    };\n-                    // Run the initialization function, letting it know if we're\n-                    // poisoned or not.\n-                    let init_state = OnceState {\n-                        poisoned: state_and_queue.addr() == POISONED,\n-                        set_state_on_drop_to: Cell::new(ptr::invalid_mut(COMPLETE)),\n-                    };\n-                    init(&init_state);\n-                    waiter_queue.set_state_on_drop_to = init_state.set_state_on_drop_to.get();\n-                    break;\n-                }\n-                _ => {\n-                    // All other values must be RUNNING with possibly a\n-                    // pointer to the waiter queue in the more significant bits.\n-                    assert!(state_and_queue.addr() & STATE_MASK == RUNNING);\n-                    wait(&self.state_and_queue, state_and_queue);\n-                    state_and_queue = self.state_and_queue.load(Ordering::Acquire);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-fn wait(state_and_queue: &AtomicPtr<Masked>, mut current_state: *mut Masked) {\n-    // Note: the following code was carefully written to avoid creating a\n-    // mutable reference to `node` that gets aliased.\n-    loop {\n-        // Don't queue this thread if the status is no longer running,\n-        // otherwise we will not be woken up.\n-        if current_state.addr() & STATE_MASK != RUNNING {\n-            return;\n-        }\n-\n-        // Create the node for our current thread.\n-        let node = Waiter {\n-            thread: Cell::new(Some(thread::current())),\n-            signaled: AtomicBool::new(false),\n-            next: current_state.with_addr(current_state.addr() & !STATE_MASK) as *const Waiter,\n-        };\n-        let me = &node as *const Waiter as *const Masked as *mut Masked;\n-\n-        // Try to slide in the node at the head of the linked list, making sure\n-        // that another thread didn't just replace the head of the linked list.\n-        let exchange_result = state_and_queue.compare_exchange(\n-            current_state,\n-            me.with_addr(me.addr() | RUNNING),\n-            Ordering::Release,\n-            Ordering::Relaxed,\n-        );\n-        if let Err(old) = exchange_result {\n-            current_state = old;\n-            continue;\n-        }\n-\n-        // We have enqueued ourselves, now lets wait.\n-        // It is important not to return before being signaled, otherwise we\n-        // would drop our `Waiter` node and leave a hole in the linked list\n-        // (and a dangling reference). Guard against spurious wakeups by\n-        // reparking ourselves until we are signaled.\n-        while !node.signaled.load(Ordering::Acquire) {\n-            // If the managing thread happens to signal and unpark us before we\n-            // can park ourselves, the result could be this thread never gets\n-            // unparked. Luckily `park` comes with the guarantee that if it got\n-            // an `unpark` just before on an unparked thread it does not park.\n-            thread::park();\n-        }\n-        break;\n+        self.inner.is_completed()\n     }\n }\n \n@@ -501,37 +257,6 @@ impl fmt::Debug for Once {\n     }\n }\n \n-impl Drop for WaiterQueue<'_> {\n-    fn drop(&mut self) {\n-        // Swap out our state with however we finished.\n-        let state_and_queue =\n-            self.state_and_queue.swap(self.set_state_on_drop_to, Ordering::AcqRel);\n-\n-        // We should only ever see an old state which was RUNNING.\n-        assert_eq!(state_and_queue.addr() & STATE_MASK, RUNNING);\n-\n-        // Walk the entire linked list of waiters and wake them up (in lifo\n-        // order, last to register is first to wake up).\n-        unsafe {\n-            // Right after setting `node.signaled = true` the other thread may\n-            // free `node` if there happens to be has a spurious wakeup.\n-            // So we have to take out the `thread` field and copy the pointer to\n-            // `next` first.\n-            let mut queue =\n-                state_and_queue.with_addr(state_and_queue.addr() & !STATE_MASK) as *const Waiter;\n-            while !queue.is_null() {\n-                let next = (*queue).next;\n-                let thread = (*queue).thread.take().unwrap();\n-                (*queue).signaled.store(true, Ordering::Release);\n-                // ^- FIXME (maybe): This is another case of issue #55005\n-                // `store()` has a potentially dangling ref to `signaled`.\n-                queue = next;\n-                thread.unpark();\n-            }\n-        }\n-    }\n-}\n-\n impl OnceState {\n     /// Returns `true` if the associated [`Once`] was poisoned prior to the\n     /// invocation of the closure passed to [`Once::call_once_force()`].\n@@ -568,13 +293,22 @@ impl OnceState {\n     ///     assert!(!state.is_poisoned());\n     /// });\n     #[stable(feature = \"once_poison\", since = \"1.51.0\")]\n+    #[inline]\n     pub fn is_poisoned(&self) -> bool {\n-        self.poisoned\n+        self.inner.is_poisoned()\n     }\n \n     /// Poison the associated [`Once`] without explicitly panicking.\n-    // NOTE: This is currently only exposed for the `lazy` module\n+    // NOTE: This is currently only exposed for `OnceLock`.\n+    #[inline]\n     pub(crate) fn poison(&self) {\n-        self.set_state_on_drop_to.set(ptr::invalid_mut(POISONED));\n+        self.inner.poison();\n+    }\n+}\n+\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n+impl fmt::Debug for OnceState {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"OnceState\").field(\"poisoned\", &self.is_poisoned()).finish()\n     }\n }"}, {"sha": "e4dd0253668b8e56951cf2491f71a7f0e60d15cc", "filename": "library/std/src/sys_common/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a688a0305fad9219505a8f2576446510601bafe8/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a688a0305fad9219505a8f2576446510601bafe8/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs?ref=a688a0305fad9219505a8f2576446510601bafe8", "patch": "@@ -27,6 +27,7 @@ pub mod io;\n pub mod lazy_box;\n pub mod memchr;\n pub mod mutex;\n+pub mod once;\n pub mod process;\n pub mod remutex;\n pub mod rwlock;"}, {"sha": "5c7e6c013715d9677d3dd973dc9fa5d4e61b8230", "filename": "library/std/src/sys_common/once/futex.rs", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/a688a0305fad9219505a8f2576446510601bafe8/library%2Fstd%2Fsrc%2Fsys_common%2Fonce%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a688a0305fad9219505a8f2576446510601bafe8/library%2Fstd%2Fsrc%2Fsys_common%2Fonce%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fonce%2Ffutex.rs?ref=a688a0305fad9219505a8f2576446510601bafe8", "patch": "@@ -0,0 +1,134 @@\n+use crate::cell::Cell;\n+use crate::sync as public;\n+use crate::sync::atomic::{\n+    AtomicU32,\n+    Ordering::{Acquire, Relaxed, Release},\n+};\n+use crate::sys::futex::{futex_wait, futex_wake_all};\n+\n+// On some platforms, the OS is very nice and handles the waiter queue for us.\n+// This means we only need one atomic value with 5 states:\n+\n+/// No initialization has run yet, and no thread is currently using the Once.\n+const INCOMPLETE: u32 = 0;\n+/// Some thread has previously attempted to initialize the Once, but it panicked,\n+/// so the Once is now poisoned. There are no other threads currently accessing\n+/// this Once.\n+const POISONED: u32 = 1;\n+/// Some thread is currently attempting to run initialization. It may succeed,\n+/// so all future threads need to wait for it to finish.\n+const RUNNING: u32 = 2;\n+/// Some thread is currently attempting to run initialization and there are threads\n+/// waiting for it to finish.\n+const QUEUED: u32 = 3;\n+/// Initialization has completed and all future calls should finish immediately.\n+const COMPLETE: u32 = 4;\n+\n+// Threads wait by setting the state to QUEUED and calling `futex_wait` on the state\n+// variable. When the running thread finishes, it will wake all waiting threads using\n+// `futex_wake_all`.\n+\n+pub struct OnceState {\n+    poisoned: bool,\n+    set_state_to: Cell<u32>,\n+}\n+\n+impl OnceState {\n+    #[inline]\n+    pub fn is_poisoned(&self) -> bool {\n+        self.poisoned\n+    }\n+\n+    #[inline]\n+    pub fn poison(&self) {\n+        self.set_state_to.set(POISONED);\n+    }\n+}\n+\n+struct CompletionGuard<'a> {\n+    state: &'a AtomicU32,\n+    set_state_on_drop_to: u32,\n+}\n+\n+impl<'a> Drop for CompletionGuard<'a> {\n+    fn drop(&mut self) {\n+        // Use release ordering to propagate changes to all threads checking\n+        // up on the Once. `futex_wake_all` does its own synchronization, hence\n+        // we do not need `AcqRel`.\n+        if self.state.swap(self.set_state_on_drop_to, Release) == QUEUED {\n+            futex_wake_all(&self.state);\n+        }\n+    }\n+}\n+\n+pub struct Once {\n+    state: AtomicU32,\n+}\n+\n+impl Once {\n+    #[inline]\n+    pub const fn new() -> Once {\n+        Once { state: AtomicU32::new(INCOMPLETE) }\n+    }\n+\n+    #[inline]\n+    pub fn is_completed(&self) -> bool {\n+        // Use acquire ordering to make all initialization changes visible to the\n+        // current thread.\n+        self.state.load(Acquire) == COMPLETE\n+    }\n+\n+    // This uses FnMut to match the API of the generic implementation. As this\n+    // implementation is quite light-weight, it is generic over the closure and\n+    // so avoids the cost of dynamic dispatch.\n+    #[cold]\n+    #[track_caller]\n+    pub fn call(&self, ignore_poisoning: bool, f: &mut impl FnMut(&public::OnceState)) {\n+        let mut state = self.state.load(Acquire);\n+        loop {\n+            match state {\n+                POISONED if !ignore_poisoning => {\n+                    // Panic to propagate the poison.\n+                    panic!(\"Once instance has previously been poisoned\");\n+                }\n+                INCOMPLETE | POISONED => {\n+                    // Try to register the current thread as the one running.\n+                    if let Err(new) =\n+                        self.state.compare_exchange_weak(state, RUNNING, Acquire, Acquire)\n+                    {\n+                        state = new;\n+                        continue;\n+                    }\n+                    // `waiter_queue` will manage other waiting threads, and\n+                    // wake them up on drop.\n+                    let mut waiter_queue =\n+                        CompletionGuard { state: &self.state, set_state_on_drop_to: POISONED };\n+                    // Run the function, letting it know if we're poisoned or not.\n+                    let f_state = public::OnceState {\n+                        inner: OnceState {\n+                            poisoned: state == POISONED,\n+                            set_state_to: Cell::new(COMPLETE),\n+                        },\n+                    };\n+                    f(&f_state);\n+                    waiter_queue.set_state_on_drop_to = f_state.inner.set_state_to.get();\n+                    return;\n+                }\n+                RUNNING | QUEUED => {\n+                    // Set the state to QUEUED if it is not already.\n+                    if state == RUNNING\n+                        && let Err(new) = self.state.compare_exchange_weak(RUNNING, QUEUED, Relaxed, Acquire)\n+                    {\n+                        state = new;\n+                        continue;\n+                    }\n+\n+                    futex_wait(&self.state, QUEUED, None);\n+                    state = self.state.load(Acquire);\n+                }\n+                COMPLETE => return,\n+                _ => unreachable!(\"state is never set to invalid values\"),\n+            }\n+        }\n+    }\n+}"}, {"sha": "acf5f247164a779a01b637d8de1ae9ed1cd8f8c9", "filename": "library/std/src/sys_common/once/generic.rs", "status": "added", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/a688a0305fad9219505a8f2576446510601bafe8/library%2Fstd%2Fsrc%2Fsys_common%2Fonce%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a688a0305fad9219505a8f2576446510601bafe8/library%2Fstd%2Fsrc%2Fsys_common%2Fonce%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fonce%2Fgeneric.rs?ref=a688a0305fad9219505a8f2576446510601bafe8", "patch": "@@ -0,0 +1,282 @@\n+// Each `Once` has one word of atomic state, and this state is CAS'd on to\n+// determine what to do. There are four possible state of a `Once`:\n+//\n+// * Incomplete - no initialization has run yet, and no thread is currently\n+//                using the Once.\n+// * Poisoned - some thread has previously attempted to initialize the Once, but\n+//              it panicked, so the Once is now poisoned. There are no other\n+//              threads currently accessing this Once.\n+// * Running - some thread is currently attempting to run initialization. It may\n+//             succeed, so all future threads need to wait for it to finish.\n+//             Note that this state is accompanied with a payload, described\n+//             below.\n+// * Complete - initialization has completed and all future calls should finish\n+//              immediately.\n+//\n+// With 4 states we need 2 bits to encode this, and we use the remaining bits\n+// in the word we have allocated as a queue of threads waiting for the thread\n+// responsible for entering the RUNNING state. This queue is just a linked list\n+// of Waiter nodes which is monotonically increasing in size. Each node is\n+// allocated on the stack, and whenever the running closure finishes it will\n+// consume the entire queue and notify all waiters they should try again.\n+//\n+// You'll find a few more details in the implementation, but that's the gist of\n+// it!\n+//\n+// Atomic orderings:\n+// When running `Once` we deal with multiple atomics:\n+// `Once.state_and_queue` and an unknown number of `Waiter.signaled`.\n+// * `state_and_queue` is used (1) as a state flag, (2) for synchronizing the\n+//   result of the `Once`, and (3) for synchronizing `Waiter` nodes.\n+//     - At the end of the `call` function we have to make sure the result\n+//       of the `Once` is acquired. So every load which can be the only one to\n+//       load COMPLETED must have at least acquire ordering, which means all\n+//       three of them.\n+//     - `WaiterQueue::drop` is the only place that may store COMPLETED, and\n+//       must do so with release ordering to make the result available.\n+//     - `wait` inserts `Waiter` nodes as a pointer in `state_and_queue`, and\n+//       needs to make the nodes available with release ordering. The load in\n+//       its `compare_exchange` can be relaxed because it only has to compare\n+//       the atomic, not to read other data.\n+//     - `WaiterQueue::drop` must see the `Waiter` nodes, so it must load\n+//       `state_and_queue` with acquire ordering.\n+//     - There is just one store where `state_and_queue` is used only as a\n+//       state flag, without having to synchronize data: switching the state\n+//       from INCOMPLETE to RUNNING in `call`. This store can be Relaxed,\n+//       but the read has to be Acquire because of the requirements mentioned\n+//       above.\n+// * `Waiter.signaled` is both used as a flag, and to protect a field with\n+//   interior mutability in `Waiter`. `Waiter.thread` is changed in\n+//   `WaiterQueue::drop` which then sets `signaled` with release ordering.\n+//   After `wait` loads `signaled` with acquire ordering and sees it is true,\n+//   it needs to see the changes to drop the `Waiter` struct correctly.\n+// * There is one place where the two atomics `Once.state_and_queue` and\n+//   `Waiter.signaled` come together, and might be reordered by the compiler or\n+//   processor. Because both use acquire ordering such a reordering is not\n+//   allowed, so no need for `SeqCst`.\n+\n+use crate::cell::Cell;\n+use crate::fmt;\n+use crate::ptr;\n+use crate::sync as public;\n+use crate::sync::atomic::{AtomicBool, AtomicPtr, Ordering};\n+use crate::thread::{self, Thread};\n+\n+type Masked = ();\n+\n+pub struct Once {\n+    state_and_queue: AtomicPtr<Masked>,\n+}\n+\n+pub struct OnceState {\n+    poisoned: bool,\n+    set_state_on_drop_to: Cell<*mut Masked>,\n+}\n+\n+// Four states that a Once can be in, encoded into the lower bits of\n+// `state_and_queue` in the Once structure.\n+const INCOMPLETE: usize = 0x0;\n+const POISONED: usize = 0x1;\n+const RUNNING: usize = 0x2;\n+const COMPLETE: usize = 0x3;\n+\n+// Mask to learn about the state. All other bits are the queue of waiters if\n+// this is in the RUNNING state.\n+const STATE_MASK: usize = 0x3;\n+\n+// Representation of a node in the linked list of waiters, used while in the\n+// RUNNING state.\n+// Note: `Waiter` can't hold a mutable pointer to the next thread, because then\n+// `wait` would both hand out a mutable reference to its `Waiter` node, and keep\n+// a shared reference to check `signaled`. Instead we hold shared references and\n+// use interior mutability.\n+#[repr(align(4))] // Ensure the two lower bits are free to use as state bits.\n+struct Waiter {\n+    thread: Cell<Option<Thread>>,\n+    signaled: AtomicBool,\n+    next: *const Waiter,\n+}\n+\n+// Head of a linked list of waiters.\n+// Every node is a struct on the stack of a waiting thread.\n+// Will wake up the waiters when it gets dropped, i.e. also on panic.\n+struct WaiterQueue<'a> {\n+    state_and_queue: &'a AtomicPtr<Masked>,\n+    set_state_on_drop_to: *mut Masked,\n+}\n+\n+impl Once {\n+    #[inline]\n+    pub const fn new() -> Once {\n+        Once { state_and_queue: AtomicPtr::new(ptr::invalid_mut(INCOMPLETE)) }\n+    }\n+\n+    #[inline]\n+    pub fn is_completed(&self) -> bool {\n+        // An `Acquire` load is enough because that makes all the initialization\n+        // operations visible to us, and, this being a fast path, weaker\n+        // ordering helps with performance. This `Acquire` synchronizes with\n+        // `Release` operations on the slow path.\n+        self.state_and_queue.load(Ordering::Acquire).addr() == COMPLETE\n+    }\n+\n+    // This is a non-generic function to reduce the monomorphization cost of\n+    // using `call_once` (this isn't exactly a trivial or small implementation).\n+    //\n+    // Additionally, this is tagged with `#[cold]` as it should indeed be cold\n+    // and it helps let LLVM know that calls to this function should be off the\n+    // fast path. Essentially, this should help generate more straight line code\n+    // in LLVM.\n+    //\n+    // Finally, this takes an `FnMut` instead of a `FnOnce` because there's\n+    // currently no way to take an `FnOnce` and call it via virtual dispatch\n+    // without some allocation overhead.\n+    #[cold]\n+    #[track_caller]\n+    pub fn call(&self, ignore_poisoning: bool, init: &mut dyn FnMut(&public::OnceState)) {\n+        let mut state_and_queue = self.state_and_queue.load(Ordering::Acquire);\n+        loop {\n+            match state_and_queue.addr() {\n+                COMPLETE => break,\n+                POISONED if !ignore_poisoning => {\n+                    // Panic to propagate the poison.\n+                    panic!(\"Once instance has previously been poisoned\");\n+                }\n+                POISONED | INCOMPLETE => {\n+                    // Try to register this thread as the one RUNNING.\n+                    let exchange_result = self.state_and_queue.compare_exchange(\n+                        state_and_queue,\n+                        ptr::invalid_mut(RUNNING),\n+                        Ordering::Acquire,\n+                        Ordering::Acquire,\n+                    );\n+                    if let Err(old) = exchange_result {\n+                        state_and_queue = old;\n+                        continue;\n+                    }\n+                    // `waiter_queue` will manage other waiting threads, and\n+                    // wake them up on drop.\n+                    let mut waiter_queue = WaiterQueue {\n+                        state_and_queue: &self.state_and_queue,\n+                        set_state_on_drop_to: ptr::invalid_mut(POISONED),\n+                    };\n+                    // Run the initialization function, letting it know if we're\n+                    // poisoned or not.\n+                    let init_state = public::OnceState {\n+                        inner: OnceState {\n+                            poisoned: state_and_queue.addr() == POISONED,\n+                            set_state_on_drop_to: Cell::new(ptr::invalid_mut(COMPLETE)),\n+                        },\n+                    };\n+                    init(&init_state);\n+                    waiter_queue.set_state_on_drop_to = init_state.inner.set_state_on_drop_to.get();\n+                    break;\n+                }\n+                _ => {\n+                    // All other values must be RUNNING with possibly a\n+                    // pointer to the waiter queue in the more significant bits.\n+                    assert!(state_and_queue.addr() & STATE_MASK == RUNNING);\n+                    wait(&self.state_and_queue, state_and_queue);\n+                    state_and_queue = self.state_and_queue.load(Ordering::Acquire);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn wait(state_and_queue: &AtomicPtr<Masked>, mut current_state: *mut Masked) {\n+    // Note: the following code was carefully written to avoid creating a\n+    // mutable reference to `node` that gets aliased.\n+    loop {\n+        // Don't queue this thread if the status is no longer running,\n+        // otherwise we will not be woken up.\n+        if current_state.addr() & STATE_MASK != RUNNING {\n+            return;\n+        }\n+\n+        // Create the node for our current thread.\n+        let node = Waiter {\n+            thread: Cell::new(Some(thread::current())),\n+            signaled: AtomicBool::new(false),\n+            next: current_state.with_addr(current_state.addr() & !STATE_MASK) as *const Waiter,\n+        };\n+        let me = &node as *const Waiter as *const Masked as *mut Masked;\n+\n+        // Try to slide in the node at the head of the linked list, making sure\n+        // that another thread didn't just replace the head of the linked list.\n+        let exchange_result = state_and_queue.compare_exchange(\n+            current_state,\n+            me.with_addr(me.addr() | RUNNING),\n+            Ordering::Release,\n+            Ordering::Relaxed,\n+        );\n+        if let Err(old) = exchange_result {\n+            current_state = old;\n+            continue;\n+        }\n+\n+        // We have enqueued ourselves, now lets wait.\n+        // It is important not to return before being signaled, otherwise we\n+        // would drop our `Waiter` node and leave a hole in the linked list\n+        // (and a dangling reference). Guard against spurious wakeups by\n+        // reparking ourselves until we are signaled.\n+        while !node.signaled.load(Ordering::Acquire) {\n+            // If the managing thread happens to signal and unpark us before we\n+            // can park ourselves, the result could be this thread never gets\n+            // unparked. Luckily `park` comes with the guarantee that if it got\n+            // an `unpark` just before on an unparked thread it does not park.\n+            thread::park();\n+        }\n+        break;\n+    }\n+}\n+\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n+impl fmt::Debug for Once {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Once\").finish_non_exhaustive()\n+    }\n+}\n+\n+impl Drop for WaiterQueue<'_> {\n+    fn drop(&mut self) {\n+        // Swap out our state with however we finished.\n+        let state_and_queue =\n+            self.state_and_queue.swap(self.set_state_on_drop_to, Ordering::AcqRel);\n+\n+        // We should only ever see an old state which was RUNNING.\n+        assert_eq!(state_and_queue.addr() & STATE_MASK, RUNNING);\n+\n+        // Walk the entire linked list of waiters and wake them up (in lifo\n+        // order, last to register is first to wake up).\n+        unsafe {\n+            // Right after setting `node.signaled = true` the other thread may\n+            // free `node` if there happens to be has a spurious wakeup.\n+            // So we have to take out the `thread` field and copy the pointer to\n+            // `next` first.\n+            let mut queue =\n+                state_and_queue.with_addr(state_and_queue.addr() & !STATE_MASK) as *const Waiter;\n+            while !queue.is_null() {\n+                let next = (*queue).next;\n+                let thread = (*queue).thread.take().unwrap();\n+                (*queue).signaled.store(true, Ordering::Release);\n+                // ^- FIXME (maybe): This is another case of issue #55005\n+                // `store()` has a potentially dangling ref to `signaled`.\n+                queue = next;\n+                thread.unpark();\n+            }\n+        }\n+    }\n+}\n+\n+impl OnceState {\n+    #[inline]\n+    pub fn is_poisoned(&self) -> bool {\n+        self.poisoned\n+    }\n+\n+    #[inline]\n+    pub fn poison(&self) {\n+        self.set_state_on_drop_to.set(ptr::invalid_mut(POISONED));\n+    }\n+}"}, {"sha": "8742e68cc7ac5901cb904df5bd2bb8afc3758c66", "filename": "library/std/src/sys_common/once/mod.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a688a0305fad9219505a8f2576446510601bafe8/library%2Fstd%2Fsrc%2Fsys_common%2Fonce%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a688a0305fad9219505a8f2576446510601bafe8/library%2Fstd%2Fsrc%2Fsys_common%2Fonce%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fonce%2Fmod.rs?ref=a688a0305fad9219505a8f2576446510601bafe8", "patch": "@@ -0,0 +1,43 @@\n+// A \"once\" is a relatively simple primitive, and it's also typically provided\n+// by the OS as well (see `pthread_once` or `InitOnceExecuteOnce`). The OS\n+// primitives, however, tend to have surprising restrictions, such as the Unix\n+// one doesn't allow an argument to be passed to the function.\n+//\n+// As a result, we end up implementing it ourselves in the standard library.\n+// This also gives us the opportunity to optimize the implementation a bit which\n+// should help the fast path on call sites.\n+//\n+// So to recap, the guarantees of a Once are that it will call the\n+// initialization closure at most once, and it will never return until the one\n+// that's running has finished running. This means that we need some form of\n+// blocking here while the custom callback is running at the very least.\n+// Additionally, we add on the restriction of **poisoning**. Whenever an\n+// initialization closure panics, the Once enters a \"poisoned\" state which means\n+// that all future calls will immediately panic as well.\n+//\n+// So to implement this, one might first reach for a `Mutex`, but those cannot\n+// be put into a `static`. It also gets a lot harder with poisoning to figure\n+// out when the mutex needs to be deallocated because it's not after the closure\n+// finishes, but after the first successful closure finishes.\n+//\n+// All in all, this is instead implemented with atomics and lock-free\n+// operations! Whee!\n+\n+cfg_if::cfg_if! {\n+    if #[cfg(any(\n+        target_os = \"linux\",\n+        target_os = \"android\",\n+        all(target_arch = \"wasm32\", target_feature = \"atomics\"),\n+        target_os = \"freebsd\",\n+        target_os = \"openbsd\",\n+        target_os = \"dragonfly\",\n+        target_os = \"fuchsia\",\n+        target_os = \"hermit\",\n+    ))] {\n+        mod futex;\n+        pub use futex::{Once, OnceState};\n+    } else {\n+        mod generic;\n+        pub use generic::{Once, OnceState};\n+    }\n+}"}]}