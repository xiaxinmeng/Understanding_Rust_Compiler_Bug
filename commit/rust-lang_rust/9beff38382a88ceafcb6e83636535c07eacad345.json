{"sha": "9beff38382a88ceafcb6e83636535c07eacad345", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliZWZmMzgzODJhODhjZWFmY2I2ZTgzNjM2NTM1YzA3ZWFjYWQzNDU=", "commit": {"author": {"name": "Shotaro Yamada", "email": "sinkuu@sinkuu.xyz", "date": "2019-07-08T08:59:26Z"}, "committer": {"name": "Shotaro Yamada", "email": "sinkuu@sinkuu.xyz", "date": "2019-08-19T08:49:54Z"}, "message": "Associated type bound for inlined impl Trait doc", "tree": {"sha": "f84773720d60d84ccd0ac748f1c8883081c6d466", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f84773720d60d84ccd0ac748f1c8883081c6d466"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9beff38382a88ceafcb6e83636535c07eacad345", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9beff38382a88ceafcb6e83636535c07eacad345", "html_url": "https://github.com/rust-lang/rust/commit/9beff38382a88ceafcb6e83636535c07eacad345", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9beff38382a88ceafcb6e83636535c07eacad345/comments", "author": {"login": "sinkuu", "id": 7091080, "node_id": "MDQ6VXNlcjcwOTEwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/7091080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sinkuu", "html_url": "https://github.com/sinkuu", "followers_url": "https://api.github.com/users/sinkuu/followers", "following_url": "https://api.github.com/users/sinkuu/following{/other_user}", "gists_url": "https://api.github.com/users/sinkuu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sinkuu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sinkuu/subscriptions", "organizations_url": "https://api.github.com/users/sinkuu/orgs", "repos_url": "https://api.github.com/users/sinkuu/repos", "events_url": "https://api.github.com/users/sinkuu/events{/privacy}", "received_events_url": "https://api.github.com/users/sinkuu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sinkuu", "id": 7091080, "node_id": "MDQ6VXNlcjcwOTEwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/7091080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sinkuu", "html_url": "https://github.com/sinkuu", "followers_url": "https://api.github.com/users/sinkuu/followers", "following_url": "https://api.github.com/users/sinkuu/following{/other_user}", "gists_url": "https://api.github.com/users/sinkuu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sinkuu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sinkuu/subscriptions", "organizations_url": "https://api.github.com/users/sinkuu/orgs", "repos_url": "https://api.github.com/users/sinkuu/repos", "events_url": "https://api.github.com/users/sinkuu/events{/privacy}", "received_events_url": "https://api.github.com/users/sinkuu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b78367d8e8c3273b2cdeefc4ce55897e08e592b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/b78367d8e8c3273b2cdeefc4ce55897e08e592b2", "html_url": "https://github.com/rust-lang/rust/commit/b78367d8e8c3273b2cdeefc4ce55897e08e592b2"}], "stats": {"total": 199, "additions": 131, "deletions": 68}, "files": [{"sha": "bde1826c7fd5a71f7f7ff3719d0d5b5d09de79be", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 70, "deletions": 23, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/9beff38382a88ceafcb6e83636535c07eacad345/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9beff38382a88ceafcb6e83636535c07eacad345/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=9beff38382a88ceafcb6e83636535c07eacad345", "patch": "@@ -1698,7 +1698,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n \n         // Don't populate `cx.impl_trait_bounds` before `clean`ning `where` clauses,\n         // since `Clean for ty::Predicate` would consume them.\n-        let mut impl_trait = FxHashMap::<ImplTraitParam, Vec<_>>::default();\n+        let mut impl_trait = FxHashMap::<ImplTraitParam, Vec<GenericBound>>::default();\n \n         // Bounds in the type_params and lifetimes fields are repeated in the\n         // predicates field (see rustc_typeck::collect::ty_generics), so remove\n@@ -1720,41 +1720,73 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n                 ty::GenericParamDefKind::Const { .. } => None,\n             }).collect::<Vec<GenericParamDef>>();\n \n+        // (param index, def id of trait) -> (name, type)\n+        let mut impl_trait_proj = FxHashMap::<(u32, DefId), Vec<(String, Type)>>::default();\n+\n         let mut where_predicates = preds.predicates.iter()\n             .flat_map(|(p, _)| {\n-                let param_idx = if let Some(trait_ref) = p.to_opt_poly_trait_ref() {\n-                    if let ty::Param(param) = trait_ref.self_ty().sty {\n-                        Some(param.index)\n-                    } else {\n-                        None\n-                    }\n-                } else if let Some(outlives) = p.to_opt_type_outlives() {\n-                    if let ty::Param(param) = outlives.skip_binder().0.sty {\n-                        Some(param.index)\n-                    } else {\n-                        None\n+                let param_idx = (|| {\n+                    if let Some(trait_ref) = p.to_opt_poly_trait_ref() {\n+                        if let ty::Param(param) = trait_ref.self_ty().sty {\n+                            return Some(param.index);\n+                        }\n+                    } else if let Some(outlives) = p.to_opt_type_outlives() {\n+                        if let ty::Param(param) = outlives.skip_binder().0.sty {\n+                            return Some(param.index);\n+                        }\n+                    } else if let ty::Predicate::Projection(proj) = p {\n+                        if let ty::Param(param) = proj.skip_binder().projection_ty.self_ty().sty {\n+                            return Some(param.index);\n+                        }\n                     }\n-                } else {\n+\n                     None\n-                };\n+                })();\n \n                 let p = p.clean(cx)?;\n \n-                if let Some(b) = param_idx.and_then(|i| impl_trait.get_mut(&i.into())) {\n-                    b.extend(\n-                        p.get_bounds()\n-                            .into_iter()\n-                            .flatten()\n-                            .cloned()\n-                            .filter(|b| !b.is_sized_bound(cx))\n-                    );\n-                    return None;\n+                if let Some(param_idx) = param_idx {\n+                    if let Some(b) = impl_trait.get_mut(&param_idx.into()) {\n+                        b.extend(\n+                            p.get_bounds()\n+                                .into_iter()\n+                                .flatten()\n+                                .cloned()\n+                                .filter(|b| !b.is_sized_bound(cx))\n+                        );\n+\n+                        let proj = match &p {\n+                            WherePredicate::EqPredicate { lhs, rhs } => Some((lhs, rhs))\n+                                .and_then(|(lhs, rhs)| Some((lhs.projection()?, rhs))),\n+                            _ => None,\n+                        };\n+                        if let Some(((_, trait_did, name), rhs)) = proj {\n+                            impl_trait_proj\n+                                .entry((param_idx, trait_did))\n+                                .or_default()\n+                                .push((name.to_string(), rhs.clone()));\n+                        }\n+\n+                        return None;\n+                    }\n                 }\n \n                 Some(p)\n             })\n             .collect::<Vec<_>>();\n \n+        for ((param_idx, trait_did), bounds) in impl_trait_proj {\n+            for (name, rhs) in bounds {\n+                simplify::merge_bounds(\n+                    cx,\n+                    impl_trait.get_mut(&param_idx.into()).unwrap(),\n+                    trait_did,\n+                    &name,\n+                    &rhs,\n+                );\n+            }\n+        }\n+\n         // Move `TraitPredicate`s to the front.\n         for (_, bounds) in impl_trait.iter_mut() {\n             bounds.sort_by_key(|b| if let GenericBound::TraitBound(..) = b {\n@@ -2664,6 +2696,21 @@ impl Type {\n             _ => false,\n         }\n     }\n+\n+    pub fn projection(&self) -> Option<(&Type, DefId, &str)> {\n+        let (self_, trait_, name) = match self {\n+            QPath { ref self_type, ref trait_, ref name } => {\n+                (self_type, trait_, name)\n+            }\n+            _ => return None,\n+        };\n+        let trait_did = match **trait_ {\n+            ResolvedPath { did, .. } => did,\n+            _ => return None,\n+        };\n+        Some((&self_, trait_did, name))\n+    }\n+\n }\n \n impl GetDefId for Type {"}, {"sha": "8758ab19691163ab4f93e847ed21d0c31d08b459", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 51, "deletions": 45, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/9beff38382a88ceafcb6e83636535c07eacad345/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9beff38382a88ceafcb6e83636535c07eacad345/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=9beff38382a88ceafcb6e83636535c07eacad345", "patch": "@@ -53,58 +53,21 @@ pub fn where_clauses(cx: &DocContext<'_>, clauses: Vec<WP>) -> Vec<WP> {\n     // Look for equality predicates on associated types that can be merged into\n     // general bound predicates\n     equalities.retain(|&(ref lhs, ref rhs)| {\n-        let (self_, trait_, name) = match *lhs {\n-            clean::QPath { ref self_type, ref trait_, ref name } => {\n-                (self_type, trait_, name)\n-            }\n-            _ => return true,\n-        };\n-        let generic = match **self_ {\n-            clean::Generic(ref s) => s,\n-            _ => return true,\n+        let (self_, trait_did, name) = if let Some(p) = lhs.projection() {\n+            p\n+        } else {\n+            return true;\n         };\n-        let trait_did = match **trait_ {\n-            clean::ResolvedPath { did, .. } => did,\n+        let generic = match self_ {\n+            clean::Generic(s) => s,\n             _ => return true,\n         };\n         let bounds = match params.get_mut(generic) {\n             Some(bound) => bound,\n             None => return true,\n         };\n-        !bounds.iter_mut().any(|b| {\n-            let trait_ref = match *b {\n-                clean::GenericBound::TraitBound(ref mut tr, _) => tr,\n-                clean::GenericBound::Outlives(..) => return false,\n-            };\n-            let (did, path) = match trait_ref.trait_ {\n-                clean::ResolvedPath { did, ref mut path, ..} => (did, path),\n-                _ => return false,\n-            };\n-            // If this QPath's trait `trait_did` is the same as, or a supertrait\n-            // of, the bound's trait `did` then we can keep going, otherwise\n-            // this is just a plain old equality bound.\n-            if !trait_is_same_or_supertrait(cx, did, trait_did) {\n-                return false\n-            }\n-            let last = path.segments.last_mut().expect(\"segments were empty\");\n-            match last.args {\n-                PP::AngleBracketed { ref mut bindings, .. } => {\n-                    bindings.push(clean::TypeBinding {\n-                        name: name.clone(),\n-                        kind: clean::TypeBindingKind::Equality {\n-                            ty: rhs.clone(),\n-                        },\n-                    });\n-                }\n-                PP::Parenthesized { ref mut output, .. } => {\n-                    assert!(output.is_none());\n-                    if *rhs != clean::Type::Tuple(Vec::new()) {\n-                        *output = Some(rhs.clone());\n-                    }\n-                }\n-            };\n-            true\n-        })\n+\n+        merge_bounds(cx, bounds, trait_did, name, rhs)\n     });\n \n     // And finally, let's reassemble everything\n@@ -127,6 +90,49 @@ pub fn where_clauses(cx: &DocContext<'_>, clauses: Vec<WP>) -> Vec<WP> {\n     clauses\n }\n \n+pub fn merge_bounds(\n+    cx: &clean::DocContext<'_>,\n+    bounds: &mut Vec<clean::GenericBound>,\n+    trait_did: DefId,\n+    name: &str,\n+    rhs: &clean::Type,\n+) -> bool {\n+    !bounds.iter_mut().any(|b| {\n+        let trait_ref = match *b {\n+            clean::GenericBound::TraitBound(ref mut tr, _) => tr,\n+            clean::GenericBound::Outlives(..) => return false,\n+        };\n+        let (did, path) = match trait_ref.trait_ {\n+            clean::ResolvedPath { did, ref mut path, ..} => (did, path),\n+            _ => return false,\n+        };\n+        // If this QPath's trait `trait_did` is the same as, or a supertrait\n+        // of, the bound's trait `did` then we can keep going, otherwise\n+        // this is just a plain old equality bound.\n+        if !trait_is_same_or_supertrait(cx, did, trait_did) {\n+            return false\n+        }\n+        let last = path.segments.last_mut().expect(\"segments were empty\");\n+        match last.args {\n+            PP::AngleBracketed { ref mut bindings, .. } => {\n+                bindings.push(clean::TypeBinding {\n+                    name: name.to_string(),\n+                    kind: clean::TypeBindingKind::Equality {\n+                        ty: rhs.clone(),\n+                    },\n+                });\n+            }\n+            PP::Parenthesized { ref mut output, .. } => {\n+                assert!(output.is_none());\n+                if *rhs != clean::Type::Tuple(Vec::new()) {\n+                    *output = Some(rhs.clone());\n+                }\n+            }\n+        };\n+        true\n+    })\n+}\n+\n pub fn ty_params(mut params: Vec<clean::GenericParamDef>) -> Vec<clean::GenericParamDef> {\n     for param in &mut params {\n         match param.kind {"}, {"sha": "7b6e665b85f1903408b0714c77206959747e8a3a", "filename": "src/test/rustdoc/inline_cross/auxiliary/impl_trait_aux.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9beff38382a88ceafcb6e83636535c07eacad345/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Fimpl_trait_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9beff38382a88ceafcb6e83636535c07eacad345/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Fimpl_trait_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Fimpl_trait_aux.rs?ref=9beff38382a88ceafcb6e83636535c07eacad345", "patch": "@@ -1,5 +1,9 @@\n+use std::ops::Deref;\n+\n pub fn func<'a>(_x: impl Clone + Into<Vec<u8>> + 'a) {}\n \n+pub fn func2<T>(_x: impl Deref<Target = Option<T>> + Iterator<Item = T>, _y: impl Iterator<Item = u8>) {}\n+\n pub struct Foo;\n \n impl Foo {"}, {"sha": "20d193aad16dc0866a32e1fe3769c7f1c2d484c6", "filename": "src/test/rustdoc/inline_cross/impl_trait.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9beff38382a88ceafcb6e83636535c07eacad345/src%2Ftest%2Frustdoc%2Finline_cross%2Fimpl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9beff38382a88ceafcb6e83636535c07eacad345/src%2Ftest%2Frustdoc%2Finline_cross%2Fimpl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fimpl_trait.rs?ref=9beff38382a88ceafcb6e83636535c07eacad345", "patch": "@@ -7,6 +7,12 @@ extern crate impl_trait_aux;\n // @!has - '//pre[@class=\"rust fn\"]' 'where'\n pub use impl_trait_aux::func;\n \n+// @has impl_trait/fn.func2.html\n+// @has - '//pre[@class=\"rust fn\"]' \"_x: impl Deref<Target = Option<T>> + Iterator<Item = T>,\"\n+// @has - '//pre[@class=\"rust fn\"]' \"_y: impl Iterator<Item = u8>)\"\n+// @!has - '//pre[@class=\"rust fn\"]' 'where'\n+pub use impl_trait_aux::func2;\n+\n // @has impl_trait/struct.Foo.html\n // @has - '//code[@id=\"method.v\"]' \"pub fn method<'a>(_x: impl Clone + Into<Vec<u8>> + 'a)\"\n // @!has - '//code[@id=\"method.v\"]' 'where'"}]}