{"sha": "4b57d2228b4f00e647efb10b0f874dd1fa9baefd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiNTdkMjIyOGI0ZjAwZTY0N2VmYjEwYjBmODc0ZGQxZmE5YmFlZmQ=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-11-07T02:26:40Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-11-24T19:37:23Z"}, "message": "Fix opaque types resulting from projections in function signature\n\nWhen we normalize the types in a function signature, we may end up\nresolving a projection to an opaque type (e.g. `Self::MyType` when\nwe have `type MyType = impl SomeTrait`). When the projection is\nresolved, we will instantiate the generic parameters into fresh\ninference variables.\n\nWhile we do want to normalize projections to opaque types, we don't want\nto replace the explicit generic parameters (e.g. `T` in `impl\nMyTrait<T>`) with inference variables. We want the opaque type in the\nfunction signature to be eligible to be a defining use of that opaque\ntype - adding inference variables prevents this, since the opaque type\nsubsts now appears to refer to some specific type, rather than a generic\ntype.\n\nTo resolve this issue, we inspect the opaque types in the function\nsignature after normalization. Any inference variables in the substs are\nreplaced with the corresponding generic parameter in the identity substs\n(e.g. `T` in `impl MyTrait<T>`). Note that normalization is the only way\nthat we can end up with inference variables in opaque substs in a\nfunction signature - users have no way of getting inference variables\ninto a function signature.\n\nNote that all of this refers to the opaque type (ty::Opaque) and its\nsubst - *not* to the underlying type.\n\nFixes #59342", "tree": {"sha": "652dd2dd4aa3cb94015a70a8b9d43d387f7f49a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/652dd2dd4aa3cb94015a70a8b9d43d387f7f49a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b57d2228b4f00e647efb10b0f874dd1fa9baefd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAl3a2/MACgkQtAh+UQ6Y\nsWR3XhAAolJJwIoAO2lwEcNZNLbBgPDCw2KFw/8W64VI/RogXBq1h8pVzHrXBWiV\n5cpG7YnBumreZZOiSfT/iJDW3ySLiIOTvCRj0HgOaPlm7+HSYl5QJbjFcNpL79dV\n6fdyDyxVruyq2U4pS5ynu1pGBrKtDoOT7WVrjfxM97WT03ScOXoek2EVFDslYL+f\nvlFSuUKl8XfYNsR1EaTSVlnnQH9MOfT9qA06YC9QPGHOKyCU3z9mdVCp4/x1rpQv\nM9vfhQ/uLYts7pbzIniIigQp37Vs0SpKxlbZlY4IlkgESC9GVEevife8P104VJ2B\nCiDzGbhf5+Wtlc5l17wl2fxIB+rc9THWdNf2fZxng9um1L24G3G3sJXIEQSz2xnu\nNZ3MaoM80R0SHNwd632m6Xm2C4MK8fLzbAQHuWhAXA9NGT0wwezEAE+J/vRWCsnG\n4yfZYlpl2e1xWosCHeehhX0lE3vchvUE7sb7X4yaMGoZVYOHcUJfAj1Fo/hXIXwb\ns74V37Z21wTDT1ZmJMnlArLxFqEFJXKjQ2hOog2aP1iaxTQ5d0/durXUEZA+CWXq\nIBbbD4C6S+5GF+UDWANPDToaTLA9QvHo6Jlh6YyMifuWlNf9SBd3rPFPVjIz8bx4\nUu5tG4i04qsbeWBorMaNM4+FR3HeVQBazPAq/wZcXc7obR0WseI=\n=2C5J\n-----END PGP SIGNATURE-----", "payload": "tree 652dd2dd4aa3cb94015a70a8b9d43d387f7f49a9\nparent 5a1d028d4c8fc15473dc10473c38df162daa7b41\nauthor Aaron Hill <aa1ronham@gmail.com> 1573093600 -0500\ncommitter Aaron Hill <aa1ronham@gmail.com> 1574624243 -0500\n\nFix opaque types resulting from projections in function signature\n\nWhen we normalize the types in a function signature, we may end up\nresolving a projection to an opaque type (e.g. `Self::MyType` when\nwe have `type MyType = impl SomeTrait`). When the projection is\nresolved, we will instantiate the generic parameters into fresh\ninference variables.\n\nWhile we do want to normalize projections to opaque types, we don't want\nto replace the explicit generic parameters (e.g. `T` in `impl\nMyTrait<T>`) with inference variables. We want the opaque type in the\nfunction signature to be eligible to be a defining use of that opaque\ntype - adding inference variables prevents this, since the opaque type\nsubsts now appears to refer to some specific type, rather than a generic\ntype.\n\nTo resolve this issue, we inspect the opaque types in the function\nsignature after normalization. Any inference variables in the substs are\nreplaced with the corresponding generic parameter in the identity substs\n(e.g. `T` in `impl MyTrait<T>`). Note that normalization is the only way\nthat we can end up with inference variables in opaque substs in a\nfunction signature - users have no way of getting inference variables\ninto a function signature.\n\nNote that all of this refers to the opaque type (ty::Opaque) and its\nsubst - *not* to the underlying type.\n\nFixes #59342\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b57d2228b4f00e647efb10b0f874dd1fa9baefd", "html_url": "https://github.com/rust-lang/rust/commit/4b57d2228b4f00e647efb10b0f874dd1fa9baefd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b57d2228b4f00e647efb10b0f874dd1fa9baefd/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a1d028d4c8fc15473dc10473c38df162daa7b41", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a1d028d4c8fc15473dc10473c38df162daa7b41", "html_url": "https://github.com/rust-lang/rust/commit/5a1d028d4c8fc15473dc10473c38df162daa7b41"}], "stats": {"total": 81, "additions": 80, "deletions": 1}, "files": [{"sha": "c0b49bb5918384fe1efce6b0269940353073e8e1", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/4b57d2228b4f00e647efb10b0f874dd1fa9baefd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b57d2228b4f00e647efb10b0f874dd1fa9baefd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4b57d2228b4f00e647efb10b0f874dd1fa9baefd", "patch": "@@ -114,7 +114,7 @@ use rustc::ty::{\n use rustc::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability, PointerCast\n };\n-use rustc::ty::fold::TypeFoldable;\n+use rustc::ty::fold::{TypeFoldable, TypeFolder};\n use rustc::ty::query::Providers;\n use rustc::ty::subst::{\n     GenericArgKind, Subst, InternalSubsts, SubstsRef, UserSelfTy, UserSubsts,\n@@ -872,6 +872,58 @@ fn used_trait_imports(tcx: TyCtxt<'_>, def_id: DefId) -> &DefIdSet {\n     &*tcx.typeck_tables_of(def_id).used_trait_imports\n }\n \n+/// Inspects the substs of opaque types, replacing any inference variables\n+/// with proper generic parameter from the identity substs.\n+///\n+/// This is run after we normalize the function signature, to fix any inference\n+/// variables introduced by the projection of associated types. This ensures that\n+/// any opaque types used in the signature continue to refer to generic parameters,\n+/// allowing them to be considered for defining uses in the function body\n+fn fixup_opaque_types<'tcx, T>(tcx: TyCtxt<'tcx>, val: &T) -> T where T: TypeFoldable<'tcx> {\n+    struct FixupFolder<'tcx> {\n+        tcx: TyCtxt<'tcx>\n+    }\n+\n+    impl<'tcx> TypeFolder<'tcx> for FixupFolder<'tcx> {\n+        fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n+            self.tcx\n+        }\n+\n+        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+            match ty.kind {\n+                ty::Opaque(def_id, substs) => {\n+                    debug!(\"fixup_opaque_types: found type {:?}\", ty);\n+                    if ty.has_infer_types() {\n+                        let new_substs = InternalSubsts::for_item(self.tcx, def_id, |param, _| {\n+                            let old_param = substs[param.index as usize];\n+                            match old_param.unpack() {\n+                                GenericArgKind::Type(old_ty) => {\n+                                    if let ty::Infer(_) = old_ty.kind {\n+                                        // Replace inference type with a generic parameter\n+                                        self.tcx.mk_param_from_def(param)\n+                                    } else {\n+                                        old_param.fold_with(self)\n+                                    }\n+                                },\n+                                _ => old_param\n+                            }\n+                        });\n+                        let new_ty = self.tcx.mk_opaque(def_id, new_substs);\n+                        debug!(\"fixup_opaque_types: new type: {:?}\", new_ty);\n+                        new_ty\n+                    } else {\n+                        ty\n+                    }\n+                },\n+                _ => ty.super_fold_with(self)\n+            }\n+        }\n+    }\n+\n+    debug!(\"fixup_opaque_types({:?})\", val);\n+    val.fold_with(&mut FixupFolder { tcx })\n+}\n+\n fn typeck_tables_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::TypeckTables<'_> {\n     // Closures' tables come from their outermost function,\n     // as they are part of the same \"inference environment\".\n@@ -911,6 +963,8 @@ fn typeck_tables_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::TypeckTables<'_> {\n                                                   param_env,\n                                                   &fn_sig);\n \n+            let fn_sig = fixup_opaque_types(tcx, &fn_sig);\n+\n             let fcx = check_fn(&inh, param_env, fn_sig, decl, id, body, None).0;\n             fcx\n         } else {"}, {"sha": "7732ac4a1c85e1eaeb4ed374e1035c3e0899b857", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4b57d2228b4f00e647efb10b0f874dd1fa9baefd/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b57d2228b4f00e647efb10b0f874dd1fa9baefd/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=4b57d2228b4f00e647efb10b0f874dd1fa9baefd", "patch": "@@ -2059,6 +2059,9 @@ fn explicit_predicates_of(\n                 ty::print::with_no_queries(|| {\n                     let substs = InternalSubsts::identity_for_item(tcx, def_id);\n                     let opaque_ty = tcx.mk_opaque(def_id, substs);\n+                    debug!(\"explicit_predicates_of({:?}): created opaque type {:?}\",\n+                        def_id, opaque_ty);\n+\n \n                     // Collect the bounds, i.e., the `A + B + 'c` in `impl A + B + 'c`.\n                     let bounds = AstConv::compute_bounds("}, {"sha": "d834d9bb112f53ae57737bad22b32d5f851bab91", "filename": "src/test/ui/impl-trait/type-alias-generic-param.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4b57d2228b4f00e647efb10b0f874dd1fa9baefd/src%2Ftest%2Fui%2Fimpl-trait%2Ftype-alias-generic-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b57d2228b4f00e647efb10b0f874dd1fa9baefd/src%2Ftest%2Fui%2Fimpl-trait%2Ftype-alias-generic-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftype-alias-generic-param.rs?ref=4b57d2228b4f00e647efb10b0f874dd1fa9baefd", "patch": "@@ -0,0 +1,22 @@\n+// Regression test for issue #59342\n+// Checks that we properly detect defining uses of opaque\n+// types in 'item' position when generic parameters are involved\n+//\n+// run-pass\n+#![feature(type_alias_impl_trait)]\n+\n+trait Meow {\n+    type MeowType;\n+    fn meow(self) -> Self::MeowType;\n+}\n+\n+impl<T, I> Meow for I\n+    where I: Iterator<Item = T>\n+{\n+    type MeowType = impl Iterator<Item = T>;\n+    fn meow(self) -> Self::MeowType {\n+        self\n+    }\n+}\n+\n+fn main() {}"}]}