{"sha": "92dd995e1705a8c398a5266c8483e2519e494f47", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyZGQ5OTVlMTcwNWE4YzM5OGE1MjY2Yzg0ODNlMjUxOWU0OTRmNDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-16T22:13:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-16T22:13:52Z"}, "message": "Auto merge of #23331 - eddyb:attr-lookahead, r=nikomatsakis\n\nMost of the changes are cleanup facilitated by straight-forward attribute handling.\r\nThis is a minor [breaking-change] for users of `quote_stmt!` (returns `Option<P<Stmt>>` now) and some of the public methods in `Parser` (a few `Vec<Attribute>` arguments/returns were removed).\r\n\r\nr? @nikomatsakis", "tree": {"sha": "6f94cde4454a63e09666c4473ecdc931d80d442c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f94cde4454a63e09666c4473ecdc931d80d442c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92dd995e1705a8c398a5266c8483e2519e494f47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92dd995e1705a8c398a5266c8483e2519e494f47", "html_url": "https://github.com/rust-lang/rust/commit/92dd995e1705a8c398a5266c8483e2519e494f47", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92dd995e1705a8c398a5266c8483e2519e494f47/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1760e8749a46d8b64f8411a08a79d90e2b5f966e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1760e8749a46d8b64f8411a08a79d90e2b5f966e", "html_url": "https://github.com/rust-lang/rust/commit/1760e8749a46d8b64f8411a08a79d90e2b5f966e"}, {"sha": "9889aae13e14c306fce8cefd669841fa40f26ee9", "url": "https://api.github.com/repos/rust-lang/rust/commits/9889aae13e14c306fce8cefd669841fa40f26ee9", "html_url": "https://github.com/rust-lang/rust/commit/9889aae13e14c306fce8cefd669841fa40f26ee9"}], "stats": {"total": 833, "additions": 323, "deletions": 510}, "files": [{"sha": "c38556b0782196e3bb51f0d59d985bbb8793aeea", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/92dd995e1705a8c398a5266c8483e2519e494f47/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92dd995e1705a8c398a5266c8483e2519e494f47/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=92dd995e1705a8c398a5266c8483e2519e494f47", "patch": "@@ -361,8 +361,7 @@ pub mod rt {\n             parse::parse_stmt_from_source_str(\"<quote expansion>\".to_string(),\n                                               s,\n                                               self.cfg(),\n-                                              Vec::new(),\n-                                              self.parse_sess())\n+                                              self.parse_sess()).expect(\"parse error\")\n         }\n \n         fn parse_expr(&self, s: String) -> P<ast::Expr> {\n@@ -407,16 +406,15 @@ pub fn expand_quote_expr<'cx>(cx: &'cx mut ExtCtxt,\n                               sp: Span,\n                               tts: &[ast::TokenTree])\n                               -> Box<base::MacResult+'cx> {\n-    let expanded = expand_parse_call(cx, sp, \"parse_expr\", Vec::new(), tts);\n+    let expanded = expand_parse_call(cx, sp, \"parse_expr\", vec!(), tts);\n     base::MacEager::expr(expanded)\n }\n \n pub fn expand_quote_item<'cx>(cx: &mut ExtCtxt,\n                               sp: Span,\n                               tts: &[ast::TokenTree])\n                               -> Box<base::MacResult+'cx> {\n-    let expanded = expand_parse_call(cx, sp, \"parse_item_with_outer_attributes\",\n-                                    vec!(), tts);\n+    let expanded = expand_parse_call(cx, sp, \"parse_item\", vec!(), tts);\n     base::MacEager::expr(expanded)\n }\n \n@@ -448,9 +446,7 @@ pub fn expand_quote_stmt(cx: &mut ExtCtxt,\n                          sp: Span,\n                          tts: &[ast::TokenTree])\n                          -> Box<base::MacResult+'static> {\n-    let e_attrs = cx.expr_vec_ng(sp);\n-    let expanded = expand_parse_call(cx, sp, \"parse_stmt\",\n-                                    vec!(e_attrs), tts);\n+    let expanded = expand_parse_call(cx, sp, \"parse_stmt\", vec!(), tts);\n     base::MacEager::expr(expanded)\n }\n "}, {"sha": "c61aec0069db255032b059d3bedd105b86305878", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92dd995e1705a8c398a5266c8483e2519e494f47/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92dd995e1705a8c398a5266c8483e2519e494f47/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=92dd995e1705a8c398a5266c8483e2519e494f47", "patch": "@@ -115,7 +115,7 @@ pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree\n                       -> Option<SmallVector<P<ast::Item>>> {\n             let mut ret = SmallVector::zero();\n             while self.p.token != token::Eof {\n-                match self.p.parse_item_with_outer_attributes() {\n+                match self.p.parse_item() {\n                     Some(item) => ret.push(item),\n                     None => self.p.span_fatal(\n                         self.p.span,"}, {"sha": "b7d40a46f3ea26026d119f0fd9be3eccfef166e2", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/92dd995e1705a8c398a5266c8483e2519e494f47/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92dd995e1705a8c398a5266c8483e2519e494f47/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=92dd995e1705a8c398a5266c8483e2519e494f47", "patch": "@@ -521,12 +521,15 @@ pub fn parse_nt(p: &mut Parser, sp: Span, name: &str) -> Nonterminal {\n     // check at the beginning and the parser checks after each bump\n     p.check_unknown_macro_variable();\n     match name {\n-      \"item\" => match p.parse_item(Vec::new()) {\n+      \"item\" => match p.parse_item() {\n         Some(i) => token::NtItem(i),\n         None => p.fatal(\"expected an item keyword\")\n       },\n       \"block\" => token::NtBlock(p.parse_block()),\n-      \"stmt\" => token::NtStmt(p.parse_stmt(Vec::new())),\n+      \"stmt\" => match p.parse_stmt() {\n+        Some(s) => token::NtStmt(s),\n+        None => p.fatal(\"expected a statement\")\n+      },\n       \"pat\" => token::NtPat(p.parse_pat()),\n       \"expr\" => token::NtExpr(p.parse_expr()),\n       \"ty\" => token::NtTy(p.parse_ty()),"}, {"sha": "7a2ae55e91494cfad3186ac0122fcbc45c955bd5", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/92dd995e1705a8c398a5266c8483e2519e494f47/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92dd995e1705a8c398a5266c8483e2519e494f47/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=92dd995e1705a8c398a5266c8483e2519e494f47", "patch": "@@ -17,7 +17,6 @@ use ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n use ext::tt::macro_parser::{parse, parse_or_else};\n use parse::lexer::new_tt_reader;\n use parse::parser::Parser;\n-use parse::attr::ParserAttr;\n use parse::token::{self, special_idents, gensym_ident, NtTT, Token};\n use parse::token::Token::*;\n use print;\n@@ -68,15 +67,8 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n     }\n     fn make_items(self: Box<ParserAnyMacro<'a>>) -> Option<SmallVector<P<ast::Item>>> {\n         let mut ret = SmallVector::zero();\n-        loop {\n-            let mut parser = self.parser.borrow_mut();\n-            // so... do outer attributes attached to the macro invocation\n-            // just disappear? This question applies to make_impl_items, as\n-            // well.\n-            match parser.parse_item_with_outer_attributes() {\n-                Some(item) => ret.push(item),\n-                None => break\n-            }\n+        while let Some(item) = self.parser.borrow_mut().parse_item() {\n+            ret.push(item);\n         }\n         self.ensure_complete_parse(false);\n         Some(ret)\n@@ -89,18 +81,17 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n             let mut parser = self.parser.borrow_mut();\n             match parser.token {\n                 token::Eof => break,\n-                _ => ret.push(parser.parse_impl_item_with_outer_attributes())\n+                _ => ret.push(parser.parse_impl_item())\n             }\n         }\n         self.ensure_complete_parse(false);\n         Some(ret)\n     }\n \n     fn make_stmt(self: Box<ParserAnyMacro<'a>>) -> Option<P<ast::Stmt>> {\n-        let attrs = self.parser.borrow_mut().parse_outer_attributes();\n-        let ret = self.parser.borrow_mut().parse_stmt(attrs);\n+        let ret = self.parser.borrow_mut().parse_stmt();\n         self.ensure_complete_parse(true);\n-        Some(ret)\n+        ret\n     }\n }\n "}, {"sha": "a5dd4f222241d0d0d5a05814a970dd4e65a8737f", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 26, "deletions": 32, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/92dd995e1705a8c398a5266c8483e2519e494f47/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92dd995e1705a8c398a5266c8483e2519e494f47/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=92dd995e1705a8c398a5266c8483e2519e494f47", "patch": "@@ -19,9 +19,8 @@ use ptr::P;\n /// A parser that can parse attributes.\n pub trait ParserAttr {\n     fn parse_outer_attributes(&mut self) -> Vec<ast::Attribute>;\n+    fn parse_inner_attributes(&mut self) -> Vec<ast::Attribute>;\n     fn parse_attribute(&mut self, permit_inner: bool) -> ast::Attribute;\n-    fn parse_inner_attrs_and_next(&mut self)\n-                                  -> (Vec<ast::Attribute>, Vec<ast::Attribute>);\n     fn parse_meta_item(&mut self) -> P<ast::MetaItem>;\n     fn parse_meta_seq(&mut self) -> Vec<P<ast::MetaItem>>;\n     fn parse_optional_meta(&mut self) -> Vec<P<ast::MetaItem>>;\n@@ -118,45 +117,40 @@ impl<'a> ParserAttr for Parser<'a> {\n \n     /// Parse attributes that appear after the opening of an item. These should\n     /// be preceded by an exclamation mark, but we accept and warn about one\n-    /// terminated by a semicolon. In addition to a vector of inner attributes,\n-    /// this function also returns a vector that may contain the first outer\n-    /// attribute of the next item (since we can't know whether the attribute\n-    /// is an inner attribute of the containing item or an outer attribute of\n-    /// the first contained item until we see the semi).\n-\n-    /// matches inner_attrs* outer_attr?\n-    /// you can make the 'next' field an Option, but the result is going to be\n-    /// more useful as a vector.\n-    fn parse_inner_attrs_and_next(&mut self)\n-                                  -> (Vec<ast::Attribute> , Vec<ast::Attribute> ) {\n-        let mut inner_attrs: Vec<ast::Attribute> = Vec::new();\n-        let mut next_outer_attrs: Vec<ast::Attribute> = Vec::new();\n+    /// terminated by a semicolon.\n+\n+    /// matches inner_attrs*\n+    fn parse_inner_attributes(&mut self) -> Vec<ast::Attribute> {\n+        let mut attrs: Vec<ast::Attribute> = vec![];\n         loop {\n-            let attr = match self.token {\n+            match self.token {\n                 token::Pound => {\n-                    self.parse_attribute(true)\n+                    // Don't even try to parse if it's not an inner attribute.\n+                    if !self.look_ahead(1, |t| t == &token::Not) {\n+                        break;\n+                    }\n+\n+                    let attr = self.parse_attribute(true);\n+                    assert!(attr.node.style == ast::AttrInner);\n+                    attrs.push(attr);\n                 }\n                 token::DocComment(s) => {\n                     // we need to get the position of this token before we bump.\n                     let Span { lo, hi, .. } = self.span;\n-                    self.bump();\n-                    attr::mk_sugared_doc_attr(attr::mk_attr_id(),\n-                                              self.id_to_interned_str(s.ident()),\n-                                              lo,\n-                                              hi)\n-                }\n-                _ => {\n-                    break;\n+                    let attr = attr::mk_sugared_doc_attr(attr::mk_attr_id(),\n+                                                         self.id_to_interned_str(s.ident()),\n+                                                         lo, hi);\n+                    if attr.node.style == ast::AttrInner {\n+                        attrs.push(attr);\n+                        self.bump();\n+                    } else {\n+                        break;\n+                    }\n                 }\n-            };\n-            if attr.node.style == ast::AttrInner {\n-                inner_attrs.push(attr);\n-            } else {\n-                next_outer_attrs.push(attr);\n-                break;\n+                _ => break\n             }\n         }\n-        (inner_attrs, next_outer_attrs)\n+        attrs\n     }\n \n     /// matches meta_item = IDENT"}, {"sha": "82ba873e54b95140ab7e0fb406729da21c68d393", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/92dd995e1705a8c398a5266c8483e2519e494f47/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92dd995e1705a8c398a5266c8483e2519e494f47/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=92dd995e1705a8c398a5266c8483e2519e494f47", "patch": "@@ -96,9 +96,7 @@ pub fn parse_crate_attrs_from_file(\n     cfg: ast::CrateConfig,\n     sess: &ParseSess\n ) -> Vec<ast::Attribute> {\n-    let mut parser = new_parser_from_file(sess, cfg, input);\n-    let (inner, _) = parser.parse_inner_attrs_and_next();\n-    inner\n+    new_parser_from_file(sess, cfg, input).parse_inner_attributes()\n }\n \n pub fn parse_crate_from_source_str(name: String,\n@@ -122,8 +120,7 @@ pub fn parse_crate_attrs_from_source_str(name: String,\n                                            cfg,\n                                            name,\n                                            source);\n-    let (inner, _) = maybe_aborted(p.parse_inner_attrs_and_next(),p);\n-    inner\n+    maybe_aborted(p.parse_inner_attributes(), p)\n }\n \n pub fn parse_expr_from_source_str(name: String,\n@@ -141,7 +138,7 @@ pub fn parse_item_from_source_str(name: String,\n                                   sess: &ParseSess)\n                                   -> Option<P<ast::Item>> {\n     let mut p = new_parser_from_source_str(sess, cfg, name, source);\n-    maybe_aborted(p.parse_item_with_outer_attributes(),p)\n+    maybe_aborted(p.parse_item(),p)\n }\n \n pub fn parse_meta_from_source_str(name: String,\n@@ -156,16 +153,15 @@ pub fn parse_meta_from_source_str(name: String,\n pub fn parse_stmt_from_source_str(name: String,\n                                   source: String,\n                                   cfg: ast::CrateConfig,\n-                                  attrs: Vec<ast::Attribute> ,\n                                   sess: &ParseSess)\n-                                  -> P<ast::Stmt> {\n+                                  -> Option<P<ast::Stmt>> {\n     let mut p = new_parser_from_source_str(\n         sess,\n         cfg,\n         name,\n         source\n     );\n-    maybe_aborted(p.parse_stmt(attrs),p)\n+    maybe_aborted(p.parse_stmt(), p)\n }\n \n // Note: keep in sync with `with_hygiene::parse_tts_from_source_str`"}, {"sha": "1b51b5155998d4e927187ddf19b3cce80aad5baf", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 272, "deletions": 439, "changes": 711, "blob_url": "https://github.com/rust-lang/rust/blob/92dd995e1705a8c398a5266c8483e2519e494f47/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92dd995e1705a8c398a5266c8483e2519e494f47/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=92dd995e1705a8c398a5266c8483e2519e494f47", "patch": "@@ -39,7 +39,7 @@ use ast::{LitStr, LitInt, Local, LocalLet};\n use ast::{MacStmtWithBraces, MacStmtWithSemicolon, MacStmtWithoutBraces};\n use ast::{MutImmutable, MutMutable, Mac_, MacInvocTT, MatchSource};\n use ast::{MutTy, BiMul, Mutability};\n-use ast::{MethodImplItem, NamedField, UnNeg, NoReturn, NodeId, UnNot};\n+use ast::{MethodImplItem, NamedField, UnNeg, NoReturn, UnNot};\n use ast::{Pat, PatEnum, PatIdent, PatLit, PatRange, PatRegion, PatStruct};\n use ast::{PatTup, PatBox, PatWild, PatWildMulti, PatWildSingle};\n use ast::{PolyTraitRef, QSelf};\n@@ -116,11 +116,6 @@ pub enum BoundParsingMode {\n     Modified,\n }\n \n-/// The `Err` case indicates a failure to parse any kind of item.\n-/// The attributes are returned.\n-type MaybeItem = Result<P<Item>, Vec<Attribute>>;\n-\n-\n /// Possibly accept an `token::Interpolated` expression (a pre-parsed expression\n /// dropped into the token stream, which happens while parsing the result of\n /// macro expansion). Placement of these is not as complex as I feared it would\n@@ -207,7 +202,7 @@ macro_rules! maybe_whole {\n             }\n         }\n     );\n-    (Some $p:expr, $constructor:ident) => (\n+    (Some deref $p:expr, $constructor:ident) => (\n         {\n             let found = match ($p).token {\n                 token::Interpolated(token::$constructor(_)) => {\n@@ -216,7 +211,7 @@ macro_rules! maybe_whole {\n                 _ => None\n             };\n             if let Some(token::Interpolated(token::$constructor(x))) = found {\n-                return Some(x.clone());\n+                return Some((*x).clone());\n             }\n         }\n     );\n@@ -1239,55 +1234,21 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parses `type Foo;` in a trait declaration only. The `type` keyword has\n-    /// already been parsed.\n-    fn parse_assoc_ty_in_trait(&mut self, attrs: Vec<Attribute>)\n-                               -> P<TraitItem> {\n-        let TyParam {id, ident, bounds, default, span} = self.parse_ty_param();\n-        self.expect(&token::Semi);\n-        P(TraitItem {\n-            id: id,\n-            ident: ident,\n-            attrs: attrs,\n-            node: TypeTraitItem(bounds, default),\n-            span: span,\n-        })\n-    }\n-\n-    /// Parses `type Foo = TYPE;` in an implementation declaration only. The\n-    /// `type` keyword has already been parsed.\n-    fn parse_assoc_ty_in_impl(&mut self, attrs: Vec<Attribute>, vis: Visibility)\n-                              -> P<ImplItem> {\n-        let lo = self.span.lo;\n-        let ident = self.parse_ident();\n-        self.expect(&token::Eq);\n-        let typ = self.parse_ty_sum();\n-        let hi = self.span.hi;\n-        self.expect(&token::Semi);\n-        P(ImplItem {\n-            id: ast::DUMMY_NODE_ID,\n-            span: mk_sp(lo, hi),\n-            ident: ident,\n-            vis: vis,\n-            attrs: attrs,\n-            node: TypeImplItem(typ),\n-        })\n-    }\n-\n     /// Parse the items in a trait declaration\n     pub fn parse_trait_items(&mut self) -> Vec<P<TraitItem>> {\n         self.parse_unspanned_seq(\n             &token::OpenDelim(token::Brace),\n             &token::CloseDelim(token::Brace),\n             seq_sep_none(),\n             |p| {\n+            let lo = p.span.lo;\n             let mut attrs = p.parse_outer_attributes();\n \n-            if p.eat_keyword(keywords::Type) {\n-                p.parse_assoc_ty_in_trait(attrs)\n+            let (name, node) = if p.eat_keyword(keywords::Type) {\n+                let TyParam {ident, bounds, default, ..} = p.parse_ty_param();\n+                p.expect(&token::Semi);\n+                (ident, TypeTraitItem(bounds, default))\n             } else {\n-                let lo = p.span.lo;\n-\n                 let style = p.parse_unsafety();\n                 let abi = if p.eat_keyword(keywords::Extern) {\n                     p.parse_opt_abi().unwrap_or(abi::C)\n@@ -1315,7 +1276,6 @@ impl<'a> Parser<'a> {\n                     explicit_self: explicit_self,\n                 };\n \n-                let hi = p.last_span.hi;\n                 let body = match p.token {\n                   token::Semi => {\n                     p.bump();\n@@ -1336,15 +1296,16 @@ impl<'a> Parser<'a> {\n                                        token_str)[..])\n                   }\n                 };\n+                (ident, ast::MethodTraitItem(sig, body))\n+            };\n \n-                P(TraitItem {\n-                    id: ast::DUMMY_NODE_ID,\n-                    ident: ident,\n-                    attrs: attrs,\n-                    node: ast::MethodTraitItem(sig, body),\n-                    span: mk_sp(lo, hi),\n-                })\n-            }\n+            P(TraitItem {\n+                id: ast::DUMMY_NODE_ID,\n+                ident: name,\n+                attrs: attrs,\n+                node: node,\n+                span: mk_sp(lo, p.last_span.hi),\n+            })\n         })\n     }\n \n@@ -3646,41 +3607,47 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    /// Get an expected item after attributes error message.\n-    fn expected_item_err(attrs: &[Attribute]) -> &'static str {\n-        match attrs.last() {\n+    /// Emit an expected item after attributes error.\n+    fn expected_item_err(&self, attrs: &[Attribute]) {\n+        let message = match attrs.last() {\n             Some(&Attribute { node: ast::Attribute_ { is_sugared_doc: true, .. }, .. }) => {\n                 \"expected item after doc comment\"\n             }\n             _ => \"expected item after attributes\",\n-        }\n+        };\n+\n+        self.span_err(self.last_span, message);\n     }\n \n     /// Parse a statement. may include decl.\n-    /// Precondition: any attributes are parsed already\n-    pub fn parse_stmt(&mut self, item_attrs: Vec<Attribute>) -> P<Stmt> {\n-        maybe_whole!(self, NtStmt);\n+    pub fn parse_stmt(&mut self) -> Option<P<Stmt>> {\n+        self.parse_stmt_().map(P)\n+    }\n+\n+    fn parse_stmt_(&mut self) -> Option<Stmt> {\n+        maybe_whole!(Some deref self, NtStmt);\n \n         fn check_expected_item(p: &mut Parser, attrs: &[Attribute]) {\n             // If we have attributes then we should have an item\n             if !attrs.is_empty() {\n-                let last_span = p.last_span;\n-                p.span_err(last_span, Parser::expected_item_err(attrs));\n+                p.expected_item_err(attrs);\n             }\n         }\n \n         let lo = self.span.lo;\n-        if self.check_keyword(keywords::Let) {\n-            check_expected_item(self, &item_attrs[..]);\n+        let attrs = self.parse_outer_attributes();\n+\n+        Some(if self.check_keyword(keywords::Let) {\n+            check_expected_item(self, &attrs);\n             self.expect_keyword(keywords::Let);\n             let decl = self.parse_let();\n-            P(spanned(lo, decl.span.hi, StmtDecl(decl, ast::DUMMY_NODE_ID)))\n+            spanned(lo, decl.span.hi, StmtDecl(decl, ast::DUMMY_NODE_ID))\n         } else if self.token.is_ident()\n             && !self.token.is_any_keyword()\n             && self.look_ahead(1, |t| *t == token::Not) {\n             // it's a macro invocation:\n \n-            check_expected_item(self, &item_attrs[..]);\n+            check_expected_item(self, &attrs);\n \n             // Potential trouble: if we allow macros with paths instead of\n             // idents, we'd need to look ahead past the whole path here...\n@@ -3727,12 +3694,11 @@ impl<'a> Parser<'a> {\n             };\n \n             if id.name == token::special_idents::invalid.name {\n-                P(spanned(lo,\n-                          hi,\n-                          StmtMac(P(spanned(lo,\n+                spanned(lo, hi,\n+                        StmtMac(P(spanned(lo,\n                                           hi,\n                                           MacInvocTT(pth, tts, EMPTY_CTXT))),\n-                                  style)))\n+                                  style))\n             } else {\n                 // if it has a special ident, it's definitely an item\n                 //\n@@ -3746,35 +3712,38 @@ impl<'a> Parser<'a> {\n                                        followed by a semicolon\");\n                     }\n                 }\n-                P(spanned(lo, hi, StmtDecl(\n+                spanned(lo, hi, StmtDecl(\n                     P(spanned(lo, hi, DeclItem(\n                         self.mk_item(\n                             lo, hi, id /*id is good here*/,\n                             ItemMac(spanned(lo, hi, MacInvocTT(pth, tts, EMPTY_CTXT))),\n                             Inherited, Vec::new(/*no attrs*/))))),\n-                    ast::DUMMY_NODE_ID)))\n+                    ast::DUMMY_NODE_ID))\n             }\n         } else {\n-            let found_attrs = !item_attrs.is_empty();\n-            let item_err = Parser::expected_item_err(&item_attrs[..]);\n-            match self.parse_item_(item_attrs, false) {\n-                Ok(i) => {\n+            match self.parse_item_(attrs, false) {\n+                Some(i) => {\n                     let hi = i.span.hi;\n                     let decl = P(spanned(lo, hi, DeclItem(i)));\n-                    P(spanned(lo, hi, StmtDecl(decl, ast::DUMMY_NODE_ID)))\n+                    spanned(lo, hi, StmtDecl(decl, ast::DUMMY_NODE_ID))\n                 }\n-                Err(_) => {\n-                    if found_attrs {\n-                        let last_span = self.last_span;\n-                        self.span_err(last_span, item_err);\n+                None => {\n+                    // Do not attempt to parse an expression if we're done here.\n+                    if self.token == token::Semi {\n+                        self.bump();\n+                        return None;\n+                    }\n+\n+                    if self.token == token::CloseDelim(token::Brace) {\n+                        return None;\n                     }\n \n                     // Remainder are line-expr stmts.\n                     let e = self.parse_expr_res(RESTRICTION_STMT_EXPR);\n-                    P(spanned(lo, e.span.hi, StmtExpr(e, ast::DUMMY_NODE_ID)))\n+                    spanned(lo, e.span.hi, StmtExpr(e, ast::DUMMY_NODE_ID))\n                 }\n             }\n-        }\n+        })\n     }\n \n     /// Is this expression a successfully-parsed statement?\n@@ -3797,153 +3766,110 @@ impl<'a> Parser<'a> {\n                                  \"place this code inside a block\");\n         }\n \n-        return self.parse_block_tail_(lo, DefaultBlock, Vec::new());\n+        self.parse_block_tail(lo, DefaultBlock)\n     }\n \n     /// Parse a block. Inner attrs are allowed.\n-    fn parse_inner_attrs_and_block(&mut self)\n-        -> (Vec<Attribute> , P<Block>) {\n-\n+    fn parse_inner_attrs_and_block(&mut self) -> (Vec<Attribute>, P<Block>) {\n         maybe_whole!(pair_empty self, NtBlock);\n \n         let lo = self.span.lo;\n         self.expect(&token::OpenDelim(token::Brace));\n-        let (inner, next) = self.parse_inner_attrs_and_next();\n-\n-        (inner, self.parse_block_tail_(lo, DefaultBlock, next))\n+        (self.parse_inner_attributes(),\n+         self.parse_block_tail(lo, DefaultBlock))\n     }\n \n+    /// Parse the rest of a block expression or function body\n     /// Precondition: already parsed the '{'.\n     fn parse_block_tail(&mut self, lo: BytePos, s: BlockCheckMode) -> P<Block> {\n-        self.parse_block_tail_(lo, s, Vec::new())\n-    }\n-\n-    /// Parse the rest of a block expression or function body\n-    fn parse_block_tail_(&mut self, lo: BytePos, s: BlockCheckMode,\n-                         first_item_attrs: Vec<Attribute>) -> P<Block> {\n         let mut stmts = vec![];\n         let mut expr = None;\n-        let mut attributes_box = first_item_attrs;\n \n-        while self.token != token::CloseDelim(token::Brace) {\n-            // parsing items even when they're not allowed lets us give\n-            // better error messages and recover more gracefully.\n-            attributes_box.push_all(&self.parse_outer_attributes());\n-            match self.token {\n-                token::Semi => {\n-                    if !attributes_box.is_empty() {\n-                        let last_span = self.last_span;\n-                        self.span_err(last_span,\n-                                      Parser::expected_item_err(&attributes_box[..]));\n-                        attributes_box = Vec::new();\n-                    }\n-                    self.bump(); // empty\n-                }\n-                token::CloseDelim(token::Brace) => {\n-                    // fall through and out.\n+        while !self.eat(&token::CloseDelim(token::Brace)) {\n+            let Spanned {node, span} = if let Some(s) = self.parse_stmt_() {\n+                s\n+            } else {\n+                // Found only `;` or `}`.\n+                continue;\n+            };\n+            match node {\n+                StmtExpr(e, _) => {\n+                    self.handle_expression_like_statement(e, span, &mut stmts, &mut expr);\n                 }\n-                _ => {\n-                    let stmt = self.parse_stmt(attributes_box);\n-                    attributes_box = Vec::new();\n-                    stmt.and_then(|Spanned {node, span}| match node {\n-                        StmtExpr(e, stmt_id) => {\n-                            self.handle_expression_like_statement(e,\n-                                                                  stmt_id,\n-                                                                  span,\n-                                                                  &mut stmts,\n-                                                                  &mut expr);\n+                StmtMac(mac, MacStmtWithoutBraces) => {\n+                    // statement macro without braces; might be an\n+                    // expr depending on whether a semicolon follows\n+                    match self.token {\n+                        token::Semi => {\n+                            stmts.push(P(Spanned {\n+                                node: StmtMac(mac, MacStmtWithSemicolon),\n+                                span: span,\n+                            }));\n+                            self.bump();\n                         }\n-                        StmtMac(mac, MacStmtWithoutBraces) => {\n-                            // statement macro without braces; might be an\n-                            // expr depending on whether a semicolon follows\n-                            match self.token {\n-                                token::Semi => {\n-                                    stmts.push(P(Spanned {\n-                                        node: StmtMac(mac,\n-                                                      MacStmtWithSemicolon),\n-                                        span: span,\n-                                    }));\n-                                    self.bump();\n-                                }\n-                                _ => {\n-                                    let e = self.mk_mac_expr(span.lo,\n-                                                             span.hi,\n-                                                             mac.and_then(|m| m.node));\n-                                    let e = self.parse_dot_or_call_expr_with(e);\n-                                    let e = self.parse_more_binops(e, 0);\n-                                    let e = self.parse_assign_expr_with(e);\n-                                    self.handle_expression_like_statement(\n-                                        e,\n-                                        ast::DUMMY_NODE_ID,\n-                                        span,\n-                                        &mut stmts,\n-                                        &mut expr);\n-                                }\n-                            }\n+                        _ => {\n+                            let e = self.mk_mac_expr(span.lo, span.hi,\n+                                                     mac.and_then(|m| m.node));\n+                            let e = self.parse_dot_or_call_expr_with(e);\n+                            let e = self.parse_more_binops(e, 0);\n+                            let e = self.parse_assign_expr_with(e);\n+                            self.handle_expression_like_statement(\n+                                e,\n+                                span,\n+                                &mut stmts,\n+                                &mut expr);\n                         }\n-                        StmtMac(m, style) => {\n-                            // statement macro; might be an expr\n-                            match self.token {\n-                                token::Semi => {\n-                                    stmts.push(P(Spanned {\n-                                        node: StmtMac(m,\n-                                                      MacStmtWithSemicolon),\n-                                        span: span,\n-                                    }));\n-                                    self.bump();\n-                                }\n-                                token::CloseDelim(token::Brace) => {\n-                                    // if a block ends in `m!(arg)` without\n-                                    // a `;`, it must be an expr\n-                                    expr = Some(\n-                                        self.mk_mac_expr(span.lo,\n-                                                         span.hi,\n+                    }\n+                }\n+                StmtMac(m, style) => {\n+                    // statement macro; might be an expr\n+                    match self.token {\n+                        token::Semi => {\n+                            stmts.push(P(Spanned {\n+                                node: StmtMac(m, MacStmtWithSemicolon),\n+                                span: span,\n+                            }));\n+                            self.bump();\n+                        }\n+                        token::CloseDelim(token::Brace) => {\n+                            // if a block ends in `m!(arg)` without\n+                            // a `;`, it must be an expr\n+                            expr = Some(self.mk_mac_expr(span.lo, span.hi,\n                                                          m.and_then(|x| x.node)));\n-                                }\n-                                _ => {\n-                                    stmts.push(P(Spanned {\n-                                        node: StmtMac(m, style),\n-                                        span: span\n-                                    }));\n-                                }\n-                            }\n                         }\n-                        _ => { // all other kinds of statements:\n-                            if classify::stmt_ends_with_semi(&node) {\n-                                self.commit_stmt_expecting(token::Semi);\n-                            }\n-\n+                        _ => {\n                             stmts.push(P(Spanned {\n-                                node: node,\n+                                node: StmtMac(m, style),\n                                 span: span\n                             }));\n                         }\n-                    })\n+                    }\n                 }\n-            }\n-        }\n+                _ => { // all other kinds of statements:\n+                    if classify::stmt_ends_with_semi(&node) {\n+                        self.commit_stmt_expecting(token::Semi);\n+                    }\n \n-        if !attributes_box.is_empty() {\n-            let last_span = self.last_span;\n-            self.span_err(last_span,\n-                          Parser::expected_item_err(&attributes_box[..]));\n+                    stmts.push(P(Spanned {\n+                        node: node,\n+                        span: span\n+                    }));\n+                }\n+            }\n         }\n \n-        let hi = self.span.hi;\n-        self.bump();\n         P(ast::Block {\n             stmts: stmts,\n             expr: expr,\n             id: ast::DUMMY_NODE_ID,\n             rules: s,\n-            span: mk_sp(lo, hi),\n+            span: mk_sp(lo, self.last_span.hi),\n         })\n     }\n \n     fn handle_expression_like_statement(\n             &mut self,\n             e: P<Expr>,\n-            stmt_id: NodeId,\n             span: Span,\n             stmts: &mut Vec<P<Stmt>>,\n             last_block_expr: &mut Option<P<Expr>>) {\n@@ -3963,14 +3889,14 @@ impl<'a> Parser<'a> {\n                     expn_id: span.expn_id,\n                 };\n                 stmts.push(P(Spanned {\n-                    node: StmtSemi(e, stmt_id),\n+                    node: StmtSemi(e, ast::DUMMY_NODE_ID),\n                     span: span_with_semi,\n                 }));\n             }\n             token::CloseDelim(token::Brace) => *last_block_expr = Some(e),\n             _ => {\n                 stmts.push(P(Spanned {\n-                    node: StmtExpr(e, stmt_id),\n+                    node: StmtExpr(e, ast::DUMMY_NODE_ID),\n                     span: span\n                 }));\n             }\n@@ -4625,14 +4551,30 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse an impl item.\n-    pub fn parse_impl_item_with_outer_attributes(&mut self) -> P<ImplItem> {\n-        let attrs = self.parse_outer_attributes();\n+    pub fn parse_impl_item(&mut self) -> P<ImplItem> {\n+        let lo = self.span.lo;\n+        let mut attrs = self.parse_outer_attributes();\n         let vis = self.parse_visibility();\n-        if self.eat_keyword(keywords::Type) {\n-            self.parse_assoc_ty_in_impl(attrs, vis)\n+        let (name, node) = if self.eat_keyword(keywords::Type) {\n+            let name = self.parse_ident();\n+            self.expect(&token::Eq);\n+            let typ = self.parse_ty_sum();\n+            self.expect(&token::Semi);\n+            (name, TypeImplItem(typ))\n         } else {\n-            self.parse_method(attrs, vis)\n-        }\n+            let (name, inner_attrs, node) = self.parse_impl_method(vis);\n+            attrs.extend(inner_attrs.into_iter());\n+            (name, node)\n+        };\n+\n+        P(ImplItem {\n+            id: ast::DUMMY_NODE_ID,\n+            span: mk_sp(lo, self.last_span.hi),\n+            ident: name,\n+            vis: vis,\n+            attrs: attrs,\n+            node: node\n+        })\n     }\n \n     fn complain_if_pub_macro(&mut self, visa: Visibility, span: Span) {\n@@ -4646,76 +4588,58 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parse a method in a trait impl, starting with `attrs` attributes.\n-    pub fn parse_method(&mut self,\n-                        attrs: Vec<Attribute>,\n-                        vis: Visibility)\n-                        -> P<ImplItem> {\n-        let lo = self.span.lo;\n-\n+    /// Parse a method or a macro invocation in a trait impl.\n+    fn parse_impl_method(&mut self, vis: Visibility)\n+                         -> (Ident, Vec<ast::Attribute>, ast::ImplItem_) {\n         // code copied from parse_macro_use_or_failure... abstraction!\n-        let (method_, hi, new_attrs, ident) = {\n-            if !self.token.is_any_keyword()\n-                && self.look_ahead(1, |t| *t == token::Not)\n-                && (self.look_ahead(2, |t| *t == token::OpenDelim(token::Paren))\n-                    || self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace))) {\n-                // method macro.\n+        if !self.token.is_any_keyword()\n+            && self.look_ahead(1, |t| *t == token::Not)\n+            && (self.look_ahead(2, |t| *t == token::OpenDelim(token::Paren))\n+                || self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace))) {\n+            // method macro.\n \n-                let last_span = self.last_span;\n-                self.complain_if_pub_macro(vis, last_span);\n-\n-                let pth = self.parse_path(NoTypesAllowed);\n-                self.expect(&token::Not);\n-\n-                // eat a matched-delimiter token tree:\n-                let delim = self.expect_open_delim();\n-                let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n-                                                seq_sep_none(),\n-                                                |p| p.parse_token_tree());\n-                let m_ = ast::MacInvocTT(pth, tts, EMPTY_CTXT);\n-                let m: ast::Mac = codemap::Spanned { node: m_,\n-                                                 span: mk_sp(self.span.lo,\n-                                                             self.span.hi) };\n-                if delim != token::Brace {\n-                    self.expect(&token::Semi)\n-                }\n-                (ast::MacImplItem(m), self.span.hi, attrs,\n-                 token::special_idents::invalid)\n-            } else {\n-                let unsafety = self.parse_unsafety();\n-                let abi = if self.eat_keyword(keywords::Extern) {\n-                    self.parse_opt_abi().unwrap_or(abi::C)\n-                } else {\n-                    abi::Rust\n-                };\n-                self.expect_keyword(keywords::Fn);\n-                let ident = self.parse_ident();\n-                let mut generics = self.parse_generics();\n-                let (explicit_self, decl) = self.parse_fn_decl_with_self(|p| {\n-                        p.parse_arg()\n-                    });\n-                self.parse_where_clause(&mut generics);\n-                let (inner_attrs, body) = self.parse_inner_attrs_and_block();\n-                let body_span = body.span;\n-                let mut new_attrs = attrs;\n-                new_attrs.push_all(&inner_attrs[..]);\n-                (MethodImplItem(ast::MethodSig {\n-                    generics: generics,\n-                    abi: abi,\n-                    explicit_self: explicit_self,\n-                    unsafety: unsafety,\n-                    decl: decl\n-                 }, body), body_span.hi, new_attrs, ident)\n+            let last_span = self.last_span;\n+            self.complain_if_pub_macro(vis, last_span);\n+\n+            let pth = self.parse_path(NoTypesAllowed);\n+            self.expect(&token::Not);\n+\n+            // eat a matched-delimiter token tree:\n+            let delim = self.expect_open_delim();\n+            let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n+                                            seq_sep_none(),\n+                                            |p| p.parse_token_tree());\n+            let m_ = ast::MacInvocTT(pth, tts, EMPTY_CTXT);\n+            let m: ast::Mac = codemap::Spanned { node: m_,\n+                                                span: mk_sp(self.span.lo,\n+                                                            self.span.hi) };\n+            if delim != token::Brace {\n+                self.expect(&token::Semi)\n             }\n-        };\n-        P(ImplItem {\n-            id: ast::DUMMY_NODE_ID,\n-            attrs: new_attrs,\n-            vis: vis,\n-            ident: ident,\n-            node: method_,\n-            span: mk_sp(lo, hi),\n-        })\n+            (token::special_idents::invalid, vec![], ast::MacImplItem(m))\n+        } else {\n+            let unsafety = self.parse_unsafety();\n+            let abi = if self.eat_keyword(keywords::Extern) {\n+                self.parse_opt_abi().unwrap_or(abi::C)\n+            } else {\n+                abi::Rust\n+            };\n+            self.expect_keyword(keywords::Fn);\n+            let ident = self.parse_ident();\n+            let mut generics = self.parse_generics();\n+            let (explicit_self, decl) = self.parse_fn_decl_with_self(|p| {\n+                    p.parse_arg()\n+                });\n+            self.parse_where_clause(&mut generics);\n+            let (inner_attrs, body) = self.parse_inner_attrs_and_block();\n+            (ident, inner_attrs, MethodImplItem(ast::MethodSig {\n+                generics: generics,\n+                abi: abi,\n+                explicit_self: explicit_self,\n+                unsafety: unsafety,\n+                decl: decl\n+             }, body))\n+        }\n     }\n \n     /// Parse trait Foo { ... }\n@@ -4746,28 +4670,6 @@ impl<'a> Parser<'a> {\n         (ident, ItemTrait(unsafety, tps, bounds, meths), None)\n     }\n \n-    fn parse_impl_items(&mut self) -> (Vec<P<ImplItem>>, Vec<Attribute>) {\n-        let mut impl_items = Vec::new();\n-        self.expect(&token::OpenDelim(token::Brace));\n-        let (inner_attrs, mut method_attrs) =\n-            self.parse_inner_attrs_and_next();\n-        loop {\n-            method_attrs.extend(self.parse_outer_attributes().into_iter());\n-            if method_attrs.is_empty() && self.eat(&token::CloseDelim(token::Brace)) {\n-                break;\n-            }\n-\n-            let vis = self.parse_visibility();\n-            impl_items.push(if self.eat_keyword(keywords::Type) {\n-                self.parse_assoc_ty_in_impl(method_attrs, vis)\n-            } else {\n-                self.parse_method(method_attrs, vis)\n-            });\n-            method_attrs = vec![];\n-        }\n-        (impl_items, inner_attrs)\n-    }\n-\n     /// Parses items implementations variants\n     ///    impl<T> Foo { ... }\n     ///    impl<T> ToString for &'static T { ... }\n@@ -4834,7 +4736,14 @@ impl<'a> Parser<'a> {\n                 ty = self.parse_ty_sum();\n             }\n             self.parse_where_clause(&mut generics);\n-            let (impl_items, attrs) = self.parse_impl_items();\n+\n+            self.expect(&token::OpenDelim(token::Brace));\n+            let attrs = self.parse_inner_attributes();\n+\n+            let mut impl_items = vec![];\n+            while !self.eat(&token::CloseDelim(token::Brace)) {\n+                impl_items.push(self.parse_impl_item());\n+            }\n \n             (ast_util::impl_pretty_name(&opt_trait, Some(&*ty)),\n              ItemImpl(unsafety, polarity, generics, opt_trait, ty, impl_items),\n@@ -5073,53 +4982,16 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Given a termination token and a vector of already-parsed\n-    /// attributes (of length 0 or 1), parse all of the items in a module\n-    fn parse_mod_items(&mut self,\n-                       term: token::Token,\n-                       first_item_attrs: Vec<Attribute>,\n-                       inner_lo: BytePos)\n-                       -> Mod {\n-        // Parse all of the items up to closing or an attribute.\n-\n-        let mut attrs = first_item_attrs;\n-        attrs.push_all(&self.parse_outer_attributes());\n+    /// Given a termination token, parse all of the items in a module\n+    fn parse_mod_items(&mut self, term: &token::Token, inner_lo: BytePos) -> Mod {\n         let mut items = vec![];\n-\n-        loop {\n-            match self.parse_item_(attrs, true) {\n-                Err(returned_attrs) => {\n-                    attrs = returned_attrs;\n-                    break\n-                }\n-                Ok(item) => {\n-                    attrs = self.parse_outer_attributes();\n-                    items.push(item)\n-                }\n-            }\n-        }\n-\n-        // don't think this other loop is even necessary....\n-\n-        while self.token != term {\n-            let mut attrs = mem::replace(&mut attrs, vec![]);\n-            attrs.push_all(&self.parse_outer_attributes());\n-            debug!(\"parse_mod_items: parse_item_(attrs={:?})\", attrs);\n-            match self.parse_item_(attrs, true /* macros allowed */) {\n-              Ok(item) => items.push(item),\n-              Err(_) => {\n-                  let token_str = self.this_token_to_string();\n-                  self.fatal(&format!(\"expected item, found `{}`\",\n-                                     token_str))\n-              }\n-            }\n+        while let Some(item) = self.parse_item() {\n+            items.push(item);\n         }\n \n-        if !attrs.is_empty() {\n-            // We parsed attributes for the first item but didn't find it\n-            let last_span = self.last_span;\n-            self.span_err(last_span,\n-                          Parser::expected_item_err(&attrs[..]));\n+        if !self.eat(term) {\n+            let token_str = self.this_token_to_string();\n+            self.fatal(&format!(\"expected item, found `{}`\", token_str))\n         }\n \n         ast::Mod {\n@@ -5157,12 +5029,11 @@ impl<'a> Parser<'a> {\n             let mod_inner_lo = self.span.lo;\n             let old_owns_directory = self.owns_directory;\n             self.owns_directory = true;\n-            let (inner, next) = self.parse_inner_attrs_and_next();\n-            let m = self.parse_mod_items(token::CloseDelim(token::Brace), next, mod_inner_lo);\n-            self.expect(&token::CloseDelim(token::Brace));\n+            let attrs = self.parse_inner_attributes();\n+            let m = self.parse_mod_items(&token::CloseDelim(token::Brace), mod_inner_lo);\n             self.owns_directory = old_owns_directory;\n             self.pop_mod_path();\n-            (id, ItemMod(m), Some(inner))\n+            (id, ItemMod(m), Some(attrs))\n         }\n     }\n \n@@ -5289,11 +5160,10 @@ impl<'a> Parser<'a> {\n                                      Some(name),\n                                      id_sp);\n         let mod_inner_lo = p0.span.lo;\n-        let (mod_attrs, next) = p0.parse_inner_attrs_and_next();\n-        let first_item_outer_attrs = next;\n-        let m0 = p0.parse_mod_items(token::Eof, first_item_outer_attrs, mod_inner_lo);\n+        let mod_attrs = p0.parse_inner_attributes();\n+        let m0 = p0.parse_mod_items(&token::Eof, mod_inner_lo);\n         self.sess.included_mod_stack.borrow_mut().pop();\n-        return (ast::ItemMod(m0), mod_attrs);\n+        (ast::ItemMod(m0), mod_attrs)\n     }\n \n     /// Parse a function declaration from a foreign module\n@@ -5340,20 +5210,6 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    /// At this point, this is essentially a wrapper for\n-    /// parse_foreign_items.\n-    fn parse_foreign_mod_items(&mut self,\n-                               abi: abi::Abi,\n-                               first_item_attrs: Vec<Attribute>)\n-                               -> ForeignMod {\n-        let foreign_items = self.parse_foreign_items(first_item_attrs);\n-        assert!(self.token == token::CloseDelim(token::Brace));\n-        ast::ForeignMod {\n-            abi: abi,\n-            items: foreign_items\n-        }\n-    }\n-\n     /// Parse extern crate links\n     ///\n     /// # Examples\n@@ -5432,24 +5288,31 @@ impl<'a> Parser<'a> {\n                               lo: BytePos,\n                               opt_abi: Option<abi::Abi>,\n                               visibility: Visibility,\n-                              attrs: Vec<Attribute>)\n+                              mut attrs: Vec<Attribute>)\n                               -> P<Item> {\n-\n         self.expect(&token::OpenDelim(token::Brace));\n \n         let abi = opt_abi.unwrap_or(abi::C);\n \n-        let (inner, next) = self.parse_inner_attrs_and_next();\n-        let m = self.parse_foreign_mod_items(abi, next);\n+        attrs.extend(self.parse_inner_attributes().into_iter());\n+\n+        let mut foreign_items = vec![];\n+        while let Some(item) = self.parse_foreign_item() {\n+            foreign_items.push(item);\n+        }\n         self.expect(&token::CloseDelim(token::Brace));\n \n         let last_span = self.last_span;\n+        let m = ast::ForeignMod {\n+            abi: abi,\n+            items: foreign_items\n+        };\n         self.mk_item(lo,\n                      last_span.hi,\n                      special_idents::invalid,\n                      ItemForeignMod(m),\n                      visibility,\n-                     maybe_append(attrs, Some(inner)))\n+                     attrs)\n     }\n \n     /// Parse type Foo = Bar;\n@@ -5591,12 +5454,11 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parse one of the items allowed by the flags; on failure,\n-    /// return `Err(remaining_attrs)`.\n+    /// Parse one of the items allowed by the flags.\n     /// NB: this function no longer parses the items inside an\n     /// extern crate.\n     fn parse_item_(&mut self, attrs: Vec<Attribute>,\n-                   macros_allowed: bool) -> MaybeItem {\n+                   macros_allowed: bool) -> Option<P<Item>> {\n         let nt_item = match self.token {\n             token::Interpolated(token::NtItem(ref item)) => {\n                 Some((**item).clone())\n@@ -5609,7 +5471,7 @@ impl<'a> Parser<'a> {\n                 let mut attrs = attrs;\n                 mem::swap(&mut item.attrs, &mut attrs);\n                 item.attrs.extend(attrs.into_iter());\n-                return Ok(P(item));\n+                return Some(P(item));\n             }\n             None => {}\n         }\n@@ -5630,12 +5492,12 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     attrs);\n-            return Ok(item);\n+            return Some(item);\n         }\n \n         if self.eat_keyword(keywords::Extern) {\n             if self.eat_keyword(keywords::Crate) {\n-                return Ok(self.parse_item_extern_crate(lo, visibility, attrs));\n+                return Some(self.parse_item_extern_crate(lo, visibility, attrs));\n             }\n \n             let opt_abi = self.parse_opt_abi();\n@@ -5652,9 +5514,9 @@ impl<'a> Parser<'a> {\n                                         item_,\n                                         visibility,\n                                         maybe_append(attrs, extra_attrs));\n-                return Ok(item);\n+                return Some(item);\n             } else if self.check(&token::OpenDelim(token::Brace)) {\n-                return Ok(self.parse_item_foreign_mod(lo, opt_abi, visibility, attrs));\n+                return Some(self.parse_item_foreign_mod(lo, opt_abi, visibility, attrs));\n             }\n \n             let span = self.span;\n@@ -5680,7 +5542,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return Ok(item);\n+            return Some(item);\n         }\n         if self.eat_keyword(keywords::Const) {\n             // CONST ITEM\n@@ -5697,7 +5559,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return Ok(item);\n+            return Some(item);\n         }\n         if self.check_keyword(keywords::Unsafe) &&\n             self.look_ahead(1, |t| t.is_keyword(keywords::Trait))\n@@ -5714,7 +5576,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return Ok(item);\n+            return Some(item);\n         }\n         if self.check_keyword(keywords::Unsafe) &&\n             self.look_ahead(1, |t| t.is_keyword(keywords::Impl))\n@@ -5730,7 +5592,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return Ok(item);\n+            return Some(item);\n         }\n         if self.check_keyword(keywords::Fn) {\n             // FUNCTION ITEM\n@@ -5744,7 +5606,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return Ok(item);\n+            return Some(item);\n         }\n         if self.check_keyword(keywords::Unsafe)\n             && self.look_ahead(1, |t| *t != token::OpenDelim(token::Brace)) {\n@@ -5765,7 +5627,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return Ok(item);\n+            return Some(item);\n         }\n         if self.eat_keyword(keywords::Mod) {\n             // MODULE ITEM\n@@ -5778,7 +5640,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return Ok(item);\n+            return Some(item);\n         }\n         if self.eat_keyword(keywords::Type) {\n             // TYPE ITEM\n@@ -5790,7 +5652,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return Ok(item);\n+            return Some(item);\n         }\n         if self.eat_keyword(keywords::Enum) {\n             // ENUM ITEM\n@@ -5802,7 +5664,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return Ok(item);\n+            return Some(item);\n         }\n         if self.eat_keyword(keywords::Trait) {\n             // TRAIT ITEM\n@@ -5815,7 +5677,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return Ok(item);\n+            return Some(item);\n         }\n         if self.eat_keyword(keywords::Impl) {\n             // IMPL ITEM\n@@ -5827,7 +5689,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return Ok(item);\n+            return Some(item);\n         }\n         if self.eat_keyword(keywords::Struct) {\n             // STRUCT ITEM\n@@ -5839,30 +5701,34 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return Ok(item);\n+            return Some(item);\n         }\n         self.parse_macro_use_or_failure(attrs,macros_allowed,lo,visibility)\n     }\n \n-    /// Parse a foreign item; on failure, return `Err(remaining_attrs)`.\n-    fn parse_foreign_item(&mut self, attrs: Vec<Attribute>)\n-                          -> Result<P<ForeignItem>, Vec<Attribute>> {\n+    /// Parse a foreign item.\n+    fn parse_foreign_item(&mut self) -> Option<P<ForeignItem>> {\n         let lo = self.span.lo;\n \n+        let attrs = self.parse_outer_attributes();\n         let visibility = self.parse_visibility();\n \n         if self.check_keyword(keywords::Static) {\n             // FOREIGN STATIC ITEM\n-            return Ok(self.parse_item_foreign_static(visibility, attrs));\n+            return Some(self.parse_item_foreign_static(visibility, attrs));\n         }\n         if self.check_keyword(keywords::Fn) || self.check_keyword(keywords::Unsafe) {\n             // FOREIGN FUNCTION ITEM\n-            return Ok(self.parse_item_foreign_fn(visibility, attrs));\n+            return Some(self.parse_item_foreign_fn(visibility, attrs));\n         }\n \n         // FIXME #5668: this will occur for a macro invocation:\n-        let item = try!(self.parse_macro_use_or_failure(attrs, true, lo, visibility));\n-        self.span_fatal(item.span, \"macros cannot expand to foreign items\");\n+        match self.parse_macro_use_or_failure(attrs, true, lo, visibility) {\n+            Some(item) => {\n+                self.span_fatal(item.span, \"macros cannot expand to foreign items\");\n+            }\n+            None => None\n+        }\n     }\n \n     /// This is the fall-through for parsing items.\n@@ -5872,7 +5738,7 @@ impl<'a> Parser<'a> {\n         macros_allowed: bool,\n         lo: BytePos,\n         visibility: Visibility\n-    ) -> MaybeItem {\n+    ) -> Option<P<Item>> {\n         if macros_allowed && !self.token.is_any_keyword()\n                 && self.look_ahead(1, |t| *t == token::Not)\n                 && (self.look_ahead(2, |t| t.is_plain_ident())\n@@ -5924,7 +5790,7 @@ impl<'a> Parser<'a> {\n                                     item_,\n                                     visibility,\n                                     attrs);\n-            return Ok(item);\n+            return Some(item);\n         }\n \n         // FAILURE TO PARSE ITEM\n@@ -5935,16 +5801,22 @@ impl<'a> Parser<'a> {\n                 self.span_fatal(last_span, \"unmatched visibility `pub`\");\n             }\n         }\n-        Err(attrs)\n+\n+        if !attrs.is_empty() {\n+            self.expected_item_err(&attrs);\n+        }\n+        None\n     }\n \n+    // HACK(eddyb) staging required for `quote_item!`.\n+    #[cfg(stage0)] // SNAP 270a677\n     pub fn parse_item_with_outer_attributes(&mut self) -> Option<P<Item>> {\n-        let attrs = self.parse_outer_attributes();\n-        self.parse_item(attrs)\n+        self.parse_item()\n     }\n \n-    pub fn parse_item(&mut self, attrs: Vec<Attribute>) -> Option<P<Item>> {\n-        self.parse_item_(attrs, true).ok()\n+    pub fn parse_item(&mut self) -> Option<P<Item>> {\n+        let attrs = self.parse_outer_attributes();\n+        self.parse_item_(attrs, true)\n     }\n \n     /// Matches view_path : MOD? non_global_path as IDENT\n@@ -6050,52 +5922,13 @@ impl<'a> Parser<'a> {\n         P(spanned(lo, self.last_span.hi, ViewPathSimple(rename_to, path)))\n     }\n \n-    /// Parses a sequence of foreign items. Stops when it finds program\n-    /// text that can't be parsed as an item\n-    fn parse_foreign_items(&mut self, first_item_attrs: Vec<Attribute>)\n-                           -> Vec<P<ForeignItem>> {\n-        let mut attrs = first_item_attrs;\n-        attrs.push_all(&self.parse_outer_attributes());\n-        let mut foreign_items = Vec::new();\n-        loop {\n-            match self.parse_foreign_item(attrs) {\n-                Ok(foreign_item) => {\n-                    foreign_items.push(foreign_item);\n-                }\n-                Err(returned_attrs) => {\n-                    if self.check(&token::CloseDelim(token::Brace)) {\n-                        attrs = returned_attrs;\n-                        break\n-                    }\n-                    self.unexpected();\n-                }\n-            }\n-            attrs = self.parse_outer_attributes();\n-        }\n-\n-        if !attrs.is_empty() {\n-            let last_span = self.last_span;\n-            self.span_err(last_span,\n-                          Parser::expected_item_err(&attrs[..]));\n-        }\n-\n-        foreign_items\n-    }\n-\n     /// Parses a source module as a crate. This is the main\n     /// entry point for the parser.\n     pub fn parse_crate_mod(&mut self) -> Crate {\n         let lo = self.span.lo;\n-        // parse the crate's inner attrs, maybe (oops) one\n-        // of the attrs of an item:\n-        let (inner, next) = self.parse_inner_attrs_and_next();\n-        let first_item_outer_attrs = next;\n-        // parse the items inside the crate:\n-        let m = self.parse_mod_items(token::Eof, first_item_outer_attrs, lo);\n-\n         ast::Crate {\n-            module: m,\n-            attrs: inner,\n+            attrs: self.parse_inner_attributes(),\n+            module: self.parse_mod_items(&token::Eof, lo),\n             config: self.cfg.clone(),\n             span: mk_sp(lo, self.span.lo),\n             exported_macros: Vec::new(),"}, {"sha": "9b570c2b1fe2993643f7d9173efe36a590ef1553", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92dd995e1705a8c398a5266c8483e2519e494f47/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92dd995e1705a8c398a5266c8483e2519e494f47/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=92dd995e1705a8c398a5266c8483e2519e494f47", "patch": "@@ -58,14 +58,14 @@ pub fn string_to_expr (source_str : String) -> P<ast::Expr> {\n /// Parse a string, return an item\n pub fn string_to_item (source_str : String) -> Option<P<ast::Item>> {\n     with_error_checking_parse(source_str, |p| {\n-        p.parse_item(Vec::new())\n+        p.parse_item()\n     })\n }\n \n /// Parse a string, return a stmt\n pub fn string_to_stmt(source_str : String) -> P<ast::Stmt> {\n     with_error_checking_parse(source_str, |p| {\n-        p.parse_stmt(Vec::new())\n+        p.parse_stmt().unwrap()\n     })\n }\n "}, {"sha": "a00ded61758c28d8c4673ac6c6512604a3203ce9", "filename": "src/test/parse-fail/column-offset-1-based.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92dd995e1705a8c398a5266c8483e2519e494f47/src%2Ftest%2Fparse-fail%2Fcolumn-offset-1-based.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92dd995e1705a8c398a5266c8483e2519e494f47/src%2Ftest%2Fparse-fail%2Fcolumn-offset-1-based.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fcolumn-offset-1-based.rs?ref=92dd995e1705a8c398a5266c8483e2519e494f47", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-# //~ ERROR 11:1: 11:2 error: expected one of `!` or `[`, found `<eof>`\n+# //~ ERROR 11:1: 11:2 error: expected `[`, found `<eof>`"}, {"sha": "6bdcf5c5edced68d52077d9f5a3c5138e091a283", "filename": "src/test/parse-fail/issue-1655.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92dd995e1705a8c398a5266c8483e2519e494f47/src%2Ftest%2Fparse-fail%2Fissue-1655.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92dd995e1705a8c398a5266c8483e2519e494f47/src%2Ftest%2Fparse-fail%2Fissue-1655.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-1655.rs?ref=92dd995e1705a8c398a5266c8483e2519e494f47", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:expected one of `!` or `[`, found `vec`\n+// error-pattern:expected `[`, found `vec`\n mod blade_runner {\n     #vec[doc(\n         brief = \"Blade Runner is probably the best movie ever\","}, {"sha": "020f5f562d2c3cd8cd83d62adf1a6e9b3fd58bcd", "filename": "src/test/run-pass-fulldeps/quote-tokens.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92dd995e1705a8c398a5266c8483e2519e494f47/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92dd995e1705a8c398a5266c8483e2519e494f47/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs?ref=92dd995e1705a8c398a5266c8483e2519e494f47", "patch": "@@ -25,7 +25,7 @@ fn syntax_extension(cx: &ExtCtxt) {\n     let a: P<syntax::ast::Expr> = quote_expr!(cx, 1 + 2);\n     let _b: Option<P<syntax::ast::Item>> = quote_item!(cx, static foo : int = $e_toks; );\n     let _c: P<syntax::ast::Pat> = quote_pat!(cx, (x, 1 .. 4, *) );\n-    let _d: P<syntax::ast::Stmt> = quote_stmt!(cx, let x = $a; );\n+    let _d: Option<P<syntax::ast::Stmt>> = quote_stmt!(cx, let x = $a; );\n     let _d: syntax::ast::Arm = quote_arm!(cx, (ref x, ref y) = (x, y) );\n     let _e: P<syntax::ast::Expr> = quote_expr!(cx, match foo { $p_toks => 10 } );\n "}]}