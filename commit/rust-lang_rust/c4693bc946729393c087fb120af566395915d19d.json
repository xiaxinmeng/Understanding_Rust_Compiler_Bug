{"sha": "c4693bc946729393c087fb120af566395915d19d", "node_id": "C_kwDOAAsO6NoAKGM0NjkzYmM5NDY3MjkzOTNjMDg3ZmIxMjBhZjU2NjM5NTkxNWQxOWQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-09T07:15:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-09T07:15:34Z"}, "message": "Auto merge of #99078 - Dylan-DPC:rollup-gnw6cli, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #98350 (Implement support for DWARF version 5.)\n - #98915 (Clarify deriving code)\n - #98980 (fix ICE in ConstProp)\n - #99008 (Adding suggestion for E0530)\n - #99043 (Collapse some weirdly-wrapping derives)\n - #99048 (Remove a string comparison about types)\n - #99070 (Update integer_atomics tracking issue)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "0dc46b256ad172db46c41010ea7765eef37bded0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0dc46b256ad172db46c41010ea7765eef37bded0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4693bc946729393c087fb120af566395915d19d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4693bc946729393c087fb120af566395915d19d", "html_url": "https://github.com/rust-lang/rust/commit/c4693bc946729393c087fb120af566395915d19d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4693bc946729393c087fb120af566395915d19d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86b8dd5389cd9d545418a60902222a4ba859365f", "url": "https://api.github.com/repos/rust-lang/rust/commits/86b8dd5389cd9d545418a60902222a4ba859365f", "html_url": "https://github.com/rust-lang/rust/commit/86b8dd5389cd9d545418a60902222a4ba859365f"}, {"sha": "3c35da224b36855ea7bd21ed4537eb7b377de082", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c35da224b36855ea7bd21ed4537eb7b377de082", "html_url": "https://github.com/rust-lang/rust/commit/3c35da224b36855ea7bd21ed4537eb7b377de082"}], "stats": {"total": 1428, "additions": 678, "deletions": 750}, "files": [{"sha": "9cd72ed0c67b272289b1d3ba3bccc6c0aa98e66f", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -80,7 +80,7 @@ pub fn expand_deriving_clone(\n             name: sym::clone,\n             generics: Bounds::empty(),\n             explicit_self: true,\n-            args: Vec::new(),\n+            nonself_args: Vec::new(),\n             ret_ty: Self_,\n             attributes: attrs,\n             unify_fieldless_variants: false,\n@@ -160,8 +160,8 @@ fn cs_clone(\n     let ctor_path;\n     let all_fields;\n     let fn_path = cx.std_path(&[sym::clone, sym::Clone, sym::clone]);\n-    let subcall = |cx: &mut ExtCtxt<'_>, field: &FieldInfo<'_>| {\n-        let args = vec![cx.expr_addr_of(field.span, field.self_.clone())];\n+    let subcall = |cx: &mut ExtCtxt<'_>, field: &FieldInfo| {\n+        let args = vec![cx.expr_addr_of(field.span, field.self_expr.clone())];\n         cx.expr_call_global(field.span, fn_path.clone(), args)\n     };\n "}, {"sha": "4e798bf6acb108ea90b37332ae105f77d6c5357a", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -32,7 +32,7 @@ pub fn expand_deriving_eq(\n             name: sym::assert_receiver_is_total_eq,\n             generics: Bounds::empty(),\n             explicit_self: true,\n-            args: vec![],\n+            nonself_args: vec![],\n             ret_ty: Unit,\n             attributes: attrs,\n             unify_fieldless_variants: true,"}, {"sha": "859e995356e804e8f1ff6c13dccf44ebdf1f228c", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/ord.rs", "status": "modified", "additions": 36, "deletions": 67, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -2,8 +2,7 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::path_std;\n \n-use rustc_ast::ptr::P;\n-use rustc_ast::{self as ast, MetaItem};\n+use rustc_ast::MetaItem;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n@@ -28,7 +27,7 @@ pub fn expand_deriving_ord(\n             name: sym::cmp,\n             generics: Bounds::empty(),\n             explicit_self: true,\n-            args: vec![(self_ref(), sym::other)],\n+            nonself_args: vec![(self_ref(), sym::other)],\n             ret_ty: Path(path_std!(cmp::Ordering)),\n             attributes: attrs,\n             unify_fieldless_variants: true,\n@@ -40,84 +39,54 @@ pub fn expand_deriving_ord(\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-pub fn ordering_collapsed(\n-    cx: &mut ExtCtxt<'_>,\n-    span: Span,\n-    self_arg_tags: &[Ident],\n-) -> P<ast::Expr> {\n-    let lft = cx.expr_addr_of(span, cx.expr_ident(span, self_arg_tags[0]));\n-    let rgt = cx.expr_addr_of(span, cx.expr_ident(span, self_arg_tags[1]));\n-    let fn_cmp_path = cx.std_path(&[sym::cmp, sym::Ord, sym::cmp]);\n-    cx.expr_call_global(span, fn_cmp_path, vec![lft, rgt])\n-}\n-\n pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> BlockOrExpr {\n     let test_id = Ident::new(sym::cmp, span);\n-    let equals_path = cx.path_global(span, cx.std_path(&[sym::cmp, sym::Ordering, sym::Equal]));\n-\n+    let equal_path = cx.path_global(span, cx.std_path(&[sym::cmp, sym::Ordering, sym::Equal]));\n     let cmp_path = cx.std_path(&[sym::cmp, sym::Ord, sym::cmp]);\n \n     // Builds:\n     //\n-    // match ::std::cmp::Ord::cmp(&self_field1, &other_field1) {\n-    // ::std::cmp::Ordering::Equal =>\n-    // match ::std::cmp::Ord::cmp(&self_field2, &other_field2) {\n-    // ::std::cmp::Ordering::Equal => {\n-    // ...\n+    // match ::core::cmp::Ord::cmp(&self.x, &other.x) {\n+    //     ::std::cmp::Ordering::Equal =>\n+    //         ::core::cmp::Ord::cmp(&self.y, &other.y),\n+    //     cmp => cmp,\n     // }\n-    // cmp => cmp\n-    // },\n-    // cmp => cmp\n-    // }\n-    //\n     let expr = cs_fold(\n         // foldr nests the if-elses correctly, leaving the first field\n         // as the outermost one, and the last as the innermost.\n         false,\n-        |cx, span, old, self_f, other_fs| {\n-            // match new {\n-            //     ::std::cmp::Ordering::Equal => old,\n-            //     cmp => cmp\n-            // }\n-            let new = {\n-                let [other_f] = other_fs else {\n-                    cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\");\n-                };\n-                let args =\n-                    vec![cx.expr_addr_of(span, self_f), cx.expr_addr_of(span, other_f.clone())];\n-                cx.expr_call_global(span, cmp_path.clone(), args)\n-            };\n-\n-            let eq_arm = cx.arm(span, cx.pat_path(span, equals_path.clone()), old);\n-            let neq_arm = cx.arm(span, cx.pat_ident(span, test_id), cx.expr_ident(span, test_id));\n-\n-            cx.expr_match(span, new, vec![eq_arm, neq_arm])\n-        },\n-        |cx, args| match args {\n-            Some((span, self_f, other_fs)) => {\n-                let new = {\n-                    let [other_f] = other_fs else {\n-                            cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\");\n-                        };\n-                    let args =\n-                        vec![cx.expr_addr_of(span, self_f), cx.expr_addr_of(span, other_f.clone())];\n-                    cx.expr_call_global(span, cmp_path.clone(), args)\n-                };\n-\n-                new\n-            }\n-            None => cx.expr_path(equals_path.clone()),\n-        },\n-        Box::new(|cx, span, tag_tuple| {\n-            if tag_tuple.len() != 2 {\n-                cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\")\n-            } else {\n-                ordering_collapsed(cx, span, tag_tuple)\n-            }\n-        }),\n         cx,\n         span,\n         substr,\n+        |cx, fold| match fold {\n+            CsFold::Single(field) => {\n+                let [other_expr] = &field.other_selflike_exprs[..] else {\n+                        cx.span_bug(field.span, \"not exactly 2 arguments in `derive(Ord)`\");\n+                    };\n+                let args = vec![\n+                    cx.expr_addr_of(field.span, field.self_expr.clone()),\n+                    cx.expr_addr_of(field.span, other_expr.clone()),\n+                ];\n+                cx.expr_call_global(field.span, cmp_path.clone(), args)\n+            }\n+            CsFold::Combine(span, expr1, expr2) => {\n+                let eq_arm = cx.arm(span, cx.pat_path(span, equal_path.clone()), expr1);\n+                let neq_arm =\n+                    cx.arm(span, cx.pat_ident(span, test_id), cx.expr_ident(span, test_id));\n+                cx.expr_match(span, expr2, vec![eq_arm, neq_arm])\n+            }\n+            CsFold::Fieldless => cx.expr_path(equal_path.clone()),\n+            CsFold::EnumNonMatching(span, tag_tuple) => {\n+                if tag_tuple.len() != 2 {\n+                    cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\")\n+                } else {\n+                    let lft = cx.expr_addr_of(span, cx.expr_ident(span, tag_tuple[0]));\n+                    let rgt = cx.expr_addr_of(span, cx.expr_ident(span, tag_tuple[1]));\n+                    let fn_cmp_path = cx.std_path(&[sym::cmp, sym::Ord, sym::cmp]);\n+                    cx.expr_call_global(span, fn_cmp_path, vec![lft, rgt])\n+                }\n+            }\n+        },\n     );\n     BlockOrExpr::new_expr(expr)\n }"}, {"sha": "724c639984cca33f8eff63d2f78e67edadc3c4b3", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 13, "deletions": 25, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -2,8 +2,7 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::{path_local, path_std};\n \n-use rustc_ast::ptr::P;\n-use rustc_ast::{BinOpKind, Expr, MetaItem};\n+use rustc_ast::{BinOpKind, MetaItem};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n@@ -23,33 +22,22 @@ pub fn expand_deriving_partial_eq(\n         combiner: BinOpKind,\n         base: bool,\n     ) -> BlockOrExpr {\n-        let op = |cx: &mut ExtCtxt<'_>, span: Span, self_f: P<Expr>, other_fs: &[P<Expr>]| {\n-            let [other_f] = other_fs else {\n-                cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialEq)`\");\n-            };\n-\n-            cx.expr_binary(span, op, self_f, other_f.clone())\n-        };\n-\n         let expr = cs_fold(\n             true, // use foldl\n-            |cx, span, subexpr, self_f, other_fs| {\n-                let eq = op(cx, span, self_f, other_fs);\n-                cx.expr_binary(span, combiner, subexpr, eq)\n-            },\n-            |cx, args| {\n-                match args {\n-                    Some((span, self_f, other_fs)) => {\n-                        // Special-case the base case to generate cleaner code.\n-                        op(cx, span, self_f, other_fs)\n-                    }\n-                    None => cx.expr_bool(span, base),\n-                }\n-            },\n-            Box::new(|cx, span, _| cx.expr_bool(span, !base)),\n             cx,\n             span,\n             substr,\n+            |cx, fold| match fold {\n+                CsFold::Single(field) => {\n+                    let [other_expr] = &field.other_selflike_exprs[..] else {\n+                        cx.span_bug(field.span, \"not exactly 2 arguments in `derive(PartialEq)`\");\n+                    };\n+                    cx.expr_binary(field.span, op, field.self_expr.clone(), other_expr.clone())\n+                }\n+                CsFold::Combine(span, expr1, expr2) => cx.expr_binary(span, combiner, expr1, expr2),\n+                CsFold::Fieldless => cx.expr_bool(span, base),\n+                CsFold::EnumNonMatching(span, _tag_tuple) => cx.expr_bool(span, !base),\n+            },\n         );\n         BlockOrExpr::new_expr(expr)\n     }\n@@ -69,7 +57,7 @@ pub fn expand_deriving_partial_eq(\n                 name: $name,\n                 generics: Bounds::empty(),\n                 explicit_self: true,\n-                args: vec![(self_ref(), sym::other)],\n+                nonself_args: vec![(self_ref(), sym::other)],\n                 ret_ty: Path(path_local!(bool)),\n                 attributes: attrs,\n                 unify_fieldless_variants: true,"}, {"sha": "3f9843922dad74ebf22253acd39281198ea0fa87", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 38, "deletions": 64, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -2,8 +2,7 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::{path_std, pathvec_std};\n \n-use rustc_ast::ptr::P;\n-use rustc_ast::{Expr, MetaItem};\n+use rustc_ast::MetaItem;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n@@ -26,7 +25,7 @@ pub fn expand_deriving_partial_ord(\n         name: sym::partial_cmp,\n         generics: Bounds::empty(),\n         explicit_self: true,\n-        args: vec![(self_ref(), sym::other)],\n+        nonself_args: vec![(self_ref(), sym::other)],\n         ret_ty,\n         attributes: attrs,\n         unify_fieldless_variants: true,\n@@ -50,79 +49,54 @@ pub fn expand_deriving_partial_ord(\n \n pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> BlockOrExpr {\n     let test_id = Ident::new(sym::cmp, span);\n-    let ordering = cx.path_global(span, cx.std_path(&[sym::cmp, sym::Ordering, sym::Equal]));\n-    let ordering_expr = cx.expr_path(ordering.clone());\n-\n+    let equal_path = cx.path_global(span, cx.std_path(&[sym::cmp, sym::Ordering, sym::Equal]));\n     let partial_cmp_path = cx.std_path(&[sym::cmp, sym::PartialOrd, sym::partial_cmp]);\n \n     // Builds:\n     //\n-    // match ::std::cmp::PartialOrd::partial_cmp(&self_field1, &other_field1) {\n-    // ::std::option::Option::Some(::std::cmp::Ordering::Equal) =>\n-    // match ::std::cmp::PartialOrd::partial_cmp(&self_field2, &other_field2) {\n-    // ::std::option::Option::Some(::std::cmp::Ordering::Equal) => {\n-    // ...\n-    // }\n-    // cmp => cmp\n-    // },\n-    // cmp => cmp\n+    // match ::core::cmp::PartialOrd::partial_cmp(&self.x, &other.x) {\n+    //     ::core::option::Option::Some(::core::cmp::Ordering::Equal) =>\n+    //         ::core::cmp::PartialOrd::partial_cmp(&self.y, &other.y),\n+    //     cmp => cmp,\n     // }\n-    //\n     let expr = cs_fold(\n         // foldr nests the if-elses correctly, leaving the first field\n         // as the outermost one, and the last as the innermost.\n         false,\n-        |cx, span, old, self_f, other_fs| {\n-            // match new {\n-            //     Some(::std::cmp::Ordering::Equal) => old,\n-            //     cmp => cmp\n-            // }\n-\n-            let new = {\n-                let [other_f] = other_fs else {\n-                    cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\");\n-                };\n-\n-                let args =\n-                    vec![cx.expr_addr_of(span, self_f), cx.expr_addr_of(span, other_f.clone())];\n-\n-                cx.expr_call_global(span, partial_cmp_path.clone(), args)\n-            };\n-\n-            let eq_arm = cx.arm(span, cx.pat_some(span, cx.pat_path(span, ordering.clone())), old);\n-            let neq_arm = cx.arm(span, cx.pat_ident(span, test_id), cx.expr_ident(span, test_id));\n-\n-            cx.expr_match(span, new, vec![eq_arm, neq_arm])\n-        },\n-        |cx: &mut ExtCtxt<'_>, args: Option<(Span, P<Expr>, &[P<Expr>])>| match args {\n-            Some((span, self_f, other_fs)) => {\n-                let new = {\n-                    let [other_f] = other_fs else {\n-                            cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\");\n-                        };\n-                    let args =\n-                        vec![cx.expr_addr_of(span, self_f), cx.expr_addr_of(span, other_f.clone())];\n-                    cx.expr_call_global(span, partial_cmp_path.clone(), args)\n-                };\n-\n-                new\n-            }\n-            None => cx.expr_some(span, ordering_expr.clone()),\n-        },\n-        Box::new(|cx, span, tag_tuple| {\n-            if tag_tuple.len() != 2 {\n-                cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n-            } else {\n-                let lft = cx.expr_addr_of(span, cx.expr_ident(span, tag_tuple[0]));\n-                let rgt = cx.expr_addr_of(span, cx.expr_ident(span, tag_tuple[1]));\n-                let fn_partial_cmp_path =\n-                    cx.std_path(&[sym::cmp, sym::PartialOrd, sym::partial_cmp]);\n-                cx.expr_call_global(span, fn_partial_cmp_path, vec![lft, rgt])\n-            }\n-        }),\n         cx,\n         span,\n         substr,\n+        |cx, fold| match fold {\n+            CsFold::Single(field) => {\n+                let [other_expr] = &field.other_selflike_exprs[..] else {\n+                        cx.span_bug(field.span, \"not exactly 2 arguments in `derive(Ord)`\");\n+                    };\n+                let args = vec![\n+                    cx.expr_addr_of(field.span, field.self_expr.clone()),\n+                    cx.expr_addr_of(field.span, other_expr.clone()),\n+                ];\n+                cx.expr_call_global(field.span, partial_cmp_path.clone(), args)\n+            }\n+            CsFold::Combine(span, expr1, expr2) => {\n+                let eq_arm =\n+                    cx.arm(span, cx.pat_some(span, cx.pat_path(span, equal_path.clone())), expr1);\n+                let neq_arm =\n+                    cx.arm(span, cx.pat_ident(span, test_id), cx.expr_ident(span, test_id));\n+                cx.expr_match(span, expr2, vec![eq_arm, neq_arm])\n+            }\n+            CsFold::Fieldless => cx.expr_some(span, cx.expr_path(equal_path.clone())),\n+            CsFold::EnumNonMatching(span, tag_tuple) => {\n+                if tag_tuple.len() != 2 {\n+                    cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n+                } else {\n+                    let lft = cx.expr_addr_of(span, cx.expr_ident(span, tag_tuple[0]));\n+                    let rgt = cx.expr_addr_of(span, cx.expr_ident(span, tag_tuple[1]));\n+                    let fn_partial_cmp_path =\n+                        cx.std_path(&[sym::cmp, sym::PartialOrd, sym::partial_cmp]);\n+                    cx.expr_call_global(span, fn_partial_cmp_path, vec![lft, rgt])\n+                }\n+            }\n+        },\n     );\n     BlockOrExpr::new_expr(expr)\n }"}, {"sha": "b99198054def8a1fde8099e8b8330a32421d8f36", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -28,7 +28,7 @@ pub fn expand_deriving_debug(\n             name: sym::fmt,\n             generics: Bounds::empty(),\n             explicit_self: true,\n-            args: vec![(fmtr, sym::f)],\n+            nonself_args: vec![(fmtr, sym::f)],\n             ret_ty: Path(path_std!(fmt::Result)),\n             attributes: Vec::new(),\n             unify_fieldless_variants: false,\n@@ -53,7 +53,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n     // We want to make sure we have the ctxt set so that we can use unstable methods\n     let span = cx.with_def_site_ctxt(span);\n     let name = cx.expr_lit(span, ast::LitKind::Str(ident.name, ast::StrStyle::Cooked));\n-    let fmt = substr.nonself_args[0].clone();\n+    let fmt = substr.nonselflike_args[0].clone();\n \n     // Struct and tuples are similar enough that we use the same code for both,\n     // with some extra pieces for structs due to the field names.\n@@ -96,7 +96,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n                 args.push(name);\n             }\n             // Use double indirection to make sure this works for unsized types\n-            let field = cx.expr_addr_of(field.span, field.self_.clone());\n+            let field = cx.expr_addr_of(field.span, field.self_expr.clone());\n             let field = cx.expr_addr_of(field.span, field);\n             args.push(field);\n         }\n@@ -116,7 +116,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n             }\n \n             // Use double indirection to make sure this works for unsized types\n-            let value_ref = cx.expr_addr_of(field.span, field.self_.clone());\n+            let value_ref = cx.expr_addr_of(field.span, field.self_expr.clone());\n             value_exprs.push(cx.expr_addr_of(field.span, value_ref));\n         }\n "}, {"sha": "d688143a2a5c622e56102406b81ca1bee70b1fbe", "filename": "compiler/rustc_builtin_macros/src/deriving/decodable.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -36,7 +36,10 @@ pub fn expand_deriving_rustc_decodable(\n                 )],\n             },\n             explicit_self: false,\n-            args: vec![(Ref(Box::new(Path(Path::new_local(typaram))), Mutability::Mut), sym::d)],\n+            nonself_args: vec![(\n+                Ref(Box::new(Path(Path::new_local(typaram))), Mutability::Mut),\n+                sym::d,\n+            )],\n             ret_ty: Path(Path::new_(\n                 pathvec_std!(result::Result),\n                 vec![\n@@ -63,7 +66,7 @@ fn decodable_substructure(\n     substr: &Substructure<'_>,\n     krate: Symbol,\n ) -> BlockOrExpr {\n-    let decoder = substr.nonself_args[0].clone();\n+    let decoder = substr.nonselflike_args[0].clone();\n     let recurse = vec![\n         Ident::new(krate, trait_span),\n         Ident::new(sym::Decodable, trait_span),"}, {"sha": "5177690917f21759da87a64be8c7cbcbc889602b", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -34,7 +34,7 @@ pub fn expand_deriving_default(\n             name: kw::Default,\n             generics: Bounds::empty(),\n             explicit_self: false,\n-            args: Vec::new(),\n+            nonself_args: Vec::new(),\n             ret_ty: Self_,\n             attributes: attrs,\n             unify_fieldless_variants: false,"}, {"sha": "49dbe51f7626c720e102f5bd324f63d81e23e843", "filename": "compiler/rustc_builtin_macros/src/deriving/encodable.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -120,7 +120,10 @@ pub fn expand_deriving_rustc_encodable(\n                 )],\n             },\n             explicit_self: true,\n-            args: vec![(Ref(Box::new(Path(Path::new_local(typaram))), Mutability::Mut), sym::s)],\n+            nonself_args: vec![(\n+                Ref(Box::new(Path(Path::new_local(typaram))), Mutability::Mut),\n+                sym::s,\n+            )],\n             ret_ty: Path(Path::new_(\n                 pathvec_std!(result::Result),\n                 vec![\n@@ -147,7 +150,7 @@ fn encodable_substructure(\n     substr: &Substructure<'_>,\n     krate: Symbol,\n ) -> BlockOrExpr {\n-    let encoder = substr.nonself_args[0].clone();\n+    let encoder = substr.nonselflike_args[0].clone();\n     // throw an underscore in front to suppress unused variable warnings\n     let blkarg = Ident::new(sym::_e, trait_span);\n     let blkencoder = cx.expr_ident(trait_span, blkarg);\n@@ -165,12 +168,12 @@ fn encodable_substructure(\n             let fn_emit_struct_field_path =\n                 cx.def_site_path(&[sym::rustc_serialize, sym::Encoder, sym::emit_struct_field]);\n             let mut stmts = Vec::new();\n-            for (i, &FieldInfo { name, ref self_, span, .. }) in fields.iter().enumerate() {\n+            for (i, &FieldInfo { name, ref self_expr, span, .. }) in fields.iter().enumerate() {\n                 let name = match name {\n                     Some(id) => id.name,\n                     None => Symbol::intern(&format!(\"_field{}\", i)),\n                 };\n-                let self_ref = cx.expr_addr_of(span, self_.clone());\n+                let self_ref = cx.expr_addr_of(span, self_expr.clone());\n                 let enc = cx.expr_call(span, fn_path.clone(), vec![self_ref, blkencoder.clone()]);\n                 let lambda = cx.lambda1(span, enc, blkarg);\n                 let call = cx.expr_call_global(\n@@ -234,8 +237,8 @@ fn encodable_substructure(\n             let mut stmts = Vec::new();\n             if !fields.is_empty() {\n                 let last = fields.len() - 1;\n-                for (i, &FieldInfo { ref self_, span, .. }) in fields.iter().enumerate() {\n-                    let self_ref = cx.expr_addr_of(span, self_.clone());\n+                for (i, &FieldInfo { ref self_expr, span, .. }) in fields.iter().enumerate() {\n+                    let self_ref = cx.expr_addr_of(span, self_expr.clone());\n                     let enc =\n                         cx.expr_call(span, fn_path.clone(), vec![self_ref, blkencoder.clone()]);\n                     let lambda = cx.lambda1(span, enc, blkarg);"}, {"sha": "74e18bffc2ec982d13c15a30930dacccd889e260", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 339, "deletions": 391, "changes": 730, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -227,8 +227,8 @@ pub struct MethodDef<'a> {\n     /// Is there is a `&self` argument? If not, it is a static function.\n     pub explicit_self: bool,\n \n-    /// Arguments other than the self argument\n-    pub args: Vec<(Ty, Symbol)>,\n+    /// Arguments other than the self argument.\n+    pub nonself_args: Vec<(Ty, Symbol)>,\n \n     /// Returns type\n     pub ret_ty: Ty,\n@@ -245,25 +245,24 @@ pub struct MethodDef<'a> {\n pub struct Substructure<'a> {\n     /// ident of self\n     pub type_ident: Ident,\n-    /// verbatim access to any non-self arguments\n-    pub nonself_args: &'a [P<Expr>],\n+    /// Verbatim access to any non-selflike arguments, i.e. arguments that\n+    /// don't have type `&Self`.\n+    pub nonselflike_args: &'a [P<Expr>],\n     pub fields: &'a SubstructureFields<'a>,\n }\n \n /// Summary of the relevant parts of a struct/enum field.\n-pub struct FieldInfo<'a> {\n+pub struct FieldInfo {\n     pub span: Span,\n     /// None for tuple structs/normal enum variants, Some for normal\n     /// structs/struct enum variants.\n     pub name: Option<Ident>,\n     /// The expression corresponding to this field of `self`\n     /// (specifically, a reference to it).\n-    pub self_: P<Expr>,\n+    pub self_expr: P<Expr>,\n     /// The expressions corresponding to references to this field in\n-    /// the other `Self` arguments.\n-    pub other: Vec<P<Expr>>,\n-    /// The attributes on the field\n-    pub attrs: &'a [ast::Attribute],\n+    /// the other selflike arguments.\n+    pub other_selflike_exprs: Vec<P<Expr>>,\n }\n \n /// Fields for a static method\n@@ -276,11 +275,11 @@ pub enum StaticFields {\n \n /// A summary of the possible sets of fields.\n pub enum SubstructureFields<'a> {\n-    Struct(&'a ast::VariantData, Vec<FieldInfo<'a>>),\n+    Struct(&'a ast::VariantData, Vec<FieldInfo>),\n     /// Matching variants of the enum: variant index, variant count, ast::Variant,\n     /// fields: the field name is only non-`None` in the case of a struct\n     /// variant.\n-    EnumMatching(usize, usize, &'a ast::Variant, Vec<FieldInfo<'a>>),\n+    EnumMatching(usize, usize, &'a ast::Variant, Vec<FieldInfo>),\n \n     /// Non-matching variants of the enum, but with all state hidden from the\n     /// consequent code. The field is a list of `Ident`s bound to the variant\n@@ -298,11 +297,6 @@ pub enum SubstructureFields<'a> {\n pub type CombineSubstructureFunc<'a> =\n     Box<dyn FnMut(&mut ExtCtxt<'_>, Span, &Substructure<'_>) -> BlockOrExpr + 'a>;\n \n-/// Deal with non-matching enum variants. The slice is the identifiers holding\n-/// the variant index value for each of the `Self` arguments.\n-pub type EnumNonMatchCollapsedFunc<'a> =\n-    Box<dyn FnMut(&mut ExtCtxt<'_>, Span, &[Ident]) -> P<Expr> + 'a>;\n-\n pub fn combine_substructure(\n     f: CombineSubstructureFunc<'_>,\n ) -> RefCell<CombineSubstructureFunc<'_>> {\n@@ -782,31 +776,39 @@ impl<'a> TraitDef<'a> {\n             .methods\n             .iter()\n             .map(|method_def| {\n-                let (explicit_self, self_args, nonself_args, tys) =\n-                    method_def.split_self_nonself_args(cx, self, type_ident, generics);\n+                let (explicit_self, selflike_args, nonselflike_args, nonself_arg_tys) =\n+                    method_def.extract_arg_details(cx, self, type_ident, generics);\n \n                 let body = if from_scratch || method_def.is_static() {\n                     method_def.expand_static_struct_method_body(\n                         cx,\n                         self,\n                         struct_def,\n                         type_ident,\n-                        &nonself_args,\n+                        &nonselflike_args,\n                     )\n                 } else {\n                     method_def.expand_struct_method_body(\n                         cx,\n                         self,\n                         struct_def,\n                         type_ident,\n-                        &self_args,\n-                        &nonself_args,\n+                        &selflike_args,\n+                        &nonselflike_args,\n                         use_temporaries,\n                         is_packed,\n                     )\n                 };\n \n-                method_def.create_method(cx, self, type_ident, generics, explicit_self, tys, body)\n+                method_def.create_method(\n+                    cx,\n+                    self,\n+                    type_ident,\n+                    generics,\n+                    explicit_self,\n+                    nonself_arg_tys,\n+                    body,\n+                )\n             })\n             .collect();\n \n@@ -831,29 +833,37 @@ impl<'a> TraitDef<'a> {\n             .methods\n             .iter()\n             .map(|method_def| {\n-                let (explicit_self, self_args, nonself_args, tys) =\n-                    method_def.split_self_nonself_args(cx, self, type_ident, generics);\n+                let (explicit_self, selflike_args, nonselflike_args, nonself_arg_tys) =\n+                    method_def.extract_arg_details(cx, self, type_ident, generics);\n \n                 let body = if from_scratch || method_def.is_static() {\n                     method_def.expand_static_enum_method_body(\n                         cx,\n                         self,\n                         enum_def,\n                         type_ident,\n-                        &nonself_args,\n+                        &nonselflike_args,\n                     )\n                 } else {\n                     method_def.expand_enum_method_body(\n                         cx,\n                         self,\n                         enum_def,\n                         type_ident,\n-                        self_args,\n-                        &nonself_args,\n+                        selflike_args,\n+                        &nonselflike_args,\n                     )\n                 };\n \n-                method_def.create_method(cx, self, type_ident, generics, explicit_self, tys, body)\n+                method_def.create_method(\n+                    cx,\n+                    self,\n+                    type_ident,\n+                    generics,\n+                    explicit_self,\n+                    nonself_arg_tys,\n+                    body,\n+                )\n             })\n             .collect();\n \n@@ -867,11 +877,11 @@ impl<'a> MethodDef<'a> {\n         cx: &mut ExtCtxt<'_>,\n         trait_: &TraitDef<'_>,\n         type_ident: Ident,\n-        nonself_args: &[P<Expr>],\n+        nonselflike_args: &[P<Expr>],\n         fields: &SubstructureFields<'_>,\n     ) -> BlockOrExpr {\n         let span = trait_.span;\n-        let substructure = Substructure { type_ident, nonself_args, fields };\n+        let substructure = Substructure { type_ident, nonselflike_args, fields };\n         let mut f = self.combine_substructure.borrow_mut();\n         let f: &mut CombineSubstructureFunc<'_> = &mut *f;\n         f(cx, span, &substructure)\n@@ -891,49 +901,51 @@ impl<'a> MethodDef<'a> {\n         !self.explicit_self\n     }\n \n-    fn split_self_nonself_args(\n+    // The return value includes:\n+    // - explicit_self: The `&self` arg, if present.\n+    // - selflike_args: Expressions for `&self` (if present) and also any other\n+    //   args with the same type (e.g. the `other` arg in `PartialEq::eq`).\n+    // - nonselflike_args: Expressions for all the remaining args.\n+    // - nonself_arg_tys: Additional information about all the args other than\n+    //   `&self`.\n+    fn extract_arg_details(\n         &self,\n         cx: &mut ExtCtxt<'_>,\n         trait_: &TraitDef<'_>,\n         type_ident: Ident,\n         generics: &Generics,\n     ) -> (Option<ast::ExplicitSelf>, Vec<P<Expr>>, Vec<P<Expr>>, Vec<(Ident, P<ast::Ty>)>) {\n-        let mut self_args = Vec::new();\n-        let mut nonself_args = Vec::new();\n-        let mut arg_tys = Vec::new();\n+        let mut selflike_args = Vec::new();\n+        let mut nonselflike_args = Vec::new();\n+        let mut nonself_arg_tys = Vec::new();\n         let span = trait_.span;\n \n-        let ast_explicit_self = if self.explicit_self {\n+        let explicit_self = if self.explicit_self {\n             let (self_expr, explicit_self) = ty::get_explicit_self(cx, span);\n-            self_args.push(self_expr);\n+            selflike_args.push(self_expr);\n             Some(explicit_self)\n         } else {\n             None\n         };\n \n-        for (ty, name) in self.args.iter() {\n+        for (ty, name) in self.nonself_args.iter() {\n             let ast_ty = ty.to_ty(cx, span, type_ident, generics);\n             let ident = Ident::new(*name, span);\n-            arg_tys.push((ident, ast_ty));\n+            nonself_arg_tys.push((ident, ast_ty));\n \n             let arg_expr = cx.expr_ident(span, ident);\n \n-            match *ty {\n-                // for static methods, just treat any Self\n-                // arguments as a normal arg\n-                Self_ if !self.is_static() => {\n-                    self_args.push(arg_expr);\n-                }\n-                Ref(ref ty, _) if matches!(**ty, Self_) && !self.is_static() => {\n-                    self_args.push(cx.expr_deref(span, arg_expr))\n-                }\n-                _ => {\n-                    nonself_args.push(arg_expr);\n+            match ty {\n+                // Selflike (`&Self`) arguments only occur in non-static methods.\n+                Ref(box Self_, _) if !self.is_static() => {\n+                    selflike_args.push(cx.expr_deref(span, arg_expr))\n                 }\n+                Self_ => cx.span_bug(span, \"`Self` in non-return position\"),\n+                _ => nonselflike_args.push(arg_expr),\n             }\n         }\n \n-        (ast_explicit_self, self_args, nonself_args, arg_tys)\n+        (explicit_self, selflike_args, nonselflike_args, nonself_arg_tys)\n     }\n \n     fn create_method(\n@@ -943,20 +955,21 @@ impl<'a> MethodDef<'a> {\n         type_ident: Ident,\n         generics: &Generics,\n         explicit_self: Option<ast::ExplicitSelf>,\n-        arg_types: Vec<(Ident, P<ast::Ty>)>,\n+        nonself_arg_tys: Vec<(Ident, P<ast::Ty>)>,\n         body: BlockOrExpr,\n     ) -> P<ast::AssocItem> {\n         let span = trait_.span;\n         // Create the generics that aren't for `Self`.\n         let fn_generics = self.generics.to_generics(cx, span, type_ident, generics);\n \n         let args = {\n-            let self_args = explicit_self.map(|explicit_self| {\n+            let self_arg = explicit_self.map(|explicit_self| {\n                 let ident = Ident::with_dummy_span(kw::SelfLower).with_span_pos(span);\n                 ast::Param::from_self(ast::AttrVec::default(), explicit_self, ident)\n             });\n-            let nonself_args = arg_types.into_iter().map(|(name, ty)| cx.param(span, name, ty));\n-            self_args.into_iter().chain(nonself_args).collect()\n+            let nonself_args =\n+                nonself_arg_tys.into_iter().map(|(name, ty)| cx.param(span, name, ty));\n+            self_arg.into_iter().chain(nonself_args).collect()\n         };\n \n         let ret_type = self.get_ret_ty(cx, trait_, generics, type_ident);\n@@ -1024,76 +1037,50 @@ impl<'a> MethodDef<'a> {\n         trait_: &TraitDef<'b>,\n         struct_def: &'b VariantData,\n         type_ident: Ident,\n-        self_args: &[P<Expr>],\n-        nonself_args: &[P<Expr>],\n+        selflike_args: &[P<Expr>],\n+        nonselflike_args: &[P<Expr>],\n         use_temporaries: bool,\n         is_packed: bool,\n     ) -> BlockOrExpr {\n-        let mut raw_fields = Vec::new(); // Vec<[fields of self], [fields of next Self arg], [etc]>\n         let span = trait_.span;\n-        let mut patterns = Vec::new();\n-\n-        for (i, self_arg) in self_args.iter().enumerate() {\n-            let ident_exprs = if !is_packed {\n-                trait_.create_struct_field_accesses(cx, self_arg, struct_def)\n-            } else {\n-                // Get the pattern for the let-destructuring.\n-                //\n-                // We could use `type_ident` instead of `Self`, but in the case of a type parameter\n-                // shadowing the struct name, that causes a second, unnecessary E0578 error. #97343\n-                let struct_path = cx.path(span, vec![Ident::new(kw::SelfUpper, type_ident.span)]);\n-                let (pat, ident_exprs) = trait_.create_struct_pattern(\n-                    cx,\n-                    struct_path,\n-                    struct_def,\n-                    &format!(\"__self_{}\", i),\n-                    ast::Mutability::Not,\n-                    use_temporaries,\n-                );\n-                patterns.push(pat);\n-                ident_exprs\n-            };\n-            raw_fields.push(ident_exprs);\n-        }\n-\n-        // transpose raw_fields\n-        let fields = if !raw_fields.is_empty() {\n-            let mut raw_fields = raw_fields.into_iter().map(|v| v.into_iter());\n-            let first_field = raw_fields.next().unwrap();\n-            let mut other_fields: Vec<vec::IntoIter<_>> = raw_fields.collect();\n-            first_field\n-                .map(|(span, opt_id, field, attrs)| FieldInfo {\n-                    span: span.with_ctxt(trait_.span.ctxt()),\n-                    name: opt_id,\n-                    self_: field,\n-                    other: other_fields\n-                        .iter_mut()\n-                        .map(|l| {\n-                            let (.., ex, _) = l.next().unwrap();\n-                            ex\n-                        })\n-                        .collect(),\n-                    attrs,\n-                })\n-                .collect()\n-        } else {\n-            cx.span_bug(span, \"no `self` parameter for method in generic `derive`\")\n+        assert!(selflike_args.len() == 1 || selflike_args.len() == 2);\n+\n+        let mk_body = |cx, selflike_fields| {\n+            self.call_substructure_method(\n+                cx,\n+                trait_,\n+                type_ident,\n+                nonselflike_args,\n+                &Struct(struct_def, selflike_fields),\n+            )\n         };\n \n-        let mut body = self.call_substructure_method(\n-            cx,\n-            trait_,\n-            type_ident,\n-            nonself_args,\n-            &Struct(struct_def, fields),\n-        );\n-\n         if !is_packed {\n-            body\n+            let selflike_fields =\n+                trait_.create_struct_field_access_fields(cx, selflike_args, struct_def);\n+            mk_body(cx, selflike_fields)\n         } else {\n+            let prefixes: Vec<_> =\n+                (0..selflike_args.len()).map(|i| format!(\"__self_{}\", i)).collect();\n+            let selflike_fields =\n+                trait_.create_struct_pattern_fields(cx, struct_def, &prefixes, use_temporaries);\n+            let mut body = mk_body(cx, selflike_fields);\n+\n+            let struct_path = cx.path(span, vec![Ident::new(kw::SelfUpper, type_ident.span)]);\n+            let patterns = trait_.create_struct_patterns(\n+                cx,\n+                struct_path,\n+                struct_def,\n+                &prefixes,\n+                ast::Mutability::Not,\n+                use_temporaries,\n+            );\n+\n             // Do the let-destructuring.\n-            let mut stmts: Vec<_> = iter::zip(self_args, patterns)\n-                .map(|(arg_expr, pat)| cx.stmt_let_pat(span, pat, arg_expr.clone()))\n+            let mut stmts: Vec<_> = iter::zip(selflike_args, patterns)\n+                .map(|(selflike_arg_expr, pat)| {\n+                    cx.stmt_let_pat(span, pat, selflike_arg_expr.clone())\n+                })\n                 .collect();\n             stmts.extend(std::mem::take(&mut body.0));\n             BlockOrExpr(stmts, body.1)\n@@ -1106,15 +1093,15 @@ impl<'a> MethodDef<'a> {\n         trait_: &TraitDef<'_>,\n         struct_def: &VariantData,\n         type_ident: Ident,\n-        nonself_args: &[P<Expr>],\n+        nonselflike_args: &[P<Expr>],\n     ) -> BlockOrExpr {\n         let summary = trait_.summarise_struct(cx, struct_def);\n \n         self.call_substructure_method(\n             cx,\n             trait_,\n             type_ident,\n-            nonself_args,\n+            nonselflike_args,\n             &StaticStruct(struct_def, summary),\n         )\n     }\n@@ -1148,7 +1135,7 @@ impl<'a> MethodDef<'a> {\n     ///     }\n     /// }\n     /// ```\n-    /// Creates a match for a tuple of all `self_args`, where either all\n+    /// Creates a match for a tuple of all `selflike_args`, where either all\n     /// variants match, or it falls into a catch-all for when one variant\n     /// does not match.\n     ///\n@@ -1161,33 +1148,33 @@ impl<'a> MethodDef<'a> {\n     /// a simple equality check (for PartialEq).\n     ///\n     /// The catch-all handler is provided access the variant index values\n-    /// for each of the self-args, carried in precomputed variables.\n+    /// for each of the selflike_args, carried in precomputed variables.\n     fn expand_enum_method_body<'b>(\n         &self,\n         cx: &mut ExtCtxt<'_>,\n         trait_: &TraitDef<'b>,\n         enum_def: &'b EnumDef,\n         type_ident: Ident,\n-        mut self_args: Vec<P<Expr>>,\n-        nonself_args: &[P<Expr>],\n+        mut selflike_args: Vec<P<Expr>>,\n+        nonselflike_args: &[P<Expr>],\n     ) -> BlockOrExpr {\n         let span = trait_.span;\n         let variants = &enum_def.variants;\n \n-        let self_arg_names = iter::once(\"__self\".to_string())\n+        let prefixes = iter::once(\"__self\".to_string())\n             .chain(\n-                self_args\n+                selflike_args\n                     .iter()\n                     .enumerate()\n                     .skip(1)\n-                    .map(|(arg_count, _self_arg)| format!(\"__arg_{}\", arg_count)),\n+                    .map(|(arg_count, _selflike_arg)| format!(\"__arg_{}\", arg_count)),\n             )\n             .collect::<Vec<String>>();\n \n         // The `vi_idents` will be bound, solely in the catch-all, to\n-        // a series of let statements mapping each self_arg to an int\n+        // a series of let statements mapping each selflike_arg to an int\n         // value corresponding to its discriminant.\n-        let vi_idents = self_arg_names\n+        let vi_idents = prefixes\n             .iter()\n             .map(|name| {\n                 let vi_suffix = format!(\"{}_vi\", name);\n@@ -1206,37 +1193,38 @@ impl<'a> MethodDef<'a> {\n         // (Variant1, Variant1, ...) => Body1\n         // (Variant2, Variant2, ...) => Body2\n         // ...\n-        // where each tuple has length = self_args.len()\n+        // where each tuple has length = selflike_args.len()\n+\n         let mut match_arms: Vec<ast::Arm> = variants\n             .iter()\n             .enumerate()\n             .filter(|&(_, v)| !(self.unify_fieldless_variants && v.data.fields().is_empty()))\n             .map(|(index, variant)| {\n-                let mk_self_pat = |cx: &mut ExtCtxt<'_>, self_arg_name: &str| {\n-                    let (p, idents) = trait_.create_enum_variant_pattern(\n-                        cx,\n-                        type_ident,\n-                        variant,\n-                        self_arg_name,\n-                        ast::Mutability::Not,\n-                    );\n-                    (cx.pat(span, PatKind::Ref(p, ast::Mutability::Not)), idents)\n-                };\n-\n                 // A single arm has form (&VariantK, &VariantK, ...) => BodyK\n                 // (see \"Final wrinkle\" note below for why.)\n-                let mut subpats = Vec::with_capacity(self_arg_names.len());\n-                let mut self_pats_idents = Vec::with_capacity(self_arg_names.len() - 1);\n-                let first_self_pat_idents = {\n-                    let (p, idents) = mk_self_pat(cx, &self_arg_names[0]);\n-                    subpats.push(p);\n-                    idents\n-                };\n-                for self_arg_name in &self_arg_names[1..] {\n-                    let (p, idents) = mk_self_pat(cx, &self_arg_name);\n-                    subpats.push(p);\n-                    self_pats_idents.push(idents);\n-                }\n+\n+                let use_temporaries = false; // enums can't be repr(packed)\n+                let fields = trait_.create_struct_pattern_fields(\n+                    cx,\n+                    &variant.data,\n+                    &prefixes,\n+                    use_temporaries,\n+                );\n+\n+                let sp = variant.span.with_ctxt(trait_.span.ctxt());\n+                let variant_path = cx.path(sp, vec![type_ident, variant.ident]);\n+                let mut subpats: Vec<_> = trait_\n+                    .create_struct_patterns(\n+                        cx,\n+                        variant_path,\n+                        &variant.data,\n+                        &prefixes,\n+                        ast::Mutability::Not,\n+                        use_temporaries,\n+                    )\n+                    .into_iter()\n+                    .map(|p| cx.pat(span, PatKind::Ref(p, ast::Mutability::Not)))\n+                    .collect();\n \n                 // Here is the pat = `(&VariantK, &VariantK, ...)`\n                 let single_pat = if subpats.len() == 1 {\n@@ -1248,57 +1236,20 @@ impl<'a> MethodDef<'a> {\n                 // For the BodyK, we need to delegate to our caller,\n                 // passing it an EnumMatching to indicate which case\n                 // we are in.\n-\n-                // All of the Self args have the same variant in these\n-                // cases.  So we transpose the info in self_pats_idents\n-                // to gather the getter expressions together, in the\n-                // form that EnumMatching expects.\n-\n-                // The transposition is driven by walking across the\n-                // arg fields of the variant for the first self pat.\n-                let field_tuples = first_self_pat_idents\n-                    .into_iter()\n-                    .enumerate()\n-                    // For each arg field of self, pull out its getter expr ...\n-                    .map(|(field_index, (span, opt_ident, self_getter_expr, attrs))| {\n-                        // ... but FieldInfo also wants getter expr\n-                        // for matching other arguments of Self type;\n-                        // so walk across the *other* self_pats_idents\n-                        // and pull out getter for same field in each\n-                        // of them (using `field_index` tracked above).\n-                        // That is the heart of the transposition.\n-                        let others = self_pats_idents\n-                            .iter()\n-                            .map(|fields| {\n-                                let (_, _opt_ident, ref other_getter_expr, _) = fields[field_index];\n-\n-                                // All Self args have same variant, so\n-                                // opt_idents are the same.  (Assert\n-                                // here to make it self-evident that\n-                                // it is okay to ignore `_opt_ident`.)\n-                                assert!(opt_ident == _opt_ident);\n-\n-                                other_getter_expr.clone()\n-                            })\n-                            .collect::<Vec<P<Expr>>>();\n-\n-                        FieldInfo {\n-                            span,\n-                            name: opt_ident,\n-                            self_: self_getter_expr,\n-                            other: others,\n-                            attrs,\n-                        }\n-                    })\n-                    .collect::<Vec<FieldInfo<'_>>>();\n-\n+                //\n                 // Now, for some given VariantK, we have built up\n                 // expressions for referencing every field of every\n                 // Self arg, assuming all are instances of VariantK.\n                 // Build up code associated with such a case.\n-                let substructure = EnumMatching(index, variants.len(), variant, field_tuples);\n+                let substructure = EnumMatching(index, variants.len(), variant, fields);\n                 let arm_expr = self\n-                    .call_substructure_method(cx, trait_, type_ident, nonself_args, &substructure)\n+                    .call_substructure_method(\n+                        cx,\n+                        trait_,\n+                        type_ident,\n+                        nonselflike_args,\n+                        &substructure,\n+                    )\n                     .into_expr(cx, span);\n \n                 cx.arm(span, single_pat, arm_expr)\n@@ -1316,13 +1267,13 @@ impl<'a> MethodDef<'a> {\n                         cx,\n                         trait_,\n                         type_ident,\n-                        nonself_args,\n+                        nonselflike_args,\n                         &substructure,\n                     )\n                     .into_expr(cx, span),\n                 )\n             }\n-            _ if variants.len() > 1 && self_args.len() > 1 => {\n+            _ if variants.len() > 1 && selflike_args.len() > 1 => {\n                 // Since we know that all the arguments will match if we reach\n                 // the match expression we add the unreachable intrinsics as the\n                 // result of the catch all which should help llvm in optimizing it\n@@ -1349,8 +1300,8 @@ impl<'a> MethodDef<'a> {\n         //   catch-all `_` match, it would trigger the\n         //   unreachable-pattern error.\n         //\n-        if variants.len() > 1 && self_args.len() > 1 {\n-            // Build a series of let statements mapping each self_arg\n+        if variants.len() > 1 && selflike_args.len() > 1 {\n+            // Build a series of let statements mapping each selflike_arg\n             // to its discriminant value.\n             //\n             // i.e., for `enum E<T> { A, B(1), C(T, T) }`, and a deriving\n@@ -1365,10 +1316,14 @@ impl<'a> MethodDef<'a> {\n             // We also build an expression which checks whether all discriminants are equal:\n             // `__self_vi == __arg_1_vi && __self_vi == __arg_2_vi && ...`\n             let mut discriminant_test = cx.expr_bool(span, true);\n-            for (i, (&ident, self_arg)) in iter::zip(&vi_idents, &self_args).enumerate() {\n-                let self_addr = cx.expr_addr_of(span, self_arg.clone());\n-                let variant_value =\n-                    deriving::call_intrinsic(cx, span, sym::discriminant_value, vec![self_addr]);\n+            for (i, (&ident, selflike_arg)) in iter::zip(&vi_idents, &selflike_args).enumerate() {\n+                let selflike_addr = cx.expr_addr_of(span, selflike_arg.clone());\n+                let variant_value = deriving::call_intrinsic(\n+                    cx,\n+                    span,\n+                    sym::discriminant_value,\n+                    vec![selflike_addr],\n+                );\n                 let let_stmt = cx.stmt_let(span, false, ident, variant_value);\n                 index_let_stmts.push(let_stmt);\n \n@@ -1389,18 +1344,18 @@ impl<'a> MethodDef<'a> {\n                     cx,\n                     trait_,\n                     type_ident,\n-                    nonself_args,\n+                    nonselflike_args,\n                     &catch_all_substructure,\n                 )\n                 .into_expr(cx, span);\n \n-            // Final wrinkle: the self_args are expressions that deref\n+            // Final wrinkle: the selflike_args are expressions that deref\n             // down to desired places, but we cannot actually deref\n             // them when they are fed as r-values into a tuple\n             // expression; here add a layer of borrowing, turning\n             // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n-            self_args.map_in_place(|self_arg| cx.expr_addr_of(span, self_arg));\n-            let match_arg = cx.expr(span, ast::ExprKind::Tup(self_args));\n+            selflike_args.map_in_place(|selflike_arg| cx.expr_addr_of(span, selflike_arg));\n+            let match_arg = cx.expr(span, ast::ExprKind::Tup(selflike_args));\n \n             // Lastly we create an expression which branches on all discriminants being equal\n             //  if discriminant_test {\n@@ -1418,67 +1373,21 @@ impl<'a> MethodDef<'a> {\n             let arm_expr = cx.expr_if(span, discriminant_test, all_match, Some(arm_expr));\n             BlockOrExpr(index_let_stmts, Some(arm_expr))\n         } else if variants.is_empty() {\n-            // As an additional wrinkle, For a zero-variant enum A,\n-            // currently the compiler\n-            // will accept `fn (a: &Self) { match   *a   { } }`\n-            // but rejects `fn (a: &Self) { match (&*a,) { } }`\n-            // as well as  `fn (a: &Self) { match ( *a,) { } }`\n-            //\n-            // This means that the strategy of building up a tuple of\n-            // all Self arguments fails when Self is a zero variant\n-            // enum: rustc rejects the expanded program, even though\n-            // the actual code tends to be impossible to execute (at\n-            // least safely), according to the type system.\n-            //\n-            // The most expedient fix for this is to just let the\n-            // code fall through to the catch-all.  But even this is\n-            // error-prone, since the catch-all as defined above would\n-            // generate code like this:\n-            //\n-            //     _ => { let __self0 = match *self { };\n-            //            let __self1 = match *__arg_0 { };\n-            //            <catch-all-expr> }\n-            //\n-            // Which is yields bindings for variables which type\n-            // inference cannot resolve to unique types.\n-            //\n-            // One option to the above might be to add explicit type\n-            // annotations.  But the *only* reason to go down that path\n-            // would be to try to make the expanded output consistent\n-            // with the case when the number of enum variants >= 1.\n-            //\n-            // That just isn't worth it.  In fact, trying to generate\n-            // sensible code for *any* deriving on a zero-variant enum\n-            // does not make sense.  But at the same time, for now, we\n-            // do not want to cause a compile failure just because the\n-            // user happened to attach a deriving to their\n-            // zero-variant enum.\n-            //\n-            // Instead, just generate a failing expression for the\n-            // zero variant case, skipping matches and also skipping\n-            // delegating back to the end user code entirely.\n-            //\n-            // (See also #4499 and #12609; note that some of the\n-            // discussions there influence what choice we make here;\n-            // e.g., if we feature-gate `match x { ... }` when x refers\n-            // to an uninhabited type (e.g., a zero-variant enum or a\n-            // type holding such an enum), but do not feature-gate\n-            // zero-variant enums themselves, then attempting to\n-            // derive Debug on such a type could here generate code\n-            // that needs the feature gate enabled.)\n-\n+            // There is no sensible code to be generated for *any* deriving on\n+            // a zero-variant enum. So we just generate a failing expression\n+            // for the zero variant case.\n             BlockOrExpr(vec![], Some(deriving::call_unreachable(cx, span)))\n         } else {\n-            // Final wrinkle: the self_args are expressions that deref\n+            // Final wrinkle: the selflike_args are expressions that deref\n             // down to desired places, but we cannot actually deref\n             // them when they are fed as r-values into a tuple\n             // expression; here add a layer of borrowing, turning\n             // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n-            self_args.map_in_place(|self_arg| cx.expr_addr_of(span, self_arg));\n-            let match_arg = if self_args.len() == 1 {\n-                self_args.pop().unwrap()\n+            selflike_args.map_in_place(|selflike_arg| cx.expr_addr_of(span, selflike_arg));\n+            let match_arg = if selflike_args.len() == 1 {\n+                selflike_args.pop().unwrap()\n             } else {\n-                cx.expr(span, ast::ExprKind::Tup(self_args))\n+                cx.expr(span, ast::ExprKind::Tup(selflike_args))\n             };\n             BlockOrExpr(vec![], Some(cx.expr_match(span, match_arg, match_arms)))\n         }\n@@ -1490,7 +1399,7 @@ impl<'a> MethodDef<'a> {\n         trait_: &TraitDef<'_>,\n         enum_def: &EnumDef,\n         type_ident: Ident,\n-        nonself_args: &[P<Expr>],\n+        nonselflike_args: &[P<Expr>],\n     ) -> BlockOrExpr {\n         let summary = enum_def\n             .variants\n@@ -1505,7 +1414,7 @@ impl<'a> MethodDef<'a> {\n             cx,\n             trait_,\n             type_ident,\n-            nonself_args,\n+            nonselflike_args,\n             &StaticEnum(enum_def, summary),\n         )\n     }\n@@ -1538,170 +1447,209 @@ impl<'a> TraitDef<'a> {\n         }\n     }\n \n-    fn create_subpatterns(\n+    fn create_struct_patterns(\n         &self,\n         cx: &mut ExtCtxt<'_>,\n-        field_paths: Vec<Ident>,\n+        struct_path: ast::Path,\n+        struct_def: &'a VariantData,\n+        prefixes: &[String],\n         mutbl: ast::Mutability,\n         use_temporaries: bool,\n     ) -> Vec<P<ast::Pat>> {\n-        field_paths\n+        prefixes\n             .iter()\n-            .map(|path| {\n-                let binding_mode = if use_temporaries {\n-                    ast::BindingMode::ByValue(ast::Mutability::Not)\n-                } else {\n-                    ast::BindingMode::ByRef(mutbl)\n-                };\n-                cx.pat(path.span, PatKind::Ident(binding_mode, *path, None))\n+            .map(|prefix| {\n+                let pieces_iter =\n+                    struct_def.fields().iter().enumerate().map(|(i, struct_field)| {\n+                        let sp = struct_field.span.with_ctxt(self.span.ctxt());\n+                        let binding_mode = if use_temporaries {\n+                            ast::BindingMode::ByValue(ast::Mutability::Not)\n+                        } else {\n+                            ast::BindingMode::ByRef(mutbl)\n+                        };\n+                        let ident = self.mk_pattern_ident(prefix, i);\n+                        let path = ident.with_span_pos(sp);\n+                        (\n+                            sp,\n+                            struct_field.ident,\n+                            cx.pat(path.span, PatKind::Ident(binding_mode, path, None)),\n+                        )\n+                    });\n+\n+                let struct_path = struct_path.clone();\n+                match *struct_def {\n+                    VariantData::Struct(..) => {\n+                        let field_pats = pieces_iter\n+                            .map(|(sp, ident, pat)| {\n+                                if ident.is_none() {\n+                                    cx.span_bug(\n+                                        sp,\n+                                        \"a braced struct with unnamed fields in `derive`\",\n+                                    );\n+                                }\n+                                ast::PatField {\n+                                    ident: ident.unwrap(),\n+                                    is_shorthand: false,\n+                                    attrs: ast::AttrVec::new(),\n+                                    id: ast::DUMMY_NODE_ID,\n+                                    span: pat.span.with_ctxt(self.span.ctxt()),\n+                                    pat,\n+                                    is_placeholder: false,\n+                                }\n+                            })\n+                            .collect();\n+                        cx.pat_struct(self.span, struct_path, field_pats)\n+                    }\n+                    VariantData::Tuple(..) => {\n+                        let subpats = pieces_iter.map(|(_, _, subpat)| subpat).collect();\n+                        cx.pat_tuple_struct(self.span, struct_path, subpats)\n+                    }\n+                    VariantData::Unit(..) => cx.pat_path(self.span, struct_path),\n+                }\n             })\n             .collect()\n     }\n \n-    fn create_struct_pattern(\n-        &self,\n-        cx: &mut ExtCtxt<'_>,\n-        struct_path: ast::Path,\n-        struct_def: &'a VariantData,\n-        prefix: &str,\n-        mutbl: ast::Mutability,\n-        use_temporaries: bool,\n-    ) -> (P<ast::Pat>, Vec<(Span, Option<Ident>, P<Expr>, &'a [ast::Attribute])>) {\n-        let mut paths = Vec::new();\n-        let mut ident_exprs = Vec::new();\n-        for (i, struct_field) in struct_def.fields().iter().enumerate() {\n-            let sp = struct_field.span.with_ctxt(self.span.ctxt());\n-            let ident = Ident::from_str_and_span(&format!(\"{}_{}\", prefix, i), self.span);\n-            paths.push(ident.with_span_pos(sp));\n-            let val = cx.expr_path(cx.path_ident(sp, ident));\n-            let val = if use_temporaries { val } else { cx.expr_deref(sp, val) };\n-            ident_exprs.push((sp, struct_field.ident, val, &struct_field.attrs[..]));\n-        }\n-\n-        let subpats = self.create_subpatterns(cx, paths, mutbl, use_temporaries);\n-        let pattern = match *struct_def {\n-            VariantData::Struct(..) => {\n-                let field_pats = iter::zip(subpats, &ident_exprs)\n-                    .map(|(pat, &(sp, ident, ..))| {\n-                        if ident.is_none() {\n-                            cx.span_bug(sp, \"a braced struct with unnamed fields in `derive`\");\n-                        }\n-                        ast::PatField {\n-                            ident: ident.unwrap(),\n-                            is_shorthand: false,\n-                            attrs: ast::AttrVec::new(),\n-                            id: ast::DUMMY_NODE_ID,\n-                            span: pat.span.with_ctxt(self.span.ctxt()),\n-                            pat,\n-                            is_placeholder: false,\n-                        }\n-                    })\n-                    .collect();\n-                cx.pat_struct(self.span, struct_path, field_pats)\n-            }\n-            VariantData::Tuple(..) => cx.pat_tuple_struct(self.span, struct_path, subpats),\n-            VariantData::Unit(..) => cx.pat_path(self.span, struct_path),\n-        };\n+    fn create_fields<F>(&self, struct_def: &'a VariantData, mk_exprs: F) -> Vec<FieldInfo>\n+    where\n+        F: Fn(usize, &ast::FieldDef, Span) -> Vec<P<ast::Expr>>,\n+    {\n+        struct_def\n+            .fields()\n+            .iter()\n+            .enumerate()\n+            .map(|(i, struct_field)| {\n+                // For this field, get an expr for each selflike_arg. E.g. for\n+                // `PartialEq::eq`, one for each of `&self` and `other`.\n+                let sp = struct_field.span.with_ctxt(self.span.ctxt());\n+                let mut exprs: Vec<_> = mk_exprs(i, struct_field, sp);\n+                let self_expr = exprs.remove(0);\n+                let other_selflike_exprs = exprs;\n+                FieldInfo {\n+                    span: sp.with_ctxt(self.span.ctxt()),\n+                    name: struct_field.ident,\n+                    self_expr,\n+                    other_selflike_exprs,\n+                }\n+            })\n+            .collect()\n+    }\n \n-        (pattern, ident_exprs)\n+    fn mk_pattern_ident(&self, prefix: &str, i: usize) -> Ident {\n+        Ident::from_str_and_span(&format!(\"{}_{}\", prefix, i), self.span)\n     }\n \n-    fn create_struct_field_accesses(\n+    fn create_struct_pattern_fields(\n         &self,\n         cx: &mut ExtCtxt<'_>,\n-        mut self_arg: &P<Expr>,\n         struct_def: &'a VariantData,\n-    ) -> Vec<(Span, Option<Ident>, P<Expr>, &'a [ast::Attribute])> {\n-        let mut ident_exprs = Vec::new();\n-        for (i, struct_field) in struct_def.fields().iter().enumerate() {\n-            let sp = struct_field.span.with_ctxt(self.span.ctxt());\n-\n-            // We don't the need the deref, if there is one.\n-            if let ast::ExprKind::Unary(ast::UnOp::Deref, inner) = &self_arg.kind {\n-                self_arg = inner;\n-            }\n-\n-            // Note: we must use `struct_field.span` rather than `span` in the\n-            // `unwrap_or_else` case otherwise the hygiene is wrong and we get\n-            // \"field `0` of struct `Point` is private\" errors on tuple\n-            // structs.\n-            let val = cx.expr(\n-                sp,\n-                ast::ExprKind::Field(\n-                    self_arg.clone(),\n-                    struct_field.ident.unwrap_or_else(|| {\n-                        Ident::from_str_and_span(&i.to_string(), struct_field.span)\n-                    }),\n-                ),\n-            );\n-            ident_exprs.push((sp, struct_field.ident, val, &struct_field.attrs[..]));\n-        }\n-        ident_exprs\n+        prefixes: &[String],\n+        use_temporaries: bool,\n+    ) -> Vec<FieldInfo> {\n+        self.create_fields(struct_def, |i, _struct_field, sp| {\n+            prefixes\n+                .iter()\n+                .map(|prefix| {\n+                    let ident = self.mk_pattern_ident(prefix, i);\n+                    let expr = cx.expr_path(cx.path_ident(sp, ident));\n+                    if use_temporaries { expr } else { cx.expr_deref(sp, expr) }\n+                })\n+                .collect()\n+        })\n     }\n \n-    fn create_enum_variant_pattern(\n+    fn create_struct_field_access_fields(\n         &self,\n         cx: &mut ExtCtxt<'_>,\n-        enum_ident: Ident,\n-        variant: &'a ast::Variant,\n-        prefix: &str,\n-        mutbl: ast::Mutability,\n-    ) -> (P<ast::Pat>, Vec<(Span, Option<Ident>, P<Expr>, &'a [ast::Attribute])>) {\n-        let sp = variant.span.with_ctxt(self.span.ctxt());\n-        let variant_path = cx.path(sp, vec![enum_ident, variant.ident]);\n-        let use_temporaries = false; // enums can't be repr(packed)\n-        self.create_struct_pattern(cx, variant_path, &variant.data, prefix, mutbl, use_temporaries)\n+        selflike_args: &[P<Expr>],\n+        struct_def: &'a VariantData,\n+    ) -> Vec<FieldInfo> {\n+        self.create_fields(struct_def, |i, struct_field, sp| {\n+            selflike_args\n+                .iter()\n+                .map(|mut selflike_arg| {\n+                    // We don't the need the deref, if there is one.\n+                    if let ast::ExprKind::Unary(ast::UnOp::Deref, inner) = &selflike_arg.kind {\n+                        selflike_arg = inner;\n+                    }\n+                    // Note: we must use `struct_field.span` rather than `span` in the\n+                    // `unwrap_or_else` case otherwise the hygiene is wrong and we get\n+                    // \"field `0` of struct `Point` is private\" errors on tuple\n+                    // structs.\n+                    cx.expr(\n+                        sp,\n+                        ast::ExprKind::Field(\n+                            selflike_arg.clone(),\n+                            struct_field.ident.unwrap_or_else(|| {\n+                                Ident::from_str_and_span(&i.to_string(), struct_field.span)\n+                            }),\n+                        ),\n+                    )\n+                })\n+                .collect()\n+        })\n     }\n }\n \n-/// Function to fold over fields, with three cases, to generate more efficient and concise code.\n-/// When the `substructure` has grouped fields, there are two cases:\n-/// Zero fields: call the base case function with `None` (like the usual base case of `cs_fold`).\n-/// One or more fields: call the base case function on the first value (which depends on\n-/// `use_fold`), and use that as the base case. Then perform `cs_fold` on the remainder of the\n-/// fields.\n-/// When the `substructure` is an `EnumNonMatchingCollapsed`, the result of `enum_nonmatch_f`\n-/// is returned. Statics may not be folded over.\n-pub fn cs_fold<F, B>(\n+/// The function passed to `cs_fold` is called repeatedly with a value of this\n+/// type. It describes one part of the code generation. The result is always an\n+/// expression.\n+pub enum CsFold<'a> {\n+    /// The basic case: a field expression for one or more selflike args. E.g.\n+    /// for `PartialEq::eq` this is something like `self.x == other.x`.\n+    Single(&'a FieldInfo),\n+\n+    /// The combination of two field expressions. E.g. for `PartialEq::eq` this\n+    /// is something like `<field1 equality> && <field2 equality>`.\n+    Combine(Span, P<Expr>, P<Expr>),\n+\n+    // The fallback case for a struct or enum variant with no fields.\n+    Fieldless,\n+\n+    /// The fallback case for non-matching enum variants. The slice is the\n+    /// identifiers holding the variant index value for each of the `Self`\n+    /// arguments.\n+    EnumNonMatching(Span, &'a [Ident]),\n+}\n+\n+/// Folds over fields, combining the expressions for each field in a sequence.\n+/// Statics may not be folded over.\n+pub fn cs_fold<F>(\n     use_foldl: bool,\n-    mut f: F,\n-    mut b: B,\n-    mut enum_nonmatch_f: EnumNonMatchCollapsedFunc<'_>,\n     cx: &mut ExtCtxt<'_>,\n     trait_span: Span,\n     substructure: &Substructure<'_>,\n+    mut f: F,\n ) -> P<Expr>\n where\n-    F: FnMut(&mut ExtCtxt<'_>, Span, P<Expr>, P<Expr>, &[P<Expr>]) -> P<Expr>,\n-    B: FnMut(&mut ExtCtxt<'_>, Option<(Span, P<Expr>, &[P<Expr>])>) -> P<Expr>,\n+    F: FnMut(&mut ExtCtxt<'_>, CsFold<'_>) -> P<Expr>,\n {\n     match *substructure.fields {\n         EnumMatching(.., ref all_fields) | Struct(_, ref all_fields) => {\n-            let (base, rest) = match (all_fields.is_empty(), use_foldl) {\n-                (false, true) => {\n-                    let (first, rest) = all_fields.split_first().unwrap();\n-                    let args = (first.span, first.self_.clone(), &first.other[..]);\n-                    (b(cx, Some(args)), rest)\n-                }\n-                (false, false) => {\n-                    let (last, rest) = all_fields.split_last().unwrap();\n-                    let args = (last.span, last.self_.clone(), &last.other[..]);\n-                    (b(cx, Some(args)), rest)\n-                }\n-                (true, _) => (b(cx, None), &all_fields[..]),\n+            if all_fields.is_empty() {\n+                return f(cx, CsFold::Fieldless);\n+            }\n+\n+            let (base_field, rest) = if use_foldl {\n+                all_fields.split_first().unwrap()\n+            } else {\n+                all_fields.split_last().unwrap()\n+            };\n+\n+            let base_expr = f(cx, CsFold::Single(base_field));\n+\n+            let op = |old, field: &FieldInfo| {\n+                let new = f(cx, CsFold::Single(field));\n+                f(cx, CsFold::Combine(field.span, old, new))\n             };\n \n             if use_foldl {\n-                rest.iter().fold(base, |old, field| {\n-                    f(cx, field.span, old, field.self_.clone(), &field.other)\n-                })\n+                rest.iter().fold(base_expr, op)\n             } else {\n-                rest.iter().rev().fold(base, |old, field| {\n-                    f(cx, field.span, old, field.self_.clone(), &field.other)\n-                })\n+                rest.iter().rfold(base_expr, op)\n             }\n         }\n-        EnumNonMatchingCollapsed(tuple) => enum_nonmatch_f(cx, trait_span, tuple),\n+        EnumNonMatchingCollapsed(tuple) => f(cx, CsFold::EnumNonMatching(trait_span, tuple)),\n         StaticEnum(..) | StaticStruct(..) => cx.span_bug(trait_span, \"static function in `derive`\"),\n     }\n }"}, {"sha": "2213cd6d37d2d9c80177b3f1c8692be2876e805c", "filename": "compiler/rustc_builtin_macros/src/deriving/hash.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -30,7 +30,7 @@ pub fn expand_deriving_hash(\n             name: sym::hash,\n             generics: Bounds { bounds: vec![(typaram, vec![path_std!(hash::Hasher)])] },\n             explicit_self: true,\n-            args: vec![(Ref(Box::new(Path(arg)), Mutability::Mut), sym::state)],\n+            nonself_args: vec![(Ref(Box::new(Path(arg)), Mutability::Mut), sym::state)],\n             ret_ty: Unit,\n             attributes: vec![],\n             unify_fieldless_variants: true,\n@@ -49,7 +49,7 @@ fn hash_substructure(\n     trait_span: Span,\n     substr: &Substructure<'_>,\n ) -> BlockOrExpr {\n-    let [state_expr] = substr.nonself_args else {\n+    let [state_expr] = substr.nonselflike_args else {\n         cx.span_bug(trait_span, \"incorrect number of arguments in `derive(Hash)`\");\n     };\n     let call_hash = |span, thing_expr| {\n@@ -82,7 +82,9 @@ fn hash_substructure(\n     };\n \n     stmts.extend(\n-        fields.iter().map(|FieldInfo { ref self_, span, .. }| call_hash(*span, self_.clone())),\n+        fields\n+            .iter()\n+            .map(|FieldInfo { ref self_expr, span, .. }| call_hash(*span, self_expr.clone())),\n     );\n     BlockOrExpr::new_stmts(stmts)\n }"}, {"sha": "77f437974c2d66527e965c27a36cf0f3aff62546", "filename": "compiler/rustc_codegen_cranelift/patches/0027-sysroot-128bit-atomic-operations.patch", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-sysroot-128bit-atomic-operations.patch", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-sysroot-128bit-atomic-operations.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-sysroot-128bit-atomic-operations.patch?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -19,7 +19,7 @@ index 092b7cf..158cf71 100644\n  #[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n  impl RefUnwindSafe for crate::sync::atomic::AtomicI64 {}\n -#[cfg(target_has_atomic_load_store = \"128\")]\n--#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n+-#[unstable(feature = \"integer_atomics\", issue = \"99069\")]\n -impl RefUnwindSafe for crate::sync::atomic::AtomicI128 {}\n \n  #[cfg(target_has_atomic_load_store = \"ptr\")]\n@@ -29,7 +29,7 @@ index 092b7cf..158cf71 100644\n  #[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n  impl RefUnwindSafe for crate::sync::atomic::AtomicU64 {}\n -#[cfg(target_has_atomic_load_store = \"128\")]\n--#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n+-#[unstable(feature = \"integer_atomics\", issue = \"99069\")]\n -impl RefUnwindSafe for crate::sync::atomic::AtomicU128 {}\n \n  #[cfg(target_has_atomic_load_store = \"8\")]\n@@ -46,14 +46,14 @@ index d9de37e..8293fce 100644\n -atomic_int! {\n -    cfg(target_has_atomic = \"128\"),\n -    cfg(target_has_atomic_equal_alignment = \"128\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n -    rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n -    cfg_attr(not(test), rustc_diagnostic_item = \"AtomicI128\"),\n -    \"i128\",\n -    \"#![feature(integer_atomics)]\\n\\n\",\n@@ -66,14 +66,14 @@ index d9de37e..8293fce 100644\n -atomic_int! {\n -    cfg(target_has_atomic = \"128\"),\n -    cfg(target_has_atomic_equal_alignment = \"128\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n -    rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n--    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n -    cfg_attr(not(test), rustc_diagnostic_item = \"AtomicU128\"),\n -    \"u128\",\n -    \"#![feature(integer_atomics)]\\n\\n\","}, {"sha": "730048d061b559201fb3e450de8c6d61e28812f1", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -103,14 +103,14 @@ impl<'ll, 'tcx> CodegenUnitDebugContext<'ll, 'tcx> {\n             // for macOS to understand. For more info see #11352\n             // This can be overridden using --llvm-opts -dwarf-version,N.\n             // Android has the same issue (#22398)\n-            if let Some(version) = sess.target.dwarf_version {\n-                llvm::LLVMRustAddModuleFlag(\n-                    self.llmod,\n-                    llvm::LLVMModFlagBehavior::Warning,\n-                    \"Dwarf Version\\0\".as_ptr().cast(),\n-                    version,\n-                )\n-            }\n+            let dwarf_version =\n+                sess.opts.debugging_opts.dwarf_version.unwrap_or(sess.target.default_dwarf_version);\n+            llvm::LLVMRustAddModuleFlag(\n+                self.llmod,\n+                llvm::LLVMModFlagBehavior::Warning,\n+                \"Dwarf Version\\0\".as_ptr().cast(),\n+                dwarf_version,\n+            );\n \n             // Indicate that we want CodeView debug information on MSVC\n             if sess.target.is_like_msvc {"}, {"sha": "29ab1d187719ceb60a72cdbe2f2bda607ed9899b", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -14,7 +14,7 @@ use rustc_middle::mir::AssertMessage;\n use rustc_session::Limit;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_target::abi::{Align, Size};\n-use rustc_target::spec::abi::Abi;\n+use rustc_target::spec::abi::Abi as CallAbi;\n \n use crate::interpret::{\n     self, compile_time_machine, AllocId, ConstAllocation, Frame, ImmTy, InterpCx, InterpResult,\n@@ -263,7 +263,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     fn find_mir_or_eval_fn(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n-        _abi: Abi,\n+        _abi: CallAbi,\n         args: &[OpTy<'tcx>],\n         _dest: &PlaceTy<'tcx>,\n         _ret: Option<mir::BasicBlock>,"}, {"sha": "7f8eea94aeeda5db7ffd06d95f4ec5a9871e3d5d", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -10,7 +10,7 @@ use rustc_middle::mir;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::def_id::DefId;\n use rustc_target::abi::Size;\n-use rustc_target::spec::abi::Abi;\n+use rustc_target::spec::abi::Abi as CallAbi;\n \n use super::{\n     AllocId, AllocRange, Allocation, ConstAllocation, Frame, ImmTy, InterpCx, InterpResult,\n@@ -138,7 +138,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Whether to enforce integers and floats not having provenance.\n     fn enforce_number_no_provenance(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n \n-    /// Whether function calls should be [ABI](Abi)-checked.\n+    /// Whether function calls should be [ABI](CallAbi)-checked.\n     fn enforce_abi(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n         true\n     }\n@@ -169,7 +169,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     fn find_mir_or_eval_fn(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n-        abi: Abi,\n+        abi: CallAbi,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n         destination: &PlaceTy<'tcx, Self::PointerTag>,\n         target: Option<mir::BasicBlock>,\n@@ -181,7 +181,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     fn call_extra_fn(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         fn_val: Self::ExtraFnVal,\n-        abi: Abi,\n+        abi: CallAbi,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n         destination: &PlaceTy<'tcx, Self::PointerTag>,\n         target: Option<mir::BasicBlock>,\n@@ -483,7 +483,7 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n     fn call_extra_fn(\n         _ecx: &mut InterpCx<$mir, $tcx, Self>,\n         fn_val: !,\n-        _abi: Abi,\n+        _abi: CallAbi,\n         _args: &[OpTy<$tcx>],\n         _destination: &PlaceTy<$tcx, Self::PointerTag>,\n         _target: Option<mir::BasicBlock>,"}, {"sha": "576958a855d24ed78da3bd42b15ff9becfeb11c6", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -78,6 +78,7 @@ impl<'tcx, Tag: Provenance> Immediate<Tag> {\n     }\n \n     #[inline]\n+    #[cfg_attr(debug_assertions, track_caller)] // only in debug builds due to perf (see #98980)\n     pub fn to_scalar_or_uninit(self) -> ScalarMaybeUninit<Tag> {\n         match self {\n             Immediate::Scalar(val) => val,\n@@ -87,11 +88,13 @@ impl<'tcx, Tag: Provenance> Immediate<Tag> {\n     }\n \n     #[inline]\n+    #[cfg_attr(debug_assertions, track_caller)] // only in debug builds due to perf (see #98980)\n     pub fn to_scalar(self) -> InterpResult<'tcx, Scalar<Tag>> {\n         self.to_scalar_or_uninit().check_init()\n     }\n \n     #[inline]\n+    #[cfg_attr(debug_assertions, track_caller)] // only in debug builds due to perf (see #98980)\n     pub fn to_scalar_or_uninit_pair(self) -> (ScalarMaybeUninit<Tag>, ScalarMaybeUninit<Tag>) {\n         match self {\n             Immediate::ScalarPair(val1, val2) => (val1, val2),\n@@ -101,6 +104,7 @@ impl<'tcx, Tag: Provenance> Immediate<Tag> {\n     }\n \n     #[inline]\n+    #[cfg_attr(debug_assertions, track_caller)] // only in debug builds due to perf (see #98980)\n     pub fn to_scalar_pair(self) -> InterpResult<'tcx, (Scalar<Tag>, Scalar<Tag>)> {\n         let (val1, val2) = self.to_scalar_or_uninit_pair();\n         Ok((val1.check_init()?, val2.check_init()?))"}, {"sha": "04f585df34cc26dff42bfab2543ca743556d7f92", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 4, "deletions": 24, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -1438,18 +1438,8 @@ impl<'hir> Body<'hir> {\n }\n \n /// The type of source expression that caused this generator to be created.\n-#[derive(\n-    Clone,\n-    PartialEq,\n-    PartialOrd,\n-    Eq,\n-    Hash,\n-    HashStable_Generic,\n-    Encodable,\n-    Decodable,\n-    Debug,\n-    Copy\n-)]\n+#[derive(Clone, PartialEq, PartialOrd, Eq, Hash, Debug, Copy)]\n+#[derive(HashStable_Generic, Encodable, Decodable)]\n pub enum GeneratorKind {\n     /// An explicit `async` block or the body of an async function.\n     Async(AsyncGeneratorKind),\n@@ -1481,18 +1471,8 @@ impl GeneratorKind {\n ///\n /// This helps error messages but is also used to drive coercions in\n /// type-checking (see #60424).\n-#[derive(\n-    Clone,\n-    PartialEq,\n-    PartialOrd,\n-    Eq,\n-    Hash,\n-    HashStable_Generic,\n-    Encodable,\n-    Decodable,\n-    Debug,\n-    Copy\n-)]\n+#[derive(Clone, PartialEq, PartialOrd, Eq, Hash, Debug, Copy)]\n+#[derive(HashStable_Generic, Encodable, Decodable)]\n pub enum AsyncGeneratorKind {\n     /// An explicit `async` block written by the user.\n     Block,"}, {"sha": "55827ff583affb6098928d32e4369927772f0c90", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -733,6 +733,7 @@ fn test_debugging_options_tracking_hash() {\n     tracked!(dep_info_omit_d_target, true);\n     tracked!(drop_tracking, true);\n     tracked!(dual_proc_macros, true);\n+    tracked!(dwarf_version, Some(5));\n     tracked!(fewer_names, Some(true));\n     tracked!(force_unstable_if_unmarked, true);\n     tracked!(fuel, Some((\"abc\".to_string(), 99)));"}, {"sha": "fb5423dd157c2fbd97fb7333cbd113ac7a9c4a54", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -22,8 +22,8 @@ use rustc_middle::ty::{\n     self, ConstKind, EarlyBinder, Instance, ParamEnv, Ty, TyCtxt, TypeVisitable,\n };\n use rustc_span::{def_id::DefId, Span};\n-use rustc_target::abi::{HasDataLayout, Size, TargetDataLayout};\n-use rustc_target::spec::abi::Abi;\n+use rustc_target::abi::{self, HasDataLayout, Size, TargetDataLayout};\n+use rustc_target::spec::abi::Abi as CallAbi;\n use rustc_trait_selection::traits;\n \n use crate::MirPass;\n@@ -195,7 +195,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n     fn find_mir_or_eval_fn(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         _instance: ty::Instance<'tcx>,\n-        _abi: Abi,\n+        _abi: CallAbi,\n         _args: &[OpTy<'tcx>],\n         _destination: &PlaceTy<'tcx>,\n         _target: Option<BasicBlock>,\n@@ -659,6 +659,11 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     (Ok(_), Ok(_)) => return this.ecx.eval_rvalue_into_place(rvalue, place),\n                 };\n \n+                if !matches!(const_arg.layout.abi, abi::Abi::Scalar(..)) {\n+                    // We cannot handle Scalar Pair stuff.\n+                    return this.ecx.eval_rvalue_into_place(rvalue, place);\n+                }\n+\n                 let arg_value = const_arg.to_scalar()?.to_bits(const_arg.layout.size)?;\n                 let dest = this.ecx.eval_place(place)?;\n "}, {"sha": "09a5cb8280f353a4aa1d18996aee87df6a5fd4ef", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -24,7 +24,7 @@ use rustc_middle::ty::{\n use rustc_session::lint;\n use rustc_span::{def_id::DefId, Span};\n use rustc_target::abi::{HasDataLayout, Size, TargetDataLayout};\n-use rustc_target::spec::abi::Abi;\n+use rustc_target::spec::abi::Abi as CallAbi;\n use rustc_trait_selection::traits;\n \n use crate::MirLint;\n@@ -191,7 +191,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n     fn find_mir_or_eval_fn(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         _instance: ty::Instance<'tcx>,\n-        _abi: Abi,\n+        _abi: CallAbi,\n         _args: &[OpTy<'tcx>],\n         _destination: &PlaceTy<'tcx>,\n         _target: Option<BasicBlock>,"}, {"sha": "18ffe9528f5656930aad671407b33d703b99b131", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -28,7 +28,7 @@ use rustc_span::{BytePos, Span};\n use tracing::debug;\n \n use crate::imports::{Import, ImportKind, ImportResolver};\n-use crate::late::Rib;\n+use crate::late::{PatternSource, Rib};\n use crate::path_names_to_string;\n use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, BindingError, Finalize};\n use crate::{HasGenericParams, MacroRulesScope, Module, ModuleKind, ModuleOrUniformRoot};\n@@ -896,25 +896,40 @@ impl<'a> Resolver<'a> {\n                 err\n             }\n             ResolutionError::BindingShadowsSomethingUnacceptable {\n-                shadowing_binding_descr,\n+                shadowing_binding,\n                 name,\n                 participle,\n                 article,\n-                shadowed_binding_descr,\n+                shadowed_binding,\n                 shadowed_binding_span,\n             } => {\n+                let shadowed_binding_descr = shadowed_binding.descr();\n                 let mut err = struct_span_err!(\n                     self.session,\n                     span,\n                     E0530,\n                     \"{}s cannot shadow {}s\",\n-                    shadowing_binding_descr,\n+                    shadowing_binding.descr(),\n                     shadowed_binding_descr,\n                 );\n                 err.span_label(\n                     span,\n                     format!(\"cannot be named the same as {} {}\", article, shadowed_binding_descr),\n                 );\n+                match (shadowing_binding, shadowed_binding) {\n+                    (\n+                        PatternSource::Match,\n+                        Res::Def(DefKind::Ctor(CtorOf::Variant | CtorOf::Struct, CtorKind::Fn), _),\n+                    ) => {\n+                        err.span_suggestion(\n+                            span,\n+                            \"try specify the pattern arguments\",\n+                            format!(\"{}(..)\", name),\n+                            Applicability::Unspecified,\n+                        );\n+                    }\n+                    _ => (),\n+                }\n                 let msg =\n                     format!(\"the {} `{}` is {} here\", shadowed_binding_descr, name, participle);\n                 err.span_label(shadowed_binding_span, msg);"}, {"sha": "f37acca3d9f276b17c5298822c478f6859e48b04", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -50,7 +50,7 @@ struct BindingInfo {\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-enum PatternSource {\n+pub enum PatternSource {\n     Match,\n     Let,\n     For,\n@@ -64,7 +64,7 @@ enum IsRepeatExpr {\n }\n \n impl PatternSource {\n-    fn descr(self) -> &'static str {\n+    pub fn descr(self) -> &'static str {\n         match self {\n             PatternSource::Match => \"match binding\",\n             PatternSource::Let => \"let binding\",\n@@ -2845,11 +2845,11 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 self.report_error(\n                     ident.span,\n                     ResolutionError::BindingShadowsSomethingUnacceptable {\n-                        shadowing_binding_descr: pat_src.descr(),\n+                        shadowing_binding: pat_src,\n                         name: ident.name,\n                         participle: if binding.is_import() { \"imported\" } else { \"defined\" },\n                         article: binding.res().article(),\n-                        shadowed_binding_descr: binding.res().descr(),\n+                        shadowed_binding: binding.res(),\n                         shadowed_binding_span: binding.span,\n                     },\n                 );\n@@ -2861,11 +2861,11 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 self.report_error(\n                     ident.span,\n                     ResolutionError::BindingShadowsSomethingUnacceptable {\n-                        shadowing_binding_descr: pat_src.descr(),\n+                        shadowing_binding: pat_src,\n                         name: ident.name,\n                         participle: \"defined\",\n                         article: res.article(),\n-                        shadowed_binding_descr: res.descr(),\n+                        shadowed_binding: res,\n                         shadowed_binding_span: self.r.opt_span(def_id).expect(\"const parameter defined outside of local crate\"),\n                     }\n                 );"}, {"sha": "8968179c92e4b69a0e9f970197a69ff155e54e46", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -61,7 +61,7 @@ use tracing::debug;\n \n use diagnostics::{ImportSuggestion, LabelSuggestion, Suggestion};\n use imports::{Import, ImportKind, ImportResolver, NameResolution};\n-use late::{HasGenericParams, PathSource};\n+use late::{HasGenericParams, PathSource, PatternSource};\n use macros::{MacroRulesBinding, MacroRulesScope, MacroRulesScopeRef};\n \n use crate::access_levels::AccessLevelsVisitor;\n@@ -230,11 +230,11 @@ enum ResolutionError<'a> {\n     ),\n     /// Error E0530: `X` bindings cannot shadow `Y`s.\n     BindingShadowsSomethingUnacceptable {\n-        shadowing_binding_descr: &'static str,\n+        shadowing_binding: PatternSource,\n         name: Symbol,\n         participle: &'static str,\n         article: &'static str,\n-        shadowed_binding_descr: &'static str,\n+        shadowed_binding: Res,\n         shadowed_binding_span: Span,\n     },\n     /// Error E0128: generic parameters with a default cannot use forward-declared identifiers."}, {"sha": "8f1057b793fa3004562d673441ab974b0a75117e", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -1272,6 +1272,8 @@ options! {\n         computed `block` spans (one span encompassing a block's terminator and \\\n         all statements). If `-Z instrument-coverage` is also enabled, create \\\n         an additional `.html` file showing the computed coverage spans.\"),\n+    dwarf_version: Option<u32> = (None, parse_opt_number, [TRACKED],\n+        \"version of DWARF debug information to emit (default: 2 or 4, depending on platform)\"),\n     emit_stack_sizes: bool = (false, parse_bool, [UNTRACKED],\n         \"emit a section containing stack size metadata (default: no)\"),\n     fewer_names: Option<bool> = (None, parse_opt_bool, [TRACKED],"}, {"sha": "1cccef2f64fec4809cb1e89ba943af94816bd5e2", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -1498,6 +1498,12 @@ fn validate_commandline_args_with_session_available(sess: &Session) {\n             ))\n         }\n     }\n+\n+    if let Some(dwarf_version) = sess.opts.debugging_opts.dwarf_version {\n+        if dwarf_version > 5 {\n+            sess.err(&format!(\"requested DWARF version {} is greater than 5\", dwarf_version));\n+        }\n+    }\n }\n \n /// Holds data on the current incremental compilation session, if there is one."}, {"sha": "65d2cd64bf69319c9b2e1e06924c1d0cfc697c5e", "filename": "compiler/rustc_target/src/asm/mod.rs", "status": "modified", "additions": 8, "deletions": 48, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -244,18 +244,8 @@ impl FromStr for InlineAsmArch {\n     }\n }\n \n-#[derive(\n-    Copy,\n-    Clone,\n-    Encodable,\n-    Decodable,\n-    Debug,\n-    Eq,\n-    PartialEq,\n-    PartialOrd,\n-    Hash,\n-    HashStable_Generic\n-)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Hash)]\n+#[derive(HashStable_Generic, Encodable, Decodable)]\n pub enum InlineAsmReg {\n     X86(X86InlineAsmReg),\n     Arm(ArmInlineAsmReg),\n@@ -406,18 +396,8 @@ impl InlineAsmReg {\n     }\n }\n \n-#[derive(\n-    Copy,\n-    Clone,\n-    Encodable,\n-    Decodable,\n-    Debug,\n-    Eq,\n-    PartialEq,\n-    PartialOrd,\n-    Hash,\n-    HashStable_Generic\n-)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Hash)]\n+#[derive(HashStable_Generic, Encodable, Decodable)]\n pub enum InlineAsmRegClass {\n     X86(X86InlineAsmRegClass),\n     Arm(ArmInlineAsmRegClass),\n@@ -620,18 +600,8 @@ impl InlineAsmRegClass {\n     }\n }\n \n-#[derive(\n-    Copy,\n-    Clone,\n-    Encodable,\n-    Decodable,\n-    Debug,\n-    Eq,\n-    PartialEq,\n-    PartialOrd,\n-    Hash,\n-    HashStable_Generic\n-)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Hash)]\n+#[derive(HashStable_Generic, Encodable, Decodable)]\n pub enum InlineAsmRegOrRegClass {\n     Reg(InlineAsmReg),\n     RegClass(InlineAsmRegClass),\n@@ -808,18 +778,8 @@ pub fn allocatable_registers(\n     }\n }\n \n-#[derive(\n-    Copy,\n-    Clone,\n-    Encodable,\n-    Decodable,\n-    Debug,\n-    Eq,\n-    PartialEq,\n-    PartialOrd,\n-    Hash,\n-    HashStable_Generic\n-)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Hash)]\n+#[derive(HashStable_Generic, Encodable, Decodable)]\n pub enum InlineAsmClobberAbi {\n     X86,\n     X86_64Win,"}, {"sha": "dc06597db6fd4a99728a837362248300b3b3075a", "filename": "compiler/rustc_target/src/spec/android_base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fandroid_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fandroid_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fandroid_base.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -3,7 +3,7 @@ use crate::spec::TargetOptions;\n pub fn opts() -> TargetOptions {\n     let mut base = super::linux_base::opts();\n     base.os = \"android\".into();\n-    base.dwarf_version = Some(2);\n+    base.default_dwarf_version = 2;\n     base.position_independent_executables = true;\n     base.has_thread_local = false;\n     // This is for backward compatibility, see https://github.com/rust-lang/rust/issues/49867"}, {"sha": "713dc9a1f0ea729f81ba9609f6eb16cd328a3bd8", "filename": "compiler/rustc_target/src/spec/apple_base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -28,7 +28,7 @@ pub fn opts(os: &'static str) -> TargetOptions {\n         executables: true,\n         families: cvs![\"unix\"],\n         is_like_osx: true,\n-        dwarf_version: Some(2),\n+        default_dwarf_version: 2,\n         frame_pointer: FramePointer::Always,\n         has_rpath: true,\n         dll_suffix: \".dylib\".into(),"}, {"sha": "c1e469746cb4c61e0ebee704f772b86e1726669b", "filename": "compiler/rustc_target/src/spec/dragonfly_base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fdragonfly_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fdragonfly_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fdragonfly_base.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -9,7 +9,7 @@ pub fn opts() -> TargetOptions {\n         has_rpath: true,\n         position_independent_executables: true,\n         relro_level: RelroLevel::Full,\n-        dwarf_version: Some(2),\n+        default_dwarf_version: 2,\n         ..Default::default()\n     }\n }"}, {"sha": "36312d26e3700ae52d8daaa3535c980f9051c005", "filename": "compiler/rustc_target/src/spec/freebsd_base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_target%2Fsrc%2Fspec%2Ffreebsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_target%2Fsrc%2Fspec%2Ffreebsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Ffreebsd_base.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -10,7 +10,7 @@ pub fn opts() -> TargetOptions {\n         position_independent_executables: true,\n         relro_level: RelroLevel::Full,\n         abi_return_struct_as_int: true,\n-        dwarf_version: Some(2),\n+        default_dwarf_version: 2,\n         ..Default::default()\n     }\n }"}, {"sha": "48ccb10f214268a566029cd0ee6b7bc258f9582f", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -1275,9 +1275,9 @@ pub struct TargetOptions {\n     pub is_like_msvc: bool,\n     /// Whether a target toolchain is like WASM.\n     pub is_like_wasm: bool,\n-    /// Version of DWARF to use if not using the default.\n+    /// Default supported version of DWARF on this platform.\n     /// Useful because some platforms (osx, bsd) only want up to DWARF2.\n-    pub dwarf_version: Option<u32>,\n+    pub default_dwarf_version: u32,\n     /// Whether the linker support GNU-like arguments such as -O. Defaults to true.\n     pub linker_is_gnu: bool,\n     /// The MinGW toolchain has a known issue that prevents it from correctly\n@@ -1539,7 +1539,7 @@ impl Default for TargetOptions {\n             is_like_windows: false,\n             is_like_msvc: false,\n             is_like_wasm: false,\n-            dwarf_version: None,\n+            default_dwarf_version: 4,\n             linker_is_gnu: true,\n             allows_weak_linkage: true,\n             has_rpath: false,\n@@ -1778,13 +1778,13 @@ impl Target {\n                     base.$key_name = s;\n                 }\n             } );\n-            ($key_name:ident, Option<u32>) => ( {\n+            ($key_name:ident, u32) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n                 if let Some(s) = obj.remove(&name).and_then(|b| b.as_u64()) {\n                     if s < 1 || s > 5 {\n                         return Err(\"Not a valid DWARF version number\".into());\n                     }\n-                    base.$key_name = Some(s as u32);\n+                    base.$key_name = s as u32;\n                 }\n             } );\n             ($key_name:ident, Option<u64>) => ( {\n@@ -2143,7 +2143,7 @@ impl Target {\n         key!(is_like_windows, bool);\n         key!(is_like_msvc, bool);\n         key!(is_like_wasm, bool);\n-        key!(dwarf_version, Option<u32>);\n+        key!(default_dwarf_version, u32);\n         key!(linker_is_gnu, bool);\n         key!(allows_weak_linkage, bool);\n         key!(has_rpath, bool);\n@@ -2387,7 +2387,7 @@ impl ToJson for Target {\n         target_option_val!(is_like_windows);\n         target_option_val!(is_like_msvc);\n         target_option_val!(is_like_wasm);\n-        target_option_val!(dwarf_version);\n+        target_option_val!(default_dwarf_version);\n         target_option_val!(linker_is_gnu);\n         target_option_val!(allows_weak_linkage);\n         target_option_val!(has_rpath);"}, {"sha": "40ef04ba04382308a1d9ec8b206ca904c111cecf", "filename": "compiler/rustc_target/src/spec/netbsd_base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fnetbsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fnetbsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fnetbsd_base.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -11,7 +11,7 @@ pub fn opts() -> TargetOptions {\n         position_independent_executables: true,\n         relro_level: RelroLevel::Full,\n         use_ctors_section: true,\n-        dwarf_version: Some(2),\n+        default_dwarf_version: 2,\n         ..Default::default()\n     }\n }"}, {"sha": "51cecdd47eab29e4d90da31403e7779065b8bb77", "filename": "compiler/rustc_target/src/spec/openbsd_base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fopenbsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fopenbsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fopenbsd_base.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -11,7 +11,7 @@ pub fn opts() -> TargetOptions {\n         position_independent_executables: true,\n         frame_pointer: FramePointer::Always, // FIXME 43575: should be MayOmit...\n         relro_level: RelroLevel::Full,\n-        dwarf_version: Some(2),\n+        default_dwarf_version: 2,\n         ..Default::default()\n     }\n }"}, {"sha": "863a981134f244966c8963c7318ae1d325edae99", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -13,7 +13,6 @@ use rustc_hir::{\n use rustc_infer::infer::{self, TyCtxtInferExt};\n use rustc_infer::traits;\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, Binder, IsSuggestable, Subst, ToPredicate, Ty};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n@@ -238,25 +237,29 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         );\n                     }\n                 }\n-            } else if found.to_string().starts_with(\"Option<\")\n-                && expected.to_string() == \"Option<&str>\"\n+            } else if let ty::Adt(found_adt, found_substs) = found.kind()\n+                && self.tcx.is_diagnostic_item(sym::Option, found_adt.did())\n+                && let ty::Adt(expected_adt, expected_substs) = expected.kind()\n+                && self.tcx.is_diagnostic_item(sym::Option, expected_adt.did())\n+                && let ty::Ref(_, inner_ty, _) = expected_substs.type_at(0).kind()\n+                && inner_ty.is_str()\n             {\n-                if let ty::Adt(_def, subst) = found.kind() {\n-                    if subst.len() != 0 {\n-                        if let GenericArgKind::Type(ty) = subst[0].unpack() {\n-                            let peeled = ty.peel_refs().to_string();\n-                            if peeled == \"String\" {\n-                                let ref_cnt = ty.to_string().len() - peeled.len();\n-                                let result = format!(\".map(|x| &*{}x)\", \"*\".repeat(ref_cnt));\n-                                err.span_suggestion_verbose(\n-                                    expr.span.shrink_to_hi(),\n-                                    \"try converting the passed type into a `&str`\",\n-                                    result,\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                            }\n-                        }\n-                    }\n+                let ty = found_substs.type_at(0);\n+                let mut peeled = ty;\n+                let mut ref_cnt = 0;\n+                while let ty::Ref(_, inner, _) = peeled.kind() {\n+                    peeled = *inner;\n+                    ref_cnt += 1;\n+                }\n+                if let ty::Adt(adt, _) = peeled.kind()\n+                    && self.tcx.is_diagnostic_item(sym::String, adt.did())\n+                {\n+                    err.span_suggestion_verbose(\n+                        expr.span.shrink_to_hi(),\n+                        \"try converting the passed type into a `&str`\",\n+                        format!(\".map(|x| &*{}x)\", \"*\".repeat(ref_cnt)),\n+                        Applicability::MaybeIncorrect,\n+                    );\n                 }\n             }\n         }"}, {"sha": "9a6153f1253c539f9f081a25adff954cefe1cd9a", "filename": "library/core/src/panic/unwind_safe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/library%2Fcore%2Fsrc%2Fpanic%2Funwind_safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/library%2Fcore%2Fsrc%2Fpanic%2Funwind_safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanic%2Funwind_safe.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -217,7 +217,7 @@ impl RefUnwindSafe for crate::sync::atomic::AtomicI32 {}\n #[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n impl RefUnwindSafe for crate::sync::atomic::AtomicI64 {}\n #[cfg(target_has_atomic_load_store = \"128\")]\n-#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n+#[unstable(feature = \"integer_atomics\", issue = \"99069\")]\n impl RefUnwindSafe for crate::sync::atomic::AtomicI128 {}\n \n #[cfg(target_has_atomic_load_store = \"ptr\")]\n@@ -236,7 +236,7 @@ impl RefUnwindSafe for crate::sync::atomic::AtomicU32 {}\n #[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n impl RefUnwindSafe for crate::sync::atomic::AtomicU64 {}\n #[cfg(target_has_atomic_load_store = \"128\")]\n-#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n+#[unstable(feature = \"integer_atomics\", issue = \"99069\")]\n impl RefUnwindSafe for crate::sync::atomic::AtomicU128 {}\n \n #[cfg(target_has_atomic_load_store = \"8\")]"}, {"sha": "b32dcfefacda89893959a37c5da97edd79b509c0", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -2692,7 +2692,7 @@ atomic_int! {\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n     cfg_attr(not(test), rustc_diagnostic_item = \"AtomicI8\"),\n     \"i8\",\n     \"\",\n@@ -2712,7 +2712,7 @@ atomic_int! {\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n     cfg_attr(not(test), rustc_diagnostic_item = \"AtomicU8\"),\n     \"u8\",\n     \"\",\n@@ -2732,7 +2732,7 @@ atomic_int! {\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n     cfg_attr(not(test), rustc_diagnostic_item = \"AtomicI16\"),\n     \"i16\",\n     \"\",\n@@ -2752,7 +2752,7 @@ atomic_int! {\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n     cfg_attr(not(test), rustc_diagnostic_item = \"AtomicU16\"),\n     \"u16\",\n     \"\",\n@@ -2772,7 +2772,7 @@ atomic_int! {\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n     cfg_attr(not(test), rustc_diagnostic_item = \"AtomicI32\"),\n     \"i32\",\n     \"\",\n@@ -2792,7 +2792,7 @@ atomic_int! {\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n     cfg_attr(not(test), rustc_diagnostic_item = \"AtomicU32\"),\n     \"u32\",\n     \"\",\n@@ -2812,7 +2812,7 @@ atomic_int! {\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n     cfg_attr(not(test), rustc_diagnostic_item = \"AtomicI64\"),\n     \"i64\",\n     \"\",\n@@ -2832,7 +2832,7 @@ atomic_int! {\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n     cfg_attr(not(test), rustc_diagnostic_item = \"AtomicU64\"),\n     \"u64\",\n     \"\",\n@@ -2845,14 +2845,14 @@ atomic_int! {\n atomic_int! {\n     cfg(target_has_atomic = \"128\"),\n     cfg(target_has_atomic_equal_alignment = \"128\"),\n-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n+    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n+    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n+    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n+    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n+    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n     rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n     cfg_attr(not(test), rustc_diagnostic_item = \"AtomicI128\"),\n     \"i128\",\n     \"#![feature(integer_atomics)]\\n\\n\",\n@@ -2865,14 +2865,14 @@ atomic_int! {\n atomic_int! {\n     cfg(target_has_atomic = \"128\"),\n     cfg(target_has_atomic_equal_alignment = \"128\"),\n-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n+    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n+    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n+    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n+    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n+    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n     rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"integer_atomics\", issue = \"99069\"),\n     cfg_attr(not(test), rustc_diagnostic_item = \"AtomicU128\"),\n     \"u128\",\n     \"#![feature(integer_atomics)]\\n\\n\","}, {"sha": "c5e86f17df741dc8490bdd514582417c1b9e7c31", "filename": "src/doc/unstable-book/src/compiler-flags/dwarf-version.md", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fdwarf-version.md", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fdwarf-version.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fdwarf-version.md?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -0,0 +1,9 @@\n+## `dwarf-version`\n+\n+This option controls the version of DWARF that the compiler emits, on platforms\n+that use DWARF to encode debug information. It takes one of the following\n+values:\n+\n+* `2`: DWARF version 2 (the default on certain platforms, like macOS).\n+* `4`: DWARF version 4 (the default on certain platforms, like Linux).\n+* `5`: DWARF version 5."}, {"sha": "f41e6bd55be7ddb2a07a1fbccc8ce65577518f52", "filename": "src/test/assembly/dwarf5.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/src%2Ftest%2Fassembly%2Fdwarf5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/src%2Ftest%2Fassembly%2Fdwarf5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fdwarf5.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -0,0 +1,20 @@\n+// Makes sure that `-Z dwarf-version=5` causes `rustc` to emit DWARF version 5.\n+// assembly-output: emit-asm\n+// compile-flags: -g --target x86_64-unknown-linux-gnu -Z dwarf-version=5\n+// needs-llvm-components: x86\n+\n+#![feature(no_core, lang_items)]\n+#![crate_type = \"rlib\"]\n+#![no_core]\n+\n+#[lang = \"sized\"]\n+trait Sized {}\n+#[lang = \"copy\"]\n+trait Copy {}\n+\n+pub fn wibble() {}\n+\n+// CHECK: .section .debug_info\n+// CHECK-NOT: .short 2\n+// CHECK-NOT: .short 4\n+// CHECK: .short 5"}, {"sha": "14c0a1399a00ebd4b17f3d0bdbbbeac26515f076", "filename": "src/test/ui/consts/issue-96169.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/src%2Ftest%2Fui%2Fconsts%2Fissue-96169.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/src%2Ftest%2Fui%2Fconsts%2Fissue-96169.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-96169.rs?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -0,0 +1,18 @@\n+// check-pass\n+// compile-flags: -Zmir-opt-level=4 --emit=mir\n+#![allow(unused)]\n+fn a() -> usize { 0 }\n+\n+fn bar(_: u32) {}\n+\n+fn baz() -> *const dyn Fn(u32) { unimplemented!() }\n+\n+fn foo() {\n+    match () {\n+        _ if baz() == &bar as &dyn Fn(u32) => (),\n+        () => (),\n+    }\n+}\n+\n+fn main() {\n+}"}, {"sha": "8d0f75d204c2fcc9f4f82519c9d4b4829acc03c2", "filename": "src/test/ui/empty/empty-struct-tuple-pat.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/src%2Ftest%2Fui%2Fempty%2Fempty-struct-tuple-pat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/src%2Ftest%2Fui%2Fempty%2Fempty-struct-tuple-pat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fempty%2Fempty-struct-tuple-pat.stderr?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -5,7 +5,10 @@ LL | struct Empty2();\n    | ---------------- the tuple struct `Empty2` is defined here\n ...\n LL |         Empty2 => ()\n-   |         ^^^^^^ cannot be named the same as a tuple struct\n+   |         ^^^^^^\n+   |         |\n+   |         cannot be named the same as a tuple struct\n+   |         help: try specify the pattern arguments: `Empty2(..)`\n \n error[E0530]: match bindings cannot shadow tuple structs\n   --> $DIR/empty-struct-tuple-pat.rs:25:9\n@@ -14,7 +17,10 @@ LL | use empty_struct::*;\n    |     --------------- the tuple struct `XEmpty6` is imported here\n ...\n LL |         XEmpty6 => ()\n-   |         ^^^^^^^ cannot be named the same as a tuple struct\n+   |         ^^^^^^^\n+   |         |\n+   |         cannot be named the same as a tuple struct\n+   |         help: try specify the pattern arguments: `XEmpty6(..)`\n \n error[E0532]: expected unit struct, unit variant or constant, found tuple variant `E::Empty4`\n   --> $DIR/empty-struct-tuple-pat.rs:29:9"}, {"sha": "d9295746158bba78e2483c2700a7f1450de17cb8", "filename": "src/test/ui/pattern/pat-tuple-field-count-cross.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-field-count-cross.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-field-count-cross.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-field-count-cross.stderr?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -5,7 +5,10 @@ LL | use declarations_for_tuple_field_count_errors::*;\n    |     -------------------------------------------- the tuple struct `Z1` is imported here\n ...\n LL |         Z1 => {}\n-   |         ^^ cannot be named the same as a tuple struct\n+   |         ^^\n+   |         |\n+   |         cannot be named the same as a tuple struct\n+   |         help: try specify the pattern arguments: `Z1(..)`\n \n error[E0532]: expected tuple struct or tuple variant, found unit struct `Z0`\n   --> $DIR/pat-tuple-field-count-cross.rs:9:9"}, {"sha": "54d89e03101dcaf010c6dbc5773a8551198e5f7b", "filename": "src/test/ui/pattern/pat-tuple-overfield.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-overfield.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-overfield.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-overfield.stderr?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -5,7 +5,10 @@ LL | struct Z1();\n    | ------------ the tuple struct `Z1` is defined here\n ...\n LL |         Z1 => {}\n-   |         ^^ cannot be named the same as a tuple struct\n+   |         ^^\n+   |         |\n+   |         cannot be named the same as a tuple struct\n+   |         help: try specify the pattern arguments: `Z1(..)`\n \n error[E0532]: expected tuple struct or tuple variant, found unit struct `Z0`\n   --> $DIR/pat-tuple-overfield.rs:52:9"}, {"sha": "1529e538b5521a7ec99b1ee7b29548237a775604", "filename": "src/test/ui/pattern/pattern-binding-disambiguation.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c4693bc946729393c087fb120af566395915d19d/src%2Ftest%2Fui%2Fpattern%2Fpattern-binding-disambiguation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c4693bc946729393c087fb120af566395915d19d/src%2Ftest%2Fui%2Fpattern%2Fpattern-binding-disambiguation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpattern-binding-disambiguation.stderr?ref=c4693bc946729393c087fb120af566395915d19d", "patch": "@@ -5,7 +5,10 @@ LL | struct TupleStruct();\n    | --------------------- the tuple struct `TupleStruct` is defined here\n ...\n LL |         TupleStruct => {}\n-   |         ^^^^^^^^^^^ cannot be named the same as a tuple struct\n+   |         ^^^^^^^^^^^\n+   |         |\n+   |         cannot be named the same as a tuple struct\n+   |         help: try specify the pattern arguments: `TupleStruct(..)`\n \n error[E0530]: match bindings cannot shadow tuple variants\n   --> $DIR/pattern-binding-disambiguation.rs:33:9\n@@ -14,7 +17,10 @@ LL | use E::*;\n    |     ---- the tuple variant `TupleVariant` is imported here\n ...\n LL |         TupleVariant => {}\n-   |         ^^^^^^^^^^^^ cannot be named the same as a tuple variant\n+   |         ^^^^^^^^^^^^\n+   |         |\n+   |         cannot be named the same as a tuple variant\n+   |         help: try specify the pattern arguments: `TupleVariant(..)`\n \n error[E0530]: match bindings cannot shadow struct variants\n   --> $DIR/pattern-binding-disambiguation.rs:36:9"}]}