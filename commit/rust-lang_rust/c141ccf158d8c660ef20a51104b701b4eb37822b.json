{"sha": "c141ccf158d8c660ef20a51104b701b4eb37822b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxNDFjY2YxNThkOGM2NjBlZjIwYTUxMTA0YjcwMWI0ZWIzNzgyMmI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-23T17:04:33Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-27T16:12:49Z"}, "message": "Miri Memory Work\n\n* Unify the two maps in memory to store the allocation and its kind together.\n* Share the handling of statics between CTFE and miri: The miri engine always\n  uses \"lazy\" `AllocType::Static` when encountering a static.  Acessing that\n  static invokes CTFE (no matter the machine).  The machine only has any\n  influence when writing to a static, which CTFE outright rejects (but miri\n  makes a copy-on-write).\n* Add an `AllocId` to by-ref consts so miri can use them as operands without\n  making copies.\n* Move responsibilities around for the `eval_fn_call` machine hook: The hook\n  just has to find the MIR (or entirely take care of everything); pushing the\n  new stack frame is taken care of by the miri engine.\n* Expose the intrinsics and lang items implemented by CTFE so miri does not\n  have to reimplement them.", "tree": {"sha": "1e27be9f8ec89be350ca2423a7c3e8a5762e1400", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e27be9f8ec89be350ca2423a7c3e8a5762e1400"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c141ccf158d8c660ef20a51104b701b4eb37822b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c141ccf158d8c660ef20a51104b701b4eb37822b", "html_url": "https://github.com/rust-lang/rust/commit/c141ccf158d8c660ef20a51104b701b4eb37822b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c141ccf158d8c660ef20a51104b701b4eb37822b/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b638d8c75f4e38c75c5caa52b10b18a350431687", "url": "https://api.github.com/repos/rust-lang/rust/commits/b638d8c75f4e38c75c5caa52b10b18a350431687", "html_url": "https://github.com/rust-lang/rust/commit/b638d8c75f4e38c75c5caa52b10b18a350431687"}], "stats": {"total": 1180, "additions": 656, "deletions": 524}, "files": [{"sha": "6ee0eb273d6b51f8e480da0248bb2007ddfb66a2", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=c141ccf158d8c660ef20a51104b701b4eb37822b", "patch": "@@ -384,7 +384,8 @@ for ::mir::interpret::ConstValue<'gcx> {\n                 a.hash_stable(hcx, hasher);\n                 b.hash_stable(hcx, hasher);\n             }\n-            ByRef(alloc, offset) => {\n+            ByRef(id, alloc, offset) => {\n+                id.hash_stable(hcx, hasher);\n                 alloc.hash_stable(hcx, hasher);\n                 offset.hash_stable(hcx, hasher);\n             }\n@@ -446,7 +447,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::Allocation {\n         }\n         self.undef_mask.hash_stable(hcx, hasher);\n         self.align.hash_stable(hcx, hasher);\n-        self.runtime_mutability.hash_stable(hcx, hasher);\n+        self.mutability.hash_stable(hcx, hasher);\n     }\n }\n "}, {"sha": "147f9ccad7c38fbd87544ac1f2aab37512b148e2", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=c141ccf158d8c660ef20a51104b701b4eb37822b", "patch": "@@ -393,7 +393,8 @@ impl fmt::Display for AllocId {\n pub enum AllocType<'tcx, M> {\n     /// The alloc id is used as a function pointer\n     Function(Instance<'tcx>),\n-    /// The alloc id points to a static variable\n+    /// The alloc id points to a \"lazy\" static variable that did not get computed (yet).\n+    /// This is also used to break the cycle in recursive statics.\n     Static(DefId),\n     /// The alloc id points to memory\n     Memory(M)\n@@ -496,13 +497,14 @@ pub struct Allocation {\n     pub undef_mask: UndefMask,\n     /// The alignment of the allocation to detect unaligned reads.\n     pub align: Align,\n-    /// Whether the allocation (of a static) should be put into mutable memory when codegenning\n-    ///\n-    /// Only happens for `static mut` or `static` with interior mutability\n-    pub runtime_mutability: Mutability,\n+    /// Whether the allocation is mutable.\n+    /// Also used by codegen to determine if a static should be put into mutable memory,\n+    /// which happens for `static mut` and `static` with interior mutability.\n+    pub mutability: Mutability,\n }\n \n impl Allocation {\n+    /// Creates a read-only allocation initialized by the given bytes\n     pub fn from_bytes(slice: &[u8], align: Align) -> Self {\n         let mut undef_mask = UndefMask::new(Size::ZERO);\n         undef_mask.grow(Size::from_bytes(slice.len() as u64), true);\n@@ -511,7 +513,7 @@ impl Allocation {\n             relocations: Relocations::new(),\n             undef_mask,\n             align,\n-            runtime_mutability: Mutability::Immutable,\n+            mutability: Mutability::Immutable,\n         }\n     }\n \n@@ -526,7 +528,7 @@ impl Allocation {\n             relocations: Relocations::new(),\n             undef_mask: UndefMask::new(size),\n             align,\n-            runtime_mutability: Mutability::Immutable,\n+            mutability: Mutability::Mutable,\n         }\n     }\n }"}, {"sha": "958c50e69d246db55c2bb2df45dadfa65a13d8cd", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 81, "deletions": 3, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=c141ccf158d8c660ef20a51104b701b4eb37822b", "patch": "@@ -14,7 +14,7 @@ use ty::layout::{HasDataLayout, Size};\n use ty::subst::Substs;\n use hir::def_id::DefId;\n \n-use super::{EvalResult, Pointer, PointerArithmetic, Allocation};\n+use super::{EvalResult, Pointer, PointerArithmetic, Allocation, AllocId, sign_extend};\n \n /// Represents a constant value in Rust. Scalar and ScalarPair are optimizations which\n /// matches the LocalValue optimizations for easy conversions between Value and ConstValue.\n@@ -32,8 +32,9 @@ pub enum ConstValue<'tcx> {\n     ///\n     /// The second field may be undef in case of `Option<usize>::None`\n     ScalarPair(Scalar, ScalarMaybeUndef),\n-    /// Used only for the remaining cases. An allocation + offset into the allocation\n-    ByRef(&'tcx Allocation, Size),\n+    /// Used only for the remaining cases. An allocation + offset into the allocation.\n+    /// Invariant: The AllocId matches the allocation.\n+    ByRef(AllocId, &'tcx Allocation, Size),\n }\n \n impl<'tcx> ConstValue<'tcx> {\n@@ -185,6 +186,49 @@ impl<'tcx> Scalar {\n             _ => err!(InvalidBool),\n         }\n     }\n+\n+    fn to_u8(self) -> EvalResult<'static, u8> {\n+        let sz = Size::from_bits(8);\n+        let b = self.to_bits(sz)?;\n+        assert_eq!(b as u8 as u128, b);\n+        Ok(b as u8)\n+    }\n+\n+    fn to_u32(self) -> EvalResult<'static, u32> {\n+        let sz = Size::from_bits(32);\n+        let b = self.to_bits(sz)?;\n+        assert_eq!(b as u32 as u128, b);\n+        Ok(b as u32)\n+    }\n+\n+    fn to_usize(self, cx: impl HasDataLayout) -> EvalResult<'static, u64> {\n+        let b = self.to_bits(cx.data_layout().pointer_size)?;\n+        assert_eq!(b as u64 as u128, b);\n+        Ok(b as u64)\n+    }\n+\n+    fn to_i8(self) -> EvalResult<'static, i8> {\n+        let sz = Size::from_bits(8);\n+        let b = self.to_bits(sz)?;\n+        let b = sign_extend(b, sz) as i128;\n+        assert_eq!(b as i8 as i128, b);\n+        Ok(b as i8)\n+    }\n+\n+    fn to_i32(self) -> EvalResult<'static, i32> {\n+        let sz = Size::from_bits(32);\n+        let b = self.to_bits(sz)?;\n+        let b = sign_extend(b, sz) as i128;\n+        assert_eq!(b as i32 as i128, b);\n+        Ok(b as i32)\n+    }\n+\n+    fn to_isize(self, cx: impl HasDataLayout) -> EvalResult<'static, i64> {\n+        let b = self.to_bits(cx.data_layout().pointer_size)?;\n+        let b = sign_extend(b, cx.data_layout().pointer_size) as i128;\n+        assert_eq!(b as i64 as i128, b);\n+        Ok(b as i64)\n+    }\n }\n \n impl From<Pointer> for Scalar {\n@@ -228,22 +272,56 @@ impl From<Scalar> for ScalarMaybeUndef {\n }\n \n impl<'tcx> ScalarMaybeUndef {\n+    #[inline]\n     pub fn not_undef(self) -> EvalResult<'static, Scalar> {\n         match self {\n             ScalarMaybeUndef::Scalar(scalar) => Ok(scalar),\n             ScalarMaybeUndef::Undef => err!(ReadUndefBytes),\n         }\n     }\n \n+    #[inline(always)]\n     pub fn to_ptr(self) -> EvalResult<'tcx, Pointer> {\n         self.not_undef()?.to_ptr()\n     }\n \n+    #[inline(always)]\n     pub fn to_bits(self, target_size: Size) -> EvalResult<'tcx, u128> {\n         self.not_undef()?.to_bits(target_size)\n     }\n \n+    #[inline(always)]\n     pub fn to_bool(self) -> EvalResult<'tcx, bool> {\n         self.not_undef()?.to_bool()\n     }\n+\n+    #[inline(always)]\n+    pub fn to_u8(self) -> EvalResult<'tcx, u8> {\n+        self.not_undef()?.to_u8()\n+    }\n+\n+    #[inline(always)]\n+    pub fn to_u32(self) -> EvalResult<'tcx, u32> {\n+        self.not_undef()?.to_u32()\n+    }\n+\n+    #[inline(always)]\n+    pub fn to_usize(self, cx: impl HasDataLayout) -> EvalResult<'tcx, u64> {\n+        self.not_undef()?.to_usize(cx)\n+    }\n+\n+    #[inline(always)]\n+    pub fn to_i8(self) -> EvalResult<'tcx, i8> {\n+        self.not_undef()?.to_i8()\n+    }\n+\n+    #[inline(always)]\n+    pub fn to_i32(self) -> EvalResult<'tcx, i32> {\n+        self.not_undef()?.to_i32()\n+    }\n+\n+    #[inline(always)]\n+    pub fn to_isize(self, cx: impl HasDataLayout) -> EvalResult<'tcx, i64> {\n+        self.not_undef()?.to_isize(cx)\n+    }\n }"}, {"sha": "b10e9f14158696be4707abefdd536e17c18aa1f6", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=c141ccf158d8c660ef20a51104b701b4eb37822b", "patch": "@@ -1043,13 +1043,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         let interned = self.global_arenas.const_allocs.alloc(alloc);\n-        if let Some(prev) = allocs.replace(interned) {\n+        if let Some(prev) = allocs.replace(interned) { // insert into interner\n             bug!(\"Tried to overwrite interned Allocation: {:#?}\", prev)\n         }\n         interned\n     }\n \n-    /// Allocates a byte or string literal for `mir::interpret`\n+    /// Allocates a byte or string literal for `mir::interpret`, read-only\n     pub fn allocate_bytes(self, bytes: &[u8]) -> interpret::AllocId {\n         // create an allocation that just contains these bytes\n         let alloc = interpret::Allocation::from_byte_aligned_bytes(bytes);"}, {"sha": "55a1eadb06f1137c26ad77b171ee018853f9bcd5", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=c141ccf158d8c660ef20a51104b701b4eb37822b", "patch": "@@ -1139,7 +1139,7 @@ impl<'tcx> TypeFoldable<'tcx> for ConstValue<'tcx> {\n         match *self {\n             ConstValue::Scalar(v) => ConstValue::Scalar(v),\n             ConstValue::ScalarPair(a, b) => ConstValue::ScalarPair(a, b),\n-            ConstValue::ByRef(alloc, offset) => ConstValue::ByRef(alloc, offset),\n+            ConstValue::ByRef(id, alloc, offset) => ConstValue::ByRef(id, alloc, offset),\n             ConstValue::Unevaluated(def_id, substs) => {\n                 ConstValue::Unevaluated(def_id, substs.fold_with(folder))\n             }\n@@ -1150,7 +1150,7 @@ impl<'tcx> TypeFoldable<'tcx> for ConstValue<'tcx> {\n         match *self {\n             ConstValue::Scalar(_) |\n             ConstValue::ScalarPair(_, _) |\n-            ConstValue::ByRef(_, _) => false,\n+            ConstValue::ByRef(_, _, _) => false,\n             ConstValue::Unevaluated(_, substs) => substs.visit_with(visitor),\n         }\n     }"}, {"sha": "b6c9658dd6fc36f67fe5c0cef76e43d7464c4a62", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=c141ccf158d8c660ef20a51104b701b4eb37822b", "patch": "@@ -57,7 +57,7 @@ pub fn scalar_to_llvm(\n             let base_addr = match alloc_type {\n                 Some(AllocType::Memory(alloc)) => {\n                     let init = const_alloc_to_llvm(cx, alloc);\n-                    if alloc.runtime_mutability == Mutability::Mutable {\n+                    if alloc.mutability == Mutability::Mutable {\n                         consts::addr_of_mut(cx, init, alloc.align, None)\n                     } else {\n                         consts::addr_of(cx, init, alloc.align, None)\n@@ -134,7 +134,7 @@ pub fn codegen_static_initializer(\n     let static_ = cx.tcx.const_eval(param_env.and(cid))?;\n \n     let alloc = match static_.val {\n-        ConstValue::ByRef(alloc, n) if n.bytes() == 0 => alloc,\n+        ConstValue::ByRef(_, alloc, n) if n.bytes() == 0 => alloc,\n         _ => bug!(\"static const eval returned {:#?}\", static_),\n     };\n     Ok((const_alloc_to_llvm(cx, alloc), alloc))"}, {"sha": "419e7298588c595f95aad5a2d2e70fa2da1b65b8", "filename": "src/librustc_codegen_llvm/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs?ref=c141ccf158d8c660ef20a51104b701b4eb37822b", "patch": "@@ -126,7 +126,7 @@ impl OperandRef<'ll, 'tcx> {\n                 };\n                 OperandValue::Pair(a_llval, b_llval)\n             },\n-            ConstValue::ByRef(alloc, offset) => {\n+            ConstValue::ByRef(_, alloc, offset) => {\n                 return Ok(PlaceRef::from_const_alloc(bx, layout, alloc, offset).load(bx));\n             },\n         };"}, {"sha": "833dca8c75fd52ed4dc753f83e346e163a36b801", "filename": "src/librustc_codegen_llvm/mir/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs?ref=c141ccf158d8c660ef20a51104b701b4eb37822b", "patch": "@@ -458,7 +458,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                 let layout = cx.layout_of(self.monomorphize(&ty));\n                 match bx.tcx().const_eval(param_env.and(cid)) {\n                     Ok(val) => match val.val {\n-                        mir::interpret::ConstValue::ByRef(alloc, offset) => {\n+                        mir::interpret::ConstValue::ByRef(_, alloc, offset) => {\n                             PlaceRef::from_const_alloc(bx, layout, alloc, offset)\n                         }\n                         _ => bug!(\"promoteds should have an allocation: {:?}\", val),"}, {"sha": "dbdaf0aab34ea33fb9a7175d3765a675c1f9d38f", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 92, "deletions": 217, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=c141ccf158d8c660ef20a51104b701b4eb37822b", "patch": "@@ -14,23 +14,22 @@ use std::error::Error;\n use rustc::hir;\n use rustc::mir::interpret::ConstEvalErr;\n use rustc::mir;\n-use rustc::ty::{self, TyCtxt, Instance};\n-use rustc::ty::layout::{LayoutOf, Primitive, TyLayout, Size};\n+use rustc::ty::{self, ParamEnv, TyCtxt, Instance, query::TyCtxtAt};\n+use rustc::ty::layout::{LayoutOf, TyLayout};\n use rustc::ty::subst::Subst;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n use syntax::ast::Mutability;\n use syntax::source_map::Span;\n use syntax::source_map::DUMMY_SP;\n-use syntax::symbol::Symbol;\n \n use rustc::mir::interpret::{\n     EvalResult, EvalError, EvalErrorKind, GlobalId,\n-    Scalar, AllocId, Allocation, ConstValue,\n+    Scalar, AllocId, Allocation, ConstValue, AllocType,\n };\n use super::{\n     Place, PlaceExtra, PlaceTy, MemPlace, OpTy, Operand, Value,\n-    EvalContext, StackPopCleanup, Memory, MemoryKind, MPlaceTy,\n+    EvalContext, StackPopCleanup, MemoryKind, Memory,\n };\n \n pub fn mk_borrowck_eval_cx<'a, 'mir, 'tcx>(\n@@ -50,7 +49,7 @@ pub fn mk_borrowck_eval_cx<'a, 'mir, 'tcx>(\n         span,\n         mir,\n         return_place: Place::null(tcx),\n-        return_to_block: StackPopCleanup::None,\n+        return_to_block: StackPopCleanup::Goto(None), // never pop\n         stmt: 0,\n     });\n     Ok(ecx)\n@@ -71,7 +70,7 @@ pub fn mk_eval_cx<'a, 'tcx>(\n         mir.span,\n         mir,\n         Place::null(tcx),\n-        StackPopCleanup::None,\n+        StackPopCleanup::Goto(None), // never pop\n     )?;\n     Ok(ecx)\n }\n@@ -110,8 +109,10 @@ pub fn op_to_const<'tcx>(\n             assert!(alloc.bytes.len() as u64 - ptr.offset.bytes() >= op.layout.size.bytes());\n             let mut alloc = alloc.clone();\n             alloc.align = align;\n+            // FIXME shouldnt it be the case that `mark_static_initialized` has already\n+            // interned this?  I thought that is the entire point of that `FinishStatic` stuff?\n             let alloc = ecx.tcx.intern_const_alloc(alloc);\n-            ConstValue::ByRef(alloc, ptr.offset)\n+            ConstValue::ByRef(ptr.alloc_id, alloc, ptr.offset)\n         },\n         Ok(Value::Scalar(x)) =>\n             ConstValue::Scalar(x.not_undef()?),\n@@ -134,7 +135,6 @@ fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n     mir: Option<&'mir mir::Mir<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n ) -> (EvalResult<'tcx, OpTy<'tcx>>, EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator>) {\n-    debug!(\"eval_body_and_ecx: {:?}, {:?}\", cid, param_env);\n     // we start out with the best span we have\n     // and try improving it down the road when more information is available\n     let span = tcx.def_span(cid.instance.def_id());\n@@ -151,7 +151,7 @@ fn eval_body_using_ecx<'a, 'mir, 'tcx>(\n     mir: Option<&'mir mir::Mir<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n ) -> EvalResult<'tcx, OpTy<'tcx>> {\n-    debug!(\"eval_body: {:?}, {:?}\", cid, param_env);\n+    debug!(\"eval_body_using_ecx: {:?}, {:?}\", cid, param_env);\n     let tcx = ecx.tcx.tcx;\n     let mut mir = match mir {\n         Some(mir) => mir,\n@@ -170,10 +170,11 @@ fn eval_body_using_ecx<'a, 'mir, 'tcx>(\n     } else {\n         Mutability::Immutable\n     };\n-    let cleanup = StackPopCleanup::MarkStatic(mutability);\n+    let cleanup = StackPopCleanup::FinishStatic(mutability);\n+\n     let name = ty::tls::with(|tcx| tcx.item_path_str(cid.instance.def_id()));\n     let prom = cid.promoted.map_or(String::new(), |p| format!(\"::promoted[{:?}]\", p));\n-    trace!(\"const_eval: pushing stack frame for global: {}{}\", name, prom);\n+    trace!(\"eval_body_using_ecx: pushing stack frame for global: {}{}\", name, prom);\n     assert!(mir.arg_count == 0);\n     ecx.push_stack_frame(\n         cid.instance,\n@@ -184,8 +185,9 @@ fn eval_body_using_ecx<'a, 'mir, 'tcx>(\n     )?;\n \n     // The main interpreter loop.\n-    while ecx.step()? {}\n+    ecx.run()?;\n \n+    debug!(\"eval_body_using_ecx done: {:?}\", *ret);\n     Ok(ret.into())\n }\n \n@@ -234,72 +236,36 @@ impl Error for ConstEvalError {\n     }\n }\n \n+impl super::IsStatic for ! {\n+    fn is_static(self) -> bool {\n+        // unreachable\n+        self\n+    }\n+}\n+\n impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n     type MemoryData = ();\n     type MemoryKinds = !;\n-    fn eval_fn_call<'a>(\n+\n+    fn find_fn<'a>(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n         args: &[OpTy<'tcx>],\n-        span: Span,\n-    ) -> EvalResult<'tcx, bool> {\n+        dest: Option<PlaceTy<'tcx>>,\n+        ret: Option<mir::BasicBlock>,\n+    ) -> EvalResult<'tcx, Option<&'mir mir::Mir<'tcx>>> {\n         debug!(\"eval_fn_call: {:?}\", instance);\n+        if ecx.hook_fn(instance, args, dest)? {\n+            ecx.goto_block(ret)?; // fully evaluated and done\n+            return Ok(None);\n+        }\n         if !ecx.tcx.is_const_fn(instance.def_id()) {\n-            let def_id = instance.def_id();\n-            // Some fn calls are actually BinOp intrinsics\n-            let _: ! = if let Some((op, oflo)) = ecx.tcx.is_binop_lang_item(def_id) {\n-                let (dest, bb) = destination.expect(\"128 lowerings can't diverge\");\n-                let l = ecx.read_value(args[0])?;\n-                let r = ecx.read_value(args[1])?;\n-                if oflo {\n-                    ecx.binop_with_overflow(op, l, r, dest)?;\n-                } else {\n-                    ecx.binop_ignore_overflow(op, l, r, dest)?;\n-                }\n-                ecx.goto_block(bb);\n-                return Ok(true);\n-            } else if Some(def_id) == ecx.tcx.lang_items().panic_fn() {\n-                assert!(args.len() == 1);\n-                // &(&'static str, &'static str, u32, u32)\n-                let ptr = ecx.read_value(args[0])?;\n-                let place = ecx.ref_to_mplace(ptr)?;\n-                let (msg, file, line, col) = (\n-                    place_field(ecx, 0, place)?,\n-                    place_field(ecx, 1, place)?,\n-                    place_field(ecx, 2, place)?,\n-                    place_field(ecx, 3, place)?,\n-                );\n-\n-                let msg = to_str(ecx, msg)?;\n-                let file = to_str(ecx, file)?;\n-                let line = to_u32(line)?;\n-                let col = to_u32(col)?;\n-                return Err(EvalErrorKind::Panic { msg, file, line, col }.into());\n-            } else if Some(def_id) == ecx.tcx.lang_items().begin_panic_fn() {\n-                assert!(args.len() == 2);\n-                // &'static str, &(&'static str, u32, u32)\n-                let msg = ecx.read_value(args[0])?;\n-                let ptr = ecx.read_value(args[1])?;\n-                let place = ecx.ref_to_mplace(ptr)?;\n-                let (file, line, col) = (\n-                    place_field(ecx, 0, place)?,\n-                    place_field(ecx, 1, place)?,\n-                    place_field(ecx, 2, place)?,\n-                );\n-\n-                let msg = to_str(ecx, msg.value)?;\n-                let file = to_str(ecx, file)?;\n-                let line = to_u32(line)?;\n-                let col = to_u32(col)?;\n-                return Err(EvalErrorKind::Panic { msg, file, line, col }.into());\n-            } else {\n-                return Err(\n-                    ConstEvalError::NotConst(format!(\"calling non-const fn `{}`\", instance)).into(),\n-                );\n-            };\n+            return Err(\n+                ConstEvalError::NotConst(format!(\"calling non-const fn `{}`\", instance)).into(),\n+            );\n         }\n-        let mir = match ecx.load_mir(instance.def) {\n+        // This is a const fn. Call it.\n+        Ok(Some(match ecx.load_mir(instance.def) {\n             Ok(mir) => mir,\n             Err(err) => {\n                 if let EvalErrorKind::NoMirFor(ref path) = err.kind {\n@@ -310,94 +276,23 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n                 }\n                 return Err(err);\n             }\n-        };\n-        let (return_place, return_to_block) = match destination {\n-            Some((place, block)) => (*place, StackPopCleanup::Goto(block)),\n-            None => (Place::null(&ecx), StackPopCleanup::None),\n-        };\n-\n-        ecx.push_stack_frame(\n-            instance,\n-            span,\n-            mir,\n-            return_place,\n-            return_to_block,\n-        )?;\n-\n-        Ok(false)\n+        }))\n     }\n \n-\n     fn call_intrinsic<'a>(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n         dest: PlaceTy<'tcx>,\n-        target: mir::BasicBlock,\n     ) -> EvalResult<'tcx> {\n-        let substs = instance.substs;\n-\n-        let intrinsic_name = &ecx.tcx.item_name(instance.def_id()).as_str()[..];\n-        match intrinsic_name {\n-            \"min_align_of\" => {\n-                let elem_ty = substs.type_at(0);\n-                let elem_align = ecx.layout_of(elem_ty)?.align.abi();\n-                let align_val = Scalar::Bits {\n-                    bits: elem_align as u128,\n-                    size: dest.layout.size.bytes() as u8,\n-                };\n-                ecx.write_scalar(align_val, dest)?;\n-            }\n-\n-            \"size_of\" => {\n-                let ty = substs.type_at(0);\n-                let size = ecx.layout_of(ty)?.size.bytes() as u128;\n-                let size_val = Scalar::Bits {\n-                    bits: size,\n-                    size: dest.layout.size.bytes() as u8,\n-                };\n-                ecx.write_scalar(size_val, dest)?;\n-            }\n-\n-            \"type_id\" => {\n-                let ty = substs.type_at(0);\n-                let type_id = ecx.tcx.type_id_hash(ty) as u128;\n-                let id_val = Scalar::Bits {\n-                    bits: type_id,\n-                    size: dest.layout.size.bytes() as u8,\n-                };\n-                ecx.write_scalar(id_val, dest)?;\n-            }\n-            \"ctpop\" | \"cttz\" | \"cttz_nonzero\" | \"ctlz\" | \"ctlz_nonzero\" | \"bswap\" => {\n-                let ty = substs.type_at(0);\n-                let layout_of = ecx.layout_of(ty)?;\n-                let bits = ecx.read_scalar(args[0])?.to_bits(layout_of.size)?;\n-                let kind = match layout_of.abi {\n-                    ty::layout::Abi::Scalar(ref scalar) => scalar.value,\n-                    _ => Err(::rustc::mir::interpret::EvalErrorKind::TypeNotPrimitive(ty))?,\n-                };\n-                let out_val = if intrinsic_name.ends_with(\"_nonzero\") {\n-                    if bits == 0 {\n-                        return err!(Intrinsic(format!(\"{} called on 0\", intrinsic_name)));\n-                    }\n-                    numeric_intrinsic(intrinsic_name.trim_right_matches(\"_nonzero\"), bits, kind)?\n-                } else {\n-                    numeric_intrinsic(intrinsic_name, bits, kind)?\n-                };\n-                ecx.write_scalar(out_val, dest)?;\n-            }\n-\n-            name => return Err(\n-                ConstEvalError::NeedsRfc(format!(\"calling intrinsic `{}`\", name)).into()\n-            ),\n+        if ecx.emulate_intrinsic(instance, args, dest)? {\n+            return Ok(());\n         }\n-\n-        ecx.goto_block(target);\n-\n-        // Since we pushed no stack frame, the main loop will act\n-        // as if the call just completed and it's returning to the\n-        // current frame.\n-        Ok(())\n+        // An intrinsic that we do not support\n+        let intrinsic_name = &ecx.tcx.item_name(instance.def_id()).as_str()[..];\n+        Err(\n+            ConstEvalError::NeedsRfc(format!(\"calling intrinsic `{}`\", intrinsic_name)).into()\n+        )\n     }\n \n     fn try_ptr_op<'a>(\n@@ -417,23 +312,17 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n         }\n     }\n \n-    fn mark_static_initialized<'a>(\n-        _mem: &mut Memory<'a, 'mir, 'tcx, Self>,\n-        _id: AllocId,\n-        _mutability: Mutability,\n-    ) -> EvalResult<'tcx, bool> {\n-        Ok(false)\n-    }\n-\n-    fn init_static<'a>(\n-        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        cid: GlobalId<'tcx>,\n-    ) -> EvalResult<'tcx, AllocId> {\n-        Ok(ecx\n-            .tcx\n-            .alloc_map\n-            .lock()\n-            .intern_static(cid.instance.def_id()))\n+    fn access_static_mut<'a, 'm>(\n+        mem: &'m mut Memory<'a, 'mir, 'tcx, Self>,\n+        id: AllocId,\n+    ) -> EvalResult<'tcx, &'m mut Allocation> {\n+        // This is always an error, we do not allow mutating statics\n+        match mem.tcx.alloc_map.lock().get(id) {\n+            Some(AllocType::Memory(..)) |\n+            Some(AllocType::Static(..)) => err!(ModifiedConstantMemory),\n+            Some(AllocType::Function(..)) => err!(DerefFunctionPointer),\n+            None => err!(DanglingPointerDeref),\n+        }\n     }\n \n     fn box_alloc<'a>(\n@@ -456,40 +345,6 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n     }\n }\n \n-fn place_field<'a, 'tcx, 'mir>(\n-    ecx: &mut EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator>,\n-    i: u64,\n-    place: MPlaceTy<'tcx>,\n-) -> EvalResult<'tcx, Value> {\n-    let place = ecx.mplace_field(place, i)?;\n-    Ok(ecx.try_read_value_from_mplace(place)?.expect(\"bad panic arg layout\"))\n-}\n-\n-fn to_str<'a, 'tcx, 'mir>(\n-    ecx: &mut EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator>,\n-    val: Value,\n-) -> EvalResult<'tcx, Symbol> {\n-    if let Value::ScalarPair(ptr, len) = val {\n-        let len = len.not_undef()?.to_bits(ecx.memory.pointer_size())?;\n-        let bytes = ecx.memory.read_bytes(ptr.not_undef()?, Size::from_bytes(len as u64))?;\n-        let str = ::std::str::from_utf8(bytes)\n-            .map_err(|err| EvalErrorKind::ValidationFailure(err.to_string()))?;\n-        Ok(Symbol::intern(str))\n-    } else {\n-        bug!(\"panic arg is not a str\")\n-    }\n-}\n-\n-fn to_u32<'a, 'tcx, 'mir>(\n-    val: Value,\n-) -> EvalResult<'tcx, u32> {\n-    if let Value::Scalar(n) = val {\n-        Ok(n.not_undef()?.to_bits(Size::from_bits(32))? as u32)\n-    } else {\n-        bug!(\"panic arg is not a str\")\n-    }\n-}\n-\n /// Project to a field of a (variant of a) const\n pub fn const_field<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -542,7 +397,7 @@ pub fn const_to_allocation_provider<'a, 'tcx>(\n     val: &'tcx ty::Const<'tcx>,\n ) -> &'tcx Allocation {\n     match val.val {\n-        ConstValue::ByRef(alloc, offset) => {\n+        ConstValue::ByRef(_, alloc, offset) => {\n             assert_eq!(offset.bytes(), 0);\n             return alloc;\n         },\n@@ -627,22 +482,42 @@ pub fn const_eval_provider<'a, 'tcx>(\n     })\n }\n \n-fn numeric_intrinsic<'tcx>(\n-    name: &str,\n-    bits: u128,\n-    kind: Primitive,\n-) -> EvalResult<'tcx, Scalar> {\n-    let size = match kind {\n-        Primitive::Int(integer, _) => integer.size(),\n-        _ => bug!(\"invalid `{}` argument: {:?}\", name, bits),\n+\n+/// Helper function to obtain the global (tcx) allocation for a static\n+pub fn static_alloc<'a, 'tcx>(\n+    tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n+    id: AllocId,\n+) -> EvalResult<'tcx, &'tcx Allocation> {\n+    let alloc = tcx.alloc_map.lock().get(id);\n+    let def_id = match alloc {\n+        Some(AllocType::Memory(mem)) => {\n+            return Ok(mem)\n+        }\n+        Some(AllocType::Function(..)) => {\n+            return err!(DerefFunctionPointer)\n+        }\n+        Some(AllocType::Static(did)) => {\n+            did\n+        }\n+        None =>\n+            return err!(DanglingPointerDeref),\n     };\n-    let extra = 128 - size.bits() as u128;\n-    let bits_out = match name {\n-        \"ctpop\" => bits.count_ones() as u128,\n-        \"ctlz\" => bits.leading_zeros() as u128 - extra,\n-        \"cttz\" => (bits << extra).trailing_zeros() as u128 - extra,\n-        \"bswap\" => (bits << extra).swap_bytes(),\n-        _ => bug!(\"not a numeric intrinsic: {}\", name),\n+    // We got a \"lazy\" static that has not been computed yet, do some work\n+    trace!(\"static_alloc: Need to compute {:?}\", def_id);\n+    if tcx.is_foreign_item(def_id) {\n+        return err!(ReadForeignStatic);\n+    }\n+    let instance = Instance::mono(tcx.tcx, def_id);\n+    let gid = GlobalId {\n+        instance,\n+        promoted: None,\n     };\n-    Ok(Scalar::Bits { bits: bits_out, size: size.bytes() as u8 })\n+    tcx.const_eval(ParamEnv::reveal_all().and(gid)).map_err(|err| {\n+        // no need to report anything, the const_eval call takes care of that for statics\n+        assert!(tcx.is_static(def_id).is_some());\n+        EvalErrorKind::ReferencedConstant(err).into()\n+    }).map(|val| {\n+        // FIXME We got our static (will be a ByRef), now we make a *copy*?!?\n+        tcx.const_to_allocation(val)\n+    })\n }"}, {"sha": "a20778d96929f2e914d6cff5cf30416a41721e5d", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 26, "deletions": 30, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=c141ccf158d8c660ef20a51104b701b4eb37822b", "patch": "@@ -85,7 +85,7 @@ pub struct Frame<'mir, 'tcx: 'mir> {\n     ////////////////////////////////////////////////////////////////////////////////\n     // Return place and locals\n     ////////////////////////////////////////////////////////////////////////////////\n-    /// The block to return to when returning from the current stack frame\n+    /// Work to perform when returning from this function\n     pub return_to_block: StackPopCleanup,\n \n     /// The location where the result of the current stack frame should be written to.\n@@ -157,6 +157,19 @@ impl<'mir, 'tcx: 'mir> Hash for Frame<'mir, 'tcx> {\n     }\n }\n \n+#[derive(Clone, Debug, Eq, PartialEq, Hash)]\n+pub enum StackPopCleanup {\n+    /// The stackframe existed to compute the initial value of a static/constant.\n+    /// Call `M::intern_static` on the return value and all allocations it references\n+    /// when this is done.  Must have a valid pointer as return place.\n+    FinishStatic(Mutability),\n+    /// Jump to the next block in the caller, or cause UB if None (that's a function\n+    /// that may never return).\n+    Goto(Option<mir::BasicBlock>),\n+    /// Just do nohing: Used by Main and for the box_alloc hook in miri\n+    None,\n+}\n+\n // State of a local variable\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub enum LocalValue {\n@@ -251,20 +264,6 @@ impl<'a, 'mir, 'tcx, M> InfiniteLoopDetector<'a, 'mir, 'tcx, M>\n     }\n }\n \n-#[derive(Clone, Debug, Eq, PartialEq, Hash)]\n-pub enum StackPopCleanup {\n-    /// The stackframe existed to compute the initial value of a static/constant, make sure it\n-    /// isn't modifyable afterwards in case of constants.\n-    /// In case of `static mut`, mark the memory to ensure it's never marked as immutable through\n-    /// references or deallocated\n-    MarkStatic(Mutability),\n-    /// A regular stackframe added due to a function call will need to get forwarded to the next\n-    /// block\n-    Goto(mir::BasicBlock),\n-    /// The main function and diverging functions have nowhere to return to\n-    None,\n-}\n-\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for &'a EvalContext<'a, 'mir, 'tcx, M> {\n     #[inline]\n     fn data_layout(&self) -> &layout::TargetDataLayout {\n@@ -388,7 +387,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     }\n \n     pub fn str_to_value(&mut self, s: &str) -> EvalResult<'tcx, Value> {\n-        let ptr = self.memory.allocate_bytes(s.as_bytes());\n+        let ptr = self.memory.allocate_static_bytes(s.as_bytes());\n         Ok(Value::new_slice(Scalar::Ptr(ptr), s.len() as u64, self.tcx.tcx))\n     }\n \n@@ -628,25 +627,22 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n     pub(super) fn pop_stack_frame(&mut self) -> EvalResult<'tcx> {\n         ::log_settings::settings().indentation -= 1;\n-        M::end_region(self, None)?;\n         let frame = self.stack.pop().expect(\n             \"tried to pop a stack frame, but there were none\",\n         );\n         match frame.return_to_block {\n-            StackPopCleanup::MarkStatic(mutable) => {\n-                if let Place::Ptr(MemPlace { ptr, .. }) = frame.return_place {\n-                    // FIXME: to_ptr()? might be too extreme here,\n-                    // static zsts might reach this under certain conditions\n-                    self.memory.mark_static_initialized(\n-                        ptr.to_ptr()?.alloc_id,\n-                        mutable,\n-                    )?\n-                } else {\n-                    bug!(\"StackPopCleanup::MarkStatic on: {:?}\", frame.return_place);\n-                }\n+            StackPopCleanup::FinishStatic(mutability) => {\n+                let mplace = frame.return_place.to_mem_place();\n+                // to_ptr should be okay here; it is the responsibility of whoever pushed\n+                // this frame to make sure that this works.\n+                let ptr = mplace.ptr.to_ptr()?;\n+                assert_eq!(ptr.offset.bytes(), 0);\n+                self.memory.mark_static_initialized(ptr.alloc_id, mutability)?;\n+            }\n+            StackPopCleanup::Goto(block) => {\n+                self.goto_block(block)?;\n             }\n-            StackPopCleanup::Goto(target) => self.goto_block(target),\n-            StackPopCleanup::None => {}\n+            StackPopCleanup::None => { }\n         }\n         // deallocate all locals that are backed by an allocation\n         for local in frame.locals {"}, {"sha": "f53bb6fcd79a89f793299b6def8e187427d6b3c8", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=c141ccf158d8c660ef20a51104b701b4eb37822b", "patch": "@@ -0,0 +1,171 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Intrinsics and other functions that the miri engine executes without\n+//! looking at their MIR.  Intrinsics/functions supported here are shared by CTFE\n+//! and miri.\n+\n+use syntax::symbol::Symbol;\n+use rustc::ty;\n+use rustc::ty::layout::{LayoutOf, Primitive};\n+use rustc::mir::interpret::{\n+    EvalResult, EvalErrorKind, Scalar,\n+};\n+\n+use super::{\n+    Machine, PlaceTy, OpTy, EvalContext,\n+};\n+\n+\n+fn numeric_intrinsic<'tcx>(\n+    name: &str,\n+    bits: u128,\n+    kind: Primitive,\n+) -> EvalResult<'tcx, Scalar> {\n+    let size = match kind {\n+        Primitive::Int(integer, _) => integer.size(),\n+        _ => bug!(\"invalid `{}` argument: {:?}\", name, bits),\n+    };\n+    let extra = 128 - size.bits() as u128;\n+    let bits_out = match name {\n+        \"ctpop\" => bits.count_ones() as u128,\n+        \"ctlz\" => bits.leading_zeros() as u128 - extra,\n+        \"cttz\" => (bits << extra).trailing_zeros() as u128 - extra,\n+        \"bswap\" => (bits << extra).swap_bytes(),\n+        _ => bug!(\"not a numeric intrinsic: {}\", name),\n+    };\n+    Ok(Scalar::Bits { bits: bits_out, size: size.bytes() as u8 })\n+}\n+\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+    /// Returns whether emulation happened.\n+    pub fn emulate_intrinsic(\n+        &mut self,\n+        instance: ty::Instance<'tcx>,\n+        args: &[OpTy<'tcx>],\n+        dest: PlaceTy<'tcx>,\n+    ) -> EvalResult<'tcx, bool> {\n+        let substs = instance.substs;\n+\n+        let intrinsic_name = &self.tcx.item_name(instance.def_id()).as_str()[..];\n+        match intrinsic_name {\n+            \"min_align_of\" => {\n+                let elem_ty = substs.type_at(0);\n+                let elem_align = self.layout_of(elem_ty)?.align.abi();\n+                let align_val = Scalar::Bits {\n+                    bits: elem_align as u128,\n+                    size: dest.layout.size.bytes() as u8,\n+                };\n+                self.write_scalar(align_val, dest)?;\n+            }\n+\n+            \"size_of\" => {\n+                let ty = substs.type_at(0);\n+                let size = self.layout_of(ty)?.size.bytes() as u128;\n+                let size_val = Scalar::Bits {\n+                    bits: size,\n+                    size: dest.layout.size.bytes() as u8,\n+                };\n+                self.write_scalar(size_val, dest)?;\n+            }\n+\n+            \"type_id\" => {\n+                let ty = substs.type_at(0);\n+                let type_id = self.tcx.type_id_hash(ty) as u128;\n+                let id_val = Scalar::Bits {\n+                    bits: type_id,\n+                    size: dest.layout.size.bytes() as u8,\n+                };\n+                self.write_scalar(id_val, dest)?;\n+            }\n+            \"ctpop\" | \"cttz\" | \"cttz_nonzero\" | \"ctlz\" | \"ctlz_nonzero\" | \"bswap\" => {\n+                let ty = substs.type_at(0);\n+                let layout_of = self.layout_of(ty)?;\n+                let bits = self.read_scalar(args[0])?.to_bits(layout_of.size)?;\n+                let kind = match layout_of.abi {\n+                    ty::layout::Abi::Scalar(ref scalar) => scalar.value,\n+                    _ => Err(::rustc::mir::interpret::EvalErrorKind::TypeNotPrimitive(ty))?,\n+                };\n+                let out_val = if intrinsic_name.ends_with(\"_nonzero\") {\n+                    if bits == 0 {\n+                        return err!(Intrinsic(format!(\"{} called on 0\", intrinsic_name)));\n+                    }\n+                    numeric_intrinsic(intrinsic_name.trim_right_matches(\"_nonzero\"), bits, kind)?\n+                } else {\n+                    numeric_intrinsic(intrinsic_name, bits, kind)?\n+                };\n+                self.write_scalar(out_val, dest)?;\n+            }\n+\n+            _ => return Ok(false),\n+        }\n+\n+        Ok(true)\n+    }\n+\n+    /// \"Intercept\" a function call because we have something special to do for it.\n+    /// Returns whether an intercept happened.\n+    pub fn hook_fn(\n+        &mut self,\n+        instance: ty::Instance<'tcx>,\n+        args: &[OpTy<'tcx>],\n+        dest: Option<PlaceTy<'tcx>>,\n+    ) -> EvalResult<'tcx, bool> {\n+        let def_id = instance.def_id();\n+        // Some fn calls are actually BinOp intrinsics\n+        if let Some((op, oflo)) = self.tcx.is_binop_lang_item(def_id) {\n+            let dest = dest.expect(\"128 lowerings can't diverge\");\n+            let l = self.read_value(args[0])?;\n+            let r = self.read_value(args[1])?;\n+            if oflo {\n+                self.binop_with_overflow(op, l, r, dest)?;\n+            } else {\n+                self.binop_ignore_overflow(op, l, r, dest)?;\n+            }\n+            return Ok(true);\n+        } else if Some(def_id) == self.tcx.lang_items().panic_fn() {\n+            assert!(args.len() == 1);\n+            // &(&'static str, &'static str, u32, u32)\n+            let ptr = self.read_value(args[0])?;\n+            let place = self.ref_to_mplace(ptr)?;\n+            let (msg, file, line, col) = (\n+                self.mplace_field(place, 0)?,\n+                self.mplace_field(place, 1)?,\n+                self.mplace_field(place, 2)?,\n+                self.mplace_field(place, 3)?,\n+            );\n+\n+            let msg = Symbol::intern(self.read_str(msg.into())?);\n+            let file = Symbol::intern(self.read_str(file.into())?);\n+            let line = self.read_scalar(line.into())?.to_u32()?;\n+            let col = self.read_scalar(col.into())?.to_u32()?;\n+            return Err(EvalErrorKind::Panic { msg, file, line, col }.into());\n+        } else if Some(def_id) == self.tcx.lang_items().begin_panic_fn() {\n+            assert!(args.len() == 2);\n+            // &'static str, &(&'static str, u32, u32)\n+            let msg = args[0];\n+            let ptr = self.read_value(args[1])?;\n+            let place = self.ref_to_mplace(ptr)?;\n+            let (file, line, col) = (\n+                self.mplace_field(place, 0)?,\n+                self.mplace_field(place, 1)?,\n+                self.mplace_field(place, 2)?,\n+            );\n+\n+            let msg = Symbol::intern(self.read_str(msg)?);\n+            let file = Symbol::intern(self.read_str(file.into())?);\n+            let line = self.read_scalar(line.into())?.to_u32()?;\n+            let col = self.read_scalar(col.into())?.to_u32()?;\n+            return Err(EvalErrorKind::Panic { msg, file, line, col }.into());\n+        } else {\n+            return Ok(false);\n+        }\n+    }\n+}"}, {"sha": "714b2f9e025ec6aa4e77bab568fe16941147a589", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 27, "deletions": 56, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=c141ccf158d8c660ef20a51104b701b4eb37822b", "patch": "@@ -14,45 +14,52 @@\n \n use std::hash::Hash;\n \n-use rustc::mir::interpret::{AllocId, EvalResult, Scalar, Pointer, AccessKind, GlobalId};\n+use rustc::mir::interpret::{AllocId, Allocation, EvalResult, Scalar};\n use super::{EvalContext, PlaceTy, OpTy, Memory};\n \n use rustc::mir;\n use rustc::ty::{self, layout::TyLayout};\n-use rustc::ty::layout::Size;\n-use syntax::source_map::Span;\n use syntax::ast::Mutability;\n \n+/// Used by the machine to tell if a certain allocation is for static memory\n+pub trait IsStatic {\n+    fn is_static(self) -> bool;\n+}\n+\n /// Methods of this trait signifies a point where CTFE evaluation would fail\n /// and some use case dependent behaviour can instead be applied\n pub trait Machine<'mir, 'tcx>: Clone + Eq + Hash {\n     /// Additional data that can be accessed via the Memory\n     type MemoryData: Clone + Eq + Hash;\n \n     /// Additional memory kinds a machine wishes to distinguish from the builtin ones\n-    type MemoryKinds: ::std::fmt::Debug + PartialEq + Copy + Clone;\n+    type MemoryKinds: ::std::fmt::Debug + Copy + Clone + Eq + Hash + IsStatic;\n \n     /// Entry point to all function calls.\n     ///\n-    /// Returns Ok(true) when the function was handled completely\n-    /// e.g. due to missing mir\n-    ///\n-    /// Returns Ok(false) if a new stack frame was pushed\n-    fn eval_fn_call<'a>(\n+    /// Returns either the mir to use for the call, or `None` if execution should\n+    /// just proceed (which usually means this hook did all the work that the\n+    /// called function should usually have done).  In the latter case, it is\n+    /// this hook's responsibility to call `goto_block(ret)` to advance the instruction pointer!\n+    /// (This is to support functions like `__rust_maybe_catch_panic` that neither find a MIR\n+    /// nor just jump to `ret`, but instead push their own stack frame.)\n+    /// Passing `dest`and `ret` in the same `Option` proved very annoying when only one of them\n+    /// was used.\n+    fn find_fn<'a>(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n         args: &[OpTy<'tcx>],\n-        span: Span,\n-    ) -> EvalResult<'tcx, bool>;\n+        dest: Option<PlaceTy<'tcx>>,\n+        ret: Option<mir::BasicBlock>,\n+    ) -> EvalResult<'tcx, Option<&'mir mir::Mir<'tcx>>>;\n \n-    /// directly process an intrinsic without pushing a stack frame.\n+    /// Directly process an intrinsic without pushing a stack frame.\n+    /// If this returns successfully, the engine will take care of jumping to the next block.\n     fn call_intrinsic<'a>(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n         dest: PlaceTy<'tcx>,\n-        target: mir::BasicBlock,\n     ) -> EvalResult<'tcx>;\n \n     /// Called for all binary operations except on float types.\n@@ -70,19 +77,11 @@ pub trait Machine<'mir, 'tcx>: Clone + Eq + Hash {\n         right_layout: TyLayout<'tcx>,\n     ) -> EvalResult<'tcx, Option<(Scalar, bool)>>;\n \n-    /// Called when trying to mark machine defined `MemoryKinds` as static\n-    fn mark_static_initialized<'a>(\n-        _mem: &mut Memory<'a, 'mir, 'tcx, Self>,\n-        _id: AllocId,\n-        _mutability: Mutability,\n-    ) -> EvalResult<'tcx, bool>;\n-\n-    /// Called when requiring a pointer to a static. Non const eval can\n-    /// create a mutable memory location for `static mut`\n-    fn init_static<'a>(\n-        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        cid: GlobalId<'tcx>,\n-    ) -> EvalResult<'tcx, AllocId>;\n+    /// Called when requiring mutable access to data in a static.\n+    fn access_static_mut<'a, 'm>(\n+        mem: &'m mut Memory<'a, 'mir, 'tcx, Self>,\n+        id: AllocId,\n+    ) -> EvalResult<'tcx, &'m mut Allocation>;\n \n     /// Heap allocations via the `box` keyword\n     ///\n@@ -99,35 +98,7 @@ pub trait Machine<'mir, 'tcx>: Clone + Eq + Hash {\n         mutability: Mutability,\n     ) -> EvalResult<'tcx>;\n \n-    fn check_locks<'a>(\n-        _mem: &Memory<'a, 'mir, 'tcx, Self>,\n-        _ptr: Pointer,\n-        _size: Size,\n-        _access: AccessKind,\n-    ) -> EvalResult<'tcx> {\n-        Ok(())\n-    }\n-\n-    fn add_lock<'a>(\n-        _mem: &mut Memory<'a, 'mir, 'tcx, Self>,\n-        _id: AllocId,\n-    ) {}\n-\n-    fn free_lock<'a>(\n-        _mem: &mut Memory<'a, 'mir, 'tcx, Self>,\n-        _id: AllocId,\n-        _len: u64,\n-    ) -> EvalResult<'tcx> {\n-        Ok(())\n-    }\n-\n-    fn end_region<'a>(\n-        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        _reg: Option<::rustc::middle::region::Scope>,\n-    ) -> EvalResult<'tcx> {\n-        Ok(())\n-    }\n-\n+    /// Execute a validation operation\n     fn validation_op<'a>(\n         _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         _op: ::rustc::mir::ValidationOp,"}, {"sha": "41d48738567dc91577fb723b237a3bd7529ec0a0", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 114, "deletions": 154, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=c141ccf158d8c660ef20a51104b701b4eb37822b", "patch": "@@ -20,33 +20,39 @@ use std::collections::VecDeque;\n use std::hash::{Hash, Hasher};\n use std::ptr;\n \n-use rustc::hir::def_id::DefId;\n use rustc::ty::Instance;\n-use rustc::ty::ParamEnv;\n use rustc::ty::query::TyCtxtAt;\n use rustc::ty::layout::{self, Align, TargetDataLayout, Size};\n-use rustc::mir::interpret::{Pointer, AllocId, Allocation, AccessKind, ScalarMaybeUndef,\n-                            EvalResult, Scalar, EvalErrorKind, GlobalId, AllocType, truncate};\n+use rustc::mir::interpret::{Pointer, AllocId, Allocation, ScalarMaybeUndef,\n+                            EvalResult, Scalar, EvalErrorKind, AllocType, truncate};\n pub use rustc::mir::interpret::{write_target_uint, read_target_uint};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap, FxHasher};\n \n use syntax::ast::Mutability;\n \n-use super::{EvalContext, Machine};\n-\n+use super::{EvalContext, Machine, IsStatic, static_alloc};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Allocations and pointers\n ////////////////////////////////////////////////////////////////////////////////\n \n-#[derive(Debug, PartialEq, Eq, Copy, Clone)]\n+#[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]\n pub enum MemoryKind<T> {\n     /// Error if deallocated except during a stack pop\n     Stack,\n     /// Additional memory kinds a machine wishes to distinguish from the builtin ones\n     Machine(T),\n }\n \n+impl<T: IsStatic> IsStatic for MemoryKind<T> {\n+    fn is_static(self) -> bool {\n+        match self {\n+            MemoryKind::Stack => false,\n+            MemoryKind::Machine(kind) => kind.is_static(),\n+        }\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Top-level interpreter memory\n ////////////////////////////////////////////////////////////////////////////////\n@@ -56,11 +62,10 @@ pub struct Memory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     /// Additional data required by the Machine\n     pub data: M::MemoryData,\n \n-    /// Helps guarantee that stack allocations aren't deallocated via `rust_deallocate`\n-    alloc_kind: FxHashMap<AllocId, MemoryKind<M::MemoryKinds>>,\n-\n-    /// Actual memory allocations (arbitrary bytes, may contain pointers into other allocations).\n-    alloc_map: FxHashMap<AllocId, Allocation>,\n+    /// Allocations local to this instance of the miri engine.  The kind\n+    /// helps ensure that the same mechanism is used for allocation and\n+    /// deallocation.\n+    alloc_map: FxHashMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation)>,\n \n     pub tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n }\n@@ -77,13 +82,11 @@ impl<'a, 'mir, 'tcx, M> PartialEq for Memory<'a, 'mir, 'tcx, M>\n     fn eq(&self, other: &Self) -> bool {\n         let Memory {\n             data,\n-            alloc_kind,\n             alloc_map,\n             tcx: _,\n         } = self;\n \n         *data == other.data\n-            && *alloc_kind == other.alloc_kind\n             && *alloc_map == other.alloc_map\n     }\n }\n@@ -95,7 +98,6 @@ impl<'a, 'mir, 'tcx, M> Hash for Memory<'a, 'mir, 'tcx, M>\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         let Memory {\n             data,\n-            alloc_kind: _,\n             alloc_map: _,\n             tcx: _,\n         } = self;\n@@ -108,10 +110,11 @@ impl<'a, 'mir, 'tcx, M> Hash for Memory<'a, 'mir, 'tcx, M>\n         // iteration orders, we use a commutative operation (in this case\n         // addition, but XOR would also work), to combine the hash of each\n         // `Allocation`.\n-        self.allocations()\n-            .map(|allocs| {\n+        self.alloc_map.iter()\n+            .map(|(&id, alloc)| {\n                 let mut h = FxHasher::default();\n-                allocs.hash(&mut h);\n+                id.hash(&mut h);\n+                alloc.hash(&mut h);\n                 h.finish()\n             })\n             .fold(0u64, |hash, x| hash.wrapping_add(x))\n@@ -123,47 +126,36 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn new(tcx: TyCtxtAt<'a, 'tcx, 'tcx>, data: M::MemoryData) -> Self {\n         Memory {\n             data,\n-            alloc_kind: FxHashMap::default(),\n             alloc_map: FxHashMap::default(),\n             tcx,\n         }\n     }\n \n-    pub fn allocations<'x>(\n-        &'x self,\n-    ) -> impl Iterator<Item = (AllocId, &'x Allocation)> {\n-        self.alloc_map.iter().map(|(&id, alloc)| (id, alloc))\n-    }\n-\n     pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> Pointer {\n         self.tcx.alloc_map.lock().create_fn_alloc(instance).into()\n     }\n \n-    pub fn allocate_bytes(&mut self, bytes: &[u8]) -> Pointer {\n+    pub fn allocate_static_bytes(&mut self, bytes: &[u8]) -> Pointer {\n         self.tcx.allocate_bytes(bytes).into()\n     }\n \n-    /// kind is `None` for statics\n-    pub fn allocate_value(\n+    pub fn allocate_with(\n         &mut self,\n         alloc: Allocation,\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> EvalResult<'tcx, AllocId> {\n         let id = self.tcx.alloc_map.lock().reserve();\n-        M::add_lock(self, id);\n-        self.alloc_map.insert(id, alloc);\n-        self.alloc_kind.insert(id, kind);\n+        self.alloc_map.insert(id, (kind, alloc));\n         Ok(id)\n     }\n \n-    /// kind is `None` for statics\n     pub fn allocate(\n         &mut self,\n         size: Size,\n         align: Align,\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> EvalResult<'tcx, Pointer> {\n-        self.allocate_value(Allocation::undef(size, align), kind).map(Pointer::from)\n+        self.allocate_with(Allocation::undef(size, align), kind).map(Pointer::from)\n     }\n \n     pub fn reallocate(\n@@ -178,15 +170,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         if ptr.offset.bytes() != 0 {\n             return err!(ReallocateNonBasePtr);\n         }\n-        if self.alloc_map.contains_key(&ptr.alloc_id) {\n-            let alloc_kind = self.alloc_kind[&ptr.alloc_id];\n-            if alloc_kind != kind {\n-                return err!(ReallocatedWrongMemoryKind(\n-                    format!(\"{:?}\", alloc_kind),\n-                    format!(\"{:?}\", kind),\n-                ));\n-            }\n-        }\n \n         // For simplicities' sake, we implement reallocate as \"alloc, copy, dealloc\"\n         let new_ptr = self.allocate(new_size, new_align, kind)?;\n@@ -196,20 +179,25 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             new_ptr.into(),\n             new_align,\n             old_size.min(new_size),\n-            /*nonoverlapping*/\n-            true,\n+            /*nonoverlapping*/ true,\n         )?;\n         self.deallocate(ptr, Some((old_size, old_align)), kind)?;\n \n         Ok(new_ptr)\n     }\n \n+    pub fn is_static(&self, alloc_id: AllocId) -> bool {\n+        self.alloc_map.get(&alloc_id).map_or(true, |&(kind, _)| kind.is_static())\n+    }\n+\n+    /// Deallocate a local, or do nothing if that local has been made into a static\n     pub fn deallocate_local(&mut self, ptr: Pointer) -> EvalResult<'tcx> {\n-        match self.alloc_kind.get(&ptr.alloc_id).cloned() {\n-            Some(MemoryKind::Stack) => self.deallocate(ptr, None, MemoryKind::Stack),\n-            // Happens if the memory was interned into immutable memory\n-            None => Ok(()),\n-            other => bug!(\"local contained non-stack memory: {:?}\", other),\n+        // The allocation might be already removed by static interning.\n+        // This can only really happen in the CTFE instance, not in miri.\n+        if self.alloc_map.contains_key(&ptr.alloc_id) {\n+            self.deallocate(ptr, None, MemoryKind::Stack)\n+        } else {\n+            Ok(())\n         }\n     }\n \n@@ -223,9 +211,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             return err!(DeallocateNonBasePtr);\n         }\n \n-        let alloc = match self.alloc_map.remove(&ptr.alloc_id) {\n+        let (alloc_kind, alloc) = match self.alloc_map.remove(&ptr.alloc_id) {\n             Some(alloc) => alloc,\n             None => {\n+                // Deallocating static memory -- always an error\n                 return match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n                     Some(AllocType::Function(..)) => err!(DeallocatedWrongMemoryKind(\n                         \"function\".to_string(),\n@@ -241,18 +230,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             }\n         };\n \n-        let alloc_kind = self.alloc_kind\n-                        .remove(&ptr.alloc_id)\n-                        .expect(\"alloc_map out of sync with alloc_kind\");\n-\n-        // It is okay for us to still holds locks on deallocation -- for example, we could store\n-        // data we own in a local, and the local could be deallocated (from StorageDead) before the\n-        // function returns. However, we should check *something*.  For now, we make sure that there\n-        // is no conflicting write lock by another frame.  We *have* to permit deallocation if we\n-        // hold a read lock.\n-        // FIXME: Figure out the exact rules here.\n-        M::free_lock(self, ptr.alloc_id, alloc.bytes.len() as u64)?;\n-\n         if alloc_kind != kind {\n             return err!(DeallocatedWrongMemoryKind(\n                 format!(\"{:?}\", alloc_kind),\n@@ -339,63 +316,33 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n /// Allocation accessors\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n-    fn const_eval_static(&self, def_id: DefId) -> EvalResult<'tcx, &'tcx Allocation> {\n-        if self.tcx.is_foreign_item(def_id) {\n-            return err!(ReadForeignStatic);\n-        }\n-        let instance = Instance::mono(self.tcx.tcx, def_id);\n-        let gid = GlobalId {\n-            instance,\n-            promoted: None,\n-        };\n-        self.tcx.const_eval(ParamEnv::reveal_all().and(gid)).map_err(|err| {\n-            // no need to report anything, the const_eval call takes care of that for statics\n-            assert!(self.tcx.is_static(def_id).is_some());\n-            EvalErrorKind::ReferencedConstant(err).into()\n-        }).map(|val| {\n-            self.tcx.const_to_allocation(val)\n-        })\n-    }\n-\n     pub fn get(&self, id: AllocId) -> EvalResult<'tcx, &Allocation> {\n         // normal alloc?\n         match self.alloc_map.get(&id) {\n-            Some(alloc) => Ok(alloc),\n-            // uninitialized static alloc?\n-            None => {\n-                // static alloc?\n-                let alloc = self.tcx.alloc_map.lock().get(id);\n-                match alloc {\n-                    Some(AllocType::Memory(mem)) => Ok(mem),\n-                    Some(AllocType::Function(..)) => {\n-                        Err(EvalErrorKind::DerefFunctionPointer.into())\n-                    }\n-                    Some(AllocType::Static(did)) => {\n-                        self.const_eval_static(did)\n-                    }\n-                    None => Err(EvalErrorKind::DanglingPointerDeref.into()),\n-                }\n-            },\n+            Some(alloc) => Ok(&alloc.1),\n+            // No need to make any copies, just provide read access to the global static\n+            // memory in tcx.\n+            None => static_alloc(self.tcx, id),\n         }\n     }\n \n-    fn get_mut(\n+    pub fn get_mut(\n         &mut self,\n         id: AllocId,\n     ) -> EvalResult<'tcx, &mut Allocation> {\n-        // normal alloc?\n-        match self.alloc_map.get_mut(&id) {\n-            Some(alloc) => Ok(alloc),\n-            // uninitialized static alloc?\n-            None => {\n-                // no alloc or immutable alloc? produce an error\n-                match self.tcx.alloc_map.lock().get(id) {\n-                    Some(AllocType::Memory(..)) |\n-                    Some(AllocType::Static(..)) => err!(ModifiedConstantMemory),\n-                    Some(AllocType::Function(..)) => err!(DerefFunctionPointer),\n-                    None => err!(DanglingPointerDeref),\n-                }\n-            },\n+        // Static?\n+        let alloc = if self.alloc_map.contains_key(&id) {\n+            &mut self.alloc_map.get_mut(&id).unwrap().1\n+        } else {\n+            // The machine controls to what extend we are allowed to mutate global\n+            // statics.  (We do not want to allow that during CTFE, but miri needs it.)\n+            M::access_static_mut(self, id)?\n+        };\n+        // See if we can use this\n+        if alloc.mutability == Mutability::Immutable {\n+            err!(ModifiedConstantMemory)\n+        } else {\n+            Ok(alloc)\n         }\n     }\n \n@@ -410,10 +357,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n-    pub fn get_alloc_kind(&self, id: AllocId) -> Option<MemoryKind<M::MemoryKinds>> {\n-        self.alloc_kind.get(&id).cloned()\n-    }\n-\n     /// For debugging, print an allocation and all allocations it points to, recursively.\n     pub fn dump_alloc(&self, id: AllocId) {\n         if !log_enabled!(::log::Level::Trace) {\n@@ -441,14 +384,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             let (alloc, immutable) =\n                 // normal alloc?\n                 match self.alloc_map.get(&id) {\n-                    Some(a) => (a, match self.alloc_kind[&id] {\n+                    Some((kind, alloc)) => (alloc, match kind {\n                         MemoryKind::Stack => \" (stack)\".to_owned(),\n                         MemoryKind::Machine(m) => format!(\" ({:?})\", m),\n                     }),\n                     None => {\n                         // static alloc?\n                         match self.tcx.alloc_map.lock().get(id) {\n-                            Some(AllocType::Memory(a)) => (a, \"(immutable)\".to_owned()),\n+                            Some(AllocType::Memory(a)) => (a, \" (immutable)\".to_owned()),\n                             Some(AllocType::Function(func)) => {\n                                 trace!(\"{} {}\", msg, func);\n                                 continue;\n@@ -510,8 +453,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn leak_report(&self) -> usize {\n         trace!(\"### LEAK REPORT ###\");\n         let leaks: Vec<_> = self.alloc_map\n-            .keys()\n-            .cloned()\n+            .iter()\n+            .filter_map(|(&id, (kind, _))|\n+                if kind.is_static() { None } else { Some(id) } )\n             .collect();\n         let n = leaks.len();\n         self.dump_allocs(leaks);\n@@ -534,7 +478,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         if size.bytes() == 0 {\n             return Ok(&[]);\n         }\n-        M::check_locks(self, ptr, size, AccessKind::Read)?;\n         // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n         self.check_bounds(ptr.offset(size, self)?, true)?;\n         let alloc = self.get(ptr.alloc_id)?;\n@@ -557,7 +500,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         if size.bytes() == 0 {\n             return Ok(&mut []);\n         }\n-        M::check_locks(self, ptr, size, AccessKind::Write)?;\n         // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n         self.check_bounds(ptr.offset(size, &*self)?, true)?;\n         let alloc = self.get_mut(ptr.alloc_id)?;\n@@ -597,11 +539,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         alloc: AllocId,\n         mutability: Mutability,\n     ) -> EvalResult<'tcx> {\n-        match self.alloc_kind.get(&alloc) {\n-            // do not go into statics\n-            None => Ok(()),\n-            // just locals and machine allocs\n-            Some(_) => self.mark_static_initialized(alloc, mutability),\n+        match self.alloc_map.contains_key(&alloc) {\n+            // already interned\n+            false => Ok(()),\n+            // this still needs work\n+            true => self.mark_static_initialized(alloc, mutability),\n         }\n     }\n \n@@ -616,28 +558,42 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             alloc_id,\n             mutability\n         );\n-        // The machine handled it\n-        if M::mark_static_initialized(self, alloc_id, mutability)? {\n-            return Ok(())\n+        // remove allocation\n+        let (kind, mut alloc) = self.alloc_map.remove(&alloc_id).unwrap();\n+        match kind {\n+            MemoryKind::Machine(_) => bug!(\"Static cannot refer to machine memory\"),\n+            MemoryKind::Stack => {},\n         }\n-        let alloc = self.alloc_map.remove(&alloc_id);\n-        match self.alloc_kind.remove(&alloc_id) {\n-            None => {},\n-            Some(MemoryKind::Machine(_)) => bug!(\"machine didn't handle machine alloc\"),\n-            Some(MemoryKind::Stack) => {},\n+        // ensure llvm knows not to put this into immutable memory\n+        alloc.mutability = mutability;\n+        let alloc = self.tcx.intern_const_alloc(alloc);\n+        self.tcx.alloc_map.lock().set_id_memory(alloc_id, alloc);\n+        // recurse into inner allocations\n+        for &alloc in alloc.relocations.values() {\n+            // FIXME: Reusing the mutability here is likely incorrect.  It is originally\n+            // determined via `is_freeze`, and data is considered frozen if there is no\n+            // `UnsafeCell` *immediately* in that data -- however, this search stops\n+            // at references.  So whenever we follow a reference, we should likely\n+            // assume immutability -- and we should make sure that the compiler\n+            // does not permit code that would break this!\n+            self.mark_inner_allocation_initialized(alloc, mutability)?;\n         }\n-        if let Some(mut alloc) = alloc {\n-            // ensure llvm knows not to put this into immutable memory\n-            alloc.runtime_mutability = mutability;\n-            let alloc = self.tcx.intern_const_alloc(alloc);\n-            self.tcx.alloc_map.lock().set_id_memory(alloc_id, alloc);\n-            // recurse into inner allocations\n-            for &alloc in alloc.relocations.values() {\n-                self.mark_inner_allocation_initialized(alloc, mutability)?;\n-            }\n-        } else {\n-            bug!(\"no allocation found for {:?}\", alloc_id);\n+        Ok(())\n+    }\n+\n+    /// The alloc_id must refer to a (mutable) static; a deep copy of that\n+    /// static is made into this memory.\n+    pub fn deep_copy_static(\n+        &mut self,\n+        id: AllocId,\n+        kind: MemoryKind<M::MemoryKinds>,\n+    ) -> EvalResult<'tcx> {\n+        let alloc = static_alloc(self.tcx, id)?;\n+        if alloc.mutability == Mutability::Immutable {\n+            return err!(ModifiedConstantMemory);\n         }\n+        let old = self.alloc_map.insert(id, (kind, alloc.clone()));\n+        assert!(old.is_none(), \"deep_copy_static: must not overwrite memory with\");\n         Ok(())\n     }\n \n@@ -745,7 +701,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                     return err!(ReadPointerAsBytes);\n                 }\n                 self.check_defined(ptr, p1)?;\n-                M::check_locks(self, ptr, p1, AccessKind::Read)?;\n                 Ok(&alloc.bytes[offset..offset + size])\n             }\n             None => err!(UnterminatedCString(ptr)),\n@@ -802,9 +757,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         let bytes = self.get_bytes_unchecked(ptr, size, ptr_align.min(self.int_align(size)))?;\n         // Undef check happens *after* we established that the alignment is correct.\n         // We must not return Ok() for unaligned pointers!\n-        if self.check_defined(ptr, size).is_err() {\n-            // this inflates undefined bytes to the entire scalar,\n-            // even if only a few bytes are undefined\n+        if !self.is_defined(ptr, size)? {\n+            // this inflates undefined bytes to the entire scalar, even if only a few\n+            // bytes are undefined\n             return Ok(ScalarMaybeUndef::Undef);\n         }\n         // Now we do the actual reading\n@@ -990,16 +945,21 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    fn check_defined(&self, ptr: Pointer, size: Size) -> EvalResult<'tcx> {\n+    fn is_defined(&self, ptr: Pointer, size: Size) -> EvalResult<'tcx, bool> {\n         let alloc = self.get(ptr.alloc_id)?;\n-        if !alloc.undef_mask.is_range_defined(\n+        Ok(alloc.undef_mask.is_range_defined(\n             ptr.offset,\n             ptr.offset + size,\n-        )\n-        {\n-            return err!(ReadUndefBytes);\n+        ))\n+    }\n+\n+    #[inline]\n+    fn check_defined(&self, ptr: Pointer, size: Size) -> EvalResult<'tcx> {\n+        if self.is_defined(ptr, size)? {\n+            Ok(())\n+        } else {\n+            err!(ReadUndefBytes)\n         }\n-        Ok(())\n     }\n \n     pub fn mark_definedness("}, {"sha": "129c098099a66996e35ddbf3a086a61e33e5ec8c", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=c141ccf158d8c660ef20a51104b701b4eb37822b", "patch": "@@ -22,6 +22,7 @@ mod terminator;\n mod traits;\n mod const_eval;\n mod validity;\n+mod intrinsics;\n \n pub use self::eval_context::{\n     EvalContext, Frame, StackPopCleanup, LocalValue,\n@@ -41,8 +42,9 @@ pub use self::const_eval::{\n     const_field,\n     const_variant_index,\n     op_to_const,\n+    static_alloc,\n };\n \n-pub use self::machine::Machine;\n+pub use self::machine::{Machine, IsStatic};\n \n pub use self::operand::{Value, ValTy, Operand, OpTy};"}, {"sha": "034b81852d584c6244cc67e4539f342a16b23dc8", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=c141ccf158d8c660ef20a51104b701b4eb37822b", "patch": "@@ -14,7 +14,7 @@\n use std::convert::TryInto;\n \n use rustc::mir;\n-use rustc::ty::layout::{self, Align, LayoutOf, TyLayout, HasDataLayout, IntegerExt};\n+use rustc::ty::layout::{self, Size, Align, LayoutOf, TyLayout, HasDataLayout, IntegerExt};\n use rustc_data_structures::indexed_vec::Idx;\n \n use rustc::mir::interpret::{\n@@ -300,6 +300,22 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n+    // operand must be a &str or compatible layout\n+    pub fn read_str(\n+        &self,\n+        op: OpTy<'tcx>,\n+    ) -> EvalResult<'tcx, &str> {\n+        let val = self.read_value(op)?;\n+        if let Value::ScalarPair(ptr, len) = *val {\n+            let len = len.not_undef()?.to_bits(self.memory.pointer_size())?;\n+            let bytes = self.memory.read_bytes(ptr.not_undef()?, Size::from_bytes(len as u64))?;\n+            let str = ::std::str::from_utf8(bytes).map_err(|err| EvalErrorKind::ValidationFailure(err.to_string()))?;\n+            Ok(str)\n+        } else {\n+            bug!(\"read_str: not a str\")\n+        }\n+    }\n+\n     pub fn uninit_operand(&mut self, layout: TyLayout<'tcx>) -> EvalResult<'tcx, Operand> {\n         // This decides which types we will use the Immediate optimization for, and hence should\n         // match what `try_read_value` and `eval_place_to_op` support.\n@@ -482,9 +498,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     // Unfortunately, this needs an `&mut` to be able to allocate a copy of a `ByRef`\n     // constant.  This bleeds up to `eval_operand` needing `&mut`.\n     pub fn const_value_to_op(\n-        &mut self,\n+        &self,\n         val: ConstValue<'tcx>,\n     ) -> EvalResult<'tcx, Operand> {\n+        trace!(\"const_value_to_op: {:?}\", val);\n         match val {\n             ConstValue::Unevaluated(def_id, substs) => {\n                 let instance = self.resolve(def_id, substs)?;\n@@ -493,9 +510,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     promoted: None,\n                 })\n             }\n-            ConstValue::ByRef(alloc, offset) => {\n-                // FIXME: Allocate new AllocId for all constants inside\n-                let id = self.memory.allocate_value(alloc.clone(), MemoryKind::Stack)?;\n+            ConstValue::ByRef(id, alloc, offset) => {\n+                // We rely on mutability being set correctly in that allocation to prevent writes\n+                // where none should happen -- and for `static mut`, we copy on demand anyway.\n                 Ok(Operand::from_ptr(Pointer::new(id, offset), alloc.align))\n             },\n             ConstValue::ScalarPair(a, b) =>\n@@ -505,7 +522,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n-    pub(super) fn global_to_op(&mut self, gid: GlobalId<'tcx>) -> EvalResult<'tcx, Operand> {\n+    pub(super) fn global_to_op(&self, gid: GlobalId<'tcx>) -> EvalResult<'tcx, Operand> {\n         let cv = self.const_eval(gid)?;\n         self.const_value_to_op(cv.val)\n     }"}, {"sha": "d216e5030798c25d1963ff2c49a71d6f5f858d71", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=c141ccf158d8c660ef20a51104b701b4eb37822b", "patch": "@@ -247,6 +247,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         let pointee_type = val.layout.ty.builtin_deref(true).unwrap().ty;\n         let layout = self.layout_of(pointee_type)?;\n         let mplace = match self.tcx.struct_tail(pointee_type).sty {\n+            // Matching on the type is okay here, because we used `struct_tail` to get to\n+            // the \"core\" of what makes this unsized.\n             ty::Dynamic(..) => {\n                 let (ptr, vtable) = val.to_scalar_dyn_trait()?;\n                 MemPlace {\n@@ -263,11 +265,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     extra: PlaceExtra::Length(len),\n                 }\n             }\n-            _ => MemPlace {\n-                ptr: val.to_scalar()?,\n-                align: layout.align,\n-                extra: PlaceExtra::None,\n-            },\n+            _ => {\n+                assert!(!layout.is_unsized(), \"Unhandled unsized type {:?}\", pointee_type);\n+                MemPlace {\n+                    ptr: val.to_scalar()?,\n+                    align: layout.align,\n+                    extra: PlaceExtra::None,\n+                }\n+            }\n         };\n         Ok(MPlaceTy { mplace, layout })\n     }\n@@ -371,6 +376,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         // Compute extra and new layout\n         let inner_len = len - to - from;\n         let (extra, ty) = match base.layout.ty.sty {\n+            // It is not nice to match on the type, but that seems to be the only way to\n+            // implement this.\n             ty::Array(inner, _) =>\n                 (PlaceExtra::None, self.tcx.mk_array(inner, inner_len)),\n             ty::Slice(..) =>\n@@ -526,7 +533,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     instance,\n                     promoted: None\n                 };\n-                let alloc = Machine::init_static(self, cid)?;\n+                // Just create a lazy reference, so we can support recursive statics.\n+                // When the data here is ever actually used, memory will notice,\n+                // and it knows how to deal with alloc_id that are present in the\n+                // global table but not in its local memory.\n+                let alloc = self.tcx.alloc_map.lock()\n+                    .intern_static(cid.instance.def_id());\n                 MPlaceTy::from_aligned_ptr(alloc.into(), layout).into()\n             }\n \n@@ -692,6 +704,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         &mut self,\n         OpTy { op, layout }: OpTy<'tcx>,\n     ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n+        trace!(\"allocate_op: {:?}\", op);\n         Ok(match op {\n             Operand::Indirect(mplace) => MPlaceTy { mplace, layout },\n             Operand::Immediate(value) => {"}, {"sha": "e6caca9e1c4c247ca1b829b1712cab2562f24f57", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=c141ccf158d8c660ef20a51104b701b4eb37822b", "patch": "@@ -76,8 +76,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         self.loop_detector.observe_and_analyze(&self.machine, &self.stack, &self.memory)\n     }\n \n+    pub fn run(&mut self) -> EvalResult<'tcx> {\n+        while self.step()? {}\n+        Ok(())\n+    }\n+\n     /// Returns true as long as there are more things to do.\n-    pub fn step(&mut self) -> EvalResult<'tcx, bool> {\n+    fn step(&mut self) -> EvalResult<'tcx, bool> {\n         if self.stack.is_empty() {\n             return Ok(false);\n         }\n@@ -147,10 +152,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     M::validation_op(self, op, operand)?;\n                 }\n             }\n-            EndRegion(ce) => {\n-                M::end_region(self, Some(ce))?;\n-            }\n \n+            EndRegion(..) => {}\n             UserAssertTy(..) => {}\n \n             // Defined to do nothing. These are added by optimization passes, to avoid changing the\n@@ -327,8 +330,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         debug!(\"{:?}\", terminator.kind);\n         self.tcx.span = terminator.source_info.span;\n         self.memory.tcx.span = terminator.source_info.span;\n+\n+        let old_stack = self.cur_frame();\n+        let old_bb = self.frame().block;\n         self.eval_terminator(terminator)?;\n         if !self.stack.is_empty() {\n+            // This should change *something*\n+            debug_assert!(self.cur_frame() != old_stack || self.frame().block != old_bb);\n             debug!(\"// {:?}\", self.frame().block);\n         }\n         Ok(())"}, {"sha": "10aaf761b490f4423e09edc593fbc3d018246953", "filename": "src/librustc_mir/interpret/terminator/drop.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs?ref=c141ccf158d8c660ef20a51104b701b4eb37822b", "patch": "@@ -57,8 +57,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n         self.eval_fn_call(\n             instance,\n-            Some((dest, target)),\n             &[arg],\n+            Some(dest),\n+            Some(target),\n             span,\n             fn_sig,\n         )"}, {"sha": "4a5699900cf1beb17623cccf566b643b85050bbf", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 65, "deletions": 28, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=c141ccf158d8c660ef20a51104b701b4eb37822b", "patch": "@@ -15,16 +15,22 @@ use syntax::source_map::Span;\n use rustc_target::spec::abi::Abi;\n \n use rustc::mir::interpret::{EvalResult, Scalar};\n-use super::{EvalContext, Machine, Value, OpTy, PlaceTy, ValTy, Operand};\n+use super::{EvalContext, Machine, Value, OpTy, Place, PlaceTy, ValTy, Operand, StackPopCleanup};\n \n use rustc_data_structures::indexed_vec::Idx;\n \n mod drop;\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n-    pub fn goto_block(&mut self, target: mir::BasicBlock) {\n-        self.frame_mut().block = target;\n-        self.frame_mut().stmt = 0;\n+    #[inline]\n+    pub fn goto_block(&mut self, target: Option<mir::BasicBlock>) -> EvalResult<'tcx> {\n+        if let Some(target) = target {\n+            self.frame_mut().block = target;\n+            self.frame_mut().stmt = 0;\n+            Ok(())\n+        } else {\n+            err!(Unreachable)\n+        }\n     }\n \n     pub(super) fn eval_terminator(\n@@ -38,7 +44,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 self.pop_stack_frame()?\n             }\n \n-            Goto { target } => self.goto_block(target),\n+            Goto { target } => self.goto_block(Some(target))?,\n \n             SwitchInt {\n                 ref discr,\n@@ -69,7 +75,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     }\n                 }\n \n-                self.goto_block(target_block);\n+                self.goto_block(Some(target_block))?;\n             }\n \n             Call {\n@@ -78,9 +84,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 ref destination,\n                 ..\n             } => {\n-                let destination = match *destination {\n-                    Some((ref lv, target)) => Some((self.eval_place(lv)?, target)),\n-                    None => None,\n+                let (dest, ret) = match *destination {\n+                    Some((ref lv, target)) => (Some(self.eval_place(lv)?), Some(target)),\n+                    None => (None, None),\n                 };\n \n                 let func = self.eval_operand(func, None)?;\n@@ -124,8 +130,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 );\n                 self.eval_fn_call(\n                     fn_def,\n-                    destination,\n                     &args[..],\n+                    dest,\n+                    ret,\n                     terminator.source_info.span,\n                     sig,\n                 )?;\n@@ -161,7 +168,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     .to_scalar()?\n                     .to_bool()?;\n                 if expected == cond_val {\n-                    self.goto_block(target);\n+                    self.goto_block(Some(target))?;\n                 } else {\n                     use rustc::mir::interpret::EvalErrorKind::*;\n                     return match *msg {\n@@ -273,30 +280,51 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     fn eval_fn_call(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n         args: &[OpTy<'tcx>],\n+        dest: Option<PlaceTy<'tcx>>,\n+        ret: Option<mir::BasicBlock>,\n         span: Span,\n         sig: ty::FnSig<'tcx>,\n     ) -> EvalResult<'tcx> {\n         trace!(\"eval_fn_call: {:#?}\", instance);\n-        if let Some((place, _)) = destination {\n+        if let Some(place) = dest {\n             assert_eq!(place.layout.ty, sig.output());\n         }\n         match instance.def {\n             ty::InstanceDef::Intrinsic(..) => {\n-                let (ret, target) = match destination {\n+                // The intrinsic itself cannot diverge, so if we got here without a return\n+                // place... (can happen e.g. for transmute returning `!`)\n+                let dest = match dest {\n                     Some(dest) => dest,\n-                    _ => return err!(Unreachable),\n+                    None => return err!(Unreachable)\n                 };\n-                M::call_intrinsic(self, instance, args, ret, target)?;\n-                self.dump_place(*ret);\n+                M::call_intrinsic(self, instance, args, dest)?;\n+                // No stack frame gets pushed, the main loop will just act as if the\n+                // call completed.\n+                self.goto_block(ret)?;\n+                self.dump_place(*dest);\n                 Ok(())\n             }\n             // FIXME: figure out why we can't just go through the shim\n             ty::InstanceDef::ClosureOnceShim { .. } => {\n-                if M::eval_fn_call(self, instance, destination, args, span)? {\n-                    return Ok(());\n-                }\n+                let mir = match M::find_fn(self, instance, args, dest, ret)? {\n+                    Some(mir) => mir,\n+                    None => return Ok(()),\n+                };\n+\n+                let return_place = match dest {\n+                    Some(place) => *place,\n+                    None => Place::null(&self),\n+                };\n+                self.push_stack_frame(\n+                    instance,\n+                    span,\n+                    mir,\n+                    return_place,\n+                    StackPopCleanup::Goto(ret),\n+                )?;\n+\n+                // Pass the arguments\n                 let mut arg_locals = self.frame().mir.args_iter();\n                 match sig.abi {\n                     // closure as closure once\n@@ -333,13 +361,22 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             ty::InstanceDef::DropGlue(..) |\n             ty::InstanceDef::CloneShim(..) |\n             ty::InstanceDef::Item(_) => {\n-                // Push the stack frame, and potentially be entirely done if the call got hooked\n-                if M::eval_fn_call(self, instance, destination, args, span)? {\n-                    // FIXME: Can we make it return the frame to push, instead\n-                    // of the hook doing half of the work and us doing the argument\n-                    // initialization?\n-                    return Ok(());\n-                }\n+                let mir = match M::find_fn(self, instance, args, dest, ret)? {\n+                    Some(mir) => mir,\n+                    None => return Ok(()),\n+                };\n+\n+                let return_place = match dest {\n+                    Some(place) => *place,\n+                    None => Place::null(&self),\n+                };\n+                self.push_stack_frame(\n+                    instance,\n+                    span,\n+                    mir,\n+                    return_place,\n+                    StackPopCleanup::Goto(ret),\n+                )?;\n \n                 // Pass the arguments\n                 let mut arg_locals = self.frame().mir.args_iter();\n@@ -418,7 +455,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 args[0].op = Operand::Immediate(Value::Scalar(ptr.into())); // strip vtable\n                 trace!(\"Patched self operand to {:#?}\", args[0]);\n                 // recurse with concrete function\n-                self.eval_fn_call(instance, destination, &args, span, sig)\n+                self.eval_fn_call(instance, &args, dest, ret, span, sig)\n             }\n         }\n     }"}, {"sha": "5b9c00e49eaeaefa04d2bee13998d6475bfb3c92", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c141ccf158d8c660ef20a51104b701b4eb37822b/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=c141ccf158d8c660ef20a51104b701b4eb37822b", "patch": "@@ -1271,7 +1271,7 @@ fn collect_const<'a, 'tcx>(\n         ConstValue::ScalarPair(Scalar::Ptr(ptr), _) |\n         ConstValue::Scalar(Scalar::Ptr(ptr)) =>\n             collect_miri(tcx, ptr.alloc_id, output),\n-        ConstValue::ByRef(alloc, _offset) => {\n+        ConstValue::ByRef(_id, alloc, _offset) => {\n             for &id in alloc.relocations.values() {\n                 collect_miri(tcx, id, output);\n             }"}]}