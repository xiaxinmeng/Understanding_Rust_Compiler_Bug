{"sha": "daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhZjVmNWE0ZDEwNTEzZmY0MmU3OWZhN2VmODgxOWIxNzBmM2ExM2Q=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-21T20:08:31Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-22T15:09:56Z"}, "message": "Drop the '2' suffix from logging macros\n\nWho doesn't like a massive renaming?", "tree": {"sha": "7a07a79c43e02debcc6bbb33d90a5e41b70119e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a07a79c43e02debcc6bbb33d90a5e41b70119e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "html_url": "https://github.com/rust-lang/rust/commit/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15a6bdebab4e7b811b9a902e3f8ed225c59af06e", "url": "https://api.github.com/repos/rust-lang/rust/commits/15a6bdebab4e7b811b9a902e3f8ed225c59af06e", "html_url": "https://github.com/rust-lang/rust/commit/15a6bdebab4e7b811b9a902e3f8ed225c59af06e"}], "stats": {"total": 6150, "additions": 3075, "deletions": 3075}, "files": [{"sha": "7f5a72e8a2c8cde5ff3c72f9e8949a8ac0aec747", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -85,20 +85,20 @@ pub fn parse_config(args: ~[~str]) -> config {\n         let message = format!(\"Usage: {} [OPTIONS] [TESTNAME...]\", argv0);\n         println(getopts::groups::usage(message, groups));\n         println(\"\");\n-        fail2!()\n+        fail!()\n     }\n \n     let matches =\n         &match getopts::groups::getopts(args_, groups) {\n           Ok(m) => m,\n-          Err(f) => fail2!(\"{}\", f.to_err_msg())\n+          Err(f) => fail!(\"{}\", f.to_err_msg())\n         };\n \n     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n         let message = format!(\"Usage: {} [OPTIONS]  [TESTNAME...]\", argv0);\n         println(getopts::groups::usage(message, groups));\n         println(\"\");\n-        fail2!()\n+        fail!()\n     }\n \n     fn opt_path(m: &getopts::Matches, nm: &str) -> Path {\n@@ -203,7 +203,7 @@ pub fn str_mode(s: ~str) -> mode {\n       ~\"pretty\" => mode_pretty,\n       ~\"debug-info\" => mode_debug_info,\n       ~\"codegen\" => mode_codegen,\n-      _ => fail2!(\"invalid mode\")\n+      _ => fail!(\"invalid mode\")\n     }\n }\n \n@@ -226,7 +226,7 @@ pub fn run_tests(config: &config) {\n     // For context, see #8904\n     rt::test::prepare_for_lots_of_tests();\n     let res = test::run_tests_console(&opts, tests);\n-    if !res { fail2!(\"Some tests failed\"); }\n+    if !res { fail!(\"Some tests failed\"); }\n }\n \n pub fn test_opts(config: &config) -> test::TestOpts {\n@@ -244,13 +244,13 @@ pub fn test_opts(config: &config) -> test::TestOpts {\n }\n \n pub fn make_tests(config: &config) -> ~[test::TestDescAndFn] {\n-    debug2!(\"making tests from {}\",\n+    debug!(\"making tests from {}\",\n            config.src_base.display());\n     let mut tests = ~[];\n     let dirs = os::list_dir_path(&config.src_base);\n     for file in dirs.iter() {\n         let file = file.clone();\n-        debug2!(\"inspecting file {}\", file.display());\n+        debug!(\"inspecting file {}\", file.display());\n         if is_test(config, &file) {\n             let t = do make_test(config, &file) {\n                 match config.mode {"}, {"sha": "0c94ec8ab8a833005a833289bc86340553da845f", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -61,7 +61,7 @@ fn parse_expected(line_num: uint, line: ~str) -> ~[ExpectedError] {\n     while idx < len && line[idx] == (' ' as u8) { idx += 1u; }\n     let msg = line.slice(idx, len).to_owned();\n \n-    debug2!(\"line={} kind={} msg={}\", line_num - adjust_line, kind, msg);\n+    debug!(\"line={} kind={} msg={}\", line_num - adjust_line, kind, msg);\n \n     return ~[ExpectedError{line: line_num - adjust_line, kind: kind,\n                            msg: msg}];"}, {"sha": "368c96ffe8542767944117fbc56320716769a271", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -154,7 +154,7 @@ fn parse_exec_env(line: &str) -> Option<(~str, ~str)> {\n               let end = strs.pop();\n               (strs.pop(), end)\n           }\n-          n => fail2!(\"Expected 1 or 2 strings, not {}\", n)\n+          n => fail!(\"Expected 1 or 2 strings, not {}\", n)\n         }\n     }\n }\n@@ -183,7 +183,7 @@ fn parse_name_value_directive(line: &str,\n         Some(colon) => {\n             let value = line.slice(colon + keycolon.len(),\n                                    line.len()).to_owned();\n-            debug2!(\"{}: {}\", directive,  value);\n+            debug!(\"{}: {}\", directive,  value);\n             Some(value)\n         }\n         None => None"}, {"sha": "d02b88ae74e5f8af60478b8e10051f9be4847d84", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -63,9 +63,9 @@ pub fn run_metrics(config: config, testfile: ~str, mm: &mut MetricMap) {\n         io::stdout().write_str(\"\\n\\n\");\n     }\n     let testfile = Path::new(testfile);\n-    debug2!(\"running {}\", testfile.display());\n+    debug!(\"running {}\", testfile.display());\n     let props = load_props(&testfile);\n-    debug2!(\"loaded props\");\n+    debug!(\"loaded props\");\n     match config.mode {\n       mode_compile_fail => run_cfail_test(&config, &props, &testfile),\n       mode_run_fail => run_rfail_test(&config, &props, &testfile),\n@@ -241,7 +241,7 @@ actual:\\n\\\n \\n\",\n                      expected, actual);\n             io::stdout().write_str(msg);\n-            fail2!();\n+            fail!();\n         }\n     }\n \n@@ -289,7 +289,7 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n     let script_str = [~\"set charset UTF-8\",\n                       cmds,\n                       ~\"quit\\n\"].connect(\"\\n\");\n-    debug2!(\"script_str = {}\", script_str);\n+    debug!(\"script_str = {}\", script_str);\n     dump_output_file(config, testfile, script_str, \"debugger.script\");\n \n     // run debugger script with gdb\n@@ -348,10 +348,10 @@ fn check_error_patterns(props: &TestProps,\n     let mut done = false;\n     for line in ProcRes.stderr.line_iter() {\n         if line.contains(*next_err_pat) {\n-            debug2!(\"found error pattern {}\", *next_err_pat);\n+            debug!(\"found error pattern {}\", *next_err_pat);\n             next_err_idx += 1u;\n             if next_err_idx == props.error_patterns.len() {\n-                debug2!(\"found all error patterns\");\n+                debug!(\"found all error patterns\");\n                 done = true;\n                 break;\n             }\n@@ -423,7 +423,7 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n         let mut was_expected = false;\n         for (i, ee) in expected_errors.iter().enumerate() {\n             if !found_flags[i] {\n-                debug2!(\"prefix={} ee.kind={} ee.msg={} line={}\",\n+                debug!(\"prefix={} ee.kind={} ee.msg={} line={}\",\n                        prefixes[i], ee.kind, ee.msg, line);\n                 if (prefix_matches(line, prefixes[i]) &&\n                     line.contains(ee.kind) &&\n@@ -626,7 +626,7 @@ fn compose_and_run_compiler(\n fn ensure_dir(path: &Path) {\n     if os::path_is_dir(path) { return; }\n     if !os::make_dir(path, 0x1c0i32) {\n-        fail2!(\"can't make dir {}\", path.display());\n+        fail!(\"can't make dir {}\", path.display());\n     }\n }\n \n@@ -784,7 +784,7 @@ fn maybe_dump_to_stdout(config: &config, out: &str, err: &str) {\n \n fn error(err: ~str) { io::stdout().write_line(format!(\"\\nerror: {}\", err)); }\n \n-fn fatal(err: ~str) -> ! { error(err); fail2!(); }\n+fn fatal(err: ~str) -> ! { error(err); fail!(); }\n \n fn fatal_ProcRes(err: ~str, ProcRes: &ProcRes) -> ! {\n     let msg =\n@@ -802,7 +802,7 @@ stderr:\\n\\\n \\n\",\n              err, ProcRes.cmdline, ProcRes.stdout, ProcRes.stderr);\n     io::stdout().write_str(msg);\n-    fail2!();\n+    fail!();\n }\n \n fn _arm_exec_compiled_test(config: &config, props: &TestProps,"}, {"sha": "04ef180299daf6d7500eda6c738a9c7ad347bd10", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -29,7 +29,7 @@ pub fn get_os(triple: &str) -> &'static str {\n             return os\n         }\n     }\n-    fail2!(\"Cannot determine OS from triple\");\n+    fail!(\"Cannot determine OS from triple\");\n }\n \n pub fn make_new_path(path: &str) -> ~str {\n@@ -63,6 +63,6 @@ pub fn path_div() -> ~str { ~\":\" }\n pub fn path_div() -> ~str { ~\";\" }\n \n pub fn logv(config: &config, s: ~str) {\n-    debug2!(\"{}\", s);\n+    debug!(\"{}\", s);\n     if config.verbose { io::println(s); }\n }"}, {"sha": "66dad4721aa98bcf0ae078e223d5705ee919445c", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -255,7 +255,7 @@ impl<T:Send> MutexArc<T> {\n         let inner = x.unwrap();\n         let MutexArcInner { failed: failed, data: data, _ } = inner;\n         if failed {\n-            fail2!(\"Can't unwrap poisoned MutexArc - another task failed inside!\");\n+            fail!(\"Can't unwrap poisoned MutexArc - another task failed inside!\");\n         }\n         data\n     }\n@@ -300,9 +300,9 @@ impl<T:Freeze + Send> MutexArc<T> {\n fn check_poison(is_mutex: bool, failed: bool) {\n     if failed {\n         if is_mutex {\n-            fail2!(\"Poisoned MutexArc - another task failed inside!\");\n+            fail!(\"Poisoned MutexArc - another task failed inside!\");\n         } else {\n-            fail2!(\"Poisoned rw_arc - another task failed inside!\");\n+            fail!(\"Poisoned rw_arc - another task failed inside!\");\n         }\n     }\n }\n@@ -505,7 +505,7 @@ impl<T:Freeze + Send> RWArc<T> {\n         let inner = x.unwrap();\n         let RWArcInner { failed: failed, data: data, _ } = inner;\n         if failed {\n-            fail2!(\"Can't unwrap poisoned RWArc - another task failed inside!\")\n+            fail!(\"Can't unwrap poisoned RWArc - another task failed inside!\")\n         }\n         data\n     }\n@@ -619,7 +619,7 @@ mod tests {\n         assert_eq!(arc_v.get()[2], 3);\n         assert_eq!(arc_v.get()[4], 5);\n \n-        info2!(\"{:?}\", arc_v);\n+        info!(\"{:?}\", arc_v);\n     }\n \n     #[test]"}, {"sha": "b684e0d429e316b94ecd92f14ec04441eb93de1d", "filename": "src/libextra/arena.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farena.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -127,7 +127,7 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n \n         let start = round_up_to(after_tydesc, align);\n \n-        //debug2!(\"freeing object: idx = {}, size = {}, align = {}, done = {}\",\n+        //debug!(\"freeing object: idx = {}, size = {}, align = {}, done = {}\",\n         //       start, size, align, is_done);\n         if is_done {\n             ((*tydesc).drop_glue)(ptr::offset(buf, start as int) as *i8);\n@@ -176,7 +176,7 @@ impl Arena {\n             }\n             this.pod_head.fill = end;\n \n-            //debug2!(\"idx = {}, size = {}, align = {}, fill = {}\",\n+            //debug!(\"idx = {}, size = {}, align = {}, fill = {}\",\n             //       start, n_bytes, align, head.fill);\n \n             ptr::offset(vec::raw::to_ptr(this.pod_head.data), start as int)\n@@ -232,7 +232,7 @@ impl Arena {\n             let head = transmute_mut_region(&mut self.head);\n             head.fill = round_up_to(end, mem::pref_align_of::<*TyDesc>());\n \n-            //debug2!(\"idx = {}, size = {}, align = {}, fill = {}\",\n+            //debug!(\"idx = {}, size = {}, align = {}, fill = {}\",\n             //       start, n_bytes, align, head.fill);\n \n             let buf = vec::raw::to_ptr(self.head.data);\n@@ -305,6 +305,6 @@ fn test_arena_destructors_fail() {\n     // Now, fail while allocating\n     do arena.alloc::<@int> {\n         // Now fail.\n-        fail2!();\n+        fail!();\n     };\n }"}, {"sha": "3960be46686983366860f8d8a86633a68573c9d5", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -141,7 +141,7 @@ impl<'self> ToBase64 for &'self [u8] {\n                     v.push('=' as u8);\n                 }\n             }\n-            _ => fail2!(\"Algebra is broken, please alert the math police\")\n+            _ => fail!(\"Algebra is broken, please alert the math police\")\n         }\n \n         unsafe {"}, {"sha": "bf0fde807d3f4dfee005c8dd633073967ea2d228", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -232,7 +232,7 @@ pub struct Bitv {\n }\n \n fn die() -> ! {\n-    fail2!(\"Tried to do operation on bit vectors with different sizes\");\n+    fail!(\"Tried to do operation on bit vectors with different sizes\");\n }\n \n impl Bitv {\n@@ -1357,7 +1357,7 @@ mod tests {\n         let mut b = Bitv::new(14, true);\n         b.clear();\n         do b.ones |i| {\n-            fail2!(\"found 1 at {:?}\", i)\n+            fail!(\"found 1 at {:?}\", i)\n         };\n     }\n \n@@ -1366,7 +1366,7 @@ mod tests {\n         let mut b = Bitv::new(140, true);\n         b.clear();\n         do b.ones |i| {\n-            fail2!(\"found 1 at {:?}\", i)\n+            fail!(\"found 1 at {:?}\", i)\n         };\n     }\n "}, {"sha": "4a3801827a21120f83ede468b37bca0e3b5ffc7b", "filename": "src/libextra/comm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcomm.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -179,7 +179,7 @@ mod test {\n         let (port, chan) = rendezvous();\n         do spawn_unlinked {\n             chan.duplex_stream.send(()); // Can't access this field outside this module\n-            fail2!()\n+            fail!()\n         }\n         port.recv()\n     }\n@@ -189,7 +189,7 @@ mod test {\n         let (port, chan) = rendezvous();\n         do spawn_unlinked {\n             port.duplex_stream.recv();\n-            fail2!()\n+            fail!()\n         }\n         chan.try_send(());\n     }\n@@ -200,7 +200,7 @@ mod test {\n         let (port, chan) = rendezvous();\n         do spawn_unlinked {\n             port.duplex_stream.recv();\n-            fail2!()\n+            fail!()\n         }\n         chan.send(());\n     }"}, {"sha": "97b82383d8432d2a9c420713f1f371a045a927e3", "filename": "src/libextra/crypto/cryptoutil.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -109,23 +109,23 @@ impl ToBits for u64 {\n     }\n }\n \n-/// Adds the specified number of bytes to the bit count. fail2!() if this would cause numeric\n+/// Adds the specified number of bytes to the bit count. fail!() if this would cause numeric\n /// overflow.\n pub fn add_bytes_to_bits<T: Int + CheckedAdd + ToBits>(bits: T, bytes: T) -> T {\n     let (new_high_bits, new_low_bits) = bytes.to_bits();\n \n     if new_high_bits > Zero::zero() {\n-        fail2!(\"Numeric overflow occured.\")\n+        fail!(\"Numeric overflow occured.\")\n     }\n \n     match bits.checked_add(&new_low_bits) {\n         Some(x) => return x,\n-        None => fail2!(\"Numeric overflow occured.\")\n+        None => fail!(\"Numeric overflow occured.\")\n     }\n }\n \n /// Adds the specified number of bytes to the bit count, which is a tuple where the first element is\n-/// the high order value. fail2!() if this would cause numeric overflow.\n+/// the high order value. fail!() if this would cause numeric overflow.\n pub fn add_bytes_to_bits_tuple\n         <T: Int + Unsigned + CheckedAdd + ToBits>\n         (bits: (T, T), bytes: T) -> (T, T) {\n@@ -144,15 +144,15 @@ pub fn add_bytes_to_bits_tuple\n             } else {\n                 match hi.checked_add(&new_high_bits) {\n                     Some(y) => return (y, x),\n-                    None => fail2!(\"Numeric overflow occured.\")\n+                    None => fail!(\"Numeric overflow occured.\")\n                 }\n             }\n         },\n         None => {\n             let one: T = One::one();\n             let z = match new_high_bits.checked_add(&one) {\n                 Some(w) => w,\n-                None => fail2!(\"Numeric overflow occured.\")\n+                None => fail!(\"Numeric overflow occured.\")\n             };\n             match hi.checked_add(&z) {\n                 // This re-executes the addition that was already performed earlier when overflow\n@@ -163,7 +163,7 @@ pub fn add_bytes_to_bits_tuple\n                 // be Unsigned - overflow is not defined for Signed types. This function could be\n                 // implemented for signed types as well if that were needed.\n                 Some(y) => return (y, low + new_low_bits),\n-                None => fail2!(\"Numeric overflow occured.\")\n+                None => fail!(\"Numeric overflow occured.\")\n             }\n         }\n     }"}, {"sha": "f29cbd6ee5294cdb70f6662ca05d8249af914a24", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -635,11 +635,11 @@ pub fn check_links<T>(list: &DList<T>) {\n     loop {\n         match (last_ptr, node_ptr.prev.resolve_immut()) {\n             (None   , None      ) => {}\n-            (None   , _         ) => fail2!(\"prev link for list_head\"),\n+            (None   , _         ) => fail!(\"prev link for list_head\"),\n             (Some(p), Some(pptr)) => {\n                 assert_eq!(p as *Node<T>, pptr as *Node<T>);\n             }\n-            _ => fail2!(\"prev link is none, not good\"),\n+            _ => fail!(\"prev link is none, not good\"),\n         }\n         match node_ptr.next {\n             Some(ref next) => {"}, {"sha": "006ae3520c60b25696f50d104a886ba1008a1fa5", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -138,7 +138,7 @@ pub mod reader {\n                         (data[start + 3u] as uint),\n                     next: start + 4u};\n         }\n-        fail2!(\"vint too big\");\n+        fail!(\"vint too big\");\n     }\n \n     #[cfg(target_arch = \"x86\")]\n@@ -216,8 +216,8 @@ pub mod reader {\n         match maybe_get_doc(d, tg) {\n             Some(d) => d,\n             None => {\n-                error2!(\"failed to find block with tag {}\", tg);\n-                fail2!();\n+                error!(\"failed to find block with tag {}\", tg);\n+                fail!();\n             }\n         }\n     }\n@@ -305,32 +305,32 @@ pub mod reader {\n                     self.pos = r_doc.end;\n                     let str = r_doc.as_str_slice();\n                     if lbl != str {\n-                        fail2!(\"Expected label {} but found {}\", lbl, str);\n+                        fail!(\"Expected label {} but found {}\", lbl, str);\n                     }\n                 }\n             }\n         }\n \n         fn next_doc(&mut self, exp_tag: EbmlEncoderTag) -> Doc {\n-            debug2!(\". next_doc(exp_tag={:?})\", exp_tag);\n+            debug!(\". next_doc(exp_tag={:?})\", exp_tag);\n             if self.pos >= self.parent.end {\n-                fail2!(\"no more documents in current node!\");\n+                fail!(\"no more documents in current node!\");\n             }\n             let TaggedDoc { tag: r_tag, doc: r_doc } =\n                 doc_at(self.parent.data, self.pos);\n-            debug2!(\"self.parent={}-{} self.pos={} r_tag={} r_doc={}-{}\",\n+            debug!(\"self.parent={}-{} self.pos={} r_tag={} r_doc={}-{}\",\n                    self.parent.start,\n                    self.parent.end,\n                    self.pos,\n                    r_tag,\n                    r_doc.start,\n                    r_doc.end);\n             if r_tag != (exp_tag as uint) {\n-                fail2!(\"expected EBML doc with tag {:?} but found tag {:?}\",\n+                fail!(\"expected EBML doc with tag {:?} but found tag {:?}\",\n                        exp_tag, r_tag);\n             }\n             if r_doc.end > self.parent.end {\n-                fail2!(\"invalid EBML, child extends to {:#x}, parent to {:#x}\",\n+                fail!(\"invalid EBML, child extends to {:#x}, parent to {:#x}\",\n                       r_doc.end, self.parent.end);\n             }\n             self.pos = r_doc.end;\n@@ -352,7 +352,7 @@ pub mod reader {\n \n         fn _next_uint(&mut self, exp_tag: EbmlEncoderTag) -> uint {\n             let r = doc_as_u32(self.next_doc(exp_tag));\n-            debug2!(\"_next_uint exp_tag={:?} result={}\", exp_tag, r);\n+            debug!(\"_next_uint exp_tag={:?} result={}\", exp_tag, r);\n             r as uint\n         }\n     }\n@@ -384,7 +384,7 @@ pub mod reader {\n         fn read_uint(&mut self) -> uint {\n             let v = doc_as_u64(self.next_doc(EsUint));\n             if v > (::std::uint::max_value as u64) {\n-                fail2!(\"uint {} too large for this architecture\", v);\n+                fail!(\"uint {} too large for this architecture\", v);\n             }\n             v as uint\n         }\n@@ -404,8 +404,8 @@ pub mod reader {\n         fn read_int(&mut self) -> int {\n             let v = doc_as_u64(self.next_doc(EsInt)) as i64;\n             if v > (int::max_value as i64) || v < (int::min_value as i64) {\n-                debug2!(\"FIXME \\\\#6122: Removing this makes this function miscompile\");\n-                fail2!(\"int {} out of range for this architecture\", v);\n+                debug!(\"FIXME \\\\#6122: Removing this makes this function miscompile\");\n+                fail!(\"int {} out of range for this architecture\", v);\n             }\n             v as int\n         }\n@@ -434,7 +434,7 @@ pub mod reader {\n                         name: &str,\n                         f: &fn(&mut Decoder) -> T)\n                         -> T {\n-            debug2!(\"read_enum({})\", name);\n+            debug!(\"read_enum({})\", name);\n             self._check_label(name);\n \n             let doc = self.next_doc(EsEnum);\n@@ -454,9 +454,9 @@ pub mod reader {\n                                 _: &[&str],\n                                 f: &fn(&mut Decoder, uint) -> T)\n                                 -> T {\n-            debug2!(\"read_enum_variant()\");\n+            debug!(\"read_enum_variant()\");\n             let idx = self._next_uint(EsEnumVid);\n-            debug2!(\"  idx={}\", idx);\n+            debug!(\"  idx={}\", idx);\n \n             let doc = self.next_doc(EsEnumBody);\n \n@@ -474,17 +474,17 @@ pub mod reader {\n         fn read_enum_variant_arg<T>(&mut self,\n                                     idx: uint,\n                                     f: &fn(&mut Decoder) -> T) -> T {\n-            debug2!(\"read_enum_variant_arg(idx={})\", idx);\n+            debug!(\"read_enum_variant_arg(idx={})\", idx);\n             f(self)\n         }\n \n         fn read_enum_struct_variant<T>(&mut self,\n                                        _: &[&str],\n                                        f: &fn(&mut Decoder, uint) -> T)\n                                        -> T {\n-            debug2!(\"read_enum_struct_variant()\");\n+            debug!(\"read_enum_struct_variant()\");\n             let idx = self._next_uint(EsEnumVid);\n-            debug2!(\"  idx={}\", idx);\n+            debug!(\"  idx={}\", idx);\n \n             let doc = self.next_doc(EsEnumBody);\n \n@@ -504,7 +504,7 @@ pub mod reader {\n                                              idx: uint,\n                                              f: &fn(&mut Decoder) -> T)\n                                              -> T {\n-            debug2!(\"read_enum_struct_variant_arg(name={}, idx={})\", name, idx);\n+            debug!(\"read_enum_struct_variant_arg(name={}, idx={})\", name, idx);\n             f(self)\n         }\n \n@@ -513,7 +513,7 @@ pub mod reader {\n                           _: uint,\n                           f: &fn(&mut Decoder) -> T)\n                           -> T {\n-            debug2!(\"read_struct(name={})\", name);\n+            debug!(\"read_struct(name={})\", name);\n             f(self)\n         }\n \n@@ -522,71 +522,71 @@ pub mod reader {\n                                 idx: uint,\n                                 f: &fn(&mut Decoder) -> T)\n                                 -> T {\n-            debug2!(\"read_struct_field(name={}, idx={})\", name, idx);\n+            debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n             self._check_label(name);\n             f(self)\n         }\n \n         fn read_tuple<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n-            debug2!(\"read_tuple()\");\n+            debug!(\"read_tuple()\");\n             self.read_seq(f)\n         }\n \n         fn read_tuple_arg<T>(&mut self, idx: uint, f: &fn(&mut Decoder) -> T)\n                              -> T {\n-            debug2!(\"read_tuple_arg(idx={})\", idx);\n+            debug!(\"read_tuple_arg(idx={})\", idx);\n             self.read_seq_elt(idx, f)\n         }\n \n         fn read_tuple_struct<T>(&mut self,\n                                 name: &str,\n                                 f: &fn(&mut Decoder, uint) -> T)\n                                 -> T {\n-            debug2!(\"read_tuple_struct(name={})\", name);\n+            debug!(\"read_tuple_struct(name={})\", name);\n             self.read_tuple(f)\n         }\n \n         fn read_tuple_struct_arg<T>(&mut self,\n                                     idx: uint,\n                                     f: &fn(&mut Decoder) -> T)\n                                     -> T {\n-            debug2!(\"read_tuple_struct_arg(idx={})\", idx);\n+            debug!(\"read_tuple_struct_arg(idx={})\", idx);\n             self.read_tuple_arg(idx, f)\n         }\n \n         fn read_option<T>(&mut self, f: &fn(&mut Decoder, bool) -> T) -> T {\n-            debug2!(\"read_option()\");\n+            debug!(\"read_option()\");\n             do self.read_enum(\"Option\") |this| {\n                 do this.read_enum_variant([\"None\", \"Some\"]) |this, idx| {\n                     match idx {\n                         0 => f(this, false),\n                         1 => f(this, true),\n-                        _ => fail2!(),\n+                        _ => fail!(),\n                     }\n                 }\n             }\n         }\n \n         fn read_seq<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n-            debug2!(\"read_seq()\");\n+            debug!(\"read_seq()\");\n             do self.push_doc(EsVec) |d| {\n                 let len = d._next_uint(EsVecLen);\n-                debug2!(\"  len={}\", len);\n+                debug!(\"  len={}\", len);\n                 f(d, len)\n             }\n         }\n \n         fn read_seq_elt<T>(&mut self, idx: uint, f: &fn(&mut Decoder) -> T)\n                            -> T {\n-            debug2!(\"read_seq_elt(idx={})\", idx);\n+            debug!(\"read_seq_elt(idx={})\", idx);\n             self.push_doc(EsVecElt, f)\n         }\n \n         fn read_map<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n-            debug2!(\"read_map()\");\n+            debug!(\"read_map()\");\n             do self.push_doc(EsMap) |d| {\n                 let len = d._next_uint(EsMapLen);\n-                debug2!(\"  len={}\", len);\n+                debug!(\"  len={}\", len);\n                 f(d, len)\n             }\n         }\n@@ -595,15 +595,15 @@ pub mod reader {\n                                idx: uint,\n                                f: &fn(&mut Decoder) -> T)\n                                -> T {\n-            debug2!(\"read_map_elt_key(idx={})\", idx);\n+            debug!(\"read_map_elt_key(idx={})\", idx);\n             self.push_doc(EsMapKey, f)\n         }\n \n         fn read_map_elt_val<T>(&mut self,\n                                idx: uint,\n                                f: &fn(&mut Decoder) -> T)\n                                -> T {\n-            debug2!(\"read_map_elt_val(idx={})\", idx);\n+            debug!(\"read_map_elt_val(idx={})\", idx);\n             self.push_doc(EsMapVal, f)\n         }\n     }\n@@ -639,7 +639,7 @@ pub mod writer {\n                             n as u8]),\n             4u => w.write(&[0x10u8 | ((n >> 24_u) as u8), (n >> 16_u) as u8,\n                             (n >> 8_u) as u8, n as u8]),\n-            _ => fail2!(\"vint to write too big: {}\", n)\n+            _ => fail!(\"vint to write too big: {}\", n)\n         };\n     }\n \n@@ -648,7 +648,7 @@ pub mod writer {\n         if n < 0x4000_u { write_sized_vuint(w, n, 2u); return; }\n         if n < 0x200000_u { write_sized_vuint(w, n, 3u); return; }\n         if n < 0x10000000_u { write_sized_vuint(w, n, 4u); return; }\n-        fail2!(\"vint to write too big: {}\", n);\n+        fail!(\"vint to write too big: {}\", n);\n     }\n \n     pub fn Encoder(w: @io::Writer) -> Encoder {\n@@ -662,7 +662,7 @@ pub mod writer {\n     // FIXME (#2741): Provide a function to write the standard ebml header.\n     impl Encoder {\n         pub fn start_tag(&mut self, tag_id: uint) {\n-            debug2!(\"Start tag {}\", tag_id);\n+            debug!(\"Start tag {}\", tag_id);\n \n             // Write the enum ID:\n             write_vuint(self.writer, tag_id);\n@@ -681,7 +681,7 @@ pub mod writer {\n             write_sized_vuint(self.writer, size, 4u);\n             self.writer.seek(cur_pos as int, io::SeekSet);\n \n-            debug2!(\"End tag (size = {})\", size);\n+            debug!(\"End tag (size = {})\", size);\n         }\n \n         pub fn wr_tag(&mut self, tag_id: uint, blk: &fn()) {\n@@ -745,12 +745,12 @@ pub mod writer {\n         }\n \n         pub fn wr_bytes(&mut self, b: &[u8]) {\n-            debug2!(\"Write {} bytes\", b.len());\n+            debug!(\"Write {} bytes\", b.len());\n             self.writer.write(b);\n         }\n \n         pub fn wr_str(&mut self, s: &str) {\n-            debug2!(\"Write str: {}\", s);\n+            debug!(\"Write str: {}\", s);\n             self.writer.write(s.as_bytes());\n         }\n     }\n@@ -969,15 +969,15 @@ mod tests {\n     #[test]\n     fn test_option_int() {\n         fn test_v(v: Option<int>) {\n-            debug2!(\"v == {:?}\", v);\n+            debug!(\"v == {:?}\", v);\n             let bytes = do io::with_bytes_writer |wr| {\n                 let mut ebml_w = writer::Encoder(wr);\n                 v.encode(&mut ebml_w)\n             };\n             let ebml_doc = reader::Doc(@bytes);\n             let mut deser = reader::Decoder(ebml_doc);\n             let v1 = serialize::Decodable::decode(&mut deser);\n-            debug2!(\"v1 == {:?}\", v1);\n+            debug!(\"v1 == {:?}\", v1);\n             assert_eq!(v, v1);\n         }\n "}, {"sha": "fda88c583ce0fe71be9827d95128974cb1ac468e", "filename": "src/libextra/fileinput.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -506,7 +506,7 @@ mod test {\n             let contents =\n                 vec::from_fn(3, |j| format!(\"{} {}\", i, j));\n             make_file(filename.get_ref(), contents);\n-            debug2!(\"contents={:?}\", contents);\n+            debug!(\"contents={:?}\", contents);\n             all_lines.push_all(contents);\n         }\n \n@@ -555,7 +555,7 @@ mod test {\n             let expected_path = match line {\n                 \"1\" | \"2\" => filenames[0].clone(),\n                 \"3\" | \"4\" => filenames[2].clone(),\n-                _ => fail2!(\"unexpected line\")\n+                _ => fail!(\"unexpected line\")\n             };\n             assert_eq!(state.current_path.clone(), expected_path);\n             count += 1;"}, {"sha": "9d6c2e8aa8207d0b4269ac8811c9c9280e5db283", "filename": "src/libextra/flate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflate.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -121,11 +121,11 @@ mod tests {\n             do 2000.times {\n                 input.push_all(r.choose(words));\n             }\n-            debug2!(\"de/inflate of {} bytes of random word-sequences\",\n+            debug!(\"de/inflate of {} bytes of random word-sequences\",\n                    input.len());\n             let cmp = deflate_bytes(input);\n             let out = inflate_bytes(cmp);\n-            debug2!(\"{} bytes deflated to {} ({:.1f}% size)\",\n+            debug!(\"{} bytes deflated to {} ({:.1f}% size)\",\n                    input.len(), cmp.len(),\n                    100.0 * ((cmp.len() as f64) / (input.len() as f64)));\n             assert_eq!(input, out);"}, {"sha": "fdb296e5f403b3d84693bd59158047257d146270", "filename": "src/libextra/future.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffuture.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -57,7 +57,7 @@ impl<A> Future<A> {\n         let state = replace(&mut this.state, Evaluating);\n         match state {\n             Forced(v) => v,\n-            _ => fail2!( \"Logic error.\" ),\n+            _ => fail!( \"Logic error.\" ),\n         }\n     }\n \n@@ -69,10 +69,10 @@ impl<A> Future<A> {\n         */\n         match self.state {\n             Forced(ref v) => return v,\n-            Evaluating => fail2!(\"Recursive forcing of future!\"),\n+            Evaluating => fail!(\"Recursive forcing of future!\"),\n             Pending(_) => {\n                 match replace(&mut self.state, Evaluating) {\n-                    Forced(_) | Evaluating => fail2!(\"Logic error.\"),\n+                    Forced(_) | Evaluating => fail!(\"Logic error.\"),\n                     Pending(f) => {\n                         self.state = Forced(f());\n                         self.get_ref()\n@@ -217,7 +217,7 @@ mod test {\n     #[test]\n     #[should_fail]\n     fn test_futurefail() {\n-        let mut f = Future::spawn(|| fail2!());\n+        let mut f = Future::spawn(|| fail!());\n         let _x: ~str = f.get();\n     }\n "}, {"sha": "a0ce29cd1b64468a64e431ca60e8af9abf00ac9d", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -60,7 +60,7 @@\n //!     ];\n //!     let matches = match getopts(args.tail(), opts) {\n //!         Ok(m) => { m }\n-//!         Err(f) => { fail2!(f.to_err_msg()) }\n+//!         Err(f) => { fail!(f.to_err_msg()) }\n //!     };\n //!     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n //!         print_usage(program, opts);\n@@ -190,7 +190,7 @@ impl Matches {\n     pub fn opt_vals(&self, nm: &str) -> ~[Optval] {\n         match find_opt(self.opts, Name::from_str(nm)) {\n             Some(id) => self.vals[id].clone(),\n-            None => fail2!(\"No option '{}' defined\", nm)\n+            None => fail!(\"No option '{}' defined\", nm)\n         }\n     }\n \n@@ -556,7 +556,7 @@ pub mod groups {\n             } = (*self).clone();\n \n             match (short_name.len(), long_name.len()) {\n-                (0,0) => fail2!(\"this long-format option was given no name\"),\n+                (0,0) => fail!(\"this long-format option was given no name\"),\n                 (0,_) => Opt {\n                     name: Long((long_name)),\n                     hasarg: hasarg,\n@@ -582,7 +582,7 @@ pub mod groups {\n                         }\n                     ]\n                 },\n-                (_,_) => fail2!(\"something is wrong with the long-form opt\")\n+                (_,_) => fail!(\"something is wrong with the long-form opt\")\n             }\n         }\n     }\n@@ -701,7 +701,7 @@ pub mod groups {\n                     row.push_str(short_name);\n                     row.push_char(' ');\n                 }\n-                _ => fail2!(\"the short name should only be 1 ascii char long\"),\n+                _ => fail!(\"the short name should only be 1 ascii char long\"),\n             }\n \n             // long option\n@@ -815,7 +815,7 @@ pub mod groups {\n \n                 (B, Cr, UnderLim) => { B }\n                 (B, Cr, OverLim)  if (i - last_start + 1) > lim\n-                                => fail2!(\"word starting with {} longer than limit!\",\n+                                => fail!(\"word starting with {} longer than limit!\",\n                                         ss.slice(last_start, i + 1)),\n                 (B, Cr, OverLim)  => { slice(); slice_start = last_start; B }\n                 (B, Ws, UnderLim) => { last_end = i; C }\n@@ -888,7 +888,7 @@ mod tests {\n             assert!(m.opt_present(\"test\"));\n             assert_eq!(m.opt_str(\"test\").unwrap(), ~\"20\");\n           }\n-          _ => { fail2!(\"test_reqopt_long failed\"); }\n+          _ => { fail!(\"test_reqopt_long failed\"); }\n         }\n     }\n \n@@ -899,7 +899,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionMissing_),\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -910,7 +910,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -921,7 +921,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionDuplicated_),\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -935,7 +935,7 @@ mod tests {\n             assert!(m.opt_present(\"t\"));\n             assert_eq!(m.opt_str(\"t\").unwrap(), ~\"20\");\n           }\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -946,7 +946,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionMissing_),\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -957,7 +957,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -968,7 +968,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionDuplicated_),\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -984,7 +984,7 @@ mod tests {\n             assert!(m.opt_present(\"test\"));\n             assert_eq!(m.opt_str(\"test\").unwrap(), ~\"20\");\n           }\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -995,7 +995,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert!(!m.opt_present(\"test\")),\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -1006,7 +1006,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -1017,7 +1017,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionDuplicated_),\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -1031,7 +1031,7 @@ mod tests {\n             assert!((m.opt_present(\"t\")));\n             assert_eq!(m.opt_str(\"t\").unwrap(), ~\"20\");\n           }\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -1042,7 +1042,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert!(!m.opt_present(\"t\")),\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -1053,7 +1053,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -1064,7 +1064,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionDuplicated_),\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -1077,7 +1077,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert!(m.opt_present(\"test\")),\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -1088,7 +1088,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert!(!m.opt_present(\"test\")),\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -1099,10 +1099,10 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => {\n-            error2!(\"{:?}\", f.clone().to_err_msg());\n+            error!(\"{:?}\", f.clone().to_err_msg());\n             check_fail_type(f, UnexpectedArgument_);\n           }\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -1113,7 +1113,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionDuplicated_),\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -1124,7 +1124,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert!(m.opt_present(\"t\")),\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -1135,7 +1135,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert!(!m.opt_present(\"t\")),\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -1150,7 +1150,7 @@ mod tests {\n \n             assert!(m.free[0] == ~\"20\");\n           }\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -1161,7 +1161,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionDuplicated_),\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -1175,7 +1175,7 @@ mod tests {\n           Ok(ref m) => {\n             assert_eq!(m.opt_count(\"v\"), 1);\n           }\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -1188,7 +1188,7 @@ mod tests {\n           Ok(ref m) => {\n             assert_eq!(m.opt_count(\"v\"), 2);\n           }\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -1201,7 +1201,7 @@ mod tests {\n           Ok(ref m) => {\n             assert_eq!(m.opt_count(\"v\"), 2);\n           }\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -1214,7 +1214,7 @@ mod tests {\n           Ok(ref m) => {\n             assert_eq!(m.opt_count(\"verbose\"), 1);\n           }\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -1227,7 +1227,7 @@ mod tests {\n           Ok(ref m) => {\n             assert_eq!(m.opt_count(\"verbose\"), 2);\n           }\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -1242,7 +1242,7 @@ mod tests {\n             assert!((m.opt_present(\"test\")));\n             assert_eq!(m.opt_str(\"test\").unwrap(), ~\"20\");\n           }\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -1253,7 +1253,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert!(!m.opt_present(\"test\")),\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -1264,7 +1264,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -1281,7 +1281,7 @@ mod tests {\n               assert!(pair[0] == ~\"20\");\n               assert!(pair[1] == ~\"30\");\n           }\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -1295,7 +1295,7 @@ mod tests {\n             assert!((m.opt_present(\"t\")));\n             assert_eq!(m.opt_str(\"t\").unwrap(), ~\"20\");\n           }\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -1306,7 +1306,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert!(!m.opt_present(\"t\")),\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -1317,7 +1317,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -1334,7 +1334,7 @@ mod tests {\n             assert!(pair[0] == ~\"20\");\n             assert!(pair[1] == ~\"30\");\n           }\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -1345,7 +1345,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, UnrecognizedOption_),\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -1356,7 +1356,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, UnrecognizedOption_),\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -1388,7 +1388,7 @@ mod tests {\n             assert!(pair[1] == ~\"-60 70\");\n             assert!((!m.opt_present(\"notpresent\")));\n           }\n-          _ => fail2!()\n+          _ => fail!()\n         }\n     }\n \n@@ -1399,7 +1399,7 @@ mod tests {\n         let args_single = ~[~\"-e\", ~\"foo\"];\n         let matches_single = &match getopts(args_single, opts) {\n           result::Ok(m) => m,\n-          result::Err(_) => fail2!()\n+          result::Err(_) => fail!()\n         };\n         assert!(matches_single.opts_present([~\"e\"]));\n         assert!(matches_single.opts_present([~\"encrypt\", ~\"e\"]));\n@@ -1415,7 +1415,7 @@ mod tests {\n         let args_both = ~[~\"-e\", ~\"foo\", ~\"--encrypt\", ~\"foo\"];\n         let matches_both = &match getopts(args_both, opts) {\n           result::Ok(m) => m,\n-          result::Err(_) => fail2!()\n+          result::Err(_) => fail!()\n         };\n         assert!(matches_both.opts_present([~\"e\"]));\n         assert!(matches_both.opts_present([~\"encrypt\"]));\n@@ -1437,7 +1437,7 @@ mod tests {\n         let opts = ~[optmulti(\"L\"), optmulti(\"M\")];\n         let matches = &match getopts(args, opts) {\n           result::Ok(m) => m,\n-          result::Err(_) => fail2!()\n+          result::Err(_) => fail!()\n         };\n         assert!(matches.opts_present([~\"L\"]));\n         assert_eq!(matches.opts_str([~\"L\"]).unwrap(), ~\"foo\");\n@@ -1580,8 +1580,8 @@ Options:\n \n         let generated_usage = groups::usage(\"Usage: fruits\", optgroups);\n \n-        debug2!(\"expected: <<{}>>\", expected);\n-        debug2!(\"generated: <<{}>>\", generated_usage);\n+        debug!(\"expected: <<{}>>\", expected);\n+        debug!(\"generated: <<{}>>\", generated_usage);\n         assert_eq!(generated_usage, expected);\n     }\n \n@@ -1608,8 +1608,8 @@ Options:\n \n         let usage = groups::usage(\"Usage: fruits\", optgroups);\n \n-        debug2!(\"expected: <<{}>>\", expected);\n-        debug2!(\"generated: <<{}>>\", usage);\n+        debug!(\"expected: <<{}>>\", expected);\n+        debug!(\"generated: <<{}>>\", usage);\n         assert!(usage == expected)\n     }\n \n@@ -1635,8 +1635,8 @@ Options:\n \n         let usage = groups::usage(\"Usage: fruits\", optgroups);\n \n-        debug2!(\"expected: <<{}>>\", expected);\n-        debug2!(\"generated: <<{}>>\", usage);\n+        debug!(\"expected: <<{}>>\", expected);\n+        debug!(\"generated: <<{}>>\", usage);\n         assert!(usage == expected)\n     }\n }"}, {"sha": "e151568ad7f818c21cc2ad0850163ab9e31f622a", "filename": "src/libextra/json.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -880,10 +880,10 @@ pub fn Decoder(json: Json) -> Decoder {\n \n impl serialize::Decoder for Decoder {\n     fn read_nil(&mut self) -> () {\n-        debug2!(\"read_nil\");\n+        debug!(\"read_nil\");\n         match self.stack.pop() {\n             Null => (),\n-            value => fail2!(\"not a null: {:?}\", value)\n+            value => fail!(\"not a null: {:?}\", value)\n         }\n     }\n \n@@ -900,18 +900,18 @@ impl serialize::Decoder for Decoder {\n     fn read_int(&mut self) -> int { self.read_f64() as int }\n \n     fn read_bool(&mut self) -> bool {\n-        debug2!(\"read_bool\");\n+        debug!(\"read_bool\");\n         match self.stack.pop() {\n             Boolean(b) => b,\n-            value => fail2!(\"not a boolean: {:?}\", value)\n+            value => fail!(\"not a boolean: {:?}\", value)\n         }\n     }\n \n     fn read_f64(&mut self) -> f64 {\n-        debug2!(\"read_f64\");\n+        debug!(\"read_f64\");\n         match self.stack.pop() {\n             Number(f) => f,\n-            value => fail2!(\"not a number: {:?}\", value)\n+            value => fail!(\"not a number: {:?}\", value)\n         }\n     }\n     fn read_f32(&mut self) -> f32 { self.read_f64() as f32 }\n@@ -921,50 +921,50 @@ impl serialize::Decoder for Decoder {\n         let mut v = ~[];\n         let s = self.read_str();\n         for c in s.iter() { v.push(c) }\n-        if v.len() != 1 { fail2!(\"string must have one character\") }\n+        if v.len() != 1 { fail!(\"string must have one character\") }\n         v[0]\n     }\n \n     fn read_str(&mut self) -> ~str {\n-        debug2!(\"read_str\");\n+        debug!(\"read_str\");\n         match self.stack.pop() {\n             String(s) => s,\n-            json => fail2!(\"not a string: {:?}\", json)\n+            json => fail!(\"not a string: {:?}\", json)\n         }\n     }\n \n     fn read_enum<T>(&mut self, name: &str, f: &fn(&mut Decoder) -> T) -> T {\n-        debug2!(\"read_enum({})\", name);\n+        debug!(\"read_enum({})\", name);\n         f(self)\n     }\n \n     fn read_enum_variant<T>(&mut self,\n                             names: &[&str],\n                             f: &fn(&mut Decoder, uint) -> T)\n                             -> T {\n-        debug2!(\"read_enum_variant(names={:?})\", names);\n+        debug!(\"read_enum_variant(names={:?})\", names);\n         let name = match self.stack.pop() {\n             String(s) => s,\n             Object(o) => {\n                 let n = match o.find(&~\"variant\").expect(\"invalidly encoded json\") {\n                     &String(ref s) => s.clone(),\n-                    _ => fail2!(\"invalidly encoded json\"),\n+                    _ => fail!(\"invalidly encoded json\"),\n                 };\n                 match o.find(&~\"fields\").expect(\"invalidly encoded json\") {\n                     &List(ref l) => {\n                         for field in l.rev_iter() {\n                             self.stack.push(field.clone());\n                         }\n                     },\n-                    _ => fail2!(\"invalidly encoded json\")\n+                    _ => fail!(\"invalidly encoded json\")\n                 }\n                 n\n             }\n-            ref json => fail2!(\"invalid variant: {:?}\", *json),\n+            ref json => fail!(\"invalid variant: {:?}\", *json),\n         };\n         let idx = match names.iter().position(|n| str::eq_slice(*n, name)) {\n             Some(idx) => idx,\n-            None => fail2!(\"Unknown variant name: {}\", name),\n+            None => fail!(\"Unknown variant name: {}\", name),\n         };\n         f(self, idx)\n     }\n@@ -973,15 +973,15 @@ impl serialize::Decoder for Decoder {\n                                 idx: uint,\n                                 f: &fn(&mut Decoder) -> T)\n                                 -> T {\n-        debug2!(\"read_enum_variant_arg(idx={})\", idx);\n+        debug!(\"read_enum_variant_arg(idx={})\", idx);\n         f(self)\n     }\n \n     fn read_enum_struct_variant<T>(&mut self,\n                                    names: &[&str],\n                                    f: &fn(&mut Decoder, uint) -> T)\n                                    -> T {\n-        debug2!(\"read_enum_struct_variant(names={:?})\", names);\n+        debug!(\"read_enum_struct_variant(names={:?})\", names);\n         self.read_enum_variant(names, f)\n     }\n \n@@ -991,7 +991,7 @@ impl serialize::Decoder for Decoder {\n                                          idx: uint,\n                                          f: &fn(&mut Decoder) -> T)\n                                          -> T {\n-        debug2!(\"read_enum_struct_variant_field(name={}, idx={})\", name, idx);\n+        debug!(\"read_enum_struct_variant_field(name={}, idx={})\", name, idx);\n         self.read_enum_variant_arg(idx, f)\n     }\n \n@@ -1000,7 +1000,7 @@ impl serialize::Decoder for Decoder {\n                       len: uint,\n                       f: &fn(&mut Decoder) -> T)\n                       -> T {\n-        debug2!(\"read_struct(name={}, len={})\", name, len);\n+        debug!(\"read_struct(name={}, len={})\", name, len);\n         let value = f(self);\n         self.stack.pop();\n         value\n@@ -1011,12 +1011,12 @@ impl serialize::Decoder for Decoder {\n                             idx: uint,\n                             f: &fn(&mut Decoder) -> T)\n                             -> T {\n-        debug2!(\"read_struct_field(name={}, idx={})\", name, idx);\n+        debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n         match self.stack.pop() {\n             Object(obj) => {\n                 let mut obj = obj;\n                 let value = match obj.pop(&name.to_owned()) {\n-                    None => fail2!(\"no such field: {}\", name),\n+                    None => fail!(\"no such field: {}\", name),\n                     Some(json) => {\n                         self.stack.push(json);\n                         f(self)\n@@ -1025,36 +1025,36 @@ impl serialize::Decoder for Decoder {\n                 self.stack.push(Object(obj));\n                 value\n             }\n-            value => fail2!(\"not an object: {:?}\", value)\n+            value => fail!(\"not an object: {:?}\", value)\n         }\n     }\n \n     fn read_tuple<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n-        debug2!(\"read_tuple()\");\n+        debug!(\"read_tuple()\");\n         self.read_seq(f)\n     }\n \n     fn read_tuple_arg<T>(&mut self,\n                          idx: uint,\n                          f: &fn(&mut Decoder) -> T)\n                          -> T {\n-        debug2!(\"read_tuple_arg(idx={})\", idx);\n+        debug!(\"read_tuple_arg(idx={})\", idx);\n         self.read_seq_elt(idx, f)\n     }\n \n     fn read_tuple_struct<T>(&mut self,\n                             name: &str,\n                             f: &fn(&mut Decoder, uint) -> T)\n                             -> T {\n-        debug2!(\"read_tuple_struct(name={})\", name);\n+        debug!(\"read_tuple_struct(name={})\", name);\n         self.read_tuple(f)\n     }\n \n     fn read_tuple_struct_arg<T>(&mut self,\n                                 idx: uint,\n                                 f: &fn(&mut Decoder) -> T)\n                                 -> T {\n-        debug2!(\"read_tuple_struct_arg(idx={})\", idx);\n+        debug!(\"read_tuple_struct_arg(idx={})\", idx);\n         self.read_tuple_arg(idx, f)\n     }\n \n@@ -1066,7 +1066,7 @@ impl serialize::Decoder for Decoder {\n     }\n \n     fn read_seq<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n-        debug2!(\"read_seq()\");\n+        debug!(\"read_seq()\");\n         let len = match self.stack.pop() {\n             List(list) => {\n                 let len = list.len();\n@@ -1075,18 +1075,18 @@ impl serialize::Decoder for Decoder {\n                 }\n                 len\n             }\n-            _ => fail2!(\"not a list\"),\n+            _ => fail!(\"not a list\"),\n         };\n         f(self, len)\n     }\n \n     fn read_seq_elt<T>(&mut self, idx: uint, f: &fn(&mut Decoder) -> T) -> T {\n-        debug2!(\"read_seq_elt(idx={})\", idx);\n+        debug!(\"read_seq_elt(idx={})\", idx);\n         f(self)\n     }\n \n     fn read_map<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n-        debug2!(\"read_map()\");\n+        debug!(\"read_map()\");\n         let len = match self.stack.pop() {\n             Object(obj) => {\n                 let len = obj.len();\n@@ -1096,7 +1096,7 @@ impl serialize::Decoder for Decoder {\n                 }\n                 len\n             }\n-            json => fail2!(\"not an object: {:?}\", json),\n+            json => fail!(\"not an object: {:?}\", json),\n         };\n         f(self, len)\n     }\n@@ -1105,13 +1105,13 @@ impl serialize::Decoder for Decoder {\n                            idx: uint,\n                            f: &fn(&mut Decoder) -> T)\n                            -> T {\n-        debug2!(\"read_map_elt_key(idx={})\", idx);\n+        debug!(\"read_map_elt_key(idx={})\", idx);\n         f(self)\n     }\n \n     fn read_map_elt_val<T>(&mut self, idx: uint, f: &fn(&mut Decoder) -> T)\n                            -> T {\n-        debug2!(\"read_map_elt_val(idx={})\", idx);\n+        debug!(\"read_map_elt_val(idx={})\", idx);\n         f(self)\n     }\n }"}, {"sha": "5eada3dfb1a4e5b1365bd3de45832174005194aa", "filename": "src/libextra/list.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Flist.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -98,7 +98,7 @@ pub fn len<T>(ls: @List<T>) -> uint {\n pub fn tail<T>(ls: @List<T>) -> @List<T> {\n     match *ls {\n         Cons(_, tl) => return tl,\n-        Nil => fail2!(\"list empty\")\n+        Nil => fail!(\"list empty\")\n     }\n }\n \n@@ -107,7 +107,7 @@ pub fn head<T:Clone>(ls: @List<T>) -> T {\n     match *ls {\n       Cons(ref hd, _) => (*hd).clone(),\n       // makes me sad\n-      _ => fail2!(\"head invoked on empty list\")\n+      _ => fail!(\"head invoked on empty list\")\n     }\n }\n "}, {"sha": "cd5ccc14cafb1a52169503c54ae633779d4aafd2", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -353,7 +353,7 @@ impl Rem<BigUint, BigUint> for BigUint {\n \n impl Neg<BigUint> for BigUint {\n     #[inline]\n-    fn neg(&self) -> BigUint { fail2!() }\n+    fn neg(&self) -> BigUint { fail!() }\n }\n \n impl Integer for BigUint {\n@@ -375,7 +375,7 @@ impl Integer for BigUint {\n     }\n \n     fn div_mod_floor(&self, other: &BigUint) -> (BigUint, BigUint) {\n-        if other.is_zero() { fail2!() }\n+        if other.is_zero() { fail!() }\n         if self.is_zero() { return (Zero::zero(), Zero::zero()); }\n         if *other == One::one() { return ((*self).clone(), Zero::zero()); }\n \n@@ -824,7 +824,7 @@ fn get_radix_base(radix: uint) -> (uint, uint) {\n         14 => (38416, 4),\n         15 => (50625, 4),\n         16 => (65536, 4),\n-        _  => fail2!()\n+        _  => fail!()\n     }\n }\n \n@@ -848,7 +848,7 @@ fn get_radix_base(radix: uint) -> (uint, uint) {\n         14 => (1475789056, 8),\n         15 => (2562890625, 8),\n         16 => (4294967296, 8),\n-        _  => fail2!()\n+        _  => fail!()\n     }\n }\n \n@@ -1102,7 +1102,7 @@ impl Integer for BigInt {\n         let d = BigInt::from_biguint(Plus, d_ui);\n         let r = BigInt::from_biguint(Plus, r_ui);\n         match (self.sign, other.sign) {\n-            (_,    Zero)   => fail2!(),\n+            (_,    Zero)   => fail!(),\n             (Plus, Plus)  | (Zero, Plus)  => ( d,  r),\n             (Plus, Minus) | (Zero, Minus) => (-d,  r),\n             (Minus, Plus)                 => (-d, -r),\n@@ -1128,7 +1128,7 @@ impl Integer for BigInt {\n         let d = BigInt::from_biguint(Plus, d_ui);\n         let m = BigInt::from_biguint(Plus, m_ui);\n         match (self.sign, other.sign) {\n-            (_,    Zero)   => fail2!(),\n+            (_,    Zero)   => fail!(),\n             (Plus, Plus)  | (Zero, Plus)  => (d, m),\n             (Plus, Minus) | (Zero, Minus) => if m.is_zero() {\n                 (-d, Zero::zero())\n@@ -1942,7 +1942,7 @@ mod biguint_tests {\n              ~\"2\" +\n              str::from_chars(vec::from_elem(bits / 2 - 1, '0')) + \"1\"),\n             (10, match bits {\n-                32 => ~\"8589934593\", 16 => ~\"131073\", _ => fail2!()\n+                32 => ~\"8589934593\", 16 => ~\"131073\", _ => fail!()\n             }),\n             (16,\n              ~\"2\" +\n@@ -1959,7 +1959,7 @@ mod biguint_tests {\n             (10, match bits {\n                 32 => ~\"55340232229718589441\",\n                 16 => ~\"12885032961\",\n-                _ => fail2!()\n+                _ => fail!()\n             }),\n             (16, ~\"3\" +\n              str::from_chars(vec::from_elem(bits / 4 - 1, '0')) + \"2\" +\n@@ -2014,7 +2014,7 @@ mod biguint_tests {\n         fn check(n: uint, s: &str) {\n             let n = factor(n);\n             let ans = match FromStrRadix::from_str_radix(s, 10) {\n-                Some(x) => x, None => fail2!()\n+                Some(x) => x, None => fail!()\n             };\n             assert_eq!(n, ans);\n         }"}, {"sha": "abb802c06f3b2943bd50cb8781872f8cfc08b4c0", "filename": "src/libextra/num/rational.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Frational.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -50,7 +50,7 @@ impl<T: Clone + Integer + Ord>\n     #[inline]\n     pub fn new(numer: T, denom: T) -> Ratio<T> {\n         if denom == Zero::zero() {\n-            fail2!(\"denominator == 0\");\n+            fail!(\"denominator == 0\");\n         }\n         let mut ret = Ratio::new_raw(numer, denom);\n         ret.reduce();"}, {"sha": "e7032db5a9195d05ef79664598da7571fcaa48a0", "filename": "src/libextra/ringbuf.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fringbuf.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -127,7 +127,7 @@ impl<T> RingBuf<T> {\n     pub fn get<'a>(&'a self, i: uint) -> &'a T {\n         let idx = self.raw_index(i);\n         match self.elts[idx] {\n-            None => fail2!(),\n+            None => fail!(),\n             Some(ref v) => v\n         }\n     }\n@@ -138,7 +138,7 @@ impl<T> RingBuf<T> {\n     pub fn get_mut<'a>(&'a mut self, i: uint) -> &'a mut T {\n         let idx = self.raw_index(i);\n         match self.elts[idx] {\n-            None => fail2!(),\n+            None => fail!(),\n             Some(ref mut v) => v\n         }\n     }\n@@ -373,21 +373,21 @@ mod tests {\n         assert_eq!(d.len(), 3u);\n         d.push_back(137);\n         assert_eq!(d.len(), 4u);\n-        debug2!(\"{:?}\", d.front());\n+        debug!(\"{:?}\", d.front());\n         assert_eq!(*d.front().unwrap(), 42);\n-        debug2!(\"{:?}\", d.back());\n+        debug!(\"{:?}\", d.back());\n         assert_eq!(*d.back().unwrap(), 137);\n         let mut i = d.pop_front();\n-        debug2!(\"{:?}\", i);\n+        debug!(\"{:?}\", i);\n         assert_eq!(i, Some(42));\n         i = d.pop_back();\n-        debug2!(\"{:?}\", i);\n+        debug!(\"{:?}\", i);\n         assert_eq!(i, Some(137));\n         i = d.pop_back();\n-        debug2!(\"{:?}\", i);\n+        debug!(\"{:?}\", i);\n         assert_eq!(i, Some(137));\n         i = d.pop_back();\n-        debug2!(\"{:?}\", i);\n+        debug!(\"{:?}\", i);\n         assert_eq!(i, Some(17));\n         assert_eq!(d.len(), 0u);\n         d.push_back(3);\n@@ -398,10 +398,10 @@ mod tests {\n         assert_eq!(d.len(), 3u);\n         d.push_front(1);\n         assert_eq!(d.len(), 4u);\n-        debug2!(\"{:?}\", d.get(0));\n-        debug2!(\"{:?}\", d.get(1));\n-        debug2!(\"{:?}\", d.get(2));\n-        debug2!(\"{:?}\", d.get(3));\n+        debug!(\"{:?}\", d.get(0));\n+        debug!(\"{:?}\", d.get(1));\n+        debug!(\"{:?}\", d.get(2));\n+        debug!(\"{:?}\", d.get(3));\n         assert_eq!(*d.get(0), 1);\n         assert_eq!(*d.get(1), 2);\n         assert_eq!(*d.get(2), 3);"}, {"sha": "e5ef9ee12d5a4b06228915c04ff081b57463cf95", "filename": "src/libextra/semver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsemver.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -159,7 +159,7 @@ fn take_nonempty_prefix(rdr: @io::Reader,\n     if buf.is_empty() {\n         bad_parse::cond.raise(())\n     }\n-    debug2!(\"extracted nonempty prefix: {}\", buf);\n+    debug!(\"extracted nonempty prefix: {}\", buf);\n     (buf, ch)\n }\n \n@@ -235,7 +235,7 @@ pub fn parse(s: &str) -> Option<Version> {\n     }\n     let s = s.trim();\n     let mut bad = false;\n-    do bad_parse::cond.trap(|_| { debug2!(\"bad\"); bad = true }).inside {\n+    do bad_parse::cond.trap(|_| { debug!(\"bad\"); bad = true }).inside {\n         do io::with_str_reader(s) |rdr| {\n             let v = parse_reader(rdr);\n             if bad || v.to_str() != s.to_owned() {"}, {"sha": "0ca0ff66039d859fbc1763d316c56f17b32fd3d5", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -265,7 +265,7 @@ mod test_map {\n         assert!(m.insert(5, 14));\n         let new = 100;\n         match m.find_mut(&5) {\n-            None => fail2!(), Some(x) => *x = new\n+            None => fail!(), Some(x) => *x = new\n         }\n         assert_eq!(m.find(&5), Some(&new));\n     }"}, {"sha": "d884f4f05c1763b0016db8b0e2e63c7aea63c308", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -564,7 +564,7 @@ impl<T:Clone + Ord> MergeState<T> {\n             shift_vec(array, dest, c2, len2);\n             swap(&mut array[dest+len2], &mut tmp[c1]);\n         } else if len1 == 0 {\n-            fail2!(\"Comparison violates its contract!\");\n+            fail!(\"Comparison violates its contract!\");\n         } else {\n             assert_eq!(len2, 0);\n             assert!(len1 > 1);\n@@ -683,7 +683,7 @@ impl<T:Clone + Ord> MergeState<T> {\n             shift_vec(array, dest+1, c1+1, len1);\n             swap(&mut array[dest], &mut tmp[c2]);\n         } else if len2 == 0 {\n-            fail2!(\"Comparison violates its contract!\");\n+            fail!(\"Comparison violates its contract!\");\n         } else {\n             assert_eq!(len1, 0);\n             assert!(len2 != 0);\n@@ -790,7 +790,7 @@ mod test_qsort {\n         quick_sort::<int>(v1, leual);\n         let mut i = 0u;\n         while i < len {\n-            // debug2!(v2[i]);\n+            // debug!(v2[i]);\n             assert_eq!(v2[i], v1[i]);\n             i += 1;\n         }\n@@ -833,7 +833,7 @@ mod test_qsort {\n         let immut_names = names;\n \n         for (&a, &b) in expected.iter().zip(immut_names.iter()) {\n-            debug2!(\"{} {}\", a, b);\n+            debug!(\"{} {}\", a, b);\n             assert_eq!(a, b);\n         }\n     }\n@@ -851,7 +851,7 @@ mod tests {\n         let v3 = merge_sort::<int>(v1, f);\n         let mut i = 0u;\n         while i < len {\n-            debug2!(\"{:?}\", v3[i]);\n+            debug!(\"{:?}\", v3[i]);\n             assert_eq!(v3[i], v2[i]);\n             i += 1;\n         }\n@@ -922,7 +922,7 @@ mod test_tim_sort {\n         fn lt(&self, other: &CVal) -> bool {\n             let mut rng = rand::rng();\n             if rng.gen::<f64>() > 0.995 {\n-                fail2!(\"It's happening!!!\");\n+                fail!(\"It's happening!!!\");\n             }\n             (*self).val < other.val\n         }\n@@ -936,7 +936,7 @@ mod test_tim_sort {\n         tim_sort::<int>(v1);\n         let mut i = 0u;\n         while i < len {\n-            // debug2!(v2[i]);\n+            // debug!(v2[i]);\n             assert_eq!(v2[i], v1[i]);\n             i += 1u;\n         }\n@@ -977,7 +977,7 @@ mod test_tim_sort {\n         };\n \n         tim_sort(arr);\n-        fail2!(\"Guarantee the fail\");\n+        fail!(\"Guarantee the fail\");\n     }\n \n     #[deriving(Clone)]\n@@ -1045,7 +1045,7 @@ mod big_tests {\n         fn isSorted<T:Ord>(arr: &[T]) {\n             for i in range(0u, arr.len() - 1) {\n                 if arr[i] > arr[i+1] {\n-                    fail2!(\"Array not sorted\");\n+                    fail!(\"Array not sorted\");\n                 }\n             }\n         }\n@@ -1116,7 +1116,7 @@ mod big_tests {\n         fn isSorted<T:Ord>(arr: &[@T]) {\n             for i in range(0u, arr.len() - 1) {\n                 if arr[i] > arr[i+1] {\n-                    fail2!(\"Array not sorted\");\n+                    fail!(\"Array not sorted\");\n                 }\n             }\n         }"}, {"sha": "5a2c1e0998ca789b60bfd61936e4d13dfa0f0282", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -309,9 +309,9 @@ fn check_cvar_bounds<U>(out_of_bounds: Option<uint>, id: uint, act: &str,\n                         blk: &fn() -> U) -> U {\n     match out_of_bounds {\n         Some(0) =>\n-            fail2!(\"{} with illegal ID {} - this lock has no condvars!\", act, id),\n+            fail!(\"{} with illegal ID {} - this lock has no condvars!\", act, id),\n         Some(length) =>\n-            fail2!(\"{} with illegal ID {} - ID must be less than {}\", act, id, length),\n+            fail!(\"{} with illegal ID {} - ID must be less than {}\", act, id, length),\n         None => blk()\n     }\n }\n@@ -636,7 +636,7 @@ impl RWLock {\n     pub fn downgrade<'a>(&self, token: RWLockWriteMode<'a>)\n                          -> RWLockReadMode<'a> {\n         if !borrow::ref_eq(self, token.lock) {\n-            fail2!(\"Can't downgrade() with a different rwlock's write_mode!\");\n+            fail!(\"Can't downgrade() with a different rwlock's write_mode!\");\n         }\n         unsafe {\n             do task::unkillable {\n@@ -920,7 +920,7 @@ mod tests {\n \n         let result: result::Result<(),()> = do task::try {\n             do m2.lock {\n-                fail2!();\n+                fail!();\n             }\n         };\n         assert!(result.is_err());\n@@ -940,7 +940,7 @@ mod tests {\n             do task::spawn || { // linked\n                 let _ = p.recv(); // wait for sibling to get in the mutex\n                 task::deschedule();\n-                fail2!();\n+                fail!();\n             }\n             do m2.lock_cond |cond| {\n                 c.send(()); // tell sibling go ahead\n@@ -978,9 +978,9 @@ mod tests {\n                         do (|| {\n                             cond.wait(); // block forever\n                         }).finally {\n-                            error2!(\"task unwinding and sending\");\n+                            error!(\"task unwinding and sending\");\n                             c.send(());\n-                            error2!(\"task unwinding and done sending\");\n+                            error!(\"task unwinding and done sending\");\n                         }\n                     }\n                 }\n@@ -990,7 +990,7 @@ mod tests {\n             }\n             do m2.lock { }\n             c.send(sibling_convos); // let parent wait on all children\n-            fail2!();\n+            fail!();\n         };\n         assert!(result.is_err());\n         // child task must have finished by the time try returns\n@@ -1030,7 +1030,7 @@ mod tests {\n             let _ = p.recv();\n             do m.lock_cond |cond| {\n                 if !cond.signal_on(0) {\n-                    fail2!(); // success; punt sibling awake.\n+                    fail!(); // success; punt sibling awake.\n                 }\n             }\n         };\n@@ -1274,7 +1274,7 @@ mod tests {\n \n         let result: result::Result<(),()> = do task::try || {\n             do lock_rwlock_in_mode(&x2, mode1) {\n-                fail2!();\n+                fail!();\n             }\n         };\n         assert!(result.is_err());\n@@ -1321,7 +1321,7 @@ mod tests {\n             let mut xopt = Some(xwrite);\n             do y.write_downgrade |_ywrite| {\n                 y.downgrade(xopt.take_unwrap());\n-                error2!(\"oops, y.downgrade(x) should have failed!\");\n+                error!(\"oops, y.downgrade(x) should have failed!\");\n             }\n         }\n     }"}, {"sha": "cebe0ba9aa659dfc00c06de425fdb69447d35b06", "filename": "src/libextra/term.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterm.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -147,7 +147,7 @@ impl Terminal {\n                 self.out.write(s.unwrap());\n                 return true\n             } else {\n-                warn2!(\"{}\", s.unwrap_err());\n+                warn!(\"{}\", s.unwrap_err());\n             }\n         }\n         false\n@@ -167,7 +167,7 @@ impl Terminal {\n                 self.out.write(s.unwrap());\n                 return true\n             } else {\n-                warn2!(\"{}\", s.unwrap_err());\n+                warn!(\"{}\", s.unwrap_err());\n             }\n         }\n         false\n@@ -188,7 +188,7 @@ impl Terminal {\n                         self.out.write(s.unwrap());\n                         return true\n                     } else {\n-                        warn2!(\"{}\", s.unwrap_err());\n+                        warn!(\"{}\", s.unwrap_err());\n                     }\n                 }\n                 false\n@@ -226,11 +226,11 @@ impl Terminal {\n         if s.is_ok() {\n             self.out.write(s.unwrap());\n         } else if self.num_colors > 0 {\n-            warn2!(\"{}\", s.unwrap_err());\n+            warn!(\"{}\", s.unwrap_err());\n         } else {\n-            // if we support attributes but not color, it would be nice to still warn2!()\n+            // if we support attributes but not color, it would be nice to still warn!()\n             // but it's not worth testing all known attributes just for this.\n-            debug2!(\"{}\", s.unwrap_err());\n+            debug!(\"{}\", s.unwrap_err());\n         }\n     }\n "}, {"sha": "d1a0a86334af4e3657aa1170352d4bf3d75c7732", "filename": "src/libextra/terminfo/parm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparm.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -462,7 +462,7 @@ impl FormatOp {\n             'x' => FormatHex,\n             'X' => FormatHEX,\n             's' => FormatString,\n-            _ => fail2!(\"bad FormatOp char\")\n+            _ => fail!(\"bad FormatOp char\")\n         }\n     }\n     fn to_char(self) -> char {"}, {"sha": "bc24c8a6e306381663a249244e955c5749d32b6d", "filename": "src/libextra/terminfo/parser/compiled.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -190,26 +190,26 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n \n     assert!(names_bytes          > 0);\n \n-    debug2!(\"names_bytes = {}\", names_bytes);\n-    debug2!(\"bools_bytes = {}\", bools_bytes);\n-    debug2!(\"numbers_count = {}\", numbers_count);\n-    debug2!(\"string_offsets_count = {}\", string_offsets_count);\n-    debug2!(\"string_table_bytes = {}\", string_table_bytes);\n+    debug!(\"names_bytes = {}\", names_bytes);\n+    debug!(\"bools_bytes = {}\", bools_bytes);\n+    debug!(\"numbers_count = {}\", numbers_count);\n+    debug!(\"string_offsets_count = {}\", string_offsets_count);\n+    debug!(\"string_table_bytes = {}\", string_table_bytes);\n \n     if (bools_bytes as uint) > boolnames.len() {\n-        error2!(\"expected bools_bytes to be less than {} but found {}\", boolnames.len(),\n+        error!(\"expected bools_bytes to be less than {} but found {}\", boolnames.len(),\n                bools_bytes);\n         return Err(~\"incompatible file: more booleans than expected\");\n     }\n \n     if (numbers_count as uint) > numnames.len() {\n-        error2!(\"expected numbers_count to be less than {} but found {}\", numnames.len(),\n+        error!(\"expected numbers_count to be less than {} but found {}\", numnames.len(),\n                numbers_count);\n         return Err(~\"incompatible file: more numbers than expected\");\n     }\n \n     if (string_offsets_count as uint) > stringnames.len() {\n-        error2!(\"expected string_offsets_count to be less than {} but found {}\", stringnames.len(),\n+        error!(\"expected string_offsets_count to be less than {} but found {}\", stringnames.len(),\n                string_offsets_count);\n         return Err(~\"incompatible file: more string offsets than expected\");\n     }\n@@ -219,26 +219,26 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n \n     file.read_byte(); // consume NUL\n \n-    debug2!(\"term names: {:?}\", term_names);\n+    debug!(\"term names: {:?}\", term_names);\n \n     let mut bools_map = HashMap::new();\n     if bools_bytes != 0 {\n         for i in range(0, bools_bytes) {\n             let b = file.read_byte();\n             if b < 0 {\n-                error2!(\"EOF reading bools after {} entries\", i);\n+                error!(\"EOF reading bools after {} entries\", i);\n                 return Err(~\"error: expected more bools but hit EOF\");\n             } else if b == 1 {\n-                debug2!(\"{} set\", bnames[i]);\n+                debug!(\"{} set\", bnames[i]);\n                 bools_map.insert(bnames[i].to_owned(), true);\n             }\n         }\n     }\n \n-    debug2!(\"bools: {:?}\", bools_map);\n+    debug!(\"bools: {:?}\", bools_map);\n \n     if (bools_bytes + names_bytes) % 2 == 1 {\n-        debug2!(\"adjusting for padding between bools and numbers\");\n+        debug!(\"adjusting for padding between bools and numbers\");\n         file.read_byte(); // compensate for padding\n     }\n \n@@ -247,13 +247,13 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n         for i in range(0, numbers_count) {\n             let n = file.read_le_u16();\n             if n != 0xFFFF {\n-                debug2!(\"{}\\\\#{}\", nnames[i], n);\n+                debug!(\"{}\\\\#{}\", nnames[i], n);\n                 numbers_map.insert(nnames[i].to_owned(), n);\n             }\n         }\n     }\n \n-    debug2!(\"numbers: {:?}\", numbers_map);\n+    debug!(\"numbers: {:?}\", numbers_map);\n \n     let mut string_map = HashMap::new();\n \n@@ -263,12 +263,12 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n             string_offsets.push(file.read_le_u16());\n         }\n \n-        debug2!(\"offsets: {:?}\", string_offsets);\n+        debug!(\"offsets: {:?}\", string_offsets);\n \n         let string_table = file.read_bytes(string_table_bytes as uint);\n \n         if string_table.len() != string_table_bytes as uint {\n-            error2!(\"EOF reading string table after {} bytes, wanted {}\", string_table.len(),\n+            error!(\"EOF reading string table after {} bytes, wanted {}\", string_table.len(),\n                    string_table_bytes);\n             return Err(~\"error: hit EOF before end of string table\");\n         }"}, {"sha": "1f8405dca949830b7eceece5cedc2d8f2232a976", "filename": "src/libextra/test.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -155,10 +155,10 @@ pub fn test_main(args: &[~str], tests: ~[TestDescAndFn]) {\n     let opts =\n         match parse_opts(args) {\n             Some(Ok(o)) => o,\n-            Some(Err(msg)) => fail2!(\"{}\", msg),\n+            Some(Err(msg)) => fail!(\"{}\", msg),\n             None => return\n         };\n-    if !run_tests_console(&opts, tests) { fail2!(\"Some tests failed\"); }\n+    if !run_tests_console(&opts, tests) { fail!(\"Some tests failed\"); }\n }\n \n // A variant optimized for invocation with a static test vector.\n@@ -178,7 +178,7 @@ pub fn test_main_static(args: &[~str], tests: &[TestDescAndFn]) {\n             TestDescAndFn { testfn: StaticBenchFn(f), desc: t.desc.clone() },\n \n             _ => {\n-                fail2!(\"non-static tests passed to test::test_main_static\");\n+                fail!(\"non-static tests passed to test::test_main_static\");\n             }\n         }\n     };\n@@ -240,7 +240,7 @@ Test Attributes:\n     #[bench]       - Indicates a function is a benchmark to be run. This\n                      function takes one argument (extra::test::BenchHarness).\n     #[should_fail] - This function (also labeled with #[test]) will only pass if\n-                     the code causes a failure (an assertion failure or fail2!)\n+                     the code causes a failure (an assertion failure or fail!)\n     #[ignore]      - When applied to a function which is already attributed as a\n                      test, then the test runner will ignore these tests during\n                      normal test runs. Running with --ignored will run these\n@@ -358,7 +358,7 @@ impl ConsoleTestState {\n                                                      io::Truncate]) {\n                 result::Ok(w) => Some(w),\n                 result::Err(ref s) => {\n-                    fail2!(\"can't open output file: {}\", *s)\n+                    fail!(\"can't open output file: {}\", *s)\n                 }\n             },\n             None => None\n@@ -607,7 +607,7 @@ pub fn fmt_bench_samples(bs: &BenchSamples) -> ~str {\n pub fn run_tests_console(opts: &TestOpts,\n                          tests: ~[TestDescAndFn]) -> bool {\n     fn callback(event: &TestEvent, st: &mut ConsoleTestState) {\n-        debug2!(\"callback(event={:?})\", event);\n+        debug!(\"callback(event={:?})\", event);\n         match (*event).clone() {\n             TeFiltered(ref filtered_tests) => st.write_run_start(filtered_tests.len()),\n             TeWait(ref test, padding) => st.write_test_start(test, padding),\n@@ -649,7 +649,7 @@ pub fn run_tests_console(opts: &TestOpts,\n     match tests.iter().max_by(|t|len_if_padded(*t)) {\n         Some(t) => {\n             let n = t.desc.name.to_str();\n-            debug2!(\"Setting max_name_len from: {}\", n);\n+            debug!(\"Setting max_name_len from: {}\", n);\n             st.max_name_len = n.len();\n         },\n         None => {}\n@@ -736,7 +736,7 @@ fn run_tests(opts: &TestOpts,\n     // It's tempting to just spawn all the tests at once, but since we have\n     // many tests that run in other processes we would be making a big mess.\n     let concurrency = get_concurrency();\n-    debug2!(\"using {} test tasks\", concurrency);\n+    debug!(\"using {} test tasks\", concurrency);\n \n     let mut remaining = filtered_tests;\n     remaining.reverse();\n@@ -783,7 +783,7 @@ fn get_concurrency() -> uint {\n             let opt_n: Option<uint> = FromStr::from_str(s);\n             match opt_n {\n                 Some(n) if n > 0 => n,\n-                _ => fail2!(\"RUST_TEST_TASKS is `{}`, should be a positive integer.\", s)\n+                _ => fail!(\"RUST_TEST_TASKS is `{}`, should be a positive integer.\", s)\n             }\n         }\n         None => {\n@@ -1047,7 +1047,7 @@ impl MetricMap {\n         };\n \n         if ok {\n-            debug2!(\"rewriting file '{:?}' with updated metrics\", p);\n+            debug!(\"rewriting file '{:?}' with updated metrics\", p);\n             self.save(p);\n         }\n         return (diff, ok)\n@@ -1086,7 +1086,7 @@ impl BenchHarness {\n \n     pub fn bench_n(&mut self, n: u64, f: &fn(&mut BenchHarness)) {\n         self.iterations = n;\n-        debug2!(\"running benchmark for {} iterations\",\n+        debug!(\"running benchmark for {} iterations\",\n                n as uint);\n         f(self);\n     }\n@@ -1127,7 +1127,7 @@ impl BenchHarness {\n             stats::winsorize(samples, 5.0);\n             let summ5 = stats::Summary::new(samples);\n \n-            debug2!(\"{} samples, median {}, MAD={}, MADP={}\",\n+            debug!(\"{} samples, median {}, MAD={}, MADP={}\",\n                    samples.len(),\n                    summ.median as f64,\n                    summ.median_abs_dev as f64,\n@@ -1198,7 +1198,7 @@ mod tests {\n \n     #[test]\n     pub fn do_not_run_ignored_tests() {\n-        fn f() { fail2!(); }\n+        fn f() { fail!(); }\n         let desc = TestDescAndFn {\n             desc: TestDesc {\n                 name: StaticTestName(\"whatever\"),\n@@ -1234,7 +1234,7 @@ mod tests {\n \n     #[test]\n     fn test_should_fail() {\n-        fn f() { fail2!(); }\n+        fn f() { fail!(); }\n         let desc = TestDescAndFn {\n             desc: TestDesc {\n                 name: StaticTestName(\"whatever\"),\n@@ -1273,7 +1273,7 @@ mod tests {\n         let args = ~[~\"progname\", ~\"filter\"];\n         let opts = match parse_opts(args) {\n             Some(Ok(o)) => o,\n-            _ => fail2!(\"Malformed arg in first_free_arg_should_be_a_filter\")\n+            _ => fail!(\"Malformed arg in first_free_arg_should_be_a_filter\")\n         };\n         assert!(\"filter\" == opts.filter.clone().unwrap());\n     }\n@@ -1283,7 +1283,7 @@ mod tests {\n         let args = ~[~\"progname\", ~\"filter\", ~\"--ignored\"];\n         let opts = match parse_opts(args) {\n             Some(Ok(o)) => o,\n-            _ => fail2!(\"Malformed arg in parse_ignored_flag\")\n+            _ => fail!(\"Malformed arg in parse_ignored_flag\")\n         };\n         assert!((opts.run_ignored));\n     }"}, {"sha": "ab701f1f982c81e6e20d92ddc152a01b5bb56029", "filename": "src/libextra/time.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -955,13 +955,13 @@ mod tests {\n         static SOME_FUTURE_DATE: i64 = 1577836800i64; // 2020-01-01T00:00:00Z\n \n         let tv1 = get_time();\n-        debug2!(\"tv1={:?} sec + {:?} nsec\", tv1.sec as uint, tv1.nsec as uint);\n+        debug!(\"tv1={:?} sec + {:?} nsec\", tv1.sec as uint, tv1.nsec as uint);\n \n         assert!(tv1.sec > SOME_RECENT_DATE);\n         assert!(tv1.nsec < 1000000000i32);\n \n         let tv2 = get_time();\n-        debug2!(\"tv2={:?} sec + {:?} nsec\", tv2.sec as uint, tv2.nsec as uint);\n+        debug!(\"tv2={:?} sec + {:?} nsec\", tv2.sec as uint, tv2.nsec as uint);\n \n         assert!(tv2.sec >= tv1.sec);\n         assert!(tv2.sec < SOME_FUTURE_DATE);\n@@ -975,16 +975,16 @@ mod tests {\n         let s0 = precise_time_s();\n         let ns1 = precise_time_ns();\n \n-        debug2!(\"s0={} sec\", f64::to_str_digits(s0, 9u));\n+        debug!(\"s0={} sec\", f64::to_str_digits(s0, 9u));\n         assert!(s0 > 0.);\n         let ns0 = (s0 * 1000000000.) as u64;\n-        debug2!(\"ns0={:?} ns\", ns0);\n+        debug!(\"ns0={:?} ns\", ns0);\n \n-        debug2!(\"ns1={:?} ns\", ns0);\n+        debug!(\"ns1={:?} ns\", ns0);\n         assert!(ns1 >= ns0);\n \n         let ns2 = precise_time_ns();\n-        debug2!(\"ns2={:?} ns\", ns0);\n+        debug!(\"ns2={:?} ns\", ns0);\n         assert!(ns2 >= ns1);\n     }\n \n@@ -1016,7 +1016,7 @@ mod tests {\n         let time = Timespec::new(1234567890, 54321);\n         let local = at(time);\n \n-        error2!(\"time_at: {:?}\", local);\n+        error!(\"time_at: {:?}\", local);\n \n         assert!(local.tm_sec == 30_i32);\n         assert!(local.tm_min == 31_i32);\n@@ -1091,7 +1091,7 @@ mod tests {\n             == Err(~\"Invalid time\"));\n \n         match strptime(\"Fri Feb 13 15:31:30.01234 2009\", format) {\n-          Err(e) => fail2!(e),\n+          Err(e) => fail!(e),\n           Ok(ref tm) => {\n             assert!(tm.tm_sec == 30_i32);\n             assert!(tm.tm_min == 31_i32);\n@@ -1111,7 +1111,7 @@ mod tests {\n         fn test(s: &str, format: &str) -> bool {\n             match strptime(s, format) {\n               Ok(ref tm) => tm.strftime(format) == s.to_owned(),\n-              Err(e) => fail2!(e)\n+              Err(e) => fail!(e)\n             }\n         }\n \n@@ -1237,7 +1237,7 @@ mod tests {\n         let utc   = at_utc(time);\n         let local = at(time);\n \n-        error2!(\"test_ctime: {:?} {:?}\", utc.ctime(), local.ctime());\n+        error!(\"test_ctime: {:?} {:?}\", utc.ctime(), local.ctime());\n \n         assert_eq!(utc.ctime(), ~\"Fri Feb 13 23:31:30 2009\");\n         assert_eq!(local.ctime(), ~\"Fri Feb 13 15:31:30 2009\");"}, {"sha": "ad196b32fb2cafc84b3cf3631bda1ddf80a3504e", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -831,7 +831,7 @@ fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n       }\n     }\n     return match node.take() {\n-        Some(~TreeNode{value, _}) => Some(value), None => fail2!()\n+        Some(~TreeNode{value, _}) => Some(value), None => fail!()\n     };\n }\n \n@@ -900,7 +900,7 @@ mod test_treemap {\n         assert!(m.insert(5, 14));\n         let new = 100;\n         match m.find_mut(&5) {\n-          None => fail2!(), Some(x) => *x = new\n+          None => fail!(), Some(x) => *x = new\n         }\n         assert_eq!(m.find(&5), Some(&new));\n     }"}, {"sha": "3ee1025132315dccdbd72fe96b8adc62d3690bd9", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -183,11 +183,11 @@ impl Database {\n         assert!(os::path_exists(&self.db_filename));\n         let f = io::file_reader(&self.db_filename);\n         match f {\n-            Err(e) => fail2!(\"Couldn't load workcache database {}: {}\",\n+            Err(e) => fail!(\"Couldn't load workcache database {}: {}\",\n                             self.db_filename.display(), e.to_str()),\n             Ok(r) =>\n                 match json::from_reader(r) {\n-                    Err(e) => fail2!(\"Couldn't parse workcache database (from file {}): {}\",\n+                    Err(e) => fail!(\"Couldn't parse workcache database (from file {}): {}\",\n                                     self.db_filename.display(), e.to_str()),\n                     Ok(r) => {\n                         let mut decoder = json::Decoder(r);\n@@ -219,7 +219,7 @@ impl Logger {\n     }\n \n     pub fn info(&self, i: &str) {\n-        info2!(\"workcache: {}\", i);\n+        info!(\"workcache: {}\", i);\n     }\n }\n \n@@ -264,7 +264,7 @@ fn json_encode<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n \n // FIXME(#5121)\n fn json_decode<T:Decodable<json::Decoder>>(s: &str) -> T {\n-    debug2!(\"json decoding: {}\", s);\n+    debug!(\"json decoding: {}\", s);\n     do io::with_str_reader(s) |rdr| {\n         let j = json::from_reader(rdr).unwrap();\n         let mut decoder = json::Decoder(j);\n@@ -321,15 +321,15 @@ impl Exec {\n                           dependency_kind: &str,\n                           dependency_name: &str,\n                           dependency_val: &str) {\n-        debug2!(\"Discovering input {} {} {}\", dependency_kind, dependency_name, dependency_val);\n+        debug!(\"Discovering input {} {} {}\", dependency_kind, dependency_name, dependency_val);\n         self.discovered_inputs.insert_work_key(WorkKey::new(dependency_kind, dependency_name),\n                                  dependency_val.to_owned());\n     }\n     pub fn discover_output(&mut self,\n                            dependency_kind: &str,\n                            dependency_name: &str,\n                            dependency_val: &str) {\n-        debug2!(\"Discovering output {} {} {}\", dependency_kind, dependency_name, dependency_val);\n+        debug!(\"Discovering output {} {} {}\", dependency_kind, dependency_name, dependency_val);\n         self.discovered_outputs.insert_work_key(WorkKey::new(dependency_kind, dependency_name),\n                                  dependency_val.to_owned());\n     }\n@@ -368,7 +368,7 @@ impl<'self> Prep<'self> {\n \n impl<'self> Prep<'self> {\n     pub fn declare_input(&mut self, kind: &str, name: &str, val: &str) {\n-        debug2!(\"Declaring input {} {} {}\", kind, name, val);\n+        debug!(\"Declaring input {} {} {}\", kind, name, val);\n         self.declared_inputs.insert_work_key(WorkKey::new(kind, name),\n                                  val.to_owned());\n     }\n@@ -377,9 +377,9 @@ impl<'self> Prep<'self> {\n                 name: &str, val: &str) -> bool {\n         let k = kind.to_owned();\n         let f = self.ctxt.freshness.get().find(&k);\n-        debug2!(\"freshness for: {}/{}/{}/{}\", cat, kind, name, val)\n+        debug!(\"freshness for: {}/{}/{}/{}\", cat, kind, name, val)\n         let fresh = match f {\n-            None => fail2!(\"missing freshness-function for '{}'\", kind),\n+            None => fail!(\"missing freshness-function for '{}'\", kind),\n             Some(f) => (*f)(name, val)\n         };\n         do self.ctxt.logger.write |lg| {\n@@ -418,7 +418,7 @@ impl<'self> Prep<'self> {\n             &'self self, blk: ~fn(&mut Exec) -> T) -> Work<'self, T> {\n         let mut bo = Some(blk);\n \n-        debug2!(\"exec_work: looking up {} and {:?}\", self.fn_name,\n+        debug!(\"exec_work: looking up {} and {:?}\", self.fn_name,\n                self.declared_inputs);\n         let cached = do self.ctxt.db.read |db| {\n             db.prepare(self.fn_name, &self.declared_inputs)\n@@ -429,14 +429,14 @@ impl<'self> Prep<'self> {\n             if self.all_fresh(\"declared input\",&self.declared_inputs) &&\n                self.all_fresh(\"discovered input\", disc_in) &&\n                self.all_fresh(\"discovered output\", disc_out) => {\n-                debug2!(\"Cache hit!\");\n-                debug2!(\"Trying to decode: {:?} / {:?} / {}\",\n+                debug!(\"Cache hit!\");\n+                debug!(\"Trying to decode: {:?} / {:?} / {}\",\n                        disc_in, disc_out, *res);\n                 Work::from_value(json_decode(*res))\n             }\n \n             _ => {\n-                debug2!(\"Cache miss!\");\n+                debug!(\"Cache miss!\");\n                 let (port, chan) = oneshot();\n                 let blk = bo.take_unwrap();\n                 let chan = Cell::new(chan);"}, {"sha": "8bf3d5008db2fcfb82ce54ade5e29093ff0d6ca0", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -129,13 +129,13 @@ pub mod jit {\n             let cstore = sess.cstore;\n             let r = cstore::get_used_crate_files(cstore);\n             for cratepath in r.iter() {\n-                debug2!(\"linking: {}\", cratepath.display());\n+                debug!(\"linking: {}\", cratepath.display());\n \n                 do cratepath.with_c_str |buf_t| {\n                     if !llvm::LLVMRustLoadCrate(manager, buf_t) {\n                         llvm_err(sess, ~\"Could not link\");\n                     }\n-                    debug2!(\"linked: {}\", cratepath.display());\n+                    debug!(\"linked: {}\", cratepath.display());\n                 }\n             }\n \n@@ -915,20 +915,20 @@ pub fn link_binary(sess: Session,\n \n     let output = if *sess.building_library {\n         let long_libname = output_dll_filename(sess.targ_cfg.os, lm);\n-        debug2!(\"link_meta.name:  {}\", lm.name);\n-        debug2!(\"long_libname: {}\", long_libname);\n-        debug2!(\"out_filename: {}\", out_filename.display());\n+        debug!(\"link_meta.name:  {}\", lm.name);\n+        debug!(\"long_libname: {}\", long_libname);\n+        debug!(\"out_filename: {}\", out_filename.display());\n         let out_dirname = out_filename.dir_path();\n-        debug2!(\"dirname(out_filename): {}\", out_dirname.display());\n+        debug!(\"dirname(out_filename): {}\", out_dirname.display());\n \n         out_filename.with_filename(long_libname)\n     } else {\n         out_filename.clone()\n     };\n \n-    debug2!(\"output: {}\", output.display());\n+    debug!(\"output: {}\", output.display());\n     let cc_args = link_args(sess, obj_filename, out_filename, lm);\n-    debug2!(\"{} link args: {}\", cc_prog, cc_args.connect(\" \"));\n+    debug!(\"{} link args: {}\", cc_prog, cc_args.connect(\" \"));\n     if (sess.opts.debugging_opts & session::print_link_args) != 0 {\n         io::println(format!(\"{} link args: {}\", cc_prog, cc_args.connect(\" \")));\n     }"}, {"sha": "3d6a8350795b35e3af767456e71f9e4d581d66c2", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -29,7 +29,7 @@ pub fn get_rpath_flags(sess: session::Session, out_filename: &Path)\n         return ~[];\n     }\n \n-    debug2!(\"preparing the RPATH!\");\n+    debug!(\"preparing the RPATH!\");\n \n     let sysroot = sess.filesearch.sysroot();\n     let output = out_filename;\n@@ -60,13 +60,13 @@ fn get_rpaths(os: session::Os,\n               output: &Path,\n               libs: &[Path],\n               target_triple: &str) -> ~[~str] {\n-    debug2!(\"sysroot: {}\", sysroot.display());\n-    debug2!(\"output: {}\", output.display());\n-    debug2!(\"libs:\");\n+    debug!(\"sysroot: {}\", sysroot.display());\n+    debug!(\"output: {}\", output.display());\n+    debug!(\"libs:\");\n     for libpath in libs.iter() {\n-        debug2!(\"    {}\", libpath.display());\n+        debug!(\"    {}\", libpath.display());\n     }\n-    debug2!(\"target_triple: {}\", target_triple);\n+    debug!(\"target_triple: {}\", target_triple);\n \n     // Use relative paths to the libraries. Binaries can be moved\n     // as long as they maintain the relative relationship to the\n@@ -81,9 +81,9 @@ fn get_rpaths(os: session::Os,\n     let fallback_rpaths = ~[get_install_prefix_rpath(target_triple)];\n \n     fn log_rpaths(desc: &str, rpaths: &[~str]) {\n-        debug2!(\"{} rpaths:\", desc);\n+        debug!(\"{} rpaths:\", desc);\n         for rpath in rpaths.iter() {\n-            debug2!(\"    {}\", *rpath);\n+            debug!(\"    {}\", *rpath);\n         }\n     }\n \n@@ -188,7 +188,7 @@ mod test {\n         let res = get_install_prefix_rpath(\"triple\");\n         let mut d = Path::new(env!(\"CFG_PREFIX\"));\n         d.push(\"lib/rustc/triple/lib\");\n-        debug2!(\"test_prefix_path: {} vs. {}\",\n+        debug!(\"test_prefix_path: {} vs. {}\",\n                res,\n                d.display());\n         assert!(res.as_bytes().ends_with(d.as_vec()));\n@@ -248,7 +248,7 @@ mod test {\n     fn test_get_absolute_rpath() {\n         let res = get_absolute_rpath(&Path::new(\"lib/libstd.so\"));\n         let lib = os::make_absolute(&Path::new(\"lib\"));\n-        debug2!(\"test_get_absolute_rpath: {} vs. {}\",\n+        debug!(\"test_get_absolute_rpath: {} vs. {}\",\n                res.to_str(), lib.display());\n \n         // FIXME (#9639): This needs to handle non-utf8 paths"}, {"sha": "67a59f24e2938885d893f2399c561d12fab509be", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -394,33 +394,33 @@ pub fn phase_6_link_output(sess: Session,\n \n pub fn stop_after_phase_3(sess: Session) -> bool {\n    if sess.opts.no_trans {\n-        debug2!(\"invoked with --no-trans, returning early from compile_input\");\n+        debug!(\"invoked with --no-trans, returning early from compile_input\");\n         return true;\n     }\n     return false;\n }\n \n pub fn stop_after_phase_1(sess: Session) -> bool {\n     if sess.opts.parse_only {\n-        debug2!(\"invoked with --parse-only, returning early from compile_input\");\n+        debug!(\"invoked with --parse-only, returning early from compile_input\");\n         return true;\n     }\n     return false;\n }\n \n pub fn stop_after_phase_5(sess: Session) -> bool {\n     if sess.opts.output_type != link::output_type_exe {\n-        debug2!(\"not building executable, returning early from compile_input\");\n+        debug!(\"not building executable, returning early from compile_input\");\n         return true;\n     }\n \n     if sess.opts.is_static && *sess.building_library {\n-        debug2!(\"building static library, returning early from compile_input\");\n+        debug!(\"building static library, returning early from compile_input\");\n         return true;\n     }\n \n     if sess.opts.jit {\n-        debug2!(\"running JIT, returning early from compile_input\");\n+        debug!(\"running JIT, returning early from compile_input\");\n         return true;\n     }\n     return false;\n@@ -1045,7 +1045,7 @@ pub fn build_output_filenames(input: &input,\n \n pub fn early_error(emitter: @diagnostic::Emitter, msg: &str) -> ! {\n     emitter.emit(None, msg, diagnostic::fatal);\n-    fail2!();\n+    fail!();\n }\n \n pub fn list_metadata(sess: Session, path: &Path, out: @io::Writer) {\n@@ -1070,7 +1070,7 @@ mod test {\n         let matches =\n             &match getopts([~\"--test\"], optgroups()) {\n               Ok(m) => m,\n-              Err(f) => fail2!(\"test_switch_implies_cfg_test: {}\", f.to_err_msg())\n+              Err(f) => fail!(\"test_switch_implies_cfg_test: {}\", f.to_err_msg())\n             };\n         let sessopts = build_session_options(\n             @\"rustc\",\n@@ -1091,7 +1091,7 @@ mod test {\n             &match getopts([~\"--test\", ~\"--cfg=test\"], optgroups()) {\n               Ok(m) => m,\n               Err(f) => {\n-                fail2!(\"test_switch_implies_cfg_test_unless_cfg_test: {}\",\n+                fail!(\"test_switch_implies_cfg_test_unless_cfg_test: {}\",\n                        f.to_err_msg());\n               }\n             };"}, {"sha": "9541a03aff25e5326b603f3c268f11ff9e2c757d", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -78,7 +78,7 @@ impl fold::ast_fold for TestHarnessGenerator {\n \n     fn fold_item(&self, i: @ast::item) -> Option<@ast::item> {\n         self.cx.path.push(i.ident);\n-        debug2!(\"current path: {}\",\n+        debug!(\"current path: {}\",\n                ast_util::path_name_i(self.cx.path.clone()));\n \n         if is_test_fn(self.cx, i) || is_bench_fn(i) {\n@@ -91,7 +91,7 @@ impl fold::ast_fold for TestHarnessGenerator {\n                                      tests\");\n                 }\n                 _ => {\n-                    debug2!(\"this is a test function\");\n+                    debug!(\"this is a test function\");\n                     let test = Test {\n                         span: i.span,\n                         path: self.cx.path.clone(),\n@@ -100,7 +100,7 @@ impl fold::ast_fold for TestHarnessGenerator {\n                         should_fail: should_fail(i)\n                     };\n                     self.cx.testfns.push(test);\n-                    // debug2!(\"have {} test/bench functions\",\n+                    // debug!(\"have {} test/bench functions\",\n                     //        cx.testfns.len());\n                 }\n             }\n@@ -327,7 +327,7 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::item {\n         span: dummy_sp(),\n      };\n \n-    debug2!(\"Synthetic test module:\\n{}\\n\",\n+    debug!(\"Synthetic test module:\\n{}\\n\",\n            pprust::item_to_str(@item.clone(), cx.sess.intr()));\n \n     return @item;\n@@ -381,7 +381,7 @@ fn is_extra(crate: &ast::Crate) -> bool {\n }\n \n fn mk_test_descs(cx: &TestCtxt) -> @ast::Expr {\n-    debug2!(\"building test vector from {} tests\", cx.testfns.len());\n+    debug!(\"building test vector from {} tests\", cx.testfns.len());\n     let mut descs = ~[];\n     for test in cx.testfns.iter() {\n         descs.push(mk_test_desc_and_fn_rec(cx, test));\n@@ -404,7 +404,7 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::Expr {\n     let span = test.span;\n     let path = test.path.clone();\n \n-    debug2!(\"encoding {}\", ast_util::path_name_i(path));\n+    debug!(\"encoding {}\", ast_util::path_name_i(path));\n \n     let name_lit: ast::lit =\n         nospan(ast::lit_str(ast_util::path_name_i(path).to_managed(), ast::CookedStr));"}, {"sha": "f7b1955191abd5d6528e3426e7993eb4e596bd94", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -74,11 +74,11 @@ struct cache_entry {\n }\n \n fn dump_crates(crate_cache: &[cache_entry]) {\n-    debug2!(\"resolved crates:\");\n+    debug!(\"resolved crates:\");\n     for entry in crate_cache.iter() {\n-        debug2!(\"cnum: {:?}\", entry.cnum);\n-        debug2!(\"span: {:?}\", entry.span);\n-        debug2!(\"hash: {:?}\", entry.hash);\n+        debug!(\"cnum: {:?}\", entry.cnum);\n+        debug!(\"span: {:?}\", entry.span);\n+        debug!(\"hash: {:?}\", entry.hash);\n     }\n }\n \n@@ -155,7 +155,7 @@ fn visit_view_item(e: @mut Env, i: &ast::view_item) {\n                   }\n             }\n           };\n-          debug2!(\"resolving extern mod stmt. ident: {:?}, meta: {:?}\",\n+          debug!(\"resolving extern mod stmt. ident: {:?}, meta: {:?}\",\n                  ident, meta_items);\n           let cnum = resolve_crate(e,\n                                    ident,\n@@ -321,7 +321,7 @@ fn resolve_crate(e: @mut Env,\n \n // Go through the crate metadata and load any crates that it references\n fn resolve_crate_deps(e: @mut Env, cdata: @~[u8]) -> cstore::cnum_map {\n-    debug2!(\"resolving deps of external crate\");\n+    debug!(\"resolving deps of external crate\");\n     // The map from crate numbers in the crate we're resolving to local crate\n     // numbers\n     let mut cnum_map = HashMap::new();\n@@ -330,18 +330,18 @@ fn resolve_crate_deps(e: @mut Env, cdata: @~[u8]) -> cstore::cnum_map {\n         let extrn_cnum = dep.cnum;\n         let cname_str = token::ident_to_str(&dep.name);\n         let cmetas = metas_with(dep.vers, @\"vers\", ~[]);\n-        debug2!(\"resolving dep crate {} ver: {} hash: {}\",\n+        debug!(\"resolving dep crate {} ver: {} hash: {}\",\n                cname_str, dep.vers, dep.hash);\n         match existing_match(e,\n                              metas_with_ident(cname_str, cmetas.clone()),\n                              dep.hash) {\n           Some(local_cnum) => {\n-            debug2!(\"already have it\");\n+            debug!(\"already have it\");\n             // We've already seen this crate\n             cnum_map.insert(extrn_cnum, local_cnum);\n           }\n           None => {\n-            debug2!(\"need to load it\");\n+            debug!(\"need to load it\");\n             // This is a new one so we've got to load it\n             // FIXME (#2404): Need better error reporting than just a bogus\n             // span."}, {"sha": "617051c217f506bc3dec9c7f5d8c9e443d5543c3", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -210,17 +210,17 @@ pub fn get_field_type(tcx: ty::ctxt, class_id: ast::DefId,\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, class_id.crate);\n     let all_items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n-    debug2!(\"Looking up {:?}\", class_id);\n+    debug!(\"Looking up {:?}\", class_id);\n     let class_doc = expect(tcx.diag,\n                            decoder::maybe_find_item(class_id.node, all_items),\n                            || format!(\"get_field_type: class ID {:?} not found\",\n                                    class_id) );\n-    debug2!(\"looking up {:?} : {:?}\", def, class_doc);\n+    debug!(\"looking up {:?} : {:?}\", def, class_doc);\n     let the_field = expect(tcx.diag,\n         decoder::maybe_find_item(def.node, class_doc),\n         || format!(\"get_field_type: in class {:?}, field ID {:?} not found\",\n                  class_id, def) );\n-    debug2!(\"got field data {:?}\", the_field);\n+    debug!(\"got field data {:?}\", the_field);\n     let ty = decoder::item_type(def, the_field, tcx, cdata);\n     ty::ty_param_bounds_and_ty {\n         generics: ty::Generics {type_param_defs: @~[],"}, {"sha": "3c79ea2fe5e3f6aac41204a37b58f0a13cee66c9", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -152,7 +152,7 @@ pub fn get_dep_hashes(cstore: &CStore) -> ~[@str] {\n         let cdata = cstore::get_crate_data(cstore, cnum);\n         let hash = decoder::get_crate_hash(cdata.data);\n         let vers = decoder::get_crate_vers(cdata.data);\n-        debug2!(\"Add hash[{}]: {} {}\", cdata.name, vers, hash);\n+        debug!(\"Add hash[{}]: {} {}\", cdata.name, vers, hash);\n         result.push(crate_hash {\n             name: cdata.name,\n             vers: vers,\n@@ -164,9 +164,9 @@ pub fn get_dep_hashes(cstore: &CStore) -> ~[@str] {\n         (a.name, a.vers, a.hash) <= (b.name, b.vers, b.hash)\n     };\n \n-    debug2!(\"sorted:\");\n+    debug!(\"sorted:\");\n     for x in sorted.iter() {\n-        debug2!(\"  hash[{}]: {}\", x.name, x.hash);\n+        debug!(\"  hash[{}]: {}\", x.name, x.hash);\n     }\n \n     sorted.map(|ch| ch.hash)"}, {"sha": "aa1c4c1eb7ec6425f4ba047e5ccf274469bc34d9", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -89,7 +89,7 @@ pub fn maybe_find_item(item_id: int, items: ebml::Doc) -> Option<ebml::Doc> {\n \n fn find_item(item_id: int, items: ebml::Doc) -> ebml::Doc {\n     match maybe_find_item(item_id, items) {\n-       None => fail2!(\"lookup_item: id not found: {}\", item_id),\n+       None => fail!(\"lookup_item: id not found: {}\", item_id),\n        Some(d) => d\n     }\n }\n@@ -148,7 +148,7 @@ fn item_family(item: ebml::Doc) -> Family {\n       'g' => PublicField,\n       'j' => PrivateField,\n       'N' => InheritedField,\n-       c => fail2!(\"unexpected family char: {}\", c)\n+       c => fail!(\"unexpected family char: {}\", c)\n     }\n }\n \n@@ -160,7 +160,7 @@ fn item_visibility(item: ebml::Doc) -> ast::visibility {\n                 'y' => ast::public,\n                 'n' => ast::private,\n                 'i' => ast::inherited,\n-                _ => fail2!(\"unknown visibility character\")\n+                _ => fail!(\"unknown visibility character\")\n             }\n         }\n     }\n@@ -494,8 +494,8 @@ pub enum DefLike {\n pub fn def_like_to_def(def_like: DefLike) -> ast::Def {\n     match def_like {\n         DlDef(def) => return def,\n-        DlImpl(*) => fail2!(\"found impl in def_like_to_def\"),\n-        DlField => fail2!(\"found field in def_like_to_def\")\n+        DlImpl(*) => fail!(\"found impl in def_like_to_def\"),\n+        DlField => fail!(\"found field in def_like_to_def\")\n     }\n }\n \n@@ -550,13 +550,13 @@ impl<'self> EachItemContext<'self> {\n         let def_like = item_to_def_like(doc, def_id, self.cdata.cnum);\n         match def_like {\n             DlDef(def) => {\n-                debug2!(\"(iterating over each item of a module) processing \\\n+                debug!(\"(iterating over each item of a module) processing \\\n                         `{}` (def {:?})\",\n                        *self.path_builder,\n                        def);\n             }\n             _ => {\n-                debug2!(\"(iterating over each item of a module) processing \\\n+                debug!(\"(iterating over each item of a module) processing \\\n                         `{}` ({}:{})\",\n                        *self.path_builder,\n                        def_id.crate,\n@@ -631,7 +631,7 @@ impl<'self> EachItemContext<'self> {\n                 reader::get_doc(root, tag_items)\n             };\n \n-            debug2!(\"(iterating over each item of a module) looking up item \\\n+            debug!(\"(iterating over each item of a module) looking up item \\\n                     {}:{} in `{}`, crate {}\",\n                    child_def_id.crate,\n                    child_def_id.node,\n@@ -644,7 +644,7 @@ impl<'self> EachItemContext<'self> {\n                 Some(child_item_doc) => {\n                     // Push the name.\n                     let child_name = item_name(self.intr, child_item_doc);\n-                    debug2!(\"(iterating over each item of a module) pushing \\\n+                    debug!(\"(iterating over each item of a module) pushing \\\n                             name `{}` onto `{}`\",\n                            token::ident_to_str(&child_name),\n                            *self.path_builder);\n@@ -682,7 +682,7 @@ impl<'self> EachItemContext<'self> {\n             let name = name_doc.as_str_slice();\n \n             // Push the name.\n-            debug2!(\"(iterating over each item of a module) pushing \\\n+            debug!(\"(iterating over each item of a module) pushing \\\n                     reexported name `{}` onto `{}` (crate {}, orig {}, \\\n                     in crate {})\",\n                    name,\n@@ -900,7 +900,7 @@ pub fn maybe_get_item_ast(cdata: Cmd, tcx: ty::ctxt,\n                           id: ast::NodeId,\n                           decode_inlined_item: decode_inlined_item)\n                        -> csearch::found_ast {\n-    debug2!(\"Looking up item: {}\", id);\n+    debug!(\"Looking up item: {}\", id);\n     let item_doc = lookup_item(id, cdata.data);\n     let path = {\n         let item_path = item_path(item_doc);\n@@ -965,7 +965,7 @@ fn get_explicit_self(item: ebml::Doc) -> ast::explicit_self_ {\n         match ch as char {\n             'i' => ast::MutImmutable,\n             'm' => ast::MutMutable,\n-            _ => fail2!(\"unknown mutability character: `{}`\", ch as char),\n+            _ => fail!(\"unknown mutability character: `{}`\", ch as char),\n         }\n     }\n \n@@ -983,7 +983,7 @@ fn get_explicit_self(item: ebml::Doc) -> ast::explicit_self_ {\n             return ast::sty_region(None, get_mutability(string[1]));\n         }\n         _ => {\n-            fail2!(\"unknown self type code: `{}`\", explicit_self_kind as char);\n+            fail!(\"unknown self type code: `{}`\", explicit_self_kind as char);\n         }\n     }\n }\n@@ -1164,7 +1164,7 @@ pub fn get_static_methods_if_impl(intr: @ident_interner,\n                 match item_family(impl_method_doc) {\n                     StaticMethod => purity = ast::impure_fn,\n                     UnsafeStaticMethod => purity = ast::unsafe_fn,\n-                    _ => fail2!()\n+                    _ => fail!()\n                 }\n \n                 static_impl_methods.push(StaticMethodInfo {\n@@ -1200,7 +1200,7 @@ fn struct_field_family_to_visibility(family: Family) -> ast::visibility {\n       PublicField => ast::public,\n       PrivateField => ast::private,\n       InheritedField => ast::inherited,\n-      _ => fail2!()\n+      _ => fail!()\n     }\n }\n \n@@ -1266,7 +1266,7 @@ fn describe_def(items: ebml::Doc, id: ast::DefId) -> ~str {\n     if id.crate != ast::LOCAL_CRATE { return ~\"external\"; }\n     let it = match maybe_find_item(id.node, items) {\n         Some(it) => it,\n-        None => fail2!(\"describe_def: item not found {:?}\", id)\n+        None => fail!(\"describe_def: item not found {:?}\", id)\n     };\n     return item_family_to_str(item_family(it));\n }\n@@ -1453,7 +1453,7 @@ pub fn translate_def_id(cdata: Cmd, did: ast::DefId) -> ast::DefId {\n \n     match cdata.cnum_map.find(&did.crate) {\n       option::Some(&n) => ast::DefId { crate: n, node: did.node },\n-      option::None => fail2!(\"didn't find a crate in the cnum_map\")\n+      option::None => fail!(\"didn't find a crate in the cnum_map\")\n     }\n }\n "}, {"sha": "9f40593a93ae76b0bad3091a020132240e761eb1", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -282,7 +282,7 @@ fn encode_symbol(ecx: &EncodeContext,\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     match ecx.item_symbols.find(&id) {\n         Some(x) => {\n-            debug2!(\"encode_symbol(id={:?}, str={})\", id, *x);\n+            debug!(\"encode_symbol(id={:?}, str={})\", id, *x);\n             ebml_w.writer.write(x.as_bytes());\n         }\n         None => {\n@@ -337,7 +337,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                             path: &[ast_map::path_elt],\n                             index: @mut ~[entry<i64>],\n                             generics: &ast::Generics) {\n-    debug2!(\"encode_enum_variant_info(id={:?})\", id);\n+    debug!(\"encode_enum_variant_info(id={:?})\", id);\n \n     let mut disr_val = 0;\n     let mut i = 0;\n@@ -423,7 +423,7 @@ fn encode_reexported_static_method(ecx: &EncodeContext,\n                                    exp: &middle::resolve::Export2,\n                                    method_def_id: DefId,\n                                    method_ident: Ident) {\n-    debug2!(\"(encode reexported static method) {}::{}\",\n+    debug!(\"(encode reexported static method) {}::{}\",\n             exp.name, ecx.tcx.sess.str_of(method_ident));\n     ebml_w.start_tag(tag_items_data_item_reexport);\n     ebml_w.start_tag(tag_items_data_item_reexport_def_id);\n@@ -496,13 +496,13 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n             if mod_path != *path || exp.name != original_name {\n                 if !encode_reexported_static_base_methods(ecx, ebml_w, exp) {\n                     if encode_reexported_static_trait_methods(ecx, ebml_w, exp) {\n-                        debug2!(\"(encode reexported static methods) {} \\\n+                        debug!(\"(encode reexported static methods) {} \\\n                                  [trait]\",\n                                 original_name);\n                     }\n                 }\n                 else {\n-                    debug2!(\"(encode reexported static methods) {} [base]\",\n+                    debug!(\"(encode reexported static methods) {} [base]\",\n                             original_name);\n                 }\n             }\n@@ -550,12 +550,12 @@ fn encode_reexports(ecx: &EncodeContext,\n                     ebml_w: &mut writer::Encoder,\n                     id: NodeId,\n                     path: &[ast_map::path_elt]) {\n-    debug2!(\"(encoding info for module) encoding reexports for {}\", id);\n+    debug!(\"(encoding info for module) encoding reexports for {}\", id);\n     match ecx.reexports2.find(&id) {\n         Some(ref exports) => {\n-            debug2!(\"(encoding info for module) found reexports for {}\", id);\n+            debug!(\"(encoding info for module) found reexports for {}\", id);\n             for exp in exports.iter() {\n-                debug2!(\"(encoding info for module) reexport '{}' ({}/{}) for \\\n+                debug!(\"(encoding info for module) reexport '{}' ({}/{}) for \\\n                         {}\",\n                        exp.name,\n                        exp.def_id.crate,\n@@ -573,7 +573,7 @@ fn encode_reexports(ecx: &EncodeContext,\n             }\n         }\n         None => {\n-            debug2!(\"(encoding info for module) found no reexports for {}\",\n+            debug!(\"(encoding info for module) found no reexports for {}\",\n                    id);\n         }\n     }\n@@ -590,7 +590,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n     encode_def_id(ebml_w, local_def(id));\n     encode_family(ebml_w, 'm');\n     encode_name(ecx, ebml_w, name);\n-    debug2!(\"(encoding info for module) encoding info for module ID {}\", id);\n+    debug!(\"(encoding info for module) encoding info for module ID {}\", id);\n \n     // Encode info about all the module children.\n     for item in md.items.iter() {\n@@ -608,7 +608,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n         match item.node {\n             item_impl(*) => {\n                 let (ident, did) = (item.ident, item.id);\n-                debug2!(\"(encoding info for module) ... encoding impl {} \\\n+                debug!(\"(encoding info for module) ... encoding impl {} \\\n                         ({:?}/{:?})\",\n                         ecx.tcx.sess.str_of(ident),\n                         did,\n@@ -627,7 +627,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n \n     // Encode the reexports of this module, if this module is public.\n     if vis == public {\n-        debug2!(\"(encoding info for module) encoding reexports for {}\", id);\n+        debug!(\"(encoding info for module) encoding reexports for {}\", id);\n         encode_reexports(ecx, ebml_w, id, path);\n     }\n \n@@ -729,7 +729,7 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n         index.push(entry {val: id as i64, pos: ebml_w.writer.tell()});\n         global_index.push(entry {val: id as i64, pos: ebml_w.writer.tell()});\n         ebml_w.start_tag(tag_items_data_item);\n-        debug2!(\"encode_info_for_struct: doing {} {}\",\n+        debug!(\"encode_info_for_struct: doing {} {}\",\n                tcx.sess.str_of(nm), id);\n         encode_struct_field_family(ebml_w, vis);\n         encode_name(ecx, ebml_w, nm);\n@@ -795,7 +795,7 @@ fn encode_info_for_method(ecx: &EncodeContext,\n                           parent_id: NodeId,\n                           ast_method_opt: Option<@method>) {\n \n-    debug2!(\"encode_info_for_method: {:?} {}\", m.def_id,\n+    debug!(\"encode_info_for_method: {:?} {}\", m.def_id,\n            ecx.tcx.sess.str_of(m.ident));\n     ebml_w.start_tag(tag_items_data_item);\n \n@@ -835,7 +835,7 @@ fn purity_static_method_family(p: purity) -> char {\n     match p {\n       unsafe_fn => 'U',\n       impure_fn => 'F',\n-      _ => fail2!(\"extern fn can't be static\")\n+      _ => fail!(\"extern fn can't be static\")\n     }\n }\n \n@@ -894,7 +894,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n     }\n     let add_to_index: &fn() = || add_to_index_(item, ebml_w, index);\n \n-    debug2!(\"encoding info for item at {}\",\n+    debug!(\"encoding info for item at {}\",\n            ecx.tcx.sess.codemap.span_to_str(item.span));\n \n     let def_id = local_def(item.id);\n@@ -1224,7 +1224,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // Encode inherent implementations for this trait.\n         encode_inherent_implementations(ecx, ebml_w, def_id);\n       }\n-      item_mac(*) => fail2!(\"item macros unimplemented\")\n+      item_mac(*) => fail!(\"item macros unimplemented\")\n     }\n }\n \n@@ -1278,15 +1278,15 @@ fn my_visit_item(i:@item, items: ast_map::map, ebml_w:&writer::Encoder,\n             let ecx : &EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n             encode_info_for_item(ecx, &mut ebml_w, i, index, *pt, i.vis);\n         }\n-        _ => fail2!(\"bad item\")\n+        _ => fail!(\"bad item\")\n     }\n }\n \n fn my_visit_foreign_item(ni:@foreign_item, items: ast_map::map, ebml_w:&writer::Encoder,\n                          ecx_ptr:*int, index: @mut ~[entry<i64>]) {\n     match items.get_copy(&ni.id) {\n         ast_map::node_foreign_item(_, abi, _, pt) => {\n-            debug2!(\"writing foreign item {}::{}\",\n+            debug!(\"writing foreign item {}::{}\",\n                    ast_map::path_to_str(\n                        *pt,\n                        token::get_ident_interner()),\n@@ -1303,7 +1303,7 @@ fn my_visit_foreign_item(ni:@foreign_item, items: ast_map::map, ebml_w:&writer::\n                                          abi);\n         }\n         // case for separate item and foreign-item tables\n-        _ => fail2!(\"bad foreign item\")\n+        _ => fail!(\"bad foreign item\")\n     }\n }\n "}, {"sha": "4b679072bba739bc0f765547c87ce96fb21c1578", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -53,7 +53,7 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n             let mut visited_dirs = HashSet::new();\n             let mut found = false;\n \n-            debug2!(\"filesearch: searching additional lib search paths [{:?}]\",\n+            debug!(\"filesearch: searching additional lib search paths [{:?}]\",\n                    self.addl_lib_search_paths.len());\n             for path in self.addl_lib_search_paths.iter() {\n                 match f(path) {\n@@ -63,7 +63,7 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n                 visited_dirs.insert(path.as_vec().to_owned());\n             }\n \n-            debug2!(\"filesearch: searching target lib path\");\n+            debug!(\"filesearch: searching target lib path\");\n             let tlib_path = make_target_lib_path(self.sysroot,\n                                         self.target_triple);\n             if !visited_dirs.contains_equiv(&tlib_path.as_vec()) {\n@@ -78,7 +78,7 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n                 let rustpath = rust_path();\n                 for path in rustpath.iter() {\n                     let tlib_path = make_rustpkg_target_lib_path(path, self.target_triple);\n-                    debug2!(\"is {} in visited_dirs? {:?}\", tlib_path.display(),\n+                    debug!(\"is {} in visited_dirs? {:?}\", tlib_path.display(),\n                             visited_dirs.contains_equiv(&tlib_path.as_vec().to_owned()));\n \n                     if !visited_dirs.contains_equiv(&tlib_path.as_vec()) {\n@@ -106,7 +106,7 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n     }\n \n     let sysroot = get_sysroot(maybe_sysroot);\n-    debug2!(\"using sysroot = {}\", sysroot.display());\n+    debug!(\"using sysroot = {}\", sysroot.display());\n     @FileSearchImpl {\n         sysroot: sysroot,\n         addl_lib_search_paths: addl_lib_search_paths,\n@@ -116,19 +116,19 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n \n pub fn search(filesearch: @FileSearch, pick: pick) {\n     do filesearch.for_each_lib_search_path() |lib_search_path| {\n-        debug2!(\"searching {}\", lib_search_path.display());\n+        debug!(\"searching {}\", lib_search_path.display());\n         let r = os::list_dir_path(lib_search_path);\n         let mut rslt = FileDoesntMatch;\n         for path in r.iter() {\n-            debug2!(\"testing {}\", path.display());\n+            debug!(\"testing {}\", path.display());\n             let maybe_picked = pick(path);\n             match maybe_picked {\n                 FileMatches => {\n-                    debug2!(\"picked {}\", path.display());\n+                    debug!(\"picked {}\", path.display());\n                     rslt = FileMatches;\n                 }\n                 FileDoesntMatch => {\n-                    debug2!(\"rejected {}\", path.display());\n+                    debug!(\"rejected {}\", path.display());\n                 }\n             }\n         }\n@@ -161,7 +161,7 @@ fn make_rustpkg_target_lib_path(dir: &Path,\n pub fn get_or_default_sysroot() -> Path {\n     match os::self_exe_path() {\n       option::Some(p) => { let mut p = p; p.pop(); p }\n-      option::None => fail2!(\"can't determine value for sysroot\")\n+      option::None => fail!(\"can't determine value for sysroot\")\n     }\n }\n "}, {"sha": "e682ff299a935a96ca507431a1b37cbeddbebe5c", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -99,21 +99,21 @@ fn find_library_crate_aux(\n           None => FileDoesntMatch,\n           Some(path_str) =>\n               if path_str.starts_with(prefix) && path_str.ends_with(suffix) {\n-                  debug2!(\"{} is a candidate\", path.display());\n+                  debug!(\"{} is a candidate\", path.display());\n                   match get_metadata_section(cx.os, path) {\n                       Some(cvec) =>\n                           if !crate_matches(cvec, cx.metas, cx.hash) {\n-                              debug2!(\"skipping {}, metadata doesn't match\",\n+                              debug!(\"skipping {}, metadata doesn't match\",\n                                   path.display());\n                               FileDoesntMatch\n                           } else {\n-                              debug2!(\"found {} with matching metadata\", path.display());\n+                              debug!(\"found {} with matching metadata\", path.display());\n                               // FIXME (#9639): This needs to handle non-utf8 paths\n                               matches.push((path.as_str().unwrap().to_owned(), cvec));\n                               FileMatches\n                           },\n                       _ => {\n-                          debug2!(\"could not load metadata for {}\", path.display());\n+                          debug!(\"could not load metadata for {}\", path.display());\n                           FileDoesntMatch\n                       }\n                   }\n@@ -151,7 +151,7 @@ pub fn crate_name_from_metas(metas: &[@ast::MetaItem]) -> @str {\n             _ => {}\n         }\n     }\n-    fail2!(\"expected to find the crate name\")\n+    fail!(\"expected to find the crate name\")\n }\n \n pub fn package_id_from_metas(metas: &[@ast::MetaItem]) -> Option<@str> {\n@@ -190,7 +190,7 @@ pub fn metadata_matches(extern_metas: &[@ast::MetaItem],\n \n // extern_metas: metas we read from the crate\n // local_metas: metas we're looking for\n-    debug2!(\"matching {} metadata requirements against {} items\",\n+    debug!(\"matching {} metadata requirements against {} items\",\n            local_metas.len(), extern_metas.len());\n \n     do local_metas.iter().all |needed| {\n@@ -213,14 +213,14 @@ fn get_metadata_section(os: Os,\n         while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n             let name_buf = llvm::LLVMGetSectionName(si.llsi);\n             let name = str::raw::from_c_str(name_buf);\n-            debug2!(\"get_metadata_section: name {}\", name);\n+            debug!(\"get_metadata_section: name {}\", name);\n             if read_meta_section_name(os) == name {\n                 let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n                 let csz = llvm::LLVMGetSectionSize(si.llsi) as uint;\n                 let mut found = None;\n                 let cvbuf: *u8 = cast::transmute(cbuf);\n                 let vlen = encoder::metadata_encoding_version.len();\n-                debug2!(\"checking {} bytes of metadata-version stamp\",\n+                debug!(\"checking {} bytes of metadata-version stamp\",\n                        vlen);\n                 let minsz = num::min(vlen, csz);\n                 let mut version_ok = false;\n@@ -231,7 +231,7 @@ fn get_metadata_section(os: Os,\n                 if !version_ok { return None; }\n \n                 let cvbuf1 = ptr::offset(cvbuf, vlen as int);\n-                debug2!(\"inflating {} bytes of compressed metadata\",\n+                debug!(\"inflating {} bytes of compressed metadata\",\n                        csz - vlen);\n                 do vec::raw::buf_as_slice(cvbuf1, csz-vlen) |bytes| {\n                     let inflated = flate::inflate_bytes(bytes);"}, {"sha": "62de991ce9631fe010762bdcf0cf9db907fba175", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -80,10 +80,10 @@ fn scan<R>(st: &mut PState, is_last: &fn(char) -> bool,\n            op: &fn(&[u8]) -> R) -> R\n {\n     let start_pos = st.pos;\n-    debug2!(\"scan: '{}' (start)\", st.data[st.pos] as char);\n+    debug!(\"scan: '{}' (start)\", st.data[st.pos] as char);\n     while !is_last(st.data[st.pos] as char) {\n         st.pos += 1;\n-        debug2!(\"scan: '{}'\", st.data[st.pos] as char);\n+        debug!(\"scan: '{}'\", st.data[st.pos] as char);\n     }\n     let end_pos = st.pos;\n     st.pos += 1;\n@@ -221,7 +221,7 @@ fn parse_region_substs(st: &mut PState) -> ty::RegionSubsts {\n             assert_eq!(next(st), '.');\n             ty::NonerasedRegions(regions)\n         }\n-        _ => fail2!(\"parse_bound_region: bad input\")\n+        _ => fail!(\"parse_bound_region: bad input\")\n     }\n }\n \n@@ -239,7 +239,7 @@ fn parse_bound_region(st: &mut PState) -> ty::bound_region {\n         assert_eq!(next(st), '|');\n         ty::br_cap_avoid(id, @parse_bound_region(st))\n       },\n-      _ => fail2!(\"parse_bound_region: bad input\")\n+      _ => fail!(\"parse_bound_region: bad input\")\n     }\n }\n \n@@ -268,15 +268,15 @@ fn parse_region(st: &mut PState) -> ty::Region {\n       'e' => {\n         ty::re_static\n       }\n-      _ => fail2!(\"parse_region: bad input\")\n+      _ => fail!(\"parse_region: bad input\")\n     }\n }\n \n fn parse_opt<T>(st: &mut PState, f: &fn(&mut PState) -> T) -> Option<T> {\n     match next(st) {\n       'n' => None,\n       's' => Some(f(st)),\n-      _ => fail2!(\"parse_opt: bad input\")\n+      _ => fail!(\"parse_opt: bad input\")\n     }\n }\n \n@@ -316,7 +316,7 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n           'D' => return ty::mk_mach_int(ast::ty_i64),\n           'f' => return ty::mk_mach_float(ast::ty_f32),\n           'F' => return ty::mk_mach_float(ast::ty_f64),\n-          _ => fail2!(\"parse_ty: bad numeric type\")\n+          _ => fail!(\"parse_ty: bad numeric type\")\n         }\n       }\n       'c' => return ty::mk_char(),\n@@ -339,7 +339,7 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n       }\n       'p' => {\n         let did = parse_def(st, TypeParameter, conv);\n-        debug2!(\"parsed ty_param: did={:?}\", did);\n+        debug!(\"parsed ty_param: did={:?}\", did);\n         return ty::mk_param(st.tcx, parse_uint(st), did);\n       }\n       's' => {\n@@ -416,7 +416,7 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n           assert_eq!(next(st), ']');\n           return ty::mk_struct(st.tcx, did, substs);\n       }\n-      c => { error2!(\"unexpected char in type string: {}\", c); fail2!();}\n+      c => { error!(\"unexpected char in type string: {}\", c); fail!();}\n     }\n }\n \n@@ -466,7 +466,7 @@ fn parse_purity(c: char) -> purity {\n       'u' => unsafe_fn,\n       'i' => impure_fn,\n       'c' => extern_fn,\n-      _ => fail2!(\"parse_purity: bad purity {}\", c)\n+      _ => fail!(\"parse_purity: bad purity {}\", c)\n     }\n }\n \n@@ -487,7 +487,7 @@ fn parse_onceness(c: char) -> ast::Onceness {\n     match c {\n         'o' => ast::Once,\n         'm' => ast::Many,\n-        _ => fail2!(\"parse_onceness: bad onceness\")\n+        _ => fail!(\"parse_onceness: bad onceness\")\n     }\n }\n \n@@ -538,21 +538,21 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n     let len = buf.len();\n     while colon_idx < len && buf[colon_idx] != ':' as u8 { colon_idx += 1u; }\n     if colon_idx == len {\n-        error2!(\"didn't find ':' when parsing def id\");\n-        fail2!();\n+        error!(\"didn't find ':' when parsing def id\");\n+        fail!();\n     }\n \n     let crate_part = buf.slice(0u, colon_idx);\n     let def_part = buf.slice(colon_idx + 1u, len);\n \n     let crate_num = match uint::parse_bytes(crate_part, 10u) {\n        Some(cn) => cn as int,\n-       None => fail2!(\"internal error: parse_def_id: crate number expected, but found {:?}\",\n+       None => fail!(\"internal error: parse_def_id: crate number expected, but found {:?}\",\n                      crate_part)\n     };\n     let def_num = match uint::parse_bytes(def_part, 10u) {\n        Some(dn) => dn as int,\n-       None => fail2!(\"internal error: parse_def_id: id expected, but found {:?}\",\n+       None => fail!(\"internal error: parse_def_id: id expected, but found {:?}\",\n                      def_part)\n     };\n     ast::DefId { crate: crate_num, node: def_num }\n@@ -598,7 +598,7 @@ fn parse_bounds(st: &mut PState, conv: conv_did) -> ty::ParamBounds {\n                 return param_bounds;\n             }\n             _ => {\n-                fail2!(\"parse_bounds: bad bounds\")\n+                fail!(\"parse_bounds: bad bounds\")\n             }\n         }\n     }"}, {"sha": "33be1be8955561639b3bb184deefdc494a209f15", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -335,18 +335,18 @@ fn enc_sty(w: @io::Writer, cx: @ctxt, st: &ty::sty) {\n       }\n       ty::ty_opaque_box => w.write_char('B'),\n       ty::ty_struct(def, ref substs) => {\n-          debug2!(\"~~~~ {}\", \"a[\");\n+          debug!(\"~~~~ {}\", \"a[\");\n           w.write_str(&\"a[\");\n           let s = (cx.ds)(def);\n-          debug2!(\"~~~~ {}\", s);\n+          debug!(\"~~~~ {}\", s);\n           w.write_str(s);\n-          debug2!(\"~~~~ {}\", \"|\");\n+          debug!(\"~~~~ {}\", \"|\");\n           w.write_char('|');\n           enc_substs(w, cx, substs);\n-          debug2!(\"~~~~ {}\", \"]\");\n+          debug!(\"~~~~ {}\", \"]\");\n           w.write_char(']');\n       }\n-      ty::ty_err => fail2!(\"Shouldn't encode error type\")\n+      ty::ty_err => fail!(\"Shouldn't encode error type\")\n     }\n }\n "}, {"sha": "294bbcb46f7b8ddd81076c70e52fe68c8755f278", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -84,7 +84,7 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n                            path: &[ast_map::path_elt],\n                            ii: ast::inlined_item,\n                            maps: Maps) {\n-    debug2!(\"> Encoding inlined item: {}::{} ({})\",\n+    debug!(\"> Encoding inlined item: {}::{} ({})\",\n            ast_map::path_to_str(path, token::get_ident_interner()),\n            ecx.tcx.sess.str_of(ii.ident()),\n            ebml_w.writer.tell());\n@@ -97,7 +97,7 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n     encode_side_tables_for_ii(ecx, maps, ebml_w, &ii);\n     ebml_w.end_tag();\n \n-    debug2!(\"< Encoded inlined fn: {}::{} ({})\",\n+    debug!(\"< Encoded inlined fn: {}::{} ({})\",\n            ast_map::path_to_str(path, token::get_ident_interner()),\n            ecx.tcx.sess.str_of(ii.ident()),\n            ebml_w.writer.tell());\n@@ -117,7 +117,7 @@ pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n     match par_doc.opt_child(c::tag_ast) {\n       None => None,\n       Some(ast_doc) => {\n-        debug2!(\"> Decoding inlined fn: {}::?\",\n+        debug!(\"> Decoding inlined fn: {}::?\",\n                ast_map::path_to_str(path, token::get_ident_interner()));\n         let mut ast_dsr = reader::Decoder(ast_doc);\n         let from_id_range = Decodable::decode(&mut ast_dsr);\n@@ -129,8 +129,8 @@ pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n         };\n         let raw_ii = decode_ast(ast_doc);\n         let ii = renumber_ast(xcx, raw_ii);\n-        debug2!(\"Fn named: {}\", tcx.sess.str_of(ii.ident()));\n-        debug2!(\"< Decoded inlined fn: {}::{}\",\n+        debug!(\"Fn named: {}\", tcx.sess.str_of(ii.ident()));\n+        debug!(\"< Decoded inlined fn: {}::{}\",\n                ast_map::path_to_str(path, token::get_ident_interner()),\n                tcx.sess.str_of(ii.ident()));\n         ast_map::map_decoded_item(tcx.sess.diagnostic(),\n@@ -140,7 +140,7 @@ pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n         decode_side_tables(xcx, ast_doc);\n         match ii {\n           ast::ii_item(i) => {\n-            debug2!(\">>> DECODED ITEM >>>\\n{}\\n<<< DECODED ITEM <<<\",\n+            debug!(\">>> DECODED ITEM >>>\\n{}\\n<<< DECODED ITEM <<<\",\n                    syntax::print::pprust::item_to_str(i, tcx.sess.intr()));\n           }\n           _ => { }\n@@ -305,7 +305,7 @@ impl fold::ast_fold for NestedItemsDropper {\n                     node: ast::DeclItem(_),\n                     span: _\n                 }, _) => None,\n-                ast::StmtMac(*) => fail2!(\"unexpanded macro in astencode\")\n+                ast::StmtMac(*) => fail!(\"unexpanded macro in astencode\")\n             }\n         }.collect();\n         let blk_sans_items = ast::Block {\n@@ -741,7 +741,7 @@ impl vtable_decoder_helpers for reader::Decoder {\n                     )\n                   }\n                   // hard to avoid - user input\n-                  _ => fail2!(\"bad enum variant\")\n+                  _ => fail!(\"bad enum variant\")\n                 }\n             }\n         }\n@@ -896,7 +896,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                              id: ast::NodeId) {\n     let tcx = ecx.tcx;\n \n-    debug2!(\"Encoding side tables for id {}\", id);\n+    debug!(\"Encoding side tables for id {}\", id);\n \n     {\n         let r = tcx.def_map.find(&id);\n@@ -1091,7 +1091,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n                 xcx.dcx.tcx,\n                 |s, a| this.convert_def_id(xcx, s, a));\n \n-            debug2!(\"read_ty({}) = {}\",\n+            debug!(\"read_ty({}) = {}\",\n                    type_string(doc),\n                    ty_to_str(xcx.dcx.tcx, ty));\n \n@@ -1176,7 +1176,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n             NominalType | TypeWithId => xcx.tr_def_id(did),\n             TypeParameter => xcx.tr_intern_def_id(did)\n         };\n-        debug2!(\"convert_def_id(source={:?}, did={:?})={:?}\", source, did, r);\n+        debug!(\"convert_def_id(source={:?}, did={:?})={:?}\", source, did, r);\n         return r;\n     }\n }\n@@ -1189,7 +1189,7 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n         let id0 = entry_doc.get(c::tag_table_id as uint).as_int();\n         let id = xcx.tr_id(id0);\n \n-        debug2!(\">> Side table document with tag 0x{:x} \\\n+        debug!(\">> Side table document with tag 0x{:x} \\\n                 found for id {} (orig {})\",\n                tag, id, id0);\n \n@@ -1210,7 +1210,7 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                     }\n                     c::tag_table_node_type => {\n                         let ty = val_dsr.read_ty(xcx);\n-                        debug2!(\"inserting ty for node {:?}: {}\",\n+                        debug!(\"inserting ty for node {:?}: {}\",\n                                id, ty_to_str(dcx.tcx, ty));\n                         dcx.tcx.node_types.insert(id as uint, ty);\n                     }\n@@ -1263,7 +1263,7 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n             }\n         }\n \n-        debug2!(\">< Side table doc loaded\");\n+        debug!(\">< Side table doc loaded\");\n         true\n     };\n }\n@@ -1381,6 +1381,6 @@ fn test_simplification() {\n                      == pprust::item_to_str(item_exp,\n                                             token::get_ident_interner()));\n       }\n-      _ => fail2!()\n+      _ => fail!()\n     }\n }"}, {"sha": "b05bdaa203220cb47a624ca97c5131f7a1f870c4", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -65,7 +65,7 @@ pub fn check_loans(bccx: &BorrowckCtxt,\n                    move_data: move_data::FlowedMoveData,\n                    all_loans: &[Loan],\n                    body: &ast::Block) {\n-    debug2!(\"check_loans(body id={:?})\", body.id);\n+    debug!(\"check_loans(body id={:?})\", body.id);\n \n     let mut clcx = CheckLoanCtxt {\n         bccx: bccx,\n@@ -197,10 +197,10 @@ impl<'self> CheckLoanCtxt<'self> {\n         //! issued when we enter `scope_id` (for example, we do not\n         //! permit two `&mut` borrows of the same variable).\n \n-        debug2!(\"check_for_conflicting_loans(scope_id={:?})\", scope_id);\n+        debug!(\"check_for_conflicting_loans(scope_id={:?})\", scope_id);\n \n         let new_loan_indices = self.loans_generated_by(scope_id);\n-        debug2!(\"new_loan_indices = {:?}\", new_loan_indices);\n+        debug!(\"new_loan_indices = {:?}\", new_loan_indices);\n \n         do self.each_issued_loan(scope_id) |issued_loan| {\n             for &new_loan_index in new_loan_indices.iter() {\n@@ -225,7 +225,7 @@ impl<'self> CheckLoanCtxt<'self> {\n         //! Checks whether `old_loan` and `new_loan` can safely be issued\n         //! simultaneously.\n \n-        debug2!(\"report_error_if_loans_conflict(old_loan={}, new_loan={})\",\n+        debug!(\"report_error_if_loans_conflict(old_loan={}, new_loan={})\",\n                old_loan.repr(self.tcx()),\n                new_loan.repr(self.tcx()));\n \n@@ -249,7 +249,7 @@ impl<'self> CheckLoanCtxt<'self> {\n         //! Checks whether the restrictions introduced by `loan1` would\n         //! prohibit `loan2`. Returns false if an error is reported.\n \n-        debug2!(\"report_error_if_loan_conflicts_with_restriction(\\\n+        debug!(\"report_error_if_loan_conflicts_with_restriction(\\\n                 loan1={}, loan2={})\",\n                loan1.repr(self.tcx()),\n                loan2.repr(self.tcx()));\n@@ -260,7 +260,7 @@ impl<'self> CheckLoanCtxt<'self> {\n             ImmutableMutability => RESTR_ALIAS | RESTR_FREEZE,\n             ConstMutability     => RESTR_ALIAS,\n         };\n-        debug2!(\"illegal_if={:?}\", illegal_if);\n+        debug!(\"illegal_if={:?}\", illegal_if);\n \n         for restr in loan1.restrictions.iter() {\n             if !restr.set.intersects(illegal_if) { continue; }\n@@ -317,7 +317,7 @@ impl<'self> CheckLoanCtxt<'self> {\n          * is using a moved/uninitialized value\n          */\n \n-        debug2!(\"check_if_path_is_moved(id={:?}, use_kind={:?}, lp={})\",\n+        debug!(\"check_if_path_is_moved(id={:?}, use_kind={:?}, lp={})\",\n                id, use_kind, lp.repr(self.bccx.tcx));\n         do self.move_data.each_move_of(id, lp) |move, moved_lp| {\n             self.bccx.report_use_of_moved_value(\n@@ -338,7 +338,7 @@ impl<'self> CheckLoanCtxt<'self> {\n             Some(&adj) => self.bccx.cat_expr_autoderefd(expr, adj)\n         };\n \n-        debug2!(\"check_assignment(cmt={})\", cmt.repr(self.tcx()));\n+        debug!(\"check_assignment(cmt={})\", cmt.repr(self.tcx()));\n \n         // Mutable values can be assigned, as long as they obey loans\n         // and aliasing restrictions:\n@@ -387,7 +387,7 @@ impl<'self> CheckLoanCtxt<'self> {\n \n             let mut cmt = cmt;\n             loop {\n-                debug2!(\"mark_writes_through_upvars_as_used_mut(cmt={})\",\n+                debug!(\"mark_writes_through_upvars_as_used_mut(cmt={})\",\n                        cmt.repr(this.tcx()));\n                 match cmt.cat {\n                     mc::cat_local(id) |\n@@ -435,7 +435,7 @@ impl<'self> CheckLoanCtxt<'self> {\n             //! Safety checks related to writes to aliasable, mutable locations\n \n             let guarantor = cmt.guarantor();\n-            debug2!(\"check_for_aliasable_mutable_writes(cmt={}, guarantor={})\",\n+            debug!(\"check_for_aliasable_mutable_writes(cmt={}, guarantor={})\",\n                    cmt.repr(this.tcx()), guarantor.repr(this.tcx()));\n             match guarantor.cat {\n                 mc::cat_deref(b, _, mc::region_ptr(MutMutable, _)) => {\n@@ -451,7 +451,7 @@ impl<'self> CheckLoanCtxt<'self> {\n                         id: guarantor.id,\n                         derefs: deref_count\n                     };\n-                    debug2!(\"Inserting write guard at {:?}\", key);\n+                    debug!(\"Inserting write guard at {:?}\", key);\n                     this.bccx.write_guard_map.insert(key);\n                 }\n \n@@ -690,7 +690,7 @@ impl<'self> CheckLoanCtxt<'self> {\n     pub fn analyze_move_out_from(&self,\n                                  expr_id: ast::NodeId,\n                                  move_path: @LoanPath) -> MoveError {\n-        debug2!(\"analyze_move_out_from(expr_id={:?}, move_path={})\",\n+        debug!(\"analyze_move_out_from(expr_id={:?}, move_path={})\",\n                expr_id, move_path.repr(self.tcx()));\n \n         // FIXME(#4384) inadequare if/when we permit `move a.b`\n@@ -794,7 +794,7 @@ fn check_loans_in_expr<'a>(this: &mut CheckLoanCtxt<'a>,\n                            expr: @ast::Expr) {\n     visit::walk_expr(this, expr, ());\n \n-    debug2!(\"check_loans_in_expr(expr={})\",\n+    debug!(\"check_loans_in_expr(expr={})\",\n            expr.repr(this.tcx()));\n \n     this.check_for_conflicting_loans(expr.id);\n@@ -805,7 +805,7 @@ fn check_loans_in_expr<'a>(this: &mut CheckLoanCtxt<'a>,\n       ast::ExprPath(*) => {\n           if !this.move_data.is_assignee(expr.id) {\n               let cmt = this.bccx.cat_expr_unadjusted(expr);\n-              debug2!(\"path cmt={}\", cmt.repr(this.tcx()));\n+              debug!(\"path cmt={}\", cmt.repr(this.tcx()));\n               let r = opt_loan_path(cmt);\n               for &lp in r.iter() {\n                   this.check_if_path_is_moved(expr.id, expr.span, MovedInUse, lp);"}, {"sha": "a0c6fdc32255fee5bb95671e7e5a0f84b9d0f033", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -27,7 +27,7 @@ pub fn guarantee_lifetime(bccx: &BorrowckCtxt,\n                           cmt: mc::cmt,\n                           loan_region: ty::Region,\n                           loan_mutbl: LoanMutability) {\n-    debug2!(\"guarantee_lifetime(cmt={}, loan_region={})\",\n+    debug!(\"guarantee_lifetime(cmt={}, loan_region={})\",\n            cmt.repr(bccx.tcx), loan_region.repr(bccx.tcx));\n     let ctxt = GuaranteeLifetimeContext {bccx: bccx,\n                                          item_scope_id: item_scope_id,\n@@ -101,7 +101,7 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n                     // L-Deref-Managed-Mut-Compiler-Root\n                     self.check_root(cmt, base, derefs, ptr_mutbl, discr_scope);\n                 } else {\n-                    debug2!(\"omitting root, base={}, base_scope={:?}\",\n+                    debug!(\"omitting root, base={}, base_scope={:?}\",\n                            base.repr(self.tcx()), base_scope);\n                 }\n             }\n@@ -189,7 +189,7 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n                   derefs: uint,\n                   ptr_mutbl: ast::Mutability,\n                   discr_scope: Option<ast::NodeId>) {\n-        debug2!(\"check_root(cmt_deref={}, cmt_base={}, derefs={:?}, ptr_mutbl={:?}, \\\n+        debug!(\"check_root(cmt_deref={}, cmt_base={}, derefs={:?}, ptr_mutbl={:?}, \\\n                 discr_scope={:?})\",\n                cmt_deref.repr(self.tcx()),\n                cmt_base.repr(self.tcx()),\n@@ -247,7 +247,7 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n         // FIXME(#3511) grow to the nearest cleanup scope---this can\n         // cause observable errors if freezing!\n         if !self.bccx.tcx.region_maps.is_cleanup_scope(root_scope) {\n-            debug2!(\"{:?} is not a cleanup scope, adjusting\", root_scope);\n+            debug!(\"{:?} is not a cleanup scope, adjusting\", root_scope);\n \n             let cleanup_scope =\n                 self.bccx.tcx.region_maps.cleanup_scope(root_scope);\n@@ -277,7 +277,7 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n         let root_info = RootInfo {scope: root_scope, freeze: opt_dyna};\n         self.bccx.root_map.insert(rm_key, root_info);\n \n-        debug2!(\"root_key: {:?} root_info: {:?}\", rm_key, root_info);\n+        debug!(\"root_key: {:?} root_info: {:?}\", rm_key, root_info);\n     }\n \n     fn check_scope(&self, max_scope: ty::Region) {"}, {"sha": "6c927794dc8117f7e568747fdfbd8d19fe159602", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -136,7 +136,7 @@ fn gather_loans_in_fn(this: &mut GatherLoanCtxt,\n                       id: ast::NodeId) {\n     match fk {\n         &visit::fk_item_fn(*) | &visit::fk_method(*) => {\n-            fail2!(\"cannot occur, due to visit_item override\");\n+            fail!(\"cannot occur, due to visit_item override\");\n         }\n \n         // Visit closures as part of the containing item.\n@@ -196,7 +196,7 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n     let bccx = this.bccx;\n     let tcx = bccx.tcx;\n \n-    debug2!(\"gather_loans_in_expr(expr={:?}/{})\",\n+    debug!(\"gather_loans_in_expr(expr={:?}/{})\",\n            ex.id, pprust::expr_to_str(ex, tcx.sess.intr()));\n \n     this.id_range.add(ex.id);\n@@ -347,20 +347,20 @@ impl<'self> GatherLoanCtxt<'self> {\n     pub fn guarantee_adjustments(&mut self,\n                                  expr: @ast::Expr,\n                                  adjustment: &ty::AutoAdjustment) {\n-        debug2!(\"guarantee_adjustments(expr={}, adjustment={:?})\",\n+        debug!(\"guarantee_adjustments(expr={}, adjustment={:?})\",\n                expr.repr(self.tcx()), adjustment);\n         let _i = indenter();\n \n         match *adjustment {\n             ty::AutoAddEnv(*) => {\n-                debug2!(\"autoaddenv -- no autoref\");\n+                debug!(\"autoaddenv -- no autoref\");\n                 return;\n             }\n \n             ty::AutoDerefRef(\n                 ty::AutoDerefRef {\n                     autoref: None, _ }) => {\n-                debug2!(\"no autoref\");\n+                debug!(\"no autoref\");\n                 return;\n             }\n \n@@ -372,7 +372,7 @@ impl<'self> GatherLoanCtxt<'self> {\n                     tcx: self.tcx(),\n                     method_map: self.bccx.method_map};\n                 let cmt = mcx.cat_expr_autoderefd(expr, autoderefs);\n-                debug2!(\"after autoderef, cmt={}\", cmt.repr(self.tcx()));\n+                debug!(\"after autoderef, cmt={}\", cmt.repr(self.tcx()));\n \n                 match *autoref {\n                     ty::AutoPtr(r, m) => {\n@@ -429,7 +429,7 @@ impl<'self> GatherLoanCtxt<'self> {\n                            cmt: mc::cmt,\n                            req_mutbl: LoanMutability,\n                            loan_region: ty::Region) {\n-        debug2!(\"guarantee_valid(borrow_id={:?}, cmt={}, \\\n+        debug!(\"guarantee_valid(borrow_id={:?}, cmt={}, \\\n                 req_mutbl={:?}, loan_region={:?})\",\n                borrow_id,\n                cmt.repr(self.tcx()),\n@@ -490,13 +490,13 @@ impl<'self> GatherLoanCtxt<'self> {\n                             format!(\"Invalid borrow lifetime: {:?}\", loan_region));\n                     }\n                 };\n-                debug2!(\"loan_scope = {:?}\", loan_scope);\n+                debug!(\"loan_scope = {:?}\", loan_scope);\n \n                 let gen_scope = self.compute_gen_scope(borrow_id, loan_scope);\n-                debug2!(\"gen_scope = {:?}\", gen_scope);\n+                debug!(\"gen_scope = {:?}\", gen_scope);\n \n                 let kill_scope = self.compute_kill_scope(loan_scope, loan_path);\n-                debug2!(\"kill_scope = {:?}\", kill_scope);\n+                debug!(\"kill_scope = {:?}\", kill_scope);\n \n                 if req_mutbl == MutableMutability {\n                     self.mark_loan_path_as_mutated(loan_path);\n@@ -516,7 +516,7 @@ impl<'self> GatherLoanCtxt<'self> {\n             }\n         };\n \n-        debug2!(\"guarantee_valid(borrow_id={:?}), loan={}\",\n+        debug!(\"guarantee_valid(borrow_id={:?}), loan={}\",\n                borrow_id, loan.repr(self.tcx()));\n \n         // let loan_path = loan.loan_path;"}, {"sha": "2722fff12a82864bc2f98322d457982cc902a72e", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -135,7 +135,7 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n \n         &visit::fk_item_fn(*) |\n         &visit::fk_method(*) => {\n-            debug2!(\"borrowck_fn(id={:?})\", id);\n+            debug!(\"borrowck_fn(id={:?})\", id);\n \n             // Check the body of fn items.\n             let (id_range, all_loans, move_data) ="}, {"sha": "e031420996789b87e89ed06a2cac0c0c680d99a4", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -244,7 +244,7 @@ impl MoveData {\n             }\n         };\n \n-        debug2!(\"move_path(lp={}, index={:?})\",\n+        debug!(\"move_path(lp={}, index={:?})\",\n                lp.repr(tcx),\n                index);\n \n@@ -304,7 +304,7 @@ impl MoveData {\n          * location `id` with kind `kind`.\n          */\n \n-        debug2!(\"add_move(lp={}, id={:?}, kind={:?})\",\n+        debug!(\"add_move(lp={}, id={:?}, kind={:?})\",\n                lp.repr(tcx),\n                id,\n                kind);\n@@ -334,7 +334,7 @@ impl MoveData {\n          * location `id` with the given `span`.\n          */\n \n-        debug2!(\"add_assignment(lp={}, assign_id={:?}, assignee_id={:?}\",\n+        debug!(\"add_assignment(lp={}, assign_id={:?}, assignee_id={:?}\",\n                lp.repr(tcx), assign_id, assignee_id);\n \n         let path_index = self.move_path(tcx, lp);\n@@ -348,12 +348,12 @@ impl MoveData {\n         };\n \n         if self.is_var_path(path_index) {\n-            debug2!(\"add_assignment[var](lp={}, assignment={}, path_index={:?})\",\n+            debug!(\"add_assignment[var](lp={}, assignment={}, path_index={:?})\",\n                    lp.repr(tcx), self.var_assignments.len(), path_index);\n \n             self.var_assignments.push(assignment);\n         } else {\n-            debug2!(\"add_assignment[path](lp={}, path_index={:?})\",\n+            debug!(\"add_assignment[path](lp={}, path_index={:?})\",\n                    lp.repr(tcx), path_index);\n \n             self.path_assignments.push(assignment);"}, {"sha": "27fbecb59790659e18438ac1863a261f1d8d9f5f", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -239,7 +239,7 @@ impl CFGBuilder {\n                 expr_exit\n             }\n \n-            ast::ExprForLoop(*) => fail2!(\"non-desugared expr_for_loop\"),\n+            ast::ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n \n             ast::ExprLoop(ref body, _) => {\n                 //"}, {"sha": "d12808c3a4dad94880079a71f2b95ad819ff01ea", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -153,7 +153,7 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n               Some(&DefStruct(_)) => { }\n \n               Some(&def) => {\n-                debug2!(\"(checking const) found bad def: {:?}\", def);\n+                debug!(\"(checking const) found bad def: {:?}\", def);\n                 sess.span_err(\n                     e.span,\n                     \"paths in constants may only refer to \\\n@@ -266,7 +266,7 @@ impl Visitor<()> for CheckItemRecursionVisitor {\n                         ast_map::node_item(it, _) => {\n                             self.visit_item(it, ());\n                         }\n-                        _ => fail2!(\"const not bound to an item\")\n+                        _ => fail!(\"const not bound to an item\")\n                     },\n                 _ => ()\n             },"}, {"sha": "de5e00d241eb1d09ae7cb221277d914564fcf8ca", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -181,14 +181,14 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, pats: ~[@Pat]) {\n                 ty::ty_enum(id, _) => {\n                     let vid = match *ctor {\n                         variant(id) => id,\n-                        _ => fail2!(\"check_exhaustive: non-variant ctor\"),\n+                        _ => fail!(\"check_exhaustive: non-variant ctor\"),\n                     };\n                     let variants = ty::enum_variants(cx.tcx, id);\n \n                     match variants.iter().find(|v| v.id == vid) {\n                         Some(v) => Some(cx.tcx.sess.str_of(v.name)),\n                         None => {\n-                            fail2!(\"check_exhaustive: bad variant in ctor\")\n+                            fail!(\"check_exhaustive: bad variant in ctor\")\n                         }\n                     }\n                 }\n@@ -409,7 +409,7 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n                     return Some(variant(v.id));\n                 }\n             }\n-            fail2!();\n+            fail!();\n         } else { None }\n       }\n       ty::ty_nil => None,\n@@ -421,7 +421,7 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n               None => (),\n               Some(val(const_bool(true))) => true_found = true,\n               Some(val(const_bool(false))) => false_found = true,\n-              _ => fail2!(\"impossible case\")\n+              _ => fail!(\"impossible case\")\n             }\n         }\n         if true_found && false_found { None }\n@@ -511,10 +511,10 @@ fn ctor_arity(cx: &MatchCheckCtxt, ctor: &ctor, ty: ty::t) -> uint {\n       ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_rptr(*) => 1u,\n       ty::ty_enum(eid, _) => {\n           let id = match *ctor { variant(id) => id,\n-          _ => fail2!(\"impossible case\") };\n+          _ => fail!(\"impossible case\") };\n         match ty::enum_variants(cx.tcx, eid).iter().find(|v| v.id == id ) {\n             Some(v) => v.args.len(),\n-            None => fail2!(\"impossible case\")\n+            None => fail!(\"impossible case\")\n         }\n       }\n       ty::ty_struct(cid, _) => ty::lookup_struct_fields(cx.tcx, cid).len(),\n@@ -585,7 +585,7 @@ fn specialize(cx: &MatchCheckCtxt,\n                                 }\n                             }\n                             single => true,\n-                            _ => fail2!(\"type error\")\n+                            _ => fail!(\"type error\")\n                         };\n                         if match_ {\n                             Some(r.tail().to_owned())\n@@ -632,7 +632,7 @@ fn specialize(cx: &MatchCheckCtxt,\n                                 }\n                             }\n                             single => true,\n-                            _ => fail2!(\"type error\")\n+                            _ => fail!(\"type error\")\n                         };\n                         if match_ {\n                             Some(r.tail().to_owned())\n@@ -739,7 +739,7 @@ fn specialize(cx: &MatchCheckCtxt,\n                         }\n                     }\n                     single => true,\n-                    _ => fail2!(\"type error\")\n+                    _ => fail!(\"type error\")\n                 };\n                 if match_ { Some(r.tail().to_owned()) } else { None }\n             }\n@@ -748,7 +748,7 @@ fn specialize(cx: &MatchCheckCtxt,\n                     val(ref v) => (*v, *v),\n                     range(ref lo, ref hi) => (*lo, *hi),\n                     single => return Some(r.tail().to_owned()),\n-                    _ => fail2!(\"type error\")\n+                    _ => fail!(\"type error\")\n                 };\n                 let v_lo = eval_const_expr(cx.tcx, lo);\n                 let v_hi = eval_const_expr(cx.tcx, hi);"}, {"sha": "22fd1d393e9729952f509f0657611585bf9fdd45", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -131,7 +131,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n                bits_per_id: uint) -> DataFlowContext<O> {\n         let words_per_id = (bits_per_id + uint::bits - 1) / uint::bits;\n \n-        debug2!(\"DataFlowContext::new(id_range={:?}, bits_per_id={:?}, words_per_id={:?})\",\n+        debug!(\"DataFlowContext::new(id_range={:?}, bits_per_id={:?}, words_per_id={:?})\",\n                id_range, bits_per_id, words_per_id);\n \n         let gens = ~[];\n@@ -154,7 +154,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n     pub fn add_gen(&mut self, id: ast::NodeId, bit: uint) {\n         //! Indicates that `id` generates `bit`\n \n-        debug2!(\"add_gen(id={:?}, bit={:?})\", id, bit);\n+        debug!(\"add_gen(id={:?}, bit={:?})\", id, bit);\n         let (start, end) = self.compute_id_range(id);\n         {\n             let gens = self.gens.mut_slice(start, end);\n@@ -165,7 +165,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n     pub fn add_kill(&mut self, id: ast::NodeId, bit: uint) {\n         //! Indicates that `id` kills `bit`\n \n-        debug2!(\"add_kill(id={:?}, bit={:?})\", id, bit);\n+        debug!(\"add_kill(id={:?}, bit={:?})\", id, bit);\n         let (start, end) = self.compute_id_range(id);\n         {\n             let kills = self.kills.mut_slice(start, end);\n@@ -176,25 +176,25 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n     fn apply_gen_kill(&mut self, id: ast::NodeId, bits: &mut [uint]) {\n         //! Applies the gen and kill sets for `id` to `bits`\n \n-        debug2!(\"apply_gen_kill(id={:?}, bits={}) [before]\",\n+        debug!(\"apply_gen_kill(id={:?}, bits={}) [before]\",\n                id, mut_bits_to_str(bits));\n         let (start, end) = self.compute_id_range(id);\n         let gens = self.gens.slice(start, end);\n         bitwise(bits, gens, |a, b| a | b);\n         let kills = self.kills.slice(start, end);\n         bitwise(bits, kills, |a, b| a & !b);\n \n-        debug2!(\"apply_gen_kill(id={:?}, bits={}) [after]\",\n+        debug!(\"apply_gen_kill(id={:?}, bits={}) [after]\",\n                id, mut_bits_to_str(bits));\n     }\n \n     fn apply_kill(&mut self, id: ast::NodeId, bits: &mut [uint]) {\n-        debug2!(\"apply_kill(id={:?}, bits={}) [before]\",\n+        debug!(\"apply_kill(id={:?}, bits={}) [before]\",\n                id, mut_bits_to_str(bits));\n         let (start, end) = self.compute_id_range(id);\n         let kills = self.kills.slice(start, end);\n         bitwise(bits, kills, |a, b| a & !b);\n-        debug2!(\"apply_kill(id={:?}, bits={}) [after]\",\n+        debug!(\"apply_kill(id={:?}, bits={}) [after]\",\n                id, mut_bits_to_str(bits));\n     }\n \n@@ -242,7 +242,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         }\n         let (start, end) = self.compute_id_range_frozen(id);\n         let on_entry = self.on_entry.slice(start, end);\n-        debug2!(\"each_bit_on_entry_frozen(id={:?}, on_entry={})\",\n+        debug!(\"each_bit_on_entry_frozen(id={:?}, on_entry={})\",\n                id, bits_to_str(on_entry));\n         self.each_bit(on_entry, f)\n     }\n@@ -255,7 +255,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n \n         let (start, end) = self.compute_id_range(id);\n         let on_entry = self.on_entry.slice(start, end);\n-        debug2!(\"each_bit_on_entry(id={:?}, on_entry={})\",\n+        debug!(\"each_bit_on_entry(id={:?}, on_entry={})\",\n                id, bits_to_str(on_entry));\n         self.each_bit(on_entry, f)\n     }\n@@ -267,7 +267,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n \n         let (start, end) = self.compute_id_range(id);\n         let gens = self.gens.slice(start, end);\n-        debug2!(\"each_gen_bit(id={:?}, gens={})\",\n+        debug!(\"each_gen_bit(id={:?}, gens={})\",\n                id, bits_to_str(gens));\n         self.each_bit(gens, f)\n     }\n@@ -281,7 +281,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         }\n         let (start, end) = self.compute_id_range_frozen(id);\n         let gens = self.gens.slice(start, end);\n-        debug2!(\"each_gen_bit(id={:?}, gens={})\",\n+        debug!(\"each_gen_bit(id={:?}, gens={})\",\n                id, bits_to_str(gens));\n         self.each_bit(gens, f)\n     }\n@@ -346,8 +346,8 @@ impl<O:DataFlowOperator+Clone+'static> DataFlowContext<O> {\n             }\n         }\n \n-        debug2!(\"Dataflow result:\");\n-        debug2!(\"{}\", {\n+        debug!(\"Dataflow result:\");\n+        debug!(\"{}\", {\n             let this = @(*self).clone();\n             this.pretty_print_to(io::stderr(), blk);\n             \"\"\n@@ -374,7 +374,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                   blk: &ast::Block,\n                   in_out: &mut [uint],\n                   loop_scopes: &mut ~[LoopScope]) {\n-        debug2!(\"DataFlowContext::walk_block(blk.id={:?}, in_out={})\",\n+        debug!(\"DataFlowContext::walk_block(blk.id={:?}, in_out={})\",\n                blk.id, bits_to_str(reslice(in_out)));\n \n         self.merge_with_entry_set(blk.id, in_out);\n@@ -425,7 +425,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                  expr: &ast::Expr,\n                  in_out: &mut [uint],\n                  loop_scopes: &mut ~[LoopScope]) {\n-        debug2!(\"DataFlowContext::walk_expr(expr={}, in_out={})\",\n+        debug!(\"DataFlowContext::walk_expr(expr={}, in_out={})\",\n                expr.repr(self.dfcx.tcx), bits_to_str(reslice(in_out)));\n \n         self.merge_with_entry_set(expr.id, in_out);\n@@ -569,7 +569,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                 copy_bits(new_loop_scope.break_bits, in_out);\n             }\n \n-            ast::ExprForLoop(*) => fail2!(\"non-desugared expr_for_loop\"),\n+            ast::ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n \n             ast::ExprLoop(ref blk, _) => {\n                 //\n@@ -756,7 +756,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n         let tcx = self.tcx();\n         let region_maps = tcx.region_maps;\n \n-        debug2!(\"pop_scopes(from_expr={}, to_scope={:?}, in_out={})\",\n+        debug!(\"pop_scopes(from_expr={}, to_scope={:?}, in_out={})\",\n                from_expr.repr(tcx), to_scope.loop_id,\n                bits_to_str(reslice(in_out)));\n \n@@ -784,7 +784,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n         self.pop_scopes(from_expr, to_scope, in_out);\n         self.dfcx.apply_kill(from_expr.id, in_out);\n         join_bits(&self.dfcx.oper, reslice(in_out), to_scope.break_bits);\n-        debug2!(\"break_from_to(from_expr={}, to_scope={:?}) final break_bits={}\",\n+        debug!(\"break_from_to(from_expr={}, to_scope={:?}) final break_bits={}\",\n                from_expr.repr(self.tcx()),\n                to_scope.loop_id,\n                bits_to_str(reslice(in_out)));\n@@ -833,11 +833,11 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                 pat: @ast::Pat,\n                 in_out: &mut [uint],\n                 _loop_scopes: &mut ~[LoopScope]) {\n-        debug2!(\"DataFlowContext::walk_pat(pat={}, in_out={})\",\n+        debug!(\"DataFlowContext::walk_pat(pat={}, in_out={})\",\n                pat.repr(self.dfcx.tcx), bits_to_str(reslice(in_out)));\n \n         do ast_util::walk_pat(pat) |p| {\n-            debug2!(\"  p.id={:?} in_out={}\", p.id, bits_to_str(reslice(in_out)));\n+            debug!(\"  p.id={:?} in_out={}\", p.id, bits_to_str(reslice(in_out)));\n             self.merge_with_entry_set(p.id, in_out);\n             self.dfcx.apply_gen_kill(p.id, in_out);\n             true\n@@ -909,15 +909,15 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n     }\n \n     fn add_to_entry_set(&mut self, id: ast::NodeId, pred_bits: &[uint]) {\n-        debug2!(\"add_to_entry_set(id={:?}, pred_bits={})\",\n+        debug!(\"add_to_entry_set(id={:?}, pred_bits={})\",\n                id, bits_to_str(pred_bits));\n         let (start, end) = self.dfcx.compute_id_range(id);\n         let changed = { // FIXME(#5074) awkward construction\n             let on_entry = self.dfcx.on_entry.mut_slice(start, end);\n             join_bits(&self.dfcx.oper, pred_bits, on_entry)\n         };\n         if changed {\n-            debug2!(\"changed entry set for {:?} to {}\",\n+            debug!(\"changed entry set for {:?} to {}\",\n                    id, bits_to_str(self.dfcx.on_entry.slice(start, end)));\n             self.changed = true;\n         }\n@@ -926,7 +926,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n     fn merge_with_entry_set(&mut self,\n                             id: ast::NodeId,\n                             pred_bits: &mut [uint]) {\n-        debug2!(\"merge_with_entry_set(id={:?}, pred_bits={})\",\n+        debug!(\"merge_with_entry_set(id={:?}, pred_bits={})\",\n                id, mut_bits_to_str(pred_bits));\n         let (start, end) = self.dfcx.compute_id_range(id);\n         let changed = { // FIXME(#5074) awkward construction\n@@ -936,7 +936,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n             changed\n         };\n         if changed {\n-            debug2!(\"changed entry set for {:?} to {}\",\n+            debug!(\"changed entry set for {:?} to {}\",\n                    id, bits_to_str(self.dfcx.on_entry.slice(start, end)));\n             self.changed = true;\n         }\n@@ -992,12 +992,12 @@ fn bitwise(out_vec: &mut [uint],\n }\n \n fn set_bit(words: &mut [uint], bit: uint) -> bool {\n-    debug2!(\"set_bit: words={} bit={}\",\n+    debug!(\"set_bit: words={} bit={}\",\n            mut_bits_to_str(words), bit_str(bit));\n     let word = bit / uint::bits;\n     let bit_in_word = bit % uint::bits;\n     let bit_mask = 1 << bit_in_word;\n-    debug2!(\"word={} bit_in_word={} bit_mask={}\", word, bit_in_word, word);\n+    debug!(\"word={} bit_in_word={} bit_mask={}\", word, bit_in_word, word);\n     let oldv = words[word];\n     let newv = oldv | bit_mask;\n     words[word] = newv;"}, {"sha": "c0ac48bfee8cf2444643f5b3fce4d72c4c8d5bfa", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -55,7 +55,7 @@ impl EffectCheckVisitor {\n             }\n             UnsafeBlock(block_id) => {\n                 // OK, but record this.\n-                debug2!(\"effect: recording unsafe block as used: {:?}\", block_id);\n+                debug!(\"effect: recording unsafe block as used: {:?}\", block_id);\n                 let _ = self.tcx.used_unsafe.insert(block_id);\n             }\n             UnsafeFn => {}\n@@ -67,7 +67,7 @@ impl EffectCheckVisitor {\n             ast::ExprIndex(_, base, _) => ty::node_id_to_type(self.tcx, base.id),\n             _ => return\n         };\n-        debug2!(\"effect: checking index with base type {}\",\n+        debug!(\"effect: checking index with base type {}\",\n                 ppaux::ty_to_str(self.tcx, base_type));\n         match ty::get(base_type).sty {\n             ty::ty_estr(*) => {\n@@ -121,7 +121,7 @@ impl Visitor<()> for EffectCheckVisitor {\n         match expr.node {\n             ast::ExprMethodCall(callee_id, _, _, _, _, _) => {\n                 let base_type = ty::node_id_to_type(self.tcx, callee_id);\n-                debug2!(\"effect: method call case, base type is {}\",\n+                debug!(\"effect: method call case, base type is {}\",\n                        ppaux::ty_to_str(self.tcx, base_type));\n                 if type_is_unsafe_function(base_type) {\n                     self.require_unsafe(expr.span,\n@@ -130,15 +130,15 @@ impl Visitor<()> for EffectCheckVisitor {\n             }\n             ast::ExprCall(base, _, _) => {\n                 let base_type = ty::node_id_to_type(self.tcx, base.id);\n-                debug2!(\"effect: call case, base type is {}\",\n+                debug!(\"effect: call case, base type is {}\",\n                        ppaux::ty_to_str(self.tcx, base_type));\n                 if type_is_unsafe_function(base_type) {\n                     self.require_unsafe(expr.span, \"call to unsafe function\")\n                 }\n             }\n             ast::ExprUnary(_, ast::UnDeref, base) => {\n                 let base_type = ty::node_id_to_type(self.tcx, base.id);\n-                debug2!(\"effect: unary case, base type is {}\",\n+                debug!(\"effect: unary case, base type is {}\",\n                         ppaux::ty_to_str(self.tcx, base_type));\n                 match ty::get(base_type).sty {\n                     ty::ty_ptr(_) => {"}, {"sha": "9aaddab69a1078bf91e5562ce6906f8bab1f92cf", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -53,7 +53,7 @@ impl Visitor<int> for CollectFreevarsVisitor {\n               ast::ExprPath(*) | ast::ExprSelf => {\n                   let mut i = 0;\n                   match self.def_map.find(&expr.id) {\n-                    None => fail2!(\"path not found\"),\n+                    None => fail!(\"path not found\"),\n                     Some(&df) => {\n                       let mut def = df;\n                       while i < depth {\n@@ -137,7 +137,7 @@ pub fn annotate_freevars(def_map: resolve::DefMap, crate: &ast::Crate) ->\n \n pub fn get_freevars(tcx: ty::ctxt, fid: ast::NodeId) -> freevar_info {\n     match tcx.freevars.find(&fid) {\n-      None => fail2!(\"get_freevars: {} has no freevars\", fid),\n+      None => fail!(\"get_freevars: {} has no freevars\", fid),\n       Some(&d) => return d\n     }\n }"}, {"sha": "87dce84d23dc5bf05fed3e37804cb981c7018948", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -343,7 +343,7 @@ mod test {\n         do graph.each_incoming_edge(start_index) |edge_index, edge| {\n             assert_eq!(graph.edge_data(edge_index), &edge.data);\n             assert!(counter < expected_incoming.len());\n-            debug2!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n+            debug!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n                    counter, expected_incoming[counter], edge_index, edge);\n             match expected_incoming[counter] {\n                 (ref e, ref n) => {\n@@ -361,7 +361,7 @@ mod test {\n         do graph.each_outgoing_edge(start_index) |edge_index, edge| {\n             assert_eq!(graph.edge_data(edge_index), &edge.data);\n             assert!(counter < expected_outgoing.len());\n-            debug2!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n+            debug!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n                    counter, expected_outgoing[counter], edge_index, edge);\n             match expected_outgoing[counter] {\n                 (ref e, ref n) => {"}, {"sha": "5737039f83c3556a5e387023f7e7a2ed6572e2c5", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -124,7 +124,7 @@ fn check_impl_of_trait(cx: &mut Context, it: @item, trait_ref: &trait_ref, self_\n \n     // If this trait has builtin-kind supertraits, meet them.\n     let self_ty: ty::t = ty::node_id_to_type(cx.tcx, it.id);\n-    debug2!(\"checking impl with self type {:?}\", ty::get(self_ty).sty);\n+    debug!(\"checking impl with self type {:?}\", ty::get(self_ty).sty);\n     do check_builtin_bounds(cx, self_ty, trait_def.bounds) |missing| {\n         cx.tcx.sess.span_err(self_type.span,\n             format!(\"the type `{}', which does not fulfill `{}`, cannot implement this \\\n@@ -265,7 +265,7 @@ fn check_fn(\n }\n \n pub fn check_expr(cx: &mut Context, e: @Expr) {\n-    debug2!(\"kind::check_expr({})\", expr_to_str(e, cx.tcx.sess.intr()));\n+    debug!(\"kind::check_expr({})\", expr_to_str(e, cx.tcx.sess.intr()));\n \n     // Handle any kind bounds on type parameters\n     let type_parameter_id = match e.get_callee_id() {\n@@ -292,7 +292,7 @@ pub fn check_expr(cx: &mut Context, e: @Expr) {\n             };\n             if ts.len() != type_param_defs.len() {\n                 // Fail earlier to make debugging easier\n-                fail2!(\"internal error: in kind::check_expr, length \\\n+                fail!(\"internal error: in kind::check_expr, length \\\n                       mismatch between actual and declared bounds: actual = \\\n                       {}, declared = {}\",\n                       ts.repr(cx.tcx),\n@@ -451,7 +451,7 @@ fn check_imm_free_var(cx: &Context, def: Def, sp: Span) {\n }\n \n fn check_copy(cx: &Context, ty: ty::t, sp: Span, reason: &str) {\n-    debug2!(\"type_contents({})={}\",\n+    debug!(\"type_contents({})={}\",\n            ty_to_str(cx.tcx, ty),\n            ty::type_contents(cx.tcx, ty).to_str());\n     if ty::type_moves_by_default(cx.tcx, ty) {"}, {"sha": "b0cdd53de922c82347f23501266c9c8f5cf21188", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -359,7 +359,7 @@ impl Context {\n                 return *k;\n             }\n         }\n-        fail2!(\"unregistered lint {:?}\", lint);\n+        fail!(\"unregistered lint {:?}\", lint);\n     }\n \n     fn span_lint(&self, lint: lint, span: Span, msg: &str) {\n@@ -380,7 +380,7 @@ impl Context {\n                 format!(\"{} [-{} {}]\", msg,\n                     match level {\n                         warn => 'W', deny => 'D', forbid => 'F',\n-                        allow => fail2!()\n+                        allow => fail!()\n                     }, self.lint_to_str(lint).replace(\"_\", \"-\"))\n             },\n             Node(src) => {\n@@ -391,7 +391,7 @@ impl Context {\n         match level {\n             warn =>          { self.tcx.sess.span_warn(span, msg); }\n             deny | forbid => { self.tcx.sess.span_err(span, msg);  }\n-            allow => fail2!(),\n+            allow => fail!(),\n         }\n \n         for &span in note.iter() {\n@@ -526,7 +526,7 @@ fn check_type_limits(cx: &Context, e: &ast::Expr) {\n             ast::BiGt => v >= min,\n             ast::BiGe => v > min,\n             ast::BiEq | ast::BiNe => v >= min && v <= max,\n-            _ => fail2!()\n+            _ => fail!()\n         }\n     }\n \n@@ -582,7 +582,7 @@ fn check_type_limits(cx: &Context, e: &ast::Expr) {\n                         ast::lit_int_unsuffixed(v) => v,\n                         _ => return true\n                     },\n-                    _ => fail2!()\n+                    _ => fail!()\n                 };\n                 is_valid(norm_binop, lit_val, min, max)\n             }\n@@ -595,7 +595,7 @@ fn check_type_limits(cx: &Context, e: &ast::Expr) {\n                         ast::lit_int_unsuffixed(v) => v as u64,\n                         _ => return true\n                     },\n-                    _ => fail2!()\n+                    _ => fail!()\n                 };\n                 is_valid(norm_binop, lit_val, min, max)\n             }"}, {"sha": "6c53fc1602f237a8fa5c71a6955d4e0783fa0a57", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -276,7 +276,7 @@ impl IrMaps {\n         self.lnks.push(lnk);\n         self.num_live_nodes += 1;\n \n-        debug2!(\"{} is of kind {}\", ln.to_str(),\n+        debug!(\"{} is of kind {}\", ln.to_str(),\n                live_node_kind_to_str(lnk, self.tcx));\n \n         ln\n@@ -288,7 +288,7 @@ impl IrMaps {\n         let ln = self.add_live_node(lnk);\n         self.live_node_map.insert(node_id, ln);\n \n-        debug2!(\"{} is node {}\", ln.to_str(), node_id);\n+        debug!(\"{} is node {}\", ln.to_str(), node_id);\n     }\n \n     pub fn add_variable(&mut self, vk: VarKind) -> Variable {\n@@ -303,7 +303,7 @@ impl IrMaps {\n             ImplicitRet => {}\n         }\n \n-        debug2!(\"{} is {:?}\", v.to_str(), vk);\n+        debug!(\"{} is {:?}\", v.to_str(), vk);\n \n         v\n     }\n@@ -367,7 +367,7 @@ fn visit_fn(v: &mut LivenessVisitor,\n             sp: Span,\n             id: NodeId,\n             this: @mut IrMaps) {\n-    debug2!(\"visit_fn: id={}\", id);\n+    debug!(\"visit_fn: id={}\", id);\n     let _i = ::util::common::indenter();\n \n     // swap in a new set of IR maps for this function body:\n@@ -376,13 +376,13 @@ fn visit_fn(v: &mut LivenessVisitor,\n                               this.capture_map);\n \n     unsafe {\n-        debug2!(\"creating fn_maps: {}\", transmute::<&IrMaps, *IrMaps>(fn_maps));\n+        debug!(\"creating fn_maps: {}\", transmute::<&IrMaps, *IrMaps>(fn_maps));\n     }\n \n     for arg in decl.inputs.iter() {\n         do pat_util::pat_bindings(this.tcx.def_map, arg.pat)\n                 |_bm, arg_id, _x, path| {\n-            debug2!(\"adding argument {}\", arg_id);\n+            debug!(\"adding argument {}\", arg_id);\n             let ident = ast_util::path_to_ident(path);\n             fn_maps.add_variable(Arg(arg_id, ident));\n         }\n@@ -429,7 +429,7 @@ fn visit_fn(v: &mut LivenessVisitor,\n fn visit_local(v: &mut LivenessVisitor, local: @Local, this: @mut IrMaps) {\n     let def_map = this.tcx.def_map;\n     do pat_util::pat_bindings(def_map, local.pat) |_bm, p_id, sp, path| {\n-        debug2!(\"adding local variable {}\", p_id);\n+        debug!(\"adding local variable {}\", p_id);\n         let name = ast_util::path_to_ident(path);\n         this.add_live_node_for_node(p_id, VarDefNode(sp));\n         let kind = match local.init {\n@@ -450,7 +450,7 @@ fn visit_arm(v: &mut LivenessVisitor, arm: &Arm, this: @mut IrMaps) {\n     let def_map = this.tcx.def_map;\n     for pat in arm.pats.iter() {\n         do pat_util::pat_bindings(def_map, *pat) |bm, p_id, sp, path| {\n-            debug2!(\"adding local variable {} from match with bm {:?}\",\n+            debug!(\"adding local variable {} from match with bm {:?}\",\n                    p_id, bm);\n             let name = ast_util::path_to_ident(path);\n             this.add_live_node_for_node(p_id, VarDefNode(sp));\n@@ -470,7 +470,7 @@ fn visit_expr(v: &mut LivenessVisitor, expr: @Expr, this: @mut IrMaps) {\n       // live nodes required for uses or definitions of variables:\n       ExprPath(_) | ExprSelf => {\n         let def = this.tcx.def_map.get_copy(&expr.id);\n-        debug2!(\"expr {}: path that leads to {:?}\", expr.id, def);\n+        debug!(\"expr {}: path that leads to {:?}\", expr.id, def);\n         if moves::moved_variable_node_id_from_def(def).is_some() {\n             this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         }\n@@ -515,7 +515,7 @@ fn visit_expr(v: &mut LivenessVisitor, expr: @Expr, this: @mut IrMaps) {\n         this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         visit::walk_expr(v, expr, this);\n       }\n-      ExprForLoop(*) => fail2!(\"non-desugared expr_for_loop\"),\n+      ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n       ExprBinary(_, op, _, _) if ast_util::lazy_binop(op) => {\n         this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         visit::walk_expr(v, expr, this);\n@@ -819,7 +819,7 @@ impl Liveness {\n         self.indices2(ln, succ_ln, |idx, succ_idx| {\n             self.users[idx] = self.users[succ_idx]\n         });\n-        debug2!(\"init_from_succ(ln={}, succ={})\",\n+        debug!(\"init_from_succ(ln={}, succ={})\",\n                self.ln_str(ln), self.ln_str(succ_ln));\n     }\n \n@@ -843,7 +843,7 @@ impl Liveness {\n             }\n         }\n \n-        debug2!(\"merge_from_succ(ln={}, succ={}, first_merge={}, changed={})\",\n+        debug!(\"merge_from_succ(ln={}, succ={}, first_merge={}, changed={})\",\n                ln.to_str(), self.ln_str(succ_ln), first_merge, changed);\n         return changed;\n \n@@ -866,7 +866,7 @@ impl Liveness {\n         self.users[idx].reader = invalid_node();\n         self.users[idx].writer = invalid_node();\n \n-        debug2!(\"{} defines {} (idx={}): {}\", writer.to_str(), var.to_str(),\n+        debug!(\"{} defines {} (idx={}): {}\", writer.to_str(), var.to_str(),\n                idx, self.ln_str(writer));\n     }\n \n@@ -891,7 +891,7 @@ impl Liveness {\n             user.used = true;\n         }\n \n-        debug2!(\"{} accesses[{:x}] {}: {}\",\n+        debug!(\"{} accesses[{:x}] {}: {}\",\n                ln.to_str(), acc, var.to_str(), self.ln_str(ln));\n     }\n \n@@ -902,18 +902,18 @@ impl Liveness {\n         // effectively a return---this only occurs in `for` loops,\n         // where the body is really a closure.\n \n-        debug2!(\"compute: using id for block, {}\", block_to_str(body,\n+        debug!(\"compute: using id for block, {}\", block_to_str(body,\n                       self.tcx.sess.intr()));\n \n         let entry_ln: LiveNode =\n             self.with_loop_nodes(body.id, self.s.exit_ln, self.s.exit_ln,\n               || { self.propagate_through_fn_block(decl, body) });\n \n-        // hack to skip the loop unless debug2! is enabled:\n-        debug2!(\"^^ liveness computation results for body {} (entry={})\",\n+        // hack to skip the loop unless debug! is enabled:\n+        debug!(\"^^ liveness computation results for body {} (entry={})\",\n                {\n                    for ln_idx in range(0u, self.ir.num_live_nodes) {\n-                       debug2!(\"{}\", self.ln_str(LiveNode(ln_idx)));\n+                       debug!(\"{}\", self.ln_str(LiveNode(ln_idx)));\n                    }\n                    body.id\n                },\n@@ -1007,7 +1007,7 @@ impl Liveness {\n \n     pub fn propagate_through_expr(&self, expr: @Expr, succ: LiveNode)\n                                   -> LiveNode {\n-        debug2!(\"propagate_through_expr: {}\",\n+        debug!(\"propagate_through_expr: {}\",\n              expr_to_str(expr, self.tcx.sess.intr()));\n \n         match expr.node {\n@@ -1022,7 +1022,7 @@ impl Liveness {\n           }\n \n           ExprFnBlock(_, ref blk) => {\n-              debug2!(\"{} is an expr_fn_block\",\n+              debug!(\"{} is an expr_fn_block\",\n                    expr_to_str(expr, self.tcx.sess.intr()));\n \n               /*\n@@ -1070,7 +1070,7 @@ impl Liveness {\n             self.propagate_through_loop(expr, Some(cond), blk, succ)\n           }\n \n-          ExprForLoop(*) => fail2!(\"non-desugared expr_for_loop\"),\n+          ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n \n           // Note that labels have been resolved, so we don't need to look\n           // at the label ident\n@@ -1382,7 +1382,7 @@ impl Liveness {\n             self.merge_from_succ(ln, succ, first_merge);\n             first_merge = false;\n         }\n-        debug2!(\"propagate_through_loop: using id for loop body {} {}\",\n+        debug!(\"propagate_through_loop: using id for loop body {} {}\",\n                expr.id, block_to_str(body, self.tcx.sess.intr()));\n \n         let cond_ln = self.propagate_through_opt_expr(cond, ln);\n@@ -1410,7 +1410,7 @@ impl Liveness {\n                               cont_ln: LiveNode,\n                               f: &fn() -> R)\n                               -> R {\n-      debug2!(\"with_loop_nodes: {} {}\", loop_node_id, *break_ln);\n+      debug!(\"with_loop_nodes: {} {}\", loop_node_id, *break_ln);\n         self.loop_scope.push(loop_node_id);\n         self.break_ln.insert(loop_node_id, break_ln);\n         self.cont_ln.insert(loop_node_id, cont_ln);\n@@ -1433,7 +1433,7 @@ fn check_local(this: &mut Liveness, local: @Local) {\n         // No initializer: the variable might be unused; if not, it\n         // should not be live at this point.\n \n-        debug2!(\"check_local() with no initializer\");\n+        debug!(\"check_local() with no initializer\");\n         do this.pat_bindings(local.pat) |ln, var, sp, id| {\n             if !this.warn_about_unused(sp, id, ln, var) {\n                 match this.live_on_exit(ln, var) {\n@@ -1499,7 +1499,7 @@ fn check_expr(this: &mut Liveness, expr: @Expr) {\n       ExprParen(*) | ExprFnBlock(*) | ExprPath(*) | ExprSelf(*) => {\n         visit::walk_expr(this, expr, ());\n       }\n-      ExprForLoop(*) => fail2!(\"non-desugared expr_for_loop\")\n+      ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\")\n     }\n }\n "}, {"sha": "37e89e58fa5696dfce734ce5388d64fbec9021f3", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -383,7 +383,7 @@ impl mem_categorization_ctxt {\n     }\n \n     pub fn cat_expr_unadjusted(&self, expr: @ast::Expr) -> cmt {\n-        debug2!(\"cat_expr: id={} expr={}\",\n+        debug!(\"cat_expr: id={} expr={}\",\n                expr.id, pprust::expr_to_str(expr, self.tcx.sess.intr()));\n \n         let expr_ty = self.expr_ty(expr);\n@@ -436,7 +436,7 @@ impl mem_categorization_ctxt {\n             return self.cat_rvalue_node(expr, expr_ty);\n           }\n \n-          ast::ExprForLoop(*) => fail2!(\"non-desugared expr_for_loop\")\n+          ast::ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\")\n         }\n     }\n \n@@ -870,7 +870,7 @@ impl mem_categorization_ctxt {\n         // get the type of the *subpattern* and use that.\n \n         let tcx = self.tcx;\n-        debug2!(\"cat_pattern: id={} pat={} cmt={}\",\n+        debug!(\"cat_pattern: id={} pat={} cmt={}\",\n                pat.id, pprust::pat_to_str(pat, tcx.sess.intr()),\n                cmt.repr(tcx));\n         let _i = indenter();"}, {"sha": "1ed517c951293078abe028f9253d7c39b1bad188", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -275,7 +275,7 @@ impl VisitContext {\n          * meaning either copied or moved depending on its type.\n          */\n \n-        debug2!(\"consume_expr(expr={})\",\n+        debug!(\"consume_expr(expr={})\",\n                expr.repr(self.tcx));\n \n         let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n@@ -293,7 +293,7 @@ impl VisitContext {\n          * meaning either copied or moved depending on its type.\n          */\n \n-        debug2!(\"consume_block(blk.id={:?})\", blk.id);\n+        debug!(\"consume_block(blk.id={:?})\", blk.id);\n \n         for stmt in blk.stmts.iter() {\n             self.visit_stmt(*stmt, ());\n@@ -312,7 +312,7 @@ impl VisitContext {\n          * in turn trigger calls to the subcomponents of `expr`.\n          */\n \n-        debug2!(\"use_expr(expr={}, mode={:?})\",\n+        debug!(\"use_expr(expr={}, mode={:?})\",\n                expr.repr(self.tcx),\n                expr_mode);\n \n@@ -326,7 +326,7 @@ impl VisitContext {\n             _ => expr_mode\n         };\n \n-        debug2!(\"comp_mode = {:?}\", comp_mode);\n+        debug!(\"comp_mode = {:?}\", comp_mode);\n \n         match expr.node {\n             ExprPath(*) | ExprSelf => {\n@@ -500,7 +500,7 @@ impl VisitContext {\n                 self.consume_block(blk);\n             }\n \n-            ExprForLoop(*) => fail2!(\"non-desugared expr_for_loop\"),\n+            ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n \n             ExprUnary(_, _, lhs) => {\n                 if !self.use_overloaded_operator(expr, lhs, [])\n@@ -620,15 +620,15 @@ impl VisitContext {\n                 BindByRef(_) => false,\n                 BindInfer => {\n                     let pat_ty = ty::node_id_to_type(self.tcx, id);\n-                    debug2!(\"pattern {:?} {} type is {}\",\n+                    debug!(\"pattern {:?} {} type is {}\",\n                            id,\n                            ast_util::path_to_ident(path).repr(self.tcx),\n                            pat_ty.repr(self.tcx));\n                     ty::type_moves_by_default(self.tcx, pat_ty)\n                 }\n             };\n \n-            debug2!(\"pattern binding {:?}: bm={:?}, binding_moves={}\",\n+            debug!(\"pattern binding {:?}: bm={:?}, binding_moves={}\",\n                    id, bm, binding_moves);\n \n             if binding_moves {\n@@ -678,7 +678,7 @@ impl VisitContext {\n     }\n \n     pub fn compute_captures(&mut self, fn_expr_id: NodeId) -> @[CaptureVar] {\n-        debug2!(\"compute_capture_vars(fn_expr_id={:?})\", fn_expr_id);\n+        debug!(\"compute_capture_vars(fn_expr_id={:?})\", fn_expr_id);\n         let _indenter = indenter();\n \n         let fn_ty = ty::node_id_to_type(self.tcx, fn_expr_id);\n@@ -696,7 +696,7 @@ impl VisitContext {\n                 let fvar = &freevars[i];\n                 let fvar_def_id = ast_util::def_id_of_def(fvar.def).node;\n                 let fvar_ty = ty::node_id_to_type(self.tcx, fvar_def_id);\n-                debug2!(\"fvar_def_id={:?} fvar_ty={}\",\n+                debug!(\"fvar_def_id={:?} fvar_ty={}\",\n                        fvar_def_id, ppaux::ty_to_str(self.tcx, fvar_ty));\n                 let mode = if ty::type_moves_by_default(self.tcx, fvar_ty) {\n                     CapMove"}, {"sha": "17aab59828981b3bf41bbc2b06d674f1eaa27909", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -192,7 +192,7 @@ impl<'self> Visitor<()> for EmbargoVisitor<'self> {\n             // Trait implementation methods are all completely public\n             ast::item_impl(_, Some(*), _, ref methods) => {\n                 for method in methods.iter() {\n-                    debug2!(\"exporting: {}\", method.id);\n+                    debug!(\"exporting: {}\", method.id);\n                     self.exported_items.insert(method.id);\n                 }\n             }\n@@ -203,11 +203,11 @@ impl<'self> Visitor<()> for EmbargoVisitor<'self> {\n                 for method in methods.iter() {\n                     match *method {\n                         ast::provided(ref m) => {\n-                            debug2!(\"provided {}\", m.id);\n+                            debug!(\"provided {}\", m.id);\n                             self.exported_items.insert(m.id);\n                         }\n                         ast::required(ref m) => {\n-                            debug2!(\"required {}\", m.id);\n+                            debug!(\"required {}\", m.id);\n                             self.exported_items.insert(m.id);\n                         }\n                     }\n@@ -267,26 +267,26 @@ impl<'self> PrivacyVisitor<'self> {\n     fn def_privacy(&self, did: ast::DefId) -> PrivacyResult {\n         if !is_local(did) {\n             if self.external_exports.contains(&did) {\n-                debug2!(\"privacy - {:?} was externally exported\", did);\n+                debug!(\"privacy - {:?} was externally exported\", did);\n                 return Allowable;\n             }\n-            debug2!(\"privacy - is {:?} a public method\", did);\n+            debug!(\"privacy - is {:?} a public method\", did);\n             return match self.tcx.methods.find(&did) {\n                 Some(meth) => {\n-                    debug2!(\"privacy - well at least it's a method: {:?}\", meth);\n+                    debug!(\"privacy - well at least it's a method: {:?}\", meth);\n                     match meth.container {\n                         ty::TraitContainer(id) => {\n-                            debug2!(\"privacy - recursing on trait {:?}\", id);\n+                            debug!(\"privacy - recursing on trait {:?}\", id);\n                             self.def_privacy(id)\n                         }\n                         ty::ImplContainer(id) => {\n                             match ty::impl_trait_ref(self.tcx, id) {\n                                 Some(t) => {\n-                                    debug2!(\"privacy - impl of trait {:?}\", id);\n+                                    debug!(\"privacy - impl of trait {:?}\", id);\n                                     self.def_privacy(t.def_id)\n                                 }\n                                 None => {\n-                                    debug2!(\"privacy - found a method {:?}\",\n+                                    debug!(\"privacy - found a method {:?}\",\n                                             meth.vis);\n                                     if meth.vis == ast::public {\n                                         Allowable\n@@ -299,27 +299,27 @@ impl<'self> PrivacyVisitor<'self> {\n                     }\n                 }\n                 None => {\n-                    debug2!(\"privacy - nope, not even a method\");\n+                    debug!(\"privacy - nope, not even a method\");\n                     ExternallyDenied\n                 }\n             };\n         } else if self.exported_items.contains(&did.node) {\n-            debug2!(\"privacy - exported item {}\", self.nodestr(did.node));\n+            debug!(\"privacy - exported item {}\", self.nodestr(did.node));\n             return Allowable;\n         }\n \n-        debug2!(\"privacy - local {:?} not public all the way down\", did);\n+        debug!(\"privacy - local {:?} not public all the way down\", did);\n         // return quickly for things in the same module\n         if self.parents.find(&did.node) == self.parents.find(&self.curitem) {\n-            debug2!(\"privacy - same parent, we're done here\");\n+            debug!(\"privacy - same parent, we're done here\");\n             return Allowable;\n         }\n \n         // We now know that there is at least one private member between the\n         // destination and the root.\n         let mut closest_private_id = did.node;\n         loop {\n-            debug2!(\"privacy - examining {}\", self.nodestr(closest_private_id));\n+            debug!(\"privacy - examining {}\", self.nodestr(closest_private_id));\n             let vis = match self.tcx.items.find(&closest_private_id) {\n                 Some(&ast_map::node_item(it, _)) => it.vis,\n                 Some(&ast_map::node_method(ref m, _, _)) => m.vis,\n@@ -339,7 +339,7 @@ impl<'self> PrivacyVisitor<'self> {\n             // way down in the first place...\n             assert!(closest_private_id != ast::DUMMY_NODE_ID);\n         }\n-        debug2!(\"privacy - closest priv {}\", self.nodestr(closest_private_id));\n+        debug!(\"privacy - closest priv {}\", self.nodestr(closest_private_id));\n         if self.private_accessible(closest_private_id) {\n             Allowable\n         } else {\n@@ -352,15 +352,15 @@ impl<'self> PrivacyVisitor<'self> {\n     /// inside.\n     fn private_accessible(&self, id: ast::NodeId) -> bool {\n         let parent = *self.parents.get(&id);\n-        debug2!(\"privacy - accessible parent {}\", self.nodestr(parent));\n+        debug!(\"privacy - accessible parent {}\", self.nodestr(parent));\n \n         // After finding `did`'s closest private member, we roll ourselves back\n         // to see if this private member's parent is anywhere in our ancestry.\n         // By the privacy rules, we can access all of our ancestor's private\n         // members, so that's why we test the parent, and not the did itself.\n         let mut cur = self.curitem;\n         loop {\n-            debug2!(\"privacy - questioning {}\", self.nodestr(cur));\n+            debug!(\"privacy - questioning {}\", self.nodestr(cur));\n             match cur {\n                 // If the relevant parent is in our history, then we're allowed\n                 // to look inside any of our ancestor's immediate private items,\n@@ -458,7 +458,7 @@ impl<'self> PrivacyVisitor<'self> {\n \n     // Checks that a path is in scope.\n     fn check_path(&mut self, span: Span, path_id: ast::NodeId, path: &ast::Path) {\n-        debug2!(\"privacy - path {}\", self.nodestr(path_id));\n+        debug!(\"privacy - path {}\", self.nodestr(path_id));\n         let def = self.tcx.def_map.get_copy(&path_id);\n         let ck = |tyname: &str| {\n             let origdid = def_id_of_def(def);\n@@ -703,7 +703,7 @@ impl<'self> Visitor<()> for PrivacyVisitor<'self> {\n                             }\n                             Some(entry) => entry\n                         };\n-                        debug2!(\"(privacy checking) checking impl method\");\n+                        debug!(\"(privacy checking) checking impl method\");\n                         self.check_method(expr.span, &entry.origin, ident);\n                     }\n                     _ => {}\n@@ -773,12 +773,12 @@ impl<'self> Visitor<()> for PrivacyVisitor<'self> {\n                     match vpath.node {\n                         ast::view_path_simple(_, ref path, id) |\n                         ast::view_path_glob(ref path, id) => {\n-                            debug2!(\"privacy - glob/simple {}\", id);\n+                            debug!(\"privacy - glob/simple {}\", id);\n                             self.check_path(vpath.span, id, path);\n                         }\n                         ast::view_path_list(_, ref list, _) => {\n                             for pid in list.iter() {\n-                                debug2!(\"privacy - list {}\", pid.node.id);\n+                                debug!(\"privacy - list {}\", pid.node.id);\n                                 let seg = ast::PathSegment {\n                                     identifier: pid.node.name,\n                                     lifetime: None,"}, {"sha": "29acfe143813878ff7f51eb4a358349f1757df8e", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -93,13 +93,13 @@ impl RegionMaps {\n             None => {}\n         }\n \n-        debug2!(\"relate_free_regions(sub={:?}, sup={:?})\", sub, sup);\n+        debug!(\"relate_free_regions(sub={:?}, sup={:?})\", sub, sup);\n \n         self.free_region_map.insert(sub, ~[sup]);\n     }\n \n     pub fn record_parent(&mut self, sub: ast::NodeId, sup: ast::NodeId) {\n-        debug2!(\"record_parent(sub={:?}, sup={:?})\", sub, sup);\n+        debug!(\"record_parent(sub={:?}, sup={:?})\", sub, sup);\n         assert!(sub != sup);\n \n         self.scope_map.insert(sub, sup);\n@@ -125,7 +125,7 @@ impl RegionMaps {\n \n         match self.scope_map.find(&id) {\n             Some(&r) => r,\n-            None => { fail2!(\"No enclosing scope for id {:?}\", id); }\n+            None => { fail!(\"No enclosing scope for id {:?}\", id); }\n         }\n     }\n \n@@ -168,7 +168,7 @@ impl RegionMaps {\n         while superscope != s {\n             match self.scope_map.find(&s) {\n                 None => {\n-                    debug2!(\"is_subscope_of({:?}, {:?}, s={:?})=false\",\n+                    debug!(\"is_subscope_of({:?}, {:?}, s={:?})=false\",\n                            subscope, superscope, s);\n \n                     return false;\n@@ -177,7 +177,7 @@ impl RegionMaps {\n             }\n         }\n \n-        debug2!(\"is_subscope_of({:?}, {:?})=true\",\n+        debug!(\"is_subscope_of({:?}, {:?})=true\",\n                subscope, superscope);\n \n         return true;\n@@ -231,7 +231,7 @@ impl RegionMaps {\n          * duplicated with the code in infer.rs.\n          */\n \n-        debug2!(\"is_subregion_of(sub_region={:?}, super_region={:?})\",\n+        debug!(\"is_subregion_of(sub_region={:?}, super_region={:?})\",\n                sub_region, super_region);\n \n         sub_region == super_region || {\n@@ -303,7 +303,7 @@ impl RegionMaps {\n         fn ancestors_of(this: &RegionMaps, scope: ast::NodeId)\n             -> ~[ast::NodeId]\n         {\n-            // debug2!(\"ancestors_of(scope={})\", scope);\n+            // debug!(\"ancestors_of(scope={})\", scope);\n             let mut result = ~[scope];\n             let mut scope = scope;\n             loop {\n@@ -314,7 +314,7 @@ impl RegionMaps {\n                         scope = superscope;\n                     }\n                 }\n-                // debug2!(\"ancestors_of_loop(scope={})\", scope);\n+                // debug!(\"ancestors_of_loop(scope={})\", scope);\n             }\n         }\n     }\n@@ -323,7 +323,7 @@ impl RegionMaps {\n /// Records the current parent (if any) as the parent of `child_id`.\n fn parent_to_expr(visitor: &mut RegionResolutionVisitor,\n                   cx: Context, child_id: ast::NodeId, sp: Span) {\n-    debug2!(\"region::parent_to_expr(span={:?})\",\n+    debug!(\"region::parent_to_expr(span={:?})\",\n            visitor.sess.codemap.span_to_str(sp));\n     for parent_id in cx.parent.iter() {\n         visitor.region_maps.record_parent(child_id, *parent_id);\n@@ -437,7 +437,7 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n               sp: Span,\n               id: ast::NodeId,\n               cx: Context) {\n-    debug2!(\"region::resolve_fn(id={:?}, \\\n+    debug!(\"region::resolve_fn(id={:?}, \\\n                                span={:?}, \\\n                                body.id={:?}, \\\n                                cx.parent={:?})\",\n@@ -619,7 +619,7 @@ impl DetermineRpCtxt {\n           Some(v) => join_variance(v, variance)\n         };\n \n-        debug2!(\"add_rp() variance for {}: {:?} == {:?} ^ {:?}\",\n+        debug!(\"add_rp() variance for {}: {:?} == {:?} ^ {:?}\",\n                ast_map::node_id_to_str(self.ast_map, id,\n                                        token::get_ident_interner()),\n                joined_variance, old_variance, variance);\n@@ -637,7 +637,7 @@ impl DetermineRpCtxt {\n     /// contains a value of type `from`, so if `from` is\n     /// region-parameterized, so is the current item.\n     pub fn add_dep(&mut self, from: ast::NodeId) {\n-        debug2!(\"add dependency from {} -> {} ({} -> {}) with variance {:?}\",\n+        debug!(\"add dependency from {} -> {} ({} -> {}) with variance {:?}\",\n                from, self.item_id,\n                ast_map::node_id_to_str(self.ast_map, from,\n                                        token::get_ident_interner()),\n@@ -715,7 +715,7 @@ impl DetermineRpCtxt {\n         let old_anon_implies_rp = self.anon_implies_rp;\n         self.item_id = item_id;\n         self.anon_implies_rp = anon_implies_rp;\n-        debug2!(\"with_item_id({}, {})\",\n+        debug!(\"with_item_id({}, {})\",\n                item_id,\n                anon_implies_rp);\n         let _i = ::util::common::indenter();\n@@ -787,7 +787,7 @@ fn determine_rp_in_ty(visitor: &mut DetermineRpVisitor,\n     let sess = cx.sess;\n     match ty.node {\n         ast::ty_rptr(ref r, _) => {\n-            debug2!(\"referenced rptr type {}\",\n+            debug!(\"referenced rptr type {}\",\n                    pprust::ty_to_str(ty, sess.intr()));\n \n             if cx.region_is_relevant(r) {\n@@ -797,7 +797,7 @@ fn determine_rp_in_ty(visitor: &mut DetermineRpVisitor,\n         }\n \n         ast::ty_closure(ref f) => {\n-            debug2!(\"referenced fn type: {}\",\n+            debug!(\"referenced fn type: {}\",\n                    pprust::ty_to_str(ty, sess.intr()));\n             match f.region {\n                 Some(_) => {\n@@ -837,7 +837,7 @@ fn determine_rp_in_ty(visitor: &mut DetermineRpVisitor,\n                 match csearch::get_region_param(cstore, did) {\n                   None => {}\n                   Some(variance) => {\n-                    debug2!(\"reference to external, rp'd type {}\",\n+                    debug!(\"reference to external, rp'd type {}\",\n                            pprust::ty_to_str(ty, sess.intr()));\n                     if cx.region_is_relevant(&path.segments.last().lifetime) {\n                         let rv = cx.add_variance(variance);\n@@ -967,7 +967,7 @@ pub fn determine_rp_in_crate(sess: Session,\n         while cx.worklist.len() != 0 {\n             let c_id = cx.worklist.pop();\n             let c_variance = cx.region_paramd_items.get_copy(&c_id);\n-            debug2!(\"popped {} from worklist\", c_id);\n+            debug!(\"popped {} from worklist\", c_id);\n             match cx.dep_map.find(&c_id) {\n               None => {}\n               Some(deps) => {\n@@ -980,11 +980,11 @@ pub fn determine_rp_in_crate(sess: Session,\n         }\n     }\n \n-    debug2!(\"{}\", {\n-        debug2!(\"Region variance results:\");\n+    debug!(\"{}\", {\n+        debug!(\"Region variance results:\");\n         let region_paramd_items = cx.region_paramd_items;\n         for (&key, &value) in region_paramd_items.iter() {\n-            debug2!(\"item {:?} ({}) is parameterized with variance {:?}\",\n+            debug!(\"item {:?} ({}) is parameterized with variance {:?}\",\n                    key,\n                    ast_map::node_id_to_str(ast_map, key,\n                                            token::get_ident_interner()),"}, {"sha": "b480aaac1acb1763958c96ebceccce9158f80154", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 121, "deletions": 121, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -665,7 +665,7 @@ impl NameBindings {\n     fn get_module(&mut self) -> @mut Module {\n         match self.get_module_if_available() {\n             None => {\n-                fail2!(\"get_module called on a node with no module \\\n+                fail!(\"get_module called on a node with no module \\\n                        definition!\")\n             }\n             Some(module_def) => module_def\n@@ -1405,7 +1405,7 @@ impl Resolver {\n                     }\n                     match self.method_map.find_mut(name) {\n                         Some(s) => { s.insert(def_id); },\n-                        _ => fail2!(\"Can't happen\"),\n+                        _ => fail!(\"Can't happen\"),\n                     }\n                 }\n \n@@ -1414,7 +1414,7 @@ impl Resolver {\n             }\n \n             item_mac(*) => {\n-                fail2!(\"item macros unimplemented\")\n+                fail!(\"item macros unimplemented\")\n             }\n         }\n     }\n@@ -1596,7 +1596,7 @@ impl Resolver {\n         if self.block_needs_anonymous_module(block) {\n             let block_id = block.id;\n \n-            debug2!(\"(building reduced graph for block) creating a new \\\n+            debug!(\"(building reduced graph for block) creating a new \\\n                     anonymous module for block {}\",\n                    block_id);\n \n@@ -1621,7 +1621,7 @@ impl Resolver {\n                            final_ident: &str,\n                            ident: Ident,\n                            new_parent: ReducedGraphParent) {\n-        debug2!(\"(building reduced graph for \\\n+        debug!(\"(building reduced graph for \\\n                 external crate) building external def, priv {:?}\",\n                vis);\n         let is_public = vis == ast::public;\n@@ -1641,12 +1641,12 @@ impl Resolver {\n           DefTy(def_id) => {\n             match child_name_bindings.type_def {\n               Some(TypeNsDef { module_def: Some(module_def), _ }) => {\n-                debug2!(\"(building reduced graph for external crate) \\\n+                debug!(\"(building reduced graph for external crate) \\\n                         already created module\");\n                 module_def.def_id = Some(def_id);\n               }\n               Some(_) | None => {\n-                debug2!(\"(building reduced graph for \\\n+                debug!(\"(building reduced graph for \\\n                         external crate) building module \\\n                         {}\", final_ident);\n                 let parent_link = self.get_parent_link(new_parent, ident);\n@@ -1666,7 +1666,7 @@ impl Resolver {\n         match def {\n           DefMod(_) | DefForeignMod(_) => {}\n           DefVariant(_, variant_id, is_struct) => {\n-            debug2!(\"(building reduced graph for external crate) building \\\n+            debug!(\"(building reduced graph for external crate) building \\\n                     variant {}\",\n                    final_ident);\n             // We assume the parent is visible, or else we wouldn't have seen\n@@ -1681,12 +1681,12 @@ impl Resolver {\n             }\n           }\n           DefFn(*) | DefStaticMethod(*) | DefStatic(*) => {\n-            debug2!(\"(building reduced graph for external \\\n+            debug!(\"(building reduced graph for external \\\n                     crate) building value (fn/static) {}\", final_ident);\n             child_name_bindings.define_value(def, dummy_sp(), is_public);\n           }\n           DefTrait(def_id) => {\n-              debug2!(\"(building reduced graph for external \\\n+              debug!(\"(building reduced graph for external \\\n                       crate) building type {}\", final_ident);\n \n               // If this is a trait, add all the method names\n@@ -1700,7 +1700,7 @@ impl Resolver {\n                       get_method_name_and_explicit_self(self.session.cstore,\n                                                         method_def_id);\n \n-                  debug2!(\"(building reduced graph for \\\n+                  debug!(\"(building reduced graph for \\\n                           external crate) ... adding \\\n                           trait method '{}'\",\n                          self.session.str_of(method_name));\n@@ -1719,7 +1719,7 @@ impl Resolver {\n                   }\n                   match self.method_map.find_mut(name) {\n                       Some(s) => { s.insert(def_id); },\n-                      _ => fail2!(\"Can't happen\"),\n+                      _ => fail!(\"Can't happen\"),\n                   }\n               }\n \n@@ -1735,13 +1735,13 @@ impl Resolver {\n                                                   dummy_sp())\n           }\n           DefTy(_) => {\n-              debug2!(\"(building reduced graph for external \\\n+              debug!(\"(building reduced graph for external \\\n                       crate) building type {}\", final_ident);\n \n               child_name_bindings.define_type(def, dummy_sp(), is_public);\n           }\n           DefStruct(def_id) => {\n-            debug2!(\"(building reduced graph for external \\\n+            debug!(\"(building reduced graph for external \\\n                     crate) building type and value for {}\",\n                    final_ident);\n             child_name_bindings.define_type(def, dummy_sp(), is_public);\n@@ -1751,15 +1751,15 @@ impl Resolver {\n             self.structs.insert(def_id);\n           }\n           DefMethod(*) => {\n-              debug2!(\"(building reduced graph for external crate) \\\n+              debug!(\"(building reduced graph for external crate) \\\n                       ignoring {:?}\", def);\n               // Ignored; handled elsewhere.\n           }\n           DefSelf(*) | DefArg(*) | DefLocal(*) |\n           DefPrimTy(*) | DefTyParam(*) | DefBinding(*) |\n           DefUse(*) | DefUpvar(*) | DefRegion(*) |\n           DefTyParamBinder(*) | DefLabel(*) | DefSelfTy(*) => {\n-            fail2!(\"didn't expect `{:?}`\", def);\n+            fail!(\"didn't expect `{:?}`\", def);\n           }\n         }\n     }\n@@ -1814,7 +1814,7 @@ impl Resolver {\n                         match static_methods_opt {\n                             Some(ref static_methods) if\n                                 static_methods.len() >= 1 => {\n-                                debug2!(\"(building reduced graph for \\\n+                                debug!(\"(building reduced graph for \\\n                                         external crate) processing \\\n                                         static methods for type name {}\",\n                                         self.session.str_of(\n@@ -1866,7 +1866,7 @@ impl Resolver {\n                                 for static_method_info in\n                                         static_methods.iter() {\n                                     let ident = static_method_info.ident;\n-                                    debug2!(\"(building reduced graph for \\\n+                                    debug!(\"(building reduced graph for \\\n                                              external crate) creating \\\n                                              static method '{}'\",\n                                            self.session.str_of(ident));\n@@ -1893,28 +1893,28 @@ impl Resolver {\n                 }\n             }\n             DlField => {\n-                debug2!(\"(building reduced graph for external crate) \\\n+                debug!(\"(building reduced graph for external crate) \\\n                         ignoring field\");\n             }\n         }\n     }\n \n     /// Builds the reduced graph rooted at the given external module.\n     fn populate_external_module(&mut self, module: @mut Module) {\n-        debug2!(\"(populating external module) attempting to populate {}\",\n+        debug!(\"(populating external module) attempting to populate {}\",\n                self.module_to_str(module));\n \n         let def_id = match module.def_id {\n             None => {\n-                debug2!(\"(populating external module) ... no def ID!\");\n+                debug!(\"(populating external module) ... no def ID!\");\n                 return\n             }\n             Some(def_id) => def_id,\n         };\n \n         do csearch::each_child_of_item(self.session.cstore, def_id)\n                 |def_like, child_ident, visibility| {\n-            debug2!(\"(populating external module) ... found ident: {}\",\n+            debug!(\"(populating external module) ... found ident: {}\",\n                    token::ident_to_str(&child_ident));\n             self.build_reduced_graph_for_external_crate_def(module,\n                                                             def_like,\n@@ -1965,14 +1965,14 @@ impl Resolver {\n \n         match *subclass {\n             SingleImport(target, _) => {\n-                debug2!(\"(building import directive) building import \\\n+                debug!(\"(building import directive) building import \\\n                         directive: {}::{}\",\n                        self.idents_to_str(directive.module_path),\n                        self.session.str_of(target));\n \n                 match module_.import_resolutions.find(&target.name) {\n                     Some(&resolution) => {\n-                        debug2!(\"(building import directive) bumping \\\n+                        debug!(\"(building import directive) bumping \\\n                                 reference\");\n                         resolution.outstanding_references += 1;\n \n@@ -1981,7 +1981,7 @@ impl Resolver {\n                         resolution.value_id = id;\n                     }\n                     None => {\n-                        debug2!(\"(building import directive) creating new\");\n+                        debug!(\"(building import directive) creating new\");\n                         let resolution = @mut ImportResolution::new(id, is_public);\n                         resolution.outstanding_references = 1;\n                         module_.import_resolutions.insert(target.name, resolution);\n@@ -2013,14 +2013,14 @@ impl Resolver {\n         let mut i = 0;\n         let mut prev_unresolved_imports = 0;\n         loop {\n-            debug2!(\"(resolving imports) iteration {}, {} imports left\",\n+            debug!(\"(resolving imports) iteration {}, {} imports left\",\n                    i, self.unresolved_imports);\n \n             let module_root = self.graph_root.get_module();\n             self.resolve_imports_for_module_subtree(module_root);\n \n             if self.unresolved_imports == 0 {\n-                debug2!(\"(resolving imports) success\");\n+                debug!(\"(resolving imports) success\");\n                 break;\n             }\n \n@@ -2038,7 +2038,7 @@ impl Resolver {\n     /// submodules.\n     fn resolve_imports_for_module_subtree(&mut self,\n                                               module_: @mut Module) {\n-        debug2!(\"(resolving imports for module subtree) resolving {}\",\n+        debug!(\"(resolving imports for module subtree) resolving {}\",\n                self.module_to_str(module_));\n         self.resolve_imports_for_module(module_);\n \n@@ -2062,7 +2062,7 @@ impl Resolver {\n     /// Attempts to resolve imports for the given module only.\n     fn resolve_imports_for_module(&mut self, module: @mut Module) {\n         if module.all_imports_resolved() {\n-            debug2!(\"(resolving imports for module) all imports resolved for \\\n+            debug!(\"(resolving imports for module) all imports resolved for \\\n                    {}\",\n                    self.module_to_str(module));\n             return;\n@@ -2151,7 +2151,7 @@ impl Resolver {\n         let mut resolution_result = Failed;\n         let module_path = &import_directive.module_path;\n \n-        debug2!(\"(resolving import for module) resolving import `{}::...` in \\\n+        debug!(\"(resolving import for module) resolving import `{}::...` in \\\n                 `{}`\",\n                self.idents_to_str(*module_path),\n                self.module_to_str(module_));\n@@ -2256,7 +2256,7 @@ impl Resolver {\n                              directive: &ImportDirective,\n                              lp: LastPrivate)\n                                  -> ResolveResult<()> {\n-        debug2!(\"(resolving single import) resolving `{}` = `{}::{}` from \\\n+        debug!(\"(resolving single import) resolving `{}` = `{}::{}` from \\\n                 `{}` id {}, last private {:?}\",\n                self.session.str_of(target),\n                self.module_to_str(containing_module),\n@@ -2300,7 +2300,7 @@ impl Resolver {\n                 // able to resolve this import.\n \n                 if containing_module.glob_count > 0 {\n-                    debug2!(\"(resolving single import) unresolved glob; \\\n+                    debug!(\"(resolving single import) unresolved glob; \\\n                             bailing out\");\n                     return Indeterminate;\n                 }\n@@ -2368,7 +2368,7 @@ impl Resolver {\n                     }\n                     Some(_) => {\n                         // The import is unresolved. Bail out.\n-                        debug2!(\"(resolving single import) unresolved import; \\\n+                        debug!(\"(resolving single import) unresolved import; \\\n                                 bailing out\");\n                         return Indeterminate;\n                     }\n@@ -2403,20 +2403,20 @@ impl Resolver {\n \n         match value_result {\n             BoundResult(target_module, name_bindings) => {\n-                debug2!(\"(resolving single import) found value target\");\n+                debug!(\"(resolving single import) found value target\");\n                 import_resolution.value_target =\n                     Some(Target::new(target_module, name_bindings));\n                 import_resolution.value_id = directive.id;\n                 used_public = name_bindings.defined_in_public_namespace(ValueNS);\n             }\n             UnboundResult => { /* Continue. */ }\n             UnknownResult => {\n-                fail2!(\"value result should be known at this point\");\n+                fail!(\"value result should be known at this point\");\n             }\n         }\n         match type_result {\n             BoundResult(target_module, name_bindings) => {\n-                debug2!(\"(resolving single import) found type target: {:?}\",\n+                debug!(\"(resolving single import) found type target: {:?}\",\n                         name_bindings.type_def.unwrap().type_def);\n                 import_resolution.type_target =\n                     Some(Target::new(target_module, name_bindings));\n@@ -2425,7 +2425,7 @@ impl Resolver {\n             }\n             UnboundResult => { /* Continue. */ }\n             UnknownResult => {\n-                fail2!(\"type result should be known at this point\");\n+                fail!(\"type result should be known at this point\");\n             }\n         }\n \n@@ -2467,7 +2467,7 @@ impl Resolver {\n             None => {}\n         }\n \n-        debug2!(\"(resolving single import) successfully resolved import\");\n+        debug!(\"(resolving single import) successfully resolved import\");\n         return Success(());\n     }\n \n@@ -2484,12 +2484,12 @@ impl Resolver {\n         // This function works in a highly imperative manner; it eagerly adds\n         // everything it can to the list of import resolutions of the module\n         // node.\n-        debug2!(\"(resolving glob import) resolving glob import {}\", id);\n+        debug!(\"(resolving glob import) resolving glob import {}\", id);\n \n         // We must bail out if the node has unresolved imports of any kind\n         // (including globs).\n         if !(*containing_module).all_imports_resolved() {\n-            debug2!(\"(resolving glob import) target module has unresolved \\\n+            debug!(\"(resolving glob import) target module has unresolved \\\n                     imports; bailing out\");\n             return Indeterminate;\n         }\n@@ -2499,13 +2499,13 @@ impl Resolver {\n         // Add all resolved imports from the containing module.\n         for (ident, target_import_resolution) in containing_module.import_resolutions.iter() {\n \n-            debug2!(\"(resolving glob import) writing module resolution \\\n+            debug!(\"(resolving glob import) writing module resolution \\\n                     {:?} into `{}`\",\n                    target_import_resolution.type_target.is_none(),\n                    self.module_to_str(module_));\n \n             if !target_import_resolution.is_public {\n-                debug2!(\"(resolving glob import) nevermind, just kidding\");\n+                debug!(\"(resolving glob import) nevermind, just kidding\");\n                 continue\n             }\n \n@@ -2566,21 +2566,21 @@ impl Resolver {\n                 }\n             }\n \n-            debug2!(\"(resolving glob import) writing resolution `{}` in `{}` \\\n+            debug!(\"(resolving glob import) writing resolution `{}` in `{}` \\\n                     to `{}`\",\n                    interner_get(name),\n                    self.module_to_str(containing_module),\n                    self.module_to_str(module_));\n \n             // Merge the child item into the import resolution.\n             if name_bindings.defined_in_public_namespace(ValueNS) {\n-                debug2!(\"(resolving glob import) ... for value target\");\n+                debug!(\"(resolving glob import) ... for value target\");\n                 dest_import_resolution.value_target =\n                     Some(Target::new(containing_module, name_bindings));\n                 dest_import_resolution.value_id = id;\n             }\n             if name_bindings.defined_in_public_namespace(TypeNS) {\n-                debug2!(\"(resolving glob import) ... for type target\");\n+                debug!(\"(resolving glob import) ... for type target\");\n                 dest_import_resolution.type_target =\n                     Some(Target::new(containing_module, name_bindings));\n                 dest_import_resolution.type_id = id;\n@@ -2610,7 +2610,7 @@ impl Resolver {\n             None => {}\n         }\n \n-        debug2!(\"(resolving glob import) successfully resolved import\");\n+        debug!(\"(resolving glob import) successfully resolved import\");\n         return Success(());\n     }\n \n@@ -2658,7 +2658,7 @@ impl Resolver {\n                     return Failed;\n                 }\n                 Indeterminate => {\n-                    debug2!(\"(resolving module path for import) module \\\n+                    debug!(\"(resolving module path for import) module \\\n                             resolution is indeterminate: {}\",\n                             self.session.str_of(name));\n                     return Indeterminate;\n@@ -2747,7 +2747,7 @@ impl Resolver {\n         let module_path_len = module_path.len();\n         assert!(module_path_len > 0);\n \n-        debug2!(\"(resolving module path for import) processing `{}` rooted at \\\n+        debug!(\"(resolving module path for import) processing `{}` rooted at \\\n                `{}`\",\n                self.idents_to_str(module_path),\n                self.module_to_str(module_));\n@@ -2776,7 +2776,7 @@ impl Resolver {\n                 return Failed;\n             }\n             Indeterminate => {\n-                debug2!(\"(resolving module path for import) indeterminate; \\\n+                debug!(\"(resolving module path for import) indeterminate; \\\n                         bailing\");\n                 return Indeterminate;\n             }\n@@ -2805,7 +2805,7 @@ impl Resolver {\n                                 return Failed;\n                             }\n                             Indeterminate => {\n-                                debug2!(\"(resolving module path for import) \\\n+                                debug!(\"(resolving module path for import) \\\n                                         indeterminate; bailing\");\n                                 return Indeterminate;\n                             }\n@@ -2842,7 +2842,7 @@ impl Resolver {\n                                      search_through_modules:\n                                      SearchThroughModulesFlag)\n                                     -> ResolveResult<(Target, bool)> {\n-        debug2!(\"(resolving item in lexical scope) resolving `{}` in \\\n+        debug!(\"(resolving item in lexical scope) resolving `{}` in \\\n                 namespace {:?} in `{}`\",\n                self.session.str_of(name),\n                namespace,\n@@ -2854,7 +2854,7 @@ impl Resolver {\n         match module_.children.find(&name.name) {\n             Some(name_bindings)\n                     if name_bindings.defined_in_namespace(namespace) => {\n-                debug2!(\"top name bindings succeeded\");\n+                debug!(\"top name bindings succeeded\");\n                 return Success((Target::new(module_, *name_bindings), false));\n             }\n             Some(_) | None => { /* Not found; continue. */ }\n@@ -2872,12 +2872,12 @@ impl Resolver {\n                 match (*import_resolution).target_for_namespace(namespace) {\n                     None => {\n                         // Not found; continue.\n-                        debug2!(\"(resolving item in lexical scope) found \\\n+                        debug!(\"(resolving item in lexical scope) found \\\n                                 import resolution, but not in namespace {:?}\",\n                                namespace);\n                     }\n                     Some(target) => {\n-                        debug2!(\"(resolving item in lexical scope) using \\\n+                        debug!(\"(resolving item in lexical scope) using \\\n                                 import resolution\");\n                         self.used_imports.insert(import_resolution.id(namespace));\n                         return Success((target, false));\n@@ -2894,7 +2894,7 @@ impl Resolver {\n                     let name_bindings =\n                         @mut Resolver::create_name_bindings_from_module(\n                             *module);\n-                    debug2!(\"lower name bindings succeeded\");\n+                    debug!(\"lower name bindings succeeded\");\n                     return Success((Target::new(module_, name_bindings), false));\n                 }\n             }\n@@ -2907,7 +2907,7 @@ impl Resolver {\n             match search_module.parent_link {\n                 NoParentLink => {\n                     // No more parents. This module was unresolved.\n-                    debug2!(\"(resolving item in lexical scope) unresolved \\\n+                    debug!(\"(resolving item in lexical scope) unresolved \\\n                             module\");\n                     return Failed;\n                 }\n@@ -2917,7 +2917,7 @@ impl Resolver {\n                             match search_module.kind {\n                                 NormalModuleKind => {\n                                     // We stop the search here.\n-                                    debug2!(\"(resolving item in lexical \\\n+                                    debug!(\"(resolving item in lexical \\\n                                             scope) unresolved module: not \\\n                                             searching through module \\\n                                             parents\");\n@@ -2953,13 +2953,13 @@ impl Resolver {\n                     // We couldn't see through the higher scope because of an\n                     // unresolved import higher up. Bail.\n \n-                    debug2!(\"(resolving item in lexical scope) indeterminate \\\n+                    debug!(\"(resolving item in lexical scope) indeterminate \\\n                             higher scope; bailing\");\n                     return Indeterminate;\n                 }\n                 Success((target, used_reexport)) => {\n                     // We found the module.\n-                    debug2!(\"(resolving item in lexical scope) found name \\\n+                    debug!(\"(resolving item in lexical scope) found name \\\n                             in module, done\");\n                     return Success((target, used_reexport));\n                 }\n@@ -2983,7 +2983,7 @@ impl Resolver {\n                     Some(ref type_def) => {\n                         match (*type_def).module_def {\n                             None => {\n-                                error2!(\"!!! (resolving module in lexical \\\n+                                error!(\"!!! (resolving module in lexical \\\n                                         scope) module wasn't actually a \\\n                                         module!\");\n                                 return Failed;\n@@ -2994,19 +2994,19 @@ impl Resolver {\n                         }\n                     }\n                     None => {\n-                        error2!(\"!!! (resolving module in lexical scope) module\n+                        error!(\"!!! (resolving module in lexical scope) module\n                                 wasn't actually a module!\");\n                         return Failed;\n                     }\n                 }\n             }\n             Indeterminate => {\n-                debug2!(\"(resolving module in lexical scope) indeterminate; \\\n+                debug!(\"(resolving module in lexical scope) indeterminate; \\\n                         bailing\");\n                 return Indeterminate;\n             }\n             Failed => {\n-                debug2!(\"(resolving module in lexical scope) failed to \\\n+                debug!(\"(resolving module in lexical scope) failed to \\\n                         resolve\");\n                 return Failed;\n             }\n@@ -3079,7 +3079,7 @@ impl Resolver {\n         // Now loop through all the `super`s we find.\n         while i < module_path.len() &&\n                 \"super\" == token::ident_to_str(&module_path[i]) {\n-            debug2!(\"(resolving module prefix) resolving `super` at {}\",\n+            debug!(\"(resolving module prefix) resolving `super` at {}\",\n                    self.module_to_str(containing_module));\n             match self.get_nearest_normal_module_parent(containing_module) {\n                 None => return Failed,\n@@ -3090,7 +3090,7 @@ impl Resolver {\n             }\n         }\n \n-        debug2!(\"(resolving module prefix) finished resolving prefix at {}\",\n+        debug!(\"(resolving module prefix) finished resolving prefix at {}\",\n                self.module_to_str(containing_module));\n \n         return Success(PrefixFound(containing_module, i));\n@@ -3108,7 +3108,7 @@ impl Resolver {\n                               namespace: Namespace,\n                               name_search_type: NameSearchType)\n                               -> ResolveResult<(Target, bool)> {\n-        debug2!(\"(resolving name in module) resolving `{}` in `{}`\",\n+        debug!(\"(resolving name in module) resolving `{}` in `{}`\",\n                self.session.str_of(name),\n                self.module_to_str(module_));\n \n@@ -3117,7 +3117,7 @@ impl Resolver {\n         match module_.children.find(&name.name) {\n             Some(name_bindings)\n                     if name_bindings.defined_in_namespace(namespace) => {\n-                debug2!(\"(resolving name in module) found node as child\");\n+                debug!(\"(resolving name in module) found node as child\");\n                 return Success((Target::new(module_, *name_bindings), false));\n             }\n             Some(_) | None => {\n@@ -3138,18 +3138,18 @@ impl Resolver {\n             Some(import_resolution) => {\n                 if import_resolution.is_public &&\n                         import_resolution.outstanding_references != 0 {\n-                    debug2!(\"(resolving name in module) import \\\n+                    debug!(\"(resolving name in module) import \\\n                            unresolved; bailing out\");\n                     return Indeterminate;\n                 }\n                 match import_resolution.target_for_namespace(namespace) {\n                     None => {\n-                        debug2!(\"(resolving name in module) name found, \\\n+                        debug!(\"(resolving name in module) name found, \\\n                                 but not in namespace {:?}\",\n                                namespace);\n                     }\n                     Some(target) => {\n-                        debug2!(\"(resolving name in module) resolved to \\\n+                        debug!(\"(resolving name in module) resolved to \\\n                                 import\");\n                         self.used_imports.insert(import_resolution.id(namespace));\n                         return Success((target, true));\n@@ -3173,7 +3173,7 @@ impl Resolver {\n         }\n \n         // We're out of luck.\n-        debug2!(\"(resolving name in module) failed to resolve `{}`\",\n+        debug!(\"(resolving name in module) failed to resolve `{}`\",\n                self.session.str_of(name));\n         return Failed;\n     }\n@@ -3233,19 +3233,19 @@ impl Resolver {\n         match module_.def_id {\n             Some(def_id) if def_id.crate == LOCAL_CRATE => {\n                 // OK. Continue.\n-                debug2!(\"(recording exports for module subtree) recording \\\n+                debug!(\"(recording exports for module subtree) recording \\\n                         exports for local module `{}`\",\n                        self.module_to_str(module_));\n             }\n             None => {\n                 // Record exports for the root module.\n-                debug2!(\"(recording exports for module subtree) recording \\\n+                debug!(\"(recording exports for module subtree) recording \\\n                         exports for root module `{}`\",\n                        self.module_to_str(module_));\n             }\n             Some(_) => {\n                 // Bail out.\n-                debug2!(\"(recording exports for module subtree) not recording \\\n+                debug!(\"(recording exports for module subtree) not recording \\\n                         exports for `{}`\",\n                        self.module_to_str(module_));\n                 return;\n@@ -3278,7 +3278,7 @@ impl Resolver {\n         match module_.def_id {\n             Some(def_id) => {\n                 self.export_map2.insert(def_id.node, exports2);\n-                debug2!(\"(computing exports) writing exports for {} (some)\",\n+                debug!(\"(computing exports) writing exports for {} (some)\",\n                        def_id.node);\n             }\n             None => {}\n@@ -3293,7 +3293,7 @@ impl Resolver {\n                                    reexport: bool) {\n         match namebindings.def_for_namespace(ns) {\n             Some(d) => {\n-                debug2!(\"(computing exports) YES: {} '{}' => {:?}\",\n+                debug!(\"(computing exports) YES: {} '{}' => {:?}\",\n                        if reexport { ~\"reexport\" } else { ~\"export\"},\n                        interner_get(name),\n                        def_id_of_def(d));\n@@ -3304,7 +3304,7 @@ impl Resolver {\n                 });\n             }\n             d_opt => {\n-                debug2!(\"(computing reexports) NO: {:?}\", d_opt);\n+                debug!(\"(computing reexports) NO: {:?}\", d_opt);\n             }\n         }\n     }\n@@ -3318,7 +3318,7 @@ impl Resolver {\n             for &ns in xs.iter() {\n                 match importresolution.target_for_namespace(ns) {\n                     Some(target) => {\n-                        debug2!(\"(computing exports) maybe reexport '{}'\",\n+                        debug!(\"(computing exports) maybe reexport '{}'\",\n                                interner_get(*name));\n                         self.add_exports_of_namebindings(exports2,\n                                                          *name,\n@@ -3362,14 +3362,14 @@ impl Resolver {\n                 self.populate_module_if_necessary(orig_module);\n                 match orig_module.children.find(&name.name) {\n                     None => {\n-                        debug2!(\"!!! (with scope) didn't find `{}` in `{}`\",\n+                        debug!(\"!!! (with scope) didn't find `{}` in `{}`\",\n                                self.session.str_of(name),\n                                self.module_to_str(orig_module));\n                     }\n                     Some(name_bindings) => {\n                         match (*name_bindings).get_module_if_available() {\n                             None => {\n-                                debug2!(\"!!! (with scope) didn't find module \\\n+                                debug!(\"!!! (with scope) didn't find module \\\n                                         for `{}` in `{}`\",\n                                        self.session.str_of(name),\n                                        self.module_to_str(orig_module));\n@@ -3529,13 +3529,13 @@ impl Resolver {\n     }\n \n     fn resolve_crate(&mut self, crate: &ast::Crate) {\n-        debug2!(\"(resolving crate) starting\");\n+        debug!(\"(resolving crate) starting\");\n \n         visit::walk_crate(self, crate, ());\n     }\n \n     fn resolve_item(&mut self, item: @item) {\n-        debug2!(\"(resolving item) resolving {}\",\n+        debug!(\"(resolving item) resolving {}\",\n                self.session.str_of(item.ident));\n \n         // Items with the !resolve_unexported attribute are X-ray contexts.\n@@ -3705,7 +3705,7 @@ impl Resolver {\n             }\n \n           item_mac(*) => {\n-            fail2!(\"item macros unimplemented\")\n+            fail!(\"item macros unimplemented\")\n           }\n         }\n \n@@ -3724,7 +3724,7 @@ impl Resolver {\n \n                 for (index, type_parameter) in generics.ty_params.iter().enumerate() {\n                     let ident = type_parameter.ident;\n-                    debug2!(\"with_type_parameter_rib: {} {}\", node_id,\n+                    debug!(\"with_type_parameter_rib: {} {}\", node_id,\n                            type_parameter.id);\n                     let def_like = DlDef(DefTyParam\n                         (local_def(type_parameter.id),\n@@ -3822,7 +3822,7 @@ impl Resolver {\n \n                         this.resolve_type(&argument.ty);\n \n-                        debug2!(\"(resolving function) recorded argument\");\n+                        debug!(\"(resolving function) recorded argument\");\n                     }\n \n                     this.resolve_type(&declaration.output);\n@@ -3832,7 +3832,7 @@ impl Resolver {\n             // Resolve the function body.\n             this.resolve_block(block);\n \n-            debug2!(\"(resolving function) leaving function\");\n+            debug!(\"(resolving function) leaving function\");\n         }\n \n         self.label_ribs.pop();\n@@ -3876,7 +3876,7 @@ impl Resolver {\n                 self.resolve_error(trait_reference.path.span, msg);\n             }\n             Some(def) => {\n-                debug2!(\"(resolving trait) found trait def: {:?}\", def);\n+                debug!(\"(resolving trait) found trait def: {:?}\", def);\n                 self.record_def(trait_reference.ref_id, def);\n             }\n         }\n@@ -4027,7 +4027,7 @@ impl Resolver {\n                           _name: Ident,\n                           id: NodeId) {\n         // Write the implementations in scope into the module metadata.\n-        debug2!(\"(resolving module) resolving module ID {}\", id);\n+        debug!(\"(resolving module) resolving module ID {}\", id);\n         visit::walk_mod(self, module_, ());\n     }\n \n@@ -4127,15 +4127,15 @@ impl Resolver {\n     }\n \n     fn resolve_block(&mut self, block: &Block) {\n-        debug2!(\"(resolving block) entering block\");\n+        debug!(\"(resolving block) entering block\");\n         self.value_ribs.push(@Rib::new(NormalRibKind));\n \n         // Move down in the graph, if there's an anonymous module rooted here.\n         let orig_module = self.current_module;\n         match self.current_module.anonymous_children.find(&block.id) {\n             None => { /* Nothing to do. */ }\n             Some(&anonymous_module) => {\n-                debug2!(\"(resolving block) found anonymous module, moving \\\n+                debug!(\"(resolving block) found anonymous module, moving \\\n                         down\");\n                 self.current_module = anonymous_module;\n             }\n@@ -4148,7 +4148,7 @@ impl Resolver {\n         self.current_module = orig_module;\n \n         self.value_ribs.pop();\n-        debug2!(\"(resolving block) leaving block\");\n+        debug!(\"(resolving block) leaving block\");\n     }\n \n     fn resolve_type(&mut self, ty: &Ty) {\n@@ -4199,7 +4199,7 @@ impl Resolver {\n                     None => {\n                         match self.resolve_path(ty.id, path, TypeNS, true) {\n                             Some(def) => {\n-                                debug2!(\"(resolving type) resolved `{}` to \\\n+                                debug!(\"(resolving type) resolved `{}` to \\\n                                         type {:?}\",\n                                        self.session.str_of(path.segments\n                                                                .last()\n@@ -4218,7 +4218,7 @@ impl Resolver {\n                 match result_def {\n                     Some(def) => {\n                         // Write the result into the def map.\n-                        debug2!(\"(resolving type) writing resolution for `{}` \\\n+                        debug!(\"(resolving type) writing resolution for `{}` \\\n                                 (id {})\",\n                                self.path_idents_to_str(path),\n                                path_id);\n@@ -4282,7 +4282,7 @@ impl Resolver {\n                     match self.resolve_bare_identifier_pattern(ident) {\n                         FoundStructOrEnumVariant(def, lp)\n                                 if mode == RefutableMode => {\n-                            debug2!(\"(resolving pattern) resolving `{}` to \\\n+                            debug!(\"(resolving pattern) resolving `{}` to \\\n                                     struct or enum variant\",\n                                    interner_get(renamed));\n \n@@ -4301,7 +4301,7 @@ impl Resolver {\n                                                        interner_get(renamed)));\n                         }\n                         FoundConst(def, lp) if mode == RefutableMode => {\n-                            debug2!(\"(resolving pattern) resolving `{}` to \\\n+                            debug!(\"(resolving pattern) resolving `{}` to \\\n                                     constant\",\n                                    interner_get(renamed));\n \n@@ -4317,7 +4317,7 @@ impl Resolver {\n                                                    allowed here\");\n                         }\n                         BareIdentifierPatternUnresolved => {\n-                            debug2!(\"(resolving pattern) binding `{}`\",\n+                            debug!(\"(resolving pattern) binding `{}`\",\n                                    interner_get(renamed));\n \n                             let is_mutable = mutability == Mutable;\n@@ -4490,7 +4490,7 @@ impl Resolver {\n                             self.record_def(pattern.id, definition);\n                         }\n                         result => {\n-                            debug2!(\"(resolving pattern) didn't find struct \\\n+                            debug!(\"(resolving pattern) didn't find struct \\\n                                     def: {:?}\", result);\n                             let msg = format!(\"`{}` does not name a structure\",\n                                               self.path_idents_to_str(path));\n@@ -4515,12 +4515,12 @@ impl Resolver {\n                                                  ValueNS,\n                                                  SearchThroughModules) {\n             Success((target, _)) => {\n-                debug2!(\"(resolve bare identifier pattern) succeeded in \\\n+                debug!(\"(resolve bare identifier pattern) succeeded in \\\n                          finding {} at {:?}\",\n                         self.session.str_of(name), target.bindings.value_def);\n                 match target.bindings.value_def {\n                     None => {\n-                        fail2!(\"resolved name in the value namespace to a \\\n+                        fail!(\"resolved name in the value namespace to a \\\n                               set of name bindings with no def?!\");\n                     }\n                     Some(def) => {\n@@ -4543,11 +4543,11 @@ impl Resolver {\n             }\n \n             Indeterminate => {\n-                fail2!(\"unexpected indeterminate result\");\n+                fail!(\"unexpected indeterminate result\");\n             }\n \n             Failed => {\n-                debug2!(\"(resolve bare identifier pattern) failed to find {}\",\n+                debug!(\"(resolve bare identifier pattern) failed to find {}\",\n                         self.session.str_of(name));\n                 return BareIdentifierPatternUnresolved;\n             }\n@@ -4713,7 +4713,7 @@ impl Resolver {\n             }\n \n             Indeterminate => {\n-                fail2!(\"indeterminate unexpected\");\n+                fail!(\"indeterminate unexpected\");\n             }\n \n             Success((resulting_module, resulting_last_private)) => {\n@@ -4740,7 +4740,7 @@ impl Resolver {\n                     Some(s) => {\n                         match containing_module.def_id {\n                             Some(def_id) if s.contains(&def_id) => {\n-                                debug2!(\"containing module was a trait or impl \\\n+                                debug!(\"containing module was a trait or impl \\\n                                         and name was a method -> not resolved\");\n                                 return None;\n                             },\n@@ -4781,7 +4781,7 @@ impl Resolver {\n             }\n \n             Indeterminate => {\n-                fail2!(\"indeterminate unexpected\");\n+                fail!(\"indeterminate unexpected\");\n             }\n \n             Success((resulting_module, resulting_last_private)) => {\n@@ -4827,7 +4827,7 @@ impl Resolver {\n \n         match search_result {\n             Some(DlDef(def)) => {\n-                debug2!(\"(resolving path in local ribs) resolved `{}` to \\\n+                debug!(\"(resolving path in local ribs) resolved `{}` to \\\n                         local: {:?}\",\n                        self.session.str_of(ident),\n                        def);\n@@ -4885,13 +4885,13 @@ impl Resolver {\n                     None => {\n                         // This can happen if we were looking for a type and\n                         // found a module instead. Modules don't have defs.\n-                        debug2!(\"(resolving item path by identifier in lexical \\\n+                        debug!(\"(resolving item path by identifier in lexical \\\n                                  scope) failed to resolve {} after success...\",\n                                  self.session.str_of(ident));\n                         return None;\n                     }\n                     Some(def) => {\n-                        debug2!(\"(resolving item path in lexical scope) \\\n+                        debug!(\"(resolving item path in lexical scope) \\\n                                 resolved `{}` to item\",\n                                self.session.str_of(ident));\n                         // This lookup is \"all public\" because it only searched\n@@ -4902,10 +4902,10 @@ impl Resolver {\n                 }\n             }\n             Indeterminate => {\n-                fail2!(\"unexpected indeterminate result\");\n+                fail!(\"unexpected indeterminate result\");\n             }\n             Failed => {\n-                debug2!(\"(resolving item path by identifier in lexical scope) \\\n+                debug!(\"(resolving item path by identifier in lexical scope) \\\n                          failed to resolve {}\", self.session.str_of(ident));\n                 return None;\n             }\n@@ -4983,7 +4983,7 @@ impl Resolver {\n                 match self.resolve_path(expr.id, path, ValueNS, true) {\n                     Some(def) => {\n                         // Write the result into the def map.\n-                        debug2!(\"(resolving expr) resolved `{}`\",\n+                        debug!(\"(resolving expr) resolved `{}`\",\n                                self.path_idents_to_str(path));\n \n                         // First-class methods are not supported yet; error\n@@ -5069,7 +5069,7 @@ impl Resolver {\n                         self.record_def(expr.id, definition);\n                     }\n                     result => {\n-                        debug2!(\"(resolving expression) didn't find struct \\\n+                        debug!(\"(resolving expression) didn't find struct \\\n                                 def: {:?}\", result);\n                         let msg = format!(\"`{}` does not name a structure\",\n                                           self.path_idents_to_str(path));\n@@ -5091,7 +5091,7 @@ impl Resolver {\n                 }\n             }\n \n-            ExprForLoop(*) => fail2!(\"non-desugared expr_for_loop\"),\n+            ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n \n             ExprBreak(Some(label)) | ExprAgain(Some(label)) => {\n                 match self.search_ribs(self.label_ribs, label, expr.span,\n@@ -5142,7 +5142,7 @@ impl Resolver {\n                 self.trait_map.insert(expr.id, @mut traits);\n             }\n             ExprMethodCall(_, _, ident, _, _, _) => {\n-                debug2!(\"(recording candidate traits for expr) recording \\\n+                debug!(\"(recording candidate traits for expr) recording \\\n                         traits for {}\",\n                        expr.id);\n                 let traits = self.search_for_traits_containing_method(ident);\n@@ -5217,7 +5217,7 @@ impl Resolver {\n \n     fn search_for_traits_containing_method(&mut self, name: Ident)\n                                                -> ~[DefId] {\n-        debug2!(\"(searching for traits containing method) looking for '{}'\",\n+        debug!(\"(searching for traits containing method) looking for '{}'\",\n                self.session.str_of(name));\n \n         let mut found_traits = ~[];\n@@ -5319,7 +5319,7 @@ impl Resolver {\n                           found_traits: &mut ~[DefId],\n                           trait_def_id: DefId,\n                           name: Ident) {\n-        debug2!(\"(adding trait info) found trait {}:{} for method '{}'\",\n+        debug!(\"(adding trait info) found trait {}:{} for method '{}'\",\n                trait_def_id.crate,\n                trait_def_id.node,\n                self.session.str_of(name));\n@@ -5338,7 +5338,7 @@ impl Resolver {\n     }\n \n     fn record_def(&mut self, node_id: NodeId, (def, lp): (Def, LastPrivate)) {\n-        debug2!(\"(recording def) recording {:?} for {:?}, last private {:?}\",\n+        debug!(\"(recording def) recording {:?} for {:?}, last private {:?}\",\n                 def, node_id, lp);\n         self.last_private.insert(node_id, lp);\n         do self.def_map.insert_or_update_with(node_id, def) |_, old_value| {\n@@ -5449,15 +5449,15 @@ impl Resolver {\n     }\n \n     fn dump_module(&mut self, module_: @mut Module) {\n-        debug2!(\"Dump of module `{}`:\", self.module_to_str(module_));\n+        debug!(\"Dump of module `{}`:\", self.module_to_str(module_));\n \n-        debug2!(\"Children:\");\n+        debug!(\"Children:\");\n         self.populate_module_if_necessary(module_);\n         for (&name, _) in module_.children.iter() {\n-            debug2!(\"* {}\", interner_get(name));\n+            debug!(\"* {}\", interner_get(name));\n         }\n \n-        debug2!(\"Import resolutions:\");\n+        debug!(\"Import resolutions:\");\n         for (name, import_resolution) in module_.import_resolutions.iter() {\n             let value_repr;\n             match import_resolution.target_for_namespace(ValueNS) {\n@@ -5477,7 +5477,7 @@ impl Resolver {\n                 }\n             }\n \n-            debug2!(\"* {}:{}{}\", interner_get(*name),\n+            debug!(\"* {}:{}{}\", interner_get(*name),\n                    value_repr, type_repr);\n         }\n     }"}, {"sha": "fdb7f1508fb47a64d9497fa7a9a7383952f48af1", "filename": "src/librustc/middle/stack_check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fstack_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fstack_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstack_check.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -123,20 +123,20 @@ fn stack_check_fn<'a>(v: &mut StackCheckVisitor,\n         }\n     };\n     let new_cx = Context {safe_stack: safe_stack};\n-    debug2!(\"stack_check_fn(safe_stack={}, id={:?})\", safe_stack, id);\n+    debug!(\"stack_check_fn(safe_stack={}, id={:?})\", safe_stack, id);\n     visit::walk_fn(v, fk, decl, body, sp, id, new_cx);\n }\n \n fn stack_check_expr<'a>(v: &mut StackCheckVisitor,\n                         expr: @ast::Expr,\n                         cx: Context) {\n-    debug2!(\"stack_check_expr(safe_stack={}, expr={})\",\n+    debug!(\"stack_check_expr(safe_stack={}, expr={})\",\n            cx.safe_stack, expr.repr(v.tcx));\n     if !cx.safe_stack {\n         match expr.node {\n             ast::ExprCall(callee, _, _) => {\n                 let callee_ty = ty::expr_ty(v.tcx, callee);\n-                debug2!(\"callee_ty={}\", callee_ty.repr(v.tcx));\n+                debug!(\"callee_ty={}\", callee_ty.repr(v.tcx));\n                 match ty::get(callee_ty).sty {\n                     ty::ty_bare_fn(ref fty) => {\n                         if !fty.abis.is_rust() && !fty.abis.is_intrinsic() {"}, {"sha": "6bb41929db1d1a618451b6280a7a51a9b8b9f2ed", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -264,7 +264,7 @@ fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n                                 a_expr = e.unwrap();\n                             }\n                         UnitLikeStructLit(_) => {\n-                            fail2!(\"UnitLikeStructLit should have been handled \\\n+                            fail!(\"UnitLikeStructLit should have been handled \\\n                                     above\")\n                         }\n                     }\n@@ -277,14 +277,14 @@ fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n                                 b_expr = e.unwrap();\n                             }\n                         UnitLikeStructLit(_) => {\n-                            fail2!(\"UnitLikeStructLit should have been handled \\\n+                            fail!(\"UnitLikeStructLit should have been handled \\\n                                     above\")\n                         }\n                     }\n \n                     match const_eval::compare_lit_exprs(tcx, a_expr, b_expr) {\n                         Some(val1) => val1 == 0,\n-                        None => fail2!(\"compare_list_exprs: type mismatch\"),\n+                        None => fail!(\"compare_list_exprs: type mismatch\"),\n                     }\n                 }\n             }\n@@ -294,7 +294,7 @@ fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n             let m2 = const_eval::compare_lit_exprs(tcx, a2, b2);\n             match (m1, m2) {\n                 (Some(val1), Some(val2)) => (val1 == 0 && val2 == 0),\n-                _ => fail2!(\"compare_list_exprs: type mismatch\"),\n+                _ => fail!(\"compare_list_exprs: type mismatch\"),\n             }\n         }\n         (&var(a, _), &var(b, _)) => a == b,\n@@ -439,7 +439,7 @@ fn expand_nested_bindings<'r>(bcx: @mut Block,\n                                   col: uint,\n                                   val: ValueRef)\n                               -> ~[Match<'r>] {\n-    debug2!(\"expand_nested_bindings(bcx={}, m={}, col={}, val={})\",\n+    debug!(\"expand_nested_bindings(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n@@ -486,7 +486,7 @@ fn enter_match<'r>(bcx: @mut Block,\n                        val: ValueRef,\n                        e: enter_pat)\n                     -> ~[Match<'r>] {\n-    debug2!(\"enter_match(bcx={}, m={}, col={}, val={})\",\n+    debug!(\"enter_match(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n@@ -523,7 +523,7 @@ fn enter_match<'r>(bcx: @mut Block,\n         }\n     }\n \n-    debug2!(\"result={}\", result.repr(bcx.tcx()));\n+    debug!(\"result={}\", result.repr(bcx.tcx()));\n \n     return result;\n }\n@@ -535,7 +535,7 @@ fn enter_default<'r>(bcx: @mut Block,\n                      val: ValueRef,\n                      chk: FailureHandler)\n                       -> ~[Match<'r>] {\n-    debug2!(\"enter_default(bcx={}, m={}, col={}, val={})\",\n+    debug!(\"enter_default(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n@@ -605,7 +605,7 @@ fn enter_opt<'r>(bcx: @mut Block,\n                      variant_size: uint,\n                      val: ValueRef)\n                   -> ~[Match<'r>] {\n-    debug2!(\"enter_opt(bcx={}, m={}, opt={:?}, col={}, val={})\",\n+    debug!(\"enter_opt(bcx={}, m={}, opt={:?}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            *opt,\n@@ -741,7 +741,7 @@ fn enter_rec_or_struct<'r>(bcx: @mut Block,\n                                fields: &[ast::Ident],\n                                val: ValueRef)\n                             -> ~[Match<'r>] {\n-    debug2!(\"enter_rec_or_struct(bcx={}, m={}, col={}, val={})\",\n+    debug!(\"enter_rec_or_struct(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n@@ -776,7 +776,7 @@ fn enter_tup<'r>(bcx: @mut Block,\n                      val: ValueRef,\n                      n_elts: uint)\n                   -> ~[Match<'r>] {\n-    debug2!(\"enter_tup(bcx={}, m={}, col={}, val={})\",\n+    debug!(\"enter_tup(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n@@ -802,7 +802,7 @@ fn enter_tuple_struct<'r>(bcx: @mut Block,\n                               val: ValueRef,\n                               n_elts: uint)\n                           -> ~[Match<'r>] {\n-    debug2!(\"enter_tuple_struct(bcx={}, m={}, col={}, val={})\",\n+    debug!(\"enter_tuple_struct(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n@@ -827,7 +827,7 @@ fn enter_box<'r>(bcx: @mut Block,\n                      col: uint,\n                      val: ValueRef)\n                  -> ~[Match<'r>] {\n-    debug2!(\"enter_box(bcx={}, m={}, col={}, val={})\",\n+    debug!(\"enter_box(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n@@ -854,7 +854,7 @@ fn enter_uniq<'r>(bcx: @mut Block,\n                       col: uint,\n                       val: ValueRef)\n                   -> ~[Match<'r>] {\n-    debug2!(\"enter_uniq(bcx={}, m={}, col={}, val={})\",\n+    debug!(\"enter_uniq(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n@@ -881,7 +881,7 @@ fn enter_region<'r>(bcx: @mut Block,\n                         col: uint,\n                         val: ValueRef)\n                     -> ~[Match<'r>] {\n-    debug2!(\"enter_region(bcx={}, m={}, col={}, val={})\",\n+    debug!(\"enter_region(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n@@ -1225,7 +1225,7 @@ impl FailureHandler {\n     fn handle_fail(&self) -> BasicBlockRef {\n         match *self {\n             Infallible => {\n-                fail2!(\"attempted to fail in infallible failure handler!\")\n+                fail!(\"attempted to fail in infallible failure handler!\")\n             }\n             JumpToBasicBlock(basic_block) => basic_block,\n             CustomFailureHandlerClass(custom_failure_handler) => {\n@@ -1376,7 +1376,7 @@ fn insert_lllocals(bcx: @mut Block,\n             }\n         };\n \n-        debug2!(\"binding {:?} to {}\", binding_info.id, bcx.val_to_str(llval));\n+        debug!(\"binding {:?} to {}\", binding_info.id, bcx.val_to_str(llval));\n         llmap.insert(binding_info.id, llval);\n \n         if bcx.sess().opts.extra_debuginfo {\n@@ -1397,7 +1397,7 @@ fn compile_guard(bcx: @mut Block,\n                      vals: &[ValueRef],\n                      chk: FailureHandler)\n                   -> @mut Block {\n-    debug2!(\"compile_guard(bcx={}, guard_expr={}, m={}, vals={})\",\n+    debug!(\"compile_guard(bcx={}, guard_expr={}, m={}, vals={})\",\n            bcx.to_str(),\n            bcx.expr_to_str(guard_expr),\n            m.repr(bcx.tcx()),\n@@ -1451,7 +1451,7 @@ fn compile_submatch(bcx: @mut Block,\n                     m: &[Match],\n                     vals: &[ValueRef],\n                     chk: FailureHandler) {\n-    debug2!(\"compile_submatch(bcx={}, m={}, vals={})\",\n+    debug!(\"compile_submatch(bcx={}, m={}, vals={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            vec_map_to_str(vals, |v| bcx.val_to_str(*v)));\n@@ -1617,7 +1617,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n \n     // Decide what kind of branch we need\n     let opts = get_options(bcx, m, col);\n-    debug2!(\"options={:?}\", opts);\n+    debug!(\"options={:?}\", opts);\n     let mut kind = no_branch;\n     let mut test_val = val;\n     if opts.len() > 0u {\n@@ -2104,7 +2104,7 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n      * - binding_mode: is this for an argument or a local variable?\n      */\n \n-    debug2!(\"bind_irrefutable_pat(bcx={}, pat={}, binding_mode={:?})\",\n+    debug!(\"bind_irrefutable_pat(bcx={}, pat={}, binding_mode={:?})\",\n            bcx.to_str(),\n            pat.repr(bcx.tcx()),\n            binding_mode);"}, {"sha": "5e64dc5c2e26e4d98f23642a6702c53210db1c60", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -113,13 +113,13 @@ pub fn represent_node(bcx: @mut Block, node: ast::NodeId) -> @Repr {\n \n /// Decides how to represent a given type.\n pub fn represent_type(cx: &mut CrateContext, t: ty::t) -> @Repr {\n-    debug2!(\"Representing: {}\", ty_to_str(cx.tcx, t));\n+    debug!(\"Representing: {}\", ty_to_str(cx.tcx, t));\n     match cx.adt_reprs.find(&t) {\n         Some(repr) => return *repr,\n         None => { }\n     }\n     let repr = @represent_type_uncached(cx, t);\n-    debug2!(\"Represented as: {:?}\", repr)\n+    debug!(\"Represented as: {:?}\", repr)\n     cx.adt_reprs.insert(t, repr);\n     return repr;\n }"}, {"sha": "7f809451b35f2d4be8f59f866e66fafe8db6715e", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -85,7 +85,7 @@ pub fn trans_inline_asm(bcx: @mut Block, ia: &ast::inline_asm) -> @mut Block {\n         constraints.push_str(clobbers);\n     }\n \n-    debug2!(\"Asm Constraints: {:?}\", constraints);\n+    debug!(\"Asm Constraints: {:?}\", constraints);\n \n     let numOutputs = outputs.len();\n "}, {"sha": "df7b09f9db79a991475d0fe15d846ccc0d2232c7", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -122,7 +122,7 @@ impl Drop for _InsnCtxt {\n }\n \n pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n-    debug2!(\"new InsnCtxt: {}\", s);\n+    debug!(\"new InsnCtxt: {}\", s);\n     do local_data::modify(task_local_insn_key) |c| {\n         do c.map |mut ctx| {\n             ctx.push(s);\n@@ -379,7 +379,7 @@ pub fn malloc_raw_dyn(bcx: @mut Block,\n                 (ty::mk_imm_box,\n                  require_alloc_fn(bcx, t, ClosureExchangeMallocFnLangItem))\n             }\n-            _ => fail2!(\"heap_exchange already handled\")\n+            _ => fail!(\"heap_exchange already handled\")\n         };\n \n         // Grab the TypeRef type of box_ptr_ty.\n@@ -911,18 +911,18 @@ pub fn invoke(bcx: @mut Block, llfn: ValueRef, llargs: ~[ValueRef],\n     }\n \n     match bcx.node_info {\n-        None => debug2!(\"invoke at ???\"),\n+        None => debug!(\"invoke at ???\"),\n         Some(node_info) => {\n-            debug2!(\"invoke at {}\",\n+            debug!(\"invoke at {}\",\n                    bcx.sess().codemap.span_to_str(node_info.span));\n         }\n     }\n \n     if need_invoke(bcx) {\n         unsafe {\n-            debug2!(\"invoking {} at {}\", llfn, bcx.llbb);\n+            debug!(\"invoking {} at {}\", llfn, bcx.llbb);\n             for &llarg in llargs.iter() {\n-                debug2!(\"arg: {}\", llarg);\n+                debug!(\"arg: {}\", llarg);\n             }\n         }\n         let normal_bcx = sub_block(bcx, \"normal return\");\n@@ -935,9 +935,9 @@ pub fn invoke(bcx: @mut Block, llfn: ValueRef, llargs: ~[ValueRef],\n         return (llresult, normal_bcx);\n     } else {\n         unsafe {\n-            debug2!(\"calling {} at {}\", llfn, bcx.llbb);\n+            debug!(\"calling {} at {}\", llfn, bcx.llbb);\n             for &llarg in llargs.iter() {\n-                debug2!(\"arg: {}\", llarg);\n+                debug!(\"arg: {}\", llarg);\n             }\n         }\n         let llresult = Call(bcx, llfn, llargs, attributes);\n@@ -1157,7 +1157,7 @@ pub fn ignore_lhs(_bcx: @mut Block, local: &ast::Local) -> bool {\n \n pub fn init_local(bcx: @mut Block, local: &ast::Local) -> @mut Block {\n \n-    debug2!(\"init_local(bcx={}, local.id={:?})\",\n+    debug!(\"init_local(bcx={}, local.id={:?})\",\n            bcx.to_str(), local.id);\n     let _indenter = indenter();\n \n@@ -1178,7 +1178,7 @@ pub fn init_local(bcx: @mut Block, local: &ast::Local) -> @mut Block {\n \n pub fn trans_stmt(cx: @mut Block, s: &ast::Stmt) -> @mut Block {\n     let _icx = push_ctxt(\"trans_stmt\");\n-    debug2!(\"trans_stmt({})\", stmt_to_str(s, cx.tcx().sess.intr()));\n+    debug!(\"trans_stmt({})\", stmt_to_str(s, cx.tcx().sess.intr()));\n \n     if cx.sess().asm_comments() {\n         add_span_comment(cx, s.span, stmt_to_str(s, cx.ccx().sess.intr()));\n@@ -1341,7 +1341,7 @@ pub fn cleanup_and_leave(bcx: @mut Block,\n     let mut bcx = bcx;\n     let is_lpad = leave == None;\n     loop {\n-        debug2!(\"cleanup_and_leave: leaving {}\", cur.to_str());\n+        debug!(\"cleanup_and_leave: leaving {}\", cur.to_str());\n \n         if bcx.sess().trace() {\n             trans_trace(\n@@ -1415,7 +1415,7 @@ pub fn cleanup_block(bcx: @mut Block, upto: Option<BasicBlockRef>) -> @mut Block\n     let mut cur = bcx;\n     let mut bcx = bcx;\n     loop {\n-        debug2!(\"cleanup_block: {}\", cur.to_str());\n+        debug!(\"cleanup_block: {}\", cur.to_str());\n \n         if bcx.sess().trace() {\n             trans_trace(\n@@ -1465,7 +1465,7 @@ pub fn with_scope(bcx: @mut Block,\n                   f: &fn(@mut Block) -> @mut Block) -> @mut Block {\n     let _icx = push_ctxt(\"with_scope\");\n \n-    debug2!(\"with_scope(bcx={}, opt_node_info={:?}, name={})\",\n+    debug!(\"with_scope(bcx={}, opt_node_info={:?}, name={})\",\n            bcx.to_str(), opt_node_info, name);\n     let _indenter = indenter();\n \n@@ -1684,7 +1684,7 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n                      -> @mut FunctionContext {\n     for p in param_substs.iter() { p.validate(); }\n \n-    debug2!(\"new_fn_ctxt_w_id(path={}, id={:?}, \\\n+    debug!(\"new_fn_ctxt_w_id(path={}, id={:?}, \\\n             param_substs={})\",\n            path_str(ccx.sess, path),\n            id,\n@@ -1798,7 +1798,7 @@ pub fn copy_args_to_allocas(fcx: @mut FunctionContext,\n                             args: &[ast::arg],\n                             raw_llargs: &[ValueRef],\n                             arg_tys: &[ty::t]) -> @mut Block {\n-    debug2!(\"copy_args_to_allocas: raw_llargs={} arg_tys={}\",\n+    debug!(\"copy_args_to_allocas: raw_llargs={} arg_tys={}\",\n            raw_llargs.llrepr(fcx.ccx),\n            arg_tys.repr(fcx.ccx.tcx));\n \n@@ -1922,7 +1922,7 @@ pub fn trans_closure(ccx: @mut CrateContext,\n     let _icx = push_ctxt(\"trans_closure\");\n     set_uwtable(llfndecl);\n \n-    debug2!(\"trans_closure(..., param_substs={})\",\n+    debug!(\"trans_closure(..., param_substs={})\",\n            param_substs.repr(ccx.tcx));\n \n     let fcx = new_fn_ctxt_w_id(ccx,\n@@ -2002,7 +2002,7 @@ pub fn trans_fn(ccx: @mut CrateContext,\n \n     let the_path_str = path_str(ccx.sess, path);\n     let _s = StatRecorder::new(ccx, the_path_str);\n-    debug2!(\"trans_fn(self_arg={:?}, param_substs={})\",\n+    debug!(\"trans_fn(self_arg={:?}, param_substs={})\",\n            self_arg,\n            param_substs.repr(ccx.tcx));\n     let _icx = push_ctxt(\"trans_fn\");\n@@ -2038,7 +2038,7 @@ fn insert_synthetic_type_entries(bcx: @mut Block,\n \n     let tcx = bcx.tcx();\n     for i in range(0u, fn_args.len()) {\n-        debug2!(\"setting type of argument {} (pat node {}) to {}\",\n+        debug!(\"setting type of argument {} (pat node {}) to {}\",\n                i, fn_args[i].pat.id, bcx.ty_to_str(arg_tys[i]));\n \n         let pat_id = fn_args[i].pat.id;\n@@ -2214,7 +2214,7 @@ pub fn trans_item(ccx: @mut CrateContext, item: &ast::item) {\n     let path = match ccx.tcx.items.get_copy(&item.id) {\n         ast_map::node_item(_, p) => p,\n         // tjc: ?\n-        _ => fail2!(\"trans_item\"),\n+        _ => fail!(\"trans_item\"),\n     };\n     match item.node {\n       ast::item_fn(ref decl, purity, _abis, ref generics, ref body) => {\n@@ -2357,7 +2357,7 @@ pub fn register_fn(ccx: @mut CrateContext,\n             assert!(f.abis.is_rust() || f.abis.is_intrinsic());\n             f\n         }\n-        _ => fail2!(\"expected bare rust fn or an intrinsic\")\n+        _ => fail!(\"expected bare rust fn or an intrinsic\")\n     };\n \n     let llfn = decl_rust_fn(ccx, f.sig.inputs, f.sig.output, sym);\n@@ -2373,7 +2373,7 @@ pub fn register_fn_llvmty(ccx: @mut CrateContext,\n                           cc: lib::llvm::CallConv,\n                           fn_ty: Type)\n                           -> ValueRef {\n-    debug2!(\"register_fn_fuller creating fn for item {} with path {}\",\n+    debug!(\"register_fn_fuller creating fn for item {} with path {}\",\n            node_id,\n            ast_map::path_to_str(item_path(ccx, &node_id), token::get_ident_interner()));\n \n@@ -2452,7 +2452,7 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n                 };\n                 (start_fn, args)\n             } else {\n-                debug2!(\"using user-defined start fn\");\n+                debug!(\"using user-defined start fn\");\n                 let args = ~[\n                     C_null(Type::opaque_box(ccx).ptr_to()),\n                     llvm::LLVMGetParam(llfn, 0 as c_uint),\n@@ -2500,7 +2500,7 @@ fn exported_name(ccx: &mut CrateContext, path: path, ty: ty::t, attrs: &[ast::At\n }\n \n pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n-    debug2!(\"get_item_val(id=`{:?}`)\", id);\n+    debug!(\"get_item_val(id=`{:?}`)\", id);\n \n     let val = ccx.item_vals.find_copy(&id);\n     match val {\n@@ -2522,10 +2522,10 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                             // we need to get the symbol from csearch instead of\n                             // using the current crate's name/version\n                             // information in the hash of the symbol\n-                            debug2!(\"making {}\", sym);\n+                            debug!(\"making {}\", sym);\n                             let sym = match ccx.external_srcs.find(&i.id) {\n                                 Some(&did) => {\n-                                    debug2!(\"but found in other crate...\");\n+                                    debug!(\"but found in other crate...\");\n                                     csearch::get_symbol(ccx.sess.cstore, did)\n                                 }\n                                 None => sym\n@@ -2575,7 +2575,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                                 }\n \n                                 if !inlineable {\n-                                    debug2!(\"{} not inlined\", sym);\n+                                    debug!(\"{} not inlined\", sym);\n                                     ccx.non_inlineable_statics.insert(id);\n                                 }\n                                 ccx.item_symbols.insert(i.id, sym);\n@@ -2596,7 +2596,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                             llfn\n                         }\n \n-                        _ => fail2!(\"get_item_val: weird result in table\")\n+                        _ => fail!(\"get_item_val: weird result in table\")\n                     };\n \n                     match (attr::first_attr_value_str_by_name(i.attrs, \"link_section\")) {\n@@ -2612,7 +2612,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                 }\n \n                 ast_map::node_trait_method(trait_method, _, pth) => {\n-                    debug2!(\"get_item_val(): processing a node_trait_method\");\n+                    debug!(\"get_item_val(): processing a node_trait_method\");\n                     match *trait_method {\n                         ast::required(_) => {\n                             ccx.sess.bug(\"unexpected variant: required trait method in \\\n@@ -2669,11 +2669,11 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                                 ast::item_enum(_, _) => {\n                                     register_fn(ccx, (*v).span, sym, id, ty)\n                                 }\n-                                _ => fail2!(\"node_variant, shouldn't happen\")\n+                                _ => fail!(\"node_variant, shouldn't happen\")\n                             };\n                         }\n                         ast::struct_variant_kind(_) => {\n-                            fail2!(\"struct variant kind unexpected in get_item_val\")\n+                            fail!(\"struct variant kind unexpected in get_item_val\")\n                         }\n                     }\n                     set_inline_hint(llfn);"}, {"sha": "2042c6ddad1040885bb1e383c032bbf289da864a", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -29,7 +29,7 @@ pub fn terminate(cx: &mut Block, _: &str) {\n \n pub fn check_not_terminated(cx: &Block) {\n     if cx.terminated {\n-        fail2!(\"already terminated!\");\n+        fail!(\"already terminated!\");\n     }\n }\n \n@@ -117,7 +117,7 @@ pub fn Invoke(cx: @mut Block,\n     }\n     check_not_terminated(cx);\n     terminate(cx, \"Invoke\");\n-    debug2!(\"Invoke({} with arguments ({}))\",\n+    debug!(\"Invoke({} with arguments ({}))\",\n            cx.val_to_str(Fn),\n            Args.map(|a| cx.val_to_str(*a)).connect(\", \"));\n     B(cx).invoke(Fn, Args, Then, Catch, attributes)"}, {"sha": "27b1e6b39dc16eaa9a5971abc0140fe6a48f3f60", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -476,7 +476,7 @@ impl Builder {\n     }\n \n     pub fn store(&self, val: ValueRef, ptr: ValueRef) {\n-        debug2!(\"Store {} -> {}\",\n+        debug!(\"Store {} -> {}\",\n                self.ccx.tn.val_to_str(val),\n                self.ccx.tn.val_to_str(ptr));\n         assert!(is_not_null(self.llbuilder));\n@@ -487,7 +487,7 @@ impl Builder {\n     }\n \n     pub fn atomic_store(&self, val: ValueRef, ptr: ValueRef, order: AtomicOrdering) {\n-        debug2!(\"Store {} -> {}\",\n+        debug!(\"Store {} -> {}\",\n                self.ccx.tn.val_to_str(val),\n                self.ccx.tn.val_to_str(ptr));\n         self.count_insn(\"store.atomic\");\n@@ -726,7 +726,7 @@ impl Builder {\n     pub fn add_span_comment(&self, sp: Span, text: &str) {\n         if self.ccx.sess.asm_comments() {\n             let s = format!(\"{} ({})\", text, self.ccx.sess.codemap.span_to_str(sp));\n-            debug2!(\"{}\", s);\n+            debug!(\"{}\", s);\n             self.add_comment(s);\n         }\n     }\n@@ -758,11 +758,11 @@ impl Builder {\n                          else          { lib::llvm::False };\n \n         let argtys = do inputs.map |v| {\n-            debug2!(\"Asm Input Type: {:?}\", self.ccx.tn.val_to_str(*v));\n+            debug!(\"Asm Input Type: {:?}\", self.ccx.tn.val_to_str(*v));\n             val_ty(*v)\n         };\n \n-        debug2!(\"Asm Output Type: {:?}\", self.ccx.tn.type_to_str(output));\n+        debug!(\"Asm Output Type: {:?}\", self.ccx.tn.type_to_str(output));\n         let fty = Type::func(argtys, &output);\n         unsafe {\n             let v = llvm::LLVMInlineAsm("}, {"sha": "736feeb0618a41414428507f6b2ba2fbf72da682", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -51,7 +51,7 @@ fn ty_align(ty: Type) -> uint {\n             let elt = ty.element_type();\n             ty_align(elt)\n         }\n-        _ => fail2!(\"ty_align: unhandled type\")\n+        _ => fail!(\"ty_align: unhandled type\")\n     }\n }\n \n@@ -81,7 +81,7 @@ fn ty_size(ty: Type) -> uint {\n             let eltsz = ty_size(elt);\n             len * eltsz\n         }\n-        _ => fail2!(\"ty_size: unhandled type\")\n+        _ => fail!(\"ty_size: unhandled type\")\n     }\n }\n "}, {"sha": "e98618c4e0108940c204417e1cdb2a0e38488586", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -51,7 +51,7 @@ fn ty_align(ty: Type) -> uint {\n             let elt = ty.element_type();\n             ty_align(elt)\n         }\n-        _ => fail2!(\"ty_size: unhandled type\")\n+        _ => fail!(\"ty_size: unhandled type\")\n     }\n }\n \n@@ -81,7 +81,7 @@ fn ty_size(ty: Type) -> uint {\n             let eltsz = ty_size(elt);\n             len * eltsz\n         }\n-        _ => fail2!(\"ty_size: unhandled type\")\n+        _ => fail!(\"ty_size: unhandled type\")\n     }\n }\n "}, {"sha": "1e22c46dd5db5fab27028998c34b8706a4dccb58", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -112,7 +112,7 @@ fn classify_ty(ty: Type) -> ~[RegClass] {\n                 let elt = ty.element_type();\n                 ty_align(elt)\n             }\n-            _ => fail2!(\"ty_size: unhandled type\")\n+            _ => fail!(\"ty_size: unhandled type\")\n         }\n     }\n \n@@ -141,7 +141,7 @@ fn classify_ty(ty: Type) -> ~[RegClass] {\n                 let eltsz = ty_size(elt);\n                 len * eltsz\n             }\n-            _ => fail2!(\"ty_size: unhandled type\")\n+            _ => fail!(\"ty_size: unhandled type\")\n         }\n     }\n \n@@ -232,7 +232,7 @@ fn classify_ty(ty: Type) -> ~[RegClass] {\n                     i += 1u;\n                 }\n             }\n-            _ => fail2!(\"classify: unhandled type\")\n+            _ => fail!(\"classify: unhandled type\")\n         }\n     }\n \n@@ -325,7 +325,7 @@ fn llreg_ty(cls: &[RegClass]) -> Type {\n             SSEDs => {\n                 tys.push(Type::f64());\n             }\n-            _ => fail2!(\"llregtype: unhandled class\")\n+            _ => fail!(\"llregtype: unhandled class\")\n         }\n         i += 1u;\n     }"}, {"sha": "7a3a67b35ee1ece8563123138f2cd25995e2ffe2", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -79,7 +79,7 @@ pub struct Callee {\n \n pub fn trans(bcx: @mut Block, expr: &ast::Expr) -> Callee {\n     let _icx = push_ctxt(\"trans_callee\");\n-    debug2!(\"callee::trans(expr={})\", expr.repr(bcx.tcx()));\n+    debug!(\"callee::trans(expr={})\", expr.repr(bcx.tcx()));\n \n     // pick out special kinds of expressions that can be called:\n     match expr.node {\n@@ -180,7 +180,7 @@ pub fn trans_fn_ref(bcx: @mut Block,\n \n     let type_params = node_id_type_params(bcx, ref_id);\n     let vtables = node_vtables(bcx, ref_id);\n-    debug2!(\"trans_fn_ref(def_id={}, ref_id={:?}, type_params={}, vtables={})\",\n+    debug!(\"trans_fn_ref(def_id={}, ref_id={:?}, type_params={}, vtables={})\",\n            def_id.repr(bcx.tcx()), ref_id, type_params.repr(bcx.tcx()),\n            vtables.repr(bcx.tcx()));\n     trans_fn_ref_with_vtables(bcx, def_id, ref_id, type_params, vtables)\n@@ -266,7 +266,7 @@ pub fn trans_fn_ref_with_vtables(\n     let ccx = bcx.ccx();\n     let tcx = ccx.tcx;\n \n-    debug2!(\"trans_fn_ref_with_vtables(bcx={}, def_id={}, ref_id={:?}, \\\n+    debug!(\"trans_fn_ref_with_vtables(bcx={}, def_id={}, ref_id={:?}, \\\n             type_params={}, vtables={})\",\n            bcx.to_str(),\n            def_id.repr(bcx.tcx()),\n@@ -329,7 +329,7 @@ pub fn trans_fn_ref_with_vtables(\n                 resolve_default_method_vtables(bcx, impl_id,\n                                                method, &substs, vtables);\n \n-            debug2!(\"trans_fn_with_vtables - default method: \\\n+            debug!(\"trans_fn_with_vtables - default method: \\\n                     substs = {}, trait_subst = {}, \\\n                     first_subst = {}, new_subst = {}, \\\n                     vtables = {}, \\\n@@ -472,7 +472,7 @@ pub fn trans_method_call(in_cx: @mut Block,\n                          dest: expr::Dest)\n                          -> @mut Block {\n     let _icx = push_ctxt(\"trans_method_call\");\n-    debug2!(\"trans_method_call(call_ex={}, rcvr={})\",\n+    debug!(\"trans_method_call(call_ex={}, rcvr={})\",\n            call_ex.repr(in_cx.tcx()),\n            rcvr.repr(in_cx.tcx()));\n     trans_call_inner(\n@@ -483,7 +483,7 @@ pub fn trans_method_call(in_cx: @mut Block,\n         |cx| {\n             match cx.ccx().maps.method_map.find_copy(&call_ex.id) {\n                 Some(origin) => {\n-                    debug2!(\"origin for {}: {}\",\n+                    debug!(\"origin for {}: {}\",\n                            call_ex.repr(in_cx.tcx()),\n                            origin.repr(in_cx.tcx()));\n \n@@ -562,7 +562,7 @@ pub fn trans_lang_call_with_type_params(bcx: @mut Block,\n                                                       substituted);\n                     new_llval = PointerCast(callee.bcx, fn_data.llfn, llfnty);\n                 }\n-                _ => fail2!()\n+                _ => fail!()\n             }\n             Callee { bcx: callee.bcx, data: Fn(FnData { llfn: new_llval }) }\n         },\n@@ -840,7 +840,7 @@ pub fn trans_arg_expr(bcx: @mut Block,\n     let _icx = push_ctxt(\"trans_arg_expr\");\n     let ccx = bcx.ccx();\n \n-    debug2!(\"trans_arg_expr(formal_arg_ty=({}), self_mode={:?}, arg_expr={})\",\n+    debug!(\"trans_arg_expr(formal_arg_ty=({}), self_mode={:?}, arg_expr={})\",\n            formal_arg_ty.repr(bcx.tcx()),\n            self_mode,\n            arg_expr.repr(bcx.tcx()));\n@@ -850,7 +850,7 @@ pub fn trans_arg_expr(bcx: @mut Block,\n     let arg_datum = arg_datumblock.datum;\n     let bcx = arg_datumblock.bcx;\n \n-    debug2!(\"   arg datum: {}\", arg_datum.to_str(bcx.ccx()));\n+    debug!(\"   arg datum: {}\", arg_datum.to_str(bcx.ccx()));\n \n     let mut val;\n     if ty::type_is_bot(arg_datum.ty) {\n@@ -890,11 +890,11 @@ pub fn trans_arg_expr(bcx: @mut Block,\n \n                 val = match self_mode {\n                     ty::ByRef => {\n-                        debug2!(\"by ref arg with type {}\", bcx.ty_to_str(arg_datum.ty));\n+                        debug!(\"by ref arg with type {}\", bcx.ty_to_str(arg_datum.ty));\n                         arg_datum.to_ref_llval(bcx)\n                     }\n                     ty::ByCopy => {\n-                        debug2!(\"by copy arg with type {}\", bcx.ty_to_str(arg_datum.ty));\n+                        debug!(\"by copy arg with type {}\", bcx.ty_to_str(arg_datum.ty));\n                         arg_datum.to_appropriate_llval(bcx)\n                     }\n                 }\n@@ -904,12 +904,12 @@ pub fn trans_arg_expr(bcx: @mut Block,\n         if formal_arg_ty != arg_datum.ty {\n             // this could happen due to e.g. subtyping\n             let llformal_arg_ty = type_of::type_of_explicit_arg(ccx, formal_arg_ty);\n-            debug2!(\"casting actual type ({}) to match formal ({})\",\n+            debug!(\"casting actual type ({}) to match formal ({})\",\n                    bcx.val_to_str(val), bcx.llty_str(llformal_arg_ty));\n             val = PointerCast(bcx, val, llformal_arg_ty);\n         }\n     }\n \n-    debug2!(\"--- trans_arg_expr passing {}\", bcx.val_to_str(val));\n+    debug!(\"--- trans_arg_expr passing {}\", bcx.val_to_str(val));\n     return rslt(bcx, val);\n }"}, {"sha": "f036f922de9ccf57db9c2298ff2e6d8cc43835e9", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -151,7 +151,7 @@ pub fn mk_closure_tys(tcx: ty::ctxt,\n         }\n     });\n     let cdata_ty = ty::mk_tup(tcx, bound_tys);\n-    debug2!(\"cdata_ty={}\", ty_to_str(tcx, cdata_ty));\n+    debug!(\"cdata_ty={}\", ty_to_str(tcx, cdata_ty));\n     return cdata_ty;\n }\n \n@@ -224,12 +224,12 @@ pub fn store_environment(bcx: @mut Block,\n     let Result {bcx: bcx, val: llbox} = allocate_cbox(bcx, sigil, cdata_ty);\n \n     let llbox = PointerCast(bcx, llbox, llboxptr_ty);\n-    debug2!(\"tuplify_box_ty = {}\", ty_to_str(tcx, cbox_ty));\n+    debug!(\"tuplify_box_ty = {}\", ty_to_str(tcx, cbox_ty));\n \n     // Copy expr values into boxed bindings.\n     let mut bcx = bcx;\n     for (i, bv) in bound_values.iter().enumerate() {\n-        debug2!(\"Copy {} into closure\", bv.to_str(ccx));\n+        debug!(\"Copy {} into closure\", bv.to_str(ccx));\n \n         if ccx.sess.asm_comments() {\n             add_comment(bcx, format!(\"Copy {} into closure\",\n@@ -268,7 +268,7 @@ pub fn build_closure(bcx0: @mut Block,\n     // Package up the captured upvars\n     let mut env_vals = ~[];\n     for cap_var in cap_vars.iter() {\n-        debug2!(\"Building closure: captured variable {:?}\", *cap_var);\n+        debug!(\"Building closure: captured variable {:?}\", *cap_var);\n         let datum = expr::trans_local_var(bcx, cap_var.def);\n         match cap_var.mode {\n             moves::CapRef => {\n@@ -384,7 +384,7 @@ pub fn trans_expr_fn(bcx: @mut Block,\n     let fty = node_id_type(bcx, outer_id);\n     let f = match ty::get(fty).sty {\n         ty::ty_closure(ref f) => f,\n-        _ => fail2!(\"expected closure\")\n+        _ => fail!(\"expected closure\")\n     };\n \n     let sub_path = vec::append_one(bcx.fcx.path.clone(),"}, {"sha": "bfea123939a4c4de15fdb0516ad1388a169b8d8d", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -449,7 +449,7 @@ pub fn add_clean(bcx: @mut Block, val: ValueRef, t: ty::t) {\n         return\n     }\n \n-    debug2!(\"add_clean({}, {}, {})\", bcx.to_str(), bcx.val_to_str(val), t.repr(bcx.tcx()));\n+    debug!(\"add_clean({}, {}, {})\", bcx.to_str(), bcx.val_to_str(val), t.repr(bcx.tcx()));\n \n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n     do in_scope_cx(bcx, None) |scope_info| {\n@@ -464,7 +464,7 @@ pub fn add_clean(bcx: @mut Block, val: ValueRef, t: ty::t) {\n \n pub fn add_clean_temp_immediate(cx: @mut Block, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(cx.tcx(), ty) { return; }\n-    debug2!(\"add_clean_temp_immediate({}, {}, {})\",\n+    debug!(\"add_clean_temp_immediate({}, {}, {})\",\n            cx.to_str(), cx.val_to_str(val),\n            ty.repr(cx.tcx()));\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n@@ -493,7 +493,7 @@ pub fn add_clean_temp_mem_in_scope(bcx: @mut Block,\n pub fn add_clean_temp_mem_in_scope_(bcx: @mut Block, scope_id: Option<ast::NodeId>,\n                                     val: ValueRef, t: ty::t) {\n     if !ty::type_needs_drop(bcx.tcx(), t) { return; }\n-    debug2!(\"add_clean_temp_mem({}, {}, {})\",\n+    debug!(\"add_clean_temp_mem({}, {}, {})\",\n            bcx.to_str(), bcx.val_to_str(val),\n            t.repr(bcx.tcx()));\n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n@@ -522,7 +522,7 @@ pub fn add_clean_return_to_mut(bcx: @mut Block,\n     //! box was frozen initially. Here, both `frozen_val_ref` and\n     //! `bits_val_ref` are in fact pointers to stack slots.\n \n-    debug2!(\"add_clean_return_to_mut({}, {}, {})\",\n+    debug!(\"add_clean_return_to_mut({}, {}, {})\",\n            bcx.to_str(),\n            bcx.val_to_str(frozen_val_ref),\n            bcx.val_to_str(bits_val_ref));\n@@ -776,15 +776,15 @@ pub fn in_scope_cx(cx: @mut Block, scope_id: Option<ast::NodeId>, f: &fn(si: &mu\n             Some(inf) => match scope_id {\n                 Some(wanted) => match inf.node_info {\n                     Some(NodeInfo { id: actual, _ }) if wanted == actual => {\n-                        debug2!(\"in_scope_cx: selected cur={} (cx={})\",\n+                        debug!(\"in_scope_cx: selected cur={} (cx={})\",\n                                cur.to_str(), cx.to_str());\n                         f(inf);\n                         return;\n                     },\n                     _ => inf.parent,\n                 },\n                 None => {\n-                    debug2!(\"in_scope_cx: selected cur={} (cx={})\",\n+                    debug!(\"in_scope_cx: selected cur={} (cx={})\",\n                            cur.to_str(), cx.to_str());\n                     f(inf);\n                     return;\n@@ -987,7 +987,7 @@ pub fn const_get_elt(cx: &CrateContext, v: ValueRef, us: &[c_uint])\n             llvm::LLVMConstExtractValue(v, p, len as c_uint)\n         };\n \n-        debug2!(\"const_get_elt(v={}, us={:?}, r={})\",\n+        debug!(\"const_get_elt(v={}, us={:?}, r={})\",\n                cx.tn.val_to_str(v), us, cx.tn.val_to_str(r));\n \n         return r;\n@@ -1230,7 +1230,7 @@ pub fn find_vtable(tcx: ty::ctxt,\n                    n_param: typeck::param_index,\n                    n_bound: uint)\n                    -> typeck::vtable_origin {\n-    debug2!(\"find_vtable(n_param={:?}, n_bound={}, ps={})\",\n+    debug!(\"find_vtable(n_param={:?}, n_bound={}, ps={})\",\n            n_param, n_bound, ps.repr(tcx));\n \n     let param_bounds = match n_param {"}, {"sha": "219307786568d1143865c0aed8a29ac44064dcf5", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -245,7 +245,7 @@ impl CrateContext {\n     pub fn const_inbounds_gepi(&self,\n                                pointer: ValueRef,\n                                indices: &[uint]) -> ValueRef {\n-        debug2!(\"const_inbounds_gepi: pointer={} indices={:?}\",\n+        debug!(\"const_inbounds_gepi: pointer={} indices={:?}\",\n                self.tn.val_to_str(pointer), indices);\n         let v: ~[ValueRef] =\n             indices.iter().map(|i| C_i32(*i as i32)).collect();"}, {"sha": "ec00f144308285d443151e18e6062c2014a1a957", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -50,7 +50,7 @@ pub fn trans_if(bcx: @mut Block,\n             els: Option<@ast::Expr>,\n             dest: expr::Dest)\n          -> @mut Block {\n-    debug2!(\"trans_if(bcx={}, cond={}, thn={:?}, dest={})\",\n+    debug!(\"trans_if(bcx={}, cond={}, thn={:?}, dest={})\",\n            bcx.to_str(), bcx.expr_to_str(cond), thn.id,\n            dest.to_str(bcx.ccx()));\n     let _indenter = indenter();\n@@ -119,7 +119,7 @@ pub fn trans_if(bcx: @mut Block,\n       }\n     };\n \n-    debug2!(\"then_bcx_in={}, else_bcx_in={}\",\n+    debug!(\"then_bcx_in={}, else_bcx_in={}\",\n            then_bcx_in.to_str(), else_bcx_in.to_str());\n \n     CondBr(bcx, cond_val, then_bcx_in.llbb, else_bcx_in.llbb);"}, {"sha": "d57c24e37d57e61f5202dbcfa66a93794aad1247", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -242,7 +242,7 @@ impl Datum {\n                           action: CopyAction,\n                           datum: Datum)\n                           -> @mut Block {\n-        debug2!(\"store_to_datum(self={}, action={:?}, datum={})\",\n+        debug!(\"store_to_datum(self={}, action={:?}, datum={})\",\n                self.to_str(bcx.ccx()), action, datum.to_str(bcx.ccx()));\n         assert!(datum.mode.is_by_ref());\n         self.store_to(bcx, action, datum.val)\n@@ -275,7 +275,7 @@ impl Datum {\n             return bcx;\n         }\n \n-        debug2!(\"copy_to(self={}, action={:?}, dst={})\",\n+        debug!(\"copy_to(self={}, action={:?}, dst={})\",\n                self.to_str(bcx.ccx()), action, bcx.val_to_str(dst));\n \n         // Watch out for the case where we are writing the copying the\n@@ -340,7 +340,7 @@ impl Datum {\n         let _icx = push_ctxt(\"move_to\");\n         let mut bcx = bcx;\n \n-        debug2!(\"move_to(self={}, action={:?}, dst={})\",\n+        debug!(\"move_to(self={}, action={:?}, dst={})\",\n                self.to_str(bcx.ccx()), action, bcx.val_to_str(dst));\n \n         if ty::type_is_voidish(bcx.tcx(), self.ty) {\n@@ -607,7 +607,7 @@ impl Datum {\n                      -> (Option<Datum>, @mut Block) {\n         let ccx = bcx.ccx();\n \n-        debug2!(\"try_deref(expr_id={:?}, derefs={:?}, is_auto={}, self={:?})\",\n+        debug!(\"try_deref(expr_id={:?}, derefs={:?}, is_auto={}, self={:?})\",\n                expr_id, derefs, is_auto, self.to_str(bcx.ccx()));\n \n         let bcx =\n@@ -732,7 +732,7 @@ impl Datum {\n                      -> DatumBlock {\n         let _icx = push_ctxt(\"autoderef\");\n \n-        debug2!(\"autoderef(expr_id={}, max={:?}, self={:?})\",\n+        debug!(\"autoderef(expr_id={}, max={:?}, self={:?})\",\n                expr_id, max, self.to_str(bcx.ccx()));\n         let _indenter = indenter();\n "}, {"sha": "2138afd2e9bb568b700f8672dccf58a9865b7ebe", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -146,7 +146,7 @@ pub struct CrateDebugContext {\n \n impl CrateDebugContext {\n     pub fn new(llmod: ModuleRef, crate: ~str) -> CrateDebugContext {\n-        debug2!(\"CrateDebugContext::new\");\n+        debug!(\"CrateDebugContext::new\");\n         let builder = unsafe { llvm::LLVMDIBuilderCreate(llmod) };\n         // DIBuilder inherits context from the module, so we'd better use the same one\n         let llcontext = unsafe { llvm::LLVMGetModuleContext(llmod) };\n@@ -234,7 +234,7 @@ pub fn finalize(cx: @mut CrateContext) {\n         return;\n     }\n \n-    debug2!(\"finalize\");\n+    debug!(\"finalize\");\n     compile_unit_metadata(cx);\n     unsafe {\n         llvm::LLVMDIBuilderFinalize(DIB(cx));\n@@ -497,7 +497,7 @@ pub fn set_source_location(fcx: &FunctionContext,\n \n     let cx = fcx.ccx;\n \n-    debug2!(\"set_source_location: {}\", cx.sess.codemap.span_to_str(span));\n+    debug!(\"set_source_location: {}\", cx.sess.codemap.span_to_str(span));\n \n     if fcx.debug_context.get_ref(cx, span).source_locations_enabled {\n         let loc = span_start(cx, span);\n@@ -857,7 +857,7 @@ fn compile_unit_metadata(cx: @mut CrateContext) {\n     let dcx = debug_context(cx);\n     let crate_name: &str = dcx.crate_file;\n \n-    debug2!(\"compile_unit_metadata: {:?}\", crate_name);\n+    debug!(\"compile_unit_metadata: {:?}\", crate_name);\n \n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let work_dir = cx.sess.working_dir.as_str().unwrap();\n@@ -968,7 +968,7 @@ fn file_metadata(cx: &mut CrateContext, full_path: &str) -> DIFile {\n         None => ()\n     }\n \n-    debug2!(\"file_metadata: {}\", full_path);\n+    debug!(\"file_metadata: {}\", full_path);\n \n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let work_dir = cx.sess.working_dir.as_str().unwrap();\n@@ -1011,7 +1011,7 @@ fn scope_metadata(fcx: &FunctionContext,\n \n fn basic_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n \n-    debug2!(\"basic_type_metadata: {:?}\", ty::get(t));\n+    debug!(\"basic_type_metadata: {:?}\", ty::get(t));\n \n     let (name, encoding) = match ty::get(t).sty {\n         ty::ty_nil | ty::ty_bot => (~\"uint\", DW_ATE_unsigned),\n@@ -1849,7 +1849,7 @@ fn vec_slice_metadata(cx: &mut CrateContext,\n                       span: Span)\n                    -> DICompositeType {\n \n-    debug2!(\"vec_slice_metadata: {:?}\", ty::get(vec_type));\n+    debug!(\"vec_slice_metadata: {:?}\", ty::get(vec_type));\n \n     let slice_llvm_type = type_of::type_of(cx, vec_type);\n     let slice_type_name = ppaux::ty_to_str(cx.tcx, vec_type);\n@@ -1964,7 +1964,7 @@ fn trait_metadata(cx: &mut CrateContext,\n }\n \n fn unimplemented_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n-    debug2!(\"unimplemented_type_metadata: {:?}\", ty::get(t));\n+    debug!(\"unimplemented_type_metadata: {:?}\", ty::get(t));\n \n     let name = ppaux::ty_to_str(cx.tcx, t);\n     let metadata = do format!(\"NYI<{}>\", name).with_c_str |name| {\n@@ -2016,7 +2016,7 @@ fn type_metadata(cx: &mut CrateContext,\n         pointer_type_metadata(cx, pointer_type, box_metadata)\n     }\n \n-    debug2!(\"type_metadata: {:?}\", ty::get(t));\n+    debug!(\"type_metadata: {:?}\", ty::get(t));\n \n     let sty = &ty::get(t).sty;\n     let type_metadata = match *sty {\n@@ -2135,7 +2135,7 @@ fn set_debug_location(cx: &mut CrateContext, debug_location: DebugLocation) {\n \n     match debug_location {\n         KnownLocation { scope, line, col } => {\n-            debug2!(\"setting debug location to {} {}\", line, col);\n+            debug!(\"setting debug location to {} {}\", line, col);\n             let elements = [C_i32(line as i32), C_i32(col as i32), scope, ptr::null()];\n             unsafe {\n                 metadata_node = llvm::LLVMMDNodeInContext(debug_context(cx).llcontext,\n@@ -2144,7 +2144,7 @@ fn set_debug_location(cx: &mut CrateContext, debug_location: DebugLocation) {\n             }\n         }\n         UnknownLocation => {\n-            debug2!(\"clearing debug location \");\n+            debug!(\"clearing debug location \");\n             metadata_node = ptr::null();\n         }\n     };"}, {"sha": "238b15fe5979fb05308c5fcf3e10e81ac1f0b541", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -183,15 +183,15 @@ fn drop_and_cancel_clean(bcx: @mut Block, dat: Datum) -> @mut Block {\n }\n \n pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n-    debug2!(\"trans_to_datum(expr={})\", bcx.expr_to_str(expr));\n+    debug!(\"trans_to_datum(expr={})\", bcx.expr_to_str(expr));\n \n     let mut bcx = bcx;\n     let mut datum = unpack_datum!(bcx, trans_to_datum_unadjusted(bcx, expr));\n     let adjustment = match bcx.tcx().adjustments.find_copy(&expr.id) {\n         None => { return DatumBlock {bcx: bcx, datum: datum}; }\n         Some(adj) => { adj }\n     };\n-    debug2!(\"unadjusted datum: {}\", datum.to_str(bcx.ccx()));\n+    debug!(\"unadjusted datum: {}\", datum.to_str(bcx.ccx()));\n     match *adjustment {\n         AutoAddEnv(*) => {\n             datum = unpack_datum!(bcx, add_env(bcx, expr, datum));\n@@ -233,7 +233,7 @@ pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n             };\n         }\n     }\n-    debug2!(\"after adjustments, datum={}\", datum.to_str(bcx.ccx()));\n+    debug!(\"after adjustments, datum={}\", datum.to_str(bcx.ccx()));\n     return DatumBlock {bcx: bcx, datum: datum};\n \n     fn auto_ref(bcx: @mut Block, datum: Datum) -> DatumBlock {\n@@ -289,7 +289,7 @@ pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n \n         let tcx = bcx.tcx();\n         let closure_ty = expr_ty_adjusted(bcx, expr);\n-        debug2!(\"add_env(closure_ty={})\", closure_ty.repr(tcx));\n+        debug!(\"add_env(closure_ty={})\", closure_ty.repr(tcx));\n         let scratch = scratch_datum(bcx, closure_ty, \"__adjust\", false);\n         let llfn = GEPi(bcx, scratch.val, [0u, abi::fn_field_code]);\n         assert_eq!(datum.appropriate_mode(bcx.ccx()), ByValue);\n@@ -313,7 +313,7 @@ pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n                        source_datum: Datum) -> DatumBlock {\n         let tcx = bcx.tcx();\n         let target_obj_ty = expr_ty_adjusted(bcx, expr);\n-        debug2!(\"auto_borrow_obj(target={})\",\n+        debug!(\"auto_borrow_obj(target={})\",\n                target_obj_ty.repr(tcx));\n \n         // Extract source store information\n@@ -434,7 +434,7 @@ pub fn trans_into(bcx: @mut Block, expr: &ast::Expr, dest: Dest) -> @mut Block {\n \n     let ty = expr_ty(bcx, expr);\n \n-    debug2!(\"trans_into_unadjusted(expr={}, dest={})\",\n+    debug!(\"trans_into_unadjusted(expr={}, dest={})\",\n            bcx.expr_to_str(expr),\n            dest.to_str(bcx.ccx()));\n     let _indenter = indenter();\n@@ -450,7 +450,7 @@ pub fn trans_into(bcx: @mut Block, expr: &ast::Expr, dest: Dest) -> @mut Block {\n     };\n \n     let kind = bcx.expr_kind(expr);\n-    debug2!(\"expr kind = {:?}\", kind);\n+    debug!(\"expr kind = {:?}\", kind);\n     return match kind {\n         ty::LvalueExpr => {\n             let datumblock = trans_lvalue_unadjusted(bcx, expr);\n@@ -508,7 +508,7 @@ fn trans_to_datum_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n \n     let mut bcx = bcx;\n \n-    debug2!(\"trans_to_datum_unadjusted(expr={})\", bcx.expr_to_str(expr));\n+    debug!(\"trans_to_datum_unadjusted(expr={})\", bcx.expr_to_str(expr));\n     let _indenter = indenter();\n \n     debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n@@ -720,7 +720,7 @@ fn trans_rvalue_dps_unadjusted(bcx: @mut Block, expr: &ast::Expr,\n         ast::ExprFnBlock(ref decl, ref body) => {\n             let expr_ty = expr_ty(bcx, expr);\n             let sigil = ty::ty_closure_sigil(expr_ty);\n-            debug2!(\"translating fn_block {} with type {}\",\n+            debug!(\"translating fn_block {} with type {}\",\n                    expr_to_str(expr, tcx.sess.intr()),\n                    expr_ty.repr(tcx));\n             return closure::trans_expr_fn(bcx, sigil, decl, body,\n@@ -889,7 +889,7 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n     let _icx = push_ctxt(\"trans_lval\");\n     let mut bcx = bcx;\n \n-    debug2!(\"trans_lvalue(expr={})\", bcx.expr_to_str(expr));\n+    debug!(\"trans_lvalue(expr={})\", bcx.expr_to_str(expr));\n     let _indenter = indenter();\n \n     trace_span!(bcx, expr.span, shorten(bcx.expr_to_str(expr)));\n@@ -977,8 +977,8 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n         let (bcx, base, len) =\n             base_datum.get_vec_base_and_len(bcx, index_expr.span, index_expr.id, 0);\n \n-        debug2!(\"trans_index: base {}\", bcx.val_to_str(base));\n-        debug2!(\"trans_index: len {}\", bcx.val_to_str(len));\n+        debug!(\"trans_index: base {}\", bcx.val_to_str(base));\n+        debug!(\"trans_index: len {}\", bcx.val_to_str(len));\n \n         let bounds_check = ICmp(bcx, lib::llvm::IntUGE, ix_val, len);\n         let bcx = do with_cond(bcx, bounds_check) |bcx| {\n@@ -1109,7 +1109,7 @@ pub fn trans_local_var(bcx: @mut Block, def: ast::Def) -> Datum {\n                 }\n             };\n \n-            debug2!(\"def_self() reference, self_info.t={}\",\n+            debug!(\"def_self() reference, self_info.t={}\",\n                    self_info.t.repr(bcx.tcx()));\n \n             Datum {\n@@ -1135,7 +1135,7 @@ pub fn trans_local_var(bcx: @mut Block, def: ast::Def) -> Datum {\n             }\n         };\n         let ty = node_id_type(bcx, nid);\n-        debug2!(\"take_local(nid={:?}, v={}, ty={})\",\n+        debug!(\"take_local(nid={:?}, v={}, ty={})\",\n                nid, bcx.val_to_str(v), bcx.ty_to_str(ty));\n         Datum {\n             val: v,\n@@ -1756,7 +1756,7 @@ fn trans_assign_op(bcx: @mut Block,\n     let _icx = push_ctxt(\"trans_assign_op\");\n     let mut bcx = bcx;\n \n-    debug2!(\"trans_assign_op(expr={})\", bcx.expr_to_str(expr));\n+    debug!(\"trans_assign_op(expr={})\", bcx.expr_to_str(expr));\n \n     // Evaluate LHS (destination), which should be an lvalue\n     let dst_datum = unpack_datum!(bcx, trans_lvalue_unadjusted(bcx, dst));"}, {"sha": "7f8f1daebc48a020fcbcf00bb37e56a9c4d2b851", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -110,7 +110,7 @@ pub fn register_foreign_item_fn(ccx: @mut CrateContext,\n      * Just adds a LLVM global.\n      */\n \n-    debug2!(\"register_foreign_item_fn(abis={}, \\\n+    debug!(\"register_foreign_item_fn(abis={}, \\\n             path={}, \\\n             foreign_item.id={:?})\",\n            abis.repr(ccx.tcx),\n@@ -165,7 +165,7 @@ pub fn trans_native_call(bcx: @mut Block,\n     let ccx = bcx.ccx();\n     let tcx = bcx.tcx();\n \n-    debug2!(\"trans_native_call(callee_ty={}, \\\n+    debug!(\"trans_native_call(callee_ty={}, \\\n             llfn={}, \\\n             llretptr={})\",\n            callee_ty.repr(tcx),\n@@ -210,7 +210,7 @@ pub fn trans_native_call(bcx: @mut Block,\n         // Does Rust pass this argument by pointer?\n         let rust_indirect = type_of::arg_is_indirect(ccx, fn_sig.inputs[i]);\n \n-        debug2!(\"argument {}, llarg_rust={}, rust_indirect={}, arg_ty={}\",\n+        debug!(\"argument {}, llarg_rust={}, rust_indirect={}, arg_ty={}\",\n                i,\n                ccx.tn.val_to_str(llarg_rust),\n                rust_indirect,\n@@ -224,7 +224,7 @@ pub fn trans_native_call(bcx: @mut Block,\n             llarg_rust = scratch;\n         }\n \n-        debug2!(\"llarg_rust={} (after indirection)\",\n+        debug!(\"llarg_rust={} (after indirection)\",\n                ccx.tn.val_to_str(llarg_rust));\n \n         // Check whether we need to do any casting\n@@ -233,7 +233,7 @@ pub fn trans_native_call(bcx: @mut Block,\n             None => ()\n         }\n \n-        debug2!(\"llarg_rust={} (after casting)\",\n+        debug!(\"llarg_rust={} (after casting)\",\n                ccx.tn.val_to_str(llarg_rust));\n \n         // Finally, load the value if needed for the foreign ABI\n@@ -244,7 +244,7 @@ pub fn trans_native_call(bcx: @mut Block,\n             Load(bcx, llarg_rust)\n         };\n \n-        debug2!(\"argument {}, llarg_foreign={}\",\n+        debug!(\"argument {}, llarg_foreign={}\",\n                i, ccx.tn.val_to_str(llarg_foreign));\n \n         // fill padding with undef value\n@@ -289,10 +289,10 @@ pub fn trans_native_call(bcx: @mut Block,\n             None => fn_type.ret_ty.ty\n         };\n \n-        debug2!(\"llretptr={}\", ccx.tn.val_to_str(llretptr));\n-        debug2!(\"llforeign_retval={}\", ccx.tn.val_to_str(llforeign_retval));\n-        debug2!(\"llrust_ret_ty={}\", ccx.tn.type_to_str(llrust_ret_ty));\n-        debug2!(\"llforeign_ret_ty={}\", ccx.tn.type_to_str(llforeign_ret_ty));\n+        debug!(\"llretptr={}\", ccx.tn.val_to_str(llretptr));\n+        debug!(\"llforeign_retval={}\", ccx.tn.val_to_str(llforeign_retval));\n+        debug!(\"llrust_ret_ty={}\", ccx.tn.type_to_str(llrust_ret_ty));\n+        debug!(\"llforeign_ret_ty={}\", ccx.tn.type_to_str(llforeign_ret_ty));\n \n         if llrust_ret_ty == llforeign_ret_ty {\n             Store(bcx, llforeign_retval, llretptr);\n@@ -318,7 +318,7 @@ pub fn trans_native_call(bcx: @mut Block,\n             let llforeign_align = machine::llalign_of_min(ccx, llforeign_ret_ty);\n             let llrust_align = machine::llalign_of_min(ccx, llrust_ret_ty);\n             let llalign = uint::min(llforeign_align, llrust_align);\n-            debug2!(\"llrust_size={:?}\", llrust_size);\n+            debug!(\"llrust_size={:?}\", llrust_size);\n             base::call_memcpy(bcx, llretptr_i8, llscratch_i8,\n                               C_uint(ccx, llrust_size), llalign as u32);\n         }\n@@ -377,7 +377,7 @@ pub fn register_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n                                         lib::llvm::CCallConv,\n                                         llfn_ty);\n     add_argument_attributes(&tys, llfn);\n-    debug2!(\"register_rust_fn_with_foreign_abi(node_id={:?}, llfn_ty={}, llfn={})\",\n+    debug!(\"register_rust_fn_with_foreign_abi(node_id={:?}, llfn_ty={}, llfn={})\",\n            node_id, ccx.tn.type_to_str(llfn_ty), ccx.tn.val_to_str(llfn));\n     llfn\n }\n@@ -430,7 +430,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n             }\n         };\n \n-        debug2!(\"build_rust_fn: path={} id={:?} t={}\",\n+        debug!(\"build_rust_fn: path={} id={:?} t={}\",\n                path.repr(tcx),\n                id,\n                t.repr(tcx));\n@@ -457,7 +457,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n             \"foreign::trans_rust_fn_with_foreign_abi::build_wrap_fn\");\n         let tcx = ccx.tcx;\n \n-        debug2!(\"build_wrap_fn(llrustfn={}, llwrapfn={})\",\n+        debug!(\"build_wrap_fn(llrustfn={}, llwrapfn={})\",\n                ccx.tn.val_to_str(llrustfn),\n                ccx.tn.val_to_str(llwrapfn));\n \n@@ -512,14 +512,14 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n             // alloca some scratch space on the stack.\n             match foreign_outptr {\n                 Some(llforeign_outptr) => {\n-                    debug2!(\"out pointer, foreign={}\",\n+                    debug!(\"out pointer, foreign={}\",\n                            ccx.tn.val_to_str(llforeign_outptr));\n                     let llrust_retptr =\n                         llvm::LLVMBuildBitCast(builder,\n                                                llforeign_outptr,\n                                                llrust_ret_ty.ptr_to().to_ref(),\n                                                noname());\n-                    debug2!(\"out pointer, foreign={} (casted)\",\n+                    debug!(\"out pointer, foreign={} (casted)\",\n                            ccx.tn.val_to_str(llrust_retptr));\n                     llrust_args.push(llrust_retptr);\n                     return_alloca = None;\n@@ -532,7 +532,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n                                                       llrust_ret_ty.to_ref(),\n                                                       s))\n                     };\n-                    debug2!(\"out pointer, \\\n+                    debug!(\"out pointer, \\\n                             allocad={}, \\\n                             llrust_ret_ty={}, \\\n                             return_ty={}\",\n@@ -552,7 +552,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n \n         // Push an (null) env pointer\n         let env_pointer = base::null_env_ptr(ccx);\n-        debug2!(\"env pointer={}\", ccx.tn.val_to_str(env_pointer));\n+        debug!(\"env pointer={}\", ccx.tn.val_to_str(env_pointer));\n         llrust_args.push(env_pointer);\n \n         // Build up the arguments to the call to the rust function.\n@@ -569,9 +569,9 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n             let foreign_index = next_foreign_arg(llforeign_arg_ty.pad.is_some());\n             let mut llforeign_arg = llvm::LLVMGetParam(llwrapfn, foreign_index);\n \n-            debug2!(\"llforeign_arg \\\\#{}: {}\",\n+            debug!(\"llforeign_arg \\\\#{}: {}\",\n                    i, ccx.tn.val_to_str(llforeign_arg));\n-            debug2!(\"rust_indirect = {}, foreign_indirect = {}\",\n+            debug!(\"rust_indirect = {}, foreign_indirect = {}\",\n                    rust_indirect, foreign_indirect);\n \n             // Ensure that the foreign argument is indirect (by\n@@ -602,14 +602,14 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n                 llvm::LLVMBuildLoad(builder, llforeign_arg, noname())\n             };\n \n-            debug2!(\"llrust_arg \\\\#{}: {}\",\n+            debug!(\"llrust_arg \\\\#{}: {}\",\n                    i, ccx.tn.val_to_str(llrust_arg));\n             llrust_args.push(llrust_arg);\n         }\n \n         // Perform the call itself\n         let llrust_ret_val = do llrust_args.as_imm_buf |ptr, len| {\n-            debug2!(\"calling llrustfn = {}\", ccx.tn.val_to_str(llrustfn));\n+            debug!(\"calling llrustfn = {}\", ccx.tn.val_to_str(llrustfn));\n             llvm::LLVMBuildCall(builder, llrustfn, ptr,\n                                 len as c_uint, noname())\n         };\n@@ -737,7 +737,7 @@ fn foreign_types_for_fn_ty(ccx: &mut CrateContext,\n                                        llsig.llarg_tys,\n                                        llsig.llret_ty,\n                                        ret_def);\n-    debug2!(\"foreign_types_for_fn_ty(\\\n+    debug!(\"foreign_types_for_fn_ty(\\\n            ty={}, \\\n            llsig={} -> {}, \\\n            fn_ty={} -> {}, \\"}, {"sha": "aaa187931c967085075ff5bb3a50fb0a645faf03", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -213,51 +213,51 @@ pub fn lazily_emit_tydesc_glue(ccx: @mut CrateContext,\n         match ti.take_glue {\n           Some(_) => (),\n           None => {\n-            debug2!(\"+++ lazily_emit_tydesc_glue TAKE {}\",\n+            debug!(\"+++ lazily_emit_tydesc_glue TAKE {}\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n             let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, \"take\");\n             ti.take_glue = Some(glue_fn);\n             make_generic_glue(ccx, ti.ty, glue_fn, make_take_glue, \"take\");\n-            debug2!(\"--- lazily_emit_tydesc_glue TAKE {}\",\n+            debug!(\"--- lazily_emit_tydesc_glue TAKE {}\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n           }\n         }\n     } else if field == abi::tydesc_field_drop_glue {\n         match ti.drop_glue {\n           Some(_) => (),\n           None => {\n-            debug2!(\"+++ lazily_emit_tydesc_glue DROP {}\",\n+            debug!(\"+++ lazily_emit_tydesc_glue DROP {}\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n             let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, \"drop\");\n             ti.drop_glue = Some(glue_fn);\n             make_generic_glue(ccx, ti.ty, glue_fn, make_drop_glue, \"drop\");\n-            debug2!(\"--- lazily_emit_tydesc_glue DROP {}\",\n+            debug!(\"--- lazily_emit_tydesc_glue DROP {}\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n           }\n         }\n     } else if field == abi::tydesc_field_free_glue {\n         match ti.free_glue {\n           Some(_) => (),\n           None => {\n-            debug2!(\"+++ lazily_emit_tydesc_glue FREE {}\",\n+            debug!(\"+++ lazily_emit_tydesc_glue FREE {}\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n             let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, \"free\");\n             ti.free_glue = Some(glue_fn);\n             make_generic_glue(ccx, ti.ty, glue_fn, make_free_glue, \"free\");\n-            debug2!(\"--- lazily_emit_tydesc_glue FREE {}\",\n+            debug!(\"--- lazily_emit_tydesc_glue FREE {}\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n           }\n         }\n     } else if field == abi::tydesc_field_visit_glue {\n         match ti.visit_glue {\n           Some(_) => (),\n           None => {\n-            debug2!(\"+++ lazily_emit_tydesc_glue VISIT {}\",\n+            debug!(\"+++ lazily_emit_tydesc_glue VISIT {}\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n             let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, \"visit\");\n             ti.visit_glue = Some(glue_fn);\n             make_generic_glue(ccx, ti.ty, glue_fn, make_visit_glue, \"visit\");\n-            debug2!(\"--- lazily_emit_tydesc_glue VISIT {}\",\n+            debug!(\"--- lazily_emit_tydesc_glue VISIT {}\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n           }\n         }\n@@ -640,7 +640,7 @@ pub fn declare_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n     let llalign = llalign_of(ccx, llty);\n     let name = mangle_internal_name_by_type_and_seq(ccx, t, \"tydesc\").to_managed();\n     note_unique_llvm_symbol(ccx, name);\n-    debug2!(\"+++ declare_tydesc {} {}\", ppaux::ty_to_str(ccx.tcx, t), name);\n+    debug!(\"+++ declare_tydesc {} {}\", ppaux::ty_to_str(ccx.tcx, t), name);\n     let gvar = do name.with_c_str |buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type.to_ref(), buf)\n@@ -661,7 +661,7 @@ pub fn declare_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n         free_glue: None,\n         visit_glue: None\n     };\n-    debug2!(\"--- declare_tydesc {}\", ppaux::ty_to_str(ccx.tcx, t));\n+    debug!(\"--- declare_tydesc {}\", ppaux::ty_to_str(ccx.tcx, t));\n     return inf;\n }\n \n@@ -671,7 +671,7 @@ pub fn declare_generic_glue(ccx: &mut CrateContext, t: ty::t, llfnty: Type,\n                             name: &str) -> ValueRef {\n     let _icx = push_ctxt(\"declare_generic_glue\");\n     let fn_nm = mangle_internal_name_by_type_and_seq(ccx, t, (~\"glue_\" + name)).to_managed();\n-    debug2!(\"{} is for type {}\", fn_nm, ppaux::ty_to_str(ccx.tcx, t));\n+    debug!(\"{} is for type {}\", fn_nm, ppaux::ty_to_str(ccx.tcx, t));\n     note_unique_llvm_symbol(ccx, fn_nm);\n     let llfn = decl_cdecl_fn(ccx.llmod, fn_nm, llfnty);\n     set_glue_inlining(llfn, t);\n@@ -771,7 +771,7 @@ pub fn emit_tydescs(ccx: &mut CrateContext) {\n               }\n             };\n \n-        debug2!(\"ti.borrow_offset: {}\", ccx.tn.val_to_str(ti.borrow_offset));\n+        debug!(\"ti.borrow_offset: {}\", ccx.tn.val_to_str(ti.borrow_offset));\n \n         let tydesc = C_named_struct(ccx.tydesc_type,\n                                     [ti.size, // size"}, {"sha": "a5be9a3ca5e141c3b1f2c5c63a52d77f3b948adb", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -29,7 +29,7 @@ pub fn maybe_instantiate_inline(ccx: @mut CrateContext, fn_id: ast::DefId)\n     match ccx.external.find(&fn_id) {\n         Some(&Some(node_id)) => {\n             // Already inline\n-            debug2!(\"maybe_instantiate_inline({}): already inline as node id {}\",\n+            debug!(\"maybe_instantiate_inline({}): already inline as node id {}\",\n                    ty::item_path_str(ccx.tcx, fn_id), node_id);\n             return local_def(node_id);\n         }\n@@ -141,7 +141,7 @@ pub fn maybe_instantiate_inline(ccx: @mut CrateContext, fn_id: ast::DefId)\n                   _ => {\n                       let self_ty = ty::node_id_to_type(ccx.tcx,\n                                                         mth.self_id);\n-                      debug2!(\"calling inline trans_fn with self_ty {}\",\n+                      debug!(\"calling inline trans_fn with self_ty {}\",\n                              ty_to_str(ccx.tcx, self_ty));\n                       match mth.explicit_self.node {\n                           ast::sty_value => impl_self(self_ty, ty::ByRef),"}, {"sha": "e627f39f201711f109fccd7bbe13a483e9f57b1e", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -41,7 +41,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                        substs: @param_substs,\n                        attributes: &[ast::Attribute],\n                        ref_id: Option<ast::NodeId>) {\n-    debug2!(\"trans_intrinsic(item.ident={})\", ccx.sess.str_of(item.ident));\n+    debug!(\"trans_intrinsic(item.ident={})\", ccx.sess.str_of(item.ident));\n \n     fn simple_llvm_intrinsic(bcx: @mut Block, name: &'static str, num_args: uint) {\n         assert!(num_args <= 4);\n@@ -311,7 +311,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             if in_type_size != out_type_size {\n                 let sp = match ccx.tcx.items.get_copy(&ref_id.unwrap()) {\n                     ast_map::node_expr(e) => e.span,\n-                    _ => fail2!(\"transmute has non-expr arg\"),\n+                    _ => fail!(\"transmute has non-expr arg\"),\n                 };\n                 let pluralize = |n| if 1u == n { \"\" } else { \"s\" };\n                 ccx.sess.span_fatal(sp,"}, {"sha": "a8c18c721671d714ad6ed8c56edded363f03379a", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -55,7 +55,7 @@ pub fn trans_impl(ccx: @mut CrateContext,\n     let _icx = push_ctxt(\"impl::trans_impl\");\n     let tcx = ccx.tcx;\n \n-    debug2!(\"trans_impl(path={}, name={}, id={:?})\",\n+    debug!(\"trans_impl(path={}, name={}, id={:?})\",\n            path.repr(tcx), name.repr(tcx), id);\n \n     // Both here and below with generic methods, be sure to recurse and look for\n@@ -117,7 +117,7 @@ pub fn trans_method(ccx: @mut CrateContext,\n                 ty::subst_tps(ccx.tcx, *tys, *self_sub, self_ty)\n             }\n         };\n-        debug2!(\"calling trans_fn with self_ty {}\",\n+        debug!(\"calling trans_fn with self_ty {}\",\n                self_ty.repr(ccx.tcx));\n         match method.explicit_self.node {\n           ast::sty_value => impl_self(self_ty, ty::ByRef),\n@@ -161,7 +161,7 @@ pub fn trans_method_callee(bcx: @mut Block,\n                            -> Callee {\n     let _icx = push_ctxt(\"impl::trans_method_callee\");\n \n-    debug2!(\"trans_method_callee(callee_id={:?}, this={}, mentry={})\",\n+    debug!(\"trans_method_callee(callee_id={:?}, this={}, mentry={})\",\n            callee_id,\n            bcx.expr_to_str(this),\n            mentry.repr(bcx.tcx()));\n@@ -199,7 +199,7 @@ pub fn trans_method_callee(bcx: @mut Block,\n                                                trait_id, off, vtbl)\n                 }\n                 // how to get rid of this?\n-                None => fail2!(\"trans_method_callee: missing param_substs\")\n+                None => fail!(\"trans_method_callee: missing param_substs\")\n             }\n         }\n \n@@ -220,7 +220,7 @@ pub fn trans_static_method_callee(bcx: @mut Block,\n     let _icx = push_ctxt(\"impl::trans_static_method_callee\");\n     let ccx = bcx.ccx();\n \n-    debug2!(\"trans_static_method_callee(method_id={:?}, trait_id={}, \\\n+    debug!(\"trans_static_method_callee(method_id={:?}, trait_id={}, \\\n             callee_id={:?})\",\n            method_id,\n            ty::item_path_str(bcx.tcx(), trait_id),\n@@ -250,16 +250,16 @@ pub fn trans_static_method_callee(bcx: @mut Block,\n             ast_map::node_trait_method(trait_method, _, _) => {\n                 ast_util::trait_method_to_ty_method(trait_method).ident\n             }\n-            _ => fail2!(\"callee is not a trait method\")\n+            _ => fail!(\"callee is not a trait method\")\n         }\n     } else {\n         let path = csearch::get_item_path(bcx.tcx(), method_id);\n         match path[path.len()-1] {\n             path_pretty_name(s, _) | path_name(s) => { s }\n-            path_mod(_) => { fail2!(\"path doesn't have a name?\") }\n+            path_mod(_) => { fail!(\"path doesn't have a name?\") }\n         }\n     };\n-    debug2!(\"trans_static_method_callee: method_id={:?}, callee_id={:?}, \\\n+    debug!(\"trans_static_method_callee: method_id={:?}, callee_id={:?}, \\\n             name={}\", method_id, callee_id, ccx.sess.str_of(mname));\n \n     let vtbls = resolve_vtables_in_fn_ctxt(\n@@ -287,7 +287,7 @@ pub fn trans_static_method_callee(bcx: @mut Block,\n             FnData {llfn: PointerCast(bcx, lval, llty)}\n         }\n         _ => {\n-            fail2!(\"vtable_param left in monomorphized \\\n+            fail!(\"vtable_param left in monomorphized \\\n                    function's vtable substs\");\n         }\n     }\n@@ -362,7 +362,7 @@ pub fn trans_monomorphized_callee(bcx: @mut Block,\n           }\n       }\n       typeck::vtable_param(*) => {\n-          fail2!(\"vtable_param left in monomorphized function's vtable substs\");\n+          fail!(\"vtable_param left in monomorphized function's vtable substs\");\n       }\n     };\n \n@@ -395,13 +395,13 @@ pub fn combine_impl_and_methods_tps(bcx: @mut Block,\n     let method = ty::method(ccx.tcx, mth_did);\n     let n_m_tps = method.generics.type_param_defs.len();\n     let node_substs = node_id_type_params(bcx, callee_id);\n-    debug2!(\"rcvr_substs={:?}\", rcvr_substs.repr(ccx.tcx));\n+    debug!(\"rcvr_substs={:?}\", rcvr_substs.repr(ccx.tcx));\n     let ty_substs\n         = vec::append(rcvr_substs.to_owned(),\n                       node_substs.tailn(node_substs.len() - n_m_tps));\n-    debug2!(\"n_m_tps={:?}\", n_m_tps);\n-    debug2!(\"node_substs={:?}\", node_substs.repr(ccx.tcx));\n-    debug2!(\"ty_substs={:?}\", ty_substs.repr(ccx.tcx));\n+    debug!(\"n_m_tps={:?}\", n_m_tps);\n+    debug!(\"node_substs={:?}\", node_substs.repr(ccx.tcx));\n+    debug!(\"ty_substs={:?}\", ty_substs.repr(ccx.tcx));\n \n \n     // Now, do the same work for the vtables.  The vtables might not\n@@ -474,13 +474,13 @@ pub fn trans_trait_callee_from_llval(bcx: @mut Block,\n     let ccx = bcx.ccx();\n \n     // Load the data pointer from the object.\n-    debug2!(\"(translating trait callee) loading second index from pair\");\n+    debug!(\"(translating trait callee) loading second index from pair\");\n     let llboxptr = GEPi(bcx, llpair, [0u, abi::trt_field_box]);\n     let llbox = Load(bcx, llboxptr);\n     let llself = PointerCast(bcx, llbox, Type::opaque_box(ccx).ptr_to());\n \n     // Load the function from the vtable and cast it to the expected type.\n-    debug2!(\"(translating trait callee) loading method\");\n+    debug!(\"(translating trait callee) loading method\");\n     let llcallee_ty = type_of_fn_from_ty(ccx, callee_ty);\n     let llvtable = Load(bcx,\n                         PointerCast(bcx,\n@@ -524,7 +524,7 @@ pub fn vtable_id(ccx: @mut CrateContext,\n         }\n \n         // can't this be checked at the callee?\n-        _ => fail2!(\"vtable_id\")\n+        _ => fail!(\"vtable_id\")\n     }\n }\n \n@@ -611,15 +611,15 @@ fn emit_vtable_methods(bcx: @mut Block,\n         // the method type from the impl to substitute into.\n         let m_id = method_with_name(ccx, impl_id, ident.name);\n         let m = ty::method(tcx, m_id);\n-        debug2!(\"(making impl vtable) emitting method {} at subst {}\",\n+        debug!(\"(making impl vtable) emitting method {} at subst {}\",\n                m.repr(tcx),\n                substs.repr(tcx));\n         let fty = ty::subst_tps(tcx,\n                                 substs,\n                                 None,\n                                 ty::mk_bare_fn(tcx, m.fty.clone()));\n         if m.generics.has_type_params() || ty::type_has_self(fty) {\n-            debug2!(\"(making impl vtable) method has self or type params: {}\",\n+            debug!(\"(making impl vtable) method has self or type params: {}\",\n                    tcx.sess.str_of(ident));\n             C_null(Type::nil().ptr_to())\n         } else {"}, {"sha": "f625ce4b01c1ac1a2f867a88a4287de15b31c649", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -36,7 +36,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n                       ref_id: Option<ast::NodeId>)\n     -> (ValueRef, bool)\n {\n-    debug2!(\"monomorphic_fn(\\\n+    debug!(\"monomorphic_fn(\\\n             fn_id={}, \\\n             real_substs={}, \\\n             vtables={}, \\\n@@ -68,7 +68,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n         must_cast = true;\n     }\n \n-    debug2!(\"monomorphic_fn(\\\n+    debug!(\"monomorphic_fn(\\\n             fn_id={}, \\\n             psubsts={}, \\\n             hash_id={:?})\",\n@@ -78,7 +78,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n \n     match ccx.monomorphized.find(&hash_id) {\n       Some(&val) => {\n-        debug2!(\"leaving monomorphic fn {}\",\n+        debug!(\"leaving monomorphic fn {}\",\n                ty::item_path_str(ccx.tcx, fn_id));\n         return (val, must_cast);\n       }\n@@ -140,7 +140,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n       ast_map::node_struct_ctor(_, i, pt) => (pt, i.ident, i.span)\n     };\n \n-    debug2!(\"monomorphic_fn about to subst into {}\", llitem_ty.repr(ccx.tcx));\n+    debug!(\"monomorphic_fn about to subst into {}\", llitem_ty.repr(ccx.tcx));\n     let mono_ty = match is_static_provided {\n         None => ty::subst_tps(ccx.tcx, psubsts.tys,\n                               psubsts.self_ty, llitem_ty),\n@@ -164,7 +164,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n                 (psubsts.tys.slice(0, idx) +\n                  &[psubsts.self_ty.unwrap()] +\n                  psubsts.tys.tailn(idx));\n-            debug2!(\"static default: changed substitution to {}\",\n+            debug!(\"static default: changed substitution to {}\",\n                    substs.repr(ccx.tcx));\n \n             ty::subst_tps(ccx.tcx, substs, None, llitem_ty)\n@@ -176,7 +176,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n             assert!(f.abis.is_rust() || f.abis.is_intrinsic());\n             f\n         }\n-        _ => fail2!(\"expected bare rust fn or an intrinsic\")\n+        _ => fail!(\"expected bare rust fn or an intrinsic\")\n     };\n \n     ccx.stats.n_monos += 1;\n@@ -197,7 +197,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n     let mut pt = (*pt).clone();\n     pt.push(elt);\n     let s = mangle_exported_name(ccx, pt.clone(), mono_ty);\n-    debug2!(\"monomorphize_fn mangled to {}\", s);\n+    debug!(\"monomorphize_fn mangled to {}\", s);\n \n     let mk_lldecl = || {\n         let lldecl = decl_internal_rust_fn(ccx, f.sig.inputs, f.sig.output, s);\n@@ -290,7 +290,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n     };\n     ccx.monomorphizing.insert(fn_id, depth);\n \n-    debug2!(\"leaving monomorphic fn {}\", ty::item_path_str(ccx.tcx, fn_id));\n+    debug!(\"leaving monomorphic fn {}\", ty::item_path_str(ccx.tcx, fn_id));\n     (lldecl, must_cast)\n }\n \n@@ -302,7 +302,7 @@ pub fn make_mono_id(ccx: @mut CrateContext,\n     let substs_iter = substs.self_ty.iter().chain(substs.tys.iter());\n     let precise_param_ids: ~[(ty::t, Option<@~[mono_id]>)] = match substs.vtables {\n       Some(vts) => {\n-        debug2!(\"make_mono_id vtables={} substs={}\",\n+        debug!(\"make_mono_id vtables={} substs={}\",\n                vts.repr(ccx.tcx), substs.tys.repr(ccx.tcx));\n         let vts_iter = substs.self_vtables.iter().chain(vts.iter());\n         vts_iter.zip(substs_iter).map(|(vtable, subst)| {"}, {"sha": "54ecc15c44f7072439599b1d12f0cb91f881cd05", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -98,10 +98,10 @@ impl Reflector {\n         let mth_ty =\n             ty::mk_bare_fn(tcx, self.visitor_methods[mth_idx].fty.clone());\n         let v = self.visitor_val;\n-        debug2!(\"passing {} args:\", args.len());\n+        debug!(\"passing {} args:\", args.len());\n         let mut bcx = self.bcx;\n         for (i, a) in args.iter().enumerate() {\n-            debug2!(\"arg {}: {}\", i, bcx.val_to_str(*a));\n+            debug!(\"arg {}: {}\", i, bcx.val_to_str(*a));\n         }\n         let bool_ty = ty::mk_bool();\n         let result = unpack_result!(bcx, callee::trans_call_inner(\n@@ -151,7 +151,7 @@ impl Reflector {\n     pub fn visit_ty(&mut self, t: ty::t) {\n         let bcx = self.bcx;\n         let tcx = bcx.ccx().tcx;\n-        debug2!(\"reflect::visit_ty {}\", ty_to_str(bcx.ccx().tcx, t));\n+        debug!(\"reflect::visit_ty {}\", ty_to_str(bcx.ccx().tcx, t));\n \n         match ty::get(t).sty {\n           ty::ty_bot => self.leaf(\"bot\"),"}, {"sha": "38c5e0b55f741a503fbf983bcb719292c6ae2683", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -169,7 +169,7 @@ pub fn trans_fixed_vstore(bcx: @mut Block,\n     // to store the array of the suitable size, so all we have to do is\n     // generate the content.\n \n-    debug2!(\"trans_fixed_vstore(vstore_expr={}, dest={:?})\",\n+    debug!(\"trans_fixed_vstore(vstore_expr={}, dest={:?})\",\n            bcx.expr_to_str(vstore_expr), dest.to_str(bcx.ccx()));\n     let _indenter = indenter();\n \n@@ -199,7 +199,7 @@ pub fn trans_slice_vstore(bcx: @mut Block,\n \n     let ccx = bcx.ccx();\n \n-    debug2!(\"trans_slice_vstore(vstore_expr={}, dest={})\",\n+    debug!(\"trans_slice_vstore(vstore_expr={}, dest={})\",\n            bcx.expr_to_str(vstore_expr), dest.to_str(ccx));\n     let _indenter = indenter();\n \n@@ -214,7 +214,7 @@ pub fn trans_slice_vstore(bcx: @mut Block,\n     // Handle the &[...] case:\n     let vt = vec_types_from_expr(bcx, vstore_expr);\n     let count = elements_required(bcx, content_expr);\n-    debug2!(\"vt={}, count={:?}\", vt.to_str(ccx), count);\n+    debug!(\"vt={}, count={:?}\", vt.to_str(ccx), count);\n \n     // Make a fixed-length backing array and allocate it on the stack.\n     let llcount = C_uint(ccx, count);\n@@ -255,7 +255,7 @@ pub fn trans_lit_str(bcx: @mut Block,\n     // different from trans_slice_vstore() above because it does need to copy\n     // the content anywhere.\n \n-    debug2!(\"trans_lit_str(lit_expr={}, dest={})\",\n+    debug!(\"trans_lit_str(lit_expr={}, dest={})\",\n            bcx.expr_to_str(lit_expr),\n            dest.to_str(bcx.ccx()));\n     let _indenter = indenter();\n@@ -286,7 +286,7 @@ pub fn trans_uniq_or_managed_vstore(bcx: @mut Block, heap: heap, vstore_expr: &a\n     // @[...] or ~[...] (also @\"...\" or ~\"...\") allocate boxes in the\n     // appropriate heap and write the array elements into them.\n \n-    debug2!(\"trans_uniq_or_managed_vstore(vstore_expr={}, heap={:?})\",\n+    debug!(\"trans_uniq_or_managed_vstore(vstore_expr={}, heap={:?})\",\n            bcx.expr_to_str(vstore_expr), heap);\n     let _indenter = indenter();\n \n@@ -317,7 +317,7 @@ pub fn trans_uniq_or_managed_vstore(bcx: @mut Block, heap: heap, vstore_expr: &a\n                 _ => {}\n             }\n         }\n-        heap_exchange_closure => fail2!(\"vectors use exchange_alloc\"),\n+        heap_exchange_closure => fail!(\"vectors use exchange_alloc\"),\n         heap_managed | heap_managed_unique => {}\n     }\n \n@@ -329,7 +329,7 @@ pub fn trans_uniq_or_managed_vstore(bcx: @mut Block, heap: heap, vstore_expr: &a\n     add_clean_free(bcx, val, heap);\n     let dataptr = get_dataptr(bcx, get_bodyptr(bcx, val, vt.vec_ty));\n \n-    debug2!(\"alloc_vec() returned val={}, dataptr={}\",\n+    debug!(\"alloc_vec() returned val={}, dataptr={}\",\n            bcx.val_to_str(val), bcx.val_to_str(dataptr));\n \n     let bcx = write_content(bcx, &vt, vstore_expr,\n@@ -349,7 +349,7 @@ pub fn write_content(bcx: @mut Block,\n     let _icx = push_ctxt(\"tvec::write_content\");\n     let mut bcx = bcx;\n \n-    debug2!(\"write_content(vt={}, dest={}, vstore_expr={:?})\",\n+    debug!(\"write_content(vt={}, dest={}, vstore_expr={:?})\",\n            vt.to_str(bcx.ccx()),\n            dest.to_str(bcx.ccx()),\n            bcx.expr_to_str(vstore_expr));\n@@ -382,7 +382,7 @@ pub fn write_content(bcx: @mut Block,\n                     let mut temp_cleanups = ~[];\n                     for (i, element) in elements.iter().enumerate() {\n                         let lleltptr = GEPi(bcx, lldest, [i]);\n-                        debug2!(\"writing index {:?} with lleltptr={:?}\",\n+                        debug!(\"writing index {:?} with lleltptr={:?}\",\n                                i, bcx.val_to_str(lleltptr));\n                         bcx = expr::trans_into(bcx, *element,\n                                                SaveIn(lleltptr));"}, {"sha": "de41548895df2eade480ff90cdf1a0685422c028", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -364,7 +364,7 @@ impl Type {\n             Double => 64,\n             X86_FP80 => 80,\n             FP128 | PPC_FP128 => 128,\n-            _ => fail2!(\"llvm_float_width called on a non-float type\")\n+            _ => fail!(\"llvm_float_width called on a non-float type\")\n         }\n     }\n }"}, {"sha": "2a8d16a2ceb83ab784368bf26984c0123a57171b", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -172,7 +172,7 @@ pub fn sizing_type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n \n // NB: If you update this, be sure to update `sizing_type_of()` as well.\n pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n-    debug2!(\"type_of {:?}: {:?}\", t, ty::get(t));\n+    debug!(\"type_of {:?}: {:?}\", t, ty::get(t));\n \n     // Check the cache.\n     match cx.lltypes.find(&t) {"}, {"sha": "577e0a28105f293533fed5322ef27170ef5591ba", "filename": "src/librustc/middle/trans/write_guard.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -39,7 +39,7 @@ pub fn root_and_write_guard(datum: &Datum,\n                             expr_id: ast::NodeId,\n                             derefs: uint) -> @mut Block {\n     let key = root_map_key { id: expr_id, derefs: derefs };\n-    debug2!(\"write_guard::root_and_write_guard(key={:?})\", key);\n+    debug!(\"write_guard::root_and_write_guard(key={:?})\", key);\n \n     // root the autoderef'd value, if necessary:\n     //\n@@ -66,7 +66,7 @@ pub fn return_to_mut(mut bcx: @mut Block,\n                      bits_val_ref: ValueRef,\n                      filename_val: ValueRef,\n                      line_val: ValueRef) -> @mut Block {\n-    debug2!(\"write_guard::return_to_mut(root_key={:?}, {}, {}, {})\",\n+    debug!(\"write_guard::return_to_mut(root_key={:?}, {}, {}, {})\",\n            root_key,\n            bcx.to_str(),\n            bcx.val_to_str(frozen_val_ref),\n@@ -111,7 +111,7 @@ fn root(datum: &Datum,\n     //! case, we will call this function, which will stash a copy\n     //! away until we exit the scope `scope_id`.\n \n-    debug2!(\"write_guard::root(root_key={:?}, root_info={:?}, datum={:?})\",\n+    debug!(\"write_guard::root(root_key={:?}, root_info={:?}, datum={:?})\",\n            root_key, root_info, datum.to_str(bcx.ccx()));\n \n     if bcx.sess().trace() {\n@@ -184,7 +184,7 @@ fn root(datum: &Datum,\n fn perform_write_guard(datum: &Datum,\n                        bcx: @mut Block,\n                        span: Span) -> @mut Block {\n-    debug2!(\"perform_write_guard\");\n+    debug!(\"perform_write_guard\");\n \n     let llval = datum.to_value_llval(bcx);\n     let (filename, line) = filename_and_line_num_from_span(bcx, span);"}, {"sha": "39aa6c5e39637833e2ac5ee6255fd58961dab73f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -1514,7 +1514,7 @@ pub fn fold_regions(\n     fldr: &fn(r: Region, in_fn: bool) -> Region) -> t {\n     fn do_fold(cx: ctxt, ty: t, in_fn: bool,\n                fldr: &fn(Region, bool) -> Region) -> t {\n-        debug2!(\"do_fold(ty={}, in_fn={})\", ty_to_str(cx, ty), in_fn);\n+        debug!(\"do_fold(ty={}, in_fn={})\", ty_to_str(cx, ty), in_fn);\n         if !type_has_regions(ty) { return ty; }\n         fold_regions_and_ty(\n             cx, ty,\n@@ -1655,7 +1655,7 @@ pub fn simd_type(cx: ctxt, ty: t) -> t {\n             let fields = lookup_struct_fields(cx, did);\n             lookup_field_type(cx, did, fields[0].id, substs)\n         }\n-        _ => fail2!(\"simd_type called on invalid type\")\n+        _ => fail!(\"simd_type called on invalid type\")\n     }\n }\n \n@@ -1665,14 +1665,14 @@ pub fn simd_size(cx: ctxt, ty: t) -> uint {\n             let fields = lookup_struct_fields(cx, did);\n             fields.len()\n         }\n-        _ => fail2!(\"simd_size called on invalid type\")\n+        _ => fail!(\"simd_size called on invalid type\")\n     }\n }\n \n pub fn get_element_type(ty: t, i: uint) -> t {\n     match get(ty).sty {\n       ty_tup(ref ts) => return ts[i],\n-      _ => fail2!(\"get_element_type called on invalid type\")\n+      _ => fail!(\"get_element_type called on invalid type\")\n     }\n }\n \n@@ -2323,7 +2323,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n \n         let mut tc = TC_ALL;\n         do each_inherited_builtin_bound(cx, bounds, traits) |bound| {\n-            debug2!(\"tc = {}, bound = {:?}\", tc.to_str(), bound);\n+            debug!(\"tc = {}, bound = {:?}\", tc.to_str(), bound);\n             tc = tc - match bound {\n                 BoundStatic => TypeContents::nonstatic(cx),\n                 BoundSend => TypeContents::nonsendable(cx),\n@@ -2333,7 +2333,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n             };\n         }\n \n-        debug2!(\"result = {}\", tc.to_str());\n+        debug!(\"result = {}\", tc.to_str());\n         return tc;\n \n         // Iterates over all builtin bounds on the type parameter def, including\n@@ -2363,7 +2363,7 @@ pub fn type_moves_by_default(cx: ctxt, ty: t) -> bool {\n pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n     fn type_requires(cx: ctxt, seen: &mut ~[DefId],\n                      r_ty: t, ty: t) -> bool {\n-        debug2!(\"type_requires({}, {})?\",\n+        debug!(\"type_requires({}, {})?\",\n                ::util::ppaux::ty_to_str(cx, r_ty),\n                ::util::ppaux::ty_to_str(cx, ty));\n \n@@ -2372,7 +2372,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n                 subtypes_require(cx, seen, r_ty, ty)\n         };\n \n-        debug2!(\"type_requires({}, {})? {}\",\n+        debug!(\"type_requires({}, {})? {}\",\n                ::util::ppaux::ty_to_str(cx, r_ty),\n                ::util::ppaux::ty_to_str(cx, ty),\n                r);\n@@ -2381,7 +2381,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n \n     fn subtypes_require(cx: ctxt, seen: &mut ~[DefId],\n                         r_ty: t, ty: t) -> bool {\n-        debug2!(\"subtypes_require({}, {})?\",\n+        debug!(\"subtypes_require({}, {})?\",\n                ::util::ppaux::ty_to_str(cx, r_ty),\n                ::util::ppaux::ty_to_str(cx, ty));\n \n@@ -2455,7 +2455,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n             }\n         };\n \n-        debug2!(\"subtypes_require({}, {})? {}\",\n+        debug!(\"subtypes_require({}, {})? {}\",\n                ::util::ppaux::ty_to_str(cx, r_ty),\n                ::util::ppaux::ty_to_str(cx, ty),\n                r);\n@@ -2472,7 +2472,7 @@ pub fn type_structurally_contains(cx: ctxt,\n                                   test: &fn(x: &sty) -> bool)\n                                -> bool {\n     let sty = &get(ty).sty;\n-    debug2!(\"type_structurally_contains: {}\",\n+    debug!(\"type_structurally_contains: {}\",\n            ::util::ppaux::ty_to_str(cx, ty));\n     if test(sty) { return true; }\n     match *sty {\n@@ -2819,7 +2819,7 @@ pub fn ty_fn_sig(fty: t) -> FnSig {\n         ty_bare_fn(ref f) => f.sig.clone(),\n         ty_closure(ref f) => f.sig.clone(),\n         ref s => {\n-            fail2!(\"ty_fn_sig() called on non-fn type: {:?}\", s)\n+            fail!(\"ty_fn_sig() called on non-fn type: {:?}\", s)\n         }\n     }\n }\n@@ -2830,7 +2830,7 @@ pub fn ty_fn_args(fty: t) -> ~[t] {\n         ty_bare_fn(ref f) => f.sig.inputs.clone(),\n         ty_closure(ref f) => f.sig.inputs.clone(),\n         ref s => {\n-            fail2!(\"ty_fn_args() called on non-fn type: {:?}\", s)\n+            fail!(\"ty_fn_args() called on non-fn type: {:?}\", s)\n         }\n     }\n }\n@@ -2839,7 +2839,7 @@ pub fn ty_closure_sigil(fty: t) -> Sigil {\n     match get(fty).sty {\n         ty_closure(ref f) => f.sigil,\n         ref s => {\n-            fail2!(\"ty_closure_sigil() called on non-closure type: {:?}\", s)\n+            fail!(\"ty_closure_sigil() called on non-closure type: {:?}\", s)\n         }\n     }\n }\n@@ -2849,7 +2849,7 @@ pub fn ty_fn_purity(fty: t) -> ast::purity {\n         ty_bare_fn(ref f) => f.purity,\n         ty_closure(ref f) => f.purity,\n         ref s => {\n-            fail2!(\"ty_fn_purity() called on non-fn type: {:?}\", s)\n+            fail!(\"ty_fn_purity() called on non-fn type: {:?}\", s)\n         }\n     }\n }\n@@ -2859,7 +2859,7 @@ pub fn ty_fn_ret(fty: t) -> t {\n         ty_bare_fn(ref f) => f.sig.output,\n         ty_closure(ref f) => f.sig.output,\n         ref s => {\n-            fail2!(\"ty_fn_ret() called on non-fn type: {:?}\", s)\n+            fail!(\"ty_fn_ret() called on non-fn type: {:?}\", s)\n         }\n     }\n }\n@@ -2876,7 +2876,7 @@ pub fn ty_vstore(ty: t) -> vstore {\n     match get(ty).sty {\n         ty_evec(_, vstore) => vstore,\n         ty_estr(vstore) => vstore,\n-        ref s => fail2!(\"ty_vstore() called on invalid sty: {:?}\", s)\n+        ref s => fail!(\"ty_vstore() called on invalid sty: {:?}\", s)\n     }\n }\n \n@@ -3310,7 +3310,7 @@ pub fn expr_kind(tcx: ctxt,\n             RvalueStmtExpr\n         }\n \n-        ast::ExprForLoop(*) => fail2!(\"non-desugared expr_for_loop\"),\n+        ast::ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n \n         ast::ExprLogLevel |\n         ast::ExprLit(_) | // Note: lit_str is carved out above\n@@ -3338,7 +3338,7 @@ pub fn stmt_node_id(s: &ast::Stmt) -> ast::NodeId {\n       ast::StmtDecl(_, id) | StmtExpr(_, id) | StmtSemi(_, id) => {\n         return id;\n       }\n-      ast::StmtMac(*) => fail2!(\"unexpanded macro in trans\")\n+      ast::StmtMac(*) => fail!(\"unexpanded macro in trans\")\n     }\n }\n \n@@ -3689,7 +3689,7 @@ fn lookup_locally_or_in_crate_store<V:Clone>(\n     }\n \n     if def_id.crate == ast::LOCAL_CRATE {\n-        fail2!(\"No def'n found for {:?} in tcx.{}\", def_id, descr);\n+        fail!(\"No def'n found for {:?} in tcx.{}\", def_id, descr);\n     }\n     let v = load_external();\n     map.insert(def_id, v.clone());\n@@ -3732,7 +3732,7 @@ pub fn impl_trait_ref(cx: ctxt, id: ast::DefId) -> Option<@TraitRef> {\n         None => {}\n     }\n     let ret = if id.crate == ast::LOCAL_CRATE {\n-        debug2!(\"(impl_trait_ref) searching for trait impl {:?}\", id);\n+        debug!(\"(impl_trait_ref) searching for trait impl {:?}\", id);\n         match cx.items.find(&id.node) {\n             Some(&ast_map::node_item(@ast::item {\n                                      node: ast::item_impl(_, ref opt_trait, _, _),\n@@ -4491,7 +4491,7 @@ pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n \n         // Add the given trait ty to the hash map\n         while i < trait_refs.len() {\n-            debug2!(\"each_bound_trait_and_supertraits(i={:?}, trait_ref={})\",\n+            debug!(\"each_bound_trait_and_supertraits(i={:?}, trait_ref={})\",\n                    i, trait_refs[i].repr(tcx));\n \n             if !f(trait_refs[i]) {\n@@ -4501,7 +4501,7 @@ pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n             // Add supertraits to supertrait_set\n             let supertrait_refs = trait_ref_supertraits(tcx, trait_refs[i]);\n             for &supertrait_ref in supertrait_refs.iter() {\n-                debug2!(\"each_bound_trait_and_supertraits(supertrait_ref={})\",\n+                debug!(\"each_bound_trait_and_supertraits(supertrait_ref={})\",\n                        supertrait_ref.repr(tcx));\n \n                 let d_id = supertrait_ref.def_id;"}, {"sha": "ccda6bbaf9d11495058de1eebbee3e7b023339ee", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -636,7 +636,7 @@ fn ty_of_method_or_bare_fn<AC:AstConv,RS:RegionScope + Clone + 'static>(\n     opt_self_info: Option<&SelfInfo>,\n     decl: &ast::fn_decl) -> (Option<Option<ty::t>>, ty::BareFnTy)\n {\n-    debug2!(\"ty_of_bare_fn\");\n+    debug!(\"ty_of_bare_fn\");\n \n     // new region names that appear inside of the fn decl are bound to\n     // that function type\n@@ -717,7 +717,7 @@ pub fn ty_of_closure<AC:AstConv,RS:RegionScope + Clone + 'static>(\n     // names or they are provided, but not both.\n     assert!(lifetimes.is_empty() || expected_sig.is_none());\n \n-    debug2!(\"ty_of_fn_decl\");\n+    debug!(\"ty_of_fn_decl\");\n     let _i = indenter();\n \n     // resolve the function bound region in the original region"}, {"sha": "25048d888fa8c27da49de652d99e9edbd7b0e9c2", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -428,8 +428,8 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::Pat, expected: ty::t) {\n             fcx.infcx().resolve_type_vars_if_possible(fcx.expr_ty(begin));\n         let e_ty =\n             fcx.infcx().resolve_type_vars_if_possible(fcx.expr_ty(end));\n-        debug2!(\"pat_range beginning type: {:?}\", b_ty);\n-        debug2!(\"pat_range ending type: {:?}\", e_ty);\n+        debug!(\"pat_range beginning type: {:?}\", b_ty);\n+        debug!(\"pat_range ending type: {:?}\", e_ty);\n         if !require_same_types(\n             tcx, Some(fcx.infcx()), false, pat.span, b_ty, e_ty,\n             || ~\"mismatched types in range\")\n@@ -488,7 +488,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::Pat, expected: ty::t) {\n         }\n         fcx.write_ty(pat.id, typ);\n \n-        debug2!(\"(checking match) writing type for pat id {}\", pat.id);\n+        debug!(\"(checking match) writing type for pat id {}\", pat.id);\n \n         match sub {\n           Some(p) => check_pat(pcx, p, expected),"}, {"sha": "f6efd3aa5ad1f573a81d1fa5382d152bfef840e1", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -151,18 +151,18 @@ pub fn lookup(\n     };\n \n     let self_ty = structurally_resolved_type(fcx, self_expr.span, self_ty);\n-    debug2!(\"method lookup(self_ty={}, expr={}, self_expr={})\",\n+    debug!(\"method lookup(self_ty={}, expr={}, self_expr={})\",\n            self_ty.repr(fcx.tcx()), expr.repr(fcx.tcx()),\n            self_expr.repr(fcx.tcx()));\n \n-    debug2!(\"searching inherent candidates\");\n+    debug!(\"searching inherent candidates\");\n     lcx.push_inherent_candidates(self_ty);\n     let mme = lcx.search(self_ty);\n     if mme.is_some() {\n         return mme;\n     }\n \n-    debug2!(\"searching extension candidates\");\n+    debug!(\"searching extension candidates\");\n     lcx.reset_candidates();\n     lcx.push_bound_candidates(self_ty);\n     lcx.push_extension_candidates();\n@@ -215,7 +215,7 @@ impl<'self> LookupContext<'self> {\n         let mut self_ty = self_ty;\n         let mut autoderefs = 0;\n         loop {\n-            debug2!(\"loop: self_ty={} autoderefs={}\",\n+            debug!(\"loop: self_ty={} autoderefs={}\",\n                    self.ty_to_str(self_ty), autoderefs);\n \n             match self.deref_args {\n@@ -397,7 +397,7 @@ impl<'self> LookupContext<'self> {\n     fn push_inherent_candidates_from_object(&self,\n                                             did: DefId,\n                                             substs: &ty::substs) {\n-        debug2!(\"push_inherent_candidates_from_object(did={}, substs={})\",\n+        debug!(\"push_inherent_candidates_from_object(did={}, substs={})\",\n                self.did_to_str(did),\n                substs_to_str(self.tcx(), substs));\n         let _indenter = indenter();\n@@ -446,7 +446,7 @@ impl<'self> LookupContext<'self> {\n     fn push_inherent_candidates_from_param(&self,\n                                            rcvr_ty: ty::t,\n                                            param_ty: param_ty) {\n-        debug2!(\"push_inherent_candidates_from_param(param_ty={:?})\",\n+        debug!(\"push_inherent_candidates_from_param(param_ty={:?})\",\n                param_ty);\n         let _indenter = indenter();\n \n@@ -523,11 +523,11 @@ impl<'self> LookupContext<'self> {\n                     let cand = mk_cand(bound_trait_ref, method,\n                                        pos, this_bound_idx);\n \n-                    debug2!(\"pushing inherent candidate for param: {:?}\", cand);\n+                    debug!(\"pushing inherent candidate for param: {:?}\", cand);\n                     self.inherent_candidates.push(cand);\n                 }\n                 None => {\n-                    debug2!(\"trait doesn't contain method: {:?}\",\n+                    debug!(\"trait doesn't contain method: {:?}\",\n                     bound_trait_ref.def_id);\n                     // check next trait or bound\n                 }\n@@ -557,7 +557,7 @@ impl<'self> LookupContext<'self> {\n         if !self.impl_dups.insert(impl_info.did) {\n             return; // already visited\n         }\n-        debug2!(\"push_candidates_from_impl: {} {} {}\",\n+        debug!(\"push_candidates_from_impl: {} {} {}\",\n                token::interner_get(self.m_name),\n                impl_info.ident.repr(self.tcx()),\n                impl_info.methods.map(|m| m.ident).repr(self.tcx()));\n@@ -603,7 +603,7 @@ impl<'self> LookupContext<'self> {\n         match self.search_for_method(self_ty) {\n             None => None,\n             Some(mme) => {\n-                debug2!(\"(searching for autoderef'd method) writing \\\n+                debug!(\"(searching for autoderef'd method) writing \\\n                        adjustment ({}) to {}\",\n                        autoderefs,\n                        self.self_expr.id);\n@@ -832,22 +832,22 @@ impl<'self> LookupContext<'self> {\n \n     fn search_for_method(&self, rcvr_ty: ty::t)\n                              -> Option<method_map_entry> {\n-        debug2!(\"search_for_method(rcvr_ty={})\", self.ty_to_str(rcvr_ty));\n+        debug!(\"search_for_method(rcvr_ty={})\", self.ty_to_str(rcvr_ty));\n         let _indenter = indenter();\n \n         // I am not sure that inherent methods should have higher\n         // priority, but it is necessary ATM to handle some of the\n         // existing code.\n \n-        debug2!(\"searching inherent candidates\");\n+        debug!(\"searching inherent candidates\");\n         match self.consider_candidates(rcvr_ty, self.inherent_candidates) {\n             None => {}\n             Some(mme) => {\n                 return Some(mme);\n             }\n         }\n \n-        debug2!(\"searching extension candidates\");\n+        debug!(\"searching extension candidates\");\n         match self.consider_candidates(rcvr_ty, self.extension_candidates) {\n             None => {\n                 return None;\n@@ -896,7 +896,7 @@ impl<'self> LookupContext<'self> {\n             let mut j = i + 1;\n             while j < candidates.len() {\n                 let candidate_b = &candidates[j];\n-                debug2!(\"attempting to merge {:?} and {:?}\",\n+                debug!(\"attempting to merge {:?} and {:?}\",\n                        candidate_a, candidate_b);\n                 let candidates_same = match (&candidate_a.origin,\n                                              &candidate_b.origin) {\n@@ -936,7 +936,7 @@ impl<'self> LookupContext<'self> {\n         let tcx = self.tcx();\n         let fty = ty::mk_bare_fn(tcx, candidate.method_ty.fty.clone());\n \n-        debug2!(\"confirm_candidate(expr={}, candidate={}, fty={})\",\n+        debug!(\"confirm_candidate(expr={}, candidate={}, fty={})\",\n                self.expr.repr(tcx),\n                self.cand_to_str(candidate),\n                self.ty_to_str(fty));\n@@ -992,11 +992,11 @@ impl<'self> LookupContext<'self> {\n         };\n \n         // Compute the method type with type parameters substituted\n-        debug2!(\"fty={} all_substs={}\",\n+        debug!(\"fty={} all_substs={}\",\n                self.ty_to_str(fty),\n                ty::substs_to_str(tcx, &all_substs));\n         let fty = ty::subst(tcx, &all_substs, fty);\n-        debug2!(\"after subst, fty={}\", self.ty_to_str(fty));\n+        debug!(\"after subst, fty={}\", self.ty_to_str(fty));\n \n         // Replace any bound regions that appear in the function\n         // signature with region variables\n@@ -1019,7 +1019,7 @@ impl<'self> LookupContext<'self> {\n             purity: bare_fn_ty.purity,\n             abis: bare_fn_ty.abis.clone(),\n         });\n-        debug2!(\"after replacing bound regions, fty={}\", self.ty_to_str(fty));\n+        debug!(\"after replacing bound regions, fty={}\", self.ty_to_str(fty));\n \n         let self_mode = get_mode_from_explicit_self(candidate.method_ty.explicit_self);\n \n@@ -1189,12 +1189,12 @@ impl<'self> LookupContext<'self> {\n     // `rcvr_ty` is the type of the expression. It may be a subtype of a\n     // candidate method's `self_ty`.\n     fn is_relevant(&self, rcvr_ty: ty::t, candidate: &Candidate) -> bool {\n-        debug2!(\"is_relevant(rcvr_ty={}, candidate={})\",\n+        debug!(\"is_relevant(rcvr_ty={}, candidate={})\",\n                self.ty_to_str(rcvr_ty), self.cand_to_str(candidate));\n \n         return match candidate.method_ty.explicit_self {\n             sty_static => {\n-                debug2!(\"(is relevant?) explicit self is static\");\n+                debug!(\"(is relevant?) explicit self is static\");\n                 false\n             }\n \n@@ -1203,7 +1203,7 @@ impl<'self> LookupContext<'self> {\n             }\n \n             sty_region(_, m) => {\n-                debug2!(\"(is relevant?) explicit self is a region\");\n+                debug!(\"(is relevant?) explicit self is a region\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_rptr(_, mt) => {\n                         mutability_matches(mt.mutbl, m) &&\n@@ -1220,7 +1220,7 @@ impl<'self> LookupContext<'self> {\n             }\n \n             sty_box(m) => {\n-                debug2!(\"(is relevant?) explicit self is a box\");\n+                debug!(\"(is relevant?) explicit self is a box\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_box(mt) => {\n                         mutability_matches(mt.mutbl, m) &&\n@@ -1237,7 +1237,7 @@ impl<'self> LookupContext<'self> {\n             }\n \n             sty_uniq => {\n-                debug2!(\"(is relevant?) explicit self is a unique pointer\");\n+                debug!(\"(is relevant?) explicit self is a unique pointer\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_uniq(mt) => {\n                         rcvr_matches_ty(self.fcx, mt.ty, candidate)\n@@ -1310,7 +1310,7 @@ impl<'self> LookupContext<'self> {\n             match self.tcx().items.find(&did.node) {\n               Some(&ast_map::node_method(m, _, _))\n               | Some(&ast_map::node_trait_method(@ast::provided(m), _, _)) => m.span,\n-              _ => fail2!(\"report_static_candidate: bad item {:?}\", did)\n+              _ => fail!(\"report_static_candidate: bad item {:?}\", did)\n             }\n         } else {\n             self.expr.span"}, {"sha": "eddf8aa518508fc35d3dd592c61264c4d138b6d4", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -362,7 +362,7 @@ impl Visitor<()> for GatherLocalsVisitor {\n               _ => Some(self.fcx.to_ty(&local.ty))\n             };\n             self.assign(local.id, o_ty);\n-            debug2!(\"Local variable {} is assigned type {}\",\n+            debug!(\"Local variable {} is assigned type {}\",\n                    self.fcx.pat_to_str(local.pat),\n                    self.fcx.infcx().ty_to_str(\n                        self.fcx.inh.locals.get_copy(&local.id)));\n@@ -375,7 +375,7 @@ impl Visitor<()> for GatherLocalsVisitor {\n               ast::PatIdent(_, ref path, _)\n                   if pat_util::pat_is_binding(self.fcx.ccx.tcx.def_map, p) => {\n                 self.assign(p.id, None);\n-                debug2!(\"Pattern binding {} is assigned to {}\",\n+                debug!(\"Pattern binding {} is assigned to {}\",\n                        self.tcx.sess.str_of(path.segments[0].identifier),\n                        self.fcx.infcx().ty_to_str(\n                            self.fcx.inh.locals.get_copy(&p.id)));\n@@ -450,7 +450,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n     let arg_tys = fn_sig.inputs.map(|a| *a);\n     let ret_ty = fn_sig.output;\n \n-    debug2!(\"check_fn(arg_tys={:?}, ret_ty={:?}, opt_self_ty={:?})\",\n+    debug!(\"check_fn(arg_tys={:?}, ret_ty={:?}, opt_self_ty={:?})\",\n            arg_tys.map(|&a| ppaux::ty_to_str(tcx, a)),\n            ppaux::ty_to_str(tcx, ret_ty),\n            opt_self_info.map(|si| ppaux::ty_to_str(tcx, si.self_ty)));\n@@ -510,7 +510,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n         // Add the self parameter\n         for self_info in opt_self_info.iter() {\n             visit.assign(self_info.self_id, Some(self_info.self_ty));\n-            debug2!(\"self is assigned to {}\",\n+            debug!(\"self is assigned to {}\",\n                    fcx.infcx().ty_to_str(\n                        fcx.inh.locals.get_copy(&self_info.self_id)));\n         }\n@@ -588,7 +588,7 @@ pub fn check_struct(ccx: @mut CrateCtxt, id: ast::NodeId, span: Span) {\n }\n \n pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n-    debug2!(\"check_item(it.id={}, it.ident={})\",\n+    debug!(\"check_item(it.id={}, it.ident={})\",\n            it.id,\n            ty::item_path_str(ccx.tcx, local_def(it.id)));\n     let _indenter = indenter();\n@@ -606,7 +606,7 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n       }\n       ast::item_impl(_, _, _, ref ms) => {\n         let rp = ccx.tcx.region_paramd_items.find(&it.id).map(|x| *x);\n-        debug2!(\"item_impl {} with id {} rp {:?}\",\n+        debug!(\"item_impl {} with id {} rp {:?}\",\n                ccx.tcx.sess.str_of(it.ident), it.id, rp);\n         for m in ms.iter() {\n             check_method(ccx, *m);\n@@ -742,14 +742,14 @@ impl FnCtxt {\n \n     #[inline]\n     pub fn write_ty(&self, node_id: ast::NodeId, ty: ty::t) {\n-        debug2!(\"write_ty({}, {}) in fcx {}\",\n+        debug!(\"write_ty({}, {}) in fcx {}\",\n                node_id, ppaux::ty_to_str(self.tcx(), ty), self.tag());\n         self.inh.node_types.insert(node_id, ty);\n     }\n \n     pub fn write_substs(&self, node_id: ast::NodeId, substs: ty::substs) {\n         if !ty::substs_is_noop(&substs) {\n-            debug2!(\"write_substs({}, {}) in fcx {}\",\n+            debug!(\"write_substs({}, {}) in fcx {}\",\n                    node_id,\n                    ty::substs_to_str(self.tcx(), &substs),\n                    self.tag());\n@@ -781,7 +781,7 @@ impl FnCtxt {\n     pub fn write_adjustment(&self,\n                             node_id: ast::NodeId,\n                             adj: @ty::AutoAdjustment) {\n-        debug2!(\"write_adjustment(node_id={:?}, adj={:?})\", node_id, adj);\n+        debug!(\"write_adjustment(node_id={:?}, adj={:?})\", node_id, adj);\n         self.inh.adjustments.insert(node_id, adj);\n     }\n \n@@ -1306,7 +1306,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                expr: @ast::Expr,\n                                expected: Option<ty::t>,\n                                unifier: &fn()) {\n-    debug2!(\">> typechecking\");\n+    debug!(\">> typechecking\");\n \n     fn check_method_argument_types(\n         fcx: @mut FnCtxt,\n@@ -1384,7 +1384,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             vec::from_elem(supplied_arg_count, ty::mk_err())\n         };\n \n-        debug2!(\"check_argument_types: formal_tys={:?}\",\n+        debug!(\"check_argument_types: formal_tys={:?}\",\n                formal_tys.map(|t| fcx.infcx().ty_to_str(*t)));\n \n         // Check the arguments.\n@@ -1396,7 +1396,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let xs = [false, true];\n         for check_blocks in xs.iter() {\n             let check_blocks = *check_blocks;\n-            debug2!(\"check_blocks={}\", check_blocks);\n+            debug!(\"check_blocks={}\", check_blocks);\n \n             // More awful hacks: before we check the blocks, try to do\n             // an \"opportunistic\" vtable resolution of any trait\n@@ -1413,7 +1413,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 };\n \n                 if is_block == check_blocks {\n-                    debug2!(\"checking the argument\");\n+                    debug!(\"checking the argument\");\n                     let mut formal_ty = formal_tys[i];\n \n                     match deref_args {\n@@ -1567,7 +1567,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 method_map.insert(expr.id, (*entry));\n             }\n             None => {\n-                debug2!(\"(checking method call) failing expr is {}\", expr.id);\n+                debug!(\"(checking method call) failing expr is {}\", expr.id);\n \n                 fcx.type_error_message(expr.span,\n                   |actual| {\n@@ -1921,7 +1921,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             ty::mk_closure(tcx, fn_ty_copy)\n         };\n \n-        debug2!(\"check_expr_fn_with_unifier fty={}\",\n+        debug!(\"check_expr_fn_with_unifier fty={}\",\n                fcx.infcx().ty_to_str(fty));\n \n         fcx.write_ty(expr.id, fty);\n@@ -1955,7 +1955,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n                 // (1) verify that the class id actually has a field called\n                 // field\n-                debug2!(\"class named {}\", ppaux::ty_to_str(tcx, base_t));\n+                debug!(\"class named {}\", ppaux::ty_to_str(tcx, base_t));\n                 let cls_items = ty::lookup_struct_fields(tcx, base_id);\n                 match lookup_field_ty(tcx, base_id, cls_items,\n                                       field, &(*substs)) {\n@@ -2570,7 +2570,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         }\n       }\n       ast::ExprForLoop(*) =>\n-          fail2!(\"non-desugared expr_for_loop\"),\n+          fail!(\"non-desugared expr_for_loop\"),\n       ast::ExprLoop(ref body, _) => {\n         check_block_no_value(fcx, (body));\n         if !may_break(tcx, expr.id, body) {\n@@ -2618,7 +2618,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n           }\n           // argh\n-          _ => fail2!(\"expected fn ty\")\n+          _ => fail!(\"expected fn ty\")\n         }\n         fcx.write_ty(expr.id, fcx.node_ty(b.id));\n       }\n@@ -2662,8 +2662,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let t_1 = fcx.to_ty(t);\n         let t_e = fcx.expr_ty(e);\n \n-        debug2!(\"t_1={}\", fcx.infcx().ty_to_str(t_1));\n-        debug2!(\"t_e={}\", fcx.infcx().ty_to_str(t_e));\n+        debug!(\"t_1={}\", fcx.infcx().ty_to_str(t_1));\n+        debug!(\"t_e={}\", fcx.infcx().ty_to_str(t_e));\n \n         if ty::type_is_error(t_e) {\n             fcx.write_error(id);\n@@ -2892,9 +2892,9 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n        }\n     }\n \n-    debug2!(\"type of expr({}) {} is...\", expr.id,\n+    debug!(\"type of expr({}) {} is...\", expr.id,\n            syntax::print::pprust::expr_to_str(expr, tcx.sess.intr()));\n-    debug2!(\"... {}, expected is {}\",\n+    debug!(\"... {}, expected is {}\",\n            ppaux::ty_to_str(tcx, fcx.expr_ty(expr)),\n            match expected {\n                Some(t) => ppaux::ty_to_str(tcx, t),\n@@ -3175,7 +3175,7 @@ pub fn check_enum_variants(ccx: @mut CrateCtxt,\n \n             match v.node.disr_expr {\n                 Some(e) => {\n-                    debug2!(\"disr expr, checking {}\", pprust::expr_to_str(e, ccx.tcx.sess.intr()));\n+                    debug!(\"disr expr, checking {}\", pprust::expr_to_str(e, ccx.tcx.sess.intr()));\n \n                     let fcx = blank_fn_ctxt(ccx, rty, e.id);\n                     let declty = ty::mk_int_var(ccx.tcx, fcx.infcx().next_int_var_id());\n@@ -3305,15 +3305,15 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n                         def: ast::Def,\n                         span: Span,\n                         node_id: ast::NodeId) {\n-    debug2!(\">>> instantiate_path\");\n+    debug!(\">>> instantiate_path\");\n \n     let ty_param_count = tpt.generics.type_param_defs.len();\n     let mut ty_substs_len = 0;\n     for segment in pth.segments.iter() {\n         ty_substs_len += segment.types.len()\n     }\n \n-    debug2!(\"tpt={} ty_param_count={:?} ty_substs_len={:?}\",\n+    debug!(\"tpt={} ty_param_count={:?} ty_substs_len={:?}\",\n            tpt.repr(fcx.tcx()),\n            ty_param_count,\n            ty_substs_len);\n@@ -3412,7 +3412,7 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n     };\n     fcx.write_ty_substs(node_id, tpt.ty, substs);\n \n-    debug2!(\"<<<\");\n+    debug!(\"<<<\");\n }\n \n // Resolves `typ` by a single level if `typ` is a type variable.  If no\n@@ -3508,7 +3508,7 @@ pub fn check_bounds_are_used(ccx: @mut CrateCtxt,\n                              span: Span,\n                              tps: &OptVec<ast::TyParam>,\n                              ty: ty::t) {\n-    debug2!(\"check_bounds_are_used(n_tps={}, ty={})\",\n+    debug!(\"check_bounds_are_used(n_tps={}, ty={})\",\n            tps.len(), ppaux::ty_to_str(ccx.tcx, ty));\n \n     // make a vector of booleans initially false, set to true when used\n@@ -3521,7 +3521,7 @@ pub fn check_bounds_are_used(ccx: @mut CrateCtxt,\n         |t| {\n             match ty::get(t).sty {\n               ty::ty_param(param_ty {idx, _}) => {\n-                  debug2!(\"Found use of ty param \\\\#{}\", idx);\n+                  debug!(\"Found use of ty param \\\\#{}\", idx);\n                   tps_used[idx] = true;\n               }\n               _ => ()"}, {"sha": "06a13059462385f557242b74d40d58ddf5c084ed", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -211,7 +211,7 @@ fn visit_local(rcx: &mut Rcx, l: @ast::Local) {\n \n fn constrain_bindings_in_pat(pat: @ast::Pat, rcx: &mut Rcx) {\n     let tcx = rcx.fcx.tcx();\n-    debug2!(\"regionck::visit_pat(pat={})\", pat.repr(tcx));\n+    debug!(\"regionck::visit_pat(pat={})\", pat.repr(tcx));\n     do pat_util::pat_bindings(tcx.def_map, pat) |_, id, span, _| {\n         // If we have a variable that contains region'd data, that\n         // data will be accessible from anywhere that the variable is\n@@ -244,7 +244,7 @@ fn constrain_bindings_in_pat(pat: @ast::Pat, rcx: &mut Rcx) {\n }\n \n fn visit_expr(rcx: &mut Rcx, expr: @ast::Expr) {\n-    debug2!(\"regionck::visit_expr(e={}, repeating_scope={:?})\",\n+    debug!(\"regionck::visit_expr(e={}, repeating_scope={:?})\",\n            expr.repr(rcx.fcx.tcx()), rcx.repeating_scope);\n \n     let has_method_map = rcx.fcx.inh.method_map.contains_key(&expr.id);\n@@ -302,7 +302,7 @@ fn visit_expr(rcx: &mut Rcx, expr: @ast::Expr) {\n     {\n         let r = rcx.fcx.inh.adjustments.find(&expr.id);\n         for &adjustment in r.iter() {\n-            debug2!(\"adjustment={:?}\", adjustment);\n+            debug!(\"adjustment={:?}\", adjustment);\n             match *adjustment {\n                 @ty::AutoDerefRef(\n                     ty::AutoDerefRef {autoderefs: autoderefs, autoref: opt_autoref}) =>\n@@ -535,7 +535,7 @@ fn constrain_call(rcx: &mut Rcx,\n     //! appear in the arguments appropriately.\n \n     let tcx = rcx.fcx.tcx();\n-    debug2!(\"constrain_call(call_expr={}, implicitly_ref_args={:?})\",\n+    debug!(\"constrain_call(call_expr={}, implicitly_ref_args={:?})\",\n            call_expr.repr(tcx), implicitly_ref_args);\n     let callee_ty = rcx.resolve_node_type(callee_id);\n     if ty::type_is_error(callee_ty) {\n@@ -597,7 +597,7 @@ fn constrain_derefs(rcx: &mut Rcx,\n     let tcx = rcx.fcx.tcx();\n     let r_deref_expr = ty::re_scope(deref_expr.id);\n     for i in range(0u, derefs) {\n-        debug2!(\"constrain_derefs(deref_expr=?, derefd_ty={}, derefs={:?}/{:?}\",\n+        debug!(\"constrain_derefs(deref_expr=?, derefd_ty={}, derefs={:?}/{:?}\",\n                rcx.fcx.infcx().ty_to_str(derefd_ty),\n                i, derefs);\n \n@@ -638,7 +638,7 @@ fn constrain_index(rcx: &mut Rcx,\n      * includes the deref expr.\n      */\n \n-    debug2!(\"constrain_index(index_expr=?, indexed_ty={}\",\n+    debug!(\"constrain_index(index_expr=?, indexed_ty={}\",\n            rcx.fcx.infcx().ty_to_str(indexed_ty));\n \n     let r_index_expr = ty::re_scope(index_expr.id);\n@@ -662,13 +662,13 @@ fn constrain_free_variables(rcx: &mut Rcx,\n      */\n \n     let tcx = rcx.fcx.ccx.tcx;\n-    debug2!(\"constrain_free_variables({}, {})\",\n+    debug!(\"constrain_free_variables({}, {})\",\n            region.repr(tcx), expr.repr(tcx));\n     for freevar in get_freevars(tcx, expr.id).iter() {\n-        debug2!(\"freevar def is {:?}\", freevar.def);\n+        debug!(\"freevar def is {:?}\", freevar.def);\n         let def = freevar.def;\n         let en_region = encl_region_of_def(rcx.fcx, def);\n-        debug2!(\"en_region = {}\", en_region.repr(tcx));\n+        debug!(\"en_region = {}\", en_region.repr(tcx));\n         rcx.fcx.mk_subr(true, infer::FreeVariable(freevar.span),\n                         region, en_region);\n     }\n@@ -692,7 +692,7 @@ fn constrain_regions_in_type_of_node(\n     let ty0 = rcx.resolve_node_type(id);\n     let adjustment = rcx.fcx.inh.adjustments.find_copy(&id);\n     let ty = ty::adjust_ty(tcx, origin.span(), ty0, adjustment);\n-    debug2!(\"constrain_regions_in_type_of_node(\\\n+    debug!(\"constrain_regions_in_type_of_node(\\\n             ty={}, ty0={}, id={}, minimum_lifetime={:?}, adjustment={:?})\",\n            ty_to_str(tcx, ty), ty_to_str(tcx, ty0),\n            id, minimum_lifetime, adjustment);\n@@ -722,12 +722,12 @@ fn constrain_regions_in_type(\n     let e = rcx.errors_reported;\n     let tcx = rcx.fcx.ccx.tcx;\n \n-    debug2!(\"constrain_regions_in_type(minimum_lifetime={}, ty={})\",\n+    debug!(\"constrain_regions_in_type(minimum_lifetime={}, ty={})\",\n            region_to_str(tcx, \"\", false, minimum_lifetime),\n            ty_to_str(tcx, ty));\n \n     do relate_nested_regions(tcx, Some(minimum_lifetime), ty) |r_sub, r_sup| {\n-        debug2!(\"relate(r_sub={}, r_sup={})\",\n+        debug!(\"relate(r_sub={}, r_sup={})\",\n                region_to_str(tcx, \"\", false, r_sub),\n                region_to_str(tcx, \"\", false, r_sup));\n \n@@ -813,7 +813,7 @@ pub mod guarantor {\n          * to the lifetime of its guarantor (if any).\n          */\n \n-        debug2!(\"guarantor::for_addr_of(base=?)\");\n+        debug!(\"guarantor::for_addr_of(base=?)\");\n \n         let guarantor = guarantor(rcx, base);\n         link(rcx, expr.span, expr.id, guarantor);\n@@ -826,9 +826,9 @@ pub mod guarantor {\n          * linked to the lifetime of its guarantor (if any).\n          */\n \n-        debug2!(\"regionck::for_match()\");\n+        debug!(\"regionck::for_match()\");\n         let discr_guarantor = guarantor(rcx, discr);\n-        debug2!(\"discr_guarantor={}\", discr_guarantor.repr(rcx.tcx()));\n+        debug!(\"discr_guarantor={}\", discr_guarantor.repr(rcx.tcx()));\n         for arm in arms.iter() {\n             for pat in arm.pats.iter() {\n                 link_ref_bindings_in_pat(rcx, *pat, discr_guarantor);\n@@ -847,10 +847,10 @@ pub mod guarantor {\n          * region pointers.\n          */\n \n-        debug2!(\"guarantor::for_autoref(autoref={:?})\", autoref);\n+        debug!(\"guarantor::for_autoref(autoref={:?})\", autoref);\n \n         let mut expr_ct = categorize_unadjusted(rcx, expr);\n-        debug2!(\"    unadjusted cat={:?}\", expr_ct.cat);\n+        debug!(\"    unadjusted cat={:?}\", expr_ct.cat);\n         expr_ct = apply_autoderefs(\n             rcx, expr, autoderefs, expr_ct);\n \n@@ -898,10 +898,10 @@ pub mod guarantor {\n          */\n \n         let tcx = rcx.tcx();\n-        debug2!(\"guarantor::for_by_ref(expr={}, callee_scope={:?})\",\n+        debug!(\"guarantor::for_by_ref(expr={}, callee_scope={:?})\",\n                expr.repr(tcx), callee_scope);\n         let expr_cat = categorize(rcx, expr);\n-        debug2!(\"guarantor::for_by_ref(expr={:?}, callee_scope={:?}) category={:?}\",\n+        debug!(\"guarantor::for_by_ref(expr={:?}, callee_scope={:?}) category={:?}\",\n                expr.id, callee_scope, expr_cat);\n         let minimum_lifetime = ty::re_scope(callee_scope);\n         for guarantor in expr_cat.guarantor.iter() {\n@@ -921,7 +921,7 @@ pub mod guarantor {\n          * to the lifetime of its guarantor (if any).\n          */\n \n-        debug2!(\"link(id={:?}, guarantor={:?})\", id, guarantor);\n+        debug!(\"link(id={:?}, guarantor={:?})\", id, guarantor);\n \n         let bound = match guarantor {\n             None => {\n@@ -939,7 +939,7 @@ pub mod guarantor {\n         let rptr_ty = rcx.resolve_node_type(id);\n         if !ty::type_is_bot(rptr_ty) {\n             let tcx = rcx.fcx.ccx.tcx;\n-            debug2!(\"rptr_ty={}\", ty_to_str(tcx, rptr_ty));\n+            debug!(\"rptr_ty={}\", ty_to_str(tcx, rptr_ty));\n             let r = ty::ty_region(tcx, span, rptr_ty);\n             rcx.fcx.mk_subr(true, infer::Reborrow(span), r, bound);\n         }\n@@ -977,7 +977,7 @@ pub mod guarantor {\n          * `&expr`).\n          */\n \n-        debug2!(\"guarantor()\");\n+        debug!(\"guarantor()\");\n         match expr.node {\n             ast::ExprUnary(_, ast::UnDeref, b) => {\n                 let cat = categorize(rcx, b);\n@@ -1035,15 +1035,15 @@ pub mod guarantor {\n                     rcx.fcx.tcx(), rcx.fcx.inh.method_map, expr));\n                 None\n             }\n-            ast::ExprForLoop(*) => fail2!(\"non-desugared expr_for_loop\"),\n+            ast::ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n         }\n     }\n \n     fn categorize(rcx: &mut Rcx, expr: @ast::Expr) -> ExprCategorization {\n-        debug2!(\"categorize()\");\n+        debug!(\"categorize()\");\n \n         let mut expr_ct = categorize_unadjusted(rcx, expr);\n-        debug2!(\"before adjustments, cat={:?}\", expr_ct.cat);\n+        debug!(\"before adjustments, cat={:?}\", expr_ct.cat);\n \n         match rcx.fcx.inh.adjustments.find(&expr.id) {\n             Some(&@ty::AutoAddEnv(*)) => {\n@@ -1056,7 +1056,7 @@ pub mod guarantor {\n             }\n \n             Some(&@ty::AutoDerefRef(ref adjustment)) => {\n-                debug2!(\"adjustment={:?}\", adjustment);\n+                debug!(\"adjustment={:?}\", adjustment);\n \n                 expr_ct = apply_autoderefs(\n                     rcx, expr, adjustment.autoderefs, expr_ct);\n@@ -1067,7 +1067,7 @@ pub mod guarantor {\n                     Some(ty::AutoUnsafe(_)) => {\n                         expr_ct.cat.guarantor = None;\n                         expr_ct.cat.pointer = OtherPointer;\n-                        debug2!(\"autoref, cat={:?}\", expr_ct.cat);\n+                        debug!(\"autoref, cat={:?}\", expr_ct.cat);\n                     }\n                     Some(ty::AutoPtr(r, _)) |\n                     Some(ty::AutoBorrowVec(r, _)) |\n@@ -1078,22 +1078,22 @@ pub mod guarantor {\n                         // expression will be some sort of borrowed pointer.\n                         expr_ct.cat.guarantor = None;\n                         expr_ct.cat.pointer = BorrowedPointer(r);\n-                        debug2!(\"autoref, cat={:?}\", expr_ct.cat);\n+                        debug!(\"autoref, cat={:?}\", expr_ct.cat);\n                     }\n                 }\n             }\n \n             None => {}\n         }\n \n-        debug2!(\"result={:?}\", expr_ct.cat);\n+        debug!(\"result={:?}\", expr_ct.cat);\n         return expr_ct.cat;\n     }\n \n     fn categorize_unadjusted(rcx: &mut Rcx,\n                              expr: @ast::Expr)\n                           -> ExprCategorizationType {\n-        debug2!(\"categorize_unadjusted()\");\n+        debug!(\"categorize_unadjusted()\");\n \n         let guarantor = {\n             if rcx.fcx.inh.method_map.contains_key(&expr.id) {\n@@ -1143,7 +1143,7 @@ pub mod guarantor {\n                 }\n             }\n \n-            debug2!(\"autoderef, cat={:?}\", ct.cat);\n+            debug!(\"autoderef, cat={:?}\", ct.cat);\n         }\n         return ct;\n     }\n@@ -1205,7 +1205,7 @@ pub mod guarantor {\n          * other pointers.\n          */\n \n-        debug2!(\"link_ref_bindings_in_pat(pat={}, guarantor={:?})\",\n+        debug!(\"link_ref_bindings_in_pat(pat={}, guarantor={:?})\",\n                rcx.fcx.pat_to_str(pat), guarantor);\n \n         match pat.node {"}, {"sha": "9ba709f7651064645aec7e79bad309e21ef1347f", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -34,23 +34,23 @@ pub fn replace_bound_regions_in_fn_sig(\n \n     for &t in opt_self_ty.iter() { all_tys.push(t) }\n \n-    debug2!(\"replace_bound_regions_in_fn_sig(self_ty={:?}, fn_sig={}, \\\n+    debug!(\"replace_bound_regions_in_fn_sig(self_ty={:?}, fn_sig={}, \\\n             all_tys={:?})\",\n            opt_self_ty.map(|t| ppaux::ty_to_str(tcx, t)),\n            ppaux::fn_sig_to_str(tcx, fn_sig),\n            all_tys.map(|t| ppaux::ty_to_str(tcx, *t)));\n     let _i = indenter();\n \n     let isr = do create_bound_region_mapping(tcx, isr, all_tys) |br| {\n-        debug2!(\"br={:?}\", br);\n+        debug!(\"br={:?}\", br);\n         mapf(br)\n     };\n     let new_fn_sig = ty::fold_sig(fn_sig, |t| {\n         replace_bound_regions(tcx, isr, t)\n     });\n     let new_self_ty = opt_self_ty.map(|t| replace_bound_regions(tcx, isr, t));\n \n-    debug2!(\"result of replace_bound_regions_in_fn_sig: \\\n+    debug!(\"result of replace_bound_regions_in_fn_sig: \\\n             new_self_ty={:?}, \\\n             fn_sig={}\",\n            new_self_ty.map(|t| ppaux::ty_to_str(tcx, t)),\n@@ -251,7 +251,7 @@ pub fn relate_free_regions(\n      * Tests: `src/test/compile-fail/regions-free-region-ordering-*.rs`\n      */\n \n-    debug2!(\"relate_free_regions >>\");\n+    debug!(\"relate_free_regions >>\");\n \n     let mut all_tys = ~[];\n     for arg in fn_sig.inputs.iter() {\n@@ -262,7 +262,7 @@ pub fn relate_free_regions(\n     }\n \n     for &t in all_tys.iter() {\n-        debug2!(\"relate_free_regions(t={})\", ppaux::ty_to_str(tcx, t));\n+        debug!(\"relate_free_regions(t={})\", ppaux::ty_to_str(tcx, t));\n         relate_nested_regions(tcx, None, t, |a, b| {\n             match (&a, &b) {\n                 (&ty::re_free(free_a), &ty::re_free(free_b)) => {\n@@ -273,5 +273,5 @@ pub fn relate_free_regions(\n         })\n     }\n \n-    debug2!(\"<< relate_free_regions\");\n+    debug!(\"<< relate_free_regions\");\n }"}, {"sha": "3c4ff35b768db42b24e60fd8491b29e7a2be7a79", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -87,7 +87,7 @@ fn lookup_vtables(vcx: &VtableContext,\n                   type_param_defs: &[ty::TypeParameterDef],\n                   substs: &ty::substs,\n                   is_early: bool) -> vtable_res {\n-    debug2!(\"lookup_vtables(location_info={:?}, \\\n+    debug!(\"lookup_vtables(location_info={:?}, \\\n             type_param_defs={}, \\\n             substs={}\",\n            location_info,\n@@ -108,7 +108,7 @@ fn lookup_vtables(vcx: &VtableContext,\n     result.reverse();\n \n     assert_eq!(substs.tps.len(), result.len());\n-    debug2!(\"lookup_vtables result(\\\n+    debug!(\"lookup_vtables result(\\\n             location_info={:?}, \\\n             type_param_defs={}, \\\n             substs={}, \\\n@@ -142,12 +142,12 @@ fn lookup_vtables_for_param(vcx: &VtableContext,\n         // Substitute the values of the type parameters that may\n         // appear in the bound.\n         let trait_ref = substs.as_ref().map_default(trait_ref, |substs| {\n-            debug2!(\"about to subst: {}, {}\",\n+            debug!(\"about to subst: {}, {}\",\n                    trait_ref.repr(tcx), substs.repr(tcx));\n             trait_ref.subst(tcx, *substs)\n         });\n \n-        debug2!(\"after subst: {}\", trait_ref.repr(tcx));\n+        debug!(\"after subst: {}\", trait_ref.repr(tcx));\n \n         match lookup_vtable(vcx, location_info, ty, trait_ref, is_early) {\n             Some(vtable) => param_result.push(vtable),\n@@ -163,7 +163,7 @@ fn lookup_vtables_for_param(vcx: &VtableContext,\n         true\n     };\n \n-    debug2!(\"lookup_vtables_for_param result(\\\n+    debug!(\"lookup_vtables_for_param result(\\\n             location_info={:?}, \\\n             type_param_bounds={}, \\\n             ty={}, \\\n@@ -228,7 +228,7 @@ fn lookup_vtable(vcx: &VtableContext,\n                  is_early: bool)\n     -> Option<vtable_origin>\n {\n-    debug2!(\"lookup_vtable(ty={}, trait_ref={})\",\n+    debug!(\"lookup_vtable(ty={}, trait_ref={})\",\n            vcx.infcx.ty_to_str(ty),\n            vcx.infcx.trait_ref_to_str(trait_ref));\n     let _i = indenter();\n@@ -291,7 +291,7 @@ fn lookup_vtable_from_bounds(vcx: &VtableContext,\n     let mut n_bound = 0;\n     let mut ret = None;\n     do ty::each_bound_trait_and_supertraits(tcx, bounds) |bound_trait_ref| {\n-        debug2!(\"checking bounds trait {}\",\n+        debug!(\"checking bounds trait {}\",\n                bound_trait_ref.repr(vcx.tcx()));\n \n         if bound_trait_ref.def_id == trait_ref.def_id {\n@@ -300,7 +300,7 @@ fn lookup_vtable_from_bounds(vcx: &VtableContext,\n                               bound_trait_ref,\n                               trait_ref);\n             let vtable = vtable_param(param, n_bound);\n-            debug2!(\"found param vtable: {:?}\",\n+            debug!(\"found param vtable: {:?}\",\n                    vtable);\n             ret = Some(vtable);\n             false\n@@ -382,7 +382,7 @@ fn search_for_vtable(vcx: &VtableContext,\n \n         // Now, in the previous example, for_ty is bound to\n         // the type self_ty, and substs is bound to [T].\n-        debug2!(\"The self ty is {} and its substs are {}\",\n+        debug!(\"The self ty is {} and its substs are {}\",\n                vcx.infcx.ty_to_str(for_ty),\n                vcx.infcx.tys_to_str(substs.tps));\n \n@@ -396,7 +396,7 @@ fn search_for_vtable(vcx: &VtableContext,\n         // some value of U) with some_trait<T>. This would fail if T\n         // and U weren't compatible.\n \n-        debug2!(\"(checking vtable) @2 relating trait \\\n+        debug!(\"(checking vtable) @2 relating trait \\\n                 ty {} to of_trait_ref {}\",\n                vcx.infcx.trait_ref_to_str(trait_ref),\n                vcx.infcx.trait_ref_to_str(of_trait_ref));\n@@ -434,7 +434,7 @@ fn search_for_vtable(vcx: &VtableContext,\n             }\n         };\n \n-        debug2!(\"The fixed-up substs are {} - \\\n+        debug!(\"The fixed-up substs are {} - \\\n                 they will be unified with the bounds for \\\n                 the target ty, {}\",\n                vcx.infcx.tys_to_str(substs_f.tps),\n@@ -486,7 +486,7 @@ fn fixup_substs(vcx: &VtableContext,\n     do fixup_ty(vcx, location_info, t, is_early).map |t_f| {\n         match ty::get(t_f).sty {\n           ty::ty_trait(_, ref substs_f, _, _, _) => (*substs_f).clone(),\n-          _ => fail2!(\"t_f should be a trait\")\n+          _ => fail!(\"t_f should be a trait\")\n         }\n     }\n }\n@@ -532,7 +532,7 @@ fn connect_trait_tps(vcx: &VtableContext,\n fn insert_vtables(fcx: @mut FnCtxt,\n                   callee_id: ast::NodeId,\n                   vtables: vtable_res) {\n-    debug2!(\"insert_vtables(callee_id={}, vtables={:?})\",\n+    debug!(\"insert_vtables(callee_id={}, vtables={:?})\",\n            callee_id, vtables.repr(fcx.tcx()));\n     fcx.inh.vtable_map.insert(callee_id, vtables);\n }\n@@ -553,23 +553,23 @@ pub fn location_info_for_item(item: @ast::item) -> LocationInfo {\n pub fn early_resolve_expr(ex: @ast::Expr,\n                           fcx: @mut FnCtxt,\n                           is_early: bool) {\n-    debug2!(\"vtable: early_resolve_expr() ex with id {:?} (early: {}): {}\",\n+    debug!(\"vtable: early_resolve_expr() ex with id {:?} (early: {}): {}\",\n            ex.id, is_early, expr_to_str(ex, fcx.tcx().sess.intr()));\n     let _indent = indenter();\n \n     let cx = fcx.ccx;\n     match ex.node {\n       ast::ExprPath(*) => {\n         do fcx.opt_node_ty_substs(ex.id) |substs| {\n-            debug2!(\"vtable resolution on parameter bounds for expr {}\",\n+            debug!(\"vtable resolution on parameter bounds for expr {}\",\n                    ex.repr(fcx.tcx()));\n             let def = cx.tcx.def_map.get_copy(&ex.id);\n             let did = ast_util::def_id_of_def(def);\n             let item_ty = ty::lookup_item_type(cx.tcx, did);\n-            debug2!(\"early resolve expr: def {:?} {:?}, {:?}, {}\", ex.id, did, def,\n+            debug!(\"early resolve expr: def {:?} {:?}, {:?}, {}\", ex.id, did, def,\n                    fcx.infcx().ty_to_str(item_ty.ty));\n             if has_trait_bounds(*item_ty.generics.type_param_defs) {\n-                debug2!(\"early_resolve_expr: looking up vtables for type params {}\",\n+                debug!(\"early_resolve_expr: looking up vtables for type params {}\",\n                        item_ty.generics.type_param_defs.repr(fcx.tcx()));\n                 let vcx = VtableContext { ccx: fcx.ccx, infcx: fcx.infcx() };\n                 let vtbls = lookup_vtables(&vcx, &location_info_for_expr(ex),\n@@ -595,7 +595,7 @@ pub fn early_resolve_expr(ex: @ast::Expr,\n       ast::ExprMethodCall(callee_id, _, _, _, _, _) => {\n         match ty::method_call_type_param_defs(cx.tcx, fcx.inh.method_map, ex.id) {\n           Some(type_param_defs) => {\n-            debug2!(\"vtable resolution on parameter bounds for method call {}\",\n+            debug!(\"vtable resolution on parameter bounds for method call {}\",\n                    ex.repr(fcx.tcx()));\n             if has_trait_bounds(*type_param_defs) {\n                 let substs = fcx.node_ty_substs(callee_id);\n@@ -611,7 +611,7 @@ pub fn early_resolve_expr(ex: @ast::Expr,\n         }\n       }\n       ast::ExprCast(src, _) => {\n-          debug2!(\"vtable resolution on expr {}\", ex.repr(fcx.tcx()));\n+          debug!(\"vtable resolution on expr {}\", ex.repr(fcx.tcx()));\n           let target_ty = fcx.expr_ty(ex);\n           match ty::get(target_ty).sty {\n               // Bounds of type's contents are not checked here, but in kind.rs.\n@@ -752,7 +752,7 @@ pub fn resolve_impl(ccx: @mut CrateCtxt, impl_item: @ast::item) {\n                 trait_bounds: ~[trait_ref]\n             };\n             let t = ty::node_id_to_type(ccx.tcx, impl_item.id);\n-            debug2!(\"=== Doing a self lookup now.\");\n+            debug!(\"=== Doing a self lookup now.\");\n             // Right now, we don't have any place to store this.\n             // We will need to make one so we can use this information\n             // for compiling default methods that refer to supertraits."}, {"sha": "46c7968a0a4141824ad2a4f6eaa66e96e0ff2333", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -70,7 +70,7 @@ fn resolve_method_map_entry(fcx: @mut FnCtxt, sp: Span, id: ast::NodeId) {\n                 for t in r.iter() {\n                     let method_map = fcx.ccx.method_map;\n                     let new_entry = method_map_entry { self_ty: *t, ..*mme };\n-                    debug2!(\"writeback::resolve_method_map_entry(id={:?}, \\\n+                    debug!(\"writeback::resolve_method_map_entry(id={:?}, \\\n                             new_entry={:?})\",\n                            id, new_entry);\n                     method_map.insert(id, new_entry);\n@@ -88,7 +88,7 @@ fn resolve_vtable_map_entry(fcx: @mut FnCtxt, sp: Span, id: ast::NodeId) {\n             let r_origins = resolve_origins(fcx, sp, *origins);\n             let vtable_map = fcx.ccx.vtable_map;\n             vtable_map.insert(id, r_origins);\n-            debug2!(\"writeback::resolve_vtable_map_entry(id={}, vtables={:?})\",\n+            debug!(\"writeback::resolve_vtable_map_entry(id={}, vtables={:?})\",\n                    id, r_origins.repr(fcx.tcx()));\n         }\n     }\n@@ -133,7 +133,7 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n                 }\n                 Ok(r1) => {\n                     let resolved_adj = @ty::AutoAddEnv(r1, s);\n-                    debug2!(\"Adjustments for node {}: {:?}\", id, resolved_adj);\n+                    debug!(\"Adjustments for node {}: {:?}\", id, resolved_adj);\n                     fcx.tcx().adjustments.insert(id, resolved_adj);\n                 }\n             }\n@@ -162,7 +162,7 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n                 autoderefs: adj.autoderefs,\n                 autoref: resolved_autoref,\n             });\n-            debug2!(\"Adjustments for node {}: {:?}\", id, resolved_adj);\n+            debug!(\"Adjustments for node {}: {:?}\", id, resolved_adj);\n             fcx.tcx().adjustments.insert(id, resolved_adj);\n         }\n     }\n@@ -176,7 +176,7 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n       }\n \n       Some(t) => {\n-        debug2!(\"resolve_type_vars_for_node(id={}, n_ty={}, t={})\",\n+        debug!(\"resolve_type_vars_for_node(id={}, n_ty={}, t={})\",\n                id, ppaux::ty_to_str(tcx, n_ty), ppaux::ty_to_str(tcx, t));\n         write_ty_to_tcx(tcx, id, t);\n         let mut ret = Some(t);\n@@ -284,7 +284,7 @@ fn visit_pat(p: @ast::Pat, wbcx: &mut WbCtxt) {\n     }\n \n     resolve_type_vars_for_node(wbcx, p.span, p.id);\n-    debug2!(\"Type for pattern binding {} (id {}) resolved to {}\",\n+    debug!(\"Type for pattern binding {} (id {}) resolved to {}\",\n            pat_to_str(p, wbcx.fcx.ccx.tcx.sess.intr()), p.id,\n            wbcx.fcx.infcx().ty_to_str(\n                ty::node_id_to_type(wbcx.fcx.ccx.tcx,\n@@ -297,7 +297,7 @@ fn visit_local(l: @ast::Local, wbcx: &mut WbCtxt) {\n     let var_ty = wbcx.fcx.local_ty(l.span, l.id);\n     match resolve_type(wbcx.fcx.infcx(), var_ty, resolve_all | force_all) {\n         Ok(lty) => {\n-            debug2!(\"Type for local {} (id {}) resolved to {}\",\n+            debug!(\"Type for local {} (id {}) resolved to {}\",\n                    pat_to_str(l.pat, wbcx.fcx.tcx().sess.intr()),\n                    l.id,\n                    wbcx.fcx.infcx().ty_to_str(lty));"}, {"sha": "795074fa61904dbe7356ee5b12f083ebd827fd90", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -76,7 +76,7 @@ pub fn get_base_type(inference_context: @mut InferCtxt,\n \n     match get(resolved_type).sty {\n         ty_enum(*) | ty_trait(*) | ty_struct(*) => {\n-            debug2!(\"(getting base type) found base type\");\n+            debug!(\"(getting base type) found base type\");\n             Some(resolved_type)\n         }\n \n@@ -85,7 +85,7 @@ pub fn get_base_type(inference_context: @mut InferCtxt,\n         ty_infer(*) | ty_param(*) | ty_self(*) | ty_type | ty_opaque_box |\n         ty_opaque_closure_ptr(*) | ty_unboxed_vec(*) | ty_err | ty_box(_) |\n         ty_uniq(_) | ty_ptr(_) | ty_rptr(_, _) => {\n-            debug2!(\"(getting base type) no base type; found {:?}\",\n+            debug!(\"(getting base type) no base type; found {:?}\",\n                    get(original_type).sty);\n             None\n         }\n@@ -135,7 +135,7 @@ pub fn get_base_type_def_id(inference_context: @mut InferCtxt,\n                     return Some(def_id);\n                 }\n                 _ => {\n-                    fail2!(\"get_base_type() returned a type that wasn't an \\\n+                    fail!(\"get_base_type() returned a type that wasn't an \\\n                            enum, struct, or trait\");\n                 }\n             }\n@@ -160,7 +160,7 @@ struct CoherenceCheckVisitor { cc: CoherenceChecker }\n impl visit::Visitor<()> for CoherenceCheckVisitor {\n     fn visit_item(&mut self, item:@item, _:()) {\n \n-//                debug2!(\"(checking coherence) item '{}'\",\n+//                debug!(\"(checking coherence) item '{}'\",\n //                       self.cc.crate_context.tcx.sess.str_of(item.ident));\n \n                 match item.node {\n@@ -266,7 +266,7 @@ impl CoherenceChecker {\n         // base type.\n \n         if associated_traits.len() == 0 {\n-            debug2!(\"(checking implementation) no associated traits for item \\\n+            debug!(\"(checking implementation) no associated traits for item \\\n                     '{}'\",\n                    self.crate_context.tcx.sess.str_of(item.ident));\n \n@@ -290,7 +290,7 @@ impl CoherenceChecker {\n         for associated_trait in associated_traits.iter() {\n             let trait_ref = ty::node_id_to_trait_ref(\n                 self.crate_context.tcx, associated_trait.ref_id);\n-            debug2!(\"(checking implementation) adding impl for trait '{}', item '{}'\",\n+            debug!(\"(checking implementation) adding impl for trait '{}', item '{}'\",\n                    trait_ref.repr(self.crate_context.tcx),\n                    self.crate_context.tcx.sess.str_of(item.ident));\n \n@@ -325,7 +325,7 @@ impl CoherenceChecker {\n                                        trait_ref: &ty::TraitRef,\n                                        all_methods: &mut ~[@Method]) {\n         let tcx = self.crate_context.tcx;\n-        debug2!(\"instantiate_default_methods(impl_id={:?}, trait_ref={})\",\n+        debug!(\"instantiate_default_methods(impl_id={:?}, trait_ref={})\",\n                impl_id, trait_ref.repr(tcx));\n \n         let impl_poly_type = ty::lookup_item_type(tcx, impl_id);\n@@ -336,7 +336,7 @@ impl CoherenceChecker {\n             let new_id = tcx.sess.next_node_id();\n             let new_did = local_def(new_id);\n \n-            debug2!(\"new_did={:?} trait_method={}\", new_did, trait_method.repr(tcx));\n+            debug!(\"new_did={:?} trait_method={}\", new_did, trait_method.repr(tcx));\n \n             // Create substitutions for the various trait parameters.\n             let new_method_ty =\n@@ -348,7 +348,7 @@ impl CoherenceChecker {\n                     *trait_method,\n                     Some(trait_method.def_id));\n \n-            debug2!(\"new_method_ty={}\", new_method_ty.repr(tcx));\n+            debug!(\"new_method_ty={}\", new_method_ty.repr(tcx));\n             all_methods.push(new_method_ty);\n \n             // construct the polytype for the method based on the method_ty\n@@ -364,7 +364,7 @@ impl CoherenceChecker {\n                 generics: new_generics,\n                 ty: ty::mk_bare_fn(tcx, new_method_ty.fty.clone())\n             };\n-            debug2!(\"new_polytype={}\", new_polytype.repr(tcx));\n+            debug!(\"new_polytype={}\", new_polytype.repr(tcx));\n \n             tcx.tcache.insert(new_did, new_polytype);\n             tcx.methods.insert(new_did, new_method_ty);\n@@ -557,7 +557,7 @@ impl CoherenceChecker {\n \n         let r = ty::trait_methods(tcx, trait_did);\n         for method in r.iter() {\n-            debug2!(\"checking for {}\", method.ident.repr(tcx));\n+            debug!(\"checking for {}\", method.ident.repr(tcx));\n             if provided_names.contains(&method.ident.name) { continue; }\n \n             tcx.sess.span_err(trait_ref_span,"}, {"sha": "9c69e6fd85cc7d60cfb9985dd5c369c3e3e7ee87", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -347,7 +347,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n         let substd_type_param_defs = m.generics.type_param_defs.subst(tcx, &substs);\n         new_type_param_defs.push_all(*substd_type_param_defs);\n \n-        debug2!(\"static method {} type_param_defs={} ty={}, substs={}\",\n+        debug!(\"static method {} type_param_defs={} ty={}, substs={}\",\n                m.def_id.repr(tcx),\n                new_type_param_defs.repr(tcx),\n                ty.repr(tcx),\n@@ -453,7 +453,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n                            trait_m: &ty::Method,\n                            trait_substs: &ty::substs,\n                            self_ty: ty::t) {\n-    debug2!(\"compare_impl_method()\");\n+    debug!(\"compare_impl_method()\");\n     let infcx = infer::new_infer_ctxt(tcx);\n \n     let impl_m = &cm.mty;\n@@ -632,10 +632,10 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n     //   that correspond to the parameters we will find on the impl\n     // - replace self region with a fresh, dummy region\n     let impl_fty = {\n-        debug2!(\"impl_fty (pre-subst): {}\", ppaux::ty_to_str(tcx, impl_fty));\n+        debug!(\"impl_fty (pre-subst): {}\", ppaux::ty_to_str(tcx, impl_fty));\n         replace_bound_self(tcx, impl_fty, dummy_self_r)\n     };\n-    debug2!(\"impl_fty (post-subst): {}\", ppaux::ty_to_str(tcx, impl_fty));\n+    debug!(\"impl_fty (post-subst): {}\", ppaux::ty_to_str(tcx, impl_fty));\n     let trait_fty = {\n         let num_trait_m_type_params = trait_m.generics.type_param_defs.len();\n         let dummy_tps = do vec::from_fn(num_trait_m_type_params) |i| {\n@@ -649,11 +649,11 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n             self_ty: Some(self_ty),\n             tps: vec::append(trait_tps, dummy_tps)\n         };\n-        debug2!(\"trait_fty (pre-subst): {} substs={}\",\n+        debug!(\"trait_fty (pre-subst): {} substs={}\",\n                trait_fty.repr(tcx), substs.repr(tcx));\n         ty::subst(tcx, &substs, trait_fty)\n     };\n-    debug2!(\"trait_fty (post-subst): {}\", trait_fty.repr(tcx));\n+    debug!(\"trait_fty (post-subst): {}\", trait_fty.repr(tcx));\n \n     match infer::mk_subty(infcx, false, infer::MethodCompatCheck(cm.span),\n                           impl_fty, trait_fty) {\n@@ -844,7 +844,7 @@ pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n     let tcx = ccx.tcx;\n     let rp = tcx.region_paramd_items.find(&it.id).map(|x| *x);\n-    debug2!(\"convert: item {} with id {} rp {:?}\",\n+    debug!(\"convert: item {} with id {} rp {:?}\",\n            tcx.sess.str_of(it.ident), it.id, rp);\n     match it.node {\n       // These don't define types.\n@@ -1120,7 +1120,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n             },\n             ty: ty::mk_bare_fn(ccx.tcx, tofd)\n         };\n-        debug2!(\"type of {} (id {}) is {}\",\n+        debug!(\"type of {} (id {}) is {}\",\n                tcx.sess.str_of(it.ident),\n                it.id,\n                ppaux::ty_to_str(tcx, tpt.ty));\n@@ -1174,8 +1174,8 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n           return tpt;\n       }\n       ast::item_impl(*) | ast::item_mod(_) |\n-      ast::item_foreign_mod(_) => fail2!(),\n-      ast::item_mac(*) => fail2!(\"item macros unimplemented\")\n+      ast::item_foreign_mod(_) => fail!(),\n+      ast::item_mac(*) => fail!(\"item macros unimplemented\")\n     }\n }\n \n@@ -1222,7 +1222,7 @@ pub fn ty_generics(ccx: &CrateCtxt,\n                         def_id: local_def(param.id),\n                         bounds: bounds\n                     };\n-                    debug2!(\"def for param: {}\", def.repr(ccx.tcx));\n+                    debug!(\"def for param: {}\", def.repr(ccx.tcx));\n                     ccx.tcx.ty_param_defs.insert(param.id, def);\n                     def\n                 }"}, {"sha": "e1f65f79e4fb7ac82020a695c0b1ee3c12595f9b", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -87,7 +87,7 @@ pub struct Coerce(CombineFields);\n \n impl Coerce {\n     pub fn tys(&self, a: ty::t, b: ty::t) -> CoerceResult {\n-        debug2!(\"Coerce.tys({} => {})\",\n+        debug!(\"Coerce.tys({} => {})\",\n                a.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n         let _indent = indenter();\n@@ -184,7 +184,7 @@ impl Coerce {\n                                    b: ty::t,\n                                    mt_b: ty::mt)\n                                    -> CoerceResult {\n-        debug2!(\"coerce_borrowed_pointer(a={}, sty_a={:?}, b={}, mt_b={:?})\",\n+        debug!(\"coerce_borrowed_pointer(a={}, sty_a={:?}, b={}, mt_b={:?})\",\n                a.inf_str(self.infcx), sty_a,\n                b.inf_str(self.infcx), mt_b);\n \n@@ -221,7 +221,7 @@ impl Coerce {\n                                   sty_a: &ty::sty,\n                                   b: ty::t)\n                                   -> CoerceResult {\n-        debug2!(\"coerce_borrowed_string(a={}, sty_a={:?}, b={})\",\n+        debug!(\"coerce_borrowed_string(a={}, sty_a={:?}, b={})\",\n                a.inf_str(self.infcx), sty_a,\n                b.inf_str(self.infcx));\n \n@@ -248,7 +248,7 @@ impl Coerce {\n                                   b: ty::t,\n                                   mt_b: ty::mt)\n                                   -> CoerceResult {\n-        debug2!(\"coerce_borrowed_vector(a={}, sty_a={:?}, b={})\",\n+        debug!(\"coerce_borrowed_vector(a={}, sty_a={:?}, b={})\",\n                a.inf_str(self.infcx), sty_a,\n                b.inf_str(self.infcx));\n \n@@ -277,7 +277,7 @@ impl Coerce {\n                               b: ty::t,\n                               b_mutbl: ast::Mutability) -> CoerceResult\n     {\n-        debug2!(\"coerce_borrowed_object(a={}, sty_a={:?}, b={})\",\n+        debug!(\"coerce_borrowed_object(a={}, sty_a={:?}, b={})\",\n                a.inf_str(self.infcx), sty_a,\n                b.inf_str(self.infcx));\n \n@@ -306,7 +306,7 @@ impl Coerce {\n                               sty_a: &ty::sty,\n                               b: ty::t)\n                               -> CoerceResult {\n-        debug2!(\"coerce_borrowed_fn(a={}, sty_a={:?}, b={})\",\n+        debug!(\"coerce_borrowed_fn(a={}, sty_a={:?}, b={})\",\n                a.inf_str(self.infcx), sty_a,\n                b.inf_str(self.infcx));\n \n@@ -361,7 +361,7 @@ impl Coerce {\n          * \"rust\" fn`) into a closure.\n          */\n \n-        debug2!(\"coerce_from_bare_fn(a={}, b={})\",\n+        debug!(\"coerce_from_bare_fn(a={}, b={})\",\n                a.inf_str(self.infcx), b.inf_str(self.infcx));\n \n         if !fn_ty_a.abis.is_rust() {\n@@ -389,7 +389,7 @@ impl Coerce {\n                              b: ty::t,\n                              mt_b: ty::mt)\n                              -> CoerceResult {\n-        debug2!(\"coerce_unsafe_ptr(a={}, sty_a={:?}, b={})\",\n+        debug!(\"coerce_unsafe_ptr(a={}, sty_a={:?}, b={})\",\n                a.inf_str(self.infcx), sty_a,\n                b.inf_str(self.infcx));\n "}, {"sha": "2d810f1da746fab196122fb83c2bb94460795b45", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -270,7 +270,7 @@ pub trait Combine {\n     fn vstores(&self, vk: ty::terr_vstore_kind,\n                a: ty::vstore, b: ty::vstore) -> cres<ty::vstore> {\n \n-        debug2!(\"{}.vstores(a={:?}, b={:?})\", self.tag(), a, b);\n+        debug!(\"{}.vstores(a={:?}, b={:?})\", self.tag(), a, b);\n \n         match (a, b) {\n             (ty::vstore_slice(a_r), ty::vstore_slice(b_r)) => {\n@@ -295,7 +295,7 @@ pub trait Combine {\n                     b: ty::TraitStore)\n                  -> cres<ty::TraitStore> {\n \n-        debug2!(\"{}.trait_stores(a={:?}, b={:?})\", self.tag(), a, b);\n+        debug!(\"{}.trait_stores(a={:?}, b={:?})\", self.tag(), a, b);\n \n         match (a, b) {\n             (ty::RegionTraitStore(a_r), ty::RegionTraitStore(b_r)) => {\n@@ -365,7 +365,7 @@ pub fn eq_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> ures {\n \n pub fn eq_regions<C:Combine>(this: &C, a: ty::Region, b: ty::Region)\n                           -> ures {\n-    debug2!(\"eq_regions({}, {})\",\n+    debug!(\"eq_regions({}, {})\",\n            a.inf_str(this.infcx()),\n            b.inf_str(this.infcx()));\n     let sub = this.sub();"}, {"sha": "87c7373b005d56db747c766d029bab7cc9aca04d", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -44,7 +44,7 @@ impl Combine for Glb {\n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n         let tcx = self.infcx.tcx;\n \n-        debug2!(\"{}.mts({}, {})\",\n+        debug!(\"{}.mts({}, {})\",\n                self.tag(),\n                mt_to_str(tcx, a),\n                mt_to_str(tcx, b));\n@@ -100,7 +100,7 @@ impl Combine for Glb {\n     }\n \n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n-        debug2!(\"{}.regions({:?}, {:?})\",\n+        debug!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n                a.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n@@ -121,7 +121,7 @@ impl Combine for Glb {\n         // Note: this is a subtle algorithm.  For a full explanation,\n         // please see the large comment in `region_inference.rs`.\n \n-        debug2!(\"{}.fn_sigs({:?}, {:?})\",\n+        debug!(\"{}.fn_sigs({:?}, {:?})\",\n                self.tag(), a.inf_str(self.infcx), b.inf_str(self.infcx));\n         let _indenter = indenter();\n \n@@ -143,7 +143,7 @@ impl Combine for Glb {\n \n         // Collect constraints.\n         let sig0 = if_ok!(super_fn_sigs(self, &a_with_fresh, &b_with_fresh));\n-        debug2!(\"sig0 = {}\", sig0.inf_str(self.infcx));\n+        debug!(\"sig0 = {}\", sig0.inf_str(self.infcx));\n \n         // Generalize the regions appearing in fn_ty0 if possible\n         let new_vars =\n@@ -155,7 +155,7 @@ impl Combine for Glb {\n                 |r, _in_fn| generalize_region(self, snapshot,\n                                               new_vars, a_isr, a_vars, b_vars,\n                                               r));\n-        debug2!(\"sig1 = {}\", sig1.inf_str(self.infcx));\n+        debug!(\"sig1 = {}\", sig1.inf_str(self.infcx));\n         return Ok(sig1);\n \n         fn generalize_region(this: &Glb,"}, {"sha": "8a32a305b3a0e6b7b7aff8942d7d1106f4825d6b", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -131,7 +131,7 @@ impl CombineFieldsLatticeMethods for CombineFields {\n         let a_bounds = node_a.possible_types.clone();\n         let b_bounds = node_b.possible_types.clone();\n \n-        debug2!(\"vars({}={} <: {}={})\",\n+        debug!(\"vars({}={} <: {}={})\",\n                a_id.to_str(), a_bounds.inf_str(self.infcx),\n                b_id.to_str(), b_bounds.inf_str(self.infcx));\n \n@@ -179,7 +179,7 @@ impl CombineFieldsLatticeMethods for CombineFields {\n         let a_bounds = &node_a.possible_types;\n         let b_bounds = &Bounds { lb: None, ub: Some(b.clone()) };\n \n-        debug2!(\"var_sub_t({}={} <: {})\",\n+        debug!(\"var_sub_t({}={} <: {})\",\n                a_id.to_str(),\n                a_bounds.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n@@ -203,7 +203,7 @@ impl CombineFieldsLatticeMethods for CombineFields {\n         let b_id = node_b.root.clone();\n         let b_bounds = &node_b.possible_types;\n \n-        debug2!(\"t_sub_var({} <: {}={})\",\n+        debug!(\"t_sub_var({} <: {}={})\",\n                a.inf_str(self.infcx),\n                b_id.to_str(),\n                b_bounds.inf_str(self.infcx));\n@@ -222,7 +222,7 @@ impl CombineFieldsLatticeMethods for CombineFields {\n          *\n          * Combines two bounds into a more general bound. */\n \n-        debug2!(\"merge_bnd({},{})\",\n+        debug!(\"merge_bnd({},{})\",\n                a.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n         let _r = indenter();\n@@ -273,7 +273,7 @@ impl CombineFieldsLatticeMethods for CombineFields {\n         //       A     \\ / A\n         //              B\n \n-        debug2!(\"merge({},{},{})\",\n+        debug!(\"merge({},{},{})\",\n                v_id.to_str(),\n                a.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n@@ -290,7 +290,7 @@ impl CombineFieldsLatticeMethods for CombineFields {\n         let ub = if_ok!(self.merge_bnd(&a.ub, &b.ub, LatticeValue::glb));\n         let lb = if_ok!(self.merge_bnd(&a.lb, &b.lb, LatticeValue::lub));\n         let bounds = Bounds { lb: lb, ub: ub };\n-        debug2!(\"merge({}): bounds={}\",\n+        debug!(\"merge({}): bounds={}\",\n                v_id.to_str(),\n                bounds.inf_str(self.infcx));\n \n@@ -305,7 +305,7 @@ impl CombineFieldsLatticeMethods for CombineFields {\n                                                a: &Bound<T>,\n                                                b: &Bound<T>)\n                                                -> ures {\n-        debug2!(\"bnds({} <: {})\", a.inf_str(self.infcx),\n+        debug!(\"bnds({} <: {})\", a.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n         let _r = indenter();\n \n@@ -370,7 +370,7 @@ pub fn super_lattice_tys<L:LatticeDir + TyLatticeDir + Combine>(\n     this: &L,\n     a: ty::t,\n     b: ty::t) -> cres<ty::t> {\n-    debug2!(\"{}.lattice_tys({}, {})\", this.tag(),\n+    debug!(\"{}.lattice_tys({}, {})\", this.tag(),\n            a.inf_str(this.infcx()),\n            b.inf_str(this.infcx()));\n     let _r = indenter();\n@@ -448,7 +448,7 @@ pub fn lattice_vars<L:LatticeDir + Combine,\n     let a_bounds = &nde_a.possible_types;\n     let b_bounds = &nde_b.possible_types;\n \n-    debug2!(\"{}.lattice_vars({}={} <: {}={})\",\n+    debug!(\"{}.lattice_vars({}={} <: {}={})\",\n            this.tag(),\n            a_vid.to_str(), a_bounds.inf_str(this.infcx()),\n            b_vid.to_str(), b_bounds.inf_str(this.infcx()));\n@@ -494,7 +494,7 @@ pub fn lattice_var_and_t<L:LatticeDir + Combine,\n     // The comments in this function are written for LUB, but they\n     // apply equally well to GLB if you inverse upper/lower/sub/super/etc.\n \n-    debug2!(\"{}.lattice_var_and_t({}={} <: {})\",\n+    debug!(\"{}.lattice_var_and_t({}={} <: {})\",\n            this.tag(),\n            a_id.to_str(),\n            a_bounds.inf_str(this.infcx()),\n@@ -503,13 +503,13 @@ pub fn lattice_var_and_t<L:LatticeDir + Combine,\n     match this.bnd(a_bounds) {\n         Some(ref a_bnd) => {\n             // If a has an upper bound, return the LUB(a.ub, b)\n-            debug2!(\"bnd=Some({})\", a_bnd.inf_str(this.infcx()));\n+            debug!(\"bnd=Some({})\", a_bnd.inf_str(this.infcx()));\n             lattice_dir_op(a_bnd, b)\n         }\n         None => {\n             // If a does not have an upper bound, make b the upper bound of a\n             // and then return b.\n-            debug2!(\"bnd=None\");\n+            debug!(\"bnd=None\");\n             let a_bounds = this.with_bnd(a_bounds, (*b).clone());\n             do this.combine_fields().bnds(&a_bounds.lb, &a_bounds.ub).then {\n                 this.infcx().set(a_id.clone(),"}, {"sha": "42793d956df063fc1a0ee6db98ee49ff39d40a66", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -50,7 +50,7 @@ impl Combine for Lub {\n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n         let tcx = self.infcx.tcx;\n \n-        debug2!(\"{}.mts({}, {})\",\n+        debug!(\"{}.mts({}, {})\",\n                self.tag(),\n                mt_to_str(tcx, a),\n                mt_to_str(tcx, b));\n@@ -106,7 +106,7 @@ impl Combine for Lub {\n     }\n \n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n-        debug2!(\"{}.regions({:?}, {:?})\",\n+        debug!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n                a.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n@@ -134,7 +134,7 @@ impl Combine for Lub {\n \n         // Collect constraints.\n         let sig0 = if_ok!(super_fn_sigs(self, &a_with_fresh, &b_with_fresh));\n-        debug2!(\"sig0 = {}\", sig0.inf_str(self.infcx));\n+        debug!(\"sig0 = {}\", sig0.inf_str(self.infcx));\n \n         // Generalize the regions appearing in sig0 if possible\n         let new_vars =\n@@ -154,7 +154,7 @@ impl Combine for Lub {\n                              r0: ty::Region) -> ty::Region {\n             // Regions that pre-dated the LUB computation stay as they are.\n             if !is_var_in_set(new_vars, r0) {\n-                debug2!(\"generalize_region(r0={:?}): not new variable\", r0);\n+                debug!(\"generalize_region(r0={:?}): not new variable\", r0);\n                 return r0;\n             }\n \n@@ -164,7 +164,7 @@ impl Combine for Lub {\n             // *related* to regions that pre-date the LUB computation\n             // stay as they are.\n             if !tainted.iter().all(|r| is_var_in_set(new_vars, *r)) {\n-                debug2!(\"generalize_region(r0={:?}): \\\n+                debug!(\"generalize_region(r0={:?}): \\\n                         non-new-variables found in {:?}\",\n                        r0, tainted);\n                 return r0;\n@@ -179,7 +179,7 @@ impl Combine for Lub {\n             do list::each(a_isr) |pair| {\n                 let (a_br, a_r) = *pair;\n                 if tainted.iter().any(|x| x == &a_r) {\n-                    debug2!(\"generalize_region(r0={:?}): \\\n+                    debug!(\"generalize_region(r0={:?}): \\\n                             replacing with {:?}, tainted={:?}\",\n                            r0, a_br, tainted);\n                     ret = Some(ty::re_bound(a_br));"}, {"sha": "487eb4c32890e9f267c8aebcf57dbe9fb163f7e8", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -285,7 +285,7 @@ pub fn common_supertype(cx: @mut InferCtxt,\n      * not possible, reports an error and returns ty::err.\n      */\n \n-    debug2!(\"common_supertype({}, {})\", a.inf_str(cx), b.inf_str(cx));\n+    debug!(\"common_supertype({}, {})\", a.inf_str(cx), b.inf_str(cx));\n \n     let trace = TypeTrace {\n         origin: origin,\n@@ -311,7 +311,7 @@ pub fn mk_subty(cx: @mut InferCtxt,\n                 a: ty::t,\n                 b: ty::t)\n              -> ures {\n-    debug2!(\"mk_subty({} <: {})\", a.inf_str(cx), b.inf_str(cx));\n+    debug!(\"mk_subty({} <: {})\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n             let trace = TypeTrace {\n@@ -324,7 +324,7 @@ pub fn mk_subty(cx: @mut InferCtxt,\n }\n \n pub fn can_mk_subty(cx: @mut InferCtxt, a: ty::t, b: ty::t) -> ures {\n-    debug2!(\"can_mk_subty({} <: {})\", a.inf_str(cx), b.inf_str(cx));\n+    debug!(\"can_mk_subty({} <: {})\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.probe {\n             let trace = TypeTrace {\n@@ -341,7 +341,7 @@ pub fn mk_subr(cx: @mut InferCtxt,\n                origin: SubregionOrigin,\n                a: ty::Region,\n                b: ty::Region) {\n-    debug2!(\"mk_subr({} <: {})\", a.inf_str(cx), b.inf_str(cx));\n+    debug!(\"mk_subr({} <: {})\", a.inf_str(cx), b.inf_str(cx));\n     cx.region_vars.start_snapshot();\n     cx.region_vars.make_subregion(origin, a, b);\n     cx.region_vars.commit();\n@@ -353,7 +353,7 @@ pub fn mk_eqty(cx: @mut InferCtxt,\n                a: ty::t,\n                b: ty::t)\n             -> ures {\n-    debug2!(\"mk_eqty({} <: {})\", a.inf_str(cx), b.inf_str(cx));\n+    debug!(\"mk_eqty({} <: {})\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n             let trace = TypeTrace {\n@@ -373,7 +373,7 @@ pub fn mk_sub_trait_refs(cx: @mut InferCtxt,\n                          b: @ty::TraitRef)\n     -> ures\n {\n-    debug2!(\"mk_sub_trait_refs({} <: {})\",\n+    debug!(\"mk_sub_trait_refs({} <: {})\",\n            a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n@@ -403,7 +403,7 @@ pub fn mk_coercety(cx: @mut InferCtxt,\n                    a: ty::t,\n                    b: ty::t)\n                 -> CoerceResult {\n-    debug2!(\"mk_coercety({} -> {})\", a.inf_str(cx), b.inf_str(cx));\n+    debug!(\"mk_coercety({} -> {})\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n             let trace = TypeTrace {\n@@ -416,7 +416,7 @@ pub fn mk_coercety(cx: @mut InferCtxt,\n }\n \n pub fn can_mk_coercety(cx: @mut InferCtxt, a: ty::t, b: ty::t) -> ures {\n-    debug2!(\"can_mk_coercety({} -> {})\", a.inf_str(cx), b.inf_str(cx));\n+    debug!(\"can_mk_coercety({} -> {})\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.probe {\n             let trace = TypeTrace {\n@@ -539,7 +539,7 @@ impl InferCtxt {\n     }\n \n     pub fn rollback_to(&mut self, snapshot: &Snapshot) {\n-        debug2!(\"rollback!\");\n+        debug!(\"rollback!\");\n         rollback_to(&mut self.ty_var_bindings, snapshot.ty_var_bindings_len);\n \n         rollback_to(&mut self.int_var_bindings,\n@@ -554,7 +554,7 @@ impl InferCtxt {\n     pub fn commit<T,E>(@mut self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n         assert!(!self.in_snapshot());\n \n-        debug2!(\"commit()\");\n+        debug!(\"commit()\");\n         do indent {\n             let r = self.try(|| f());\n \n@@ -567,7 +567,7 @@ impl InferCtxt {\n \n     /// Execute `f`, unroll bindings on failure\n     pub fn try<T,E>(@mut self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n-        debug2!(\"try()\");\n+        debug!(\"try()\");\n         do indent {\n             let snapshot = self.start_snapshot();\n             let r = f();\n@@ -581,7 +581,7 @@ impl InferCtxt {\n \n     /// Execute `f` then unroll any bindings it creates\n     pub fn probe<T,E>(@mut self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n-        debug2!(\"probe()\");\n+        debug!(\"probe()\");\n         do indent {\n             let snapshot = self.start_snapshot();\n             let r = f();\n@@ -725,7 +725,7 @@ impl InferCtxt {\n                                                 expected_ty: Option<ty::t>,\n                                                 actual_ty: ~str,\n                                                 err: Option<&ty::type_err>) {\n-        debug2!(\"hi! expected_ty = {:?}, actual_ty = {}\", expected_ty, actual_ty);\n+        debug!(\"hi! expected_ty = {:?}, actual_ty = {}\", expected_ty, actual_ty);\n \n         let error_str = do err.map_default(~\"\") |t_err| {\n             format!(\" ({})\", ty::type_err_to_str(self.tcx, t_err))\n@@ -792,7 +792,7 @@ impl InferCtxt {\n             replace_bound_regions_in_fn_sig(self.tcx, @Nil, None, fsig, |br| {\n                 let rvar = self.next_region_var(\n                     BoundRegionInFnType(trace.origin.span(), br));\n-                debug2!(\"Bound region {} maps to {:?}\",\n+                debug!(\"Bound region {} maps to {:?}\",\n                        bound_region_to_str(self.tcx, \"\", false, br),\n                        rvar);\n                 rvar"}, {"sha": "68c5ec3b7d66dc73aa5004965bdbedbc60de09b6", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -130,7 +130,7 @@ impl RegionVarBindings {\n     }\n \n     pub fn start_snapshot(&mut self) -> uint {\n-        debug2!(\"RegionVarBindings: snapshot()={}\", self.undo_log.len());\n+        debug!(\"RegionVarBindings: snapshot()={}\", self.undo_log.len());\n         if self.in_snapshot() {\n             self.undo_log.len()\n         } else {\n@@ -140,17 +140,17 @@ impl RegionVarBindings {\n     }\n \n     pub fn commit(&mut self) {\n-        debug2!(\"RegionVarBindings: commit()\");\n+        debug!(\"RegionVarBindings: commit()\");\n         while self.undo_log.len() > 0 {\n             self.undo_log.pop();\n         }\n     }\n \n     pub fn rollback_to(&mut self, snapshot: uint) {\n-        debug2!(\"RegionVarBindings: rollback_to({})\", snapshot);\n+        debug!(\"RegionVarBindings: rollback_to({})\", snapshot);\n         while self.undo_log.len() > snapshot {\n             let undo_item = self.undo_log.pop();\n-            debug2!(\"undo_item={:?}\", undo_item);\n+            debug!(\"undo_item={:?}\", undo_item);\n             match undo_item {\n               Snapshot => {}\n               AddVar(vid) => {\n@@ -181,7 +181,7 @@ impl RegionVarBindings {\n         if self.in_snapshot() {\n             self.undo_log.push(AddVar(vid));\n         }\n-        debug2!(\"created new region variable {:?} with origin {:?}\",\n+        debug!(\"created new region variable {:?} with origin {:?}\",\n                vid, origin.repr(self.tcx));\n         return vid;\n     }\n@@ -218,7 +218,7 @@ impl RegionVarBindings {\n         // cannot add constraints once regions are resolved\n         assert!(self.values.is_empty());\n \n-        debug2!(\"RegionVarBindings: add_constraint({:?})\", constraint);\n+        debug!(\"RegionVarBindings: add_constraint({:?})\", constraint);\n \n         if self.constraints.insert(constraint, origin) {\n             if self.in_snapshot() {\n@@ -234,7 +234,7 @@ impl RegionVarBindings {\n         // cannot add constraints once regions are resolved\n         assert!(self.values.is_empty());\n \n-        debug2!(\"RegionVarBindings: make_subregion({:?}, {:?})\", sub, sup);\n+        debug!(\"RegionVarBindings: make_subregion({:?}, {:?})\", sub, sup);\n         match (sub, sup) {\n           (re_infer(ReVar(sub_id)), re_infer(ReVar(sup_id))) => {\n             self.add_constraint(ConstrainVarSubVar(sub_id, sup_id), origin);\n@@ -269,7 +269,7 @@ impl RegionVarBindings {\n         // cannot add constraints once regions are resolved\n         assert!(self.values.is_empty());\n \n-        debug2!(\"RegionVarBindings: lub_regions({:?}, {:?})\", a, b);\n+        debug!(\"RegionVarBindings: lub_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n             (re_static, _) | (_, re_static) => {\n                 re_static // nothing lives longer than static\n@@ -292,7 +292,7 @@ impl RegionVarBindings {\n         // cannot add constraints once regions are resolved\n         assert!(self.values.is_empty());\n \n-        debug2!(\"RegionVarBindings: glb_regions({:?}, {:?})\", a, b);\n+        debug!(\"RegionVarBindings: glb_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n             (re_static, r) | (r, re_static) => {\n                 // static lives longer than everything else\n@@ -317,7 +317,7 @@ impl RegionVarBindings {\n         }\n \n         let v = self.values.with_ref(|values| values[rid.to_uint()]);\n-        debug2!(\"RegionVarBindings: resolve_var({:?}={})={:?}\",\n+        debug!(\"RegionVarBindings: resolve_var({:?}={})={:?}\",\n                rid, rid.to_uint(), v);\n         match v {\n             Value(r) => r,\n@@ -367,7 +367,7 @@ impl RegionVarBindings {\n         }\n         relate(self, a, re_infer(ReVar(c)));\n         relate(self, b, re_infer(ReVar(c)));\n-        debug2!(\"combine_vars() c={:?}\", c);\n+        debug!(\"combine_vars() c={:?}\", c);\n         re_infer(ReVar(c))\n     }\n \n@@ -390,7 +390,7 @@ impl RegionVarBindings {\n          * regions.\n          */\n \n-        debug2!(\"tainted(snapshot={}, r0={:?})\", snapshot, r0);\n+        debug!(\"tainted(snapshot={}, r0={:?})\", snapshot, r0);\n         let _indenter = indenter();\n \n         let undo_len = self.undo_log.len();\n@@ -404,7 +404,7 @@ impl RegionVarBindings {\n             // nb: can't use uint::range() here because result_set grows\n             let r = result_set[result_index];\n \n-            debug2!(\"result_index={}, r={:?}\", result_index, r);\n+            debug!(\"result_index={}, r={:?}\", result_index, r);\n \n             let mut undo_index = snapshot;\n             while undo_index < undo_len {\n@@ -469,7 +469,7 @@ impl RegionVarBindings {\n     errors are reported.\n     */\n     pub fn resolve_regions(&mut self) -> OptVec<RegionResolutionError> {\n-        debug2!(\"RegionVarBindings: resolve_regions()\");\n+        debug!(\"RegionVarBindings: resolve_regions()\");\n         let mut errors = opt_vec::Empty;\n         let v = self.infer_variable_values(&mut errors);\n         self.values.put_back(v);\n@@ -582,7 +582,7 @@ impl RegionVarBindings {\n                             a: Region,\n                             b: Region)\n                          -> cres<Region> {\n-        debug2!(\"glb_concrete_regions({:?}, {:?})\", a, b);\n+        debug!(\"glb_concrete_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n             (re_static, r) | (r, re_static) => {\n                 // static lives longer than everything else\n@@ -691,7 +691,7 @@ impl RegionVarBindings {\n         // scopes or two free regions.  So, if one of\n         // these scopes is a subscope of the other, return\n         // it.  Otherwise fail.\n-        debug2!(\"intersect_scopes(scope_a={:?}, scope_b={:?}, region_a={:?}, region_b={:?})\",\n+        debug!(\"intersect_scopes(scope_a={:?}, scope_b={:?}, region_a={:?}, region_b={:?})\",\n                scope_a, scope_b, region_a, region_b);\n         let rm = self.tcx.region_maps;\n         match rm.nearest_common_ancestor(scope_a, scope_b) {\n@@ -778,13 +778,13 @@ impl RegionVarBindings {\n                    b_vid: RegionVid,\n                    b_data: &mut VarData)\n                    -> bool {\n-        debug2!(\"expand_node({:?}, {:?} == {:?})\",\n+        debug!(\"expand_node({:?}, {:?} == {:?})\",\n                a_region, b_vid, b_data.value);\n \n         b_data.classification = Expanding;\n         match b_data.value {\n           NoValue => {\n-            debug2!(\"Setting initial value of {:?} to {:?}\", b_vid, a_region);\n+            debug!(\"Setting initial value of {:?} to {:?}\", b_vid, a_region);\n \n             b_data.value = Value(a_region);\n             return true;\n@@ -796,7 +796,7 @@ impl RegionVarBindings {\n                 return false;\n             }\n \n-            debug2!(\"Expanding value of {:?} from {:?} to {:?}\",\n+            debug!(\"Expanding value of {:?} from {:?} to {:?}\",\n                    b_vid, cur_region, lub);\n \n             b_data.value = Value(lub);\n@@ -843,7 +843,7 @@ impl RegionVarBindings {\n                      a_data: &mut VarData,\n                      b_region: Region)\n                      -> bool {\n-        debug2!(\"contract_node({:?} == {:?}/{:?}, {:?})\",\n+        debug!(\"contract_node({:?} == {:?}/{:?}, {:?})\",\n                a_vid, a_data.value, a_data.classification, b_region);\n \n         return match a_data.value {\n@@ -876,7 +876,7 @@ impl RegionVarBindings {\n                       b_region: Region)\n                    -> bool {\n             if !this.is_subregion_of(a_region, b_region) {\n-                debug2!(\"Setting {:?} to ErrorValue: {:?} not subregion of {:?}\",\n+                debug!(\"Setting {:?} to ErrorValue: {:?} not subregion of {:?}\",\n                        a_vid, a_region, b_region);\n                 a_data.value = ErrorValue;\n             }\n@@ -894,14 +894,14 @@ impl RegionVarBindings {\n                     if glb == a_region {\n                         false\n                     } else {\n-                        debug2!(\"Contracting value of {:?} from {:?} to {:?}\",\n+                        debug!(\"Contracting value of {:?} from {:?} to {:?}\",\n                                a_vid, a_region, glb);\n                         a_data.value = Value(glb);\n                         true\n                     }\n                 }\n                 Err(_) => {\n-                    debug2!(\"Setting {:?} to ErrorValue: no glb of {:?}, {:?}\",\n+                    debug!(\"Setting {:?} to ErrorValue: no glb of {:?}, {:?}\",\n                            a_vid, a_region, b_region);\n                     a_data.value = ErrorValue;\n                     false\n@@ -930,7 +930,7 @@ impl RegionVarBindings {\n                 continue;\n             }\n \n-            debug2!(\"ConcreteFailure: !(sub <= sup): sub={:?}, sup={:?}\",\n+            debug!(\"ConcreteFailure: !(sub <= sup): sub={:?}, sup={:?}\",\n                    sub, sup);\n             let origin = self.constraints.get_copy(constraint);\n             errors.push(ConcreteFailure(origin, sub, sup));\n@@ -943,7 +943,7 @@ impl RegionVarBindings {\n         errors: &mut OptVec<RegionResolutionError>)\n         -> ~[VarValue]\n     {\n-        debug2!(\"extract_values_and_collect_conflicts()\");\n+        debug!(\"extract_values_and_collect_conflicts()\");\n \n         // This is the best way that I have found to suppress\n         // duplicate and related errors. Basically we keep a set of\n@@ -1182,7 +1182,7 @@ impl RegionVarBindings {\n                 state.dup_found = true;\n             }\n \n-            debug2!(\"collect_concrete_regions(orig_node_idx={:?}, node_idx={:?}, \\\n+            debug!(\"collect_concrete_regions(orig_node_idx={:?}, node_idx={:?}, \\\n                     classification={:?})\",\n                    orig_node_idx, node_idx, classification);\n \n@@ -1204,7 +1204,7 @@ impl RegionVarBindings {\n                          graph: &RegionGraph,\n                          source_vid: RegionVid,\n                          dir: Direction) {\n-            debug2!(\"process_edges(source_vid={:?}, dir={:?})\", source_vid, dir);\n+            debug!(\"process_edges(source_vid={:?}, dir={:?})\", source_vid, dir);\n \n             let source_node_index = NodeIndex(source_vid.to_uint());\n             do graph.each_adjacent_edge(source_node_index, dir) |_, edge| {\n@@ -1240,17 +1240,17 @@ impl RegionVarBindings {\n         while changed {\n             changed = false;\n             iteration += 1;\n-            debug2!(\"---- {} Iteration \\\\#{}\", tag, iteration);\n+            debug!(\"---- {} Iteration \\\\#{}\", tag, iteration);\n             for (constraint, _) in self.constraints.iter() {\n                 let edge_changed = body(constraint);\n                 if edge_changed {\n-                    debug2!(\"Updated due to constraint {}\",\n+                    debug!(\"Updated due to constraint {}\",\n                            constraint.repr(self.tcx));\n                     changed = true;\n                 }\n             }\n         }\n-        debug2!(\"---- {} Complete after {} iteration(s)\", tag, iteration);\n+        debug!(\"---- {} Complete after {} iteration(s)\", tag, iteration);\n     }\n \n }"}, {"sha": "564fcb76dc73b57ec688500de4c10b08d256b283", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -104,7 +104,7 @@ impl ResolveState {\n     pub fn resolve_type_chk(&mut self, typ: ty::t) -> fres<ty::t> {\n         self.err = None;\n \n-        debug2!(\"Resolving {} (modes={:x})\",\n+        debug!(\"Resolving {} (modes={:x})\",\n                ty_to_str(self.infcx.tcx, typ),\n                self.modes);\n \n@@ -116,7 +116,7 @@ impl ResolveState {\n         assert!(self.v_seen.is_empty());\n         match self.err {\n           None => {\n-            debug2!(\"Resolved to {} + {} (modes={:x})\",\n+            debug!(\"Resolved to {} + {} (modes={:x})\",\n                    ty_to_str(self.infcx.tcx, rty),\n                    ty_to_str(self.infcx.tcx, rty),\n                    self.modes);\n@@ -137,7 +137,7 @@ impl ResolveState {\n     }\n \n     pub fn resolve_type(&mut self, typ: ty::t) -> ty::t {\n-        debug2!(\"resolve_type({})\", typ.inf_str(self.infcx));\n+        debug!(\"resolve_type({})\", typ.inf_str(self.infcx));\n         let _i = indenter();\n \n         if !ty::type_needs_infer(typ) {\n@@ -179,7 +179,7 @@ impl ResolveState {\n     }\n \n     pub fn resolve_region(&mut self, orig: ty::Region) -> ty::Region {\n-        debug2!(\"Resolve_region({})\", orig.inf_str(self.infcx));\n+        debug!(\"Resolve_region({})\", orig.inf_str(self.infcx));\n         match orig {\n           ty::re_infer(ty::ReVar(rid)) => self.resolve_region_var(rid),\n           _ => orig"}, {"sha": "e5afefe0c716471b18bb503f35a6389df9129aaa", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -56,7 +56,7 @@ impl Combine for Sub {\n     }\n \n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n-        debug2!(\"{}.regions({}, {})\",\n+        debug!(\"{}.regions({}, {})\",\n                self.tag(),\n                a.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n@@ -65,7 +65,7 @@ impl Combine for Sub {\n     }\n \n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n-        debug2!(\"mts({} <: {})\", a.inf_str(self.infcx), b.inf_str(self.infcx));\n+        debug!(\"mts({} <: {})\", a.inf_str(self.infcx), b.inf_str(self.infcx));\n \n         if a.mutbl != b.mutbl {\n             return Err(ty::terr_mutability);\n@@ -110,7 +110,7 @@ impl Combine for Sub {\n     }\n \n     fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n-        debug2!(\"{}.tys({}, {})\", self.tag(),\n+        debug!(\"{}.tys({}, {})\", self.tag(),\n                a.inf_str(self.infcx), b.inf_str(self.infcx));\n         if a == b { return Ok(a); }\n         let _indenter = indenter();\n@@ -143,7 +143,7 @@ impl Combine for Sub {\n     }\n \n     fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n-        debug2!(\"fn_sigs(a={}, b={})\",\n+        debug!(\"fn_sigs(a={}, b={})\",\n                a.inf_str(self.infcx), b.inf_str(self.infcx));\n         let _indenter = indenter();\n \n@@ -172,15 +172,15 @@ impl Combine for Sub {\n             do replace_bound_regions_in_fn_sig(self.infcx.tcx, @Nil,\n                                               None, b) |br| {\n                 let skol = self.infcx.region_vars.new_skolemized(br);\n-                debug2!(\"Bound region {} skolemized to {:?}\",\n+                debug!(\"Bound region {} skolemized to {:?}\",\n                        bound_region_to_str(self.infcx.tcx, \"\", false, br),\n                        skol);\n                 skol\n             }\n         };\n \n-        debug2!(\"a_sig={}\", a_sig.inf_str(self.infcx));\n-        debug2!(\"b_sig={}\", b_sig.inf_str(self.infcx));\n+        debug!(\"a_sig={}\", a_sig.inf_str(self.infcx));\n+        debug!(\"b_sig={}\", b_sig.inf_str(self.infcx));\n \n         // Compare types now that bound regions have been replaced.\n         let sig = if_ok!(super_fn_sigs(self, &a_sig, &b_sig));"}, {"sha": "48660ab64e591b541a0bad53009f7e0a039786e0", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -100,7 +100,7 @@ impl Env {\n         return match search_mod(self, &self.crate.node.module, 0, names) {\n             Some(id) => id,\n             None => {\n-                fail2!(\"No item found: `%s`\", names.connect(\"::\"));\n+                fail!(\"No item found: `%s`\", names.connect(\"::\"));\n             }\n         };\n \n@@ -153,15 +153,15 @@ impl Env {\n \n     pub fn assert_subtype(&self, a: ty::t, b: ty::t) {\n         if !self.is_subtype(a, b) {\n-            fail2!(\"%s is not a subtype of %s, but it should be\",\n+            fail!(\"%s is not a subtype of %s, but it should be\",\n                   self.ty_to_str(a),\n                   self.ty_to_str(b));\n         }\n     }\n \n     pub fn assert_not_subtype(&self, a: ty::t, b: ty::t) {\n         if self.is_subtype(a, b) {\n-            fail2!(\"%s is a subtype of %s, but it shouldn't be\",\n+            fail!(\"%s is a subtype of %s, but it shouldn't be\",\n                   self.ty_to_str(a),\n                   self.ty_to_str(b));\n         }\n@@ -223,12 +223,12 @@ impl Env {\n     pub fn glb() -> Glb { Glb(self.infcx.combine_fields(true, dummy_sp())) }\n \n     pub fn resolve_regions(exp_count: uint) {\n-        debug2!(\"resolve_regions(%u)\", exp_count);\n+        debug!(\"resolve_regions(%u)\", exp_count);\n \n         self.infcx.resolve_regions();\n         if self.err_messages.len() != exp_count {\n             for msg in self.err_messages.iter() {\n-                debug2!(\"Error encountered: %s\", *msg);\n+                debug!(\"Error encountered: %s\", *msg);\n             }\n             format!(\"Resolving regions encountered %u errors but expected %u!\",\n                  self.err_messages.len(),\n@@ -240,7 +240,7 @@ impl Env {\n     pub fn check_lub(&self, t1: ty::t, t2: ty::t, t_lub: ty::t) {\n         match self.lub().tys(t1, t2) {\n             Err(e) => {\n-                fail2!(\"Unexpected error computing LUB: %?\", e)\n+                fail!(\"Unexpected error computing LUB: %?\", e)\n             }\n             Ok(t) => {\n                 self.assert_eq(t, t_lub);\n@@ -256,13 +256,13 @@ impl Env {\n \n     /// Checks that `GLB(t1,t2) == t_glb`\n     pub fn check_glb(&self, t1: ty::t, t2: ty::t, t_glb: ty::t) {\n-        debug2!(\"check_glb(t1=%s, t2=%s, t_glb=%s)\",\n+        debug!(\"check_glb(t1=%s, t2=%s, t_glb=%s)\",\n                self.ty_to_str(t1),\n                self.ty_to_str(t2),\n                self.ty_to_str(t_glb));\n         match self.glb().tys(t1, t2) {\n             Err(e) => {\n-                fail2!(\"Unexpected error computing LUB: %?\", e)\n+                fail!(\"Unexpected error computing LUB: %?\", e)\n             }\n             Ok(t) => {\n                 self.assert_eq(t, t_glb);\n@@ -281,7 +281,7 @@ impl Env {\n         match self.lub().tys(t1, t2) {\n             Err(_) => {}\n             Ok(t) => {\n-                fail2!(\"Unexpected success computing LUB: %?\", self.ty_to_str(t))\n+                fail!(\"Unexpected success computing LUB: %?\", self.ty_to_str(t))\n             }\n         }\n     }\n@@ -291,7 +291,7 @@ impl Env {\n         match self.glb().tys(t1, t2) {\n             Err(_) => {}\n             Ok(t) => {\n-                fail2!(\"Unexpected success computing GLB: %?\", self.ty_to_str(t))\n+                fail!(\"Unexpected success computing GLB: %?\", self.ty_to_str(t))\n             }\n         }\n     }"}, {"sha": "b58a526b7ea94e1d10941666a804edbd1dce4555", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -116,7 +116,7 @@ impl UnifyInferCtxtMethods for InferCtxt {\n          * Sets the value for `vid` to `new_v`.  `vid` MUST be a root node!\n          */\n \n-        debug2!(\"Updating variable {} to {}\",\n+        debug!(\"Updating variable {} to {}\",\n                vid.to_str(), new_v.inf_str(self));\n \n         let vb = UnifyVid::appropriate_vals_and_bindings(self);\n@@ -134,7 +134,7 @@ impl UnifyInferCtxtMethods for InferCtxt {\n         // Rank optimization: if you don't know what it is, check\n         // out <http://en.wikipedia.org/wiki/Disjoint-set_data_structure>\n \n-        debug2!(\"unify(node_a(id={:?}, rank={:?}), \\\n+        debug!(\"unify(node_a(id={:?}, rank={:?}), \\\n                 node_b(id={:?}, rank={:?}))\",\n                node_a.root, node_a.rank,\n                node_b.root, node_b.rank);"}, {"sha": "10005bfb2cb68cae39342397f60e8c757e435d9a", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -226,15 +226,15 @@ pub struct CrateCtxt {\n \n // Functions that write types into the node type table\n pub fn write_ty_to_tcx(tcx: ty::ctxt, node_id: ast::NodeId, ty: ty::t) {\n-    debug2!(\"write_ty_to_tcx({}, {})\", node_id, ppaux::ty_to_str(tcx, ty));\n+    debug!(\"write_ty_to_tcx({}, {})\", node_id, ppaux::ty_to_str(tcx, ty));\n     assert!(!ty::type_needs_infer(ty));\n     tcx.node_types.insert(node_id as uint, ty);\n }\n pub fn write_substs_to_tcx(tcx: ty::ctxt,\n                            node_id: ast::NodeId,\n                            substs: ~[ty::t]) {\n     if substs.len() > 0u {\n-        debug2!(\"write_substs_to_tcx({}, {:?})\", node_id,\n+        debug!(\"write_substs_to_tcx({}, {:?})\", node_id,\n                substs.map(|t| ppaux::ty_to_str(tcx, *t)));\n         assert!(substs.iter().all(|t| !ty::type_needs_infer(*t)));\n         tcx.node_type_substs.insert(node_id, substs);"}, {"sha": "1967122745dad5ebfaa98895dbebd991fd0fa8fd", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -235,7 +235,7 @@ impl RegionScope for TypeRscope {\n             None => {\n                 // if the self region is used, region parameterization should\n                 // have inferred that this type is RP\n-                fail2!(\"region parameterization should have inferred that \\\n+                fail!(\"region parameterization should have inferred that \\\n                         this type is RP\");\n             }\n             Some(ref region_parameterization) => {"}, {"sha": "8bdb518b621172b14eab513c025a87b4f6c23f48", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -392,7 +392,7 @@ pub fn monitor(f: ~fn(@diagnostic::Emitter)) {\n                 }\n             }\n             // Fail so the process returns a failure code\n-            fail2!();\n+            fail!();\n         }\n     }\n }"}, {"sha": "ecc53ae5f80615420ac576af45224f093d07576d", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -29,9 +29,9 @@ pub fn time<T, U>(do_it: bool, what: &str, u: U, f: &fn(U) -> T) -> T {\n pub fn indent<R>(op: &fn() -> R) -> R {\n     // Use in conjunction with the log post-processor like `src/etc/indenter`\n     // to make debug output more readable.\n-    debug2!(\">>\");\n+    debug!(\">>\");\n     let r = op();\n-    debug2!(\"<< (Result = {:?})\", r);\n+    debug!(\"<< (Result = {:?})\", r);\n     r\n }\n \n@@ -40,7 +40,7 @@ pub struct _indenter {\n }\n \n impl Drop for _indenter {\n-    fn drop(&mut self) { debug2!(\"<<\"); }\n+    fn drop(&mut self) { debug!(\"<<\"); }\n }\n \n pub fn _indenter(_i: ()) -> _indenter {\n@@ -50,7 +50,7 @@ pub fn _indenter(_i: ()) -> _indenter {\n }\n \n pub fn indenter() -> _indenter {\n-    debug2!(\">>\");\n+    debug!(\">>\");\n     _indenter(())\n }\n "}, {"sha": "6ee7f8c172743d403ca5b3bcca20f7ad8027a585", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -86,7 +86,7 @@ impl Clean<Crate> for visit_ast::RustdocVisitor {\n         Crate {\n             name: match maybe_meta {\n                 Some(x) => x.to_owned(),\n-                None => fail2!(\"rustdoc requires a \\\\#[link(name=\\\"foo\\\")] \\\n+                None => fail!(\"rustdoc requires a \\\\#[link(name=\\\"foo\\\")] \\\n                                 crate attribute\"),\n             },\n             module: Some(self.module.clean()),\n@@ -623,9 +623,9 @@ pub enum TypeKind {\n impl Clean<Type> for ast::Ty {\n     fn clean(&self) -> Type {\n         use syntax::ast::*;\n-        debug2!(\"cleaning type `{:?}`\", self);\n+        debug!(\"cleaning type `{:?}`\", self);\n         let codemap = local_data::get(super::ctxtkey, |x| *x.unwrap()).sess.codemap;\n-        debug2!(\"span corresponds to `{}`\", codemap.span_to_str(self.span));\n+        debug!(\"span corresponds to `{}`\", codemap.span_to_str(self.span));\n         match self.node {\n             ty_nil => Unit,\n             ty_ptr(ref m) => RawPointer(m.mutbl.clean(), ~m.ty.clean()),\n@@ -643,7 +643,7 @@ impl Clean<Type> for ast::Ty {\n             ty_closure(ref c) => Closure(~c.clean()),\n             ty_bare_fn(ref barefn) => BareFunction(~barefn.clean()),\n             ty_bot => Bottom,\n-            ref x => fail2!(\"Unimplemented type {:?}\", x),\n+            ref x => fail!(\"Unimplemented type {:?}\", x),\n         }\n     }\n }\n@@ -927,7 +927,7 @@ pub struct Static {\n \n impl Clean<Item> for doctree::Static {\n     fn clean(&self) -> Item {\n-        debug2!(\"claning static {}: {:?}\", self.name.clean(), self);\n+        debug!(\"claning static {}: {:?}\", self.name.clean(), self);\n         Item {\n             name: Some(self.name.clean()),\n             attrs: self.attrs.clean(),\n@@ -1107,13 +1107,13 @@ trait ToSource {\n \n impl ToSource for syntax::codemap::Span {\n     fn to_src(&self) -> ~str {\n-        debug2!(\"converting span {:?} to snippet\", self.clean());\n+        debug!(\"converting span {:?} to snippet\", self.clean());\n         let cm = local_data::get(super::ctxtkey, |x| x.unwrap().clone()).sess.codemap.clone();\n         let sn = match cm.span_to_snippet(*self) {\n             Some(x) => x,\n             None    => ~\"\"\n         };\n-        debug2!(\"got snippet {}\", sn);\n+        debug!(\"got snippet {}\", sn);\n         sn\n     }\n }\n@@ -1139,17 +1139,17 @@ fn name_from_pat(p: &ast::Pat) -> ~str {\n         PatWild => ~\"_\",\n         PatIdent(_, ref p, _) => path_to_str(p),\n         PatEnum(ref p, _) => path_to_str(p),\n-        PatStruct(*) => fail2!(\"tried to get argument name from pat_struct, \\\n+        PatStruct(*) => fail!(\"tried to get argument name from pat_struct, \\\n                                 which is not allowed in function arguments\"),\n         PatTup(*) => ~\"(tuple arg NYI)\",\n         PatBox(p) => name_from_pat(p),\n         PatUniq(p) => name_from_pat(p),\n         PatRegion(p) => name_from_pat(p),\n-        PatLit(*) => fail2!(\"tried to get argument name from pat_lit, \\\n+        PatLit(*) => fail!(\"tried to get argument name from pat_lit, \\\n                             which is not allowed in function arguments\"),\n-        PatRange(*) => fail2!(\"tried to get argument name from pat_range, \\\n+        PatRange(*) => fail!(\"tried to get argument name from pat_range, \\\n                               which is not allowed in function arguments\"),\n-        PatVec(*) => fail2!(\"tried to get argument name from pat_vec, \\\n+        PatVec(*) => fail!(\"tried to get argument name from pat_vec, \\\n                              which is not allowed in function arguments\")\n     }\n }\n@@ -1158,14 +1158,14 @@ fn name_from_pat(p: &ast::Pat) -> ~str {\n fn resolve_type(path: Path, tpbs: Option<~[TyParamBound]>,\n                 id: ast::NodeId) -> Type {\n     let cx = local_data::get(super::ctxtkey, |x| *x.unwrap());\n-    debug2!(\"searching for {:?} in defmap\", id);\n+    debug!(\"searching for {:?} in defmap\", id);\n     let d = match cx.tycx.def_map.find(&id) {\n         Some(k) => k,\n         None => {\n             let ctxt = local_data::get(super::ctxtkey, |x| *x.unwrap());\n-            debug2!(\"could not find {:?} in defmap (`{}`)\", id,\n+            debug!(\"could not find {:?} in defmap (`{}`)\", id,\n                    syntax::ast_map::node_id_to_str(ctxt.tycx.items, id, ctxt.sess.intr()));\n-            fail2!(\"Unexpected failure: unresolved id not in defmap (this is a bug!)\")\n+            fail!(\"Unexpected failure: unresolved id not in defmap (this is a bug!)\")\n         }\n     };\n \n@@ -1174,7 +1174,7 @@ fn resolve_type(path: Path, tpbs: Option<~[TyParamBound]>,\n         ast::DefSelf(i) | ast::DefSelfTy(i) => return Self(i),\n         ast::DefTy(i) => (i, TypeEnum),\n         ast::DefTrait(i) => {\n-            debug2!(\"saw DefTrait in def_to_id\");\n+            debug!(\"saw DefTrait in def_to_id\");\n             (i, TypeTrait)\n         },\n         ast::DefPrimTy(p) => match p {\n@@ -1185,10 +1185,10 @@ fn resolve_type(path: Path, tpbs: Option<~[TyParamBound]>,\n         ast::DefTyParam(i, _) => return Generic(i.node),\n         ast::DefStruct(i) => (i, TypeStruct),\n         ast::DefTyParamBinder(i) => {\n-            debug2!(\"found a typaram_binder, what is it? {}\", i);\n+            debug!(\"found a typaram_binder, what is it? {}\", i);\n             return TyParamBinder(i);\n         },\n-        x => fail2!(\"resolved type maps to a weird def {:?}\", x),\n+        x => fail!(\"resolved type maps to a weird def {:?}\", x),\n     };\n     if ast_util::is_local(def_id) {\n         ResolvedPath{ path: path, typarams: tpbs, id: def_id.node }"}, {"sha": "b6e16720459ea85a75f98190890d63998971cb7b", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -84,17 +84,17 @@ fn get_ast_and_resolve(cpath: &Path,\n                                       .to_owned_vec());\n     }\n \n-    debug2!(\"crate: {:?}\", crate);\n+    debug!(\"crate: {:?}\", crate);\n     return (DocContext { crate: crate, tycx: ty_cx, sess: sess },\n             CrateAnalysis { reexports: reexports, exported_items: exported_items });\n }\n \n pub fn run_core (libs: ~[Path], path: &Path) -> (clean::Crate, CrateAnalysis) {\n     let (ctxt, analysis) = get_ast_and_resolve(path, libs);\n     let ctxt = @ctxt;\n-    debug2!(\"defmap:\");\n+    debug!(\"defmap:\");\n     for (k, v) in ctxt.tycx.def_map.iter() {\n-        debug2!(\"{:?}: {:?}\", k, v);\n+        debug!(\"{:?}: {:?}\", k, v);\n     }\n     local_data::set(super::ctxtkey, ctxt);\n "}, {"sha": "e92d159b5a15d521d9913888b03ab47afa5d82d1", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -291,7 +291,7 @@ pub fn run(mut crate: clean::Crate, dst: Path) {\n \n     // Render all source files (this may turn into a giant no-op)\n     {\n-        info2!(\"emitting source files\");\n+        info!(\"emitting source files\");\n         let dst = cx.dst.join(\"src\");\n         mkdir(&dst);\n         let dst = dst.join(crate.name.as_slice());\n@@ -323,9 +323,9 @@ fn write(dst: Path, contents: &str) {\n /// skipping if the directory already exists.\n fn mkdir(path: &Path) {\n     do io::io_error::cond.trap(|err| {\n-        error2!(\"Couldn't create directory `{}`: {}\",\n+        error!(\"Couldn't create directory `{}`: {}\",\n                 path.display(), err.desc);\n-        fail2!()\n+        fail!()\n     }).inside {\n         if !path.is_dir() {\n             file::mkdir(path);\n@@ -647,7 +647,7 @@ impl Context {\n     /// sure it always points to the top (relatively)\n     fn recurse<T>(&mut self, s: ~str, f: &fn(&mut Context) -> T) -> T {\n         if s.len() == 0 {\n-            fail2!(\"what {:?}\", self);\n+            fail!(\"what {:?}\", self);\n         }\n         let prev = self.dst.clone();\n         self.dst.push(s.as_slice());\n@@ -679,7 +679,7 @@ impl Context {\n         let workers = match os::getenv(\"RUSTDOC_WORKERS\") {\n             Some(s) => {\n                 match from_str::<uint>(s) {\n-                    Some(n) => n, None => fail2!(\"{} not a number\", s)\n+                    Some(n) => n, None => fail!(\"{} not a number\", s)\n                 }\n             }\n             None => 10,\n@@ -974,7 +974,7 @@ fn document(w: &mut io::Writer, item: &clean::Item) {\n fn item_module(w: &mut io::Writer, cx: &Context,\n                item: &clean::Item, items: &[clean::Item]) {\n     document(w, item);\n-    debug2!(\"{:?}\", items);\n+    debug!(\"{:?}\", items);\n     let mut indices = vec::from_fn(items.len(), |i| i);\n \n     fn lt(i1: &clean::Item, i2: &clean::Item, idx1: uint, idx2: uint) -> bool {\n@@ -1013,12 +1013,12 @@ fn item_module(w: &mut io::Writer, cx: &Context,\n         }\n     }\n \n-    debug2!(\"{:?}\", indices);\n+    debug!(\"{:?}\", indices);\n     do sort::quick_sort(indices) |&i1, &i2| {\n         lt(&items[i1], &items[i2], i1, i2)\n     }\n \n-    debug2!(\"{:?}\", indices);\n+    debug!(\"{:?}\", indices);\n     let mut curty = \"\";\n     for &idx in indices.iter() {\n         let myitem = &items[idx];"}, {"sha": "1e7c42455f241291eac5e8773164bcd29e59b732", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -34,7 +34,7 @@ pub fn strip_hidden(crate: clean::Crate) -> plugins::PluginResult {\n                         for innerattr in l.iter() {\n                             match innerattr {\n                                 &clean::Word(ref s) if \"hidden\" == *s => {\n-                                    debug2!(\"found one in strip_hidden; removing\");\n+                                    debug!(\"found one in strip_hidden; removing\");\n                                     return None;\n                                 },\n                                 _ => (),"}, {"sha": "ddf686a3905d49ec6434b3b1894499e8b15b6d15", "filename": "src/librustdoc/rustdoc.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Frustdoc.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -134,7 +134,7 @@ pub fn main_args(args: &[~str]) -> int {\n         }\n     };\n \n-    info2!(\"going to format\");\n+    info!(\"going to format\");\n     let started = time::precise_time_ns();\n     let output = matches.opt_str(\"o\").map(|s| Path::new(s));\n     match matches.opt_str(\"w\") {\n@@ -150,7 +150,7 @@ pub fn main_args(args: &[~str]) -> int {\n         }\n     }\n     let ended = time::precise_time_ns();\n-    info2!(\"Took {:.03f}s\", (ended as f64 - started as f64) / 1e9f64);\n+    info!(\"Took {:.03f}s\", (ended as f64 - started as f64) / 1e9f64);\n \n     return 0;\n }\n@@ -192,12 +192,12 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n     // First, parse the crate and extract all relevant information.\n     let libs = Cell::new(matches.opt_strs(\"L\").map(|s| Path::new(s.as_slice())));\n     let cr = Cell::new(Path::new(cratefile));\n-    info2!(\"starting to run rustc\");\n+    info!(\"starting to run rustc\");\n     let (crate, analysis) = do std::task::try {\n         let cr = cr.take();\n         core::run_core(libs.take(), &cr)\n     }.unwrap();\n-    info2!(\"finished with rustc\");\n+    info!(\"finished with rustc\");\n     local_data::set(analysiskey, analysis);\n \n     // Process all of the crate attributes, extracting plugin metadata along\n@@ -238,19 +238,19 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n         let plugin = match PASSES.iter().position(|&(p, _, _)| p == *pass) {\n             Some(i) => PASSES[i].n1(),\n             None => {\n-                error2!(\"unknown pass {}, skipping\", *pass);\n+                error!(\"unknown pass {}, skipping\", *pass);\n                 continue\n             },\n         };\n         pm.add_plugin(plugin);\n     }\n-    info2!(\"loading plugins...\");\n+    info!(\"loading plugins...\");\n     for pname in plugins.move_iter() {\n         pm.load_plugin(pname);\n     }\n \n     // Run everything!\n-    info2!(\"Executing passes/plugins\");\n+    info!(\"Executing passes/plugins\");\n     return pm.run_plugins(crate);\n }\n \n@@ -311,7 +311,7 @@ fn json_output(crate: clean::Crate, res: ~[plugins::PluginJson], dst: Path) {\n     };\n     let crate_json = match json::from_str(crate_json_str) {\n         Ok(j) => j,\n-        Err(_) => fail2!(\"Rust generated JSON is invalid??\")\n+        Err(_) => fail!(\"Rust generated JSON is invalid??\")\n     };\n \n     json.insert(~\"crate\", crate_json);"}, {"sha": "79ab752f295a84445ad291ef6f1edab80d849da7", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -37,7 +37,7 @@ impl RustdocVisitor {\n         self.attrs = crate.attrs.clone();\n         fn visit_struct_def(item: &ast::item, sd: @ast::struct_def, generics:\n                             &ast::Generics) -> Struct {\n-            debug2!(\"Visiting struct\");\n+            debug!(\"Visiting struct\");\n             let struct_type = struct_type_from_def(sd);\n             Struct {\n                 id: item.id,\n@@ -52,7 +52,7 @@ impl RustdocVisitor {\n         }\n \n         fn visit_enum_def(it: &ast::item, def: &ast::enum_def, params: &ast::Generics) -> Enum {\n-            debug2!(\"Visiting enum\");\n+            debug!(\"Visiting enum\");\n             let mut vars: ~[Variant] = ~[];\n             for x in def.variants.iter() {\n                 vars.push(Variant {\n@@ -77,7 +77,7 @@ impl RustdocVisitor {\n \n         fn visit_fn(item: &ast::item, fd: &ast::fn_decl, purity: &ast::purity,\n                      _abi: &AbiSet, gen: &ast::Generics) -> Function {\n-            debug2!(\"Visiting fn\");\n+            debug!(\"Visiting fn\");\n             Function {\n                 id: item.id,\n                 vis: item.vis,\n@@ -96,7 +96,7 @@ impl RustdocVisitor {\n             let name = match am.find(&id) {\n                 Some(m) => match m {\n                     &ast_map::node_item(ref it, _) => Some(it.ident),\n-                    _ => fail2!(\"mod id mapped to non-item in the ast map\")\n+                    _ => fail!(\"mod id mapped to non-item in the ast map\")\n                 },\n                 None => None\n             };\n@@ -113,7 +113,7 @@ impl RustdocVisitor {\n         }\n \n         fn visit_item(item: &ast::item, om: &mut Module) {\n-            debug2!(\"Visiting item {:?}\", item);\n+            debug!(\"Visiting item {:?}\", item);\n             match item.node {\n                 ast::item_mod(ref m) => {\n                     om.mods.push(visit_mod_contents(item.span, item.attrs.clone(),"}, {"sha": "1f5802927a641d1f96c23f46a5cc86b3c397c9e1", "filename": "src/librustpkg/api.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustpkg%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustpkg%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fapi.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -54,7 +54,7 @@ fn binary_is_fresh(path: &str, in_hash: &str) -> bool {\n \n pub fn new_workcache_context(p: &Path) -> workcache::Context {\n     let db_file = p.join(\"rustpkg_db.json\"); // ??? probably wrong\n-    debug2!(\"Workcache database file: {}\", db_file.display());\n+    debug!(\"Workcache database file: {}\", db_file.display());\n     let db = RWArc::new(Database::new(db_file));\n     let lg = RWArc::new(Logger::new());\n     let cfg = Arc::new(TreeMap::new());"}, {"sha": "3f1f2a1f59d5210b6734dc193b5fc97c0bb514bb", "filename": "src/librustpkg/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustpkg%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustpkg%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcontext.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -154,7 +154,7 @@ impl Context {\n /// rustpkg from a Rust target directory. This is part of a\n /// kludgy hack used to adjust the sysroot.\n pub fn in_target(sysroot: &Path) -> bool {\n-    debug2!(\"Checking whether {} is in target\", sysroot.display());\n+    debug!(\"Checking whether {} is in target\", sysroot.display());\n     let mut p = sysroot.dir_path();\n     p.set_filename(\"rustc\");\n     os::path_is_dir(&p)"}, {"sha": "767a31ed78563578356bcb610319a12a0ef6475c", "filename": "src/librustpkg/installed_packages.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustpkg%2Finstalled_packages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustpkg%2Finstalled_packages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Finstalled_packages.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -31,17 +31,17 @@ pub fn list_installed_packages(f: &fn(&PkgId) -> bool) -> bool  {\n         }\n         let libfiles = os::list_dir(&p.join(\"lib\"));\n         for lib in libfiles.iter() {\n-            debug2!(\"Full name: {}\", lib.display());\n+            debug!(\"Full name: {}\", lib.display());\n             match has_library(lib) {\n                 Some(basename) => {\n                     let parent = p.join(\"lib\");\n-                    debug2!(\"parent = {}, child = {}\",\n+                    debug!(\"parent = {}, child = {}\",\n                             parent.display(), lib.display());\n                     let rel_p = lib.path_relative_from(&parent).unwrap();\n-                    debug2!(\"Rel: {}\", rel_p.display());\n+                    debug!(\"Rel: {}\", rel_p.display());\n                     let rel_path = rel_p.join(basename);\n                     do rel_path.display().with_str |s| {\n-                        debug2!(\"Rel name: {}\", s);\n+                        debug!(\"Rel name: {}\", s);\n                         f(&PkgId::new(s));\n                     }\n                 }"}, {"sha": "68d2d9662e3458237bc652c9a3016d1378eb18b8", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -77,7 +77,7 @@ impl PkgSrc {\n                id: PkgId) -> PkgSrc {\n         use conditions::nonexistent_package::cond;\n \n-        debug2!(\"Checking package source for package ID {}, \\\n+        debug!(\"Checking package source for package ID {}, \\\n                 workspace = {} -> {}, use_rust_path_hack = {:?}\",\n                 id.to_str(),\n                 source_workspace.display(),\n@@ -115,13 +115,13 @@ impl PkgSrc {\n \n         }\n \n-        debug2!(\"Checking dirs: {:?}\", to_try.map(|p| p.display().to_str()).connect(\":\"));\n+        debug!(\"Checking dirs: {:?}\", to_try.map(|p| p.display().to_str()).connect(\":\"));\n \n         let path = to_try.iter().find(|&d| os::path_exists(d));\n \n         // See the comments on the definition of PkgSrc\n         let mut build_in_destination = use_rust_path_hack;\n-        debug2!(\"1. build_in_destination = {:?}\", build_in_destination);\n+        debug!(\"1. build_in_destination = {:?}\", build_in_destination);\n \n         let dir: Path = match path {\n             Some(d) => (*d).clone(),\n@@ -131,7 +131,7 @@ impl PkgSrc {\n                 for (prefix, suffix) in id.prefixes_iter() {\n                     let package_id = PkgId::new(prefix.as_str().unwrap());\n                     let path = build_dir.join(&package_id.path);\n-                    debug2!(\"in loop: checking if {} is a directory\", path.display());\n+                    debug!(\"in loop: checking if {} is a directory\", path.display());\n                     if os::path_is_dir(&path) {\n                         let ps = PkgSrc::new(source_workspace,\n                                              destination_workspace,\n@@ -154,7 +154,7 @@ impl PkgSrc {\n                                     tests: ~[],\n                                     benchs: ~[]\n                                 };\n-                                debug2!(\"pkgsrc: Returning {}\", result.to_str());\n+                                debug!(\"pkgsrc: Returning {}\", result.to_str());\n                                 return result;\n                             }\n                         }\n@@ -165,12 +165,12 @@ impl PkgSrc {\n                 // Ok, no prefixes work, so try fetching from git\n                 let mut ok_d = None;\n                 for w in output_names.iter() {\n-                    debug2!(\"Calling fetch_git on {}\", w.display());\n+                    debug!(\"Calling fetch_git on {}\", w.display());\n                     let target_dir_opt = PkgSrc::fetch_git(w, &id);\n                     for p in target_dir_opt.iter() {\n                         ok_d = Some(p.clone());\n                         build_in_destination = true;\n-                        debug2!(\"2. build_in_destination = {:?}\", build_in_destination);\n+                        debug!(\"2. build_in_destination = {:?}\", build_in_destination);\n                         break;\n                     }\n                     match ok_d {\n@@ -232,10 +232,10 @@ impl PkgSrc {\n                 }\n             }\n         };\n-        debug2!(\"3. build_in_destination = {:?}\", build_in_destination);\n-        debug2!(\"source: {} dest: {}\", source_workspace.display(), destination_workspace.display());\n+        debug!(\"3. build_in_destination = {:?}\", build_in_destination);\n+        debug!(\"source: {} dest: {}\", source_workspace.display(), destination_workspace.display());\n \n-        debug2!(\"For package id {}, returning {}\", id.to_str(), dir.display());\n+        debug!(\"For package id {}, returning {}\", id.to_str(), dir.display());\n \n         if !os::path_is_dir(&dir) {\n             cond.raise((id.clone(), ~\"supplied path for package dir is a \\\n@@ -264,7 +264,7 @@ impl PkgSrc {\n         use conditions::git_checkout_failed::cond;\n \n         let cwd = os::getcwd();\n-        debug2!(\"Checking whether {} (path = {}) exists locally. Cwd = {}, does it? {:?}\",\n+        debug!(\"Checking whether {} (path = {}) exists locally. Cwd = {}, does it? {:?}\",\n                 pkgid.to_str(), pkgid.path.display(),\n                 cwd.display(),\n                 os::path_exists(&pkgid.path));\n@@ -282,7 +282,7 @@ impl PkgSrc {\n \n                 // FIXME (#9639): This needs to handle non-utf8 paths\n                 let url = format!(\"https://{}\", pkgid.path.as_str().unwrap());\n-                debug2!(\"Fetching package: git clone {} {} [version={}]\",\n+                debug!(\"Fetching package: git clone {} {} [version={}]\",\n                         url, clone_target.display(), pkgid.version.to_str());\n \n                 let mut failed = false;\n@@ -311,7 +311,7 @@ impl PkgSrc {\n     // return the path for it. Otherwise, None\n     pub fn package_script_option(&self) -> Option<Path> {\n         let maybe_path = self.start_dir.join(\"pkg.rs\");\n-        debug2!(\"package_script_option: checking whether {} exists\", maybe_path.display());\n+        debug!(\"package_script_option: checking whether {} exists\", maybe_path.display());\n         if os::path_exists(&maybe_path) {\n             Some(maybe_path)\n         } else {\n@@ -334,7 +334,7 @@ impl PkgSrc {\n         for c in it {\n             sub.push(c);\n         }\n-        debug2!(\"Will compile crate {}\", sub.display());\n+        debug!(\"Will compile crate {}\", sub.display());\n         cs.push(Crate::new(&sub));\n     }\n \n@@ -348,7 +348,7 @@ impl PkgSrc {\n         use conditions::missing_pkg_files::cond;\n \n         let prefix = self.start_dir.component_iter().len();\n-        debug2!(\"Matching against {}\", self.id.short_name);\n+        debug!(\"Matching against {}\", self.id.short_name);\n         do os::walk_dir(&self.start_dir) |pth| {\n             let maybe_known_crate_set = match pth.filename_str() {\n                 Some(filename) if filter(filename) => match filename {\n@@ -377,7 +377,7 @@ impl PkgSrc {\n             cond.raise(self.id.clone());\n         }\n \n-        debug2!(\"In {}, found {} libs, {} mains, {} tests, {} benchs\",\n+        debug!(\"In {}, found {} libs, {} mains, {} tests, {} benchs\",\n                self.start_dir.display(),\n                self.libs.len(),\n                self.mains.len(),\n@@ -393,11 +393,11 @@ impl PkgSrc {\n                     what: OutputType) {\n         for crate in crates.iter() {\n             let path = self.start_dir.join(&crate.file);\n-            debug2!(\"build_crates: compiling {}\", path.display());\n+            debug!(\"build_crates: compiling {}\", path.display());\n             let cfgs = crate.cfgs + cfgs;\n \n             do ctx.workcache_context.with_prep(crate_tag(&path)) |prep| {\n-                debug2!(\"Building crate {}, declaring it as an input\", path.display());\n+                debug!(\"Building crate {}, declaring it as an input\", path.display());\n                 // FIXME (#9639): This needs to handle non-utf8 paths\n                 prep.declare_input(\"file\", path.as_str().unwrap(),\n                                    workcache_support::digest_file_with_date(&path));\n@@ -424,7 +424,7 @@ impl PkgSrc {\n                     // output as \"Some(\\\"path\\\")\". But I don't know what to do about it.\n                     // FIXME (#9639): This needs to handle non-utf8 paths\n                     let result = result.as_ref().map(|p|p.as_str().unwrap());\n-                    debug2!(\"Result of compiling {} was {}\", subpath.display(), result.to_str());\n+                    debug!(\"Result of compiling {} was {}\", subpath.display(), result.to_str());\n                     result.to_str()\n                 }\n             };\n@@ -436,11 +436,11 @@ impl PkgSrc {\n     pub fn declare_inputs(&self, prep: &mut workcache::Prep) {\n         let to_do = ~[self.libs.clone(), self.mains.clone(),\n                       self.tests.clone(), self.benchs.clone()];\n-        debug2!(\"In declare inputs, self = {}\", self.to_str());\n+        debug!(\"In declare inputs, self = {}\", self.to_str());\n         for cs in to_do.iter() {\n             for c in cs.iter() {\n                 let path = self.start_dir.join(&c.file);\n-                debug2!(\"Declaring input: {}\", path.display());\n+                debug!(\"Declaring input: {}\", path.display());\n                 // FIXME (#9639): This needs to handle non-utf8 paths\n                 prep.declare_input(\"file\", path.as_str().unwrap(),\n                                    workcache_support::digest_file_with_date(&path.clone()));\n@@ -459,14 +459,14 @@ impl PkgSrc {\n         let mains = self.mains.clone();\n         let tests = self.tests.clone();\n         let benchs = self.benchs.clone();\n-        debug2!(\"Building libs in {}, destination = {}\",\n+        debug!(\"Building libs in {}, destination = {}\",\n                self.source_workspace.display(), self.build_workspace().display());\n         self.build_crates(build_context, &mut deps, libs, cfgs, Lib);\n-        debug2!(\"Building mains\");\n+        debug!(\"Building mains\");\n         self.build_crates(build_context, &mut deps, mains, cfgs, Main);\n-        debug2!(\"Building tests\");\n+        debug!(\"Building tests\");\n         self.build_crates(build_context, &mut deps, tests, cfgs, Test);\n-        debug2!(\"Building benches\");\n+        debug!(\"Building benches\");\n         self.build_crates(build_context, &mut deps, benchs, cfgs, Bench);\n         deps\n     }\n@@ -486,7 +486,7 @@ impl PkgSrc {\n         let crate_sets = [&self.libs, &self.mains, &self.tests, &self.benchs];\n         for crate_set in crate_sets.iter() {\n             for c in crate_set.iter() {\n-                debug2!(\"Built crate: {}\", c.file.display())\n+                debug!(\"Built crate: {}\", c.file.display())\n             }\n         }\n     }"}, {"sha": "c47c89d777b483080d123d42933c97ba7447daa4", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -25,7 +25,7 @@ use messages::*;\n pub fn default_workspace() -> Path {\n     let p = rust_path();\n     if p.is_empty() {\n-        fail2!(\"Empty RUST_PATH\");\n+        fail!(\"Empty RUST_PATH\");\n     }\n     let result = p[0];\n     if !os::path_is_dir(&result) {\n@@ -88,9 +88,9 @@ pub fn workspace_contains_package_id_(pkgid: &PkgId, workspace: &Path,\n     };\n \n     if found.is_some() {\n-        debug2!(\"Found {} in {}\", pkgid.to_str(), workspace.display());\n+        debug!(\"Found {} in {}\", pkgid.to_str(), workspace.display());\n     } else {\n-        debug2!(\"Didn't find {} in {}\", pkgid.to_str(), workspace.display());\n+        debug!(\"Didn't find {} in {}\", pkgid.to_str(), workspace.display());\n     }\n     found\n }\n@@ -123,13 +123,13 @@ fn target_bin_dir(workspace: &Path) -> Path {\n pub fn built_executable_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n     let mut result = target_build_dir(workspace);\n     result = mk_output_path(Main, Build, pkgid, result);\n-    debug2!(\"built_executable_in_workspace: checking whether {} exists\",\n+    debug!(\"built_executable_in_workspace: checking whether {} exists\",\n            result.display());\n     if os::path_exists(&result) {\n         Some(result)\n     }\n     else {\n-        debug2!(\"built_executable_in_workspace: {} does not exist\", result.display());\n+        debug!(\"built_executable_in_workspace: {} does not exist\", result.display());\n         None\n     }\n }\n@@ -150,13 +150,13 @@ fn output_in_workspace(pkgid: &PkgId, workspace: &Path, what: OutputType) -> Opt\n     let mut result = target_build_dir(workspace);\n     // should use a target-specific subdirectory\n     result = mk_output_path(what, Build, pkgid, result);\n-    debug2!(\"output_in_workspace: checking whether {} exists\",\n+    debug!(\"output_in_workspace: checking whether {} exists\",\n            result.display());\n     if os::path_exists(&result) {\n         Some(result)\n     }\n     else {\n-        error2!(\"output_in_workspace: {} does not exist\", result.display());\n+        error!(\"output_in_workspace: {} does not exist\", result.display());\n         None\n     }\n }\n@@ -186,13 +186,13 @@ pub fn installed_library_in_workspace(pkg_path: &Path, workspace: &Path) -> Opti\n /// `short_name` is taken as the link name of the library.\n pub fn library_in_workspace(path: &Path, short_name: &str, where: Target,\n                         workspace: &Path, prefix: &str, version: &Version) -> Option<Path> {\n-    debug2!(\"library_in_workspace: checking whether a library named {} exists\",\n+    debug!(\"library_in_workspace: checking whether a library named {} exists\",\n            short_name);\n \n     // We don't know what the hash is, so we have to search through the directory\n     // contents\n \n-    debug2!(\"short_name = {} where = {:?} workspace = {} \\\n+    debug!(\"short_name = {} where = {:?} workspace = {} \\\n             prefix = {}\", short_name, where, workspace.display(), prefix);\n \n     let dir_to_search = match where {\n@@ -209,20 +209,20 @@ pub fn system_library(sysroot: &Path, lib_name: &str) -> Option<Path> {\n }\n \n fn library_in(short_name: &str, version: &Version, dir_to_search: &Path) -> Option<Path> {\n-    debug2!(\"Listing directory {}\", dir_to_search.display());\n+    debug!(\"Listing directory {}\", dir_to_search.display());\n     let dir_contents = os::list_dir(dir_to_search);\n-    debug2!(\"dir has {:?} entries\", dir_contents.len());\n+    debug!(\"dir has {:?} entries\", dir_contents.len());\n \n     let lib_prefix = format!(\"{}{}\", os::consts::DLL_PREFIX, short_name);\n     let lib_filetype = os::consts::DLL_EXTENSION;\n \n-    debug2!(\"lib_prefix = {} and lib_filetype = {}\", lib_prefix, lib_filetype);\n+    debug!(\"lib_prefix = {} and lib_filetype = {}\", lib_prefix, lib_filetype);\n \n     // Find a filename that matches the pattern:\n     // (lib_prefix)-hash-(version)(lib_suffix)\n     let mut libraries = do dir_contents.iter().filter |p| {\n         let extension = p.extension_str();\n-        debug2!(\"p = {}, p's extension is {:?}\", p.display(), extension);\n+        debug!(\"p = {}, p's extension is {:?}\", p.display(), extension);\n         match extension {\n             None => false,\n             Some(ref s) => lib_filetype == *s\n@@ -243,12 +243,12 @@ fn library_in(short_name: &str, version: &Version, dir_to_search: &Path) -> Opti\n             if f_name.is_empty() { break; }\n             match f_name.rfind('-') {\n                 Some(i) => {\n-                    debug2!(\"Maybe {} is a version\", f_name.slice(i + 1, f_name.len()));\n+                    debug!(\"Maybe {} is a version\", f_name.slice(i + 1, f_name.len()));\n                     match try_parsing_version(f_name.slice(i + 1, f_name.len())) {\n                        Some(ref found_vers) if version == found_vers => {\n                            match f_name.slice(0, i).rfind('-') {\n                                Some(j) => {\n-                                   debug2!(\"Maybe {} equals {}\", f_name.slice(0, j), lib_prefix);\n+                                   debug!(\"Maybe {} equals {}\", f_name.slice(0, j), lib_prefix);\n                                    if f_name.slice(0, j) == lib_prefix {\n                                        result_filename = Some(p_path.clone());\n                                    }\n@@ -266,15 +266,15 @@ fn library_in(short_name: &str, version: &Version, dir_to_search: &Path) -> Opti\n     } // for\n \n     if result_filename.is_none() {\n-        debug2!(\"warning: library_in_workspace didn't find a library in {} for {}\",\n+        debug!(\"warning: library_in_workspace didn't find a library in {} for {}\",\n                   dir_to_search.display(), short_name);\n     }\n \n     // Return the filename that matches, which we now know exists\n     // (if result_filename != None)\n     let abs_path = do result_filename.map |result_filename| {\n         let absolute_path = dir_to_search.join(&result_filename);\n-        debug2!(\"result_filename = {}\", absolute_path.display());\n+        debug!(\"result_filename = {}\", absolute_path.display());\n         absolute_path\n     };\n \n@@ -348,7 +348,7 @@ pub fn build_pkg_id_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n \n     let mut result = target_build_dir(workspace);\n     result.push(&pkgid.path);\n-    debug2!(\"Creating build dir {} for package id {}\", result.display(),\n+    debug!(\"Creating build dir {} for package id {}\", result.display(),\n            pkgid.to_str());\n     if os::path_exists(&result) || os::mkdir_recursive(&result, U_RWX) {\n         result\n@@ -372,7 +372,7 @@ pub fn mk_output_path(what: OutputType, where: Target,\n         // and if we're just building, it goes in a package-specific subdir\n         Build => workspace.join(&pkg_id.path)\n     };\n-    debug2!(\"[{:?}:{:?}] mk_output_path: short_name = {}, path = {}\", what, where,\n+    debug!(\"[{:?}:{:?}] mk_output_path: short_name = {}, path = {}\", what, where,\n            if what == Lib { short_name_with_version.clone() } else { pkg_id.short_name.clone() },\n            dir.display());\n     let mut output_path = match what {\n@@ -390,7 +390,7 @@ pub fn mk_output_path(what: OutputType, where: Target,\n     if !output_path.is_absolute() {\n         output_path = os::getcwd().join(&output_path);\n     }\n-    debug2!(\"mk_output_path: returning {}\", output_path.display());\n+    debug!(\"mk_output_path: returning {}\", output_path.display());\n     output_path\n }\n \n@@ -431,13 +431,13 @@ pub fn find_dir_using_rust_path_hack(p: &PkgId) -> Option<Path> {\n         // Note that this only matches if the package ID being searched for\n         // has a name that's a single component\n         if dir.ends_with_path(&p.path) || dir.ends_with_path(&versionize(&p.path, &p.version)) {\n-            debug2!(\"In find_dir_using_rust_path_hack: checking dir {}\", dir.display());\n+            debug!(\"In find_dir_using_rust_path_hack: checking dir {}\", dir.display());\n             if dir_has_crate_file(dir) {\n-                debug2!(\"Did find id {} in dir {}\", p.to_str(), dir.display());\n+                debug!(\"Did find id {} in dir {}\", p.to_str(), dir.display());\n                 return Some(dir.clone());\n             }\n         }\n-        debug2!(\"Didn't find id {} in dir {}\", p.to_str(), dir.display())\n+        debug!(\"Didn't find id {} in dir {}\", p.to_str(), dir.display())\n     }\n     None\n }"}, {"sha": "6c55f7af0c06a2c79d74f59628791f6f5427f745", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -104,7 +104,7 @@ impl<'self> PkgScript<'self> {\n         let binary = os::args()[0].to_managed();\n         // Build the rustc session data structures to pass\n         // to the compiler\n-        debug2!(\"pkgscript parse: {}\", sysroot.display());\n+        debug!(\"pkgscript parse: {}\", sysroot.display());\n         let options = @session::options {\n             binary: binary,\n             maybe_sysroot: Some(sysroot),\n@@ -120,7 +120,7 @@ impl<'self> PkgScript<'self> {\n         let crate = driver::phase_2_configure_and_expand(sess, cfg.clone(), crate);\n         let work_dir = build_pkg_id_in_workspace(id, workspace);\n \n-        debug2!(\"Returning package script with id {}\", id.to_str());\n+        debug!(\"Returning package script with id {}\", id.to_str());\n \n         PkgScript {\n             id: id,\n@@ -140,10 +140,10 @@ impl<'self> PkgScript<'self> {\n                   sysroot: &Path) -> (~[~str], ExitCode) {\n         let sess = self.sess;\n \n-        debug2!(\"Working directory = {}\", self.build_dir.display());\n+        debug!(\"Working directory = {}\", self.build_dir.display());\n         // Collect together any user-defined commands in the package script\n         let crate = util::ready_crate(sess, self.crate.take_unwrap());\n-        debug2!(\"Building output filenames with script name {}\",\n+        debug!(\"Building output filenames with script name {}\",\n                driver::source_name(&driver::file_input(self.input.clone())));\n         let exe = self.build_dir.join(\"pkg\" + util::exe_suffix());\n         util::compile_crate_from_input(&self.input,\n@@ -152,7 +152,7 @@ impl<'self> PkgScript<'self> {\n                                        &self.build_dir,\n                                        sess,\n                                        crate);\n-        debug2!(\"Running program: {} {} {}\", exe.display(),\n+        debug!(\"Running program: {} {} {}\", exe.display(),\n                sysroot.display(), \"install\");\n         // Discover the output\n         // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -165,7 +165,7 @@ impl<'self> PkgScript<'self> {\n             return (~[], status);\n         }\n         else {\n-            debug2!(\"Running program (configs): {} {} {}\",\n+            debug!(\"Running program (configs): {} {} {}\",\n                    exe.display(), sysroot.display(), \"configs\");\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             let output = run::process_output(exe.as_str().unwrap(),\n@@ -243,7 +243,7 @@ impl CtxMethods for BuildContext {\n             let pkgid = PkgId::new(args[0].clone());\n             let mut dest_ws = default_workspace();\n             do each_pkg_parent_workspace(&self.context, &pkgid) |workspace| {\n-                debug2!(\"found pkg {} in workspace {}, trying to build\",\n+                debug!(\"found pkg {} in workspace {}, trying to build\",\n                        pkgid.to_str(), workspace.display());\n                 dest_ws = determine_destination(os::getcwd(),\n                                                 self.context.use_rust_path_hack,\n@@ -315,7 +315,7 @@ impl CtxMethods for BuildContext {\n                     // argument\n                     let pkgid = PkgId::new(args[0]);\n                     let workspaces = pkg_parent_workspaces(&self.context, &pkgid);\n-                    debug2!(\"package ID = {}, found it in {:?} workspaces\",\n+                    debug!(\"package ID = {}, found it in {:?} workspaces\",\n                            pkgid.to_str(), workspaces.len());\n                     if workspaces.is_empty() {\n                         let d = default_workspace();\n@@ -401,13 +401,13 @@ impl CtxMethods for BuildContext {\n \n                 self.unprefer(args[0], None);\n             }\n-            _ => fail2!(\"I don't know the command `{}`\", cmd)\n+            _ => fail!(\"I don't know the command `{}`\", cmd)\n         }\n     }\n \n     fn do_cmd(&self, _cmd: &str, _pkgname: &str)  {\n         // stub\n-        fail2!(\"`do` not yet implemented\");\n+        fail!(\"`do` not yet implemented\");\n     }\n \n     fn build(&self, pkg_src: &mut PkgSrc, what_to_build: &WhatToBuild) {\n@@ -416,7 +416,7 @@ impl CtxMethods for BuildContext {\n         let workspace = pkg_src.source_workspace.clone();\n         let pkgid = pkg_src.id.clone();\n \n-        debug2!(\"build: workspace = {} (in Rust path? {:?} is git dir? {:?} \\\n+        debug!(\"build: workspace = {} (in Rust path? {:?} is git dir? {:?} \\\n                 pkgid = {} pkgsrc start_dir = {}\", workspace.display(),\n                in_rust_path(&workspace), is_git_dir(&workspace.join(&pkgid.path)),\n                pkgid.to_str(), pkg_src.start_dir.display());\n@@ -435,7 +435,7 @@ impl CtxMethods for BuildContext {\n                 _ => cond.raise((pkgid.path.as_str().unwrap().to_owned(), out_dir.clone()))\n             };\n             let default_ws = default_workspace();\n-            debug2!(\"Calling build recursively with {:?} and {:?}\", default_ws.display(),\n+            debug!(\"Calling build recursively with {:?} and {:?}\", default_ws.display(),\n                    pkgid.to_str());\n             return self.build(&mut PkgSrc::new(default_ws.clone(),\n                                                default_ws,\n@@ -445,9 +445,9 @@ impl CtxMethods for BuildContext {\n \n         // Is there custom build logic? If so, use it\n         let mut custom = false;\n-        debug2!(\"Package source directory = {}\", pkg_src.to_str());\n+        debug!(\"Package source directory = {}\", pkg_src.to_str());\n         let opt = pkg_src.package_script_option();\n-        debug2!(\"Calling pkg_script_option on {:?}\", opt);\n+        debug!(\"Calling pkg_script_option on {:?}\", opt);\n         let cfgs = match pkg_src.package_script_option() {\n             Some(package_script_path) => {\n                 let sysroot = self.sysroot_to_use();\n@@ -469,16 +469,16 @@ impl CtxMethods for BuildContext {\n                         pscript.run_custom(exec, &sub_sysroot)\n                     }\n                 };\n-                debug2!(\"Command return code = {:?}\", hook_result);\n+                debug!(\"Command return code = {:?}\", hook_result);\n                 if hook_result != 0 {\n-                    fail2!(\"Error running custom build command\")\n+                    fail!(\"Error running custom build command\")\n                 }\n                 custom = true;\n                 // otherwise, the package script succeeded\n                 cfgs\n             }\n             None => {\n-                debug2!(\"No package script, continuing\");\n+                debug!(\"No package script, continuing\");\n                 ~[]\n             }\n         } + self.context.cfgs;\n@@ -495,7 +495,7 @@ impl CtxMethods for BuildContext {\n                 &JustOne(ref p) => {\n                     // We expect that p is relative to the package source's start directory,\n                     // so check that assumption\n-                    debug2!(\"JustOne: p = {}\", p.display());\n+                    debug!(\"JustOne: p = {}\", p.display());\n                     assert!(os::path_exists(&pkg_src.start_dir.join(p)));\n                     if is_lib(p) {\n                         PkgSrc::push_crate(&mut pkg_src.libs, 0, p);\n@@ -534,7 +534,7 @@ impl CtxMethods for BuildContext {\n \n     fn info(&self) {\n         // stub\n-        fail2!(\"info not yet implemented\");\n+        fail!(\"info not yet implemented\");\n     }\n \n     fn install(&self, mut pkg_src: PkgSrc, what: &WhatToBuild) -> (~[Path], ~[(~str, ~str)]) {\n@@ -545,19 +545,19 @@ impl CtxMethods for BuildContext {\n         let mut inputs = ~[];\n         let mut build_inputs = ~[];\n \n-        debug2!(\"Installing package source: {}\", pkg_src.to_str());\n+        debug!(\"Installing package source: {}\", pkg_src.to_str());\n \n         // workcache only knows about *crates*. Building a package\n         // just means inferring all the crates in it, then building each one.\n         self.build(&mut pkg_src, what);\n \n         let to_do = ~[pkg_src.libs.clone(), pkg_src.mains.clone(),\n                       pkg_src.tests.clone(), pkg_src.benchs.clone()];\n-        debug2!(\"In declare inputs for {}\", id.to_str());\n+        debug!(\"In declare inputs for {}\", id.to_str());\n         for cs in to_do.iter() {\n             for c in cs.iter() {\n                 let path = pkg_src.start_dir.join(&c.file);\n-                debug2!(\"Recording input: {}\", path.display());\n+                debug!(\"Recording input: {}\", path.display());\n                 // FIXME (#9639): This needs to handle non-utf8 paths\n                 inputs.push((~\"file\", path.as_str().unwrap().to_owned()));\n                 build_inputs.push(path);\n@@ -568,7 +568,7 @@ impl CtxMethods for BuildContext {\n                                            build_inputs,\n                                            &pkg_src.destination_workspace,\n                                            &id).map(|s| Path::new(s.as_slice()));\n-        debug2!(\"install: id = {}, about to call discover_outputs, {:?}\",\n+        debug!(\"install: id = {}, about to call discover_outputs, {:?}\",\n                id.to_str(), result.map(|p| p.display().to_str()));\n         installed_files = installed_files + result;\n         note(format!(\"Installed package {} to {}\",\n@@ -585,7 +585,7 @@ impl CtxMethods for BuildContext {\n                         id: &PkgId) -> ~[~str] {\n         use conditions::copy_failed::cond;\n \n-        debug2!(\"install_no_build: assuming {} comes from {} with target {}\",\n+        debug!(\"install_no_build: assuming {} comes from {} with target {}\",\n                id.to_str(), build_workspace.display(), target_workspace.display());\n \n         // Now copy stuff into the install dirs\n@@ -595,7 +595,7 @@ impl CtxMethods for BuildContext {\n         let target_lib = maybe_library.as_ref()\n             .map(|_| target_library_in_workspace(id, target_workspace));\n \n-        debug2!(\"target_exec = {} target_lib = {:?} \\\n+        debug!(\"target_exec = {} target_lib = {:?} \\\n                maybe_executable = {:?} maybe_library = {:?}\",\n                target_exec.display(), target_lib,\n                maybe_executable, maybe_library);\n@@ -641,7 +641,7 @@ impl CtxMethods for BuildContext {\n \n \n                 for exec in subex.iter() {\n-                    debug2!(\"Copying: {} -> {}\", exec.display(), sub_target_ex.display());\n+                    debug!(\"Copying: {} -> {}\", exec.display(), sub_target_ex.display());\n                     if !(os::mkdir_recursive(&sub_target_ex.dir_path(), U_RWX) &&\n                          os::copy_file(exec, &sub_target_ex)) {\n                         cond.raise(((*exec).clone(), sub_target_ex.clone()));\n@@ -661,7 +661,7 @@ impl CtxMethods for BuildContext {\n                          os::copy_file(lib, &target_lib)) {\n                         cond.raise(((*lib).clone(), target_lib.clone()));\n                     }\n-                    debug2!(\"3. discovering output {}\", target_lib.display());\n+                    debug!(\"3. discovering output {}\", target_lib.display());\n                     exe_thing.discover_output(\"binary\",\n                                               target_lib.as_str().unwrap(),\n                                               workcache_support::digest_only_date(&target_lib));\n@@ -673,13 +673,13 @@ impl CtxMethods for BuildContext {\n     }\n \n     fn prefer(&self, _id: &str, _vers: Option<~str>)  {\n-        fail2!(\"prefer not yet implemented\");\n+        fail!(\"prefer not yet implemented\");\n     }\n \n     fn test(&self, pkgid: &PkgId, workspace: &Path)  {\n         match built_test_in_workspace(pkgid, workspace) {\n             Some(test_exec) => {\n-                debug2!(\"test: test_exec = {}\", test_exec.display());\n+                debug!(\"test: test_exec = {}\", test_exec.display());\n                 // FIXME (#9639): This needs to handle non-utf8 paths\n                 let status = run::process_status(test_exec.as_str().unwrap(), [~\"--test\"]);\n                 os::set_exit_status(status);\n@@ -700,11 +700,11 @@ impl CtxMethods for BuildContext {\n     }\n \n     fn uninstall(&self, _id: &str, _vers: Option<~str>)  {\n-        fail2!(\"uninstall not yet implemented\");\n+        fail!(\"uninstall not yet implemented\");\n     }\n \n     fn unprefer(&self, _id: &str, _vers: Option<~str>)  {\n-        fail2!(\"unprefer not yet implemented\");\n+        fail!(\"unprefer not yet implemented\");\n     }\n }\n \n@@ -880,9 +880,9 @@ pub fn main_args(args: &[~str]) -> int {\n         _ => filesearch::get_or_default_sysroot()\n     };\n \n-    debug2!(\"Using sysroot: {}\", sroot.display());\n+    debug!(\"Using sysroot: {}\", sroot.display());\n     let ws = default_workspace();\n-    debug2!(\"Will store workcache in {}\", ws.display());\n+    debug!(\"Will store workcache in {}\", ws.display());\n \n     let rm_args = remaining_args.clone();\n     let sub_cmd = cmd.clone();"}, {"sha": "aec4e95f8e21c5201a1f0d6d769d8386e3441a42", "filename": "src/librustpkg/search.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustpkg%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustpkg%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsearch.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -17,7 +17,7 @@ use version::Version;\n /// FIXME #8711: This ignores the desired version.\n pub fn find_installed_library_in_rust_path(pkg_path: &Path, _version: &Version) -> Option<Path> {\n     let rp = rust_path();\n-    debug2!(\"find_installed_library_in_rust_path: looking for path {}\",\n+    debug!(\"find_installed_library_in_rust_path: looking for path {}\",\n             pkg_path.display());\n     for p in rp.iter() {\n         match installed_library_in_workspace(pkg_path, p) {"}, {"sha": "9a571e07570844c140ac187d91bc6d4665a7a445", "filename": "src/librustpkg/source_control.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustpkg%2Fsource_control.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustpkg%2Fsource_control.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsource_control.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -23,14 +23,14 @@ use path_util::chmod_read_only;\n /// Returns `CheckedOutSources` if the clone succeeded.\n pub fn safe_git_clone(source: &Path, v: &Version, target: &Path) -> CloneResult {\n     if os::path_exists(source) {\n-        debug2!(\"{} exists locally! Cloning it into {}\",\n+        debug!(\"{} exists locally! Cloning it into {}\",\n                 source.display(), target.display());\n         // Ok to use target here; we know it will succeed\n         assert!(os::path_is_dir(source));\n         assert!(is_git_dir(source));\n \n         if !os::path_exists(target) {\n-            debug2!(\"Running: git clone {} {}\", source.display(), target.display());\n+            debug!(\"Running: git clone {} {}\", source.display(), target.display());\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             let outp = run::process_output(\"git\", [~\"clone\",\n                                                    source.as_str().unwrap().to_owned(),\n@@ -44,7 +44,7 @@ pub fn safe_git_clone(source: &Path, v: &Version, target: &Path) -> CloneResult\n                 match v {\n                     &ExactRevision(ref s) => {\n                         let git_dir = target.join(\".git\");\n-                        debug2!(\"`Running: git --work-tree={} --git-dir={} checkout {}\",\n+                        debug!(\"`Running: git --work-tree={} --git-dir={} checkout {}\",\n                                 *s, target.display(), git_dir.display());\n                         // FIXME (#9639: This needs to handle non-utf8 paths\n                         let outp = run::process_output(\"git\",\n@@ -65,7 +65,7 @@ pub fn safe_git_clone(source: &Path, v: &Version, target: &Path) -> CloneResult\n             // case where a version was requested, but I haven't implemented it.\n             assert!(*v == NoVersion);\n             let git_dir = target.join(\".git\");\n-            debug2!(\"Running: git --work-tree={} --git-dir={} pull --no-edit {}\",\n+            debug!(\"Running: git --work-tree={} --git-dir={} pull --no-edit {}\",\n                     target.display(), git_dir.display(), source.display());\n             // FIXME (#9639: This needs to handle non-utf8 paths\n             let args = [format!(\"--work-tree={}\", target.as_str().unwrap().to_owned()),\n@@ -111,8 +111,8 @@ pub fn git_clone_url(source: &str, target: &Path, v: &Version) {\n     let outp = run::process_output(\"git\", [~\"clone\", source.to_owned(),\n                                            target.as_str().unwrap().to_owned()]);\n     if outp.status != 0 {\n-         debug2!(\"{}\", str::from_utf8_owned(outp.output.clone()));\n-         debug2!(\"{}\", str::from_utf8_owned(outp.error));\n+         debug!(\"{}\", str::from_utf8_owned(outp.output.clone()));\n+         debug!(\"{}\", str::from_utf8_owned(outp.error));\n          cond.raise((source.to_owned(), target.clone()))\n     }\n     else {\n@@ -121,8 +121,8 @@ pub fn git_clone_url(source: &str, target: &Path, v: &Version) {\n                     let outp = process_output_in_cwd(\"git\", [~\"checkout\", s.to_owned()],\n                                                          target);\n                     if outp.status != 0 {\n-                        debug2!(\"{}\", str::from_utf8_owned(outp.output.clone()));\n-                        debug2!(\"{}\", str::from_utf8_owned(outp.error));\n+                        debug!(\"{}\", str::from_utf8_owned(outp.output.clone()));\n+                        debug!(\"{}\", str::from_utf8_owned(outp.error));\n                         cond.raise((source.to_owned(), target.clone()))\n                     }\n             }"}, {"sha": "58c6b4ff81fb66e9e193d1ad45aab93055689c96", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 96, "deletions": 96, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -115,12 +115,12 @@ fn mk_temp_workspace(short_name: &Path, version: &Version) -> (TempDir, Path) {\n                                                               short_name.as_str().unwrap(),\n                                                               version.to_str())]);\n \n-    debug2!(\"Created {} and does it exist? {:?}\", package_dir.display(),\n+    debug!(\"Created {} and does it exist? {:?}\", package_dir.display(),\n           os::path_is_dir(&package_dir));\n     // Create main, lib, test, and bench files\n-    debug2!(\"mk_workspace: creating {}\", package_dir.display());\n+    debug!(\"mk_workspace: creating {}\", package_dir.display());\n     assert!(os::mkdir_recursive(&package_dir, U_RWX));\n-    debug2!(\"Created {} and does it exist? {:?}\", package_dir.display(),\n+    debug!(\"Created {} and does it exist? {:?}\", package_dir.display(),\n           os::path_is_dir(&package_dir));\n     // Create main, lib, test, and bench files\n \n@@ -146,7 +146,7 @@ fn run_git(args: &[~str], env: Option<~[(~str, ~str)]>, cwd: &Path, err_msg: &st\n     });\n     let rslt = prog.finish_with_output();\n     if rslt.status != 0 {\n-        fail2!(\"{} [git returned {:?}, output = {}, error = {}]\", err_msg,\n+        fail!(\"{} [git returned {:?}, output = {}, error = {}]\", err_msg,\n            rslt.status, str::from_utf8(rslt.output), str::from_utf8(rslt.error));\n     }\n }\n@@ -159,7 +159,7 @@ fn init_git_repo(p: &Path) -> TempDir {\n     let work_dir = tmp.path().join(p);\n     let work_dir_for_opts = work_dir.clone();\n     assert!(os::mkdir_recursive(&work_dir, U_RWX));\n-    debug2!(\"Running: git init in {}\", work_dir.display());\n+    debug!(\"Running: git init in {}\", work_dir.display());\n     run_git([~\"init\"], None, &work_dir_for_opts,\n         format!(\"Couldn't initialize git repository in {}\", work_dir.display()));\n     // Add stuff to the dir so that git tag succeeds\n@@ -239,15 +239,15 @@ fn rustpkg_exec() -> Path {\n             second_try\n         }\n         else {\n-            fail2!(\"in rustpkg test, can't find an installed rustpkg\");\n+            fail!(\"in rustpkg test, can't find an installed rustpkg\");\n         }\n     }\n }\n \n fn command_line_test(args: &[~str], cwd: &Path) -> ProcessOutput {\n     match command_line_test_with_env(args, cwd, None) {\n         Success(r) => r,\n-        Fail(error) => fail2!(\"Command line test failed with error {}\", error)\n+        Fail(error) => fail!(\"Command line test failed with error {}\", error)\n     }\n }\n \n@@ -260,9 +260,9 @@ fn command_line_test_expect_fail(args: &[~str],\n                                  env: Option<~[(~str, ~str)]>,\n                                  expected_exitcode: int) {\n     match command_line_test_with_env(args, cwd, env) {\n-        Success(_) => fail2!(\"Should have failed with {}, but it succeeded\", expected_exitcode),\n+        Success(_) => fail!(\"Should have failed with {}, but it succeeded\", expected_exitcode),\n         Fail(error) if error == expected_exitcode => (), // ok\n-        Fail(other) => fail2!(\"Expected to fail with {}, but failed with {} instead\",\n+        Fail(other) => fail!(\"Expected to fail with {}, but failed with {} instead\",\n                               expected_exitcode, other)\n     }\n }\n@@ -284,7 +284,7 @@ fn command_line_test_with_env(args: &[~str], cwd: &Path, env: Option<~[(~str, ~s\n         Some(ref pairs) => pairs.map(|&(ref k, ref v)| { format!(\"{}={}\", *k, *v) }).connect(\",\"),\n         None        => ~\"\"\n     };\n-    debug2!(\"{} cd {}; {} {}\", env_str, cwd.display(), cmd, args.connect(\" \"));\n+    debug!(\"{} cd {}; {} {}\", env_str, cwd.display(), cmd, args.connect(\" \"));\n     assert!(os::path_is_dir(&*cwd));\n     let cwd = (*cwd).clone();\n     let mut prog = run::Process::new(cmd, args, run::ProcessOptions {\n@@ -295,7 +295,7 @@ fn command_line_test_with_env(args: &[~str], cwd: &Path, env: Option<~[(~str, ~s\n         err_fd: None\n     });\n     let output = prog.finish_with_output();\n-    debug2!(\"Output from command {} with args {:?} was {} \\\\{{}\\\\}[{:?}]\",\n+    debug!(\"Output from command {} with args {:?} was {} \\\\{{}\\\\}[{:?}]\",\n                     cmd, args, str::from_utf8(output.output),\n                    str::from_utf8(output.error),\n                    output.status);\n@@ -306,7 +306,7 @@ So tests that use this need to check the existence of a file\n to make sure the command succeeded\n */\n     if output.status != 0 {\n-        debug2!(\"Command {} {:?} failed with exit code {:?}; its output was --- {} ---\",\n+        debug!(\"Command {} {:?} failed with exit code {:?}; its output was --- {} ---\",\n               cmd, args, output.status,\n               str::from_utf8(output.output) + str::from_utf8(output.error));\n         Fail(output.status)\n@@ -318,7 +318,7 @@ to make sure the command succeeded\n \n fn create_local_package(pkgid: &PkgId) -> TempDir {\n     let (workspace, parent_dir) = mk_temp_workspace(&pkgid.path, &pkgid.version);\n-    debug2!(\"Created empty package dir for {}, returning {}\", pkgid.to_str(), parent_dir.display());\n+    debug!(\"Created empty package dir for {}, returning {}\", pkgid.to_str(), parent_dir.display());\n     workspace\n }\n \n@@ -328,7 +328,7 @@ fn create_local_package_in(pkgid: &PkgId, pkgdir: &Path) -> Path {\n \n     // Create main, lib, test, and bench files\n     assert!(os::mkdir_recursive(&package_dir, U_RWX));\n-    debug2!(\"Created {} and does it exist? {:?}\", package_dir.display(),\n+    debug!(\"Created {} and does it exist? {:?}\", package_dir.display(),\n           os::path_is_dir(&package_dir));\n     // Create main, lib, test, and bench files\n \n@@ -344,7 +344,7 @@ fn create_local_package_in(pkgid: &PkgId, pkgdir: &Path) -> Path {\n }\n \n fn create_local_package_with_test(pkgid: &PkgId) -> TempDir {\n-    debug2!(\"Dry run -- would create package {:?} with test\", pkgid);\n+    debug!(\"Dry run -- would create package {:?} with test\", pkgid);\n     create_local_package(pkgid) // Already has tests???\n }\n \n@@ -363,7 +363,7 @@ fn create_local_package_with_dep(pkgid: &PkgId, subord_pkgid: &PkgId) -> TempDir\n \n fn create_local_package_with_custom_build_hook(pkgid: &PkgId,\n                                                custom_build_hook: &str) -> TempDir {\n-    debug2!(\"Dry run -- would create package {} with custom build hook {}\",\n+    debug!(\"Dry run -- would create package {} with custom build hook {}\",\n            pkgid.to_str(), custom_build_hook);\n     create_local_package(pkgid)\n     // actually write the pkg.rs with the custom build hook\n@@ -375,9 +375,9 @@ fn assert_lib_exists(repo: &Path, pkg_path: &Path, v: Version) {\n }\n \n fn lib_exists(repo: &Path, pkg_path: &Path, _v: Version) -> bool { // ??? version?\n-    debug2!(\"assert_lib_exists: repo = {}, pkg_path = {}\", repo.display(), pkg_path.display());\n+    debug!(\"assert_lib_exists: repo = {}, pkg_path = {}\", repo.display(), pkg_path.display());\n     let lib = installed_library_in_workspace(pkg_path, repo);\n-    debug2!(\"assert_lib_exists: checking whether {:?} exists\", lib);\n+    debug!(\"assert_lib_exists: checking whether {:?} exists\", lib);\n     lib.is_some() && {\n         let libname = lib.get_ref();\n         os::path_exists(libname) && is_rwx(libname)\n@@ -389,13 +389,13 @@ fn assert_executable_exists(repo: &Path, short_name: &str) {\n }\n \n fn executable_exists(repo: &Path, short_name: &str) -> bool {\n-    debug2!(\"executable_exists: repo = {}, short_name = {}\", repo.display(), short_name);\n+    debug!(\"executable_exists: repo = {}, short_name = {}\", repo.display(), short_name);\n     let exec = target_executable_in_workspace(&PkgId::new(short_name), repo);\n     os::path_exists(&exec) && is_rwx(&exec)\n }\n \n fn test_executable_exists(repo: &Path, short_name: &str) -> bool {\n-    debug2!(\"test_executable_exists: repo = {}, short_name = {}\", repo.display(), short_name);\n+    debug!(\"test_executable_exists: repo = {}, short_name = {}\", repo.display(), short_name);\n     let exec = built_test_in_workspace(&PkgId::new(short_name), repo);\n     do exec.map_default(false) |exec| {\n         os::path_exists(&exec) && is_rwx(&exec)\n@@ -414,7 +414,7 @@ fn assert_built_executable_exists(repo: &Path, short_name: &str) {\n }\n \n fn built_executable_exists(repo: &Path, short_name: &str) -> bool {\n-    debug2!(\"assert_built_executable_exists: repo = {}, short_name = {}\",\n+    debug!(\"assert_built_executable_exists: repo = {}, short_name = {}\",\n             repo.display(), short_name);\n     let exec = built_executable_in_workspace(&PkgId::new(short_name), repo);\n     exec.is_some() && {\n@@ -457,7 +457,7 @@ fn assert_built_library_exists(repo: &Path, short_name: &str) {\n }\n \n fn built_library_exists(repo: &Path, short_name: &str) -> bool {\n-    debug2!(\"assert_built_library_exists: repo = {}, short_name = {}\", repo.display(), short_name);\n+    debug!(\"assert_built_library_exists: repo = {}, short_name = {}\", repo.display(), short_name);\n     let lib = built_library_in_workspace(&PkgId::new(short_name), repo);\n     lib.is_some() && {\n         let libname = lib.get_ref();\n@@ -479,7 +479,7 @@ fn command_line_test_output_with_env(args: &[~str], env: ~[(~str, ~str)]) -> ~[~\n     let mut result = ~[];\n     let p_output = match command_line_test_with_env(args,\n         &os::getcwd(), Some(env)) {\n-        Fail(_) => fail2!(\"Command-line test failed\"),\n+        Fail(_) => fail!(\"Command-line test failed\"),\n         Success(r) => r\n     };\n     let test_output = str::from_utf8(p_output.output);\n@@ -491,7 +491,7 @@ fn command_line_test_output_with_env(args: &[~str], env: ~[(~str, ~str)]) -> ~[~\n \n // assumes short_name and path are one and the same -- I should fix\n fn lib_output_file_name(workspace: &Path, short_name: &str) -> Path {\n-    debug2!(\"lib_output_file_name: given {} and short name {}\",\n+    debug!(\"lib_output_file_name: given {} and short name {}\",\n            workspace.display(), short_name);\n     library_in_workspace(&Path::new(short_name),\n                          short_name,\n@@ -549,11 +549,11 @@ fn frob_source_file(workspace: &Path, pkgid: &PkgId, filename: &str) {\n     let pkg_src_dir = workspace.join_many([~\"src\", pkgid.to_str()]);\n     let mut maybe_p = None;\n     let maybe_file = pkg_src_dir.join(filename);\n-    debug2!(\"Trying to frob {} -- {}\", pkg_src_dir.display(), filename);\n+    debug!(\"Trying to frob {} -- {}\", pkg_src_dir.display(), filename);\n     if os::path_exists(&maybe_file) {\n         maybe_p = Some(maybe_file);\n     }\n-    debug2!(\"Frobbed? {:?}\", maybe_p);\n+    debug!(\"Frobbed? {:?}\", maybe_p);\n     match maybe_p {\n         Some(ref p) => {\n             let w = io::file_writer(p, &[io::Append]);\n@@ -562,7 +562,7 @@ fn frob_source_file(workspace: &Path, pkgid: &PkgId, filename: &str) {\n                 Ok(w)  => w.write_line(\"/* hi */\")\n             }\n         }\n-        None => fail2!(\"frob_source_file failed to find a source file in {}\",\n+        None => fail!(\"frob_source_file failed to find a source file in {}\",\n                            pkg_src_dir.display())\n     }\n }\n@@ -573,7 +573,7 @@ fn test_make_dir_rwx() {\n     let dir = temp.join(\"quux\");\n     assert!(!os::path_exists(&dir) ||\n             os::remove_dir_recursive(&dir));\n-    debug2!(\"Trying to make {}\", dir.display());\n+    debug!(\"Trying to make {}\", dir.display());\n     assert!(make_dir_rwx(&dir));\n     assert!(os::path_is_dir(&dir));\n     assert!(is_rwx(&dir));\n@@ -589,12 +589,12 @@ fn test_install_valid() {\n     use path_util::installed_library_in_workspace;\n \n     let sysroot = test_sysroot();\n-    debug2!(\"sysroot = {}\", sysroot.display());\n+    debug!(\"sysroot = {}\", sysroot.display());\n     let temp_pkg_id = fake_pkg();\n     let (temp_workspace, _pkg_dir) = mk_temp_workspace(&temp_pkg_id.path, &NoVersion);\n     let temp_workspace = temp_workspace.path();\n     let ctxt = fake_ctxt(sysroot, temp_workspace);\n-    debug2!(\"temp_workspace = {}\", temp_workspace.display());\n+    debug!(\"temp_workspace = {}\", temp_workspace.display());\n     // should have test, bench, lib, and main\n     let src = PkgSrc::new(temp_workspace.clone(),\n                           temp_workspace.clone(),\n@@ -603,19 +603,19 @@ fn test_install_valid() {\n     ctxt.install(src, &Everything);\n     // Check that all files exist\n     let exec = target_executable_in_workspace(&temp_pkg_id, temp_workspace);\n-    debug2!(\"exec = {}\", exec.display());\n+    debug!(\"exec = {}\", exec.display());\n     assert!(os::path_exists(&exec));\n     assert!(is_rwx(&exec));\n \n     let lib = installed_library_in_workspace(&temp_pkg_id.path, temp_workspace);\n-    debug2!(\"lib = {:?}\", lib);\n+    debug!(\"lib = {:?}\", lib);\n     assert!(lib.as_ref().map_default(false, |l| os::path_exists(l)));\n     assert!(lib.as_ref().map_default(false, |l| is_rwx(l)));\n \n     // And that the test and bench executables aren't installed\n     assert!(!os::path_exists(&target_test_in_workspace(&temp_pkg_id, temp_workspace)));\n     let bench = target_bench_in_workspace(&temp_pkg_id, temp_workspace);\n-    debug2!(\"bench = {}\", bench.display());\n+    debug!(\"bench = {}\", bench.display());\n     assert!(!os::path_exists(&bench));\n \n     // Make sure the db isn't dirty, so that it doesn't try to save()\n@@ -656,19 +656,19 @@ fn test_install_valid_external() {\n \n     // Check that all files exist\n     let exec = target_executable_in_workspace(&temp_pkg_id, temp_workspace);\n-    debug2!(\"exec = {}\", exec.display());\n+    debug!(\"exec = {}\", exec.display());\n     assert!(os::path_exists(&exec));\n     assert!(is_rwx(&exec));\n \n     let lib = installed_library_in_workspace(&temp_pkg_id.path, temp_workspace);\n-    debug2!(\"lib = {:?}\", lib);\n+    debug!(\"lib = {:?}\", lib);\n     assert!(lib.as_ref().map_default(false, |l| os::path_exists(l)));\n     assert!(lib.as_ref().map_default(false, |l| is_rwx(l)));\n \n     // And that the test and bench executables aren't installed\n     assert!(!os::path_exists(&target_test_in_workspace(&temp_pkg_id, temp_workspace)));\n     let bench = target_bench_in_workspace(&temp_pkg_id, temp_workspace);\n-    debug2!(\"bench = {}\", bench.display());\n+    debug!(\"bench = {}\", bench.display());\n     assert!(!os::path_exists(&bench));\n \n }\n@@ -689,9 +689,9 @@ fn test_install_git() {\n     let temp_pkg_id = git_repo_pkg();\n     let repo = init_git_repo(&temp_pkg_id.path);\n     let repo = repo.path();\n-    debug2!(\"repo = {}\", repo.display());\n+    debug!(\"repo = {}\", repo.display());\n     let repo_subdir = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\"]);\n-    debug2!(\"repo_subdir = {}\", repo_subdir.display());\n+    debug!(\"repo_subdir = {}\", repo_subdir.display());\n \n     writeFile(&repo_subdir.join(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n@@ -703,16 +703,16 @@ fn test_install_git() {\n               \"#[bench] pub fn f() { (); }\");\n     add_git_tag(&repo_subdir, ~\"0.1\"); // this has the effect of committing the files\n \n-    debug2!(\"test_install_git: calling rustpkg install {} in {}\",\n+    debug!(\"test_install_git: calling rustpkg install {} in {}\",\n            temp_pkg_id.path.display(), repo.display());\n     // should have test, bench, lib, and main\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     command_line_test([~\"install\", temp_pkg_id.path.as_str().unwrap().to_owned()], repo);\n     let ws = repo.join(\".rust\");\n     // Check that all files exist\n-    debug2!(\"Checking for files in {}\", ws.display());\n+    debug!(\"Checking for files in {}\", ws.display());\n     let exec = target_executable_in_workspace(&temp_pkg_id, &ws);\n-    debug2!(\"exec = {}\", exec.display());\n+    debug!(\"exec = {}\", exec.display());\n     assert!(os::path_exists(&exec));\n     assert!(is_rwx(&exec));\n     let _built_lib =\n@@ -728,9 +728,9 @@ fn test_install_git() {\n     // And that the test and bench executables aren't installed\n     let test = target_test_in_workspace(&temp_pkg_id, &ws);\n     assert!(!os::path_exists(&test));\n-    debug2!(\"test = {}\", test.display());\n+    debug!(\"test = {}\", test.display());\n     let bench = target_bench_in_workspace(&temp_pkg_id, &ws);\n-    debug2!(\"bench = {}\", bench.display());\n+    debug!(\"bench = {}\", bench.display());\n     assert!(!os::path_exists(&bench));\n }\n \n@@ -784,7 +784,7 @@ fn test_package_version() {\n     let repo = init_git_repo(&Path::new(local_path));\n     let repo = repo.path();\n     let repo_subdir = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test_pkg_version\"]);\n-    debug2!(\"Writing files in: {}\", repo_subdir.display());\n+    debug!(\"Writing files in: {}\", repo_subdir.display());\n     writeFile(&repo_subdir.join(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n     writeFile(&repo_subdir.join(\"lib.rs\"),\n@@ -823,7 +823,7 @@ fn test_package_request_version() {\n     let repo = init_git_repo(&Path::new(local_path));\n     let repo = repo.path();\n     let repo_subdir = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test_pkg_version\"]);\n-    debug2!(\"Writing files in: {}\", repo_subdir.display());\n+    debug!(\"Writing files in: {}\", repo_subdir.display());\n     writeFile(&repo_subdir.join(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n     writeFile(&repo_subdir.join(\"lib.rs\"),\n@@ -842,7 +842,7 @@ fn test_package_request_version() {\n     assert!(match installed_library_in_workspace(&Path::new(\"test_pkg_version\"),\n                                                  &repo.join(\".rust\")) {\n         Some(p) => {\n-            debug2!(\"installed: {}\", p.display());\n+            debug!(\"installed: {}\", p.display());\n             let suffix = format!(\"0.3{}\", os::consts::DLL_SUFFIX);\n             p.as_vec().ends_with(suffix.as_bytes())\n         }\n@@ -854,7 +854,7 @@ fn test_package_request_version() {\n \n     let mut dir = target_build_dir(&repo.join(\".rust\"));\n     dir.push(&Path::new(\"src/mockgithub.com/catamorphism/test_pkg_version-0.3\"));\n-    debug2!(\"dir = {}\", dir.display());\n+    debug!(\"dir = {}\", dir.display());\n     assert!(os::path_is_dir(&dir));\n     assert!(os::path_exists(&dir.join(\"version-0.3-file.txt\")));\n     assert!(!os::path_exists(&dir.join(\"version-0.4-file.txt\")));\n@@ -874,7 +874,7 @@ fn rustpkg_library_target() {\n     let foo_repo = foo_repo.path();\n     let package_dir = foo_repo.join(\"foo\");\n \n-    debug2!(\"Writing files in: {}\", package_dir.display());\n+    debug!(\"Writing files in: {}\", package_dir.display());\n     writeFile(&package_dir.join(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n     writeFile(&package_dir.join(\"lib.rs\"),\n@@ -901,14 +901,14 @@ fn rustpkg_local_pkg() {\n fn package_script_with_default_build() {\n     let dir = create_local_package(&PkgId::new(\"fancy-lib\"));\n     let dir = dir.path();\n-    debug2!(\"dir = {}\", dir.display());\n+    debug!(\"dir = {}\", dir.display());\n     let mut source = test_sysroot().dir_path();\n     source.pop(); source.pop();\n     source.push_many([\"src\", \"librustpkg\", \"testsuite\", \"pass\", \"src\", \"fancy-lib\", \"pkg.rs\"]);\n-    debug2!(\"package_script_with_default_build: {}\", source.display());\n+    debug!(\"package_script_with_default_build: {}\", source.display());\n     if !os::copy_file(&source,\n                       &dir.join_many([\"src\", \"fancy-lib-0.1\", \"pkg.rs\"])) {\n-        fail2!(\"Couldn't copy file\");\n+        fail!(\"Couldn't copy file\");\n     }\n     command_line_test([~\"install\", ~\"fancy-lib\"], dir);\n     assert_lib_exists(dir, &Path::new(\"fancy-lib\"), NoVersion);\n@@ -924,7 +924,7 @@ fn rustpkg_build_no_arg() {\n \n     writeFile(&package_dir.join(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n-    debug2!(\"build_no_arg: dir = {}\", package_dir.display());\n+    debug!(\"build_no_arg: dir = {}\", package_dir.display());\n     command_line_test([~\"build\"], &package_dir);\n     assert_built_executable_exists(&tmp, \"foo\");\n }\n@@ -937,7 +937,7 @@ fn rustpkg_install_no_arg() {\n     assert!(os::mkdir_recursive(&package_dir, U_RWX));\n     writeFile(&package_dir.join(\"lib.rs\"),\n               \"fn main() { let _x = (); }\");\n-    debug2!(\"install_no_arg: dir = {}\", package_dir.display());\n+    debug!(\"install_no_arg: dir = {}\", package_dir.display());\n     command_line_test([~\"install\"], &package_dir);\n     assert_lib_exists(&tmp, &Path::new(\"foo\"), NoVersion);\n }\n@@ -951,7 +951,7 @@ fn rustpkg_clean_no_arg() {\n \n     writeFile(&package_dir.join(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n-    debug2!(\"clean_no_arg: dir = {}\", package_dir.display());\n+    debug!(\"clean_no_arg: dir = {}\", package_dir.display());\n     command_line_test([~\"build\"], &package_dir);\n     assert_built_executable_exists(&tmp, \"foo\");\n     command_line_test([~\"clean\"], &package_dir);\n@@ -963,11 +963,11 @@ fn rustpkg_clean_no_arg() {\n fn rust_path_test() {\n     let dir_for_path = TempDir::new(\"more_rust\").expect(\"rust_path_test failed\");\n     let dir = mk_workspace(dir_for_path.path(), &Path::new(\"foo\"), &NoVersion);\n-    debug2!(\"dir = {}\", dir.display());\n+    debug!(\"dir = {}\", dir.display());\n     writeFile(&dir.join(\"main.rs\"), \"fn main() { let _x = (); }\");\n \n     let cwd = os::getcwd();\n-    debug2!(\"cwd = {}\", cwd.display());\n+    debug!(\"cwd = {}\", cwd.display());\n                                      // use command_line_test_with_env\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     command_line_test_with_env([~\"install\", ~\"foo\"],\n@@ -1080,7 +1080,7 @@ fn install_check_duplicates() {\n     let mut contents = ~[];\n     let check_dups = |p: &PkgId| {\n         if contents.contains(p) {\n-            fail2!(\"package {} appears in `list` output more than once\", p.path.display());\n+            fail!(\"package {} appears in `list` output more than once\", p.path.display());\n         }\n         else {\n             contents.push((*p).clone());\n@@ -1104,8 +1104,8 @@ fn no_rebuilding() {\n \n     match command_line_test_partial([~\"build\", ~\"foo\"], workspace) {\n         Success(*) => (), // ok\n-        Fail(status) if status == 65 => fail2!(\"no_rebuilding failed: it tried to rebuild bar\"),\n-        Fail(_) => fail2!(\"no_rebuilding failed for some other reason\")\n+        Fail(status) if status == 65 => fail!(\"no_rebuilding failed: it tried to rebuild bar\"),\n+        Fail(_) => fail!(\"no_rebuilding failed for some other reason\")\n     }\n }\n \n@@ -1122,8 +1122,8 @@ fn no_rebuilding_dep() {\n     assert!(chmod_read_only(&bar_lib));\n     match command_line_test_partial([~\"build\", ~\"foo\"], workspace) {\n         Success(*) => (), // ok\n-        Fail(status) if status == 65 => fail2!(\"no_rebuilding_dep failed: it tried to rebuild bar\"),\n-        Fail(_) => fail2!(\"no_rebuilding_dep failed for some other reason\")\n+        Fail(status) if status == 65 => fail!(\"no_rebuilding_dep failed: it tried to rebuild bar\"),\n+        Fail(_) => fail!(\"no_rebuilding_dep failed for some other reason\")\n     }\n }\n \n@@ -1141,9 +1141,9 @@ fn do_rebuild_dep_dates_change() {\n     assert!(chmod_read_only(&bar_lib_name));\n \n     match command_line_test_partial([~\"build\", ~\"foo\"], workspace) {\n-        Success(*) => fail2!(\"do_rebuild_dep_dates_change failed: it didn't rebuild bar\"),\n+        Success(*) => fail!(\"do_rebuild_dep_dates_change failed: it didn't rebuild bar\"),\n         Fail(status) if status == 65 => (), // ok\n-        Fail(_) => fail2!(\"do_rebuild_dep_dates_change failed for some other reason\")\n+        Fail(_) => fail!(\"do_rebuild_dep_dates_change failed for some other reason\")\n     }\n }\n \n@@ -1162,9 +1162,9 @@ fn do_rebuild_dep_only_contents_change() {\n \n     // should adjust the datestamp\n     match command_line_test_partial([~\"build\", ~\"foo\"], workspace) {\n-        Success(*) => fail2!(\"do_rebuild_dep_only_contents_change failed: it didn't rebuild bar\"),\n+        Success(*) => fail!(\"do_rebuild_dep_only_contents_change failed: it didn't rebuild bar\"),\n         Fail(status) if status == 65 => (), // ok\n-        Fail(_) => fail2!(\"do_rebuild_dep_only_contents_change failed for some other reason\")\n+        Fail(_) => fail!(\"do_rebuild_dep_only_contents_change failed for some other reason\")\n     }\n }\n \n@@ -1270,7 +1270,7 @@ fn test_extern_mod() {\n     });\n     let outp = prog.finish_with_output();\n     if outp.status != 0 {\n-        fail2!(\"output was {}, error was {}\",\n+        fail!(\"output was {}, error was {}\",\n               str::from_utf8(outp.output),\n               str::from_utf8(outp.error));\n     }\n@@ -1304,7 +1304,7 @@ fn test_extern_mod_simpler() {\n     let rustpkg_exec = rustpkg_exec();\n     let rustc = rustpkg_exec.with_filename(\"rustc\");\n     let test_sys = test_sysroot();\n-    debug2!(\"RUST_PATH={} {} {} \\n --sysroot {} -o {}\",\n+    debug!(\"RUST_PATH={} {} {} \\n --sysroot {} -o {}\",\n                      lib_depend_dir.display(),\n                      rustc.display(),\n                      main_file.display(),\n@@ -1325,7 +1325,7 @@ fn test_extern_mod_simpler() {\n     });\n     let outp = prog.finish_with_output();\n     if outp.status != 0 {\n-        fail2!(\"output was {}, error was {}\",\n+        fail!(\"output was {}, error was {}\",\n               str::from_utf8(outp.output),\n               str::from_utf8(outp.error));\n     }\n@@ -1340,7 +1340,7 @@ fn test_import_rustpkg() {\n     writeFile(&workspace.join_many([\"src\", \"foo-0.1\", \"pkg.rs\"]),\n               \"extern mod rustpkg; fn main() {}\");\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n-    debug2!(\"workspace = {}\", workspace.display());\n+    debug!(\"workspace = {}\", workspace.display());\n     assert!(os::path_exists(&target_build_dir(workspace).join(\"foo\").join(format!(\"pkg{}\",\n         os::EXE_SUFFIX))));\n }\n@@ -1351,9 +1351,9 @@ fn test_macro_pkg_script() {\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     writeFile(&workspace.join_many([\"src\", \"foo-0.1\", \"pkg.rs\"]),\n-              \"extern mod rustpkg; fn main() { debug2!(\\\"Hi\\\"); }\");\n+              \"extern mod rustpkg; fn main() { debug!(\\\"Hi\\\"); }\");\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n-    debug2!(\"workspace = {}\", workspace.display());\n+    debug!(\"workspace = {}\", workspace.display());\n     assert!(os::path_exists(&target_build_dir(workspace).join(\"foo\").join(format!(\"pkg{}\",\n         os::EXE_SUFFIX))));\n }\n@@ -1367,9 +1367,9 @@ fn multiple_workspaces() {\n     let (a_loc, _pkg_dir) = mk_temp_workspace(&Path::new(\"foo\"), &NoVersion);\n     let (b_loc, _pkg_dir) = mk_temp_workspace(&Path::new(\"foo\"), &NoVersion);\n     let (a_loc, b_loc) = (a_loc.path(), b_loc.path());\n-    debug2!(\"Trying to install foo in {}\", a_loc.display());\n+    debug!(\"Trying to install foo in {}\", a_loc.display());\n     command_line_test([~\"install\", ~\"foo\"], a_loc);\n-    debug2!(\"Trying to install foo in {}\", b_loc.display());\n+    debug!(\"Trying to install foo in {}\", b_loc.display());\n     command_line_test([~\"install\", ~\"foo\"], b_loc);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let env = Some(~[(~\"RUST_PATH\", format!(\"{}:{}\", a_loc.as_str().unwrap(),\n@@ -1443,7 +1443,7 @@ fn rust_path_hack_cwd() {\n    // FIXME (#9639): This needs to handle non-utf8 paths\n    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\", ~\"foo\"], &cwd, rust_path);\n-   debug2!(\"Checking that foo exists in {}\", dest_workspace.display());\n+   debug!(\"Checking that foo exists in {}\", dest_workspace.display());\n    assert_lib_exists(dest_workspace, &Path::new(\"foo\"), NoVersion);\n    assert_built_library_exists(dest_workspace, \"foo\");\n    assert!(!lib_exists(&cwd, &Path::new(\"foo\"), NoVersion));\n@@ -1464,7 +1464,7 @@ fn rust_path_hack_multi_path() {\n    // FIXME (#9639): This needs to handle non-utf8 paths\n    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\", name.clone()], &subdir, rust_path);\n-   debug2!(\"Checking that {} exists in {}\", name, dest_workspace.display());\n+   debug!(\"Checking that {} exists in {}\", name, dest_workspace.display());\n    assert_lib_exists(dest_workspace, &Path::new(\"quux\"), NoVersion);\n    assert_built_library_exists(dest_workspace, name);\n    assert!(!lib_exists(&subdir, &Path::new(\"quux\"), NoVersion));\n@@ -1485,7 +1485,7 @@ fn rust_path_hack_install_no_arg() {\n    // FIXME (#9639): This needs to handle non-utf8 paths\n    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\"], &source_dir, rust_path);\n-   debug2!(\"Checking that foo exists in {}\", dest_workspace.display());\n+   debug!(\"Checking that foo exists in {}\", dest_workspace.display());\n    assert_lib_exists(dest_workspace, &Path::new(\"foo\"), NoVersion);\n    assert_built_library_exists(dest_workspace, \"foo\");\n    assert!(!lib_exists(&source_dir, &Path::new(\"foo\"), NoVersion));\n@@ -1505,7 +1505,7 @@ fn rust_path_hack_build_no_arg() {\n    // FIXME (#9639): This needs to handle non-utf8 paths\n    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n    command_line_test_with_env([~\"build\", ~\"--rust-path-hack\"], &source_dir, rust_path);\n-   debug2!(\"Checking that foo exists in {}\", dest_workspace.display());\n+   debug!(\"Checking that foo exists in {}\", dest_workspace.display());\n    assert_built_library_exists(dest_workspace, \"foo\");\n    assert!(!built_library_exists(&source_dir, \"foo\"));\n }\n@@ -1515,7 +1515,7 @@ fn rust_path_install_target() {\n     let dir_for_path = TempDir::new(\n         \"source_workspace\").expect(\"rust_path_install_target failed\");\n     let mut dir = mk_workspace(dir_for_path.path(), &Path::new(\"foo\"), &NoVersion);\n-    debug2!(\"dir = {}\", dir.display());\n+    debug!(\"dir = {}\", dir.display());\n     writeFile(&dir.join(\"main.rs\"), \"fn main() { let _x = (); }\");\n     let dir_to_install_to = TempDir::new(\n         \"dest_workspace\").expect(\"rust_path_install_target failed\");\n@@ -1696,7 +1696,7 @@ fn test_cfg_fail() {\n                        ~\"build\",\n                        ~\"foo\"],\n                       workspace) {\n-        Success(*) => fail2!(\"test_cfg_fail failed\"),\n+        Success(*) => fail!(\"test_cfg_fail failed\"),\n         _          => ()\n     }\n }\n@@ -1857,7 +1857,7 @@ fn pkgid_pointing_to_subdir() {\n     writeFile(&foo_dir.join(\"lib.rs\"), \"pub fn f() {}\");\n     writeFile(&bar_dir.join(\"lib.rs\"), \"pub fn g() {}\");\n \n-    debug2!(\"Creating a file in {}\", workspace.display());\n+    debug!(\"Creating a file in {}\", workspace.display());\n     let testpkg_dir = workspace.join_many([\"src\", \"testpkg-0.1\"]);\n     assert!(os::mkdir_recursive(&testpkg_dir, U_RWX));\n \n@@ -1888,7 +1888,7 @@ fn test_recursive_deps() {\n                \"extern mod c; use c::g; pub fn f() { g(); }\");\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let environment = Some(~[(~\"RUST_PATH\", b_workspace.as_str().unwrap().to_owned())]);\n-    debug2!(\"RUST_PATH={}\", b_workspace.display());\n+    debug!(\"RUST_PATH={}\", b_workspace.display());\n     command_line_test_with_env([~\"install\", ~\"a\"],\n                                a_workspace,\n                                environment);\n@@ -1908,7 +1908,7 @@ fn test_install_to_rust_path() {\n     let rust_path = Some(~[(~\"RUST_PATH\",\n                             format!(\"{}:{}\", first_workspace.as_str().unwrap(),\n                                     second_workspace.as_str().unwrap()))]);\n-    debug2!(\"RUST_PATH={}:{}\", first_workspace.display(), second_workspace.display());\n+    debug!(\"RUST_PATH={}:{}\", first_workspace.display(), second_workspace.display());\n     let test_sys = test_sysroot();\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     command_line_test_with_env([test_sys.as_str().unwrap().to_owned(),\n@@ -2086,9 +2086,9 @@ fn test_rebuild_when_needed() {\n     frob_source_file(foo_workspace, &foo_id, \"test.rs\");\n     chmod_read_only(&test_executable);\n     match command_line_test_partial([~\"test\", ~\"foo\"], foo_workspace) {\n-        Success(*) => fail2!(\"test_rebuild_when_needed didn't rebuild\"),\n+        Success(*) => fail!(\"test_rebuild_when_needed didn't rebuild\"),\n         Fail(status) if status == 65 => (), // ok\n-        Fail(_) => fail2!(\"test_rebuild_when_needed failed for some other reason\")\n+        Fail(_) => fail!(\"test_rebuild_when_needed failed for some other reason\")\n     }\n }\n \n@@ -2106,8 +2106,8 @@ fn test_no_rebuilding() {\n     chmod_read_only(&test_executable);\n     match command_line_test_partial([~\"test\", ~\"foo\"], foo_workspace) {\n         Success(*) => (), // ok\n-        Fail(status) if status == 65 => fail2!(\"test_no_rebuilding failed: it rebuilt the tests\"),\n-        Fail(_) => fail2!(\"test_no_rebuilding failed for some other reason\")\n+        Fail(status) if status == 65 => fail!(\"test_no_rebuilding failed: it rebuilt the tests\"),\n+        Fail(_) => fail!(\"test_no_rebuilding failed for some other reason\")\n     }\n }\n \n@@ -2118,9 +2118,9 @@ fn test_installed_read_only() {\n     let temp_pkg_id = git_repo_pkg();\n     let repo = init_git_repo(&temp_pkg_id.path);\n     let repo = repo.path();\n-    debug2!(\"repo = {}\", repo.display());\n+    debug!(\"repo = {}\", repo.display());\n     let repo_subdir = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\"]);\n-    debug2!(\"repo_subdir = {}\", repo_subdir.display());\n+    debug!(\"repo_subdir = {}\", repo_subdir.display());\n \n     writeFile(&repo_subdir.join(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n@@ -2133,9 +2133,9 @@ fn test_installed_read_only() {\n \n     let ws = repo.join(\".rust\");\n     // Check that all files exist\n-    debug2!(\"Checking for files in {}\", ws.display());\n+    debug!(\"Checking for files in {}\", ws.display());\n     let exec = target_executable_in_workspace(&temp_pkg_id, &ws);\n-    debug2!(\"exec = {}\", exec.display());\n+    debug!(\"exec = {}\", exec.display());\n     assert!(os::path_exists(&exec));\n     assert!(is_rwx(&exec));\n     let built_lib =\n@@ -2158,9 +2158,9 @@ fn test_installed_local_changes() {\n     let temp_pkg_id = git_repo_pkg();\n     let repo = init_git_repo(&temp_pkg_id.path);\n     let repo = repo.path();\n-    debug2!(\"repo = {}\", repo.display());\n+    debug!(\"repo = {}\", repo.display());\n     let repo_subdir = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\"]);\n-    debug2!(\"repo_subdir = {}\", repo_subdir.display());\n+    debug!(\"repo_subdir = {}\", repo_subdir.display());\n     assert!(os::mkdir_recursive(&repo.join_many([\".rust\", \"src\"]), U_RWX));\n \n     writeFile(&repo_subdir.join(\"main.rs\"),\n@@ -2181,12 +2181,12 @@ fn test_installed_local_changes() {\n                                                   \"mockgithub.com\",\n                                                   \"catamorphism\",\n                                                   \"test-pkg-0.1\"]);\n-    debug2!(\"---- git clone {} {}\", repo_subdir.display(), target_dir.display());\n+    debug!(\"---- git clone {} {}\", repo_subdir.display(), target_dir.display());\n \n     let c_res = safe_git_clone(&repo_subdir, &NoVersion, &target_dir);\n \n     match c_res {\n-        DirToUse(_) => fail2!(\"test_installed_local_changes failed\"),\n+        DirToUse(_) => fail!(\"test_installed_local_changes failed\"),\n         CheckedOutSources => ()\n     };\n \n@@ -2232,9 +2232,9 @@ fn test_compile_error() {\n     writeFile(&main_crate, \"pub fn main() { if 42 != ~\\\"the answer\\\" { fail!(); } }\");\n     let result = command_line_test_partial([~\"build\", ~\"foo\"], foo_workspace);\n     match result {\n-        Success(*) => fail2!(\"Failed by succeeding!\"), // should be a compile error\n+        Success(*) => fail!(\"Failed by succeeding!\"), // should be a compile error\n         Fail(status) => {\n-            debug2!(\"Failed with status {:?}... that's good, right?\", status);\n+            debug!(\"Failed with status {:?}... that's good, right?\", status);\n         }\n     }\n }"}, {"sha": "a3a4a07cfc77a9dbf432c78255d15ea55fba782c", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -175,7 +175,7 @@ pub fn compile_input(context: &BuildContext,\n                      what: OutputType) -> Option<Path> {\n     assert!(in_file.component_iter().nth(1).is_some());\n     let input = driver::file_input(in_file.clone());\n-    debug2!(\"compile_input: {} / {:?}\", in_file.display(), what);\n+    debug!(\"compile_input: {} / {:?}\", in_file.display(), what);\n     // tjc: by default, use the package ID name as the link name\n     // not sure if we should support anything else\n \n@@ -186,10 +186,10 @@ pub fn compile_input(context: &BuildContext,\n \n     let binary = os::args()[0].to_managed();\n \n-    debug2!(\"flags: {}\", flags.connect(\" \"));\n-    debug2!(\"cfgs: {}\", cfgs.connect(\" \"));\n+    debug!(\"flags: {}\", flags.connect(\" \"));\n+    debug!(\"cfgs: {}\", cfgs.connect(\" \"));\n     let csysroot = context.sysroot();\n-    debug2!(\"compile_input's sysroot = {}\", csysroot.display());\n+    debug!(\"compile_input's sysroot = {}\", csysroot.display());\n \n     let crate_type = match what {\n         Lib => lib_crate,\n@@ -206,7 +206,7 @@ pub fn compile_input(context: &BuildContext,\n                           + context.flag_strs()\n                           + cfgs.flat_map(|c| { ~[~\"--cfg\", (*c).clone()] }),\n                           driver::optgroups()).unwrap();\n-    debug2!(\"rustc flags: {:?}\", matches);\n+    debug!(\"rustc flags: {:?}\", matches);\n \n     // Hack so that rustpkg can run either out of a rustc target dir,\n     // or the host dir\n@@ -221,8 +221,8 @@ pub fn compile_input(context: &BuildContext,\n         p\n     };\n     let csysroot = context.sysroot();\n-    debug2!(\"compile_input's sysroot = {}\", csysroot.display());\n-    debug2!(\"sysroot_to_use = {}\", sysroot_to_use.display());\n+    debug!(\"compile_input's sysroot = {}\", csysroot.display());\n+    debug!(\"sysroot_to_use = {}\", sysroot_to_use.display());\n \n     let output_type = match context.compile_upto() {\n         Assemble => link::output_type_assembly,\n@@ -270,7 +270,7 @@ pub fn compile_input(context: &BuildContext,\n \n     find_and_install_dependencies(context, pkg_id, in_file, sess, exec, &crate, deps,\n                                   |p| {\n-                                      debug2!(\"a dependency: {}\", p.display());\n+                                      debug!(\"a dependency: {}\", p.display());\n                                       // Pass the directory containing a dependency\n                                       // as an additional lib search path\n                                       if !addl_lib_search_paths.contains(&p) {\n@@ -287,19 +287,19 @@ pub fn compile_input(context: &BuildContext,\n             Bench => format!(\"{}bench\", pkg_id.short_name).to_managed(),\n             _     => pkg_id.short_name.to_managed()\n         };\n-        debug2!(\"Injecting link name: {}\", name_to_use);\n+        debug!(\"Injecting link name: {}\", name_to_use);\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         let link_options =\n             ~[attr::mk_name_value_item_str(@\"name\", name_to_use),\n               attr::mk_name_value_item_str(@\"vers\", pkg_id.version.to_str().to_managed())] +\n             ~[attr::mk_name_value_item_str(@\"package_id\",\n                                            pkg_id.path.as_str().unwrap().to_managed())];\n \n-        debug2!(\"link options: {:?}\", link_options);\n+        debug!(\"link options: {:?}\", link_options);\n         crate.attrs = ~[attr::mk_attr(attr::mk_list_item(@\"link\", link_options))];\n     }\n \n-    debug2!(\"calling compile_crate_from_input, workspace = {},\n+    debug!(\"calling compile_crate_from_input, workspace = {},\n            building_library = {:?}\", out_dir.display(), sess.building_library);\n     let result = compile_crate_from_input(in_file,\n                                           exec,\n@@ -315,9 +315,9 @@ pub fn compile_input(context: &BuildContext,\n         result\n     };\n     for p in discovered_output.iter() {\n-        debug2!(\"About to discover output {}\", p.display());\n+        debug!(\"About to discover output {}\", p.display());\n         if os::path_exists(p) {\n-            debug2!(\"4. discovering output {}\", p.display());\n+            debug!(\"4. discovering output {}\", p.display());\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             exec.discover_output(\"binary\", p.as_str().unwrap(), digest_only_date(p));\n         }\n@@ -342,22 +342,22 @@ pub fn compile_crate_from_input(input: &Path,\n // Returns None if one of the flags that suppresses compilation output was\n // given\n                                 crate: ast::Crate) -> Option<Path> {\n-    debug2!(\"Calling build_output_filenames with {}, building library? {:?}\",\n+    debug!(\"Calling build_output_filenames with {}, building library? {:?}\",\n            out_dir.display(), sess.building_library);\n \n     // bad copy\n-    debug2!(\"out_dir = {}\", out_dir.display());\n+    debug!(\"out_dir = {}\", out_dir.display());\n     let outputs = driver::build_output_filenames(&driver::file_input(input.clone()),\n                                                  &Some(out_dir.clone()), &None,\n                                                  crate.attrs, sess);\n \n-    debug2!(\"Outputs are out_filename: {} and obj_filename: {} and output type = {:?}\",\n+    debug!(\"Outputs are out_filename: {} and obj_filename: {} and output type = {:?}\",\n            outputs.out_filename.display(),\n            outputs.obj_filename.display(),\n            sess.opts.output_type);\n-    debug2!(\"additional libraries:\");\n+    debug!(\"additional libraries:\");\n     for lib in sess.opts.addl_lib_search_paths.iter() {\n-        debug2!(\"an additional library: {}\", lib.display());\n+        debug!(\"an additional library: {}\", lib.display());\n     }\n     let analysis = driver::phase_3_run_analysis_passes(sess, &crate);\n     if driver::stop_after_phase_3(sess) { return None; }\n@@ -375,7 +375,7 @@ pub fn compile_crate_from_input(input: &Path,\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     exec.discover_input(\"file\", input.as_str().unwrap(), digest_file_with_date(input));\n \n-    debug2!(\"Built {}, date = {:?}\", outputs.out_filename.display(),\n+    debug!(\"Built {}, date = {:?}\", outputs.out_filename.display(),\n            datestamp(&outputs.out_filename));\n \n     Some(outputs.out_filename)\n@@ -401,10 +401,10 @@ pub fn compile_crate(ctxt: &BuildContext,\n                      cfgs: &[~str],\n                      opt: bool,\n                      what: OutputType) -> Option<Path> {\n-    debug2!(\"compile_crate: crate={}, workspace={}\", crate.display(), workspace.display());\n-    debug2!(\"compile_crate: short_name = {}, flags =...\", pkg_id.to_str());\n+    debug!(\"compile_crate: crate={}, workspace={}\", crate.display(), workspace.display());\n+    debug!(\"compile_crate: short_name = {}, flags =...\", pkg_id.to_str());\n     for fl in flags.iter() {\n-        debug2!(\"+++ {}\", *fl);\n+        debug!(\"+++ {}\", *fl);\n     }\n     compile_input(ctxt, exec, pkg_id, crate, workspace, deps, flags, cfgs, opt, what)\n }\n@@ -429,11 +429,11 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                     Some((p, _)) => p,\n                     None => self.sess.str_of(lib_ident)\n                 };\n-                debug2!(\"Finding and installing... {}\", lib_name);\n+                debug!(\"Finding and installing... {}\", lib_name);\n                 // Check standard Rust library path first\n                 match system_library(&self.context.sysroot(), lib_name) {\n                     Some(ref installed_path) => {\n-                        debug2!(\"It exists: {}\", installed_path.display());\n+                        debug!(\"It exists: {}\", installed_path.display());\n                         // Say that [path for c] has a discovered dependency on\n                         // installed_path\n                         // For binary files, we only hash the datestamp, not the contents.\n@@ -449,7 +449,7 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                     }\n                     None => {\n                         // FIXME #8711: need to parse version out of path_opt\n-                        debug2!(\"Trying to install library {}, rebuilding it\",\n+                        debug!(\"Trying to install library {}, rebuilding it\",\n                                lib_name.to_str());\n                         // Try to install it\n                         let pkg_id = PkgId::new(lib_name);\n@@ -479,15 +479,15 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                                                   pkg_id.clone());\n                         let (outputs_disc, inputs_disc) =\n                             self.context.install(pkg_src, &JustOne(Path::new(lib_crate_filename)));\n-                        debug2!(\"Installed {}, returned {:?} dependencies and \\\n+                        debug!(\"Installed {}, returned {:?} dependencies and \\\n                                {:?} transitive dependencies\",\n                                lib_name, outputs_disc.len(), inputs_disc.len());\n-                        debug2!(\"discovered outputs = {:?} discovered_inputs = {:?}\",\n+                        debug!(\"discovered outputs = {:?} discovered_inputs = {:?}\",\n                                outputs_disc, inputs_disc);\n                         // It must have installed *something*...\n                         assert!(!outputs_disc.is_empty());\n                         for dep in outputs_disc.iter() {\n-                            debug2!(\"Discovering a binary input: {}\", dep.display());\n+                            debug!(\"Discovering a binary input: {}\", dep.display());\n                             // FIXME (#9639): This needs to handle non-utf8 paths\n                             self.exec.discover_input(\"binary\",\n                                                      dep.as_str().unwrap(),\n@@ -498,10 +498,10 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n \n                             // Also, add an additional search path\n                             let dep_dir = dep.dir_path();\n-                            debug2!(\"Installed {} into {}\", dep.display(), dep_dir.display());\n+                            debug!(\"Installed {} into {}\", dep.display(), dep_dir.display());\n                             (self.save)(dep_dir);\n                         }\n-                        debug2!(\"Installed {}, returned {} dependencies and \\\n+                        debug!(\"Installed {}, returned {} dependencies and \\\n                                 {} transitive dependencies\",\n                                 lib_name, outputs_disc.len(), inputs_disc.len());\n                         // It must have installed *something*...\n@@ -526,10 +526,10 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                                                          digest_only_date(\n                                                              &Path::new(dep.as_slice())));\n                             } else {\n-                                fail2!(\"Bad kind: {}\", *what);\n+                                fail!(\"Bad kind: {}\", *what);\n                             }\n                             // Also, add an additional search path\n-                            debug2!(\"Installed {} into {}\",\n+                            debug!(\"Installed {} into {}\",\n                                     lib_name, target_workspace.as_str().unwrap().to_owned());\n                             (self.save)(target_workspace.clone());\n                         }\n@@ -554,7 +554,7 @@ pub fn find_and_install_dependencies(context: &BuildContext,\n                                      c: &ast::Crate,\n                                      deps: &mut DepMap,\n                                      save: &fn(Path)) {\n-    debug2!(\"In find_and_install_dependencies...\");\n+    debug!(\"In find_and_install_dependencies...\");\n     let mut visitor = ViewItemVisitor {\n         context: context,\n         parent: parent,\n@@ -608,9 +608,9 @@ fn debug_flags() -> ~[~str] { ~[] }\n \n /// Returns the last-modified date as an Option\n pub fn datestamp(p: &Path) -> Option<libc::time_t> {\n-    debug2!(\"Scrutinizing datestamp for {} - does it exist? {:?}\", p.display(), os::path_exists(p));\n+    debug!(\"Scrutinizing datestamp for {} - does it exist? {:?}\", p.display(), os::path_exists(p));\n     let out = p.stat().map(|stat| stat.st_mtime);\n-    debug2!(\"Date = {:?}\", out);\n+    debug!(\"Date = {:?}\", out);\n     out.map(|t| { t as libc::time_t })\n }\n "}, {"sha": "6ca19562724fe8b0a60e22e5d1abb3070ebae30a", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -107,7 +107,7 @@ pub fn try_getting_local_version(local_path: &Path) -> Option<Version> {\n         let outp = run::process_output(\"git\",\n                                    [\"--git-dir=\" + git_dir.as_str().unwrap(), ~\"tag\", ~\"-l\"]);\n \n-        debug2!(\"git --git-dir={} tag -l ~~~> {:?}\", git_dir.display(), outp.status);\n+        debug!(\"git --git-dir={} tag -l ~~~> {:?}\", git_dir.display(), outp.status);\n \n         if outp.status != 0 {\n             continue;\n@@ -136,29 +136,29 @@ pub fn try_getting_version(remote_path: &Path) -> Option<Version> {\n         let tmp_dir = TempDir::new(\"test\");\n         let tmp_dir = tmp_dir.expect(\"try_getting_version: couldn't create temp dir\");\n         let tmp_dir = tmp_dir.path();\n-        debug2!(\"(to get version) executing \\\\{git clone https://{} {}\\\\}\",\n+        debug!(\"(to get version) executing \\\\{git clone https://{} {}\\\\}\",\n                remote_path.display(),\n                tmp_dir.display());\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         let outp  = run::process_output(\"git\", [~\"clone\", format!(\"https://{}\",\n                                                                   remote_path.as_str().unwrap()),\n                                                 tmp_dir.as_str().unwrap().to_owned()]);\n         if outp.status == 0 {\n-            debug2!(\"Cloned it... ( {}, {} )\",\n+            debug!(\"Cloned it... ( {}, {} )\",\n                    str::from_utf8(outp.output),\n                    str::from_utf8(outp.error));\n             let mut output = None;\n             let git_dir = tmp_dir.join(\".git\");\n-            debug2!(\"(getting version, now getting tags) executing \\\\{git --git-dir={} tag -l\\\\}\",\n+            debug!(\"(getting version, now getting tags) executing \\\\{git --git-dir={} tag -l\\\\}\",\n                    git_dir.display());\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             let outp = run::process_output(\"git\",\n                                            [\"--git-dir=\" + git_dir.as_str().unwrap(),\n                                             ~\"tag\", ~\"-l\"]);\n             let output_text = str::from_utf8(outp.output);\n-            debug2!(\"Full output: ( {} ) [{:?}]\", output_text, outp.status);\n+            debug!(\"Full output: ( {} ) [{:?}]\", output_text, outp.status);\n             for l in output_text.line_iter() {\n-                debug2!(\"A line of output: {}\", l);\n+                debug!(\"A line of output: {}\", l);\n                 if !l.is_whitespace() {\n                     output = Some(l);\n                 }\n@@ -185,7 +185,7 @@ enum ParseState {\n \n pub fn try_parsing_version(s: &str) -> Option<Version> {\n     let s = s.trim();\n-    debug2!(\"Attempting to parse: {}\", s);\n+    debug!(\"Attempting to parse: {}\", s);\n     let mut parse_state = Start;\n     for c in s.iter() {\n         if char::is_digit(c) {\n@@ -248,7 +248,7 @@ fn test_parse_version() {\n #[test]\n fn test_split_version() {\n     let s = \"a/b/c#0.1\";\n-    debug2!(\"== {:?} ==\", split_version(s));\n+    debug!(\"== {:?} ==\", split_version(s));\n     assert!(split_version(s) == Some((s.slice(0, 5), ExactRevision(~\"0.1\"))));\n     assert!(split_version(\"a/b/c\") == None);\n     let s = \"a#1.2\";"}, {"sha": "0352067a7e9edf7387ce438fcf974db7f3fbacf6", "filename": "src/librustpkg/workcache_support.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustpkg%2Fworkcache_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustpkg%2Fworkcache_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkcache_support.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -54,9 +54,9 @@ pub fn digest_only_date(path: &Path) -> ~str {\n \n /// Adds multiple discovered outputs\n pub fn discover_outputs(e: &mut workcache::Exec, outputs: ~[Path]) {\n-    debug2!(\"Discovering {:?} outputs\", outputs.len());\n+    debug!(\"Discovering {:?} outputs\", outputs.len());\n     for p in outputs.iter() {\n-        debug2!(\"Discovering output! {}\", p.display());\n+        debug!(\"Discovering output! {}\", p.display());\n         // For now, assume that all discovered outputs are binaries\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         e.discover_output(\"binary\", p.as_str().unwrap(), digest_only_date(p));"}, {"sha": "a35500372467c2e5dad9caf65c35c42c96006cfc", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -24,7 +24,7 @@ pub fn each_pkg_parent_workspace(cx: &Context, pkgid: &PkgId, action: &fn(&Path)\n     let workspaces = pkg_parent_workspaces(cx, pkgid);\n     if workspaces.is_empty() {\n         // tjc: make this a condition\n-        fail2!(\"Package {} not found in any of \\\n+        fail!(\"Package {} not found in any of \\\n                     the following workspaces: {}\",\n                    pkgid.path.display(),\n                    rust_path().map(|p| p.display().to_str()).to_str());"}, {"sha": "ee0b9b0df0b808b95124f2d1ad4c56a945e234e5", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -238,7 +238,7 @@ pub mod raw {\n                 let alloc = n * (*ty).size;\n                 let total_size = alloc + mem::size_of::<Vec<()>>();\n                 if alloc / (*ty).size != n || total_size < alloc {\n-                    fail2!(\"vector size is too large: {}\", n);\n+                    fail!(\"vector size is too large: {}\", n);\n                 }\n                 (*ptr) = local_realloc(*ptr as *(), total_size) as *mut Box<Vec<()>>;\n                 (**ptr).data.alloc = alloc;"}, {"sha": "acfa02a4defd5f2782068673b135c83d927e15ce", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -116,7 +116,7 @@ impl CString {\n     ///\n     /// Fails if the CString is null.\n     pub fn with_ref<T>(&self, f: &fn(*libc::c_char) -> T) -> T {\n-        if self.buf.is_null() { fail2!(\"CString is null!\"); }\n+        if self.buf.is_null() { fail!(\"CString is null!\"); }\n         f(self.buf)\n     }\n \n@@ -126,7 +126,7 @@ impl CString {\n     ///\n     /// Fails if the CString is null.\n     pub fn with_mut_ref<T>(&mut self, f: &fn(*mut libc::c_char) -> T) -> T {\n-        if self.buf.is_null() { fail2!(\"CString is null!\"); }\n+        if self.buf.is_null() { fail!(\"CString is null!\"); }\n         f(unsafe { cast::transmute_mut_unsafe(self.buf) })\n     }\n \n@@ -152,7 +152,7 @@ impl CString {\n     /// Fails if the CString is null.\n     #[inline]\n     pub fn as_bytes<'a>(&'a self) -> &'a [u8] {\n-        if self.buf.is_null() { fail2!(\"CString is null!\"); }\n+        if self.buf.is_null() { fail!(\"CString is null!\"); }\n         unsafe {\n             cast::transmute((self.buf, self.len() + 1))\n         }\n@@ -273,7 +273,7 @@ impl<'self> ToCStr for &'self [u8] {\n         do self.as_imm_buf |self_buf, self_len| {\n             let buf = libc::malloc(self_len as libc::size_t + 1) as *mut u8;\n             if buf.is_null() {\n-                fail2!(\"failed to allocate memory!\");\n+                fail!(\"failed to allocate memory!\");\n             }\n \n             ptr::copy_memory(buf, self_buf, self_len);"}, {"sha": "a1459b780dfb3cd204d4d47bc8f1d04eb2da374e", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -44,7 +44,7 @@ impl<T> Cell<T> {\n     pub fn take(&self) -> T {\n         let this = unsafe { transmute_mut(self) };\n         if this.is_empty() {\n-            fail2!(\"attempt to take an empty cell\");\n+            fail!(\"attempt to take an empty cell\");\n         }\n \n         this.value.take_unwrap()\n@@ -60,7 +60,7 @@ impl<T> Cell<T> {\n     pub fn put_back(&self, value: T) {\n         let this = unsafe { transmute_mut(self) };\n         if !this.is_empty() {\n-            fail2!(\"attempt to put a value back into a full cell\");\n+            fail!(\"attempt to put a value back into a full cell\");\n         }\n         this.value = Some(value);\n     }"}, {"sha": "643498f000af695b0714bef76a428ff3e4fee84f", "filename": "src/libstd/char.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fchar.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -187,7 +187,7 @@ pub fn is_digit_radix(c: char, radix: uint) -> bool {\n #[inline]\n pub fn to_digit(c: char, radix: uint) -> Option<uint> {\n     if radix > 36 {\n-        fail2!(\"to_digit: radix {} is to high (maximum 36)\", radix);\n+        fail!(\"to_digit: radix {} is to high (maximum 36)\", radix);\n     }\n     let val = match c {\n       '0' .. '9' => c as uint - ('0' as uint),\n@@ -214,7 +214,7 @@ pub fn to_digit(c: char, radix: uint) -> Option<uint> {\n #[inline]\n pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n     if radix > 36 {\n-        fail2!(\"from_digit: radix {} is to high (maximum 36)\", num);\n+        fail!(\"from_digit: radix {} is to high (maximum 36)\", num);\n     }\n     if num < radix {\n         unsafe {\n@@ -342,7 +342,7 @@ pub fn len_utf8_bytes(c: char) -> uint {\n         _ if code < MAX_TWO_B   => 2u,\n         _ if code < MAX_THREE_B => 3u,\n         _ if code < MAX_FOUR_B  => 4u,\n-        _                       => fail2!(\"invalid character!\"),\n+        _                       => fail!(\"invalid character!\"),\n     }\n }\n "}, {"sha": "a9070a7a7a2727cee40a026dadbe0b3f6ae41e3c", "filename": "src/libstd/cleanup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcleanup.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -123,7 +123,7 @@ pub unsafe fn annihilate() {\n \n     if debug_mem() {\n         // We do logging here w/o allocation.\n-        debug2!(\"annihilator stats:\\n  \\\n+        debug!(\"annihilator stats:\\n  \\\n                        total boxes: {}\\n  \\\n                       unique boxes: {}\\n  \\\n                        bytes freed: {}\","}, {"sha": "cb9552b189ce5b7fa99184bb694473501f5e8461", "filename": "src/libstd/condition.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcondition.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -56,7 +56,7 @@ do my_error::cond.trap(|raised_int| {\n Condition handling is useful in cases where propagating errors is either to\n cumbersome or just not necessary in the first place. It should also be noted,\n though, that if there is not handler installed when a condition is raised, then\n-the task invokes `fail2!()` and will terminate.\n+the task invokes `fail!()` and will terminate.\n \n ## More Info\n \n@@ -128,19 +128,19 @@ impl<T, U> Condition<T, U> {\n     /// function will not return.\n     pub fn raise(&self, t: T) -> U {\n         let msg = format!(\"Unhandled condition: {}: {:?}\", self.name, t);\n-        self.raise_default(t, || fail2!(\"{}\", msg.clone()))\n+        self.raise_default(t, || fail!(\"{}\", msg.clone()))\n     }\n \n     /// Performs the same functionality as `raise`, except that when no handler\n     /// is found the `default` argument is called instead of failing the task.\n     pub fn raise_default(&self, t: T, default: &fn() -> U) -> U {\n         match local_data::pop(self.key) {\n             None => {\n-                debug2!(\"Condition.raise: found no handler\");\n+                debug!(\"Condition.raise: found no handler\");\n                 default()\n             }\n             Some(handler) => {\n-                debug2!(\"Condition.raise: found handler\");\n+                debug!(\"Condition.raise: found handler\");\n                 match handler.prev {\n                     None => {}\n                     Some(hp) => local_data::set(self.key, hp)\n@@ -183,7 +183,7 @@ impl<'self, T, U> Trap<'self, T, U> {\n     /// ```\n     pub fn inside<V>(&self, inner: &'self fn() -> V) -> V {\n         let _g = Guard { cond: self.cond };\n-        debug2!(\"Trap: pushing handler to TLS\");\n+        debug!(\"Trap: pushing handler to TLS\");\n         local_data::set(self.cond.key, self.handler);\n         inner()\n     }\n@@ -197,7 +197,7 @@ struct Guard<'self, T, U> {\n #[unsafe_destructor]\n impl<'self, T, U> Drop for Guard<'self, T, U> {\n     fn drop(&mut self) {\n-        debug2!(\"Guard: popping handler from TLS\");\n+        debug!(\"Guard: popping handler from TLS\");\n         let curr = local_data::pop(self.cond.key);\n         match curr {\n             None => {}\n@@ -216,20 +216,20 @@ mod test {\n     }\n \n     fn trouble(i: int) {\n-        debug2!(\"trouble: raising condition\");\n+        debug!(\"trouble: raising condition\");\n         let j = sadness::cond.raise(i);\n-        debug2!(\"trouble: handler recovered with {}\", j);\n+        debug!(\"trouble: handler recovered with {}\", j);\n     }\n \n     fn nested_trap_test_inner() {\n         let mut inner_trapped = false;\n \n         do sadness::cond.trap(|_j| {\n-            debug2!(\"nested_trap_test_inner: in handler\");\n+            debug!(\"nested_trap_test_inner: in handler\");\n             inner_trapped = true;\n             0\n         }).inside {\n-            debug2!(\"nested_trap_test_inner: in protected block\");\n+            debug!(\"nested_trap_test_inner: in protected block\");\n             trouble(1);\n         }\n \n@@ -241,10 +241,10 @@ mod test {\n         let mut outer_trapped = false;\n \n         do sadness::cond.trap(|_j| {\n-            debug2!(\"nested_trap_test_outer: in handler\");\n+            debug!(\"nested_trap_test_outer: in handler\");\n             outer_trapped = true; 0\n         }).inside {\n-            debug2!(\"nested_guard_test_outer: in protected block\");\n+            debug!(\"nested_guard_test_outer: in protected block\");\n             nested_trap_test_inner();\n             trouble(1);\n         }\n@@ -256,13 +256,13 @@ mod test {\n         let mut inner_trapped = false;\n \n         do sadness::cond.trap(|_j| {\n-            debug2!(\"nested_reraise_trap_test_inner: in handler\");\n+            debug!(\"nested_reraise_trap_test_inner: in handler\");\n             inner_trapped = true;\n             let i = 10;\n-            debug2!(\"nested_reraise_trap_test_inner: handler re-raising\");\n+            debug!(\"nested_reraise_trap_test_inner: handler re-raising\");\n             sadness::cond.raise(i)\n         }).inside {\n-            debug2!(\"nested_reraise_trap_test_inner: in protected block\");\n+            debug!(\"nested_reraise_trap_test_inner: in protected block\");\n             trouble(1);\n         }\n \n@@ -274,10 +274,10 @@ mod test {\n         let mut outer_trapped = false;\n \n         do sadness::cond.trap(|_j| {\n-            debug2!(\"nested_reraise_trap_test_outer: in handler\");\n+            debug!(\"nested_reraise_trap_test_outer: in handler\");\n             outer_trapped = true; 0\n         }).inside {\n-            debug2!(\"nested_reraise_trap_test_outer: in protected block\");\n+            debug!(\"nested_reraise_trap_test_outer: in protected block\");\n             nested_reraise_trap_test_inner();\n         }\n \n@@ -289,10 +289,10 @@ mod test {\n         let mut trapped = false;\n \n         do sadness::cond.trap(|j| {\n-            debug2!(\"test_default: in handler\");\n+            debug!(\"test_default: in handler\");\n             sadness::cond.raise_default(j, || { trapped=true; 5 })\n         }).inside {\n-            debug2!(\"test_default: in protected block\");\n+            debug!(\"test_default: in protected block\");\n             trouble(1);\n         }\n "}, {"sha": "262cdaed492acd897f54dae9755bf65f8636ce42", "filename": "src/libstd/either.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Feither.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -78,7 +78,7 @@ impl<L, R> Either<L, R> {\n     pub fn expect_left(self, reason: &str) -> L {\n         match self {\n             Left(x) => x,\n-            Right(_) => fail2!(\"{}\", reason.to_owned())\n+            Right(_) => fail!(\"{}\", reason.to_owned())\n         }\n     }\n \n@@ -94,7 +94,7 @@ impl<L, R> Either<L, R> {\n     pub fn expect_right(self, reason: &str) -> R {\n         match self {\n             Right(x) => x,\n-            Left(_) => fail2!(\"{}\", reason.to_owned())\n+            Left(_) => fail!(\"{}\", reason.to_owned())\n         }\n     }\n "}, {"sha": "ed7fc9eb1d9546215685e3ed0e84820dbf10119b", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -493,18 +493,18 @@ mod tests {\n         }\n \n         while t < 64 {\n-            debug2!(\"siphash test {}\", t);\n+            debug!(\"siphash test {}\", t);\n             let vec = u8to64_le!(vecs[t], 0);\n             let out = Bytes(buf.as_slice()).hash_keyed(k0, k1);\n-            debug2!(\"got {:?}, expected {:?}\", out, vec);\n+            debug!(\"got {:?}, expected {:?}\", out, vec);\n             assert_eq!(vec, out);\n \n             stream_full.reset();\n             stream_full.input(buf);\n             let f = stream_full.result_str();\n             let i = stream_inc.result_str();\n             let v = to_hex_str(&vecs[t]);\n-            debug2!(\"{}: ({}) => inc={} full={}\", t, v, i, f);\n+            debug!(\"{}: ({}) => inc={} full={}\", t, v, i, f);\n \n             assert!(f == i && f == v);\n "}, {"sha": "edefd39ebb4d1c62f7be6b50d99dffcaa468e333", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -179,7 +179,7 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n     fn value_for_bucket<'a>(&'a self, idx: uint) -> &'a V {\n         match self.buckets[idx] {\n             Some(ref bkt) => &bkt.value,\n-            None => fail2!(\"HashMap::find: internal logic error\"),\n+            None => fail!(\"HashMap::find: internal logic error\"),\n         }\n     }\n \n@@ -196,7 +196,7 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n     /// True if there was no previous entry with that key\n     fn insert_internal(&mut self, hash: uint, k: K, v: V) -> Option<V> {\n         match self.bucket_for_key_with_hash(hash, &k) {\n-            TableFull => { fail2!(\"Internal logic error\"); }\n+            TableFull => { fail!(\"Internal logic error\"); }\n             FoundHole(idx) => {\n                 self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n                                                 value: v});\n@@ -205,7 +205,7 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n             }\n             FoundEntry(idx) => {\n                 match self.buckets[idx] {\n-                    None => { fail2!(\"insert_internal: Internal logic error\") }\n+                    None => { fail!(\"insert_internal: Internal logic error\") }\n                     Some(ref mut b) => {\n                         b.hash = hash;\n                         b.key = k;\n@@ -374,7 +374,7 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n \n         let hash = k.hash_keyed(self.k0, self.k1) as uint;\n         let idx = match self.bucket_for_key_with_hash(hash, &k) {\n-            TableFull => fail2!(\"Internal logic error\"),\n+            TableFull => fail!(\"Internal logic error\"),\n             FoundEntry(idx) => { found(&k, self.mut_value_for_bucket(idx), a); idx }\n             FoundHole(idx) => {\n                 let v = not_found(&k, a);\n@@ -413,7 +413,7 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n     pub fn get<'a>(&'a self, k: &K) -> &'a V {\n         match self.find(k) {\n             Some(v) => v,\n-            None => fail2!(\"No entry found for key: {:?}\", k),\n+            None => fail!(\"No entry found for key: {:?}\", k),\n         }\n     }\n \n@@ -422,7 +422,7 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n     pub fn get_mut<'a>(&'a mut self, k: &K) -> &'a mut V {\n         match self.find_mut(k) {\n             Some(v) => v,\n-            None => fail2!(\"No entry found for key: {:?}\", k),\n+            None => fail!(\"No entry found for key: {:?}\", k),\n         }\n     }\n \n@@ -826,7 +826,7 @@ mod test_map {\n         assert!(m.insert(5, 14));\n         let new = 100;\n         match m.find_mut(&5) {\n-            None => fail2!(), Some(x) => *x = new\n+            None => fail!(), Some(x) => *x = new\n         }\n         assert_eq!(m.find(&5), Some(&new));\n     }\n@@ -943,7 +943,7 @@ mod test_map {\n         assert!(m.find(&1).is_none());\n         m.insert(1, 2);\n         match m.find(&1) {\n-            None => fail2!(),\n+            None => fail!(),\n             Some(v) => assert!(*v == 2)\n         }\n     }"}, {"sha": "94a6b7cfea8dd1c69714a80aae89a1d19a4b2b92", "filename": "src/libstd/io.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -946,8 +946,8 @@ impl Reader for *libc::FILE {\n                   match libc::ferror(*self) {\n                     0 => (),\n                     _ => {\n-                      error2!(\"error reading buffer: {}\", os::last_os_error());\n-                      fail2!();\n+                      error!(\"error reading buffer: {}\", os::last_os_error());\n+                      fail!();\n                     }\n                   }\n                 }\n@@ -1194,8 +1194,8 @@ impl Writer for *libc::FILE {\n                                         len as size_t,\n                                         *self);\n                 if nout != len as size_t {\n-                    error2!(\"error writing buffer: {}\", os::last_os_error());\n-                    fail2!();\n+                    error!(\"error writing buffer: {}\", os::last_os_error());\n+                    fail!();\n                 }\n             }\n         }\n@@ -1255,21 +1255,21 @@ impl Writer for fd_t {\n                     let vb = ptr::offset(vbuf, count as int) as *c_void;\n                     let nout = libc::write(*self, vb, len as IoSize);\n                     if nout < 0 as IoRet {\n-                        error2!(\"error writing buffer: {}\", os::last_os_error());\n-                        fail2!();\n+                        error!(\"error writing buffer: {}\", os::last_os_error());\n+                        fail!();\n                     }\n                     count += nout as uint;\n                 }\n             }\n         }\n     }\n     fn seek(&self, _offset: int, _whence: SeekStyle) {\n-        error2!(\"need 64-bit foreign calls for seek, sorry\");\n-        fail2!();\n+        error!(\"need 64-bit foreign calls for seek, sorry\");\n+        fail!();\n     }\n     fn tell(&self) -> uint {\n-        error2!(\"need 64-bit foreign calls for tell, sorry\");\n-        fail2!();\n+        error!(\"need 64-bit foreign calls for tell, sorry\");\n+        fail!();\n     }\n     fn flush(&self) -> int { 0 }\n     fn get_type(&self) -> WriterType {\n@@ -1895,17 +1895,17 @@ mod tests {\n     #[test]\n     fn test_simple() {\n         let tmpfile = &Path::new(\"tmp/lib-io-test-simple.tmp\");\n-        debug2!(\"{}\", tmpfile.display());\n+        debug!(\"{}\", tmpfile.display());\n         let frood: ~str =\n             ~\"A hoopy frood who really knows where his towel is.\";\n-        debug2!(\"{}\", frood.clone());\n+        debug!(\"{}\", frood.clone());\n         {\n             let out = io::file_writer(tmpfile, [io::Create, io::Truncate]).unwrap();\n             out.write_str(frood);\n         }\n         let inp = io::file_reader(tmpfile).unwrap();\n         let frood2: ~str = inp.read_c_str();\n-        debug2!(\"{}\", frood2.clone());\n+        debug!(\"{}\", frood2.clone());\n         assert_eq!(frood, frood2);\n     }\n \n@@ -1922,14 +1922,14 @@ mod tests {\n         {\n             let file = io::file_reader(&path).unwrap();\n             do file.each_byte() |_| {\n-                fail2!(\"must be empty\")\n+                fail!(\"must be empty\")\n             };\n         }\n \n         {\n             let file = io::file_reader(&path).unwrap();\n             do file.each_char() |_| {\n-                fail2!(\"must be empty\")\n+                fail!(\"must be empty\")\n             };\n         }\n     }\n@@ -2016,7 +2016,7 @@ mod tests {\n           Err(e) => {\n             assert_eq!(e, ~\"error opening not a file\");\n           }\n-          Ok(_) => fail2!()\n+          Ok(_) => fail!()\n         }\n     }\n \n@@ -2056,7 +2056,7 @@ mod tests {\n           Err(e) => {\n             assert!(e.starts_with(\"error opening\"));\n           }\n-          Ok(_) => fail2!()\n+          Ok(_) => fail!()\n         }\n     }\n "}, {"sha": "01af3d931573cd3234eac42b51ae38719cdc95f9", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -742,7 +742,7 @@ pub trait ExactSize<A> : DoubleEndedIterator<A> {\n                 Some(x) => {\n                     i = match i.checked_sub(&1) {\n                         Some(x) => x,\n-                        None => fail2!(\"rposition: incorrect ExactSize\")\n+                        None => fail!(\"rposition: incorrect ExactSize\")\n                     };\n                     if predicate(x) {\n                         return Some(i)\n@@ -2487,7 +2487,7 @@ mod tests {\n         assert!(v.iter().all(|&x| x < 10));\n         assert!(!v.iter().all(|&x| x.is_even()));\n         assert!(!v.iter().all(|&x| x > 100));\n-        assert!(v.slice(0, 0).iter().all(|_| fail2!()));\n+        assert!(v.slice(0, 0).iter().all(|_| fail!()));\n     }\n \n     #[test]\n@@ -2496,7 +2496,7 @@ mod tests {\n         assert!(v.iter().any(|&x| x < 10));\n         assert!(v.iter().any(|&x| x.is_even()));\n         assert!(!v.iter().any(|&x| x > 100));\n-        assert!(!v.slice(0, 0).iter().any(|_| fail2!()));\n+        assert!(!v.slice(0, 0).iter().any(|_| fail!()));\n     }\n \n     #[test]\n@@ -2646,7 +2646,7 @@ mod tests {\n         let mut i = 0;\n         do v.iter().rposition |_elt| {\n             if i == 2 {\n-                fail2!()\n+                fail!()\n             }\n             i += 1;\n             false\n@@ -2790,12 +2790,12 @@ mod tests {\n     fn test_double_ended_range() {\n         assert_eq!(range(11i, 14).invert().collect::<~[int]>(), ~[13i, 12, 11]);\n         for _ in range(10i, 0).invert() {\n-            fail2!(\"unreachable\");\n+            fail!(\"unreachable\");\n         }\n \n         assert_eq!(range(11u, 14).invert().collect::<~[uint]>(), ~[13u, 12, 11]);\n         for _ in range(10u, 0).invert() {\n-            fail2!(\"unreachable\");\n+            fail!(\"unreachable\");\n         }\n     }\n "}, {"sha": "30175d6609b93167243c9f7ebc9731ab2c7d7ba3", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -144,7 +144,7 @@ pub fn pop<T: 'static>(key: Key<T>) -> Option<T> {\n         match *entry {\n             Some((k, _, loan)) if k == key_value => {\n                 if loan != NoLoan {\n-                    fail2!(\"TLS value cannot be removed because it is currently \\\n+                    fail!(\"TLS value cannot be removed because it is currently \\\n                           borrowed as {}\", loan.describe());\n                 }\n                 // Move the data out of the `entry` slot via util::replace.\n@@ -241,7 +241,7 @@ fn get_with<T: 'static, U>(key: Key<T>,\n                         }\n                         (ImmLoan, ImmLoan) => {}\n                         (want, cur) => {\n-                            fail2!(\"TLS slot cannot be borrowed as {} because \\\n+                            fail!(\"TLS slot cannot be borrowed as {} because \\\n                                     it is already borrowed as {}\",\n                                   want.describe(), cur.describe());\n                         }\n@@ -305,7 +305,7 @@ pub fn set<T: 'static>(key: Key<T>, data: T) {\n             match *entry {\n                 Some((ekey, _, loan)) if key == ekey => {\n                     if loan != NoLoan {\n-                        fail2!(\"TLS value cannot be overwritten because it is\n+                        fail!(\"TLS value cannot be overwritten because it is\n                                already borrowed as {}\", loan.describe())\n                     }\n                     true\n@@ -389,15 +389,15 @@ mod tests {\n         static my_key: Key<@~str> = &Key;\n         modify(my_key, |data| {\n             match data {\n-                Some(@ref val) => fail2!(\"unwelcome value: {}\", *val),\n+                Some(@ref val) => fail!(\"unwelcome value: {}\", *val),\n                 None           => Some(@~\"first data\")\n             }\n         });\n         modify(my_key, |data| {\n             match data {\n                 Some(@~\"first data\") => Some(@~\"next data\"),\n-                Some(@ref val)       => fail2!(\"wrong value: {}\", *val),\n-                None                 => fail2!(\"missing value\")\n+                Some(@ref val)       => fail!(\"wrong value: {}\", *val),\n+                None                 => fail!(\"missing value\")\n             }\n         });\n         assert!(*(pop(my_key).unwrap()) == ~\"next data\");\n@@ -457,11 +457,11 @@ mod tests {\n             set(str_key, @~\"string data\");\n             set(box_key, @@());\n             set(int_key, @42);\n-            fail2!();\n+            fail!();\n         }\n         // Not quite nondeterministic.\n         set(int_key, @31337);\n-        fail2!();\n+        fail!();\n     }\n \n     #[test]"}, {"sha": "3103731a52faf110ece91a8e1f2eef962bf523c0", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -820,7 +820,7 @@ impl num::ToStrRadix for f32 {\n     fn to_str_radix(&self, rdx: uint) -> ~str {\n         let (r, special) = strconv::float_to_str_common(\n             *self, rdx, true, strconv::SignNeg, strconv::DigAll);\n-        if special { fail2!(\"number has a special value, \\\n+        if special { fail!(\"number has a special value, \\\n                              try to_str_radix_special() if those are expected\") }\n         r\n     }"}, {"sha": "da8270703d72fff004d14f013d8f8d734a1e0a61", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -868,7 +868,7 @@ impl num::ToStrRadix for f64 {\n     fn to_str_radix(&self, rdx: uint) -> ~str {\n         let (r, special) = strconv::float_to_str_common(\n             *self, rdx, true, strconv::SignNeg, strconv::DigAll);\n-        if special { fail2!(\"number has a special value, \\\n+        if special { fail!(\"number has a special value, \\\n                              try to_str_radix_special() if those are expected\") }\n         r\n     }"}, {"sha": "d17c947ab5620398c78affd7810adb22816414b2", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -473,19 +473,19 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Div<T,T>+\n         ) -> Option<T> {\n     match exponent {\n         ExpDec if radix >= DIGIT_E_RADIX       // decimal exponent 'e'\n-          => fail2!(\"from_str_bytes_common: radix {:?} incompatible with \\\n+          => fail!(\"from_str_bytes_common: radix {:?} incompatible with \\\n                     use of 'e' as decimal exponent\", radix),\n         ExpBin if radix >= DIGIT_P_RADIX       // binary exponent 'p'\n-          => fail2!(\"from_str_bytes_common: radix {:?} incompatible with \\\n+          => fail!(\"from_str_bytes_common: radix {:?} incompatible with \\\n                     use of 'p' as binary exponent\", radix),\n         _ if special && radix >= DIGIT_I_RADIX // first digit of 'inf'\n-          => fail2!(\"from_str_bytes_common: radix {:?} incompatible with \\\n+          => fail!(\"from_str_bytes_common: radix {:?} incompatible with \\\n                     special values 'inf' and 'NaN'\", radix),\n         _ if (radix as int) < 2\n-          => fail2!(\"from_str_bytes_common: radix {:?} to low, \\\n+          => fail!(\"from_str_bytes_common: radix {:?} to low, \\\n                     must lie in the range [2, 36]\", radix),\n         _ if (radix as int) > 36\n-          => fail2!(\"from_str_bytes_common: radix {:?} to high, \\\n+          => fail!(\"from_str_bytes_common: radix {:?} to high, \\\n                     must lie in the range [2, 36]\", radix),\n         _ => ()\n     }"}, {"sha": "732dbe64d015fb35db16acb6237f95cd3a947974", "filename": "src/libstd/option.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -244,7 +244,7 @@ impl<T> Option<T> {\n     pub fn get_ref<'a>(&'a self) -> &'a T {\n         match *self {\n             Some(ref x) => x,\n-            None => fail2!(\"called `Option::get_ref()` on a `None` value\"),\n+            None => fail!(\"called `Option::get_ref()` on a `None` value\"),\n         }\n     }\n \n@@ -264,7 +264,7 @@ impl<T> Option<T> {\n     pub fn get_mut_ref<'a>(&'a mut self) -> &'a mut T {\n         match *self {\n             Some(ref mut x) => x,\n-            None => fail2!(\"called `Option::get_mut_ref()` on a `None` value\"),\n+            None => fail!(\"called `Option::get_mut_ref()` on a `None` value\"),\n         }\n     }\n \n@@ -286,7 +286,7 @@ impl<T> Option<T> {\n     pub fn unwrap(self) -> T {\n         match self {\n             Some(x) => x,\n-            None => fail2!(\"called `Option::unwrap()` on a `None` value\"),\n+            None => fail!(\"called `Option::unwrap()` on a `None` value\"),\n         }\n     }\n \n@@ -299,7 +299,7 @@ impl<T> Option<T> {\n     #[inline]\n     pub fn take_unwrap(&mut self) -> T {\n         if self.is_none() {\n-            fail2!(\"called `Option::take_unwrap()` on a `None` value\")\n+            fail!(\"called `Option::take_unwrap()` on a `None` value\")\n         }\n         self.take().unwrap()\n     }\n@@ -314,7 +314,7 @@ impl<T> Option<T> {\n     pub fn expect(self, reason: &str) -> T {\n         match self {\n             Some(val) => val,\n-            None => fail2!(\"{}\", reason.to_owned()),\n+            None => fail!(\"{}\", reason.to_owned()),\n         }\n     }\n \n@@ -630,7 +630,7 @@ mod tests {\n \n     #[test]\n     #[should_fail]\n-    fn test_unwrap_fail2() {\n+    fn test_unwrap_fail() {\n         let x: Option<~str> = None;\n         x.unwrap();\n     }"}, {"sha": "ba2b42c9b9c8b227d50c263ee1f88cf62ffdea79", "filename": "src/libstd/os.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -89,7 +89,7 @@ pub fn getcwd() -> Path {\n     do buf.as_mut_buf |buf, len| {\n         unsafe {\n             if libc::getcwd(buf, len as size_t).is_null() {\n-                fail2!()\n+                fail!()\n             }\n \n             Path::new(CString::new(buf as *c_char, false))\n@@ -106,7 +106,7 @@ pub fn getcwd() -> Path {\n     do buf.as_mut_buf |buf, len| {\n         unsafe {\n             if libc::GetCurrentDirectoryW(len as DWORD, buf) == 0 as DWORD {\n-                fail2!();\n+                fail!();\n             }\n         }\n     }\n@@ -197,7 +197,7 @@ pub fn env() -> ~[(~str,~str)] {\n             };\n             let ch = GetEnvironmentStringsA();\n             if (ch as uint == 0) {\n-                fail2!(\"os::env() failure getting env string from OS: {}\",\n+                fail!(\"os::env() failure getting env string from OS: {}\",\n                        os::last_os_error());\n             }\n             let result = str::raw::from_c_multistring(ch as *libc::c_char, None);\n@@ -213,13 +213,13 @@ pub fn env() -> ~[(~str,~str)] {\n             }\n             let environ = rust_env_pairs();\n             if (environ as uint == 0) {\n-                fail2!(\"os::env() failure getting env string from OS: {}\",\n+                fail!(\"os::env() failure getting env string from OS: {}\",\n                        os::last_os_error());\n             }\n             let mut result = ~[];\n             ptr::array_each(environ, |e| {\n                 let env_pair = str::raw::from_c_str(e);\n-                debug2!(\"get_env_pairs: {}\", env_pair);\n+                debug!(\"get_env_pairs: {}\", env_pair);\n                 result.push(env_pair);\n             });\n             result\n@@ -229,7 +229,7 @@ pub fn env() -> ~[(~str,~str)] {\n             let mut pairs = ~[];\n             for p in input.iter() {\n                 let vs: ~[&str] = p.splitn_iter('=', 1).collect();\n-                debug2!(\"splitting: len: {}\", vs.len());\n+                debug!(\"splitting: len: {}\", vs.len());\n                 assert_eq!(vs.len(), 2);\n                 pairs.push((vs[0].to_owned(), vs[1].to_owned()));\n             }\n@@ -767,14 +767,14 @@ pub fn list_dir(p: &Path) -> ~[Path] {\n                 fn rust_list_dir_val(ptr: *dirent_t) -> *libc::c_char;\n             }\n             let mut paths = ~[];\n-            debug2!(\"os::list_dir -- BEFORE OPENDIR\");\n+            debug!(\"os::list_dir -- BEFORE OPENDIR\");\n \n             let dir_ptr = do p.with_c_str |buf| {\n                 opendir(buf)\n             };\n \n             if (dir_ptr as uint != 0) {\n-                debug2!(\"os::list_dir -- opendir() SUCCESS\");\n+                debug!(\"os::list_dir -- opendir() SUCCESS\");\n                 let mut entry_ptr = readdir(dir_ptr);\n                 while (entry_ptr as uint != 0) {\n                     let cstr = CString::new(rust_list_dir_val(entry_ptr), false);\n@@ -784,9 +784,9 @@ pub fn list_dir(p: &Path) -> ~[Path] {\n                 closedir(dir_ptr);\n             }\n             else {\n-                debug2!(\"os::list_dir -- opendir() FAILURE\");\n+                debug!(\"os::list_dir -- opendir() FAILURE\");\n             }\n-            debug2!(\"os::list_dir -- AFTER -- \\\\#: {}\", paths.len());\n+            debug!(\"os::list_dir -- AFTER -- \\\\#: {}\", paths.len());\n             paths\n         }\n         #[cfg(windows)]\n@@ -820,7 +820,7 @@ pub fn list_dir(p: &Path) -> ~[Path] {\n                     while more_files != 0 {\n                         let fp_buf = rust_list_dir_wfd_fp_buf(wfd_ptr);\n                         if fp_buf as uint == 0 {\n-                            fail2!(\"os::list_dir() failure: got null ptr from wfd\");\n+                            fail!(\"os::list_dir() failure: got null ptr from wfd\");\n                         }\n                         else {\n                             let fp_vec = vec::from_buf(\n@@ -1143,7 +1143,7 @@ pub fn last_os_error() -> ~str {\n         do buf.as_mut_buf |buf, len| {\n             unsafe {\n                 if strerror_r(errno() as c_int, buf, len as size_t) < 0 {\n-                    fail2!(\"strerror_r failure\");\n+                    fail!(\"strerror_r failure\");\n                 }\n \n                 str::raw::from_c_str(buf as *c_char)\n@@ -1207,7 +1207,7 @@ pub fn last_os_error() -> ~str {\n                                          len as DWORD,\n                                          ptr::null());\n                 if res == 0 {\n-                    fail2!(\"[{}] FormatMessage failure\", errno());\n+                    fail!(\"[{}] FormatMessage failure\", errno());\n                 }\n             }\n \n@@ -1263,7 +1263,7 @@ fn real_args() -> ~[~str] {\n \n     match rt::args::clone() {\n         Some(args) => args,\n-        None => fail2!(\"process arguments not initialized\")\n+        None => fail!(\"process arguments not initialized\")\n     }\n }\n \n@@ -1508,10 +1508,10 @@ impl Drop for MemoryMap {\n             match libc::munmap(self.data as *c_void, self.len) {\n                 0 => (),\n                 -1 => match errno() as c_int {\n-                    libc::EINVAL => error2!(\"invalid addr or len\"),\n-                    e => error2!(\"unknown errno={}\", e)\n+                    libc::EINVAL => error!(\"invalid addr or len\"),\n+                    e => error!(\"unknown errno={}\", e)\n                 },\n-                r => error2!(\"Unexpected result {}\", r)\n+                r => error!(\"Unexpected result {}\", r)\n             }\n         }\n     }\n@@ -1639,15 +1639,15 @@ impl Drop for MemoryMap {\n                     if libc::VirtualFree(self.data as *mut c_void,\n                                          self.len,\n                                          libc::MEM_RELEASE) == FALSE {\n-                        error2!(\"VirtualFree failed: {}\", errno());\n+                        error!(\"VirtualFree failed: {}\", errno());\n                     }\n                 },\n                 MapFile(mapping) => {\n                     if libc::UnmapViewOfFile(self.data as LPCVOID) == FALSE {\n-                        error2!(\"UnmapViewOfFile failed: {}\", errno());\n+                        error!(\"UnmapViewOfFile failed: {}\", errno());\n                     }\n                     if libc::CloseHandle(mapping as HANDLE) == FALSE {\n-                        error2!(\"CloseHandle failed: {}\", errno());\n+                        error!(\"CloseHandle failed: {}\", errno());\n                     }\n                 }\n             }\n@@ -1778,7 +1778,7 @@ mod tests {\n \n     #[test]\n     pub fn last_os_error() {\n-        debug2!(\"{}\", os::last_os_error());\n+        debug!(\"{}\", os::last_os_error());\n     }\n \n     #[test]\n@@ -1833,7 +1833,7 @@ mod tests {\n         }\n         let n = make_rand_name();\n         setenv(n, s);\n-        debug2!(\"{}\", s.clone());\n+        debug!(\"{}\", s.clone());\n         assert_eq!(getenv(n), option::Some(s));\n     }\n \n@@ -1842,7 +1842,7 @@ mod tests {\n         let path = os::self_exe_path();\n         assert!(path.is_some());\n         let path = path.unwrap();\n-        debug2!(\"{:?}\", path.clone());\n+        debug!(\"{:?}\", path.clone());\n \n         // Hard to test this function\n         assert!(path.is_absolute());\n@@ -1855,7 +1855,7 @@ mod tests {\n         assert!(e.len() > 0u);\n         for p in e.iter() {\n             let (n, v) = (*p).clone();\n-            debug2!(\"{:?}\", n.clone());\n+            debug!(\"{:?}\", n.clone());\n             let v2 = getenv(n);\n             // MingW seems to set some funky environment variables like\n             // \"=C:=C:\\MinGW\\msys\\1.0\\bin\" and \"!::=::\\\" that are returned\n@@ -1881,10 +1881,10 @@ mod tests {\n         assert!((!Path::new(\"test-path\").is_absolute()));\n \n         let cwd = getcwd();\n-        debug2!(\"Current working directory: {}\", cwd.display());\n+        debug!(\"Current working directory: {}\", cwd.display());\n \n-        debug2!(\"{:?}\", make_absolute(&Path::new(\"test-path\")));\n-        debug2!(\"{:?}\", make_absolute(&Path::new(\"/usr/bin\")));\n+        debug!(\"{:?}\", make_absolute(&Path::new(\"test-path\")));\n+        debug!(\"{:?}\", make_absolute(&Path::new(\"/usr/bin\")));\n     }\n \n     #[test]\n@@ -1949,7 +1949,7 @@ mod tests {\n         assert!(dirs.len() > 0u);\n \n         for dir in dirs.iter() {\n-            debug2!(\"{:?}\", (*dir).clone());\n+            debug!(\"{:?}\", (*dir).clone());\n         }\n     }\n \n@@ -1978,16 +1978,16 @@ mod tests {\n         let mut dirpath = os::tmpdir();\n         dirpath.push(format!(\"rust-test-{}/test-\\uac00\\u4e00\\u30fc\\u4f60\\u597d\",\n             rand::random::<u32>())); // \uac00\u4e00\u30fc\u4f60\u597d\n-        debug2!(\"path_is_dir dirpath: {}\", dirpath.display());\n+        debug!(\"path_is_dir dirpath: {}\", dirpath.display());\n \n         let mkdir_result = os::mkdir_recursive(&dirpath, (S_IRUSR | S_IWUSR | S_IXUSR) as i32);\n-        debug2!(\"path_is_dir mkdir_result: {}\", mkdir_result);\n+        debug!(\"path_is_dir mkdir_result: {}\", mkdir_result);\n \n         assert!((os::path_is_dir(&dirpath)));\n \n         let mut filepath = dirpath;\n         filepath.push(\"unicode-file-\\uac00\\u4e00\\u30fc\\u4f60\\u597d.rs\");\n-        debug2!(\"path_is_dir filepath: {}\", filepath.display());\n+        debug!(\"path_is_dir filepath: {}\", filepath.display());\n \n         open(&filepath, OpenOrCreate, Read); // ignore return; touch only\n         assert!((!os::path_is_dir(&filepath)));\n@@ -2048,7 +2048,7 @@ mod tests {\n             let in_mode = input.get_mode();\n             let rs = os::copy_file(&input, &out);\n             if (!os::path_exists(&input)) {\n-                fail2!(\"{} doesn't exist\", input.display());\n+                fail!(\"{} doesn't exist\", input.display());\n             }\n             assert!((rs));\n             // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -2076,7 +2076,7 @@ mod tests {\n             os::MapWritable\n         ]) {\n             Ok(chunk) => chunk,\n-            Err(msg) => fail2!(msg.to_str())\n+            Err(msg) => fail!(msg.to_str())\n         };\n         assert!(chunk.len >= 16);\n \n@@ -2133,7 +2133,7 @@ mod tests {\n             MapOffset(size / 2)\n         ]) {\n             Ok(chunk) => chunk,\n-            Err(msg) => fail2!(msg.to_str())\n+            Err(msg) => fail!(msg.to_str())\n         };\n         assert!(chunk.len > 0);\n "}, {"sha": "f71f67a30db84467c966c04e4d7de83b5e316157", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -54,12 +54,12 @@ actually operates on the path; it is only intended for display.\n \n ```rust\n let mut path = Path::new(\"/tmp/path\");\n-debug2!(\"path: {}\", path.display());\n+debug!(\"path: {}\", path.display());\n path.set_filename(\"foo\");\n path.push(\"bar\");\n-debug2!(\"new path: {}\", path.display());\n+debug!(\"new path: {}\", path.display());\n let b = std::os::path_exists(&path);\n-debug2!(\"path exists: {}\", b);\n+debug!(\"path exists: {}\", b);\n ```\n \n */"}, {"sha": "8803d39b0c67e3c5e41a468a908711bb2ca610e7", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -236,16 +236,16 @@ pub fn to_mut_unsafe_ptr<T>(thing: &mut T) -> *mut T {\n   SAFETY NOTE: Pointer-arithmetic. Dragons be here.\n */\n pub unsafe fn array_each_with_len<T>(arr: **T, len: uint, cb: &fn(*T)) {\n-    debug2!(\"array_each_with_len: before iterate\");\n+    debug!(\"array_each_with_len: before iterate\");\n     if (arr as uint == 0) {\n-        fail2!(\"ptr::array_each_with_len failure: arr input is null pointer\");\n+        fail!(\"ptr::array_each_with_len failure: arr input is null pointer\");\n     }\n     //let start_ptr = *arr;\n     for e in range(0, len) {\n         let n = offset(arr, e as int);\n         cb(*n);\n     }\n-    debug2!(\"array_each_with_len: after iterate\");\n+    debug!(\"array_each_with_len: after iterate\");\n }\n \n /**\n@@ -259,10 +259,10 @@ pub unsafe fn array_each_with_len<T>(arr: **T, len: uint, cb: &fn(*T)) {\n */\n pub unsafe fn array_each<T>(arr: **T, cb: &fn(*T)) {\n     if (arr as uint == 0) {\n-        fail2!(\"ptr::array_each_with_len failure: arr input is null pointer\");\n+        fail!(\"ptr::array_each_with_len failure: arr input is null pointer\");\n     }\n     let len = buf_len(arr);\n-    debug2!(\"array_each inferred len: {}\", len);\n+    debug!(\"array_each inferred len: {}\", len);\n     array_each_with_len(arr, len, cb);\n }\n \n@@ -669,7 +669,7 @@ pub mod ptr_tests {\n                      let expected = do expected_arr[ctr].with_ref |buf| {\n                          str::raw::from_c_str(buf)\n                      };\n-                     debug2!(\n+                     debug!(\n                          \"test_ptr_array_each_with_len e: {}, a: {}\",\n                          expected, actual);\n                      assert_eq!(actual, expected);\n@@ -706,7 +706,7 @@ pub mod ptr_tests {\n                      let expected = do expected_arr[ctr].with_ref |buf| {\n                          str::raw::from_c_str(buf)\n                      };\n-                     debug2!(\n+                     debug!(\n                          \"test_ptr_array_each e: {}, a: {}\",\n                          expected, actual);\n                      assert_eq!(actual, expected);"}, {"sha": "f5c60417bacb5c9344f64b745687f7d2ec060297", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -175,7 +175,7 @@ pub trait Rng {\n                 *b = (rand >> 8) as u8;\n                 *c = (rand >> 16) as u8;\n             }\n-            _ => fail2!(\"Rng.fill_bytes: the impossible occurred: remaining != 1, 2 or 3\")\n+            _ => fail!(\"Rng.fill_bytes: the impossible occurred: remaining != 1, 2 or 3\")\n         }\n     }\n \n@@ -797,7 +797,7 @@ mod test {\n         let mut r = rng();\n         let a = r.gen::<f64>();\n         let b = r.gen::<f64>();\n-        debug2!(\"{:?}\", (a, b));\n+        debug!(\"{:?}\", (a, b));\n     }\n \n     #[test]\n@@ -810,9 +810,9 @@ mod test {\n     #[test]\n     fn test_gen_ascii_str() {\n         let mut r = rng();\n-        debug2!(\"{}\", r.gen_ascii_str(10u));\n-        debug2!(\"{}\", r.gen_ascii_str(10u));\n-        debug2!(\"{}\", r.gen_ascii_str(10u));\n+        debug!(\"{}\", r.gen_ascii_str(10u));\n+        debug!(\"{}\", r.gen_ascii_str(10u));\n+        debug!(\"{}\", r.gen_ascii_str(10u));\n         assert_eq!(r.gen_ascii_str(0u).len(), 0u);\n         assert_eq!(r.gen_ascii_str(10u).len(), 10u);\n         assert_eq!(r.gen_ascii_str(16u).len(), 16u);"}, {"sha": "f1e67da815e1700fb8cdbf3c6d16e6e9957bb149", "filename": "src/libstd/rand/reader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -68,9 +68,9 @@ impl<R: Reader> Rng for ReaderRng<R> {\n         if v.len() == 0 { return }\n         match self.reader.read(v) {\n             Some(n) if n == v.len() => return,\n-            Some(n) => fail2!(\"ReaderRng.fill_bytes could not fill buffer: \\\n+            Some(n) => fail!(\"ReaderRng.fill_bytes could not fill buffer: \\\n                               read {} out of {} bytes.\", n, v.len()),\n-            None => fail2!(\"ReaderRng.fill_bytes reached eof.\")\n+            None => fail!(\"ReaderRng.fill_bytes reached eof.\")\n         }\n     }\n }"}, {"sha": "4feb1ca19104b1ddf68c0535c443eaa28dff1681", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -182,7 +182,7 @@ impl<'self> ReprVisitor<'self> {\n         } else if mtbl == 1 {\n             // skip, this is ast::m_imm\n         } else {\n-            fail2!(\"invalid mutability value\");\n+            fail!(\"invalid mutability value\");\n         }\n     }\n \n@@ -294,7 +294,7 @@ impl<'self> TyVisitor for ReprVisitor<'self> {\n \n     // Type no longer exists, vestigial function.\n     fn visit_estr_fixed(&mut self, _n: uint, _sz: uint,\n-                        _align: uint) -> bool { fail2!(); }\n+                        _align: uint) -> bool { fail!(); }\n \n     fn visit_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.writer.write(['@' as u8]);\n@@ -337,7 +337,7 @@ impl<'self> TyVisitor for ReprVisitor<'self> {\n     }\n \n     // Type no longer exists, vestigial function.\n-    fn visit_vec(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { fail2!(); }\n+    fn visit_vec(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { fail!(); }\n \n     fn visit_unboxed_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         do self.get::<raw::Vec<()>> |this, b| {\n@@ -552,7 +552,7 @@ impl<'self> TyVisitor for ReprVisitor<'self> {\n                         _align: uint)\n                         -> bool {\n         match self.var_stk.pop() {\n-            SearchingFor(*) => fail2!(\"enum value matched no variant\"),\n+            SearchingFor(*) => fail!(\"enum value matched no variant\"),\n             _ => true\n         }\n     }"}, {"sha": "957ba4a04389317456f9e52b231dc01faf712a8d", "filename": "src/libstd/result.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -47,7 +47,7 @@ impl<T, E: ToStr> Result<T, E> {\n     pub fn get_ref<'a>(&'a self) -> &'a T {\n         match *self {\n             Ok(ref t) => t,\n-            Err(ref e) => fail2!(\"called `Result::get_ref()` on `Err` value: {}\",\n+            Err(ref e) => fail!(\"called `Result::get_ref()` on `Err` value: {}\",\n                                  e.to_str()),\n         }\n     }\n@@ -108,7 +108,7 @@ impl<T, E: ToStr> Result<T, E> {\n     pub fn unwrap(self) -> T {\n         match self {\n             Ok(t) => t,\n-            Err(e) => fail2!(\"called `Result::unwrap()` on `Err` value: {}\",\n+            Err(e) => fail!(\"called `Result::unwrap()` on `Err` value: {}\",\n                              e.to_str()),\n         }\n     }\n@@ -126,7 +126,7 @@ impl<T, E: ToStr> Result<T, E> {\n     pub fn expect(self, reason: &str) -> T {\n         match self {\n             Ok(t) => t,\n-            Err(_) => fail2!(\"{}\", reason.to_owned()),\n+            Err(_) => fail!(\"{}\", reason.to_owned()),\n         }\n     }\n \n@@ -136,7 +136,7 @@ impl<T, E: ToStr> Result<T, E> {\n     pub fn expect_err(self, reason: &str) -> E {\n         match self {\n             Err(e) => e,\n-            Ok(_) => fail2!(\"{}\", reason.to_owned()),\n+            Ok(_) => fail!(\"{}\", reason.to_owned()),\n         }\n     }\n \n@@ -571,7 +571,7 @@ mod tests {\n                    Err(2));\n \n         // test that it does not take more elements than it needs\n-        let functions = [|| Ok(()), || Err(1), || fail2!()];\n+        let functions = [|| Ok(()), || Err(1), || fail!()];\n \n         assert_eq!(collect(functions.iter().map(|f| (*f)())),\n                    Err(1));\n@@ -591,7 +591,7 @@ mod tests {\n                    Err(2));\n \n         // test that it does not take more elements than it needs\n-        let functions = [|| Ok(()), || Err(1), || fail2!()];\n+        let functions = [|| Ok(()), || Err(1), || fail!()];\n \n         assert_eq!(fold_(functions.iter()\n                         .map(|f| (*f)())),"}, {"sha": "24143ba040ba74e3f4a48d00af93ecf310750cdf", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -163,14 +163,14 @@ mod imp {\n     }\n \n     pub fn take() -> Option<~[~str]> {\n-        fail2!()\n+        fail!()\n     }\n \n     pub fn put(_args: ~[~str]) {\n-        fail2!()\n+        fail!()\n     }\n \n     pub fn clone() -> Option<~[~str]> {\n-        fail2!()\n+        fail!()\n     }\n }"}, {"sha": "4eae8bdc9a8224f9dfbcaa6038da3b9117803375", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -196,7 +196,7 @@ impl<T> PortOne<T> {\n         match self.try_recv() {\n             Some(val) => val,\n             None => {\n-                fail2!(\"receiving on closed channel\");\n+                fail!(\"receiving on closed channel\");\n             }\n         }\n     }\n@@ -495,7 +495,7 @@ impl<T> GenericPort<T> for Port<T> {\n         match self.try_recv() {\n             Some(val) => val,\n             None => {\n-                fail2!(\"receiving on closed channel\");\n+                fail!(\"receiving on closed channel\");\n             }\n         }\n     }\n@@ -650,7 +650,7 @@ impl<T: Send> GenericPort<T> for SharedPort<T> {\n         match self.try_recv() {\n             Some(val) => val,\n             None => {\n-                fail2!(\"receiving on a closed channel\");\n+                fail!(\"receiving on a closed channel\");\n             }\n         }\n     }"}, {"sha": "d33e1af90f8d0adaf4e9d3dfecec07a281701352", "filename": "src/libstd/rt/crate_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fcrate_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fcrate_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcrate_map.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -93,7 +93,7 @@ fn do_iter_crate_map<'a>(crate_map: &'a CrateMap<'a>, f: &fn(&ModEntry),\n                     do_iter_crate_map(*child, |x| f(x), visited);\n                 }\n             },\n-            _ => fail2!(\"invalid crate map version\")\n+            _ => fail!(\"invalid crate map version\")\n         }\n     }\n }"}, {"sha": "06424fee8bc121831a71eb2aeb5afd69a8240f75", "filename": "src/libstd/rt/io/comm_adapters.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fcomm_adapters.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -15,45 +15,45 @@ use super::{Reader, Writer};\n struct PortReader<P>;\n \n impl<P: GenericPort<~[u8]>> PortReader<P> {\n-    pub fn new(_port: P) -> PortReader<P> { fail2!() }\n+    pub fn new(_port: P) -> PortReader<P> { fail!() }\n }\n \n impl<P: GenericPort<~[u8]>> Reader for PortReader<P> {\n-    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail2!() }\n+    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n \n-    fn eof(&mut self) -> bool { fail2!() }\n+    fn eof(&mut self) -> bool { fail!() }\n }\n \n struct ChanWriter<C>;\n \n impl<C: GenericChan<~[u8]>> ChanWriter<C> {\n-    pub fn new(_chan: C) -> ChanWriter<C> { fail2!() }\n+    pub fn new(_chan: C) -> ChanWriter<C> { fail!() }\n }\n \n impl<C: GenericChan<~[u8]>> Writer for ChanWriter<C> {\n-    fn write(&mut self, _buf: &[u8]) { fail2!() }\n+    fn write(&mut self, _buf: &[u8]) { fail!() }\n \n-    fn flush(&mut self) { fail2!() }\n+    fn flush(&mut self) { fail!() }\n }\n \n struct ReaderPort<R>;\n \n impl<R: Reader> ReaderPort<R> {\n-    pub fn new(_reader: R) -> ReaderPort<R> { fail2!() }\n+    pub fn new(_reader: R) -> ReaderPort<R> { fail!() }\n }\n \n impl<R: Reader> GenericPort<~[u8]> for ReaderPort<R> {\n-    fn recv(&self) -> ~[u8] { fail2!() }\n+    fn recv(&self) -> ~[u8] { fail!() }\n \n-    fn try_recv(&self) -> Option<~[u8]> { fail2!() }\n+    fn try_recv(&self) -> Option<~[u8]> { fail!() }\n }\n \n struct WriterChan<W>;\n \n impl<W: Writer> WriterChan<W> {\n-    pub fn new(_writer: W) -> WriterChan<W> { fail2!() }\n+    pub fn new(_writer: W) -> WriterChan<W> { fail!() }\n }\n \n impl<W: Writer> GenericChan<~[u8]> for WriterChan<W> {\n-    fn send(&self, _x: ~[u8]) { fail2!() }\n+    fn send(&self, _x: ~[u8]) { fail!() }\n }"}, {"sha": "99634b532b082c6962d27f05cc09cf3dfa237ddd", "filename": "src/libstd/rt/io/extensions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fextensions.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -288,7 +288,7 @@ impl<T: Reader> ReaderUtil for T {\n         let mut buf = [0];\n         match self.read(buf) {\n             Some(0) => {\n-                debug2!(\"read 0 bytes. trying again\");\n+                debug!(\"read 0 bytes. trying again\");\n                 self.read_byte()\n             }\n             Some(1) => Some(buf[0]),"}, {"sha": "a5d593d2454da691f47e3f26633a3568a955d874", "filename": "src/libstd/rt/io/file.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffile.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -59,7 +59,7 @@ use path::Path;\n ///     }).inside {\n ///         let stream = match open(p, Create, ReadWrite) {\n ///             Some(s) => s,\n-///             None => fail2!(\"whoops! I'm sure this raised, anyways..\");\n+///             None => fail!(\"whoops! I'm sure this raised, anyways..\");\n ///         }\n ///         // do some stuff with that stream\n ///\n@@ -223,7 +223,7 @@ pub fn rmdir<P: PathLike>(path: &P) {\n ///     }).inside {\n ///         let info = match stat(p) {\n ///             Some(s) => s,\n-///             None => fail2!(\"whoops! I'm sure this raised, anyways..\");\n+///             None => fail!(\"whoops! I'm sure this raised, anyways..\");\n ///         }\n ///         if stat.is_file {\n ///             // just imagine the possibilities ...\n@@ -271,7 +271,7 @@ pub fn stat<P: PathLike>(path: &P) -> Option<FileStat> {\n ///                 else { cb(entry); }\n ///             }\n ///         }\n-///         else { fail2!(\"nope\"); }\n+///         else { fail!(\"nope\"); }\n ///     }\n ///\n /// # Errors\n@@ -596,7 +596,7 @@ impl FileInfo for Path { }\n ///             else { cb(entry); }\n ///         }\n ///     }\n-///     else { fail2!(\"nope\"); }\n+///     else { fail!(\"nope\"); }\n /// }\n /// ```\n pub trait DirectoryInfo : FileSystemInfo {\n@@ -713,7 +713,7 @@ mod test {\n                 let mut read_stream = open(filename, Open, Read).unwrap();\n                 let mut read_buf = [0, .. 1028];\n                 let read_str = match read_stream.read(read_buf).unwrap() {\n-                    -1|0 => fail2!(\"shouldn't happen\"),\n+                    -1|0 => fail!(\"shouldn't happen\"),\n                     n => str::from_utf8(read_buf.slice_to(n))\n                 };\n                 assert!(read_str == message.to_owned());\n@@ -881,7 +881,7 @@ mod test {\n             }\n             let stat_res = match stat(filename) {\n                 Some(s) => s,\n-                None => fail2!(\"shouldn't happen\")\n+                None => fail!(\"shouldn't happen\")\n             };\n             assert!(stat_res.is_file);\n             unlink(filename);\n@@ -895,7 +895,7 @@ mod test {\n             mkdir(filename);\n             let stat_res = match stat(filename) {\n                 Some(s) => s,\n-                None => fail2!(\"shouldn't happen\")\n+                None => fail!(\"shouldn't happen\")\n             };\n             assert!(stat_res.is_dir);\n             rmdir(filename);\n@@ -964,15 +964,15 @@ mod test {\n                             r.read(mem);\n                             let read_str = str::from_utf8(mem);\n                             let expected = match n {\n-                                None|Some(\"\") => fail2!(\"really shouldn't happen..\"),\n+                                None|Some(\"\") => fail!(\"really shouldn't happen..\"),\n                                 Some(n) => prefix+n\n                             };\n                             assert!(expected == read_str);\n                         }\n                         f.unlink();\n                     }\n                 },\n-                None => fail2!(\"shouldn't happen\")\n+                None => fail!(\"shouldn't happen\")\n             }\n             dir.rmdir();\n         }"}, {"sha": "7c72ce6ba891ea13e107f5711d41eb351589d6d9", "filename": "src/libstd/rt/io/flate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fio%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fio%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fflate.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -29,9 +29,9 @@ impl<W: Writer> DeflateWriter<W> {\n }\n \n impl<W: Writer> Writer for DeflateWriter<W> {\n-    fn write(&mut self, _buf: &[u8]) { fail2!() }\n+    fn write(&mut self, _buf: &[u8]) { fail!() }\n \n-    fn flush(&mut self) { fail2!() }\n+    fn flush(&mut self) { fail!() }\n }\n \n impl<W: Writer> Decorator<W> for DeflateWriter<W> {\n@@ -68,9 +68,9 @@ impl<R: Reader> InflateReader<R> {\n }\n \n impl<R: Reader> Reader for InflateReader<R> {\n-    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail2!() }\n+    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n \n-    fn eof(&mut self) -> bool { fail2!() }\n+    fn eof(&mut self) -> bool { fail!() }\n }\n \n impl<R: Reader> Decorator<R> for InflateReader<R> {"}, {"sha": "5f6b4398c22f72be83aac931ab8fba5191b05e64", "filename": "src/libstd/rt/io/mem.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmem.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -40,7 +40,7 @@ impl Writer for MemWriter {\n impl Seek for MemWriter {\n     fn tell(&self) -> u64 { self.buf.len() as u64 }\n \n-    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail2!() }\n+    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n }\n \n impl Decorator<~[u8]> for MemWriter {\n@@ -102,7 +102,7 @@ impl Reader for MemReader {\n impl Seek for MemReader {\n     fn tell(&self) -> u64 { self.pos as u64 }\n \n-    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail2!() }\n+    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n }\n \n impl Decorator<~[u8]> for MemReader {\n@@ -143,15 +143,15 @@ impl<'self> BufWriter<'self> {\n }\n \n impl<'self> Writer for BufWriter<'self> {\n-    fn write(&mut self, _buf: &[u8]) { fail2!() }\n+    fn write(&mut self, _buf: &[u8]) { fail!() }\n \n-    fn flush(&mut self) { fail2!() }\n+    fn flush(&mut self) { fail!() }\n }\n \n impl<'self> Seek for BufWriter<'self> {\n-    fn tell(&self) -> u64 { fail2!() }\n+    fn tell(&self) -> u64 { fail!() }\n \n-    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail2!() }\n+    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n }\n \n \n@@ -193,7 +193,7 @@ impl<'self> Reader for BufReader<'self> {\n impl<'self> Seek for BufReader<'self> {\n     fn tell(&self) -> u64 { self.pos as u64 }\n \n-    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail2!() }\n+    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n }\n \n ///Calls a function with a MemWriter and returns"}, {"sha": "c0971b5d3cd5d3f7d50c09782a19835a16fd40dc", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -611,7 +611,7 @@ pub fn standard_error(kind: IoErrorKind) -> IoError {\n                 detail: None\n             }\n         }\n-        _ => fail2!()\n+        _ => fail!()\n     }\n }\n "}, {"sha": "d682098118172fa2f09ca4368f38138519fe0f4b", "filename": "src/libstd/rt/io/native/file.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -241,7 +241,7 @@ mod tests {\n                     assert_eq!(buf[2], 's' as u8);\n                     assert_eq!(buf[3], 't' as u8);\n                 }\n-                r => fail2!(\"invalid read: {:?}\", r)\n+                r => fail!(\"invalid read: {:?}\", r)\n             }\n \n             let mut raised = false;\n@@ -276,7 +276,7 @@ mod tests {\n                     assert_eq!(buf[2], 's' as u8);\n                     assert_eq!(buf[3], 't' as u8);\n                 }\n-                r => fail2!(\"invalid read: {:?}\", r)\n+                r => fail!(\"invalid read: {:?}\", r)\n             }\n         }\n     }"}, {"sha": "91fff6d92630b802a26d0c5f1d1ec88eb7324810", "filename": "src/libstd/rt/io/native/process.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fio%2Fnative%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fio%2Fnative%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnative%2Fprocess.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -124,7 +124,7 @@ impl Process {\n     pub fn input<'a>(&'a mut self) -> &'a mut io::Writer {\n         match self.input {\n             Some(ref mut fd) => fd as &mut io::Writer,\n-            None => fail2!(\"This process has no stdin\")\n+            None => fail!(\"This process has no stdin\")\n         }\n     }\n \n@@ -138,7 +138,7 @@ impl Process {\n     pub fn output<'a>(&'a mut self) -> &'a mut io::Reader {\n         match self.input {\n             Some(ref mut fd) => fd as &mut io::Reader,\n-            None => fail2!(\"This process has no stdout\")\n+            None => fail!(\"This process has no stdout\")\n         }\n     }\n \n@@ -152,7 +152,7 @@ impl Process {\n     pub fn error<'a>(&'a mut self) -> &'a mut io::Reader {\n         match self.error {\n             Some(ref mut fd) => fd as &mut io::Reader,\n-            None => fail2!(\"This process has no stderr\")\n+            None => fail!(\"This process has no stderr\")\n         }\n     }\n \n@@ -283,29 +283,29 @@ fn spawn_process_os(prog: &str, args: &[~str],\n \n         let orig_std_in = get_osfhandle(in_fd) as HANDLE;\n         if orig_std_in == INVALID_HANDLE_VALUE as HANDLE {\n-            fail2!(\"failure in get_osfhandle: {}\", os::last_os_error());\n+            fail!(\"failure in get_osfhandle: {}\", os::last_os_error());\n         }\n         if DuplicateHandle(cur_proc, orig_std_in, cur_proc, &mut si.hStdInput,\n                            0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n-            fail2!(\"failure in DuplicateHandle: {}\", os::last_os_error());\n+            fail!(\"failure in DuplicateHandle: {}\", os::last_os_error());\n         }\n \n         let orig_std_out = get_osfhandle(out_fd) as HANDLE;\n         if orig_std_out == INVALID_HANDLE_VALUE as HANDLE {\n-            fail2!(\"failure in get_osfhandle: {}\", os::last_os_error());\n+            fail!(\"failure in get_osfhandle: {}\", os::last_os_error());\n         }\n         if DuplicateHandle(cur_proc, orig_std_out, cur_proc, &mut si.hStdOutput,\n                            0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n-            fail2!(\"failure in DuplicateHandle: {}\", os::last_os_error());\n+            fail!(\"failure in DuplicateHandle: {}\", os::last_os_error());\n         }\n \n         let orig_std_err = get_osfhandle(err_fd) as HANDLE;\n         if orig_std_err == INVALID_HANDLE_VALUE as HANDLE {\n-            fail2!(\"failure in get_osfhandle: {}\", os::last_os_error());\n+            fail!(\"failure in get_osfhandle: {}\", os::last_os_error());\n         }\n         if DuplicateHandle(cur_proc, orig_std_err, cur_proc, &mut si.hStdError,\n                            0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n-            fail2!(\"failure in DuplicateHandle: {}\", os::last_os_error());\n+            fail!(\"failure in DuplicateHandle: {}\", os::last_os_error());\n         }\n \n         let cmd = make_command_line(prog, args);\n@@ -330,7 +330,7 @@ fn spawn_process_os(prog: &str, args: &[~str],\n         CloseHandle(si.hStdError);\n \n         for msg in create_err.iter() {\n-            fail2!(\"failure in CreateProcess: {}\", *msg);\n+            fail!(\"failure in CreateProcess: {}\", *msg);\n         }\n \n         // We close the thread handle because we don't care about keeping the\n@@ -471,21 +471,21 @@ fn spawn_process_os(prog: &str, args: &[~str],\n \n         let pid = fork();\n         if pid < 0 {\n-            fail2!(\"failure in fork: {}\", os::last_os_error());\n+            fail!(\"failure in fork: {}\", os::last_os_error());\n         } else if pid > 0 {\n             return SpawnProcessResult {pid: pid, handle: ptr::null()};\n         }\n \n         rustrt::rust_unset_sigprocmask();\n \n         if dup2(in_fd, 0) == -1 {\n-            fail2!(\"failure in dup2(in_fd, 0): {}\", os::last_os_error());\n+            fail!(\"failure in dup2(in_fd, 0): {}\", os::last_os_error());\n         }\n         if dup2(out_fd, 1) == -1 {\n-            fail2!(\"failure in dup2(out_fd, 1): {}\", os::last_os_error());\n+            fail!(\"failure in dup2(out_fd, 1): {}\", os::last_os_error());\n         }\n         if dup2(err_fd, 2) == -1 {\n-            fail2!(\"failure in dup3(err_fd, 2): {}\", os::last_os_error());\n+            fail!(\"failure in dup3(err_fd, 2): {}\", os::last_os_error());\n         }\n         // close all other fds\n         for fd in range(3, getdtablesize()).invert() {\n@@ -494,7 +494,7 @@ fn spawn_process_os(prog: &str, args: &[~str],\n \n         do with_dirp(dir) |dirp| {\n             if !dirp.is_null() && chdir(dirp) == -1 {\n-                fail2!(\"failure in chdir: {}\", os::last_os_error());\n+                fail!(\"failure in chdir: {}\", os::last_os_error());\n             }\n         }\n \n@@ -505,7 +505,7 @@ fn spawn_process_os(prog: &str, args: &[~str],\n             do with_argv(prog, args) |argv| {\n                 execvp(*argv, argv);\n                 // execvp only returns if an error occurred\n-                fail2!(\"failure in execvp: {}\", os::last_os_error());\n+                fail!(\"failure in execvp: {}\", os::last_os_error());\n             }\n         }\n     }\n@@ -651,22 +651,22 @@ fn waitpid(pid: pid_t) -> int {\n \n             let proc = OpenProcess(SYNCHRONIZE | PROCESS_QUERY_INFORMATION, FALSE, pid as DWORD);\n             if proc.is_null() {\n-                fail2!(\"failure in OpenProcess: {}\", os::last_os_error());\n+                fail!(\"failure in OpenProcess: {}\", os::last_os_error());\n             }\n \n             loop {\n                 let mut status = 0;\n                 if GetExitCodeProcess(proc, &mut status) == FALSE {\n                     CloseHandle(proc);\n-                    fail2!(\"failure in GetExitCodeProcess: {}\", os::last_os_error());\n+                    fail!(\"failure in GetExitCodeProcess: {}\", os::last_os_error());\n                 }\n                 if status != STILL_ACTIVE {\n                     CloseHandle(proc);\n                     return status as int;\n                 }\n                 if WaitForSingleObject(proc, INFINITE) == WAIT_FAILED {\n                     CloseHandle(proc);\n-                    fail2!(\"failure in WaitForSingleObject: {}\", os::last_os_error());\n+                    fail!(\"failure in WaitForSingleObject: {}\", os::last_os_error());\n                 }\n             }\n         }\n@@ -704,7 +704,7 @@ fn waitpid(pid: pid_t) -> int {\n \n         let mut status = 0 as c_int;\n         if unsafe { waitpid(pid, &mut status, 0) } == -1 {\n-            fail2!(\"failure in waitpid: {}\", os::last_os_error());\n+            fail!(\"failure in waitpid: {}\", os::last_os_error());\n         }\n \n         return if WIFEXITED(status) {"}, {"sha": "f29e17cfc2f3d127152f16b9d66be1874e690fd0", "filename": "src/libstd/rt/io/net/tcp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -84,7 +84,7 @@ impl Reader for TcpStream {\n         }\n     }\n \n-    fn eof(&mut self) -> bool { fail2!() }\n+    fn eof(&mut self) -> bool { fail!() }\n }\n \n impl Writer for TcpStream {\n@@ -324,7 +324,7 @@ mod test {\n                     if cfg!(windows) {\n                         assert_eq!(e.kind, NotConnected);\n                     } else {\n-                        fail2!();\n+                        fail!();\n                     }\n                 }).inside {\n                     let nread = stream.read(buf);\n@@ -359,7 +359,7 @@ mod test {\n                     if cfg!(windows) {\n                         assert_eq!(e.kind, NotConnected);\n                     } else {\n-                        fail2!();\n+                        fail!();\n                     }\n                 }).inside {\n                     let nread = stream.read(buf);"}, {"sha": "27faae0838b15d2383e8564bb3b3c6d04c6c9a02", "filename": "src/libstd/rt/io/net/udp.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -94,7 +94,7 @@ impl Reader for UdpStream {\n         }\n     }\n \n-    fn eof(&mut self) -> bool { fail2!() }\n+    fn eof(&mut self) -> bool { fail!() }\n }\n \n impl Writer for UdpStream {\n@@ -104,7 +104,7 @@ impl Writer for UdpStream {\n         }\n     }\n \n-    fn flush(&mut self) { fail2!() }\n+    fn flush(&mut self) { fail!() }\n }\n \n #[cfg(test)]\n@@ -153,10 +153,10 @@ mod test {\n                                 assert_eq!(buf[0], 99);\n                                 assert_eq!(src, client_ip);\n                             }\n-                            None => fail2!()\n+                            None => fail!()\n                         }\n                     }\n-                    None => fail2!()\n+                    None => fail!()\n                 }\n             }\n \n@@ -166,7 +166,7 @@ mod test {\n                         port.take().recv();\n                         client.sendto([99], server_ip)\n                     }\n-                    None => fail2!()\n+                    None => fail!()\n                 }\n             }\n         }\n@@ -192,10 +192,10 @@ mod test {\n                                 assert_eq!(buf[0], 99);\n                                 assert_eq!(src, client_ip);\n                             }\n-                            None => fail2!()\n+                            None => fail!()\n                         }\n                     }\n-                    None => fail2!()\n+                    None => fail!()\n                 }\n             }\n \n@@ -205,7 +205,7 @@ mod test {\n                         port.take().recv();\n                         client.sendto([99], server_ip)\n                     }\n-                    None => fail2!()\n+                    None => fail!()\n                 }\n             }\n         }\n@@ -232,10 +232,10 @@ mod test {\n                                 assert_eq!(nread, 1);\n                                 assert_eq!(buf[0], 99);\n                             }\n-                            None => fail2!()\n+                            None => fail!()\n                         }\n                     }\n-                    None => fail2!()\n+                    None => fail!()\n                 }\n             }\n \n@@ -247,7 +247,7 @@ mod test {\n                         port.take().recv();\n                         stream.write([99]);\n                     }\n-                    None => fail2!()\n+                    None => fail!()\n                 }\n             }\n         }\n@@ -274,10 +274,10 @@ mod test {\n                                 assert_eq!(nread, 1);\n                                 assert_eq!(buf[0], 99);\n                             }\n-                            None => fail2!()\n+                            None => fail!()\n                         }\n                     }\n-                    None => fail2!()\n+                    None => fail!()\n                 }\n             }\n \n@@ -289,7 +289,7 @@ mod test {\n                         port.take().recv();\n                         stream.write([99]);\n                     }\n-                    None => fail2!()\n+                    None => fail!()\n                 }\n             }\n         }"}, {"sha": "1771a963ba78cdf6dacb6b49aa3bf905e37eed84", "filename": "src/libstd/rt/io/net/unix.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Funix.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -16,36 +16,36 @@ pub struct UnixStream;\n \n impl UnixStream {\n     pub fn connect<P: PathLike>(_path: &P) -> Option<UnixStream> {\n-        fail2!()\n+        fail!()\n     }\n }\n \n impl Reader for UnixStream {\n-    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail2!() }\n+    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n \n-    fn eof(&mut self) -> bool { fail2!() }\n+    fn eof(&mut self) -> bool { fail!() }\n }\n \n impl Writer for UnixStream {\n-    fn write(&mut self, _v: &[u8]) { fail2!() }\n+    fn write(&mut self, _v: &[u8]) { fail!() }\n \n-    fn flush(&mut self) { fail2!() }\n+    fn flush(&mut self) { fail!() }\n }\n \n pub struct UnixListener;\n \n impl UnixListener {\n     pub fn bind<P: PathLike>(_path: &P) -> Option<UnixListener> {\n-        fail2!()\n+        fail!()\n     }\n }\n \n impl Listener<UnixStream, UnixAcceptor> for UnixListener {\n-    fn listen(self) -> Option<UnixAcceptor> { fail2!() }\n+    fn listen(self) -> Option<UnixAcceptor> { fail!() }\n }\n \n pub struct UnixAcceptor;\n \n impl Acceptor<UnixStream> for UnixAcceptor {\n-    fn accept(&mut self) -> Option<UnixStream> { fail2!() }\n+    fn accept(&mut self) -> Option<UnixStream> { fail!() }\n }"}, {"sha": "d2cd531ed266fd99c631e6e216844f958c016b4e", "filename": "src/libstd/rt/io/pipe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fpipe.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -64,7 +64,7 @@ impl Reader for PipeStream {\n         }\n     }\n \n-    fn eof(&mut self) -> bool { fail2!() }\n+    fn eof(&mut self) -> bool { fail!() }\n }\n \n impl Writer for PipeStream {\n@@ -77,5 +77,5 @@ impl Writer for PipeStream {\n         }\n     }\n \n-    fn flush(&mut self) { fail2!() }\n+    fn flush(&mut self) { fail!() }\n }"}, {"sha": "8029e3f643175507277a6c50780a1cde87c80bbb", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -403,7 +403,7 @@ impl KillHandle {\n         // FIXME(#7544)(bblum): is it really necessary to prohibit double kill?\n         match inner.unkillable.compare_and_swap(KILL_RUNNING, KILL_UNKILLABLE, Relaxed) {\n             KILL_RUNNING    => { }, // normal case\n-            KILL_KILLED     => if !already_failing { fail2!(\"{}\", KILLED_MSG) },\n+            KILL_KILLED     => if !already_failing { fail!(\"{}\", KILLED_MSG) },\n             _               => rtabort!(\"inhibit_kill: task already unkillable\"),\n         }\n     }\n@@ -416,7 +416,7 @@ impl KillHandle {\n         // FIXME(#7544)(bblum): is it really necessary to prohibit double kill?\n         match inner.unkillable.compare_and_swap(KILL_UNKILLABLE, KILL_RUNNING, Relaxed) {\n             KILL_UNKILLABLE => { }, // normal case\n-            KILL_KILLED     => if !already_failing { fail2!(\"{}\", KILLED_MSG) },\n+            KILL_KILLED     => if !already_failing { fail!(\"{}\", KILLED_MSG) },\n             _               => rtabort!(\"allow_kill: task already killable\"),\n         }\n     }\n@@ -624,7 +624,7 @@ impl Death {\n                 // synchronization during unwinding or cleanup (for example,\n                 // sending on a notify port). In that case failing won't help.\n                 if self.unkillable == 0 && (!already_failing) && kill_handle.killed() {\n-                    fail2!(\"{}\", KILLED_MSG);\n+                    fail!(\"{}\", KILLED_MSG);\n                 },\n             // This may happen during task death (see comments in collect_failure).\n             None => rtassert!(self.unkillable > 0),\n@@ -650,7 +650,7 @@ impl Death {\n         if self.unkillable == 0 {\n             // we need to decrement the counter before failing.\n             self.unkillable -= 1;\n-            fail2!(\"Cannot enter a rekillable() block without a surrounding unkillable()\");\n+            fail!(\"Cannot enter a rekillable() block without a surrounding unkillable()\");\n         }\n         self.unkillable -= 1;\n         if self.unkillable == 0 {"}, {"sha": "336d2518e437c82941c8e90cf28819cdd421b70e", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -1292,12 +1292,12 @@ mod test {\n             while (true) {\n                 match p.recv() {\n                     (1, end_chan) => {\n-                                debug2!(\"{}\\n\", id);\n+                                debug!(\"{}\\n\", id);\n                                 end_chan.send(());\n                                 return;\n                     }\n                     (token, end_chan) => {\n-                        debug2!(\"thread: {}   got token: {}\", id, token);\n+                        debug!(\"thread: {}   got token: {}\", id, token);\n                         ch.send((token - 1, end_chan));\n                         if token <= n_tasks {\n                             return;"}, {"sha": "a6f9e11e40e9e2ed68b8f75eaad48226f4c47db6", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -626,7 +626,7 @@ mod test {\n             let result = spawntask_try(||());\n             rtdebug!(\"trying first assert\");\n             assert!(result.is_ok());\n-            let result = spawntask_try(|| fail2!());\n+            let result = spawntask_try(|| fail!());\n             rtdebug!(\"trying second assert\");\n             assert!(result.is_err());\n         }\n@@ -644,7 +644,7 @@ mod test {\n     #[test]\n     fn logging() {\n         do run_in_newsched_task() {\n-            info2!(\"here i am. logging in a newsched task\");\n+            info!(\"here i am. logging in a newsched task\");\n         }\n     }\n \n@@ -686,7 +686,7 @@ mod test {\n     fn linked_failure() {\n         do run_in_newsched_task() {\n             let res = do spawntask_try {\n-                spawntask_random(|| fail2!());\n+                spawntask_random(|| fail!());\n             };\n             assert!(res.is_err());\n         }"}, {"sha": "4f7ebb4a72195954e71d0ecb30f97be9a2d2725f", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -115,15 +115,15 @@ mod darwin_fd_limit {\n                   to_mut_unsafe_ptr(&mut size),\n                   mut_null(), 0) != 0 {\n             let err = last_os_error();\n-            error2!(\"raise_fd_limit: error calling sysctl: {}\", err);\n+            error!(\"raise_fd_limit: error calling sysctl: {}\", err);\n             return;\n         }\n \n         // Fetch the current resource limits\n         let mut rlim = rlimit{rlim_cur: 0, rlim_max: 0};\n         if getrlimit(RLIMIT_NOFILE, to_mut_unsafe_ptr(&mut rlim)) != 0 {\n             let err = last_os_error();\n-            error2!(\"raise_fd_limit: error calling getrlimit: {}\", err);\n+            error!(\"raise_fd_limit: error calling getrlimit: {}\", err);\n             return;\n         }\n \n@@ -133,7 +133,7 @@ mod darwin_fd_limit {\n         // Set our newly-increased resource limit\n         if setrlimit(RLIMIT_NOFILE, to_unsafe_ptr(&rlim)) != 0 {\n             let err = last_os_error();\n-            error2!(\"raise_fd_limit: error calling setrlimit: {}\", err);\n+            error!(\"raise_fd_limit: error calling setrlimit: {}\", err);\n             return;\n         }\n     }"}, {"sha": "3a6d858df791cbfa2abd9a87162e30988ba12f2b", "filename": "src/libstd/rt/uv/file.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ffile.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -505,7 +505,7 @@ mod test {\n                 let unlink_req = FsRequest::new();\n                 let result = unlink_req.unlink_sync(&loop_, &Path::new(path_str));\n                 assert!(result.is_ok());\n-            } else { fail2!(\"nread was 0.. wudn't expectin' that.\"); }\n+            } else { fail!(\"nread was 0.. wudn't expectin' that.\"); }\n             loop_.close();\n         }\n     }"}, {"sha": "a2608bf6b2406be50c1c5a0c1a020b7d43b6781b", "filename": "src/libstd/rt/uv/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fnet.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -34,7 +34,7 @@ fn sockaddr_to_UvSocketAddr(addr: *uvll::sockaddr) -> UvSocketAddr {\n         match addr {\n             _ if is_ip4_addr(addr) => UvIpv4SocketAddr(addr as *uvll::sockaddr_in),\n             _ if is_ip6_addr(addr) => UvIpv6SocketAddr(addr as *uvll::sockaddr_in6),\n-            _ => fail2!(),\n+            _ => fail!(),\n         }\n     }\n }"}, {"sha": "a406058631823779049167d46456dc662da23080", "filename": "src/libstd/run.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -229,7 +229,7 @@ impl Process {\n             ((1, o), (2, e)) => (e, o),\n             ((2, e), (1, o)) => (e, o),\n             ((x, _), (y, _)) => {\n-                fail2!(\"unexpected file numbers: {}, {}\", x, y);\n+                fail!(\"unexpected file numbers: {}, {}\", x, y);\n             }\n         };\n "}, {"sha": "62a09984794978671703af45600f3d73cec8b3de", "filename": "src/libstd/select.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fselect.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -35,7 +35,7 @@ pub trait SelectPort<T> : SelectPortInner<T> { }\n /// port whose data is ready. (If multiple are ready, returns the lowest index.)\n pub fn select<A: Select>(ports: &mut [A]) -> uint {\n     if ports.is_empty() {\n-        fail2!(\"can't select on an empty list\");\n+        fail!(\"can't select on an empty list\");\n     }\n \n     for (index, port) in ports.mut_iter().enumerate() {\n@@ -116,7 +116,7 @@ pub fn select2<TA, A: SelectPort<TA>, TB, B: SelectPort<TB>>(mut a: A, mut b: B)\n     match result {\n         0 => Left ((a.recv_ready(), b)),\n         1 => Right((a, b.recv_ready())),\n-        x => fail2!(\"impossible case in select2: {:?}\", x)\n+        x => fail!(\"impossible case in select2: {:?}\", x)\n     }\n }\n \n@@ -335,7 +335,7 @@ mod test {\n                         let _ = dead_cs;\n                     }\n                     do task::spawn {\n-                        fail2!(); // should kill sibling awake\n+                        fail!(); // should kill sibling awake\n                     }\n \n                     // wait for killed selector to close (NOT send on) its c."}, {"sha": "883934124a6c3bcc8c14d8fe0f8accfd562031b7", "filename": "src/libstd/str.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -1229,7 +1229,7 @@ pub mod raw {\n                 match ctr {\n                     0 => assert_eq!(x, &~\"zero\"),\n                     1 => assert_eq!(x, &~\"one\"),\n-                    _ => fail2!(\"shouldn't happen!\")\n+                    _ => fail!(\"shouldn't happen!\")\n                 }\n                 ctr += 1;\n             }\n@@ -2001,8 +2001,8 @@ impl<'self> StrSlice<'self> for &'self str {\n         if end_byte.is_none() && count == end { end_byte = Some(self.len()) }\n \n         match (begin_byte, end_byte) {\n-            (None, _) => fail2!(\"slice_chars: `begin` is beyond end of string\"),\n-            (_, None) => fail2!(\"slice_chars: `end` is beyond end of string\"),\n+            (None, _) => fail!(\"slice_chars: `begin` is beyond end of string\"),\n+            (_, None) => fail!(\"slice_chars: `end` is beyond end of string\"),\n             (Some(a), Some(b)) => unsafe { raw::slice_bytes(*self, a, b) }\n         }\n     }\n@@ -3246,7 +3246,7 @@ mod tests {\n         // original problem code path anymore.)\n         let s = ~\"\";\n         let _bytes = s.as_bytes();\n-        fail2!();\n+        fail!();\n     }\n \n     #[test]\n@@ -3304,8 +3304,8 @@ mod tests {\n         while i < n1 {\n             let a: u8 = s1[i];\n             let b: u8 = s2[i];\n-            debug2!(\"{}\", a);\n-            debug2!(\"{}\", b);\n+            debug!(\"{}\", a);\n+            debug!(\"{}\", b);\n             assert_eq!(a, b);\n             i += 1u;\n         }"}, {"sha": "970a62b676fcc5c63e8d0f3b1e545ce765aa40ba", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -192,7 +192,7 @@ pub fn task() -> TaskBuilder {\n impl TaskBuilder {\n     fn consume(&mut self) -> TaskBuilder {\n         if self.consumed {\n-            fail2!(\"Cannot copy a task_builder\"); // Fake move mode on self\n+            fail!(\"Cannot copy a task_builder\"); // Fake move mode on self\n         }\n         self.consumed = true;\n         let gen_body = self.gen_body.take();\n@@ -280,7 +280,7 @@ impl TaskBuilder {\n         // sending out messages.\n \n         if self.opts.notify_chan.is_some() {\n-            fail2!(\"Can't set multiple future_results for one task!\");\n+            fail!(\"Can't set multiple future_results for one task!\");\n         }\n \n         // Construct the future and give it to the caller.\n@@ -540,7 +540,7 @@ pub fn with_task_name<U>(blk: &fn(Option<&str>) -> U) -> U {\n             }\n         }\n     } else {\n-        fail2!(\"no task name exists in non-green task context\")\n+        fail!(\"no task name exists in non-green task context\")\n     }\n }\n \n@@ -648,7 +648,7 @@ fn test_kill_unkillable_task() {\n     do run_in_newsched_task {\n         do task::try {\n             do task::spawn {\n-                fail2!();\n+                fail!();\n             }\n             do task::unkillable { }\n         };\n@@ -667,7 +667,7 @@ fn test_kill_rekillable_task() {\n             do task::unkillable {\n                 do task::rekillable {\n                     do task::spawn {\n-                        fail2!();\n+                        fail!();\n                     }\n                 }\n             }\n@@ -697,7 +697,7 @@ fn test_rekillable_nested_failure() {\n         do unkillable {\n             do rekillable {\n                 let (port,chan) = comm::stream();\n-                do task::spawn { chan.send(()); fail2!(); }\n+                do task::spawn { chan.send(()); fail!(); }\n                 port.recv(); // wait for child to exist\n                 port.recv(); // block forever, expect to get killed.\n             }\n@@ -741,7 +741,7 @@ fn test_spawn_unlinked_unsup_no_fail_down() { // grandchild sends on a port\n                 do 16.times { task::deschedule(); }\n                 ch.send(()); // If killed first, grandparent hangs.\n             }\n-            fail2!(); // Shouldn't kill either (grand)parent or (grand)child.\n+            fail!(); // Shouldn't kill either (grand)parent or (grand)child.\n         }\n         po.recv();\n     }\n@@ -751,15 +751,15 @@ fn test_spawn_unlinked_unsup_no_fail_down() { // grandchild sends on a port\n fn test_spawn_unlinked_unsup_no_fail_up() { // child unlinked fails\n     use rt::test::run_in_newsched_task;\n     do run_in_newsched_task {\n-        do spawn_unlinked { fail2!(); }\n+        do spawn_unlinked { fail!(); }\n     }\n }\n #[ignore(reason = \"linked failure\")]\n #[test]\n fn test_spawn_unlinked_sup_no_fail_up() { // child unlinked fails\n     use rt::test::run_in_newsched_task;\n     do run_in_newsched_task {\n-        do spawn_supervised { fail2!(); }\n+        do spawn_supervised { fail!(); }\n         // Give child a chance to fail-but-not-kill-us.\n         do 16.times { task::deschedule(); }\n     }\n@@ -771,7 +771,7 @@ fn test_spawn_unlinked_sup_fail_down() {\n     do run_in_newsched_task {\n         let result: Result<(),()> = do try {\n             do spawn_supervised { block_forever(); }\n-            fail2!(); // Shouldn't leave a child hanging around.\n+            fail!(); // Shouldn't leave a child hanging around.\n         };\n         assert!(result.is_err());\n     }\n@@ -791,7 +791,7 @@ fn test_spawn_linked_sup_fail_up() { // child fails; parent fails\n             b0.opts.supervised = true;\n \n             do b0.spawn {\n-                fail2!();\n+                fail!();\n             }\n             block_forever(); // We should get punted awake\n         };\n@@ -810,7 +810,7 @@ fn test_spawn_linked_sup_fail_down() { // parent fails; child fails\n             b0.opts.linked = true;\n             b0.opts.supervised = true;\n             do b0.spawn { block_forever(); }\n-            fail2!(); // *both* mechanisms would be wrong if this didn't kill the child\n+            fail!(); // *both* mechanisms would be wrong if this didn't kill the child\n         };\n         assert!(result.is_err());\n     }\n@@ -822,7 +822,7 @@ fn test_spawn_linked_unsup_fail_up() { // child fails; parent fails\n     do run_in_newsched_task {\n         let result: Result<(),()> = do try {\n             // Default options are to spawn linked & unsupervised.\n-            do spawn { fail2!(); }\n+            do spawn { fail!(); }\n             block_forever(); // We should get punted awake\n         };\n         assert!(result.is_err());\n@@ -836,7 +836,7 @@ fn test_spawn_linked_unsup_fail_down() { // parent fails; child fails\n         let result: Result<(),()> = do try {\n             // Default options are to spawn linked & unsupervised.\n             do spawn { block_forever(); }\n-            fail2!();\n+            fail!();\n         };\n         assert!(result.is_err());\n     }\n@@ -851,7 +851,7 @@ fn test_spawn_linked_unsup_default_opts() { // parent fails; child fails\n             let mut builder = task();\n             builder.linked();\n             do builder.spawn { block_forever(); }\n-            fail2!();\n+            fail!();\n         };\n         assert!(result.is_err());\n     }\n@@ -871,7 +871,7 @@ fn test_spawn_failure_propagate_grandchild() {\n                 do spawn_supervised { block_forever(); }\n             }\n             do 16.times { task::deschedule(); }\n-            fail2!();\n+            fail!();\n         };\n         assert!(result.is_err());\n     }\n@@ -888,7 +888,7 @@ fn test_spawn_failure_propagate_secondborn() {\n                 do spawn { block_forever(); } // linked\n             }\n             do 16.times { task::deschedule(); }\n-            fail2!();\n+            fail!();\n         };\n         assert!(result.is_err());\n     }\n@@ -905,7 +905,7 @@ fn test_spawn_failure_propagate_nephew_or_niece() {\n                 do spawn_supervised { block_forever(); }\n             }\n             do 16.times { task::deschedule(); }\n-            fail2!();\n+            fail!();\n         };\n         assert!(result.is_err());\n     }\n@@ -922,7 +922,7 @@ fn test_spawn_linked_sup_propagate_sibling() {\n                 do spawn { block_forever(); } // linked\n             }\n             do 16.times { task::deschedule(); }\n-            fail2!();\n+            fail!();\n         };\n         assert!(result.is_err());\n     }\n@@ -1030,7 +1030,7 @@ fn test_future_result() {\n     let result = builder.future_result();\n     builder.unlinked();\n     do builder.spawn {\n-        fail2!();\n+        fail!();\n     }\n     assert_eq!(result.recv(), Failure);\n }\n@@ -1048,17 +1048,17 @@ fn test_try_success() {\n         ~\"Success!\"\n     } {\n         result::Ok(~\"Success!\") => (),\n-        _ => fail2!()\n+        _ => fail!()\n     }\n }\n \n #[test]\n fn test_try_fail() {\n     match do try {\n-        fail2!()\n+        fail!()\n     } {\n         result::Err(()) => (),\n-        result::Ok(()) => fail2!()\n+        result::Ok(()) => fail!()\n     }\n }\n \n@@ -1248,7 +1248,7 @@ fn test_unkillable() {\n         deschedule();\n         // We want to fail after the unkillable task\n         // blocks on recv\n-        fail2!();\n+        fail!();\n     }\n \n     unsafe {\n@@ -1283,7 +1283,7 @@ fn test_unkillable_nested() {\n         deschedule();\n         // We want to fail after the unkillable task\n         // blocks on recv\n-        fail2!();\n+        fail!();\n     }\n \n     unsafe {\n@@ -1348,7 +1348,7 @@ fn test_spawn_watched() {\n                 t.watched();\n                 do t.spawn {\n                     task::deschedule();\n-                    fail2!();\n+                    fail!();\n                 }\n             }\n         };\n@@ -1384,7 +1384,7 @@ fn test_indestructible() {\n                 do t.spawn {\n                     p3.recv();\n                     task::deschedule();\n-                    fail2!();\n+                    fail!();\n                 }\n                 c3.send(());\n                 p2.recv();"}, {"sha": "7cf0f04c7e9f6882438d66e6fbd389c71278d69b", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -631,7 +631,7 @@ pub fn spawn_raw(mut opts: TaskOpts, f: ~fn()) {\n             let (thread_port, thread_chan) = oneshot();\n             let thread_port_cell = Cell::new(thread_port);\n             let join_task = do Task::build_child(None) {\n-                debug2!(\"running join task\");\n+                debug!(\"running join task\");\n                 let thread_port = thread_port_cell.take();\n                 let thread: Thread = thread_port.recv();\n                 thread.join();\n@@ -648,11 +648,11 @@ pub fn spawn_raw(mut opts: TaskOpts, f: ~fn()) {\n                 let join_task = join_task_cell.take();\n \n                 let bootstrap_task = ~do Task::new_root(&mut new_sched.stack_pool, None) || {\n-                    debug2!(\"boostrapping a 1:1 scheduler\");\n+                    debug!(\"boostrapping a 1:1 scheduler\");\n                 };\n                 new_sched.bootstrap(bootstrap_task);\n \n-                debug2!(\"enqueing join_task\");\n+                debug!(\"enqueing join_task\");\n                 // Now tell the original scheduler to join with this thread\n                 // by scheduling a thread-joining task on the original scheduler\n                 orig_sched_handle.send_task_from_friend(join_task);\n@@ -684,7 +684,7 @@ pub fn spawn_raw(mut opts: TaskOpts, f: ~fn()) {\n     }\n \n     task.name = opts.name.take();\n-    debug2!(\"spawn calling run_task\");\n+    debug!(\"spawn calling run_task\");\n     Scheduler::run_task(task);\n \n }\n@@ -707,7 +707,7 @@ fn test_spawn_raw_unsupervise() {\n         .. default_task_opts()\n     };\n     do spawn_raw(opts) {\n-        fail2!();\n+        fail!();\n     }\n }\n \n@@ -736,7 +736,7 @@ fn test_spawn_raw_notify_failure() {\n         .. default_task_opts()\n     };\n     do spawn_raw(opts) {\n-        fail2!();\n+        fail!();\n     }\n     assert_eq!(notify_po.recv(), Failure);\n }"}, {"sha": "c561fb6cc8a457d1759982e02a6076f56087b8a2", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -422,7 +422,7 @@ fn remove<T>(count: &mut uint, child: &mut Child<T>, key: uint,\n       External(stored, _) if stored == key => {\n         match replace(child, Nothing) {\n             External(_, value) => (Some(value), true),\n-            _ => fail2!()\n+            _ => fail!()\n         }\n       }\n       External(*) => (None, false),\n@@ -531,7 +531,7 @@ mod test_map {\n         assert!(m.insert(5, 14));\n         let new = 100;\n         match m.find_mut(&5) {\n-            None => fail2!(), Some(x) => *x = new\n+            None => fail!(), Some(x) => *x = new\n         }\n         assert_eq!(m.find(&5), Some(&new));\n     }"}, {"sha": "d3d768bc0c6fba6ecb070fdee0a64580fe83f9bb", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -33,7 +33,7 @@ impl Drop for DynamicLibrary {\n             }\n         } {\n             Ok(()) => {},\n-            Err(str) => fail2!(\"{}\", str)\n+            Err(str) => fail!(\"{}\", str)\n         }\n     }\n }\n@@ -94,13 +94,13 @@ mod test {\n         // The math library does not need to be loaded since it is already\n         // statically linked in\n         let libm = match DynamicLibrary::open(None) {\n-            Err(error) => fail2!(\"Could not load self as module: {}\", error),\n+            Err(error) => fail!(\"Could not load self as module: {}\", error),\n             Ok(libm) => libm\n         };\n \n         let cosine: extern fn(libc::c_double) -> libc::c_double = unsafe {\n             match libm.symbol(\"cos\") {\n-                Err(error) => fail2!(\"Could not load function cos: {}\", error),\n+                Err(error) => fail!(\"Could not load function cos: {}\", error),\n                 Ok(cosine) => cosine\n             }\n         };\n@@ -109,7 +109,7 @@ mod test {\n         let expected_result = 1.0;\n         let result = cosine(argument);\n         if result != expected_result {\n-            fail2!(\"cos({:?}) != {:?} but equaled {:?} instead\", argument,\n+            fail!(\"cos({:?}) != {:?} but equaled {:?} instead\", argument,\n                    expected_result, result)\n         }\n     }\n@@ -124,7 +124,7 @@ mod test {\n         let path = GenericPath::new(\"/dev/null\");\n         match DynamicLibrary::open(Some(&path)) {\n             Err(_) => {}\n-            Ok(_) => fail2!(\"Successfully opened the empty library.\")\n+            Ok(_) => fail!(\"Successfully opened the empty library.\")\n         }\n     }\n }"}, {"sha": "c1365a44bc913c8d19a6cc8cffcd206e4bcb1a5e", "filename": "src/libstd/unstable/finally.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Funstable%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Funstable%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Ffinally.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -87,7 +87,7 @@ fn test_fail() {\n     let mut i = 0;\n     do (|| {\n         i = 10;\n-        fail2!();\n+        fail!();\n     }).finally {\n         assert!(failing());\n         assert_eq!(i, 10);"}, {"sha": "4c6ad469d8cbeaccd1ecd18773821c31e2b64586", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -172,7 +172,7 @@ impl<T: Send> UnsafeArc<T> {\n                     // If 'put' returns the server end back to us, we were rejected;\n                     // someone else was trying to unwrap. Avoid guaranteed deadlock.\n                     cast::forget(data);\n-                    fail2!(\"Another task is already unwrapping this Arc!\");\n+                    fail!(\"Another task is already unwrapping this Arc!\");\n                 }\n             }\n         }\n@@ -386,7 +386,7 @@ impl<T:Send> Exclusive<T> {\n         let rec = self.x.get();\n         do (*rec).lock.lock {\n             if (*rec).failed {\n-                fail2!(\"Poisoned Exclusive::new - another task failed inside!\");\n+                fail!(\"Poisoned Exclusive::new - another task failed inside!\");\n             }\n             (*rec).failed = true;\n             let result = f(&mut (*rec).data);\n@@ -617,7 +617,7 @@ mod tests {\n             let x2 = x.clone();\n             do task::spawn {\n                 do 10.times { task::deschedule(); } // try to let the unwrapper go\n-                fail2!(); // punt it awake from its deadlock\n+                fail!(); // punt it awake from its deadlock\n             }\n             let _z = x.unwrap();\n             unsafe { do x2.with |_hello| { } }"}, {"sha": "b10d0ded5b47757345b2b3b6bca964dd0cb27aa9", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -1063,7 +1063,7 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n \n     #[inline]\n     fn head(&self) -> &'self T {\n-        if self.len() == 0 { fail2!(\"head: empty vector\") }\n+        if self.len() == 0 { fail!(\"head: empty vector\") }\n         &self[0]\n     }\n \n@@ -1090,7 +1090,7 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n \n     #[inline]\n     fn last(&self) -> &'self T {\n-        if self.len() == 0 { fail2!(\"last: empty vector\") }\n+        if self.len() == 0 { fail!(\"last: empty vector\") }\n         &self[self.len() - 1]\n     }\n \n@@ -1409,7 +1409,7 @@ impl<T> OwnedVector<T> for ~[T] {\n                     let alloc = n * mem::nonzero_size_of::<T>();\n                     let size = alloc + mem::size_of::<Vec<()>>();\n                     if alloc / mem::nonzero_size_of::<T>() != n || size < alloc {\n-                        fail2!(\"vector size is too large: {}\", n);\n+                        fail!(\"vector size is too large: {}\", n);\n                     }\n                     *ptr = realloc_raw(*ptr as *mut c_void, size)\n                            as *mut Vec<()>;\n@@ -1428,7 +1428,7 @@ impl<T> OwnedVector<T> for ~[T] {\n     fn reserve_additional(&mut self, n: uint) {\n         if self.capacity() - self.len() < n {\n             match self.len().checked_add(&n) {\n-                None => fail2!(\"vec::reserve_additional: `uint` overflow\"),\n+                None => fail!(\"vec::reserve_additional: `uint` overflow\"),\n                 Some(new_cap) => self.reserve_at_least(new_cap)\n             }\n         }\n@@ -1622,7 +1622,7 @@ impl<T> OwnedVector<T> for ~[T] {\n     fn swap_remove(&mut self, index: uint) -> T {\n         let ln = self.len();\n         if index >= ln {\n-            fail2!(\"vec::swap_remove - index {} >= length {}\", index, ln);\n+            fail!(\"vec::swap_remove - index {} >= length {}\", index, ln);\n         }\n         if index < ln - 1 {\n             self.swap(index, ln - 1);\n@@ -2997,7 +2997,7 @@ mod tests {\n                 3 => assert_eq!(v, [2, 3, 1]),\n                 4 => assert_eq!(v, [2, 1, 3]),\n                 5 => assert_eq!(v, [1, 2, 3]),\n-                _ => fail2!(),\n+                _ => fail!(),\n             }\n         }\n     }\n@@ -3244,7 +3244,7 @@ mod tests {\n     #[should_fail]\n     fn test_from_fn_fail() {\n         do from_fn(100) |v| {\n-            if v == 50 { fail2!() }\n+            if v == 50 { fail!() }\n             (~0, @0)\n         };\n     }\n@@ -3263,7 +3263,7 @@ mod tests {\n             fn clone(&self) -> S {\n                 let s = unsafe { cast::transmute_mut(self) };\n                 s.f += 1;\n-                if s.f == 10 { fail2!() }\n+                if s.f == 10 { fail!() }\n                 S { f: s.f, boxes: s.boxes.clone() }\n             }\n         }\n@@ -3280,7 +3280,7 @@ mod tests {\n             push((~0, @0));\n             push((~0, @0));\n             push((~0, @0));\n-            fail2!();\n+            fail!();\n         };\n     }\n \n@@ -3290,7 +3290,7 @@ mod tests {\n         let mut v = ~[];\n         do v.grow_fn(100) |i| {\n             if i == 50 {\n-                fail2!()\n+                fail!()\n             }\n             (~0, @0)\n         }\n@@ -3303,7 +3303,7 @@ mod tests {\n         let mut i = 0;\n         do v.map |_elt| {\n             if i == 2 {\n-                fail2!()\n+                fail!()\n             }\n             i += 1;\n             ~[(~0, @0)]\n@@ -3317,7 +3317,7 @@ mod tests {\n         let mut i = 0;\n         do flat_map(v) |_elt| {\n             if i == 2 {\n-                fail2!()\n+                fail!()\n             }\n             i += 1;\n             ~[(~0, @0)]\n@@ -3331,7 +3331,7 @@ mod tests {\n         let mut i = 0;\n         for _ in v.permutations_iter() {\n             if i == 2 {\n-                fail2!()\n+                fail!()\n             }\n             i += 1;\n         }\n@@ -3342,7 +3342,7 @@ mod tests {\n     fn test_as_imm_buf_fail() {\n         let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         do v.as_imm_buf |_buf, _i| {\n-            fail2!()\n+            fail!()\n         }\n     }\n \n@@ -3351,7 +3351,7 @@ mod tests {\n     fn test_as_mut_buf_fail() {\n         let mut v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         do v.as_mut_buf |_buf, _i| {\n-            fail2!()\n+            fail!()\n         }\n     }\n \n@@ -3816,7 +3816,7 @@ mod bench {\n                 sum += *x;\n             }\n             // sum == 11806, to stop dead code elimination.\n-            if sum == 0 {fail2!()}\n+            if sum == 0 {fail!()}\n         }\n     }\n "}, {"sha": "ed20b160eb4d3810e0b3ca58652655b664c6e764", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -221,7 +221,7 @@ impl AbiSet {\n             let data = abi.data();\n             for other_abi in abis.slice(0, i).iter() {\n                 let other_data = other_abi.data();\n-                debug2!(\"abis=({:?},{:?}) datas=({:?},{:?})\",\n+                debug!(\"abis=({:?},{:?}) datas=({:?},{:?})\",\n                        abi, data.abi_arch,\n                        other_abi, other_data.abi_arch);\n                 match (&data.abi_arch, &other_data.abi_arch) {\n@@ -306,7 +306,7 @@ fn cannot_combine(n: Abi, m: Abi) {\n                          (m == a && n == b));\n         }\n         None => {\n-            fail2!(\"Invalid match not detected\");\n+            fail!(\"Invalid match not detected\");\n         }\n     }\n }\n@@ -318,7 +318,7 @@ fn can_combine(n: Abi, m: Abi) {\n     set.add(m);\n     match set.check_valid() {\n         Some((_, _)) => {\n-            fail2!(\"Valid match declared invalid\");\n+            fail!(\"Valid match declared invalid\");\n         }\n         None => {}\n     }\n@@ -367,15 +367,15 @@ fn abi_to_str_c_aaps() {\n     let mut set = AbiSet::empty();\n     set.add(Aapcs);\n     set.add(C);\n-    debug2!(\"set = {}\", set.to_str());\n+    debug!(\"set = {}\", set.to_str());\n     assert!(set.to_str() == ~\"\\\"aapcs C\\\"\");\n }\n \n #[test]\n fn abi_to_str_rust() {\n     let mut set = AbiSet::empty();\n     set.add(Rust);\n-    debug2!(\"set = {}\", set.to_str());\n+    debug!(\"set = {}\", set.to_str());\n     assert!(set.to_str() == ~\"\\\"Rust\\\"\");\n }\n "}, {"sha": "01033e829f6a76d14c8cc6647f0a8aec0fc4dc45", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -47,7 +47,7 @@ impl Eq for Ident {\n             // if it should be non-hygienic (most things are), just compare the\n             // 'name' fields of the idents. Or, even better, replace the idents\n             // with Name's.\n-            fail2!(\"not allowed to compare these idents: {:?}, {:?}.\n+            fail!(\"not allowed to compare these idents: {:?}, {:?}.\n                     Probably related to issue \\\\#6993\", self, other);\n         }\n     }"}, {"sha": "17613d19c7ef1148c1fb76b0f135538e6ce6c2fd", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -185,7 +185,7 @@ impl Ctx {\n                                                          item,\n                                                          p));\n                     }\n-                    _ => fail2!(\"struct def parent wasn't an item\")\n+                    _ => fail!(\"struct def parent wasn't an item\")\n                 }\n             }\n         }\n@@ -485,6 +485,6 @@ pub fn node_item_query<Result>(items: map, id: NodeId,\n                                error_msg: ~str) -> Result {\n     match items.find(&id) {\n         Some(&node_item(it, _)) => query(it),\n-        _ => fail2!(\"{}\", error_msg)\n+        _ => fail!(\"{}\", error_msg)\n     }\n }"}, {"sha": "bdebc9872e690dd3b9352a8438a64c2d2deedccb", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -45,7 +45,7 @@ pub fn stmt_id(s: &Stmt) -> NodeId {\n       StmtDecl(_, id) => id,\n       StmtExpr(_, id) => id,\n       StmtSemi(_, id) => id,\n-      StmtMac(*) => fail2!(\"attempted to analyze unexpanded stmt\")\n+      StmtMac(*) => fail!(\"attempted to analyze unexpanded stmt\")\n     }\n }\n \n@@ -72,7 +72,7 @@ pub fn def_id_of_def(d: Def) -> DefId {\n         local_def(id)\n       }\n \n-      DefPrimTy(_) => fail2!()\n+      DefPrimTy(_) => fail!()\n     }\n }\n \n@@ -735,7 +735,7 @@ pub fn new_mark_internal(m:Mrk, tail:SyntaxContext,table:&mut SCTable)\n         }\n         true => {\n             match table.mark_memo.find(&key) {\n-                None => fail2!(\"internal error: key disappeared 2013042901\"),\n+                None => fail!(\"internal error: key disappeared 2013042901\"),\n                 Some(idxptr) => {*idxptr}\n             }\n         }\n@@ -762,7 +762,7 @@ pub fn new_rename_internal(id:Ident, to:Name, tail:SyntaxContext, table: &mut SC\n         }\n         true => {\n             match table.rename_memo.find(&key) {\n-                None => fail2!(\"internal error: key disappeared 2013042902\"),\n+                None => fail!(\"internal error: key disappeared 2013042902\"),\n                 Some(idxptr) => {*idxptr}\n             }\n         }\n@@ -795,9 +795,9 @@ pub fn get_sctable() -> @mut SCTable {\n \n /// print out an SCTable for debugging\n pub fn display_sctable(table : &SCTable) {\n-    error2!(\"SC table:\");\n+    error!(\"SC table:\");\n     for (idx,val) in table.table.iter().enumerate() {\n-        error2!(\"{:4u} : {:?}\",idx,val);\n+        error!(\"{:4u} : {:?}\",idx,val);\n     }\n }\n \n@@ -859,7 +859,7 @@ pub fn resolve_internal(id : Ident,\n                             resolvedthis\n                         }\n                     }\n-                    IllegalCtxt() => fail2!(\"expected resolvable context, got IllegalCtxt\")\n+                    IllegalCtxt() => fail!(\"expected resolvable context, got IllegalCtxt\")\n                 }\n             };\n             resolve_table.insert(key,resolved);\n@@ -900,7 +900,7 @@ pub fn marksof(ctxt: SyntaxContext, stopname: Name, table: &SCTable) -> ~[Mrk] {\n                     loopvar = tl;\n                 }\n             }\n-            IllegalCtxt => fail2!(\"expected resolvable context, got IllegalCtxt\")\n+            IllegalCtxt => fail!(\"expected resolvable context, got IllegalCtxt\")\n         }\n     }\n }\n@@ -911,7 +911,7 @@ pub fn mtwt_outer_mark(ctxt: SyntaxContext) -> Mrk {\n     let sctable = get_sctable();\n     match sctable.table[ctxt] {\n         ast::Mark(mrk,_) => mrk,\n-        _ => fail2!(\"can't retrieve outer mark when outside is not a mark\")\n+        _ => fail!(\"can't retrieve outer mark when outside is not a mark\")\n     }\n }\n \n@@ -1043,7 +1043,7 @@ mod test {\n                     sc = tail;\n                     continue;\n                 }\n-                IllegalCtxt => fail2!(\"expected resolvable context, got IllegalCtxt\")\n+                IllegalCtxt => fail!(\"expected resolvable context, got IllegalCtxt\")\n             }\n         }\n     }"}, {"sha": "40b7ff29e241a45b2d1b7eefe7b9fd4140e5166b", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -168,17 +168,17 @@ pub fn mk_sugared_doc_attr(text: @str, lo: BytePos, hi: BytePos) -> Attribute {\n /// span included in the `==` comparison a plain MetaItem.\n pub fn contains(haystack: &[@ast::MetaItem],\n                 needle: @ast::MetaItem) -> bool {\n-    debug2!(\"attr::contains (name={})\", needle.name());\n+    debug!(\"attr::contains (name={})\", needle.name());\n     do haystack.iter().any |item| {\n-        debug2!(\"  testing: {}\", item.name());\n+        debug!(\"  testing: {}\", item.name());\n         item.node == needle.node\n     }\n }\n \n pub fn contains_name<AM: AttrMetaMethods>(metas: &[AM], name: &str) -> bool {\n-    debug2!(\"attr::contains_name (name={})\", name);\n+    debug!(\"attr::contains_name (name={})\", name);\n     do metas.iter().any |item| {\n-        debug2!(\"  testing: {}\", item.name());\n+        debug!(\"  testing: {}\", item.name());\n         name == item.name()\n     }\n }\n@@ -279,23 +279,23 @@ pub fn test_cfg<AM: AttrMetaMethods, It: Iterator<AM>>\n     // this would be much nicer as a chain of iterator adaptors, but\n     // this doesn't work.\n     let some_cfg_matches = do metas.any |mi| {\n-        debug2!(\"testing name: {}\", mi.name());\n+        debug!(\"testing name: {}\", mi.name());\n         if \"cfg\" == mi.name() { // it is a #[cfg()] attribute\n-            debug2!(\"is cfg\");\n+            debug!(\"is cfg\");\n             no_cfgs = false;\n              // only #[cfg(...)] ones are understood.\n             match mi.meta_item_list() {\n                 Some(cfg_meta) => {\n-                    debug2!(\"is cfg(...)\");\n+                    debug!(\"is cfg(...)\");\n                     do cfg_meta.iter().all |cfg_mi| {\n-                        debug2!(\"cfg({}[...])\", cfg_mi.name());\n+                        debug!(\"cfg({}[...])\", cfg_mi.name());\n                         match cfg_mi.node {\n                             ast::MetaList(s, ref not_cfgs) if \"not\" == s => {\n-                                debug2!(\"not!\");\n+                                debug!(\"not!\");\n                                 // inside #[cfg(not(...))], so these need to all\n                                 // not match.\n                                 not_cfgs.iter().all(|mi| {\n-                                    debug2!(\"cfg(not({}[...]))\", mi.name());\n+                                    debug!(\"cfg(not({}[...]))\", mi.name());\n                                     !contains(cfg, *mi)\n                                 })\n                             }\n@@ -309,7 +309,7 @@ pub fn test_cfg<AM: AttrMetaMethods, It: Iterator<AM>>\n             false\n         }\n     };\n-    debug2!(\"test_cfg (no_cfgs={}, some_cfg_matches={})\", no_cfgs, some_cfg_matches);\n+    debug!(\"test_cfg (no_cfgs={}, some_cfg_matches={})\", no_cfgs, some_cfg_matches);\n     no_cfgs || some_cfg_matches\n }\n "}, {"sha": "5e4355161f40af946af3434dfc82b48a59f6afd2", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -374,7 +374,7 @@ impl CodeMap {\n         for fm in self.files.iter() { if filename == fm.name { return *fm; } }\n         //XXjdm the following triggers a mismatched type bug\n         //      (or expected function, found _|_)\n-        fail2!(); // (\"asking for \" + filename + \" which we don't know about\");\n+        fail!(); // (\"asking for \" + filename + \" which we don't know about\");\n     }\n }\n \n@@ -393,7 +393,7 @@ impl CodeMap {\n             }\n         }\n         if (a >= len) {\n-            fail2!(\"position {} does not resolve to a source location\", pos.to_uint())\n+            fail!(\"position {} does not resolve to a source location\", pos.to_uint())\n         }\n \n         return a;\n@@ -419,11 +419,11 @@ impl CodeMap {\n         let chpos = self.bytepos_to_local_charpos(pos);\n         let linebpos = f.lines[a];\n         let linechpos = self.bytepos_to_local_charpos(linebpos);\n-        debug2!(\"codemap: byte pos {:?} is on the line at byte pos {:?}\",\n+        debug!(\"codemap: byte pos {:?} is on the line at byte pos {:?}\",\n                pos, linebpos);\n-        debug2!(\"codemap: char pos {:?} is on the line at char pos {:?}\",\n+        debug!(\"codemap: char pos {:?} is on the line at char pos {:?}\",\n                chpos, linechpos);\n-        debug2!(\"codemap: byte is on line: {:?}\", line);\n+        debug!(\"codemap: byte is on line: {:?}\", line);\n         assert!(chpos >= linechpos);\n         return Loc {\n             file: f,\n@@ -450,15 +450,15 @@ impl CodeMap {\n     // Converts an absolute BytePos to a CharPos relative to the file it is\n     // located in\n     fn bytepos_to_local_charpos(&self, bpos: BytePos) -> CharPos {\n-        debug2!(\"codemap: converting {:?} to char pos\", bpos);\n+        debug!(\"codemap: converting {:?} to char pos\", bpos);\n         let idx = self.lookup_filemap_idx(bpos);\n         let map = self.files[idx];\n \n         // The number of extra bytes due to multibyte chars in the FileMap\n         let mut total_extra_bytes = 0;\n \n         for mbc in map.multibyte_chars.iter() {\n-            debug2!(\"codemap: {:?}-byte char at {:?}\", mbc.bytes, mbc.pos);\n+            debug!(\"codemap: {:?}-byte char at {:?}\", mbc.bytes, mbc.pos);\n             if mbc.pos < bpos {\n                 total_extra_bytes += mbc.bytes;\n                 // We should never see a byte position in the middle of a"}, {"sha": "b38d46115357c6af247ae0654ca64cc79cf2eeb9", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -69,7 +69,7 @@ struct CodemapT {\n impl span_handler for CodemapT {\n     fn span_fatal(@mut self, sp: Span, msg: &str) -> ! {\n         self.handler.emit(Some((self.cm, sp)), msg, fatal);\n-        fail2!();\n+        fail!();\n     }\n     fn span_err(@mut self, sp: Span, msg: &str) {\n         self.handler.emit(Some((self.cm, sp)), msg, error);\n@@ -95,7 +95,7 @@ impl span_handler for CodemapT {\n impl handler for HandlerT {\n     fn fatal(@mut self, msg: &str) -> ! {\n         self.emit.emit(None, msg, fatal);\n-        fail2!();\n+        fail!();\n     }\n     fn err(@mut self, msg: &str) {\n         self.emit.emit(None, msg, error);"}, {"sha": "1f9fe28a46d5b5088de46c10906da6774f3645af", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -540,11 +540,11 @@ impl <K: Eq + Hash + IterBytes + 'static, V: 'static> MapChain<K,V>{\n     // names? I think not.\n     // delaying implementing this....\n     pub fn each_key (&self, _f: &fn (&K)->bool) {\n-        fail2!(\"unimplemented 2013-02-15T10:01\");\n+        fail!(\"unimplemented 2013-02-15T10:01\");\n     }\n \n     pub fn each_value (&self, _f: &fn (&V) -> bool) {\n-        fail2!(\"unimplemented 2013-02-15T10:02\");\n+        fail!(\"unimplemented 2013-02-15T10:02\");\n     }\n \n     // Returns a copy of the value that the name maps to.\n@@ -587,7 +587,7 @@ impl <K: Eq + Hash + IterBytes + 'static, V: 'static> MapChain<K,V>{\n                 if satisfies_pred(map,&n,pred) {\n                     map.insert(key,ext);\n                 } else {\n-                    fail2!(\"expected map chain containing satisfying frame\")\n+                    fail!(\"expected map chain containing satisfying frame\")\n                 }\n             },\n             ConsMapChain (~ref mut map, rest) => {"}, {"sha": "e1cc63fd0b82865161958ee767a093951ed7c1ad", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -429,7 +429,7 @@ fn insert_macro(exts: SyntaxEnv, name: ast::Name, transformer: @Transformer) {\n         match t {\n             &@BlockInfo(BlockInfo {macros_escape:false,_}) => true,\n             &@BlockInfo(BlockInfo {_}) => false,\n-            _ => fail2!(\"special identifier {:?} was bound to a non-BlockInfo\",\n+            _ => fail!(\"special identifier {:?} was bound to a non-BlockInfo\",\n                         special_block_name)\n         }\n     };\n@@ -741,15 +741,15 @@ pub fn expand_block_elts(exts: SyntaxEnv, b: &Block, fld: &MacroExpander)\n fn mustbesome<T>(val : Option<T>) -> T {\n     match val {\n         Some(v) => v,\n-        None => fail2!(\"rename_fold returned None\")\n+        None => fail!(\"rename_fold returned None\")\n     }\n }\n \n // get the (innermost) BlockInfo from an exts stack\n fn get_block_info(exts : SyntaxEnv) -> BlockInfo {\n     match exts.find_in_topmost_frame(&intern(special_block_name)) {\n         Some(@BlockInfo(bi)) => bi,\n-        _ => fail2!(\"special identifier {:?} was bound to a non-BlockInfo\",\n+        _ => fail!(\"special identifier {:?} was bound to a non-BlockInfo\",\n                     @\" block\")\n     }\n }\n@@ -782,7 +782,7 @@ pub fn renames_to_fold(renames: @mut ~[(ast::Ident,ast::Name)]) -> @ast_fold {\n fn apply_pending_renames(folder : @ast_fold, stmt : ast::Stmt) -> @ast::Stmt {\n     match folder.fold_stmt(&stmt) {\n         Some(s) => s,\n-        None => fail2!(\"renaming of stmt produced None\")\n+        None => fail!(\"renaming of stmt produced None\")\n     }\n }\n \n@@ -840,11 +840,11 @@ pub fn std_macros() -> @str {\n \n     // NOTE (acrichto): remove these after the next snapshot\n     macro_rules! log2( ($($arg:tt)*) => (log!($($arg)*)) )\n-    macro_rules! error2( ($($arg:tt)*) => (error!($($arg)*)) )\n-    macro_rules! warn2 ( ($($arg:tt)*) => (warn!($($arg)*)) )\n-    macro_rules! info2 ( ($($arg:tt)*) => (info!($($arg)*)) )\n-    macro_rules! debug2( ($($arg:tt)*) => (debug!($($arg)*)) )\n-    macro_rules! fail2( ($($arg:tt)*) => (fail!($($arg)*)) )\n+    macro_rules! error( ($($arg:tt)*) => (error!($($arg)*)) )\n+    macro_rules! warn ( ($($arg:tt)*) => (warn!($($arg)*)) )\n+    macro_rules! info ( ($($arg:tt)*) => (info!($($arg)*)) )\n+    macro_rules! debug( ($($arg:tt)*) => (debug!($($arg)*)) )\n+    macro_rules! fail( ($($arg:tt)*) => (fail!($($arg)*)) )\n \n     macro_rules! assert(\n         ($cond:expr) => {\n@@ -873,7 +873,7 @@ pub fn std_macros() -> @str {\n                 // check both directions of equality....\n                 if !((*given_val == *expected_val) &&\n                      (*expected_val == *given_val)) {\n-                    fail2!(\\\"assertion failed: `(left == right) && (right == \\\n+                    fail!(\\\"assertion failed: `(left == right) && (right == \\\n                              left)` (left: `{:?}`, right: `{:?}`)\\\",\n                            *given_val, *expected_val);\n                 }\n@@ -893,7 +893,7 @@ pub fn std_macros() -> @str {\n                     given_val.approx_eq(&expected_val) &&\n                     expected_val.approx_eq(&given_val)\n                 ) {\n-                    fail2!(\\\"left: {:?} does not approximately equal right: {:?}\\\",\n+                    fail!(\\\"left: {:?} does not approximately equal right: {:?}\\\",\n                            given_val, expected_val);\n                 }\n             }\n@@ -910,7 +910,7 @@ pub fn std_macros() -> @str {\n                     given_val.approx_eq_eps(&expected_val, &epsilon_val) &&\n                     expected_val.approx_eq_eps(&given_val, &epsilon_val)\n                 ) {\n-                    fail2!(\\\"left: {:?} does not approximately equal right: \\\n+                    fail!(\\\"left: {:?} does not approximately equal right: \\\n                              {:?} with epsilon: {:?}\\\",\n                           given_val, expected_val, epsilon_val);\n                 }\n@@ -945,7 +945,7 @@ pub fn std_macros() -> @str {\n \n     */\n     macro_rules! unreachable (() => (\n-        fail2!(\\\"internal error: entered unreachable code\\\");\n+        fail!(\\\"internal error: entered unreachable code\\\");\n     ))\n \n     macro_rules! condition (\n@@ -1123,7 +1123,7 @@ pub fn inject_std_macros(parse_sess: @mut parse::ParseSess,\n                                               ~[],\n                                               parse_sess) {\n         Some(item) => item,\n-        None => fail2!(\"expected core macros to parse correctly\")\n+        None => fail!(\"expected core macros to parse correctly\")\n     };\n \n     let injector = @Injector {\n@@ -1381,16 +1381,16 @@ mod test {\n     use util::parser_testing::{string_to_pat, string_to_tts, strs_to_idents};\n     use visit;\n \n-    // make sure that fail2! is present\n+    // make sure that fail! is present\n     #[test] fn fail_exists_test () {\n-        let src = @\"fn main() { fail2!(\\\"something appropriately gloomy\\\");}\";\n+        let src = @\"fn main() { fail!(\\\"something appropriately gloomy\\\");}\";\n         let sess = parse::new_parse_sess(None);\n         let crate_ast = parse::parse_crate_from_source_str(\n             @\"<test>\",\n             src,\n             ~[],sess);\n         let crate_ast = inject_std_macros(sess, ~[], crate_ast);\n-        // don't bother with striping, doesn't affect fail2!.\n+        // don't bother with striping, doesn't affect fail!.\n         expand_crate(sess,~[],crate_ast);\n     }\n \n@@ -1448,7 +1448,7 @@ mod test {\n             cfg,~[],sess);\n         match item_ast {\n             Some(_) => (), // success\n-            None => fail2!(\"expected this to parse\")\n+            None => fail!(\"expected this to parse\")\n         }\n     }\n \n@@ -1487,15 +1487,15 @@ mod test {\n         let marked_once_ctxt =\n             match marked_once[0] {\n                 ast::tt_tok(_,token::IDENT(id,_)) => id.ctxt,\n-                _ => fail2!(format!(\"unexpected shape for marked tts: {:?}\",marked_once[0]))\n+                _ => fail!(format!(\"unexpected shape for marked tts: {:?}\",marked_once[0]))\n             };\n         assert_eq!(mtwt_marksof(marked_once_ctxt,invalid_name),~[fm]);\n         let remarked = mtwt_cancel_outer_mark(marked_once,marked_once_ctxt);\n         assert_eq!(remarked.len(),1);\n         match remarked[0] {\n             ast::tt_tok(_,token::IDENT(id,_)) =>\n             assert_eq!(mtwt_marksof(id.ctxt,invalid_name),~[]),\n-            _ => fail2!(format!(\"unexpected shape for marked tts: {:?}\",remarked[0]))\n+            _ => fail!(format!(\"unexpected shape for marked tts: {:?}\",remarked[0]))\n         }\n     }\n \n@@ -1700,7 +1700,7 @@ foo_module!()\n             bindings.iter().filter(|b|{@\"xx\" == (ident_to_str(*b))}).collect();\n         let cxbind = match cxbinds {\n             [b] => b,\n-            _ => fail2!(\"expected just one binding for ext_cx\")\n+            _ => fail!(\"expected just one binding for ext_cx\")\n         };\n         let resolved_binding = mtwt_resolve(*cxbind);\n         // find all the xx varrefs:"}, {"sha": "d10ec4229874b13eadc74e190f325db4e7a88ddd", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -255,8 +255,8 @@ pub mod rt {\n             match res {\n                 Some(ast) => ast,\n                 None => {\n-                    error2!(\"Parse error with ```\\n{}\\n```\", s);\n-                    fail2!()\n+                    error!(\"Parse error with ```\\n{}\\n```\", s);\n+                    fail!()\n                 }\n             }\n         }\n@@ -490,7 +490,7 @@ fn mk_token(cx: @ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n                                       ~[mk_ident(cx, sp, ident)]);\n         }\n \n-        INTERPOLATED(_) => fail2!(\"quote! with interpolated token\"),\n+        INTERPOLATED(_) => fail!(\"quote! with interpolated token\"),\n \n         _ => ()\n     }\n@@ -528,7 +528,7 @@ fn mk_token(cx: @ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n         DOLLAR => \"DOLLAR\",\n         UNDERSCORE => \"UNDERSCORE\",\n         EOF => \"EOF\",\n-        _ => fail2!()\n+        _ => fail!()\n     };\n     cx.expr_ident(sp, id_ext(name))\n }\n@@ -553,7 +553,7 @@ fn mk_tt(cx: @ExtCtxt, sp: Span, tt: &ast::token_tree)\n         }\n \n         ast::tt_delim(ref tts) => mk_tts(cx, sp, **tts),\n-        ast::tt_seq(*) => fail2!(\"tt_seq in quote!\"),\n+        ast::tt_seq(*) => fail!(\"tt_seq in quote!\"),\n \n         ast::tt_nonterminal(sp, ident) => {\n "}, {"sha": "50688afc56a5fe3ba3302bda13ae3e40cc07dda5", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -122,7 +122,7 @@ pub struct MatcherPos {\n pub fn copy_up(mpu: &matcher_pos_up) -> ~MatcherPos {\n     match *mpu {\n       matcher_pos_up(Some(ref mp)) => (*mp).clone(),\n-      _ => fail2!()\n+      _ => fail!()\n     }\n }\n \n@@ -387,7 +387,7 @@ pub fn parse(\n                         format!(\"{} ('{}')\", ident_to_str(name),\n                              ident_to_str(bind))\n                       }\n-                      _ => fail2!()\n+                      _ => fail!()\n                     } }).connect(\" or \");\n                 return error(sp, format!(\n                     \"Local ambiguity: multiple parsing options: \\\n@@ -412,7 +412,7 @@ pub fn parse(\n                         parse_nt(&rust_parser, ident_to_str(name))));\n                     ei.idx += 1u;\n                   }\n-                  _ => fail2!()\n+                  _ => fail!()\n                 }\n                 cur_eis.push(ei);\n "}, {"sha": "37bc00d5827b9f252cb9d7633398308a8763118e", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -891,7 +891,7 @@ mod test {\n                 let a_val = $a;\n                 let b_val = $b;\n                 if !(pred_val(a_val,b_val)) {\n-                    fail2!(\"expected args satisfying {}, got {:?} and {:?}\",\n+                    fail!(\"expected args satisfying {}, got {:?} and {:?}\",\n                           $predname, a_val, b_val);\n                 }\n             }"}, {"sha": "2000d0b97461f8b8f150a38cb6d02b8b566ff8de", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -66,7 +66,7 @@ impl<T> OptVec<T> {\n \n     pub fn get<'a>(&'a self, i: uint) -> &'a T {\n         match *self {\n-            Empty => fail2!(\"Invalid index {}\", i),\n+            Empty => fail!(\"Invalid index {}\", i),\n             Vec(ref v) => &v[i]\n         }\n     }"}, {"sha": "a8132860b9b4fe2e3eaf12bd0864dbfda3084682", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -32,7 +32,7 @@ impl parser_attr for Parser {\n     fn parse_outer_attributes(&self) -> ~[ast::Attribute] {\n         let mut attrs: ~[ast::Attribute] = ~[];\n         loop {\n-            debug2!(\"parse_outer_attributes: self.token={:?}\",\n+            debug!(\"parse_outer_attributes: self.token={:?}\",\n                    self.token);\n             match *self.token {\n               token::INTERPOLATED(token::nt_attr(*)) => {\n@@ -67,7 +67,7 @@ impl parser_attr for Parser {\n     // if permit_inner is true, then a trailing `;` indicates an inner\n     // attribute\n     fn parse_attribute(&self, permit_inner: bool) -> ast::Attribute {\n-        debug2!(\"parse_attributes: permit_inner={:?} self.token={:?}\",\n+        debug!(\"parse_attributes: permit_inner={:?} self.token={:?}\",\n                permit_inner, self.token);\n         let (span, value) = match *self.token {\n             INTERPOLATED(token::nt_attr(attr)) => {"}, {"sha": "38921648a2bc618e3f6194d19889a8f231ef4763", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -134,7 +134,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n         return lines.connect(\"\\n\");\n     }\n \n-    fail2!(\"not a doc-comment: {}\", comment);\n+    fail!(\"not a doc-comment: {}\", comment);\n }\n \n fn read_to_eol(rdr: @mut StringReader) -> ~str {\n@@ -161,7 +161,7 @@ fn consume_non_eol_whitespace(rdr: @mut StringReader) {\n }\n \n fn push_blank_line_comment(rdr: @mut StringReader, comments: &mut ~[cmnt]) {\n-    debug2!(\">>> blank-line comment\");\n+    debug!(\">>> blank-line comment\");\n     let v: ~[~str] = ~[];\n     comments.push(cmnt {style: blank_line, lines: v, pos: rdr.last_pos});\n }\n@@ -179,9 +179,9 @@ fn consume_whitespace_counting_blank_lines(rdr: @mut StringReader,\n \n fn read_shebang_comment(rdr: @mut StringReader, code_to_the_left: bool,\n                                             comments: &mut ~[cmnt]) {\n-    debug2!(\">>> shebang comment\");\n+    debug!(\">>> shebang comment\");\n     let p = rdr.last_pos;\n-    debug2!(\"<<< shebang comment\");\n+    debug!(\"<<< shebang comment\");\n     comments.push(cmnt {\n         style: if code_to_the_left { trailing } else { isolated },\n         lines: ~[read_one_line_comment(rdr)],\n@@ -191,19 +191,19 @@ fn read_shebang_comment(rdr: @mut StringReader, code_to_the_left: bool,\n \n fn read_line_comments(rdr: @mut StringReader, code_to_the_left: bool,\n                                           comments: &mut ~[cmnt]) {\n-    debug2!(\">>> line comments\");\n+    debug!(\">>> line comments\");\n     let p = rdr.last_pos;\n     let mut lines: ~[~str] = ~[];\n     while rdr.curr == '/' && nextch(rdr) == '/' {\n         let line = read_one_line_comment(rdr);\n-        debug2!(\"{}\", line);\n+        debug!(\"{}\", line);\n         if is_doc_comment(line) { // doc-comments are not put in comments\n             break;\n         }\n         lines.push(line);\n         consume_non_eol_whitespace(rdr);\n     }\n-    debug2!(\"<<< line comments\");\n+    debug!(\"<<< line comments\");\n     if !lines.is_empty() {\n         comments.push(cmnt {\n             style: if code_to_the_left { trailing } else { isolated },\n@@ -242,14 +242,14 @@ fn trim_whitespace_prefix_and_push_line(lines: &mut ~[~str],\n         }\n         None => s,\n     };\n-    debug2!(\"pushing line: {}\", s1);\n+    debug!(\"pushing line: {}\", s1);\n     lines.push(s1);\n }\n \n fn read_block_comment(rdr: @mut StringReader,\n                       code_to_the_left: bool,\n                       comments: &mut ~[cmnt]) {\n-    debug2!(\">>> block comment\");\n+    debug!(\">>> block comment\");\n     let p = rdr.last_pos;\n     let mut lines: ~[~str] = ~[];\n     let col: CharPos = rdr.col;\n@@ -275,7 +275,7 @@ fn read_block_comment(rdr: @mut StringReader,\n     } else {\n         let mut level: int = 1;\n         while level > 0 {\n-            debug2!(\"=== block comment level {}\", level);\n+            debug!(\"=== block comment level {}\", level);\n             if is_eof(rdr) {\n                 (rdr as @mut reader).fatal(~\"unterminated block comment\");\n             }\n@@ -311,7 +311,7 @@ fn read_block_comment(rdr: @mut StringReader,\n     if !is_eof(rdr) && rdr.curr != '\\n' && lines.len() == 1u {\n         style = mixed;\n     }\n-    debug2!(\"<<< block comment\");\n+    debug!(\"<<< block comment\");\n     comments.push(cmnt {style: style, lines: lines, pos: p});\n }\n \n@@ -324,15 +324,15 @@ fn peeking_at_comment(rdr: @mut StringReader) -> bool {\n fn consume_comment(rdr: @mut StringReader,\n                    code_to_the_left: bool,\n                    comments: &mut ~[cmnt]) {\n-    debug2!(\">>> consume comment\");\n+    debug!(\">>> consume comment\");\n     if rdr.curr == '/' && nextch(rdr) == '/' {\n         read_line_comments(rdr, code_to_the_left, comments);\n     } else if rdr.curr == '/' && nextch(rdr) == '*' {\n         read_block_comment(rdr, code_to_the_left, comments);\n     } else if rdr.curr == '#' && nextch(rdr) == '!' {\n         read_shebang_comment(rdr, code_to_the_left, comments);\n-    } else { fail2!(); }\n-    debug2!(\"<<< consume comment\");\n+    } else { fail!(); }\n+    debug!(\"<<< consume comment\");\n }\n \n #[deriving(Clone)]\n@@ -378,11 +378,11 @@ pub fn gather_comments_and_literals(span_diagnostic:\n         let TokenAndSpan {tok: tok, sp: sp} = rdr.peek();\n         if token::is_lit(&tok) {\n             do with_str_from(rdr, bstart) |s| {\n-                debug2!(\"tok lit: {}\", s);\n+                debug!(\"tok lit: {}\", s);\n                 literals.push(lit {lit: s.to_owned(), pos: sp.lo});\n             }\n         } else {\n-            debug2!(\"tok: {}\", token::to_str(get_ident_interner(), &tok));\n+            debug!(\"tok: {}\", token::to_str(get_ident_interner(), &tok));\n         }\n         first_read = false;\n     }"}, {"sha": "7ac999c46a40017e5f9a5efda8dea962b727f1dd", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -133,7 +133,7 @@ impl reader for TtReader {\n     fn is_eof(@mut self) -> bool { self.cur_tok == token::EOF }\n     fn next_token(@mut self) -> TokenAndSpan {\n         let r = tt_next_token(self);\n-        debug2!(\"TtReader: r={:?}\", r);\n+        debug!(\"TtReader: r={:?}\", r);\n         return r;\n     }\n     fn fatal(@mut self, m: ~str) -> ! {\n@@ -273,7 +273,7 @@ fn hex_digit_val(c: char) -> int {\n     if in_range(c, '0', '9') { return (c as int) - ('0' as int); }\n     if in_range(c, 'a', 'f') { return (c as int) - ('a' as int) + 10; }\n     if in_range(c, 'A', 'F') { return (c as int) - ('A' as int) + 10; }\n-    fail2!();\n+    fail!();\n }\n \n fn bin_digit_value(c: char) -> int { if c == '0' { return 0; } return 1; }\n@@ -576,7 +576,7 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n                                ~\"int literal is too large\")\n         };\n \n-        debug2!(\"lexing {} as an unsuffixed integer literal\", num_str);\n+        debug!(\"lexing {} as an unsuffixed integer literal\", num_str);\n         return token::LIT_INT_UNSUFFIXED(parsed as i64);\n     }\n }"}, {"sha": "c9405d72464bb46d659b76693e3bdcd46ca28089", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -417,18 +417,18 @@ mod test {\n                         _ => assert_eq!(\"wrong 4\",\"correct\")\n                     },\n                     _ => {\n-                        error2!(\"failing value 3: {:?}\",first_set);\n+                        error!(\"failing value 3: {:?}\",first_set);\n                         assert_eq!(\"wrong 3\",\"correct\")\n                     }\n                 },\n                 _ => {\n-                    error2!(\"failing value 2: {:?}\",delim_elts);\n+                    error!(\"failing value 2: {:?}\",delim_elts);\n                     assert_eq!(\"wrong\",\"correct\");\n                 }\n \n             },\n             _ => {\n-                error2!(\"failing value: {:?}\",tts);\n+                error!(\"failing value: {:?}\",tts);\n                 assert_eq!(\"wrong 1\",\"correct\");\n             }\n         }"}, {"sha": "ed6019e1a55ace0e28adc8babef81f4670b9e278", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -448,7 +448,7 @@ impl Parser {\n     // followed by some token from the set edible + inedible.  Recover\n     // from anticipated input errors, discarding erroneous characters.\n     pub fn commit_expr(&self, e: @Expr, edible: &[token::Token], inedible: &[token::Token]) {\n-        debug2!(\"commit_expr {:?}\", e);\n+        debug!(\"commit_expr {:?}\", e);\n         match e.node {\n             ExprPath(*) => {\n                 // might be unit-struct construction; check for recoverableinput error.\n@@ -468,7 +468,7 @@ impl Parser {\n     // followed by some token from the set edible + inedible.  Check\n     // for recoverable input errors, discarding erroneous characters.\n     pub fn commit_stmt(&self, s: @Stmt, edible: &[token::Token], inedible: &[token::Token]) {\n-        debug2!(\"commit_stmt {:?}\", s);\n+        debug!(\"commit_stmt {:?}\", s);\n         let _s = s; // unused, but future checks might want to inspect `s`.\n         if self.last_token.as_ref().map_default(false, |t| is_ident_or_path(*t)) {\n             let expected = vec::append(edible.to_owned(), inedible);\n@@ -933,13 +933,13 @@ impl Parser {\n             };\n \n             let hi = p.last_span.hi;\n-            debug2!(\"parse_trait_methods(): trait method signature ends in \\\n+            debug!(\"parse_trait_methods(): trait method signature ends in \\\n                     `{}`\",\n                    self.this_token_to_str());\n             match *p.token {\n               token::SEMI => {\n                 p.bump();\n-                debug2!(\"parse_trait_methods(): parsing required method\");\n+                debug!(\"parse_trait_methods(): parsing required method\");\n                 // NB: at the moment, visibility annotations on required\n                 // methods are ignored; this could change.\n                 if vis != ast::inherited {\n@@ -958,7 +958,7 @@ impl Parser {\n                 })\n               }\n               token::LBRACE => {\n-                debug2!(\"parse_trait_methods(): parsing provided method\");\n+                debug!(\"parse_trait_methods(): parsing provided method\");\n                 let (inner_attrs, body) =\n                     p.parse_inner_attrs_and_block();\n                 let attrs = vec::append(attrs, inner_attrs);\n@@ -1196,7 +1196,7 @@ impl Parser {\n             _ => 0\n         };\n \n-        debug2!(\"parser is_named_argument offset:{}\", offset);\n+        debug!(\"parser is_named_argument offset:{}\", offset);\n \n         if offset == 0 {\n             is_plain_ident_or_underscore(&*self.token)\n@@ -1212,7 +1212,7 @@ impl Parser {\n     pub fn parse_arg_general(&self, require_name: bool) -> arg {\n         let is_mutbl = self.eat_keyword(keywords::Mut);\n         let pat = if require_name || self.is_named_argument() {\n-            debug2!(\"parse_arg_general parse_pat (require_name:{:?})\",\n+            debug!(\"parse_arg_general parse_pat (require_name:{:?})\",\n                    require_name);\n             let pat = self.parse_pat();\n \n@@ -1223,7 +1223,7 @@ impl Parser {\n             self.expect(&token::COLON);\n             pat\n         } else {\n-            debug2!(\"parse_arg_general ident_to_pat\");\n+            debug!(\"parse_arg_general ident_to_pat\");\n             ast_util::ident_to_pat(ast::DUMMY_NODE_ID,\n                                    *self.last_span,\n                                    special_idents::invalid)\n@@ -2470,7 +2470,7 @@ impl Parser {\n                 // There may be other types of expressions that can\n                 // represent the callee in `for` and `do` expressions\n                 // but they aren't represented by tests\n-                debug2!(\"sugary call on {:?}\", e.node);\n+                debug!(\"sugary call on {:?}\", e.node);\n                 self.span_fatal(\n                     e.span,\n                     format!(\"`{}` must be followed by a block call\", keyword));\n@@ -3916,7 +3916,7 @@ impl Parser {\n                 attrs = attrs_remaining + attrs;\n                 first = false;\n             }\n-            debug2!(\"parse_mod_items: parse_item_or_view_item(attrs={:?})\",\n+            debug!(\"parse_mod_items: parse_item_or_view_item(attrs={:?})\",\n                    attrs);\n             match self.parse_item_or_view_item(attrs,\n                                                true /* macros allowed */) {\n@@ -4629,7 +4629,7 @@ impl Parser {\n \n         let first_ident = self.parse_ident();\n         let mut path = ~[first_ident];\n-        debug2!(\"parsed view_path: {}\", self.id_to_str(first_ident));\n+        debug!(\"parsed view_path: {}\", self.id_to_str(first_ident));\n         match *self.token {\n           token::EQ => {\n             // x = foo::bar\n@@ -4837,7 +4837,7 @@ impl Parser {\n                     break;\n                 }\n                 iovi_foreign_item(_) => {\n-                    fail2!();\n+                    fail!();\n                 }\n             }\n             attrs = self.parse_outer_attributes();\n@@ -4860,7 +4860,7 @@ impl Parser {\n                     items.push(item)\n                 }\n                 iovi_foreign_item(_) => {\n-                    fail2!();\n+                    fail!();\n                 }\n             }\n         }"}, {"sha": "27747d94b6614ac7d00fe6903ac63419bbc93ffa", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -219,8 +219,8 @@ pub fn to_str(input: @ident_interner, t: &Token) -> ~str {\n                       nt_block(*) => ~\"block\",\n                       nt_stmt(*) => ~\"statement\",\n                       nt_pat(*) => ~\"pattern\",\n-                      nt_attr(*) => fail2!(\"should have been handled\"),\n-                      nt_expr(*) => fail2!(\"should have been handled above\"),\n+                      nt_attr(*) => fail!(\"should have been handled\"),\n+                      nt_expr(*) => fail!(\"should have been handled above\"),\n                       nt_ty(*) => ~\"type\",\n                       nt_ident(*) => ~\"identifier\",\n                       nt_path(*) => ~\"path\",\n@@ -275,7 +275,7 @@ pub fn flip_delimiter(t: &token::Token) -> token::Token {\n       RPAREN => LPAREN,\n       RBRACE => LBRACE,\n       RBRACKET => LBRACKET,\n-      _ => fail2!()\n+      _ => fail!()\n     }\n }\n "}, {"sha": "871584003b51e4a8bca61512f5c801d0a0687c58", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -152,7 +152,7 @@ pub fn mk_printer(out: @io::Writer, linewidth: uint) -> @mut Printer {\n     // Yes 3, it makes the ring buffers big enough to never\n     // fall behind.\n     let n: uint = 3 * linewidth;\n-    debug2!(\"mk_printer {}\", linewidth);\n+    debug!(\"mk_printer {}\", linewidth);\n     let token: ~[token] = vec::from_elem(n, EOF);\n     let size: ~[int] = vec::from_elem(n, 0);\n     let scan_stack: ~[uint] = vec::from_elem(n, 0u);\n@@ -288,7 +288,7 @@ impl Printer {\n         self.token[self.right] = t;\n     }\n     pub fn pretty_print(&mut self, t: token) {\n-        debug2!(\"pp ~[{},{}]\", self.left, self.right);\n+        debug!(\"pp ~[{},{}]\", self.left, self.right);\n         match t {\n           EOF => {\n             if !self.scan_stack_empty {\n@@ -305,18 +305,18 @@ impl Printer {\n                 self.left = 0u;\n                 self.right = 0u;\n             } else { self.advance_right(); }\n-            debug2!(\"pp BEGIN({})/buffer ~[{},{}]\",\n+            debug!(\"pp BEGIN({})/buffer ~[{},{}]\",\n                    b.offset, self.left, self.right);\n             self.token[self.right] = t;\n             self.size[self.right] = -self.right_total;\n             self.scan_push(self.right);\n           }\n           END => {\n             if self.scan_stack_empty {\n-                debug2!(\"pp END/print ~[{},{}]\", self.left, self.right);\n+                debug!(\"pp END/print ~[{},{}]\", self.left, self.right);\n                 self.print(t, 0);\n             } else {\n-                debug2!(\"pp END/buffer ~[{},{}]\", self.left, self.right);\n+                debug!(\"pp END/buffer ~[{},{}]\", self.left, self.right);\n                 self.advance_right();\n                 self.token[self.right] = t;\n                 self.size[self.right] = -1;\n@@ -330,7 +330,7 @@ impl Printer {\n                 self.left = 0u;\n                 self.right = 0u;\n             } else { self.advance_right(); }\n-            debug2!(\"pp BREAK({})/buffer ~[{},{}]\",\n+            debug!(\"pp BREAK({})/buffer ~[{},{}]\",\n                    b.offset, self.left, self.right);\n             self.check_stack(0);\n             self.scan_push(self.right);\n@@ -340,11 +340,11 @@ impl Printer {\n           }\n           STRING(s, len) => {\n             if self.scan_stack_empty {\n-                debug2!(\"pp STRING('{}')/print ~[{},{}]\",\n+                debug!(\"pp STRING('{}')/print ~[{},{}]\",\n                        s, self.left, self.right);\n                 self.print(t, len);\n             } else {\n-                debug2!(\"pp STRING('{}')/buffer ~[{},{}]\",\n+                debug!(\"pp STRING('{}')/buffer ~[{},{}]\",\n                        s, self.left, self.right);\n                 self.advance_right();\n                 self.token[self.right] = t;\n@@ -356,14 +356,14 @@ impl Printer {\n         }\n     }\n     pub fn check_stream(&mut self) {\n-        debug2!(\"check_stream ~[{}, {}] with left_total={}, right_total={}\",\n+        debug!(\"check_stream ~[{}, {}] with left_total={}, right_total={}\",\n                self.left, self.right, self.left_total, self.right_total);\n         if self.right_total - self.left_total > self.space {\n-            debug2!(\"scan window is {}, longer than space on line ({})\",\n+            debug!(\"scan window is {}, longer than space on line ({})\",\n                    self.right_total - self.left_total, self.space);\n             if !self.scan_stack_empty {\n                 if self.left == self.scan_stack[self.bottom] {\n-                    debug2!(\"setting {} to infinity and popping\", self.left);\n+                    debug!(\"setting {} to infinity and popping\", self.left);\n                     self.size[self.scan_pop_bottom()] = size_infinity;\n                 }\n             }\n@@ -372,7 +372,7 @@ impl Printer {\n         }\n     }\n     pub fn scan_push(&mut self, x: uint) {\n-        debug2!(\"scan_push {}\", x);\n+        debug!(\"scan_push {}\", x);\n         if self.scan_stack_empty {\n             self.scan_stack_empty = false;\n         } else {\n@@ -408,7 +408,7 @@ impl Printer {\n         assert!((self.right != self.left));\n     }\n     pub fn advance_left(&mut self, x: token, L: int) {\n-        debug2!(\"advnce_left ~[{},{}], sizeof({})={}\", self.left, self.right,\n+        debug!(\"advnce_left ~[{},{}], sizeof({})={}\", self.left, self.right,\n                self.left, L);\n         if L >= 0 {\n             self.print(x, L);\n@@ -451,13 +451,13 @@ impl Printer {\n         }\n     }\n     pub fn print_newline(&mut self, amount: int) {\n-        debug2!(\"NEWLINE {}\", amount);\n+        debug!(\"NEWLINE {}\", amount);\n         (*self.out).write_str(\"\\n\");\n         self.pending_indentation = 0;\n         self.indent(amount);\n     }\n     pub fn indent(&mut self, amount: int) {\n-        debug2!(\"INDENT {}\", amount);\n+        debug!(\"INDENT {}\", amount);\n         self.pending_indentation += amount;\n     }\n     pub fn get_top(&mut self) -> print_stack_elt {\n@@ -480,9 +480,9 @@ impl Printer {\n         (*self.out).write_str(s);\n     }\n     pub fn print(&mut self, x: token, L: int) {\n-        debug2!(\"print {} {} (remaining line space={})\", tok_str(x), L,\n+        debug!(\"print {} {} (remaining line space={})\", tok_str(x), L,\n                self.space);\n-        debug2!(\"{}\", buf_str(self.token.clone(),\n+        debug!(\"{}\", buf_str(self.token.clone(),\n                              self.size.clone(),\n                              self.left,\n                              self.right,\n@@ -491,21 +491,21 @@ impl Printer {\n           BEGIN(b) => {\n             if L > self.space {\n                 let col = self.margin - self.space + b.offset;\n-                debug2!(\"print BEGIN -> push broken block at col {}\", col);\n+                debug!(\"print BEGIN -> push broken block at col {}\", col);\n                 self.print_stack.push(print_stack_elt {\n                     offset: col,\n                     pbreak: broken(b.breaks)\n                 });\n             } else {\n-                debug2!(\"print BEGIN -> push fitting block\");\n+                debug!(\"print BEGIN -> push fitting block\");\n                 self.print_stack.push(print_stack_elt {\n                     offset: 0,\n                     pbreak: fits\n                 });\n             }\n           }\n           END => {\n-            debug2!(\"print END -> pop END\");\n+            debug!(\"print END -> pop END\");\n             let print_stack = &mut *self.print_stack;\n             assert!((print_stack.len() != 0u));\n             print_stack.pop();\n@@ -514,24 +514,24 @@ impl Printer {\n             let top = self.get_top();\n             match top.pbreak {\n               fits => {\n-                debug2!(\"print BREAK({}) in fitting block\", b.blank_space);\n+                debug!(\"print BREAK({}) in fitting block\", b.blank_space);\n                 self.space -= b.blank_space;\n                 self.indent(b.blank_space);\n               }\n               broken(consistent) => {\n-                debug2!(\"print BREAK({}+{}) in consistent block\",\n+                debug!(\"print BREAK({}+{}) in consistent block\",\n                        top.offset, b.offset);\n                 self.print_newline(top.offset + b.offset);\n                 self.space = self.margin - (top.offset + b.offset);\n               }\n               broken(inconsistent) => {\n                 if L > self.space {\n-                    debug2!(\"print BREAK({}+{}) w/ newline in inconsistent\",\n+                    debug!(\"print BREAK({}+{}) w/ newline in inconsistent\",\n                            top.offset, b.offset);\n                     self.print_newline(top.offset + b.offset);\n                     self.space = self.margin - (top.offset + b.offset);\n                 } else {\n-                    debug2!(\"print BREAK({}) w/o newline in inconsistent\",\n+                    debug!(\"print BREAK({}) w/o newline in inconsistent\",\n                            b.blank_space);\n                     self.indent(b.blank_space);\n                     self.space -= b.blank_space;\n@@ -540,15 +540,15 @@ impl Printer {\n             }\n           }\n           STRING(s, len) => {\n-            debug2!(\"print STRING({})\", s);\n+            debug!(\"print STRING({})\", s);\n             assert_eq!(L, len);\n             // assert!(L <= space);\n             self.space -= len;\n             self.print_str(s);\n           }\n           EOF => {\n             // EOF should never get here.\n-            fail2!();\n+            fail!();\n           }\n         }\n     }"}, {"sha": "b245bd75ace7286a33be1035eef0480136f33468", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -453,10 +453,10 @@ pub fn print_type(s: @ps, ty: &ast::Ty) {\n           word(s.s, \")\");\n       }\n       ast::ty_mac(_) => {\n-          fail2!(\"print_type doesn't know how to print a ty_mac\");\n+          fail!(\"print_type doesn't know how to print a ty_mac\");\n       }\n       ast::ty_infer => {\n-          fail2!(\"print_type shouldn't see a ty_infer\");\n+          fail!(\"print_type shouldn't see a ty_infer\");\n       }\n \n     }\n@@ -701,7 +701,7 @@ pub fn print_struct(s: @ps,\n             popen(s);\n             do commasep(s, inconsistent, struct_def.fields) |s, field| {\n                 match field.node.kind {\n-                    ast::named_field(*) => fail2!(\"unexpected named field\"),\n+                    ast::named_field(*) => fail!(\"unexpected named field\"),\n                     ast::unnamed_field => {\n                         maybe_print_comment(s, field.span.lo);\n                         print_type(s, &field.node.ty);\n@@ -720,7 +720,7 @@ pub fn print_struct(s: @ps,\n \n         for field in struct_def.fields.iter() {\n             match field.node.kind {\n-                ast::unnamed_field => fail2!(\"unexpected unnamed field\"),\n+                ast::unnamed_field => fail!(\"unexpected unnamed field\"),\n                 ast::named_field(ident, visibility) => {\n                     hardbreak_if_not_bol(s);\n                     maybe_print_comment(s, field.span.lo);\n@@ -1009,7 +1009,7 @@ pub fn print_if(s: @ps, test: &ast::Expr, blk: &ast::Block,\n               }\n               // BLEAH, constraints would be great here\n               _ => {\n-                  fail2!(\"print_if saw if with weird alternative\");\n+                  fail!(\"print_if saw if with weird alternative\");\n               }\n             }\n           }\n@@ -1311,7 +1311,7 @@ pub fn print_expr(s: @ps, expr: &ast::Expr) {\n                         }\n                         end(s); // close enclosing cbox\n                     }\n-                    None => fail2!()\n+                    None => fail!()\n                 }\n             } else {\n                 // the block will close the pattern's ibox\n@@ -2304,7 +2304,7 @@ mod test {\n \n     fn string_check<T:Eq> (given : &T, expected: &T) {\n         if !(given == expected) {\n-            fail2!(\"given {:?}, expected {:?}\", given, expected);\n+            fail!(\"given {:?}, expected {:?}\", given, expected);\n         }\n     }\n "}, {"sha": "98e5c8c2b5bbd59316a209d5c1e41673bbe95388", "filename": "src/test/auxiliary/cci_class_4.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -21,19 +21,19 @@ pub mod kitties {\n \n         pub fn eat(&mut self) -> bool {\n             if self.how_hungry > 0 {\n-                error2!(\"OM NOM NOM\");\n+                error!(\"OM NOM NOM\");\n                 self.how_hungry -= 2;\n                 return true;\n             } else {\n-                error2!(\"Not hungry!\");\n+                error!(\"Not hungry!\");\n                 return false;\n             }\n         }\n     }\n \n     impl cat {\n         pub fn meow(&mut self) {\n-            error2!(\"Meow\");\n+            error!(\"Meow\");\n             self.meows += 1u;\n             if self.meows % 5u == 0u {\n                 self.how_hungry += 1;"}, {"sha": "8fac4a3f322af16db2df251e6a93ba677bf52bb9", "filename": "src/test/auxiliary/cci_class_cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -21,7 +21,7 @@ pub mod kitty {\n \n     impl cat {\n         fn meow(&mut self) {\n-            error2!(\"Meow\");\n+            error!(\"Meow\");\n             self.meows += 1u;\n             if self.meows % 5u == 0u {\n                 self.how_hungry += 1;\n@@ -35,12 +35,12 @@ pub mod kitty {\n \n         pub fn eat(&mut self) -> bool {\n             if self.how_hungry > 0 {\n-                error2!(\"OM NOM NOM\");\n+                error!(\"OM NOM NOM\");\n                 self.how_hungry -= 2;\n                 return true;\n             }\n             else {\n-                error2!(\"Not hungry!\");\n+                error!(\"Not hungry!\");\n                 return false;\n             }\n         }"}, {"sha": "350bd09826fad67c7d66950fd6ee060e63a8289c", "filename": "src/test/auxiliary/cci_nested_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -33,7 +33,7 @@ pub fn alist_get<A:Clone + 'static,\n             return entry.value.clone();\n         }\n     }\n-    fail2!();\n+    fail!();\n }\n \n #[inline]"}, {"sha": "0f762039746f78cd178ae0bbd546a2a4a11c0cb6", "filename": "src/test/auxiliary/extern-crosscrate-source.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -28,7 +28,7 @@ pub mod rustrt {\n #[fixed_stack_segment] #[inline(never)]\n pub fn fact(n: uint) -> uint {\n     unsafe {\n-        info2!(\"n = {}\", n);\n+        info!(\"n = {}\", n);\n         rustrt::rust_dbg_call(cb, n)\n     }\n }"}, {"sha": "ea14229cc48a7520683d3871a3652581f86776ae", "filename": "src/test/auxiliary/issue2378a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fauxiliary%2Fissue2378a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fauxiliary%2Fissue2378a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue2378a.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -17,7 +17,7 @@ impl <T:Clone> Index<uint,T> for maybe<T> {\n     fn index(&self, _idx: &uint) -> T {\n         match self {\n             &just(ref t) => (*t).clone(),\n-            &nothing => { fail2!(); }\n+            &nothing => { fail!(); }\n         }\n     }\n }"}, {"sha": "b3fa8e73cc22292fc9349262d887613eacd446ce", "filename": "src/test/auxiliary/issue_2723_a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fauxiliary%2Fissue_2723_a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fauxiliary%2Fissue_2723_a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_2723_a.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n pub unsafe fn f(xs: ~[int]) {\n-    xs.map(|_x| { unsafe fn q() { fail2!(); } });\n+    xs.map(|_x| { unsafe fn q() { fail!(); } });\n }"}, {"sha": "4fc7de9f7d2f5556cee26d9495fbc73fbf972388", "filename": "src/test/auxiliary/logging_right_crate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fauxiliary%2Flogging_right_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fauxiliary%2Flogging_right_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flogging_right_crate.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n pub fn foo<T>() {\n-    fn death() -> int { fail2!() }\n-    debug2!(\"{:?}\", (||{ death() })());\n+    fn death() -> int { fail!() }\n+    debug!(\"{:?}\", (||{ death() })());\n }"}, {"sha": "6978b9209d8bcc97db065ecb7acb31d15b839480", "filename": "src/test/auxiliary/static-methods-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -38,6 +38,6 @@ impl read for bool {\n pub fn read<T:read>(s: ~str) -> T {\n     match read::readMaybe(s) {\n       Some(x) => x,\n-      _ => fail2!(\"read failed!\")\n+      _ => fail!(\"read failed!\")\n     }\n }"}, {"sha": "f549f747ef7971634d2401166f6fbab2fc360a8d", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -138,7 +138,7 @@ fn is_utf8_ascii() {\n     for _ in range(0u, 20000) {\n         v.push('b' as u8);\n         if !str::is_utf8(v) {\n-            fail2!(\"is_utf8 failed\");\n+            fail!(\"is_utf8 failed\");\n         }\n     }\n }\n@@ -149,7 +149,7 @@ fn is_utf8_multibyte() {\n     for _ in range(0u, 5000) {\n         v.push_all(s.as_bytes());\n         if !str::is_utf8(v) {\n-            fail2!(\"is_utf8 failed\");\n+            fail!(\"is_utf8 failed\");\n         }\n     }\n }"}, {"sha": "aec0bfb1e657cc7e17f13085c520a38f97eb1327", "filename": "src/test/bench/core-uint-to-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -25,6 +25,6 @@ fn main() {\n \n     for i in range(0u, n) {\n         let x = i.to_str();\n-        info2!(\"{}\", x);\n+        info!(\"{}\", x);\n     }\n }"}, {"sha": "97479fc133a67b5aade23eeef2ee9285a85acc7b", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -42,15 +42,15 @@ fn server(requests: &Port<request>, responses: &Chan<uint>) {\n         match requests.try_recv() {\n           Some(get_count) => { responses.send(count.clone()); }\n           Some(bytes(b)) => {\n-            //error2!(\"server: received {:?} bytes\", b);\n+            //error!(\"server: received {:?} bytes\", b);\n             count += b;\n           }\n           None => { done = true; }\n           _ => { }\n         }\n     }\n     responses.send(count);\n-    //error2!(\"server exiting\");\n+    //error!(\"server exiting\");\n }\n \n fn run(args: &[~str]) {\n@@ -70,10 +70,10 @@ fn run(args: &[~str]) {\n         worker_results.push(builder.future_result());\n         do builder.spawn {\n             for _ in range(0u, size / workers) {\n-                //error2!(\"worker {:?}: sending {:?} bytes\", i, num_bytes);\n+                //error!(\"worker {:?}: sending {:?} bytes\", i, num_bytes);\n                 to_child.send(bytes(num_bytes));\n             }\n-            //error2!(\"worker {:?} exiting\", i);\n+            //error!(\"worker {:?} exiting\", i);\n         }\n     }\n     do task::spawn || {\n@@ -84,7 +84,7 @@ fn run(args: &[~str]) {\n         r.recv();\n     }\n \n-    //error2!(\"sending stop message\");\n+    //error!(\"sending stop message\");\n     to_child.send(stop);\n     move_out(to_child);\n     let result = from_child.recv();\n@@ -107,6 +107,6 @@ fn main() {\n         args.clone()\n     };\n \n-    info2!(\"{:?}\", args);\n+    info!(\"{:?}\", args);\n     run(args);\n }"}, {"sha": "584a8b8befcc6e59100cb2da794a23974f90c3bd", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -37,15 +37,15 @@ fn server(requests: &Port<request>, responses: &Chan<uint>) {\n         match requests.try_recv() {\n           Some(get_count) => { responses.send(count.clone()); }\n           Some(bytes(b)) => {\n-            //error2!(\"server: received {:?} bytes\", b);\n+            //error!(\"server: received {:?} bytes\", b);\n             count += b;\n           }\n           None => { done = true; }\n           _ => { }\n         }\n     }\n     responses.send(count);\n-    //error2!(\"server exiting\");\n+    //error!(\"server exiting\");\n }\n \n fn run(args: &[~str]) {\n@@ -64,10 +64,10 @@ fn run(args: &[~str]) {\n         worker_results.push(builder.future_result());\n         do builder.spawn {\n             for _ in range(0u, size / workers) {\n-                //error2!(\"worker {:?}: sending {:?} bytes\", i, num_bytes);\n+                //error!(\"worker {:?}: sending {:?} bytes\", i, num_bytes);\n                 to_child.send(bytes(num_bytes));\n             }\n-            //error2!(\"worker {:?} exiting\", i);\n+            //error!(\"worker {:?} exiting\", i);\n         };\n     }\n     do task::spawn || {\n@@ -78,7 +78,7 @@ fn run(args: &[~str]) {\n         r.recv();\n     }\n \n-    //error2!(\"sending stop message\");\n+    //error!(\"sending stop message\");\n     to_child.send(stop);\n     move_out(to_child);\n     let result = from_child.recv();\n@@ -101,6 +101,6 @@ fn main() {\n         args.clone()\n     };\n \n-    info2!(\"{:?}\", args);\n+    info!(\"{:?}\", args);\n     run(args);\n }"}, {"sha": "96e87788b70d8be2ccc064f44dcc4fad5a976ccc", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -66,7 +66,7 @@ fn show_digit(nn: uint) -> ~str {\n         7 => {~\"seven\"}\n         8 => {~\"eight\"}\n         9 => {~\"nine\"}\n-        _ => {fail2!(\"expected digits from 0 to 9...\")}\n+        _ => {fail!(\"expected digits from 0 to 9...\")}\n     }\n }\n "}, {"sha": "88b3cfdff42986b22e8ade806af9daff4e4d3dee", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -66,7 +66,7 @@ fn parse_opts(argv: ~[~str]) -> Config {\n       Ok(ref m) => {\n           return Config {stress: m.opt_present(\"stress\")}\n       }\n-      Err(_) => { fail2!(); }\n+      Err(_) => { fail!(); }\n     }\n }\n \n@@ -76,7 +76,7 @@ fn stress_task(id: int) {\n         let n = 15;\n         assert_eq!(fib(n), fib(n));\n         i += 1;\n-        error2!(\"{}: Completed {} iterations\", id, i);\n+        error!(\"{}: Completed {} iterations\", id, i);\n     }\n }\n "}, {"sha": "5e0968163064134ae6e2f525d93e261356bcee31", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -44,7 +44,7 @@ fn roundtrip(id: int, n_tasks: int, p: &Port<int>, ch: &Chan<int>) {\n             return;\n           }\n           token => {\n-            info2!(\"thread: {}   got token: {}\", id, token);\n+            info!(\"thread: {}   got token: {}\", id, token);\n             ch.send(token - 1);\n             if token <= n_tasks {\n                 return;"}, {"sha": "a4e32b4c074a6eb72dc238a8cd00d2f0f786beca", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -79,7 +79,7 @@ impl Sudoku {\n                 g[row][col] = from_str::<uint>(comps[2]).unwrap() as u8;\n             }\n             else {\n-                fail2!(\"Invalid sudoku file\");\n+                fail!(\"Invalid sudoku file\");\n             }\n         }\n         return Sudoku::new(g)\n@@ -117,7 +117,7 @@ impl Sudoku {\n                 ptr = ptr + 1u;\n             } else {\n                 // no: redo this field aft recoloring pred; unless there is none\n-                if ptr == 0u { fail2!(\"No solution found for this sudoku\"); }\n+                if ptr == 0u { fail!(\"No solution found for this sudoku\"); }\n                 ptr = ptr - 1u;\n             }\n         }"}, {"sha": "7ee0c3e13ce9d0b7c7b37350e50ec55f9f205493", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -31,11 +31,11 @@ fn main() {\n \n fn run(repeat: int, depth: int) {\n     for _ in range(0, repeat) {\n-        info2!(\"starting {:.4f}\", precise_time_s());\n+        info!(\"starting {:.4f}\", precise_time_s());\n         do task::try {\n             recurse_or_fail(depth, None)\n         };\n-        info2!(\"stopping {:.4f}\", precise_time_s());\n+        info!(\"stopping {:.4f}\", precise_time_s());\n     }\n }\n \n@@ -68,8 +68,8 @@ fn r(l: @nillist) -> r {\n \n fn recurse_or_fail(depth: int, st: Option<State>) {\n     if depth == 0 {\n-        info2!(\"unwinding {:.4f}\", precise_time_s());\n-        fail2!();\n+        info!(\"unwinding {:.4f}\", precise_time_s());\n+        fail!();\n     } else {\n         let depth = depth - 1;\n "}, {"sha": "0827f7d34475b28aa683582dcdb335c7ab76e1d8", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -54,6 +54,6 @@ fn main() {\n     let (p,c) = comm::stream();\n     child_generation(from_str::<uint>(args[1]).unwrap(), c);\n     if p.try_recv().is_none() {\n-        fail2!(\"it happened when we slumbered\");\n+        fail!(\"it happened when we slumbered\");\n     }\n }"}, {"sha": "5484a3965b3a895ec63edeee0e389441a3b08d15", "filename": "src/test/bench/task-perf-linked-failure.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -43,13 +43,13 @@ fn grandchild_group(num_tasks: uint) {\n             p.recv(); // block forever\n         }\n     }\n-    error2!(\"Grandchild group getting started\");\n+    error!(\"Grandchild group getting started\");\n     for _ in range(0, num_tasks) {\n         // Make sure all above children are fully spawned; i.e., enlisted in\n         // their ancestor groups.\n         po.recv();\n     }\n-    error2!(\"Grandchild group ready to go.\");\n+    error!(\"Grandchild group ready to go.\");\n     // Master grandchild task exits early.\n }\n \n@@ -58,7 +58,7 @@ fn spawn_supervised_blocking(myname: &str, f: ~fn()) {\n     let res = builder.future_result();\n     builder.supervised();\n     builder.spawn(f);\n-    error2!(\"{} group waiting\", myname);\n+    error!(\"{} group waiting\", myname);\n     let x = res.recv();\n     assert_eq!(x, task::Success);\n }\n@@ -84,11 +84,11 @@ fn main() {\n                 grandchild_group(num_tasks);\n             }\n             // When grandchild group is ready to go, make the middle group exit.\n-            error2!(\"Middle group wakes up and exits\");\n+            error!(\"Middle group wakes up and exits\");\n         }\n         // Grandparent group waits for middle group to be gone, then fails\n-        error2!(\"Grandparent group wakes up and fails\");\n-        fail2!();\n+        error!(\"Grandparent group wakes up and fails\");\n+        fail!();\n     };\n     assert!(x.is_err());\n }"}, {"sha": "4e934d988019b45709b2d1d5924393857adbb09c", "filename": "src/test/compile-fail/asm-in-bad-modifier.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fasm-in-bad-modifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fasm-in-bad-modifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fasm-in-bad-modifier.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -11,7 +11,7 @@\n // xfail-fast #[feature] doesn't work with check-fast\n #[feature(asm)];\n \n-fn foo(x: int) { info2!(\"{}\", x); }\n+fn foo(x: int) { info!(\"{}\", x); }\n \n #[cfg(target_arch = \"x86\")]\n #[cfg(target_arch = \"x86_64\")]"}, {"sha": "599ab76e61ce9c5cc79a4a6628ba29d7db2a911e", "filename": "src/test/compile-fail/asm-out-assign-imm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fasm-out-assign-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fasm-out-assign-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fasm-out-assign-imm.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -11,7 +11,7 @@\n // xfail-fast #[feature] doesn't work with check-fast\n #[feature(asm)];\n \n-fn foo(x: int) { info2!(\"{}\", x); }\n+fn foo(x: int) { info!(\"{}\", x); }\n \n #[cfg(target_arch = \"x86\")]\n #[cfg(target_arch = \"x86_64\")]"}, {"sha": "b520c27c80ed013648440a7085f5da3c82b0e232", "filename": "src/test/compile-fail/asm-out-no-modifier.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fasm-out-no-modifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fasm-out-no-modifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fasm-out-no-modifier.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -11,7 +11,7 @@\n // xfail-fast #[feature] doesn't work with check-fast\n #[feature(asm)];\n \n-fn foo(x: int) { info2!(\"{}\", x); }\n+fn foo(x: int) { info!(\"{}\", x); }\n \n #[cfg(target_arch = \"x86\")]\n #[cfg(target_arch = \"x86_64\")]"}, {"sha": "f49624295b1debde02e0cfd6ab11337fd06b81b0", "filename": "src/test/compile-fail/asm-out-read-uninit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fasm-out-read-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fasm-out-read-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fasm-out-read-uninit.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -11,7 +11,7 @@\n // xfail-fast #[feature] doesn't work with check-fast\n #[feature(asm)];\n \n-fn foo(x: int) { info2!(\"{}\", x); }\n+fn foo(x: int) { info!(\"{}\", x); }\n \n #[cfg(target_arch = \"x86\")]\n #[cfg(target_arch = \"x86_64\")]"}, {"sha": "e11b47a1b582c527725ce4ea0b9d05870eac96af", "filename": "src/test/compile-fail/assign-imm-local-twice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fassign-imm-local-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fassign-imm-local-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassign-imm-local-twice.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -11,9 +11,9 @@\n fn test() {\n     let v: int;\n     v = 1; //~ NOTE prior assignment occurs here\n-    info2!(\"v={}\", v);\n+    info!(\"v={}\", v);\n     v = 2; //~ ERROR re-assignment of immutable variable\n-    info2!(\"v={}\", v);\n+    info!(\"v={}\", v);\n }\n \n fn main() {"}, {"sha": "f300bd51b24eca1582df34ca467bfdaf8e6e1242", "filename": "src/test/compile-fail/assign-to-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fassign-to-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fassign-to-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassign-to-method.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -27,5 +27,5 @@ fn cat(in_x : uint, in_y : int) -> cat {\n \n fn main() {\n   let nyan : cat = cat(52u, 99);\n-  nyan.speak = || info2!(\"meow\"); //~ ERROR attempted to take value of method\n+  nyan.speak = || info!(\"meow\"); //~ ERROR attempted to take value of method\n }"}, {"sha": "b8af09e308b487eb2214d56abd83a29bf8d0905b", "filename": "src/test/compile-fail/autoderef-full-lval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -21,11 +21,11 @@ fn main() {\n     let a: clam = clam{x: @1, y: @2};\n     let b: clam = clam{x: @10, y: @20};\n     let z: int = a.x + b.y; //~ ERROR binary operation + cannot be applied to type `@int`\n-    info2!(\"{:?}\", z);\n+    info!(\"{:?}\", z);\n     assert_eq!(z, 21);\n     let forty: fish = fish{a: @40};\n     let two: fish = fish{a: @2};\n     let answer: int = forty.a + two.a;  //~ ERROR binary operation + cannot be applied to type `@int`\n-    info2!(\"{:?}\", answer);\n+    info!(\"{:?}\", answer);\n     assert_eq!(answer, 42);\n }"}, {"sha": "2ffb5dd29066f37f712f0c54823627e19a2dd4a9", "filename": "src/test/compile-fail/bad-bang-ann.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -12,7 +12,7 @@\n // Tests that a function with a ! annotation always actually fails\n \n fn bad_bang(i: uint) -> ! {\n-    if i < 0u { } else { fail2!(); }\n+    if i < 0u { } else { fail!(); }\n     //~^ ERROR expected `!` but found `()`\n }\n "}, {"sha": "08ced2b002da614816579b5776e2e563077fd55d", "filename": "src/test/compile-fail/bad-const-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fbad-const-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fbad-const-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-const-type.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -11,4 +11,4 @@\n // error-pattern:expected `~str` but found `int`\n \n static i: ~str = 10i;\n-fn main() { info2!(\"{:?}\", i); }\n+fn main() { info!(\"{:?}\", i); }"}, {"sha": "3d1cca46085dbf06f8d9f95a890360b85d309391", "filename": "src/test/compile-fail/bind-by-move-neither-can-live-while-the-other-survives-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-1.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -12,14 +12,14 @@ struct X { x: () }\n \n impl Drop for X {\n     fn drop(&mut self) {\n-        error2!(\"destructor runs\");\n+        error!(\"destructor runs\");\n     }\n }\n \n fn main() {\n     let x = Some(X { x: () });\n     match x {\n         Some(ref _y @ _z) => { }, //~ ERROR cannot bind by-move and by-ref in the same pattern\n-        None => fail2!()\n+        None => fail!()\n     }\n }"}, {"sha": "a1803a621a53fc2996f4ddea13508ddcc58a5d0d", "filename": "src/test/compile-fail/bind-by-move-neither-can-live-while-the-other-survives-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-2.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -12,14 +12,14 @@ struct X { x: (), }\n \n impl Drop for X {\n     fn drop(&mut self) {\n-        error2!(\"destructor runs\");\n+        error!(\"destructor runs\");\n     }\n }\n \n fn main() {\n     let x = Some((X { x: () }, X { x: () }));\n     match x {\n         Some((ref _y, _z)) => { }, //~ ERROR cannot bind by-move and by-ref in the same pattern\n-        None => fail2!()\n+        None => fail!()\n     }\n }"}, {"sha": "34a9c0b8fc26d01fdcdbcc6ead782b013377ef62", "filename": "src/test/compile-fail/bind-by-move-neither-can-live-while-the-other-survives-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-3.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -12,7 +12,7 @@ struct X { x: (), }\n \n impl Drop for X {\n     fn drop(&mut self) {\n-        error2!(\"destructor runs\");\n+        error!(\"destructor runs\");\n     }\n }\n \n@@ -22,6 +22,6 @@ fn main() {\n     let x = some2(X { x: () }, X { x: () });\n     match x {\n         some2(ref _y, _z) => { }, //~ ERROR cannot bind by-move and by-ref in the same pattern\n-        none2 => fail2!()\n+        none2 => fail!()\n     }\n }"}, {"sha": "2aa3379993b7abaf195f247baa57c9707d592a04", "filename": "src/test/compile-fail/bind-by-move-neither-can-live-while-the-other-survives-4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-4.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -12,14 +12,14 @@ struct X { x: (), }\n \n impl Drop for X {\n     fn drop(&mut self) {\n-        error2!(\"destructor runs\");\n+        error!(\"destructor runs\");\n     }\n }\n \n fn main() {\n     let x = Some((X { x: () }, X { x: () }));\n     match x {\n         Some((_y, ref _z)) => { }, //~ ERROR cannot bind by-move and by-ref in the same pattern\n-        None => fail2!()\n+        None => fail!()\n     }\n }"}, {"sha": "348781d74977e79710b52ee6563fd2d088f4f233", "filename": "src/test/compile-fail/bind-by-move-no-guards.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -15,8 +15,8 @@ fn main() {\n     let x = Some(p);\n     c.send(false);\n     match x {\n-        Some(z) if z.recv() => { fail2!() }, //~ ERROR cannot bind by-move into a pattern guard\n+        Some(z) if z.recv() => { fail!() }, //~ ERROR cannot bind by-move into a pattern guard\n         Some(z) => { assert!(!z.recv()); },\n-        None => fail2!()\n+        None => fail!()\n     }\n }"}, {"sha": "7143ce0252b733c4b5683f3d2453fe753d16a317", "filename": "src/test/compile-fail/bind-by-move-no-sub-bindings.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-sub-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-sub-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-sub-bindings.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -12,14 +12,14 @@ struct X { x: (), }\n \n impl Drop for X {\n     fn drop(&mut self) {\n-        error2!(\"destructor runs\");\n+        error!(\"destructor runs\");\n     }\n }\n \n fn main() {\n     let x = Some(X { x: () });\n     match x {\n         Some(_y @ ref _z) => { }, //~ ERROR cannot bind by-move with sub-bindings\n-        None => fail2!()\n+        None => fail!()\n     }\n }"}, {"sha": "7637ebdc80dcc5422b5a2d7cded9b6c5f3ef6ff7", "filename": "src/test/compile-fail/block-arg-as-stmt-with-value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -17,6 +17,6 @@ fn compute1() -> f64 {\n \n fn main() {\n     let x = compute1();\n-    info2!(\"{:?}\", x);\n+    info!(\"{:?}\", x);\n     assert_eq!(x, -4f64);\n }"}, {"sha": "71afba18bb1ff46f197b5ebdf00ae44ce9cd91a1", "filename": "src/test/compile-fail/block-coerce-no.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -21,6 +21,6 @@ fn coerce(b: &fn()) -> extern fn() {\n \n fn main() {\n     let i = 8;\n-    let f = coerce(|| error2!(\"{:?}\", i) );\n+    let f = coerce(|| error!(\"{:?}\", i) );\n     f();\n }"}, {"sha": "63d12b72cc6353c1fcd8e2d4a404751d0bb12d36", "filename": "src/test/compile-fail/bogus-tag.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fbogus-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fbogus-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbogus-tag.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -17,7 +17,7 @@ enum color { rgb(int, int, int), rgba(int, int, int, int), }\n fn main() {\n     let red: color = rgb(255, 0, 0);\n     match red {\n-      rgb(r, g, b) => { info2!(\"rgb\"); }\n-      hsl(h, s, l) => { info2!(\"hsl\"); }\n+      rgb(r, g, b) => { info!(\"rgb\"); }\n+      hsl(h, s, l) => { info!(\"hsl\"); }\n     }\n }"}, {"sha": "da0a9323d2c8178da4b8cff2cf4db54e790596c8", "filename": "src/test/compile-fail/borrowck-anon-fields-variant.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-anon-fields-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-anon-fields-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-anon-fields-variant.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -10,12 +10,12 @@ fn distinct_variant() {\n \n     let a = match y {\n       Y(ref mut a, _) => a,\n-      X => fail2!()\n+      X => fail!()\n     };\n \n     let b = match y {\n       Y(_, ref mut b) => b,\n-      X => fail2!()\n+      X => fail!()\n     };\n \n     *a += 1;\n@@ -27,12 +27,12 @@ fn same_variant() {\n \n     let a = match y {\n       Y(ref mut a, _) => a,\n-      X => fail2!()\n+      X => fail!()\n     };\n \n     let b = match y {\n       Y(ref mut b, _) => b, //~ ERROR cannot borrow\n-      X => fail2!()\n+      X => fail!()\n     };\n \n     *a += 1;"}, {"sha": "81e16b6b615ed715544cb2909f057fc0ea740ca9", "filename": "src/test/compile-fail/borrowck-assign-comp-idx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -21,7 +21,7 @@ fn a() {\n \n     p[0] = 5; //~ ERROR cannot assign\n \n-    info2!(\"{}\", *q);\n+    info!(\"{}\", *q);\n }\n \n fn borrow(_x: &[int], _f: &fn()) {}"}, {"sha": "4bbd1b0decf57c8b3f222bf80669e30564b0f0b4", "filename": "src/test/compile-fail/borrowck-autoref-3261.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -24,7 +24,7 @@ fn main() {\n                 x = X(Left((0,0))); //~ ERROR cannot assign to `x`\n                 (*f)()\n             },\n-            _ => fail2!()\n+            _ => fail!()\n         }\n     }\n }"}, {"sha": "1051c5829ec387cd9e5957a6b48e8f042a13bdec", "filename": "src/test/compile-fail/borrowck-borrow-from-owned-ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-owned-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-owned-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-owned-ptr.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -18,7 +18,7 @@ struct Bar {\n   int2: int,\n }\n \n-fn make_foo() -> ~Foo { fail2!() }\n+fn make_foo() -> ~Foo { fail!() }\n \n fn borrow_same_field_twice_mut_mut() {\n     let mut foo = make_foo();"}, {"sha": "cdcf50c906e3655234f3a9cdd276d505a8e99355", "filename": "src/test/compile-fail/borrowck-borrow-from-stack-variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-stack-variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-stack-variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-stack-variable.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -18,7 +18,7 @@ struct Bar {\n   int2: int,\n }\n \n-fn make_foo() -> Foo { fail2!() }\n+fn make_foo() -> Foo { fail!() }\n \n fn borrow_same_field_twice_mut_mut() {\n     let mut foo = make_foo();"}, {"sha": "cc196a6f7cf57454639b7881a5612cddab22f152", "filename": "src/test/compile-fail/borrowck-borrowed-uniq-rvalue-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue-2.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -16,7 +16,7 @@ struct defer<'self> {\n impl<'self> Drop for defer<'self> {\n     fn drop(&mut self) {\n         unsafe {\n-            error2!(\"{:?}\", self.x);\n+            error!(\"{:?}\", self.x);\n         }\n     }\n }"}, {"sha": "563f63b98be05528580535b642cbc6bc77fd11f6", "filename": "src/test/compile-fail/borrowck-lend-flow-if.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-if.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -16,9 +16,9 @@\n \n fn borrow(_v: &int) {}\n fn borrow_mut(_v: &mut int) {}\n-fn cond() -> bool { fail2!() }\n-fn for_func(_f: &fn() -> bool) { fail2!() }\n-fn produce<T>() -> T { fail2!(); }\n+fn cond() -> bool { fail!() }\n+fn for_func(_f: &fn() -> bool) { fail!() }\n+fn produce<T>() -> T { fail!(); }\n \n fn inc(v: &mut ~int) {\n     *v = ~(**v + 1);"}, {"sha": "9286340f6c9f5f79803c7fe8100ea3fb098ba481", "filename": "src/test/compile-fail/borrowck-lend-flow-loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -16,8 +16,8 @@\n \n fn borrow(_v: &int) {}\n fn borrow_mut(_v: &mut int) {}\n-fn cond() -> bool { fail2!() }\n-fn produce<T>() -> T { fail2!(); }\n+fn cond() -> bool { fail!() }\n+fn produce<T>() -> T { fail!(); }\n \n fn inc(v: &mut ~int) {\n     *v = ~(**v + 1);"}, {"sha": "d5c5597e57fce15f3d0794bd44e92e6872b51b27", "filename": "src/test/compile-fail/borrowck-lend-flow-match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-match.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -13,7 +13,7 @@\n #[allow(unused_variable)];\n #[allow(dead_assignment)];\n \n-fn cond() -> bool { fail2!() }\n+fn cond() -> bool { fail!() }\n fn link<'a>(v: &'a uint, w: &mut &'a uint) -> bool { *w = v; true }\n \n fn separate_arms() {"}, {"sha": "ea840a28b4e6ac97efd6fe7ebb3af8bbcbe691a9", "filename": "src/test/compile-fail/borrowck-lend-flow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -16,9 +16,9 @@\n \n fn borrow(_v: &int) {}\n fn borrow_mut(_v: &mut int) {}\n-fn cond() -> bool { fail2!() }\n-fn for_func(_f: &fn() -> bool) { fail2!() }\n-fn produce<T>() -> T { fail2!(); }\n+fn cond() -> bool { fail!() }\n+fn for_func(_f: &fn() -> bool) { fail!() }\n+fn produce<T>() -> T { fail!(); }\n \n fn inc(v: &mut ~int) {\n     *v = ~(**v + 1);"}, {"sha": "0284f234d9a5a21841e68ac51a2800ce8ecd1b12", "filename": "src/test/compile-fail/borrowck-loan-blocks-move-cc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -18,14 +18,14 @@ fn box_imm() {\n     let v = ~3;\n     let _w = &v;\n     do task::spawn {\n-        info2!(\"v={}\", *v);\n+        info!(\"v={}\", *v);\n         //~^ ERROR cannot move `v` into closure\n     }\n \n     let v = ~3;\n     let _w = &v;\n     task::spawn(|| {\n-        info2!(\"v={}\", *v);\n+        info!(\"v={}\", *v);\n         //~^ ERROR cannot move\n     });\n }"}, {"sha": "e2136c82313efc63e0d769995e804d4d0113c300", "filename": "src/test/compile-fail/borrowck-loan-local-as-both-mut-and-imm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-local-as-both-mut-and-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-local-as-both-mut-and-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-local-as-both-mut-and-imm.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -16,7 +16,7 @@ use std::either::{Either, Left, Right};\n                 *x = Right(1.0);\n                 *z\n             }\n-            _ => fail2!()\n+            _ => fail!()\n         }\n     }\n "}, {"sha": "4b6a2eca1af1df5ce4221fe1223831ff3a8cd399", "filename": "src/test/compile-fail/borrowck-move-out-of-vec-tail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -23,7 +23,7 @@ pub fn main() {\n                 }\n             }\n             let z = tail[0].clone();\n-            info2!(\"{:?}\", z);\n+            info!(\"{:?}\", z);\n         }\n         _ => {\n             unreachable!();"}, {"sha": "cab2a5565f4ec671a85abfa295d7df87c22169d4", "filename": "src/test/compile-fail/borrowck-mut-addr-of-imm-var.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-addr-of-imm-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-addr-of-imm-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-addr-of-imm-var.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -12,5 +12,5 @@ fn main() {\n     let x: int = 3;\n     let y: &mut int = &mut x; //~ ERROR cannot borrow\n     *y = 5;\n-    info2!(\"{:?}\", *y);\n+    info!(\"{:?}\", *y);\n }"}, {"sha": "cb56e929754da1ccf77669eb819f65065e54372b", "filename": "src/test/compile-fail/borrowck-ref-into-rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-into-rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-into-rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-into-rvalue.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -14,7 +14,7 @@ fn main() {\n         Some(ref m) => { //~ ERROR borrowed value does not live long enough\n             msg = m;\n         },\n-        None => { fail2!() }\n+        None => { fail!() }\n     }\n     println(*msg);\n }"}, {"sha": "ca20d68e4cdcbde130e1e448ab4ef9cec03edeab", "filename": "src/test/compile-fail/borrowck-vec-pattern-element-loan.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -2,7 +2,7 @@ fn a() -> &[int] {\n     let vec = ~[1, 2, 3, 4];\n     let tail = match vec {\n         [_, ..tail] => tail, //~ ERROR does not live long enough\n-        _ => fail2!(\"a\")\n+        _ => fail!(\"a\")\n     };\n     tail\n }\n@@ -11,7 +11,7 @@ fn b() -> &[int] {\n     let vec = ~[1, 2, 3, 4];\n     let init = match vec {\n         [..init, _] => init, //~ ERROR does not live long enough\n-        _ => fail2!(\"b\")\n+        _ => fail!(\"b\")\n     };\n     init\n }\n@@ -20,7 +20,7 @@ fn c() -> &[int] {\n     let vec = ~[1, 2, 3, 4];\n     let slice = match vec {\n         [_, ..slice, _] => slice, //~ ERROR does not live long enough\n-        _ => fail2!(\"c\")\n+        _ => fail!(\"c\")\n     };\n     slice\n }"}, {"sha": "02ba1b9d2fffb634f41b8336a5aedfc7bbccfe71", "filename": "src/test/compile-fail/borrowck-vec-pattern-nesting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -4,7 +4,7 @@ fn a() {\n         [~ref _a] => {\n             vec[0] = ~4; //~ ERROR cannot assign to `(*vec)[]` because it is borrowed\n         }\n-        _ => fail2!(\"foo\")\n+        _ => fail!(\"foo\")\n     }\n }\n "}, {"sha": "e542238d035665c2b56f238f167877663d939223", "filename": "src/test/compile-fail/borrowck-vec-pattern-tail-element-loan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -2,7 +2,7 @@ fn a() -> &int {\n     let vec = ~[1, 2, 3, 4];\n     let tail = match vec {\n         [_a, ..tail] => &tail[0], //~ ERROR borrowed value does not live long enough\n-        _ => fail2!(\"foo\")\n+        _ => fail!(\"foo\")\n     };\n     tail\n }"}, {"sha": "0d1582bf85713b654dc3c68efa5cbb5d58cce8b6", "filename": "src/test/compile-fail/class-cast-to-trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -22,12 +22,12 @@ struct cat {\n impl cat {\n   pub fn eat(&self) -> bool {\n     if self.how_hungry > 0 {\n-        error2!(\"OM NOM NOM\");\n+        error!(\"OM NOM NOM\");\n         self.how_hungry -= 2;\n         return true;\n     }\n     else {\n-        error2!(\"Not hungry!\");\n+        error!(\"Not hungry!\");\n         return false;\n     }\n   }\n@@ -40,7 +40,7 @@ impl noisy for cat {\n \n impl cat {\n     fn meow(&self) {\n-      error2!(\"Meow\");\n+      error!(\"Meow\");\n       self.meows += 1;\n       if self.meows % 5 == 0 {\n           self.how_hungry += 1;"}, {"sha": "c27c27b5942e1b3276e86c410a94a21883c57b8b", "filename": "src/test/compile-fail/class-missing-self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fclass-missing-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fclass-missing-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-missing-self.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -15,7 +15,7 @@ struct cat {\n impl cat {\n     fn sleep(&self) { loop{} }\n     fn meow(&self) {\n-      error2!(\"Meow\");\n+      error!(\"Meow\");\n       meows += 1u; //~ ERROR unresolved name\n       sleep();     //~ ERROR unresolved name\n     }"}, {"sha": "aad0e8bcbb6dd874fa5ead459190574cdcfeb112", "filename": "src/test/compile-fail/closure-that-fails.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fclosure-that-fails.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fclosure-that-fails.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-that-fails.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -2,6 +2,6 @@ fn foo(f: &fn() -> !) {}\n \n fn main() {\n     // Type inference didn't use to be able to handle this:\n-    foo(|| fail2!());\n+    foo(|| fail!());\n     foo(|| 22); //~ ERROR mismatched types\n }"}, {"sha": "7e928e190a327e748fab93ef51b67b8f32558d47", "filename": "src/test/compile-fail/copy-a-resource.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -26,5 +26,5 @@ fn main() {\n     let x = foo(10);\n     let _y = x.clone();\n     //~^ ERROR does not implement any method in scope\n-    error2!(\"{:?}\", x);\n+    error!(\"{:?}\", x);\n }"}, {"sha": "7b1b0f6243ac4321b22ebd7470b7d8be4441979e", "filename": "src/test/compile-fail/deref-non-pointer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fderef-non-pointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fderef-non-pointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderef-non-pointer.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -10,6 +10,6 @@\n \n fn main() {\n   match *1 { //~ ERROR: cannot be dereferenced\n-      _ => { fail2!(); }\n+      _ => { fail!(); }\n   }\n }"}, {"sha": "945c3d6295277435469d1ad75d7ed00912334615", "filename": "src/test/compile-fail/disallowed-deconstructing-destructing-struct-let.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-let.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -14,7 +14,7 @@ struct X {\n \n impl Drop for X {\n     fn drop(&mut self) {\n-        error2!(\"value: {}\", self.x);\n+        error!(\"value: {}\", self.x);\n     }\n }\n \n@@ -26,5 +26,5 @@ fn unwrap(x: X) -> ~str {\n fn main() {\n     let x = X { x: ~\"hello\" };\n     let y = unwrap(x);\n-    error2!(\"contents: {}\", y);\n+    error!(\"contents: {}\", y);\n }"}, {"sha": "0432920c1a6fe1a49c4fcf4111ef35390627c465", "filename": "src/test/compile-fail/disallowed-deconstructing-destructing-struct-match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-match.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -14,15 +14,15 @@ struct X {\n \n impl Drop for X {\n     fn drop(&mut self) {\n-        error2!(\"value: {}\", self.x);\n+        error!(\"value: {}\", self.x);\n     }\n }\n \n fn main() {\n     let x = X { x: ~\"hello\" };\n \n     match x {\n-        X { x: y } => error2!(\"contents: {}\", y)\n+        X { x: y } => error!(\"contents: {}\", y)\n         //~^ ERROR cannot move out of type `X`, which defines the `Drop` trait\n     }\n }"}, {"sha": "9d2b68ddb81ef6ce2cd712ac3160e3941998c7c2", "filename": "src/test/compile-fail/does-nothing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fdoes-nothing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fdoes-nothing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdoes-nothing.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -1,2 +1,2 @@\n // error-pattern: unresolved name `this_does_nothing_what_the`.\n-fn main() { info2!(\"doing\"); this_does_nothing_what_the; info2!(\"boing\"); }\n+fn main() { info!(\"doing\"); this_does_nothing_what_the; info!(\"boing\"); }"}, {"sha": "22762eb4a7eb514d54cbe8c37b38422abbce6ef8", "filename": "src/test/compile-fail/export2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fexport2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fexport2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexport2.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -15,7 +15,7 @@ mod foo {\n }\n \n mod bar {\n-    fn x() { info2!(\"x\"); }\n+    fn x() { info!(\"x\"); }\n \n     pub fn y() { }\n }"}, {"sha": "98270bdc583835e63d9b274d6dd1e3996cdac965", "filename": "src/test/compile-fail/fail-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Ffail-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Ffail-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffail-expr.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -10,4 +10,4 @@\n \n // error-pattern:failed to find an implementation of trait std::sys::FailWithCause for int\n \n-fn main() { fail2!(5); }\n+fn main() { fail!(5); }"}, {"sha": "7def16770a790d9e39f7f22f7982c3a38bdee63c", "filename": "src/test/compile-fail/fail-simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Ffail-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Ffail-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffail-simple.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -12,5 +12,5 @@\n \n // error-pattern:unexpected token\n fn main() {\n-  fail2!(@);\n+  fail!(@);\n }"}, {"sha": "b6755249bcf98108dce766569262e59a522784ff", "filename": "src/test/compile-fail/fail-type-err.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Ffail-type-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Ffail-type-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffail-type-err.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -9,4 +9,4 @@\n // except according to those terms.\n \n // error-pattern:failed to find an implementation of trait std::sys::FailWithCause for ~[int]\n-fn main() { fail2!(~[0i]); }\n+fn main() { fail!(~[0i]); }"}, {"sha": "dcda6afa6ca1e366b2364b5d6a734495800e94ec", "filename": "src/test/compile-fail/if-without-else-result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fif-without-else-result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fif-without-else-result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fif-without-else-result.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -12,5 +12,5 @@\n \n fn main() {\n     let a = if true { true };\n-    info2!(\"{:?}\", a);\n+    info!(\"{:?}\", a);\n }"}, {"sha": "124d4631601d6d34c9e8d0f3d7e29f318d3d6364", "filename": "src/test/compile-fail/import-glob-0.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fimport-glob-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fimport-glob-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-glob-0.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -15,10 +15,10 @@\n use module_of_many_things::*;\n \n mod module_of_many_things {\n-    pub fn f1() { info2!(\"f1\"); }\n-    pub fn f2() { info2!(\"f2\"); }\n-    fn f3() { info2!(\"f3\"); }\n-    pub fn f4() { info2!(\"f4\"); }\n+    pub fn f1() { info!(\"f1\"); }\n+    pub fn f2() { info!(\"f2\"); }\n+    fn f3() { info!(\"f3\"); }\n+    pub fn f4() { info!(\"f4\"); }\n }\n \n "}, {"sha": "ae5a0f04e2c043d45b15058fae613f8df176c302", "filename": "src/test/compile-fail/import-glob-circular.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fimport-glob-circular.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fimport-glob-circular.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-glob-circular.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -14,13 +14,13 @@\n \n mod circ1 {\n     pub use circ2::f2;\n-    pub fn f1() { info2!(\"f1\"); }\n+    pub fn f1() { info!(\"f1\"); }\n     pub fn common() -> uint { return 0u; }\n }\n \n mod circ2 {\n     pub use circ1::f1;\n-    pub fn f2() { info2!(\"f2\"); }\n+    pub fn f2() { info!(\"f2\"); }\n     pub fn common() -> uint { return 1u; }\n }\n "}, {"sha": "5177dc4e47570caa711ee236b52fed63724dddf0", "filename": "src/test/compile-fail/import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -12,6 +12,6 @@\n use zed::bar;\n use zed::baz;\n mod zed {\n-    pub fn bar() { info2!(\"bar\"); }\n+    pub fn bar() { info!(\"bar\"); }\n }\n fn main(args: ~[str]) { bar(); }"}, {"sha": "e67a79130b1f9a6e0529088136cf7aa14a2166e7", "filename": "src/test/compile-fail/import2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fimport2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fimport2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport2.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -13,6 +13,6 @@ use baz::zed::bar;  //~ ERROR unresolved import\n \n mod baz {}\n mod zed {\n-    pub fn bar() { info2!(\"bar3\"); }\n+    pub fn bar() { info!(\"bar3\"); }\n }\n fn main(args: ~[str]) { bar(); }"}, {"sha": "7a7f4f20aea07f1b4dc57eba1a17d144120c92df", "filename": "src/test/compile-fail/import3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fimport3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fimport3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport3.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -11,4 +11,4 @@\n // error-pattern: unresolved\n use main::bar;\n \n-fn main(args: ~[str]) { info2!(\"foo\"); }\n+fn main(args: ~[str]) { info!(\"foo\"); }"}, {"sha": "087842d78c709f6910011c49886675be479cf420", "filename": "src/test/compile-fail/import4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fimport4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fimport4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport4.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -13,4 +13,4 @@\n mod a { pub use b::foo; }\n mod b { pub use a::foo; }\n \n-fn main(args: ~[str]) { info2!(\"loop\"); }\n+fn main(args: ~[str]) { info!(\"loop\"); }"}, {"sha": "e2ca7641500c3014f11aa2e05dcfaffc64005b46", "filename": "src/test/compile-fail/issue-1448-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fissue-1448-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fissue-1448-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1448-2.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -13,5 +13,5 @@\n fn foo(a: uint) -> uint { a }\n \n fn main() {\n-    info2!(\"{:u}\", foo(10i)); //~ ERROR mismatched types\n+    info!(\"{:u}\", foo(10i)); //~ ERROR mismatched types\n }"}, {"sha": "ed2e75c4fa602fff2e726bc9edad452f711d2b9c", "filename": "src/test/compile-fail/issue-1476.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fissue-1476.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fissue-1476.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1476.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    error2!(\"{:?}\", x); //~ ERROR unresolved name `x`.\n+    error!(\"{:?}\", x); //~ ERROR unresolved name `x`.\n }"}, {"sha": "3da01c6fb01398fb105dae508654b5cde55c4551", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -14,7 +14,7 @@ trait vec_monad<A> {\n \n impl<A> vec_monad<A> for ~[A] {\n     fn bind<B>(&self, f: &fn(A) -> ~[B]) {\n-        let mut r = fail2!();\n+        let mut r = fail!();\n         for elt in self.iter() { r = r + f(*elt); }\n         //~^ ERROR the type of this value must be known\n    }"}, {"sha": "64344ab4277939605bdaea6b4c13063dab6fa0fd", "filename": "src/test/compile-fail/issue-2150.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2150.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -13,7 +13,7 @@\n \n fn fail_len(v: ~[int]) -> uint {\n     let mut i = 3;\n-    fail2!();\n+    fail!();\n     for x in v.iter() { i += 1u; }\n     //~^ ERROR: unreachable statement\n     return i;"}, {"sha": "5559ba344ed17a44e61bc775f65e77413276e033", "filename": "src/test/compile-fail/issue-2151.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fissue-2151.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fissue-2151.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2151.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n fn main() {\n-    let x = fail2!();\n+    let x = fail!();\n     x.clone(); //~ ERROR the type of this value must be known in this context\n }"}, {"sha": "7896d91443dadd6cbfdc7afb758e650ca9dcf57b", "filename": "src/test/compile-fail/issue-2281-part1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fissue-2281-part1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fissue-2281-part1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2281-part1.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -10,4 +10,4 @@\n \n // error-pattern: unresolved name `foobar`.\n \n-fn main(args: ~[str]) { info2!(\"{:?}\", foobar); }\n+fn main(args: ~[str]) { info!(\"{:?}\", foobar); }"}, {"sha": "6152e82294d1b51f9d0d4faa28506f0cf48117ae", "filename": "src/test/compile-fail/issue-2330.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fissue-2330.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fissue-2330.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2330.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -16,7 +16,7 @@ trait channel<T> {\n \n // `chan` is not a trait, it's an enum\n impl chan for int { //~ ERROR chan is not a trait\n-    fn send(&self, v: int) { fail2!() }\n+    fn send(&self, v: int) { fail!() }\n }\n \n fn main() {"}, {"sha": "dc4530d586eae832ff694eda8b625acc5cd40688", "filename": "src/test/compile-fail/issue-2370-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fissue-2370-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fissue-2370-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2370-2.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -15,5 +15,5 @@ struct cat {\n \n fn main() {\n     let kitty : cat = cat { x: () };\n-    error2!(\"{:?}\", *kitty);\n+    error!(\"{:?}\", *kitty);\n }"}, {"sha": "656088a00b7dd3ad158745e8f324641ef96d2a99", "filename": "src/test/compile-fail/issue-2370.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fissue-2370.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fissue-2370.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2370.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -15,5 +15,5 @@ struct cat {\n \n fn main() {\n     let nyan = cat { foo: () };\n-    error2!(\"{:?}\", *nyan);\n+    error!(\"{:?}\", *nyan);\n }"}, {"sha": "c62c28745253d157977417675c3758126fcdf2e8", "filename": "src/test/compile-fail/issue-2611-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fissue-2611-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf5f5a4d10513ff42e79fa7ef8819b170f3a13d/src%2Ftest%2Fcompile-fail%2Fissue-2611-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2611-4.rs?ref=daf5f5a4d10513ff42e79fa7ef8819b170f3a13d", "patch": "@@ -20,7 +20,7 @@ struct E {\n }\n \n impl A for E {\n-  fn b<F:Freeze,G>(_x: F) -> F { fail2!() } //~ ERROR type parameter 0 requires `Freeze`\n+  fn b<F:Freeze,G>(_x: F) -> F { fail!() } //~ ERROR type parameter 0 requires `Freeze`\n }\n \n fn main() {}"}]}