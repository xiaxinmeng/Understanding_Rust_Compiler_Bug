{"sha": "d433b80e026960b28ba660ebdb09175237e02e05", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0MzNiODBlMDI2OTYwYjI4YmE2NjBlYmRiMDkxNzUyMzdlMDJlMDU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-02-08T10:46:55Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-02-09T08:17:40Z"}, "message": "std: Add init and uninit to mem. Replace direct intrinsic usage", "tree": {"sha": "8b18795290b7b6c9d717e14f07e7ce5b99eeff6b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b18795290b7b6c9d717e14f07e7ce5b99eeff6b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d433b80e026960b28ba660ebdb09175237e02e05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d433b80e026960b28ba660ebdb09175237e02e05", "html_url": "https://github.com/rust-lang/rust/commit/d433b80e026960b28ba660ebdb09175237e02e05", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d433b80e026960b28ba660ebdb09175237e02e05/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49ac48db3fe2666751908668ba8e5ab16e2fb07a", "url": "https://api.github.com/repos/rust-lang/rust/commits/49ac48db3fe2666751908668ba8e5ab16e2fb07a", "html_url": "https://github.com/rust-lang/rust/commit/49ac48db3fe2666751908668ba8e5ab16e2fb07a"}], "stats": {"total": 103, "additions": 60, "deletions": 43}, "files": [{"sha": "eaec482fc9b8d8e14af3ce39e8bc6be73635cea1", "filename": "src/doc/guide-ffi.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d433b80e026960b28ba660ebdb09175237e02e05/src%2Fdoc%2Fguide-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/d433b80e026960b28ba660ebdb09175237e02e05/src%2Fdoc%2Fguide-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-ffi.md?ref=d433b80e026960b28ba660ebdb09175237e02e05", "patch": "@@ -176,6 +176,7 @@ and `free`:\n ~~~~\n use std::cast;\n use std::libc::{c_void, size_t, malloc, free};\n+use std::mem;\n use std::ptr;\n use std::unstable::intrinsics;\n \n@@ -226,7 +227,7 @@ impl<T: Send> Unique<T> {\n impl<T: Send> Drop for Unique<T> {\n     fn drop(&mut self) {\n         unsafe {\n-            let x = intrinsics::uninit(); // dummy value to swap in\n+            let x = mem::uninit(); // dummy value to swap in\n             // We need to move the object out of the box, so that\n             // the destructor is called (at the end of this scope.)\n             ptr::replace_ptr(self.ptr, x);"}, {"sha": "c8754c839b28625e4d3b8741721a628b392ccc8f", "filename": "src/libnative/io/file.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d433b80e026960b28ba660ebdb09175237e02e05/src%2Flibnative%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d433b80e026960b28ba660ebdb09175237e02e05/src%2Flibnative%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile.rs?ref=d433b80e026960b28ba660ebdb09175237e02e05", "patch": "@@ -16,9 +16,9 @@ use std::io::IoError;\n use std::io;\n use std::libc::{c_int, c_void};\n use std::libc;\n+use std::mem;\n use std::os;\n use std::rt::rtio;\n-use std::unstable::intrinsics;\n use std::vec;\n \n use io::{IoResult, retry};\n@@ -147,7 +147,7 @@ impl rtio::RtioFileStream for FileDesc {\n         #[cfg(windows)]\n         fn os_pread(fd: c_int, buf: *u8, amt: uint, offset: u64) -> IoResult<int> {\n             unsafe {\n-                let mut overlap: libc::OVERLAPPED = intrinsics::init();\n+                let mut overlap: libc::OVERLAPPED = mem::init();\n                 let handle = libc::get_osfhandle(fd) as libc::HANDLE;\n                 let mut bytes_read = 0;\n                 overlap.Offset = offset as libc::DWORD;\n@@ -179,7 +179,7 @@ impl rtio::RtioFileStream for FileDesc {\n         #[cfg(windows)]\n         fn os_pwrite(fd: c_int, buf: *u8, amt: uint, offset: u64) -> IoResult<()> {\n             unsafe {\n-                let mut overlap: libc::OVERLAPPED = intrinsics::init();\n+                let mut overlap: libc::OVERLAPPED = mem::init();\n                 let handle = libc::get_osfhandle(fd) as libc::HANDLE;\n                 overlap.Offset = offset as libc::DWORD;\n                 overlap.OffsetHigh = (offset >> 32) as libc::DWORD;\n@@ -867,7 +867,7 @@ pub fn stat(p: &CString) -> IoResult<io::FileStat> {\n \n     #[cfg(windows)]\n     fn os_stat(p: &CString) -> IoResult<io::FileStat> {\n-        let mut stat: libc::stat = unsafe { intrinsics::uninit() };\n+        let mut stat: libc::stat = unsafe { mem::uninit() };\n         as_utf16_p(p.as_str().unwrap(), |up| {\n             match retry(|| unsafe { libc::wstat(up, &mut stat) }) {\n                 0 => Ok(mkstat(&stat, p)),\n@@ -878,7 +878,7 @@ pub fn stat(p: &CString) -> IoResult<io::FileStat> {\n \n     #[cfg(unix)]\n     fn os_stat(p: &CString) -> IoResult<io::FileStat> {\n-        let mut stat: libc::stat = unsafe { intrinsics::uninit() };\n+        let mut stat: libc::stat = unsafe { mem::uninit() };\n         match retry(|| unsafe { libc::stat(p.with_ref(|p| p), &mut stat) }) {\n             0 => Ok(mkstat(&stat, p)),\n             _ => Err(super::last_error()),\n@@ -897,7 +897,7 @@ pub fn lstat(p: &CString) -> IoResult<io::FileStat> {\n \n     #[cfg(unix)]\n     fn os_lstat(p: &CString) -> IoResult<io::FileStat> {\n-        let mut stat: libc::stat = unsafe { intrinsics::uninit() };\n+        let mut stat: libc::stat = unsafe { mem::uninit() };\n         match retry(|| unsafe { libc::lstat(p.with_ref(|p| p), &mut stat) }) {\n             0 => Ok(mkstat(&stat, p)),\n             _ => Err(super::last_error()),"}, {"sha": "9042353c50a73236b0ee203a94940eb35fd65b90", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d433b80e026960b28ba660ebdb09175237e02e05/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d433b80e026960b28ba660ebdb09175237e02e05/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=d433b80e026960b28ba660ebdb09175237e02e05", "patch": "@@ -68,7 +68,7 @@ fn ip_to_inaddr(ip: ip::IpAddr) -> InAddr {\n \n fn addr_to_sockaddr(addr: ip::SocketAddr) -> (libc::sockaddr_storage, uint) {\n     unsafe {\n-        let storage: libc::sockaddr_storage = intrinsics::init();\n+        let storage: libc::sockaddr_storage = mem::init();\n         let len = match ip_to_inaddr(addr.ip) {\n             InAddr(inaddr) => {\n                 let storage: *mut libc::sockaddr_in = cast::transmute(&storage);\n@@ -138,7 +138,7 @@ fn sockname(fd: sock_t,\n                                          *mut libc::socklen_t) -> libc::c_int)\n     -> IoResult<ip::SocketAddr>\n {\n-    let mut storage: libc::sockaddr_storage = unsafe { intrinsics::init() };\n+    let mut storage: libc::sockaddr_storage = unsafe { mem::init() };\n     let mut len = mem::size_of::<libc::sockaddr_storage>() as libc::socklen_t;\n     unsafe {\n         let storage = &mut storage as *mut libc::sockaddr_storage;\n@@ -225,7 +225,7 @@ pub fn init() {\n \n         LOCK.lock();\n         if !INITIALIZED {\n-            let mut data: WSADATA = intrinsics::init();\n+            let mut data: WSADATA = mem::init();\n             let ret = WSAStartup(0x202,      // version 2.2\n                                  &mut data);\n             assert_eq!(ret, 0);\n@@ -438,7 +438,7 @@ impl TcpAcceptor {\n \n     pub fn native_accept(&mut self) -> IoResult<TcpStream> {\n         unsafe {\n-            let mut storage: libc::sockaddr_storage = intrinsics::init();\n+            let mut storage: libc::sockaddr_storage = mem::init();\n             let storagep = &mut storage as *mut libc::sockaddr_storage;\n             let size = mem::size_of::<libc::sockaddr_storage>();\n             let mut size = size as libc::socklen_t;\n@@ -543,7 +543,7 @@ impl rtio::RtioSocket for UdpSocket {\n impl rtio::RtioUdpSocket for UdpSocket {\n     fn recvfrom(&mut self, buf: &mut [u8]) -> IoResult<(uint, ip::SocketAddr)> {\n         unsafe {\n-            let mut storage: libc::sockaddr_storage = intrinsics::init();\n+            let mut storage: libc::sockaddr_storage = mem::init();\n             let storagep = &mut storage as *mut libc::sockaddr_storage;\n             let mut addrlen: libc::socklen_t =\n                     mem::size_of::<libc::sockaddr_storage>() as libc::socklen_t;"}, {"sha": "a06cab33a52f76868fc24fb1a1211894876d6f2d", "filename": "src/libnative/io/timer_other.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d433b80e026960b28ba660ebdb09175237e02e05/src%2Flibnative%2Fio%2Ftimer_other.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d433b80e026960b28ba660ebdb09175237e02e05/src%2Flibnative%2Fio%2Ftimer_other.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_other.rs?ref=d433b80e026960b28ba660ebdb09175237e02e05", "patch": "@@ -49,11 +49,11 @@\n use std::comm::Data;\n use std::hashmap::HashMap;\n use std::libc;\n+use std::mem;\n use std::os;\n use std::ptr;\n use std::rt::rtio;\n use std::sync::atomics;\n-use std::unstable::intrinsics;\n \n use io::file::FileDesc;\n use io::IoResult;\n@@ -87,17 +87,17 @@ pub enum Req {\n // returns the current time (in milliseconds)\n fn now() -> u64 {\n     unsafe {\n-        let mut now: libc::timeval = intrinsics::init();\n+        let mut now: libc::timeval = mem::init();\n         assert_eq!(imp::gettimeofday(&mut now, ptr::null()), 0);\n         return (now.tv_sec as u64) * 1000 + (now.tv_usec as u64) / 1000;\n     }\n }\n \n fn helper(input: libc::c_int, messages: Port<Req>) {\n-    let mut set: imp::fd_set = unsafe { intrinsics::init() };\n+    let mut set: imp::fd_set = unsafe { mem::init() };\n \n     let mut fd = FileDesc::new(input, true);\n-    let mut timeout: libc::timeval = unsafe { intrinsics::init() };\n+    let mut timeout: libc::timeval = unsafe { mem::init() };\n \n     // active timers are those which are able to be selected upon (and it's a\n     // sorted list, and dead timers are those which have expired, but ownership"}, {"sha": "434794e32cb3c222e7f5527c2509e9c31f73a147", "filename": "src/libnative/io/timer_timerfd.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d433b80e026960b28ba660ebdb09175237e02e05/src%2Flibnative%2Fio%2Ftimer_timerfd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d433b80e026960b28ba660ebdb09175237e02e05/src%2Flibnative%2Fio%2Ftimer_timerfd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_timerfd.rs?ref=d433b80e026960b28ba660ebdb09175237e02e05", "patch": "@@ -34,7 +34,7 @@ use std::ptr;\n use std::os;\n use std::rt::rtio;\n use std::hashmap::HashMap;\n-use std::unstable::intrinsics;\n+use std::mem;\n \n use io::file::FileDesc;\n use io::IoResult;\n@@ -75,7 +75,7 @@ fn helper(input: libc::c_int, messages: Port<Req>) {\n     }\n \n     add(efd, input);\n-    let events: [imp::epoll_event, ..16] = unsafe { intrinsics::init() };\n+    let events: [imp::epoll_event, ..16] = unsafe { mem::init() };\n     let mut map: HashMap<libc::c_int, (Chan<()>, bool)> = HashMap::new();\n     'outer: loop {\n         let n = match unsafe {"}, {"sha": "7c9448bb73241a6c34166c128bf0db81fce2d842", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d433b80e026960b28ba660ebdb09175237e02e05/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d433b80e026960b28ba660ebdb09175237e02e05/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=d433b80e026960b28ba660ebdb09175237e02e05", "patch": "@@ -28,6 +28,7 @@ use std::cast;\n use std::fmt;\n use std::io;\n use std::libc;\n+use std::mem;\n use std::str;\n use std::unstable::intrinsics;\n use std::vec;\n@@ -144,7 +145,7 @@ pub fn render(w: &mut io::Writer, s: &str) -> fmt::Result {\n             flags: 0,\n             link_attributes: None,\n         };\n-        let mut callbacks: sd_callbacks = intrinsics::init();\n+        let mut callbacks: sd_callbacks = mem::init();\n \n         sdhtml_renderer(&callbacks, &options, 0);\n         let opaque = my_opaque {\n@@ -197,7 +198,7 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n                          MKDEXT_STRIKETHROUGH;\n         let callbacks = sd_callbacks {\n             blockcode: block,\n-            other: intrinsics::init()\n+            other: mem::init()\n         };\n \n         let tests = tests as *mut ::test::Collector as *libc::c_void;"}, {"sha": "9ccef383efaf918ac309b1a4a6186515492d199f", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d433b80e026960b28ba660ebdb09175237e02e05/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d433b80e026960b28ba660ebdb09175237e02e05/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=d433b80e026960b28ba660ebdb09175237e02e05", "patch": "@@ -80,7 +80,7 @@ pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n \n fn addr_to_sockaddr(addr: ip::SocketAddr) -> (libc::sockaddr_storage, uint) {\n     unsafe {\n-        let mut storage: libc::sockaddr_storage = intrinsics::init();\n+        let mut storage: libc::sockaddr_storage = mem::init();\n         let len = match addr.ip {\n             ip::Ipv4Addr(a, b, c, d) => {\n                 let storage: &mut libc::sockaddr_in =\n@@ -134,7 +134,7 @@ fn socket_name(sk: SocketNameKind,\n     };\n \n     // Allocate a sockaddr_storage since we don't know if it's ipv4 or ipv6\n-    let mut sockaddr: libc::sockaddr_storage = unsafe { intrinsics::init() };\n+    let mut sockaddr: libc::sockaddr_storage = unsafe { mem::init() };\n     let mut namelen = mem::size_of::<libc::sockaddr_storage>() as c_int;\n \n     let sockaddr_p = &mut sockaddr as *mut libc::sockaddr_storage;"}, {"sha": "cc6cd7666d642bbbce53ac37b5c6f924fafe8bf6", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d433b80e026960b28ba660ebdb09175237e02e05/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d433b80e026960b28ba660ebdb09175237e02e05/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=d433b80e026960b28ba660ebdb09175237e02e05", "patch": "@@ -70,14 +70,14 @@ use kinds::marker;\n use ops::Drop;\n use cmp::Eq;\n use clone::Clone;\n+use mem;\n use option::{Option, Some, None};\n use ptr::RawPtr;\n use ptr;\n use str::StrSlice;\n use str;\n use vec::{ImmutableVector, MutableVector};\n use vec;\n-use unstable::intrinsics;\n use rt::global_heap::malloc_raw;\n \n /// The representation of a C String.\n@@ -327,7 +327,7 @@ impl<'a> ToCStr for &'a [u8] {\n // Unsafe function that handles possibly copying the &[u8] into a stack array.\n unsafe fn with_c_str<T>(v: &[u8], checked: bool, f: |*libc::c_char| -> T) -> T {\n     if v.len() < BUF_LEN {\n-        let mut buf: [u8, .. BUF_LEN] = intrinsics::uninit();\n+        let mut buf: [u8, .. BUF_LEN] = mem::uninit();\n         vec::bytes::copy_memory(buf, v);\n         buf[v.len()] = 0;\n "}, {"sha": "258c0e23094041b2ead4f73a952b7698cf7fdfe5", "filename": "src/libstd/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d433b80e026960b28ba660ebdb09175237e02e05/src%2Flibstd%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d433b80e026960b28ba660ebdb09175237e02e05/src%2Flibstd%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcast.rs?ref=d433b80e026960b28ba660ebdb09175237e02e05", "patch": "@@ -18,7 +18,7 @@ use ptr::copy_nonoverlapping_memory;\n /// Casts the value at `src` to U. The two types must have the same length.\n #[inline]\n pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n-    let mut dest: U = intrinsics::uninit();\n+    let mut dest: U = mem::uninit();\n     let dest_ptr: *mut u8 = transmute(&mut dest);\n     let src_ptr: *u8 = transmute(src);\n     copy_nonoverlapping_memory(dest_ptr, src_ptr, mem::size_of::<U>());"}, {"sha": "05bc8ed982610bff8a0f714b1384dfad4780dfc3", "filename": "src/libstd/mem.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d433b80e026960b28ba660ebdb09175237e02e05/src%2Flibstd%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d433b80e026960b28ba660ebdb09175237e02e05/src%2Flibstd%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmem.rs?ref=d433b80e026960b28ba660ebdb09175237e02e05", "patch": "@@ -68,6 +68,21 @@ pub fn pref_align_of_val<T>(_val: &T) -> uint {\n     pref_align_of::<T>()\n }\n \n+/// Create a value initialized to zero.\n+///\n+/// `init` is unsafe because it returns a zeroed-out datum,\n+/// which is unsafe unless T is Pod.\n+#[inline]\n+pub unsafe fn init<T>() -> T {\n+    intrinsics::init()\n+}\n+\n+/// Create an uninitialized value.\n+#[inline]\n+pub unsafe fn uninit<T>() -> T {\n+    intrinsics::uninit()\n+}\n+\n #[cfg(test)]\n mod tests {\n     use mem::*;"}, {"sha": "d22e91fb83e275c4b194f64d5a0aa1ae524eaf27", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d433b80e026960b28ba660ebdb09175237e02e05/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d433b80e026960b28ba660ebdb09175237e02e05/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=d433b80e026960b28ba660ebdb09175237e02e05", "patch": "@@ -15,6 +15,7 @@ use clone::Clone;\n #[cfg(not(test))]\n use cmp::Equiv;\n use iter::{range, Iterator};\n+use mem;\n use option::{Option, Some, None};\n use unstable::intrinsics;\n use util::swap;\n@@ -132,7 +133,7 @@ pub unsafe fn zero_memory<T>(dst: *mut T, count: uint) {\n #[inline]\n pub unsafe fn swap_ptr<T>(x: *mut T, y: *mut T) {\n     // Give ourselves some scratch space to work with\n-    let mut tmp: T = intrinsics::uninit();\n+    let mut tmp: T = mem::uninit();\n     let t: *mut T = &mut tmp;\n \n     // Perform the swap\n@@ -160,7 +161,7 @@ pub unsafe fn replace_ptr<T>(dest: *mut T, mut src: T) -> T {\n  */\n #[inline(always)]\n pub unsafe fn read_ptr<T>(src: *T) -> T {\n-    let mut tmp: T = intrinsics::uninit();\n+    let mut tmp: T = mem::uninit();\n     copy_nonoverlapping_memory(&mut tmp, src, 1);\n     tmp\n }"}, {"sha": "b443182c157a343a8bb11ba39bba31ad7da2d28d", "filename": "src/libstd/rt/thread.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d433b80e026960b28ba660ebdb09175237e02e05/src%2Flibstd%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d433b80e026960b28ba660ebdb09175237e02e05/src%2Flibstd%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread.rs?ref=d433b80e026960b28ba660ebdb09175237e02e05", "patch": "@@ -205,17 +205,17 @@ mod imp {\n     use cmp;\n     use libc::consts::os::posix01::{PTHREAD_CREATE_JOINABLE, PTHREAD_STACK_MIN};\n     use libc;\n+    use mem;\n     use os;\n     use ptr;\n-    use unstable::intrinsics;\n     use unstable::stack::RED_ZONE;\n \n     pub type rust_thread = libc::pthread_t;\n     pub type rust_thread_return = *u8;\n \n     pub unsafe fn create(stack: uint, p: ~proc()) -> rust_thread {\n-        let mut native: libc::pthread_t = intrinsics::uninit();\n-        let mut attr: libc::pthread_attr_t = intrinsics::uninit();\n+        let mut native: libc::pthread_t = mem::uninit();\n+        let mut attr: libc::pthread_attr_t = mem::uninit();\n         assert_eq!(pthread_attr_init(&mut attr), 0);\n         assert_eq!(pthread_attr_setdetachstate(&mut attr,\n                                                PTHREAD_CREATE_JOINABLE), 0);"}, {"sha": "624a5aa72de7b8fac65b0f359ad13103032706f1", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d433b80e026960b28ba660ebdb09175237e02e05/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d433b80e026960b28ba660ebdb09175237e02e05/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=d433b80e026960b28ba660ebdb09175237e02e05", "patch": "@@ -16,7 +16,7 @@ use iter::{Extendable, FromIterator, Iterator};\n use mem;\n use uint;\n use util::replace;\n-use unstable::intrinsics::init;\n+use mem::init;\n use vec;\n use ptr::RawPtr;\n use vec::{ImmutableVector, Items, MutableVector, MutItems, OwnedVector};"}, {"sha": "8f313ed661d36e4efe0ac691f36ba7f0a36318f9", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d433b80e026960b28ba660ebdb09175237e02e05/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d433b80e026960b28ba660ebdb09175237e02e05/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=d433b80e026960b28ba660ebdb09175237e02e05", "patch": "@@ -288,8 +288,7 @@ extern \"rust-intrinsic\" {\n     /// Create a value initialized to zero.\n     ///\n     /// `init` is unsafe because it returns a zeroed-out datum,\n-    /// which is unsafe unless T is POD. We don't have a POD\n-    /// kind yet. (See #4074).\n+    /// which is unsafe unless T is Pod.\n     pub fn init<T>() -> T;\n \n     /// Create an uninitialized value."}, {"sha": "3122e925e82d9f5d6fdfdcfc6967d451cee6be05", "filename": "src/libstd/unstable/mutex.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d433b80e026960b28ba660ebdb09175237e02e05/src%2Flibstd%2Funstable%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d433b80e026960b28ba660ebdb09175237e02e05/src%2Flibstd%2Funstable%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmutex.rs?ref=d433b80e026960b28ba660ebdb09175237e02e05", "patch": "@@ -92,7 +92,7 @@ mod imp {\n     use libc;\n     use self::os::{PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER,\n                    pthread_mutex_t, pthread_cond_t};\n-    use unstable::intrinsics;\n+    use mem;\n \n     type pthread_mutexattr_t = libc::c_void;\n     type pthread_condattr_t = libc::c_void;\n@@ -208,8 +208,8 @@ mod imp {\n     impl Mutex {\n         pub unsafe fn new() -> Mutex {\n             let mut m = Mutex {\n-                lock: intrinsics::init(),\n-                cond: intrinsics::init(),\n+                lock: mem::init(),\n+                cond: mem::init(),\n             };\n \n             pthread_mutex_init(&mut m.lock, 0 as *libc::c_void);"}, {"sha": "05c5d7e1588169f9317df831b66f98c89003270e", "filename": "src/libstd/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d433b80e026960b28ba660ebdb09175237e02e05/src%2Flibstd%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d433b80e026960b28ba660ebdb09175237e02e05/src%2Flibstd%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Futil.rs?ref=d433b80e026960b28ba660ebdb09175237e02e05", "patch": "@@ -11,8 +11,8 @@\n //! Miscellaneous helpers for common patterns\n \n use cast;\n+use mem;\n use ptr;\n-use unstable::intrinsics;\n \n /// The identity function.\n #[inline]\n@@ -26,7 +26,7 @@ pub fn id<T>(x: T) -> T { x }\n pub fn swap<T>(x: &mut T, y: &mut T) {\n     unsafe {\n         // Give ourselves some scratch space to work with\n-        let mut tmp: T = intrinsics::uninit();\n+        let mut tmp: T = mem::uninit();\n         let t: *mut T = &mut tmp;\n \n         // Perform the swap, `&mut` pointers never alias"}, {"sha": "5140a2984f224846c129b02a633d3d8d9440ea6a", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d433b80e026960b28ba660ebdb09175237e02e05/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d433b80e026960b28ba660ebdb09175237e02e05/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=d433b80e026960b28ba660ebdb09175237e02e05", "patch": "@@ -16,8 +16,8 @@ use std::cast::transmute;\n use std::i32::range;\n use std::libc::{STDIN_FILENO, c_int, fdopen, fgets, fileno, fopen, fstat};\n use std::libc::{stat, strlen};\n+use std::mem::init;\n use std::ptr::null;\n-use std::unstable::intrinsics::init;\n use std::vec::{reverse};\n \n static LINE_LEN: uint = 80;"}, {"sha": "3c389f49aa14af6c5456d3ff1aad18262de92415", "filename": "src/test/run-pass/issue-10714.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d433b80e026960b28ba660ebdb09175237e02e05/src%2Ftest%2Frun-pass%2Fissue-10714.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d433b80e026960b28ba660ebdb09175237e02e05/src%2Ftest%2Frun-pass%2Fissue-10714.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10714.rs?ref=d433b80e026960b28ba660ebdb09175237e02e05", "patch": "@@ -10,5 +10,5 @@\n \n enum v {}\n pub fn main() {\n-    let y: v = unsafe { ::std::unstable::intrinsics::uninit() };\n+    let y: v = unsafe { ::std::mem::uninit() };\n }"}, {"sha": "df24a399f4a737df79794785856d6504c5dbb9fa", "filename": "src/test/run-pass/uninit-empty-types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d433b80e026960b28ba660ebdb09175237e02e05/src%2Ftest%2Frun-pass%2Funinit-empty-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d433b80e026960b28ba660ebdb09175237e02e05/src%2Ftest%2Frun-pass%2Funinit-empty-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funinit-empty-types.rs?ref=d433b80e026960b28ba660ebdb09175237e02e05", "patch": "@@ -11,14 +11,14 @@\n // Test the uninit() construct returning various empty types.\n \n use std::vec;\n-use std::unstable::intrinsics;\n+use std::mem;\n \n #[deriving(Clone)]\n struct Foo;\n \n pub fn main() {\n     unsafe {\n-        let _x: Foo = intrinsics::uninit();\n-        let _x: [Foo, ..2] = intrinsics::uninit();\n+        let _x: Foo = mem::uninit();\n+        let _x: [Foo, ..2] = mem::uninit();\n     }\n }"}]}