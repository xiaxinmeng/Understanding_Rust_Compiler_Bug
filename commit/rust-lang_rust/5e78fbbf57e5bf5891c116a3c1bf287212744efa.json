{"sha": "5e78fbbf57e5bf5891c116a3c1bf287212744efa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlNzhmYmJmNTdlNWJmNTg5MWMxMTZhM2MxYmYyODcyMTI3NDRlZmE=", "commit": {"author": {"name": "Vikas Kumar", "email": "kr.vikas@gmail.com", "date": "2015-10-20T18:26:54Z"}, "committer": {"name": "Vikas Kumar", "email": "kr.vikas@gmail.com", "date": "2015-10-20T18:26:54Z"}, "message": "Fixups from review comments\n\n1. Moved common check `in_external_macro` to the top of function from inside each\nconditionals.\n2. Inlined `is_bool_expr` call", "tree": {"sha": "60f5afbc4358b7dce820b82339f305123aae9da6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60f5afbc4358b7dce820b82339f305123aae9da6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e78fbbf57e5bf5891c116a3c1bf287212744efa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e78fbbf57e5bf5891c116a3c1bf287212744efa", "html_url": "https://github.com/rust-lang/rust/commit/5e78fbbf57e5bf5891c116a3c1bf287212744efa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e78fbbf57e5bf5891c116a3c1bf287212744efa/comments", "author": {"login": "kvikas", "id": 1178022, "node_id": "MDQ6VXNlcjExNzgwMjI=", "avatar_url": "https://avatars.githubusercontent.com/u/1178022?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kvikas", "html_url": "https://github.com/kvikas", "followers_url": "https://api.github.com/users/kvikas/followers", "following_url": "https://api.github.com/users/kvikas/following{/other_user}", "gists_url": "https://api.github.com/users/kvikas/gists{/gist_id}", "starred_url": "https://api.github.com/users/kvikas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kvikas/subscriptions", "organizations_url": "https://api.github.com/users/kvikas/orgs", "repos_url": "https://api.github.com/users/kvikas/repos", "events_url": "https://api.github.com/users/kvikas/events{/privacy}", "received_events_url": "https://api.github.com/users/kvikas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kvikas", "id": 1178022, "node_id": "MDQ6VXNlcjExNzgwMjI=", "avatar_url": "https://avatars.githubusercontent.com/u/1178022?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kvikas", "html_url": "https://github.com/kvikas", "followers_url": "https://api.github.com/users/kvikas/followers", "following_url": "https://api.github.com/users/kvikas/following{/other_user}", "gists_url": "https://api.github.com/users/kvikas/gists{/gist_id}", "starred_url": "https://api.github.com/users/kvikas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kvikas/subscriptions", "organizations_url": "https://api.github.com/users/kvikas/orgs", "repos_url": "https://api.github.com/users/kvikas/repos", "events_url": "https://api.github.com/users/kvikas/events{/privacy}", "received_events_url": "https://api.github.com/users/kvikas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "675c532eabadeb5e203e71336a50fbf70f7decde", "url": "https://api.github.com/repos/rust-lang/rust/commits/675c532eabadeb5e203e71336a50fbf70f7decde", "html_url": "https://github.com/rust-lang/rust/commit/675c532eabadeb5e203e71336a50fbf70f7decde"}], "stats": {"total": 13, "additions": 4, "deletions": 9}, "files": [{"sha": "da770c6f484808e3752201f529b664d04fbf431f", "filename": "src/matches.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5e78fbbf57e5bf5891c116a3c1bf287212744efa/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e78fbbf57e5bf5891c116a3c1bf287212744efa/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=5e78fbbf57e5bf5891c116a3c1bf287212744efa", "patch": "@@ -25,6 +25,8 @@ impl LintPass for MatchPass {\n impl LateLintPass for MatchPass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprMatch(ref ex, ref arms, MatchSource::Normal) = expr.node {\n+            if in_external_macro(cx, expr.span) { return; }\n+\n             // check preconditions for SINGLE_MATCH\n                 // only two arms\n             if arms.len() == 2 &&\n@@ -39,7 +41,6 @@ impl LateLintPass for MatchPass {\n                 // finally, we don't want any content in the second arm (unit or empty block)\n                 is_unit_expr(&arms[1].body)\n             {\n-                if in_external_macro(cx, expr.span) {return;}\n                 span_help_and_lint(cx, SINGLE_MATCH, expr.span,\n                                    \"you seem to be trying to use match for destructuring a \\\n                                     single pattern. Consider using `if let`\",\n@@ -51,7 +52,6 @@ impl LateLintPass for MatchPass {\n \n             // check preconditions for MATCH_REF_PATS\n             if has_only_ref_pats(arms) {\n-                if in_external_macro(cx, expr.span) { return; }\n                 if let ExprAddrOf(Mutability::MutImmutable, ref inner) = ex.node {\n                     span_lint(cx, MATCH_REF_PATS, expr.span, &format!(\n                         \"you don't need to add `&` to both the expression to match \\\n@@ -65,12 +65,11 @@ impl LateLintPass for MatchPass {\n \n             // check preconditions for MATCH_BOOL\n             // type of expression == bool\n-            if is_bool_expr(cx, ex) {\n-                if in_external_macro(cx, expr.span) { return; }\n+            if cx.tcx.expr_ty(ex).sty == ty::TyBool {\n \n                 span_lint(cx, MATCH_BOOL, expr.span,\n                                    \"you seem to be trying to match on a boolean expression. \\\n-                                   Consider using if..else block\");\n+                                   Consider using an if..else block\");\n             }\n         }\n     }\n@@ -84,10 +83,6 @@ fn is_unit_expr(expr: &Expr) -> bool {\n     }\n }\n \n-fn is_bool_expr(cx: &LateContext, ex: &Expr ) -> bool {\n-    cx.tcx.expr_ty(ex).sty == ty::TyBool\n-}\n-\n fn has_only_ref_pats(arms: &[Arm]) -> bool {\n     let mapped = arms.iter().flat_map(|a| &a.pats).map(|p| match p.node {\n         PatRegion(..) => Some(true),  // &-patterns"}]}