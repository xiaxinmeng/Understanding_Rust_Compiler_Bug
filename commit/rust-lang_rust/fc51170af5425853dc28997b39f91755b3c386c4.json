{"sha": "fc51170af5425853dc28997b39f91755b3c386c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjNTExNzBhZjU0MjU4NTNkYzI4OTk3YjM5ZjkxNzU1YjNjMzg2YzQ=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-02-13T20:28:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-13T20:28:05Z"}, "message": "Rollup merge of #69057 - Centril:clean-expand, r=petrochenkov\n\nexpand: misc cleanups and simplifications\n\nSome work I did while trying to understand expand for the purposes of https://github.com/rust-lang/rust/issues/64197.\n\nr? @petrochenkov", "tree": {"sha": "8095033a92f8671ee08f2766797758520a0886bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8095033a92f8671ee08f2766797758520a0886bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc51170af5425853dc28997b39f91755b3c386c4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeRbFVCRBK7hj4Ov3rIwAAdHIIABo+L3kaHeK3gCMwG3NCThT+\nYb1+og87lcLvRpg8xaYWyozQvNEhPNzcQ9Isum9eJ87QKpv+O4hMU5Rw9TpffAO2\n9RbvrQcgmVwhbdUiuRvDqi47eU8WlREY9anGQi8bn77rGNcdNQlBxyJgG9YR77q2\nsVlXhBgUCkW1M9Xam5jVH4NsMoTEmOUl6Y/wyGyo130CcKlXXGQUfrADDA6QsHl/\nLMQv5otxvlWx11H6fLEHcxckcnyHvUN5BhreJNj+15k9V60GUt39+tkU+Xo8Bvns\npPU1PKOILFI8eixjn7kyk3KHqll7fe7LTqVO4v5eJsPmUu2f/hIpafWIV49t7Qw=\n=AtWV\n-----END PGP SIGNATURE-----\n", "payload": "tree 8095033a92f8671ee08f2766797758520a0886bd\nparent 998daf36b9b71549af6606fac8a30c39c21d9218\nparent ec434500157c47143a9b5600a7e34522c49f4e8e\nauthor Dylan DPC <dylan.dpc@gmail.com> 1581625685 +0100\ncommitter GitHub <noreply@github.com> 1581625685 +0100\n\nRollup merge of #69057 - Centril:clean-expand, r=petrochenkov\n\nexpand: misc cleanups and simplifications\n\nSome work I did while trying to understand expand for the purposes of https://github.com/rust-lang/rust/issues/64197.\n\nr? @petrochenkov\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc51170af5425853dc28997b39f91755b3c386c4", "html_url": "https://github.com/rust-lang/rust/commit/fc51170af5425853dc28997b39f91755b3c386c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc51170af5425853dc28997b39f91755b3c386c4/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "998daf36b9b71549af6606fac8a30c39c21d9218", "url": "https://api.github.com/repos/rust-lang/rust/commits/998daf36b9b71549af6606fac8a30c39c21d9218", "html_url": "https://github.com/rust-lang/rust/commit/998daf36b9b71549af6606fac8a30c39c21d9218"}, {"sha": "ec434500157c47143a9b5600a7e34522c49f4e8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec434500157c47143a9b5600a7e34522c49f4e8e", "html_url": "https://github.com/rust-lang/rust/commit/ec434500157c47143a9b5600a7e34522c49f4e8e"}], "stats": {"total": 208, "additions": 94, "deletions": 114}, "files": [{"sha": "371d1f744dd25755b0872f713f0b450d5eedac81", "filename": "src/librustc_expand/expand.rs", "status": "modified", "additions": 60, "deletions": 59, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/fc51170af5425853dc28997b39f91755b3c386c4/src%2Flibrustc_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc51170af5425853dc28997b39f91755b3c386c4/src%2Flibrustc_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fexpand.rs?ref=fc51170af5425853dc28997b39f91755b3c386c4", "patch": "@@ -451,28 +451,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         _ => unreachable!(),\n                     };\n                     if !item.derive_allowed() {\n-                        let attr = attr::find_by_name(item.attrs(), sym::derive)\n-                            .expect(\"`derive` attribute should exist\");\n-                        let span = attr.span;\n-                        let mut err = self.cx.struct_span_err(\n-                            span,\n-                            \"`derive` may only be applied to structs, enums and unions\",\n-                        );\n-                        if let ast::AttrStyle::Inner = attr.style {\n-                            let trait_list = derives\n-                                .iter()\n-                                .map(|t| pprust::path_to_string(t))\n-                                .collect::<Vec<_>>();\n-                            let suggestion = format!(\"#[derive({})]\", trait_list.join(\", \"));\n-                            err.span_suggestion(\n-                                span,\n-                                \"try an outer attribute\",\n-                                suggestion,\n-                                // We don't \ud835\udc58\ud835\udc5b\ud835\udc5c\ud835\udc64 that the following item is an ADT\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        }\n-                        err.emit();\n+                        self.error_derive_forbidden_on_non_adt(&derives, &item);\n                     }\n \n                     let mut item = self.fully_configure(item);\n@@ -521,6 +500,27 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         fragment_with_placeholders\n     }\n \n+    fn error_derive_forbidden_on_non_adt(&self, derives: &[Path], item: &Annotatable) {\n+        let attr =\n+            attr::find_by_name(item.attrs(), sym::derive).expect(\"`derive` attribute should exist\");\n+        let span = attr.span;\n+        let mut err = self\n+            .cx\n+            .struct_span_err(span, \"`derive` may only be applied to structs, enums and unions\");\n+        if let ast::AttrStyle::Inner = attr.style {\n+            let trait_list = derives.iter().map(|t| pprust::path_to_string(t)).collect::<Vec<_>>();\n+            let suggestion = format!(\"#[derive({})]\", trait_list.join(\", \"));\n+            err.span_suggestion(\n+                span,\n+                \"try an outer attribute\",\n+                suggestion,\n+                // We don't \ud835\udc58\ud835\udc5b\ud835\udc5c\ud835\udc64 that the following item is an ADT\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+        err.emit();\n+    }\n+\n     fn resolve_imports(&mut self) {\n         if self.monotonic {\n             self.cx.resolver.resolve_imports();\n@@ -606,21 +606,38 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n     }\n \n-    fn expand_invoc(&mut self, invoc: Invocation, ext: &SyntaxExtensionKind) -> AstFragment {\n-        if self.cx.current_expansion.depth > self.cx.ecfg.recursion_limit {\n-            let expn_data = self.cx.current_expansion.id.expn_data();\n-            let suggested_limit = self.cx.ecfg.recursion_limit * 2;\n-            let mut err = self.cx.struct_span_err(\n+    fn error_recursion_limit_reached(&mut self) {\n+        let expn_data = self.cx.current_expansion.id.expn_data();\n+        let suggested_limit = self.cx.ecfg.recursion_limit * 2;\n+        self.cx\n+            .struct_span_err(\n                 expn_data.call_site,\n                 &format!(\"recursion limit reached while expanding `{}`\", expn_data.kind.descr()),\n-            );\n-            err.help(&format!(\n+            )\n+            .help(&format!(\n                 \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate (`{}`)\",\n                 suggested_limit, self.cx.ecfg.crate_name,\n-            ));\n-            err.emit();\n-            self.cx.trace_macros_diag();\n-            FatalError.raise();\n+            ))\n+            .emit();\n+        self.cx.trace_macros_diag();\n+        FatalError.raise();\n+    }\n+\n+    /// A macro's expansion does not fit in this fragment kind.\n+    /// For example, a non-type macro in a type position.\n+    fn error_wrong_fragment_kind(&mut self, kind: AstFragmentKind, mac: &ast::Mac, span: Span) {\n+        let msg = format!(\n+            \"non-{kind} macro in {kind} position: {path}\",\n+            kind = kind.name(),\n+            path = pprust::path_to_string(&mac.path),\n+        );\n+        self.cx.span_err(span, &msg);\n+        self.cx.trace_macros_diag();\n+    }\n+\n+    fn expand_invoc(&mut self, invoc: Invocation, ext: &SyntaxExtensionKind) -> AstFragment {\n+        if self.cx.current_expansion.depth > self.cx.ecfg.recursion_limit {\n+            self.error_recursion_limit_reached();\n         }\n \n         let (fragment_kind, span) = (invoc.fragment_kind, invoc.span());\n@@ -638,13 +655,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     let result = if let Some(result) = fragment_kind.make_from(tok_result) {\n                         result\n                     } else {\n-                        let msg = format!(\n-                            \"non-{kind} macro in {kind} position: {path}\",\n-                            kind = fragment_kind.name(),\n-                            path = pprust::path_to_string(&mac.path),\n-                        );\n-                        self.cx.span_err(span, &msg);\n-                        self.cx.trace_macros_diag();\n+                        self.error_wrong_fragment_kind(fragment_kind, &mac, span);\n                         fragment_kind.dummy(span)\n                     };\n                     self.cx.current_expansion.prior_type_ascription = prev;\n@@ -1030,13 +1041,10 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     }\n \n     /// If `item` is an attr invocation, remove and return the macro attribute and derive traits.\n-    fn classify_item<T>(\n+    fn classify_item(\n         &mut self,\n-        item: &mut T,\n-    ) -> (Option<ast::Attribute>, Vec<Path>, /* after_derive */ bool)\n-    where\n-        T: HasAttrs,\n-    {\n+        item: &mut impl HasAttrs,\n+    ) -> (Option<ast::Attribute>, Vec<Path>, /* after_derive */ bool) {\n         let (mut attr, mut traits, mut after_derive) = (None, Vec::new(), false);\n \n         item.visit_attrs(|mut attrs| {\n@@ -1050,9 +1058,9 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     /// Alternative to `classify_item()` that ignores `#[derive]` so invocations fallthrough\n     /// to the unused-attributes lint (making it an error on statements and expressions\n     /// is a breaking change)\n-    fn classify_nonitem<T: HasAttrs>(\n+    fn classify_nonitem(\n         &mut self,\n-        nonitem: &mut T,\n+        nonitem: &mut impl HasAttrs,\n     ) -> (Option<ast::Attribute>, /* after_derive */ bool) {\n         let (mut attr, mut after_derive) = (None, false);\n \n@@ -1375,21 +1383,14 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                     _ => unreachable!(),\n                 })\n             }\n-            ast::ItemKind::Mod(ast::Mod { inner, .. }) => {\n-                if item.ident == Ident::invalid() {\n-                    return noop_flat_map_item(item, self);\n-                }\n-\n+            ast::ItemKind::Mod(ast::Mod { inner, inline, .. })\n+                if item.ident != Ident::invalid() =>\n+            {\n                 let orig_directory_ownership = self.cx.current_expansion.directory_ownership;\n                 let mut module = (*self.cx.current_expansion.module).clone();\n                 module.mod_path.push(item.ident);\n \n-                // Detect if this is an inline module (`mod m { ... }` as opposed to `mod m;`).\n-                // In the non-inline case, `inner` is never the dummy span (cf. `parse_item_mod`).\n-                // Thus, if `inner` is the dummy span, we know the module is inline.\n-                let inline_module = item.span.contains(inner) || inner.is_dummy();\n-\n-                if inline_module {\n+                if inline {\n                     if let Some(path) = attr::first_attr_value_str_by_name(&item.attrs, sym::path) {\n                         self.cx.current_expansion.directory_ownership =\n                             DirectoryOwnership::Owned { relative: None };"}, {"sha": "ec0d251a3f8df7fa545444811c9209c5c9550fe0", "filename": "src/librustc_parse/config.rs", "status": "modified", "additions": 34, "deletions": 55, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/fc51170af5425853dc28997b39f91755b3c386c4/src%2Flibrustc_parse%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc51170af5425853dc28997b39f91755b3c386c4/src%2Flibrustc_parse%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fconfig.rs?ref=fc51170af5425853dc28997b39f91755b3c386c4", "patch": "@@ -207,30 +207,29 @@ pub fn features(\n     edition: Edition,\n     allow_features: &Option<Vec<String>>,\n ) -> (ast::Crate, Features) {\n-    let features;\n-    {\n-        let mut strip_unconfigured = StripUnconfigured { sess, features: None };\n+    let mut strip_unconfigured = StripUnconfigured { sess, features: None };\n \n-        let unconfigured_attrs = krate.attrs.clone();\n-        let err_count = sess.span_diagnostic.err_count();\n-        if let Some(attrs) = strip_unconfigured.configure(krate.attrs) {\n-            krate.attrs = attrs;\n-        } else {\n-            // the entire crate is unconfigured\n+    let unconfigured_attrs = krate.attrs.clone();\n+    let diag = &sess.span_diagnostic;\n+    let err_count = diag.err_count();\n+    let features = match strip_unconfigured.configure(krate.attrs) {\n+        None => {\n+            // The entire crate is unconfigured.\n             krate.attrs = Vec::new();\n             krate.module.items = Vec::new();\n-            return (krate, Features::default());\n+            Features::default()\n         }\n-\n-        features = get_features(&sess.span_diagnostic, &krate.attrs, edition, allow_features);\n-\n-        // Avoid reconfiguring malformed `cfg_attr`s\n-        if err_count == sess.span_diagnostic.err_count() {\n-            strip_unconfigured.features = Some(&features);\n-            strip_unconfigured.configure(unconfigured_attrs);\n+        Some(attrs) => {\n+            krate.attrs = attrs;\n+            let features = get_features(diag, &krate.attrs, edition, allow_features);\n+            if err_count == diag.err_count() {\n+                // Avoid reconfiguring malformed `cfg_attr`s.\n+                strip_unconfigured.features = Some(&features);\n+                strip_unconfigured.configure(unconfigured_attrs);\n+            }\n+            features\n         }\n-    }\n-\n+    };\n     (krate, features)\n }\n \n@@ -347,7 +346,13 @@ impl<'a> StripUnconfigured<'a> {\n             if !is_cfg(attr) {\n                 return true;\n             }\n-\n+            let meta_item = match validate_attr::parse_meta(self.sess, attr) {\n+                Ok(meta_item) => meta_item,\n+                Err(mut err) => {\n+                    err.emit();\n+                    return true;\n+                }\n+            };\n             let error = |span, msg, suggestion: &str| {\n                 let mut err = self.sess.span_diagnostic.struct_span_err(span, msg);\n                 if !suggestion.is_empty() {\n@@ -361,41 +366,15 @@ impl<'a> StripUnconfigured<'a> {\n                 err.emit();\n                 true\n             };\n-\n-            let meta_item = match validate_attr::parse_meta(self.sess, attr) {\n-                Ok(meta_item) => meta_item,\n-                Err(mut err) => {\n-                    err.emit();\n-                    return true;\n-                }\n-            };\n-            let nested_meta_items = if let Some(nested_meta_items) = meta_item.meta_item_list() {\n-                nested_meta_items\n-            } else {\n-                return error(\n-                    meta_item.span,\n-                    \"`cfg` is not followed by parentheses\",\n-                    \"cfg(/* predicate */)\",\n-                );\n-            };\n-\n-            if nested_meta_items.is_empty() {\n-                return error(meta_item.span, \"`cfg` predicate is not specified\", \"\");\n-            } else if nested_meta_items.len() > 1 {\n-                return error(\n-                    nested_meta_items.last().unwrap().span(),\n-                    \"multiple `cfg` predicates are specified\",\n-                    \"\",\n-                );\n-            }\n-\n-            match nested_meta_items[0].meta_item() {\n-                Some(meta_item) => attr::cfg_matches(meta_item, self.sess, self.features),\n-                None => error(\n-                    nested_meta_items[0].span(),\n-                    \"`cfg` predicate key cannot be a literal\",\n-                    \"\",\n-                ),\n+            let span = meta_item.span;\n+            match meta_item.meta_item_list() {\n+                None => error(span, \"`cfg` is not followed by parentheses\", \"cfg(/* predicate */)\"),\n+                Some([]) => error(span, \"`cfg` predicate is not specified\", \"\"),\n+                Some([_, .., l]) => error(l.span(), \"multiple `cfg` predicates are specified\", \"\"),\n+                Some([single]) => match single.meta_item() {\n+                    Some(meta_item) => attr::cfg_matches(meta_item, self.sess, self.features),\n+                    None => error(single.span(), \"`cfg` predicate key cannot be a literal\", \"\"),\n+                },\n             }\n         })\n     }"}]}