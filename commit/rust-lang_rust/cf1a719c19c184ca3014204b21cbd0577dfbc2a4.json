{"sha": "cf1a719c19c184ca3014204b21cbd0577dfbc2a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmMWE3MTljMTljMTg0Y2EzMDE0MjA0YjIxY2JkMDU3N2RmYmMyYTQ=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-03-09T16:54:50Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-05-01T22:10:57Z"}, "message": "Implement fold_const for BoundVarReplacer", "tree": {"sha": "779d0d5ee5986b28d5dd8fe3542069242dd1e4fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/779d0d5ee5986b28d5dd8fe3542069242dd1e4fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf1a719c19c184ca3014204b21cbd0577dfbc2a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf1a719c19c184ca3014204b21cbd0577dfbc2a4", "html_url": "https://github.com/rust-lang/rust/commit/cf1a719c19c184ca3014204b21cbd0577dfbc2a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf1a719c19c184ca3014204b21cbd0577dfbc2a4/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa394c2283b6bdfc87711812739a59da29a2fd2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa394c2283b6bdfc87711812739a59da29a2fd2a", "html_url": "https://github.com/rust-lang/rust/commit/fa394c2283b6bdfc87711812739a59da29a2fd2a"}], "stats": {"total": 99, "additions": 81, "deletions": 18}, "files": [{"sha": "6b716d6c3b8ea2831cb104277f59674f7117a5a6", "filename": "src/librustc/infer/canonical/substitute.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cf1a719c19c184ca3014204b21cbd0577dfbc2a4/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf1a719c19c184ca3014204b21cbd0577dfbc2a4/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=cf1a719c19c184ca3014204b21cbd0577dfbc2a4", "patch": "@@ -70,6 +70,13 @@ where\n             }\n         };\n \n-        tcx.replace_escaping_bound_vars(value, fld_r, fld_t).0\n+        let fld_c = |bound_ct: ty::BoundVar, _| {\n+            match var_values.var_values[bound_ct].unpack() {\n+                UnpackedKind::Const(ct) => ct,\n+                c => bug!(\"{:?} is a const but value is {:?}\", bound_ct, c),\n+            }\n+        };\n+\n+        tcx.replace_escaping_bound_vars(value, fld_r, fld_t, fld_c).0\n     }\n }"}, {"sha": "ec77bb39e7d2afd6a22a75c5aaf173e156c3a955", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cf1a719c19c184ca3014204b21cbd0577dfbc2a4/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf1a719c19c184ca3014204b21cbd0577dfbc2a4/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=cf1a719c19c184ca3014204b21cbd0577dfbc2a4", "patch": "@@ -4,10 +4,12 @@\n use super::combine::CombineFields;\n use super::{HigherRankedType, InferCtxt, PlaceholderMap};\n \n-use crate::infer::CombinedSnapshot;\n+use crate::infer::{CombinedSnapshot, ConstVariableOrigin};\n use crate::ty::relate::{Relate, RelateResult, TypeRelation};\n use crate::ty::{self, Binder, TypeFoldable};\n \n+use syntax_pos::DUMMY_SP;\n+\n impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n     pub fn higher_ranked_sub<T>(\n         &mut self,\n@@ -99,7 +101,16 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }))\n         };\n \n-        let (result, map) = self.tcx.replace_bound_vars(binder, fld_r, fld_t);\n+        let fld_c = |_: ty::BoundVar, ty| {\n+            self.next_const_var_in_universe(\n+                ty,\n+                // FIXME(const_generics): do we want a placeholder const?\n+                ConstVariableOrigin::MiscVariable(DUMMY_SP),\n+                next_universe,\n+            )\n+        };\n+\n+        let (result, map) = self.tcx.replace_bound_vars(binder, fld_r, fld_t, fld_c);\n \n         debug!(\n             \"replace_bound_vars_with_placeholders(\\"}, {"sha": "80816100faed7885d962672bbdb30293229d64c1", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf1a719c19c184ca3014204b21cbd0577dfbc2a4/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf1a719c19c184ca3014204b21cbd0577dfbc2a4/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=cf1a719c19c184ca3014204b21cbd0577dfbc2a4", "patch": "@@ -1476,7 +1476,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     {\n         let fld_r = |br| self.next_region_var(LateBoundRegion(span, br, lbrct));\n         let fld_t = |_| self.next_ty_var(TypeVariableOrigin::MiscVariable(span));\n-        self.tcx.replace_bound_vars(value, fld_r, fld_t)\n+        let fld_c = |_, ty| self.next_const_var(ty, ConstVariableOrigin::MiscVariable(span));\n+        self.tcx.replace_bound_vars(value, fld_r, fld_t, fld_c)\n     }\n \n     /// See the [`region_constraints::verify_generic_bound`] method."}, {"sha": "13b5885f51d293db21aa150f845b1408807bf262", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 58, "deletions": 14, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/cf1a719c19c184ca3014204b21cbd0577dfbc2a4/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf1a719c19c184ca3014204b21cbd0577dfbc2a4/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=cf1a719c19c184ca3014204b21cbd0577dfbc2a4", "patch": "@@ -431,22 +431,26 @@ struct BoundVarReplacer<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n \n     fld_r: &'a mut (dyn FnMut(ty::BoundRegion) -> ty::Region<'tcx> + 'a),\n     fld_t: &'a mut (dyn FnMut(ty::BoundTy) -> Ty<'tcx> + 'a),\n+    fld_c: &'a mut (dyn FnMut(ty::BoundVar, Ty<'tcx>) -> &'tcx ty::LazyConst<'tcx> + 'a),\n }\n \n impl<'a, 'gcx, 'tcx> BoundVarReplacer<'a, 'gcx, 'tcx> {\n-    fn new<F, G>(\n+    fn new<F, G, H>(\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         fld_r: &'a mut F,\n-        fld_t: &'a mut G\n+        fld_t: &'a mut G,\n+        fld_c: &'a mut H,\n     ) -> Self\n         where F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n-              G: FnMut(ty::BoundTy) -> Ty<'tcx>\n+              G: FnMut(ty::BoundTy) -> Ty<'tcx>,\n+              H: FnMut(ty::BoundVar, Ty<'tcx>) -> &'tcx ty::LazyConst<'tcx>,\n     {\n         BoundVarReplacer {\n             tcx,\n             current_index: ty::INNERMOST,\n             fld_r,\n             fld_t,\n+            fld_c,\n         }\n     }\n }\n@@ -508,7 +512,29 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for BoundVarReplacer<'a, 'gcx, 'tcx>\n     }\n \n     fn fold_const(&mut self, ct: &'tcx ty::LazyConst<'tcx>) -> &'tcx ty::LazyConst<'tcx> {\n-        ct // FIXME(const_generics)\n+        if let ty::LazyConst::Evaluated(ty::Const {\n+            val: ConstValue::Infer(ty::InferConst::Canonical(debruijn, bound_const)),\n+            ty,\n+        }) = *ct {\n+            if debruijn == self.current_index {\n+                let fld_c = &mut self.fld_c;\n+                let ct = fld_c(bound_const, ty);\n+                ty::fold::shift_vars(\n+                    self.tcx,\n+                    &ct,\n+                    self.current_index.as_u32()\n+                )\n+            } else {\n+                ct\n+            }\n+        } else {\n+            if !ct.has_vars_bound_at_or_above(self.current_index) {\n+                // Nothing more to substitute.\n+                ct\n+            } else {\n+                ct.super_fold_with(self)\n+            }\n+        }\n     }\n }\n \n@@ -532,27 +558,34 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         where F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n               T: TypeFoldable<'tcx>\n     {\n-        // identity for bound types\n+        // identity for bound types and consts\n         let fld_t = |bound_ty| self.mk_ty(ty::Bound(ty::INNERMOST, bound_ty));\n-        self.replace_escaping_bound_vars(value.skip_binder(), fld_r, fld_t)\n+        let fld_c = |bound_ct, ty| {\n+            self.mk_const_infer(ty::InferConst::Canonical(ty::INNERMOST, bound_ct), ty)\n+        };\n+        self.replace_escaping_bound_vars(value.skip_binder(), fld_r, fld_t, fld_c)\n     }\n \n     /// Replaces all escaping bound vars. The `fld_r` closure replaces escaping\n-    /// bound regions while the `fld_t` closure replaces escaping bound types.\n-    pub fn replace_escaping_bound_vars<T, F, G>(\n+    /// bound regions; the `fld_t` closure replaces escaping bound types and the `fld_c`\n+    /// closure replaces escaping bound consts.\n+    pub fn replace_escaping_bound_vars<T, F, G, H>(\n         self,\n         value: &T,\n         mut fld_r: F,\n-        mut fld_t: G\n+        mut fld_t: G,\n+        mut fld_c: H,\n     ) -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n         where F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n               G: FnMut(ty::BoundTy) -> Ty<'tcx>,\n-              T: TypeFoldable<'tcx>\n+              H: FnMut(ty::BoundVar, Ty<'tcx>) -> &'tcx ty::LazyConst<'tcx>,\n+              T: TypeFoldable<'tcx>,\n     {\n         use rustc_data_structures::fx::FxHashMap;\n \n         let mut region_map = BTreeMap::new();\n         let mut type_map = FxHashMap::default();\n+        let mut const_map = FxHashMap::default();\n \n         if !value.has_escaping_bound_vars() {\n             (value.clone(), region_map)\n@@ -565,7 +598,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 *type_map.entry(bound_ty).or_insert_with(|| fld_t(bound_ty))\n             };\n \n-            let mut replacer = BoundVarReplacer::new(self, &mut real_fld_r, &mut real_fld_t);\n+            let mut real_fld_c = |bound_ct, ty| {\n+                *const_map.entry(bound_ct).or_insert_with(|| fld_c(bound_ct, ty))\n+            };\n+\n+            let mut replacer = BoundVarReplacer::new(\n+                self,\n+                &mut real_fld_r,\n+                &mut real_fld_t,\n+                &mut real_fld_c,\n+            );\n             let result = value.fold_with(&mut replacer);\n             (result, region_map)\n         }\n@@ -574,17 +616,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Replaces all types or regions bound by the given `Binder`. The `fld_r`\n     /// closure replaces bound regions while the `fld_t` closure replaces bound\n     /// types.\n-    pub fn replace_bound_vars<T, F, G>(\n+    pub fn replace_bound_vars<T, F, G, H>(\n         self,\n         value: &Binder<T>,\n         fld_r: F,\n-        fld_t: G\n+        fld_t: G,\n+        fld_c: H,\n     ) -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n         where F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n               G: FnMut(ty::BoundTy) -> Ty<'tcx>,\n+              H: FnMut(ty::BoundVar, Ty<'tcx>) -> &'tcx ty::LazyConst<'tcx>,\n               T: TypeFoldable<'tcx>\n     {\n-        self.replace_escaping_bound_vars(value.skip_binder(), fld_r, fld_t)\n+        self.replace_escaping_bound_vars(value.skip_binder(), fld_r, fld_t, fld_c)\n     }\n \n     /// Replaces any late-bound regions bound in `value` with"}]}