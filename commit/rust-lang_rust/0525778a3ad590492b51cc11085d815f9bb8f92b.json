{"sha": "0525778a3ad590492b51cc11085d815f9bb8f92b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1MjU3NzhhM2FkNTkwNDkyYjUxY2MxMTA4NWQ4MTVmOWJiOGY5MmI=", "commit": {"author": {"name": "Seivan Heidari", "email": "seivan.heidari@icloud.com", "date": "2019-11-12T18:04:54Z"}, "committer": {"name": "Seivan Heidari", "email": "seivan.heidari@icloud.com", "date": "2019-11-12T18:04:54Z"}, "message": "Merge branch 'master' of https://github.com/rust-analyzer/rust-analyzer into feature/themes", "tree": {"sha": "56096932b19861ab86c9564717f88cf7cd86d023", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56096932b19861ab86c9564717f88cf7cd86d023"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0525778a3ad590492b51cc11085d815f9bb8f92b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0525778a3ad590492b51cc11085d815f9bb8f92b", "html_url": "https://github.com/rust-lang/rust/commit/0525778a3ad590492b51cc11085d815f9bb8f92b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0525778a3ad590492b51cc11085d815f9bb8f92b/comments", "author": {"login": "seivan", "id": 55424, "node_id": "MDQ6VXNlcjU1NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/55424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seivan", "html_url": "https://github.com/seivan", "followers_url": "https://api.github.com/users/seivan/followers", "following_url": "https://api.github.com/users/seivan/following{/other_user}", "gists_url": "https://api.github.com/users/seivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/seivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seivan/subscriptions", "organizations_url": "https://api.github.com/users/seivan/orgs", "repos_url": "https://api.github.com/users/seivan/repos", "events_url": "https://api.github.com/users/seivan/events{/privacy}", "received_events_url": "https://api.github.com/users/seivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "seivan", "id": 55424, "node_id": "MDQ6VXNlcjU1NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/55424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seivan", "html_url": "https://github.com/seivan", "followers_url": "https://api.github.com/users/seivan/followers", "following_url": "https://api.github.com/users/seivan/following{/other_user}", "gists_url": "https://api.github.com/users/seivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/seivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seivan/subscriptions", "organizations_url": "https://api.github.com/users/seivan/orgs", "repos_url": "https://api.github.com/users/seivan/repos", "events_url": "https://api.github.com/users/seivan/events{/privacy}", "received_events_url": "https://api.github.com/users/seivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11755f3eff87cd8ee0af7961377e0ae3ffea5050", "url": "https://api.github.com/repos/rust-lang/rust/commits/11755f3eff87cd8ee0af7961377e0ae3ffea5050", "html_url": "https://github.com/rust-lang/rust/commit/11755f3eff87cd8ee0af7961377e0ae3ffea5050"}, {"sha": "3322d65addd9ec61b8c5bc055803f6549946da8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3322d65addd9ec61b8c5bc055803f6549946da8b", "html_url": "https://github.com/rust-lang/rust/commit/3322d65addd9ec61b8c5bc055803f6549946da8b"}], "stats": {"total": 1521, "additions": 842, "deletions": 679}, "files": [{"sha": "51d953f6e896a7c34f2172ac4cfd731692a629e2", "filename": "crates/ra_cfg/src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_cfg%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_cfg%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cfg%2Fsrc%2Flib.rs?ref=0525778a3ad590492b51cc11085d815f9bb8f92b", "patch": "@@ -1,11 +1,12 @@\n //! ra_cfg defines conditional compiling options, `cfg` attibute parser and evaluator\n+\n+mod cfg_expr;\n+\n use std::iter::IntoIterator;\n \n use ra_syntax::SmolStr;\n use rustc_hash::FxHashSet;\n \n-mod cfg_expr;\n-\n pub use cfg_expr::{parse_cfg, CfgExpr};\n \n /// Configuration options used for conditional compilition on items with `cfg` attributes."}, {"sha": "ee883b615457f48fcbffaef9bf2c284bb54a7205", "filename": "crates/ra_db/src/fixture.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Ffixture.rs?ref=0525778a3ad590492b51cc11085d815f9bb8f92b", "patch": "@@ -1,5 +1,6 @@\n //! FIXME: write short doc here\n \n+use std::str::FromStr;\n use std::sync::Arc;\n \n use ra_cfg::CfgOptions;\n@@ -164,7 +165,7 @@ fn parse_meta(meta: &str) -> ParsedMeta {\n         match key {\n             \"crate\" => krate = Some(value.to_string()),\n             \"deps\" => deps = value.split(',').map(|it| it.to_string()).collect(),\n-            \"edition\" => edition = Edition::from_string(&value),\n+            \"edition\" => edition = Edition::from_str(&value).unwrap(),\n             \"cfg\" => {\n                 for key in value.split(',') {\n                     match split1(key, '=') {"}, {"sha": "c0d95a13fa1bfbdcdb52a3625e9a652ede8ebacf", "filename": "crates/ra_db/src/input.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Finput.rs?ref=0525778a3ad590492b51cc11085d815f9bb8f92b", "patch": "@@ -13,6 +13,7 @@ use ra_syntax::SmolStr;\n use rustc_hash::FxHashSet;\n \n use crate::{RelativePath, RelativePathBuf};\n+use std::str::FromStr;\n \n /// `FileId` is an integer which uniquely identifies a file. File paths are\n /// messy and system-dependent, so most of the code should work directly with\n@@ -97,12 +98,18 @@ pub enum Edition {\n     Edition2015,\n }\n \n-impl Edition {\n-    //FIXME: replace with FromStr with proper error handling\n-    pub fn from_string(s: &str) -> Edition {\n+#[derive(Debug)]\n+pub struct ParseEditionError {\n+    pub msg: String,\n+}\n+\n+impl FromStr for Edition {\n+    type Err = ParseEditionError;\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n         match s {\n-            \"2015\" => Edition::Edition2015,\n-            \"2018\" | _ => Edition::Edition2018,\n+            \"2015\" => Ok(Edition::Edition2015),\n+            \"2018\" => Ok(Edition::Edition2018),\n+            _ => Err(ParseEditionError { msg: format!(\"unknown edition: {}\", s) }),\n         }\n     }\n }"}, {"sha": "a30ed4cbb863ea052a2a39392a215f12e823774e", "filename": "crates/ra_fmt/src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_fmt%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_fmt%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_fmt%2Fsrc%2Flib.rs?ref=0525778a3ad590492b51cc11085d815f9bb8f92b", "patch": "@@ -1,13 +1,14 @@\n //! This crate provides some utilities for indenting rust code.\n-//!\n+\n+use std::iter::successors;\n+\n use itertools::Itertools;\n use ra_syntax::{\n     ast::{self, AstNode, AstToken},\n     SmolStr, SyntaxKind,\n     SyntaxKind::*,\n     SyntaxNode, SyntaxToken, T,\n };\n-use std::iter::successors;\n \n pub fn reindent(text: &str, indent: &str) -> String {\n     let indent = format!(\"\\n{}\", indent);"}, {"sha": "2fd4ccb10902bab934b41e976f6b3780400bb67f", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=0525778a3ad590492b51cc11085d815f9bb8f92b", "patch": "@@ -550,7 +550,7 @@ where\n     }\n \n     fn body(self, db: &impl HirDatabase) -> Arc<Body> {\n-        db.body_hir(self.into())\n+        db.body(self.into())\n     }\n \n     fn body_source_map(self, db: &impl HirDatabase) -> Arc<BodySourceMap> {\n@@ -564,7 +564,7 @@ impl HasBody for DefWithBody {\n     }\n \n     fn body(self, db: &impl HirDatabase) -> Arc<Body> {\n-        db.body_hir(self)\n+        db.body(self)\n     }\n \n     fn body_source_map(self, db: &impl HirDatabase) -> Arc<BodySourceMap> {\n@@ -666,7 +666,7 @@ impl Function {\n     }\n \n     pub fn body(self, db: &impl HirDatabase) -> Arc<Body> {\n-        db.body_hir(self.into())\n+        db.body(self.into())\n     }\n \n     pub fn ty(self, db: &impl HirDatabase) -> Ty {\n@@ -1079,7 +1079,7 @@ pub struct Local {\n \n impl Local {\n     pub fn name(self, db: &impl HirDatabase) -> Option<Name> {\n-        let body = db.body_hir(self.parent);\n+        let body = db.body(self.parent);\n         match &body[self.pat_id] {\n             Pat::Bind { name, .. } => Some(name.clone()),\n             _ => None,\n@@ -1091,7 +1091,7 @@ impl Local {\n     }\n \n     pub fn is_mut(self, db: &impl HirDatabase) -> bool {\n-        let body = db.body_hir(self.parent);\n+        let body = db.body(self.parent);\n         match &body[self.pat_id] {\n             Pat::Bind { mode, .. } => match mode {\n                 BindingAnnotation::Mutable | BindingAnnotation::RefMut => true,"}, {"sha": "9ac811232fca4cca148d7006847c51bd0c84d29e", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=0525778a3ad590492b51cc11085d815f9bb8f92b", "patch": "@@ -8,6 +8,7 @@ use ra_syntax::SmolStr;\n \n use crate::{\n     debug::HirDebugDatabase,\n+    expr::{Body, BodySourceMap},\n     generics::{GenericDef, GenericParams},\n     ids,\n     impl_block::{ImplBlock, ImplSourceMap, ModuleImplBlocks},\n@@ -113,13 +114,10 @@ pub trait HirDatabase: DefDatabase + AstDatabase {\n     fn generic_defaults(&self, def: GenericDef) -> Substs;\n \n     #[salsa::invoke(crate::expr::body_with_source_map_query)]\n-    fn body_with_source_map(\n-        &self,\n-        def: DefWithBody,\n-    ) -> (Arc<crate::expr::Body>, Arc<crate::expr::BodySourceMap>);\n+    fn body_with_source_map(&self, def: DefWithBody) -> (Arc<Body>, Arc<BodySourceMap>);\n \n-    #[salsa::invoke(crate::expr::body_hir_query)]\n-    fn body_hir(&self, def: DefWithBody) -> Arc<crate::expr::Body>;\n+    #[salsa::invoke(crate::expr::body_query)]\n+    fn body(&self, def: DefWithBody) -> Arc<Body>;\n \n     #[salsa::invoke(crate::ty::method_resolution::CrateImplBlocks::impls_in_crate_query)]\n     fn impls_in_crate(&self, krate: Crate) -> Arc<CrateImplBlocks>;"}, {"sha": "82955fa55867fd897c36d5bc165c9262dffb7e71", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 35, "deletions": 536, "changes": 571, "blob_url": "https://github.com/rust-lang/rust/blob/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=0525778a3ad590492b51cc11085d815f9bb8f92b", "patch": "@@ -1,549 +1,24 @@\n //! FIXME: write short doc here\n \n-pub(crate) mod lower;\n pub(crate) mod scope;\n pub(crate) mod validation;\n \n-use std::{ops::Index, sync::Arc};\n+use std::sync::Arc;\n \n-use hir_def::{\n-    path::GenericArgs,\n-    type_ref::{Mutability, TypeRef},\n-};\n-use ra_arena::{impl_arena_id, map::ArenaMap, Arena, RawId};\n use ra_syntax::{ast, AstPtr};\n-use rustc_hash::FxHashMap;\n \n-use crate::{\n-    db::HirDatabase,\n-    ty::primitive::{UncertainFloatTy, UncertainIntTy},\n-    DefWithBody, Either, HasSource, Name, Path, Resolver, Source,\n-};\n+use crate::{db::HirDatabase, DefWithBody, HasSource, Resolver};\n \n pub use self::scope::ExprScopes;\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct ExprId(RawId);\n-impl_arena_id!(ExprId);\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct PatId(RawId);\n-impl_arena_id!(PatId);\n-\n-/// The body of an item (function, const etc.).\n-#[derive(Debug, Eq, PartialEq)]\n-pub struct Body {\n-    /// The def of the item this body belongs to\n-    owner: DefWithBody,\n-    exprs: Arena<ExprId, Expr>,\n-    pats: Arena<PatId, Pat>,\n-    /// The patterns for the function's parameters. While the parameter types are\n-    /// part of the function signature, the patterns are not (they don't change\n-    /// the external type of the function).\n-    ///\n-    /// If this `Body` is for the body of a constant, this will just be\n-    /// empty.\n-    params: Vec<PatId>,\n-    /// The `ExprId` of the actual body expression.\n-    body_expr: ExprId,\n-}\n-\n-type ExprPtr = Either<AstPtr<ast::Expr>, AstPtr<ast::RecordField>>;\n-type ExprSource = Source<ExprPtr>;\n-\n-type PatPtr = Either<AstPtr<ast::Pat>, AstPtr<ast::SelfParam>>;\n-type PatSource = Source<PatPtr>;\n-\n-/// An item body together with the mapping from syntax nodes to HIR expression\n-/// IDs. This is needed to go from e.g. a position in a file to the HIR\n-/// expression containing it; but for type inference etc., we want to operate on\n-/// a structure that is agnostic to the actual positions of expressions in the\n-/// file, so that we don't recompute types whenever some whitespace is typed.\n-///\n-/// One complication here is that, due to macro expansion, a single `Body` might\n-/// be spread across several files. So, for each ExprId and PatId, we record\n-/// both the HirFileId and the position inside the file. However, we only store\n-/// AST -> ExprId mapping for non-macro files, as it is not clear how to handle\n-/// this properly for macros.\n-#[derive(Default, Debug, Eq, PartialEq)]\n-pub struct BodySourceMap {\n-    expr_map: FxHashMap<ExprPtr, ExprId>,\n-    expr_map_back: ArenaMap<ExprId, ExprSource>,\n-    pat_map: FxHashMap<PatPtr, PatId>,\n-    pat_map_back: ArenaMap<PatId, PatSource>,\n-    field_map: FxHashMap<(ExprId, usize), AstPtr<ast::RecordField>>,\n-}\n-\n-impl Body {\n-    pub fn params(&self) -> &[PatId] {\n-        &self.params\n-    }\n-\n-    pub fn body_expr(&self) -> ExprId {\n-        self.body_expr\n-    }\n-\n-    pub fn owner(&self) -> DefWithBody {\n-        self.owner\n-    }\n-\n-    pub fn exprs(&self) -> impl Iterator<Item = (ExprId, &Expr)> {\n-        self.exprs.iter()\n-    }\n-\n-    pub fn pats(&self) -> impl Iterator<Item = (PatId, &Pat)> {\n-        self.pats.iter()\n-    }\n-}\n-\n-// needs arbitrary_self_types to be a method... or maybe move to the def?\n-pub(crate) fn resolver_for_expr(\n-    body: Arc<Body>,\n-    db: &impl HirDatabase,\n-    expr_id: ExprId,\n-) -> Resolver {\n-    let scopes = db.expr_scopes(body.owner);\n-    resolver_for_scope(body, db, scopes.scope_for(expr_id))\n-}\n-\n-pub(crate) fn resolver_for_scope(\n-    body: Arc<Body>,\n-    db: &impl HirDatabase,\n-    scope_id: Option<scope::ScopeId>,\n-) -> Resolver {\n-    let mut r = body.owner.resolver(db);\n-    let scopes = db.expr_scopes(body.owner);\n-    let scope_chain = scopes.scope_chain(scope_id).collect::<Vec<_>>();\n-    for scope in scope_chain.into_iter().rev() {\n-        r = r.push_expr_scope(Arc::clone(&scopes), scope);\n-    }\n-    r\n-}\n-\n-impl Index<ExprId> for Body {\n-    type Output = Expr;\n-\n-    fn index(&self, expr: ExprId) -> &Expr {\n-        &self.exprs[expr]\n-    }\n-}\n-\n-impl Index<PatId> for Body {\n-    type Output = Pat;\n-\n-    fn index(&self, pat: PatId) -> &Pat {\n-        &self.pats[pat]\n-    }\n-}\n-\n-impl BodySourceMap {\n-    pub(crate) fn expr_syntax(&self, expr: ExprId) -> Option<ExprSource> {\n-        self.expr_map_back.get(expr).copied()\n-    }\n-\n-    pub(crate) fn node_expr(&self, node: &ast::Expr) -> Option<ExprId> {\n-        self.expr_map.get(&Either::A(AstPtr::new(node))).cloned()\n-    }\n-\n-    pub(crate) fn pat_syntax(&self, pat: PatId) -> Option<PatSource> {\n-        self.pat_map_back.get(pat).copied()\n-    }\n-\n-    pub(crate) fn node_pat(&self, node: &ast::Pat) -> Option<PatId> {\n-        self.pat_map.get(&Either::A(AstPtr::new(node))).cloned()\n-    }\n-\n-    pub(crate) fn field_syntax(&self, expr: ExprId, field: usize) -> AstPtr<ast::RecordField> {\n-        self.field_map[&(expr, field)]\n-    }\n-}\n-\n-#[derive(Debug, Clone, Eq, PartialEq)]\n-pub enum Literal {\n-    String(String),\n-    ByteString(Vec<u8>),\n-    Char(char),\n-    Bool(bool),\n-    Int(u64, UncertainIntTy),\n-    Float(u64, UncertainFloatTy), // FIXME: f64 is not Eq\n-}\n-\n-#[derive(Debug, Clone, Eq, PartialEq)]\n-pub enum Expr {\n-    /// This is produced if syntax tree does not have a required expression piece.\n-    Missing,\n-    Path(Path),\n-    If {\n-        condition: ExprId,\n-        then_branch: ExprId,\n-        else_branch: Option<ExprId>,\n-    },\n-    Block {\n-        statements: Vec<Statement>,\n-        tail: Option<ExprId>,\n-    },\n-    Loop {\n-        body: ExprId,\n-    },\n-    While {\n-        condition: ExprId,\n-        body: ExprId,\n-    },\n-    For {\n-        iterable: ExprId,\n-        pat: PatId,\n-        body: ExprId,\n-    },\n-    Call {\n-        callee: ExprId,\n-        args: Vec<ExprId>,\n-    },\n-    MethodCall {\n-        receiver: ExprId,\n-        method_name: Name,\n-        args: Vec<ExprId>,\n-        generic_args: Option<GenericArgs>,\n-    },\n-    Match {\n-        expr: ExprId,\n-        arms: Vec<MatchArm>,\n-    },\n-    Continue,\n-    Break {\n-        expr: Option<ExprId>,\n-    },\n-    Return {\n-        expr: Option<ExprId>,\n-    },\n-    RecordLit {\n-        path: Option<Path>,\n-        fields: Vec<RecordLitField>,\n-        spread: Option<ExprId>,\n-    },\n-    Field {\n-        expr: ExprId,\n-        name: Name,\n-    },\n-    Await {\n-        expr: ExprId,\n-    },\n-    Try {\n-        expr: ExprId,\n-    },\n-    TryBlock {\n-        body: ExprId,\n-    },\n-    Cast {\n-        expr: ExprId,\n-        type_ref: TypeRef,\n+pub use hir_def::{\n+    body::{Body, BodySourceMap, ExprPtr, ExprSource, PatPtr, PatSource},\n+    expr::{\n+        ArithOp, Array, BinaryOp, BindingAnnotation, CmpOp, Expr, ExprId, Literal, LogicOp,\n+        MatchArm, Ordering, Pat, PatId, RecordFieldPat, RecordLitField, Statement, UnaryOp,\n     },\n-    Ref {\n-        expr: ExprId,\n-        mutability: Mutability,\n-    },\n-    Box {\n-        expr: ExprId,\n-    },\n-    UnaryOp {\n-        expr: ExprId,\n-        op: UnaryOp,\n-    },\n-    BinaryOp {\n-        lhs: ExprId,\n-        rhs: ExprId,\n-        op: Option<BinaryOp>,\n-    },\n-    Index {\n-        base: ExprId,\n-        index: ExprId,\n-    },\n-    Lambda {\n-        args: Vec<PatId>,\n-        arg_types: Vec<Option<TypeRef>>,\n-        body: ExprId,\n-    },\n-    Tuple {\n-        exprs: Vec<ExprId>,\n-    },\n-    Array(Array),\n-    Literal(Literal),\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum BinaryOp {\n-    LogicOp(LogicOp),\n-    ArithOp(ArithOp),\n-    CmpOp(CmpOp),\n-    Assignment { op: Option<ArithOp> },\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum LogicOp {\n-    And,\n-    Or,\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum CmpOp {\n-    Eq { negated: bool },\n-    Ord { ordering: Ordering, strict: bool },\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum Ordering {\n-    Less,\n-    Greater,\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum ArithOp {\n-    Add,\n-    Mul,\n-    Sub,\n-    Div,\n-    Rem,\n-    Shl,\n-    Shr,\n-    BitXor,\n-    BitOr,\n-    BitAnd,\n-}\n-\n-pub use ra_syntax::ast::PrefixOp as UnaryOp;\n-#[derive(Debug, Clone, Eq, PartialEq)]\n-pub enum Array {\n-    ElementList(Vec<ExprId>),\n-    Repeat { initializer: ExprId, repeat: ExprId },\n-}\n-\n-#[derive(Debug, Clone, Eq, PartialEq)]\n-pub struct MatchArm {\n-    pub pats: Vec<PatId>,\n-    pub guard: Option<ExprId>,\n-    pub expr: ExprId,\n-}\n-\n-#[derive(Debug, Clone, Eq, PartialEq)]\n-pub struct RecordLitField {\n-    pub name: Name,\n-    pub expr: ExprId,\n-}\n-\n-#[derive(Debug, Clone, Eq, PartialEq)]\n-pub enum Statement {\n-    Let { pat: PatId, type_ref: Option<TypeRef>, initializer: Option<ExprId> },\n-    Expr(ExprId),\n-}\n-\n-impl Expr {\n-    pub fn walk_child_exprs(&self, mut f: impl FnMut(ExprId)) {\n-        match self {\n-            Expr::Missing => {}\n-            Expr::Path(_) => {}\n-            Expr::If { condition, then_branch, else_branch } => {\n-                f(*condition);\n-                f(*then_branch);\n-                if let Some(else_branch) = else_branch {\n-                    f(*else_branch);\n-                }\n-            }\n-            Expr::Block { statements, tail } => {\n-                for stmt in statements {\n-                    match stmt {\n-                        Statement::Let { initializer, .. } => {\n-                            if let Some(expr) = initializer {\n-                                f(*expr);\n-                            }\n-                        }\n-                        Statement::Expr(e) => f(*e),\n-                    }\n-                }\n-                if let Some(expr) = tail {\n-                    f(*expr);\n-                }\n-            }\n-            Expr::TryBlock { body } => f(*body),\n-            Expr::Loop { body } => f(*body),\n-            Expr::While { condition, body } => {\n-                f(*condition);\n-                f(*body);\n-            }\n-            Expr::For { iterable, body, .. } => {\n-                f(*iterable);\n-                f(*body);\n-            }\n-            Expr::Call { callee, args } => {\n-                f(*callee);\n-                for arg in args {\n-                    f(*arg);\n-                }\n-            }\n-            Expr::MethodCall { receiver, args, .. } => {\n-                f(*receiver);\n-                for arg in args {\n-                    f(*arg);\n-                }\n-            }\n-            Expr::Match { expr, arms } => {\n-                f(*expr);\n-                for arm in arms {\n-                    f(arm.expr);\n-                }\n-            }\n-            Expr::Continue => {}\n-            Expr::Break { expr } | Expr::Return { expr } => {\n-                if let Some(expr) = expr {\n-                    f(*expr);\n-                }\n-            }\n-            Expr::RecordLit { fields, spread, .. } => {\n-                for field in fields {\n-                    f(field.expr);\n-                }\n-                if let Some(expr) = spread {\n-                    f(*expr);\n-                }\n-            }\n-            Expr::Lambda { body, .. } => {\n-                f(*body);\n-            }\n-            Expr::BinaryOp { lhs, rhs, .. } => {\n-                f(*lhs);\n-                f(*rhs);\n-            }\n-            Expr::Index { base, index } => {\n-                f(*base);\n-                f(*index);\n-            }\n-            Expr::Field { expr, .. }\n-            | Expr::Await { expr }\n-            | Expr::Try { expr }\n-            | Expr::Cast { expr, .. }\n-            | Expr::Ref { expr, .. }\n-            | Expr::UnaryOp { expr, .. }\n-            | Expr::Box { expr } => {\n-                f(*expr);\n-            }\n-            Expr::Tuple { exprs } => {\n-                for expr in exprs {\n-                    f(*expr);\n-                }\n-            }\n-            Expr::Array(a) => match a {\n-                Array::ElementList(exprs) => {\n-                    for expr in exprs {\n-                        f(*expr);\n-                    }\n-                }\n-                Array::Repeat { initializer, repeat } => {\n-                    f(*initializer);\n-                    f(*repeat)\n-                }\n-            },\n-            Expr::Literal(_) => {}\n-        }\n-    }\n-}\n-\n-/// Explicit binding annotations given in the HIR for a binding. Note\n-/// that this is not the final binding *mode* that we infer after type\n-/// inference.\n-#[derive(Clone, PartialEq, Eq, Debug, Copy)]\n-pub enum BindingAnnotation {\n-    /// No binding annotation given: this means that the final binding mode\n-    /// will depend on whether we have skipped through a `&` reference\n-    /// when matching. For example, the `x` in `Some(x)` will have binding\n-    /// mode `None`; if you do `let Some(x) = &Some(22)`, it will\n-    /// ultimately be inferred to be by-reference.\n-    Unannotated,\n-\n-    /// Annotated with `mut x` -- could be either ref or not, similar to `None`.\n-    Mutable,\n-\n-    /// Annotated as `ref`, like `ref x`\n-    Ref,\n-\n-    /// Annotated as `ref mut x`.\n-    RefMut,\n-}\n-\n-impl BindingAnnotation {\n-    fn new(is_mutable: bool, is_ref: bool) -> Self {\n-        match (is_mutable, is_ref) {\n-            (true, true) => BindingAnnotation::RefMut,\n-            (false, true) => BindingAnnotation::Ref,\n-            (true, false) => BindingAnnotation::Mutable,\n-            (false, false) => BindingAnnotation::Unannotated,\n-        }\n-    }\n-}\n-\n-#[derive(Debug, Clone, Eq, PartialEq)]\n-pub struct RecordFieldPat {\n-    pub(crate) name: Name,\n-    pub(crate) pat: PatId,\n-}\n-\n-/// Close relative to rustc's hir::PatKind\n-#[derive(Debug, Clone, Eq, PartialEq)]\n-pub enum Pat {\n-    Missing,\n-    Wild,\n-    Tuple(Vec<PatId>),\n-    Record {\n-        path: Option<Path>,\n-        args: Vec<RecordFieldPat>,\n-        // FIXME: 'ellipsis' option\n-    },\n-    Range {\n-        start: ExprId,\n-        end: ExprId,\n-    },\n-    Slice {\n-        prefix: Vec<PatId>,\n-        rest: Option<PatId>,\n-        suffix: Vec<PatId>,\n-    },\n-    Path(Path),\n-    Lit(ExprId),\n-    Bind {\n-        mode: BindingAnnotation,\n-        name: Name,\n-        subpat: Option<PatId>,\n-    },\n-    TupleStruct {\n-        path: Option<Path>,\n-        args: Vec<PatId>,\n-    },\n-    Ref {\n-        pat: PatId,\n-        mutability: Mutability,\n-    },\n-}\n-\n-impl Pat {\n-    pub fn walk_child_pats(&self, mut f: impl FnMut(PatId)) {\n-        match self {\n-            Pat::Range { .. } | Pat::Lit(..) | Pat::Path(..) | Pat::Wild | Pat::Missing => {}\n-            Pat::Bind { subpat, .. } => {\n-                subpat.iter().copied().for_each(f);\n-            }\n-            Pat::Tuple(args) | Pat::TupleStruct { args, .. } => {\n-                args.iter().copied().for_each(f);\n-            }\n-            Pat::Ref { pat, .. } => f(*pat),\n-            Pat::Slice { prefix, rest, suffix } => {\n-                let total_iter = prefix.iter().chain(rest.iter()).chain(suffix.iter());\n-                total_iter.copied().for_each(f);\n-            }\n-            Pat::Record { args, .. } => {\n-                args.iter().map(|f| f.pat).for_each(f);\n-            }\n-        }\n-    }\n-}\n+};\n \n-// Queries\n pub(crate) fn body_with_source_map_query(\n     db: &impl HirDatabase,\n     def: DefWithBody,\n@@ -565,11 +40,35 @@ pub(crate) fn body_with_source_map_query(\n             (src.file_id, src.ast.body())\n         }\n     };\n-\n-    let (body, source_map) = lower::lower(db, def.resolver(db), file_id, def, params, body);\n+    let resolver = hir_def::body::MacroResolver::new(db, def.module(db).id);\n+    let (body, source_map) = Body::new(db, resolver, file_id, params, body);\n     (Arc::new(body), Arc::new(source_map))\n }\n \n-pub(crate) fn body_hir_query(db: &impl HirDatabase, def: DefWithBody) -> Arc<Body> {\n+pub(crate) fn body_query(db: &impl HirDatabase, def: DefWithBody) -> Arc<Body> {\n     db.body_with_source_map(def).0\n }\n+\n+// needs arbitrary_self_types to be a method... or maybe move to the def?\n+pub(crate) fn resolver_for_expr(\n+    db: &impl HirDatabase,\n+    owner: DefWithBody,\n+    expr_id: ExprId,\n+) -> Resolver {\n+    let scopes = db.expr_scopes(owner);\n+    resolver_for_scope(db, owner, scopes.scope_for(expr_id))\n+}\n+\n+pub(crate) fn resolver_for_scope(\n+    db: &impl HirDatabase,\n+    owner: DefWithBody,\n+    scope_id: Option<scope::ScopeId>,\n+) -> Resolver {\n+    let mut r = owner.resolver(db);\n+    let scopes = db.expr_scopes(owner);\n+    let scope_chain = scopes.scope_chain(scope_id).collect::<Vec<_>>();\n+    for scope in scope_chain.into_iter().rev() {\n+        r = r.push_expr_scope(Arc::clone(&scopes), scope);\n+    }\n+    r\n+}"}, {"sha": "0e49a28d6c32be51534e89997c1e27441932e02a", "filename": "crates/ra_hir/src/expr/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs?ref=0525778a3ad590492b51cc11085d815f9bb8f92b", "patch": "@@ -46,7 +46,7 @@ pub(crate) struct ScopeData {\n \n impl ExprScopes {\n     pub(crate) fn expr_scopes_query(db: &impl HirDatabase, def: DefWithBody) -> Arc<ExprScopes> {\n-        let body = db.body_hir(def);\n+        let body = db.body(def);\n         let res = ExprScopes::new(body);\n         Arc::new(res)\n     }"}, {"sha": "0f754eb9c75515c3ed8767723127102802a6da16", "filename": "crates/ra_hir/src/marks.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmarks.rs?ref=0525778a3ad590492b51cc11085d815f9bb8f92b", "patch": "@@ -5,6 +5,5 @@ test_utils::marks!(\n     type_var_cycles_resolve_as_possible\n     type_var_resolves_to_int_var\n     match_ergonomics_ref\n-    infer_while_let\n     coerce_merge_fail_fallback\n );"}, {"sha": "f28e9c931abbaddba516e0b9fc8eb20d160e2352", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=0525778a3ad590492b51cc11085d815f9bb8f92b", "patch": "@@ -150,7 +150,7 @@ impl SourceAnalyzer {\n                 None => scope_for(&scopes, &source_map, &node),\n                 Some(offset) => scope_for_offset(&scopes, &source_map, file_id.into(), offset),\n             };\n-            let resolver = expr::resolver_for_scope(def.body(db), db, scope);\n+            let resolver = expr::resolver_for_scope(db, def, scope);\n             SourceAnalyzer {\n                 resolver,\n                 body_owner: Some(def),"}, {"sha": "f17c6c6143397b58b01dd6644f50355f6f09caf5", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=0525778a3ad590492b51cc11085d815f9bb8f92b", "patch": "@@ -43,7 +43,7 @@ use crate::{\n     expr::{BindingAnnotation, Body, ExprId, PatId},\n     resolve::{Resolver, TypeNs},\n     ty::infer::diagnostics::InferenceDiagnostic,\n-    Adt, AssocItem, ConstData, DefWithBody, FnData, Function, HasBody, Path, StructField,\n+    Adt, AssocItem, ConstData, DefWithBody, FnData, Function, Path, StructField,\n };\n \n macro_rules! ty_app {\n@@ -64,9 +64,8 @@ mod coerce;\n /// The entry point of type inference.\n pub fn infer_query(db: &impl HirDatabase, def: DefWithBody) -> Arc<InferenceResult> {\n     let _p = profile(\"infer_query\");\n-    let body = def.body(db);\n     let resolver = def.resolver(db);\n-    let mut ctx = InferenceContext::new(db, body, resolver);\n+    let mut ctx = InferenceContext::new(db, def, resolver);\n \n     match def {\n         DefWithBody::Const(ref c) => ctx.collect_const(&c.data(db)),\n@@ -187,6 +186,7 @@ impl Index<PatId> for InferenceResult {\n #[derive(Clone, Debug)]\n struct InferenceContext<'a, D: HirDatabase> {\n     db: &'a D,\n+    owner: DefWithBody,\n     body: Arc<Body>,\n     resolver: Resolver,\n     var_unification_table: InPlaceUnificationTable<TypeVarId>,\n@@ -204,7 +204,7 @@ struct InferenceContext<'a, D: HirDatabase> {\n }\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n-    fn new(db: &'a D, body: Arc<Body>, resolver: Resolver) -> Self {\n+    fn new(db: &'a D, owner: DefWithBody, resolver: Resolver) -> Self {\n         InferenceContext {\n             result: InferenceResult::default(),\n             var_unification_table: InPlaceUnificationTable::new(),\n@@ -213,7 +213,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             trait_env: lower::trait_env(db, &resolver),\n             coerce_unsized_map: Self::init_coerce_unsized_map(db, &resolver),\n             db,\n-            body,\n+            owner,\n+            body: db.body(owner),\n             resolver,\n         }\n     }"}, {"sha": "c6802487a0c6812bc34716dca84262ff99078d1e", "filename": "crates/ra_hir/src/ty/infer/expr.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs?ref=0525778a3ad590492b51cc11085d815f9bb8f92b", "patch": "@@ -130,10 +130,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     TypeCtor::FnPtr { num_args: sig_tys.len() as u16 - 1 },\n                     Substs(sig_tys.into()),\n                 );\n-                let closure_ty = Ty::apply_one(\n-                    TypeCtor::Closure { def: self.body.owner(), expr: tgt_expr },\n-                    sig_ty,\n-                );\n+                let closure_ty =\n+                    Ty::apply_one(TypeCtor::Closure { def: self.owner, expr: tgt_expr }, sig_ty);\n \n                 // Eagerly try to relate the closure type with the expected\n                 // type, otherwise we often won't have enough information to\n@@ -184,7 +182,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             }\n             Expr::Path(p) => {\n                 // FIXME this could be more efficient...\n-                let resolver = expr::resolver_for_expr(self.body.clone(), self.db, tgt_expr);\n+                let resolver = expr::resolver_for_expr(self.db, self.owner, tgt_expr);\n                 self.infer_path(&resolver, p, tgt_expr.into()).unwrap_or(Ty::Unknown)\n             }\n             Expr::Continue => Ty::simple(TypeCtor::Never),\n@@ -452,8 +450,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     Ty::apply_one(TypeCtor::Ref(Mutability::Shared), slice_type)\n                 }\n                 Literal::Char(..) => Ty::simple(TypeCtor::Char),\n-                Literal::Int(_v, ty) => Ty::simple(TypeCtor::Int(*ty)),\n-                Literal::Float(_v, ty) => Ty::simple(TypeCtor::Float(*ty)),\n+                Literal::Int(_v, ty) => Ty::simple(TypeCtor::Int((*ty).into())),\n+                Literal::Float(_v, ty) => Ty::simple(TypeCtor::Float((*ty).into())),\n             },\n         };\n         // use a new type variable if we got Ty::Unknown here"}, {"sha": "1832fcf5042e53edfec18dc7f9f8fb4a29dc582e", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=0525778a3ad590492b51cc11085d815f9bb8f92b", "patch": "@@ -9,7 +9,7 @@ use std::iter;\n use std::sync::Arc;\n \n use hir_def::{\n-    builtin_type::BuiltinType,\n+    builtin_type::{BuiltinFloat, BuiltinInt, BuiltinType},\n     path::{GenericArg, PathSegment},\n     type_ref::{TypeBound, TypeRef},\n };\n@@ -25,7 +25,7 @@ use crate::{\n     generics::{GenericDef, WherePredicate},\n     resolve::{Resolver, TypeNs},\n     ty::{\n-        primitive::{FloatTy, IntTy},\n+        primitive::{FloatTy, IntTy, UncertainFloatTy, UncertainIntTy},\n         Adt,\n     },\n     util::make_mut_slice,\n@@ -657,13 +657,41 @@ fn type_for_builtin(def: BuiltinType) -> Ty {\n         BuiltinType::Char => TypeCtor::Char,\n         BuiltinType::Bool => TypeCtor::Bool,\n         BuiltinType::Str => TypeCtor::Str,\n-        BuiltinType::Int { signedness, bitness } => {\n-            TypeCtor::Int(IntTy { signedness, bitness }.into())\n-        }\n-        BuiltinType::Float { bitness } => TypeCtor::Float(FloatTy { bitness }.into()),\n+        BuiltinType::Int(t) => TypeCtor::Int(IntTy::from(t).into()),\n+        BuiltinType::Float(t) => TypeCtor::Float(FloatTy::from(t).into()),\n     })\n }\n \n+impl From<BuiltinInt> for IntTy {\n+    fn from(t: BuiltinInt) -> Self {\n+        IntTy { signedness: t.signedness, bitness: t.bitness }\n+    }\n+}\n+\n+impl From<BuiltinFloat> for FloatTy {\n+    fn from(t: BuiltinFloat) -> Self {\n+        FloatTy { bitness: t.bitness }\n+    }\n+}\n+\n+impl From<Option<BuiltinInt>> for UncertainIntTy {\n+    fn from(t: Option<BuiltinInt>) -> Self {\n+        match t {\n+            None => UncertainIntTy::Unknown,\n+            Some(t) => UncertainIntTy::Known(t.into()),\n+        }\n+    }\n+}\n+\n+impl From<Option<BuiltinFloat>> for UncertainFloatTy {\n+    fn from(t: Option<BuiltinFloat>) -> Self {\n+        match t {\n+            None => UncertainFloatTy::Unknown,\n+            Some(t) => UncertainFloatTy::Known(t.into()),\n+        }\n+    }\n+}\n+\n fn fn_sig_for_struct_constructor(db: &impl HirDatabase, def: Struct) -> FnSig {\n     let struct_data = db.struct_data(def.id.into());\n     let fields = match struct_data.variant_data.fields() {"}, {"sha": "7362de4c3f76bb58a1b5c65c611dd909f1b21c69", "filename": "crates/ra_hir/src/ty/primitive.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs?ref=0525778a3ad590492b51cc11085d815f9bb8f92b", "patch": "@@ -129,24 +129,6 @@ impl IntTy {\n             (Signedness::Unsigned, IntBitness::X128) => \"u128\",\n         }\n     }\n-\n-    pub(crate) fn from_suffix(suffix: &str) -> Option<IntTy> {\n-        match suffix {\n-            \"isize\" => Some(IntTy::isize()),\n-            \"i8\" => Some(IntTy::i8()),\n-            \"i16\" => Some(IntTy::i16()),\n-            \"i32\" => Some(IntTy::i32()),\n-            \"i64\" => Some(IntTy::i64()),\n-            \"i128\" => Some(IntTy::i128()),\n-            \"usize\" => Some(IntTy::usize()),\n-            \"u8\" => Some(IntTy::u8()),\n-            \"u16\" => Some(IntTy::u16()),\n-            \"u32\" => Some(IntTy::u32()),\n-            \"u64\" => Some(IntTy::u64()),\n-            \"u128\" => Some(IntTy::u128()),\n-            _ => None,\n-        }\n-    }\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n@@ -181,12 +163,4 @@ impl FloatTy {\n             FloatBitness::X64 => \"f64\",\n         }\n     }\n-\n-    pub(crate) fn from_suffix(suffix: &str) -> Option<FloatTy> {\n-        match suffix {\n-            \"f32\" => Some(FloatTy::f32()),\n-            \"f64\" => Some(FloatTy::f64()),\n-            _ => None,\n-        }\n-    }\n }"}, {"sha": "8863c3608739935571a5c9bb3e52cfe792112a0d", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=0525778a3ad590492b51cc11085d815f9bb8f92b", "patch": "@@ -222,7 +222,6 @@ mod collections {\n \n #[test]\n fn infer_while_let() {\n-    covers!(infer_while_let);\n     let (db, pos) = TestDB::with_position(\n         r#\"\n //- /main.rs\n@@ -4825,7 +4824,7 @@ fn main() {\n         @r###\"\n         ![0; 1) '6': i32\n         [64; 88) '{     ...!(); }': ()\n-        [74; 75) 'x': i32        \n+        [74; 75) 'x': i32\n     \"###\n     );\n }"}, {"sha": "de322dd523ff4cc1e1143618f9bf555e93c314ac", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=0525778a3ad590492b51cc11085d815f9bb8f92b", "patch": "@@ -714,7 +714,7 @@ fn closure_fn_trait_impl_datum(\n     let fn_once_trait = get_fn_trait(db, krate, super::FnTrait::FnOnce)?;\n     let trait_ = get_fn_trait(db, krate, data.fn_trait)?; // get corresponding fn trait\n \n-    let num_args: u16 = match &db.body_hir(data.def)[data.expr] {\n+    let num_args: u16 = match &db.body(data.def)[data.expr] {\n         crate::expr::Expr::Lambda { args, .. } => args.len() as u16,\n         _ => {\n             log::warn!(\"closure for closure type {:?} not found\", data);"}, {"sha": "ac8f8261b8ff23c4c466542a474608abd1c6ce82", "filename": "crates/ra_hir_def/src/body.rs", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody.rs?ref=0525778a3ad590492b51cc11085d815f9bb8f92b", "patch": "@@ -0,0 +1,144 @@\n+//! FIXME: write short doc here\n+mod lower;\n+\n+use std::{ops::Index, sync::Arc};\n+\n+use hir_expand::{either::Either, HirFileId, MacroDefId, Source};\n+use ra_arena::{map::ArenaMap, Arena};\n+use ra_syntax::{ast, AstPtr};\n+use rustc_hash::FxHashMap;\n+\n+use crate::{\n+    db::DefDatabase2,\n+    expr::{Expr, ExprId, Pat, PatId},\n+    nameres::CrateDefMap,\n+    path::Path,\n+    ModuleId,\n+};\n+\n+pub struct MacroResolver {\n+    crate_def_map: Arc<CrateDefMap>,\n+    module: ModuleId,\n+}\n+\n+impl MacroResolver {\n+    pub fn new(db: &impl DefDatabase2, module: ModuleId) -> MacroResolver {\n+        MacroResolver { crate_def_map: db.crate_def_map(module.krate), module }\n+    }\n+\n+    pub(crate) fn resolve_path_as_macro(\n+        &self,\n+        db: &impl DefDatabase2,\n+        path: &Path,\n+    ) -> Option<MacroDefId> {\n+        self.crate_def_map.resolve_path(db, self.module.module_id, path).0.get_macros()\n+    }\n+}\n+\n+/// The body of an item (function, const etc.).\n+#[derive(Debug, Eq, PartialEq)]\n+pub struct Body {\n+    exprs: Arena<ExprId, Expr>,\n+    pats: Arena<PatId, Pat>,\n+    /// The patterns for the function's parameters. While the parameter types are\n+    /// part of the function signature, the patterns are not (they don't change\n+    /// the external type of the function).\n+    ///\n+    /// If this `Body` is for the body of a constant, this will just be\n+    /// empty.\n+    params: Vec<PatId>,\n+    /// The `ExprId` of the actual body expression.\n+    body_expr: ExprId,\n+}\n+\n+pub type ExprPtr = Either<AstPtr<ast::Expr>, AstPtr<ast::RecordField>>;\n+pub type ExprSource = Source<ExprPtr>;\n+\n+pub type PatPtr = Either<AstPtr<ast::Pat>, AstPtr<ast::SelfParam>>;\n+pub type PatSource = Source<PatPtr>;\n+\n+/// An item body together with the mapping from syntax nodes to HIR expression\n+/// IDs. This is needed to go from e.g. a position in a file to the HIR\n+/// expression containing it; but for type inference etc., we want to operate on\n+/// a structure that is agnostic to the actual positions of expressions in the\n+/// file, so that we don't recompute types whenever some whitespace is typed.\n+///\n+/// One complication here is that, due to macro expansion, a single `Body` might\n+/// be spread across several files. So, for each ExprId and PatId, we record\n+/// both the HirFileId and the position inside the file. However, we only store\n+/// AST -> ExprId mapping for non-macro files, as it is not clear how to handle\n+/// this properly for macros.\n+#[derive(Default, Debug, Eq, PartialEq)]\n+pub struct BodySourceMap {\n+    expr_map: FxHashMap<ExprPtr, ExprId>,\n+    expr_map_back: ArenaMap<ExprId, ExprSource>,\n+    pat_map: FxHashMap<PatPtr, PatId>,\n+    pat_map_back: ArenaMap<PatId, PatSource>,\n+    field_map: FxHashMap<(ExprId, usize), AstPtr<ast::RecordField>>,\n+}\n+\n+impl Body {\n+    pub fn new(\n+        db: &impl DefDatabase2,\n+        resolver: MacroResolver,\n+        file_id: HirFileId,\n+        params: Option<ast::ParamList>,\n+        body: Option<ast::Expr>,\n+    ) -> (Body, BodySourceMap) {\n+        lower::lower(db, resolver, file_id, params, body)\n+    }\n+\n+    pub fn params(&self) -> &[PatId] {\n+        &self.params\n+    }\n+\n+    pub fn body_expr(&self) -> ExprId {\n+        self.body_expr\n+    }\n+\n+    pub fn exprs(&self) -> impl Iterator<Item = (ExprId, &Expr)> {\n+        self.exprs.iter()\n+    }\n+\n+    pub fn pats(&self) -> impl Iterator<Item = (PatId, &Pat)> {\n+        self.pats.iter()\n+    }\n+}\n+\n+impl Index<ExprId> for Body {\n+    type Output = Expr;\n+\n+    fn index(&self, expr: ExprId) -> &Expr {\n+        &self.exprs[expr]\n+    }\n+}\n+\n+impl Index<PatId> for Body {\n+    type Output = Pat;\n+\n+    fn index(&self, pat: PatId) -> &Pat {\n+        &self.pats[pat]\n+    }\n+}\n+\n+impl BodySourceMap {\n+    pub fn expr_syntax(&self, expr: ExprId) -> Option<ExprSource> {\n+        self.expr_map_back.get(expr).copied()\n+    }\n+\n+    pub fn node_expr(&self, node: &ast::Expr) -> Option<ExprId> {\n+        self.expr_map.get(&Either::A(AstPtr::new(node))).cloned()\n+    }\n+\n+    pub fn pat_syntax(&self, pat: PatId) -> Option<PatSource> {\n+        self.pat_map_back.get(pat).copied()\n+    }\n+\n+    pub fn node_pat(&self, node: &ast::Pat) -> Option<PatId> {\n+        self.pat_map.get(&Either::A(AstPtr::new(node))).cloned()\n+    }\n+\n+    pub fn field_syntax(&self, expr: ExprId, field: usize) -> AstPtr<ast::RecordField> {\n+        self.field_map[&(expr, field)]\n+    }\n+}"}, {"sha": "2aa863c9ecd228ddae8e09511622ad52085233b6", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "renamed", "additions": 23, "deletions": 39, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=0525778a3ad590492b51cc11085d815f9bb8f92b", "patch": "@@ -1,9 +1,10 @@\n //! FIXME: write short doc here\n \n-use hir_def::{path::GenericArgs, type_ref::TypeRef};\n use hir_expand::{\n+    either::Either,\n     hygiene::Hygiene,\n     name::{self, AsName, Name},\n+    AstId, HirFileId, MacroCallLoc, MacroFileKind, Source,\n };\n use ra_arena::Arena;\n use ra_syntax::{\n@@ -13,25 +14,24 @@ use ra_syntax::{\n     },\n     AstNode, AstPtr,\n };\n-use test_utils::tested_by;\n \n use crate::{\n-    db::HirDatabase,\n-    ty::primitive::{FloatTy, IntTy, UncertainFloatTy, UncertainIntTy},\n-    AstId, DefWithBody, Either, HirFileId, MacroCallLoc, MacroFileKind, Mutability, Path, Resolver,\n-    Source,\n-};\n-\n-use super::{\n-    ArithOp, Array, BinaryOp, BindingAnnotation, Body, BodySourceMap, CmpOp, Expr, ExprId, Literal,\n-    LogicOp, MatchArm, Ordering, Pat, PatId, PatPtr, RecordFieldPat, RecordLitField, Statement,\n+    body::{Body, BodySourceMap, MacroResolver, PatPtr},\n+    builtin_type::{BuiltinFloat, BuiltinInt},\n+    db::DefDatabase2,\n+    expr::{\n+        ArithOp, Array, BinaryOp, BindingAnnotation, CmpOp, Expr, ExprId, Literal, LogicOp,\n+        MatchArm, Ordering, Pat, PatId, RecordFieldPat, RecordLitField, Statement,\n+    },\n+    path::GenericArgs,\n+    path::Path,\n+    type_ref::{Mutability, TypeRef},\n };\n \n pub(super) fn lower(\n-    db: &impl HirDatabase,\n-    resolver: Resolver,\n+    db: &impl DefDatabase2,\n+    resolver: MacroResolver,\n     file_id: HirFileId,\n-    owner: DefWithBody,\n     params: Option<ast::ParamList>,\n     body: Option<ast::Expr>,\n ) -> (Body, BodySourceMap) {\n@@ -42,23 +42,18 @@ pub(super) fn lower(\n         current_file_id: file_id,\n         source_map: BodySourceMap::default(),\n         body: Body {\n-            owner,\n             exprs: Arena::default(),\n             pats: Arena::default(),\n             params: Vec::new(),\n-            body_expr: ExprId((!0).into()),\n+            body_expr: ExprId::dummy(),\n         },\n     }\n     .collect(params, body)\n }\n \n struct ExprCollector<DB> {\n     db: DB,\n-    resolver: Resolver,\n-    // Expr collector expands macros along the way. original points to the file\n-    // we started with, current points to the current macro expansion. source\n-    // maps don't support macros yet, so we only record info into source map if\n-    // current == original (see #1196)\n+    resolver: MacroResolver,\n     original_file_id: HirFileId,\n     current_file_id: HirFileId,\n \n@@ -68,7 +63,7 @@ struct ExprCollector<DB> {\n \n impl<'a, DB> ExprCollector<&'a DB>\n where\n-    DB: HirDatabase,\n+    DB: DefDatabase2,\n {\n     fn collect(\n         mut self,\n@@ -209,7 +204,6 @@ where\n                         None => self.collect_expr_opt(condition.expr()),\n                         // if let -- desugar to match\n                         Some(pat) => {\n-                            tested_by!(infer_while_let);\n                             let pat = self.collect_pat(pat);\n                             let match_expr = self.collect_expr_opt(condition.expr());\n                             let placeholder_pat = self.missing_pat();\n@@ -423,28 +417,18 @@ where\n             ast::Expr::Literal(e) => {\n                 let lit = match e.kind() {\n                     LiteralKind::IntNumber { suffix } => {\n-                        let known_name = suffix\n-                            .and_then(|it| IntTy::from_suffix(&it).map(UncertainIntTy::Known));\n+                        let known_name = suffix.and_then(|it| BuiltinInt::from_suffix(&it));\n \n-                        Literal::Int(\n-                            Default::default(),\n-                            known_name.unwrap_or(UncertainIntTy::Unknown),\n-                        )\n+                        Literal::Int(Default::default(), known_name)\n                     }\n                     LiteralKind::FloatNumber { suffix } => {\n-                        let known_name = suffix\n-                            .and_then(|it| FloatTy::from_suffix(&it).map(UncertainFloatTy::Known));\n+                        let known_name = suffix.and_then(|it| BuiltinFloat::from_suffix(&it));\n \n-                        Literal::Float(\n-                            Default::default(),\n-                            known_name.unwrap_or(UncertainFloatTy::Unknown),\n-                        )\n+                        Literal::Float(Default::default(), known_name)\n                     }\n                     LiteralKind::ByteString => Literal::ByteString(Default::default()),\n                     LiteralKind::String => Literal::String(Default::default()),\n-                    LiteralKind::Byte => {\n-                        Literal::Int(Default::default(), UncertainIntTy::Known(IntTy::u8()))\n-                    }\n+                    LiteralKind::Byte => Literal::Int(Default::default(), Some(BuiltinInt::U8)),\n                     LiteralKind::Bool => Literal::Bool(Default::default()),\n                     LiteralKind::Char => Literal::Char(Default::default()),\n                 };\n@@ -467,7 +451,7 @@ where\n \n                 if let Some(path) = e.path().and_then(|path| self.parse_path(path)) {\n                     if let Some(def) = self.resolver.resolve_path_as_macro(self.db, &path) {\n-                        let call_id = self.db.intern_macro(MacroCallLoc { def: def.id, ast_id });\n+                        let call_id = self.db.intern_macro(MacroCallLoc { def, ast_id });\n                         let file_id = call_id.as_file(MacroFileKind::Expr);\n                         if let Some(node) = self.db.parse_or_expand(file_id) {\n                             if let Some(expr) = ast::Expr::cast(node) {", "previous_filename": "crates/ra_hir/src/expr/lower.rs"}, {"sha": "5e815714434ff3fdf381ce94f757846351743154", "filename": "crates/ra_hir_def/src/builtin_type.rs", "status": "modified", "additions": 85, "deletions": 20, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir_def%2Fsrc%2Fbuiltin_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir_def%2Fsrc%2Fbuiltin_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbuiltin_type.rs?ref=0525778a3ad590492b51cc11085d815f9bb8f92b", "patch": "@@ -29,13 +29,24 @@ pub enum FloatBitness {\n     X64,\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct BuiltinInt {\n+    pub signedness: Signedness,\n+    pub bitness: IntBitness,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct BuiltinFloat {\n+    pub bitness: FloatBitness,\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub enum BuiltinType {\n     Char,\n     Bool,\n     Str,\n-    Int { signedness: Signedness, bitness: IntBitness },\n-    Float { bitness: FloatBitness },\n+    Int(BuiltinInt),\n+    Float(BuiltinFloat),\n }\n \n impl BuiltinType {\n@@ -45,22 +56,22 @@ impl BuiltinType {\n         (name::BOOL, BuiltinType::Bool),\n         (name::STR,  BuiltinType::Str ),\n \n-        (name::ISIZE, BuiltinType::Int { signedness: Signedness::Signed,   bitness: IntBitness::Xsize }),\n-        (name::I8,    BuiltinType::Int { signedness: Signedness::Signed,   bitness: IntBitness::X8    }),\n-        (name::I16,   BuiltinType::Int { signedness: Signedness::Signed,   bitness: IntBitness::X16   }),\n-        (name::I32,   BuiltinType::Int { signedness: Signedness::Signed,   bitness: IntBitness::X32   }),\n-        (name::I64,   BuiltinType::Int { signedness: Signedness::Signed,   bitness: IntBitness::X64   }),\n-        (name::I128,  BuiltinType::Int { signedness: Signedness::Signed,   bitness: IntBitness::X128  }),\n-\n-        (name::USIZE, BuiltinType::Int { signedness: Signedness::Unsigned, bitness: IntBitness::Xsize }),\n-        (name::U8,    BuiltinType::Int { signedness: Signedness::Unsigned, bitness: IntBitness::X8    }),\n-        (name::U16,   BuiltinType::Int { signedness: Signedness::Unsigned, bitness: IntBitness::X16   }),\n-        (name::U32,   BuiltinType::Int { signedness: Signedness::Unsigned, bitness: IntBitness::X32   }),\n-        (name::U64,   BuiltinType::Int { signedness: Signedness::Unsigned, bitness: IntBitness::X64   }),\n-        (name::U128,  BuiltinType::Int { signedness: Signedness::Unsigned, bitness: IntBitness::X128  }),\n-\n-        (name::F32, BuiltinType::Float { bitness: FloatBitness::X32 }),\n-        (name::F64, BuiltinType::Float { bitness: FloatBitness::X64 }),\n+        (name::ISIZE, BuiltinType::Int(BuiltinInt::ISIZE)),\n+        (name::I8,    BuiltinType::Int(BuiltinInt::I8)),\n+        (name::I16,   BuiltinType::Int(BuiltinInt::I16)),\n+        (name::I32,   BuiltinType::Int(BuiltinInt::I32)),\n+        (name::I64,   BuiltinType::Int(BuiltinInt::I64)),\n+        (name::I128,  BuiltinType::Int(BuiltinInt::I128)),\n+\n+        (name::USIZE, BuiltinType::Int(BuiltinInt::USIZE)),\n+        (name::U8,    BuiltinType::Int(BuiltinInt::U8)),\n+        (name::U16,   BuiltinType::Int(BuiltinInt::U16)),\n+        (name::U32,   BuiltinType::Int(BuiltinInt::U32)),\n+        (name::U64,   BuiltinType::Int(BuiltinInt::U64)),\n+        (name::U128,  BuiltinType::Int(BuiltinInt::U128)),\n+\n+        (name::F32, BuiltinType::Float(BuiltinFloat::F32)),\n+        (name::F64, BuiltinType::Float(BuiltinFloat::F64)),\n     ];\n }\n \n@@ -70,7 +81,7 @@ impl fmt::Display for BuiltinType {\n             BuiltinType::Char => \"char\",\n             BuiltinType::Bool => \"bool\",\n             BuiltinType::Str => \"str\",\n-            BuiltinType::Int { signedness, bitness } => match (signedness, bitness) {\n+            BuiltinType::Int(BuiltinInt { signedness, bitness }) => match (signedness, bitness) {\n                 (Signedness::Signed, IntBitness::Xsize) => \"isize\",\n                 (Signedness::Signed, IntBitness::X8) => \"i8\",\n                 (Signedness::Signed, IntBitness::X16) => \"i16\",\n@@ -85,11 +96,65 @@ impl fmt::Display for BuiltinType {\n                 (Signedness::Unsigned, IntBitness::X64) => \"u64\",\n                 (Signedness::Unsigned, IntBitness::X128) => \"u128\",\n             },\n-            BuiltinType::Float { bitness } => match bitness {\n+            BuiltinType::Float(BuiltinFloat { bitness }) => match bitness {\n                 FloatBitness::X32 => \"f32\",\n                 FloatBitness::X64 => \"f64\",\n             },\n         };\n         f.write_str(type_name)\n     }\n }\n+\n+#[rustfmt::skip]\n+impl BuiltinInt {\n+    pub const ISIZE: BuiltinInt = BuiltinInt { signedness: Signedness::Signed, bitness: IntBitness::Xsize   };\n+    pub const I8   : BuiltinInt = BuiltinInt { signedness: Signedness::Signed, bitness: IntBitness::X8      };\n+    pub const I16  : BuiltinInt = BuiltinInt { signedness: Signedness::Signed, bitness: IntBitness::X16     };\n+    pub const I32  : BuiltinInt = BuiltinInt { signedness: Signedness::Signed, bitness: IntBitness::X32     };\n+    pub const I64  : BuiltinInt = BuiltinInt { signedness: Signedness::Signed, bitness: IntBitness::X64     };\n+    pub const I128 : BuiltinInt = BuiltinInt { signedness: Signedness::Signed, bitness: IntBitness::X128    };\n+\n+    pub const USIZE: BuiltinInt = BuiltinInt { signedness: Signedness::Unsigned, bitness: IntBitness::Xsize };\n+    pub const U8   : BuiltinInt = BuiltinInt { signedness: Signedness::Unsigned, bitness: IntBitness::X8    };\n+    pub const U16  : BuiltinInt = BuiltinInt { signedness: Signedness::Unsigned, bitness: IntBitness::X16   };\n+    pub const U32  : BuiltinInt = BuiltinInt { signedness: Signedness::Unsigned, bitness: IntBitness::X32   };\n+    pub const U64  : BuiltinInt = BuiltinInt { signedness: Signedness::Unsigned, bitness: IntBitness::X64   };\n+    pub const U128 : BuiltinInt = BuiltinInt { signedness: Signedness::Unsigned, bitness: IntBitness::X128  };\n+\n+\n+    pub fn from_suffix(suffix: &str) -> Option<BuiltinInt> {\n+        let res = match suffix {\n+            \"isize\" => Self::ISIZE,\n+            \"i8\"    => Self::I8,\n+            \"i16\"   => Self::I16,\n+            \"i32\"   => Self::I32,\n+            \"i64\"   => Self::I64,\n+            \"i128\"  => Self::I128,\n+\n+            \"usize\" => Self::USIZE,\n+            \"u8\"    => Self::U8,\n+            \"u16\"   => Self::U16,\n+            \"u32\"   => Self::U32,\n+            \"u64\"   => Self::U64,\n+            \"u128\"  => Self::U128,\n+\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+}\n+\n+#[rustfmt::skip]\n+impl BuiltinFloat {\n+    pub const F32: BuiltinFloat = BuiltinFloat { bitness: FloatBitness::X32 };\n+    pub const F64: BuiltinFloat = BuiltinFloat { bitness: FloatBitness::X64 };\n+\n+    pub fn from_suffix(suffix: &str) -> Option<BuiltinFloat> {\n+        let res = match suffix {\n+            \"f32\" => BuiltinFloat::F32,\n+            \"f64\" => BuiltinFloat::F64,\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+}"}, {"sha": "04c1d8f69b8651d41f511c241fcfd2fcd909d12d", "filename": "crates/ra_hir_def/src/expr.rs", "status": "added", "additions": 421, "deletions": 0, "changes": 421, "blob_url": "https://github.com/rust-lang/rust/blob/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs?ref=0525778a3ad590492b51cc11085d815f9bb8f92b", "patch": "@@ -0,0 +1,421 @@\n+//! This module describes hir-level representation of expressions.\n+//!\n+//! This representaion is:\n+//!\n+//! 1. Identity-based. Each expression has an `id`, so we can distinguish\n+//!    between different `1` in `1 + 1`.\n+//! 2. Independent of syntax. Though syntactic provenance information can be\n+//!    attached separately via id-based side map.\n+//! 3. Unresolved. Paths are stored as sequences of names, and not as defs the\n+//!    names refer to.\n+//! 4. Desugared. There's no `if let`.\n+//!\n+//! See also a neighboring `body` module.\n+\n+use hir_expand::name::Name;\n+use ra_arena::{impl_arena_id, RawId};\n+\n+use crate::{\n+    builtin_type::{BuiltinFloat, BuiltinInt},\n+    path::{GenericArgs, Path},\n+    type_ref::{Mutability, TypeRef},\n+};\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct ExprId(RawId);\n+impl_arena_id!(ExprId);\n+\n+impl ExprId {\n+    pub fn dummy() -> ExprId {\n+        ExprId((!0).into())\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct PatId(RawId);\n+impl_arena_id!(PatId);\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub enum Literal {\n+    String(String),\n+    ByteString(Vec<u8>),\n+    Char(char),\n+    Bool(bool),\n+    Int(u64, Option<BuiltinInt>),\n+    Float(u64, Option<BuiltinFloat>), // FIXME: f64 is not Eq\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub enum Expr {\n+    /// This is produced if syntax tree does not have a required expression piece.\n+    Missing,\n+    Path(Path),\n+    If {\n+        condition: ExprId,\n+        then_branch: ExprId,\n+        else_branch: Option<ExprId>,\n+    },\n+    Block {\n+        statements: Vec<Statement>,\n+        tail: Option<ExprId>,\n+    },\n+    Loop {\n+        body: ExprId,\n+    },\n+    While {\n+        condition: ExprId,\n+        body: ExprId,\n+    },\n+    For {\n+        iterable: ExprId,\n+        pat: PatId,\n+        body: ExprId,\n+    },\n+    Call {\n+        callee: ExprId,\n+        args: Vec<ExprId>,\n+    },\n+    MethodCall {\n+        receiver: ExprId,\n+        method_name: Name,\n+        args: Vec<ExprId>,\n+        generic_args: Option<GenericArgs>,\n+    },\n+    Match {\n+        expr: ExprId,\n+        arms: Vec<MatchArm>,\n+    },\n+    Continue,\n+    Break {\n+        expr: Option<ExprId>,\n+    },\n+    Return {\n+        expr: Option<ExprId>,\n+    },\n+    RecordLit {\n+        path: Option<Path>,\n+        fields: Vec<RecordLitField>,\n+        spread: Option<ExprId>,\n+    },\n+    Field {\n+        expr: ExprId,\n+        name: Name,\n+    },\n+    Await {\n+        expr: ExprId,\n+    },\n+    Try {\n+        expr: ExprId,\n+    },\n+    TryBlock {\n+        body: ExprId,\n+    },\n+    Cast {\n+        expr: ExprId,\n+        type_ref: TypeRef,\n+    },\n+    Ref {\n+        expr: ExprId,\n+        mutability: Mutability,\n+    },\n+    Box {\n+        expr: ExprId,\n+    },\n+    UnaryOp {\n+        expr: ExprId,\n+        op: UnaryOp,\n+    },\n+    BinaryOp {\n+        lhs: ExprId,\n+        rhs: ExprId,\n+        op: Option<BinaryOp>,\n+    },\n+    Index {\n+        base: ExprId,\n+        index: ExprId,\n+    },\n+    Lambda {\n+        args: Vec<PatId>,\n+        arg_types: Vec<Option<TypeRef>>,\n+        body: ExprId,\n+    },\n+    Tuple {\n+        exprs: Vec<ExprId>,\n+    },\n+    Array(Array),\n+    Literal(Literal),\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum BinaryOp {\n+    LogicOp(LogicOp),\n+    ArithOp(ArithOp),\n+    CmpOp(CmpOp),\n+    Assignment { op: Option<ArithOp> },\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum LogicOp {\n+    And,\n+    Or,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum CmpOp {\n+    Eq { negated: bool },\n+    Ord { ordering: Ordering, strict: bool },\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum Ordering {\n+    Less,\n+    Greater,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum ArithOp {\n+    Add,\n+    Mul,\n+    Sub,\n+    Div,\n+    Rem,\n+    Shl,\n+    Shr,\n+    BitXor,\n+    BitOr,\n+    BitAnd,\n+}\n+\n+pub use ra_syntax::ast::PrefixOp as UnaryOp;\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub enum Array {\n+    ElementList(Vec<ExprId>),\n+    Repeat { initializer: ExprId, repeat: ExprId },\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct MatchArm {\n+    pub pats: Vec<PatId>,\n+    pub guard: Option<ExprId>,\n+    pub expr: ExprId,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct RecordLitField {\n+    pub name: Name,\n+    pub expr: ExprId,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub enum Statement {\n+    Let { pat: PatId, type_ref: Option<TypeRef>, initializer: Option<ExprId> },\n+    Expr(ExprId),\n+}\n+\n+impl Expr {\n+    pub fn walk_child_exprs(&self, mut f: impl FnMut(ExprId)) {\n+        match self {\n+            Expr::Missing => {}\n+            Expr::Path(_) => {}\n+            Expr::If { condition, then_branch, else_branch } => {\n+                f(*condition);\n+                f(*then_branch);\n+                if let Some(else_branch) = else_branch {\n+                    f(*else_branch);\n+                }\n+            }\n+            Expr::Block { statements, tail } => {\n+                for stmt in statements {\n+                    match stmt {\n+                        Statement::Let { initializer, .. } => {\n+                            if let Some(expr) = initializer {\n+                                f(*expr);\n+                            }\n+                        }\n+                        Statement::Expr(e) => f(*e),\n+                    }\n+                }\n+                if let Some(expr) = tail {\n+                    f(*expr);\n+                }\n+            }\n+            Expr::TryBlock { body } => f(*body),\n+            Expr::Loop { body } => f(*body),\n+            Expr::While { condition, body } => {\n+                f(*condition);\n+                f(*body);\n+            }\n+            Expr::For { iterable, body, .. } => {\n+                f(*iterable);\n+                f(*body);\n+            }\n+            Expr::Call { callee, args } => {\n+                f(*callee);\n+                for arg in args {\n+                    f(*arg);\n+                }\n+            }\n+            Expr::MethodCall { receiver, args, .. } => {\n+                f(*receiver);\n+                for arg in args {\n+                    f(*arg);\n+                }\n+            }\n+            Expr::Match { expr, arms } => {\n+                f(*expr);\n+                for arm in arms {\n+                    f(arm.expr);\n+                }\n+            }\n+            Expr::Continue => {}\n+            Expr::Break { expr } | Expr::Return { expr } => {\n+                if let Some(expr) = expr {\n+                    f(*expr);\n+                }\n+            }\n+            Expr::RecordLit { fields, spread, .. } => {\n+                for field in fields {\n+                    f(field.expr);\n+                }\n+                if let Some(expr) = spread {\n+                    f(*expr);\n+                }\n+            }\n+            Expr::Lambda { body, .. } => {\n+                f(*body);\n+            }\n+            Expr::BinaryOp { lhs, rhs, .. } => {\n+                f(*lhs);\n+                f(*rhs);\n+            }\n+            Expr::Index { base, index } => {\n+                f(*base);\n+                f(*index);\n+            }\n+            Expr::Field { expr, .. }\n+            | Expr::Await { expr }\n+            | Expr::Try { expr }\n+            | Expr::Cast { expr, .. }\n+            | Expr::Ref { expr, .. }\n+            | Expr::UnaryOp { expr, .. }\n+            | Expr::Box { expr } => {\n+                f(*expr);\n+            }\n+            Expr::Tuple { exprs } => {\n+                for expr in exprs {\n+                    f(*expr);\n+                }\n+            }\n+            Expr::Array(a) => match a {\n+                Array::ElementList(exprs) => {\n+                    for expr in exprs {\n+                        f(*expr);\n+                    }\n+                }\n+                Array::Repeat { initializer, repeat } => {\n+                    f(*initializer);\n+                    f(*repeat)\n+                }\n+            },\n+            Expr::Literal(_) => {}\n+        }\n+    }\n+}\n+\n+/// Explicit binding annotations given in the HIR for a binding. Note\n+/// that this is not the final binding *mode* that we infer after type\n+/// inference.\n+#[derive(Clone, PartialEq, Eq, Debug, Copy)]\n+pub enum BindingAnnotation {\n+    /// No binding annotation given: this means that the final binding mode\n+    /// will depend on whether we have skipped through a `&` reference\n+    /// when matching. For example, the `x` in `Some(x)` will have binding\n+    /// mode `None`; if you do `let Some(x) = &Some(22)`, it will\n+    /// ultimately be inferred to be by-reference.\n+    Unannotated,\n+\n+    /// Annotated with `mut x` -- could be either ref or not, similar to `None`.\n+    Mutable,\n+\n+    /// Annotated as `ref`, like `ref x`\n+    Ref,\n+\n+    /// Annotated as `ref mut x`.\n+    RefMut,\n+}\n+\n+impl BindingAnnotation {\n+    pub fn new(is_mutable: bool, is_ref: bool) -> Self {\n+        match (is_mutable, is_ref) {\n+            (true, true) => BindingAnnotation::RefMut,\n+            (false, true) => BindingAnnotation::Ref,\n+            (true, false) => BindingAnnotation::Mutable,\n+            (false, false) => BindingAnnotation::Unannotated,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct RecordFieldPat {\n+    pub name: Name,\n+    pub pat: PatId,\n+}\n+\n+/// Close relative to rustc's hir::PatKind\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub enum Pat {\n+    Missing,\n+    Wild,\n+    Tuple(Vec<PatId>),\n+    Record {\n+        path: Option<Path>,\n+        args: Vec<RecordFieldPat>,\n+        // FIXME: 'ellipsis' option\n+    },\n+    Range {\n+        start: ExprId,\n+        end: ExprId,\n+    },\n+    Slice {\n+        prefix: Vec<PatId>,\n+        rest: Option<PatId>,\n+        suffix: Vec<PatId>,\n+    },\n+    Path(Path),\n+    Lit(ExprId),\n+    Bind {\n+        mode: BindingAnnotation,\n+        name: Name,\n+        subpat: Option<PatId>,\n+    },\n+    TupleStruct {\n+        path: Option<Path>,\n+        args: Vec<PatId>,\n+    },\n+    Ref {\n+        pat: PatId,\n+        mutability: Mutability,\n+    },\n+}\n+\n+impl Pat {\n+    pub fn walk_child_pats(&self, mut f: impl FnMut(PatId)) {\n+        match self {\n+            Pat::Range { .. } | Pat::Lit(..) | Pat::Path(..) | Pat::Wild | Pat::Missing => {}\n+            Pat::Bind { subpat, .. } => {\n+                subpat.iter().copied().for_each(f);\n+            }\n+            Pat::Tuple(args) | Pat::TupleStruct { args, .. } => {\n+                args.iter().copied().for_each(f);\n+            }\n+            Pat::Ref { pat, .. } => f(*pat),\n+            Pat::Slice { prefix, rest, suffix } => {\n+                let total_iter = prefix.iter().chain(rest.iter()).chain(suffix.iter());\n+                total_iter.copied().for_each(f);\n+            }\n+            Pat::Record { args, .. } => {\n+                args.iter().map(|f| f.pat).for_each(f);\n+            }\n+        }\n+    }\n+}"}, {"sha": "4a758bb835ed45c90a405c3c35ea8a8ec581cd59", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=0525778a3ad590492b51cc11085d815f9bb8f92b", "patch": "@@ -14,6 +14,8 @@ pub mod type_ref;\n pub mod builtin_type;\n pub mod adt;\n pub mod diagnostics;\n+pub mod expr;\n+pub mod body;\n \n #[cfg(test)]\n mod test_db;"}, {"sha": "010b45141fdca345d73bce4b277b531ac03395e8", "filename": "crates/ra_ide_api/src/change.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fchange.rs?ref=0525778a3ad590492b51cc11085d815f9bb8f92b", "patch": "@@ -276,7 +276,7 @@ impl RootDatabase {\n \n         self.query(hir::db::ExprScopesQuery).sweep(sweep);\n         self.query(hir::db::InferQuery).sweep(sweep);\n-        self.query(hir::db::BodyHirQuery).sweep(sweep);\n+        self.query(hir::db::BodyQuery).sweep(sweep);\n     }\n \n     pub(crate) fn per_query_memory_usage(&mut self) -> Vec<(String, Bytes)> {\n@@ -333,7 +333,7 @@ impl RootDatabase {\n             hir::db::GenericPredicatesQuery\n             hir::db::GenericDefaultsQuery\n             hir::db::BodyWithSourceMapQuery\n-            hir::db::BodyHirQuery\n+            hir::db::BodyQuery\n             hir::db::ImplsInCrateQuery\n             hir::db::ImplsForTraitQuery\n             hir::db::AssociatedTyDataQuery"}, {"sha": "cf88911b751b3a86e224f28155b1c63a734f266e", "filename": "crates/ra_project_model/src/cargo_workspace.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0525778a3ad590492b51cc11085d815f9bb8f92b/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs?ref=0525778a3ad590492b51cc11085d815f9bb8f92b", "patch": "@@ -1,6 +1,7 @@\n //! FIXME: write short doc here\n \n use std::path::{Path, PathBuf};\n+use std::str::FromStr;\n \n use cargo_metadata::{CargoOpt, MetadataCommand};\n use ra_arena::{impl_arena_id, Arena, RawId};\n@@ -140,18 +141,21 @@ impl CargoWorkspace {\n         let ws_members = &meta.workspace_members;\n \n         for meta_pkg in meta.packages {\n-            let is_member = ws_members.contains(&meta_pkg.id);\n+            let cargo_metadata::Package { id, edition, name, manifest_path, .. } = meta_pkg;\n+            let is_member = ws_members.contains(&id);\n+            let edition = Edition::from_str(&edition)\n+                .map_err(|e| (format!(\"metadata for package {} failed: {}\", &name, e.msg)))?;\n             let pkg = packages.alloc(PackageData {\n-                name: meta_pkg.name,\n-                manifest: meta_pkg.manifest_path.clone(),\n+                name,\n+                manifest: manifest_path,\n                 targets: Vec::new(),\n                 is_member,\n-                edition: Edition::from_string(&meta_pkg.edition),\n+                edition,\n                 dependencies: Vec::new(),\n                 features: Vec::new(),\n             });\n             let pkg_data = &mut packages[pkg];\n-            pkg_by_id.insert(meta_pkg.id.clone(), pkg);\n+            pkg_by_id.insert(id, pkg);\n             for meta_tgt in meta_pkg.targets {\n                 let tgt = targets.alloc(TargetData {\n                     pkg,"}, {"sha": "14121986017db8589e472098f5ca7eeaaf56b98e", "filename": "xtask/tests/tidy-tests/docs.rs", "status": "modified", "additions": 43, "deletions": 6, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/0525778a3ad590492b51cc11085d815f9bb8f92b/xtask%2Ftests%2Ftidy-tests%2Fdocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0525778a3ad590492b51cc11085d815f9bb8f92b/xtask%2Ftests%2Ftidy-tests%2Fdocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Ftests%2Ftidy-tests%2Fdocs.rs?ref=0525778a3ad590492b51cc11085d815f9bb8f92b", "patch": "@@ -1,10 +1,6 @@\n-use std::fs;\n-use std::io::prelude::*;\n-use std::io::BufReader;\n-use std::path::Path;\n+use std::{collections::HashMap, fs, io::prelude::*, io::BufReader, path::Path};\n \n use walkdir::{DirEntry, WalkDir};\n-\n use xtask::project_root;\n \n fn is_exclude_dir(p: &Path) -> bool {\n@@ -37,6 +33,7 @@ fn no_docs_comments() {\n     let crates = project_root().join(\"crates\");\n     let iter = WalkDir::new(crates);\n     let mut missing_docs = Vec::new();\n+    let mut contains_fixme = Vec::new();\n     for f in iter.into_iter().filter_entry(|e| !is_hidden(e)) {\n         let f = f.unwrap();\n         if f.file_type().is_dir() {\n@@ -54,7 +51,12 @@ fn no_docs_comments() {\n         let mut reader = BufReader::new(fs::File::open(f.path()).unwrap());\n         let mut line = String::new();\n         reader.read_line(&mut line).unwrap();\n-        if !line.starts_with(\"//!\") {\n+\n+        if line.starts_with(\"//!\") {\n+            if line.contains(\"FIXME\") {\n+                contains_fixme.push(f.path().to_path_buf())\n+            }\n+        } else {\n             missing_docs.push(f.path().display().to_string());\n         }\n     }\n@@ -65,4 +67,39 @@ fn no_docs_comments() {\n             missing_docs.join(\"\\n\")\n         )\n     }\n+\n+    let whitelist = [\n+        \"ra_batch\",\n+        \"ra_cli\",\n+        \"ra_db\",\n+        \"ra_hir\",\n+        \"ra_hir_expand\",\n+        \"ra_hir_def\",\n+        \"ra_ide_api\",\n+        \"ra_lsp_server\",\n+        \"ra_mbe\",\n+        \"ra_parser\",\n+        \"ra_prof\",\n+        \"ra_project_model\",\n+        \"ra_syntax\",\n+        \"ra_text_edit\",\n+        \"ra_tt\",\n+    ];\n+\n+    let mut has_fixmes = whitelist.iter().map(|it| (*it, false)).collect::<HashMap<&str, bool>>();\n+    'outer: for path in contains_fixme {\n+        for krate in whitelist.iter() {\n+            if path.components().any(|it| it.as_os_str() == *krate) {\n+                has_fixmes.insert(krate, true);\n+                continue 'outer;\n+            }\n+        }\n+        panic!(\"FIXME doc in a fully-documented crate: {}\", path.display())\n+    }\n+\n+    for (krate, has_fixme) in has_fixmes.iter() {\n+        if !has_fixme {\n+            panic!(\"crate {} is fully documented, remove it from the white list\", krate)\n+        }\n+    }\n }"}]}