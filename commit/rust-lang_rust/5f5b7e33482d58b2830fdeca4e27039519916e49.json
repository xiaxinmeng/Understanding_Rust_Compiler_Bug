{"sha": "5f5b7e33482d58b2830fdeca4e27039519916e49", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmNWI3ZTMzNDgyZDU4YjI4MzBmZGVjYTRlMjcwMzk1MTk5MTZlNDk=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-28T18:23:53Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-28T18:24:34Z"}, "message": "rustc: Don't call cmp glue if the type is a simple scalar", "tree": {"sha": "27d69d8a8361f01207d28a6011985d1bb3054156", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27d69d8a8361f01207d28a6011985d1bb3054156"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f5b7e33482d58b2830fdeca4e27039519916e49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f5b7e33482d58b2830fdeca4e27039519916e49", "html_url": "https://github.com/rust-lang/rust/commit/5f5b7e33482d58b2830fdeca4e27039519916e49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f5b7e33482d58b2830fdeca4e27039519916e49/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0dc2aa3d09661a6943e64887137cc4ef07366a56", "url": "https://api.github.com/repos/rust-lang/rust/commits/0dc2aa3d09661a6943e64887137cc4ef07366a56", "html_url": "https://github.com/rust-lang/rust/commit/0dc2aa3d09661a6943e64887137cc4ef07366a56"}], "stats": {"total": 99, "additions": 60, "deletions": 39}, "files": [{"sha": "aed4d3b753e27f2b0d162b5cbd213cdd3078ee45", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 60, "deletions": 39, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/5f5b7e33482d58b2830fdeca4e27039519916e49/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f5b7e33482d58b2830fdeca4e27039519916e49/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=5f5b7e33482d58b2830fdeca4e27039519916e49", "patch": "@@ -2199,7 +2199,7 @@ fn make_cmp_glue(&@block_ctxt cx, ValueRef lhs0, ValueRef rhs0, &ty::t t,\n             alt (ty::struct(cx.fcx.lcx.ccx.tcx, t)) {\n                 case (ty::ty_box(?ti)) { ti.ty }\n             };\n-        auto rslt = call_cmp_glue(cx, lhs, rhs, t_inner, llop);\n+        auto rslt = compare(cx, lhs, rhs, t_inner, llop);\n         rslt.bcx.build.Store(rslt.val, cx.fcx.llretptr);\n         rslt.bcx.build.RetVoid();\n     } else if (ty::type_is_structural(cx.fcx.lcx.ccx.tcx, t) ||\n@@ -2291,14 +2291,13 @@ fn make_cmp_glue(&@block_ctxt cx, ValueRef lhs0, ValueRef rhs0, &ty::t t,\n                 av = load_if_immediate(cx, av, t);\n                 bv = load_if_immediate(cx, bv, t);\n             }\n-            // First 'eq' comparison: if so, continue to next elts.\n \n-            auto eq_r =\n-                call_cmp_glue(cx, av, bv, t, C_u8(abi::cmp_glue_op_eq));\n+            // First 'eq' comparison: if so, continue to next elts.\n+            auto eq_r = compare(cx, av, bv, t, C_u8(abi::cmp_glue_op_eq));\n             eq_r.bcx.build.CondBr(eq_r.val, cnt_cx.llbb, stop_cx.llbb);\n-            // Second 'op' comparison: find out how this elt-pair decides.\n \n-            auto stop_r = call_cmp_glue(stop_cx, av, bv, t, llop);\n+            // Second 'op' comparison: find out how this elt-pair decides.\n+            auto stop_r = compare(stop_cx, av, bv, t, llop);\n             stop_r.bcx.build.Store(stop_r.val, flag);\n             stop_r.bcx.build.Br(last_cx.llbb);\n             ret rslt(cnt_cx, C_nil());\n@@ -2339,63 +2338,75 @@ fn make_cmp_glue(&@block_ctxt cx, ValueRef lhs0, ValueRef rhs0, &ty::t t,\n tag numerical_type { signed_int; unsigned_int; floating_point; }\n \n \n-// A helper function to create scalar comparison glue.\n-fn make_scalar_cmp_glue(&@block_ctxt cx, ValueRef lhs, ValueRef rhs, &ty::t t,\n-                        ValueRef llop) {\n-    // assert ty::type_is_scalar(cx.fcx.lcx.ccx.tcx, t);\n-\n-    // In most cases, we need to know whether to do signed, unsigned, or float\n-    // comparison.\n-\n-    auto f = bind make_numerical_cmp_glue(cx, lhs, rhs, _, llop);\n-\n+fn compare_scalar_types(@block_ctxt cx, ValueRef lhs, ValueRef rhs, &ty::t t,\n+                        ValueRef llop) -> result {\n     // FIXME: this could be a lot shorter if we could combine multiple cases\n     // of alt expressions (issue #449).\n+\n+    auto f = bind compare_numerical_values(cx, lhs, rhs, _, llop);\n+\n     alt (ty::struct(cx.fcx.lcx.ccx.tcx, t)) {\n-        case (ty::ty_nil) {\n-            cx.build.Store(C_bool(true), cx.fcx.llretptr);\n-            cx.build.RetVoid();\n-        }\n-        case (ty::ty_bool) { f(unsigned_int); }\n-        case (ty::ty_int) { f(signed_int); }\n-        case (ty::ty_float) { f(floating_point); }\n-        case (ty::ty_uint) { f(unsigned_int); }\n+        case (ty::ty_nil) { ret rslt(cx, C_bool(true)); }\n+        case (ty::ty_bool) { ret f(unsigned_int); }\n+        case (ty::ty_int) { ret f(signed_int); }\n+        case (ty::ty_float) { ret f(floating_point); }\n+        case (ty::ty_uint) { ret f(unsigned_int); }\n         case (ty::ty_machine(_)) {\n \n-            // Floating point machine types\n             if (ty::type_is_fp(cx.fcx.lcx.ccx.tcx, t)) {\n-                f(floating_point);\n-            } else if (\n-             // Signed, integral machine types\n-             ty::type_is_signed(cx.fcx.lcx.ccx.tcx, t)) {\n-                f(signed_int);\n-            } else \n-             // Unsigned, integral machine types\n-             {\n-                f(unsigned_int);\n+                // Floating point machine types\n+                ret f(floating_point);\n+            } else if (ty::type_is_signed(cx.fcx.lcx.ccx.tcx, t)) {\n+                // Signed, integral machine types\n+                ret f(signed_int);\n+            } else {\n+                // Unsigned, integral machine types\n+                ret f(unsigned_int);\n             }\n         }\n-        case (ty::ty_char) { f(unsigned_int); }\n+        case (ty::ty_char) { ret f(unsigned_int); }\n         case (ty::ty_type) {\n             trans_fail(cx, none[common::span],\n                        \"attempt to compare values of type type\");\n+\n+            // This is a bit lame, because we return a dummy block to the\n+            // caller that's actually unreachable, but I don't think it\n+            // matters.\n+            ret rslt(new_sub_block_ctxt(cx, \"after_fail_dummy\"),\n+                     C_bool(false));\n         }\n         case (ty::ty_native) {\n             trans_fail(cx, none[common::span],\n                        \"attempt to compare values of type native\");\n+            ret rslt(new_sub_block_ctxt(cx, \"after_fail_dummy\"),\n+                     C_bool(false));\n         }\n         case (ty::ty_ptr(_)) {\n-            f(unsigned_int);\n+            ret f(unsigned_int);\n         }\n         case (_) {\n             // Should never get here, because t is scalar.\n-\n             cx.fcx.lcx.ccx.sess.bug(\"non-scalar type passed to \" +\n-                                        \"make_scalar_cmp_glue\");\n+                                    \"compare_scalar_types\");\n         }\n     }\n }\n \n+// A helper function to create scalar comparison glue.\n+fn make_scalar_cmp_glue(&@block_ctxt cx, ValueRef lhs, ValueRef rhs, &ty::t t,\n+                        ValueRef llop) {\n+    assert ty::type_is_scalar(cx.fcx.lcx.ccx.tcx, t);\n+\n+    // In most cases, we need to know whether to do signed, unsigned, or float\n+    // comparison.\n+\n+    auto rslt = compare_scalar_types(cx, lhs, rhs, t, llop);\n+    auto bcx = rslt.bcx;\n+    auto compare_result = rslt.val;\n+    bcx.build.Store(compare_result, cx.fcx.llretptr);\n+    bcx.build.RetVoid();\n+}\n+\n \n // A helper function to compare numerical values.\n fn compare_numerical_values(&@block_ctxt cx, ValueRef lhs, ValueRef rhs,\n@@ -3032,6 +3043,16 @@ fn call_cmp_glue(&@block_ctxt cx, ValueRef lhs, ValueRef rhs, &ty::t t,\n     ret rslt(r.bcx, r.bcx.build.Load(llcmpresultptr));\n }\n \n+// Compares two values. Performs the simple scalar comparison if the types are\n+// scalar and calls to comparison glue otherwise.\n+fn compare(&@block_ctxt cx, ValueRef lhs, ValueRef rhs, &ty::t t,\n+           ValueRef llop) -> result {\n+    if (ty::type_is_scalar(cx.fcx.lcx.ccx.tcx, t)) {\n+        ret compare_scalar_types(cx, lhs, rhs, t, llop);\n+    }\n+    ret call_cmp_glue(cx, lhs, rhs, t, llop);\n+}\n+\n fn take_ty(&@block_ctxt cx, ValueRef v, ty::t t) -> result {\n     if (ty::type_has_pointers(cx.fcx.lcx.ccx.tcx, t)) {\n         ret call_tydesc_glue(cx, v, t, abi::tydesc_field_take_glue);\n@@ -3327,7 +3348,7 @@ fn trans_compare(&@block_ctxt cx0, ast::binop op, &ty::t t0, ValueRef lhs0,\n         case (ast::ge) { llop = C_u8(abi::cmp_glue_op_lt); }\n         case (ast::gt) { llop = C_u8(abi::cmp_glue_op_le); }\n     }\n-    auto rs = call_cmp_glue(cx, lhs, rhs, t, llop);\n+    auto rs = compare(cx, lhs, rhs, t, llop);\n \n     // Invert the result if necessary.\n     // FIXME: Use or-patterns when we have them."}]}