{"sha": "668225d157d91e5c55a02aa7abc1b65ec9690ffa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2ODIyNWQxNTdkOTFlNWM1NWEwMmFhN2FiYzFiNjVlYzk2OTBmZmE=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-09-21T18:42:40Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-09-21T18:43:44Z"}, "message": "Revert \"Revert adding Atomic::from_mut.\"\n\nThis reverts commit 5ef1db3622c373883571868cbdafbfbd568cddcb.", "tree": {"sha": "83002bb2105ef36d6ad0a61f5dc4bba077e754d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83002bb2105ef36d6ad0a61f5dc4bba077e754d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/668225d157d91e5c55a02aa7abc1b65ec9690ffa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/668225d157d91e5c55a02aa7abc1b65ec9690ffa", "html_url": "https://github.com/rust-lang/rust/commit/668225d157d91e5c55a02aa7abc1b65ec9690ffa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/668225d157d91e5c55a02aa7abc1b65ec9690ffa/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54fdf54e06e3287958d906d2fb1b905b778d5e38", "url": "https://api.github.com/repos/rust-lang/rust/commits/54fdf54e06e3287958d906d2fb1b905b778d5e38", "html_url": "https://github.com/rust-lang/rust/commit/54fdf54e06e3287958d906d2fb1b905b778d5e38"}], "stats": {"total": 90, "additions": 90, "deletions": 0}, "files": [{"sha": "c67d6422c01ec9f6dc107eae1b821eb35a7537d1", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/668225d157d91e5c55a02aa7abc1b65ec9690ffa/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/668225d157d91e5c55a02aa7abc1b65ec9690ffa/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=668225d157d91e5c55a02aa7abc1b65ec9690ffa", "patch": "@@ -110,6 +110,7 @@ use self::Ordering::*;\n use crate::cell::UnsafeCell;\n use crate::fmt;\n use crate::intrinsics;\n+use crate::mem::align_of;\n \n use crate::hint::spin_loop;\n \n@@ -327,6 +328,27 @@ impl AtomicBool {\n         unsafe { &mut *(self.v.get() as *mut bool) }\n     }\n \n+    /// Get atomic access to a `&mut bool`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(atomic_from_mut)]\n+    /// use std::sync::atomic::{AtomicBool, Ordering};\n+    ///\n+    /// let mut some_bool = true;\n+    /// let a = AtomicBool::from_mut(&mut some_bool);\n+    /// a.store(false, Ordering::Relaxed);\n+    /// assert_eq!(some_bool, false);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"atomic_from_mut\", issue = \"76314\")]\n+    pub fn from_mut(v: &mut bool) -> &Self {\n+        // SAFETY: the mutable reference guarantees unique ownership, and\n+        // alignment of both `bool` and `Self` is 1.\n+        unsafe { &*(v as *mut bool as *mut Self) }\n+    }\n+\n     /// Consumes the atomic and returns the contained value.\n     ///\n     /// This is safe because passing `self` by value guarantees that no other threads are\n@@ -819,6 +841,30 @@ impl<T> AtomicPtr<T> {\n         self.p.get_mut()\n     }\n \n+    /// Get atomic access to a pointer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(atomic_from_mut)]\n+    /// use std::sync::atomic::{AtomicPtr, Ordering};\n+    ///\n+    /// let mut some_ptr = &mut 123 as *mut i32;\n+    /// let a = AtomicPtr::from_mut(&mut some_ptr);\n+    /// a.store(&mut 456, Ordering::Relaxed);\n+    /// assert_eq!(unsafe { *some_ptr }, 456);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"atomic_from_mut\", issue = \"76314\")]\n+    pub fn from_mut(v: &mut *mut T) -> &Self {\n+        let [] = [(); align_of::<AtomicPtr<()>>() - align_of::<*mut ()>()];\n+        // SAFETY:\n+        //  - the mutable reference guarantees unique ownership.\n+        //  - the alignment of `*mut T` and `Self` is the same on all platforms\n+        //    supported by rust, as verified above.\n+        unsafe { &*(v as *mut *mut T as *mut Self) }\n+    }\n+\n     /// Consumes the atomic and returns the contained value.\n     ///\n     /// This is safe because passing `self` by value guarantees that no other threads are\n@@ -1121,6 +1167,7 @@ macro_rules! atomic_int {\n      $stable_nand:meta,\n      $const_stable:meta,\n      $stable_init_const:meta,\n+     $(from_mut: cfg($from_mut_cfg:meta),)?\n      $s_int_type:literal, $int_ref:expr,\n      $extra_feature:expr,\n      $min_fn:ident, $max_fn:ident,\n@@ -1231,6 +1278,45 @@ assert_eq!(some_var.load(Ordering::SeqCst), 5);\n                 }\n             }\n \n+            doc_comment! {\n+                concat!(\"Get atomic access to a `&mut \", stringify!($int_type), \"`.\n+\n+\",\n+if_not_8_bit! {\n+    $int_type,\n+    concat!(\n+        \"**Note:** This function is only available on targets where `\",\n+        stringify!($int_type), \"` has an alignment of \", $align, \" bytes.\"\n+    )\n+},\n+\"\n+\n+# Examples\n+\n+```\n+#![feature(atomic_from_mut)]\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let mut some_int = 123;\n+let a = \", stringify!($atomic_type), \"::from_mut(&mut some_int);\n+a.store(100, Ordering::Relaxed);\n+assert_eq!(some_int, 100);\n+```\n+                \"),\n+                #[inline]\n+                $(#[cfg($from_mut_cfg)])?\n+                #[unstable(feature = \"atomic_from_mut\", issue = \"76314\")]\n+                pub fn from_mut(v: &mut $int_type) -> &Self {\n+                    let [] = [(); align_of::<Self>() - align_of::<$int_type>()];\n+                    // SAFETY:\n+                    //  - the mutable reference guarantees unique ownership.\n+                    //  - the alignment of `$int_type` and `Self` is the\n+                    //    same on all platforms enabled by `$from_mut_cfg`\n+                    //    as verified above.\n+                    unsafe { &*(v as *mut $int_type as *mut Self) }\n+                }\n+            }\n+\n             doc_comment! {\n                 concat!(\"Consumes the atomic and returns the contained value.\n \n@@ -1989,6 +2075,7 @@ atomic_int! {\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    from_mut: cfg(not(target_arch = \"x86\")),\n     \"i64\", \"../../../std/primitive.i64.html\",\n     \"\",\n     atomic_min, atomic_max,\n@@ -2007,6 +2094,7 @@ atomic_int! {\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    from_mut: cfg(not(target_arch = \"x86\")),\n     \"u64\", \"../../../std/primitive.u64.html\",\n     \"\",\n     atomic_umin, atomic_umax,\n@@ -2025,6 +2113,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    from_mut: cfg(not(target_arch = \"x86_64\")),\n     \"i128\", \"../../../std/primitive.i128.html\",\n     \"#![feature(integer_atomics)]\\n\\n\",\n     atomic_min, atomic_max,\n@@ -2043,6 +2132,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    from_mut: cfg(not(target_arch = \"x86_64\")),\n     \"u128\", \"../../../std/primitive.u128.html\",\n     \"#![feature(integer_atomics)]\\n\\n\",\n     atomic_umin, atomic_umax,"}]}