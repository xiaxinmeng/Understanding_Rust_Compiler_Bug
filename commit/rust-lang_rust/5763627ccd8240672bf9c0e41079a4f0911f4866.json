{"sha": "5763627ccd8240672bf9c0e41079a4f0911f4866", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3NjM2MjdjY2Q4MjQwNjcyYmY5YzBlNDEwNzlhNGYwOTExZjQ4NjY=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2019-11-29T15:04:40Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2019-12-20T03:47:28Z"}, "message": "save LTO import information and check it when trying to reuse build products.\n\nadopts simple strategy devised with assistance from mw: Instead of accumulating\n(and acting upon) LTO import information over an unbounded number of prior\ncompilations, just see if the current import set matches the previous import set.\nif they don't match, then you cannot reuse the PostLTO build product for that\nmodule.\n\nIn either case (of a match or a non-match), we can (and must) unconditionally\nemit the current import set as the recorded information in the incremental\ncompilation cache, ready to be loaded during the next compiler run for use in\nthe same check described above.\n\nresolves issue 59535.", "tree": {"sha": "0f551ccb570abaf874d7a2c6e2074fd12021ba8e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f551ccb570abaf874d7a2c6e2074fd12021ba8e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5763627ccd8240672bf9c0e41079a4f0911f4866", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5763627ccd8240672bf9c0e41079a4f0911f4866", "html_url": "https://github.com/rust-lang/rust/commit/5763627ccd8240672bf9c0e41079a4f0911f4866", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5763627ccd8240672bf9c0e41079a4f0911f4866/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19b3813b5eab1988312f222e4316d3a225e20966", "url": "https://api.github.com/repos/rust-lang/rust/commits/19b3813b5eab1988312f222e4316d3a225e20966", "html_url": "https://github.com/rust-lang/rust/commit/19b3813b5eab1988312f222e4316d3a225e20966"}], "stats": {"total": 124, "additions": 114, "deletions": 10}, "files": [{"sha": "6481ef5c73ce011eb7ba27c37914ce4c10dd15f8", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 114, "deletions": 10, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/5763627ccd8240672bf9c0e41079a4f0911f4866/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5763627ccd8240672bf9c0e41079a4f0911f4866/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=5763627ccd8240672bf9c0e41079a4f0911f4866", "patch": "@@ -16,15 +16,24 @@ use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::middle::exported_symbols::SymbolExportLevel;\n use rustc::session::config::{self, Lto};\n use rustc::util::common::time_ext;\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use rustc_codegen_ssa::{RLIB_BYTECODE_EXTENSION, ModuleCodegen, ModuleKind};\n use log::{info, debug};\n \n use std::ffi::{CStr, CString};\n+use std::fs::File;\n+use std::io;\n+use std::mem;\n+use std::path::Path;\n use std::ptr;\n use std::slice;\n use std::sync::Arc;\n \n+/// We keep track of past LTO imports that were used to produce the current set\n+/// of compiled object files that we might choose to reuse during this\n+/// compilation session.\n+pub const THIN_LTO_IMPORTS_INCR_COMP_FILE_NAME: &str = \"thin-lto-past-imports.bin\";\n+\n pub fn crate_type_allows_lto(crate_type: config::CrateType) -> bool {\n     match crate_type {\n         config::CrateType::Executable |\n@@ -472,13 +481,26 @@ fn thin_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n \n         info!(\"thin LTO data created\");\n \n-        let import_map = if cgcx.incr_comp_session_dir.is_some() {\n-            ThinLTOImports::from_thin_lto_data(data)\n+        let (import_map_path, prev_import_map, curr_import_map) =\n+            if let Some(ref incr_comp_session_dir) = cgcx.incr_comp_session_dir\n+        {\n+            let path = incr_comp_session_dir.join(THIN_LTO_IMPORTS_INCR_COMP_FILE_NAME);\n+            // If previous imports have been deleted, or we get an IO error\n+            // reading the file storing them, then we'll just use `None` as the\n+            // prev_import_map, which will force the code to be recompiled.\n+            let prev = if path.exists() {\n+                ThinLTOImports::load_from_file(&path).ok()\n+            } else {\n+                None\n+            };\n+            let curr = ThinLTOImports::from_thin_lto_data(data);\n+            (Some(path), prev, curr)\n         } else {\n             // If we don't compile incrementally, we don't need to load the\n             // import data from LLVM.\n             assert!(green_modules.is_empty());\n-            ThinLTOImports::default()\n+            let curr = ThinLTOImports::default();\n+            (None, None, curr)\n         };\n         info!(\"thin LTO import map loaded\");\n \n@@ -502,18 +524,36 @@ fn thin_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         for (module_index, module_name) in shared.module_names.iter().enumerate() {\n             let module_name = module_name_to_str(module_name);\n \n-            // If the module hasn't changed and none of the modules it imports\n-            // from has changed, we can re-use the post-ThinLTO version of the\n-            // module.\n-            if green_modules.contains_key(module_name) {\n-                let imports_all_green = import_map.modules_imported_by(module_name)\n+            // If (1.) the module hasn't changed, and (2.) none of the modules\n+            // it imports from has changed, *and* (3.) the import-set itself has\n+            // not changed from the previous compile when it was last\n+            // ThinLTO'ed, then we can re-use the post-ThinLTO version of the\n+            // module. Otherwise, freshly perform LTO optimization.\n+            //\n+            // This strategy means we can always save the computed imports as\n+            // canon: when we reuse the post-ThinLTO version, condition (3.)\n+            // ensures that the curent import set is the same as the previous\n+            // one. (And of course, when we don't reuse the post-ThinLTO\n+            // version, the current import set *is* the correct one, since we\n+            // are doing the ThinLTO in this current compilation cycle.)\n+            //\n+            // See rust-lang/rust#59535.\n+            if let (Some(prev_import_map), true) =\n+                (prev_import_map.as_ref(), green_modules.contains_key(module_name))\n+            {\n+                assert!(cgcx.incr_comp_session_dir.is_some());\n+\n+                let prev_imports = prev_import_map.modules_imported_by(module_name);\n+                let curr_imports = curr_import_map.modules_imported_by(module_name);\n+                let imports_all_green = curr_imports\n                     .iter()\n                     .all(|imported_module| green_modules.contains_key(imported_module));\n \n-                if imports_all_green {\n+                if imports_all_green && equivalent_as_sets(prev_imports, curr_imports) {\n                     let work_product = green_modules[module_name].clone();\n                     copy_jobs.push(work_product);\n                     info!(\" - {}: re-used\", module_name);\n+                    assert!(cgcx.incr_comp_session_dir.is_some());\n                     cgcx.cgu_reuse_tracker.set_actual_reuse(module_name,\n                                                             CguReuse::PostLto);\n                     continue\n@@ -527,10 +567,33 @@ fn thin_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n             }));\n         }\n \n+        // Save the curent ThinLTO import information for the next compilation\n+        // session, overwriting the previous serialized imports (if any).\n+        if let Some(path) = import_map_path {\n+            if let Err(err) = curr_import_map.save_to_file(&path) {\n+                let msg = format!(\"Error while writing ThinLTO import data: {}\", err);\n+                return Err(write::llvm_err(&diag_handler, &msg));\n+            }\n+        }\n+\n         Ok((opt_jobs, copy_jobs))\n     }\n }\n \n+/// Given two slices, each with no repeat elements. returns true if and only if\n+/// the two slices have the same contents when considered as sets (i.e. when\n+/// element order is disregarded).\n+fn equivalent_as_sets(a: &[String], b: &[String]) -> bool {\n+    // cheap path: unequal lengths means cannot possibly be set equivalent.\n+    if a.len() != b.len() { return false; }\n+    // fast path: before building new things, check if inputs are equivalent as is.\n+    if a == b { return true; }\n+    // slow path: general set comparison.\n+    let a: FxHashSet<&str> = a.iter().map(|s| s.as_str()).collect();\n+    let b: FxHashSet<&str> = b.iter().map(|s| s.as_str()).collect();\n+    a == b\n+}\n+\n pub(crate) fn run_pass_manager(cgcx: &CodegenContext<LlvmCodegenBackend>,\n                     module: &ModuleCodegen<ModuleLlvm>,\n                     config: &ModuleConfig,\n@@ -832,6 +895,47 @@ impl ThinLTOImports {\n         self.imports.get(llvm_module_name).map(|v| &v[..]).unwrap_or(&[])\n     }\n \n+    fn save_to_file(&self, path: &Path) -> io::Result<()> {\n+        use std::io::Write;\n+        let file = File::create(path)?;\n+        let mut writer = io::BufWriter::new(file);\n+        for (importing_module_name, imported_modules) in &self.imports {\n+            writeln!(writer, \"{}\", importing_module_name)?;\n+            for imported_module in imported_modules {\n+                writeln!(writer, \" {}\", imported_module)?;\n+            }\n+            writeln!(writer)?;\n+        }\n+        Ok(())\n+    }\n+\n+    fn load_from_file(path: &Path) -> io::Result<ThinLTOImports> {\n+        use std::io::BufRead;\n+        let mut imports = FxHashMap::default();\n+        let mut current_module = None;\n+        let mut current_imports = vec![];\n+        let file = File::open(path)?;\n+        for line in io::BufReader::new(file).lines() {\n+            let line = line?;\n+            if line.is_empty() {\n+                let importing_module = current_module\n+                    .take()\n+                    .expect(\"Importing module not set\");\n+                imports.insert(importing_module,\n+                               mem::replace(&mut current_imports, vec![]));\n+            } else if line.starts_with(\" \") {\n+                // Space marks an imported module\n+                assert_ne!(current_module, None);\n+                current_imports.push(line.trim().to_string());\n+            } else {\n+                // Otherwise, beginning of a new module (must be start or follow empty line)\n+                assert_eq!(current_module, None);\n+                current_module = Some(line.trim().to_string());\n+            }\n+        }\n+        Ok(ThinLTOImports { imports })\n+    }\n+\n     /// Loads the ThinLTO import map from ThinLTOData.\n     unsafe fn from_thin_lto_data(data: *const llvm::ThinLTOData) -> ThinLTOImports {\n         unsafe extern \"C\" fn imported_module_callback(payload: *mut libc::c_void,"}]}