{"sha": "be7325073acb63ed76861de387c6035d714c26db", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlNzMyNTA3M2FjYjYzZWQ3Njg2MWRlMzg3YzYwMzVkNzE0YzI2ZGI=", "commit": {"author": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-08-13T22:20:11Z"}, "committer": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-08-15T16:26:52Z"}, "message": "Removed spawn and task from the parser. Updated all the tests except for the benchmarks.", "tree": {"sha": "551adfe941a9d543958e764b45b6aca1fc94bdc1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/551adfe941a9d543958e764b45b6aca1fc94bdc1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be7325073acb63ed76861de387c6035d714c26db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be7325073acb63ed76861de387c6035d714c26db", "html_url": "https://github.com/rust-lang/rust/commit/be7325073acb63ed76861de387c6035d714c26db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be7325073acb63ed76861de387c6035d714c26db/comments", "author": null, "committer": null, "parents": [{"sha": "c3535f58427aed5aed891f302de728b0b809838c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3535f58427aed5aed891f302de728b0b809838c", "html_url": "https://github.com/rust-lang/rust/commit/c3535f58427aed5aed891f302de728b0b809838c"}], "stats": {"total": 632, "additions": 367, "deletions": 265}, "files": [{"sha": "a0ee9d785d0f79008a3171c3dd8b59bfb7881156", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be7325073acb63ed76861de387c6035d714c26db/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7325073acb63ed76861de387c6035d714c26db/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=be7325073acb63ed76861de387c6035d714c26db", "patch": "@@ -475,8 +475,10 @@ fn parse_ty(p: &parser) -> @ast::ty {\n         t = ast::ty_istr;\n     } else if (eat_word(p, \"char\")) {\n         t = ast::ty_char;\n+/*\n     } else if (eat_word(p, \"task\")) {\n         t = ast::ty_task;\n+*/\n     } else if (eat_word(p, \"i8\")) {\n         t = ast::ty_machine(ast::ty_i8);\n     } else if (eat_word(p, \"i16\")) {\n@@ -804,8 +806,10 @@ fn parse_bottom_expr(p: &parser) -> @ast::expr {\n         ret parse_do_while_expr(p);\n     } else if (eat_word(p, \"alt\")) {\n         ret parse_alt_expr(p);\n+/*\n     } else if (eat_word(p, \"spawn\")) {\n         ret parse_spawn_expr(p);\n+*/\n     } else if (eat_word(p, \"fn\")) {\n         ret parse_fn_expr(p, ast::proto_fn);\n     } else if (eat_word(p, \"block\")) {"}, {"sha": "afc3bcadccdf5e8f693e21161e236ca61659aefa", "filename": "src/lib/aio.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/be7325073acb63ed76861de387c6035d714c26db/src%2Flib%2Faio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7325073acb63ed76861de387c6035d714c26db/src%2Flib%2Faio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Faio.rs?ref=be7325073acb63ed76861de387c6035d714c26db", "patch": "@@ -1,4 +1,5 @@\n import str::sbuf;\n+import task;\n \n native \"rust\" mod rustrt {\n     type socket;\n@@ -102,7 +103,7 @@ fn server_task(ip: str, portnum: int, events: chan[server_event],\n           log \"client was actually null, returning\";\n           ret;\n         } else {\n-          spawn accept_task(client, events);\n+          task::_spawn(bind accept_task(client, events));\n         }\n     }\n }\n@@ -126,10 +127,10 @@ fn request_task(c: chan[ctx]) {\n                 ret;\n             }\n             connect(remote(ip,portnum),client) {\n-                spawn connect_task(ip, portnum, client);\n+                task::_spawn(bind connect_task(ip, portnum, client));\n             }\n             serve(ip,portnum,events,server) {\n-                spawn server_task(ip, portnum, events, server);\n+                task::_spawn(bind server_task(ip, portnum, events, server));\n             }\n             write(socket,v,status) {\n                 rustrt::aio_writedata(socket,\n@@ -155,19 +156,19 @@ fn iotask(c: chan[ctx]) {\n \n     log \"io task init\";\n     // Spawn our request task\n-    let reqtask: task = spawn request_task(c);\n+    let reqtask = task::_spawn(bind request_task(c));\n \n     log \"uv run task init\";\n     // Enter IO loop. This never returns until aio_stop is called.\n     rustrt::aio_run();\n     log \"waiting for request task to finish\";\n \n-    task::join(reqtask);\n+    task::join_id(reqtask);\n }\n \n fn new() -> ctx {\n     let p: port[ctx] = port();\n-    let t: task = spawn iotask(chan(p));\n+    let t = task::_spawn(bind iotask(chan(p)));\n     let cx: ctx;\n     p |> cx;\n     ret cx;"}, {"sha": "b0148d8a750bb0f49bc2a4b6cec1a208099db3e5", "filename": "src/lib/task.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/be7325073acb63ed76861de387c6035d714c26db/src%2Flib%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7325073acb63ed76861de387c6035d714c26db/src%2Flib%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftask.rs?ref=be7325073acb63ed76861de387c6035d714c26db", "patch": "@@ -43,9 +43,12 @@ fn yield() { ret rustrt::task_yield(); }\n \n tag task_result { tr_success; tr_failure; }\n \n+// FIXME: Re-enable this once the task type is removed from the compiler.\n+/*\n fn join(t: task) -> task_result {\n     join_id(cast(t))\n }\n+*/\n \n fn join_id(t : task_id) -> task_result {\n     alt rustrt::task_join(t) { 0 { tr_success } _ { tr_failure } }"}, {"sha": "abff663a8da41cd2e2b40303412199e430966c2d", "filename": "src/lib/test.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/be7325073acb63ed76861de387c6035d714c26db/src%2Flib%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7325073acb63ed76861de387c6035d714c26db/src%2Flib%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftest.rs?ref=be7325073acb63ed76861de387c6035d714c26db", "patch": "@@ -4,6 +4,7 @@\n // while providing a base that other test frameworks may build off of.\n \n import generic_os::getenv;\n+import task::task_id;\n \n export test_name;\n export test_fn;\n@@ -94,7 +95,7 @@ tag test_result { tr_ok; tr_failed; tr_ignored; }\n // In cases where test functions and closures it is not ok to just dump them\n // into a task and run them, so this transformation gives the caller a chance\n // to create the test task.\n-type test_to_task = fn(&fn()) -> task ;\n+type test_to_task = fn(&fn()) -> task_id ;\n \n // A simple console test runner\n fn run_tests_console(opts: &test_opts, tests: &[test_desc]) -> bool {\n@@ -318,12 +319,12 @@ fn run_test(test: &test_desc, to_task: &test_to_task) -> test_future {\n         ret {test: test,\n              fnref: fnref,\n              wait:\n-                 bind fn (test_task: &task) -> test_result {\n-                          alt task::join(test_task) {\n-                            task::tr_success. { tr_ok }\n-                            task::tr_failure. { tr_failed }\n-                          }\n-                      }(test_task)};\n+             bind fn (test_task: task_id) -> test_result {\n+                 alt task::join_id(test_task) {\n+                   task::tr_success. { tr_ok }\n+                   task::tr_failure. { tr_failed }\n+                 }\n+             }(test_task)};\n     } else {\n         ret {test: test,\n              fnref: fnref,\n@@ -335,14 +336,14 @@ fn run_test(test: &test_desc, to_task: &test_to_task) -> test_future {\n // But, at least currently, functions can't be used as spawn arguments so\n // we've got to treat our test functions as unsafe pointers.  This function\n // only works with functions that don't contain closures.\n-fn default_test_to_task(f: &fn()) -> task {\n+fn default_test_to_task(f: &fn()) -> task_id {\n     fn run_task(fptr: *mutable fn() ) {\n         configure_test_task();\n         // Run the test\n         (*fptr)()\n     }\n     let fptr = ptr::addr_of(f);\n-    ret spawn run_task(fptr);\n+    ret task::_spawn(bind run_task(fptr));\n }\n \n // Call from within a test task to make sure it's set up correctly"}, {"sha": "d9755c5588862660ec2d11a5ac06e794a9529eca", "filename": "src/rt/memory_region.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be7325073acb63ed76861de387c6035d714c26db/src%2Frt%2Fmemory_region.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/be7325073acb63ed76861de387c6035d714c26db/src%2Frt%2Fmemory_region.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmemory_region.cpp?ref=be7325073acb63ed76861de387c6035d714c26db", "patch": "@@ -4,7 +4,7 @@\n // NB: please do not commit code with this uncommented. It's\n // hugely expensive and should only be used as a last resort.\n //\n-// #define TRACK_ALLOCATIONS\n+#define TRACK_ALLOCATIONS\n \n #define MAGIC 0xbadc0ffe\n "}, {"sha": "148996f0008023fa69bc81b6b97edd70ec5f58cf", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/be7325073acb63ed76861de387c6035d714c26db/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/be7325073acb63ed76861de387c6035d714c26db/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=be7325073acb63ed76861de387c6035d714c26db", "patch": "@@ -107,12 +107,19 @@ struct spawn_args {\n                        uintptr_t, uintptr_t);\n };\n \n+struct rust_closure {\n+    intptr_t ref_count;\n+    type_desc *td;\n+};\n+\n extern \"C\" CDECL\n-void task_exit(intptr_t *env, int rval, rust_task *task) {\n+void task_exit(rust_closure *env, int rval, rust_task *task) {\n     LOG(task, task, \"task exited with value %d\", rval);\n     if(env) {\n         // free the environment.\n-        I(task->sched, 1 == *env); // the ref count better be 1\n+        I(task->sched, 1 == env->ref_count); // the ref count better be 1\n+        //env->td->drop_glue(NULL, task, NULL, env->td->first_param, env);\n+        //env->td->free_glue(NULL, task, NULL, env->td->first_param, env);\n         task->free(env);\n     }\n     task->die();"}, {"sha": "1568e143cd00fc2cbda05d243a199a163edcb1e6", "filename": "src/test/compile-fail/chan-parameterized-args.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c3535f58427aed5aed891f302de728b0b809838c/src%2Ftest%2Fcompile-fail%2Fchan-parameterized-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3535f58427aed5aed891f302de728b0b809838c/src%2Ftest%2Fcompile-fail%2Fchan-parameterized-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fchan-parameterized-args.rs?ref=c3535f58427aed5aed891f302de728b0b809838c", "patch": "@@ -1,16 +0,0 @@\n-// error-pattern:spawning functions with type params not allowed\n-fn main() {\n-    fn echo[T](c: chan[T], oc: chan[chan[T]]) {\n-        let p: port[T] = port();\n-        oc <| chan(p);\n-\n-        let x;\n-        p |> x;\n-        c <| x;\n-    }\n-\n-    let p = port[int]();\n-    let p2 = port[chan[int]]();\n-\n-    spawn echo(chan(p), chan(p2));\n-}"}, {"sha": "dfc5471f4de5cae6df9813ba72d0c2aec57f284a", "filename": "src/test/compile-fail/spawn-non-nil-fn.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Fcompile-fail%2Fspawn-non-nil-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Fcompile-fail%2Fspawn-non-nil-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fspawn-non-nil-fn.rs?ref=be7325073acb63ed76861de387c6035d714c26db", "patch": "@@ -1,5 +1,8 @@\n // error-pattern: mismatched types\n \n+use std;\n+import std::task;\n+\n fn f(x: int) -> int { ret x; }\n \n-fn main() { spawn f(10); }\n\\ No newline at end of file\n+fn main() { task::_spawn(bind f(10)); }\n\\ No newline at end of file"}, {"sha": "91011818423865c0d645d6b72af60f62ee6faa99", "filename": "src/test/compiletest/compiletest.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fcompiletest.rs?ref=be7325073acb63ed76861de387c6035d714c26db", "patch": "@@ -5,6 +5,13 @@ import std::fs;\n import std::str;\n import std::ivec;\n import std::task;\n+import std::task::task_id;\n+\n+import std::comm;\n+import std::comm::_port;\n+import std::comm::_chan;\n+import std::comm::send;\n+import std::comm::mk_port;\n \n import common::cx;\n import common::config;\n@@ -116,11 +123,11 @@ fn test_opts(config: &config) -> test::test_opts {\n }\n \n type tests_and_conv_fn =\n-    {tests: [test::test_desc], to_task: fn(&fn() ) -> task };\n+    {tests: [test::test_desc], to_task: fn(&fn() ) -> task_id };\n \n fn make_tests(cx: &cx) -> tests_and_conv_fn {\n     log #fmt(\"making tests from %s\", cx.config.src_base);\n-    let configport = port[str]();\n+    let configport = mk_port[[u8]]();\n     let tests = ~[];\n     for file: str  in fs::list_dir(cx.config.src_base) {\n         log #fmt(\"inspecting file %s\", file);\n@@ -153,11 +160,11 @@ fn is_test(config: &config, testfile: &str) -> bool {\n     ret valid;\n }\n \n-fn make_test(cx: &cx, testfile: &str, configport: &port[str]) ->\n+fn make_test(cx: &cx, testfile: &str, configport: &_port[[u8]]) ->\n    test::test_desc {\n     {name: make_test_name(cx.config, testfile),\n-     fn: make_test_closure(testfile, chan(configport)),\n-            ignore: header::is_test_ignored(cx.config, testfile)}\n+     fn: make_test_closure(testfile, configport.mk_chan()),\n+     ignore: header::is_test_ignored(cx.config, testfile)}\n }\n \n fn make_test_name(config: &config, testfile: &str) -> str {\n@@ -183,12 +190,13 @@ up. Then we'll spawn that data into another task and return the task.\n Really convoluted. Need to think up of a better definition for tests.\n */\n \n-fn make_test_closure(testfile: &str, configchan: chan[str]) -> test::test_fn {\n+fn make_test_closure(testfile: &str, configchan: _chan[[u8]]) -> test::test_fn\n+{\n     bind send_config(testfile, configchan)\n }\n \n-fn send_config(testfile: str, configchan: chan[str]) {\n-    task::send(configchan, testfile);\n+fn send_config(testfile: str, configchan: _chan[[u8]]) {\n+    send(configchan, str::bytes(testfile));\n }\n \n /*\n@@ -201,24 +209,25 @@ break up the config record and pass everything individually to the spawned\n function.\n */\n \n-fn closure_to_task(cx: cx, configport: port[str], testfn: &fn() ) -> task {\n+fn closure_to_task(cx: cx, configport: _port[[u8]], testfn: &fn() ) -> task_id\n+{\n     testfn();\n-    let testfile = task::recv(configport);\n-    ret spawn run_test_task(cx.config.compile_lib_path,\n+    let testfile = configport.recv();\n+    ret task::_spawn(bind run_test_task(cx.config.compile_lib_path,\n                             cx.config.run_lib_path, cx.config.rustc_path,\n                             cx.config.src_base, cx.config.build_base,\n                             cx.config.stage_id, mode_str(cx.config.mode),\n                             cx.config.run_ignored, opt_str(cx.config.filter),\n                             opt_str(cx.config.runtool),\n                             opt_str(cx.config.rustcflags), cx.config.verbose,\n-                            task::clone_chan(cx.procsrv.chan), testfile);\n+                            cx.procsrv.chan, testfile));\n }\n \n fn run_test_task(compile_lib_path: str, run_lib_path: str, rustc_path: str,\n                  src_base: str, build_base: str, stage_id: str, mode: str,\n                  run_ignored: bool, opt_filter: str, opt_runtool: str,\n                  opt_rustcflags: str, verbose: bool,\n-                 procsrv_chan: procsrv::reqchan, testfile: str) {\n+                 procsrv_chan: procsrv::reqchan, testfile: -[u8]) {\n \n     let config =\n         {compile_lib_path: compile_lib_path,"}, {"sha": "a1a7fd3bd6b8b10bf0e9518f800a1e729b3e0a49", "filename": "src/test/compiletest/procsrv.rs", "status": "modified", "additions": 45, "deletions": 43, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fprocsrv.rs?ref=be7325073acb63ed76861de387c6035d714c26db", "patch": "@@ -6,14 +6,18 @@\n \n import std::option;\n import std::task;\n+import std::task::task_id;\n import std::generic_os::setenv;\n import std::generic_os::getenv;\n import std::ivec;\n import std::os;\n import std::run;\n-import std::unsafe;\n import std::io;\n import std::str;\n+import std::comm::_chan;\n+import std::comm::mk_port;\n+import std::comm::_port;\n+import std::comm::send;\n \n export handle;\n export mk;\n@@ -22,47 +26,47 @@ export run;\n export close;\n export reqchan;\n \n-type reqchan = chan[request];\n+type reqchan = _chan[request];\n \n-type handle = {task: option::t[task], chan: reqchan};\n+type handle = {task: option::t[task_id], chan: reqchan};\n \n tag request {\n-    exec(str, str, [str], chan[response]);\n+    exec([u8], [u8], [[u8]], _chan[response]);\n     stop;\n }\n \n type response = {pid: int, infd: int, outfd: int, errfd: int};\n \n fn mk() -> handle {\n-    let setupport = port();\n-    let task = spawn fn(setupchan: chan[chan[request]]) {\n-        let reqport = port();\n-        let reqchan = chan(reqport);\n-        task::send(setupchan, task::clone_chan(reqchan));\n+    let setupport = mk_port();\n+    let task = task::_spawn(bind fn(setupchan: _chan[_chan[request]]) {\n+        let reqport = mk_port();\n+        let reqchan = reqport.mk_chan();\n+        send(setupchan, reqchan);\n         worker(reqport);\n-    } (chan(setupport));\n+    } (setupport.mk_chan()));\n     ret {task: option::some(task),\n-         chan: task::recv(setupport)\n+         chan: setupport.recv()\n         };\n }\n \n fn from_chan(ch: &reqchan) -> handle { {task: option::none, chan: ch} }\n \n fn close(handle: &handle) {\n-    task::send(handle.chan, stop);\n-    task::join(option::get(handle.task));\n+    send(handle.chan, stop);\n+    task::join_id(option::get(handle.task));\n }\n \n fn run(handle: &handle, lib_path: &str,\n        prog: &str, args: &[str], input: &option::t[str]) ->\n {status: int, out: str, err: str} {\n-    let p = port[response]();\n-    let ch = chan(p);\n-    task::send(handle.chan, exec(lib_path,\n-                                 prog,\n-                                 clone_ivecstr(args),\n-                                 task::clone_chan(ch)));\n-    let resp = task::recv(p);\n+    let p = mk_port[response]();\n+    let ch = p.mk_chan();\n+    send(handle.chan, exec(str::bytes(lib_path),\n+                           str::bytes(prog),\n+                           clone_ivecstr(args),\n+                           ch));\n+    let resp = p.recv();\n \n     writeclose(resp.infd, input);\n     let output = readclose(resp.outfd);\n@@ -95,7 +99,7 @@ fn readclose(fd: int) -> str {\n     ret buf;\n }\n \n-fn worker(p: port[request]) {\n+fn worker(p: _port[request]) {\n \n     // FIXME (787): If we declare this inside of the while loop and then\n     // break out of it before it's ever initialized (i.e. we don't run\n@@ -105,8 +109,7 @@ fn worker(p: port[request]) {\n         lib_path: \"\",\n         prog: \"\",\n         args: ~[],\n-        // This works because a NULL box is ignored during cleanup\n-        respchan: unsafe::reinterpret_cast(0)\n+        respchan: p.mk_chan()\n     };\n \n     while true {\n@@ -121,12 +124,12 @@ fn worker(p: port[request]) {\n             // put the entire alt in another block to make sure the exec\n             // message goes out of scope. Seems like the scoping rules for\n             // the alt discriminant are wrong.\n-            alt task::recv(p) {\n+            alt p.recv() {\n               exec(lib_path, prog, args, respchan) {\n                 {\n-                    lib_path: clone_str(lib_path),\n-                    prog: clone_str(prog),\n-                    args: clone_ivecstr(args),\n+                    lib_path: str::unsafe_from_bytes(lib_path),\n+                    prog: str::unsafe_from_bytes(prog),\n+                    args: clone_ivecu8str(args),\n                     respchan: respchan\n                 }\n               }\n@@ -156,11 +159,11 @@ fn worker(p: port[request]) {\n             fail;\n         }\n \n-        task::send(execparms.respchan,\n-                   {pid: pid,\n-                    infd: pipe_in.out,\n-                    outfd: pipe_out.in,\n-                    errfd: pipe_err.in});\n+        send(execparms.respchan,\n+             {pid: pid,\n+              infd: pipe_in.out,\n+              outfd: pipe_out.in,\n+              errfd: pipe_err.in});\n     }\n }\n \n@@ -181,19 +184,18 @@ fn append_lib_path(path: &str) { export_lib_path(util::make_new_path(path)); }\n \n fn export_lib_path(path: &str) { setenv(util::lib_path_env_var(), path); }\n \n-fn clone_str(s: &str) -> str {\n-    let new = s + \"\";\n-    // new should be a different pointer\n-    let sptr: int = unsafe::reinterpret_cast(s);\n-    let newptr: int = unsafe::reinterpret_cast(new);\n-    assert sptr != newptr;\n-    new\n+fn clone_ivecstr(v: &[str]) -> [[u8]] {\n+    let r = [];\n+    for t: str in ivec::slice(v, 0u, ivec::len(v)) {\n+        r += [str::bytes(t)];\n+    }\n+    ret r;\n }\n \n-fn clone_ivecstr(v: &[str]) -> [str] {\n-    let r = ~[];\n-    for t: str in ivec::slice(v, 0u, ivec::len(v)) {\n-        r += ~[clone_str(t)];\n+fn clone_ivecu8str(v: &[[u8]]) -> [str] {\n+    let r = [];\n+    for t in ivec::slice(v, 0u, ivec::len(v)) {\n+        r += [str::unsafe_from_bytes(t)];\n     }\n     ret r;\n }"}, {"sha": "15d010172d92b11282f46705f70c813c584dabf9", "filename": "src/test/compiletest/runtest.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fruntest.rs?ref=be7325073acb63ed76861de387c6035d714c26db", "patch": "@@ -18,7 +18,8 @@ import util::logv;\n \n export run;\n \n-fn run(cx: &cx, testfile: &str) {\n+fn run(cx: &cx, _testfile: -[u8]) {\n+    let testfile = str::unsafe_from_bytes(_testfile);\n     test::configure_test_task();\n     if (cx.config.verbose) {\n         // We're going to be dumping a lot of info. Start on a new line."}, {"sha": "f7932c93a271f518a9dd130c2aad9b299ab4fb00", "filename": "src/test/run-fail/linked-failure.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-fail%2Flinked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-fail%2Flinked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure.rs?ref=be7325073acb63ed76861de387c6035d714c26db", "patch": "@@ -3,6 +3,13 @@\n // error-pattern:1 == 2\n // no-valgrind\n \n+use std;\n+import std::task;\n+\n fn child() { assert (1 == 2); }\n \n-fn main() { let p: port[int] = port(); spawn child(); let x: int; p |> x; }\n\\ No newline at end of file\n+fn main() {\n+    let p: port[int] = port();\n+    task::_spawn(bind child());\n+    let x: int; p |> x;\n+}"}, {"sha": "0861b66aab86e595ae6f143aa4af769d3b0d2b05", "filename": "src/test/run-pass/acyclic-unwind.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Facyclic-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Facyclic-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Facyclic-unwind.rs?ref=be7325073acb63ed76861de387c6035d714c26db", "patch": "@@ -3,14 +3,18 @@\n // xfail-stage3\n // -*- rust -*-\n \n-fn f(c: chan[int]) {\n+use std;\n+import std::comm;\n+import std::task;\n+\n+fn f(c: comm::_chan[int]) {\n     type t = {_0: int, _1: int, _2: int};\n \n     // Allocate a box.\n     let x: @t = @{_0: 1, _1: 2, _2: 3};\n \n     // Signal parent that we've allocated a box.\n-    c <| 1;\n+    comm::send(c, 1);\n \n \n     while true {\n@@ -21,18 +25,17 @@ fn f(c: chan[int]) {\n         // sending to the channel are never received\n         // by the parent, therefore this test cases drops\n         // messages on the floor\n-        c <| 1;\n+        comm::send(c, 1);\n     }\n }\n \n-\n fn main() {\n-    let p: port[int] = port();\n-    spawn f(chan(p));\n+    let p = comm::mk_port();\n+    task::_spawn(bind f(p.mk_chan()));\n     let i: int;\n \n     // synchronize on event from child.\n-    p |> i;\n+    i = p.recv();\n \n     log \"parent exiting, killing child\";\n }\n\\ No newline at end of file"}, {"sha": "884fd053adb900e5afc11f05f4e7142d2db44ee1", "filename": "src/test/run-pass/basic-1.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fbasic-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fbasic-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbasic-1.rs?ref=be7325073acb63ed76861de387c6035d714c26db", "patch": "@@ -1,23 +1,29 @@\n // -*- rust -*-\n \n-fn a(c: chan[int]) { c <| 10; }\n+use std;\n+import std::comm::_chan;\n+import std::comm::mk_port;\n+import std::comm::send;\n+import std::task;\n+\n+fn a(c: _chan[int]) { send(c, 10); }\n \n fn main() {\n-    let p: port[int] = port();\n-    spawn a(chan(p));\n-    spawn b(chan(p));\n+    let p = mk_port();\n+    task::_spawn(bind a(p.mk_chan()));\n+    task::_spawn(bind b(p.mk_chan()));\n     let n: int = 0;\n-    p |> n;\n-    p |> n;\n+    n = p.recv();\n+    n = p.recv();\n     //    log \"Finished.\";\n }\n \n-fn b(c: chan[int]) {\n+fn b(c: _chan[int]) {\n     //    log \"task b0\";\n     //    log \"task b1\";\n     //    log \"task b2\";\n     //    log \"task b3\";\n     //    log \"task b4\";\n     //    log \"task b5\";\n-    c <| 10;\n+    send(c, 10);\n }\n\\ No newline at end of file"}, {"sha": "6e600fac978591188df63b7f45d1e50b86d05909", "filename": "src/test/run-pass/basic-2.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fbasic-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fbasic-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbasic-2.rs?ref=be7325073acb63ed76861de387c6035d714c26db", "patch": "@@ -1,22 +1,28 @@\n // -*- rust -*-\n \n-fn a(c: chan[int]) { log \"task a0\"; log \"task a1\"; c <| 10; }\n+use std;\n+import std::comm;\n+import std::comm::send;\n+import std::comm::_chan;\n+import std::task;\n+\n+fn a(c: _chan[int]) { log \"task a0\"; log \"task a1\"; send(c, 10); }\n \n fn main() {\n-    let p: port[int] = port();\n-    spawn a(chan(p));\n-    spawn b(chan(p));\n+    let p = comm::mk_port();\n+    task::_spawn(bind a(p.mk_chan()));\n+    task::_spawn(bind b(p.mk_chan()));\n     let n: int = 0;\n-    p |> n;\n-    p |> n;\n+    n = p.recv();\n+    n = p.recv();\n     log \"Finished.\";\n }\n \n-fn b(c: chan[int]) {\n+fn b(c: _chan[int]) {\n     log \"task b0\";\n     log \"task b1\";\n     log \"task b2\";\n     log \"task b2\";\n     log \"task b3\";\n-    c <| 10;\n+    send(c, 10);\n }\n\\ No newline at end of file"}, {"sha": "eec899b842f9ff4fca8548e576ca95a0f6e6bd88", "filename": "src/test/run-pass/basic.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbasic.rs?ref=be7325073acb63ed76861de387c6035d714c26db", "patch": "@@ -1,14 +1,20 @@\n // -*- rust -*-\n \n-fn a(c: chan[int]) {\n+use std;\n+import std::comm;\n+import std::comm::send;\n+import std::comm::_chan;\n+import std::task;\n+\n+fn a(c: _chan[int]) {\n     if true {\n         log \"task a\";\n         log \"task a\";\n         log \"task a\";\n         log \"task a\";\n         log \"task a\";\n     }\n-    c <| 10;\n+    send(c, 10);\n }\n \n fn k(x: int) -> int { ret 15; }\n@@ -18,19 +24,19 @@ fn g(x: int, y: str) -> int { log x; log y; let z: int = k(1); ret z; }\n fn main() {\n     let n: int = 2 + 3 * 7;\n     let s: str = \"hello there\";\n-    let p: port[int] = port();\n-    spawn a(chan(p));\n-    spawn b(chan(p));\n+    let p = comm::mk_port();\n+    task::_spawn(bind a(p.mk_chan()));\n+    task::_spawn(bind b(p.mk_chan()));\n     let x: int = 10;\n     x = g(n, s);\n     log x;\n-    p |> n;\n-    p |> n;\n+    n = p.recv();\n+    n = p.recv();\n     // FIXME: use signal-channel for this.\n     log \"children finished, root finishing\";\n }\n \n-fn b(c: chan[int]) {\n+fn b(c: _chan[int]) {\n     if true {\n         log \"task b\";\n         log \"task b\";\n@@ -39,5 +45,5 @@ fn b(c: chan[int]) {\n         log \"task b\";\n         log \"task b\";\n     }\n-    c <| 10;\n+    send(c, 10);\n }\n\\ No newline at end of file"}, {"sha": "5dd321a5ef22d352f49d2c8783ac0a8f2bf0b3b1", "filename": "src/test/run-pass/bind-native.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fbind-native.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fbind-native.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-native.rs?ref=be7325073acb63ed76861de387c6035d714c26db", "patch": "@@ -0,0 +1,14 @@\n+/*\n+Can we bind native things?\n+*/\n+\n+//xfail-stage0\n+//xfail-stage1\n+//xfail-stage2\n+//xfail-stage3\n+\n+native \"rust\" mod rustrt {\n+    fn task_yield();\n+}\n+\n+fn main() { bind rustrt::task_yield(); }"}, {"sha": "b5a852611ad5f37faded1cb0e0a52f30cb84ebae", "filename": "src/test/run-pass/binops.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fbinops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fbinops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinops.rs?ref=be7325073acb63ed76861de387c6035d714c26db", "patch": "@@ -2,6 +2,7 @@\n \n use std;\n import std::unsafe::reinterpret_cast;\n+import std::task;\n \n fn test_nil() {\n     assert (() == ());\n@@ -82,8 +83,8 @@ fn test_ptr() {\n \n fn test_task() {\n     fn f() { }\n-    let t1 = spawn f();\n-    let t2 = spawn f();\n+    let t1 = task::_spawn(bind f());\n+    let t2 = task::_spawn(bind f());\n \n     assert t1 == t1;\n     assert t1 != t2;"}, {"sha": "7723eef6d1b2445978ad6b3eadbc2469bb84a190", "filename": "src/test/run-pass/chan-leak.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fchan-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fchan-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchan-leak.rs?ref=be7325073acb63ed76861de387c6035d714c26db", "patch": "@@ -2,35 +2,39 @@\n \n use std;\n import std::task;\n+import std::comm::_chan;\n+import std::comm::send;\n+import std::comm;\n+import std::comm::mk_port;\n \n tag request {\n   quit;\n-  close(chan[bool]);\n+  close(_chan[bool]);\n }\n \n-type ctx = chan[request];\n+type ctx = _chan[request];\n \n-fn request_task(c: chan[ctx]) {\n-    let p: port[request] = port();\n-    c <| chan(p);\n+fn request_task(c: _chan[ctx]) {\n+    let p = mk_port();\n+    send(c, p.mk_chan());\n     let req: request;\n-    p |> req;\n+    req = p.recv();\n     // Need to drop req before receiving it again\n-    p |> req;\n+    req = p.recv();\n }\n \n fn new() -> ctx {\n-    let p: port[ctx] = port();\n-    let t = spawn request_task(chan(p));\n+    let p = mk_port();\n+    let t = task::_spawn(bind request_task(p.mk_chan()));\n     let cx: ctx;\n-    p |> cx;\n+    cx = p.recv();\n     ret cx;\n }\n \n fn main() {\n     let cx = new();\n \n-    let p: port[bool] = port();\n-    cx <| close(chan(p));\n-    cx <| quit;\n+    let p = mk_port[bool]();\n+    send(cx, close(p.mk_chan()));\n+    send(cx, quit);\n }"}, {"sha": "d6b48ccb131d90648585eca5e0c7f39f2995b51c", "filename": "src/test/run-pass/child-outlives-parent.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs?ref=be7325073acb63ed76861de387c6035d714c26db", "patch": "@@ -1,4 +1,8 @@\n // Reported as issue #126, child leaks the string.\n+\n+use std;\n+import std::task;\n+\n fn child2(s: str) { }\n \n-fn main() { let x = spawn child2(\"hi\"); }\n\\ No newline at end of file\n+fn main() { let x = task::_spawn(bind child2(\"hi\")); }\n\\ No newline at end of file"}, {"sha": "1feed8042e70d18f83a157f296f1dd0c3545a3dc", "filename": "src/test/run-pass/clone-with-exterior.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs?ref=be7325073acb63ed76861de387c6035d714c26db", "patch": "@@ -1,13 +1,18 @@\n-// xfail-stage1\n-// xfail-stage2\n-// xfail-stage3\n-fn f(@rec(int a, int b) x) {\n-  assert (x.a == 10);\n-  assert (x.b == 12);\n+//xfail-stage0\n+//xfail-stage1\n+//xfail-stage2\n+//xfail-stage3\n+\n+use std;\n+import std::task;\n+\n+fn f(x : @{a:int, b:int}) {\n+    assert (x.a == 10);\n+    assert (x.b == 12);\n }\n \n fn main() {\n-  let @rec(int a, int b) z = rec(a=10, b=12);\n-  let task p = spawn thread f(z);\n-  join p;\n+    let z : @{a:int, b:int} = @{ a : 10, b : 12};\n+    let p = task::_spawn(bind f(z));\n+    task::join_id(p);\n }\n\\ No newline at end of file"}, {"sha": "4a6516c869ad9de939f7af06ed62b84438d99515", "filename": "src/test/run-pass/comm.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcomm.rs?ref=be7325073acb63ed76861de387c6035d714c26db", "patch": "@@ -1,13 +1,22 @@\n // -*- rust -*-\n \n+use std;\n+import std::comm;\n+import std::comm::_chan;\n+import std::comm::send;\n+import std::task;\n+\n fn main() {\n-    let p: port[int] = port();\n-    let t: task = spawn child(chan(p));\n-    let y: int;\n-    p |> y;\n+    let p = comm::mk_port();\n+    let t = task::_spawn(bind child(p.mk_chan()));\n+    let y = p.recv();\n     log_err \"received\";\n     log_err y;\n     assert (y == 10);\n }\n \n-fn child(c: chan[int]) { log_err \"sending\"; c <| 10; log_err \"value sent\" }\n\\ No newline at end of file\n+fn child(c: _chan[int]) {\n+    log_err \"sending\";\n+    send(c, 10);\n+    log_err \"value sent\"\n+}\n\\ No newline at end of file"}, {"sha": "8077219b0f0b91003339c4b3fcf08e371d463999", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=be7325073acb63ed76861de387c6035d714c26db", "patch": "@@ -12,6 +12,12 @@ import std::option::none;\n import std::str;\n import std::ivec;\n import std::map;\n+import std::task;\n+import std::comm::_chan;\n+import std::comm::_port;\n+import std::comm::send;\n+import std::comm::mk_port;\n+import std::comm;\n \n fn map(filename: str, emit: map_reduce::putter) { emit(filename, \"1\"); }\n \n@@ -24,39 +30,39 @@ mod map_reduce {\n \n     type mapper = fn(str, putter) ;\n \n-    tag ctrl_proto { find_reducer(str, chan[int]); mapper_done; }\n+    tag ctrl_proto { find_reducer([u8], _chan[int]); mapper_done; }\n \n-    fn start_mappers(ctrl: chan[ctrl_proto], inputs: &[str]) {\n-        for i: str  in inputs { spawn map_task(ctrl, i); }\n+    fn start_mappers(ctrl: _chan[ctrl_proto], inputs: &[str]) {\n+        for i: str  in inputs { task::_spawn(bind map_task(ctrl, i)); }\n     }\n \n-    fn map_task(ctrl: chan[ctrl_proto], input: str) {\n+    fn map_task(ctrl: _chan[ctrl_proto], input: str) {\n \n         let intermediates = map::new_str_hash();\n \n-        fn emit(im: &map::hashmap[str, int], ctrl: chan[ctrl_proto], key: str,\n-                val: str) {\n+        fn emit(im: &map::hashmap[str, int], ctrl: _chan[ctrl_proto],\n+                key: str, val: str) {\n             let c;\n             alt im.find(key) {\n               some(_c) { c = _c }\n               none. {\n-                let p = port();\n+                let p = mk_port();\n                 log_err \"sending find_reducer\";\n-                ctrl <| find_reducer(key, chan(p));\n+                send(ctrl, find_reducer(str::bytes(key), p.mk_chan()));\n                 log_err \"receiving\";\n-                p |> c;\n+                c = p.recv();\n                 log_err c;\n                 im.insert(key, c);\n               }\n             }\n         }\n \n         map(input, bind emit(intermediates, ctrl, _, _));\n-        ctrl <| mapper_done;\n+        send(ctrl, mapper_done);\n     }\n \n     fn map_reduce(inputs: &[str]) {\n-        let ctrl = port[ctrl_proto]();\n+        let ctrl = mk_port[ctrl_proto]();\n \n         // This task becomes the master control task. It spawns others\n         // to do the rest.\n@@ -65,22 +71,20 @@ mod map_reduce {\n \n         reducers = map::new_str_hash();\n \n-        start_mappers(chan(ctrl), inputs);\n+        start_mappers(ctrl.mk_chan(), inputs);\n \n         let num_mappers = ivec::len(inputs) as int;\n \n-\n         while num_mappers > 0 {\n-            let m;\n-            ctrl |> m;\n-\n-\n-            alt m {\n+            alt ctrl.recv() {\n               mapper_done. { num_mappers -= 1; }\n               find_reducer(k, cc) {\n                 let c;\n-                alt reducers.find(k) { some(_c) { c = _c; } none. { c = 0; } }\n-                cc <| c;\n+                alt reducers.find(str::unsafe_from_bytes(k)) {\n+                  some(_c) { c = _c; }\n+                  none. { c = 0; }\n+                }\n+                send(cc, c);\n               }\n             }\n         }"}, {"sha": "cb3e972d67938b8a42bc37251f356b91c2e0863a", "filename": "src/test/run-pass/issue-506.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fissue-506.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fissue-506.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-506.rs?ref=be7325073acb63ed76861de387c6035d714c26db", "patch": "@@ -2,9 +2,15 @@\n   A reduced test case for Issue #506, provided by Rob Arnold.\n */\n \n+use std;\n+import std::task;\n+\n native \"rust\" mod rustrt {\n     fn task_yield();\n }\n \n-fn main() { spawn rustrt::task_yield(); }\n+fn yield_wrap() {\n+    rustrt::task_yield();\n+}\n \n+fn main() { task::_spawn(bind yield_wrap()); }"}, {"sha": "2aee3ce1a3b58836dabc7a40a7f8351e97977a84", "filename": "src/test/run-pass/issue-507.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fissue-507.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fissue-507.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-507.rs?ref=be7325073acb63ed76861de387c6035d714c26db", "patch": "@@ -7,26 +7,29 @@\n \n use std;\n \n-import std::task::join;\n+import std::task;\n+import std::task::join_id;\n+import std::comm;\n+import std::comm::_chan;\n+import std::comm::send;\n \n-fn grandchild(c: chan[int]) { c <| 42; }\n+fn grandchild(c: _chan[int]) { send(c, 42); }\n \n-fn child(c: chan[int]) {\n-    let _grandchild = spawn grandchild(c);\n-    join(_grandchild);\n+fn child(c: _chan[int]) {\n+    let _grandchild = task::_spawn(bind grandchild(c));\n+    join_id(_grandchild);\n }\n \n fn main() {\n-    let p: port[int] = port();\n+    let p = comm::mk_port();\n \n-    let _child = spawn child(chan(p));\n+    let _child = task::_spawn(bind child(p.mk_chan()));\n \n-    let x: int;\n-    p |> x;\n+    let x: int = p.recv();\n \n     log x;\n \n     assert (x == 42);\n \n-    join(_child);\n+    join_id(_child);\n }\n\\ No newline at end of file"}, {"sha": "ff7b1979dfe30204123936cdc31c99ff851284fe", "filename": "src/test/run-pass/issue-687.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fissue-687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fissue-687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-687.rs?ref=be7325073acb63ed76861de387c6035d714c26db", "patch": "@@ -1,49 +1,52 @@\n use std;\n import std::ivec;\n+import std::task;\n+import std::comm;\n+import std::comm::_chan;\n+import std::comm::_port;\n+import std::comm::mk_port;\n+import std::comm::send;\n \n tag msg { closed; received([u8]); }\n \n-fn producer(c: chan[[u8]]) {\n-    c <| ~[1u8, 2u8, 3u8, 4u8];\n-    let empty: [u8] = ~[];\n-    c <| empty;\n+fn producer(c: _chan[[u8]]) {\n+    send(c, [1u8, 2u8, 3u8, 4u8]);\n+    let empty: [u8] = [];\n+    send(c, empty);\n }\n \n-fn packager(cb: chan[chan[[u8]]], msg: chan[msg]) {\n-    let p: port[[u8]] = port();\n-    cb <| chan(p);\n+fn packager(cb: _chan[_chan[[u8]]], msg: _chan[msg]) {\n+    let p: _port[[u8]] = mk_port();\n+    send(cb, p.mk_chan());\n     while true {\n         log \"waiting for bytes\";\n-        let data: [u8];\n-        p |> data;\n+        let data = p.recv();\n         log \"got bytes\";\n-        if ivec::len[u8](data) == 0u {\n+        if ivec::len(data) == 0u {\n             log \"got empty bytes, quitting\";\n             break;\n         }\n         log \"sending non-empty buffer of length\";\n-        log ivec::len[u8](data);\n-        msg <| received(data);\n+        log ivec::len(data);\n+        send(msg, received(data));\n         log \"sent non-empty buffer\";\n     }\n     log \"sending closed message\";\n-    msg <| closed;\n+    send(msg, closed);\n     log \"sent closed message\";\n }\n \n fn main() {\n-    let p: port[msg] = port();\n-    let recv_reader: port[chan[[u8]]] = port();\n-    let pack = spawn packager(chan(recv_reader), chan(p));\n-\n-    let source_chan: chan[[u8]];\n-    recv_reader |> source_chan;\n-    let prod: task = spawn producer(source_chan);\n+    let p: _port[msg] = mk_port();\n+    let recv_reader: _port[_chan[[u8]]] = mk_port();\n+    let pack = task::_spawn(bind packager(recv_reader.mk_chan(),\n+                                          p.mk_chan()));\n \n+    let source_chan: _chan[[u8]] = recv_reader.recv();\n+    let prod = task::_spawn(bind producer(source_chan));\n \n     while true {\n-        let msg: msg;\n-        p |> msg;\n+        let msg = p.recv();\n         alt msg {\n           closed. { log \"Got close message\"; break; }\n           received(data) {"}, {"sha": "65b6c6bd166be7926af8a79e5c0ebce86c7186a2", "filename": "src/test/run-pass/ivec-tag.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fivec-tag.rs?ref=be7325073acb63ed76861de387c6035d714c26db", "patch": "@@ -1,14 +1,20 @@\n use std;\n \n-fn producer(c: chan[[u8]]) {\n-    c <| ~[1u8, 2u8, 3u8, 4u8, 5u8, 6u8, 7u8,\n-           8u8, 9u8, 10u8, 11u8, 12u8, 13u8 ];\n+import std::task;\n+import std::comm;\n+import std::comm::_chan;\n+import std::comm::_port;\n+import std::comm::mk_port;\n+import std::comm::send;\n+\n+fn producer(c: _chan[[u8]]) {\n+    send(c, [1u8, 2u8, 3u8, 4u8, 5u8, 6u8, 7u8,\n+             8u8, 9u8, 10u8, 11u8, 12u8, 13u8 ]);\n }\n \n fn main() {\n-    let p: port[[u8]] = port();\n-    let prod: task = spawn producer(chan(p));\n+    let p: _port[[u8]] = mk_port();\n+    let prod = task::_spawn(bind producer(p.mk_chan()));\n \n-    let data: [u8];\n-    p |> data;\n+    let data: [u8] = p.recv();\n }"}, {"sha": "1856d80cafb1f8658de472678f31a349ff9e9af4", "filename": "src/test/run-pass/join.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fjoin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fjoin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fjoin.rs?ref=be7325073acb63ed76861de387c6035d714c26db", "patch": "@@ -5,10 +5,10 @@ use std;\n import std::task::*;\n \n fn main() {\n-    let other = spawn child();\n+    let other = _spawn(bind child());\n     log_err \"1\";\n     yield();\n-    join(other);\n+    join_id(other);\n     log_err \"3\";\n }\n "}, {"sha": "1f4e283b9f91d355acb9f3da6724fe32be7e3fbf", "filename": "src/test/run-pass/lazychan.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Flazychan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Flazychan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flazychan.rs?ref=be7325073acb63ed76861de387c6035d714c26db", "patch": "@@ -1,20 +1,24 @@\n // -*- rust -*-\n \n+use std;\n+import std::task;\n+import std::comm::*;\n+\n fn main() {\n-    let p: port[int] = port();\n+    let p = mk_port();\n     let y: int;\n \n-    spawn child(chan(p));\n-    p |> y;\n+    task::_spawn(bind child(p.mk_chan()));\n+    y = p.recv();\n     log \"received 1\";\n     log y;\n     assert (y == 10);\n \n-    spawn child(chan(p));\n-    p |> y;\n+    task::_spawn(bind child(p.mk_chan()));\n+    y = p.recv();\n     log \"received 2\";\n     log y;\n     assert (y == 10);\n }\n \n-fn child(c: chan[int]) { c <| 10; }\n\\ No newline at end of file\n+fn child(c: _chan[int]) { send(c, 10); }\n\\ No newline at end of file"}, {"sha": "27fcb963223721f25ba3cec35cbd3816d56d48ef", "filename": "src/test/run-pass/many.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fmany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fmany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmany.rs?ref=be7325073acb63ed76861de387c6035d714c26db", "patch": "@@ -1,20 +1,24 @@\n // -*- rust -*-\n \n-fn sub(parent: chan[int], id: int) {\n+use std;\n+import std::task;\n+import std::comm;\n+\n+fn sub(parent: comm::_chan[int], id: int) {\n   if (id == 0) {\n-    parent <| 0;\n+      comm::send(parent, 0);\n   } else {\n-    let p: port[int] = port();\n-    let child = spawn sub(chan(p), id-1);\n-    let y: int; p |> y;\n-    parent <| y + 1;\n+      let p = comm::mk_port();\n+      let child = task::_spawn(bind sub(p.mk_chan(), id-1));\n+      let y = p.recv();\n+      comm::send(parent, y + 1);\n   }\n }\n \n fn main() {\n-  let p: port[int] = port();\n-  let child = spawn sub(chan(p), 200);\n-  let y: int; p |> y;\n+  let p = comm::mk_port();\n+  let child = task::_spawn(bind sub(p.mk_chan(), 200));\n+  let y = p.recv();\n   log \"transmission complete\";\n   log y;\n   assert (y == 200);"}, {"sha": "26495c4a08503c187c0685e89d33769fb4a028c5", "filename": "src/test/run-pass/spawn-fn.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fspawn-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fspawn-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-fn.rs?ref=be7325073acb63ed76861de387c6035d714c26db", "patch": "@@ -2,13 +2,14 @@\n \n use std;\n import std::task::yield;\n+import std::task;\n \n fn x(s: str, n: int) { log s; log n; }\n \n fn main() {\n-    spawn x(\"hello from first spawned fn\", 65);\n-    spawn x(\"hello from second spawned fn\", 66);\n-    spawn x(\"hello from third spawned fn\", 67);\n+    task::_spawn(bind x(\"hello from first spawned fn\", 65));\n+    task::_spawn(bind x(\"hello from second spawned fn\", 66));\n+    task::_spawn(bind x(\"hello from third spawned fn\", 67));\n     let i: int = 30;\n     while i > 0 { i = i - 1; log \"parent sleeping\"; yield(); }\n }\n\\ No newline at end of file"}, {"sha": "46d0dfee616ddaea0a93dccd16d88e28a58a7e19", "filename": "src/test/run-pass/spawn-module-qualified.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fspawn-module-qualified.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Fspawn-module-qualified.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-module-qualified.rs?ref=be7325073acb63ed76861de387c6035d714c26db", "patch": "@@ -1,9 +1,10 @@\n use std;\n-import std::task::join;\n+import std::task::join_id;\n+import std::task::_spawn;\n \n fn main() {\n-  let x = spawn m::child(10);\n-  join(x);\n+  let x = _spawn(bind m::child(10));\n+  join_id(x);\n }\n mod m {\n   fn child(i: int) {"}, {"sha": "50b87bea511704d914e07ddab3f770f0ded700ee", "filename": "src/test/run-pass/task-comm-10.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs?ref=be7325073acb63ed76861de387c6035d714c26db", "patch": "@@ -9,8 +9,7 @@ use std;\n import std::task;\n import std::comm;\n \n-fn start(pcc: *u8) {\n-    let c = comm::chan_from_unsafe_ptr(pcc);\n+fn start(c: comm::_chan[str]) {\n     let p = comm::mk_port[str]();\n     c.send(p.mk_chan().unsafe_ptr());\n \n@@ -23,11 +22,10 @@ fn start(pcc: *u8) {\n }\n \n fn main() {\n-    let p = comm::mk_port[*u8]();\n-    let child = spawn start(p.mk_chan().unsafe_ptr());\n+    let p = comm::mk_port();\n+    let child = task::_spawn(bind start(p.mk_chan()));\n \n-    let pc = p.recv();\n-    let c = comm::chan_from_unsafe_ptr(pc);\n+    let c = p.recv();\n     c.send(\"A\");\n     c.send(\"B\");\n     task::yield();"}, {"sha": "591666f745fec155b8a580c437a7a42a5655eab2", "filename": "src/test/run-pass/task-comm-12.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs?ref=be7325073acb63ed76861de387c6035d714c26db", "patch": "@@ -7,13 +7,13 @@ fn start(task_number: int) { log \"Started / Finished task.\"; }\n \n fn test00() {\n     let i: int = 0;\n-    let t: task = spawn start(i);\n+    let t = task::_spawn(bind start(i));\n \n     // Sleep long enough for the task to finish.\n     task::sleep(10000u);\n \n     // Try joining tasks that have already finished.\n-    task::join(t);\n+    task::join_id(t);\n \n     log \"Joined task.\";\n }"}, {"sha": "1dbc425d6369a09ace05258ffbfc1556d6c334c8", "filename": "src/test/run-pass/task-comm-15.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs?ref=be7325073acb63ed76861de387c6035d714c26db", "patch": "@@ -1,27 +1,19 @@\n-// xfail-stage1\n-// xfail-stage2\n-// xfail-stage3\n-// This test fails when run with multiple threads\n-\n use std;\n import std::comm;\n+import std::task;\n \n-fn start(pc: *u8, n: int) {\n-    let c = comm::chan_from_unsafe_ptr();\n+fn start(c : comm::_chan[int], n: int) {\n     let i: int = n;\n \n-\n-    while i > 0 { c.send(0); i = i - 1; }\n+    while i > 0 { comm::send(c, 0); i = i - 1; }\n }\n \n fn main() {\n-    let p = comm::mk_port();\n+    let p = comm::mk_port[comm::_chan[int]]();\n     // Spawn a task that sends us back messages. The parent task\n     // is likely to terminate before the child completes, so from\n     // the child's point of view the receiver may die. We should\n     // drop messages on the floor in this case, and not crash!\n-    let child = spawn start(p.mk_chan().unsafe_ptr(), 10);\n-    let c;\n-    let pc = p.recv();\n-    c = chan::chan_from_unsafe_ptr();\n+    let child = task::_spawn(bind start(p.mk_chan(), 10));\n+    let c = p.recv();\n }\n\\ No newline at end of file"}, {"sha": "4d689bcb36a1245fa648c2f13dfc07971a3cfe62", "filename": "src/test/stdtest/task.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Fstdtest%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7325073acb63ed76861de387c6035d714c26db/src%2Ftest%2Fstdtest%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ftask.rs?ref=be7325073acb63ed76861de387c6035d714c26db", "patch": "@@ -7,22 +7,22 @@ fn test_sleep() { task::sleep(1000000u); }\n #[test]\n fn test_unsupervise() {\n     fn f() { task::unsupervise(); fail; }\n-    spawn f();\n+    task::_spawn(bind f());\n }\n \n #[test]\n fn test_join() {\n     fn winner() { }\n \n-    let wintask = spawn winner();\n+    let wintask = task::_spawn(bind winner());\n \n-    assert (task::join(wintask) == task::tr_success);\n+    assert (task::join_id(wintask) == task::tr_success);\n \n     fn failer() { task::unsupervise(); fail; }\n \n-    let failtask = spawn failer();\n+    let failtask = task::_spawn(bind failer());\n \n-    assert (task::join(failtask) == task::tr_failure);\n+    assert (task::join_id(failtask) == task::tr_failure);\n }\n \n #[test]"}]}