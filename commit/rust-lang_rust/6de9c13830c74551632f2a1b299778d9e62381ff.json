{"sha": "6de9c13830c74551632f2a1b299778d9e62381ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkZTljMTM4MzBjNzQ1NTE2MzJmMmExYjI5OTc3OGQ5ZTYyMzgxZmY=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2018-11-04T15:14:44Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2018-12-30T13:47:09Z"}, "message": "rustfmt: librust_typeck/check/callee.rs", "tree": {"sha": "191c29818a7c0ea87fc9a95ee8315aecda40d54e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/191c29818a7c0ea87fc9a95ee8315aecda40d54e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6de9c13830c74551632f2a1b299778d9e62381ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6de9c13830c74551632f2a1b299778d9e62381ff", "html_url": "https://github.com/rust-lang/rust/commit/6de9c13830c74551632f2a1b299778d9e62381ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6de9c13830c74551632f2a1b299778d9e62381ff/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e77c3a9b1ac25e3c01911e37e0b79cef93ec7ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e77c3a9b1ac25e3c01911e37e0b79cef93ec7ee", "html_url": "https://github.com/rust-lang/rust/commit/4e77c3a9b1ac25e3c01911e37e0b79cef93ec7ee"}], "stats": {"total": 344, "additions": 200, "deletions": 144}, "files": [{"sha": "727fbf7b30f67e99a42dcdb85c03872543814d4d", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 200, "deletions": 144, "changes": 344, "blob_url": "https://github.com/rust-lang/rust/blob/6de9c13830c74551632f2a1b299778d9e62381ff/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6de9c13830c74551632f2a1b299778d9e62381ff/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=6de9c13830c74551632f2a1b299778d9e62381ff", "patch": "@@ -1,16 +1,16 @@\n-use super::{Expectation, FnCtxt, Needs, TupleArgumentsFlag};\n use super::autoderef::Autoderef;\n use super::method::MethodCallee;\n+use super::{Expectation, FnCtxt, Needs, TupleArgumentsFlag};\n \n+use errors::Applicability;\n use hir::def::Def;\n use hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::{infer, traits};\n-use rustc::ty::{self, TyCtxt, TypeFoldable, Ty};\n-use rustc::ty::adjustment::{Adjustment, Adjust, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc_target::spec::abi;\n use syntax::ast::Ident;\n use syntax_pos::Span;\n-use errors::Applicability;\n \n use rustc::hir;\n \n@@ -33,12 +33,13 @@ enum CallStep<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn check_call(&self,\n-                      call_expr: &'gcx hir::Expr,\n-                      callee_expr: &'gcx hir::Expr,\n-                      arg_exprs: &'gcx [hir::Expr],\n-                      expected: Expectation<'tcx>)\n-                      -> Ty<'tcx> {\n+    pub fn check_call(\n+        &self,\n+        call_expr: &'gcx hir::Expr,\n+        callee_expr: &'gcx hir::Expr,\n+        arg_exprs: &'gcx [hir::Expr],\n+        expected: Expectation<'tcx>,\n+    ) -> Ty<'tcx> {\n         let original_callee_ty = self.check_expr(callee_expr);\n         let expr_ty = self.structurally_resolved_type(call_expr.span, original_callee_ty);\n \n@@ -74,15 +75,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         output\n     }\n \n-    fn try_overloaded_call_step(&self,\n-                                call_expr: &'gcx hir::Expr,\n-                                callee_expr: &'gcx hir::Expr,\n-                                autoderef: &Autoderef<'a, 'gcx, 'tcx>)\n-                                -> Option<CallStep<'tcx>> {\n+    fn try_overloaded_call_step(\n+        &self,\n+        call_expr: &'gcx hir::Expr,\n+        callee_expr: &'gcx hir::Expr,\n+        autoderef: &Autoderef<'a, 'gcx, 'tcx>,\n+    ) -> Option<CallStep<'tcx>> {\n         let adjusted_ty = autoderef.unambiguous_final_ty(self);\n-        debug!(\"try_overloaded_call_step(call_expr={:?}, adjusted_ty={:?})\",\n-               call_expr,\n-               adjusted_ty);\n+        debug!(\n+            \"try_overloaded_call_step(call_expr={:?}, adjusted_ty={:?})\",\n+            call_expr, adjusted_ty\n+        );\n \n         // If the callee is a bare function or a closure, then we're all set.\n         match adjusted_ty.sty {\n@@ -100,21 +103,26 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // fnmut vs fnonce. If so, we have to defer further processing.\n                 if self.closure_kind(def_id, substs).is_none() {\n                     let closure_ty = self.closure_sig(def_id, substs);\n-                    let fn_sig = self.replace_bound_vars_with_fresh_vars(\n-                        call_expr.span,\n-                        infer::FnCall,\n-                        &closure_ty\n-                    ).0;\n+                    let fn_sig = self\n+                        .replace_bound_vars_with_fresh_vars(\n+                            call_expr.span,\n+                            infer::FnCall,\n+                            &closure_ty,\n+                        )\n+                        .0;\n                     let adjustments = autoderef.adjust_steps(self, Needs::None);\n-                    self.record_deferred_call_resolution(def_id, DeferredCallResolution {\n-                        call_expr,\n-                        callee_expr,\n-                        adjusted_ty,\n-                        adjustments,\n-                        fn_sig,\n-                        closure_def_id: def_id,\n-                        closure_substs: substs,\n-                    });\n+                    self.record_deferred_call_resolution(\n+                        def_id,\n+                        DeferredCallResolution {\n+                            call_expr,\n+                            callee_expr,\n+                            adjusted_ty,\n+                            adjustments,\n+                            fn_sig,\n+                            closure_def_id: def_id,\n+                            closure_substs: substs,\n+                        },\n+                    );\n                     return Some(CallStep::DeferredClosure(fn_sig));\n                 }\n             }\n@@ -134,34 +142,50 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             _ => {}\n         }\n \n-        self.try_overloaded_call_traits(call_expr, adjusted_ty).map(|(autoref, method)| {\n-            let mut adjustments = autoderef.adjust_steps(self, Needs::None);\n-            adjustments.extend(autoref);\n-            self.apply_adjustments(callee_expr, adjustments);\n-            CallStep::Overloaded(method)\n-        })\n+        self.try_overloaded_call_traits(call_expr, adjusted_ty)\n+            .map(|(autoref, method)| {\n+                let mut adjustments = autoderef.adjust_steps(self, Needs::None);\n+                adjustments.extend(autoref);\n+                self.apply_adjustments(callee_expr, adjustments);\n+                CallStep::Overloaded(method)\n+            })\n     }\n \n-    fn try_overloaded_call_traits(&self,\n-                                  call_expr: &hir::Expr,\n-                                  adjusted_ty: Ty<'tcx>)\n-                                  -> Option<(Option<Adjustment<'tcx>>,\n-                                             MethodCallee<'tcx>)> {\n+    fn try_overloaded_call_traits(\n+        &self,\n+        call_expr: &hir::Expr,\n+        adjusted_ty: Ty<'tcx>,\n+    ) -> Option<(Option<Adjustment<'tcx>>, MethodCallee<'tcx>)> {\n         // Try the options that are least restrictive on the caller first.\n-        for &(opt_trait_def_id, method_name, borrow) in\n-            &[(self.tcx.lang_items().fn_trait(), Ident::from_str(\"call\"), true),\n-              (self.tcx.lang_items().fn_mut_trait(), Ident::from_str(\"call_mut\"), true),\n-              (self.tcx.lang_items().fn_once_trait(), Ident::from_str(\"call_once\"), false)] {\n+        for &(opt_trait_def_id, method_name, borrow) in &[\n+            (\n+                self.tcx.lang_items().fn_trait(),\n+                Ident::from_str(\"call\"),\n+                true,\n+            ),\n+            (\n+                self.tcx.lang_items().fn_mut_trait(),\n+                Ident::from_str(\"call_mut\"),\n+                true,\n+            ),\n+            (\n+                self.tcx.lang_items().fn_once_trait(),\n+                Ident::from_str(\"call_once\"),\n+                false,\n+            ),\n+        ] {\n             let trait_def_id = match opt_trait_def_id {\n                 Some(def_id) => def_id,\n                 None => continue,\n             };\n \n-            if let Some(ok) = self.lookup_method_in_trait(call_expr.span,\n-                                                          method_name,\n-                                                          trait_def_id,\n-                                                          adjusted_ty,\n-                                                          None) {\n+            if let Some(ok) = self.lookup_method_in_trait(\n+                call_expr.span,\n+                method_name,\n+                trait_def_id,\n+                adjusted_ty,\n+                None,\n+            ) {\n                 let method = self.register_infer_ok_obligations(ok);\n                 let mut autoref = None;\n                 if borrow {\n@@ -173,11 +197,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 // deployment, conservatively omit\n                                 // overloaded function call ops.\n                                 allow_two_phase_borrow: AllowTwoPhase::No,\n-                            }\n+                            },\n                         };\n                         autoref = Some(Adjustment {\n                             kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n-                            target: method.sig.inputs()[0]\n+                            target: method.sig.inputs()[0],\n                         });\n                     }\n                 }\n@@ -188,16 +212,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         None\n     }\n \n-    fn confirm_builtin_call(&self,\n-                            call_expr: &hir::Expr,\n-                            callee_ty: Ty<'tcx>,\n-                            arg_exprs: &'gcx [hir::Expr],\n-                            expected: Expectation<'tcx>)\n-                            -> Ty<'tcx> {\n+    fn confirm_builtin_call(\n+        &self,\n+        call_expr: &hir::Expr,\n+        callee_ty: Ty<'tcx>,\n+        arg_exprs: &'gcx [hir::Expr],\n+        expected: Expectation<'tcx>,\n+    ) -> Ty<'tcx> {\n         let (fn_sig, def_span) = match callee_ty.sty {\n-            ty::FnDef(def_id, _) => {\n-                (callee_ty.fn_sig(self.tcx), self.tcx.hir().span_if_local(def_id))\n-            }\n+            ty::FnDef(def_id, _) => (\n+                callee_ty.fn_sig(self.tcx),\n+                self.tcx.hir().span_if_local(def_id),\n+            ),\n             ty::FnPtr(sig) => (sig, None),\n             ref t => {\n                 let mut unit_variant = None;\n@@ -219,84 +245,96 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         match unit_variant {\n                             Some(ref path) => format!(\"enum variant `{}`\", path),\n                             None => format!(\"`{}`\", callee_ty),\n-                        });\n+                        }\n+                    );\n \n                     if let Some(ref path) = unit_variant {\n                         err.span_suggestion_with_applicability(\n                             call_expr.span,\n-                            &format!(\"`{}` is a unit variant, you need to write it \\\n-                                      without the parenthesis\", path),\n+                            &format!(\n+                                \"`{}` is a unit variant, you need to write it \\\n+                                 without the parenthesis\",\n+                                path\n+                            ),\n                             path.to_string(),\n-                            Applicability::MachineApplicable\n+                            Applicability::MachineApplicable,\n                         );\n                     }\n \n                     let mut inner_callee_path = None;\n                     let def = match callee.node {\n                         hir::ExprKind::Path(ref qpath) => {\n                             self.tables.borrow().qpath_def(qpath, callee.hir_id)\n-                        },\n+                        }\n                         hir::ExprKind::Call(ref inner_callee, _) => {\n                             // If the call spans more than one line and the callee kind is\n                             // itself another `ExprCall`, that's a clue that we might just be\n                             // missing a semicolon (Issue #51055)\n-                            let call_is_multiline = self.tcx.sess.source_map()\n-                                .is_multiline(call_expr.span);\n+                            let call_is_multiline =\n+                                self.tcx.sess.source_map().is_multiline(call_expr.span);\n                             if call_is_multiline {\n                                 let span = self.tcx.sess.source_map().next_point(callee.span);\n                                 err.span_suggestion_with_applicability(\n                                     span,\n                                     \"try adding a semicolon\",\n                                     \";\".to_owned(),\n-                                    Applicability::MaybeIncorrect\n+                                    Applicability::MaybeIncorrect,\n                                 );\n                             }\n                             if let hir::ExprKind::Path(ref inner_qpath) = inner_callee.node {\n                                 inner_callee_path = Some(inner_qpath);\n-                                self.tables.borrow().qpath_def(inner_qpath, inner_callee.hir_id)\n+                                self.tables\n+                                    .borrow()\n+                                    .qpath_def(inner_qpath, inner_callee.hir_id)\n                             } else {\n                                 Def::Err\n                             }\n-                        },\n-                        _ => {\n-                            Def::Err\n                         }\n+                        _ => Def::Err,\n                     };\n \n                     err.span_label(call_expr.span, \"call expression requires function\");\n \n                     let def_span = match def {\n                         Def::Err => None,\n-                        Def::Local(id) | Def::Upvar(id, ..) => {\n-                            Some(self.tcx.hir().span(id))\n-                        }\n-                        _ => def.opt_def_id().and_then(|did| self.tcx.hir().span_if_local(did)),\n+                        Def::Local(id) | Def::Upvar(id, ..) => Some(self.tcx.hir().span(id)),\n+                        _ => def\n+                            .opt_def_id()\n+                            .and_then(|did| self.tcx.hir().span_if_local(did)),\n                     };\n                     if let Some(span) = def_span {\n                         let label = match (unit_variant, inner_callee_path) {\n                             (Some(path), _) => format!(\"`{}` defined here\", path),\n                             (_, Some(hir::QPath::Resolved(_, path))) => format!(\n-                                \"`{}` defined here returns `{}`\", path, callee_ty.to_string()\n+                                \"`{}` defined here returns `{}`\",\n+                                path,\n+                                callee_ty.to_string()\n                             ),\n                             _ => format!(\"`{}` defined here\", callee_ty.to_string()),\n                         };\n                         err.span_label(span, label);\n                     }\n                     err.emit();\n                 } else {\n-                    bug!(\"call_expr.node should be an ExprKind::Call, got {:?}\", call_expr.node);\n+                    bug!(\n+                        \"call_expr.node should be an ExprKind::Call, got {:?}\",\n+                        call_expr.node\n+                    );\n                 }\n \n                 // This is the \"default\" function signature, used in case of error.\n                 // In that case, we check each argument against \"error\" in order to\n                 // set up all the node type bindings.\n-                (ty::Binder::bind(self.tcx.mk_fn_sig(\n-                    self.err_args(arg_exprs.len()).into_iter(),\n-                    self.tcx.types.err,\n-                    false,\n-                    hir::Unsafety::Normal,\n-                    abi::Abi::Rust\n-                )), None)\n+                (\n+                    ty::Binder::bind(self.tcx.mk_fn_sig(\n+                        self.err_args(arg_exprs.len()).into_iter(),\n+                        self.tcx.types.err,\n+                        false,\n+                        hir::Unsafety::Normal,\n+                        abi::Abi::Rust,\n+                    )),\n+                    None,\n+                )\n             }\n         };\n \n@@ -305,69 +343,80 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // renormalize the associated types at this point, since they\n         // previously appeared within a `Binder<>` and hence would not\n         // have been normalized before.\n-        let fn_sig =\n-            self.replace_bound_vars_with_fresh_vars(call_expr.span, infer::FnCall, &fn_sig)\n-                .0;\n+        let fn_sig = self\n+            .replace_bound_vars_with_fresh_vars(call_expr.span, infer::FnCall, &fn_sig)\n+            .0;\n         let fn_sig = self.normalize_associated_types_in(call_expr.span, &fn_sig);\n \n         // Call the generic checker.\n-        let expected_arg_tys =\n-            self.expected_inputs_for_expected_output(call_expr.span,\n-                                            expected,\n-                                            fn_sig.output(),\n-                                            fn_sig.inputs());\n-        self.check_argument_types(call_expr.span,\n-                                  call_expr.span,\n-                                  fn_sig.inputs(),\n-                                  &expected_arg_tys[..],\n-                                  arg_exprs,\n-                                  fn_sig.variadic,\n-                                  TupleArgumentsFlag::DontTupleArguments,\n-                                  def_span);\n+        let expected_arg_tys = self.expected_inputs_for_expected_output(\n+            call_expr.span,\n+            expected,\n+            fn_sig.output(),\n+            fn_sig.inputs(),\n+        );\n+        self.check_argument_types(\n+            call_expr.span,\n+            call_expr.span,\n+            fn_sig.inputs(),\n+            &expected_arg_tys[..],\n+            arg_exprs,\n+            fn_sig.variadic,\n+            TupleArgumentsFlag::DontTupleArguments,\n+            def_span,\n+        );\n \n         fn_sig.output()\n     }\n \n-    fn confirm_deferred_closure_call(&self,\n-                                     call_expr: &hir::Expr,\n-                                     arg_exprs: &'gcx [hir::Expr],\n-                                     expected: Expectation<'tcx>,\n-                                     fn_sig: ty::FnSig<'tcx>)\n-                                     -> Ty<'tcx> {\n+    fn confirm_deferred_closure_call(\n+        &self,\n+        call_expr: &hir::Expr,\n+        arg_exprs: &'gcx [hir::Expr],\n+        expected: Expectation<'tcx>,\n+        fn_sig: ty::FnSig<'tcx>,\n+    ) -> Ty<'tcx> {\n         // `fn_sig` is the *signature* of the cosure being called. We\n         // don't know the full details yet (`Fn` vs `FnMut` etc), but we\n         // do know the types expected for each argument and the return\n         // type.\n \n-        let expected_arg_tys = self.expected_inputs_for_expected_output(call_expr.span,\n-                                                               expected,\n-                                                               fn_sig.output().clone(),\n-                                                               fn_sig.inputs());\n-\n-        self.check_argument_types(call_expr.span,\n-                                  call_expr.span,\n-                                  fn_sig.inputs(),\n-                                  &expected_arg_tys,\n-                                  arg_exprs,\n-                                  fn_sig.variadic,\n-                                  TupleArgumentsFlag::TupleArguments,\n-                                  None);\n+        let expected_arg_tys = self.expected_inputs_for_expected_output(\n+            call_expr.span,\n+            expected,\n+            fn_sig.output().clone(),\n+            fn_sig.inputs(),\n+        );\n+\n+        self.check_argument_types(\n+            call_expr.span,\n+            call_expr.span,\n+            fn_sig.inputs(),\n+            &expected_arg_tys,\n+            arg_exprs,\n+            fn_sig.variadic,\n+            TupleArgumentsFlag::TupleArguments,\n+            None,\n+        );\n \n         fn_sig.output()\n     }\n \n-    fn confirm_overloaded_call(&self,\n-                               call_expr: &hir::Expr,\n-                               arg_exprs: &'gcx [hir::Expr],\n-                               expected: Expectation<'tcx>,\n-                               method_callee: MethodCallee<'tcx>)\n-                               -> Ty<'tcx> {\n-        let output_type = self.check_method_argument_types(call_expr.span,\n-                                                           call_expr.span,\n-                                                           Ok(method_callee),\n-                                                           arg_exprs,\n-                                                           TupleArgumentsFlag::TupleArguments,\n-                                                           expected);\n+    fn confirm_overloaded_call(\n+        &self,\n+        call_expr: &hir::Expr,\n+        arg_exprs: &'gcx [hir::Expr],\n+        expected: Expectation<'tcx>,\n+        method_callee: MethodCallee<'tcx>,\n+    ) -> Ty<'tcx> {\n+        let output_type = self.check_method_argument_types(\n+            call_expr.span,\n+            call_expr.span,\n+            Ok(method_callee),\n+            arg_exprs,\n+            TupleArgumentsFlag::TupleArguments,\n+            expected,\n+        );\n \n         self.write_method_call(call_expr.hir_id, method_callee);\n         output_type\n@@ -391,11 +440,12 @@ impl<'a, 'gcx, 'tcx> DeferredCallResolution<'gcx, 'tcx> {\n \n         // we should not be invoked until the closure kind has been\n         // determined by upvar inference\n-        assert!(fcx.closure_kind(self.closure_def_id, self.closure_substs).is_some());\n+        assert!(fcx\n+            .closure_kind(self.closure_def_id, self.closure_substs)\n+            .is_some());\n \n         // We may now know enough to figure out fn vs fnmut etc.\n-        match fcx.try_overloaded_call_traits(self.call_expr,\n-                                             self.adjusted_ty) {\n+        match fcx.try_overloaded_call_traits(self.call_expr, self.adjusted_ty) {\n             Some((autoref, method_callee)) => {\n                 // One problem is that when we get here, we are going\n                 // to have a newly instantiated function signature\n@@ -410,22 +460,28 @@ impl<'a, 'gcx, 'tcx> DeferredCallResolution<'gcx, 'tcx> {\n                 debug!(\"attempt_resolution: method_callee={:?}\", method_callee);\n \n                 for (method_arg_ty, self_arg_ty) in\n-                    method_sig.inputs().iter().skip(1).zip(self.fn_sig.inputs()) {\n+                    method_sig.inputs().iter().skip(1).zip(self.fn_sig.inputs())\n+                {\n                     fcx.demand_eqtype(self.call_expr.span, &self_arg_ty, &method_arg_ty);\n                 }\n \n-                fcx.demand_eqtype(self.call_expr.span, method_sig.output(), self.fn_sig.output());\n+                fcx.demand_eqtype(\n+                    self.call_expr.span,\n+                    method_sig.output(),\n+                    self.fn_sig.output(),\n+                );\n \n                 let mut adjustments = self.adjustments;\n                 adjustments.extend(autoref);\n                 fcx.apply_adjustments(self.callee_expr, adjustments);\n \n-                fcx.write_method_call(self.call_expr.hir_id,\n-                                      method_callee);\n+                fcx.write_method_call(self.call_expr.hir_id, method_callee);\n             }\n             None => {\n-                span_bug!(self.call_expr.span,\n-                          \"failed to find an overloaded call trait for closure call\");\n+                span_bug!(\n+                    self.call_expr.span,\n+                    \"failed to find an overloaded call trait for closure call\"\n+                );\n             }\n         }\n     }"}]}