{"sha": "944d852afe6c27b6207984b907d902565cf550d6", "node_id": "C_kwDOAAsO6NoAKDk0NGQ4NTJhZmU2YzI3YjYyMDc5ODRiOTA3ZDkwMjU2NWNmNTUwZDY", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-04-08T20:52:07Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-04-12T17:53:46Z"}, "message": "Simplify error reporting.", "tree": {"sha": "0619e59da7d4feb4eda985f5caa5a3c7c18dda68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0619e59da7d4feb4eda985f5caa5a3c7c18dda68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/944d852afe6c27b6207984b907d902565cf550d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/944d852afe6c27b6207984b907d902565cf550d6", "html_url": "https://github.com/rust-lang/rust/commit/944d852afe6c27b6207984b907d902565cf550d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/944d852afe6c27b6207984b907d902565cf550d6/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1c1bbe5f3a0b731450bb90aca15997293df397d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1c1bbe5f3a0b731450bb90aca15997293df397d", "html_url": "https://github.com/rust-lang/rust/commit/d1c1bbe5f3a0b731450bb90aca15997293df397d"}], "stats": {"total": 161, "additions": 76, "deletions": 85}, "files": [{"sha": "6684c463da0be8d30db592c40674336f47ec9a1f", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 76, "deletions": 84, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/944d852afe6c27b6207984b907d902565cf550d6/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/944d852afe6c27b6207984b907d902565cf550d6/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=944d852afe6c27b6207984b907d902565cf550d6", "patch": "@@ -1385,14 +1385,12 @@ impl<'a> Resolver<'a> {\n         path: &[Segment],\n         opt_ns: Option<Namespace>, // `None` indicates a module path in import\n         parent_scope: &ParentScope<'a>,\n-        finalize_full: Finalize,\n         ribs: Option<&PerNS<Vec<Rib<'a>>>>,\n         unusable_binding: Option<&'a NameBinding<'a>>,\n         module: Option<ModuleOrUniformRoot<'a>>,\n         i: usize,\n         ident: Ident,\n     ) -> (String, Option<Suggestion>) {\n-        let finalize = finalize_full.path_span();\n         let is_last = i == path.len() - 1;\n         let ns = if is_last { opt_ns.unwrap_or(TypeNS) } else { TypeNS };\n         let module_res = match module {\n@@ -1418,81 +1416,7 @@ impl<'a> Resolver<'a> {\n             } else {\n                 (format!(\"could not find `{}` in the crate root\", ident), None)\n             }\n-        } else if i == 0 {\n-            if ident.name.as_str().chars().next().map_or(false, |c| c.is_ascii_uppercase()) {\n-                // Check whether the name refers to an item in the value namespace.\n-                let suggestion = if ribs.is_some() {\n-                    let match_span = match self.resolve_ident_in_lexical_scope(\n-                        ident,\n-                        ValueNS,\n-                        parent_scope,\n-                        Finalize::No,\n-                        &ribs.unwrap()[ValueNS],\n-                        unusable_binding,\n-                    ) {\n-                        // Name matches a local variable. For example:\n-                        // ```\n-                        // fn f() {\n-                        //     let Foo: &str = \"\";\n-                        //     println!(\"{}\", Foo::Bar); // Name refers to local\n-                        //                               // variable `Foo`.\n-                        // }\n-                        // ```\n-                        Some(LexicalScopeBinding::Res(Res::Local(id))) => {\n-                            Some(*self.pat_span_map.get(&id).unwrap())\n-                        }\n-\n-                        // Name matches item from a local name binding\n-                        // created by `use` declaration. For example:\n-                        // ```\n-                        // pub Foo: &str = \"\";\n-                        //\n-                        // mod submod {\n-                        //     use super::Foo;\n-                        //     println!(\"{}\", Foo::Bar); // Name refers to local\n-                        //                               // binding `Foo`.\n-                        // }\n-                        // ```\n-                        Some(LexicalScopeBinding::Item(name_binding)) => Some(name_binding.span),\n-                        _ => None,\n-                    };\n-\n-                    if let Some(span) = match_span {\n-                        Some((\n-                            vec![(span, String::from(\"\"))],\n-                            format!(\"`{}` is defined here, but is not a type\", ident),\n-                            Applicability::MaybeIncorrect,\n-                        ))\n-                    } else {\n-                        None\n-                    }\n-                } else {\n-                    None\n-                };\n-\n-                (format!(\"use of undeclared type `{}`\", ident), suggestion)\n-            } else {\n-                (\n-                    format!(\"use of undeclared crate or module `{}`\", ident),\n-                    if ident.name == sym::alloc {\n-                        Some((\n-                            vec![],\n-                            String::from(\"add `extern crate alloc` to use the `alloc` crate\"),\n-                            Applicability::MaybeIncorrect,\n-                        ))\n-                    } else {\n-                        self.find_similarly_named_module_or_crate(ident.name, &parent_scope.module)\n-                            .map(|sugg| {\n-                                (\n-                                    vec![(ident.span, sugg.to_string())],\n-                                    String::from(\"there is a crate or module with a similar name\"),\n-                                    Applicability::MaybeIncorrect,\n-                                )\n-                            })\n-                    },\n-                )\n-            }\n-        } else {\n+        } else if i > 0 {\n             let parent = path[i - 1].ident.name;\n             let parent = match parent {\n                 // ::foo is mounted at the crate root for 2015, and is the extern\n@@ -1501,9 +1425,7 @@ impl<'a> Resolver<'a> {\n                     \"the list of imported crates\".to_owned()\n                 }\n                 kw::PathRoot | kw::Crate => \"the crate root\".to_owned(),\n-                _ => {\n-                    format!(\"`{}`\", parent)\n-                }\n+                _ => format!(\"`{}`\", parent),\n             };\n \n             let mut msg = format!(\"could not find `{}` in {}\", ident, parent);\n@@ -1515,7 +1437,7 @@ impl<'a> Resolver<'a> {\n                         ident,\n                         ns_to_try,\n                         parent_scope,\n-                        finalize,\n+                        None,\n                         false,\n                         unusable_binding,\n                     ).ok()\n@@ -1526,7 +1448,7 @@ impl<'a> Resolver<'a> {\n                         ident,\n                         ns_to_try,\n                         parent_scope,\n-                        finalize_full,\n+                        Finalize::No,\n                         &ribs[ns_to_try],\n                         unusable_binding,\n                     ) {\n@@ -1540,8 +1462,8 @@ impl<'a> Resolver<'a> {\n                         ident,\n                         scopes,\n                         parent_scope,\n-                        finalize,\n-                        finalize.is_some(),\n+                        None,\n+                        false,\n                         false,\n                         unusable_binding,\n                     ).ok()\n@@ -1567,6 +1489,76 @@ impl<'a> Resolver<'a> {\n                 };\n             }\n             (msg, None)\n+        } else if ident.name.as_str().chars().next().map_or(false, |c| c.is_ascii_uppercase()) {\n+            // Check whether the name refers to an item in the value namespace.\n+            let binding = if let Some(ribs) = ribs {\n+                self.resolve_ident_in_lexical_scope(\n+                    ident,\n+                    ValueNS,\n+                    parent_scope,\n+                    Finalize::No,\n+                    &ribs[ValueNS],\n+                    unusable_binding,\n+                )\n+            } else {\n+                None\n+            };\n+            let match_span = match binding {\n+                // Name matches a local variable. For example:\n+                // ```\n+                // fn f() {\n+                //     let Foo: &str = \"\";\n+                //     println!(\"{}\", Foo::Bar); // Name refers to local\n+                //                               // variable `Foo`.\n+                // }\n+                // ```\n+                Some(LexicalScopeBinding::Res(Res::Local(id))) => {\n+                    Some(*self.pat_span_map.get(&id).unwrap())\n+                }\n+                // Name matches item from a local name binding\n+                // created by `use` declaration. For example:\n+                // ```\n+                // pub Foo: &str = \"\";\n+                //\n+                // mod submod {\n+                //     use super::Foo;\n+                //     println!(\"{}\", Foo::Bar); // Name refers to local\n+                //                               // binding `Foo`.\n+                // }\n+                // ```\n+                Some(LexicalScopeBinding::Item(name_binding)) => Some(name_binding.span),\n+                _ => None,\n+            };\n+            let suggestion = if let Some(span) = match_span {\n+                Some((\n+                    vec![(span, String::from(\"\"))],\n+                    format!(\"`{}` is defined here, but is not a type\", ident),\n+                    Applicability::MaybeIncorrect,\n+                ))\n+            } else {\n+                None\n+            };\n+\n+            (format!(\"use of undeclared type `{}`\", ident), suggestion)\n+        } else {\n+            let suggestion = if ident.name == sym::alloc {\n+                Some((\n+                    vec![],\n+                    String::from(\"add `extern crate alloc` to use the `alloc` crate\"),\n+                    Applicability::MaybeIncorrect,\n+                ))\n+            } else {\n+                self.find_similarly_named_module_or_crate(ident.name, &parent_scope.module).map(\n+                    |sugg| {\n+                        (\n+                            vec![(ident.span, sugg.to_string())],\n+                            String::from(\"there is a crate or module with a similar name\"),\n+                            Applicability::MaybeIncorrect,\n+                        )\n+                    },\n+                )\n+            };\n+            (format!(\"use of undeclared crate or module `{}`\", ident), suggestion)\n         }\n     }\n }"}, {"sha": "0260386cb735fefa0e83b711cf1fe5da7bae3fa3", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/944d852afe6c27b6207984b907d902565cf550d6/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/944d852afe6c27b6207984b907d902565cf550d6/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=944d852afe6c27b6207984b907d902565cf550d6", "patch": "@@ -1568,7 +1568,6 @@ impl<'a> Resolver<'a> {\n                             path,\n                             opt_ns,\n                             parent_scope,\n-                            finalize_full,\n                             ribs,\n                             unusable_binding,\n                             module,"}]}