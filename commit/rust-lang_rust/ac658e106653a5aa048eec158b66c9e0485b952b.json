{"sha": "ac658e106653a5aa048eec158b66c9e0485b952b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjNjU4ZTEwNjY1M2E1YWEwNDhlZWMxNThiNjZjOWUwNDg1Yjk1MmI=", "commit": {"author": {"name": "Jon Gjengset", "email": "jon@thesquareplanet.com", "date": "2021-05-27T02:04:38Z"}, "committer": {"name": "Jon Gjengset", "email": "jon@thesquareplanet.com", "date": "2021-05-27T02:04:38Z"}, "message": "Merge branch 'master' into no-unpin-in-pin-future-impl", "tree": {"sha": "5397b8680e9d3ca17e223a6ec3f000a6fd09851b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5397b8680e9d3ca17e223a6ec3f000a6fd09851b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac658e106653a5aa048eec158b66c9e0485b952b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niHUEABYKAB0WIQRIAlMG/9GjsFwKNi2GO0ihHCONWgUCYK7+NwAKCRCGO0ihHCON\nWhr2AQCzQ1/yb24SR3yWvKFVhWRnEJ5QinCmMFX2KywwhCLTZwD/e2D4twNfRwWd\nd5mdZ2aGDYroV1nJsk7Mk7zb6Cx6yQ0=\n=ReU7\n-----END PGP SIGNATURE-----", "payload": "tree 5397b8680e9d3ca17e223a6ec3f000a6fd09851b\nparent 3b2b5b2914d40aa011d189bfe546084cdee53dbe\nparent 86ac0b4147822e23c671a40e7ba1bf5b5835150d\nauthor Jon Gjengset <jon@thesquareplanet.com> 1622081078 -0700\ncommitter Jon Gjengset <jon@thesquareplanet.com> 1622081078 -0700\n\nMerge branch 'master' into no-unpin-in-pin-future-impl\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac658e106653a5aa048eec158b66c9e0485b952b", "html_url": "https://github.com/rust-lang/rust/commit/ac658e106653a5aa048eec158b66c9e0485b952b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac658e106653a5aa048eec158b66c9e0485b952b/comments", "author": {"login": "jonhoo", "id": 176295, "node_id": "MDQ6VXNlcjE3NjI5NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/176295?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonhoo", "html_url": "https://github.com/jonhoo", "followers_url": "https://api.github.com/users/jonhoo/followers", "following_url": "https://api.github.com/users/jonhoo/following{/other_user}", "gists_url": "https://api.github.com/users/jonhoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonhoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonhoo/subscriptions", "organizations_url": "https://api.github.com/users/jonhoo/orgs", "repos_url": "https://api.github.com/users/jonhoo/repos", "events_url": "https://api.github.com/users/jonhoo/events{/privacy}", "received_events_url": "https://api.github.com/users/jonhoo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonhoo", "id": 176295, "node_id": "MDQ6VXNlcjE3NjI5NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/176295?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonhoo", "html_url": "https://github.com/jonhoo", "followers_url": "https://api.github.com/users/jonhoo/followers", "following_url": "https://api.github.com/users/jonhoo/following{/other_user}", "gists_url": "https://api.github.com/users/jonhoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonhoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonhoo/subscriptions", "organizations_url": "https://api.github.com/users/jonhoo/orgs", "repos_url": "https://api.github.com/users/jonhoo/repos", "events_url": "https://api.github.com/users/jonhoo/events{/privacy}", "received_events_url": "https://api.github.com/users/jonhoo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b2b5b2914d40aa011d189bfe546084cdee53dbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b2b5b2914d40aa011d189bfe546084cdee53dbe", "html_url": "https://github.com/rust-lang/rust/commit/3b2b5b2914d40aa011d189bfe546084cdee53dbe"}, {"sha": "86ac0b4147822e23c671a40e7ba1bf5b5835150d", "url": "https://api.github.com/repos/rust-lang/rust/commits/86ac0b4147822e23c671a40e7ba1bf5b5835150d", "html_url": "https://github.com/rust-lang/rust/commit/86ac0b4147822e23c671a40e7ba1bf5b5835150d"}], "stats": {"total": 247434, "additions": 169490, "deletions": 77944}, "files": [{"sha": "82599b1450386719fab9e732cc3502d342e4e850", "filename": ".gitattributes", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitattributes?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -16,3 +16,11 @@ config.toml.example linguist-language=TOML\n *.ico binary\n *.woff binary\n *.woff2 binary\n+\n+# Needed as part of converting rustfmt to a subtree, can hopefully be removed later.\n+src/tools/rustfmt/tests/source/issue-3494/crlf.rs -text\n+src/tools/rustfmt/tests/source/comment_crlf_newline.rs -text\n+src/tools/rustfmt/tests/source/configs/enum_discrim_align_threshold/40.rs -text\n+src/tools/rustfmt/tests/target/issue-3494/crlf.rs -text\n+src/tools/rustfmt/tests/target/comment_crlf_newline.rs -text\n+src/tools/rustfmt/tests/target/configs/enum_discrim_align_threshold/40.rs -text"}, {"sha": "c0e90824a710dfa73be33368854ee94d768bde41", "filename": ".github/ISSUE_TEMPLATE/regression.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/.github%2FISSUE_TEMPLATE%2Fregression.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/.github%2FISSUE_TEMPLATE%2Fregression.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fregression.md?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -1,7 +1,7 @@\n ---\n name: Regression\n about: Report something that unexpectedly changed between Rust versions.\n-labels: C-bug regression-untriaged\n+labels: C-bug, regression-untriaged\n ---\n <!--\n Thank you for filing a regression report! \ud83d\udc1b A regression is something that changed between versions of Rust but was not supposed to."}, {"sha": "aa9d97ba477b76b85fddb9391195d4b1a6ce1fca", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -72,6 +72,9 @@ jobs:\n       - name: decide whether to skip this job\n         run: src/ci/scripts/should-skip-this.sh\n         if: success() && !env.SKIP_JOB\n+      - name: ensure the channel matches the target branch\n+        run: src/ci/scripts/verify-channel.sh\n+        if: success() && !env.SKIP_JOB\n       - name: configure GitHub Actions to kill the build when outdated\n         uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n         with:\n@@ -434,6 +437,9 @@ jobs:\n       - name: decide whether to skip this job\n         run: src/ci/scripts/should-skip-this.sh\n         if: success() && !env.SKIP_JOB\n+      - name: ensure the channel matches the target branch\n+        run: src/ci/scripts/verify-channel.sh\n+        if: success() && !env.SKIP_JOB\n       - name: configure GitHub Actions to kill the build when outdated\n         uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n         with:\n@@ -541,6 +547,9 @@ jobs:\n       - name: decide whether to skip this job\n         run: src/ci/scripts/should-skip-this.sh\n         if: success() && !env.SKIP_JOB\n+      - name: ensure the channel matches the target branch\n+        run: src/ci/scripts/verify-channel.sh\n+        if: success() && !env.SKIP_JOB\n       - name: configure GitHub Actions to kill the build when outdated\n         uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n         with:"}, {"sha": "0cd6b9f648d0fb4bfd0189a66969c39c58e55a40", "filename": ".gitignore", "status": "modified", "additions": 44, "deletions": 26, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -5,53 +5,71 @@\n # created during manual debugging and many people like to clean up instead of\n # having git ignore such leftovers. You can use `.git/info/exclude` to\n # configure your local ignore list.\n-# FIXME: This needs cleanup.\n-*~\n+\n+## File system\n+.DS_Store\n+desktop.ini\n+\n+## Editor\n *.swp\n *.swo\n-.#*\n-.DS_Store\n+Session.vim\n .cproject\n-.hg/\n-.hgignore\n .idea\n *.iml\n-__pycache__/\n-*.py[cod]\n-*$py.class\n+.vscode\n .project\n+.favorites.json\n .settings/\n+\n+## Tool\n .valgrindrc\n-.vscode\n-.favorites.json\n-/Makefile\n-/build/\n+.cargo\n+# Included because it is part of the test case\n+!/src/test/run-make/thumb-none-qemu/example/.cargo\n+\n+## Configuration\n /config.toml\n-/dist/\n+/Makefile\n+config.mk\n+config.stamp\n+no_llvm_build\n+\n+## Build\n /dl/\n /doc/\n /inst/\n /llvm/\n /mingw-build/\n-/src/tools/x/target\n-# Created by default with `src/ci/docker/run.sh`:\n-/obj/\n+/build/\n+/dist/\n /unicode-downloads\n /target\n-# Generated by compiletest for incremental:\n+/src/tools/x/target\n+# Generated by compiletest for incremental\n /tmp/\n+# Created by default with `src/ci/docker/run.sh`\n+/obj/\n+\n+## Temporary files\n+*~\n+\\#*\n+\\#*\\#\n+.#*\n+\n+## Tags\n tags\n tags.*\n TAGS\n TAGS.*\n-\\#*\n-\\#*\\#\n-config.mk\n-config.stamp\n-Session.vim\n-.cargo\n-!/src/test/run-make/thumb-none-qemu/example/.cargo\n-no_llvm_build\n+\n+## Python\n+__pycache__/\n+*.py[cod]\n+*$py.class\n+\n+## Node\n **node_modules\n **package-lock.json\n+\n # Before adding new lines, see the comment at the top."}, {"sha": "aee038aa4c8e5e9f267b08a2ca503514c382a289", "filename": ".gitmodules", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -16,9 +16,6 @@\n [submodule \"src/tools/rls\"]\n \tpath = src/tools/rls\n \turl = https://github.com/rust-lang/rls.git\n-[submodule \"src/tools/rustfmt\"]\n-\tpath = src/tools/rustfmt\n-\turl = https://github.com/rust-lang/rustfmt.git\n [submodule \"src/tools/miri\"]\n \tpath = src/tools/miri\n \turl = https://github.com/rust-lang/miri.git\n@@ -37,7 +34,7 @@\n [submodule \"src/llvm-project\"]\n \tpath = src/llvm-project\n \turl = https://github.com/rust-lang/llvm-project.git\n-\tbranch = rustc/12.0-2021-02-03\n+\tbranch = rustc/12.0-2021-04-15\n [submodule \"src/doc/embedded-book\"]\n \tpath = src/doc/embedded-book\n \turl = https://github.com/rust-embedded/book.git"}, {"sha": "213aa6eff6666be80b43271e684fa8bc643da700", "filename": ".mailmap", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -43,7 +43,8 @@ Brian Anderson <banderson@mozilla.com> <andersrb@gmail.com>\n Brian Anderson <banderson@mozilla.com> <banderson@mozilla.org>\n Brian Dawn <brian.t.dawn@gmail.com>\n Brian Leibig <brian@brianleibig.com> Brian Leibig <brian.leibig@gmail.com>\n-Camelid <camelidcamel@gmail.com> <37223377+camelid@users.noreply.github.com>\n+Noah Lev <camelidcamel@gmail.com>\n+Noah Lev <camelidcamel@gmail.com> <37223377+camelid@users.noreply.github.com>\n Carl-Anton Ingmarsson <mail@carlanton.se> <ca.ingmarsson@gmail.com>\n Carol (Nichols || Goulding) <carol.nichols@gmail.com> <193874+carols10cents@users.noreply.github.com>\n Carol (Nichols || Goulding) <carol.nichols@gmail.com> <carol.nichols@gmail.com>\n@@ -286,7 +287,7 @@ Xuefeng Wu <benewu@gmail.com> Xuefeng Wu <xfwu@thoughtworks.com>\n Xuefeng Wu <benewu@gmail.com> XuefengWu <benewu@gmail.com>\n York Xiang <bombless@126.com>\n Youngsoo Son <ysson83@gmail.com> <ysoo.son@samsung.com>\n-Yuki Okushi <huyuumi.dev@gmail.com>\n+Yuki Okushi <jtitor@2k36.org> <huyuumi.dev@gmail.com>\n Zach Pomerantz <zmp@umich.edu>\n Zack Corr <zack@z0w0.me> <zackcorr95@gmail.com>\n Zack Slayton <zack.slayton@gmail.com>"}, {"sha": "d5453c5fd6ca190e2692f2819f210f1a6a3730b2", "filename": "Cargo.lock", "status": "modified", "additions": 305, "deletions": 392, "changes": 697, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -55,23 +55,17 @@ dependencies = [\n  \"markup5ever_rcdom\",\n  \"matches\",\n  \"tendril\",\n- \"url 2.1.1\",\n-]\n-\n-[[package]]\n-name = \"annotate-snippets\"\n-version = \"0.6.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c7021ce4924a3f25f802b2cccd1af585e39ea1a363a1aa2e72afe54b67a3a7a7\"\n-dependencies = [\n- \"ansi_term 0.11.0\",\n+ \"url 2.2.2\",\n ]\n \n [[package]]\n name = \"annotate-snippets\"\n version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"d78ea013094e5ea606b1c05fe35f1dd7ea1eb1ea259908d040b25bd5ec677ee5\"\n+dependencies = [\n+ \"yansi-term\",\n+]\n \n [[package]]\n name = \"ansi_term\"\n@@ -103,17 +97,11 @@ version = \"1.0.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8f8cb5d814eb646a863c4f24978cff2880c4be96ad8cde2c0f0678732902e271\"\n \n-[[package]]\n-name = \"arrayref\"\n-version = \"0.3.6\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a4c527152e37cf757a3f78aae5a06fbeefdb07ccc535c980a3208ee3060dd544\"\n-\n [[package]]\n name = \"arrayvec\"\n-version = \"0.5.1\"\n+version = \"0.7.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cff77d8686867eceff3105329d4698d96c2391c176d5d03adc90c7389162b5b8\"\n+checksum = \"5a2f58b0bb10c380af2b26e57212856b8c9a59e0925b4c20f4a174a49734eaf7\"\n \n [[package]]\n name = \"atty\"\n@@ -132,12 +120,6 @@ version = \"1.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"f8aac770f1885fd7e387acedd76065302551364496e46b3dd00860b2f8359b9d\"\n \n-[[package]]\n-name = \"base64\"\n-version = \"0.11.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b41b7ea54a0c9d92199de89e20e58d49f02f8e699814ef3fdf266f6f748d15c7\"\n-\n [[package]]\n name = \"bitflags\"\n version = \"1.2.1\"\n@@ -153,17 +135,6 @@ dependencies = [\n  \"typenum\",\n ]\n \n-[[package]]\n-name = \"blake2b_simd\"\n-version = \"0.5.10\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d8fb2d74254a3a0b5cac33ac9f8ed0e44aa50378d9dbb2e5d83bd21ed1dc2c8a\"\n-dependencies = [\n- \"arrayref\",\n- \"arrayvec\",\n- \"constant_time_eq\",\n-]\n-\n [[package]]\n name = \"block-buffer\"\n version = \"0.7.3\"\n@@ -281,7 +252,7 @@ checksum = \"81a18687293a1546b67c246452202bbbf143d239cb43494cc163da14979082da\"\n \n [[package]]\n name = \"cargo\"\n-version = \"0.53.0\"\n+version = \"0.55.0\"\n dependencies = [\n  \"anyhow\",\n  \"atty\",\n@@ -292,7 +263,7 @@ dependencies = [\n  \"cargo-util\",\n  \"clap\",\n  \"crates-io\",\n- \"crossbeam-utils 0.8.0\",\n+ \"crossbeam-utils 0.8.3\",\n  \"curl\",\n  \"curl-sys\",\n  \"env_logger 0.8.1\",\n@@ -326,14 +297,15 @@ dependencies = [\n  \"serde\",\n  \"serde_ignored\",\n  \"serde_json\",\n+ \"shell-escape\",\n  \"strip-ansi-escapes\",\n  \"tar\",\n  \"tempfile\",\n  \"termcolor\",\n  \"toml\",\n  \"unicode-width\",\n  \"unicode-xid\",\n- \"url 2.1.1\",\n+ \"url 2.2.2\",\n  \"walkdir\",\n  \"winapi 0.3.9\",\n ]\n@@ -406,7 +378,7 @@ dependencies = [\n  \"serde_json\",\n  \"tar\",\n  \"toml\",\n- \"url 2.1.1\",\n+ \"url 2.2.2\",\n ]\n \n [[package]]\n@@ -469,9 +441,9 @@ version = \"0.1.0\"\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.60\"\n+version = \"1.0.67\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ef611cc68ff783f18535d77ddd080185275713d852c4f5cbb6122c462a7a825c\"\n+checksum = \"e3c69b077ad434294d3ce9f1f6143a2a4b89a8a2d54ef813d85003a4fd1137fd\"\n dependencies = [\n  \"jobserver\",\n ]\n@@ -576,12 +548,12 @@ dependencies = [\n \n [[package]]\n name = \"clippy\"\n-version = \"0.1.53\"\n+version = \"0.1.54\"\n dependencies = [\n  \"cargo_metadata 0.12.0\",\n  \"clippy-mini-macro-test\",\n  \"clippy_lints\",\n- \"compiletest_rs 0.6.0\",\n+ \"compiletest_rs\",\n  \"derive-new\",\n  \"quote\",\n  \"regex\",\n@@ -591,16 +563,29 @@ dependencies = [\n  \"serde\",\n  \"syn\",\n  \"tempfile\",\n- \"tester 0.9.0\",\n+ \"tester\",\n ]\n \n [[package]]\n name = \"clippy-mini-macro-test\"\n version = \"0.2.0\"\n \n+[[package]]\n+name = \"clippy_dev\"\n+version = \"0.0.1\"\n+dependencies = [\n+ \"bytecount\",\n+ \"clap\",\n+ \"itertools 0.9.0\",\n+ \"opener\",\n+ \"regex\",\n+ \"shell-escape\",\n+ \"walkdir\",\n+]\n+\n [[package]]\n name = \"clippy_lints\"\n-version = \"0.1.53\"\n+version = \"0.1.54\"\n dependencies = [\n  \"cargo_metadata 0.12.0\",\n  \"clippy_utils\",\n@@ -612,14 +597,15 @@ dependencies = [\n  \"rustc-semver\",\n  \"semver 0.11.0\",\n  \"serde\",\n+ \"serde_json\",\n  \"toml\",\n  \"unicode-normalization\",\n- \"url 2.1.1\",\n+ \"url 2.2.2\",\n ]\n \n [[package]]\n name = \"clippy_utils\"\n-version = \"0.1.53\"\n+version = \"0.1.54\"\n dependencies = [\n  \"if_chain\",\n  \"itertools 0.9.0\",\n@@ -669,9 +655,9 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.39\"\n+version = \"0.1.43\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3748f82c7d366a0b4950257d19db685d4958d2fa27c6d164a3f069fec42b748b\"\n+checksum = \"65af2dcae4779003dfa91aedc6ade7bdc7ba685944e50a8b4f9380df376a4466\"\n dependencies = [\n  \"cc\",\n  \"rustc-std-workspace-core\",\n@@ -699,28 +685,6 @@ dependencies = [\n  \"winapi 0.3.9\",\n ]\n \n-[[package]]\n-name = \"compiletest_rs\"\n-version = \"0.5.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9f737835bfbbe29ed1ff82d5137520338d7ed5bf1a1d4b9c1c7c58bb45b8fa29\"\n-dependencies = [\n- \"diff\",\n- \"filetime\",\n- \"getopts\",\n- \"libc\",\n- \"log\",\n- \"miow 0.3.6\",\n- \"regex\",\n- \"rustfix\",\n- \"serde\",\n- \"serde_derive\",\n- \"serde_json\",\n- \"tempfile\",\n- \"tester 0.7.0\",\n- \"winapi 0.3.9\",\n-]\n-\n [[package]]\n name = \"compiletest_rs\"\n version = \"0.6.0\"\n@@ -740,22 +704,10 @@ dependencies = [\n  \"serde_derive\",\n  \"serde_json\",\n  \"tempfile\",\n- \"tester 0.9.0\",\n+ \"tester\",\n  \"winapi 0.3.9\",\n ]\n \n-[[package]]\n-name = \"const_fn\"\n-version = \"0.4.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c478836e029dcef17fb47c89023448c64f781a046e0300e257ad8225ae59afab\"\n-\n-[[package]]\n-name = \"constant_time_eq\"\n-version = \"0.1.5\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"245097e9a4535ee1e3e3931fcfcd55a796a44c643e8596ff6566d68f09b87bbc\"\n-\n [[package]]\n name = \"core\"\n version = \"0.0.0\"\n@@ -798,7 +750,7 @@ dependencies = [\n  \"percent-encoding 2.1.0\",\n  \"serde\",\n  \"serde_json\",\n- \"url 2.1.1\",\n+ \"url 2.2.2\",\n ]\n \n [[package]]\n@@ -817,7 +769,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"dca26ee1f8d361640700bde38b2c37d8c22b3ce2d360e1fc1c74ea4b0aa7d775\"\n dependencies = [\n  \"cfg-if 1.0.0\",\n- \"crossbeam-utils 0.8.0\",\n+ \"crossbeam-utils 0.8.3\",\n ]\n \n [[package]]\n@@ -870,13 +822,12 @@ dependencies = [\n \n [[package]]\n name = \"crossbeam-utils\"\n-version = \"0.8.0\"\n+version = \"0.8.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ec91540d98355f690a86367e566ecad2e9e579f230230eb7c21398372be73ea5\"\n+checksum = \"e7e9d99fa91428effe99c5c6d4634cdeba32b8cf784fc428a2a687f61a952c49\"\n dependencies = [\n  \"autocfg\",\n  \"cfg-if 1.0.0\",\n- \"const_fn\",\n  \"lazy_static\",\n ]\n \n@@ -914,24 +865,24 @@ dependencies = [\n \n [[package]]\n name = \"curl\"\n-version = \"0.4.34\"\n+version = \"0.4.36\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e268162af1a5fe89917ae25ba3b0a77c8da752bdc58e7dbb4f15b91fbd33756e\"\n+checksum = \"d0bac9f84ca0977c4d9b8db998689de55b9e976656a6bc87fada2ca710d504c7\"\n dependencies = [\n  \"curl-sys\",\n  \"libc\",\n  \"openssl-probe\",\n  \"openssl-sys\",\n  \"schannel\",\n- \"socket2\",\n+ \"socket2 0.4.0\",\n  \"winapi 0.3.9\",\n ]\n \n [[package]]\n name = \"curl-sys\"\n-version = \"0.4.39+curl-7.74.0\"\n+version = \"0.4.42+curl-7.76.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"07a8ce861e7b68a0b394e814d7ee9f1b2750ff8bd10372c6ad3bacc10e86f874\"\n+checksum = \"4636d8d6109c842707018a104051436bffb8991ea20b2d1293db70b6e0ee4c7c\"\n dependencies = [\n  \"cc\",\n  \"libc\",\n@@ -1003,9 +954,9 @@ dependencies = [\n \n [[package]]\n name = \"directories\"\n-version = \"3.0.1\"\n+version = \"3.0.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f8fed639d60b58d0f53498ab13d26f621fd77569cc6edb031f4cc36a2ad9da0f\"\n+checksum = \"e69600ff1703123957937708eb27f7a564e48885c537782722ed0ba3189ce1d7\"\n dependencies = [\n  \"dirs-sys\",\n ]\n@@ -1032,12 +983,12 @@ dependencies = [\n \n [[package]]\n name = \"dirs-sys\"\n-version = \"0.3.5\"\n+version = \"0.3.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8e93d7f5705de3e49895a2b5e0b8855a1c27f080192ae9c32a6432d50741a57a\"\n+checksum = \"03d86534ed367a67548dc68113a0f5db55432fdfbb6e6f9d77704397d95d5780\"\n dependencies = [\n  \"libc\",\n- \"redox_users 0.3.4\",\n+ \"redox_users\",\n  \"winapi 0.3.9\",\n ]\n \n@@ -1048,7 +999,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"4ebda144c4fe02d1f7ea1a7d9641b6fc6b580adcfa024ae48797ecdeb6825b4d\"\n dependencies = [\n  \"libc\",\n- \"redox_users 0.4.0\",\n+ \"redox_users\",\n  \"winapi 0.3.9\",\n ]\n \n@@ -1093,6 +1044,26 @@ dependencies = [\n  \"log\",\n ]\n \n+[[package]]\n+name = \"enum-iterator\"\n+version = \"0.6.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c79a6321a1197d7730510c7e3f6cb80432dfefecb32426de8cea0aa19b4bb8d7\"\n+dependencies = [\n+ \"enum-iterator-derive\",\n+]\n+\n+[[package]]\n+name = \"enum-iterator-derive\"\n+version = \"0.6.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1e94aa31f7c0dc764f57896dc615ddd76fc13b0d5dca7eb6cc5e018a5a09ec06\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n [[package]]\n name = \"env_logger\"\n version = \"0.6.2\"\n@@ -1166,13 +1137,13 @@ checksum = \"e88a8acf291dafb59c2d96e8f59828f3838bb1a70398823ade51a84de6a6deed\"\n \n [[package]]\n name = \"filetime\"\n-version = \"0.2.12\"\n+version = \"0.2.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3ed85775dcc68644b5c950ac06a2b23768d3bc9390464151aaf27136998dcf9e\"\n+checksum = \"1d34cfa13a63ae058bfa601fe9e313bbdb3746427c1459185464ce0fcf62e1e8\"\n dependencies = [\n- \"cfg-if 0.1.10\",\n+ \"cfg-if 1.0.0\",\n  \"libc\",\n- \"redox_syscall 0.1.57\",\n+ \"redox_syscall\",\n  \"winapi 0.3.9\",\n ]\n \n@@ -1216,6 +1187,16 @@ version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"00b0228411908ca8685dba7fc2cdd70ec9990a6e753e89b6ac91a84c40fbaf4b\"\n \n+[[package]]\n+name = \"form_urlencoded\"\n+version = \"1.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5fc25a87fa4fd2094bffb06925852034d90a17f0d1e05197d4956d3555752191\"\n+dependencies = [\n+ \"matches\",\n+ \"percent-encoding 2.1.0\",\n+]\n+\n [[package]]\n name = \"fortanix-sgx-abi\"\n version = \"0.3.3\"\n@@ -1240,12 +1221,9 @@ checksum = \"5f2a4a2034423744d2cc7ca2068453168dcdb82c438419e639a26bd87839c674\"\n \n [[package]]\n name = \"fst\"\n-version = \"0.3.5\"\n+version = \"0.4.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"927fb434ff9f0115b215dc0efd2e4fbdd7448522a92a1aa37c77d6a2f8f1ebd6\"\n-dependencies = [\n- \"byteorder\",\n-]\n+checksum = \"d79238883cf0307100b90aba4a755d8051a3182305dfe7f649a1e9dc0517006f\"\n \n [[package]]\n name = \"fuchsia-zircon\"\n@@ -1438,6 +1416,18 @@ dependencies = [\n  \"wasi\",\n ]\n \n+[[package]]\n+name = \"getset\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"24b328c01a4d71d2d8173daa93562a73ab0fe85616876f02500f53d82948c504\"\n+dependencies = [\n+ \"proc-macro-error\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n [[package]]\n name = \"gimli\"\n version = \"0.23.0\"\n@@ -1461,7 +1451,7 @@ dependencies = [\n  \"log\",\n  \"openssl-probe\",\n  \"openssl-sys\",\n- \"url 2.1.1\",\n+ \"url 2.2.2\",\n ]\n \n [[package]]\n@@ -1473,7 +1463,7 @@ dependencies = [\n  \"curl\",\n  \"git2\",\n  \"log\",\n- \"url 2.1.1\",\n+ \"url 2.2.2\",\n ]\n \n [[package]]\n@@ -1635,11 +1625,11 @@ checksum = \"c3360c7b59e5ffa2653671fb74b4741a5d343c03f331c0a4aeda42b5c2b0ec7d\"\n \n [[package]]\n name = \"ignore\"\n-version = \"0.4.16\"\n+version = \"0.4.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"22dcbf2a4a289528dbef21686354904e1c694ac642610a9bff9e7df730d9ec72\"\n+checksum = \"b287fb45c60bb826a0dc68ff08742b9d88a2fea13d6e0c286b3172065aaf878c\"\n dependencies = [\n- \"crossbeam-utils 0.7.2\",\n+ \"crossbeam-utils 0.8.3\",\n  \"globset\",\n  \"lazy_static\",\n  \"log\",\n@@ -1731,31 +1721,20 @@ version = \"0.4.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"dc6f3ad7b9d11a0c00842ff8de1b60ee58661048eb8049ed33c73594f359d7e6\"\n \n-[[package]]\n-name = \"jemalloc-sys\"\n-version = \"0.3.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0d3b9f3f5c9b31aa0f5ed3260385ac205db665baa41d49bb8338008ae94ede45\"\n-dependencies = [\n- \"cc\",\n- \"fs_extra\",\n- \"libc\",\n-]\n-\n [[package]]\n name = \"jobserver\"\n-version = \"0.1.21\"\n+version = \"0.1.22\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5c71313ebb9439f74b00d9d2dcec36440beaf57a6aa0623068441dd7cd81a7f2\"\n+checksum = \"972f5ae5d1cb9c6ae417789196c803205313edde988685da5e3aae0827b9e7fd\"\n dependencies = [\n  \"libc\",\n ]\n \n [[package]]\n name = \"json\"\n-version = \"0.11.15\"\n+version = \"0.12.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"92c245af8786f6ac35f95ca14feca9119e71339aaab41e878e7cdd655c97e9e5\"\n+checksum = \"078e285eafdfb6c4b434e0d31e8cfcb5115b651496faca5749b88fafd4f23bfd\"\n \n [[package]]\n name = \"jsondocck\"\n@@ -1909,9 +1888,9 @@ checksum = \"830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.88\"\n+version = \"0.2.93\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"03b07a082330a35e43f63177cc01689da34fbffa0105e1246cf0311472cac73a\"\n+checksum = \"9385f66bf6105b241aa65a61cb923ef20efc665cb9f9bb50ac2f0c4b7f378d41\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -2006,11 +1985,11 @@ dependencies = [\n \n [[package]]\n name = \"log\"\n-version = \"0.4.11\"\n+version = \"0.4.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4fabed175da42fed1fa0746b0ea71f412aa9d35e76e95e59b192c64b9dc2bf8b\"\n+checksum = \"51b9bbe6c47d51fc3e1a9b945965946b4c44142ab8792c50835a980d362c2710\"\n dependencies = [\n- \"cfg-if 0.1.10\",\n+ \"cfg-if 1.0.0\",\n ]\n \n [[package]]\n@@ -2034,7 +2013,7 @@ dependencies = [\n  \"serde\",\n  \"serde_json\",\n  \"serde_repr\",\n- \"url 2.1.1\",\n+ \"url 2.2.2\",\n ]\n \n [[package]]\n@@ -2156,16 +2135,16 @@ dependencies = [\n \n [[package]]\n name = \"measureme\"\n-version = \"9.1.0\"\n+version = \"9.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4a98e07fe802486895addb2b5467f33f205e82c426bfaf350f5d8109b137767c\"\n+checksum = \"49cf14eb7d2eea897d9949b68f19e165638755e3a1a3c0941b6b6c3e00141f2c\"\n dependencies = [\n  \"log\",\n- \"memmap\",\n+ \"memmap2\",\n  \"parking_lot\",\n  \"perf-event-open-sys\",\n  \"rustc-hash\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n ]\n \n [[package]]\n@@ -2174,16 +2153,6 @@ version = \"2.3.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3728d817d99e5ac407411fa471ff9800a778d88a24685968b36824eaf4bee400\"\n \n-[[package]]\n-name = \"memmap\"\n-version = \"0.7.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6585fd95e7bb50d6cc31e20d4cf9afb4e2ba16c5846fc76793f11218da9c475b\"\n-dependencies = [\n- \"libc\",\n- \"winapi 0.3.9\",\n-]\n-\n [[package]]\n name = \"memmap2\"\n version = \"0.2.1\"\n@@ -2226,9 +2195,9 @@ dependencies = [\n \n [[package]]\n name = \"minifier\"\n-version = \"0.0.39\"\n+version = \"0.0.41\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6cdf618de5c9c98d4a7b2e0d1f1e44f82a19196cfd94040bb203621c25d28d98\"\n+checksum = \"5594542d20834f2b974f5e5fb8e0cf1c67a2119dcadc29ef5d93a081fb30cc08\"\n dependencies = [\n  \"macro-utils\",\n ]\n@@ -2305,7 +2274,7 @@ version = \"0.3.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"5a33c1b55807fbed163481b5ba66db4b2fa6cde694a5027be10fb724206c5897\"\n dependencies = [\n- \"socket2\",\n+ \"socket2 0.3.19\",\n  \"winapi 0.3.9\",\n ]\n \n@@ -2314,17 +2283,17 @@ name = \"miri\"\n version = \"0.1.0\"\n dependencies = [\n  \"colored\",\n- \"compiletest_rs 0.5.0\",\n- \"env_logger 0.7.1\",\n+ \"compiletest_rs\",\n+ \"env_logger 0.8.1\",\n  \"getrandom 0.2.0\",\n  \"hex 0.4.2\",\n  \"libc\",\n  \"log\",\n- \"rand 0.7.3\",\n+ \"rand 0.8.3\",\n  \"rustc-workspace-hack\",\n  \"rustc_version\",\n  \"shell-escape\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n ]\n \n [[package]]\n@@ -2422,15 +2391,15 @@ dependencies = [\n \n [[package]]\n name = \"openssl\"\n-version = \"0.10.30\"\n+version = \"0.10.33\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8d575eff3665419f9b83678ff2815858ad9d11567e082f5ac1814baba4e2bcb4\"\n+checksum = \"a61075b62a23fef5a29815de7536d940aa35ce96d18ce0cc5076272db678a577\"\n dependencies = [\n  \"bitflags\",\n- \"cfg-if 0.1.10\",\n+ \"cfg-if 1.0.0\",\n  \"foreign-types\",\n- \"lazy_static\",\n  \"libc\",\n+ \"once_cell\",\n  \"openssl-sys\",\n ]\n \n@@ -2442,18 +2411,18 @@ checksum = \"77af24da69f9d9341038eba93a073b1fdaaa1b788221b00a69bce9e762cb32de\"\n \n [[package]]\n name = \"openssl-src\"\n-version = \"111.12.0+1.1.1h\"\n+version = \"111.15.0+1.1.1k\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"858a4132194f8570a7ee9eb8629e85b23cbc4565f2d4a162e87556e5956abf61\"\n+checksum = \"b1a5f6ae2ac04393b217ea9f700cd04fa9bf3d93fae2872069f3d15d908af70a\"\n dependencies = [\n  \"cc\",\n ]\n \n [[package]]\n name = \"openssl-sys\"\n-version = \"0.9.58\"\n+version = \"0.9.61\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a842db4709b604f0fe5d1170ae3565899be2ad3d9cbc72dedc789ac0511f78de\"\n+checksum = \"313752393519e876837e09e1fa183ddef0be7735868dced3196f4472d536277f\"\n dependencies = [\n  \"autocfg\",\n  \"cc\",\n@@ -2492,6 +2461,7 @@ dependencies = [\n name = \"panic_abort\"\n version = \"0.0.0\"\n dependencies = [\n+ \"alloc\",\n  \"cfg-if 0.1.10\",\n  \"compiler_builtins\",\n  \"core\",\n@@ -2546,8 +2516,8 @@ dependencies = [\n  \"cfg-if 1.0.0\",\n  \"instant\",\n  \"libc\",\n- \"redox_syscall 0.2.5\",\n- \"smallvec 1.6.1\",\n+ \"redox_syscall\",\n+ \"smallvec\",\n  \"winapi 0.3.9\",\n ]\n \n@@ -2875,9 +2845,9 @@ dependencies = [\n \n [[package]]\n name = \"racer\"\n-version = \"2.1.44\"\n+version = \"2.1.47\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7972a124e2b24dce35eb19f81eced829faec0e8227a7d744bbb1089934d05399\"\n+checksum = \"513c70e67444a0d62fdc581dffa521c6820942a5f08300d0864863f8d0e750e3\"\n dependencies = [\n  \"bitflags\",\n  \"clap\",\n@@ -3030,12 +3000,6 @@ dependencies = [\n  \"num_cpus\",\n ]\n \n-[[package]]\n-name = \"redox_syscall\"\n-version = \"0.1.57\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"41cc0f7e4d5d4544e8861606a285bb08d3e70712ccc7d2b84d7c0ccfaf4b05ce\"\n-\n [[package]]\n name = \"redox_syscall\"\n version = \"0.2.5\"\n@@ -3045,25 +3009,14 @@ dependencies = [\n  \"bitflags\",\n ]\n \n-[[package]]\n-name = \"redox_users\"\n-version = \"0.3.4\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"09b23093265f8d200fa7b4c2c76297f47e681c655f6f1285a8780d6a022f7431\"\n-dependencies = [\n- \"getrandom 0.1.14\",\n- \"redox_syscall 0.1.57\",\n- \"rust-argon2\",\n-]\n-\n [[package]]\n name = \"redox_users\"\n version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"528532f3d801c87aec9def2add9ca802fe569e44a544afe633765267840abe64\"\n dependencies = [\n  \"getrandom 0.2.0\",\n- \"redox_syscall 0.2.5\",\n+ \"redox_syscall\",\n ]\n \n [[package]]\n@@ -3117,6 +3070,7 @@ version = \"1.41.0\"\n dependencies = [\n  \"anyhow\",\n  \"cargo\",\n+ \"cargo-util\",\n  \"cargo_metadata 0.8.2\",\n  \"clippy_lints\",\n  \"crossbeam-channel\",\n@@ -3125,7 +3079,7 @@ dependencies = [\n  \"futures 0.3.12\",\n  \"heck\",\n  \"home\",\n- \"itertools 0.8.2\",\n+ \"itertools 0.9.0\",\n  \"jsonrpc-core\",\n  \"lazy_static\",\n  \"log\",\n@@ -3154,20 +3108,20 @@ dependencies = [\n  \"tokio\",\n  \"tokio-util\",\n  \"toml\",\n- \"url 2.1.1\",\n+ \"url 2.2.2\",\n  \"walkdir\",\n ]\n \n [[package]]\n name = \"rls-analysis\"\n-version = \"0.18.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"534032993e1b60e5db934eab2dde54da7afd1e46c3465fddb2b29eb47cb1ed3a\"\n+version = \"0.18.2\"\n dependencies = [\n  \"derive-new\",\n+ \"env_logger 0.7.1\",\n  \"fst\",\n- \"itertools 0.8.2\",\n+ \"itertools 0.9.0\",\n  \"json\",\n+ \"lazy_static\",\n  \"log\",\n  \"rls-data\",\n  \"rls-span\",\n@@ -3231,18 +3185,6 @@ dependencies = [\n  \"rls-span\",\n ]\n \n-[[package]]\n-name = \"rust-argon2\"\n-version = \"0.7.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2bc8af4bda8e1ff4932523b94d3dd20ee30a87232323eda55903ffd71d2fb017\"\n-dependencies = [\n- \"base64\",\n- \"blake2b_simd\",\n- \"constant_time_eq\",\n- \"crossbeam-utils 0.7.2\",\n-]\n-\n [[package]]\n name = \"rust-demangler\"\n version = \"0.0.1\"\n@@ -3262,18 +3204,19 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_arena\"\n-version = \"705.0.0\"\n+version = \"718.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"93575affa286089b92c8208aea4e60fe9fdd251a619a09b566d6e4e2cc123212\"\n+checksum = \"526610f47139efa440178239553b59ea805ff57a532b4e295c71d2a9b18fd676\"\n dependencies = [\n- \"smallvec 1.6.1\",\n+ \"rustc-ap-rustc_data_structures\",\n+ \"smallvec\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_ast\"\n-version = \"705.0.0\"\n+version = \"718.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4c700f2d3b25aa8d6446dd2936048737b08b2d547bd86e2a70afa9fee4e9c522\"\n+checksum = \"cf6a9dda0804a7243b0282e3b75a8cf4654c7a61f033e587751941e1fe39391b\"\n dependencies = [\n  \"bitflags\",\n  \"rustc-ap-rustc_data_structures\",\n@@ -3282,73 +3225,37 @@ dependencies = [\n  \"rustc-ap-rustc_macros\",\n  \"rustc-ap-rustc_serialize\",\n  \"rustc-ap-rustc_span\",\n- \"smallvec 1.6.1\",\n- \"tracing\",\n-]\n-\n-[[package]]\n-name = \"rustc-ap-rustc_ast_passes\"\n-version = \"705.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8e01f63e5259ee397bbe2e395d34a2e6b6b24f10c184d30fbbee1dcd7117f4f3\"\n-dependencies = [\n- \"itertools 0.9.0\",\n- \"rustc-ap-rustc_ast\",\n- \"rustc-ap-rustc_ast_pretty\",\n- \"rustc-ap-rustc_attr\",\n- \"rustc-ap-rustc_data_structures\",\n- \"rustc-ap-rustc_errors\",\n- \"rustc-ap-rustc_feature\",\n- \"rustc-ap-rustc_parse\",\n- \"rustc-ap-rustc_session\",\n- \"rustc-ap-rustc_span\",\n+ \"smallvec\",\n  \"tracing\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_ast_pretty\"\n-version = \"705.0.0\"\n+version = \"718.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"99d644c69c55deb24257cb0cb5261265fe5134f6f545e9062e1c18b07e422c68\"\n+checksum = \"82f5019be8b41a58664169fd2f4b1a37fe82705681db394b76419e4e87d40ab1\"\n dependencies = [\n  \"rustc-ap-rustc_ast\",\n  \"rustc-ap-rustc_span\",\n  \"tracing\",\n ]\n \n-[[package]]\n-name = \"rustc-ap-rustc_attr\"\n-version = \"705.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"797fc68816d5396870f04e03d35164f5275d2502403239d4caec7ce063683f41\"\n-dependencies = [\n- \"rustc-ap-rustc_ast\",\n- \"rustc-ap-rustc_ast_pretty\",\n- \"rustc-ap-rustc_data_structures\",\n- \"rustc-ap-rustc_errors\",\n- \"rustc-ap-rustc_feature\",\n- \"rustc-ap-rustc_lexer\",\n- \"rustc-ap-rustc_macros\",\n- \"rustc-ap-rustc_serialize\",\n- \"rustc-ap-rustc_session\",\n- \"rustc-ap-rustc_span\",\n-]\n-\n [[package]]\n name = \"rustc-ap-rustc_data_structures\"\n-version = \"705.0.0\"\n+version = \"718.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5d840c4e6198b57982a54543ae604d634c7ceb7107f0c75970b88ebaff077ac5\"\n+checksum = \"a701717fb14549331085756b9741ae3b4bf35808489f1887d72c1d0e0fe52b77\"\n dependencies = [\n  \"arrayvec\",\n  \"bitflags\",\n  \"cfg-if 0.1.10\",\n- \"crossbeam-utils 0.7.2\",\n+ \"crossbeam-utils 0.8.3\",\n  \"ena\",\n  \"indexmap\",\n  \"jobserver\",\n  \"libc\",\n  \"measureme\",\n+ \"memmap2\",\n  \"parking_lot\",\n  \"rustc-ap-rustc_graphviz\",\n  \"rustc-ap-rustc_index\",\n@@ -3357,7 +3264,7 @@ dependencies = [\n  \"rustc-hash\",\n  \"rustc-rayon\",\n  \"rustc-rayon-core\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"stable_deref_trait\",\n  \"stacker\",\n  \"tempfile\",\n@@ -3367,11 +3274,11 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_errors\"\n-version = \"705.0.0\"\n+version = \"718.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2f2f99bdc828ad417636d9016611dc9047b641fadcb7f533b8b0e9616d81f90b\"\n+checksum = \"e3182ce85e8bfc96443475547f2f5aa2b5e67655d9b88721795f36f0ba9e265a\"\n dependencies = [\n- \"annotate-snippets 0.8.0\",\n+ \"annotate-snippets\",\n  \"atty\",\n  \"rustc-ap-rustc_data_structures\",\n  \"rustc-ap-rustc_lint_defs\",\n@@ -3385,57 +3292,33 @@ dependencies = [\n  \"winapi 0.3.9\",\n ]\n \n-[[package]]\n-name = \"rustc-ap-rustc_expand\"\n-version = \"705.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"27008b4c7ded287bf5cb20b84d6d5a6566329140f2e2bc8f6e68b37a34898595\"\n-dependencies = [\n- \"rustc-ap-rustc_ast\",\n- \"rustc-ap-rustc_ast_passes\",\n- \"rustc-ap-rustc_ast_pretty\",\n- \"rustc-ap-rustc_attr\",\n- \"rustc-ap-rustc_data_structures\",\n- \"rustc-ap-rustc_errors\",\n- \"rustc-ap-rustc_feature\",\n- \"rustc-ap-rustc_lexer\",\n- \"rustc-ap-rustc_lint_defs\",\n- \"rustc-ap-rustc_macros\",\n- \"rustc-ap-rustc_parse\",\n- \"rustc-ap-rustc_serialize\",\n- \"rustc-ap-rustc_session\",\n- \"rustc-ap-rustc_span\",\n- \"smallvec 1.6.1\",\n- \"tracing\",\n-]\n-\n [[package]]\n name = \"rustc-ap-rustc_feature\"\n-version = \"705.0.0\"\n+version = \"718.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6bb47b53670f1263ed1389dda932d5b5a6daf98579c1f076c2ee7d7f22709b7c\"\n+checksum = \"eed033b93270126ef60963c3ebbd0e026bf53b985172b6366c7b0e7881c9d507\"\n dependencies = [\n  \"rustc-ap-rustc_data_structures\",\n  \"rustc-ap-rustc_span\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_fs_util\"\n-version = \"705.0.0\"\n+version = \"718.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cdaddc4bae5ffab17037553e172f5014686db600050429aaa60aec14fe780e84\"\n+checksum = \"28ee6531986a205101e09fd143d7bf31897388f33b1814d4bcc45fd62211dca6\"\n \n [[package]]\n name = \"rustc-ap-rustc_graphviz\"\n-version = \"705.0.0\"\n+version = \"718.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3d73c72543311e88786f7380a3bfd946395579c1a0c0441a879a97fcdea79130\"\n+checksum = \"3398fddc0e23d2db89c036f8952ddf78cadc597f7059752116e69483e164a5b6\"\n \n [[package]]\n name = \"rustc-ap-rustc_index\"\n-version = \"705.0.0\"\n+version = \"718.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bba8d74ed4bad44a5b4264cf2a51ad0bd458ed56caa5bb090e989b8002ec6327\"\n+checksum = \"dca4e27eb5b701f6bbd47d8fc9d242378fca3e4107a519a28415c2989c4a3bd3\"\n dependencies = [\n  \"arrayvec\",\n  \"rustc-ap-rustc_macros\",\n@@ -3444,18 +3327,18 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_lexer\"\n-version = \"705.0.0\"\n+version = \"718.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3a030d00510966cd31e13dca5e6c1bd40d303a932c54eca40e854188bca8c49e\"\n+checksum = \"786bbfe9d4d5264294c1819dbf1497a2480b583d5eda1ca9ae22e12d6661f5df\"\n dependencies = [\n  \"unicode-xid\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_lint_defs\"\n-version = \"705.0.0\"\n+version = \"718.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bdff95da1b5d979183ef5c285817ba6cc67a1ac11296ef1e87b1b5bbaf57213c\"\n+checksum = \"be2f045e2b999c154ec505d5fea69c994b742f3ebd2f552d11a6c81723921e47\"\n dependencies = [\n  \"rustc-ap-rustc_ast\",\n  \"rustc-ap-rustc_data_structures\",\n@@ -3468,9 +3351,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_macros\"\n-version = \"705.0.0\"\n+version = \"718.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fe3ed7401bf6f5a256d58cd0e1c1e2e77eec25e60a0d7ad75313962edcb4e396\"\n+checksum = \"27789cd26d6b9e2fdfa68a262a20664d79ca67d31a3886d40fb88ebf6935869c\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -3480,9 +3363,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_parse\"\n-version = \"705.0.0\"\n+version = \"718.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"609a624baffa3f99847d57d30c96ee6732ce0912f8df4be239b6fd91533910d6\"\n+checksum = \"1dc331f4958350679679e619d63a891e8d5d34ef99087068c89aa9e657d52caa\"\n dependencies = [\n  \"bitflags\",\n  \"rustc-ap-rustc_ast\",\n@@ -3493,26 +3376,26 @@ dependencies = [\n  \"rustc-ap-rustc_lexer\",\n  \"rustc-ap-rustc_session\",\n  \"rustc-ap-rustc_span\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tracing\",\n  \"unicode-normalization\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_serialize\"\n-version = \"705.0.0\"\n+version = \"718.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bc232e2a351d8131c8f1386ce372ee22ef7b1b0b897bbf817a8ce4792029a564\"\n+checksum = \"e9a6824a462c4c1a379e911b0faf86d303a54bcf8673d4cc445195085966a4a4\"\n dependencies = [\n  \"indexmap\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_session\"\n-version = \"705.0.0\"\n+version = \"718.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"18acf94c820cd0c64ee1cbd811fd1f4d5ba18987c457c88771359b90cb1a12f5\"\n+checksum = \"a782a5f6ada0dbe089c6416ad0104f0b8a8bdb4bd26ea95e5fefaec67aed5e8a\"\n dependencies = [\n  \"bitflags\",\n  \"getopts\",\n@@ -3532,9 +3415,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_span\"\n-version = \"705.0.0\"\n+version = \"718.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d3479f453a38b6a5572938d035fc2b3cb6ec379c57f598b8682b512eb90c7858\"\n+checksum = \"a257546cb264b250c7abdb81239bb02f18a274a966211755a3ea89411b122214\"\n dependencies = [\n  \"cfg-if 0.1.10\",\n  \"md-5\",\n@@ -3552,9 +3435,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_target\"\n-version = \"705.0.0\"\n+version = \"718.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"78cacaf829778cf07bb97a9f4604896789de12392175f3743e74a30ed370f1c1\"\n+checksum = \"b5a72dd689421bcb5750f3ed0dedf367076e714ef0ba56c02ed391b9a8582862\"\n dependencies = [\n  \"bitflags\",\n  \"rustc-ap-rustc_data_structures\",\n@@ -3585,9 +3468,10 @@ checksum = \"08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2\"\n name = \"rustc-main\"\n version = \"0.0.0\"\n dependencies = [\n- \"jemalloc-sys\",\n  \"rustc_codegen_ssa\",\n  \"rustc_driver\",\n+ \"tikv-jemalloc-sys\",\n+ \"tikv-jemallocator\",\n ]\n \n [[package]]\n@@ -3646,17 +3530,17 @@ name = \"rustc-workspace-hack\"\n version = \"1.0.0\"\n dependencies = [\n  \"byteorder\",\n- \"crossbeam-utils 0.7.2\",\n+ \"crossbeam-utils 0.8.3\",\n  \"libc\",\n  \"libz-sys\",\n  \"proc-macro2\",\n  \"quote\",\n+ \"rand_core 0.5.1\",\n  \"serde\",\n  \"serde_json\",\n- \"smallvec 0.6.14\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"syn\",\n- \"url 2.1.1\",\n+ \"url 2.2.2\",\n  \"winapi 0.3.9\",\n ]\n \n@@ -3665,15 +3549,15 @@ name = \"rustc_apfloat\"\n version = \"0.0.0\"\n dependencies = [\n  \"bitflags\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n ]\n \n [[package]]\n name = \"rustc_arena\"\n version = \"0.0.0\"\n dependencies = [\n  \"rustc_data_structures\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n ]\n \n [[package]]\n@@ -3687,7 +3571,7 @@ dependencies = [\n  \"rustc_macros\",\n  \"rustc_serialize\",\n  \"rustc_span\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tracing\",\n ]\n \n@@ -3705,7 +3589,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tracing\",\n ]\n \n@@ -3768,7 +3652,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tracing\",\n ]\n \n@@ -3797,7 +3681,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"snap\",\n  \"tracing\",\n ]\n@@ -3811,7 +3695,7 @@ dependencies = [\n  \"itertools 0.9.0\",\n  \"jobserver\",\n  \"libc\",\n- \"memmap2\",\n+ \"object\",\n  \"pathdiff\",\n  \"rustc_apfloat\",\n  \"rustc_ast\",\n@@ -3840,12 +3724,13 @@ dependencies = [\n  \"arrayvec\",\n  \"bitflags\",\n  \"cfg-if 0.1.10\",\n- \"crossbeam-utils 0.7.2\",\n+ \"crossbeam-utils 0.8.3\",\n  \"ena\",\n  \"indexmap\",\n  \"jobserver\",\n  \"libc\",\n  \"measureme\",\n+ \"memmap2\",\n  \"parking_lot\",\n  \"rustc-hash\",\n  \"rustc-rayon\",\n@@ -3854,7 +3739,7 @@ dependencies = [\n  \"rustc_index\",\n  \"rustc_macros\",\n  \"rustc_serialize\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"stable_deref_trait\",\n  \"stacker\",\n  \"tempfile\",\n@@ -3905,7 +3790,7 @@ version = \"0.0.0\"\n name = \"rustc_errors\"\n version = \"0.0.0\"\n dependencies = [\n- \"annotate-snippets 0.8.0\",\n+ \"annotate-snippets\",\n  \"atty\",\n  \"rustc_data_structures\",\n  \"rustc_lint_defs\",\n@@ -3937,7 +3822,7 @@ dependencies = [\n  \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tracing\",\n ]\n \n@@ -3969,7 +3854,7 @@ dependencies = [\n  \"rustc_serialize\",\n  \"rustc_span\",\n  \"rustc_target\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tracing\",\n ]\n \n@@ -4027,7 +3912,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tracing\",\n ]\n \n@@ -4071,7 +3956,7 @@ dependencies = [\n  \"rustc_traits\",\n  \"rustc_ty_utils\",\n  \"rustc_typeck\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tempfile\",\n  \"tracing\",\n  \"winapi 0.3.9\",\n@@ -4145,7 +4030,6 @@ name = \"rustc_metadata\"\n version = \"0.0.0\"\n dependencies = [\n  \"libc\",\n- \"memmap2\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n  \"rustc_data_structures\",\n@@ -4161,7 +4045,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"snap\",\n  \"stable_deref_trait\",\n  \"tracing\",\n@@ -4193,7 +4077,7 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"rustc_type_ir\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tracing\",\n ]\n \n@@ -4224,7 +4108,7 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"rustc_trait_selection\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tracing\",\n ]\n \n@@ -4247,7 +4131,7 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"rustc_trait_selection\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tracing\",\n ]\n \n@@ -4264,7 +4148,7 @@ dependencies = [\n  \"rustc_lexer\",\n  \"rustc_session\",\n  \"rustc_span\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tracing\",\n  \"unicode-normalization\",\n ]\n@@ -4365,7 +4249,7 @@ dependencies = [\n  \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tracing\",\n ]\n \n@@ -4389,7 +4273,7 @@ dependencies = [\n  \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tracing\",\n ]\n \n@@ -4418,7 +4302,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"indexmap\",\n  \"rustc_macros\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n ]\n \n [[package]]\n@@ -4515,7 +4399,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tracing\",\n ]\n \n@@ -4535,7 +4419,7 @@ dependencies = [\n  \"rustc_middle\",\n  \"rustc_span\",\n  \"rustc_trait_selection\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tracing\",\n ]\n \n@@ -4585,17 +4469,18 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"rustc_trait_selection\",\n- \"smallvec 1.6.1\",\n+ \"rustc_ty_utils\",\n+ \"smallvec\",\n  \"tracing\",\n ]\n \n [[package]]\n name = \"rustc_version\"\n-version = \"0.2.3\"\n+version = \"0.3.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a\"\n+checksum = \"f0dfe2087c51c460008730de8b57e6a320782fbfb312e1f4d520e6c6fae155ee\"\n dependencies = [\n- \"semver 0.9.0\",\n+ \"semver 0.11.0\",\n ]\n \n [[package]]\n@@ -4612,7 +4497,7 @@ dependencies = [\n  \"rustdoc-json-types\",\n  \"serde\",\n  \"serde_json\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"tempfile\",\n  \"tracing\",\n  \"tracing-subscriber\",\n@@ -4662,9 +4547,9 @@ dependencies = [\n \n [[package]]\n name = \"rustfmt-nightly\"\n-version = \"1.4.36\"\n+version = \"1.4.37\"\n dependencies = [\n- \"annotate-snippets 0.6.1\",\n+ \"annotate-snippets\",\n  \"anyhow\",\n  \"bytecount\",\n  \"cargo_metadata 0.8.2\",\n@@ -4678,15 +4563,6 @@ dependencies = [\n  \"lazy_static\",\n  \"log\",\n  \"regex\",\n- \"rustc-ap-rustc_ast\",\n- \"rustc-ap-rustc_ast_pretty\",\n- \"rustc-ap-rustc_attr\",\n- \"rustc-ap-rustc_data_structures\",\n- \"rustc-ap-rustc_errors\",\n- \"rustc-ap-rustc_expand\",\n- \"rustc-ap-rustc_parse\",\n- \"rustc-ap-rustc_session\",\n- \"rustc-ap-rustc_span\",\n  \"rustc-workspace-hack\",\n  \"rustfmt-config_proc_macro\",\n  \"serde\",\n@@ -4959,15 +4835,6 @@ version = \"0.4.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"c111b5bd5695e56cffe5129854aa230b39c93a305372fdbb2668ca2394eea9f8\"\n \n-[[package]]\n-name = \"smallvec\"\n-version = \"0.6.14\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b97fcaeba89edba30f044a10c6a3cc39df9c3f17d7cd829dd1446cab35f890e0\"\n-dependencies = [\n- \"maybe-uninit\",\n-]\n-\n [[package]]\n name = \"smallvec\"\n version = \"1.6.1\"\n@@ -4982,13 +4849,22 @@ checksum = \"da73c8f77aebc0e40c300b93f0a5f1bece7a248a36eee287d4e095f35c7b7d6e\"\n \n [[package]]\n name = \"socket2\"\n-version = \"0.3.16\"\n+version = \"0.3.19\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7fd8b795c389288baa5f355489c65e71fd48a02104600d15c4cfbc561e9e429d\"\n+checksum = \"122e570113d28d773067fab24266b66753f6ea915758651696b6e35e49f88d6e\"\n+dependencies = [\n+ \"cfg-if 1.0.0\",\n+ \"libc\",\n+ \"winapi 0.3.9\",\n+]\n+\n+[[package]]\n+name = \"socket2\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9e3dfc207c526015c632472a77be09cf1b6e46866581aecae5cc38fb4235dea2\"\n dependencies = [\n- \"cfg-if 0.1.10\",\n  \"libc\",\n- \"redox_syscall 0.1.57\",\n  \"winapi 0.3.9\",\n ]\n \n@@ -5032,10 +4908,22 @@ dependencies = [\n  \"profiler_builtins\",\n  \"rand 0.7.3\",\n  \"rustc-demangle\",\n+ \"std_detect\",\n  \"unwind\",\n  \"wasi\",\n ]\n \n+[[package]]\n+name = \"std_detect\"\n+version = \"0.1.5\"\n+dependencies = [\n+ \"cfg-if 0.1.10\",\n+ \"compiler_builtins\",\n+ \"libc\",\n+ \"rustc-std-workspace-alloc\",\n+ \"rustc-std-workspace-core\",\n+]\n+\n [[package]]\n name = \"string_cache\"\n version = \"0.8.0\"\n@@ -5143,26 +5031,25 @@ dependencies = [\n \n [[package]]\n name = \"tar\"\n-version = \"0.4.29\"\n+version = \"0.4.33\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c8a4c1d0bee3230179544336c15eefb563cf0302955d962e456542323e8c2e8a\"\n+checksum = \"c0bcfbd6a598361fda270d82469fff3d65089dc33e175c9a131f7b4cd395f228\"\n dependencies = [\n  \"filetime\",\n  \"libc\",\n- \"redox_syscall 0.1.57\",\n  \"xattr\",\n ]\n \n [[package]]\n name = \"tempfile\"\n-version = \"3.1.0\"\n+version = \"3.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7a6e24d9338a0a5be79593e2fa15a648add6138caa803e2d5bc782c371732ca9\"\n+checksum = \"dac1c663cfc93810f88aed9b8941d48cabf856a1b111c29a40439018d870eb22\"\n dependencies = [\n- \"cfg-if 0.1.10\",\n+ \"cfg-if 1.0.0\",\n  \"libc\",\n- \"rand 0.7.3\",\n- \"redox_syscall 0.1.57\",\n+ \"rand 0.8.3\",\n+ \"redox_syscall\",\n  \"remove_dir_all\",\n  \"winapi 0.3.9\",\n ]\n@@ -5241,17 +5128,6 @@ dependencies = [\n  \"term 0.0.0\",\n ]\n \n-[[package]]\n-name = \"tester\"\n-version = \"0.7.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ee72ec31009a42b53de9a6b7d8f462b493ab3b1e4767bda1fcdbb52127f13b6c\"\n-dependencies = [\n- \"getopts\",\n- \"libc\",\n- \"term 0.6.1\",\n-]\n-\n [[package]]\n name = \"tester\"\n version = \"0.9.0\"\n@@ -5308,6 +5184,7 @@ name = \"tidy\"\n version = \"0.1.0\"\n dependencies = [\n  \"cargo_metadata 0.11.1\",\n+ \"crossbeam-utils 0.8.3\",\n  \"lazy_static\",\n  \"regex\",\n  \"walkdir\",\n@@ -5317,6 +5194,27 @@ dependencies = [\n name = \"tier-check\"\n version = \"0.1.0\"\n \n+[[package]]\n+name = \"tikv-jemalloc-sys\"\n+version = \"0.4.1+5.2.1-patched\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8a26331b05179d4cb505c8d6814a7e18d298972f0a551b0e3cefccff927f86d3\"\n+dependencies = [\n+ \"cc\",\n+ \"fs_extra\",\n+ \"libc\",\n+]\n+\n+[[package]]\n+name = \"tikv-jemallocator\"\n+version = \"0.4.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3c14a5a604eb8715bc5785018a37d00739b180bcf609916ddf4393d33d49ccdf\"\n+dependencies = [\n+ \"libc\",\n+ \"tikv-jemalloc-sys\",\n+]\n+\n [[package]]\n name = \"time\"\n version = \"0.1.43\"\n@@ -5464,7 +5362,7 @@ dependencies = [\n  \"serde\",\n  \"serde_json\",\n  \"sharded-slab\",\n- \"smallvec 1.6.1\",\n+ \"smallvec\",\n  \"thread_local\",\n  \"tracing\",\n  \"tracing-core\",\n@@ -5628,10 +5526,11 @@ dependencies = [\n \n [[package]]\n name = \"url\"\n-version = \"2.1.1\"\n+version = \"2.2.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"829d4a8476c35c9bf0bbce5a3b23f4106f79728039b726d292bb93bc106787cb\"\n+checksum = \"a507c383b2d33b5fc35d1861e77e6b383d158b2da5e14fe51b83dfedf6fd578c\"\n dependencies = [\n+ \"form_urlencoded\",\n  \"idna 0.2.0\",\n  \"matches\",\n  \"percent-encoding 2.1.0\",\n@@ -5664,19 +5563,24 @@ checksum = \"f1bddf1187be692e79c5ffeab891132dfb0f236ed36a43c7ed39f1165ee20191\"\n \n [[package]]\n name = \"vergen\"\n-version = \"3.1.0\"\n+version = \"5.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4ce50d8996df1f85af15f2cd8d33daae6e479575123ef4314a51a70a230739cb\"\n+checksum = \"dfbc87f9a7a9d61b15d51d1d3547284f67b6b4f1494ce3fc5814c101f35a5183\"\n dependencies = [\n- \"bitflags\",\n+ \"anyhow\",\n  \"chrono\",\n+ \"enum-iterator\",\n+ \"getset\",\n+ \"git2\",\n+ \"rustversion\",\n+ \"thiserror\",\n ]\n \n [[package]]\n name = \"version_check\"\n-version = \"0.9.1\"\n+version = \"0.9.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"078775d0255232fb988e6fccf26ddc9d1ac274299aaedcedce21c6f72cc533ce\"\n+checksum = \"5fecdca9a5291cc2b8dcf7dc02453fee791a280f3743cb0905f8822ae463b3fe\"\n \n [[package]]\n name = \"vte\"\n@@ -5817,3 +5721,12 @@ checksum = \"39f0c922f1a334134dc2f7a8b67dc5d25f0735263feec974345ff706bcf20b0d\"\n dependencies = [\n  \"linked-hash-map\",\n ]\n+\n+[[package]]\n+name = \"yansi-term\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"fe5c30ade05e61656247b2e334a031dfd0cc466fadef865bdcdea8d537951bf1\"\n+dependencies = [\n+ \"winapi 0.3.9\",\n+]"}, {"sha": "327afe35c2fb96b9107bbf5836c6d6e5ee8b8d44", "filename": "Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -7,6 +7,7 @@ members = [\n   \"src/rustdoc-json-types\",\n   \"src/tools/cargotest\",\n   \"src/tools/clippy\",\n+  \"src/tools/clippy/clippy_dev\",\n   \"src/tools/compiletest\",\n   \"src/tools/error_index_generator\",\n   \"src/tools/linkchecker\",\n@@ -45,6 +46,8 @@ exclude = [\n   # not all `Cargo.toml` files are available, so we exclude the `x` binary,\n   # so it can be invoked before the current checkout is set up.\n   \"src/tools/x\",\n+  # stdarch has its own Cargo workspace\n+  \"library/stdarch\",\n ]\n \n [profile.release.package.compiler_builtins]\n@@ -88,6 +91,7 @@ object.debug = 0\n # vendored copy.\n [patch.\"https://github.com/rust-lang/cargo\"]\n cargo = { path = \"src/tools/cargo\" }\n+cargo-util = { path = \"src/tools/cargo/crates/cargo-util\" }\n \n [patch.\"https://github.com/rust-lang/rustfmt\"]\n # Similar to Cargo above we want the RLS to use a vendored version of `rustfmt`"}, {"sha": "af6a4090a27cb58c85b1ddd2adb6accdea2efa80", "filename": "README.md", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -19,8 +19,28 @@ Read [\"Installation\"] from [The Book].\n ## Installing from Source\n \n The Rust build system uses a Python script called `x.py` to build the compiler,\n-which manages the bootstrapping process. More information about it can be found\n-by running `./x.py --help` or reading the [rustc dev guide][rustcguidebuild].\n+which manages the bootstrapping process. It lives in the root of the project.\n+\n+The `x.py` command can be run directly on most systems in the following format: \n+\n+```sh\n+./x.py <subcommand> [flags]\n+```\n+\n+This is how the documentation and examples assume you are running `x.py`.\n+\n+Systems such as Ubuntu 20.04 LTS do not create the necessary `python` command by default when Python is installed that allows `x.py` to be run directly. In that case you can either create a symlink for `python` (Ubuntu provides the `python-is-python3` package for this), or run `x.py` using Python itself:\n+\n+```sh\n+# Python 3\n+python3 x.py <subcommand> [flags]\n+\n+# Python 2.7\n+python2.7 x.py <subcommand> [flags]\n+```\n+\n+More information about `x.py` can be found\n+by running it with the `--help` flag or reading the [rustc dev guide][rustcguidebuild].\n \n [gettingstarted]: https://rustc-dev-guide.rust-lang.org/getting-started.html\n [rustcguidebuild]: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html"}, {"sha": "60b3359c1b68ab519664e78c38cfc539a2336192", "filename": "RELEASES.md", "status": "modified", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -1,3 +1,172 @@\n+Version 1.52.1 (2021-05-10)\n+============================\n+\n+This release disables incremental compilation, unless the user has explicitly\n+opted in via the newly added RUSTC_FORCE_INCREMENTAL=1 environment variable.\n+\n+This is due to the widespread, and frequently occuring, breakage encountered by\n+Rust users due to newly enabled incremental verification in 1.52.0. Notably,\n+Rust users **should** upgrade to 1.52.0 or 1.52.1: the bugs that are detected by\n+newly added incremental verification are still present in past stable versions,\n+and are not yet fixed on any channel. These bugs can lead to miscompilation of\n+Rust binaries.\n+\n+These problems only affect incremental builds, so release builds with Cargo\n+should not be affected unless the user has explicitly opted into incremental.\n+Debug and check builds are affected.\n+\n+See [84970] for more details.\n+\n+[84970]: https://github.com/rust-lang/rust/issues/84970\n+\n+Version 1.52.0 (2021-05-06)\n+============================\n+\n+Language\n+--------\n+- [Added the `unsafe_op_in_unsafe_fn` lint, which checks whether the unsafe code\n+  in an `unsafe fn` is wrapped in a `unsafe` block.][79208] This lint\n+  is allowed by default, and may become a warning or hard error in a\n+  future edition.\n+- [You can now cast mutable references to arrays to a pointer of the same type as\n+  the element.][81479]\n+\n+Compiler\n+--------\n+- [Upgraded the default LLVM to LLVM 12.][81451]\n+\n+Added tier 3\\* support for the following targets.\n+\n+- [`s390x-unknown-linux-musl`][82166]\n+- [`riscv32gc-unknown-linux-musl` & `riscv64gc-unknown-linux-musl`][82202]\n+- [`powerpc-unknown-openbsd`][82733]\n+\n+\\* Refer to Rust's [platform support page][platform-support-doc] for more\n+information on Rust's tiered platform support.\n+\n+Libraries\n+---------\n+- [`OsString` now implements `Extend` and `FromIterator`.][82121]\n+- [`cmp::Reverse` now has `#[repr(transparent)]` representation.][81879]\n+- [`Arc<impl Error>` now implements `error::Error`.][80553]\n+- [All integer division and remainder operations are now `const`.][80962]\n+\n+Stabilised APIs\n+-------------\n+- [`Arguments::as_str`]\n+- [`char::MAX`]\n+- [`char::REPLACEMENT_CHARACTER`]\n+- [`char::UNICODE_VERSION`]\n+- [`char::decode_utf16`]\n+- [`char::from_digit`]\n+- [`char::from_u32_unchecked`]\n+- [`char::from_u32`]\n+- [`slice::partition_point`]\n+- [`str::rsplit_once`]\n+- [`str::split_once`]\n+\n+The following previously stable APIs are now `const`.\n+\n+- [`char::len_utf8`]\n+- [`char::len_utf16`]\n+- [`char::to_ascii_uppercase`]\n+- [`char::to_ascii_lowercase`]\n+- [`char::eq_ignore_ascii_case`]\n+- [`u8::to_ascii_uppercase`]\n+- [`u8::to_ascii_lowercase`]\n+- [`u8::eq_ignore_ascii_case`]\n+\n+Rustdoc\n+-------\n+- [Rustdoc lints are now treated as a tool lint, meaning that\n+  lints are now prefixed with `rustdoc::` (e.g. `#[warn(rustdoc::broken_intra_doc_links)]`).][80527]\n+  Using the old style is still allowed, and will become a warning in\n+  a future release.\n+- [Rustdoc now supports argument files.][82261]\n+- [Rustdoc now generates smart punctuation for documentation.][79423]\n+- [You can now use \"task lists\" in Rustdoc Markdown.][81766] E.g.\n+  ```markdown\n+  - [x] Complete\n+  - [ ] Todo\n+  ```\n+\n+Misc\n+----\n+- [You can now pass multiple filters to tests.][81356] E.g.\n+  `cargo test -- foo bar` will run all tests that match `foo` and `bar`.\n+- [Rustup now distributes PDB symbols for the `std` library on Windows,\n+  allowing you to see `std` symbols when debugging.][82218]\n+\n+Internal Only\n+-------------\n+These changes provide no direct user facing benefits, but represent significant\n+improvements to the internals and overall performance of rustc and\n+related tools.\n+\n+- [Check the result cache before the DepGraph when ensuring queries][81855]\n+- [Try fast_reject::simplify_type in coherence before doing full check][81744]\n+- [Only store a LocalDefId in some HIR nodes][81611]\n+- [Store HIR attributes in a side table][79519]\n+\n+Compatibility Notes\n+-------------------\n+- [Cargo build scripts are now forbidden from setting `RUSTC_BOOTSTRAP`.][cargo/9181]\n+- [Removed support for the `x86_64-rumprun-netbsd` target.][82594]\n+- [Deprecated the `x86_64-sun-solaris` target in favor of `x86_64-pc-solaris`.][82216]\n+- [Rustdoc now only accepts `,`, ` `, and `\\t` as delimiters for specifying\n+  languages in code blocks.][78429]\n+- [Rustc now catches more cases of `pub_use_of_private_extern_crate`][80763]\n+- [Changes in how proc macros handle whitespace may lead to panics when used\n+  with older `proc-macro-hack` versions. A `cargo update` should be sufficient to fix this in all cases.][84136]\n+\n+[84136]: https://github.com/rust-lang/rust/issues/84136\n+[80763]: https://github.com/rust-lang/rust/pull/80763\n+[82166]: https://github.com/rust-lang/rust/pull/82166\n+[82121]: https://github.com/rust-lang/rust/pull/82121\n+[81879]: https://github.com/rust-lang/rust/pull/81879\n+[82261]: https://github.com/rust-lang/rust/pull/82261\n+[82218]: https://github.com/rust-lang/rust/pull/82218\n+[82216]: https://github.com/rust-lang/rust/pull/82216\n+[82202]: https://github.com/rust-lang/rust/pull/82202\n+[81855]: https://github.com/rust-lang/rust/pull/81855\n+[81766]: https://github.com/rust-lang/rust/pull/81766\n+[81744]: https://github.com/rust-lang/rust/pull/81744\n+[81611]: https://github.com/rust-lang/rust/pull/81611\n+[81479]: https://github.com/rust-lang/rust/pull/81479\n+[81451]: https://github.com/rust-lang/rust/pull/81451\n+[81356]: https://github.com/rust-lang/rust/pull/81356\n+[80962]: https://github.com/rust-lang/rust/pull/80962\n+[80553]: https://github.com/rust-lang/rust/pull/80553\n+[80527]: https://github.com/rust-lang/rust/pull/80527\n+[79519]: https://github.com/rust-lang/rust/pull/79519\n+[79423]: https://github.com/rust-lang/rust/pull/79423\n+[79208]: https://github.com/rust-lang/rust/pull/79208\n+[78429]: https://github.com/rust-lang/rust/pull/78429\n+[82733]: https://github.com/rust-lang/rust/pull/82733\n+[82594]: https://github.com/rust-lang/rust/pull/82594\n+[cargo/9181]: https://github.com/rust-lang/cargo/pull/9181\n+[`char::MAX`]: https://doc.rust-lang.org/std/primitive.char.html#associatedconstant.MAX\n+[`char::REPLACEMENT_CHARACTER`]: https://doc.rust-lang.org/std/primitive.char.html#associatedconstant.REPLACEMENT_CHARACTER\n+[`char::UNICODE_VERSION`]: https://doc.rust-lang.org/std/primitive.char.html#associatedconstant.UNICODE_VERSION\n+[`char::decode_utf16`]: https://doc.rust-lang.org/std/primitive.char.html#method.decode_utf16\n+[`char::from_u32`]: https://doc.rust-lang.org/std/primitive.char.html#method.from_u32\n+[`char::from_u32_unchecked`]: https://doc.rust-lang.org/std/primitive.char.html#method.from_u32_unchecked\n+[`char::from_digit`]: https://doc.rust-lang.org/std/primitive.char.html#method.from_digit\n+[`Peekable::next_if`]: https://doc.rust-lang.org/stable/std/iter/struct.Peekable.html#method.next_if\n+[`Peekable::next_if_eq`]: https://doc.rust-lang.org/stable/std/iter/struct.Peekable.html#method.next_if_eq\n+[`Arguments::as_str`]: https://doc.rust-lang.org/stable/std/fmt/struct.Arguments.html#method.as_str\n+[`str::split_once`]: https://doc.rust-lang.org/stable/std/primitive.str.html#method.split_once\n+[`str::rsplit_once`]: https://doc.rust-lang.org/stable/std/primitive.str.html#method.rsplit_once\n+[`slice::partition_point`]: https://doc.rust-lang.org/stable/std/primitive.slice.html#method.partition_point\n+[`char::len_utf8`]: https://doc.rust-lang.org/stable/std/primitive.char.html#method.len_utf8\n+[`char::len_utf16`]: https://doc.rust-lang.org/stable/std/primitive.char.html#method.len_utf16\n+[`char::to_ascii_uppercase`]: https://doc.rust-lang.org/stable/std/primitive.char.html#method.to_ascii_uppercase\n+[`char::to_ascii_lowercase`]: https://doc.rust-lang.org/stable/std/primitive.char.html#method.to_ascii_lowercase\n+[`char::eq_ignore_ascii_case`]: https://doc.rust-lang.org/stable/std/primitive.char.html#method.eq_ignore_ascii_case\n+[`u8::to_ascii_uppercase`]: https://doc.rust-lang.org/stable/std/primitive.u8.html#method.to_ascii_uppercase\n+[`u8::to_ascii_lowercase`]: https://doc.rust-lang.org/stable/std/primitive.u8.html#method.to_ascii_lowercase\n+[`u8::eq_ignore_ascii_case`]: https://doc.rust-lang.org/stable/std/primitive.u8.html#method.eq_ignore_ascii_case\n+\n Version 1.51.0 (2021-03-25)\n ============================\n \n@@ -50,6 +219,8 @@ Libraries\n - [`io::Empty` now implements `io::Seek`.][78044]\n - [`rc::Weak<T>` and `sync::Weak<T>`'s methods such as `as_ptr` are now implemented for\n   `T: ?Sized` types.][80764]\n+- [`Div` and `Rem` by their `NonZero` variant is now implemented for all unsigned integers.][79134]\n+\n \n Stabilized APIs\n ---------------\n@@ -72,6 +243,8 @@ Stabilized APIs\n - [`str::split_inclusive`]\n - [`sync::OnceState`]\n - [`task::Wake`]\n+- [`VecDeque::range`]\n+- [`VecDeque::range_mut`]\n \n Cargo\n -----\n@@ -115,6 +288,7 @@ Compatibility Notes\n     - `thumbv7neon-unknown-linux-gnueabihf`\n     - `armv7-unknown-linux-gnueabi`\n     - `x86_64-unknown-linux-gnux32`\n+- [`atomic::spin_loop_hint` has been deprecated.][80966] It's recommended to use `hint::spin_loop` instead.\n \n Internal Only\n -------------\n@@ -145,6 +319,8 @@ Internal Only\n [80764]: https://github.com/rust-lang/rust/pull/80764\n [80749]: https://github.com/rust-lang/rust/pull/80749\n [80662]: https://github.com/rust-lang/rust/pull/80662\n+[79134]: https://github.com/rust-lang/rust/pull/79134\n+[80966]: https://github.com/rust-lang/rust/pull/80966\n [cargo/8997]: https://github.com/rust-lang/cargo/pull/8997\n [cargo/9112]: https://github.com/rust-lang/cargo/pull/9112\n [feature-resolver@2.0]: https://doc.rust-lang.org/nightly/cargo/reference/features.html#feature-resolver-version-2\n@@ -166,6 +342,8 @@ Internal Only\n [`Seek::stream_position`]: https://doc.rust-lang.org/nightly/std/io/trait.Seek.html#method.stream_position\n [`Peekable::next_if`]: https://doc.rust-lang.org/nightly/std/iter/struct.Peekable.html#method.next_if\n [`Peekable::next_if_eq`]: https://doc.rust-lang.org/nightly/std/iter/struct.Peekable.html#method.next_if_eq\n+[`VecDeque::range`]: https://doc.rust-lang.org/nightly/std/collections/struct.VecDeque.html#method.range\n+[`VecDeque::range_mut`]: https://doc.rust-lang.org/nightly/std/collections/struct.VecDeque.html#method.range_mut\n \n Version 1.50.0 (2021-02-11)\n ============================\n@@ -1906,6 +2084,11 @@ Cargo\n - [You can now pass the `--features` option multiple times to enable\n   multiple features.][cargo/7084]\n \n+Rustdoc\n+-------\n+\n+- [Documentation on `pub use` statements is prepended to the documentation of the re-exported item][63048]\n+\n Misc\n ----\n - [`rustc` will now warn about some incorrect uses of\n@@ -1940,6 +2123,7 @@ Compatibility Notes\n [63421]: https://github.com/rust-lang/rust/pull/63421/\n [cargo/7084]: https://github.com/rust-lang/cargo/pull/7084/\n [cargo/7143]: https://github.com/rust-lang/cargo/pull/7143/\n+[63048]: https://github.com/rust-lang/rust/pull/63048\n [`<*const T>::cast`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.cast\n [`<*mut T>::cast`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.cast\n [`Duration::as_secs_f32`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.as_secs_f32"}, {"sha": "ca6055c46a6473e846dfd2c85e4b808c6ced8ddc", "filename": "compiler/rustc/Cargo.toml", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc%2FCargo.toml?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -11,12 +11,16 @@ rustc_driver = { path = \"../rustc_driver\" }\n # crate is intended to be used by codegen backends, which may not be in-tree.\n rustc_codegen_ssa = { path = \"../rustc_codegen_ssa\" }\n \n-[dependencies.jemalloc-sys]\n-version = '0.3.0'\n+[dependencies.tikv-jemalloc-sys]\n+version = '0.4.0'\n optional = true\n features = ['unprefixed_malloc_on_supported_platforms']\n \n+[dependencies.tikv-jemallocator]\n+version = '0.4.0'\n+optional = true\n+\n [features]\n-jemalloc = ['jemalloc-sys']\n+jemalloc = ['tikv-jemalloc-sys', 'tikv-jemallocator']\n llvm = ['rustc_driver/llvm']\n max_level_info = ['rustc_driver/max_level_info']"}, {"sha": "c80fab99496bc0d250ab4065b0eea235e9bbb142", "filename": "compiler/rustc/src/main.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc%2Fsrc%2Fmain.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -1,3 +1,16 @@\n+// Configure jemalloc as the `global_allocator` when configured. This is\n+// so that we use the sized deallocation apis jemalloc provides\n+// (namely `sdallocx`).\n+//\n+// The symbol overrides documented below are also performed so that we can\n+// ensure that we use a consistent allocator across the rustc <-> llvm boundary\n+#[cfg(feature = \"jemalloc\")]\n+#[global_allocator]\n+static ALLOC: tikv_jemallocator::Jemalloc = tikv_jemallocator::Jemalloc;\n+\n+#[cfg(feature = \"tikv-jemalloc-sys\")]\n+use tikv_jemalloc_sys as jemalloc_sys;\n+\n fn main() {\n     // Pull in jemalloc when enabled.\n     //\n@@ -7,7 +20,7 @@ fn main() {\n     // dynamic libraries. That means to pull in jemalloc we actually need to\n     // reference allocation symbols one way or another (as this file is the only\n     // object code in the rustc executable).\n-    #[cfg(feature = \"jemalloc-sys\")]\n+    #[cfg(feature = \"tikv-jemalloc-sys\")]\n     {\n         use std::os::raw::{c_int, c_void};\n "}, {"sha": "7eeec4aa86bc16e3e54859bc6cb12f5e12da27f7", "filename": "compiler/rustc_apfloat/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_apfloat%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_apfloat%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_apfloat%2Fsrc%2Flib.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -35,7 +35,6 @@\n #![forbid(unsafe_code)]\n #![feature(iter_zip)]\n #![feature(nll)]\n-#![cfg_attr(bootstrap, feature(or_patterns))]\n \n #[macro_use]\n extern crate alloc;"}, {"sha": "c3e4945c4464cfadf866398839075ea2d82b5811", "filename": "compiler/rustc_arena/src/lib.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Flib.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -236,26 +236,6 @@ impl<T> TypedArena<T> {\n         start_ptr\n     }\n \n-    /// Allocates a slice of objects that are copied into the `TypedArena`, returning a mutable\n-    /// reference to it. Will panic if passed a zero-sized types.\n-    ///\n-    /// Panics:\n-    ///\n-    ///  - Zero-sized types\n-    ///  - Zero-length slices\n-    #[inline]\n-    pub fn alloc_slice(&self, slice: &[T]) -> &mut [T]\n-    where\n-        T: Copy,\n-    {\n-        unsafe {\n-            let len = slice.len();\n-            let start_ptr = self.alloc_raw_slice(len);\n-            slice.as_ptr().copy_to_nonoverlapping(start_ptr, len);\n-            slice::from_raw_parts_mut(start_ptr, len)\n-        }\n-    }\n-\n     #[inline]\n     pub fn alloc_from_iter<I: IntoIterator<Item = T>>(&self, iter: I) -> &mut [T] {\n         assert!(mem::size_of::<T>() != 0);"}, {"sha": "b3bac1d7ecdefd1525320faa61b892de9c572c30", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 9, "deletions": 76, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -100,6 +100,7 @@ pub struct Path {\n }\n \n impl PartialEq<Symbol> for Path {\n+    #[inline]\n     fn eq(&self, symbol: &Symbol) -> bool {\n         self.segments.len() == 1 && { self.segments[0].ident.name == *symbol }\n     }\n@@ -277,7 +278,7 @@ impl ParenthesizedArgs {\n             .cloned()\n             .map(|input| AngleBracketedArg::Arg(GenericArg::Type(input)))\n             .collect();\n-        AngleBracketedArgs { span: self.span, args }\n+        AngleBracketedArgs { span: self.inputs_span, args }\n     }\n }\n \n@@ -762,14 +763,6 @@ pub enum Mutability {\n }\n \n impl Mutability {\n-    /// Returns `MutMutable` only if both `self` and `other` are mutable.\n-    pub fn and(self, other: Self) -> Self {\n-        match self {\n-            Mutability::Mut => other,\n-            Mutability::Not => Mutability::Not,\n-        }\n-    }\n-\n     pub fn invert(self) -> Self {\n         match self {\n             Mutability::Mut => Mutability::Not,\n@@ -1353,7 +1346,7 @@ pub enum ExprKind {\n     Field(P<Expr>, Ident),\n     /// An indexing operation (e.g., `foo[2]`).\n     Index(P<Expr>, P<Expr>),\n-    /// A range (e.g., `1..2`, `1..`, `..2`, `1..=2`, `..=2`; and `..` in destructuring assingment).\n+    /// A range (e.g., `1..2`, `1..`, `..2`, `1..=2`, `..=2`; and `..` in destructuring assignment).\n     Range(Option<P<Expr>>, Option<P<Expr>>, RangeLimits),\n     /// An underscore, used in destructuring assignment to ignore a value.\n     Underscore,\n@@ -1722,13 +1715,6 @@ impl FloatTy {\n             FloatTy::F64 => sym::f64,\n         }\n     }\n-\n-    pub fn bit_width(self) -> u64 {\n-        match self {\n-            FloatTy::F32 => 32,\n-            FloatTy::F64 => 64,\n-        }\n-    }\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n@@ -1764,29 +1750,6 @@ impl IntTy {\n             IntTy::I128 => sym::i128,\n         }\n     }\n-\n-    pub fn bit_width(&self) -> Option<u64> {\n-        Some(match *self {\n-            IntTy::Isize => return None,\n-            IntTy::I8 => 8,\n-            IntTy::I16 => 16,\n-            IntTy::I32 => 32,\n-            IntTy::I64 => 64,\n-            IntTy::I128 => 128,\n-        })\n-    }\n-\n-    pub fn normalize(&self, target_width: u32) -> Self {\n-        match self {\n-            IntTy::Isize => match target_width {\n-                16 => IntTy::I16,\n-                32 => IntTy::I32,\n-                64 => IntTy::I64,\n-                _ => unreachable!(),\n-            },\n-            _ => *self,\n-        }\n-    }\n }\n \n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Copy, Debug)]\n@@ -1822,29 +1785,6 @@ impl UintTy {\n             UintTy::U128 => sym::u128,\n         }\n     }\n-\n-    pub fn bit_width(&self) -> Option<u64> {\n-        Some(match *self {\n-            UintTy::Usize => return None,\n-            UintTy::U8 => 8,\n-            UintTy::U16 => 16,\n-            UintTy::U32 => 32,\n-            UintTy::U64 => 64,\n-            UintTy::U128 => 128,\n-        })\n-    }\n-\n-    pub fn normalize(&self, target_width: u32) -> Self {\n-        match self {\n-            UintTy::Usize => match target_width {\n-                16 => UintTy::U16,\n-                32 => UintTy::U32,\n-                64 => UintTy::U64,\n-                _ => unreachable!(),\n-            },\n-            _ => *self,\n-        }\n-    }\n }\n \n /// A constraint on an associated type (e.g., `A = Bar` in `Foo<A = Bar>` or\n@@ -1921,6 +1861,10 @@ pub enum TyKind {\n     Never,\n     /// A tuple (`(A, B, C, D,...)`).\n     Tup(Vec<P<Ty>>),\n+    /// An anonymous struct type i.e. `struct { foo: Type }`\n+    AnonymousStruct(Vec<FieldDef>, bool),\n+    /// An anonymous union type i.e. `union { bar: Type }`\n+    AnonymousUnion(Vec<FieldDef>, bool),\n     /// A path (`module::module::...::Type`), optionally\n     /// \"qualified\", e.g., `<Vec<T> as SomeTrait>::SomeType`.\n     ///\n@@ -2059,7 +2003,7 @@ pub enum InlineAsmOperand {\n         out_expr: Option<P<Expr>>,\n     },\n     Const {\n-        expr: P<Expr>,\n+        anon_const: AnonConst,\n     },\n     Sym {\n         expr: P<Expr>,\n@@ -2215,9 +2159,6 @@ pub struct FnDecl {\n }\n \n impl FnDecl {\n-    pub fn get_self(&self) -> Option<ExplicitSelf> {\n-        self.inputs.get(0).and_then(Param::to_self)\n-    }\n     pub fn has_self(&self) -> bool {\n         self.inputs.get(0).map_or(false, Param::is_self)\n     }\n@@ -2342,14 +2283,6 @@ pub struct ForeignMod {\n     pub items: Vec<P<ForeignItem>>,\n }\n \n-/// Global inline assembly.\n-///\n-/// Also known as \"module-level assembly\" or \"file-scoped assembly\".\n-#[derive(Clone, Encodable, Decodable, Debug, Copy)]\n-pub struct GlobalAsm {\n-    pub asm: Symbol,\n-}\n-\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct EnumDef {\n     pub variants: Vec<Variant>,\n@@ -2732,7 +2665,7 @@ pub enum ItemKind {\n     /// E.g., `extern {}` or `extern \"C\" {}`.\n     ForeignMod(ForeignMod),\n     /// Module-level inline assembly (from `global_asm!()`).\n-    GlobalAsm(GlobalAsm),\n+    GlobalAsm(InlineAsm),\n     /// A type alias (`type`).\n     ///\n     /// E.g., `type Foo = Bar<u8>;`."}, {"sha": "945a44ab66371ccbae0b8e3cec39975ae5168396", "filename": "compiler/rustc_ast/src/ast_like.rs", "status": "modified", "additions": 95, "deletions": 7, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -1,20 +1,32 @@\n use super::ptr::P;\n+use super::token::Nonterminal;\n use super::tokenstream::LazyTokenStream;\n use super::{Arm, ExprField, FieldDef, GenericParam, Param, PatField, Variant};\n-use super::{AssocItem, Expr, ForeignItem, Item, Local};\n+use super::{AssocItem, Expr, ForeignItem, Item, Local, MacCallStmt};\n use super::{AttrItem, AttrKind, Block, Pat, Path, Ty, Visibility};\n use super::{AttrVec, Attribute, Stmt, StmtKind};\n \n+use std::fmt::Debug;\n+\n /// An `AstLike` represents an AST node (or some wrapper around\n /// and AST node) which stores some combination of attributes\n /// and tokens.\n-pub trait AstLike: Sized {\n+pub trait AstLike: Sized + Debug {\n+    /// This is `true` if this `AstLike` might support 'custom' (proc-macro) inner\n+    /// attributes. Attributes like `#![cfg]` and `#![cfg_attr]` are not\n+    /// considered 'custom' attributes\n+    ///\n+    /// If this is `false`, then this `AstLike` definitely does\n+    /// not support 'custom' inner attributes, which enables some optimizations\n+    /// during token collection.\n+    const SUPPORTS_CUSTOM_INNER_ATTRS: bool;\n     fn attrs(&self) -> &[Attribute];\n     fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>));\n     fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>>;\n }\n \n impl<T: AstLike + 'static> AstLike for P<T> {\n+    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = T::SUPPORTS_CUSTOM_INNER_ATTRS;\n     fn attrs(&self) -> &[Attribute] {\n         (**self).attrs()\n     }\n@@ -26,6 +38,55 @@ impl<T: AstLike + 'static> AstLike for P<T> {\n     }\n }\n \n+impl AstLike for crate::token::Nonterminal {\n+    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = true;\n+    fn attrs(&self) -> &[Attribute] {\n+        match self {\n+            Nonterminal::NtItem(item) => item.attrs(),\n+            Nonterminal::NtStmt(stmt) => stmt.attrs(),\n+            Nonterminal::NtExpr(expr) | Nonterminal::NtLiteral(expr) => expr.attrs(),\n+            Nonterminal::NtPat(_)\n+            | Nonterminal::NtTy(_)\n+            | Nonterminal::NtMeta(_)\n+            | Nonterminal::NtPath(_)\n+            | Nonterminal::NtVis(_)\n+            | Nonterminal::NtTT(_)\n+            | Nonterminal::NtBlock(_)\n+            | Nonterminal::NtIdent(..)\n+            | Nonterminal::NtLifetime(_) => &[],\n+        }\n+    }\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+        match self {\n+            Nonterminal::NtItem(item) => item.visit_attrs(f),\n+            Nonterminal::NtStmt(stmt) => stmt.visit_attrs(f),\n+            Nonterminal::NtExpr(expr) | Nonterminal::NtLiteral(expr) => expr.visit_attrs(f),\n+            Nonterminal::NtPat(_)\n+            | Nonterminal::NtTy(_)\n+            | Nonterminal::NtMeta(_)\n+            | Nonterminal::NtPath(_)\n+            | Nonterminal::NtVis(_)\n+            | Nonterminal::NtTT(_)\n+            | Nonterminal::NtBlock(_)\n+            | Nonterminal::NtIdent(..)\n+            | Nonterminal::NtLifetime(_) => {}\n+        }\n+    }\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+        match self {\n+            Nonterminal::NtItem(item) => item.tokens_mut(),\n+            Nonterminal::NtStmt(stmt) => stmt.tokens_mut(),\n+            Nonterminal::NtExpr(expr) | Nonterminal::NtLiteral(expr) => expr.tokens_mut(),\n+            Nonterminal::NtPat(pat) => pat.tokens_mut(),\n+            Nonterminal::NtTy(ty) => ty.tokens_mut(),\n+            Nonterminal::NtMeta(attr_item) => attr_item.tokens_mut(),\n+            Nonterminal::NtPath(path) => path.tokens_mut(),\n+            Nonterminal::NtVis(vis) => vis.tokens_mut(),\n+            _ => panic!(\"Called tokens_mut on {:?}\", self),\n+        }\n+    }\n+}\n+\n fn visit_attrvec(attrs: &mut AttrVec, f: impl FnOnce(&mut Vec<Attribute>)) {\n     crate::mut_visit::visit_clobber(attrs, |attrs| {\n         let mut vec = attrs.into();\n@@ -35,6 +96,10 @@ fn visit_attrvec(attrs: &mut AttrVec, f: impl FnOnce(&mut Vec<Attribute>)) {\n }\n \n impl AstLike for StmtKind {\n+    // This might be an `StmtKind::Item`, which contains\n+    // an item that supports inner attrs\n+    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = true;\n+\n     fn attrs(&self) -> &[Attribute] {\n         match self {\n             StmtKind::Local(local) => local.attrs(),\n@@ -66,6 +131,8 @@ impl AstLike for StmtKind {\n }\n \n impl AstLike for Stmt {\n+    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = StmtKind::SUPPORTS_CUSTOM_INNER_ATTRS;\n+\n     fn attrs(&self) -> &[Attribute] {\n         self.kind.attrs()\n     }\n@@ -79,6 +146,8 @@ impl AstLike for Stmt {\n }\n \n impl AstLike for Attribute {\n+    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = false;\n+\n     fn attrs(&self) -> &[Attribute] {\n         &[]\n     }\n@@ -94,6 +163,8 @@ impl AstLike for Attribute {\n }\n \n impl<T: AstLike> AstLike for Option<T> {\n+    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = T::SUPPORTS_CUSTOM_INNER_ATTRS;\n+\n     fn attrs(&self) -> &[Attribute] {\n         self.as_ref().map(|inner| inner.attrs()).unwrap_or(&[])\n     }\n@@ -127,8 +198,13 @@ impl VecOrAttrVec for AttrVec {\n }\n \n macro_rules! derive_has_tokens_and_attrs {\n-    ($($ty:path),*) => { $(\n+    (\n+        const SUPPORTS_CUSTOM_INNER_ATTRS: bool = $inner_attrs:literal;\n+        $($ty:path),*\n+    ) => { $(\n         impl AstLike for $ty {\n+            const SUPPORTS_CUSTOM_INNER_ATTRS: bool = $inner_attrs;\n+\n             fn attrs(&self) -> &[Attribute] {\n                 &self.attrs\n             }\n@@ -140,13 +216,16 @@ macro_rules! derive_has_tokens_and_attrs {\n             fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n                 Some(&mut self.tokens)\n             }\n+\n         }\n     )* }\n }\n \n macro_rules! derive_has_attrs_no_tokens {\n     ($($ty:path),*) => { $(\n         impl AstLike for $ty {\n+            const SUPPORTS_CUSTOM_INNER_ATTRS: bool = false;\n+\n             fn attrs(&self) -> &[Attribute] {\n                 &self.attrs\n             }\n@@ -165,23 +244,32 @@ macro_rules! derive_has_attrs_no_tokens {\n macro_rules! derive_has_tokens_no_attrs {\n     ($($ty:path),*) => { $(\n         impl AstLike for $ty {\n+            const SUPPORTS_CUSTOM_INNER_ATTRS: bool = false;\n+\n             fn attrs(&self) -> &[Attribute] {\n                 &[]\n             }\n \n             fn visit_attrs(&mut self, _f: impl FnOnce(&mut Vec<Attribute>)) {}\n-\n             fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n                 Some(&mut self.tokens)\n             }\n         }\n     )* }\n }\n \n-// These AST nodes support both inert and active\n-// attributes, so they also have tokens.\n+// These ast nodes support both active and inert attributes,\n+// so they have tokens collected to pass to proc macros\n+derive_has_tokens_and_attrs! {\n+    // Both `Item` and `AssocItem` can have bodies, which\n+    // can contain inner attributes\n+    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = true;\n+    Item, AssocItem, ForeignItem\n+}\n+\n derive_has_tokens_and_attrs! {\n-    Item, Expr, Local, AssocItem, ForeignItem\n+    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = false;\n+    Local, MacCallStmt, Expr\n }\n \n // These ast nodes only support inert attributes, so they don't"}, {"sha": "41121d095f3ed79bf3c12f997bf885b28e75f469", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 11, "deletions": 43, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -6,7 +6,9 @@ use crate::ast::{Lit, LitKind};\n use crate::ast::{MacArgs, MacDelimiter, MetaItem, MetaItemKind, NestedMetaItem};\n use crate::ast::{Path, PathSegment};\n use crate::token::{self, CommentKind, Token};\n-use crate::tokenstream::{DelimSpan, LazyTokenStream, TokenStream, TokenTree, TreeAndSpacing};\n+use crate::tokenstream::{AttrAnnotatedTokenStream, AttrAnnotatedTokenTree};\n+use crate::tokenstream::{DelimSpan, Spacing, TokenTree, TreeAndSpacing};\n+use crate::tokenstream::{LazyTokenStream, TokenStream};\n \n use rustc_index::bit_set::GrowableBitSet;\n use rustc_span::source_map::BytePos;\n@@ -100,16 +102,7 @@ impl NestedMetaItem {\n         self.meta_item().map_or(false, |meta_item| meta_item.is_word())\n     }\n \n-    /// Returns `true` if `self` is a `MetaItem` and the meta item is a `ValueString`.\n-    pub fn is_value_str(&self) -> bool {\n-        self.value_str().is_some()\n-    }\n-\n-    /// Returns `true` if `self` is a `MetaItem` and the meta item is a list.\n-    pub fn is_meta_item_list(&self) -> bool {\n-        self.meta_item_list().is_some()\n-    }\n-\n+    /// See [`MetaItem::name_value_literal_span`].\n     pub fn name_value_literal_span(&self) -> Option<Span> {\n         self.meta_item()?.name_value_literal_span()\n     }\n@@ -165,31 +158,6 @@ impl Attribute {\n             false\n         }\n     }\n-\n-    pub fn is_meta_item_list(&self) -> bool {\n-        self.meta_item_list().is_some()\n-    }\n-\n-    /// Indicates if the attribute is a `ValueString`.\n-    pub fn is_value_str(&self) -> bool {\n-        self.value_str().is_some()\n-    }\n-\n-    /// This is used in case you want the value span instead of the whole attribute. Example:\n-    ///\n-    /// ```text\n-    /// #[doc(alias = \"foo\")]\n-    /// ```\n-    ///\n-    /// In here, it'll return a span for `\"foo\"`.\n-    pub fn name_value_literal_span(&self) -> Option<Span> {\n-        match self.kind {\n-            AttrKind::Normal(ref item, _) => {\n-                item.meta(self.span).and_then(|meta| meta.name_value_literal_span())\n-            }\n-            AttrKind::DocComment(..) => None,\n-        }\n-    }\n }\n \n impl MetaItem {\n@@ -236,10 +204,6 @@ impl MetaItem {\n         self.path == name\n     }\n \n-    pub fn is_value_str(&self) -> bool {\n-        self.value_str().is_some()\n-    }\n-\n     /// This is used in case you want the value span instead of the whole attribute. Example:\n     ///\n     /// ```text\n@@ -306,14 +270,18 @@ impl Attribute {\n         }\n     }\n \n-    pub fn tokens(&self) -> TokenStream {\n+    pub fn tokens(&self) -> AttrAnnotatedTokenStream {\n         match self.kind {\n             AttrKind::Normal(_, ref tokens) => tokens\n                 .as_ref()\n                 .unwrap_or_else(|| panic!(\"attribute is missing tokens: {:?}\", self))\n                 .create_token_stream(),\n-            AttrKind::DocComment(comment_kind, data) => TokenStream::from(TokenTree::Token(\n-                Token::new(token::DocComment(comment_kind, self.style, data), self.span),\n+            AttrKind::DocComment(comment_kind, data) => AttrAnnotatedTokenStream::from((\n+                AttrAnnotatedTokenTree::Token(Token::new(\n+                    token::DocComment(comment_kind, self.style, data),\n+                    self.span,\n+                )),\n+                Spacing::Alone,\n             )),\n         }\n     }"}, {"sha": "2ee1bfe0ae71ba273835c9b2db5369002fee6512", "filename": "compiler/rustc_ast/src/expand/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast%2Fsrc%2Fexpand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast%2Fsrc%2Fexpand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fexpand%2Fmod.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -1,3 +1,3 @@\n-//! Definitions shared by macros / syntax extensions and e.g. librustc_middle.\n+//! Definitions shared by macros / syntax extensions and e.g. `rustc_middle`.\n \n pub mod allocator;"}, {"sha": "0f6e0fb8825be2828262c2d8b6394c3cfb4b5612", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -10,14 +10,13 @@\n )]\n #![feature(box_syntax)]\n #![feature(box_patterns)]\n-#![feature(const_fn)] // For the `transmute` in `P::new`\n+#![cfg_attr(bootstrap, feature(const_fn_unsize))]\n #![feature(const_fn_transmute)]\n #![feature(const_panic)]\n #![feature(crate_visibility_modifier)]\n #![feature(iter_zip)]\n #![feature(label_break_value)]\n #![feature(nll)]\n-#![cfg_attr(bootstrap, feature(or_patterns))]\n #![recursion_limit = \"256\"]\n \n #[macro_use]\n@@ -59,7 +58,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n \n /// Requirements for a `StableHashingContext` to be used in this crate.\n /// This is a hack to allow using the `HashStable_Generic` derive macro\n-/// instead of implementing everything in librustc_middle.\n+/// instead of implementing everything in `rustc_middle`.\n pub trait HashStableContext: rustc_span::HashStableContext {\n     fn hash_attr(&mut self, _: &ast::Attribute, hasher: &mut StableHasher);\n }"}, {"sha": "071d41ea2b2c7c83718af8fd8b9b65cc307b9d2e", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 72, "deletions": 26, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -484,6 +484,9 @@ pub fn noop_visit_ty<T: MutVisitor>(ty: &mut P<Ty>, vis: &mut T) {\n             visit_vec(bounds, |bound| vis.visit_param_bound(bound));\n         }\n         TyKind::MacCall(mac) => vis.visit_mac_call(mac),\n+        TyKind::AnonymousStruct(fields, ..) | TyKind::AnonymousUnion(fields, ..) => {\n+            fields.flat_map_in_place(|field| vis.flat_map_field_def(field));\n+        }\n     }\n     vis.visit_span(span);\n     visit_lazy_tts(tokens, vis);\n@@ -630,6 +633,33 @@ pub fn noop_flat_map_param<T: MutVisitor>(mut param: Param, vis: &mut T) -> Smal\n     smallvec![param]\n }\n \n+// No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n+pub fn visit_attr_annotated_tt<T: MutVisitor>(tt: &mut AttrAnnotatedTokenTree, vis: &mut T) {\n+    match tt {\n+        AttrAnnotatedTokenTree::Token(token) => {\n+            visit_token(token, vis);\n+        }\n+        AttrAnnotatedTokenTree::Delimited(DelimSpan { open, close }, _delim, tts) => {\n+            vis.visit_span(open);\n+            vis.visit_span(close);\n+            visit_attr_annotated_tts(tts, vis);\n+        }\n+        AttrAnnotatedTokenTree::Attributes(data) => {\n+            for attr in &mut *data.attrs {\n+                match &mut attr.kind {\n+                    AttrKind::Normal(_, attr_tokens) => {\n+                        visit_lazy_tts(attr_tokens, vis);\n+                    }\n+                    AttrKind::DocComment(..) => {\n+                        vis.visit_span(&mut attr.span);\n+                    }\n+                }\n+            }\n+            visit_lazy_tts_opt_mut(Some(&mut data.tokens), vis);\n+        }\n+    }\n+}\n+\n // No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n pub fn visit_tt<T: MutVisitor>(tt: &mut TokenTree, vis: &mut T) {\n     match tt {\n@@ -652,16 +682,30 @@ pub fn visit_tts<T: MutVisitor>(TokenStream(tts): &mut TokenStream, vis: &mut T)\n     }\n }\n \n-pub fn visit_lazy_tts<T: MutVisitor>(lazy_tts: &mut Option<LazyTokenStream>, vis: &mut T) {\n+pub fn visit_attr_annotated_tts<T: MutVisitor>(\n+    AttrAnnotatedTokenStream(tts): &mut AttrAnnotatedTokenStream,\n+    vis: &mut T,\n+) {\n+    if vis.token_visiting_enabled() && !tts.is_empty() {\n+        let tts = Lrc::make_mut(tts);\n+        visit_vec(tts, |(tree, _is_joint)| visit_attr_annotated_tt(tree, vis));\n+    }\n+}\n+\n+pub fn visit_lazy_tts_opt_mut<T: MutVisitor>(lazy_tts: Option<&mut LazyTokenStream>, vis: &mut T) {\n     if vis.token_visiting_enabled() {\n-        visit_opt(lazy_tts, |lazy_tts| {\n+        if let Some(lazy_tts) = lazy_tts {\n             let mut tts = lazy_tts.create_token_stream();\n-            visit_tts(&mut tts, vis);\n+            visit_attr_annotated_tts(&mut tts, vis);\n             *lazy_tts = LazyTokenStream::new(tts);\n-        })\n+        }\n     }\n }\n \n+pub fn visit_lazy_tts<T: MutVisitor>(lazy_tts: &mut Option<LazyTokenStream>, vis: &mut T) {\n+    visit_lazy_tts_opt_mut(lazy_tts.as_mut(), vis);\n+}\n+\n // No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n // Applies ident visitor if it's an ident; applies other visits to interpolated nodes.\n // In practice the ident part is not actually used by specific visitors right now,\n@@ -924,7 +968,7 @@ pub fn noop_visit_item_kind<T: MutVisitor>(kind: &mut ItemKind, vis: &mut T) {\n             ModKind::Unloaded => {}\n         },\n         ItemKind::ForeignMod(nm) => vis.visit_foreign_mod(nm),\n-        ItemKind::GlobalAsm(_ga) => {}\n+        ItemKind::GlobalAsm(asm) => noop_visit_inline_asm(asm, vis),\n         ItemKind::TyAlias(box TyAliasKind(_, generics, bounds, ty)) => {\n             vis.visit_generics(generics);\n             visit_bounds(bounds, vis);\n@@ -1129,6 +1173,28 @@ pub fn noop_visit_anon_const<T: MutVisitor>(AnonConst { id, value }: &mut AnonCo\n     vis.visit_expr(value);\n }\n \n+fn noop_visit_inline_asm<T: MutVisitor>(asm: &mut InlineAsm, vis: &mut T) {\n+    for (op, _) in &mut asm.operands {\n+        match op {\n+            InlineAsmOperand::In { expr, .. }\n+            | InlineAsmOperand::InOut { expr, .. }\n+            | InlineAsmOperand::Sym { expr, .. } => vis.visit_expr(expr),\n+            InlineAsmOperand::Out { expr, .. } => {\n+                if let Some(expr) = expr {\n+                    vis.visit_expr(expr);\n+                }\n+            }\n+            InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n+                vis.visit_expr(in_expr);\n+                if let Some(out_expr) = out_expr {\n+                    vis.visit_expr(out_expr);\n+                }\n+            }\n+            InlineAsmOperand::Const { anon_const, .. } => vis.visit_anon_const(anon_const),\n+        }\n+    }\n+}\n+\n pub fn noop_visit_expr<T: MutVisitor>(\n     Expr { kind, id, span, attrs, tokens }: &mut Expr,\n     vis: &mut T,\n@@ -1247,27 +1313,7 @@ pub fn noop_visit_expr<T: MutVisitor>(\n         ExprKind::Ret(expr) => {\n             visit_opt(expr, |expr| vis.visit_expr(expr));\n         }\n-        ExprKind::InlineAsm(asm) => {\n-            for (op, _) in &mut asm.operands {\n-                match op {\n-                    InlineAsmOperand::In { expr, .. }\n-                    | InlineAsmOperand::InOut { expr, .. }\n-                    | InlineAsmOperand::Const { expr, .. }\n-                    | InlineAsmOperand::Sym { expr, .. } => vis.visit_expr(expr),\n-                    InlineAsmOperand::Out { expr, .. } => {\n-                        if let Some(expr) = expr {\n-                            vis.visit_expr(expr);\n-                        }\n-                    }\n-                    InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n-                        vis.visit_expr(in_expr);\n-                        if let Some(out_expr) = out_expr {\n-                            vis.visit_expr(out_expr);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n+        ExprKind::InlineAsm(asm) => noop_visit_inline_asm(asm, vis),\n         ExprKind::LlvmInlineAsm(asm) => {\n             let LlvmInlineAsm {\n                 asm: _,"}, {"sha": "15f46ef5d7fe54bf473a22e43f319670bc9bb448", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -688,16 +688,12 @@ pub enum NonterminalKind {\n     Item,\n     Block,\n     Stmt,\n-    Pat2015 {\n-        /// Keep track of whether the user used `:pat2015` or `:pat` and we inferred it from the\n-        /// edition of the span. This is used for diagnostics.\n-        inferred: bool,\n-    },\n-    Pat2021 {\n-        /// Keep track of whether the user used `:pat2015` or `:pat` and we inferred it from the\n+    PatParam {\n+        /// Keep track of whether the user used `:pat_param` or `:pat` and we inferred it from the\n         /// edition of the span. This is used for diagnostics.\n         inferred: bool,\n     },\n+    PatWithOr,\n     Expr,\n     Ty,\n     Ident,\n@@ -722,12 +718,11 @@ impl NonterminalKind {\n             sym::stmt => NonterminalKind::Stmt,\n             sym::pat => match edition() {\n                 Edition::Edition2015 | Edition::Edition2018 => {\n-                    NonterminalKind::Pat2015 { inferred: true }\n+                    NonterminalKind::PatParam { inferred: true }\n                 }\n-                Edition::Edition2021 => NonterminalKind::Pat2021 { inferred: true },\n+                Edition::Edition2021 => NonterminalKind::PatWithOr,\n             },\n-            sym::pat2015 => NonterminalKind::Pat2015 { inferred: false },\n-            sym::pat2021 => NonterminalKind::Pat2021 { inferred: false },\n+            sym::pat_param => NonterminalKind::PatParam { inferred: false },\n             sym::expr => NonterminalKind::Expr,\n             sym::ty => NonterminalKind::Ty,\n             sym::ident => NonterminalKind::Ident,\n@@ -745,10 +740,8 @@ impl NonterminalKind {\n             NonterminalKind::Item => sym::item,\n             NonterminalKind::Block => sym::block,\n             NonterminalKind::Stmt => sym::stmt,\n-            NonterminalKind::Pat2015 { inferred: false } => sym::pat2015,\n-            NonterminalKind::Pat2021 { inferred: false } => sym::pat2021,\n-            NonterminalKind::Pat2015 { inferred: true }\n-            | NonterminalKind::Pat2021 { inferred: true } => sym::pat,\n+            NonterminalKind::PatParam { inferred: false } => sym::pat_param,\n+            NonterminalKind::PatParam { inferred: true } | NonterminalKind::PatWithOr => sym::pat,\n             NonterminalKind::Expr => sym::expr,\n             NonterminalKind::Ty => sym::ty,\n             NonterminalKind::Ident => sym::ident,"}, {"sha": "2d463a4588c561ecd8e1df5da5eca65000a10b5e", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 156, "deletions": 26, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -14,6 +14,7 @@\n //! ownership of the original.\n \n use crate::token::{self, DelimToken, Token, TokenKind};\n+use crate::AttrVec;\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::{self, Lrc};\n@@ -89,10 +90,6 @@ impl TokenTree {\n         }\n     }\n \n-    pub fn joint(self) -> TokenStream {\n-        TokenStream::new(vec![(self, Spacing::Joint)])\n-    }\n-\n     pub fn token(kind: TokenKind, span: Span) -> TokenTree {\n         TokenTree::Token(Token::new(kind, span))\n     }\n@@ -127,11 +124,11 @@ where\n }\n \n pub trait CreateTokenStream: sync::Send + sync::Sync {\n-    fn create_token_stream(&self) -> TokenStream;\n+    fn create_token_stream(&self) -> AttrAnnotatedTokenStream;\n }\n \n-impl CreateTokenStream for TokenStream {\n-    fn create_token_stream(&self) -> TokenStream {\n+impl CreateTokenStream for AttrAnnotatedTokenStream {\n+    fn create_token_stream(&self) -> AttrAnnotatedTokenStream {\n         self.clone()\n     }\n }\n@@ -147,14 +144,14 @@ impl LazyTokenStream {\n         LazyTokenStream(Lrc::new(Box::new(inner)))\n     }\n \n-    pub fn create_token_stream(&self) -> TokenStream {\n+    pub fn create_token_stream(&self) -> AttrAnnotatedTokenStream {\n         self.0.create_token_stream()\n     }\n }\n \n impl fmt::Debug for LazyTokenStream {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Debug::fmt(\"LazyTokenStream\", f)\n+        write!(f, \"LazyTokenStream({:?})\", self.create_token_stream())\n     }\n }\n \n@@ -177,12 +174,151 @@ impl<CTX> HashStable<CTX> for LazyTokenStream {\n     }\n }\n \n+/// A `AttrAnnotatedTokenStream` is similar to a `TokenStream`, but with extra\n+/// information about the tokens for attribute targets. This is used\n+/// during expansion to perform early cfg-expansion, and to process attributes\n+/// during proc-macro invocations.\n+#[derive(Clone, Debug, Default, Encodable, Decodable)]\n+pub struct AttrAnnotatedTokenStream(pub Lrc<Vec<(AttrAnnotatedTokenTree, Spacing)>>);\n+\n+/// Like `TokenTree`, but for `AttrAnnotatedTokenStream`\n+#[derive(Clone, Debug, Encodable, Decodable)]\n+pub enum AttrAnnotatedTokenTree {\n+    Token(Token),\n+    Delimited(DelimSpan, DelimToken, AttrAnnotatedTokenStream),\n+    /// Stores the attributes for an attribute target,\n+    /// along with the tokens for that attribute target.\n+    /// See `AttributesData` for more information\n+    Attributes(AttributesData),\n+}\n+\n+impl AttrAnnotatedTokenStream {\n+    pub fn new(tokens: Vec<(AttrAnnotatedTokenTree, Spacing)>) -> AttrAnnotatedTokenStream {\n+        AttrAnnotatedTokenStream(Lrc::new(tokens))\n+    }\n+\n+    /// Converts this `AttrAnnotatedTokenStream` to a plain `TokenStream\n+    /// During conversion, `AttrAnnotatedTokenTree::Attributes` get 'flattened'\n+    /// back to a `TokenStream` of the form `outer_attr attr_target`.\n+    /// If there are inner attributes, they are inserted into the proper\n+    /// place in the attribute target tokens.\n+    pub fn to_tokenstream(&self) -> TokenStream {\n+        let trees: Vec<_> = self\n+            .0\n+            .iter()\n+            .flat_map(|tree| match &tree.0 {\n+                AttrAnnotatedTokenTree::Token(inner) => {\n+                    smallvec![(TokenTree::Token(inner.clone()), tree.1)].into_iter()\n+                }\n+                AttrAnnotatedTokenTree::Delimited(span, delim, stream) => smallvec![(\n+                    TokenTree::Delimited(*span, *delim, stream.to_tokenstream()),\n+                    tree.1,\n+                )]\n+                .into_iter(),\n+                AttrAnnotatedTokenTree::Attributes(data) => {\n+                    let mut outer_attrs = Vec::new();\n+                    let mut inner_attrs = Vec::new();\n+                    let attrs: Vec<_> = data.attrs.clone().into();\n+                    for attr in attrs {\n+                        match attr.style {\n+                            crate::AttrStyle::Outer => {\n+                                assert!(\n+                                    inner_attrs.len() == 0,\n+                                    \"Found outer attribute {:?} after inner attrs {:?}\",\n+                                    attr,\n+                                    inner_attrs\n+                                );\n+                                outer_attrs.push(attr);\n+                            }\n+                            crate::AttrStyle::Inner => {\n+                                inner_attrs.push(attr);\n+                            }\n+                        }\n+                    }\n+\n+                    let mut target_tokens: Vec<_> = data\n+                        .tokens\n+                        .create_token_stream()\n+                        .to_tokenstream()\n+                        .0\n+                        .iter()\n+                        .cloned()\n+                        .collect();\n+                    if !inner_attrs.is_empty() {\n+                        let mut found = false;\n+                        // Check the last two trees (to account for a trailing semi)\n+                        for (tree, _) in target_tokens.iter_mut().rev().take(2) {\n+                            if let TokenTree::Delimited(span, delim, delim_tokens) = tree {\n+                                // Inner attributes are only supported on extern blocks, functions, impls,\n+                                // and modules. All of these have their inner attributes placed at\n+                                // the beginning of the rightmost outermost braced group:\n+                                // e.g. fn foo() { #![my_attr} }\n+                                //\n+                                // Therefore, we can insert them back into the right location\n+                                // without needing to do any extra position tracking.\n+                                //\n+                                // Note: Outline modules are an exception - they can\n+                                // have attributes like `#![my_attr]` at the start of a file.\n+                                // Support for custom attributes in this position is not\n+                                // properly implemented - we always synthesize fake tokens,\n+                                // so we never reach this code.\n+\n+                                let mut builder = TokenStreamBuilder::new();\n+                                for inner_attr in &inner_attrs {\n+                                    builder.push(inner_attr.tokens().to_tokenstream());\n+                                }\n+                                builder.push(delim_tokens.clone());\n+                                *tree = TokenTree::Delimited(*span, *delim, builder.build());\n+                                found = true;\n+                                break;\n+                            }\n+                        }\n+\n+                        assert!(\n+                            found,\n+                            \"Failed to find trailing delimited group in: {:?}\",\n+                            target_tokens\n+                        );\n+                    }\n+                    let mut flat: SmallVec<[_; 1]> = SmallVec::new();\n+                    for attr in outer_attrs {\n+                        // FIXME: Make this more efficient\n+                        flat.extend(attr.tokens().to_tokenstream().0.clone().iter().cloned());\n+                    }\n+                    flat.extend(target_tokens);\n+                    flat.into_iter()\n+                }\n+            })\n+            .collect();\n+        TokenStream::new(trees)\n+    }\n+}\n+\n+/// Stores the tokens for an attribute target, along\n+/// with its attributes.\n+///\n+/// This is constructed during parsing when we need to capture\n+/// tokens.\n+///\n+/// For example, `#[cfg(FALSE)] struct Foo {}` would\n+/// have an `attrs` field containing the `#[cfg(FALSE)]` attr,\n+/// and a `tokens` field storing the (unparesd) tokens `struct Foo {}`\n+#[derive(Clone, Debug, Encodable, Decodable)]\n+pub struct AttributesData {\n+    /// Attributes, both outer and inner.\n+    /// These are stored in the original order that they were parsed in.\n+    pub attrs: AttrVec,\n+    /// The underlying tokens for the attribute target that `attrs`\n+    /// are applied to\n+    pub tokens: LazyTokenStream,\n+}\n+\n /// A `TokenStream` is an abstract sequence of tokens, organized into [`TokenTree`]s.\n ///\n /// The goal is for procedural macros to work with `TokenStream`s and `TokenTree`s\n /// instead of a representation of the abstract syntax tree.\n /// Today's `TokenTree`s can still contain AST via `token::Interpolated` for\n-/// backwards compatability.\n+/// backwards compatibility.\n #[derive(Clone, Debug, Default, Encodable, Decodable)]\n pub struct TokenStream(pub(crate) Lrc<Vec<TreeAndSpacing>>);\n \n@@ -239,6 +375,12 @@ impl TokenStream {\n     }\n }\n \n+impl From<(AttrAnnotatedTokenTree, Spacing)> for AttrAnnotatedTokenStream {\n+    fn from((tree, spacing): (AttrAnnotatedTokenTree, Spacing)) -> AttrAnnotatedTokenStream {\n+        AttrAnnotatedTokenStream::new(vec![(tree, spacing)])\n+    }\n+}\n+\n impl From<TokenTree> for TokenStream {\n     fn from(tree: TokenTree) -> TokenStream {\n         TokenStream::new(vec![(tree, Spacing::Alone)])\n@@ -278,14 +420,6 @@ impl TokenStream {\n         self.0.len()\n     }\n \n-    pub fn span(&self) -> Option<Span> {\n-        match &**self.0 {\n-            [] => None,\n-            [(tt, _)] => Some(tt.span()),\n-            [(tt_start, _), .., (tt_end, _)] => Some(tt_start.span().to(tt_end.span())),\n-        }\n-    }\n-\n     pub fn from_streams(mut streams: SmallVec<[TokenStream; 2]>) -> TokenStream {\n         match streams.len() {\n             0 => TokenStream::default(),\n@@ -325,10 +459,6 @@ impl TokenStream {\n         }\n     }\n \n-    pub fn trees_ref(&self) -> CursorRef<'_> {\n-        CursorRef::new(self)\n-    }\n-\n     pub fn trees(&self) -> Cursor {\n         self.clone().into_trees()\n     }\n@@ -427,10 +557,6 @@ pub struct CursorRef<'t> {\n }\n \n impl<'t> CursorRef<'t> {\n-    fn new(stream: &TokenStream) -> CursorRef<'_> {\n-        CursorRef { stream, index: 0 }\n-    }\n-\n     fn next_with_spacing(&mut self) -> Option<&'t TreeAndSpacing> {\n         self.stream.0.get(self.index).map(|tree| {\n             self.index += 1;\n@@ -477,6 +603,10 @@ impl Cursor {\n         }\n     }\n \n+    pub fn index(&self) -> usize {\n+        self.index\n+    }\n+\n     pub fn append(&mut self, new_stream: TokenStream) {\n         if new_stream.is_empty() {\n             return;"}, {"sha": "f1a99bc51c96d0eb1c8de4be0d0b83de317104ec", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -90,9 +90,6 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_foreign_item(&mut self, i: &'ast ForeignItem) {\n         walk_foreign_item(self, i)\n     }\n-    fn visit_global_asm(&mut self, ga: &'ast GlobalAsm) {\n-        walk_global_asm(self, ga)\n-    }\n     fn visit_item(&mut self, i: &'ast Item) {\n         walk_item(self, i)\n     }\n@@ -299,7 +296,7 @@ pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n         ItemKind::ForeignMod(ref foreign_module) => {\n             walk_list!(visitor, visit_foreign_item, &foreign_module.items);\n         }\n-        ItemKind::GlobalAsm(ref ga) => visitor.visit_global_asm(ga),\n+        ItemKind::GlobalAsm(ref asm) => walk_inline_asm(visitor, asm),\n         ItemKind::TyAlias(box TyAliasKind(_, ref generics, ref bounds, ref ty)) => {\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_param_bound, bounds);\n@@ -407,6 +404,9 @@ pub fn walk_ty<'a, V: Visitor<'a>>(visitor: &mut V, typ: &'a Ty) {\n         TyKind::Typeof(ref expression) => visitor.visit_anon_const(expression),\n         TyKind::Infer | TyKind::ImplicitSelf | TyKind::Err => {}\n         TyKind::MacCall(ref mac) => visitor.visit_mac_call(mac),\n+        TyKind::AnonymousStruct(ref fields, ..) | TyKind::AnonymousUnion(ref fields, ..) => {\n+            walk_list!(visitor, visit_field_def, fields)\n+        }\n         TyKind::Never | TyKind::CVarArgs => {}\n     }\n }\n@@ -557,10 +557,6 @@ pub fn walk_foreign_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a ForeignI\n     }\n }\n \n-pub fn walk_global_asm<'a, V: Visitor<'a>>(_: &mut V, _: &'a GlobalAsm) {\n-    // Empty!\n-}\n-\n pub fn walk_param_bound<'a, V: Visitor<'a>>(visitor: &mut V, bound: &'a GenericBound) {\n     match *bound {\n         GenericBound::Trait(ref typ, ref modifier) => visitor.visit_poly_trait_ref(typ, modifier),\n@@ -708,6 +704,28 @@ pub fn walk_anon_const<'a, V: Visitor<'a>>(visitor: &mut V, constant: &'a AnonCo\n     visitor.visit_expr(&constant.value);\n }\n \n+fn walk_inline_asm<'a, V: Visitor<'a>>(visitor: &mut V, asm: &'a InlineAsm) {\n+    for (op, _) in &asm.operands {\n+        match op {\n+            InlineAsmOperand::In { expr, .. }\n+            | InlineAsmOperand::InOut { expr, .. }\n+            | InlineAsmOperand::Sym { expr, .. } => visitor.visit_expr(expr),\n+            InlineAsmOperand::Out { expr, .. } => {\n+                if let Some(expr) = expr {\n+                    visitor.visit_expr(expr);\n+                }\n+            }\n+            InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n+                visitor.visit_expr(in_expr);\n+                if let Some(out_expr) = out_expr {\n+                    visitor.visit_expr(out_expr);\n+                }\n+            }\n+            InlineAsmOperand::Const { anon_const, .. } => visitor.visit_anon_const(anon_const),\n+        }\n+    }\n+}\n+\n pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n     walk_list!(visitor, visit_attribute, expression.attrs.iter());\n \n@@ -830,27 +848,7 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n         }\n         ExprKind::MacCall(ref mac) => visitor.visit_mac_call(mac),\n         ExprKind::Paren(ref subexpression) => visitor.visit_expr(subexpression),\n-        ExprKind::InlineAsm(ref ia) => {\n-            for (op, _) in &ia.operands {\n-                match op {\n-                    InlineAsmOperand::In { expr, .. }\n-                    | InlineAsmOperand::InOut { expr, .. }\n-                    | InlineAsmOperand::Const { expr, .. }\n-                    | InlineAsmOperand::Sym { expr, .. } => visitor.visit_expr(expr),\n-                    InlineAsmOperand::Out { expr, .. } => {\n-                        if let Some(expr) = expr {\n-                            visitor.visit_expr(expr);\n-                        }\n-                    }\n-                    InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n-                        visitor.visit_expr(in_expr);\n-                        if let Some(out_expr) = out_expr {\n-                            visitor.visit_expr(out_expr);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n+        ExprKind::InlineAsm(ref asm) => walk_inline_asm(visitor, asm),\n         ExprKind::LlvmInlineAsm(ref ia) => {\n             for &(_, ref input) in &ia.inputs {\n                 visitor.visit_expr(input)"}, {"sha": "1c3fae2afe71f2af5304cc7654434940082f744f", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "added", "additions": 329, "deletions": 0, "changes": 329, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -0,0 +1,329 @@\n+use super::LoweringContext;\n+\n+use rustc_ast::*;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_errors::struct_span_err;\n+use rustc_hir as hir;\n+use rustc_span::{Span, Symbol};\n+use rustc_target::asm;\n+use std::collections::hash_map::Entry;\n+use std::fmt::Write;\n+\n+impl<'a, 'hir> LoweringContext<'a, 'hir> {\n+    crate fn lower_inline_asm(&mut self, sp: Span, asm: &InlineAsm) -> &'hir hir::InlineAsm<'hir> {\n+        // Rustdoc needs to support asm! from foriegn architectures: don't try\n+        // lowering the register contraints in this case.\n+        let asm_arch = if self.sess.opts.actually_rustdoc { None } else { self.sess.asm_arch };\n+        if asm_arch.is_none() && !self.sess.opts.actually_rustdoc {\n+            struct_span_err!(self.sess, sp, E0472, \"inline assembly is unsupported on this target\")\n+                .emit();\n+        }\n+        if asm.options.contains(InlineAsmOptions::ATT_SYNTAX)\n+            && !matches!(asm_arch, Some(asm::InlineAsmArch::X86 | asm::InlineAsmArch::X86_64))\n+            && !self.sess.opts.actually_rustdoc\n+        {\n+            self.sess\n+                .struct_span_err(sp, \"the `att_syntax` option is only supported on x86\")\n+                .emit();\n+        }\n+\n+        // Lower operands to HIR. We use dummy register classes if an error\n+        // occurs during lowering because we still need to be able to produce a\n+        // valid HIR.\n+        let sess = self.sess;\n+        let operands: Vec<_> = asm\n+            .operands\n+            .iter()\n+            .map(|(op, op_sp)| {\n+                let lower_reg = |reg| match reg {\n+                    InlineAsmRegOrRegClass::Reg(s) => {\n+                        asm::InlineAsmRegOrRegClass::Reg(if let Some(asm_arch) = asm_arch {\n+                            asm::InlineAsmReg::parse(\n+                                asm_arch,\n+                                |feature| sess.target_features.contains(&Symbol::intern(feature)),\n+                                &sess.target,\n+                                s,\n+                            )\n+                            .unwrap_or_else(|e| {\n+                                let msg = format!(\"invalid register `{}`: {}\", s.as_str(), e);\n+                                sess.struct_span_err(*op_sp, &msg).emit();\n+                                asm::InlineAsmReg::Err\n+                            })\n+                        } else {\n+                            asm::InlineAsmReg::Err\n+                        })\n+                    }\n+                    InlineAsmRegOrRegClass::RegClass(s) => {\n+                        asm::InlineAsmRegOrRegClass::RegClass(if let Some(asm_arch) = asm_arch {\n+                            asm::InlineAsmRegClass::parse(asm_arch, s).unwrap_or_else(|e| {\n+                                let msg = format!(\"invalid register class `{}`: {}\", s.as_str(), e);\n+                                sess.struct_span_err(*op_sp, &msg).emit();\n+                                asm::InlineAsmRegClass::Err\n+                            })\n+                        } else {\n+                            asm::InlineAsmRegClass::Err\n+                        })\n+                    }\n+                };\n+\n+                let op = match *op {\n+                    InlineAsmOperand::In { reg, ref expr } => hir::InlineAsmOperand::In {\n+                        reg: lower_reg(reg),\n+                        expr: self.lower_expr_mut(expr),\n+                    },\n+                    InlineAsmOperand::Out { reg, late, ref expr } => hir::InlineAsmOperand::Out {\n+                        reg: lower_reg(reg),\n+                        late,\n+                        expr: expr.as_ref().map(|expr| self.lower_expr_mut(expr)),\n+                    },\n+                    InlineAsmOperand::InOut { reg, late, ref expr } => {\n+                        hir::InlineAsmOperand::InOut {\n+                            reg: lower_reg(reg),\n+                            late,\n+                            expr: self.lower_expr_mut(expr),\n+                        }\n+                    }\n+                    InlineAsmOperand::SplitInOut { reg, late, ref in_expr, ref out_expr } => {\n+                        hir::InlineAsmOperand::SplitInOut {\n+                            reg: lower_reg(reg),\n+                            late,\n+                            in_expr: self.lower_expr_mut(in_expr),\n+                            out_expr: out_expr.as_ref().map(|expr| self.lower_expr_mut(expr)),\n+                        }\n+                    }\n+                    InlineAsmOperand::Const { ref anon_const } => hir::InlineAsmOperand::Const {\n+                        anon_const: self.lower_anon_const(anon_const),\n+                    },\n+                    InlineAsmOperand::Sym { ref expr } => {\n+                        hir::InlineAsmOperand::Sym { expr: self.lower_expr_mut(expr) }\n+                    }\n+                };\n+                (op, *op_sp)\n+            })\n+            .collect();\n+\n+        // Validate template modifiers against the register classes for the operands\n+        for p in &asm.template {\n+            if let InlineAsmTemplatePiece::Placeholder {\n+                operand_idx,\n+                modifier: Some(modifier),\n+                span: placeholder_span,\n+            } = *p\n+            {\n+                let op_sp = asm.operands[operand_idx].1;\n+                match &operands[operand_idx].0 {\n+                    hir::InlineAsmOperand::In { reg, .. }\n+                    | hir::InlineAsmOperand::Out { reg, .. }\n+                    | hir::InlineAsmOperand::InOut { reg, .. }\n+                    | hir::InlineAsmOperand::SplitInOut { reg, .. } => {\n+                        let class = reg.reg_class();\n+                        if class == asm::InlineAsmRegClass::Err {\n+                            continue;\n+                        }\n+                        let valid_modifiers = class.valid_modifiers(asm_arch.unwrap());\n+                        if !valid_modifiers.contains(&modifier) {\n+                            let mut err = sess.struct_span_err(\n+                                placeholder_span,\n+                                \"invalid asm template modifier for this register class\",\n+                            );\n+                            err.span_label(placeholder_span, \"template modifier\");\n+                            err.span_label(op_sp, \"argument\");\n+                            if !valid_modifiers.is_empty() {\n+                                let mut mods = format!(\"`{}`\", valid_modifiers[0]);\n+                                for m in &valid_modifiers[1..] {\n+                                    let _ = write!(mods, \", `{}`\", m);\n+                                }\n+                                err.note(&format!(\n+                                    \"the `{}` register class supports \\\n+                                     the following template modifiers: {}\",\n+                                    class.name(),\n+                                    mods\n+                                ));\n+                            } else {\n+                                err.note(&format!(\n+                                    \"the `{}` register class does not support template modifiers\",\n+                                    class.name()\n+                                ));\n+                            }\n+                            err.emit();\n+                        }\n+                    }\n+                    hir::InlineAsmOperand::Const { .. } => {\n+                        let mut err = sess.struct_span_err(\n+                            placeholder_span,\n+                            \"asm template modifiers are not allowed for `const` arguments\",\n+                        );\n+                        err.span_label(placeholder_span, \"template modifier\");\n+                        err.span_label(op_sp, \"argument\");\n+                        err.emit();\n+                    }\n+                    hir::InlineAsmOperand::Sym { .. } => {\n+                        let mut err = sess.struct_span_err(\n+                            placeholder_span,\n+                            \"asm template modifiers are not allowed for `sym` arguments\",\n+                        );\n+                        err.span_label(placeholder_span, \"template modifier\");\n+                        err.span_label(op_sp, \"argument\");\n+                        err.emit();\n+                    }\n+                }\n+            }\n+        }\n+\n+        let mut used_input_regs = FxHashMap::default();\n+        let mut used_output_regs = FxHashMap::default();\n+        let mut required_features: Vec<&str> = vec![];\n+        for (idx, &(ref op, op_sp)) in operands.iter().enumerate() {\n+            if let Some(reg) = op.reg() {\n+                // Make sure we don't accidentally carry features from the\n+                // previous iteration.\n+                required_features.clear();\n+\n+                let reg_class = reg.reg_class();\n+                if reg_class == asm::InlineAsmRegClass::Err {\n+                    continue;\n+                }\n+\n+                // We ignore target feature requirements for clobbers: if the\n+                // feature is disabled then the compiler doesn't care what we\n+                // do with the registers.\n+                //\n+                // Note that this is only possible for explicit register\n+                // operands, which cannot be used in the asm string.\n+                let is_clobber = matches!(\n+                    op,\n+                    hir::InlineAsmOperand::Out {\n+                        reg: asm::InlineAsmRegOrRegClass::Reg(_),\n+                        late: _,\n+                        expr: None\n+                    }\n+                );\n+\n+                if !is_clobber {\n+                    // Validate register classes against currently enabled target\n+                    // features. We check that at least one type is available for\n+                    // the current target.\n+                    for &(_, feature) in reg_class.supported_types(asm_arch.unwrap()) {\n+                        if let Some(feature) = feature {\n+                            if self.sess.target_features.contains(&Symbol::intern(feature)) {\n+                                required_features.clear();\n+                                break;\n+                            } else {\n+                                required_features.push(feature);\n+                            }\n+                        } else {\n+                            required_features.clear();\n+                            break;\n+                        }\n+                    }\n+                    // We are sorting primitive strs here and can use unstable sort here\n+                    required_features.sort_unstable();\n+                    required_features.dedup();\n+                    match &required_features[..] {\n+                        [] => {}\n+                        [feature] => {\n+                            let msg = format!(\n+                                \"register class `{}` requires the `{}` target feature\",\n+                                reg_class.name(),\n+                                feature\n+                            );\n+                            sess.struct_span_err(op_sp, &msg).emit();\n+                        }\n+                        features => {\n+                            let msg = format!(\n+                                \"register class `{}` requires at least one target feature: {}\",\n+                                reg_class.name(),\n+                                features.join(\", \")\n+                            );\n+                            sess.struct_span_err(op_sp, &msg).emit();\n+                        }\n+                    }\n+                }\n+\n+                // Check for conflicts between explicit register operands.\n+                if let asm::InlineAsmRegOrRegClass::Reg(reg) = reg {\n+                    let (input, output) = match op {\n+                        hir::InlineAsmOperand::In { .. } => (true, false),\n+\n+                        // Late output do not conflict with inputs, but normal outputs do\n+                        hir::InlineAsmOperand::Out { late, .. } => (!late, true),\n+\n+                        hir::InlineAsmOperand::InOut { .. }\n+                        | hir::InlineAsmOperand::SplitInOut { .. } => (true, true),\n+\n+                        hir::InlineAsmOperand::Const { .. } | hir::InlineAsmOperand::Sym { .. } => {\n+                            unreachable!()\n+                        }\n+                    };\n+\n+                    // Flag to output the error only once per operand\n+                    let mut skip = false;\n+                    reg.overlapping_regs(|r| {\n+                        let mut check = |used_regs: &mut FxHashMap<asm::InlineAsmReg, usize>,\n+                                         input| {\n+                            match used_regs.entry(r) {\n+                                Entry::Occupied(o) => {\n+                                    if skip {\n+                                        return;\n+                                    }\n+                                    skip = true;\n+\n+                                    let idx2 = *o.get();\n+                                    let &(ref op2, op_sp2) = &operands[idx2];\n+                                    let reg2 = match op2.reg() {\n+                                        Some(asm::InlineAsmRegOrRegClass::Reg(r)) => r,\n+                                        _ => unreachable!(),\n+                                    };\n+\n+                                    let msg = format!(\n+                                        \"register `{}` conflicts with register `{}`\",\n+                                        reg.name(),\n+                                        reg2.name()\n+                                    );\n+                                    let mut err = sess.struct_span_err(op_sp, &msg);\n+                                    err.span_label(op_sp, &format!(\"register `{}`\", reg.name()));\n+                                    err.span_label(op_sp2, &format!(\"register `{}`\", reg2.name()));\n+\n+                                    match (op, op2) {\n+                                        (\n+                                            hir::InlineAsmOperand::In { .. },\n+                                            hir::InlineAsmOperand::Out { late, .. },\n+                                        )\n+                                        | (\n+                                            hir::InlineAsmOperand::Out { late, .. },\n+                                            hir::InlineAsmOperand::In { .. },\n+                                        ) => {\n+                                            assert!(!*late);\n+                                            let out_op_sp = if input { op_sp2 } else { op_sp };\n+                                            let msg = \"use `lateout` instead of \\\n+                                                       `out` to avoid conflict\";\n+                                            err.span_help(out_op_sp, msg);\n+                                        }\n+                                        _ => {}\n+                                    }\n+\n+                                    err.emit();\n+                                }\n+                                Entry::Vacant(v) => {\n+                                    v.insert(idx);\n+                                }\n+                            }\n+                        };\n+                        if input {\n+                            check(&mut used_input_regs, true);\n+                        }\n+                        if output {\n+                            check(&mut used_output_regs, false);\n+                        }\n+                    });\n+                }\n+            }\n+        }\n+\n+        let operands = self.arena.alloc_from_iter(operands);\n+        let template = self.arena.alloc_from_iter(asm.template.iter().cloned());\n+        let line_spans = self.arena.alloc_slice(&asm.line_spans[..]);\n+        let hir_asm = hir::InlineAsm { template, operands, options: asm.options, line_spans };\n+        self.arena.alloc(hir_asm)\n+    }\n+}"}, {"sha": "866f2180bb6e3503ec8874e4094d406c6edc718f", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 31, "deletions": 336, "changes": 367, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -3,7 +3,6 @@ use super::{ImplTraitContext, LoweringContext, ParamMode, ParenthesizedGenericAr\n use rustc_ast::attr;\n use rustc_ast::ptr::P as AstP;\n use rustc_ast::*;\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::struct_span_err;\n@@ -15,9 +14,6 @@ use rustc_span::hygiene::ExpnId;\n use rustc_span::source_map::{respan, DesugaringKind, Span, Spanned};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{hygiene::ForLoopLoc, DUMMY_SP};\n-use rustc_target::asm;\n-use std::collections::hash_map::Entry;\n-use std::fmt::Write;\n \n impl<'hir> LoweringContext<'_, 'hir> {\n     fn lower_exprs(&mut self, exprs: &[AstP<Expr>]) -> &'hir [hir::Expr<'hir>] {\n@@ -222,7 +218,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let e = e.as_ref().map(|x| self.lower_expr(x));\n                     hir::ExprKind::Ret(e)\n                 }\n-                ExprKind::InlineAsm(ref asm) => self.lower_expr_asm(e.span, asm),\n+                ExprKind::InlineAsm(ref asm) => {\n+                    hir::ExprKind::InlineAsm(self.lower_inline_asm(e.span, asm))\n+                }\n                 ExprKind::LlvmInlineAsm(ref asm) => self.lower_expr_llvm_asm(asm),\n                 ExprKind::Struct(ref se) => {\n                     let rest = match &se.rest {\n@@ -338,7 +336,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let mut generic_args = vec![];\n         for (idx, arg) in args.into_iter().enumerate() {\n             if legacy_args_idx.contains(&idx) {\n-                let parent_def_id = self.current_hir_id_owner.last().unwrap().0;\n+                let parent_def_id = self.current_hir_id_owner.0;\n                 let node_id = self.resolver.next_node_id();\n \n                 // Add a definition for the in-band const def.\n@@ -562,8 +560,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         )\n     }\n \n-    /// Desugar `try { <stmts>; <expr> }` into `{ <stmts>; ::std::ops::Try::from_ok(<expr>) }`,\n-    /// `try { <stmts>; }` into `{ <stmts>; ::std::ops::Try::from_ok(()) }`\n+    /// Desugar `try { <stmts>; <expr> }` into `{ <stmts>; ::std::ops::Try::from_output(<expr>) }`,\n+    /// `try { <stmts>; }` into `{ <stmts>; ::std::ops::Try::from_output(()) }`\n     /// and save the block id to use it as a break target for desugaring of the `?` operator.\n     fn lower_expr_try_block(&mut self, body: &Block) -> hir::ExprKind<'hir> {\n         self.with_catch_scope(body.id, |this| {\n@@ -592,9 +590,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             let ok_wrapped_span =\n                 this.mark_span_with_reason(DesugaringKind::TryBlock, tail_expr.span, None);\n \n-            // `::std::ops::Try::from_ok($tail_expr)`\n+            // `::std::ops::Try::from_output($tail_expr)`\n             block.expr = Some(this.wrap_in_try_constructor(\n-                hir::LangItem::TryFromOk,\n+                hir::LangItem::TryTraitFromOutput,\n                 try_span,\n                 tail_expr,\n                 ok_wrapped_span,\n@@ -1236,9 +1234,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             (Some(..), Some(..), HalfOpen) => hir::LangItem::Range,\n             (None, Some(..), Closed) => hir::LangItem::RangeToInclusive,\n             (Some(..), Some(..), Closed) => unreachable!(),\n-            (_, None, Closed) => {\n-                self.diagnostic().span_fatal(span, \"inclusive range with no end\").raise()\n-            }\n+            (_, None, Closed) => self.diagnostic().span_fatal(span, \"inclusive range with no end\"),\n         };\n \n         let fields = self.arena.alloc_from_iter(\n@@ -1331,301 +1327,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         result\n     }\n \n-    fn lower_expr_asm(&mut self, sp: Span, asm: &InlineAsm) -> hir::ExprKind<'hir> {\n-        // Rustdoc needs to support asm! from foriegn architectures: don't try\n-        // lowering the register contraints in this case.\n-        let asm_arch = if self.sess.opts.actually_rustdoc { None } else { self.sess.asm_arch };\n-        if asm_arch.is_none() && !self.sess.opts.actually_rustdoc {\n-            struct_span_err!(self.sess, sp, E0472, \"asm! is unsupported on this target\").emit();\n-        }\n-        if asm.options.contains(InlineAsmOptions::ATT_SYNTAX)\n-            && !matches!(asm_arch, Some(asm::InlineAsmArch::X86 | asm::InlineAsmArch::X86_64))\n-            && !self.sess.opts.actually_rustdoc\n-        {\n-            self.sess\n-                .struct_span_err(sp, \"the `att_syntax` option is only supported on x86\")\n-                .emit();\n-        }\n-\n-        // Lower operands to HIR. We use dummy register classes if an error\n-        // occurs during lowering because we still need to be able to produce a\n-        // valid HIR.\n-        let sess = self.sess;\n-        let operands: Vec<_> = asm\n-            .operands\n-            .iter()\n-            .map(|(op, op_sp)| {\n-                let lower_reg = |reg| match reg {\n-                    InlineAsmRegOrRegClass::Reg(s) => {\n-                        asm::InlineAsmRegOrRegClass::Reg(if let Some(asm_arch) = asm_arch {\n-                            asm::InlineAsmReg::parse(\n-                                asm_arch,\n-                                |feature| sess.target_features.contains(&Symbol::intern(feature)),\n-                                &sess.target,\n-                                s,\n-                            )\n-                            .unwrap_or_else(|e| {\n-                                let msg = format!(\"invalid register `{}`: {}\", s.as_str(), e);\n-                                sess.struct_span_err(*op_sp, &msg).emit();\n-                                asm::InlineAsmReg::Err\n-                            })\n-                        } else {\n-                            asm::InlineAsmReg::Err\n-                        })\n-                    }\n-                    InlineAsmRegOrRegClass::RegClass(s) => {\n-                        asm::InlineAsmRegOrRegClass::RegClass(if let Some(asm_arch) = asm_arch {\n-                            asm::InlineAsmRegClass::parse(asm_arch, s).unwrap_or_else(|e| {\n-                                let msg = format!(\"invalid register class `{}`: {}\", s.as_str(), e);\n-                                sess.struct_span_err(*op_sp, &msg).emit();\n-                                asm::InlineAsmRegClass::Err\n-                            })\n-                        } else {\n-                            asm::InlineAsmRegClass::Err\n-                        })\n-                    }\n-                };\n-\n-                let op = match *op {\n-                    InlineAsmOperand::In { reg, ref expr } => hir::InlineAsmOperand::In {\n-                        reg: lower_reg(reg),\n-                        expr: self.lower_expr_mut(expr),\n-                    },\n-                    InlineAsmOperand::Out { reg, late, ref expr } => hir::InlineAsmOperand::Out {\n-                        reg: lower_reg(reg),\n-                        late,\n-                        expr: expr.as_ref().map(|expr| self.lower_expr_mut(expr)),\n-                    },\n-                    InlineAsmOperand::InOut { reg, late, ref expr } => {\n-                        hir::InlineAsmOperand::InOut {\n-                            reg: lower_reg(reg),\n-                            late,\n-                            expr: self.lower_expr_mut(expr),\n-                        }\n-                    }\n-                    InlineAsmOperand::SplitInOut { reg, late, ref in_expr, ref out_expr } => {\n-                        hir::InlineAsmOperand::SplitInOut {\n-                            reg: lower_reg(reg),\n-                            late,\n-                            in_expr: self.lower_expr_mut(in_expr),\n-                            out_expr: out_expr.as_ref().map(|expr| self.lower_expr_mut(expr)),\n-                        }\n-                    }\n-                    InlineAsmOperand::Const { ref expr } => {\n-                        hir::InlineAsmOperand::Const { expr: self.lower_expr_mut(expr) }\n-                    }\n-                    InlineAsmOperand::Sym { ref expr } => {\n-                        hir::InlineAsmOperand::Sym { expr: self.lower_expr_mut(expr) }\n-                    }\n-                };\n-                (op, *op_sp)\n-            })\n-            .collect();\n-\n-        // Validate template modifiers against the register classes for the operands\n-        for p in &asm.template {\n-            if let InlineAsmTemplatePiece::Placeholder {\n-                operand_idx,\n-                modifier: Some(modifier),\n-                span: placeholder_span,\n-            } = *p\n-            {\n-                let op_sp = asm.operands[operand_idx].1;\n-                match &operands[operand_idx].0 {\n-                    hir::InlineAsmOperand::In { reg, .. }\n-                    | hir::InlineAsmOperand::Out { reg, .. }\n-                    | hir::InlineAsmOperand::InOut { reg, .. }\n-                    | hir::InlineAsmOperand::SplitInOut { reg, .. } => {\n-                        let class = reg.reg_class();\n-                        if class == asm::InlineAsmRegClass::Err {\n-                            continue;\n-                        }\n-                        let valid_modifiers = class.valid_modifiers(asm_arch.unwrap());\n-                        if !valid_modifiers.contains(&modifier) {\n-                            let mut err = sess.struct_span_err(\n-                                placeholder_span,\n-                                \"invalid asm template modifier for this register class\",\n-                            );\n-                            err.span_label(placeholder_span, \"template modifier\");\n-                            err.span_label(op_sp, \"argument\");\n-                            if !valid_modifiers.is_empty() {\n-                                let mut mods = format!(\"`{}`\", valid_modifiers[0]);\n-                                for m in &valid_modifiers[1..] {\n-                                    let _ = write!(mods, \", `{}`\", m);\n-                                }\n-                                err.note(&format!(\n-                                    \"the `{}` register class supports \\\n-                                     the following template modifiers: {}\",\n-                                    class.name(),\n-                                    mods\n-                                ));\n-                            } else {\n-                                err.note(&format!(\n-                                    \"the `{}` register class does not support template modifiers\",\n-                                    class.name()\n-                                ));\n-                            }\n-                            err.emit();\n-                        }\n-                    }\n-                    hir::InlineAsmOperand::Const { .. } => {\n-                        let mut err = sess.struct_span_err(\n-                            placeholder_span,\n-                            \"asm template modifiers are not allowed for `const` arguments\",\n-                        );\n-                        err.span_label(placeholder_span, \"template modifier\");\n-                        err.span_label(op_sp, \"argument\");\n-                        err.emit();\n-                    }\n-                    hir::InlineAsmOperand::Sym { .. } => {\n-                        let mut err = sess.struct_span_err(\n-                            placeholder_span,\n-                            \"asm template modifiers are not allowed for `sym` arguments\",\n-                        );\n-                        err.span_label(placeholder_span, \"template modifier\");\n-                        err.span_label(op_sp, \"argument\");\n-                        err.emit();\n-                    }\n-                }\n-            }\n-        }\n-\n-        let mut used_input_regs = FxHashMap::default();\n-        let mut used_output_regs = FxHashMap::default();\n-        let mut required_features: Vec<&str> = vec![];\n-        for (idx, &(ref op, op_sp)) in operands.iter().enumerate() {\n-            if let Some(reg) = op.reg() {\n-                // Make sure we don't accidentally carry features from the\n-                // previous iteration.\n-                required_features.clear();\n-\n-                // Validate register classes against currently enabled target\n-                // features. We check that at least one type is available for\n-                // the current target.\n-                let reg_class = reg.reg_class();\n-                if reg_class == asm::InlineAsmRegClass::Err {\n-                    continue;\n-                }\n-                for &(_, feature) in reg_class.supported_types(asm_arch.unwrap()) {\n-                    if let Some(feature) = feature {\n-                        if self.sess.target_features.contains(&Symbol::intern(feature)) {\n-                            required_features.clear();\n-                            break;\n-                        } else {\n-                            required_features.push(feature);\n-                        }\n-                    } else {\n-                        required_features.clear();\n-                        break;\n-                    }\n-                }\n-                // We are sorting primitive strs here and can use unstable sort here\n-                required_features.sort_unstable();\n-                required_features.dedup();\n-                match &required_features[..] {\n-                    [] => {}\n-                    [feature] => {\n-                        let msg = format!(\n-                            \"register class `{}` requires the `{}` target feature\",\n-                            reg_class.name(),\n-                            feature\n-                        );\n-                        sess.struct_span_err(op_sp, &msg).emit();\n-                    }\n-                    features => {\n-                        let msg = format!(\n-                            \"register class `{}` requires at least one target feature: {}\",\n-                            reg_class.name(),\n-                            features.join(\", \")\n-                        );\n-                        sess.struct_span_err(op_sp, &msg).emit();\n-                    }\n-                }\n-\n-                // Check for conflicts between explicit register operands.\n-                if let asm::InlineAsmRegOrRegClass::Reg(reg) = reg {\n-                    let (input, output) = match op {\n-                        hir::InlineAsmOperand::In { .. } => (true, false),\n-                        // Late output do not conflict with inputs, but normal outputs do\n-                        hir::InlineAsmOperand::Out { late, .. } => (!late, true),\n-                        hir::InlineAsmOperand::InOut { .. }\n-                        | hir::InlineAsmOperand::SplitInOut { .. } => (true, true),\n-                        hir::InlineAsmOperand::Const { .. } | hir::InlineAsmOperand::Sym { .. } => {\n-                            unreachable!()\n-                        }\n-                    };\n-\n-                    // Flag to output the error only once per operand\n-                    let mut skip = false;\n-                    reg.overlapping_regs(|r| {\n-                        let mut check = |used_regs: &mut FxHashMap<asm::InlineAsmReg, usize>,\n-                                         input| {\n-                            match used_regs.entry(r) {\n-                                Entry::Occupied(o) => {\n-                                    if skip {\n-                                        return;\n-                                    }\n-                                    skip = true;\n-\n-                                    let idx2 = *o.get();\n-                                    let &(ref op2, op_sp2) = &operands[idx2];\n-                                    let reg2 = match op2.reg() {\n-                                        Some(asm::InlineAsmRegOrRegClass::Reg(r)) => r,\n-                                        _ => unreachable!(),\n-                                    };\n-\n-                                    let msg = format!(\n-                                        \"register `{}` conflicts with register `{}`\",\n-                                        reg.name(),\n-                                        reg2.name()\n-                                    );\n-                                    let mut err = sess.struct_span_err(op_sp, &msg);\n-                                    err.span_label(op_sp, &format!(\"register `{}`\", reg.name()));\n-                                    err.span_label(op_sp2, &format!(\"register `{}`\", reg2.name()));\n-\n-                                    match (op, op2) {\n-                                        (\n-                                            hir::InlineAsmOperand::In { .. },\n-                                            hir::InlineAsmOperand::Out { late, .. },\n-                                        )\n-                                        | (\n-                                            hir::InlineAsmOperand::Out { late, .. },\n-                                            hir::InlineAsmOperand::In { .. },\n-                                        ) => {\n-                                            assert!(!*late);\n-                                            let out_op_sp = if input { op_sp2 } else { op_sp };\n-                                            let msg = \"use `lateout` instead of \\\n-                                                    `out` to avoid conflict\";\n-                                            err.span_help(out_op_sp, msg);\n-                                        }\n-                                        _ => {}\n-                                    }\n-\n-                                    err.emit();\n-                                }\n-                                Entry::Vacant(v) => {\n-                                    v.insert(idx);\n-                                }\n-                            }\n-                        };\n-                        if input {\n-                            check(&mut used_input_regs, true);\n-                        }\n-                        if output {\n-                            check(&mut used_output_regs, false);\n-                        }\n-                    });\n-                }\n-            }\n-        }\n-\n-        let operands = self.arena.alloc_from_iter(operands);\n-        let template = self.arena.alloc_from_iter(asm.template.iter().cloned());\n-        let line_spans = self.arena.alloc_slice(&asm.line_spans[..]);\n-        let hir_asm = hir::InlineAsm { template, operands, options: asm.options, line_spans };\n-        hir::ExprKind::InlineAsm(self.arena.alloc(hir_asm))\n-    }\n-\n     fn lower_expr_llvm_asm(&mut self, asm: &LlvmInlineAsm) -> hir::ExprKind<'hir> {\n         let inner = hir::LlvmInlineAsmInner {\n             inputs: asm.inputs.iter().map(|&(c, _)| c).collect(),\n@@ -1878,14 +1579,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             self.allow_try_trait.clone(),\n         );\n \n-        // `Try::into_result(<expr>)`\n+        // `Try::branch(<expr>)`\n         let scrutinee = {\n             // expand <expr>\n             let sub_expr = self.lower_expr_mut(sub_expr);\n \n             self.expr_call_lang_item_fn(\n                 unstable_span,\n-                hir::LangItem::TryIntoResult,\n+                hir::LangItem::TryTraitBranch,\n                 arena_vec![self; sub_expr],\n             )\n         };\n@@ -1903,8 +1604,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         };\n         let attrs = vec![attr];\n \n-        // `Ok(val) => #[allow(unreachable_code)] val,`\n-        let ok_arm = {\n+        // `ControlFlow::Continue(val) => #[allow(unreachable_code)] val,`\n+        let continue_arm = {\n             let val_ident = Ident::with_dummy_span(sym::val);\n             let (val_pat, val_pat_nid) = self.pat_ident(span, val_ident);\n             let val_expr = self.arena.alloc(self.expr_ident_with_attrs(\n@@ -1913,27 +1614,21 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 val_pat_nid,\n                 ThinVec::from(attrs.clone()),\n             ));\n-            let ok_pat = self.pat_ok(span, val_pat);\n-            self.arm(ok_pat, val_expr)\n+            let continue_pat = self.pat_cf_continue(unstable_span, val_pat);\n+            self.arm(continue_pat, val_expr)\n         };\n \n-        // `Err(err) => #[allow(unreachable_code)]\n-        //              return Try::from_error(From::from(err)),`\n-        let err_arm = {\n-            let err_ident = Ident::with_dummy_span(sym::err);\n-            let (err_local, err_local_nid) = self.pat_ident(try_span, err_ident);\n-            let from_expr = {\n-                let err_expr = self.expr_ident_mut(try_span, err_ident, err_local_nid);\n-                self.expr_call_lang_item_fn(\n-                    try_span,\n-                    hir::LangItem::FromFrom,\n-                    arena_vec![self; err_expr],\n-                )\n-            };\n-            let from_err_expr = self.wrap_in_try_constructor(\n-                hir::LangItem::TryFromError,\n-                unstable_span,\n-                from_expr,\n+        // `ControlFlow::Break(residual) =>\n+        //     #[allow(unreachable_code)]\n+        //     return Try::from_residual(residual),`\n+        let break_arm = {\n+            let residual_ident = Ident::with_dummy_span(sym::residual);\n+            let (residual_local, residual_local_nid) = self.pat_ident(try_span, residual_ident);\n+            let residual_expr = self.expr_ident_mut(try_span, residual_ident, residual_local_nid);\n+            let from_residual_expr = self.wrap_in_try_constructor(\n+                hir::LangItem::TryTraitFromResidual,\n+                try_span,\n+                self.arena.alloc(residual_expr),\n                 unstable_span,\n             );\n             let thin_attrs = ThinVec::from(attrs);\n@@ -1944,25 +1639,25 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     try_span,\n                     hir::ExprKind::Break(\n                         hir::Destination { label: None, target_id },\n-                        Some(from_err_expr),\n+                        Some(from_residual_expr),\n                     ),\n                     thin_attrs,\n                 ))\n             } else {\n                 self.arena.alloc(self.expr(\n                     try_span,\n-                    hir::ExprKind::Ret(Some(from_err_expr)),\n+                    hir::ExprKind::Ret(Some(from_residual_expr)),\n                     thin_attrs,\n                 ))\n             };\n \n-            let err_pat = self.pat_err(try_span, err_local);\n-            self.arm(err_pat, ret_expr)\n+            let break_pat = self.pat_cf_break(try_span, residual_local);\n+            self.arm(break_pat, ret_expr)\n         };\n \n         hir::ExprKind::Match(\n             scrutinee,\n-            arena_vec![self; err_arm, ok_arm],\n+            arena_vec![self; break_arm, continue_arm],\n             hir::MatchSource::TryDesugar,\n         )\n     }"}, {"sha": "292643d6d7510821cdbf653455290170dda6bd86", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -329,7 +329,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         .alloc_from_iter(fm.items.iter().map(|x| self.lower_foreign_item_ref(x))),\n                 }\n             }\n-            ItemKind::GlobalAsm(ref ga) => hir::ItemKind::GlobalAsm(self.lower_global_asm(ga)),\n+            ItemKind::GlobalAsm(ref asm) => {\n+                hir::ItemKind::GlobalAsm(self.lower_inline_asm(span, asm))\n+            }\n             ItemKind::TyAlias(box TyAliasKind(_, ref gen, _, Some(ref ty))) => {\n                 // We lower\n                 //\n@@ -746,10 +748,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n     }\n \n-    fn lower_global_asm(&mut self, ga: &GlobalAsm) -> &'hir hir::GlobalAsm {\n-        self.arena.alloc(hir::GlobalAsm { asm: ga.asm })\n-    }\n-\n     fn lower_variant(&mut self, v: &Variant) -> hir::Variant<'hir> {\n         let id = self.lower_node_id(v.id);\n         self.lower_attrs(id, &v.attrs);\n@@ -791,7 +789,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n     }\n \n-    fn lower_field_def(&mut self, (index, f): (usize, &FieldDef)) -> hir::FieldDef<'hir> {\n+    pub(super) fn lower_field_def(\n+        &mut self,\n+        (index, f): (usize, &FieldDef),\n+    ) -> hir::FieldDef<'hir> {\n         let ty = if let TyKind::Path(ref qself, ref path) = f.ty.kind {\n             let t = self.lower_path_ty(\n                 &f.ty,\n@@ -836,9 +837,17 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 (generics, hir::TraitItemKind::Fn(sig, hir::TraitFn::Required(names)))\n             }\n             AssocItemKind::Fn(box FnKind(_, ref sig, ref generics, Some(ref body))) => {\n-                let body_id = self.lower_fn_body_block(i.span, &sig.decl, Some(body));\n-                let (generics, sig) =\n-                    self.lower_method_sig(generics, sig, trait_item_def_id, false, None, i.id);\n+                let asyncness = sig.header.asyncness;\n+                let body_id =\n+                    self.lower_maybe_async_body(i.span, &sig.decl, asyncness, Some(&body));\n+                let (generics, sig) = self.lower_method_sig(\n+                    generics,\n+                    sig,\n+                    trait_item_def_id,\n+                    false,\n+                    asyncness.opt_return_id(),\n+                    i.id,\n+                );\n                 (generics, hir::TraitItemKind::Fn(sig, hir::TraitFn::Provided(body_id)))\n             }\n             AssocItemKind::TyAlias(box TyAliasKind(_, ref generics, ref bounds, ref default)) => {"}, {"sha": "6f1772ff8188da778b446e935f5e591dbc3ce8c3", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 61, "deletions": 85, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -31,22 +31,21 @@\n //! in the HIR, especially for multiple identifiers.\n \n #![feature(crate_visibility_modifier)]\n-#![cfg_attr(bootstrap, feature(or_patterns))]\n #![feature(box_patterns)]\n #![feature(iter_zip)]\n #![recursion_limit = \"256\"]\n \n use rustc_ast::node_id::NodeMap;\n-use rustc_ast::token::{self, DelimToken, Nonterminal, Token};\n-use rustc_ast::tokenstream::{CanSynthesizeMissingTokens, DelimSpan, TokenStream, TokenTree};\n+use rustc_ast::token::{self, Token};\n+use rustc_ast::tokenstream::{CanSynthesizeMissingTokens, TokenStream, TokenTree};\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n use rustc_ast::walk_list;\n use rustc_ast::{self as ast, *};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::struct_span_err;\n+use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Namespace, PartialRes, PerNS, Res};\n use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId, CRATE_DEF_ID};\n@@ -56,12 +55,13 @@ use rustc_hir::{ConstArg, GenericArg, ParamName};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_session::lint::builtin::{BARE_TRAIT_OBJECTS, MISSING_ABI};\n use rustc_session::lint::{BuiltinLintDiagnostics, LintBuffer};\n-use rustc_session::parse::ParseSess;\n+use rustc_session::utils::{FlattenNonterminals, NtToTokenstream};\n use rustc_session::Session;\n+use rustc_span::edition::Edition;\n use rustc_span::hygiene::ExpnId;\n use rustc_span::source_map::{respan, DesugaringKind};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::Span;\n+use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::abi::Abi;\n \n use smallvec::{smallvec, SmallVec};\n@@ -76,6 +76,7 @@ macro_rules! arena_vec {\n     });\n }\n \n+mod asm;\n mod expr;\n mod item;\n mod pat;\n@@ -93,7 +94,7 @@ struct LoweringContext<'a, 'hir: 'a> {\n \n     /// HACK(Centril): there is a cyclic dependency between the parser and lowering\n     /// if we don't have this function pointer. To avoid that dependency so that\n-    /// librustc_middle is independent of the parser, we use dynamic dispatch here.\n+    /// `rustc_middle` is independent of the parser, we use dynamic dispatch here.\n     nt_to_tokenstream: NtToTokenstream,\n \n     /// Used to allocate HIR nodes.\n@@ -165,7 +166,7 @@ struct LoweringContext<'a, 'hir: 'a> {\n \n     type_def_lifetime_params: DefIdMap<usize>,\n \n-    current_hir_id_owner: Vec<(LocalDefId, u32)>,\n+    current_hir_id_owner: (LocalDefId, u32),\n     item_local_id_counters: NodeMap<u32>,\n     node_id_to_hir_id: IndexVec<NodeId, Option<hir::HirId>>,\n \n@@ -213,8 +214,6 @@ pub trait ResolverAstLowering {\n     ) -> LocalDefId;\n }\n \n-type NtToTokenstream = fn(&Nonterminal, &ParseSess, CanSynthesizeMissingTokens) -> TokenStream;\n-\n /// Context of `impl Trait` in code, which determines whether it is allowed in an HIR subtree,\n /// and if so, what meaning it has.\n #[derive(Debug)]\n@@ -323,7 +322,7 @@ pub fn lower_crate<'a, 'hir>(\n         anonymous_lifetime_mode: AnonymousLifetimeMode::PassThrough,\n         type_def_lifetime_params: Default::default(),\n         current_module: CRATE_DEF_ID,\n-        current_hir_id_owner: vec![(CRATE_DEF_ID, 0)],\n+        current_hir_id_owner: (CRATE_DEF_ID, 0),\n         item_local_id_counters: Default::default(),\n         node_id_to_hir_id: IndexVec::new(),\n         generator_kind: None,\n@@ -332,7 +331,7 @@ pub fn lower_crate<'a, 'hir>(\n         lifetimes_to_define: Vec::new(),\n         is_collecting_in_band_lifetimes: false,\n         in_scope_lifetimes: Vec::new(),\n-        allow_try_trait: Some([sym::try_trait][..].into()),\n+        allow_try_trait: Some([sym::control_flow_enum, sym::try_trait_v2][..].into()),\n         allow_gen_future: Some([sym::gen_future][..].into()),\n     }\n     .lower_crate(krate)\n@@ -403,42 +402,6 @@ enum AnonymousLifetimeMode {\n     PassThrough,\n }\n \n-struct TokenStreamLowering<'a> {\n-    parse_sess: &'a ParseSess,\n-    synthesize_tokens: CanSynthesizeMissingTokens,\n-    nt_to_tokenstream: NtToTokenstream,\n-}\n-\n-impl<'a> TokenStreamLowering<'a> {\n-    fn lower_token_stream(&mut self, tokens: TokenStream) -> TokenStream {\n-        tokens.into_trees().flat_map(|tree| self.lower_token_tree(tree).into_trees()).collect()\n-    }\n-\n-    fn lower_token_tree(&mut self, tree: TokenTree) -> TokenStream {\n-        match tree {\n-            TokenTree::Token(token) => self.lower_token(token),\n-            TokenTree::Delimited(span, delim, tts) => {\n-                TokenTree::Delimited(span, delim, self.lower_token_stream(tts)).into()\n-            }\n-        }\n-    }\n-\n-    fn lower_token(&mut self, token: Token) -> TokenStream {\n-        match token.kind {\n-            token::Interpolated(nt) => {\n-                let tts = (self.nt_to_tokenstream)(&nt, self.parse_sess, self.synthesize_tokens);\n-                TokenTree::Delimited(\n-                    DelimSpan::from_single(token.span),\n-                    DelimToken::NoDelim,\n-                    self.lower_token_stream(tts),\n-                )\n-                .into()\n-            }\n-            _ => TokenTree::Token(token).into(),\n-        }\n-    }\n-}\n-\n impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_crate(mut self, c: &Crate) -> hir::Crate<'hir> {\n         /// Full-crate AST visitor that inserts into a fresh\n@@ -569,7 +532,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n \n         hir::Crate {\n-            item: hir::CrateItem { module, span: c.span },\n+            item: module,\n             exported_macros: self.arena.alloc_from_iter(self.exported_macros),\n             non_exported_macro_attrs: self.arena.alloc_from_iter(self.non_exported_macro_attrs),\n             items: self.items,\n@@ -632,9 +595,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             .insert(owner, HIR_ID_COUNTER_LOCKED)\n             .unwrap_or_else(|| panic!(\"no `item_local_id_counters` entry for {:?}\", owner));\n         let def_id = self.resolver.local_def_id(owner);\n-        self.current_hir_id_owner.push((def_id, counter));\n+        let old_owner = std::mem::replace(&mut self.current_hir_id_owner, (def_id, counter));\n         let ret = f(self);\n-        let (new_def_id, new_counter) = self.current_hir_id_owner.pop().unwrap();\n+        let (new_def_id, new_counter) =\n+            std::mem::replace(&mut self.current_hir_id_owner, old_owner);\n \n         debug_assert!(def_id == new_def_id);\n         debug_assert!(new_counter >= counter);\n@@ -652,8 +616,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// properly. Calling the method twice with the same `NodeId` is fine though.\n     fn lower_node_id(&mut self, ast_node_id: NodeId) -> hir::HirId {\n         self.lower_node_id_generic(ast_node_id, |this| {\n-            let &mut (owner, ref mut local_id_counter) =\n-                this.current_hir_id_owner.last_mut().unwrap();\n+            let &mut (owner, ref mut local_id_counter) = &mut this.current_hir_id_owner;\n             let local_id = *local_id_counter;\n             *local_id_counter += 1;\n             hir::HirId { owner, local_id: hir::ItemLocalId::from_u32(local_id) }\n@@ -906,10 +869,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // wouldn't have been added yet.\n                     let generics = this.lower_generics_mut(\n                         generics,\n-                        ImplTraitContext::Universal(\n-                            &mut params,\n-                            this.current_hir_id_owner.last().unwrap().0,\n-                        ),\n+                        ImplTraitContext::Universal(&mut params, this.current_hir_id_owner.0),\n                     );\n                     let res = f(this, &mut params);\n                     (params, (generics, res))\n@@ -1037,12 +997,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     }\n                 }\n \n-                let tokens = TokenStreamLowering {\n+                let tokens = FlattenNonterminals {\n                     parse_sess: &self.sess.parse_sess,\n                     synthesize_tokens: CanSynthesizeMissingTokens::Yes,\n                     nt_to_tokenstream: self.nt_to_tokenstream,\n                 }\n-                .lower_token(token.clone());\n+                .process_token(token.clone());\n                 MacArgs::Eq(eq_span, unwrap_single_token(self.sess, tokens, token.span))\n             }\n         }\n@@ -1053,12 +1013,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         tokens: TokenStream,\n         synthesize_tokens: CanSynthesizeMissingTokens,\n     ) -> TokenStream {\n-        TokenStreamLowering {\n+        FlattenNonterminals {\n             parse_sess: &self.sess.parse_sess,\n             synthesize_tokens,\n             nt_to_tokenstream: self.nt_to_tokenstream,\n         }\n-        .lower_token_stream(tokens)\n+        .process_token_stream(tokens)\n     }\n \n     /// Given an associated type constraint like one of these:\n@@ -1115,7 +1075,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n             AssocTyConstraintKind::Bound { ref bounds } => {\n                 let mut capturable_lifetimes;\n-                let mut parent_def_id = self.current_hir_id_owner.last().unwrap().0;\n+                let mut parent_def_id = self.current_hir_id_owner.0;\n                 // Piggy-back on the `impl Trait` context to figure out the correct behavior.\n                 let (desugar_to_impl_trait, itctx) = match itctx {\n                     // We are in the return position:\n@@ -1236,7 +1196,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                             // Construct a AnonConst where the expr is the \"ty\"'s path.\n \n-                            let parent_def_id = self.current_hir_id_owner.last().unwrap().0;\n+                            let parent_def_id = self.current_hir_id_owner.0;\n                             let node_id = self.resolver.next_node_id();\n \n                             // Add a definition for the in-band const def.\n@@ -1306,6 +1266,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let kind = match t.kind {\n             TyKind::Infer => hir::TyKind::Infer,\n             TyKind::Err => hir::TyKind::Err,\n+            // FIXME(unnamed_fields): IMPLEMENTATION IN PROGRESS\n+            TyKind::AnonymousStruct(ref _fields, _recovered) => {\n+                self.sess.struct_span_err(t.span, \"anonymous structs are unimplemented\").emit();\n+                hir::TyKind::Err\n+            }\n+            TyKind::AnonymousUnion(ref _fields, _recovered) => {\n+                self.sess.struct_span_err(t.span, \"anonymous unions are unimplemented\").emit();\n+                hir::TyKind::Err\n+            }\n             TyKind::Slice(ref ty) => hir::TyKind::Slice(self.lower_ty(ty, itctx)),\n             TyKind::Ptr(ref mt) => hir::TyKind::Ptr(self.lower_mt(mt, itctx)),\n             TyKind::Rptr(ref region, ref mt) => {\n@@ -1852,10 +1821,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 if let Some((_, ibty)) = &mut in_band_ty_params {\n                     this.lower_ty_direct(\n                         &param.ty,\n-                        ImplTraitContext::Universal(\n-                            ibty,\n-                            this.current_hir_id_owner.last().unwrap().0,\n-                        ),\n+                        ImplTraitContext::Universal(ibty, this.current_hir_id_owner.0),\n                     )\n                 } else {\n                     this.lower_ty_direct(&param.ty, ImplTraitContext::disallowed())\n@@ -2127,6 +2093,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             args: &[],\n             bindings: arena_vec![self; self.output_ty_binding(span, output_ty)],\n             parenthesized: false,\n+            span_ext: DUMMY_SP,\n         });\n \n         hir::GenericBound::LangItemTrait(\n@@ -2259,13 +2226,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                 let kind = hir::GenericParamKind::Type {\n                     default: default.as_ref().map(|x| {\n-                        self.lower_ty(\n-                            x,\n-                            ImplTraitContext::OtherOpaqueTy {\n-                                capturable_lifetimes: &mut FxHashSet::default(),\n-                                origin: hir::OpaqueTyOrigin::Misc,\n-                            },\n-                        )\n+                        self.lower_ty(x, ImplTraitContext::Disallowed(ImplTraitPosition::Other))\n                     }),\n                     synthetic: param\n                         .attrs\n@@ -2528,14 +2489,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.pat(span, hir::PatKind::Lit(expr))\n     }\n \n-    fn pat_ok(&mut self, span: Span, pat: &'hir hir::Pat<'hir>) -> &'hir hir::Pat<'hir> {\n+    fn pat_cf_continue(&mut self, span: Span, pat: &'hir hir::Pat<'hir>) -> &'hir hir::Pat<'hir> {\n         let field = self.single_pat_field(span, pat);\n-        self.pat_lang_item_variant(span, hir::LangItem::ResultOk, field)\n+        self.pat_lang_item_variant(span, hir::LangItem::ControlFlowContinue, field)\n     }\n \n-    fn pat_err(&mut self, span: Span, pat: &'hir hir::Pat<'hir>) -> &'hir hir::Pat<'hir> {\n+    fn pat_cf_break(&mut self, span: Span, pat: &'hir hir::Pat<'hir>) -> &'hir hir::Pat<'hir> {\n         let field = self.single_pat_field(span, pat);\n-        self.pat_lang_item_variant(span, hir::LangItem::ResultErr, field)\n+        self.pat_lang_item_variant(span, hir::LangItem::ControlFlowBreak, field)\n     }\n \n     fn pat_some(&mut self, span: Span, pat: &'hir hir::Pat<'hir>) -> &'hir hir::Pat<'hir> {\n@@ -2780,13 +2741,26 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             .map(|snippet| snippet.starts_with(\"#[\"))\n             .unwrap_or(true);\n         if !is_macro_callsite {\n-            self.resolver.lint_buffer().buffer_lint_with_diagnostic(\n-                BARE_TRAIT_OBJECTS,\n-                id,\n-                span,\n-                \"trait objects without an explicit `dyn` are deprecated\",\n-                BuiltinLintDiagnostics::BareTraitObject(span, is_global),\n-            )\n+            if span.edition() < Edition::Edition2021 {\n+                self.resolver.lint_buffer().buffer_lint_with_diagnostic(\n+                    BARE_TRAIT_OBJECTS,\n+                    id,\n+                    span,\n+                    \"trait objects without an explicit `dyn` are deprecated\",\n+                    BuiltinLintDiagnostics::BareTraitObject(span, is_global),\n+                )\n+            } else {\n+                let msg = \"trait objects must include the `dyn` keyword\";\n+                let label = \"add `dyn` keyword before this trait\";\n+                let mut err = struct_span_err!(self.sess, span, E0782, \"{}\", msg,);\n+                err.span_suggestion_verbose(\n+                    span.shrink_to_lo(),\n+                    label,\n+                    String::from(\"dyn \"),\n+                    Applicability::MachineApplicable,\n+                );\n+                err.emit();\n+            }\n         }\n     }\n \n@@ -2824,6 +2798,7 @@ struct GenericArgsCtor<'hir> {\n     args: SmallVec<[hir::GenericArg<'hir>; 4]>,\n     bindings: &'hir [hir::TypeBinding<'hir>],\n     parenthesized: bool,\n+    span: Span,\n }\n \n impl<'hir> GenericArgsCtor<'hir> {\n@@ -2836,6 +2811,7 @@ impl<'hir> GenericArgsCtor<'hir> {\n             args: arena.alloc_from_iter(self.args),\n             bindings: self.bindings,\n             parenthesized: self.parenthesized,\n+            span_ext: self.span,\n         }\n     }\n }"}, {"sha": "fe9f1fb20f05608fe21bc43ffe957ee80a52d6ea", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 49, "deletions": 23, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -10,7 +10,7 @@ use rustc_hir::GenericArg;\n use rustc_session::lint::builtin::ELIDED_LIFETIMES_IN_PATHS;\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_span::symbol::Ident;\n-use rustc_span::Span;\n+use rustc_span::{BytePos, Span, DUMMY_SP};\n \n use smallvec::smallvec;\n use tracing::debug;\n@@ -24,6 +24,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         param_mode: ParamMode,\n         mut itctx: ImplTraitContext<'_, 'hir>,\n     ) -> hir::QPath<'hir> {\n+        debug!(\"lower_qpath(id: {:?}, qself: {:?}, p: {:?})\", id, qself, p);\n         let qself_position = qself.as_ref().map(|q| q.position);\n         let qself = qself.as_ref().map(|q| self.lower_ty(&q.ty, itctx.reborrow()));\n \n@@ -222,6 +223,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         itctx: ImplTraitContext<'_, 'hir>,\n         explicit_owner: Option<NodeId>,\n     ) -> hir::PathSegment<'hir> {\n+        debug!(\n+            \"path_span: {:?}, lower_path_segment(segment: {:?}, expected_lifetimes: {:?})\",\n+            path_span, segment, expected_lifetimes\n+        );\n         let (mut generic_args, infer_args) = if let Some(ref generic_args) = segment.args {\n             let msg = \"parenthesized type parameters may only be used with a `Fn` trait\";\n             match **generic_args {\n@@ -262,23 +267,34 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 },\n             }\n         } else {\n-            self.lower_angle_bracketed_parameter_data(&Default::default(), param_mode, itctx)\n+            (\n+                GenericArgsCtor {\n+                    args: Default::default(),\n+                    bindings: &[],\n+                    parenthesized: false,\n+                    span: path_span.shrink_to_hi(),\n+                },\n+                param_mode == ParamMode::Optional,\n+            )\n         };\n \n         let has_lifetimes =\n             generic_args.args.iter().any(|arg| matches!(arg, GenericArg::Lifetime(_)));\n-        let first_generic_span = generic_args\n-            .args\n-            .iter()\n-            .map(|a| a.span())\n-            .chain(generic_args.bindings.iter().map(|b| b.span))\n-            .next();\n         if !generic_args.parenthesized && !has_lifetimes {\n+            // Note: these spans are used for diagnostics when they can't be inferred.\n+            // See rustc_resolve::late::lifetimes::LifetimeContext::add_missing_lifetime_specifiers_label\n+            let elided_lifetime_span = if generic_args.span.is_empty() {\n+                // If there are no brackets, use the identifier span.\n+                segment.ident.span\n+            } else if generic_args.is_empty() {\n+                // If there are brackets, but not generic arguments, then use the opening bracket\n+                generic_args.span.with_hi(generic_args.span.lo() + BytePos(1))\n+            } else {\n+                // Else use an empty span right after the opening bracket.\n+                generic_args.span.with_lo(generic_args.span.lo() + BytePos(1)).shrink_to_lo()\n+            };\n             generic_args.args = self\n-                .elided_path_lifetimes(\n-                    first_generic_span.map_or(segment.ident.span, |s| s.shrink_to_lo()),\n-                    expected_lifetimes,\n-                )\n+                .elided_path_lifetimes(elided_lifetime_span, expected_lifetimes)\n                 .map(GenericArg::Lifetime)\n                 .chain(generic_args.args.into_iter())\n                 .collect();\n@@ -287,15 +303,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 let no_non_lt_args = generic_args.args.len() == expected_lifetimes;\n                 let no_bindings = generic_args.bindings.is_empty();\n                 let (incl_angl_brckt, insertion_sp, suggestion) = if no_non_lt_args && no_bindings {\n-                    // If there are no (non-implicit) generic args or associated type\n-                    // bindings, our suggestion includes the angle brackets.\n+                    // If there are no generic args, our suggestion can include the angle brackets.\n                     (true, path_span.shrink_to_hi(), format!(\"<{}>\", anon_lt_suggestion))\n                 } else {\n-                    // Otherwise (sorry, this is kind of gross) we need to infer the\n-                    // place to splice in the `'_, ` from the generics that do exist.\n-                    let first_generic_span = first_generic_span\n-                        .expect(\"already checked that non-lifetime args or bindings exist\");\n-                    (false, first_generic_span.shrink_to_lo(), format!(\"{}, \", anon_lt_suggestion))\n+                    // Otherwise we'll insert a `'_, ` right after the opening bracket.\n+                    let span = generic_args\n+                        .span\n+                        .with_lo(generic_args.span.lo() + BytePos(1))\n+                        .shrink_to_lo();\n+                    (false, span, format!(\"{}, \", anon_lt_suggestion))\n                 };\n                 match self.anonymous_lifetime_mode {\n                     // In create-parameter mode we error here because we don't want to support\n@@ -357,7 +373,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             hir_id: Some(id),\n             res: Some(self.lower_res(res)),\n             infer_args,\n-            args: if generic_args.is_empty() {\n+            args: if generic_args.is_empty() && generic_args.span.is_empty() {\n                 None\n             } else {\n                 Some(self.arena.alloc(generic_args.into_generic_args(self.arena)))\n@@ -390,7 +406,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n             AngleBracketedArg::Arg(_) => None,\n         }));\n-        let ctor = GenericArgsCtor { args, bindings, parenthesized: false };\n+        let ctor = GenericArgsCtor { args, bindings, parenthesized: false, span: data.span };\n         (ctor, !has_non_lt_args && param_mode == ParamMode::Optional)\n     }\n \n@@ -415,7 +431,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             let args = smallvec![GenericArg::Type(this.ty_tup(*inputs_span, inputs))];\n             let binding = this.output_ty_binding(output_ty.span, output_ty);\n             (\n-                GenericArgsCtor { args, bindings: arena_vec![this; binding], parenthesized: true },\n+                GenericArgsCtor {\n+                    args,\n+                    bindings: arena_vec![this; binding],\n+                    parenthesized: true,\n+                    span: data.inputs_span,\n+                },\n                 false,\n             )\n         })\n@@ -431,7 +452,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let kind = hir::TypeBindingKind::Equality { ty };\n         let args = arena_vec![self;];\n         let bindings = arena_vec![self;];\n-        let gen_args = self.arena.alloc(hir::GenericArgs { args, bindings, parenthesized: false });\n+        let gen_args = self.arena.alloc(hir::GenericArgs {\n+            args,\n+            bindings,\n+            parenthesized: false,\n+            span_ext: DUMMY_SP,\n+        });\n         hir::TypeBinding { hir_id: self.next_id(), gen_args, span, ident, kind }\n     }\n }"}, {"sha": "ba2da7694978d9791f5326da3eee0b179e38da11", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 243, "deletions": 82, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -175,10 +175,30 @@ impl<'a> AstValidator<'a> {\n                     }\n                 }\n             }\n+            TyKind::AnonymousStruct(ref fields, ..) | TyKind::AnonymousUnion(ref fields, ..) => {\n+                self.with_banned_assoc_ty_bound(|this| {\n+                    walk_list!(this, visit_struct_field_def, fields)\n+                });\n+            }\n             _ => visit::walk_ty(self, t),\n         }\n     }\n \n+    fn visit_struct_field_def(&mut self, field: &'a FieldDef) {\n+        if let Some(ident) = field.ident {\n+            if ident.name == kw::Underscore {\n+                self.check_anonymous_field(field);\n+                self.visit_vis(&field.vis);\n+                self.visit_ident(ident);\n+                self.visit_ty_common(&field.ty);\n+                self.walk_ty(&field.ty);\n+                walk_list!(self, visit_attribute, &field.attrs);\n+                return;\n+            }\n+        }\n+        self.visit_field_def(field);\n+    }\n+\n     fn err_handler(&self) -> &rustc_errors::Handler {\n         &self.session.diagnostic()\n     }\n@@ -213,6 +233,66 @@ impl<'a> AstValidator<'a> {\n         err.emit();\n     }\n \n+    fn check_anonymous_field(&self, field: &FieldDef) {\n+        let FieldDef { ty, .. } = field;\n+        match &ty.kind {\n+            TyKind::AnonymousStruct(..) | TyKind::AnonymousUnion(..) => {\n+                // We already checked for `kw::Underscore` before calling this function,\n+                // so skip the check\n+            }\n+            TyKind::Path(..) => {\n+                // If the anonymous field contains a Path as type, we can't determine\n+                // if the path is a valid struct or union, so skip the check\n+            }\n+            _ => {\n+                let msg = \"unnamed fields can only have struct or union types\";\n+                let label = \"not a struct or union\";\n+                self.err_handler()\n+                    .struct_span_err(field.span, msg)\n+                    .span_label(ty.span, label)\n+                    .emit();\n+            }\n+        }\n+    }\n+\n+    fn deny_anonymous_struct(&self, ty: &Ty) {\n+        match &ty.kind {\n+            TyKind::AnonymousStruct(..) => {\n+                self.err_handler()\n+                    .struct_span_err(\n+                        ty.span,\n+                        \"anonymous structs are not allowed outside of unnamed struct or union fields\",\n+                    )\n+                    .span_label(ty.span, \"anonymous struct declared here\")\n+                    .emit();\n+            }\n+            TyKind::AnonymousUnion(..) => {\n+                self.err_handler()\n+                    .struct_span_err(\n+                        ty.span,\n+                        \"anonymous unions are not allowed outside of unnamed struct or union fields\",\n+                    )\n+                    .span_label(ty.span, \"anonymous union declared here\")\n+                    .emit();\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn deny_anonymous_field(&self, field: &FieldDef) {\n+        if let Some(ident) = field.ident {\n+            if ident.name == kw::Underscore {\n+                self.err_handler()\n+                    .struct_span_err(\n+                        field.span,\n+                        \"anonymous fields are not allowed outside of structs or unions\",\n+                    )\n+                    .span_label(ident.span, \"anonymous field declared here\")\n+                    .emit()\n+            }\n+        }\n+    }\n+\n     fn check_decl_no_pat(decl: &FnDecl, mut report_err: impl FnMut(Span, Option<Ident>, bool)) {\n         for Param { pat, .. } in &decl.inputs {\n             match pat.kind {\n@@ -532,6 +612,25 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n+    /// An item in `extern { ... }` cannot use non-ascii identifier.\n+    fn check_foreign_item_ascii_only(&self, ident: Ident) {\n+        let symbol_str = ident.as_str();\n+        if !symbol_str.is_ascii() {\n+            let n = 83942;\n+            self.err_handler()\n+                .struct_span_err(\n+                    ident.span,\n+                    \"items in `extern` blocks cannot use non-ascii identifiers\",\n+                )\n+                .span_label(self.current_extern_span(), \"in this `extern` block\")\n+                .note(&format!(\n+                    \"This limitation may be lifted in the future; see issue #{} <https://github.com/rust-lang/rust/issues/{}> for more information\",\n+                    n, n,\n+                ))\n+                .emit();\n+        }\n+    }\n+\n     /// Reject C-varadic type unless the function is foreign,\n     /// or free and `unsafe extern \"C\"` semantically.\n     fn check_c_varadic_type(&self, fk: FnKind<'a>) {\n@@ -592,7 +691,7 @@ impl<'a> AstValidator<'a> {\n             self.session,\n             ident.span,\n             E0754,\n-            \"trying to load file for module `{}` with non ascii identifer name\",\n+            \"trying to load file for module `{}` with non-ascii identifier name\",\n             ident.name\n         )\n         .help(\"consider using `#[path]` attribute to specify filesystem path\")\n@@ -713,6 +812,71 @@ impl<'a> AstValidator<'a> {\n             )\n             .emit();\n     }\n+\n+    fn visit_ty_common(&mut self, ty: &'a Ty) {\n+        match ty.kind {\n+            TyKind::BareFn(ref bfty) => {\n+                self.check_fn_decl(&bfty.decl, SelfSemantic::No);\n+                Self::check_decl_no_pat(&bfty.decl, |span, _, _| {\n+                    struct_span_err!(\n+                        self.session,\n+                        span,\n+                        E0561,\n+                        \"patterns aren't allowed in function pointer types\"\n+                    )\n+                    .emit();\n+                });\n+                self.check_late_bound_lifetime_defs(&bfty.generic_params);\n+            }\n+            TyKind::TraitObject(ref bounds, ..) => {\n+                let mut any_lifetime_bounds = false;\n+                for bound in bounds {\n+                    if let GenericBound::Outlives(ref lifetime) = *bound {\n+                        if any_lifetime_bounds {\n+                            struct_span_err!(\n+                                self.session,\n+                                lifetime.ident.span,\n+                                E0226,\n+                                \"only a single explicit lifetime bound is permitted\"\n+                            )\n+                            .emit();\n+                            break;\n+                        }\n+                        any_lifetime_bounds = true;\n+                    }\n+                }\n+                self.no_questions_in_bounds(bounds, \"trait object types\", false);\n+            }\n+            TyKind::ImplTrait(_, ref bounds) => {\n+                if self.is_impl_trait_banned {\n+                    struct_span_err!(\n+                        self.session,\n+                        ty.span,\n+                        E0667,\n+                        \"`impl Trait` is not allowed in path parameters\"\n+                    )\n+                    .emit();\n+                }\n+\n+                if let Some(outer_impl_trait_sp) = self.outer_impl_trait {\n+                    struct_span_err!(\n+                        self.session,\n+                        ty.span,\n+                        E0666,\n+                        \"nested `impl Trait` is not allowed\"\n+                    )\n+                    .span_label(outer_impl_trait_sp, \"outer `impl Trait`\")\n+                    .span_label(ty.span, \"nested `impl Trait` here\")\n+                    .emit();\n+                }\n+\n+                if !bounds.iter().any(|b| matches!(b, GenericBound::Trait(..))) {\n+                    self.err_handler().span_err(ty.span, \"at least one trait must be specified\");\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n }\n \n /// Checks that generic parameters are in the correct order,\n@@ -735,7 +899,7 @@ fn validate_generic_param_order(\n             GenericParamKind::Type { default: _ } => (ParamKindOrd::Type, ident),\n             GenericParamKind::Const { ref ty, kw_span: _, default: _ } => {\n                 let ty = pprust::ty_to_string(ty);\n-                let unordered = sess.features_untracked().const_generics;\n+                let unordered = sess.features_untracked().unordered_const_ty_params();\n                 (ParamKindOrd::Const { unordered }, Some(format!(\"const {}: {}\", param.ident, ty)))\n             }\n         };\n@@ -831,72 +995,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_ty(&mut self, ty: &'a Ty) {\n-        match ty.kind {\n-            TyKind::BareFn(ref bfty) => {\n-                self.check_fn_decl(&bfty.decl, SelfSemantic::No);\n-                Self::check_decl_no_pat(&bfty.decl, |span, _, _| {\n-                    struct_span_err!(\n-                        self.session,\n-                        span,\n-                        E0561,\n-                        \"patterns aren't allowed in function pointer types\"\n-                    )\n-                    .emit();\n-                });\n-                self.check_late_bound_lifetime_defs(&bfty.generic_params);\n-            }\n-            TyKind::TraitObject(ref bounds, ..) => {\n-                let mut any_lifetime_bounds = false;\n-                for bound in bounds {\n-                    if let GenericBound::Outlives(ref lifetime) = *bound {\n-                        if any_lifetime_bounds {\n-                            struct_span_err!(\n-                                self.session,\n-                                lifetime.ident.span,\n-                                E0226,\n-                                \"only a single explicit lifetime bound is permitted\"\n-                            )\n-                            .emit();\n-                            break;\n-                        }\n-                        any_lifetime_bounds = true;\n-                    }\n-                }\n-                self.no_questions_in_bounds(bounds, \"trait object types\", false);\n-            }\n-            TyKind::ImplTrait(_, ref bounds) => {\n-                if self.is_impl_trait_banned {\n-                    struct_span_err!(\n-                        self.session,\n-                        ty.span,\n-                        E0667,\n-                        \"`impl Trait` is not allowed in path parameters\"\n-                    )\n-                    .emit();\n-                }\n-\n-                if let Some(outer_impl_trait_sp) = self.outer_impl_trait {\n-                    struct_span_err!(\n-                        self.session,\n-                        ty.span,\n-                        E0666,\n-                        \"nested `impl Trait` is not allowed\"\n-                    )\n-                    .span_label(outer_impl_trait_sp, \"outer `impl Trait`\")\n-                    .span_label(ty.span, \"nested `impl Trait` here\")\n-                    .emit();\n-                }\n-\n-                if !bounds.iter().any(|b| matches!(b, GenericBound::Trait(..))) {\n-                    self.err_handler().span_err(ty.span, \"at least one trait must be specified\");\n-                }\n-\n-                self.walk_ty(ty);\n-                return;\n-            }\n-            _ => {}\n-        }\n-\n+        self.visit_ty_common(ty);\n+        self.deny_anonymous_struct(ty);\n         self.walk_ty(ty)\n     }\n \n@@ -910,6 +1010,11 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         visit::walk_lifetime(self, lifetime);\n     }\n \n+    fn visit_field_def(&mut self, s: &'a FieldDef) {\n+        self.deny_anonymous_field(s);\n+        visit::walk_field_def(self, s)\n+    }\n+\n     fn visit_item(&mut self, item: &'a Item) {\n         if item.attrs.iter().any(|attr| self.session.is_proc_macro_attr(attr)) {\n             self.has_proc_macro_decls = true;\n@@ -1065,14 +1170,42 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     self.check_mod_file_item_asciionly(item.ident);\n                 }\n             }\n-            ItemKind::Union(ref vdata, _) => {\n-                if let VariantData::Tuple(..) | VariantData::Unit(..) = vdata {\n-                    self.err_handler()\n-                        .span_err(item.span, \"tuple and unit unions are not permitted\");\n+            ItemKind::Struct(ref vdata, ref generics) => match vdata {\n+                // Duplicating the `Visitor` logic allows catching all cases\n+                // of `Anonymous(Struct, Union)` outside of a field struct or union.\n+                //\n+                // Inside `visit_ty` the validator catches every `Anonymous(Struct, Union)` it\n+                // encounters, and only on `ItemKind::Struct` and `ItemKind::Union`\n+                // it uses `visit_ty_common`, which doesn't contain that specific check.\n+                VariantData::Struct(ref fields, ..) => {\n+                    self.visit_vis(&item.vis);\n+                    self.visit_ident(item.ident);\n+                    self.visit_generics(generics);\n+                    self.with_banned_assoc_ty_bound(|this| {\n+                        walk_list!(this, visit_struct_field_def, fields);\n+                    });\n+                    walk_list!(self, visit_attribute, &item.attrs);\n+                    return;\n                 }\n+                _ => {}\n+            },\n+            ItemKind::Union(ref vdata, ref generics) => {\n                 if vdata.fields().is_empty() {\n                     self.err_handler().span_err(item.span, \"unions cannot have zero fields\");\n                 }\n+                match vdata {\n+                    VariantData::Struct(ref fields, ..) => {\n+                        self.visit_vis(&item.vis);\n+                        self.visit_ident(item.ident);\n+                        self.visit_generics(generics);\n+                        self.with_banned_assoc_ty_bound(|this| {\n+                            walk_list!(this, visit_struct_field_def, fields);\n+                        });\n+                        walk_list!(self, visit_attribute, &item.attrs);\n+                        return;\n+                    }\n+                    _ => {}\n+                }\n             }\n             ItemKind::Const(def, .., None) => {\n                 self.check_defaultness(item.span, def);\n@@ -1103,15 +1236,18 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 self.check_defaultness(fi.span, *def);\n                 self.check_foreign_fn_bodyless(fi.ident, body.as_deref());\n                 self.check_foreign_fn_headerless(fi.ident, fi.span, sig.header);\n+                self.check_foreign_item_ascii_only(fi.ident);\n             }\n             ForeignItemKind::TyAlias(box TyAliasKind(def, generics, bounds, body)) => {\n                 self.check_defaultness(fi.span, *def);\n                 self.check_foreign_kind_bodyless(fi.ident, \"type\", body.as_ref().map(|b| b.span));\n                 self.check_type_no_bounds(bounds, \"`extern` blocks\");\n                 self.check_foreign_ty_genericless(generics);\n+                self.check_foreign_item_ascii_only(fi.ident);\n             }\n             ForeignItemKind::Static(_, _, body) => {\n                 self.check_foreign_kind_bodyless(fi.ident, \"static\", body.as_ref().map(|b| b.span));\n+                self.check_foreign_item_ascii_only(fi.ident);\n             }\n             ForeignItemKind::MacCall(..) => {}\n         }\n@@ -1191,8 +1327,41 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 deny_equality_constraints(self, predicate, generics);\n             }\n         }\n-\n-        visit::walk_generics(self, generics)\n+        walk_list!(self, visit_generic_param, &generics.params);\n+        for predicate in &generics.where_clause.predicates {\n+            match predicate {\n+                WherePredicate::BoundPredicate(bound_pred) => {\n+                    // A type binding, eg `for<'c> Foo: Send+Clone+'c`\n+                    self.check_late_bound_lifetime_defs(&bound_pred.bound_generic_params);\n+\n+                    // This is slightly complicated. Our representation for poly-trait-refs contains a single\n+                    // binder and thus we only allow a single level of quantification. However,\n+                    // the syntax of Rust permits quantification in two places in where clauses,\n+                    // e.g., `T: for <'a> Foo<'a>` and `for <'a, 'b> &'b T: Foo<'a>`. If both are\n+                    // defined, then error.\n+                    if !bound_pred.bound_generic_params.is_empty() {\n+                        for bound in &bound_pred.bounds {\n+                            match bound {\n+                                GenericBound::Trait(t, _) => {\n+                                    if !t.bound_generic_params.is_empty() {\n+                                        struct_span_err!(\n+                                            self.err_handler(),\n+                                            t.span,\n+                                            E0316,\n+                                            \"nested quantification of lifetimes\"\n+                                        )\n+                                        .emit();\n+                                    }\n+                                }\n+                                GenericBound::Outlives(_) => {}\n+                            }\n+                        }\n+                    }\n+                }\n+                _ => {}\n+            }\n+            self.visit_where_predicate(predicate);\n+        }\n     }\n \n     fn visit_generic_param(&mut self, param: &'a GenericParam) {\n@@ -1241,14 +1410,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         visit::walk_pat(self, pat)\n     }\n \n-    fn visit_where_predicate(&mut self, p: &'a WherePredicate) {\n-        if let &WherePredicate::BoundPredicate(ref bound_predicate) = p {\n-            // A type binding, eg `for<'c> Foo: Send+Clone+'c`\n-            self.check_late_bound_lifetime_defs(&bound_predicate.bound_generic_params);\n-        }\n-        visit::walk_where_predicate(self, p);\n-    }\n-\n     fn visit_poly_trait_ref(&mut self, t: &'a PolyTraitRef, m: &'a TraitBoundModifier) {\n         self.check_late_bound_lifetime_defs(&t.bound_generic_params);\n         visit::walk_poly_trait_ref(self, t, m);"}, {"sha": "4996c2195efdf2402f8cd32c816671c31623f553", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 82, "deletions": 35, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -8,7 +8,7 @@ use rustc_feature::{Features, GateIssue};\n use rustc_session::parse::{feature_err, feature_err_issue};\n use rustc_session::Session;\n use rustc_span::source_map::Spanned;\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::sym;\n use rustc_span::Span;\n \n use tracing::debug;\n@@ -196,6 +196,14 @@ impl<'a> PostExpansionVisitor<'a> {\n                     \"thiscall-unwind ABI is experimental and subject to change\"\n                 );\n             }\n+            \"wasm\" => {\n+                gate_feature_post!(\n+                    &self,\n+                    wasm_abi,\n+                    span,\n+                    \"wasm ABI is experimental and subject to change\"\n+                );\n+            }\n             abi => self\n                 .sess\n                 .parse_sess\n@@ -313,21 +321,49 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                     include => external_doc\n                     cfg => doc_cfg\n                     masked => doc_masked\n-                    spotlight => doc_spotlight\n+                    notable_trait => doc_notable_trait\n                     keyword => doc_keyword\n                 );\n             }\n         }\n-    }\n \n-    fn visit_name(&mut self, sp: Span, name: Symbol) {\n-        if !name.as_str().is_ascii() {\n-            gate_feature_post!(\n-                &self,\n-                non_ascii_idents,\n-                self.sess.parse_sess.source_map().guess_head_span(sp),\n-                \"non-ascii idents are not fully supported\"\n-            );\n+        // Check for unstable modifiers on `#[link(..)]` attribute\n+        if self.sess.check_name(attr, sym::link) {\n+            for nested_meta in attr.meta_item_list().unwrap_or_default() {\n+                if nested_meta.has_name(sym::modifiers) {\n+                    gate_feature_post!(\n+                        self,\n+                        native_link_modifiers,\n+                        nested_meta.span(),\n+                        \"native link modifiers are experimental\"\n+                    );\n+\n+                    if let Some(modifiers) = nested_meta.value_str() {\n+                        for modifier in modifiers.as_str().split(',') {\n+                            if let Some(modifier) = modifier.strip_prefix(&['+', '-'][..]) {\n+                                macro_rules! gate_modifier { ($($name:literal => $feature:ident)*) => {\n+                                    $(if modifier == $name {\n+                                        let msg = concat!(\"`#[link(modifiers=\\\"\", $name, \"\\\")]` is unstable\");\n+                                        gate_feature_post!(\n+                                            self,\n+                                            $feature,\n+                                            nested_meta.name_value_literal_span().unwrap(),\n+                                            msg\n+                                        );\n+                                    })*\n+                                }}\n+\n+                                gate_modifier!(\n+                                    \"bundle\" => native_link_modifiers_bundle\n+                                    \"verbatim\" => native_link_modifiers_verbatim\n+                                    \"whole-archive\" => native_link_modifiers_whole_archive\n+                                    \"as-needed\" => native_link_modifiers_as_needed\n+                                );\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n         }\n     }\n \n@@ -358,16 +394,6 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                          over time\"\n                     );\n                 }\n-                if self.sess.contains_name(&i.attrs[..], sym::main) {\n-                    gate_feature_post!(\n-                        &self,\n-                        main,\n-                        i.span,\n-                        \"declaration of a non-standard `#[main]` \\\n-                         function may change over time, for now \\\n-                         a top-level `fn main()` is required\"\n-                    );\n-                }\n             }\n \n             ast::ItemKind::Struct(..) => {\n@@ -599,12 +625,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n \n     fn visit_assoc_item(&mut self, i: &'a ast::AssocItem, ctxt: AssocCtxt) {\n         let is_fn = match i.kind {\n-            ast::AssocItemKind::Fn(box ast::FnKind(_, ref sig, _, _)) => {\n-                if let (ast::Const::Yes(_), AssocCtxt::Trait) = (sig.header.constness, ctxt) {\n-                    gate_feature_post!(&self, const_fn, i.span, \"const fn is unstable\");\n-                }\n-                true\n-            }\n+            ast::AssocItemKind::Fn(_) => true,\n             ast::AssocItemKind::TyAlias(box ast::TyAliasKind(_, ref generics, _, ref ty)) => {\n                 if let (Some(_), AssocCtxt::Trait) = (ty, ctxt) {\n                     gate_feature_post!(\n@@ -691,10 +712,6 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n     gate_all!(const_trait_impl, \"const trait impls are experimental\");\n     gate_all!(half_open_range_patterns, \"half-open range patterns are unstable\");\n     gate_all!(inline_const, \"inline-const is experimental\");\n-    gate_all!(\n-        extended_key_value_attributes,\n-        \"arbitrary expressions in key-value attributes are unstable\"\n-    );\n     gate_all!(\n         const_generics_defaults,\n         \"default values for const generic parameters are experimental\"\n@@ -704,7 +721,7 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n         // involved, so we only emit errors where there are no other parsing errors.\n         gate_all!(destructuring_assignment, \"destructuring assignments are unstable\");\n     }\n-    gate_all!(pub_macro_rules, \"`pub` on `macro_rules` items is unstable\");\n+    gate_all!(unnamed_fields, \"unnamed fields are not yet fully implemented\");\n \n     // All uses of `gate_all!` below this point were added in #65742,\n     // and subsequently disabled (with the non-early gating readded).\n@@ -740,16 +757,46 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n }\n \n fn maybe_stage_features(sess: &Session, krate: &ast::Crate) {\n+    use rustc_errors::Applicability;\n+\n     if !sess.opts.unstable_features.is_nightly_build() {\n+        let lang_features = &sess.features_untracked().declared_lang_features;\n         for attr in krate.attrs.iter().filter(|attr| sess.check_name(attr, sym::feature)) {\n-            struct_span_err!(\n+            let mut err = struct_span_err!(\n                 sess.parse_sess.span_diagnostic,\n                 attr.span,\n                 E0554,\n                 \"`#![feature]` may not be used on the {} release channel\",\n                 option_env!(\"CFG_RELEASE_CHANNEL\").unwrap_or(\"(unknown)\")\n-            )\n-            .emit();\n+            );\n+            let mut all_stable = true;\n+            for ident in\n+                attr.meta_item_list().into_iter().flatten().map(|nested| nested.ident()).flatten()\n+            {\n+                let name = ident.name;\n+                let stable_since = lang_features\n+                    .iter()\n+                    .flat_map(|&(feature, _, since)| if feature == name { since } else { None })\n+                    .next();\n+                if let Some(since) = stable_since {\n+                    err.help(&format!(\n+                        \"the feature `{}` has been stable since {} and no longer requires \\\n+                                  an attribute to enable\",\n+                        name, since\n+                    ));\n+                } else {\n+                    all_stable = false;\n+                }\n+            }\n+            if all_stable {\n+                err.span_suggestion(\n+                    attr.span,\n+                    \"remove the attribute\",\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            err.emit();\n         }\n     }\n }"}, {"sha": "6bd543ff15021ee555b59bdb83bbfe1ff9ebf365", "filename": "compiler/rustc_ast_pretty/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Flib.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -1,6 +1,5 @@\n #![feature(bool_to_option)]\n #![feature(crate_visibility_modifier)]\n-#![cfg_attr(bootstrap, feature(or_patterns))]\n #![feature(box_patterns)]\n #![recursion_limit = \"256\"]\n "}, {"sha": "976725b308e02d6f2631b79db7f29c519acd4e93", "filename": "compiler/rustc_ast_pretty/src/pprust/mod.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fmod.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -22,10 +22,6 @@ pub fn token_to_string(token: &Token) -> String {\n     State::new().token_to_string(token)\n }\n \n-pub fn token_to_string_ext(token: &Token, convert_dollar_crate: bool) -> String {\n-    State::new().token_to_string_ext(token, convert_dollar_crate)\n-}\n-\n pub fn ty_to_string(ty: &ast::Ty) -> String {\n     State::new().ty_to_string(ty)\n }\n@@ -50,18 +46,10 @@ pub fn tts_to_string(tokens: &TokenStream) -> String {\n     State::new().tts_to_string(tokens)\n }\n \n-pub fn stmt_to_string(stmt: &ast::Stmt) -> String {\n-    State::new().stmt_to_string(stmt)\n-}\n-\n pub fn item_to_string(i: &ast::Item) -> String {\n     State::new().item_to_string(i)\n }\n \n-pub fn generic_params_to_string(generic_params: &[ast::GenericParam]) -> String {\n-    State::new().generic_params_to_string(generic_params)\n-}\n-\n pub fn path_to_string(p: &ast::Path) -> String {\n     State::new().path_to_string(p)\n }\n@@ -74,26 +62,14 @@ pub fn vis_to_string(v: &ast::Visibility) -> String {\n     State::new().vis_to_string(v)\n }\n \n-pub fn block_to_string(blk: &ast::Block) -> String {\n-    State::new().block_to_string(blk)\n-}\n-\n pub fn meta_list_item_to_string(li: &ast::NestedMetaItem) -> String {\n     State::new().meta_list_item_to_string(li)\n }\n \n-pub fn attr_item_to_string(ai: &ast::AttrItem) -> String {\n-    State::new().attr_item_to_string(ai)\n-}\n-\n pub fn attribute_to_string(attr: &ast::Attribute) -> String {\n     State::new().attribute_to_string(attr)\n }\n \n-pub fn param_to_string(arg: &ast::Param) -> String {\n-    State::new().param_to_string(arg)\n-}\n-\n pub fn to_string(f: impl FnOnce(&mut State<'_>)) -> String {\n     State::new().to_string(f)\n }"}, {"sha": "b7bb896f31802281214b5cc44e55e84606de1e8e", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 154, "deletions": 159, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -140,12 +140,15 @@ pub fn print_crate<'a>(\n // and also addresses some specific regressions described in #63896 and #73345.\n fn tt_prepend_space(tt: &TokenTree, prev: &TokenTree) -> bool {\n     if let TokenTree::Token(token) = prev {\n+        if matches!(token.kind, token::Dot) {\n+            return false;\n+        }\n         if let token::DocComment(comment_kind, ..) = token.kind {\n             return comment_kind != CommentKind::Line;\n         }\n     }\n     match tt {\n-        TokenTree::Token(token) => token.kind != token::Comma,\n+        TokenTree::Token(token) => !matches!(token.kind, token::Comma | token::Not | token::Dot),\n         TokenTree::Delimited(_, DelimToken::Paren, _) => {\n             !matches!(prev, TokenTree::Token(Token { kind: token::Ident(..), .. }))\n         }\n@@ -366,10 +369,6 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n         self.print_either_attributes(attrs, ast::AttrStyle::Inner, false, true)\n     }\n \n-    fn print_inner_attributes_no_trailing_hardbreak(&mut self, attrs: &[ast::Attribute]) {\n-        self.print_either_attributes(attrs, ast::AttrStyle::Inner, false, false)\n-    }\n-\n     fn print_outer_attributes(&mut self, attrs: &[ast::Attribute]) {\n         self.print_either_attributes(attrs, ast::AttrStyle::Outer, false, true)\n     }\n@@ -955,6 +954,14 @@ impl<'a> State<'a> {\n                 }\n                 self.pclose();\n             }\n+            ast::TyKind::AnonymousStruct(ref fields, ..) => {\n+                self.head(\"struct\");\n+                self.print_record_struct_body(&fields, ty.span);\n+            }\n+            ast::TyKind::AnonymousUnion(ref fields, ..) => {\n+                self.head(\"union\");\n+                self.print_record_struct_body(&fields, ty.span);\n+            }\n             ast::TyKind::Paren(ref typ) => {\n                 self.popen();\n                 self.print_type(typ);\n@@ -1168,9 +1175,9 @@ impl<'a> State<'a> {\n                 self.print_foreign_mod(nmod, &item.attrs);\n                 self.bclose(item.span);\n             }\n-            ast::ItemKind::GlobalAsm(ref ga) => {\n+            ast::ItemKind::GlobalAsm(ref asm) => {\n                 self.head(visibility_qualified(&item.vis, \"global_asm!\"));\n-                self.s.word(ga.asm.to_string());\n+                self.print_inline_asm(asm);\n                 self.end();\n             }\n             ast::ItemKind::TyAlias(box ast::TyAliasKind(def, ref generics, ref bounds, ref ty)) => {\n@@ -1390,6 +1397,24 @@ impl<'a> State<'a> {\n         }\n     }\n \n+    crate fn print_record_struct_body(&mut self, fields: &[ast::FieldDef], span: rustc_span::Span) {\n+        self.bopen();\n+        self.hardbreak_if_not_bol();\n+\n+        for field in fields {\n+            self.hardbreak_if_not_bol();\n+            self.maybe_print_comment(field.span.lo());\n+            self.print_outer_attributes(&field.attrs);\n+            self.print_visibility(&field.vis);\n+            self.print_ident(field.ident.unwrap());\n+            self.word_nbsp(\":\");\n+            self.print_type(&field.ty);\n+            self.s.word(\",\");\n+        }\n+\n+        self.bclose(span)\n+    }\n+\n     crate fn print_struct(\n         &mut self,\n         struct_def: &ast::VariantData,\n@@ -1419,24 +1444,10 @@ impl<'a> State<'a> {\n                 self.end();\n                 self.end(); // Close the outer-box.\n             }\n-            ast::VariantData::Struct(..) => {\n+            ast::VariantData::Struct(ref fields, ..) => {\n                 self.print_where_clause(&generics.where_clause);\n                 self.nbsp();\n-                self.bopen();\n-                self.hardbreak_if_not_bol();\n-\n-                for field in struct_def.fields() {\n-                    self.hardbreak_if_not_bol();\n-                    self.maybe_print_comment(field.span.lo());\n-                    self.print_outer_attributes(&field.attrs);\n-                    self.print_visibility(&field.vis);\n-                    self.print_ident(field.ident.unwrap());\n-                    self.word_nbsp(\":\");\n-                    self.print_type(&field.ty);\n-                    self.s.word(\",\");\n-                }\n-\n-                self.bclose(span)\n+                self.print_record_struct_body(fields, span);\n             }\n         }\n     }\n@@ -1675,32 +1686,24 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    fn print_expr_vec(&mut self, exprs: &[P<ast::Expr>], attrs: &[ast::Attribute]) {\n+    fn print_expr_vec(&mut self, exprs: &[P<ast::Expr>]) {\n         self.ibox(INDENT_UNIT);\n         self.s.word(\"[\");\n-        self.print_inner_attributes_inline(attrs);\n         self.commasep_exprs(Inconsistent, exprs);\n         self.s.word(\"]\");\n         self.end();\n     }\n \n-    fn print_expr_anon_const(&mut self, expr: &ast::AnonConst, attrs: &[ast::Attribute]) {\n+    fn print_expr_anon_const(&mut self, expr: &ast::AnonConst) {\n         self.ibox(INDENT_UNIT);\n         self.s.word(\"const\");\n-        self.print_inner_attributes_inline(attrs);\n         self.print_expr(&expr.value);\n         self.end();\n     }\n \n-    fn print_expr_repeat(\n-        &mut self,\n-        element: &ast::Expr,\n-        count: &ast::AnonConst,\n-        attrs: &[ast::Attribute],\n-    ) {\n+    fn print_expr_repeat(&mut self, element: &ast::Expr, count: &ast::AnonConst) {\n         self.ibox(INDENT_UNIT);\n         self.s.word(\"[\");\n-        self.print_inner_attributes_inline(attrs);\n         self.print_expr(element);\n         self.word_space(\";\");\n         self.print_expr(&count.value);\n@@ -1713,11 +1716,9 @@ impl<'a> State<'a> {\n         path: &ast::Path,\n         fields: &[ast::ExprField],\n         rest: &ast::StructRest,\n-        attrs: &[ast::Attribute],\n     ) {\n         self.print_path(path, true, 0);\n         self.s.word(\"{\");\n-        self.print_inner_attributes_inline(attrs);\n         self.commasep_cmnt(\n             Consistent,\n             fields,\n@@ -1752,9 +1753,8 @@ impl<'a> State<'a> {\n         self.s.word(\"}\");\n     }\n \n-    fn print_expr_tup(&mut self, exprs: &[P<ast::Expr>], attrs: &[ast::Attribute]) {\n+    fn print_expr_tup(&mut self, exprs: &[P<ast::Expr>]) {\n         self.popen();\n-        self.print_inner_attributes_inline(attrs);\n         self.commasep_exprs(Inconsistent, exprs);\n         if exprs.len() == 1 {\n             self.s.word(\",\");\n@@ -1865,19 +1865,19 @@ impl<'a> State<'a> {\n                 self.print_expr_maybe_paren(expr, parser::PREC_PREFIX);\n             }\n             ast::ExprKind::Array(ref exprs) => {\n-                self.print_expr_vec(&exprs[..], attrs);\n+                self.print_expr_vec(exprs);\n             }\n             ast::ExprKind::ConstBlock(ref anon_const) => {\n-                self.print_expr_anon_const(anon_const, attrs);\n+                self.print_expr_anon_const(anon_const);\n             }\n             ast::ExprKind::Repeat(ref element, ref count) => {\n-                self.print_expr_repeat(element, count, attrs);\n+                self.print_expr_repeat(element, count);\n             }\n             ast::ExprKind::Struct(ref se) => {\n-                self.print_expr_struct(&se.path, &se.fields, &se.rest, attrs);\n+                self.print_expr_struct(&se.path, &se.fields, &se.rest);\n             }\n             ast::ExprKind::Tup(ref exprs) => {\n-                self.print_expr_tup(&exprs[..], attrs);\n+                self.print_expr_tup(exprs);\n             }\n             ast::ExprKind::Call(ref func, ref args) => {\n                 self.print_expr_call(func, &args[..]);\n@@ -1955,7 +1955,6 @@ impl<'a> State<'a> {\n                 self.print_expr_as_cond(expr);\n                 self.s.space();\n                 self.bopen();\n-                self.print_inner_attributes_no_trailing_hardbreak(attrs);\n                 for arm in arms {\n                     self.print_arm(arm);\n                 }\n@@ -2082,117 +2081,8 @@ impl<'a> State<'a> {\n                 }\n             }\n             ast::ExprKind::InlineAsm(ref a) => {\n-                enum AsmArg<'a> {\n-                    Template(String),\n-                    Operand(&'a InlineAsmOperand),\n-                    Options(InlineAsmOptions),\n-                }\n-\n-                let mut args = vec![];\n-                args.push(AsmArg::Template(InlineAsmTemplatePiece::to_string(&a.template)));\n-                args.extend(a.operands.iter().map(|(o, _)| AsmArg::Operand(o)));\n-                if !a.options.is_empty() {\n-                    args.push(AsmArg::Options(a.options));\n-                }\n-\n                 self.word(\"asm!\");\n-                self.popen();\n-                self.commasep(Consistent, &args, |s, arg| match arg {\n-                    AsmArg::Template(template) => s.print_string(&template, ast::StrStyle::Cooked),\n-                    AsmArg::Operand(op) => {\n-                        let print_reg_or_class = |s: &mut Self, r: &InlineAsmRegOrRegClass| match r\n-                        {\n-                            InlineAsmRegOrRegClass::Reg(r) => {\n-                                s.print_symbol(*r, ast::StrStyle::Cooked)\n-                            }\n-                            InlineAsmRegOrRegClass::RegClass(r) => s.word(r.to_string()),\n-                        };\n-                        match op {\n-                            InlineAsmOperand::In { reg, expr } => {\n-                                s.word(\"in\");\n-                                s.popen();\n-                                print_reg_or_class(s, reg);\n-                                s.pclose();\n-                                s.space();\n-                                s.print_expr(expr);\n-                            }\n-                            InlineAsmOperand::Out { reg, late, expr } => {\n-                                s.word(if *late { \"lateout\" } else { \"out\" });\n-                                s.popen();\n-                                print_reg_or_class(s, reg);\n-                                s.pclose();\n-                                s.space();\n-                                match expr {\n-                                    Some(expr) => s.print_expr(expr),\n-                                    None => s.word(\"_\"),\n-                                }\n-                            }\n-                            InlineAsmOperand::InOut { reg, late, expr } => {\n-                                s.word(if *late { \"inlateout\" } else { \"inout\" });\n-                                s.popen();\n-                                print_reg_or_class(s, reg);\n-                                s.pclose();\n-                                s.space();\n-                                s.print_expr(expr);\n-                            }\n-                            InlineAsmOperand::SplitInOut { reg, late, in_expr, out_expr } => {\n-                                s.word(if *late { \"inlateout\" } else { \"inout\" });\n-                                s.popen();\n-                                print_reg_or_class(s, reg);\n-                                s.pclose();\n-                                s.space();\n-                                s.print_expr(in_expr);\n-                                s.space();\n-                                s.word_space(\"=>\");\n-                                match out_expr {\n-                                    Some(out_expr) => s.print_expr(out_expr),\n-                                    None => s.word(\"_\"),\n-                                }\n-                            }\n-                            InlineAsmOperand::Const { expr } => {\n-                                s.word(\"const\");\n-                                s.space();\n-                                s.print_expr(expr);\n-                            }\n-                            InlineAsmOperand::Sym { expr } => {\n-                                s.word(\"sym\");\n-                                s.space();\n-                                s.print_expr(expr);\n-                            }\n-                        }\n-                    }\n-                    AsmArg::Options(opts) => {\n-                        s.word(\"options\");\n-                        s.popen();\n-                        let mut options = vec![];\n-                        if opts.contains(InlineAsmOptions::PURE) {\n-                            options.push(\"pure\");\n-                        }\n-                        if opts.contains(InlineAsmOptions::NOMEM) {\n-                            options.push(\"nomem\");\n-                        }\n-                        if opts.contains(InlineAsmOptions::READONLY) {\n-                            options.push(\"readonly\");\n-                        }\n-                        if opts.contains(InlineAsmOptions::PRESERVES_FLAGS) {\n-                            options.push(\"preserves_flags\");\n-                        }\n-                        if opts.contains(InlineAsmOptions::NORETURN) {\n-                            options.push(\"noreturn\");\n-                        }\n-                        if opts.contains(InlineAsmOptions::NOSTACK) {\n-                            options.push(\"nostack\");\n-                        }\n-                        if opts.contains(InlineAsmOptions::ATT_SYNTAX) {\n-                            options.push(\"att_syntax\");\n-                        }\n-                        s.commasep(Inconsistent, &options, |s, &opt| {\n-                            s.word(opt);\n-                        });\n-                        s.pclose();\n-                    }\n-                });\n-                self.pclose();\n+                self.print_inline_asm(a);\n             }\n             ast::ExprKind::LlvmInlineAsm(ref a) => {\n                 self.s.word(\"llvm_asm!\");\n@@ -2253,7 +2143,6 @@ impl<'a> State<'a> {\n             ast::ExprKind::MacCall(ref m) => self.print_mac(m),\n             ast::ExprKind::Paren(ref e) => {\n                 self.popen();\n-                self.print_inner_attributes_inline(attrs);\n                 self.print_expr(e);\n                 self.pclose();\n             }\n@@ -2284,6 +2173,116 @@ impl<'a> State<'a> {\n         self.end();\n     }\n \n+    fn print_inline_asm(&mut self, asm: &ast::InlineAsm) {\n+        enum AsmArg<'a> {\n+            Template(String),\n+            Operand(&'a InlineAsmOperand),\n+            Options(InlineAsmOptions),\n+        }\n+\n+        let mut args = vec![];\n+        args.push(AsmArg::Template(InlineAsmTemplatePiece::to_string(&asm.template)));\n+        args.extend(asm.operands.iter().map(|(o, _)| AsmArg::Operand(o)));\n+        if !asm.options.is_empty() {\n+            args.push(AsmArg::Options(asm.options));\n+        }\n+\n+        self.popen();\n+        self.commasep(Consistent, &args, |s, arg| match arg {\n+            AsmArg::Template(template) => s.print_string(&template, ast::StrStyle::Cooked),\n+            AsmArg::Operand(op) => {\n+                let print_reg_or_class = |s: &mut Self, r: &InlineAsmRegOrRegClass| match r {\n+                    InlineAsmRegOrRegClass::Reg(r) => s.print_symbol(*r, ast::StrStyle::Cooked),\n+                    InlineAsmRegOrRegClass::RegClass(r) => s.word(r.to_string()),\n+                };\n+                match op {\n+                    InlineAsmOperand::In { reg, expr } => {\n+                        s.word(\"in\");\n+                        s.popen();\n+                        print_reg_or_class(s, reg);\n+                        s.pclose();\n+                        s.space();\n+                        s.print_expr(expr);\n+                    }\n+                    InlineAsmOperand::Out { reg, late, expr } => {\n+                        s.word(if *late { \"lateout\" } else { \"out\" });\n+                        s.popen();\n+                        print_reg_or_class(s, reg);\n+                        s.pclose();\n+                        s.space();\n+                        match expr {\n+                            Some(expr) => s.print_expr(expr),\n+                            None => s.word(\"_\"),\n+                        }\n+                    }\n+                    InlineAsmOperand::InOut { reg, late, expr } => {\n+                        s.word(if *late { \"inlateout\" } else { \"inout\" });\n+                        s.popen();\n+                        print_reg_or_class(s, reg);\n+                        s.pclose();\n+                        s.space();\n+                        s.print_expr(expr);\n+                    }\n+                    InlineAsmOperand::SplitInOut { reg, late, in_expr, out_expr } => {\n+                        s.word(if *late { \"inlateout\" } else { \"inout\" });\n+                        s.popen();\n+                        print_reg_or_class(s, reg);\n+                        s.pclose();\n+                        s.space();\n+                        s.print_expr(in_expr);\n+                        s.space();\n+                        s.word_space(\"=>\");\n+                        match out_expr {\n+                            Some(out_expr) => s.print_expr(out_expr),\n+                            None => s.word(\"_\"),\n+                        }\n+                    }\n+                    InlineAsmOperand::Const { anon_const } => {\n+                        s.word(\"const\");\n+                        s.space();\n+                        s.print_expr(&anon_const.value);\n+                    }\n+                    InlineAsmOperand::Sym { expr } => {\n+                        s.word(\"sym\");\n+                        s.space();\n+                        s.print_expr(expr);\n+                    }\n+                }\n+            }\n+            AsmArg::Options(opts) => {\n+                s.word(\"options\");\n+                s.popen();\n+                let mut options = vec![];\n+                if opts.contains(InlineAsmOptions::PURE) {\n+                    options.push(\"pure\");\n+                }\n+                if opts.contains(InlineAsmOptions::NOMEM) {\n+                    options.push(\"nomem\");\n+                }\n+                if opts.contains(InlineAsmOptions::READONLY) {\n+                    options.push(\"readonly\");\n+                }\n+                if opts.contains(InlineAsmOptions::PRESERVES_FLAGS) {\n+                    options.push(\"preserves_flags\");\n+                }\n+                if opts.contains(InlineAsmOptions::NORETURN) {\n+                    options.push(\"noreturn\");\n+                }\n+                if opts.contains(InlineAsmOptions::NOSTACK) {\n+                    options.push(\"nostack\");\n+                }\n+                if opts.contains(InlineAsmOptions::ATT_SYNTAX) {\n+                    options.push(\"att_syntax\");\n+                }\n+                s.commasep(Inconsistent, &options, |s, &opt| {\n+                    s.word(opt);\n+                });\n+                s.pclose();\n+            }\n+        });\n+        self.pclose();\n+    }\n+\n     crate fn print_local_decl(&mut self, loc: &ast::Local) {\n         self.print_pat(&loc.pat);\n         if let Some(ref ty) = loc.ty {\n@@ -2292,10 +2291,6 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_usize(&mut self, i: usize) {\n-        self.s.word(i.to_string())\n-    }\n-\n     crate fn print_name(&mut self, name: Symbol) {\n         self.s.word(name.to_string());\n         self.ann.post(self, AnnNode::Name(&name))"}, {"sha": "20971ebb95748888568d994fbf31286e33ea2282", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 14, "deletions": 36, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -862,18 +862,6 @@ pub fn find_repr_attrs(sess: &Session, attr: &Attribute) -> Vec<ReprAttr> {\n         if let Some(items) = attr.meta_item_list() {\n             sess.mark_attr_used(attr);\n             for item in items {\n-                if !item.is_meta_item() {\n-                    handle_errors(\n-                        &sess.parse_sess,\n-                        item.span(),\n-                        AttrError::UnsupportedLiteral(\n-                            \"meta item in `repr` must be an identifier\",\n-                            false,\n-                        ),\n-                    );\n-                    continue;\n-                }\n-\n                 let mut recognised = false;\n                 if item.is_word() {\n                     let hint = match item.name_or_empty() {\n@@ -890,23 +878,6 @@ pub fn find_repr_attrs(sess: &Session, attr: &Attribute) -> Vec<ReprAttr> {\n                         acc.push(h);\n                     }\n                 } else if let Some((name, value)) = item.name_value_literal() {\n-                    let parse_alignment = |node: &ast::LitKind| -> Result<u32, &'static str> {\n-                        if let ast::LitKind::Int(literal, ast::LitIntType::Unsuffixed) = node {\n-                            if literal.is_power_of_two() {\n-                                // rustc_middle::ty::layout::Align restricts align to <= 2^29\n-                                if *literal <= 1 << 29 {\n-                                    Ok(*literal as u32)\n-                                } else {\n-                                    Err(\"larger than 2^29\")\n-                                }\n-                            } else {\n-                                Err(\"not a power of two\")\n-                            }\n-                        } else {\n-                            Err(\"not an unsuffixed integer\")\n-                        }\n-                    };\n-\n                     let mut literal_error = None;\n                     if name == sym::align {\n                         recognised = true;\n@@ -966,13 +937,7 @@ pub fn find_repr_attrs(sess: &Session, attr: &Attribute) -> Vec<ReprAttr> {\n                 }\n                 if !recognised {\n                     // Not a word we recognize\n-                    struct_span_err!(\n-                        diagnostic,\n-                        item.span(),\n-                        E0552,\n-                        \"unrecognized representation hint\"\n-                    )\n-                    .emit();\n+                    diagnostic.delay_span_bug(item.span(), \"unrecognized representation hint\");\n                 }\n             }\n         }\n@@ -1080,3 +1045,16 @@ fn allow_unstable<'a>(\n         name\n     })\n }\n+\n+pub fn parse_alignment(node: &ast::LitKind) -> Result<u32, &'static str> {\n+    if let ast::LitKind::Int(literal, ast::LitIntType::Unsuffixed) = node {\n+        if literal.is_power_of_two() {\n+            // rustc_middle::ty::layout::Align restricts align to <= 2^29\n+            if *literal <= 1 << 29 { Ok(*literal as u32) } else { Err(\"larger than 2^29\") }\n+        } else {\n+            Err(\"not a power of two\")\n+        }\n+    } else {\n+        Err(\"not an unsuffixed integer\")\n+    }\n+}"}, {"sha": "3fb11f77872bee95a28114e89d9e7aabc4270c1b", "filename": "compiler/rustc_attr/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_attr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_attr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Flib.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -4,8 +4,6 @@\n //! The goal is to move the definition of `MetaItem` and things that don't need to be in `syntax`\n //! to this crate.\n \n-#![cfg_attr(bootstrap, feature(or_patterns))]\n-\n #[macro_use]\n extern crate rustc_macros;\n "}, {"sha": "b28c6f0d99c5e0ebb5ac2d5708d4663f5a235144", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 75, "deletions": 31, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -8,9 +8,11 @@ use rustc_expand::base::{self, *};\n use rustc_parse::parser::Parser;\n use rustc_parse_format as parse;\n use rustc_session::lint;\n+use rustc_span::symbol::Ident;\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::{InnerSpan, Span};\n use rustc_target::asm::InlineAsmArch;\n+use smallvec::smallvec;\n \n struct AsmArgs {\n     templates: Vec<P<ast::Expr>>,\n@@ -25,6 +27,7 @@ fn parse_args<'a>(\n     ecx: &mut ExtCtxt<'a>,\n     sp: Span,\n     tts: TokenStream,\n+    is_global_asm: bool,\n ) -> Result<AsmArgs, DiagnosticBuilder<'a>> {\n     let mut p = ecx.new_parser_from_tts(tts);\n \n@@ -33,7 +36,7 @@ fn parse_args<'a>(\n     }\n \n     // Detect use of the legacy llvm_asm! syntax (which used to be called asm!)\n-    if p.look_ahead(1, |t| *t == token::Colon || *t == token::ModSep) {\n+    if !is_global_asm && p.look_ahead(1, |t| *t == token::Colon || *t == token::ModSep) {\n         let mut err =\n             ecx.struct_span_err(sp, \"the legacy LLVM-style asm! syntax is no longer supported\");\n         err.note(\"consider migrating to the new asm! syntax specified in RFC 2873\");\n@@ -84,7 +87,7 @@ fn parse_args<'a>(\n \n         // Parse options\n         if p.eat_keyword(sym::options) {\n-            parse_options(&mut p, &mut args)?;\n+            parse_options(&mut p, &mut args, is_global_asm)?;\n             allow_templates = false;\n             continue;\n         }\n@@ -103,19 +106,19 @@ fn parse_args<'a>(\n         };\n \n         let mut explicit_reg = false;\n-        let op = if p.eat_keyword(kw::In) {\n+        let op = if !is_global_asm && p.eat_keyword(kw::In) {\n             let reg = parse_reg(&mut p, &mut explicit_reg)?;\n             let expr = p.parse_expr()?;\n             ast::InlineAsmOperand::In { reg, expr }\n-        } else if p.eat_keyword(sym::out) {\n+        } else if !is_global_asm && p.eat_keyword(sym::out) {\n             let reg = parse_reg(&mut p, &mut explicit_reg)?;\n             let expr = if p.eat_keyword(kw::Underscore) { None } else { Some(p.parse_expr()?) };\n             ast::InlineAsmOperand::Out { reg, expr, late: false }\n-        } else if p.eat_keyword(sym::lateout) {\n+        } else if !is_global_asm && p.eat_keyword(sym::lateout) {\n             let reg = parse_reg(&mut p, &mut explicit_reg)?;\n             let expr = if p.eat_keyword(kw::Underscore) { None } else { Some(p.parse_expr()?) };\n             ast::InlineAsmOperand::Out { reg, expr, late: true }\n-        } else if p.eat_keyword(sym::inout) {\n+        } else if !is_global_asm && p.eat_keyword(sym::inout) {\n             let reg = parse_reg(&mut p, &mut explicit_reg)?;\n             let expr = p.parse_expr()?;\n             if p.eat(&token::FatArrow) {\n@@ -125,7 +128,7 @@ fn parse_args<'a>(\n             } else {\n                 ast::InlineAsmOperand::InOut { reg, expr, late: false }\n             }\n-        } else if p.eat_keyword(sym::inlateout) {\n+        } else if !is_global_asm && p.eat_keyword(sym::inlateout) {\n             let reg = parse_reg(&mut p, &mut explicit_reg)?;\n             let expr = p.parse_expr()?;\n             if p.eat(&token::FatArrow) {\n@@ -136,9 +139,9 @@ fn parse_args<'a>(\n                 ast::InlineAsmOperand::InOut { reg, expr, late: true }\n             }\n         } else if p.eat_keyword(kw::Const) {\n-            let expr = p.parse_expr()?;\n-            ast::InlineAsmOperand::Const { expr }\n-        } else if p.eat_keyword(sym::sym) {\n+            let anon_const = p.parse_anon_const_expr()?;\n+            ast::InlineAsmOperand::Const { anon_const }\n+        } else if !is_global_asm && p.eat_keyword(sym::sym) {\n             let expr = p.parse_expr()?;\n             match expr.kind {\n                 ast::ExprKind::Path(..) => {}\n@@ -329,23 +332,27 @@ fn try_set_option<'a>(\n     }\n }\n \n-fn parse_options<'a>(p: &mut Parser<'a>, args: &mut AsmArgs) -> Result<(), DiagnosticBuilder<'a>> {\n+fn parse_options<'a>(\n+    p: &mut Parser<'a>,\n+    args: &mut AsmArgs,\n+    is_global_asm: bool,\n+) -> Result<(), DiagnosticBuilder<'a>> {\n     let span_start = p.prev_token.span;\n \n     p.expect(&token::OpenDelim(token::DelimToken::Paren))?;\n \n     while !p.eat(&token::CloseDelim(token::DelimToken::Paren)) {\n-        if p.eat_keyword(sym::pure) {\n+        if !is_global_asm && p.eat_keyword(sym::pure) {\n             try_set_option(p, args, sym::pure, ast::InlineAsmOptions::PURE);\n-        } else if p.eat_keyword(sym::nomem) {\n+        } else if !is_global_asm && p.eat_keyword(sym::nomem) {\n             try_set_option(p, args, sym::nomem, ast::InlineAsmOptions::NOMEM);\n-        } else if p.eat_keyword(sym::readonly) {\n+        } else if !is_global_asm && p.eat_keyword(sym::readonly) {\n             try_set_option(p, args, sym::readonly, ast::InlineAsmOptions::READONLY);\n-        } else if p.eat_keyword(sym::preserves_flags) {\n+        } else if !is_global_asm && p.eat_keyword(sym::preserves_flags) {\n             try_set_option(p, args, sym::preserves_flags, ast::InlineAsmOptions::PRESERVES_FLAGS);\n-        } else if p.eat_keyword(sym::noreturn) {\n+        } else if !is_global_asm && p.eat_keyword(sym::noreturn) {\n             try_set_option(p, args, sym::noreturn, ast::InlineAsmOptions::NORETURN);\n-        } else if p.eat_keyword(sym::nostack) {\n+        } else if !is_global_asm && p.eat_keyword(sym::nostack) {\n             try_set_option(p, args, sym::nostack, ast::InlineAsmOptions::NOSTACK);\n         } else if p.eat_keyword(sym::att_syntax) {\n             try_set_option(p, args, sym::att_syntax, ast::InlineAsmOptions::ATT_SYNTAX);\n@@ -388,7 +395,7 @@ fn parse_reg<'a>(\n     Ok(result)\n }\n \n-fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, sp: Span, args: AsmArgs) -> P<ast::Expr> {\n+fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, args: AsmArgs) -> Option<ast::InlineAsm> {\n     let mut template = vec![];\n     // Register operands are implicitly used since they are not allowed to be\n     // referenced in the template string.\n@@ -415,7 +422,7 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, sp: Span, args: AsmArgs) -> P<ast\n                     if let Some(mut err) = err {\n                         err.emit();\n                     }\n-                    return DummyResult::raw_expr(sp, true);\n+                    return None;\n                 }\n             };\n \n@@ -492,7 +499,7 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, sp: Span, args: AsmArgs) -> P<ast\n                 e.span_label(err_sp, label);\n             }\n             e.emit();\n-            return DummyResult::raw_expr(sp, true);\n+            return None;\n         }\n \n         curarg = parser.curarg;\n@@ -643,24 +650,61 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, sp: Span, args: AsmArgs) -> P<ast\n         }\n     }\n \n-    let inline_asm =\n-        ast::InlineAsm { template, operands: args.operands, options: args.options, line_spans };\n-    P(ast::Expr {\n-        id: ast::DUMMY_NODE_ID,\n-        kind: ast::ExprKind::InlineAsm(P(inline_asm)),\n-        span: sp,\n-        attrs: ast::AttrVec::new(),\n-        tokens: None,\n-    })\n+    Some(ast::InlineAsm { template, operands: args.operands, options: args.options, line_spans })\n }\n \n pub fn expand_asm<'cx>(\n     ecx: &'cx mut ExtCtxt<'_>,\n     sp: Span,\n     tts: TokenStream,\n ) -> Box<dyn base::MacResult + 'cx> {\n-    match parse_args(ecx, sp, tts) {\n-        Ok(args) => MacEager::expr(expand_preparsed_asm(ecx, sp, args)),\n+    match parse_args(ecx, sp, tts, false) {\n+        Ok(args) => {\n+            let expr = if let Some(inline_asm) = expand_preparsed_asm(ecx, args) {\n+                P(ast::Expr {\n+                    id: ast::DUMMY_NODE_ID,\n+                    kind: ast::ExprKind::InlineAsm(P(inline_asm)),\n+                    span: sp,\n+                    attrs: ast::AttrVec::new(),\n+                    tokens: None,\n+                })\n+            } else {\n+                DummyResult::raw_expr(sp, true)\n+            };\n+            MacEager::expr(expr)\n+        }\n+        Err(mut err) => {\n+            err.emit();\n+            DummyResult::any(sp)\n+        }\n+    }\n+}\n+\n+pub fn expand_global_asm<'cx>(\n+    ecx: &'cx mut ExtCtxt<'_>,\n+    sp: Span,\n+    tts: TokenStream,\n+) -> Box<dyn base::MacResult + 'cx> {\n+    match parse_args(ecx, sp, tts, true) {\n+        Ok(args) => {\n+            if let Some(inline_asm) = expand_preparsed_asm(ecx, args) {\n+                MacEager::items(smallvec![P(ast::Item {\n+                    ident: Ident::invalid(),\n+                    attrs: Vec::new(),\n+                    id: ast::DUMMY_NODE_ID,\n+                    kind: ast::ItemKind::GlobalAsm(inline_asm),\n+                    vis: ast::Visibility {\n+                        span: sp.shrink_to_lo(),\n+                        kind: ast::VisibilityKind::Inherited,\n+                        tokens: None,\n+                    },\n+                    span: ecx.with_def_site_ctxt(sp),\n+                    tokens: None,\n+                })])\n+            } else {\n+                DummyResult::any(sp)\n+            }\n+        }\n         Err(mut err) => {\n             err.emit();\n             DummyResult::any(sp)"}, {"sha": "79dc857074d5990ae1320deea5668f8db9c922eb", "filename": "compiler/rustc_builtin_macros/src/cfg_eval.rs", "status": "modified", "additions": 167, "deletions": 55, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -1,11 +1,18 @@\n use crate::util::check_builtin_macro_attribute;\n \n-use rustc_ast::mut_visit::{self, MutVisitor};\n-use rustc_ast::ptr::P;\n-use rustc_ast::{self as ast, AstLike};\n+use rustc_ast as ast;\n+use rustc_ast::mut_visit::MutVisitor;\n+use rustc_ast::tokenstream::CanSynthesizeMissingTokens;\n+use rustc_ast::visit::Visitor;\n+use rustc_ast::{mut_visit, visit};\n+use rustc_ast::{AstLike, Attribute};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_expand::config::StripUnconfigured;\n use rustc_expand::configure;\n+use rustc_parse::parser::ForceCollect;\n+use rustc_session::utils::FlattenNonterminals;\n+\n+use rustc_ast::ptr::P;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n use smallvec::SmallVec;\n@@ -22,74 +29,179 @@ crate fn expand(\n \n crate fn cfg_eval(ecx: &ExtCtxt<'_>, annotatable: Annotatable) -> Vec<Annotatable> {\n     let mut visitor = CfgEval {\n-        cfg: StripUnconfigured { sess: ecx.sess, features: ecx.ecfg.features, modified: false },\n+        cfg: &mut StripUnconfigured {\n+            sess: ecx.sess,\n+            features: ecx.ecfg.features,\n+            config_tokens: true,\n+        },\n     };\n-    let mut annotatable = visitor.configure_annotatable(annotatable);\n-    if visitor.cfg.modified {\n-        // Erase the tokens if cfg-stripping modified the item\n-        // This will cause us to synthesize fake tokens\n-        // when `nt_to_tokenstream` is called on this item.\n-        if let Some(tokens) = annotatable.tokens_mut() {\n-            *tokens = None;\n+    let annotatable = visitor.configure_annotatable(annotatable);\n+    vec![annotatable]\n+}\n+\n+struct CfgEval<'a, 'b> {\n+    cfg: &'a mut StripUnconfigured<'b>,\n+}\n+\n+fn flat_map_annotatable(vis: &mut impl MutVisitor, annotatable: Annotatable) -> Annotatable {\n+    // Since the item itself has already been configured by the InvocationCollector,\n+    // we know that fold result vector will contain exactly one element\n+    match annotatable {\n+        Annotatable::Item(item) => Annotatable::Item(vis.flat_map_item(item).pop().unwrap()),\n+        Annotatable::TraitItem(item) => {\n+            Annotatable::TraitItem(vis.flat_map_trait_item(item).pop().unwrap())\n+        }\n+        Annotatable::ImplItem(item) => {\n+            Annotatable::ImplItem(vis.flat_map_impl_item(item).pop().unwrap())\n+        }\n+        Annotatable::ForeignItem(item) => {\n+            Annotatable::ForeignItem(vis.flat_map_foreign_item(item).pop().unwrap())\n         }\n+        Annotatable::Stmt(stmt) => {\n+            Annotatable::Stmt(stmt.map(|stmt| vis.flat_map_stmt(stmt).pop().unwrap()))\n+        }\n+        Annotatable::Expr(mut expr) => Annotatable::Expr({\n+            vis.visit_expr(&mut expr);\n+            expr\n+        }),\n+        Annotatable::Arm(arm) => Annotatable::Arm(vis.flat_map_arm(arm).pop().unwrap()),\n+        Annotatable::ExprField(field) => {\n+            Annotatable::ExprField(vis.flat_map_expr_field(field).pop().unwrap())\n+        }\n+        Annotatable::PatField(fp) => {\n+            Annotatable::PatField(vis.flat_map_pat_field(fp).pop().unwrap())\n+        }\n+        Annotatable::GenericParam(param) => {\n+            Annotatable::GenericParam(vis.flat_map_generic_param(param).pop().unwrap())\n+        }\n+        Annotatable::Param(param) => Annotatable::Param(vis.flat_map_param(param).pop().unwrap()),\n+        Annotatable::FieldDef(sf) => {\n+            Annotatable::FieldDef(vis.flat_map_field_def(sf).pop().unwrap())\n+        }\n+        Annotatable::Variant(v) => Annotatable::Variant(vis.flat_map_variant(v).pop().unwrap()),\n+    }\n+}\n+\n+struct CfgFinder {\n+    has_cfg_or_cfg_attr: bool,\n+}\n+\n+impl CfgFinder {\n+    fn has_cfg_or_cfg_attr(annotatable: &Annotatable) -> bool {\n+        let mut finder = CfgFinder { has_cfg_or_cfg_attr: false };\n+        match annotatable {\n+            Annotatable::Item(item) => finder.visit_item(&item),\n+            Annotatable::TraitItem(item) => finder.visit_assoc_item(&item, visit::AssocCtxt::Trait),\n+            Annotatable::ImplItem(item) => finder.visit_assoc_item(&item, visit::AssocCtxt::Impl),\n+            Annotatable::ForeignItem(item) => finder.visit_foreign_item(&item),\n+            Annotatable::Stmt(stmt) => finder.visit_stmt(&stmt),\n+            Annotatable::Expr(expr) => finder.visit_expr(&expr),\n+            Annotatable::Arm(arm) => finder.visit_arm(&arm),\n+            Annotatable::ExprField(field) => finder.visit_expr_field(&field),\n+            Annotatable::PatField(field) => finder.visit_pat_field(&field),\n+            Annotatable::GenericParam(param) => finder.visit_generic_param(&param),\n+            Annotatable::Param(param) => finder.visit_param(&param),\n+            Annotatable::FieldDef(field) => finder.visit_field_def(&field),\n+            Annotatable::Variant(variant) => finder.visit_variant(&variant),\n+        };\n+        finder.has_cfg_or_cfg_attr\n     }\n-    vec![annotatable]\n }\n \n-struct CfgEval<'a> {\n-    cfg: StripUnconfigured<'a>,\n+impl<'ast> visit::Visitor<'ast> for CfgFinder {\n+    fn visit_attribute(&mut self, attr: &'ast Attribute) {\n+        // We want short-circuiting behavior, so don't use the '|=' operator.\n+        self.has_cfg_or_cfg_attr = self.has_cfg_or_cfg_attr\n+            || attr\n+                .ident()\n+                .map_or(false, |ident| ident.name == sym::cfg || ident.name == sym::cfg_attr);\n+    }\n }\n \n-impl CfgEval<'_> {\n+impl CfgEval<'_, '_> {\n     fn configure<T: AstLike>(&mut self, node: T) -> Option<T> {\n         self.cfg.configure(node)\n     }\n \n-    fn configure_annotatable(&mut self, annotatable: Annotatable) -> Annotatable {\n-        // Since the item itself has already been configured by the InvocationCollector,\n-        // we know that fold result vector will contain exactly one element\n-        match annotatable {\n-            Annotatable::Item(item) => Annotatable::Item(self.flat_map_item(item).pop().unwrap()),\n-            Annotatable::TraitItem(item) => {\n-                Annotatable::TraitItem(self.flat_map_trait_item(item).pop().unwrap())\n-            }\n-            Annotatable::ImplItem(item) => {\n-                Annotatable::ImplItem(self.flat_map_impl_item(item).pop().unwrap())\n-            }\n-            Annotatable::ForeignItem(item) => {\n-                Annotatable::ForeignItem(self.flat_map_foreign_item(item).pop().unwrap())\n-            }\n-            Annotatable::Stmt(stmt) => {\n-                Annotatable::Stmt(stmt.map(|stmt| self.flat_map_stmt(stmt).pop().unwrap()))\n-            }\n-            Annotatable::Expr(mut expr) => Annotatable::Expr({\n-                self.visit_expr(&mut expr);\n-                expr\n-            }),\n-            Annotatable::Arm(arm) => Annotatable::Arm(self.flat_map_arm(arm).pop().unwrap()),\n-            Annotatable::ExprField(field) => {\n-                Annotatable::ExprField(self.flat_map_expr_field(field).pop().unwrap())\n-            }\n-            Annotatable::PatField(fp) => {\n-                Annotatable::PatField(self.flat_map_pat_field(fp).pop().unwrap())\n-            }\n-            Annotatable::GenericParam(param) => {\n-                Annotatable::GenericParam(self.flat_map_generic_param(param).pop().unwrap())\n-            }\n-            Annotatable::Param(param) => {\n-                Annotatable::Param(self.flat_map_param(param).pop().unwrap())\n-            }\n-            Annotatable::FieldDef(sf) => {\n-                Annotatable::FieldDef(self.flat_map_field_def(sf).pop().unwrap())\n+    pub fn configure_annotatable(&mut self, mut annotatable: Annotatable) -> Annotatable {\n+        // Tokenizing and re-parsing the `Annotatable` can have a significant\n+        // performance impact, so try to avoid it if possible\n+        if !CfgFinder::has_cfg_or_cfg_attr(&annotatable) {\n+            return annotatable;\n+        }\n+\n+        // The majority of parsed attribute targets will never need to have early cfg-expansion\n+        // run (e.g. they are not part of a `#[derive]` or `#[cfg_eval]` macro inoput).\n+        // Therefore, we normally do not capture the necessary information about `#[cfg]`\n+        // and `#[cfg_attr]` attributes during parsing.\n+        //\n+        // Therefore, when we actually *do* run early cfg-expansion, we need to tokenize\n+        // and re-parse the attribute target, this time capturing information about\n+        // the location of `#[cfg]` and `#[cfg_attr]` in the token stream. The tokenization\n+        // process is lossless, so this process is invisible to proc-macros.\n+\n+        // FIXME - get rid of this clone\n+        let nt = annotatable.clone().into_nonterminal();\n+\n+        let mut orig_tokens = rustc_parse::nt_to_tokenstream(\n+            &nt,\n+            &self.cfg.sess.parse_sess,\n+            CanSynthesizeMissingTokens::No,\n+        );\n+\n+        // 'Flatten' all nonterminals (i.e. `TokenKind::Interpolated`)\n+        // to `None`-delimited groups containing the corresponding tokens. This\n+        // is normally delayed until the proc-macro server actually needs to\n+        // provide a `TokenKind::Interpolated` to a proc-macro. We do this earlier,\n+        // so that we can handle cases like:\n+        //\n+        // ```rust\n+        // #[cfg_eval] #[cfg] $item\n+        //```\n+        //\n+        // where `$item` is `#[cfg_attr] struct Foo {}`. We want to make\n+        // sure to evaluate *all* `#[cfg]` and `#[cfg_attr]` attributes - the simplest\n+        // way to do this is to do a single parse of a stream without any nonterminals.\n+        let mut flatten = FlattenNonterminals {\n+            nt_to_tokenstream: rustc_parse::nt_to_tokenstream,\n+            parse_sess: &self.cfg.sess.parse_sess,\n+            synthesize_tokens: CanSynthesizeMissingTokens::No,\n+        };\n+        orig_tokens = flatten.process_token_stream(orig_tokens);\n+\n+        // Re-parse the tokens, setting the `capture_cfg` flag to save extra information\n+        // to the captured `AttrAnnotatedTokenStream` (specifically, we capture\n+        // `AttrAnnotatedTokenTree::AttributesData` for all occurences of `#[cfg]` and `#[cfg_attr]`)\n+        let mut parser =\n+            rustc_parse::stream_to_parser(&self.cfg.sess.parse_sess, orig_tokens, None);\n+        parser.capture_cfg = true;\n+        annotatable = match annotatable {\n+            Annotatable::Item(_) => {\n+                Annotatable::Item(parser.parse_item(ForceCollect::Yes).unwrap().unwrap())\n             }\n-            Annotatable::Variant(v) => {\n-                Annotatable::Variant(self.flat_map_variant(v).pop().unwrap())\n+            Annotatable::TraitItem(_) => Annotatable::TraitItem(\n+                parser.parse_trait_item(ForceCollect::Yes).unwrap().unwrap().unwrap(),\n+            ),\n+            Annotatable::ImplItem(_) => Annotatable::ImplItem(\n+                parser.parse_impl_item(ForceCollect::Yes).unwrap().unwrap().unwrap(),\n+            ),\n+            Annotatable::ForeignItem(_) => Annotatable::ForeignItem(\n+                parser.parse_foreign_item(ForceCollect::Yes).unwrap().unwrap().unwrap(),\n+            ),\n+            Annotatable::Stmt(_) => {\n+                Annotatable::Stmt(P(parser.parse_stmt(ForceCollect::Yes).unwrap().unwrap()))\n             }\n-        }\n+            Annotatable::Expr(_) => Annotatable::Expr(parser.parse_expr_force_collect().unwrap()),\n+            _ => unreachable!(),\n+        };\n+\n+        // Now that we have our re-parsed `AttrAnnotatedTokenStream`, recursively configuring\n+        // our attribute target will correctly the tokens as well.\n+        flat_map_annotatable(self, annotatable)\n     }\n }\n \n-impl MutVisitor for CfgEval<'_> {\n+impl MutVisitor for CfgEval<'_, '_> {\n     fn visit_expr(&mut self, expr: &mut P<ast::Expr>) {\n         self.cfg.configure_expr(expr);\n         mut_visit::noop_visit_expr(expr, self);"}, {"sha": "1bb050a40cee23c813d617f5d024bded7b38a3e6", "filename": "compiler/rustc_builtin_macros/src/derive.rs", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -1,6 +1,6 @@\n use crate::cfg_eval::cfg_eval;\n \n-use rustc_ast::{self as ast, token, ItemKind, MetaItemKind, NestedMetaItem, StmtKind};\n+use rustc_ast::{self as ast, attr, token, ItemKind, MetaItemKind, NestedMetaItem, StmtKind};\n use rustc_errors::{struct_span_err, Applicability};\n use rustc_expand::base::{Annotatable, ExpandResult, ExtCtxt, Indeterminate, MultiItemModifier};\n use rustc_feature::AttributeTemplate;\n@@ -26,32 +26,39 @@ impl MultiItemModifier for Expander {\n             return ExpandResult::Ready(vec![item]);\n         }\n \n-        let template =\n-            AttributeTemplate { list: Some(\"Trait1, Trait2, ...\"), ..Default::default() };\n-        let attr = ecx.attribute(meta_item.clone());\n-        validate_attr::check_builtin_attribute(&sess.parse_sess, &attr, sym::derive, template);\n+        let result =\n+            ecx.resolver.resolve_derives(ecx.current_expansion.id, ecx.force_mode, &|| {\n+                let template =\n+                    AttributeTemplate { list: Some(\"Trait1, Trait2, ...\"), ..Default::default() };\n+                let attr = attr::mk_attr_outer(meta_item.clone());\n+                validate_attr::check_builtin_attribute(\n+                    &sess.parse_sess,\n+                    &attr,\n+                    sym::derive,\n+                    template,\n+                );\n \n-        let derives: Vec<_> = attr\n-            .meta_item_list()\n-            .unwrap_or_default()\n-            .into_iter()\n-            .filter_map(|nested_meta| match nested_meta {\n-                NestedMetaItem::MetaItem(meta) => Some(meta),\n-                NestedMetaItem::Literal(lit) => {\n-                    // Reject `#[derive(\"Debug\")]`.\n-                    report_unexpected_literal(sess, &lit);\n-                    None\n-                }\n-            })\n-            .map(|meta| {\n-                // Reject `#[derive(Debug = \"value\", Debug(abc))]`, but recover the paths.\n-                report_path_args(sess, &meta);\n-                meta.path\n-            })\n-            .collect();\n+                attr.meta_item_list()\n+                    .unwrap_or_default()\n+                    .into_iter()\n+                    .filter_map(|nested_meta| match nested_meta {\n+                        NestedMetaItem::MetaItem(meta) => Some(meta),\n+                        NestedMetaItem::Literal(lit) => {\n+                            // Reject `#[derive(\"Debug\")]`.\n+                            report_unexpected_literal(sess, &lit);\n+                            None\n+                        }\n+                    })\n+                    .map(|meta| {\n+                        // Reject `#[derive(Debug = \"value\", Debug(abc))]`, but recover the paths.\n+                        report_path_args(sess, &meta);\n+                        meta.path\n+                    })\n+                    .map(|path| (path, None))\n+                    .collect()\n+            });\n \n-        // FIXME: Try to cache intermediate results to avoid collecting same paths multiple times.\n-        match ecx.resolver.resolve_derives(ecx.current_expansion.id, derives, ecx.force_mode) {\n+        match result {\n             Ok(()) => ExpandResult::Ready(cfg_eval(ecx, item)),\n             Err(Indeterminate) => ExpandResult::Retry(item),\n         }"}, {"sha": "54ab88dc3ffc9abd2949be3aef93a4edb8e0a406", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/eq.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -15,10 +15,12 @@ pub fn expand_deriving_eq(\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n ) {\n+    let span = cx.with_def_site_ctxt(span);\n     let inline = cx.meta_word(span, sym::inline);\n     let hidden = rustc_ast::attr::mk_nested_word_item(Ident::new(sym::hidden, span));\n     let doc = rustc_ast::attr::mk_list_item(Ident::new(sym::doc, span), vec![hidden]);\n-    let attrs = vec![cx.attribute(inline), cx.attribute(doc)];\n+    let no_coverage = cx.meta_word(span, sym::no_coverage);\n+    let attrs = vec![cx.attribute(inline), cx.attribute(doc), cx.attribute(no_coverage)];\n     let trait_def = TraitDef {\n         span,\n         attributes: Vec::new(),"}, {"sha": "a3decff3ae7e1892fa075881cb859a80fc41a697", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -541,7 +541,7 @@ impl<'a> TraitDef<'a> {\n             self.generics.to_generics(cx, self.span, type_ident, generics);\n \n         // Create the generic parameters\n-        params.extend(generics.params.iter().map(|param| match param.kind {\n+        params.extend(generics.params.iter().map(|param| match &param.kind {\n             GenericParamKind::Lifetime { .. } => param.clone(),\n             GenericParamKind::Type { .. } => {\n                 // I don't think this can be moved out of the loop, since\n@@ -561,7 +561,18 @@ impl<'a> TraitDef<'a> {\n \n                 cx.typaram(self.span, param.ident, vec![], bounds, None)\n             }\n-            GenericParamKind::Const { .. } => param.clone(),\n+            GenericParamKind::Const { ty, kw_span, .. } => {\n+                let const_nodefault_kind = GenericParamKind::Const {\n+                    ty: ty.clone(),\n+                    kw_span: kw_span.clone(),\n+\n+                    // We can't have default values inside impl block\n+                    default: None,\n+                };\n+                let mut param_clone = param.clone();\n+                param_clone.kind = const_nodefault_kind;\n+                param_clone\n+            }\n         }));\n \n         // and similarly for where clauses"}, {"sha": "76d874529270e179167c66ce5a78fc0d9765e568", "filename": "compiler/rustc_builtin_macros/src/global_asm.rs", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/3b2b5b2914d40aa011d189bfe546084cdee53dbe/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b2b5b2914d40aa011d189bfe546084cdee53dbe/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_asm.rs?ref=3b2b5b2914d40aa011d189bfe546084cdee53dbe", "patch": "@@ -1,68 +0,0 @@\n-//! Module-level assembly support.\n-//!\n-//! The macro defined here allows you to specify \"top-level\",\n-//! \"file-scoped\", or \"module-level\" assembly. These synonyms\n-//! all correspond to LLVM's module-level inline assembly instruction.\n-//!\n-//! For example, `global_asm!(\"some assembly here\")` codegens to\n-//! LLVM's `module asm \"some assembly here\"`. All of LLVM's caveats\n-//! therefore apply.\n-\n-use rustc_ast as ast;\n-use rustc_ast::ptr::P;\n-use rustc_ast::token;\n-use rustc_ast::tokenstream::TokenStream;\n-use rustc_errors::DiagnosticBuilder;\n-use rustc_expand::base::{self, *};\n-use rustc_span::symbol::Ident;\n-use rustc_span::Span;\n-use smallvec::smallvec;\n-\n-pub fn expand_global_asm<'cx>(\n-    cx: &'cx mut ExtCtxt<'_>,\n-    sp: Span,\n-    tts: TokenStream,\n-) -> Box<dyn base::MacResult + 'cx> {\n-    match parse_global_asm(cx, sp, tts) {\n-        Ok(Some(global_asm)) => MacEager::items(smallvec![P(ast::Item {\n-            ident: Ident::invalid(),\n-            attrs: Vec::new(),\n-            id: ast::DUMMY_NODE_ID,\n-            kind: ast::ItemKind::GlobalAsm(global_asm),\n-            vis: ast::Visibility {\n-                span: sp.shrink_to_lo(),\n-                kind: ast::VisibilityKind::Inherited,\n-                tokens: None,\n-            },\n-            span: cx.with_def_site_ctxt(sp),\n-            tokens: None,\n-        })]),\n-        Ok(None) => DummyResult::any(sp),\n-        Err(mut err) => {\n-            err.emit();\n-            DummyResult::any(sp)\n-        }\n-    }\n-}\n-\n-fn parse_global_asm<'a>(\n-    cx: &mut ExtCtxt<'a>,\n-    sp: Span,\n-    tts: TokenStream,\n-) -> Result<Option<ast::GlobalAsm>, DiagnosticBuilder<'a>> {\n-    let mut p = cx.new_parser_from_tts(tts);\n-\n-    if p.token == token::Eof {\n-        let mut err = cx.struct_span_err(sp, \"macro requires a string literal as an argument\");\n-        err.span_label(sp, \"string literal required\");\n-        return Err(err);\n-    }\n-\n-    let expr = p.parse_expr()?;\n-    let (asm, _) = match expr_to_string(cx, expr, \"inline assembly must be a string literal\") {\n-        Some((s, st)) => (s, st),\n-        None => return Ok(None),\n-    };\n-\n-    Ok(Some(ast::GlobalAsm { asm }))\n-}"}, {"sha": "2393e0b9ebfac662e8b744d9b920f1190cdc1e76", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -9,7 +9,6 @@\n #![feature(decl_macro)]\n #![feature(iter_zip)]\n #![feature(nll)]\n-#![cfg_attr(bootstrap, feature(or_patterns))]\n #![feature(proc_macro_internals)]\n #![feature(proc_macro_quote)]\n #![recursion_limit = \"256\"]\n@@ -20,6 +19,7 @@ use crate::deriving::*;\n \n use rustc_expand::base::{MacroExpanderFn, ResolverExpand, SyntaxExtensionKind};\n use rustc_expand::proc_macro::BangProcMacro;\n+use rustc_span::def_id::LOCAL_CRATE;\n use rustc_span::symbol::sym;\n \n mod asm;\n@@ -36,7 +36,6 @@ mod env;\n mod format;\n mod format_foreign;\n mod global_allocator;\n-mod global_asm;\n mod llvm_asm;\n mod log_syntax;\n mod panic;\n@@ -74,7 +73,7 @@ pub fn register_builtin_macros(resolver: &mut dyn ResolverExpand) {\n         file: source_util::expand_file,\n         format_args_nl: format::expand_format_args_nl,\n         format_args: format::expand_format_args,\n-        global_asm: global_asm::expand_global_asm,\n+        global_asm: asm::expand_global_asm,\n         include_bytes: source_util::expand_include_bytes,\n         include_str: source_util::expand_include_str,\n         include: source_util::expand_include,\n@@ -114,5 +113,8 @@ pub fn register_builtin_macros(resolver: &mut dyn ResolverExpand) {\n     }\n \n     let client = proc_macro::bridge::client::Client::expand1(proc_macro::quote);\n-    register(sym::quote, SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client })));\n+    register(\n+        sym::quote,\n+        SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client, krate: LOCAL_CRATE })),\n+    );\n }"}, {"sha": "ccb9f15b0f50585effc0e1918fd6d718a18abcbc", "filename": "compiler/rustc_builtin_macros/src/source_util.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -61,7 +61,9 @@ pub fn expand_file(\n \n     let topmost = cx.expansion_cause().unwrap_or(sp);\n     let loc = cx.source_map().lookup_char_pos(topmost.lo());\n-    base::MacEager::expr(cx.expr_str(topmost, Symbol::intern(&loc.file.name.to_string())))\n+    base::MacEager::expr(\n+        cx.expr_str(topmost, Symbol::intern(&loc.file.name.prefer_remapped().to_string_lossy())),\n+    )\n }\n \n pub fn expand_stringify("}, {"sha": "c8a7ff67b4d507cceaca965827ad9f9d6d860110", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -142,7 +142,7 @@ fn entry_point_type(sess: &Session, item: &ast::Item, depth: usize) -> EntryPoin\n         ast::ItemKind::Fn(..) => {\n             if sess.contains_name(&item.attrs, sym::start) {\n                 EntryPointType::Start\n-            } else if sess.contains_name(&item.attrs, sym::main) {\n+            } else if sess.contains_name(&item.attrs, sym::rustc_main) {\n                 EntryPointType::MainAttr\n             } else if item.ident.name == sym::main {\n                 if depth == 1 {\n@@ -187,7 +187,7 @@ impl<'a> MutVisitor for EntryPointCleaner<'a> {\n                     let attrs = attrs\n                         .into_iter()\n                         .filter(|attr| {\n-                            !self.sess.check_name(attr, sym::main)\n+                            !self.sess.check_name(attr, sym::rustc_main)\n                                 && !self.sess.check_name(attr, sym::start)\n                         })\n                         .chain(iter::once(allow_dead_code))\n@@ -220,7 +220,7 @@ fn generate_test_harness(\n     let expn_id = ext_cx.resolver.expansion_for_ast_pass(\n         DUMMY_SP,\n         AstPass::TestHarness,\n-        &[sym::main, sym::test, sym::rustc_attrs],\n+        &[sym::test, sym::rustc_attrs],\n         None,\n     );\n     let def_site = DUMMY_SP.with_def_site_ctxt(expn_id);\n@@ -247,7 +247,7 @@ fn generate_test_harness(\n /// By default this expands to\n ///\n /// ```\n-/// #[main]\n+/// #[rustc_main]\n /// pub fn main() {\n ///     extern crate test;\n ///     test::test_main_static(&[\n@@ -297,8 +297,8 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n     let test_extern_stmt =\n         ecx.stmt_item(sp, ecx.item(sp, test_id, vec![], ast::ItemKind::ExternCrate(None)));\n \n-    // #[main]\n-    let main_meta = ecx.meta_word(sp, sym::main);\n+    // #[rustc_main]\n+    let main_meta = ecx.meta_word(sp, sym::rustc_main);\n     let main_attr = ecx.attribute(main_meta);\n \n     // pub fn main() { ... }"}, {"sha": "8c94a0aa5e6ebe7beba14d52e5ed817053529f8e", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/bootstrap_rustc.yml", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3b2b5b2914d40aa011d189bfe546084cdee53dbe/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fbootstrap_rustc.yml", "raw_url": "https://github.com/rust-lang/rust/raw/3b2b5b2914d40aa011d189bfe546084cdee53dbe/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fbootstrap_rustc.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fbootstrap_rustc.yml?ref=3b2b5b2914d40aa011d189bfe546084cdee53dbe", "patch": "@@ -1,44 +0,0 @@\n-name: Bootstrap rustc using cg_clif\n-\n-on:\n-  - push\n-\n-jobs:\n-  bootstrap_rustc:\n-    runs-on: ubuntu-latest\n-\n-    steps:\n-    - uses: actions/checkout@v2\n-\n-    - name: Cache cargo installed crates\n-      uses: actions/cache@v2\n-      with:\n-        path: ~/.cargo/bin\n-        key: ${{ runner.os }}-cargo-installed-crates\n-\n-    - name: Cache cargo registry and index\n-      uses: actions/cache@v2\n-      with:\n-        path: |\n-            ~/.cargo/registry\n-            ~/.cargo/git\n-        key: ${{ runner.os }}-cargo-registry-and-index-${{ hashFiles('**/Cargo.lock') }}\n-\n-    - name: Cache cargo target dir\n-      uses: actions/cache@v2\n-      with:\n-        path: target\n-        key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n-\n-    - name: Prepare dependencies\n-      run: |\n-        git config --global user.email \"user@example.com\"\n-        git config --global user.name \"User\"\n-        ./prepare.sh\n-\n-    - name: Test\n-      run: |\n-        # Enable backtraces for easier debugging\n-        export RUST_BACKTRACE=1\n-\n-        ./scripts/test_bootstrap.sh"}, {"sha": "4d45e36c956c908f5ee1f0f295a00b0dc6c95ec7", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/main.yml", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -7,11 +7,18 @@ on:\n jobs:\n   build:\n     runs-on: ${{ matrix.os }}\n+    timeout-minutes: 60\n \n     strategy:\n       fail-fast: false\n       matrix:\n-        os: [ubuntu-latest, macos-latest]\n+        include:\n+          - os: ubuntu-latest\n+          - os: macos-latest\n+          # cross-compile from Linux to Windows using mingw\n+          - os: ubuntu-latest\n+            env:\n+              TARGET_TRIPLE: x86_64-pc-windows-gnu\n \n     steps:\n     - uses: actions/checkout@v2\n@@ -36,13 +43,21 @@ jobs:\n         path: target\n         key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n \n+    - name: Install MinGW toolchain and wine\n+      if: matrix.os == 'ubuntu-latest' && matrix.env.TARGET_TRIPLE == 'x86_64-pc-windows-gnu'\n+      run: |\n+        sudo apt-get install -y gcc-mingw-w64-x86-64 wine-stable\n+        rustup target add x86_64-pc-windows-gnu\n+\n     - name: Prepare dependencies\n       run: |\n         git config --global user.email \"user@example.com\"\n         git config --global user.name \"User\"\n         ./prepare.sh\n \n     - name: Test\n+      env:\n+        TARGET_TRIPLE: ${{ matrix.env.TARGET_TRIPLE }}\n       run: |\n         # Enable backtraces for easier debugging\n         export RUST_BACKTRACE=1\n@@ -51,13 +66,24 @@ jobs:\n         export COMPILE_RUNS=2\n         export RUN_RUNS=2\n \n+        # Enable extra checks\n+        export CG_CLIF_ENABLE_VERIFIER=1\n+\n         ./test.sh\n \n     - name: Package prebuilt cg_clif\n       run: tar cvfJ cg_clif.tar.xz build\n \n     - name: Upload prebuilt cg_clif\n+      if: matrix.env.TARGET_TRIPLE != 'x86_64-pc-windows-gnu'\n       uses: actions/upload-artifact@v2\n       with:\n         name: cg_clif-${{ runner.os }}\n         path: cg_clif.tar.xz\n+\n+    - name: Upload prebuilt cg_clif (cross compile)\n+      if: matrix.env.TARGET_TRIPLE == 'x86_64-pc-windows-gnu'\n+      uses: actions/upload-artifact@v2\n+      with:\n+        name: cg_clif-${{ runner.os }}-cross-x86_64-mingw\n+        path: cg_clif.tar.xz"}, {"sha": "e01a92598bab745b4df24ef41bb5e50ccfef4701", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/rustc.yml", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Frustc.yml", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Frustc.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Frustc.yml?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -0,0 +1,82 @@\n+name: Various rustc tests\n+\n+on:\n+  - push\n+\n+jobs:\n+  bootstrap_rustc:\n+    runs-on: ubuntu-latest\n+\n+    steps:\n+    - uses: actions/checkout@v2\n+\n+    - name: Cache cargo installed crates\n+      uses: actions/cache@v2\n+      with:\n+        path: ~/.cargo/bin\n+        key: ${{ runner.os }}-cargo-installed-crates\n+\n+    - name: Cache cargo registry and index\n+      uses: actions/cache@v2\n+      with:\n+        path: |\n+            ~/.cargo/registry\n+            ~/.cargo/git\n+        key: ${{ runner.os }}-cargo-registry-and-index-${{ hashFiles('**/Cargo.lock') }}\n+\n+    - name: Cache cargo target dir\n+      uses: actions/cache@v2\n+      with:\n+        path: target\n+        key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n+\n+    - name: Prepare dependencies\n+      run: |\n+        git config --global user.email \"user@example.com\"\n+        git config --global user.name \"User\"\n+        ./prepare.sh\n+\n+    - name: Test\n+      run: |\n+        # Enable backtraces for easier debugging\n+        export RUST_BACKTRACE=1\n+\n+        ./scripts/test_bootstrap.sh\n+  rustc_test_suite:\n+    runs-on: ubuntu-latest\n+\n+    steps:\n+    - uses: actions/checkout@v2\n+\n+    - name: Cache cargo installed crates\n+      uses: actions/cache@v2\n+      with:\n+        path: ~/.cargo/bin\n+        key: ${{ runner.os }}-cargo-installed-crates\n+\n+    - name: Cache cargo registry and index\n+      uses: actions/cache@v2\n+      with:\n+        path: |\n+            ~/.cargo/registry\n+            ~/.cargo/git\n+        key: ${{ runner.os }}-cargo-registry-and-index-${{ hashFiles('**/Cargo.lock') }}\n+\n+    - name: Cache cargo target dir\n+      uses: actions/cache@v2\n+      with:\n+        path: target\n+        key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n+\n+    - name: Prepare dependencies\n+      run: |\n+        git config --global user.email \"user@example.com\"\n+        git config --global user.name \"User\"\n+        ./prepare.sh\n+\n+    - name: Test\n+      run: |\n+        # Enable backtraces for easier debugging\n+        export RUST_BACKTRACE=1\n+\n+        ./scripts/test_rustc_tests.sh"}, {"sha": "9009a532c54dcc91ac5ea9943a48ba63f0803bc9", "filename": "compiler/rustc_codegen_cranelift/.vscode/settings.json", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -1,8 +1,8 @@\n {\n     // source for rustc_* is not included in the rust-src component; disable the errors about this\n-    \"rust-analyzer.diagnostics.disabled\": [\"unresolved-extern-crate\", \"macro-error\"],\n+    \"rust-analyzer.diagnostics.disabled\": [\"unresolved-extern-crate\", \"unresolved-macro-call\"],\n     \"rust-analyzer.assist.importMergeBehavior\": \"last\",\n-    \"rust-analyzer.cargo.loadOutDirsFromCheck\": true,\n+    \"rust-analyzer.cargo.runBuildScripts\": true,\n     \"rust-analyzer.linkedProjects\": [\n         \"./Cargo.toml\",\n         //\"./build_sysroot/sysroot_src/src/libstd/Cargo.toml\","}, {"sha": "e6792def56796c2cc1ba0e328c73bb251a3404be", "filename": "compiler/rustc_codegen_cranelift/Cargo.lock", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.lock?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -39,16 +39,16 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"cranelift-bforest\"\n-version = \"0.70.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n+version = \"0.73.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#45bee40f338c631bff4a799288101ba328c7ad36\"\n dependencies = [\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen\"\n-version = \"0.70.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n+version = \"0.73.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#45bee40f338c631bff4a799288101ba328c7ad36\"\n dependencies = [\n  \"byteorder\",\n  \"cranelift-bforest\",\n@@ -65,27 +65,27 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-codegen-meta\"\n-version = \"0.70.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n+version = \"0.73.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#45bee40f338c631bff4a799288101ba328c7ad36\"\n dependencies = [\n  \"cranelift-codegen-shared\",\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen-shared\"\n-version = \"0.70.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n+version = \"0.73.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#45bee40f338c631bff4a799288101ba328c7ad36\"\n \n [[package]]\n name = \"cranelift-entity\"\n-version = \"0.70.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n+version = \"0.73.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#45bee40f338c631bff4a799288101ba328c7ad36\"\n \n [[package]]\n name = \"cranelift-frontend\"\n-version = \"0.70.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n+version = \"0.73.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#45bee40f338c631bff4a799288101ba328c7ad36\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"log\",\n@@ -95,8 +95,8 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-jit\"\n-version = \"0.70.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n+version = \"0.73.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#45bee40f338c631bff4a799288101ba328c7ad36\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -113,8 +113,8 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-module\"\n-version = \"0.70.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n+version = \"0.73.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#45bee40f338c631bff4a799288101ba328c7ad36\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -125,17 +125,17 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-native\"\n-version = \"0.70.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n+version = \"0.73.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#45bee40f338c631bff4a799288101ba328c7ad36\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"target-lexicon\",\n ]\n \n [[package]]\n name = \"cranelift-object\"\n-version = \"0.70.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n+version = \"0.73.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#45bee40f338c631bff4a799288101ba328c7ad36\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -306,6 +306,7 @@ dependencies = [\n  \"cranelift-frontend\",\n  \"cranelift-jit\",\n  \"cranelift-module\",\n+ \"cranelift-native\",\n  \"cranelift-object\",\n  \"gimli\",\n  \"indexmap\",\n@@ -334,9 +335,9 @@ dependencies = [\n \n [[package]]\n name = \"target-lexicon\"\n-version = \"0.11.2\"\n+version = \"0.12.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"422045212ea98508ae3d28025bc5aaa2bd4a9cdaecd442a08da2ee620ee9ea95\"\n+checksum = \"64ae3b39281e4b14b8123bdbaddd472b7dfe215e444181f2f9d2443c2444f834\"\n \n [[package]]\n name = \"thiserror\""}, {"sha": "2789207c65581ab380463f0ff114ddeb7a601159", "filename": "compiler/rustc_codegen_cranelift/Cargo.toml", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.toml?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -9,14 +9,15 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n # These have to be in sync with each other\n-cranelift-codegen = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\", features = [\"unwind\", \"x64\"] }\n+cranelift-codegen = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\", features = [\"unwind\"] }\n cranelift-frontend = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n cranelift-module = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n+cranelift-native = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n cranelift-jit = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\", optional = true }\n cranelift-object = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n-target-lexicon = \"0.11.0\"\n+target-lexicon = \"0.12.0\"\n gimli = { version = \"0.23.0\", default-features = false, features = [\"write\"]}\n-object = { version = \"0.23.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n+object = { version = \"0.23.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n \n ar = { git = \"https://github.com/bjorn3/rust-ar.git\", branch = \"do_not_remove_cg_clif_ranlib\" }\n indexmap = \"1.0.2\"\n@@ -28,6 +29,7 @@ smallvec = \"1.6.1\"\n #cranelift-codegen = { path = \"../wasmtime/cranelift/codegen\" }\n #cranelift-frontend = { path = \"../wasmtime/cranelift/frontend\" }\n #cranelift-module = { path = \"../wasmtime/cranelift/module\" }\n+#cranelift-native = { path = ../wasmtime/cranelift/native\" }\n #cranelift-jit = { path = \"../wasmtime/cranelift/jit\" }\n #cranelift-object = { path = \"../wasmtime/cranelift/object\" }\n \n@@ -75,3 +77,6 @@ debug = false\n [profile.release.package.syn]\n opt-level = 0\n debug = false\n+\n+[package.metadata.rust-analyzer]\n+rustc_private = true"}, {"sha": "08f9373be6262ba35226ceb02fb0a3f5aba22be8", "filename": "compiler/rustc_codegen_cranelift/Readme.md", "status": "modified", "additions": 23, "deletions": 56, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2FReadme.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2FReadme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FReadme.md?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -34,70 +34,20 @@ rustc_codegen_cranelift can be used as a near-drop-in replacement for `cargo bui\n \n Assuming `$cg_clif_dir` is the directory you cloned this repo into and you followed the instructions (`prepare.sh` and `build.sh` or `test.sh`).\n \n-### Cargo\n-\n In the directory with your project (where you can do the usual `cargo build`), run:\n \n ```bash\n-$ $cg_clif_dir/build/cargo.sh run\n-```\n-\n-This should build and run your project with rustc_codegen_cranelift instead of the usual LLVM backend.\n-\n-### Rustc\n-\n-> You should prefer using the Cargo method.\n-\n-```bash\n-$ $cg_clif_dir/build/bin/cg_clif my_crate.rs\n-```\n-\n-### Jit mode\n-\n-In jit mode cg_clif will immediately execute your code without creating an executable file.\n-\n-> This requires all dependencies to be available as dynamic library.\n-> The jit mode will probably need cargo integration to make this possible.\n-\n-```bash\n-$ $cg_clif_dir/build/cargo.sh jit\n-```\n-\n-or\n-\n-```bash\n-$ $cg_clif_dir/build/bin/cg_clif -Cllvm-args=mode=jit -Cprefer-dynamic my_crate.rs\n-```\n-\n-There is also an experimental lazy jit mode. In this mode functions are only compiled once they are\n-first called. It currently does not work with multi-threaded programs. When a not yet compiled\n-function is called from another thread than the main thread, you will get an ICE.\n-\n-```bash\n-$ $cg_clif_dir/build/cargo.sh lazy-jit\n+$ $cg_clif_dir/build/cargo.sh build\n ```\n \n-### Shell\n-\n-These are a few functions that allow you to easily run rust code from the shell using cg_clif as jit.\n-\n-```bash\n-function jit_naked() {\n-    echo \"$@\" | $cg_clif_dir/build/bin/cg_clif - -Cllvm-args=mode=jit -Cprefer-dynamic\n-}\n-\n-function jit() {\n-    jit_naked \"fn main() { $@ }\"\n-}\n+This will build your project with rustc_codegen_cranelift instead of the usual LLVM backend.\n \n-function jit_calc() {\n-    jit 'println!(\"0x{:x}\", ' $@ ');';\n-}\n-```\n+For additional ways to use rustc_codegen_cranelift like the JIT mode see [usage.md](docs/usage.md).\n \n-## Env vars\n+## Configuration\n \n-[see env_vars.md](docs/env_vars.md)\n+See the documentation on the `BackendConfig` struct in [config.rs](src/config.rs) for all\n+configuration options.\n \n ## Not yet supported\n \n@@ -106,3 +56,20 @@ function jit_calc() {\n       `llvm_asm!` will remain unimplemented forever. `asm!` doesn't yet support reg classes. You\n       have to specify specific registers instead.\n * SIMD ([tracked here](https://github.com/bjorn3/rustc_codegen_cranelift/issues/171), some basic things work)\n+\n+## License\n+\n+Licensed under either of\n+\n+  * Apache License, Version 2.0 ([LICENSE-APACHE](LICENSE-APACHE) or\n+    http://www.apache.org/licenses/LICENSE-2.0)\n+  * MIT license ([LICENSE-MIT](LICENSE-MIT) or\n+    http://opensource.org/licenses/MIT)\n+\n+at your option.\n+\n+### Contribution\n+\n+Unless you explicitly state otherwise, any contribution intentionally submitted\n+for inclusion in the work by you shall be dual licensed as above, without any\n+additional terms or conditions."}, {"sha": "76bc1884334afe4ea539ca65be6b5f8c32f5203d", "filename": "compiler/rustc_codegen_cranelift/build.sh", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fbuild.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fbuild.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild.sh?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -55,6 +55,7 @@ ln target/$CHANNEL/*rustc_codegen_cranelift* \"$target_dir\"/lib\n ln rust-toolchain scripts/config.sh scripts/cargo.sh \"$target_dir\"\n \n mkdir -p \"$target_dir/lib/rustlib/$TARGET_TRIPLE/lib/\"\n+mkdir -p \"$target_dir/lib/rustlib/$HOST_TRIPLE/lib/\"\n if [[ \"$TARGET_TRIPLE\" == \"x86_64-pc-windows-gnu\" ]]; then\n     cp $(rustc --print sysroot)/lib/rustlib/$TARGET_TRIPLE/lib/*.o \"$target_dir/lib/rustlib/$TARGET_TRIPLE/lib/\"\n fi\n@@ -64,12 +65,18 @@ case \"$build_sysroot\" in\n         ;;\n     \"llvm\")\n         cp -r $(rustc --print sysroot)/lib/rustlib/$TARGET_TRIPLE/lib \"$target_dir/lib/rustlib/$TARGET_TRIPLE/\"\n+        if [[ \"$HOST_TRIPLE\" != \"$TARGET_TRIPLE\" ]]; then\n+            cp -r $(rustc --print sysroot)/lib/rustlib/$HOST_TRIPLE/lib \"$target_dir/lib/rustlib/$HOST_TRIPLE/\"\n+        fi\n         ;;\n     \"clif\")\n         echo \"[BUILD] sysroot\"\n         dir=$(pwd)\n         cd \"$target_dir\"\n         time \"$dir/build_sysroot/build_sysroot.sh\"\n+        if [[ \"$HOST_TRIPLE\" != \"$TARGET_TRIPLE\" ]]; then\n+            time TARGET_TRIPLE=\"$HOST_TRIPLE\" \"$dir/build_sysroot/build_sysroot.sh\"\n+        fi\n         cp lib/rustlib/*/lib/libstd-* lib/\n         ;;\n     *)"}, {"sha": "e058a972ead3c184c382937d3f5afd19afcfa95b", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.lock", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -16,9 +16,9 @@ dependencies = [\n \n [[package]]\n name = \"adler\"\n-version = \"0.2.3\"\n+version = \"1.0.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ee2a4ec343196209d6594e19543ae87a39f96d5534d7174822a3ad825dd6ed7e\"\n+checksum = \"f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe\"\n dependencies = [\n  \"compiler_builtins\",\n  \"rustc-std-workspace-core\",\n@@ -56,7 +56,7 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.39\"\n+version = \"0.1.40\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -110,9 +110,9 @@ dependencies = [\n \n [[package]]\n name = \"hashbrown\"\n-version = \"0.9.1\"\n+version = \"0.11.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d7afe4a420e3fe79967a00898cc1f4db7c8a49a9333a29f8a4bd76a253d5cd04\"\n+checksum = \"ab5ef0d4909ef3724cc8cce6ccc8572c5c817592e9285f5464f8e86f8bd3726e\"\n dependencies = [\n  \"compiler_builtins\",\n  \"rustc-std-workspace-alloc\",\n@@ -132,18 +132,18 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.86\"\n+version = \"0.2.94\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b7282d924be3275cec7f6756ff4121987bc6481325397dde6ba3e7802b1a8b1c\"\n+checksum = \"18794a8ad5b29321f790b55d93dfba91e125cb1a9edbd4f8e3150acc771c1a5e\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n \n [[package]]\n name = \"miniz_oxide\"\n-version = \"0.4.3\"\n+version = \"0.4.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0f2d26ec3309788e423cfbf68ad1800f061638098d76a83681af979dc4eda19d\"\n+checksum = \"a92518e98c078586bc6c934028adcca4c92a53d6a958196de835170a01d84e4b\"\n dependencies = [\n  \"adler\",\n  \"autocfg\",\n@@ -167,6 +167,7 @@ dependencies = [\n name = \"panic_abort\"\n version = \"0.0.0\"\n dependencies = [\n+ \"alloc\",\n  \"cfg-if\",\n  \"compiler_builtins\",\n  \"core\",\n@@ -242,10 +243,22 @@ dependencies = [\n  \"panic_abort\",\n  \"panic_unwind\",\n  \"rustc-demangle\",\n+ \"std_detect\",\n  \"unwind\",\n  \"wasi\",\n ]\n \n+[[package]]\n+name = \"std_detect\"\n+version = \"0.1.5\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"compiler_builtins\",\n+ \"libc\",\n+ \"rustc-std-workspace-alloc\",\n+ \"rustc-std-workspace-core\",\n+]\n+\n [[package]]\n name = \"sysroot\"\n version = \"0.0.0\""}, {"sha": "0354304e55bf77477039d6737749d845128ac80c", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/build_sysroot.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fbuild_sysroot.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fbuild_sysroot.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fbuild_sysroot.sh?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -28,7 +28,7 @@ export __CARGO_DEFAULT_LIB_METADATA=\"cg_clif\"\n if [[ \"$1\" != \"--debug\" ]]; then\n     sysroot_channel='release'\n     # FIXME Enable incremental again once rust-lang/rust#74946 is fixed\n-    CARGO_INCREMENTAL=0 RUSTFLAGS=\"$RUSTFLAGS -Zmir-opt-level=2\" cargo build --target \"$TARGET_TRIPLE\" --release\n+    CARGO_INCREMENTAL=0 RUSTFLAGS=\"$RUSTFLAGS -Zmir-opt-level=3\" cargo build --target \"$TARGET_TRIPLE\" --release\n else\n     sysroot_channel='debug'\n     cargo build --target \"$TARGET_TRIPLE\""}, {"sha": "f7fcef10774102706c7a5169a3882eec5930bee1", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/prepare_sysroot_src.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fprepare_sysroot_src.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fprepare_sysroot_src.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fprepare_sysroot_src.sh?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -32,7 +32,7 @@ popd\n git clone https://github.com/rust-lang/compiler-builtins.git || echo \"rust-lang/compiler-builtins has already been cloned\"\n pushd compiler-builtins\n git checkout -- .\n-git checkout 0.1.39\n+git checkout 0.1.40\n git apply ../../crate_patches/000*-compiler-builtins-*.patch\n popd\n "}, {"sha": "b4acc4f5b73659923b329cc9fae53339f8335fa0", "filename": "compiler/rustc_codegen_cranelift/crate_patches/0001-compiler-builtins-Remove-rotate_left-from-Int.patch", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fcrate_patches%2F0001-compiler-builtins-Remove-rotate_left-from-Int.patch", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fcrate_patches%2F0001-compiler-builtins-Remove-rotate_left-from-Int.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fcrate_patches%2F0001-compiler-builtins-Remove-rotate_left-from-Int.patch?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -17,8 +17,8 @@ index 06054c8..3bea17b 100644\n      fn wrapping_shr(self, other: u32) -> Self;\n -    fn rotate_left(self, other: u32) -> Self;\n      fn overflowing_add(self, other: Self) -> (Self, bool);\n-     fn aborting_div(self, other: Self) -> Self;\n-     fn aborting_rem(self, other: Self) -> Self;\n+     fn leading_zeros(self) -> u32;\n+ }\n @@ -209,10 +208,6 @@ macro_rules! int_impl_common {\n              <Self>::wrapping_shr(self, other)\n          }"}, {"sha": "f0a0a6ad42ef52af66cc35678e57cb2b415b783d", "filename": "compiler/rustc_codegen_cranelift/docs/env_vars.md", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3b2b5b2914d40aa011d189bfe546084cdee53dbe/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fenv_vars.md", "raw_url": "https://github.com/rust-lang/rust/raw/3b2b5b2914d40aa011d189bfe546084cdee53dbe/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fenv_vars.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fenv_vars.md?ref=3b2b5b2914d40aa011d189bfe546084cdee53dbe", "patch": "@@ -1,12 +0,0 @@\n-# List of env vars recognized by cg_clif\n-\n-<dl>\n-    <dt>CG_CLIF_JIT_ARGS</dt>\n-    <dd>When JIT mode is enable pass these arguments to the program.</dd>\n-    <dt>CG_CLIF_INCR_CACHE_DISABLED</dt>\n-    <dd>Don't cache object files in the incremental cache. Useful during development of cg_clif\n-    to make it possible to use incremental mode for all analyses performed by rustc without caching\n-    object files when their content should have been changed by a change to cg_clif.</dd>\n-    <dt>CG_CLIF_DISPLAY_CG_TIME</dt>\n-    <dd>If \"1\", display the time it took to perform codegen for a crate</dd>\n-</dl>"}, {"sha": "3eee3b554e3b62ccd06db4acbb819c5c760983e4", "filename": "compiler/rustc_codegen_cranelift/docs/usage.md", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fusage.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fusage.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fusage.md?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -0,0 +1,66 @@\n+# Usage\n+\n+rustc_codegen_cranelift can be used as a near-drop-in replacement for `cargo build` or `cargo run` for existing projects.\n+\n+Assuming `$cg_clif_dir` is the directory you cloned this repo into and you followed the instructions (`prepare.sh` and `build.sh` or `test.sh`).\n+\n+## Cargo\n+\n+In the directory with your project (where you can do the usual `cargo build`), run:\n+\n+```bash\n+$ $cg_clif_dir/build/cargo.sh build\n+```\n+\n+This will build your project with rustc_codegen_cranelift instead of the usual LLVM backend.\n+\n+## Rustc\n+\n+> You should prefer using the Cargo method.\n+\n+```bash\n+$ $cg_clif_dir/build/bin/cg_clif my_crate.rs\n+```\n+\n+## Jit mode\n+\n+In jit mode cg_clif will immediately execute your code without creating an executable file.\n+\n+> This requires all dependencies to be available as dynamic library.\n+> The jit mode will probably need cargo integration to make this possible.\n+\n+```bash\n+$ $cg_clif_dir/build/cargo.sh jit\n+```\n+\n+or\n+\n+```bash\n+$ $cg_clif_dir/build/bin/cg_clif -Cllvm-args=mode=jit -Cprefer-dynamic my_crate.rs\n+```\n+\n+There is also an experimental lazy jit mode. In this mode functions are only compiled once they are\n+first called. It currently does not work with multi-threaded programs. When a not yet compiled\n+function is called from another thread than the main thread, you will get an ICE.\n+\n+```bash\n+$ $cg_clif_dir/build/cargo.sh lazy-jit\n+```\n+\n+## Shell\n+\n+These are a few functions that allow you to easily run rust code from the shell using cg_clif as jit.\n+\n+```bash\n+function jit_naked() {\n+    echo \"$@\" | $cg_clif_dir/build/bin/cg_clif - -Cllvm-args=mode=jit -Cprefer-dynamic\n+}\n+\n+function jit() {\n+    jit_naked \"fn main() { $@ }\"\n+}\n+\n+function jit_calc() {\n+    jit 'println!(\"0x{:x}\", ' $@ ');';\n+}\n+```"}, {"sha": "c4834c804087199822e4552a19874744235992ef", "filename": "compiler/rustc_codegen_cranelift/example/mini_core.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -621,6 +621,7 @@ struct PanicLocation {\n }\n \n #[no_mangle]\n+#[cfg(not(windows))]\n pub fn get_tls() -> u8 {\n     #[thread_local]\n     static A: u8 = 42;"}, {"sha": "6570f2bf9f297fbccf66a4681d639a91f266a18f", "filename": "compiler/rustc_codegen_cranelift/example/mini_core_hello_world.rs", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -1,7 +1,4 @@\n-#![feature(\n-    no_core, start, lang_items, box_syntax, never_type, linkage,\n-    extern_types, thread_local\n-)]\n+#![feature(no_core, lang_items, box_syntax, never_type, linkage, extern_types, thread_local)]\n #![no_core]\n #![allow(dead_code, non_camel_case_types)]\n \n@@ -14,6 +11,22 @@ unsafe extern \"C\" fn my_puts(s: *const i8) {\n     puts(s);\n }\n \n+macro_rules! assert {\n+    ($e:expr) => {\n+        if !$e {\n+            panic(stringify!(! $e));\n+        }\n+    };\n+}\n+\n+macro_rules! assert_eq {\n+    ($l:expr, $r: expr) => {\n+        if $l != $r {\n+            panic(stringify!($l != $r));\n+        }\n+    }\n+}\n+\n #[lang = \"termination\"]\n trait Termination {\n     fn report(self) -> i32;\n@@ -23,8 +36,9 @@ impl Termination for () {\n     fn report(self) -> i32 {\n         unsafe {\n             NUM = 6 * 7 + 1 + (1u8 == 1u8) as u8; // 44\n-            *NUM_REF as i32\n+            assert_eq!(*NUM_REF as i32, 44);\n         }\n+        0\n     }\n }\n \n@@ -85,29 +99,12 @@ fn start<T: Termination + 'static>(\n         unsafe { puts(*((argv as usize + 2 * intrinsics::size_of::<*const u8>()) as *const *const i8)); }\n     }\n \n-    main().report();\n-    0\n+    main().report() as isize\n }\n \n static mut NUM: u8 = 6 * 7;\n static NUM_REF: &'static u8 = unsafe { &NUM };\n \n-macro_rules! assert {\n-    ($e:expr) => {\n-        if !$e {\n-            panic(stringify!(! $e));\n-        }\n-    };\n-}\n-\n-macro_rules! assert_eq {\n-    ($l:expr, $r: expr) => {\n-        if $l != $r {\n-            panic(stringify!($l != $r));\n-        }\n-    }\n-}\n-\n struct Unique<T: ?Sized> {\n     pointer: *const T,\n     _marker: PhantomData<T>,\n@@ -239,7 +236,7 @@ fn main() {\n \n     assert_eq!(((|()| 42u8) as fn(()) -> u8)(()), 42);\n \n-    #[cfg(not(jit))]\n+    #[cfg(not(any(jit, windows)))]\n     {\n         extern {\n             #[linkage = \"extern_weak\"]\n@@ -292,13 +289,18 @@ fn main() {\n \n     from_decimal_string();\n \n-    #[cfg(not(jit))]\n+    #[cfg(not(any(jit, windows)))]\n     test_tls();\n \n     #[cfg(all(not(jit), target_os = \"linux\"))]\n     unsafe {\n         global_asm_test();\n     }\n+\n+    // Both statics have a reference that points to the same anonymous allocation.\n+    static REF1: &u8 = &42;\n+    static REF2: &u8 = REF1;\n+    assert_eq!(*REF1, *REF2);\n }\n \n #[cfg(all(not(jit), target_os = \"linux\"))]"}, {"sha": "77ba72df8ef371ddbc1163c7b0f6f0aca38b0d7e", "filename": "compiler/rustc_codegen_cranelift/example/std_example.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -48,6 +48,8 @@ fn main() {\n     assert_eq!(2.3f32.copysign(-1.0), -2.3f32);\n     println!(\"{}\", 2.3f32.powf(2.0));\n \n+    assert_eq!(i64::MAX.checked_mul(2), None);\n+\n     assert_eq!(-128i8, (-128i8).saturating_sub(1));\n     assert_eq!(127i8, 127i8.saturating_sub(-128));\n     assert_eq!(-128i8, (-128i8).saturating_add(-128));\n@@ -84,6 +86,7 @@ fn main() {\n     assert_eq!(houndred_i128 as f64, 100.0);\n     assert_eq!(houndred_f32 as i128, 100);\n     assert_eq!(houndred_f64 as i128, 100);\n+    assert_eq!(1u128.rotate_left(2), 4);\n \n     // Test signed 128bit comparing\n     let max = usize::MAX as i128;"}, {"sha": "64c097261c908bf6909aec2789646e998552f4ee", "filename": "compiler/rustc_codegen_cranelift/prepare.sh", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fprepare.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fprepare.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fprepare.sh?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -1,7 +1,6 @@\n #!/usr/bin/env bash\n set -e\n \n-rustup component add rust-src rustc-dev llvm-tools-preview\n ./build_sysroot/prepare_sysroot_src.sh\n cargo install hyperfine || echo \"Skipping hyperfine install\"\n "}, {"sha": "5442e3345aa913899488cf757816c1ebe01df325", "filename": "compiler/rustc_codegen_cranelift/rust-toolchain", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Frust-toolchain?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -1 +1,3 @@\n-nightly-2021-03-05\n+[toolchain]\n+channel = \"nightly-2021-04-28\"\n+components = [\"rust-src\", \"rustc-dev\", \"llvm-tools-preview\"]"}, {"sha": "1daa5a78f7bd25e6396d21b3e92d7fe336171f83", "filename": "compiler/rustc_codegen_cranelift/scripts/cargo.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo.sh?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -4,7 +4,7 @@ dir=$(dirname \"$0\")\n source \"$dir/config.sh\"\n \n # read nightly compiler from rust-toolchain file\n-TOOLCHAIN=$(cat \"$dir/rust-toolchain\")\n+TOOLCHAIN=$(cat \"$dir/rust-toolchain\" | grep channel | sed \"s/channel = \\\"\\(.*\\)\\\"/\\1/\")\n \n cmd=$1\n shift || true"}, {"sha": "99b302ee1d94b3cf044132fccd3401031b9c2c42", "filename": "compiler/rustc_codegen_cranelift/scripts/config.sh", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fconfig.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fconfig.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fconfig.sh?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -2,15 +2,7 @@\n \n set -e\n \n-unamestr=$(uname)\n-if [[ \"$unamestr\" == 'Linux' || \"$unamestr\" == 'FreeBSD' ]]; then\n-   dylib_ext='so'\n-elif [[ \"$unamestr\" == 'Darwin' ]]; then\n-   dylib_ext='dylib'\n-else\n-   echo \"Unsupported os\"\n-   exit 1\n-fi\n+dylib=$(echo \"\" | rustc --print file-names --crate-type dylib --crate-name rustc_codegen_cranelift -)\n \n if echo \"$RUSTC_WRAPPER\" | grep sccache; then\n echo\n@@ -24,10 +16,10 @@ dir=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\"; pwd)\n export RUSTC=$dir\"/bin/cg_clif\"\n \n export RUSTDOCFLAGS=$linker' -Cpanic=abort -Zpanic-abort-tests '\\\n-'-Zcodegen-backend='$dir'/lib/librustc_codegen_cranelift.'$dylib_ext' --sysroot '$dir\n+'-Zcodegen-backend='$dir'/lib/'$dylib' --sysroot '$dir\n \n # FIXME fix `#[linkage = \"extern_weak\"]` without this\n-if [[ \"$unamestr\" == 'Darwin' ]]; then\n+if [[ \"$(uname)\" == 'Darwin' ]]; then\n    export RUSTFLAGS=\"$RUSTFLAGS -Clink-arg=-undefined -Clink-arg=dynamic_lookup\"\n fi\n "}, {"sha": "3f98d77d76cad82fe2d7546f64f7b0407b576de4", "filename": "compiler/rustc_codegen_cranelift/scripts/ext_config.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fext_config.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fext_config.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fext_config.sh?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -5,7 +5,7 @@\n set -e\n \n export CG_CLIF_DISPLAY_CG_TIME=1\n-export CG_CLIF_INCR_CACHE_DISABLED=1\n+export CG_CLIF_DISABLE_INCR_CACHE=1\n \n export HOST_TRIPLE=$(rustc -vV | grep host | cut -d: -f2 | tr -d \" \")\n export TARGET_TRIPLE=${TARGET_TRIPLE:-$HOST_TRIPLE}"}, {"sha": "fa7557653d879a161e77afdaddb0dc1822fc374f", "filename": "compiler/rustc_codegen_cranelift/scripts/rustup.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustup.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustup.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustup.sh?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -8,7 +8,7 @@ case $1 in\n \n         echo \"=> Installing new nightly\"\n         rustup toolchain install --profile minimal \"nightly-${TOOLCHAIN}\" # Sanity check to see if the nightly exists\n-        echo \"nightly-${TOOLCHAIN}\" > rust-toolchain\n+        sed -i \"s/\\\"nightly-.*\\\"/\\\"nightly-${TOOLCHAIN}\\\"/\" rust-toolchain\n         rustup component add rustfmt || true\n \n         echo \"=> Uninstalling all old nighlies\""}, {"sha": "4821a07ac5d5de473b0efcc6c6a23811a908ad28", "filename": "compiler/rustc_codegen_cranelift/scripts/setup_rust_fork.sh", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -0,0 +1,68 @@\n+#!/bin/bash\n+set -e\n+\n+./build.sh\n+source build/config.sh\n+\n+echo \"[SETUP] Rust fork\"\n+git clone https://github.com/rust-lang/rust.git || true\n+pushd rust\n+git fetch\n+git checkout -- .\n+git checkout \"$(rustc -V | cut -d' ' -f3 | tr -d '(')\"\n+\n+git apply - <<EOF\n+diff --git a/Cargo.toml b/Cargo.toml\n+index 5bd1147cad5..10d68a2ff14 100644\n+--- a/Cargo.toml\n++++ b/Cargo.toml\n+@@ -111,5 +111,7 @@ rustc-std-workspace-std = { path = 'library/rustc-std-workspace-std' }\n+ rustc-std-workspace-alloc = { path = 'library/rustc-std-workspace-alloc' }\n+ rustc-std-workspace-std = { path = 'library/rustc-std-workspace-std' }\n+\n++compiler_builtins = { path = \"../build_sysroot/compiler-builtins\" }\n++\n+ [patch.\"https://github.com/rust-lang/rust-clippy\"]\n+ clippy_lints = { path = \"src/tools/clippy/clippy_lints\" }\n+diff --git a/compiler/rustc_data_structures/Cargo.toml b/compiler/rustc_data_structures/Cargo.toml\n+index 23e689fcae7..5f077b765b6 100644\n+--- a/compiler/rustc_data_structures/Cargo.toml\n++++ b/compiler/rustc_data_structures/Cargo.toml\n+@@ -32,7 +32,6 @@ tempfile = \"3.0.5\"\n+\n+ [dependencies.parking_lot]\n+ version = \"0.11\"\n+-features = [\"nightly\"]\n+\n+ [target.'cfg(windows)'.dependencies]\n+ winapi = { version = \"0.3\", features = [\"fileapi\", \"psapi\"] }\n+diff --git a/library/alloc/Cargo.toml b/library/alloc/Cargo.toml\n+index d95b5b7f17f..00b6f0e3635 100644\n+--- a/library/alloc/Cargo.toml\n++++ b/library/alloc/Cargo.toml\n+@@ -8,7 +8,7 @@ edition = \"2018\"\n+\n+ [dependencies]\n+ core = { path = \"../core\" }\n+-compiler_builtins = { version = \"0.1.39\", features = ['rustc-dep-of-std'] }\n++compiler_builtins = { version = \"0.1.40\", features = ['rustc-dep-of-std', 'no-asm'] }\n+\n+ [dev-dependencies]\n+ rand = \"0.7\"\n+EOF\n+\n+cat > config.toml <<EOF\n+[llvm]\n+ninja = false\n+\n+[build]\n+rustc = \"$(pwd)/../build/bin/cg_clif\"\n+cargo = \"$(rustup which cargo)\"\n+full-bootstrap = true\n+local-rebuild = true\n+\n+[rust]\n+codegen-backends = [\"cranelift\"]\n+deny-warnings = false\n+EOF\n+popd"}, {"sha": "791d457993de3a3d42ad77c2e9a843ea719b4d39", "filename": "compiler/rustc_codegen_cranelift/scripts/test_bootstrap.sh", "status": "modified", "additions": 1, "deletions": 61, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_bootstrap.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_bootstrap.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_bootstrap.sh?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -3,70 +3,10 @@ set -e\n \n cd \"$(dirname \"$0\")/../\"\n \n-./build.sh\n-source build/config.sh\n+source ./scripts/setup_rust_fork.sh\n \n echo \"[TEST] Bootstrap of rustc\"\n-git clone https://github.com/rust-lang/rust.git || true\n pushd rust\n-git fetch\n-git checkout -- .\n-git checkout \"$(rustc -V | cut -d' ' -f3 | tr -d '(')\"\n-\n-git apply - <<EOF\n-diff --git a/Cargo.toml b/Cargo.toml\n-index 5bd1147cad5..10d68a2ff14 100644\n---- a/Cargo.toml\n-+++ b/Cargo.toml\n-@@ -111,5 +111,7 @@ rustc-std-workspace-std = { path = 'library/rustc-std-workspace-std' }\n- rustc-std-workspace-alloc = { path = 'library/rustc-std-workspace-alloc' }\n- rustc-std-workspace-std = { path = 'library/rustc-std-workspace-std' }\n- \n-+compiler_builtins = { path = \"../build_sysroot/compiler-builtins\" }\n-+\n- [patch.\"https://github.com/rust-lang/rust-clippy\"]\n- clippy_lints = { path = \"src/tools/clippy/clippy_lints\" }\n-diff --git a/compiler/rustc_data_structures/Cargo.toml b/compiler/rustc_data_structures/Cargo.toml\n-index 23e689fcae7..5f077b765b6 100644\n---- a/compiler/rustc_data_structures/Cargo.toml\n-+++ b/compiler/rustc_data_structures/Cargo.toml\n-@@ -32,7 +32,6 @@ tempfile = \"3.0.5\"\n-\n- [dependencies.parking_lot]\n- version = \"0.11\"\n--features = [\"nightly\"]\n-\n- [target.'cfg(windows)'.dependencies]\n- winapi = { version = \"0.3\", features = [\"fileapi\", \"psapi\"] }\n-diff --git a/library/alloc/Cargo.toml b/library/alloc/Cargo.toml\n-index d95b5b7f17f..00b6f0e3635 100644\n---- a/library/alloc/Cargo.toml\n-+++ b/library/alloc/Cargo.toml\n-@@ -8,7 +8,7 @@ edition = \"2018\"\n- \n- [dependencies]\n- core = { path = \"../core\" }\n--compiler_builtins = { version = \"0.1.39\", features = ['rustc-dep-of-std'] }\n-+compiler_builtins = { version = \"0.1.39\", features = ['rustc-dep-of-std', 'no-asm'] }\n- \n- [dev-dependencies]\n- rand = \"0.7\"\n-EOF\n-\n-cat > config.toml <<EOF\n-[llvm]\n-ninja = false\n-\n-[build]\n-rustc = \"$(pwd)/../build/bin/cg_clif\"\n-cargo = \"$(rustup which cargo)\"\n-full-bootstrap = true\n-local-rebuild = true\n-\n-[rust]\n-codegen-backends = [\"cranelift\"]\n-EOF\n-\n rm -r compiler/rustc_codegen_cranelift/{Cargo.*,src}\n cp ../Cargo.* compiler/rustc_codegen_cranelift/\n cp -r ../src compiler/rustc_codegen_cranelift/src"}, {"sha": "347fb40e6f9e7bbf0999157ba046d052e6ab8f75", "filename": "compiler/rustc_codegen_cranelift/scripts/test_rustc_tests.sh", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -0,0 +1,92 @@\n+#!/bin/bash\n+set -e\n+\n+cd $(dirname \"$0\")/../\n+\n+source ./scripts/setup_rust_fork.sh\n+\n+echo \"[TEST] Test suite of rustc\"\n+pushd rust\n+\n+cargo install ripgrep\n+\n+rm -r src/test/ui/{extern/,panics/,unsized-locals/,thinlto/,simd*,*lto*.rs,linkage*,unwind-*.rs} || true\n+for test in $(rg --files-with-matches \"asm!|catch_unwind|should_panic|lto\" src/test/ui); do\n+  rm $test\n+done\n+\n+for test in $(rg -i --files-with-matches \"//(\\[\\w+\\])?~|// error-pattern:|// build-fail|// run-fail|-Cllvm-args\" src/test/ui); do\n+  rm $test\n+done\n+\n+git checkout -- src/test/ui/issues/auxiliary/issue-3136-a.rs # contains //~ERROR, but shouldn't be removed\n+\n+# these all depend on unwinding support\n+rm src/test/ui/backtrace.rs\n+rm src/test/ui/array-slice-vec/box-of-array-of-drop-*.rs\n+rm src/test/ui/array-slice-vec/slice-panic-*.rs\n+rm src/test/ui/array-slice-vec/nested-vec-3.rs\n+rm src/test/ui/cleanup-rvalue-temp-during-incomplete-alloc.rs\n+rm src/test/ui/issues/issue-26655.rs\n+rm src/test/ui/issues/issue-29485.rs\n+rm src/test/ui/issues/issue-30018-panic.rs\n+rm src/test/ui/multi-panic.rs\n+rm src/test/ui/sepcomp/sepcomp-unwind.rs\n+rm src/test/ui/structs-enums/unit-like-struct-drop-run.rs\n+rm src/test/ui/terminate-in-initializer.rs\n+rm src/test/ui/threads-sendsync/task-stderr.rs\n+rm src/test/ui/numbers-arithmetic/int-abs-overflow.rs\n+rm src/test/ui/drop/drop-trait-enum.rs\n+rm src/test/ui/numbers-arithmetic/issue-8460.rs\n+rm src/test/incremental/change_crate_dep_kind.rs # requires -Cpanic=unwind\n+\n+rm src/test/ui/issues/issue-28950.rs # depends on stack size optimizations\n+rm src/test/ui/init-large-type.rs # same\n+rm src/test/ui/sse2.rs # cpuid not supported, so sse2 not detected\n+rm src/test/ui/issues/issue-33992.rs # unsupported linkages\n+rm src/test/ui/issues/issue-51947.rs # same\n+rm src/test/ui/numbers-arithmetic/saturating-float-casts.rs # intrinsic gives different but valid result\n+rm src/test/ui/mir/mir_misc_casts.rs # depends on deduplication of constants\n+rm src/test/ui/mir/mir_raw_fat_ptr.rs # same\n+rm src/test/ui/consts/issue-33537.rs # same\n+rm src/test/ui/async-await/async-fn-size-moved-locals.rs # -Cpanic=abort shrinks some generator by one byte\n+rm src/test/ui/async-await/async-fn-size-uninit-locals.rs # same\n+rm src/test/ui/generator/size-moved-locals.rs # same\n+rm src/test/ui/fn/dyn-fn-alignment.rs # wants a 256 byte alignment\n+rm src/test/ui/test-attrs/test-fn-signature-verification-for-explicit-return-type.rs # \"Cannot run dynamic test fn out-of-process\"\n+rm src/test/ui/intrinsics/intrinsic-nearby.rs # unimplemented nearbyintf32 and nearbyintf64 intrinsics\n+\n+rm src/test/incremental/hashes/inline_asm.rs # inline asm\n+rm src/test/incremental/issue-72386.rs # same\n+rm src/test/incremental/issue-49482.rs # same\n+rm src/test/incremental/issue-54059.rs # same\n+rm src/test/incremental/lto.rs # requires lto\n+\n+rm -r src/test/run-make/emit-shared-files # requires the rustdoc executable in build/bin/\n+rm -r src/test/run-make/unstable-flag-required # same\n+\n+rm src/test/pretty/asm.rs # inline asm\n+rm src/test/pretty/raw-str-nonexpr.rs # same\n+\n+rm -r src/test/run-pass-valgrind/unsized-locals\n+\n+rm src/test/ui/json-bom-plus-crlf-multifile.rs # differing warning\n+rm src/test/ui/json-bom-plus-crlf.rs # same\n+rm src/test/ui/match/issue-82392.rs # differing error\n+rm src/test/ui/type-alias-impl-trait/cross_crate_ice*.rs # requires removed aux dep\n+\n+rm src/test/ui/allocator/no_std-alloc-error-handler-default.rs # missing rust_oom definition\n+rm src/test/ui/cfg/cfg-panic.rs\n+rm src/test/ui/default-alloc-error-hook.rs\n+rm -r src/test/ui/hygiene/\n+\n+rm -r src/test/ui/polymorphization/ # polymorphization not yet supported\n+rm src/test/codegen-units/polymorphization/unused_type_parameters.rs # same\n+\n+rm -r src/test/run-make/fmt-write-bloat/ # tests an optimization\n+rm src/test/ui/abi/mir/mir_codegen_calls_variadic.rs # requires float varargs\n+rm src/test/ui/abi/variadic-ffi.rs # requires callee side vararg support\n+\n+echo \"[TEST] rustc test suite\"\n+RUST_TEST_NOCAPTURE=1 COMPILETEST_FORCE_STAGE0=1 ./x.py test --stage 0 src/test/{codegen-units,run-make,run-pass-valgrind,ui}\n+popd"}, {"sha": "3afcea8f06bd6c257b6ec97077d17ee7496ed565", "filename": "compiler/rustc_codegen_cranelift/scripts/tests.sh", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -71,14 +71,20 @@ function base_sysroot_tests() {\n     echo \"[AOT] mod_bench\"\n     $MY_RUSTC example/mod_bench.rs --crate-type bin --target \"$TARGET_TRIPLE\"\n     $RUN_WRAPPER ./target/out/mod_bench\n+}\n \n+function extended_sysroot_tests() {\n     pushd rand\n-    rm -r ./target || true\n-    ../build/cargo.sh test --workspace\n+    cargo clean\n+    if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n+        echo \"[TEST] rust-random/rand\"\n+        ../build/cargo.sh test --workspace\n+    else\n+        echo \"[AOT] rust-random/rand\"\n+        ../build/cargo.sh build --workspace --target $TARGET_TRIPLE --tests\n+    fi\n     popd\n-}\n \n-function extended_sysroot_tests() {\n     pushd simple-raytracer\n     if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n         echo \"[BENCH COMPILE] ebobby/simple-raytracer\"\n@@ -92,27 +98,40 @@ function extended_sysroot_tests() {\n     else\n         echo \"[BENCH COMPILE] ebobby/simple-raytracer (skipped)\"\n         echo \"[COMPILE] ebobby/simple-raytracer\"\n-        ../cargo.sh build\n+        ../build/cargo.sh build --target $TARGET_TRIPLE\n         echo \"[BENCH RUN] ebobby/simple-raytracer (skipped)\"\n     fi\n     popd\n \n     pushd build_sysroot/sysroot_src/library/core/tests\n     echo \"[TEST] libcore\"\n-    rm -r ./target || true\n-    ../../../../../build/cargo.sh test\n+    cargo clean\n+    if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n+        ../../../../../build/cargo.sh test\n+    else\n+        ../../../../../build/cargo.sh build --target $TARGET_TRIPLE --tests\n+    fi\n     popd\n \n     pushd regex\n     echo \"[TEST] rust-lang/regex example shootout-regex-dna\"\n-    ../build/cargo.sh clean\n+    cargo clean\n     # Make sure `[codegen mono items] start` doesn't poison the diff\n-    ../build/cargo.sh build --example shootout-regex-dna\n-    cat examples/regexdna-input.txt | ../build/cargo.sh run --example shootout-regex-dna | grep -v \"Spawned thread\" > res.txt\n-    diff -u res.txt examples/regexdna-output.txt\n+    ../build/cargo.sh build --example shootout-regex-dna --target $TARGET_TRIPLE\n+    if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n+        cat examples/regexdna-input.txt \\\n+            | ../build/cargo.sh run --example shootout-regex-dna --target $TARGET_TRIPLE \\\n+            | grep -v \"Spawned thread\" > res.txt\n+        diff -u res.txt examples/regexdna-output.txt\n+    fi\n \n-    echo \"[TEST] rust-lang/regex tests\"\n-    ../build/cargo.sh test --tests -- --exclude-should-panic --test-threads 1 -Zunstable-options -q\n+    if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n+        echo \"[TEST] rust-lang/regex tests\"\n+        ../build/cargo.sh test --tests -- --exclude-should-panic --test-threads 1 -Zunstable-options -q\n+    else\n+        echo \"[AOT] rust-lang/regex tests\"\n+        ../build/cargo.sh build --tests --target $TARGET_TRIPLE\n+    fi\n     popd\n }\n "}, {"sha": "5fbaed7283a6781400a2ca0628cc731ae49edb8e", "filename": "compiler/rustc_codegen_cranelift/src/abi/comments.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -11,9 +11,11 @@ use cranelift_codegen::entity::EntityRef;\n use crate::prelude::*;\n \n pub(super) fn add_args_header_comment(fx: &mut FunctionCx<'_, '_, '_>) {\n-    fx.add_global_comment(\n-        \"kind  loc.idx   param    pass mode                            ty\".to_string(),\n-    );\n+    if fx.clif_comments.enabled() {\n+        fx.add_global_comment(\n+            \"kind  loc.idx   param    pass mode                            ty\".to_string(),\n+        );\n+    }\n }\n \n pub(super) fn add_arg_comment<'tcx>(\n@@ -25,6 +27,10 @@ pub(super) fn add_arg_comment<'tcx>(\n     arg_abi_mode: PassMode,\n     arg_layout: TyAndLayout<'tcx>,\n ) {\n+    if !fx.clif_comments.enabled() {\n+        return;\n+    }\n+\n     let local = if let Some(local) = local {\n         Cow::Owned(format!(\"{:?}\", local))\n     } else {\n@@ -59,17 +65,22 @@ pub(super) fn add_arg_comment<'tcx>(\n }\n \n pub(super) fn add_locals_header_comment(fx: &mut FunctionCx<'_, '_, '_>) {\n-    fx.add_global_comment(String::new());\n-    fx.add_global_comment(\n-        \"kind  local ty                              size align (abi,pref)\".to_string(),\n-    );\n+    if fx.clif_comments.enabled() {\n+        fx.add_global_comment(String::new());\n+        fx.add_global_comment(\n+            \"kind  local ty                              size align (abi,pref)\".to_string(),\n+        );\n+    }\n }\n \n pub(super) fn add_local_place_comments<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     place: CPlace<'tcx>,\n     local: Local,\n ) {\n+    if !fx.clif_comments.enabled() {\n+        return;\n+    }\n     let TyAndLayout { ty, layout } = place.layout();\n     let rustc_target::abi::Layout { size, align, abi: _, variants: _, fields: _, largest_niche: _ } =\n         layout;\n@@ -90,7 +101,7 @@ pub(super) fn add_local_place_comments<'tcx>(\n             } else {\n                 Cow::Borrowed(\"\")\n             };\n-            match ptr.base_and_offset() {\n+            match ptr.debug_base_and_offset() {\n                 (crate::pointer::PointerBase::Addr(addr), offset) => {\n                     (\"reuse\", format!(\"storage={}{}{}\", addr, offset, meta).into())\n                 }"}, {"sha": "54c8fb0e7b80be401a13d87c8de39e46bd9ebc99", "filename": "compiler/rustc_codegen_cranelift/src/abi/mod.rs", "status": "modified", "additions": 14, "deletions": 25, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -1,6 +1,5 @@\n //! Handling of everything related to the calling convention. Also fills `fx.local_map`.\n \n-#[cfg(debug_assertions)]\n mod comments;\n mod pass_mode;\n mod returning;\n@@ -64,19 +63,20 @@ pub(crate) fn import_function<'tcx>(\n     module: &mut dyn Module,\n     inst: Instance<'tcx>,\n ) -> FuncId {\n-    let name = tcx.symbol_name(inst).name.to_string();\n+    let name = tcx.symbol_name(inst).name;\n     let sig = get_function_sig(tcx, module.isa().triple(), inst);\n-    module.declare_function(&name, Linkage::Import, &sig).unwrap()\n+    module.declare_function(name, Linkage::Import, &sig).unwrap()\n }\n \n impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n     /// Instance must be monomorphized\n     pub(crate) fn get_function_ref(&mut self, inst: Instance<'tcx>) -> FuncRef {\n-        let func_id = import_function(self.tcx, self.cx.module, inst);\n-        let func_ref = self.cx.module.declare_func_in_func(func_id, &mut self.bcx.func);\n+        let func_id = import_function(self.tcx, self.module, inst);\n+        let func_ref = self.module.declare_func_in_func(func_id, &mut self.bcx.func);\n \n-        #[cfg(debug_assertions)]\n-        self.add_comment(func_ref, format!(\"{:?}\", inst));\n+        if self.clif_comments.enabled() {\n+            self.add_comment(func_ref, format!(\"{:?}\", inst));\n+        }\n \n         func_ref\n     }\n@@ -89,11 +89,10 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         args: &[Value],\n     ) -> &[Value] {\n         let sig = Signature { params, returns, call_conv: CallConv::triple_default(self.triple()) };\n-        let func_id = self.cx.module.declare_function(&name, Linkage::Import, &sig).unwrap();\n-        let func_ref = self.cx.module.declare_func_in_func(func_id, &mut self.bcx.func);\n+        let func_id = self.module.declare_function(name, Linkage::Import, &sig).unwrap();\n+        let func_ref = self.module.declare_func_in_func(func_id, &mut self.bcx.func);\n         let call_inst = self.bcx.ins().call(func_ref, args);\n-        #[cfg(debug_assertions)]\n-        {\n+        if self.clif_comments.enabled() {\n             self.add_comment(call_inst, format!(\"easy_call {}\", name));\n         }\n         let results = self.bcx.inst_results(call_inst);\n@@ -149,7 +148,6 @@ fn make_local_place<'tcx>(\n         CPlace::new_stack_slot(fx, layout)\n     };\n \n-    #[cfg(debug_assertions)]\n     self::comments::add_local_place_comments(fx, place, local);\n \n     place\n@@ -163,7 +161,6 @@ pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_\n \n     let ssa_analyzed = crate::analyze::analyze(fx);\n \n-    #[cfg(debug_assertions)]\n     self::comments::add_args_header_comment(fx);\n \n     let mut block_params_iter = fx.bcx.func.dfg.block_params(start_block).to_vec().into_iter();\n@@ -228,7 +225,6 @@ pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_\n     fx.fn_abi = Some(fn_abi);\n     assert!(block_params_iter.next().is_none(), \"arg_value left behind\");\n \n-    #[cfg(debug_assertions)]\n     self::comments::add_locals_header_comment(fx);\n \n     for (local, arg_kind, ty) in func_params {\n@@ -256,7 +252,6 @@ pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_\n                         CPlace::for_ptr(addr, val.layout())\n                     };\n \n-                    #[cfg(debug_assertions)]\n                     self::comments::add_local_place_comments(fx, place, local);\n \n                     assert_eq!(fx.local_map.push(place), local);\n@@ -300,7 +295,6 @@ pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_\n pub(crate) fn codegen_terminator_call<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     span: Span,\n-    current_block: Block,\n     func: &Operand<'tcx>,\n     args: &[Operand<'tcx>],\n     destination: Option<(Place<'tcx>, BasicBlock)>,\n@@ -362,7 +356,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n         .map(|inst| fx.tcx.codegen_fn_attrs(inst.def_id()).flags.contains(CodegenFnAttrFlags::COLD))\n         .unwrap_or(false);\n     if is_cold {\n-        fx.cold_blocks.insert(current_block);\n+        // FIXME Mark current_block block as cold once Cranelift supports it\n     }\n \n     // Unpack arguments tuple for closures\n@@ -392,8 +386,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n     let (func_ref, first_arg) = match instance {\n         // Trait object call\n         Some(Instance { def: InstanceDef::Virtual(_, idx), .. }) => {\n-            #[cfg(debug_assertions)]\n-            {\n+            if fx.clif_comments.enabled() {\n                 let nop_inst = fx.bcx.ins().nop();\n                 fx.add_comment(\n                     nop_inst,\n@@ -414,8 +407,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n \n         // Indirect call\n         None => {\n-            #[cfg(debug_assertions)]\n-            {\n+            if fx.clif_comments.enabled() {\n                 let nop_inst = fx.bcx.ins().nop();\n                 fx.add_comment(nop_inst, \"indirect call\");\n             }\n@@ -477,10 +469,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n     // FIXME find a cleaner way to support varargs\n     if fn_sig.c_variadic {\n         if !matches!(fn_sig.abi, Abi::C { .. }) {\n-            fx.tcx.sess.span_fatal(\n-                span,\n-                &format!(\"Variadic call for non-C abi {:?}\", fn_sig.abi),\n-            );\n+            fx.tcx.sess.span_fatal(span, &format!(\"Variadic call for non-C abi {:?}\", fn_sig.abi));\n         }\n         let sig_ref = fx.bcx.func.dfg.call_signature(call_inst).unwrap();\n         let abi_params = call_args"}, {"sha": "7c275965199e056567512a0b71118943b80838cc", "filename": "compiler/rustc_codegen_cranelift/src/abi/pass_mode.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -208,7 +208,7 @@ pub(super) fn from_casted_value<'tcx>(\n     });\n     let ptr = Pointer::new(fx.bcx.ins().stack_addr(pointer_ty(fx.tcx), stack_slot, 0));\n     let mut offset = 0;\n-    let mut block_params_iter = block_params.into_iter().copied();\n+    let mut block_params_iter = block_params.iter().copied();\n     for param in abi_params {\n         let val = ptr.offset_i64(fx, offset).store(\n             fx,\n@@ -248,8 +248,8 @@ pub(super) fn adjust_arg_for_abi<'tcx>(\n /// as necessary.\n pub(super) fn cvalue_for_param<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n-    #[cfg_attr(not(debug_assertions), allow(unused_variables))] local: Option<mir::Local>,\n-    #[cfg_attr(not(debug_assertions), allow(unused_variables))] local_field: Option<usize>,\n+    local: Option<mir::Local>,\n+    local_field: Option<usize>,\n     arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n     block_params_iter: &mut impl Iterator<Item = Value>,\n ) -> Option<CValue<'tcx>> {\n@@ -263,7 +263,6 @@ pub(super) fn cvalue_for_param<'tcx>(\n         })\n         .collect::<SmallVec<[_; 2]>>();\n \n-    #[cfg(debug_assertions)]\n     crate::abi::comments::add_arg_comment(\n         fx,\n         \"arg\","}, {"sha": "e1c53224b4f841751bba96f80a37b99fbcdd9e93", "filename": "compiler/rustc_codegen_cranelift/src/abi/returning.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -84,10 +84,6 @@ pub(super) fn codegen_return_param<'tcx>(\n         }\n     };\n \n-    #[cfg(not(debug_assertions))]\n-    let _ = ret_param;\n-\n-    #[cfg(debug_assertions)]\n     crate::abi::comments::add_arg_comment(\n         fx,\n         \"ret\",\n@@ -146,7 +142,7 @@ pub(super) fn codegen_with_call_return_arg<'tcx, T>(\n                 let results = fx\n                     .bcx\n                     .inst_results(call_inst)\n-                    .into_iter()\n+                    .iter()\n                     .copied()\n                     .collect::<SmallVec<[Value; 2]>>();\n                 let result ="}, {"sha": "357a9f2daf746e67e4f9bdea0e38a37637251e27", "filename": "compiler/rustc_codegen_cranelift/src/allocator.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -3,16 +3,17 @@\n \n use crate::prelude::*;\n \n+use cranelift_codegen::binemit::{NullStackMapSink, NullTrapSink};\n use rustc_ast::expand::allocator::{AllocatorKind, AllocatorTy, ALLOCATOR_METHODS};\n use rustc_span::symbol::sym;\n \n /// Returns whether an allocator shim was created\n pub(crate) fn codegen(\n     tcx: TyCtxt<'_>,\n     module: &mut impl Module,\n-    unwind_context: &mut UnwindContext<'_>,\n+    unwind_context: &mut UnwindContext,\n ) -> bool {\n-    let any_dynamic_crate = tcx.dependency_formats(LOCAL_CRATE).iter().any(|(_, list)| {\n+    let any_dynamic_crate = tcx.dependency_formats(()).iter().any(|(_, list)| {\n         use rustc_middle::middle::dependency_format::Linkage;\n         list.iter().any(|&linkage| linkage == Linkage::Dynamic)\n     });\n@@ -28,7 +29,7 @@ pub(crate) fn codegen(\n \n fn codegen_inner(\n     module: &mut impl Module,\n-    unwind_context: &mut UnwindContext<'_>,\n+    unwind_context: &mut UnwindContext,\n     kind: AllocatorKind,\n ) {\n     let usize_ty = module.target_config().pointer_type();\n@@ -92,7 +93,7 @@ fn codegen_inner(\n             bcx.finalize();\n         }\n         module\n-            .define_function(func_id, &mut ctx, &mut cranelift_codegen::binemit::NullTrapSink {})\n+            .define_function(func_id, &mut ctx, &mut NullTrapSink {}, &mut NullStackMapSink {})\n             .unwrap();\n         unwind_context.add_function(func_id, &ctx, module.isa());\n     }\n@@ -132,7 +133,7 @@ fn codegen_inner(\n         bcx.finalize();\n     }\n     module\n-        .define_function(func_id, &mut ctx, &mut cranelift_codegen::binemit::NullTrapSink {})\n+        .define_function(func_id, &mut ctx, &mut NullTrapSink {}, &mut NullStackMapSink {})\n         .unwrap();\n     unwind_context.add_function(func_id, &ctx, module.isa());\n }"}, {"sha": "fc0823302e0189971c492fcf6c96cd77292c2cfb", "filename": "compiler/rustc_codegen_cranelift/src/archive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -85,8 +85,8 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         ));\n     }\n \n-    fn add_native_library(&mut self, name: rustc_span::symbol::Symbol) {\n-        let location = find_library(name, &self.lib_search_paths, self.sess);\n+    fn add_native_library(&mut self, name: rustc_span::symbol::Symbol, verbatim: bool) {\n+        let location = find_library(name, verbatim, &self.lib_search_paths, self.sess);\n         self.add_archive(location.clone(), |_| false).unwrap_or_else(|e| {\n             panic!(\"failed to add native library {}: {}\", location.to_string_lossy(), e);\n         });"}, {"sha": "05c06bac27db47d653f3cea67422290b9f7fe517", "filename": "compiler/rustc_codegen_cranelift/src/backend.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbackend.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -5,23 +5,23 @@ use std::convert::{TryFrom, TryInto};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_session::Session;\n \n+use cranelift_codegen::isa::TargetIsa;\n use cranelift_module::FuncId;\n+use cranelift_object::{ObjectBuilder, ObjectModule, ObjectProduct};\n \n use object::write::*;\n use object::{RelocationEncoding, SectionKind, SymbolFlags};\n \n-use cranelift_object::{ObjectBuilder, ObjectModule, ObjectProduct};\n-\n use gimli::SectionId;\n \n use crate::debuginfo::{DebugReloc, DebugRelocName};\n \n pub(crate) trait WriteMetadata {\n-    fn add_rustc_section(&mut self, symbol_name: String, data: Vec<u8>, is_like_osx: bool);\n+    fn add_rustc_section(&mut self, symbol_name: String, data: Vec<u8>);\n }\n \n impl WriteMetadata for object::write::Object {\n-    fn add_rustc_section(&mut self, symbol_name: String, data: Vec<u8>, _is_like_osx: bool) {\n+    fn add_rustc_section(&mut self, symbol_name: String, data: Vec<u8>) {\n         let segment = self.segment_name(object::write::StandardSegment::Data).to_vec();\n         let section_id = self.add_section(segment, b\".rustc\".to_vec(), object::SectionKind::Data);\n         let offset = self.append_section_data(section_id, &data, 1);\n@@ -113,7 +113,7 @@ impl WriteDebugInfo for ObjectProduct {\n }\n \n pub(crate) fn with_object(sess: &Session, name: &str, f: impl FnOnce(&mut Object)) -> Vec<u8> {\n-    let triple = crate::build_isa(sess).triple().clone();\n+    let triple = crate::target_triple(sess);\n \n     let binary_format = match triple.binary_format {\n         target_lexicon::BinaryFormat::Elf => object::BinaryFormat::Elf,\n@@ -141,13 +141,9 @@ pub(crate) fn with_object(sess: &Session, name: &str, f: impl FnOnce(&mut Object\n     metadata_object.write().unwrap()\n }\n \n-pub(crate) fn make_module(sess: &Session, name: String) -> ObjectModule {\n-    let mut builder = ObjectBuilder::new(\n-        crate::build_isa(sess),\n-        name + \".o\",\n-        cranelift_module::default_libcall_names(),\n-    )\n-    .unwrap();\n+pub(crate) fn make_module(sess: &Session, isa: Box<dyn TargetIsa>, name: String) -> ObjectModule {\n+    let mut builder =\n+        ObjectBuilder::new(isa, name + \".o\", cranelift_module::default_libcall_names()).unwrap();\n     // Unlike cg_llvm, cg_clif defaults to disabling -Zfunction-sections. For cg_llvm binary size\n     // is important, while cg_clif cares more about compilation times. Enabling -Zfunction-sections\n     // can easily double the amount of time necessary to perform linking."}, {"sha": "3ec5c14ff17a2d8308657936aa5c21f15cfc6160", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 58, "deletions": 141, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -1,16 +1,18 @@\n //! Codegen of a single function\n \n+use cranelift_codegen::binemit::{NullStackMapSink, NullTrapSink};\n use rustc_index::vec::IndexVec;\n use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::layout::FnAbiExt;\n use rustc_target::abi::call::FnAbi;\n \n+use crate::constant::ConstantCx;\n use crate::prelude::*;\n \n pub(crate) fn codegen_fn<'tcx>(\n-    cx: &mut crate::CodegenCx<'_, 'tcx>,\n+    cx: &mut crate::CodegenCx<'tcx>,\n+    module: &mut dyn Module,\n     instance: Instance<'tcx>,\n-    linkage: Linkage,\n ) {\n     let tcx = cx.tcx;\n \n@@ -21,9 +23,9 @@ pub(crate) fn codegen_fn<'tcx>(\n     let mir = tcx.instance_mir(instance.def);\n \n     // Declare function\n-    let name = tcx.symbol_name(instance).name.to_string();\n-    let sig = get_function_sig(tcx, cx.module.isa().triple(), instance);\n-    let func_id = cx.module.declare_function(&name, linkage, &sig).unwrap();\n+    let symbol_name = tcx.symbol_name(instance);\n+    let sig = get_function_sig(tcx, module.isa().triple(), instance);\n+    let func_id = module.declare_function(symbol_name.name, Linkage::Local, &sig).unwrap();\n \n     cx.cached_context.clear();\n \n@@ -42,23 +44,26 @@ pub(crate) fn codegen_fn<'tcx>(\n         (0..mir.basic_blocks().len()).map(|_| bcx.create_block()).collect();\n \n     // Make FunctionCx\n-    let pointer_type = cx.module.target_config().pointer_type();\n+    let pointer_type = module.target_config().pointer_type();\n     let clif_comments = crate::pretty_clif::CommentWriter::new(tcx, instance);\n \n     let mut fx = FunctionCx {\n         cx,\n+        module,\n         tcx,\n         pointer_type,\n+        vtables: FxHashMap::default(),\n+        constants_cx: ConstantCx::new(),\n \n         instance,\n+        symbol_name,\n         mir,\n         fn_abi: Some(FnAbi::of_instance(&RevealAllLayoutCx(tcx), instance, &[])),\n \n         bcx,\n         block_map,\n         local_map: IndexVec::with_capacity(mir.local_decls.len()),\n         caller_location: None, // set by `codegen_fn_prelude`\n-        cold_blocks: EntitySet::new(),\n \n         clif_comments,\n         source_info_set: indexmap::IndexSet::new(),\n@@ -93,7 +98,8 @@ pub(crate) fn codegen_fn<'tcx>(\n     let mut clif_comments = fx.clif_comments;\n     let source_info_set = fx.source_info_set;\n     let local_map = fx.local_map;\n-    let cold_blocks = fx.cold_blocks;\n+\n+    fx.constants_cx.finalize(fx.tcx, &mut *fx.module);\n \n     // Store function in context\n     let context = &mut cx.cached_context;\n@@ -106,40 +112,33 @@ pub(crate) fn codegen_fn<'tcx>(\n \n     // Perform rust specific optimizations\n     tcx.sess.time(\"optimize clif ir\", || {\n-        crate::optimize::optimize_function(\n-            tcx,\n-            instance,\n-            context,\n-            &cold_blocks,\n-            &mut clif_comments,\n-        );\n+        crate::optimize::optimize_function(tcx, instance, context, &mut clif_comments);\n     });\n \n     // If the return block is not reachable, then the SSA builder may have inserted an `iconst.i128`\n     // instruction, which doesn't have an encoding.\n     context.compute_cfg();\n     context.compute_domtree();\n-    context.eliminate_unreachable_code(cx.module.isa()).unwrap();\n-    context.dce(cx.module.isa()).unwrap();\n+    context.eliminate_unreachable_code(module.isa()).unwrap();\n+    context.dce(module.isa()).unwrap();\n     // Some Cranelift optimizations expect the domtree to not yet be computed and as such don't\n     // invalidate it when it would change.\n     context.domtree.clear();\n \n     context.want_disasm = crate::pretty_clif::should_write_ir(tcx);\n \n     // Define function\n-    let module = &mut cx.module;\n     tcx.sess.time(\"define function\", || {\n         module\n-            .define_function(func_id, context, &mut cranelift_codegen::binemit::NullTrapSink {})\n+            .define_function(func_id, context, &mut NullTrapSink {}, &mut NullStackMapSink {})\n             .unwrap()\n     });\n \n     // Write optimized function to file for debugging\n     crate::pretty_clif::write_clif_file(\n         tcx,\n         \"opt\",\n-        Some(cx.module.isa()),\n+        Some(module.isa()),\n         instance,\n         &context,\n         &clif_comments,\n@@ -148,21 +147,21 @@ pub(crate) fn codegen_fn<'tcx>(\n     if let Some(disasm) = &context.mach_compile_result.as_ref().unwrap().disasm {\n         crate::pretty_clif::write_ir_file(\n             tcx,\n-            &format!(\"{}.vcode\", tcx.symbol_name(instance).name),\n+            || format!(\"{}.vcode\", tcx.symbol_name(instance).name),\n             |file| file.write_all(disasm.as_bytes()),\n         )\n     }\n \n     // Define debuginfo for function\n-    let isa = cx.module.isa();\n+    let isa = module.isa();\n     let debug_context = &mut cx.debug_context;\n     let unwind_context = &mut cx.unwind_context;\n     tcx.sess.time(\"generate debug info\", || {\n         if let Some(debug_context) = debug_context {\n             debug_context.define_function(\n                 instance,\n                 func_id,\n-                &name,\n+                symbol_name.name,\n                 isa,\n                 context,\n                 &source_info_set,\n@@ -208,9 +207,8 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n             // Unwinding after panicking is not supported\n             continue;\n \n-            // FIXME once unwinding is supported uncomment next lines\n-            // // Unwinding is unlikely to happen, so mark cleanup block's as cold.\n-            // fx.cold_blocks.insert(block);\n+            // FIXME Once unwinding is supported and Cranelift supports marking blocks as cold, do\n+            // so for cleanup blocks.\n         }\n \n         fx.bcx.ins().nop();\n@@ -219,8 +217,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n             codegen_stmt(fx, block, stmt);\n         }\n \n-        #[cfg(debug_assertions)]\n-        {\n+        if fx.clif_comments.enabled() {\n             let mut terminator_head = \"\\n\".to_string();\n             bb_data.terminator().kind.fmt_head(&mut terminator_head).unwrap();\n             let inst = fx.bcx.func.layout.last_inst(block).unwrap();\n@@ -266,7 +263,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n \n                 let target = fx.get_block(*target);\n                 let failure = fx.bcx.create_block();\n-                fx.cold_blocks.insert(failure);\n+                // FIXME Mark failure block as cold once Cranelift supports it\n \n                 if *expected {\n                     fx.bcx.ins().brz(cond, failure, &[]);\n@@ -359,14 +356,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n                 from_hir_call: _,\n             } => {\n                 fx.tcx.sess.time(\"codegen call\", || {\n-                    crate::abi::codegen_terminator_call(\n-                        fx,\n-                        *fn_span,\n-                        block,\n-                        func,\n-                        args,\n-                        *destination,\n-                    )\n+                    crate::abi::codegen_terminator_call(fx, *fn_span, func, args, *destination)\n                 });\n             }\n             TerminatorKind::InlineAsm {\n@@ -433,12 +423,14 @@ fn codegen_stmt<'tcx>(\n \n     fx.set_debug_loc(stmt.source_info);\n \n-    #[cfg(false_debug_assertions)]\n+    #[cfg(disabled)]\n     match &stmt.kind {\n         StatementKind::StorageLive(..) | StatementKind::StorageDead(..) => {} // Those are not very useful\n         _ => {\n-            let inst = fx.bcx.func.layout.last_inst(cur_block).unwrap();\n-            fx.add_comment(inst, format!(\"{:?}\", stmt));\n+            if fx.clif_comments.enabled() {\n+                let inst = fx.bcx.func.layout.last_inst(cur_block).unwrap();\n+                fx.add_comment(inst, format!(\"{:?}\", stmt));\n+            }\n         }\n     }\n \n@@ -464,16 +456,16 @@ fn codegen_stmt<'tcx>(\n                     let val = crate::constant::codegen_tls_ref(fx, def_id, lval.layout());\n                     lval.write_cvalue(fx, val);\n                 }\n-                Rvalue::BinaryOp(bin_op, box (ref lhs, ref rhs)) => {\n-                    let lhs = codegen_operand(fx, lhs);\n-                    let rhs = codegen_operand(fx, rhs);\n+                Rvalue::BinaryOp(bin_op, ref lhs_rhs) => {\n+                    let lhs = codegen_operand(fx, &lhs_rhs.0);\n+                    let rhs = codegen_operand(fx, &lhs_rhs.1);\n \n                     let res = crate::num::codegen_binop(fx, bin_op, lhs, rhs);\n                     lval.write_cvalue(fx, res);\n                 }\n-                Rvalue::CheckedBinaryOp(bin_op, box (ref lhs, ref rhs)) => {\n-                    let lhs = codegen_operand(fx, lhs);\n-                    let rhs = codegen_operand(fx, rhs);\n+                Rvalue::CheckedBinaryOp(bin_op, ref lhs_rhs) => {\n+                    let lhs = codegen_operand(fx, &lhs_rhs.0);\n+                    let rhs = codegen_operand(fx, &lhs_rhs.1);\n \n                     let res = if !fx.tcx.sess.overflow_checks() {\n                         let val =\n@@ -659,12 +651,14 @@ fn codegen_stmt<'tcx>(\n                         .val\n                         .try_to_bits(fx.tcx.data_layout.pointer_size)\n                         .unwrap();\n-                    if fx.clif_type(operand.layout().ty) == Some(types::I8) {\n+                    if operand.layout().size.bytes() == 0 {\n+                        // Do nothing for ZST's\n+                    } else if fx.clif_type(operand.layout().ty) == Some(types::I8) {\n                         let times = fx.bcx.ins().iconst(fx.pointer_type, times as i64);\n                         // FIXME use emit_small_memset where possible\n                         let addr = lval.to_ptr().get_addr(fx);\n                         let val = operand.load_scalar(fx);\n-                        fx.bcx.call_memset(fx.cx.module.target_config(), addr, val, times);\n+                        fx.bcx.call_memset(fx.module.target_config(), addr, val, times);\n                     } else {\n                         let loop_block = fx.bcx.create_block();\n                         let loop_block2 = fx.bcx.create_block();\n@@ -750,108 +744,31 @@ fn codegen_stmt<'tcx>(\n         | StatementKind::AscribeUserType(..) => {}\n \n         StatementKind::LlvmInlineAsm(asm) => {\n-            use rustc_span::symbol::Symbol;\n-            let LlvmInlineAsm { asm, outputs, inputs } = &**asm;\n-            let rustc_hir::LlvmInlineAsmInner {\n-                asm: asm_code,         // Name\n-                outputs: output_names, // Vec<LlvmInlineAsmOutput>\n-                inputs: input_names,   // Vec<Name>\n-                clobbers,              // Vec<Name>\n-                volatile,              // bool\n-                alignstack,            // bool\n-                dialect: _,\n-                asm_str_style: _,\n-            } = asm;\n-            match asm_code.as_str().trim() {\n+            match asm.asm.asm.as_str().trim() {\n                 \"\" => {\n                     // Black box\n                 }\n-                \"mov %rbx, %rsi\\n                  cpuid\\n                  xchg %rbx, %rsi\" => {\n-                    assert_eq!(input_names, &[Symbol::intern(\"{eax}\"), Symbol::intern(\"{ecx}\")]);\n-                    assert_eq!(output_names.len(), 4);\n-                    for (i, c) in (&[\"={eax}\", \"={esi}\", \"={ecx}\", \"={edx}\"]).iter().enumerate() {\n-                        assert_eq!(&output_names[i].constraint.as_str(), c);\n-                        assert!(!output_names[i].is_rw);\n-                        assert!(!output_names[i].is_indirect);\n-                    }\n-\n-                    assert_eq!(clobbers, &[]);\n-\n-                    assert!(!volatile);\n-                    assert!(!alignstack);\n-\n-                    assert_eq!(inputs.len(), 2);\n-                    let leaf = codegen_operand(fx, &inputs[0].1).load_scalar(fx); // %eax\n-                    let subleaf = codegen_operand(fx, &inputs[1].1).load_scalar(fx); // %ecx\n-\n-                    let (eax, ebx, ecx, edx) =\n-                        crate::intrinsics::codegen_cpuid_call(fx, leaf, subleaf);\n-\n-                    assert_eq!(outputs.len(), 4);\n-                    codegen_place(fx, outputs[0])\n-                        .write_cvalue(fx, CValue::by_val(eax, fx.layout_of(fx.tcx.types.u32)));\n-                    codegen_place(fx, outputs[1])\n-                        .write_cvalue(fx, CValue::by_val(ebx, fx.layout_of(fx.tcx.types.u32)));\n-                    codegen_place(fx, outputs[2])\n-                        .write_cvalue(fx, CValue::by_val(ecx, fx.layout_of(fx.tcx.types.u32)));\n-                    codegen_place(fx, outputs[3])\n-                        .write_cvalue(fx, CValue::by_val(edx, fx.layout_of(fx.tcx.types.u32)));\n-                }\n-                \"xgetbv\" => {\n-                    assert_eq!(input_names, &[Symbol::intern(\"{ecx}\")]);\n-\n-                    assert_eq!(output_names.len(), 2);\n-                    for (i, c) in (&[\"={eax}\", \"={edx}\"]).iter().enumerate() {\n-                        assert_eq!(&output_names[i].constraint.as_str(), c);\n-                        assert!(!output_names[i].is_rw);\n-                        assert!(!output_names[i].is_indirect);\n-                    }\n-\n-                    assert_eq!(clobbers, &[]);\n-\n-                    assert!(!volatile);\n-                    assert!(!alignstack);\n-\n-                    crate::trap::trap_unimplemented(fx, \"_xgetbv arch intrinsic is not supported\");\n-                }\n-                // ___chkstk, ___chkstk_ms and __alloca are only used on Windows\n-                _ if fx.tcx.symbol_name(fx.instance).name.starts_with(\"___chkstk\") => {\n-                    crate::trap::trap_unimplemented(fx, \"Stack probes are not supported\");\n-                }\n-                _ if fx.tcx.symbol_name(fx.instance).name == \"__alloca\" => {\n-                    crate::trap::trap_unimplemented(fx, \"Alloca is not supported\");\n-                }\n-                // Used in sys::windows::abort_internal\n-                \"int $$0x29\" => {\n-                    crate::trap::trap_unimplemented(fx, \"Windows abort\");\n-                }\n-                _ => fx\n-                    .tcx\n-                    .sess\n-                    .span_fatal(stmt.source_info.span, \"Inline assembly is not supported\"),\n+                _ => fx.tcx.sess.span_fatal(\n+                    stmt.source_info.span,\n+                    \"Legacy `llvm_asm!` inline assembly is not supported. \\\n+                    Try using the new `asm!` instead.\",\n+                ),\n             }\n         }\n         StatementKind::Coverage { .. } => fx.tcx.sess.fatal(\"-Zcoverage is unimplemented\"),\n-        StatementKind::CopyNonOverlapping(box rustc_middle::mir::CopyNonOverlapping {\n-          src,\n-          dst,\n-          count,\n-        }) => {\n-            let dst = codegen_operand(fx, dst);\n+        StatementKind::CopyNonOverlapping(inner) => {\n+            let dst = codegen_operand(fx, &inner.dst);\n             let pointee = dst\n-              .layout()\n-              .pointee_info_at(fx, rustc_target::abi::Size::ZERO)\n-              .expect(\"Expected pointer\");\n+                .layout()\n+                .pointee_info_at(fx, rustc_target::abi::Size::ZERO)\n+                .expect(\"Expected pointer\");\n             let dst = dst.load_scalar(fx);\n-            let src = codegen_operand(fx, src).load_scalar(fx);\n-            let count = codegen_operand(fx, count).load_scalar(fx);\n+            let src = codegen_operand(fx, &inner.src).load_scalar(fx);\n+            let count = codegen_operand(fx, &inner.count).load_scalar(fx);\n             let elem_size: u64 = pointee.size.bytes();\n-            let bytes = if elem_size != 1 {\n-               fx.bcx.ins().imul_imm(count, elem_size as i64)\n-            } else {\n-               count\n-            };\n-            fx.bcx.call_memcpy(fx.cx.module.target_config(), dst, src, bytes);\n+            let bytes =\n+                if elem_size != 1 { fx.bcx.ins().imul_imm(count, elem_size as i64) } else { count };\n+            fx.bcx.call_memcpy(fx.module.target_config(), dst, src, bytes);\n         }\n     }\n }"}, {"sha": "ffe1922ab9056dc3c82a303e21d8d147b7243a2c", "filename": "compiler/rustc_codegen_cranelift/src/codegen_i128.rs", "status": "modified", "additions": 70, "deletions": 19, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -32,18 +32,56 @@ pub(crate) fn maybe_codegen<'tcx>(\n         BinOp::Add | BinOp::Sub if !checked => None,\n         BinOp::Mul if !checked => {\n             let val_ty = if is_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n-            Some(fx.easy_call(\"__multi3\", &[lhs, rhs], val_ty))\n+            if fx.tcx.sess.target.is_like_windows {\n+                let ret_place = CPlace::new_stack_slot(fx, lhs.layout());\n+                let (lhs_ptr, lhs_extra) = lhs.force_stack(fx);\n+                let (rhs_ptr, rhs_extra) = rhs.force_stack(fx);\n+                assert!(lhs_extra.is_none());\n+                assert!(rhs_extra.is_none());\n+                let args =\n+                    [ret_place.to_ptr().get_addr(fx), lhs_ptr.get_addr(fx), rhs_ptr.get_addr(fx)];\n+                fx.lib_call(\n+                    \"__multi3\",\n+                    vec![\n+                        AbiParam::special(pointer_ty(fx.tcx), ArgumentPurpose::StructReturn),\n+                        AbiParam::new(pointer_ty(fx.tcx)),\n+                        AbiParam::new(pointer_ty(fx.tcx)),\n+                    ],\n+                    vec![],\n+                    &args,\n+                );\n+                Some(ret_place.to_cvalue(fx))\n+            } else {\n+                Some(fx.easy_call(\"__multi3\", &[lhs, rhs], val_ty))\n+            }\n         }\n         BinOp::Add | BinOp::Sub | BinOp::Mul => {\n             assert!(checked);\n             let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n             let out_place = CPlace::new_stack_slot(fx, fx.layout_of(out_ty));\n-            let param_types = vec![\n-                AbiParam::special(pointer_ty(fx.tcx), ArgumentPurpose::StructReturn),\n-                AbiParam::new(types::I128),\n-                AbiParam::new(types::I128),\n-            ];\n-            let args = [out_place.to_ptr().get_addr(fx), lhs.load_scalar(fx), rhs.load_scalar(fx)];\n+            let (param_types, args) = if fx.tcx.sess.target.is_like_windows {\n+                let (lhs_ptr, lhs_extra) = lhs.force_stack(fx);\n+                let (rhs_ptr, rhs_extra) = rhs.force_stack(fx);\n+                assert!(lhs_extra.is_none());\n+                assert!(rhs_extra.is_none());\n+                (\n+                    vec![\n+                        AbiParam::special(pointer_ty(fx.tcx), ArgumentPurpose::StructReturn),\n+                        AbiParam::new(pointer_ty(fx.tcx)),\n+                        AbiParam::new(pointer_ty(fx.tcx)),\n+                    ],\n+                    [out_place.to_ptr().get_addr(fx), lhs_ptr.get_addr(fx), rhs_ptr.get_addr(fx)],\n+                )\n+            } else {\n+                (\n+                    vec![\n+                        AbiParam::special(pointer_ty(fx.tcx), ArgumentPurpose::StructReturn),\n+                        AbiParam::new(types::I128),\n+                        AbiParam::new(types::I128),\n+                    ],\n+                    [out_place.to_ptr().get_addr(fx), lhs.load_scalar(fx), rhs.load_scalar(fx)],\n+                )\n+            };\n             let name = match (bin_op, is_signed) {\n                 (BinOp::Add, false) => \"__rust_u128_addo\",\n                 (BinOp::Add, true) => \"__rust_i128_addo\",\n@@ -57,20 +95,33 @@ pub(crate) fn maybe_codegen<'tcx>(\n             Some(out_place.to_cvalue(fx))\n         }\n         BinOp::Offset => unreachable!(\"offset should only be used on pointers, not 128bit ints\"),\n-        BinOp::Div => {\n+        BinOp::Div | BinOp::Rem => {\n             assert!(!checked);\n-            if is_signed {\n-                Some(fx.easy_call(\"__divti3\", &[lhs, rhs], fx.tcx.types.i128))\n-            } else {\n-                Some(fx.easy_call(\"__udivti3\", &[lhs, rhs], fx.tcx.types.u128))\n-            }\n-        }\n-        BinOp::Rem => {\n-            assert!(!checked);\n-            if is_signed {\n-                Some(fx.easy_call(\"__modti3\", &[lhs, rhs], fx.tcx.types.i128))\n+            let name = match (bin_op, is_signed) {\n+                (BinOp::Div, false) => \"__udivti3\",\n+                (BinOp::Div, true) => \"__divti3\",\n+                (BinOp::Rem, false) => \"__umodti3\",\n+                (BinOp::Rem, true) => \"__modti3\",\n+                _ => unreachable!(),\n+            };\n+            if fx.tcx.sess.target.is_like_windows {\n+                let (lhs_ptr, lhs_extra) = lhs.force_stack(fx);\n+                let (rhs_ptr, rhs_extra) = rhs.force_stack(fx);\n+                assert!(lhs_extra.is_none());\n+                assert!(rhs_extra.is_none());\n+                let args = [lhs_ptr.get_addr(fx), rhs_ptr.get_addr(fx)];\n+                let ret = fx.lib_call(\n+                    name,\n+                    vec![AbiParam::new(pointer_ty(fx.tcx)), AbiParam::new(pointer_ty(fx.tcx))],\n+                    vec![AbiParam::new(types::I64X2)],\n+                    &args,\n+                )[0];\n+                // FIXME use bitcast instead of store to get from i64x2 to i128\n+                let ret_place = CPlace::new_stack_slot(fx, lhs.layout());\n+                ret_place.to_ptr().store(fx, ret, MemFlags::trusted());\n+                Some(ret_place.to_cvalue(fx))\n             } else {\n-                Some(fx.easy_call(\"__umodti3\", &[lhs, rhs], fx.tcx.types.u128))\n+                Some(fx.easy_call(name, &[lhs, rhs], lhs.layout().ty))\n             }\n         }\n         BinOp::Lt | BinOp::Le | BinOp::Eq | BinOp::Ge | BinOp::Gt | BinOp::Ne => {"}, {"sha": "c12d6d0f1414306a13c698059eb544493129766a", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -1,8 +1,10 @@\n use rustc_index::vec::IndexVec;\n+use rustc_middle::ty::SymbolName;\n use rustc_target::abi::call::FnAbi;\n use rustc_target::abi::{Integer, Primitive};\n use rustc_target::spec::{HasTargetSpec, Target};\n \n+use crate::constant::ConstantCx;\n use crate::prelude::*;\n \n pub(crate) fn pointer_ty(tcx: TyCtxt<'_>) -> types::Type {\n@@ -226,12 +228,16 @@ pub(crate) fn type_sign(ty: Ty<'_>) -> bool {\n     }\n }\n \n-pub(crate) struct FunctionCx<'m, 'clif, 'tcx> {\n-    pub(crate) cx: &'clif mut crate::CodegenCx<'m, 'tcx>,\n+pub(crate) struct FunctionCx<'m, 'clif, 'tcx: 'm> {\n+    pub(crate) cx: &'clif mut crate::CodegenCx<'tcx>,\n+    pub(crate) module: &'m mut dyn Module,\n     pub(crate) tcx: TyCtxt<'tcx>,\n     pub(crate) pointer_type: Type, // Cached from module\n+    pub(crate) vtables: FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), DataId>,\n+    pub(crate) constants_cx: ConstantCx,\n \n     pub(crate) instance: Instance<'tcx>,\n+    pub(crate) symbol_name: SymbolName<'tcx>,\n     pub(crate) mir: &'tcx Body<'tcx>,\n     pub(crate) fn_abi: Option<FnAbi<'tcx, Ty<'tcx>>>,\n \n@@ -242,9 +248,6 @@ pub(crate) struct FunctionCx<'m, 'clif, 'tcx> {\n     /// When `#[track_caller]` is used, the implicit caller location is stored in this variable.\n     pub(crate) caller_location: Option<CValue<'tcx>>,\n \n-    /// See [`crate::optimize::code_layout`] for more information.\n-    pub(crate) cold_blocks: EntitySet<Block>,\n-\n     pub(crate) clif_comments: crate::pretty_clif::CommentWriter,\n     pub(crate) source_info_set: indexmap::IndexSet<SourceInfo>,\n \n@@ -331,15 +334,17 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n         let caller = self.tcx.sess.source_map().lookup_char_pos(topmost.lo());\n         let const_loc = self.tcx.const_caller_location((\n-            rustc_span::symbol::Symbol::intern(&caller.file.name.to_string()),\n+            rustc_span::symbol::Symbol::intern(\n+                &caller.file.name.prefer_remapped().to_string_lossy(),\n+            ),\n             caller.line as u32,\n             caller.col_display as u32 + 1,\n         ));\n         crate::constant::codegen_const_value(self, const_loc, self.tcx.caller_location_ty())\n     }\n \n     pub(crate) fn triple(&self) -> &target_lexicon::Triple {\n-        self.cx.module.isa().triple()\n+        self.module.isa().triple()\n     }\n \n     pub(crate) fn anonymous_str(&mut self, prefix: &str, msg: &str) -> Value {\n@@ -352,17 +357,15 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         let mut data_ctx = DataContext::new();\n         data_ctx.define(msg.as_bytes().to_vec().into_boxed_slice());\n         let msg_id = self\n-            .cx\n             .module\n             .declare_data(&format!(\"__{}_{:08x}\", prefix, msg_hash), Linkage::Local, false, false)\n             .unwrap();\n \n         // Ignore DuplicateDefinition error, as the data will be the same\n-        let _ = self.cx.module.define_data(msg_id, &data_ctx);\n+        let _ = self.module.define_data(msg_id, &data_ctx);\n \n-        let local_msg_id = self.cx.module.declare_data_in_func(msg_id, self.bcx.func);\n-        #[cfg(debug_assertions)]\n-        {\n+        let local_msg_id = self.module.declare_data_in_func(msg_id, self.bcx.func);\n+        if self.clif_comments.enabled() {\n             self.add_comment(local_msg_id, msg);\n         }\n         self.bcx.ins().global_value(self.pointer_type, local_msg_id)"}, {"sha": "177f850afb398ef6c90e8d1e161920ec56d846e0", "filename": "compiler/rustc_codegen_cranelift/src/compiler_builtins.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcompiler_builtins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcompiler_builtins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcompiler_builtins.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -0,0 +1,41 @@\n+macro builtin_functions($register:ident; $(fn $name:ident($($arg_name:ident: $arg_ty:ty),*) -> $ret_ty:ty;)*) {\n+    #[cfg(feature = \"jit\")]\n+    #[allow(improper_ctypes)]\n+    extern \"C\" {\n+        $(fn $name($($arg_name: $arg_ty),*) -> $ret_ty;)*\n+    }\n+\n+    #[cfg(feature = \"jit\")]\n+    pub(crate) fn $register(builder: &mut cranelift_jit::JITBuilder) {\n+        for &(name, val) in &[$((stringify!($name), $name as *const u8)),*] {\n+            builder.symbol(name, val);\n+        }\n+    }\n+}\n+\n+builtin_functions! {\n+    register_functions_for_jit;\n+\n+    // integers\n+    fn __multi3(a: i128, b: i128) -> i128;\n+    fn __udivti3(n: u128, d: u128) -> u128;\n+    fn __divti3(n: i128, d: i128) -> i128;\n+    fn __umodti3(n: u128, d: u128) -> u128;\n+    fn __modti3(n: i128, d: i128) -> i128;\n+    fn __rust_u128_addo(a: u128, b: u128) -> (u128, bool);\n+    fn __rust_i128_addo(a: i128, b: i128) -> (i128, bool);\n+    fn __rust_u128_subo(a: u128, b: u128) -> (u128, bool);\n+    fn __rust_i128_subo(a: i128, b: i128) -> (i128, bool);\n+    fn __rust_u128_mulo(a: u128, b: u128) -> (u128, bool);\n+    fn __rust_i128_mulo(a: i128, b: i128) -> (i128, bool);\n+\n+    // floats\n+    fn __floattisf(i: i128) -> f32;\n+    fn __floattidf(i: i128) -> f64;\n+    fn __floatuntisf(i: u128) -> f32;\n+    fn __floatuntidf(i: u128) -> f64;\n+    fn __fixsfti(f: f32) -> i128;\n+    fn __fixdfti(f: f64) -> i128;\n+    fn __fixunssfti(f: f32) -> u128;\n+    fn __fixunsdfti(f: f64) -> u128;\n+}"}, {"sha": "e59a0cb0a23237bfe0b4fd0164909db4d8a98e49", "filename": "compiler/rustc_codegen_cranelift/src/config.rs", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconfig.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -0,0 +1,107 @@\n+use std::env;\n+use std::str::FromStr;\n+\n+fn bool_env_var(key: &str) -> bool {\n+    env::var(key).as_ref().map(|val| &**val) == Ok(\"1\")\n+}\n+\n+/// The mode to use for compilation.\n+#[derive(Copy, Clone, Debug)]\n+pub enum CodegenMode {\n+    /// AOT compile the crate. This is the default.\n+    Aot,\n+    /// JIT compile and execute the crate.\n+    Jit,\n+    /// JIT compile and execute the crate, but only compile functions the first time they are used.\n+    JitLazy,\n+}\n+\n+impl FromStr for CodegenMode {\n+    type Err = String;\n+\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        match s {\n+            \"aot\" => Ok(CodegenMode::Aot),\n+            \"jit\" => Ok(CodegenMode::Jit),\n+            \"jit-lazy\" => Ok(CodegenMode::JitLazy),\n+            _ => Err(format!(\"Unknown codegen mode `{}`\", s)),\n+        }\n+    }\n+}\n+\n+/// Configuration of cg_clif as passed in through `-Cllvm-args` and various env vars.\n+#[derive(Clone, Debug)]\n+pub struct BackendConfig {\n+    /// Should the crate be AOT compiled or JIT executed.\n+    ///\n+    /// Defaults to AOT compilation. Can be set using `-Cllvm-args=mode=...`.\n+    pub codegen_mode: CodegenMode,\n+\n+    /// When JIT mode is enable pass these arguments to the program.\n+    ///\n+    /// Defaults to the value of `CG_CLIF_JIT_ARGS`.\n+    pub jit_args: Vec<String>,\n+\n+    /// Display the time it took to perform codegen for a crate.\n+    ///\n+    /// Defaults to true when the `CG_CLIF_DISPLAY_CG_TIME` env var is set to 1 or false otherwise.\n+    /// Can be set using `-Cllvm-args=display_cg_time=...`.\n+    pub display_cg_time: bool,\n+\n+    /// Enable the Cranelift ir verifier for all compilation passes. If not set it will only run\n+    /// once before passing the clif ir to Cranelift for compilation.\n+    ///\n+    /// Defaults to true when the `CG_CLIF_ENABLE_VERIFIER` env var is set to 1 or when cg_clif is\n+    /// compiled with debug assertions enabled or false otherwise. Can be set using\n+    /// `-Cllvm-args=enable_verifier=...`.\n+    pub enable_verifier: bool,\n+\n+    /// Don't cache object files in the incremental cache. Useful during development of cg_clif\n+    /// to make it possible to use incremental mode for all analyses performed by rustc without\n+    /// caching object files when their content should have been changed by a change to cg_clif.\n+    ///\n+    /// Defaults to true when the `CG_CLIF_DISABLE_INCR_CACHE` env var is set to 1 or false\n+    /// otherwise. Can be set using `-Cllvm-args=disable_incr_cache=...`.\n+    pub disable_incr_cache: bool,\n+}\n+\n+impl Default for BackendConfig {\n+    fn default() -> Self {\n+        BackendConfig {\n+            codegen_mode: CodegenMode::Aot,\n+            jit_args: {\n+                let args = std::env::var(\"CG_CLIF_JIT_ARGS\").unwrap_or_else(|_| String::new());\n+                args.split(' ').map(|arg| arg.to_string()).collect()\n+            },\n+            display_cg_time: bool_env_var(\"CG_CLIF_DISPLAY_CG_TIME\"),\n+            enable_verifier: cfg!(debug_assertions) || bool_env_var(\"CG_CLIF_ENABLE_VERIFIER\"),\n+            disable_incr_cache: bool_env_var(\"CG_CLIF_DISABLE_INCR_CACHE\"),\n+        }\n+    }\n+}\n+\n+impl BackendConfig {\n+    /// Parse the configuration passed in using `-Cllvm-args`.\n+    pub fn from_opts(opts: &[String]) -> Result<Self, String> {\n+        fn parse_bool(name: &str, value: &str) -> Result<bool, String> {\n+            value.parse().map_err(|_| format!(\"failed to parse value `{}` for {}\", value, name))\n+        }\n+\n+        let mut config = BackendConfig::default();\n+        for opt in opts {\n+            if let Some((name, value)) = opt.split_once('=') {\n+                match name {\n+                    \"mode\" => config.codegen_mode = value.parse()?,\n+                    \"display_cg_time\" => config.display_cg_time = parse_bool(name, value)?,\n+                    \"enable_verifier\" => config.enable_verifier = parse_bool(name, value)?,\n+                    \"disable_incr_cache\" => config.disable_incr_cache = parse_bool(name, value)?,\n+                    _ => return Err(format!(\"Unknown option `{}`\", name)),\n+                }\n+            } else {\n+                return Err(format!(\"Invalid option `{}`\", opt));\n+            }\n+        }\n+\n+        Ok(config)\n+    }\n+}"}, {"sha": "6b132e4ff0fb8093712495e2935ff17cb7d2f3a6", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 58, "deletions": 45, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -2,11 +2,12 @@\n \n use rustc_span::DUMMY_SP;\n \n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_ast::Mutability;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::ErrorReported;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::interpret::{\n-    read_target_uint, AllocId, Allocation, ConstValue, ErrorHandled, GlobalAlloc, Pointer, Scalar,\n+    alloc_range, read_target_uint, AllocId, Allocation, ConstValue, ErrorHandled, GlobalAlloc, Scalar,\n };\n use rustc_middle::ty::ConstKind;\n \n@@ -15,10 +16,10 @@ use cranelift_module::*;\n \n use crate::prelude::*;\n \n-#[derive(Default)]\n pub(crate) struct ConstantCx {\n     todo: Vec<TodoItem>,\n     done: FxHashSet<DataId>,\n+    anon_allocs: FxHashMap<AllocId, DataId>,\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -28,6 +29,10 @@ enum TodoItem {\n }\n \n impl ConstantCx {\n+    pub(crate) fn new() -> Self {\n+        ConstantCx { todo: vec![], done: FxHashSet::default(), anon_allocs: FxHashMap::default() }\n+    }\n+\n     pub(crate) fn finalize(mut self, tcx: TyCtxt<'_>, module: &mut dyn Module) {\n         //println!(\"todo {:?}\", self.todo);\n         define_all_allocs(tcx, module, &mut self);\n@@ -74,19 +79,22 @@ pub(crate) fn check_constants(fx: &mut FunctionCx<'_, '_, '_>) -> bool {\n     all_constants_ok\n }\n \n-pub(crate) fn codegen_static(constants_cx: &mut ConstantCx, def_id: DefId) {\n+pub(crate) fn codegen_static(tcx: TyCtxt<'_>, module: &mut dyn Module, def_id: DefId) {\n+    let mut constants_cx = ConstantCx::new();\n     constants_cx.todo.push(TodoItem::Static(def_id));\n+    constants_cx.finalize(tcx, module);\n }\n \n pub(crate) fn codegen_tls_ref<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     def_id: DefId,\n     layout: TyAndLayout<'tcx>,\n ) -> CValue<'tcx> {\n-    let data_id = data_id_for_static(fx.tcx, fx.cx.module, def_id, false);\n-    let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n-    #[cfg(debug_assertions)]\n-    fx.add_comment(local_data_id, format!(\"tls {:?}\", def_id));\n+    let data_id = data_id_for_static(fx.tcx, fx.module, def_id, false);\n+    let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+    if fx.clif_comments.enabled() {\n+        fx.add_comment(local_data_id, format!(\"tls {:?}\", def_id));\n+    }\n     let tls_ptr = fx.bcx.ins().tls_value(fx.pointer_type, local_data_id);\n     CValue::by_val(tls_ptr, layout)\n }\n@@ -96,10 +104,11 @@ fn codegen_static_ref<'tcx>(\n     def_id: DefId,\n     layout: TyAndLayout<'tcx>,\n ) -> CPlace<'tcx> {\n-    let data_id = data_id_for_static(fx.tcx, fx.cx.module, def_id, false);\n-    let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n-    #[cfg(debug_assertions)]\n-    fx.add_comment(local_data_id, format!(\"{:?}\", def_id));\n+    let data_id = data_id_for_static(fx.tcx, fx.module, def_id, false);\n+    let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+    if fx.clif_comments.enabled() {\n+        fx.add_comment(local_data_id, format!(\"{:?}\", def_id));\n+    }\n     let global_ptr = fx.bcx.ins().global_value(fx.pointer_type, local_data_id);\n     assert!(!layout.is_unsized(), \"unsized statics aren't supported\");\n     assert!(\n@@ -122,7 +131,9 @@ pub(crate) fn codegen_constant<'tcx>(\n     };\n     let const_val = match const_.val {\n         ConstKind::Value(const_val) => const_val,\n-        ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted }) if fx.tcx.is_static(def.did) => {\n+        ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted })\n+            if fx.tcx.is_static(def.did) =>\n+        {\n             assert!(substs.is_empty());\n             assert!(promoted.is_none());\n \n@@ -165,9 +176,9 @@ pub(crate) fn codegen_const_value<'tcx>(\n                 let mut alloc = Allocation::from_bytes(\n                     std::iter::repeat(0).take(size.bytes_usize()).collect::<Vec<u8>>(),\n                     align,\n+                    Mutability::Not,\n                 );\n-                let ptr = Pointer::new(AllocId(!0), Size::ZERO); // The alloc id is never used\n-                alloc.write_scalar(fx, ptr, x.into(), size).unwrap();\n+                alloc.write_scalar(fx, alloc_range(Size::ZERO, size), x.into()).unwrap();\n                 let alloc = fx.tcx.intern_const_alloc(alloc);\n                 return CValue::by_ref(pointer_for_allocation(fx, alloc), layout);\n             }\n@@ -178,29 +189,34 @@ pub(crate) fn codegen_const_value<'tcx>(\n                     let alloc_kind = fx.tcx.get_global_alloc(ptr.alloc_id);\n                     let base_addr = match alloc_kind {\n                         Some(GlobalAlloc::Memory(alloc)) => {\n-                            fx.cx.constants_cx.todo.push(TodoItem::Alloc(ptr.alloc_id));\n-                            let data_id =\n-                                data_id_for_alloc_id(fx.cx.module, ptr.alloc_id, alloc.mutability);\n+                            fx.constants_cx.todo.push(TodoItem::Alloc(ptr.alloc_id));\n+                            let data_id = data_id_for_alloc_id(\n+                                &mut fx.constants_cx,\n+                                fx.module,\n+                                ptr.alloc_id,\n+                                alloc.mutability,\n+                            );\n                             let local_data_id =\n-                                fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n-                            #[cfg(debug_assertions)]\n-                            fx.add_comment(local_data_id, format!(\"{:?}\", ptr.alloc_id));\n+                                fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+                            if fx.clif_comments.enabled() {\n+                                fx.add_comment(local_data_id, format!(\"{:?}\", ptr.alloc_id));\n+                            }\n                             fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n                         }\n                         Some(GlobalAlloc::Function(instance)) => {\n-                            let func_id =\n-                                crate::abi::import_function(fx.tcx, fx.cx.module, instance);\n+                            let func_id = crate::abi::import_function(fx.tcx, fx.module, instance);\n                             let local_func_id =\n-                                fx.cx.module.declare_func_in_func(func_id, &mut fx.bcx.func);\n+                                fx.module.declare_func_in_func(func_id, &mut fx.bcx.func);\n                             fx.bcx.ins().func_addr(fx.pointer_type, local_func_id)\n                         }\n                         Some(GlobalAlloc::Static(def_id)) => {\n                             assert!(fx.tcx.is_static(def_id));\n-                            let data_id = data_id_for_static(fx.tcx, fx.cx.module, def_id, false);\n+                            let data_id = data_id_for_static(fx.tcx, fx.module, def_id, false);\n                             let local_data_id =\n-                                fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n-                            #[cfg(debug_assertions)]\n-                            fx.add_comment(local_data_id, format!(\"{:?}\", def_id));\n+                                fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+                            if fx.clif_comments.enabled() {\n+                                fx.add_comment(local_data_id, format!(\"{:?}\", def_id));\n+                            }\n                             fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n                         }\n                         None => bug!(\"missing allocation {:?}\", ptr.alloc_id),\n@@ -237,29 +253,27 @@ fn pointer_for_allocation<'tcx>(\n     alloc: &'tcx Allocation,\n ) -> crate::pointer::Pointer {\n     let alloc_id = fx.tcx.create_memory_alloc(alloc);\n-    fx.cx.constants_cx.todo.push(TodoItem::Alloc(alloc_id));\n-    let data_id = data_id_for_alloc_id(fx.cx.module, alloc_id, alloc.mutability);\n+    fx.constants_cx.todo.push(TodoItem::Alloc(alloc_id));\n+    let data_id =\n+        data_id_for_alloc_id(&mut fx.constants_cx, &mut *fx.module, alloc_id, alloc.mutability);\n \n-    let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n-    #[cfg(debug_assertions)]\n-    fx.add_comment(local_data_id, format!(\"{:?}\", alloc_id));\n+    let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+    if fx.clif_comments.enabled() {\n+        fx.add_comment(local_data_id, format!(\"{:?}\", alloc_id));\n+    }\n     let global_ptr = fx.bcx.ins().global_value(fx.pointer_type, local_data_id);\n     crate::pointer::Pointer::new(global_ptr)\n }\n \n fn data_id_for_alloc_id(\n+    cx: &mut ConstantCx,\n     module: &mut dyn Module,\n     alloc_id: AllocId,\n     mutability: rustc_hir::Mutability,\n ) -> DataId {\n-    module\n-        .declare_data(\n-            &format!(\".L__alloc_{:x}\", alloc_id.0),\n-            Linkage::Local,\n-            mutability == rustc_hir::Mutability::Mut,\n-            false,\n-        )\n-        .unwrap()\n+    *cx.anon_allocs.entry(alloc_id).or_insert_with(|| {\n+        module.declare_anonymous_data(mutability == rustc_hir::Mutability::Mut, false).unwrap()\n+    })\n }\n \n fn data_id_for_static(\n@@ -337,7 +351,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n                     GlobalAlloc::Memory(alloc) => alloc,\n                     GlobalAlloc::Function(_) | GlobalAlloc::Static(_) => unreachable!(),\n                 };\n-                let data_id = data_id_for_alloc_id(module, alloc_id, alloc.mutability);\n+                let data_id = data_id_for_alloc_id(cx, module, alloc_id, alloc.mutability);\n                 (data_id, alloc, None)\n             }\n             TodoItem::Static(def_id) => {\n@@ -390,7 +404,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n                 }\n                 GlobalAlloc::Memory(target_alloc) => {\n                     cx.todo.push(TodoItem::Alloc(reloc));\n-                    data_id_for_alloc_id(module, reloc, target_alloc.mutability)\n+                    data_id_for_alloc_id(cx, module, reloc, target_alloc.mutability)\n                 }\n                 GlobalAlloc::Static(def_id) => {\n                     if tcx.codegen_fn_attrs(def_id).flags.contains(CodegenFnAttrFlags::THREAD_LOCAL)\n@@ -412,8 +426,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n             data_ctx.write_data_addr(offset.bytes() as u32, global_value, addend as i64);\n         }\n \n-        // FIXME don't duplicate definitions in lazy jit mode\n-        let _ = module.define_data(data_id, &data_ctx);\n+        module.define_data(data_id, &data_ctx).unwrap();\n         cx.done.insert(data_id);\n     }\n "}, {"sha": "9eb067706309e12cebc5a06146d24e433da1f6e0", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/line_info.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -39,11 +39,11 @@ fn osstr_as_utf8_bytes(path: &OsStr) -> &[u8] {\n     #[cfg(unix)]\n     {\n         use std::os::unix::ffi::OsStrExt;\n-        return path.as_bytes();\n+        path.as_bytes()\n     }\n     #[cfg(not(unix))]\n     {\n-        return path.to_str().unwrap().as_bytes();\n+        path.to_str().unwrap().as_bytes()\n     }\n }\n \n@@ -66,7 +66,7 @@ fn line_program_add_file(\n ) -> FileId {\n     match &file.name {\n         FileName::Real(path) => {\n-            let (dir_path, file_name) = split_path_dir_and_file(path.stable_name());\n+            let (dir_path, file_name) = split_path_dir_and_file(path.remapped_path_if_available());\n             let dir_name = osstr_as_utf8_bytes(dir_path.as_os_str());\n             let file_name = osstr_as_utf8_bytes(file_name);\n \n@@ -87,7 +87,7 @@ fn line_program_add_file(\n         filename => {\n             let dir_id = line_program.default_directory();\n             let dummy_file_name = LineString::new(\n-                filename.to_string().into_bytes(),\n+                filename.prefer_remapped().to_string().into_bytes(),\n                 line_program.encoding(),\n                 line_strings,\n             );"}, {"sha": "61e54a76f29ba514956cb25c6066ef6182190e79", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -64,7 +64,7 @@ impl<'tcx> DebugContext<'tcx> {\n         // FIXME: how to get version when building out of tree?\n         // Normally this would use option_env!(\"CFG_VERSION\").\n         let producer = format!(\"cg_clif (rustc {})\", \"unknown version\");\n-        let comp_dir = tcx.sess.working_dir.0.to_string_lossy().into_owned();\n+        let comp_dir = tcx.sess.working_dir.to_string_lossy(false).into_owned();\n         let (name, file_info) = match tcx.sess.local_crate_source_file.clone() {\n             Some(path) => {\n                 let name = path.to_string_lossy().into_owned();"}, {"sha": "d1251e749f31fe90687312a9ff7837d7a0149d9b", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/unwind.rs", "status": "modified", "additions": 22, "deletions": 49, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Funwind.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -5,17 +5,19 @@ use crate::prelude::*;\n use cranelift_codegen::isa::{unwind::UnwindInfo, TargetIsa};\n \n use gimli::write::{Address, CieId, EhFrame, FrameTable, Section};\n+use gimli::RunTimeEndian;\n \n use crate::backend::WriteDebugInfo;\n \n-pub(crate) struct UnwindContext<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n+pub(crate) struct UnwindContext {\n+    endian: RunTimeEndian,\n     frame_table: FrameTable,\n     cie_id: Option<CieId>,\n }\n \n-impl<'tcx> UnwindContext<'tcx> {\n-    pub(crate) fn new(tcx: TyCtxt<'tcx>, isa: &dyn TargetIsa, pic_eh_frame: bool) -> Self {\n+impl UnwindContext {\n+    pub(crate) fn new(tcx: TyCtxt<'_>, isa: &dyn TargetIsa, pic_eh_frame: bool) -> Self {\n+        let endian = super::target_endian(tcx);\n         let mut frame_table = FrameTable::default();\n \n         let cie_id = if let Some(mut cie) = isa.create_systemv_cie() {\n@@ -28,7 +30,7 @@ impl<'tcx> UnwindContext<'tcx> {\n             None\n         };\n \n-        UnwindContext { tcx, frame_table, cie_id }\n+        UnwindContext { endian, frame_table, cie_id }\n     }\n \n     pub(crate) fn add_function(&mut self, func_id: FuncId, context: &Context, isa: &dyn TargetIsa) {\n@@ -54,8 +56,7 @@ impl<'tcx> UnwindContext<'tcx> {\n     }\n \n     pub(crate) fn emit<P: WriteDebugInfo>(self, product: &mut P) {\n-        let mut eh_frame =\n-            EhFrame::from(super::emit::WriterRelocate::new(super::target_endian(self.tcx)));\n+        let mut eh_frame = EhFrame::from(super::emit::WriterRelocate::new(self.endian));\n         self.frame_table.write_eh_frame(&mut eh_frame).unwrap();\n \n         if !eh_frame.0.writer.slice().is_empty() {\n@@ -70,34 +71,36 @@ impl<'tcx> UnwindContext<'tcx> {\n         }\n     }\n \n-    #[cfg(feature = \"jit\")]\n-    pub(crate) unsafe fn register_jit(\n-        self,\n-        jit_module: &cranelift_jit::JITModule,\n-    ) -> Option<UnwindRegistry> {\n-        let mut eh_frame =\n-            EhFrame::from(super::emit::WriterRelocate::new(super::target_endian(self.tcx)));\n+    #[cfg(all(feature = \"jit\", windows))]\n+    pub(crate) unsafe fn register_jit(self, _jit_module: &cranelift_jit::JITModule) {}\n+\n+    #[cfg(all(feature = \"jit\", not(windows)))]\n+    pub(crate) unsafe fn register_jit(self, jit_module: &cranelift_jit::JITModule) {\n+        let mut eh_frame = EhFrame::from(super::emit::WriterRelocate::new(self.endian));\n         self.frame_table.write_eh_frame(&mut eh_frame).unwrap();\n \n         if eh_frame.0.writer.slice().is_empty() {\n-            return None;\n+            return;\n         }\n \n         let mut eh_frame = eh_frame.0.relocate_for_jit(jit_module);\n \n         // GCC expects a terminating \"empty\" length, so write a 0 length at the end of the table.\n         eh_frame.extend(&[0, 0, 0, 0]);\n \n-        let mut registrations = Vec::new();\n+        // FIXME support unregistering unwind tables once cranelift-jit supports deallocating\n+        // individual functions\n+        #[allow(unused_variables)]\n+        let (eh_frame, eh_frame_len, _) = Vec::into_raw_parts(eh_frame);\n \n         // =======================================================================\n         // Everything after this line up to the end of the file is loosly based on\n         // https://github.com/bytecodealliance/wasmtime/blob/4471a82b0c540ff48960eca6757ccce5b1b5c3e4/crates/jit/src/unwind/systemv.rs\n         #[cfg(target_os = \"macos\")]\n         {\n             // On macOS, `__register_frame` takes a pointer to a single FDE\n-            let start = eh_frame.as_ptr();\n-            let end = start.add(eh_frame.len());\n+            let start = eh_frame;\n+            let end = start.add(eh_frame_len);\n             let mut current = start;\n \n             // Walk all of the entries in the frame table and register them\n@@ -107,7 +110,6 @@ impl<'tcx> UnwindContext<'tcx> {\n                 // Skip over the CIE\n                 if current != start {\n                     __register_frame(current);\n-                    registrations.push(current as usize);\n                 }\n \n                 // Move to the next table entry (+4 because the length itself is not inclusive)\n@@ -117,41 +119,12 @@ impl<'tcx> UnwindContext<'tcx> {\n         #[cfg(not(target_os = \"macos\"))]\n         {\n             // On other platforms, `__register_frame` will walk the FDEs until an entry of length 0\n-            let ptr = eh_frame.as_ptr();\n-            __register_frame(ptr);\n-            registrations.push(ptr as usize);\n+            __register_frame(eh_frame);\n         }\n-\n-        Some(UnwindRegistry { _frame_table: eh_frame, registrations })\n     }\n }\n \n-/// Represents a registry of function unwind information for System V ABI.\n-pub(crate) struct UnwindRegistry {\n-    _frame_table: Vec<u8>,\n-    registrations: Vec<usize>,\n-}\n-\n extern \"C\" {\n     // libunwind import\n     fn __register_frame(fde: *const u8);\n-    fn __deregister_frame(fde: *const u8);\n-}\n-\n-impl Drop for UnwindRegistry {\n-    fn drop(&mut self) {\n-        unsafe {\n-            // libgcc stores the frame entries as a linked list in decreasing sort order\n-            // based on the PC value of the registered entry.\n-            //\n-            // As we store the registrations in increasing order, it would be O(N^2) to\n-            // deregister in that order.\n-            //\n-            // To ensure that we just pop off the first element in the list upon every\n-            // deregistration, walk our list of registrations backwards.\n-            for fde in self.registrations.iter().rev() {\n-                __deregister_frame(*fde as *const _);\n-            }\n-        }\n-    }\n }"}, {"sha": "24d933728db693b804325b232d664f33b65f77d0", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 73, "deletions": 45, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -3,6 +3,7 @@\n \n use std::path::PathBuf;\n \n+use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_codegen_ssa::back::linker::LinkerInfo;\n use rustc_codegen_ssa::{CodegenResults, CompiledModule, CrateInfo, ModuleKind};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n@@ -16,12 +17,6 @@ use cranelift_object::ObjectModule;\n \n use crate::{prelude::*, BackendConfig};\n \n-fn new_module(tcx: TyCtxt<'_>, name: String) -> ObjectModule {\n-    let module = crate::backend::make_module(tcx.sess, name);\n-    assert_eq!(pointer_ty(tcx), module.target_config().pointer_type());\n-    module\n-}\n-\n struct ModuleCodegenResult(CompiledModule, Option<(WorkProductId, WorkProduct)>);\n \n impl<HCX> HashStable<HCX> for ModuleCodegenResult {\n@@ -32,11 +27,12 @@ impl<HCX> HashStable<HCX> for ModuleCodegenResult {\n \n fn emit_module(\n     tcx: TyCtxt<'_>,\n+    backend_config: &BackendConfig,\n     name: String,\n     kind: ModuleKind,\n     module: ObjectModule,\n     debug: Option<DebugContext<'_>>,\n-    unwind_context: UnwindContext<'_>,\n+    unwind_context: UnwindContext,\n ) -> ModuleCodegenResult {\n     let mut product = module.finish();\n \n@@ -46,13 +42,13 @@ fn emit_module(\n \n     unwind_context.emit(&mut product);\n \n-    let tmp_file = tcx.output_filenames(LOCAL_CRATE).temp_path(OutputType::Object, Some(&name));\n+    let tmp_file = tcx.output_filenames(()).temp_path(OutputType::Object, Some(&name));\n     let obj = product.object.write().unwrap();\n     if let Err(err) = std::fs::write(&tmp_file, obj) {\n         tcx.sess.fatal(&format!(\"error writing object file: {}\", err));\n     }\n \n-    let work_product = if std::env::var(\"CG_CLIF_INCR_CACHE_DISABLED\").is_ok() {\n+    let work_product = if backend_config.disable_incr_cache {\n         None\n     } else {\n         rustc_incremental::copy_cgu_workproduct_to_incr_comp_cache_dir(\n@@ -78,7 +74,7 @@ fn reuse_workproduct_for_cgu(\n     let work_product = cgu.work_product(tcx);\n     if let Some(saved_file) = &work_product.saved_file {\n         let obj_out = tcx\n-            .output_filenames(LOCAL_CRATE)\n+            .output_filenames(())\n             .temp_path(OutputType::Object, Some(&cgu.name().as_str()));\n         object = Some(obj_out.clone());\n         let source_file = rustc_incremental::in_incr_comp_dir(&incr_comp_session_dir, &saved_file);\n@@ -110,63 +106,91 @@ fn module_codegen(\n     let cgu = tcx.codegen_unit(cgu_name);\n     let mono_items = cgu.items_in_deterministic_order(tcx);\n \n-    let mut module = new_module(tcx, cgu_name.as_str().to_string());\n+    let isa = crate::build_isa(tcx.sess, &backend_config);\n+    let mut module = crate::backend::make_module(tcx.sess, isa, cgu_name.as_str().to_string());\n \n     let mut cx = crate::CodegenCx::new(\n         tcx,\n-        backend_config,\n-        &mut module,\n+        backend_config.clone(),\n+        module.isa(),\n         tcx.sess.opts.debuginfo != DebugInfo::None,\n     );\n-    super::predefine_mono_items(&mut cx, &mono_items);\n-    for (mono_item, (linkage, visibility)) in mono_items {\n-        let linkage = crate::linkage::get_clif_linkage(mono_item, linkage, visibility);\n+    super::predefine_mono_items(tcx, &mut module, &mono_items);\n+    for (mono_item, _) in mono_items {\n         match mono_item {\n             MonoItem::Fn(inst) => {\n-                cx.tcx.sess.time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, inst, linkage));\n-            }\n-            MonoItem::Static(def_id) => {\n-                crate::constant::codegen_static(&mut cx.constants_cx, def_id)\n+                cx.tcx\n+                    .sess\n+                    .time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, &mut module, inst));\n             }\n+            MonoItem::Static(def_id) => crate::constant::codegen_static(tcx, &mut module, def_id),\n             MonoItem::GlobalAsm(item_id) => {\n                 let item = cx.tcx.hir().item(item_id);\n-                if let rustc_hir::ItemKind::GlobalAsm(rustc_hir::GlobalAsm { asm }) = item.kind {\n-                    cx.global_asm.push_str(&*asm.as_str());\n-                    cx.global_asm.push_str(\"\\n\\n\");\n+                if let rustc_hir::ItemKind::GlobalAsm(asm) = item.kind {\n+                    if !asm.options.contains(InlineAsmOptions::ATT_SYNTAX) {\n+                        cx.global_asm.push_str(\"\\n.intel_syntax noprefix\\n\");\n+                    } else {\n+                        cx.global_asm.push_str(\"\\n.att_syntax\\n\");\n+                    }\n+                    for piece in asm.template {\n+                        match *piece {\n+                            InlineAsmTemplatePiece::String(ref s) => cx.global_asm.push_str(s),\n+                            InlineAsmTemplatePiece::Placeholder { .. } => todo!(),\n+                        }\n+                    }\n+                    cx.global_asm.push_str(\"\\n.att_syntax\\n\\n\");\n                 } else {\n                     bug!(\"Expected GlobalAsm found {:?}\", item);\n                 }\n             }\n         }\n     }\n-    let (global_asm, debug, mut unwind_context) =\n-        tcx.sess.time(\"finalize CodegenCx\", || cx.finalize());\n-    crate::main_shim::maybe_create_entry_wrapper(tcx, &mut module, &mut unwind_context);\n+    crate::main_shim::maybe_create_entry_wrapper(tcx, &mut module, &mut cx.unwind_context, false);\n \n-    let codegen_result = emit_module(\n-        tcx,\n-        cgu.name().as_str().to_string(),\n-        ModuleKind::Regular,\n-        module,\n-        debug,\n-        unwind_context,\n-    );\n+    let debug_context = cx.debug_context;\n+    let unwind_context = cx.unwind_context;\n+    let codegen_result = tcx.sess.time(\"write object file\", || {\n+        emit_module(\n+            tcx,\n+            &backend_config,\n+            cgu.name().as_str().to_string(),\n+            ModuleKind::Regular,\n+            module,\n+            debug_context,\n+            unwind_context,\n+        )\n+    });\n \n-    codegen_global_asm(tcx, &cgu.name().as_str(), &global_asm);\n+    codegen_global_asm(tcx, &cgu.name().as_str(), &cx.global_asm);\n \n     codegen_result\n }\n \n-pub(super) fn run_aot(\n+pub(crate) fn run_aot(\n     tcx: TyCtxt<'_>,\n     backend_config: BackendConfig,\n     metadata: EncodedMetadata,\n     need_metadata_module: bool,\n ) -> Box<(CodegenResults, FxHashMap<WorkProductId, WorkProduct>)> {\n+    use rustc_span::symbol::sym;\n+\n+    let crate_attrs = tcx.hir().attrs(rustc_hir::CRATE_HIR_ID);\n+    let subsystem = tcx.sess.first_attr_value_str_by_name(crate_attrs, sym::windows_subsystem);\n+    let windows_subsystem = subsystem.map(|subsystem| {\n+        if subsystem != sym::windows && subsystem != sym::console {\n+            tcx.sess.fatal(&format!(\n+                \"invalid windows subsystem `{}`, only \\\n+                                    `windows` and `console` are allowed\",\n+                subsystem\n+            ));\n+        }\n+        subsystem.to_string()\n+    });\n+\n     let mut work_products = FxHashMap::default();\n \n     let cgus = if tcx.sess.opts.output_types.should_codegen() {\n-        tcx.collect_and_partition_mono_items(LOCAL_CRATE).1\n+        tcx.collect_and_partition_mono_items(()).1\n     } else {\n         // If only `--emit metadata` is used, we shouldn't perform any codegen.\n         // Also `tcx.collect_and_partition_mono_items` may panic in that case.\n@@ -179,14 +203,14 @@ pub(super) fn run_aot(\n         }\n     }\n \n-    let modules = super::time(tcx, \"codegen mono items\", || {\n+    let modules = super::time(tcx, backend_config.display_cg_time, \"codegen mono items\", || {\n         cgus.iter()\n             .map(|cgu| {\n                 let cgu_reuse = determine_cgu_reuse(tcx, cgu);\n                 tcx.sess.cgu_reuse_tracker.set_actual_reuse(&cgu.name().as_str(), cgu_reuse);\n \n                 match cgu_reuse {\n-                    _ if std::env::var(\"CG_CLIF_INCR_CACHE_DISABLED\").is_ok() => {}\n+                    _ if backend_config.disable_incr_cache => {}\n                     CguReuse::No => {}\n                     CguReuse::PreLto => {\n                         return reuse_workproduct_for_cgu(tcx, &*cgu, &mut work_products);\n@@ -198,7 +222,7 @@ pub(super) fn run_aot(\n                 let (ModuleCodegenResult(module, work_product), _) = tcx.dep_graph.with_task(\n                     dep_node,\n                     tcx,\n-                    (backend_config, cgu.name()),\n+                    (backend_config.clone(), cgu.name()),\n                     module_codegen,\n                     rustc_middle::dep_graph::hash_result,\n                 );\n@@ -214,14 +238,18 @@ pub(super) fn run_aot(\n \n     tcx.sess.abort_if_errors();\n \n-    let mut allocator_module = new_module(tcx, \"allocator_shim\".to_string());\n+    let isa = crate::build_isa(tcx.sess, &backend_config);\n+    let mut allocator_module =\n+        crate::backend::make_module(tcx.sess, isa, \"allocator_shim\".to_string());\n+    assert_eq!(pointer_ty(tcx), allocator_module.target_config().pointer_type());\n     let mut allocator_unwind_context = UnwindContext::new(tcx, allocator_module.isa(), true);\n     let created_alloc_shim =\n         crate::allocator::codegen(tcx, &mut allocator_module, &mut allocator_unwind_context);\n \n     let allocator_module = if created_alloc_shim {\n         let ModuleCodegenResult(module, work_product) = emit_module(\n             tcx,\n+            &backend_config,\n             \"allocator_shim\".to_string(),\n             ModuleKind::Allocator,\n             allocator_module,\n@@ -248,7 +276,7 @@ pub(super) fn run_aot(\n                 .to_string();\n \n             let tmp_file = tcx\n-                .output_filenames(LOCAL_CRATE)\n+                .output_filenames(())\n                 .temp_path(OutputType::Metadata, Some(&metadata_cgu_name));\n \n             let obj = crate::backend::with_object(tcx.sess, &metadata_cgu_name, |object| {\n@@ -280,8 +308,8 @@ pub(super) fn run_aot(\n             allocator_module,\n             metadata_module,\n             metadata,\n-            windows_subsystem: None, // Windows is not yet supported\n-            linker_info: LinkerInfo::new(tcx),\n+            windows_subsystem,\n+            linker_info: LinkerInfo::new(tcx, crate::target_triple(tcx.sess).to_string()),\n             crate_info: CrateInfo::new(tcx),\n         },\n         work_products,\n@@ -325,7 +353,7 @@ fn codegen_global_asm(tcx: TyCtxt<'_>, cgu_name: &str, global_asm: &str) {\n         .join(\"\\n\");\n \n     let output_object_file =\n-        tcx.output_filenames(LOCAL_CRATE).temp_path(OutputType::Object, Some(cgu_name));\n+        tcx.output_filenames(()).temp_path(OutputType::Object, Some(cgu_name));\n \n     // Assemble `global_asm`\n     let global_asm_object_file = add_file_stem_postfix(output_object_file.clone(), \".asm\");"}, {"sha": "632e86da736ab235530d52e7d25512fefe83b590", "filename": "compiler/rustc_codegen_cranelift/src/driver/jit.rs", "status": "modified", "additions": 103, "deletions": 84, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -1,10 +1,11 @@\n-//! The JIT driver uses [`cranelift_simplejit`] to JIT execute programs without writing any object\n+//! The JIT driver uses [`cranelift_jit`] to JIT execute programs without writing any object\n //! files.\n \n use std::cell::RefCell;\n use std::ffi::CString;\n use std::os::raw::{c_char, c_int};\n \n+use cranelift_codegen::binemit::{NullStackMapSink, NullTrapSink};\n use rustc_codegen_ssa::CrateInfo;\n use rustc_middle::mir::mono::MonoItem;\n \n@@ -13,36 +14,58 @@ use cranelift_jit::{JITBuilder, JITModule};\n use crate::{prelude::*, BackendConfig};\n use crate::{CodegenCx, CodegenMode};\n \n-thread_local! {\n-    pub static BACKEND_CONFIG: RefCell<Option<BackendConfig>> = RefCell::new(None);\n-    pub static CURRENT_MODULE: RefCell<Option<JITModule>> = RefCell::new(None);\n+struct JitState {\n+    backend_config: BackendConfig,\n+    jit_module: JITModule,\n }\n \n-pub(super) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n-    if !tcx.sess.opts.output_types.should_codegen() {\n-        tcx.sess.fatal(\"JIT mode doesn't work with `cargo check`.\");\n-    }\n+thread_local! {\n+    static LAZY_JIT_STATE: RefCell<Option<JitState>> = RefCell::new(None);\n+}\n \n+fn create_jit_module<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    backend_config: &BackendConfig,\n+    hotswap: bool,\n+) -> (JITModule, CodegenCx<'tcx>) {\n     let imported_symbols = load_imported_symbols_for_jit(tcx);\n \n-    let mut jit_builder =\n-        JITBuilder::with_isa(crate::build_isa(tcx.sess), cranelift_module::default_libcall_names());\n-    jit_builder.hotswap(matches!(backend_config.codegen_mode, CodegenMode::JitLazy));\n+    let isa = crate::build_isa(tcx.sess, backend_config);\n+    let mut jit_builder = JITBuilder::with_isa(isa, cranelift_module::default_libcall_names());\n+    jit_builder.hotswap(hotswap);\n+    crate::compiler_builtins::register_functions_for_jit(&mut jit_builder);\n     jit_builder.symbols(imported_symbols);\n     let mut jit_module = JITModule::new(jit_builder);\n-    assert_eq!(pointer_ty(tcx), jit_module.target_config().pointer_type());\n \n-    let sig = Signature {\n-        params: vec![\n-            AbiParam::new(jit_module.target_config().pointer_type()),\n-            AbiParam::new(jit_module.target_config().pointer_type()),\n-        ],\n-        returns: vec![AbiParam::new(jit_module.target_config().pointer_type() /*isize*/)],\n-        call_conv: CallConv::triple_default(&crate::target_triple(tcx.sess)),\n-    };\n-    let main_func_id = jit_module.declare_function(\"main\", Linkage::Import, &sig).unwrap();\n+    let mut cx = crate::CodegenCx::new(tcx, backend_config.clone(), jit_module.isa(), false);\n+\n+    crate::allocator::codegen(tcx, &mut jit_module, &mut cx.unwind_context);\n+    crate::main_shim::maybe_create_entry_wrapper(\n+        tcx,\n+        &mut jit_module,\n+        &mut cx.unwind_context,\n+        true,\n+    );\n+\n+    (jit_module, cx)\n+}\n+\n+pub(crate) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n+    if !tcx.sess.opts.output_types.should_codegen() {\n+        tcx.sess.fatal(\"JIT mode doesn't work with `cargo check`\");\n+    }\n+\n+    if !tcx.sess.crate_types().contains(&rustc_session::config::CrateType::Executable) {\n+        tcx.sess.fatal(\"can't jit non-executable crate\");\n+    }\n \n-    let (_, cgus) = tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n+    let (mut jit_module, mut cx) = create_jit_module(\n+        tcx,\n+        &backend_config,\n+        matches!(backend_config.codegen_mode, CodegenMode::JitLazy),\n+    );\n+\n+    let (_, cgus) = tcx.collect_and_partition_mono_items(());\n     let mono_items = cgus\n         .iter()\n         .map(|cgu| cgu.items_in_deterministic_order(tcx).into_iter())\n@@ -51,62 +74,45 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n         .into_iter()\n         .collect::<Vec<(_, (_, _))>>();\n \n-    let mut cx = crate::CodegenCx::new(tcx, backend_config, &mut jit_module, false);\n-\n-    super::time(tcx, \"codegen mono items\", || {\n-        super::predefine_mono_items(&mut cx, &mono_items);\n-        for (mono_item, (linkage, visibility)) in mono_items {\n-            let linkage = crate::linkage::get_clif_linkage(mono_item, linkage, visibility);\n+    super::time(tcx, backend_config.display_cg_time, \"codegen mono items\", || {\n+        super::predefine_mono_items(tcx, &mut jit_module, &mono_items);\n+        for (mono_item, _) in mono_items {\n             match mono_item {\n                 MonoItem::Fn(inst) => match backend_config.codegen_mode {\n                     CodegenMode::Aot => unreachable!(),\n                     CodegenMode::Jit => {\n-                        cx.tcx\n-                            .sess\n-                            .time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, inst, linkage));\n+                        cx.tcx.sess.time(\"codegen fn\", || {\n+                            crate::base::codegen_fn(&mut cx, &mut jit_module, inst)\n+                        });\n                     }\n-                    CodegenMode::JitLazy => codegen_shim(&mut cx, inst),\n+                    CodegenMode::JitLazy => codegen_shim(&mut cx, &mut jit_module, inst),\n                 },\n                 MonoItem::Static(def_id) => {\n-                    crate::constant::codegen_static(&mut cx.constants_cx, def_id);\n+                    crate::constant::codegen_static(tcx, &mut jit_module, def_id);\n                 }\n                 MonoItem::GlobalAsm(item_id) => {\n-                    let item = cx.tcx.hir().item(item_id);\n+                    let item = tcx.hir().item(item_id);\n                     tcx.sess.span_fatal(item.span, \"Global asm is not supported in JIT mode\");\n                 }\n             }\n         }\n     });\n \n-    let (global_asm, _debug, mut unwind_context) =\n-        tcx.sess.time(\"finalize CodegenCx\", || cx.finalize());\n-    jit_module.finalize_definitions();\n-\n-    if !global_asm.is_empty() {\n+    if !cx.global_asm.is_empty() {\n         tcx.sess.fatal(\"Inline asm is not supported in JIT mode\");\n     }\n \n-    crate::main_shim::maybe_create_entry_wrapper(tcx, &mut jit_module, &mut unwind_context);\n-    crate::allocator::codegen(tcx, &mut jit_module, &mut unwind_context);\n-\n     tcx.sess.abort_if_errors();\n \n     jit_module.finalize_definitions();\n-\n-    let _unwind_register_guard = unsafe { unwind_context.register_jit(&jit_module) };\n-\n-    let finalized_main: *const u8 = jit_module.get_finalized_function(main_func_id);\n+    unsafe { cx.unwind_context.register_jit(&jit_module) };\n \n     println!(\n         \"Rustc codegen cranelift will JIT run the executable, because -Cllvm-args=mode=jit was passed\"\n     );\n \n-    let f: extern \"C\" fn(c_int, *const *const c_char) -> c_int =\n-        unsafe { ::std::mem::transmute(finalized_main) };\n-\n-    let args = ::std::env::var(\"CG_CLIF_JIT_ARGS\").unwrap_or_else(|_| String::new());\n     let args = std::iter::once(&*tcx.crate_name(LOCAL_CRATE).as_str().to_string())\n-        .chain(args.split(' '))\n+        .chain(backend_config.jit_args.iter().map(|arg| &**arg))\n         .map(|arg| CString::new(arg).unwrap())\n         .collect::<Vec<_>>();\n     let mut argv = args.iter().map(|arg| arg.as_ptr()).collect::<Vec<_>>();\n@@ -115,14 +121,26 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n     // useful as some dynamic linkers use it as a marker to jump over.\n     argv.push(std::ptr::null());\n \n-    BACKEND_CONFIG.with(|tls_backend_config| {\n-        assert!(tls_backend_config.borrow_mut().replace(backend_config).is_none())\n+    let start_sig = Signature {\n+        params: vec![\n+            AbiParam::new(jit_module.target_config().pointer_type()),\n+            AbiParam::new(jit_module.target_config().pointer_type()),\n+        ],\n+        returns: vec![AbiParam::new(jit_module.target_config().pointer_type() /*isize*/)],\n+        call_conv: CallConv::triple_default(&crate::target_triple(tcx.sess)),\n+    };\n+    let start_func_id = jit_module.declare_function(\"main\", Linkage::Import, &start_sig).unwrap();\n+    let finalized_start: *const u8 = jit_module.get_finalized_function(start_func_id);\n+\n+    LAZY_JIT_STATE.with(|lazy_jit_state| {\n+        let mut lazy_jit_state = lazy_jit_state.borrow_mut();\n+        assert!(lazy_jit_state.is_none());\n+        *lazy_jit_state = Some(JitState { backend_config, jit_module });\n     });\n-    CURRENT_MODULE\n-        .with(|current_module| assert!(current_module.borrow_mut().replace(jit_module).is_none()));\n \n+    let f: extern \"C\" fn(c_int, *const *const c_char) -> c_int =\n+        unsafe { ::std::mem::transmute(finalized_start) };\n     let ret = f(args.len() as c_int, argv.as_ptr());\n-\n     std::process::exit(ret);\n }\n \n@@ -132,25 +150,23 @@ extern \"C\" fn __clif_jit_fn(instance_ptr: *const Instance<'static>) -> *const u8\n         // lift is used to ensure the correct lifetime for instance.\n         let instance = tcx.lift(unsafe { *instance_ptr }).unwrap();\n \n-        CURRENT_MODULE.with(|jit_module| {\n-            let mut jit_module = jit_module.borrow_mut();\n-            let jit_module = jit_module.as_mut().unwrap();\n-            let backend_config =\n-                BACKEND_CONFIG.with(|backend_config| backend_config.borrow().clone().unwrap());\n+        LAZY_JIT_STATE.with(|lazy_jit_state| {\n+            let mut lazy_jit_state = lazy_jit_state.borrow_mut();\n+            let lazy_jit_state = lazy_jit_state.as_mut().unwrap();\n+            let jit_module = &mut lazy_jit_state.jit_module;\n+            let backend_config = lazy_jit_state.backend_config.clone();\n \n-            let name = tcx.symbol_name(instance).name.to_string();\n+            let name = tcx.symbol_name(instance).name;\n             let sig = crate::abi::get_function_sig(tcx, jit_module.isa().triple(), instance);\n-            let func_id = jit_module.declare_function(&name, Linkage::Export, &sig).unwrap();\n+            let func_id = jit_module.declare_function(name, Linkage::Export, &sig).unwrap();\n             jit_module.prepare_for_function_redefine(func_id).unwrap();\n \n-            let mut cx = crate::CodegenCx::new(tcx, backend_config, jit_module, false);\n-            tcx.sess\n-                .time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, instance, Linkage::Export));\n+            let mut cx = crate::CodegenCx::new(tcx, backend_config, jit_module.isa(), false);\n+            tcx.sess.time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, jit_module, instance));\n \n-            let (global_asm, _debug_context, unwind_context) = cx.finalize();\n-            assert!(global_asm.is_empty());\n+            assert!(cx.global_asm.is_empty());\n             jit_module.finalize_definitions();\n-            std::mem::forget(unsafe { unwind_context.register_jit(&jit_module) });\n+            unsafe { cx.unwind_context.register_jit(&jit_module) };\n             jit_module.get_finalized_function(func_id)\n         })\n     })\n@@ -162,7 +178,7 @@ fn load_imported_symbols_for_jit(tcx: TyCtxt<'_>) -> Vec<(String, *const u8)> {\n     let mut dylib_paths = Vec::new();\n \n     let crate_info = CrateInfo::new(tcx);\n-    let formats = tcx.dependency_formats(LOCAL_CRATE);\n+    let formats = tcx.dependency_formats(());\n     let data = &formats\n         .iter()\n         .find(|(crate_type, _data)| *crate_type == rustc_session::config::CrateType::Executable)\n@@ -220,35 +236,37 @@ fn load_imported_symbols_for_jit(tcx: TyCtxt<'_>) -> Vec<(String, *const u8)> {\n     imported_symbols\n }\n \n-pub(super) fn codegen_shim<'tcx>(cx: &mut CodegenCx<'_, 'tcx>, inst: Instance<'tcx>) {\n+fn codegen_shim<'tcx>(cx: &mut CodegenCx<'tcx>, module: &mut JITModule, inst: Instance<'tcx>) {\n     let tcx = cx.tcx;\n \n-    let pointer_type = cx.module.target_config().pointer_type();\n+    let pointer_type = module.target_config().pointer_type();\n \n-    let name = tcx.symbol_name(inst).name.to_string();\n-    let sig = crate::abi::get_function_sig(tcx, cx.module.isa().triple(), inst);\n-    let func_id = cx.module.declare_function(&name, Linkage::Export, &sig).unwrap();\n+    let name = tcx.symbol_name(inst).name;\n+    let sig = crate::abi::get_function_sig(tcx, module.isa().triple(), inst);\n+    let func_id = module.declare_function(name, Linkage::Export, &sig).unwrap();\n \n     let instance_ptr = Box::into_raw(Box::new(inst));\n \n-    let jit_fn = cx\n-        .module\n+    let jit_fn = module\n         .declare_function(\n             \"__clif_jit_fn\",\n             Linkage::Import,\n             &Signature {\n-                call_conv: cx.module.target_config().default_call_conv,\n+                call_conv: module.target_config().default_call_conv,\n                 params: vec![AbiParam::new(pointer_type)],\n                 returns: vec![AbiParam::new(pointer_type)],\n             },\n         )\n         .unwrap();\n \n-    let mut trampoline = Function::with_name_signature(ExternalName::default(), sig.clone());\n+    cx.cached_context.clear();\n+    let trampoline = &mut cx.cached_context.func;\n+    trampoline.signature = sig.clone();\n+\n     let mut builder_ctx = FunctionBuilderContext::new();\n-    let mut trampoline_builder = FunctionBuilder::new(&mut trampoline, &mut builder_ctx);\n+    let mut trampoline_builder = FunctionBuilder::new(trampoline, &mut builder_ctx);\n \n-    let jit_fn = cx.module.declare_func_in_func(jit_fn, trampoline_builder.func);\n+    let jit_fn = module.declare_func_in_func(jit_fn, trampoline_builder.func);\n     let sig_ref = trampoline_builder.func.import_signature(sig);\n \n     let entry_block = trampoline_builder.create_block();\n@@ -263,11 +281,12 @@ pub(super) fn codegen_shim<'tcx>(cx: &mut CodegenCx<'_, 'tcx>, inst: Instance<'t\n     let ret_vals = trampoline_builder.func.dfg.inst_results(call_inst).to_vec();\n     trampoline_builder.ins().return_(&ret_vals);\n \n-    cx.module\n+    module\n         .define_function(\n             func_id,\n-            &mut Context::for_function(trampoline),\n-            &mut cranelift_codegen::binemit::NullTrapSink {},\n+            &mut cx.cached_context,\n+            &mut NullTrapSink {},\n+            &mut NullStackMapSink {},\n         )\n         .unwrap();\n }"}, {"sha": "8f5714ecb417704e446edda114f65b4966facb66", "filename": "compiler/rustc_codegen_cranelift/src/driver/mod.rs", "status": "modified", "additions": 22, "deletions": 42, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -1,66 +1,46 @@\n-//! Drivers are responsible for calling [`codegen_mono_item`] and performing any further actions\n-//! like JIT executing or writing object files.\n+//! Drivers are responsible for calling [`codegen_fn`] or [`codegen_static`] for each mono item and\n+//! performing any further actions like JIT executing or writing object files.\n+//!\n+//! [`codegen_fn`]: crate::base::codegen_fn\n+//! [`codegen_static`]: crate::constant::codegen_static\n \n-use std::any::Any;\n-\n-use rustc_middle::middle::cstore::EncodedMetadata;\n use rustc_middle::mir::mono::{Linkage as RLinkage, MonoItem, Visibility};\n \n use crate::prelude::*;\n-use crate::CodegenMode;\n \n-mod aot;\n+pub(crate) mod aot;\n #[cfg(feature = \"jit\")]\n-mod jit;\n-\n-pub(crate) fn codegen_crate(\n-    tcx: TyCtxt<'_>,\n-    metadata: EncodedMetadata,\n-    need_metadata_module: bool,\n-    backend_config: crate::BackendConfig,\n-) -> Box<dyn Any> {\n-    tcx.sess.abort_if_errors();\n-\n-    match backend_config.codegen_mode {\n-        CodegenMode::Aot => aot::run_aot(tcx, backend_config, metadata, need_metadata_module),\n-        CodegenMode::Jit | CodegenMode::JitLazy => {\n-            let is_executable =\n-                tcx.sess.crate_types().contains(&rustc_session::config::CrateType::Executable);\n-            if !is_executable {\n-                tcx.sess.fatal(\"can't jit non-executable crate\");\n-            }\n-\n-            #[cfg(feature = \"jit\")]\n-            let _: ! = jit::run_jit(tcx, backend_config);\n-\n-            #[cfg(not(feature = \"jit\"))]\n-            tcx.sess.fatal(\"jit support was disabled when compiling rustc_codegen_cranelift\");\n-        }\n-    }\n-}\n+pub(crate) mod jit;\n \n fn predefine_mono_items<'tcx>(\n-    cx: &mut crate::CodegenCx<'_, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+    module: &mut dyn Module,\n     mono_items: &[(MonoItem<'tcx>, (RLinkage, Visibility))],\n ) {\n-    cx.tcx.sess.time(\"predefine functions\", || {\n+    tcx.sess.time(\"predefine functions\", || {\n+        let is_compiler_builtins = tcx.is_compiler_builtins(LOCAL_CRATE);\n         for &(mono_item, (linkage, visibility)) in mono_items {\n             match mono_item {\n                 MonoItem::Fn(instance) => {\n-                    let name = cx.tcx.symbol_name(instance).name.to_string();\n+                    let name = tcx.symbol_name(instance).name;\n                     let _inst_guard = crate::PrintOnPanic(|| format!(\"{:?} {}\", instance, name));\n-                    let sig = get_function_sig(cx.tcx, cx.module.isa().triple(), instance);\n-                    let linkage = crate::linkage::get_clif_linkage(mono_item, linkage, visibility);\n-                    cx.module.declare_function(&name, linkage, &sig).unwrap();\n+                    let sig = get_function_sig(tcx, module.isa().triple(), instance);\n+                    let linkage = crate::linkage::get_clif_linkage(\n+                        mono_item,\n+                        linkage,\n+                        visibility,\n+                        is_compiler_builtins,\n+                    );\n+                    module.declare_function(name, linkage, &sig).unwrap();\n                 }\n                 MonoItem::Static(_) | MonoItem::GlobalAsm(_) => {}\n             }\n         }\n     });\n }\n \n-fn time<R>(tcx: TyCtxt<'_>, name: &'static str, f: impl FnOnce() -> R) -> R {\n-    if std::env::var(\"CG_CLIF_DISPLAY_CG_TIME\").as_ref().map(|val| &**val) == Ok(\"1\") {\n+fn time<R>(tcx: TyCtxt<'_>, display: bool, name: &'static str, f: impl FnOnce() -> R) -> R {\n+    if display {\n         println!(\"[{:<30}: {}] start\", tcx.crate_name(LOCAL_CRATE), name);\n         let before = std::time::Instant::now();\n         let res = tcx.sess.time(name, f);"}, {"sha": "4ab4c2957ca4e3f29fa06902f9332d26712e9b86", "filename": "compiler/rustc_codegen_cranelift/src/inline_asm.rs", "status": "modified", "additions": 70, "deletions": 8, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -20,6 +20,68 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n     if template.is_empty() {\n         // Black box\n         return;\n+    } else if template[0] == InlineAsmTemplatePiece::String(\"int $$0x29\".to_string()) {\n+        let true_ = fx.bcx.ins().iconst(types::I32, 1);\n+        fx.bcx.ins().trapnz(true_, TrapCode::User(1));\n+        return;\n+    } else if template[0] == InlineAsmTemplatePiece::String(\"mov rsi, rbx\".to_string())\n+        && template[1] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n+        && template[2] == InlineAsmTemplatePiece::String(\"cpuid\".to_string())\n+        && template[3] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n+        && template[4] == InlineAsmTemplatePiece::String(\"xchg rsi, rbx\".to_string())\n+    {\n+        assert_eq!(operands.len(), 4);\n+        let (leaf, eax_place) = match operands[0] {\n+            InlineAsmOperand::InOut { reg, late: true, ref in_value, out_place } => {\n+                let reg = expect_reg(reg);\n+                assert_eq!(reg, InlineAsmReg::X86(X86InlineAsmReg::ax));\n+                (\n+                    crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n+                    crate::base::codegen_place(fx, out_place.unwrap()),\n+                )\n+            }\n+            _ => unreachable!(),\n+        };\n+        let ebx_place = match operands[1] {\n+            InlineAsmOperand::Out { reg, late: true, place } => {\n+                let reg = expect_reg(reg);\n+                assert_eq!(reg, InlineAsmReg::X86(X86InlineAsmReg::si));\n+                crate::base::codegen_place(fx, place.unwrap())\n+            }\n+            _ => unreachable!(),\n+        };\n+        let (sub_leaf, ecx_place) = match operands[2] {\n+            InlineAsmOperand::InOut { reg, late: true, ref in_value, out_place } => {\n+                let reg = expect_reg(reg);\n+                assert_eq!(reg, InlineAsmReg::X86(X86InlineAsmReg::cx));\n+                (\n+                    crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n+                    crate::base::codegen_place(fx, out_place.unwrap()),\n+                )\n+            }\n+            _ => unreachable!(),\n+        };\n+        let edx_place = match operands[3] {\n+            InlineAsmOperand::Out { reg, late: true, place } => {\n+                let reg = expect_reg(reg);\n+                assert_eq!(reg, InlineAsmReg::X86(X86InlineAsmReg::dx));\n+                crate::base::codegen_place(fx, place.unwrap())\n+            }\n+            _ => unreachable!(),\n+        };\n+\n+        let (eax, ebx, ecx, edx) = crate::intrinsics::codegen_cpuid_call(fx, leaf, sub_leaf);\n+\n+        eax_place.write_cvalue(fx, CValue::by_val(eax, fx.layout_of(fx.tcx.types.u32)));\n+        ebx_place.write_cvalue(fx, CValue::by_val(ebx, fx.layout_of(fx.tcx.types.u32)));\n+        ecx_place.write_cvalue(fx, CValue::by_val(ecx, fx.layout_of(fx.tcx.types.u32)));\n+        edx_place.write_cvalue(fx, CValue::by_val(edx, fx.layout_of(fx.tcx.types.u32)));\n+        return;\n+    } else if fx.tcx.symbol_name(fx.instance).name.starts_with(\"___chkstk\") {\n+        // ___chkstk, ___chkstk_ms and __alloca are only used on Windows\n+        crate::trap::trap_unimplemented(fx, \"Stack probes are not supported\");\n+    } else if fx.tcx.symbol_name(fx.instance).name == \"__alloca\" {\n+        crate::trap::trap_unimplemented(fx, \"Alloca is not supported\");\n     }\n \n     let mut slot_size = Size::from_bytes(0);\n@@ -88,8 +150,7 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n \n     let inline_asm_index = fx.inline_asm_index;\n     fx.inline_asm_index += 1;\n-    let asm_name =\n-        format!(\"{}__inline_asm_{}\", fx.tcx.symbol_name(fx.instance).name, inline_asm_index);\n+    let asm_name = format!(\"{}__inline_asm_{}\", fx.symbol_name, inline_asm_index);\n \n     let generated_asm = generate_asm_wrapper(\n         &asm_name,\n@@ -193,11 +254,11 @@ fn call_inline_asm<'tcx>(\n         offset: None,\n         size: u32::try_from(slot_size.bytes()).unwrap(),\n     });\n-    #[cfg(debug_assertions)]\n-    fx.add_comment(stack_slot, \"inline asm scratch slot\");\n+    if fx.clif_comments.enabled() {\n+        fx.add_comment(stack_slot, \"inline asm scratch slot\");\n+    }\n \n     let inline_asm_func = fx\n-        .cx\n         .module\n         .declare_function(\n             asm_name,\n@@ -209,9 +270,10 @@ fn call_inline_asm<'tcx>(\n             },\n         )\n         .unwrap();\n-    let inline_asm_func = fx.cx.module.declare_func_in_func(inline_asm_func, &mut fx.bcx.func);\n-    #[cfg(debug_assertions)]\n-    fx.add_comment(inline_asm_func, asm_name);\n+    let inline_asm_func = fx.module.declare_func_in_func(inline_asm_func, &mut fx.bcx.func);\n+    if fx.clif_comments.enabled() {\n+        fx.add_comment(inline_asm_func, asm_name);\n+    }\n \n     for (_reg, offset, value) in inputs {\n         fx.bcx.ins().stack_store(value, stack_slot, i32::try_from(offset.bytes()).unwrap());"}, {"sha": "9de12e759bcc8826d8dca15c789cccc5c37f80e7", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/cpuid.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fcpuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fcpuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fcpuid.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -8,7 +8,7 @@ use crate::prelude::*;\n pub(crate) fn codegen_cpuid_call<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     leaf: Value,\n-    _subleaf: Value,\n+    _sub_leaf: Value,\n ) -> (Value, Value, Value, Value) {\n     let leaf_0 = fx.bcx.create_block();\n     let leaf_1 = fx.bcx.create_block();"}, {"sha": "ba4ed2162cd5d1397c38fa210e1c36445a0226a3", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/llvm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -22,7 +22,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n         };\n \n         // Used by `_mm_movemask_epi8` and `_mm256_movemask_epi8`\n-        llvm.x86.sse2.pmovmskb.128 | llvm.x86.avx2.pmovmskb | llvm.x86.sse2.movmsk.pd, (c a) {\n+        \"llvm.x86.sse2.pmovmskb.128\" | \"llvm.x86.avx2.pmovmskb\" | \"llvm.x86.sse2.movmsk.pd\", (c a) {\n             let (lane_count, lane_ty) = a.layout().ty.simd_size_and_type(fx.tcx);\n             let lane_ty = fx.clif_type(lane_ty).unwrap();\n             assert!(lane_count <= 32);\n@@ -51,7 +51,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n             let res = CValue::by_val(res, fx.layout_of(fx.tcx.types.i32));\n             ret.write_cvalue(fx, res);\n         };\n-        llvm.x86.sse2.cmp.ps | llvm.x86.sse2.cmp.pd, (c x, c y, o kind) {\n+        \"llvm.x86.sse2.cmp.ps\" | \"llvm.x86.sse2.cmp.pd\", (c x, c y, o kind) {\n             let kind_const = crate::constant::mir_operand_get_const_val(fx, kind).expect(\"llvm.x86.sse2.cmp.* kind not const\");\n             let flt_cc = match kind_const.try_to_bits(Size::from_bytes(1)).unwrap_or_else(|| panic!(\"kind not scalar: {:?}\", kind_const)) {\n                 0 => FloatCC::Equal,\n@@ -81,7 +81,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n                 bool_to_zero_or_max_uint(fx, res_lane_layout, res_lane)\n             });\n         };\n-        llvm.x86.sse2.psrli.d, (c a, o imm8) {\n+        \"llvm.x86.sse2.psrli.d\", (c a, o imm8) {\n             let imm8 = crate::constant::mir_operand_get_const_val(fx, imm8).expect(\"llvm.x86.sse2.psrli.d imm8 not const\");\n             simd_for_each_lane(fx, a, ret, |fx, _lane_layout, res_lane_layout, lane| {\n                 let res_lane = match imm8.try_to_bits(Size::from_bytes(4)).unwrap_or_else(|| panic!(\"imm8 not scalar: {:?}\", imm8)) {\n@@ -91,7 +91,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n                 CValue::by_val(res_lane, res_lane_layout)\n             });\n         };\n-        llvm.x86.sse2.pslli.d, (c a, o imm8) {\n+        \"llvm.x86.sse2.pslli.d\", (c a, o imm8) {\n             let imm8 = crate::constant::mir_operand_get_const_val(fx, imm8).expect(\"llvm.x86.sse2.psrli.d imm8 not const\");\n             simd_for_each_lane(fx, a, ret, |fx, _lane_layout, res_lane_layout, lane| {\n                 let res_lane = match imm8.try_to_bits(Size::from_bytes(4)).unwrap_or_else(|| panic!(\"imm8 not scalar: {:?}\", imm8)) {\n@@ -101,7 +101,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n                 CValue::by_val(res_lane, res_lane_layout)\n             });\n         };\n-        llvm.x86.sse2.storeu.dq, (v mem_addr, c a) {\n+        \"llvm.x86.sse2.storeu.dq\", (v mem_addr, c a) {\n             // FIXME correctly handle the unalignment\n             let dest = CPlace::for_ptr(Pointer::new(mem_addr), a.layout());\n             dest.write_cvalue(fx, a);"}, {"sha": "435737f3a513b511c1788db6cc663994fd6b7886", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 76, "deletions": 68, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -8,23 +8,25 @@ mod simd;\n pub(crate) use cpuid::codegen_cpuid_call;\n pub(crate) use llvm::codegen_llvm_intrinsic_call;\n \n+use rustc_span::symbol::{sym, kw};\n+use rustc_middle::ty::print::with_no_trimmed_paths;\n+\n use crate::prelude::*;\n use cranelift_codegen::ir::AtomicRmwOp;\n-use rustc_middle::ty::print::with_no_trimmed_paths;\n \n macro intrinsic_pat {\n     (_) => {\n         _\n     },\n     ($name:ident) => {\n-        stringify!($name)\n+        sym::$name\n+    },\n+    (kw.$name:ident) => {\n+        kw::$name\n     },\n     ($name:literal) => {\n-        stringify!($name)\n+        $name\n     },\n-    ($x:ident . $($xs:tt).*) => {\n-        concat!(stringify!($x), \".\", intrinsic_pat!($($xs).*))\n-    }\n }\n \n macro intrinsic_arg {\n@@ -87,7 +89,7 @@ macro call_intrinsic_match {\n     )*) => {\n         match $intrinsic {\n             $(\n-                stringify!($name) => {\n+                sym::$name => {\n                     assert!($substs.is_noop());\n                     if let [$(ref $arg),*] = *$args {\n                         let ($($arg,)*) = (\n@@ -400,18 +402,17 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n     let def_id = instance.def_id();\n     let substs = instance.substs;\n \n-    let intrinsic = fx.tcx.item_name(def_id).as_str();\n-    let intrinsic = &intrinsic[..];\n+    let intrinsic = fx.tcx.item_name(def_id);\n \n     let ret = match destination {\n         Some((place, _)) => place,\n         None => {\n             // Insert non returning intrinsics here\n             match intrinsic {\n-                \"abort\" => {\n+                sym::abort => {\n                     trap_abort(fx, \"Called intrinsic::abort.\");\n                 }\n-                \"transmute\" => {\n+                sym::transmute => {\n                     crate::base::codegen_panic(fx, \"Transmuting to uninhabited type.\", span);\n                 }\n                 _ => unimplemented!(\"unsupported instrinsic {}\", intrinsic),\n@@ -420,7 +421,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         }\n     };\n \n-    if intrinsic.starts_with(\"simd_\") {\n+    if intrinsic.as_str().starts_with(\"simd_\") {\n         self::simd::codegen_simd_intrinsic_call(fx, instance, args, ret, span);\n         let ret_block = fx.get_block(destination.expect(\"SIMD intrinsics don't diverge\").1);\n         fx.bcx.ins().jump(ret_block, &[]);\n@@ -470,8 +471,6 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         sinf64(flt) -> f64 => sin,\n         cosf32(flt) -> f32 => cosf,\n         cosf64(flt) -> f64 => cos,\n-        tanf32(flt) -> f32 => tanf,\n-        tanf64(flt) -> f64 => tan,\n     }\n \n     intrinsic_match! {\n@@ -496,12 +495,12 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n                 count\n             };\n \n-            if intrinsic.contains(\"nonoverlapping\") {\n+            if intrinsic == sym::copy_nonoverlapping {\n                 // FIXME emit_small_memcpy\n-                fx.bcx.call_memcpy(fx.cx.module.target_config(), dst, src, byte_amount);\n+                fx.bcx.call_memcpy(fx.module.target_config(), dst, src, byte_amount);\n             } else {\n                 // FIXME emit_small_memmove\n-                fx.bcx.call_memmove(fx.cx.module.target_config(), dst, src, byte_amount);\n+                fx.bcx.call_memmove(fx.module.target_config(), dst, src, byte_amount);\n             }\n         };\n         // NOTE: the volatile variants have src and dst swapped\n@@ -515,12 +514,12 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             };\n \n             // FIXME make the copy actually volatile when using emit_small_mem{cpy,move}\n-            if intrinsic.contains(\"nonoverlapping\") {\n+            if intrinsic == sym::volatile_copy_nonoverlapping_memory {\n                 // FIXME emit_small_memcpy\n-                fx.bcx.call_memcpy(fx.cx.module.target_config(), dst, src, byte_amount);\n+                fx.bcx.call_memcpy(fx.module.target_config(), dst, src, byte_amount);\n             } else {\n                 // FIXME emit_small_memmove\n-                fx.bcx.call_memmove(fx.cx.module.target_config(), dst, src, byte_amount);\n+                fx.bcx.call_memmove(fx.module.target_config(), dst, src, byte_amount);\n             }\n         };\n         size_of_val, <T> (c ptr) {\n@@ -552,27 +551,28 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             ret.write_cvalue(fx, CValue::by_val(align, usize_layout));\n         };\n \n-        _ if intrinsic.starts_with(\"unchecked_\") || intrinsic == \"exact_div\", (c x, c y) {\n+        unchecked_add | unchecked_sub | unchecked_div | exact_div | unchecked_rem\n+        | unchecked_shl | unchecked_shr, (c x, c y) {\n             // FIXME trap on overflow\n             let bin_op = match intrinsic {\n-                \"unchecked_add\" => BinOp::Add,\n-                \"unchecked_sub\" => BinOp::Sub,\n-                \"unchecked_div\" | \"exact_div\" => BinOp::Div,\n-                \"unchecked_rem\" => BinOp::Rem,\n-                \"unchecked_shl\" => BinOp::Shl,\n-                \"unchecked_shr\" => BinOp::Shr,\n-                _ => unreachable!(\"intrinsic {}\", intrinsic),\n+                sym::unchecked_add => BinOp::Add,\n+                sym::unchecked_sub => BinOp::Sub,\n+                sym::unchecked_div | sym::exact_div => BinOp::Div,\n+                sym::unchecked_rem => BinOp::Rem,\n+                sym::unchecked_shl => BinOp::Shl,\n+                sym::unchecked_shr => BinOp::Shr,\n+                _ => unreachable!(),\n             };\n             let res = crate::num::codegen_int_binop(fx, bin_op, x, y);\n             ret.write_cvalue(fx, res);\n         };\n-        _ if intrinsic.ends_with(\"_with_overflow\"), (c x, c y) {\n+        add_with_overflow | sub_with_overflow | mul_with_overflow, (c x, c y) {\n             assert_eq!(x.layout().ty, y.layout().ty);\n             let bin_op = match intrinsic {\n-                \"add_with_overflow\" => BinOp::Add,\n-                \"sub_with_overflow\" => BinOp::Sub,\n-                \"mul_with_overflow\" => BinOp::Mul,\n-                _ => unreachable!(\"intrinsic {}\", intrinsic),\n+                sym::add_with_overflow => BinOp::Add,\n+                sym::sub_with_overflow => BinOp::Sub,\n+                sym::mul_with_overflow => BinOp::Mul,\n+                _ => unreachable!(),\n             };\n \n             let res = crate::num::codegen_checked_int_binop(\n@@ -583,12 +583,12 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             );\n             ret.write_cvalue(fx, res);\n         };\n-        _ if intrinsic.starts_with(\"saturating_\"), <T> (c lhs, c rhs) {\n+        saturating_add | saturating_sub, <T> (c lhs, c rhs) {\n             assert_eq!(lhs.layout().ty, rhs.layout().ty);\n             let bin_op = match intrinsic {\n-                \"saturating_add\" => BinOp::Add,\n-                \"saturating_sub\" => BinOp::Sub,\n-                _ => unreachable!(\"intrinsic {}\", intrinsic),\n+                sym::saturating_add => BinOp::Add,\n+                sym::saturating_sub => BinOp::Sub,\n+                _ => unreachable!(),\n             };\n \n             let signed = type_sign(T);\n@@ -609,15 +609,15 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let (min, max) = type_min_max_value(&mut fx.bcx, clif_ty, signed);\n \n             let val = match (intrinsic, signed) {\n-                (\"saturating_add\", false) => fx.bcx.ins().select(has_overflow, max, val),\n-                (\"saturating_sub\", false) => fx.bcx.ins().select(has_overflow, min, val),\n-                (\"saturating_add\", true) => {\n+                (sym::saturating_add, false) => fx.bcx.ins().select(has_overflow, max, val),\n+                (sym::saturating_sub, false) => fx.bcx.ins().select(has_overflow, min, val),\n+                (sym::saturating_add, true) => {\n                     let rhs = rhs.load_scalar(fx);\n                     let rhs_ge_zero = fx.bcx.ins().icmp_imm(IntCC::SignedGreaterThanOrEqual, rhs, 0);\n                     let sat_val = fx.bcx.ins().select(rhs_ge_zero, max, min);\n                     fx.bcx.ins().select(has_overflow, sat_val, val)\n                 }\n-                (\"saturating_sub\", true) => {\n+                (sym::saturating_sub, true) => {\n                     let rhs = rhs.load_scalar(fx);\n                     let rhs_ge_zero = fx.bcx.ins().icmp_imm(IntCC::SignedGreaterThanOrEqual, rhs, 0);\n                     let sat_val = fx.bcx.ins().select(rhs_ge_zero, min, max);\n@@ -632,11 +632,21 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         };\n         rotate_left, <T>(v x, v y) {\n             let layout = fx.layout_of(T);\n+            let y = if fx.bcx.func.dfg.value_type(y) == types::I128 {\n+                fx.bcx.ins().ireduce(types::I64, y)\n+            } else {\n+                y\n+            };\n             let res = fx.bcx.ins().rotl(x, y);\n             ret.write_cvalue(fx, CValue::by_val(res, layout));\n         };\n         rotate_right, <T>(v x, v y) {\n             let layout = fx.layout_of(T);\n+            let y = if fx.bcx.func.dfg.value_type(y) == types::I128 {\n+                fx.bcx.ins().ireduce(types::I64, y)\n+            } else {\n+                y\n+            };\n             let res = fx.bcx.ins().rotr(x, y);\n             ret.write_cvalue(fx, CValue::by_val(res, layout));\n         };\n@@ -670,7 +680,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let dst_ptr = dst.load_scalar(fx);\n             // FIXME make the memset actually volatile when switching to emit_small_memset\n             // FIXME use emit_small_memset\n-            fx.bcx.call_memset(fx.cx.module.target_config(), dst_ptr, val, count);\n+            fx.bcx.call_memset(fx.module.target_config(), dst_ptr, val, count);\n         };\n         ctlz | ctlz_nonzero, <T> (v arg) {\n             // FIXME trap on `ctlz_nonzero` with zero arg.\n@@ -806,7 +816,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n                 return;\n             }\n \n-            if intrinsic == \"assert_zero_valid\" && !layout.might_permit_raw_init(fx, /*zero:*/ true).unwrap() {\n+            if intrinsic == sym::assert_zero_valid && !layout.might_permit_raw_init(fx, /*zero:*/ true).unwrap() {\n                 with_no_trimmed_paths(|| crate::base::codegen_panic(\n                     fx,\n                     &format!(\"attempted to zero-initialize type `{}`, which is invalid\", T),\n@@ -815,7 +825,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n                 return;\n             }\n \n-            if intrinsic == \"assert_uninit_valid\" && !layout.might_permit_raw_init(fx, /*zero:*/ false).unwrap() {\n+            if intrinsic == sym::assert_uninit_valid && !layout.might_permit_raw_init(fx, /*zero:*/ false).unwrap() {\n                 with_no_trimmed_paths(|| crate::base::codegen_panic(\n                     fx,\n                     &format!(\"attempted to leave type `{}` uninitialized, which is invalid\", T),\n@@ -827,7 +837,6 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n \n         volatile_load | unaligned_volatile_load, (c ptr) {\n             // Cranelift treats loads as volatile by default\n-            // FIXME ignore during stack2reg optimization\n             // FIXME correctly handle unaligned_volatile_load\n             let inner_layout =\n                 fx.layout_of(ptr.layout().ty.builtin_deref(true).unwrap().ty);\n@@ -836,7 +845,6 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         };\n         volatile_store | unaligned_volatile_store, (v ptr, c val) {\n             // Cranelift treats stores as volatile by default\n-            // FIXME ignore during stack2reg optimization\n             // FIXME correctly handle unaligned_volatile_store\n             let dest = CPlace::for_ptr(Pointer::new(ptr), val.layout());\n             dest.write_cvalue(fx, val);\n@@ -878,14 +886,14 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             ret.write_cvalue(fx, caller_location);\n         };\n \n-        _ if intrinsic.starts_with(\"atomic_fence\"), () {\n+        _ if intrinsic.as_str().starts_with(\"atomic_fence\"), () {\n             fx.bcx.ins().fence();\n         };\n-        _ if intrinsic.starts_with(\"atomic_singlethreadfence\"), () {\n+        _ if intrinsic.as_str().starts_with(\"atomic_singlethreadfence\"), () {\n             // FIXME use a compiler fence once Cranelift supports it\n             fx.bcx.ins().fence();\n         };\n-        _ if intrinsic.starts_with(\"atomic_load\"), <T> (v ptr) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_load\"), <T> (v ptr) {\n             validate_atomic_type!(fx, intrinsic, span, T);\n             let ty = fx.clif_type(T).unwrap();\n \n@@ -894,14 +902,14 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let val = CValue::by_val(val, fx.layout_of(T));\n             ret.write_cvalue(fx, val);\n         };\n-        _ if intrinsic.starts_with(\"atomic_store\"), (v ptr, c val) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_store\"), (v ptr, c val) {\n             validate_atomic_type!(fx, intrinsic, span, val.layout().ty);\n \n             let val = val.load_scalar(fx);\n \n             fx.bcx.ins().atomic_store(MemFlags::trusted(), val, ptr);\n         };\n-        _ if intrinsic.starts_with(\"atomic_xchg\"), (v ptr, c new) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_xchg\"), (v ptr, c new) {\n             let layout = new.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n             let ty = fx.clif_type(layout.ty).unwrap();\n@@ -913,7 +921,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let old = CValue::by_val(old, layout);\n             ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_cxchg\"), (v ptr, c test_old, c new) { // both atomic_cxchg_* and atomic_cxchgweak_*\n+        _ if intrinsic.as_str().starts_with(\"atomic_cxchg\"), (v ptr, c test_old, c new) { // both atomic_cxchg_* and atomic_cxchgweak_*\n             let layout = new.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n \n@@ -927,7 +935,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             ret.write_cvalue(fx, ret_val)\n         };\n \n-        _ if intrinsic.starts_with(\"atomic_xadd\"), (v ptr, c amount) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_xadd\"), (v ptr, c amount) {\n             let layout = amount.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n             let ty = fx.clif_type(layout.ty).unwrap();\n@@ -939,7 +947,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let old = CValue::by_val(old, layout);\n             ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_xsub\"), (v ptr, c amount) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_xsub\"), (v ptr, c amount) {\n             let layout = amount.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n             let ty = fx.clif_type(layout.ty).unwrap();\n@@ -951,7 +959,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let old = CValue::by_val(old, layout);\n             ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_and\"), (v ptr, c src) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_and\"), (v ptr, c src) {\n             let layout = src.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n             let ty = fx.clif_type(layout.ty).unwrap();\n@@ -963,7 +971,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let old = CValue::by_val(old, layout);\n             ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_or\"), (v ptr, c src) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_or\"), (v ptr, c src) {\n             let layout = src.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n             let ty = fx.clif_type(layout.ty).unwrap();\n@@ -975,7 +983,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let old = CValue::by_val(old, layout);\n             ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_xor\"), (v ptr, c src) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_xor\"), (v ptr, c src) {\n             let layout = src.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n             let ty = fx.clif_type(layout.ty).unwrap();\n@@ -989,7 +997,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         };\n \n         // FIXME https://github.com/bytecodealliance/wasmtime/issues/2647\n-        _ if intrinsic.starts_with(\"atomic_nand\"), (v ptr, c src) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_nand\"), (v ptr, c src) {\n             let layout = src.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n             let ty = fx.clif_type(layout.ty).unwrap();\n@@ -1001,7 +1009,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let old = CValue::by_val(old, layout);\n             ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_max\"), (v ptr, c src) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_max\"), (v ptr, c src) {\n             let layout = src.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n             let ty = fx.clif_type(layout.ty).unwrap();\n@@ -1013,7 +1021,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let old = CValue::by_val(old, layout);\n             ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_umax\"), (v ptr, c src) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_umax\"), (v ptr, c src) {\n             let layout = src.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n             let ty = fx.clif_type(layout.ty).unwrap();\n@@ -1025,7 +1033,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let old = CValue::by_val(old, layout);\n             ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_min\"), (v ptr, c src) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_min\"), (v ptr, c src) {\n             let layout = src.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n             let ty = fx.clif_type(layout.ty).unwrap();\n@@ -1037,7 +1045,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let old = CValue::by_val(old, layout);\n             ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_umin\"), (v ptr, c src) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_umin\"), (v ptr, c src) {\n             let layout = src.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n             let ty = fx.clif_type(layout.ty).unwrap();\n@@ -1071,7 +1079,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             ret.write_cvalue(fx, val);\n         };\n \n-        try, (v f, v data, v _catch_fn) {\n+        kw.Try, (v f, v data, v _catch_fn) {\n             // FIXME once unwinding is supported, change this to actually catch panics\n             let f_sig = fx.bcx.func.import_signature(Signature {\n                 call_conv: CallConv::triple_default(fx.triple()),\n@@ -1088,11 +1096,11 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n \n         fadd_fast | fsub_fast | fmul_fast | fdiv_fast | frem_fast, (c x, c y) {\n             let res = crate::num::codegen_float_binop(fx, match intrinsic {\n-                \"fadd_fast\" => BinOp::Add,\n-                \"fsub_fast\" => BinOp::Sub,\n-                \"fmul_fast\" => BinOp::Mul,\n-                \"fdiv_fast\" => BinOp::Div,\n-                \"frem_fast\" => BinOp::Rem,\n+                sym::fadd_fast => BinOp::Add,\n+                sym::fsub_fast => BinOp::Sub,\n+                sym::fmul_fast => BinOp::Mul,\n+                sym::fdiv_fast => BinOp::Div,\n+                sym::frem_fast => BinOp::Rem,\n                 _ => unreachable!(),\n             }, x, y);\n             ret.write_cvalue(fx, res);"}, {"sha": "c2f469fa021e15ab0703f65b6bc1596de4c80a20", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/simd.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -13,8 +13,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n     let def_id = instance.def_id();\n     let substs = instance.substs;\n \n-    let intrinsic = fx.tcx.item_name(def_id).as_str();\n-    let intrinsic = &intrinsic[..];\n+    let intrinsic = fx.tcx.item_name(def_id);\n \n     intrinsic_match! {\n         fx, intrinsic, substs, args,\n@@ -65,10 +64,10 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n         };\n \n         // simd_shuffle32<T, U>(x: T, y: T, idx: [u32; 32]) -> U\n-        _ if intrinsic.starts_with(\"simd_shuffle\"), (c x, c y, o idx) {\n+        _ if intrinsic.as_str().starts_with(\"simd_shuffle\"), (c x, c y, o idx) {\n             validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n \n-            let n: u16 = intrinsic[\"simd_shuffle\".len()..].parse().unwrap();\n+            let n: u16 = intrinsic.as_str()[\"simd_shuffle\".len()..].parse().unwrap();\n \n             assert_eq!(x.layout(), y.layout());\n             let layout = x.layout();\n@@ -87,9 +86,8 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n \n                 let idx_bytes = match idx_const {\n                     ConstValue::ByRef { alloc, offset } => {\n-                        let ptr = Pointer::new(AllocId(0 /* dummy */), offset);\n-                        let size = Size::from_bytes(4 * u64::from(ret_lane_count) /* size_of([u32; ret_lane_count]) */);\n-                        alloc.get_bytes(fx, ptr, size).unwrap()\n+                        let size = Size::from_bytes(4 * ret_lane_count /* size_of([u32; ret_lane_count]) */);\n+                        alloc.get_bytes(fx, alloc_range(offset, size)).unwrap()\n                     }\n                     _ => unreachable!(\"{:?}\", idx_const),\n                 };\n@@ -277,5 +275,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n         // simd_select\n         // simd_rem\n         // simd_neg\n+        // simd_trunc\n+        // simd_floor\n     }\n }"}, {"sha": "ff6e1856059af0066f85b7f8023f9ec5e03990c8", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 63, "deletions": 106, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -1,13 +1,4 @@\n-#![feature(\n-    rustc_private,\n-    decl_macro,\n-    type_alias_impl_trait,\n-    associated_type_bounds,\n-    never_type,\n-    try_blocks,\n-    box_patterns,\n-    hash_drain_filter\n-)]\n+#![feature(rustc_private, decl_macro, never_type, hash_drain_filter, vec_into_raw_parts)]\n #![warn(rust_2018_idioms)]\n #![warn(unused_lifetimes)]\n #![warn(unreachable_pub)]\n@@ -32,7 +23,6 @@ extern crate rustc_target;\n extern crate rustc_driver;\n \n use std::any::Any;\n-use std::str::FromStr;\n \n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_codegen_ssa::CodegenResults;\n@@ -43,9 +33,10 @@ use rustc_middle::ty::query::Providers;\n use rustc_session::config::OutputFilenames;\n use rustc_session::Session;\n \n+use cranelift_codegen::isa::TargetIsa;\n use cranelift_codegen::settings::{self, Configurable};\n \n-use crate::constant::ConstantCx;\n+pub use crate::config::*;\n use crate::prelude::*;\n \n mod abi;\n@@ -57,6 +48,8 @@ mod base;\n mod cast;\n mod codegen_i128;\n mod common;\n+mod compiler_builtins;\n+mod config;\n mod constant;\n mod debuginfo;\n mod discriminant;\n@@ -95,7 +88,6 @@ mod prelude {\n \n     pub(crate) use rustc_index::vec::Idx;\n \n-    pub(crate) use cranelift_codegen::entity::EntitySet;\n     pub(crate) use cranelift_codegen::ir::condcodes::{FloatCC, IntCC};\n     pub(crate) use cranelift_codegen::ir::function::Function;\n     pub(crate) use cranelift_codegen::ir::types;\n@@ -127,95 +119,36 @@ impl<F: Fn() -> String> Drop for PrintOnPanic<F> {\n     }\n }\n \n-struct CodegenCx<'m, 'tcx: 'm> {\n+/// The codegen context holds any information shared between the codegen of individual functions\n+/// inside a single codegen unit with the exception of the Cranelift [`Module`](cranelift_module::Module).\n+struct CodegenCx<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    module: &'m mut dyn Module,\n     global_asm: String,\n-    constants_cx: ConstantCx,\n     cached_context: Context,\n-    vtables: FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), DataId>,\n     debug_context: Option<DebugContext<'tcx>>,\n-    unwind_context: UnwindContext<'tcx>,\n+    unwind_context: UnwindContext,\n }\n \n-impl<'m, 'tcx> CodegenCx<'m, 'tcx> {\n+impl<'tcx> CodegenCx<'tcx> {\n     fn new(\n         tcx: TyCtxt<'tcx>,\n         backend_config: BackendConfig,\n-        module: &'m mut dyn Module,\n+        isa: &dyn TargetIsa,\n         debug_info: bool,\n     ) -> Self {\n-        let unwind_context = UnwindContext::new(\n-            tcx,\n-            module.isa(),\n-            matches!(backend_config.codegen_mode, CodegenMode::Aot),\n-        );\n-        let debug_context =\n-            if debug_info { Some(DebugContext::new(tcx, module.isa())) } else { None };\n+        assert_eq!(pointer_ty(tcx), isa.pointer_type());\n+\n+        let unwind_context =\n+            UnwindContext::new(tcx, isa, matches!(backend_config.codegen_mode, CodegenMode::Aot));\n+        let debug_context = if debug_info { Some(DebugContext::new(tcx, isa)) } else { None };\n         CodegenCx {\n             tcx,\n-            module,\n             global_asm: String::new(),\n-            constants_cx: ConstantCx::default(),\n             cached_context: Context::new(),\n-            vtables: FxHashMap::default(),\n             debug_context,\n             unwind_context,\n         }\n     }\n-\n-    fn finalize(self) -> (String, Option<DebugContext<'tcx>>, UnwindContext<'tcx>) {\n-        self.constants_cx.finalize(self.tcx, self.module);\n-        (self.global_asm, self.debug_context, self.unwind_context)\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum CodegenMode {\n-    Aot,\n-    Jit,\n-    JitLazy,\n-}\n-\n-impl Default for CodegenMode {\n-    fn default() -> Self {\n-        CodegenMode::Aot\n-    }\n-}\n-\n-impl FromStr for CodegenMode {\n-    type Err = String;\n-\n-    fn from_str(s: &str) -> Result<Self, Self::Err> {\n-        match s {\n-            \"aot\" => Ok(CodegenMode::Aot),\n-            \"jit\" => Ok(CodegenMode::Jit),\n-            \"jit-lazy\" => Ok(CodegenMode::JitLazy),\n-            _ => Err(format!(\"Unknown codegen mode `{}`\", s)),\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug, Default)]\n-pub struct BackendConfig {\n-    pub codegen_mode: CodegenMode,\n-}\n-\n-impl BackendConfig {\n-    fn from_opts(opts: &[String]) -> Result<Self, String> {\n-        let mut config = BackendConfig::default();\n-        for opt in opts {\n-            if let Some((name, value)) = opt.split_once('=') {\n-                match name {\n-                    \"mode\" => config.codegen_mode = value.parse()?,\n-                    _ => return Err(format!(\"Unknown option `{}`\", name)),\n-                }\n-            } else {\n-                return Err(format!(\"Invalid option `{}`\", opt));\n-            }\n-        }\n-        Ok(config)\n-    }\n }\n \n pub struct CraneliftCodegenBackend {\n@@ -224,13 +157,15 @@ pub struct CraneliftCodegenBackend {\n \n impl CodegenBackend for CraneliftCodegenBackend {\n     fn init(&self, sess: &Session) {\n-        if sess.lto() != rustc_session::config::Lto::No && sess.opts.cg.embed_bitcode {\n-            sess.warn(\"LTO is not supported. You may get a linker error.\");\n+        use rustc_session::config::Lto;\n+        match sess.lto() {\n+            Lto::No | Lto::ThinLocal => {}\n+            Lto::Thin | Lto::Fat => sess.warn(\"LTO is not supported. You may get a linker error.\"),\n         }\n     }\n \n     fn metadata_loader(&self) -> Box<dyn MetadataLoader + Sync> {\n-        Box::new(crate::metadata::CraneliftMetadataLoader)\n+        Box::new(rustc_codegen_ssa::back::metadata::DefaultMetadataLoader)\n     }\n \n     fn provide(&self, _providers: &mut Providers) {}\n@@ -240,21 +175,29 @@ impl CodegenBackend for CraneliftCodegenBackend {\n         vec![]\n     }\n \n-    fn codegen_crate<'tcx>(\n+    fn codegen_crate(\n         &self,\n-        tcx: TyCtxt<'tcx>,\n+        tcx: TyCtxt<'_>,\n         metadata: EncodedMetadata,\n         need_metadata_module: bool,\n     ) -> Box<dyn Any> {\n-        let config = if let Some(config) = self.config {\n+        tcx.sess.abort_if_errors();\n+        let config = if let Some(config) = self.config.clone() {\n             config\n         } else {\n             BackendConfig::from_opts(&tcx.sess.opts.cg.llvm_args)\n                 .unwrap_or_else(|err| tcx.sess.fatal(&err))\n         };\n-        let res = driver::codegen_crate(tcx, metadata, need_metadata_module, config);\n-\n-        res\n+        match config.codegen_mode {\n+            CodegenMode::Aot => driver::aot::run_aot(tcx, config, metadata, need_metadata_module),\n+            CodegenMode::Jit | CodegenMode::JitLazy => {\n+                #[cfg(feature = \"jit\")]\n+                let _: ! = driver::jit::run_jit(tcx, config);\n+\n+                #[cfg(not(feature = \"jit\"))]\n+                tcx.sess.fatal(\"jit support was disabled when compiling rustc_codegen_cranelift\");\n+            }\n+        }\n     }\n \n     fn join_codegen(\n@@ -275,13 +218,11 @@ impl CodegenBackend for CraneliftCodegenBackend {\n     ) -> Result<(), ErrorReported> {\n         use rustc_codegen_ssa::back::link::link_binary;\n \n-        let target_cpu = crate::target_triple(sess).to_string();\n         link_binary::<crate::archive::ArArchiveBuilder<'_>>(\n             sess,\n             &codegen_results,\n             outputs,\n             &codegen_results.crate_name.as_str(),\n-            &target_cpu,\n         );\n \n         Ok(())\n@@ -292,17 +233,16 @@ fn target_triple(sess: &Session) -> target_lexicon::Triple {\n     sess.target.llvm_target.parse().unwrap()\n }\n \n-fn build_isa(sess: &Session) -> Box<dyn isa::TargetIsa + 'static> {\n+fn build_isa(sess: &Session, backend_config: &BackendConfig) -> Box<dyn isa::TargetIsa + 'static> {\n     use target_lexicon::BinaryFormat;\n \n     let target_triple = crate::target_triple(sess);\n \n     let mut flags_builder = settings::builder();\n     flags_builder.enable(\"is_pic\").unwrap();\n     flags_builder.set(\"enable_probestack\", \"false\").unwrap(); // __cranelift_probestack is not provided\n-    flags_builder\n-        .set(\"enable_verifier\", if cfg!(debug_assertions) { \"true\" } else { \"false\" })\n-        .unwrap();\n+    let enable_verifier = if backend_config.enable_verifier { \"true\" } else { \"false\" };\n+    flags_builder.set(\"enable_verifier\", enable_verifier).unwrap();\n \n     let tls_model = match target_triple.binary_format {\n         BinaryFormat::Elf => \"elf_gd\",\n@@ -314,27 +254,44 @@ fn build_isa(sess: &Session) -> Box<dyn isa::TargetIsa + 'static> {\n \n     flags_builder.set(\"enable_simd\", \"true\").unwrap();\n \n+    flags_builder.set(\"enable_llvm_abi_extensions\", \"true\").unwrap();\n+\n     use rustc_session::config::OptLevel;\n     match sess.opts.optimize {\n         OptLevel::No => {\n             flags_builder.set(\"opt_level\", \"none\").unwrap();\n         }\n         OptLevel::Less | OptLevel::Default => {}\n-        OptLevel::Aggressive => {\n+        OptLevel::Size | OptLevel::SizeMin | OptLevel::Aggressive => {\n             flags_builder.set(\"opt_level\", \"speed_and_size\").unwrap();\n         }\n-        OptLevel::Size | OptLevel::SizeMin => {\n-            sess.warn(\"Optimizing for size is not supported. Just ignoring the request\");\n-        }\n     }\n \n     let flags = settings::Flags::new(flags_builder);\n \n     let variant = cranelift_codegen::isa::BackendVariant::MachInst;\n-    let mut isa_builder = cranelift_codegen::isa::lookup_variant(target_triple, variant).unwrap();\n-    // Don't use \"haswell\", as it implies `has_lzcnt`.macOS CI is still at Ivy Bridge EP, so `lzcnt`\n-    // is interpreted as `bsr`.\n-    isa_builder.enable(\"nehalem\").unwrap();\n+\n+    let isa_builder = match sess.opts.cg.target_cpu.as_deref() {\n+        Some(\"native\") => {\n+            let builder = cranelift_native::builder_with_options(variant, true).unwrap();\n+            builder\n+        }\n+        Some(value) => {\n+            let mut builder = cranelift_codegen::isa::lookup_variant(target_triple, variant).unwrap();\n+            if let Err(_) = builder.enable(value) {\n+                sess.fatal(\"The specified target cpu isn't currently supported by Cranelift.\");\n+            }\n+            builder\n+        }\n+        None => {\n+            let mut builder = cranelift_codegen::isa::lookup_variant(target_triple, variant).unwrap();\n+            // Don't use \"haswell\" as the default, as it implies `has_lzcnt`.\n+            // macOS CI is still at Ivy Bridge EP, so `lzcnt` is interpreted as `bsr`.\n+            builder.enable(\"nehalem\").unwrap();\n+            builder\n+        }\n+    };\n+    \n     isa_builder.finish(flags)\n }\n "}, {"sha": "ca853aac15892285208581ed6884e4835babf864", "filename": "compiler/rustc_codegen_cranelift/src/linkage.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flinkage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flinkage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flinkage.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -6,11 +6,14 @@ pub(crate) fn get_clif_linkage(\n     mono_item: MonoItem<'_>,\n     linkage: RLinkage,\n     visibility: Visibility,\n+    is_compiler_builtins: bool,\n ) -> Linkage {\n     match (linkage, visibility) {\n+        (RLinkage::External, Visibility::Default) if is_compiler_builtins => Linkage::Hidden,\n         (RLinkage::External, Visibility::Default) => Linkage::Export,\n         (RLinkage::Internal, Visibility::Default) => Linkage::Local,\n         (RLinkage::External, Visibility::Hidden) => Linkage::Hidden,\n+        (RLinkage::WeakAny, Visibility::Default) => Linkage::Preemptible,\n         _ => panic!(\"{:?} = {:?} {:?}\", mono_item, linkage, visibility),\n     }\n }"}, {"sha": "d1958c5f96b86b7be79f1a2c1129e4e57a82f1a6", "filename": "compiler/rustc_codegen_cranelift/src/main_shim.rs", "status": "modified", "additions": 62, "deletions": 19, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -1,5 +1,9 @@\n+use cranelift_codegen::binemit::{NullStackMapSink, NullTrapSink};\n use rustc_hir::LangItem;\n+use rustc_middle::ty::subst::GenericArg;\n+use rustc_middle::ty::AssocKind;\n use rustc_session::config::EntryFnType;\n+use rustc_span::symbol::Ident;\n \n use crate::prelude::*;\n \n@@ -8,11 +12,12 @@ use crate::prelude::*;\n pub(crate) fn maybe_create_entry_wrapper(\n     tcx: TyCtxt<'_>,\n     module: &mut impl Module,\n-    unwind_context: &mut UnwindContext<'_>,\n+    unwind_context: &mut UnwindContext,\n+    is_jit: bool,\n ) {\n-    let (main_def_id, use_start_lang_item) = match tcx.entry_fn(LOCAL_CRATE) {\n+    let (main_def_id, is_main_fn) = match tcx.entry_fn(()) {\n         Some((def_id, entry_ty)) => (\n-            def_id.to_def_id(),\n+            def_id,\n             match entry_ty {\n                 EntryFnType::Main => true,\n                 EntryFnType::Start => false,\n@@ -22,18 +27,19 @@ pub(crate) fn maybe_create_entry_wrapper(\n     };\n \n     let instance = Instance::mono(tcx, main_def_id).polymorphize(tcx);\n-    if module.get_name(&*tcx.symbol_name(instance).name).is_none() {\n+    if !is_jit && module.get_name(&*tcx.symbol_name(instance).name).is_none() {\n         return;\n     }\n \n-    create_entry_fn(tcx, module, unwind_context, main_def_id, use_start_lang_item);\n+    create_entry_fn(tcx, module, unwind_context, main_def_id, is_jit, is_main_fn);\n \n     fn create_entry_fn(\n         tcx: TyCtxt<'_>,\n         m: &mut impl Module,\n-        unwind_context: &mut UnwindContext<'_>,\n+        unwind_context: &mut UnwindContext,\n         rust_main_def_id: DefId,\n-        use_start_lang_item: bool,\n+        ignore_lang_start_wrapper: bool,\n+        is_main_fn: bool,\n     ) {\n         let main_ret_ty = tcx.fn_sig(rust_main_def_id).output();\n         // Given that `main()` has no arguments,\n@@ -56,9 +62,9 @@ pub(crate) fn maybe_create_entry_wrapper(\n \n         let instance = Instance::mono(tcx, rust_main_def_id).polymorphize(tcx);\n \n-        let main_name = tcx.symbol_name(instance).name.to_string();\n+        let main_name = tcx.symbol_name(instance).name;\n         let main_sig = get_function_sig(tcx, m.isa().triple(), instance);\n-        let main_func_id = m.declare_function(&main_name, Linkage::Import, &main_sig).unwrap();\n+        let main_func_id = m.declare_function(main_name, Linkage::Import, &main_sig).unwrap();\n \n         let mut ctx = Context::new();\n         ctx.func = Function::with_name_signature(ExternalName::user(0, 0), cmain_sig);\n@@ -73,7 +79,47 @@ pub(crate) fn maybe_create_entry_wrapper(\n \n             let main_func_ref = m.declare_func_in_func(main_func_id, &mut bcx.func);\n \n-            let call_inst = if use_start_lang_item {\n+            let result = if is_main_fn && ignore_lang_start_wrapper {\n+                // regular main fn, but ignoring #[lang = \"start\"] as we are running in the jit\n+                // FIXME set program arguments somehow\n+                let call_inst = bcx.ins().call(main_func_ref, &[]);\n+                let call_results = bcx.func.dfg.inst_results(call_inst).to_owned();\n+\n+                let termination_trait = tcx.require_lang_item(LangItem::Termination, None);\n+                let report = tcx\n+                    .associated_items(termination_trait)\n+                    .find_by_name_and_kind(\n+                        tcx,\n+                        Ident::from_str(\"report\"),\n+                        AssocKind::Fn,\n+                        termination_trait,\n+                    )\n+                    .unwrap();\n+                let report = Instance::resolve(\n+                    tcx,\n+                    ParamEnv::reveal_all(),\n+                    report.def_id,\n+                    tcx.mk_substs([GenericArg::from(main_ret_ty)].iter()),\n+                )\n+                .unwrap()\n+                .unwrap();\n+\n+                let report_name = tcx.symbol_name(report).name;\n+                let report_sig = get_function_sig(tcx, m.isa().triple(), report);\n+                let report_func_id =\n+                    m.declare_function(report_name, Linkage::Import, &report_sig).unwrap();\n+                let report_func_ref = m.declare_func_in_func(report_func_id, &mut bcx.func);\n+\n+                // FIXME do proper abi handling instead of expecting the pass mode to be identical\n+                // for returns and arguments.\n+                let report_call_inst = bcx.ins().call(report_func_ref, &call_results);\n+                let res = bcx.func.dfg.inst_results(report_call_inst)[0];\n+                match m.target_config().pointer_type() {\n+                    types::I32 => res,\n+                    types::I64 => bcx.ins().sextend(types::I64, res),\n+                    _ => unimplemented!(\"16bit systems are not yet supported\"),\n+                }\n+            } else if is_main_fn {\n                 let start_def_id = tcx.require_lang_item(LangItem::Start, None);\n                 let start_instance = Instance::resolve(\n                     tcx,\n@@ -89,23 +135,20 @@ pub(crate) fn maybe_create_entry_wrapper(\n                 let main_val = bcx.ins().func_addr(m.target_config().pointer_type(), main_func_ref);\n \n                 let func_ref = m.declare_func_in_func(start_func_id, &mut bcx.func);\n-                bcx.ins().call(func_ref, &[main_val, arg_argc, arg_argv])\n+                let call_inst = bcx.ins().call(func_ref, &[main_val, arg_argc, arg_argv]);\n+                bcx.inst_results(call_inst)[0]\n             } else {\n                 // using user-defined start fn\n-                bcx.ins().call(main_func_ref, &[arg_argc, arg_argv])\n+                let call_inst = bcx.ins().call(main_func_ref, &[arg_argc, arg_argv]);\n+                bcx.inst_results(call_inst)[0]\n             };\n \n-            let result = bcx.inst_results(call_inst)[0];\n             bcx.ins().return_(&[result]);\n             bcx.seal_all_blocks();\n             bcx.finalize();\n         }\n-        m.define_function(\n-            cmain_func_id,\n-            &mut ctx,\n-            &mut cranelift_codegen::binemit::NullTrapSink {},\n-        )\n-        .unwrap();\n+        m.define_function(cmain_func_id, &mut ctx, &mut NullTrapSink {}, &mut NullStackMapSink {})\n+            .unwrap();\n         unwind_context.add_function(cmain_func_id, &ctx, m.isa());\n     }\n }"}, {"sha": "ab238244d68d504c983bfff1ffea366fd6eb7c5f", "filename": "compiler/rustc_codegen_cranelift/src/metadata.rs", "status": "modified", "additions": 3, "deletions": 89, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmetadata.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -1,106 +1,20 @@\n-//! Reading and writing of the rustc metadata for rlibs and dylibs\n+//! Writing of the rustc metadata for dylibs\n \n-use std::convert::TryFrom;\n-use std::fs::File;\n-use std::path::Path;\n-\n-use rustc_codegen_ssa::METADATA_FILENAME;\n-use rustc_data_structures::owning_ref::OwningRef;\n-use rustc_data_structures::rustc_erase_owner;\n-use rustc_data_structures::sync::MetadataRef;\n-use rustc_middle::middle::cstore::{EncodedMetadata, MetadataLoader};\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::config;\n-use rustc_target::spec::Target;\n \n use crate::backend::WriteMetadata;\n \n-pub(crate) struct CraneliftMetadataLoader;\n-\n-impl MetadataLoader for CraneliftMetadataLoader {\n-    fn get_rlib_metadata(&self, _target: &Target, path: &Path) -> Result<MetadataRef, String> {\n-        let mut archive = ar::Archive::new(File::open(path).map_err(|e| format!(\"{:?}\", e))?);\n-        // Iterate over all entries in the archive:\n-        while let Some(entry_result) = archive.next_entry() {\n-            let mut entry = entry_result.map_err(|e| format!(\"{:?}\", e))?;\n-            if entry.header().identifier() == METADATA_FILENAME.as_bytes() {\n-                let mut buf = Vec::with_capacity(\n-                    usize::try_from(entry.header().size())\n-                        .expect(\"Rlib metadata file too big to load into memory.\"),\n-                );\n-                ::std::io::copy(&mut entry, &mut buf).map_err(|e| format!(\"{:?}\", e))?;\n-                let buf: OwningRef<Vec<u8>, [u8]> = OwningRef::new(buf);\n-                return Ok(rustc_erase_owner!(buf.map_owner_box()));\n-            }\n-        }\n-\n-        Err(\"couldn't find metadata entry\".to_string())\n-    }\n-\n-    fn get_dylib_metadata(&self, _target: &Target, path: &Path) -> Result<MetadataRef, String> {\n-        use object::{Object, ObjectSection};\n-        let file = std::fs::read(path).map_err(|e| format!(\"read:{:?}\", e))?;\n-        let file = object::File::parse(&file).map_err(|e| format!(\"parse: {:?}\", e))?;\n-        let buf = file\n-            .section_by_name(\".rustc\")\n-            .ok_or(\"no .rustc section\")?\n-            .data()\n-            .map_err(|e| format!(\"failed to read .rustc section: {:?}\", e))?\n-            .to_owned();\n-        let buf: OwningRef<Vec<u8>, [u8]> = OwningRef::new(buf);\n-        Ok(rustc_erase_owner!(buf.map_owner_box()))\n-    }\n-}\n-\n // Adapted from https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src/librustc_codegen_llvm/base.rs#L47-L112\n-pub(crate) fn write_metadata<P: WriteMetadata>(\n-    tcx: TyCtxt<'_>,\n-    product: &mut P,\n-) -> EncodedMetadata {\n+pub(crate) fn write_metadata<O: WriteMetadata>(tcx: TyCtxt<'_>, object: &mut O) {\n     use snap::write::FrameEncoder;\n     use std::io::Write;\n \n-    #[derive(PartialEq, Eq, PartialOrd, Ord)]\n-    enum MetadataKind {\n-        None,\n-        Uncompressed,\n-        Compressed,\n-    }\n-\n-    let kind = tcx\n-        .sess\n-        .crate_types()\n-        .iter()\n-        .map(|ty| match *ty {\n-            config::CrateType::Executable\n-            | config::CrateType::Staticlib\n-            | config::CrateType::Cdylib => MetadataKind::None,\n-\n-            config::CrateType::Rlib => MetadataKind::Uncompressed,\n-\n-            config::CrateType::Dylib | config::CrateType::ProcMacro => MetadataKind::Compressed,\n-        })\n-        .max()\n-        .unwrap_or(MetadataKind::None);\n-\n-    if kind == MetadataKind::None {\n-        return EncodedMetadata::new();\n-    }\n-\n     let metadata = tcx.encode_metadata();\n-    if kind == MetadataKind::Uncompressed {\n-        return metadata;\n-    }\n-\n-    assert!(kind == MetadataKind::Compressed);\n     let mut compressed = tcx.metadata_encoding_version();\n     FrameEncoder::new(&mut compressed).write_all(&metadata.raw_data).unwrap();\n \n-    product.add_rustc_section(\n+    object.add_rustc_section(\n         rustc_middle::middle::exported_symbols::metadata_symbol_name(tcx),\n         compressed,\n-        tcx.sess.target.is_like_osx,\n     );\n-\n-    metadata\n }"}, {"sha": "b6d378a5fe10ae59b53ca8c4656923902250fc05", "filename": "compiler/rustc_codegen_cranelift/src/num.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -166,13 +166,11 @@ pub(crate) fn codegen_int_binop<'tcx>(\n         BinOp::Shl => {\n             let lhs_ty = fx.bcx.func.dfg.value_type(lhs);\n             let actual_shift = fx.bcx.ins().band_imm(rhs, i64::from(lhs_ty.bits() - 1));\n-            let actual_shift = clif_intcast(fx, actual_shift, types::I8, false);\n             fx.bcx.ins().ishl(lhs, actual_shift)\n         }\n         BinOp::Shr => {\n             let lhs_ty = fx.bcx.func.dfg.value_type(lhs);\n             let actual_shift = fx.bcx.ins().band_imm(rhs, i64::from(lhs_ty.bits() - 1));\n-            let actual_shift = clif_intcast(fx, actual_shift, types::I8, false);\n             if signed {\n                 fx.bcx.ins().sshr(lhs, actual_shift)\n             } else {\n@@ -273,14 +271,17 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n                         let val_hi = fx.bcx.ins().umulhi(lhs, rhs);\n                         fx.bcx.ins().icmp_imm(IntCC::NotEqual, val_hi, 0)\n                     } else {\n+                        // Based on LLVM's instruction sequence for compiling\n+                        // a.checked_mul(b).is_some() to riscv64gc:\n+                        // mulh    a2, a0, a1\n+                        // mul     a0, a0, a1\n+                        // srai    a0, a0, 63\n+                        // xor     a0, a0, a2\n+                        // snez    a0, a0\n                         let val_hi = fx.bcx.ins().smulhi(lhs, rhs);\n-                        let not_all_zero = fx.bcx.ins().icmp_imm(IntCC::NotEqual, val_hi, 0);\n-                        let not_all_ones = fx.bcx.ins().icmp_imm(\n-                            IntCC::NotEqual,\n-                            val_hi,\n-                            u64::try_from((1u128 << ty.bits()) - 1).unwrap() as i64,\n-                        );\n-                        fx.bcx.ins().band(not_all_zero, not_all_ones)\n+                        let val_sign = fx.bcx.ins().sshr_imm(val, i64::from(ty.bits() - 1));\n+                        let xor = fx.bcx.ins().bxor(val_hi, val_sign);\n+                        fx.bcx.ins().icmp_imm(IntCC::NotEqual, xor, 0)\n                     };\n                     (val, has_overflow)\n                 }\n@@ -387,7 +388,7 @@ pub(crate) fn codegen_ptr_binop<'tcx>(\n                 let lhs = in_lhs.load_scalar(fx);\n                 let rhs = in_rhs.load_scalar(fx);\n \n-                return codegen_compare_bin_op(fx, bin_op, false, lhs, rhs);\n+                codegen_compare_bin_op(fx, bin_op, false, lhs, rhs)\n             }\n             BinOp::Offset => {\n                 let pointee_ty = in_lhs.layout().ty.builtin_deref(true).unwrap().ty;\n@@ -396,10 +397,10 @@ pub(crate) fn codegen_ptr_binop<'tcx>(\n                 let ptr_diff = fx.bcx.ins().imul_imm(offset, pointee_size as i64);\n                 let base_val = base.load_scalar(fx);\n                 let res = fx.bcx.ins().iadd(base_val, ptr_diff);\n-                return CValue::by_val(res, base.layout());\n+                CValue::by_val(res, base.layout())\n             }\n             _ => unreachable!(\"{:?}({:?}, {:?})\", bin_op, in_lhs, in_rhs),\n-        };\n+        }\n     } else {\n         let (lhs_ptr, lhs_extra) = in_lhs.load_scalar_pair(fx);\n         let (rhs_ptr, rhs_extra) = in_rhs.load_scalar_pair(fx);"}, {"sha": "ca9ff15ec10ffee9967d95ccf086ab0e345ba1fe", "filename": "compiler/rustc_codegen_cranelift/src/optimize/code_layout.rs", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3b2b5b2914d40aa011d189bfe546084cdee53dbe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fcode_layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b2b5b2914d40aa011d189bfe546084cdee53dbe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fcode_layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fcode_layout.rs?ref=3b2b5b2914d40aa011d189bfe546084cdee53dbe", "patch": "@@ -1,34 +0,0 @@\n-//! This optimization moves cold code to the end of the function.\n-//!\n-//! Some code is executed much less often than other code. For example panicking or the\n-//! landingpads for unwinding. By moving this cold code to the end of the function the average\n-//! amount of jumps is reduced and the code locality is improved.\n-//!\n-//! # Undefined behaviour\n-//!\n-//! This optimization doesn't assume anything that isn't already assumed by Cranelift itself.\n-\n-use crate::prelude::*;\n-\n-pub(super) fn optimize_function(ctx: &mut Context, cold_blocks: &EntitySet<Block>) {\n-    // FIXME Move the block in place instead of remove and append once\n-    // bytecodealliance/cranelift#1339 is implemented.\n-\n-    let mut block_insts = FxHashMap::default();\n-    for block in cold_blocks.keys().filter(|&block| cold_blocks.contains(block)) {\n-        let insts = ctx.func.layout.block_insts(block).collect::<Vec<_>>();\n-        for &inst in &insts {\n-            ctx.func.layout.remove_inst(inst);\n-        }\n-        block_insts.insert(block, insts);\n-        ctx.func.layout.remove_block(block);\n-    }\n-\n-    // And then append them at the back again.\n-    for block in cold_blocks.keys().filter(|&block| cold_blocks.contains(block)) {\n-        ctx.func.layout.append_block(block);\n-        for inst in block_insts.remove(&block).unwrap() {\n-            ctx.func.layout.append_inst(inst, block);\n-        }\n-    }\n-}"}, {"sha": "137fb5f77313cbae7d39c54291a383fa9e7e2357", "filename": "compiler/rustc_codegen_cranelift/src/optimize/mod.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fmod.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -2,29 +2,16 @@\n \n use crate::prelude::*;\n \n-mod code_layout;\n pub(crate) mod peephole;\n-mod stack2reg;\n \n pub(crate) fn optimize_function<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     instance: Instance<'tcx>,\n     ctx: &mut Context,\n-    cold_blocks: &EntitySet<Block>,\n     clif_comments: &mut crate::pretty_clif::CommentWriter,\n ) {\n-    // The code_layout optimization is very cheap.\n-    self::code_layout::optimize_function(ctx, cold_blocks);\n+    // FIXME classify optimizations over opt levels once we have more\n \n-    if tcx.sess.opts.optimize == rustc_session::config::OptLevel::No {\n-        return; // FIXME classify optimizations over opt levels\n-    }\n-\n-    // FIXME(#1142) stack2reg miscompiles lewton\n-    if false {\n-        self::stack2reg::optimize_function(ctx, clif_comments);\n-    }\n-\n-    crate::pretty_clif::write_clif_file(tcx, \"stack2reg\", None, instance, &ctx, &*clif_comments);\n+    crate::pretty_clif::write_clif_file(tcx, \"preopt\", None, instance, &ctx, &*clif_comments);\n     crate::base::verify_func(tcx, &*clif_comments, &ctx.func);\n }"}, {"sha": "d111f37f5e4552a3d582636e73026b07f31364ac", "filename": "compiler/rustc_codegen_cranelift/src/optimize/stack2reg.rs", "status": "removed", "additions": 0, "deletions": 481, "changes": 481, "blob_url": "https://github.com/rust-lang/rust/blob/3b2b5b2914d40aa011d189bfe546084cdee53dbe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fstack2reg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b2b5b2914d40aa011d189bfe546084cdee53dbe/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fstack2reg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fstack2reg.rs?ref=3b2b5b2914d40aa011d189bfe546084cdee53dbe", "patch": "@@ -1,481 +0,0 @@\n-//! This optimization replaces stack accesses with SSA variables and removes dead stores when possible.\n-//!\n-//! # Undefined behaviour\n-//!\n-//! This optimization is based on the assumption that stack slots which don't have their address\n-//! leaked through `stack_addr` are only accessed using `stack_load` and `stack_store` in the\n-//! function which has the stack slots. This optimization also assumes that stack slot accesses\n-//! are never out of bounds. If these assumptions are not correct, then this optimization may remove\n-//! `stack_store` instruction incorrectly, or incorrectly use a previously stored value as the value\n-//! being loaded by a `stack_load`.\n-\n-use std::collections::BTreeMap;\n-use std::fmt;\n-use std::ops::Not;\n-\n-use rustc_data_structures::fx::FxHashSet;\n-\n-use cranelift_codegen::cursor::{Cursor, FuncCursor};\n-use cranelift_codegen::ir::immediates::Offset32;\n-use cranelift_codegen::ir::{InstructionData, Opcode, ValueDef};\n-\n-use crate::prelude::*;\n-\n-/// Workaround for `StackSlot` not implementing `Ord`.\n-#[derive(Copy, Clone, PartialEq, Eq)]\n-struct OrdStackSlot(StackSlot);\n-\n-impl fmt::Debug for OrdStackSlot {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{:?}\", self.0)\n-    }\n-}\n-\n-impl PartialOrd for OrdStackSlot {\n-    fn partial_cmp(&self, rhs: &Self) -> Option<std::cmp::Ordering> {\n-        self.0.as_u32().partial_cmp(&rhs.0.as_u32())\n-    }\n-}\n-\n-impl Ord for OrdStackSlot {\n-    fn cmp(&self, rhs: &Self) -> std::cmp::Ordering {\n-        self.0.as_u32().cmp(&rhs.0.as_u32())\n-    }\n-}\n-\n-#[derive(Debug, Default)]\n-struct StackSlotUsage {\n-    stack_addr: FxHashSet<Inst>,\n-    stack_load: FxHashSet<Inst>,\n-    stack_store: FxHashSet<Inst>,\n-}\n-\n-impl StackSlotUsage {\n-    fn potential_stores_for_load(&self, ctx: &Context, load: Inst) -> Vec<Inst> {\n-        self.stack_store\n-            .iter()\n-            .cloned()\n-            .filter(|&store| {\n-                match spatial_overlap(&ctx.func, store, load) {\n-                    SpatialOverlap::No => false, // Can never be the source of the loaded value.\n-                    SpatialOverlap::Partial | SpatialOverlap::Full => true,\n-                }\n-            })\n-            .filter(|&store| {\n-                match temporal_order(ctx, store, load) {\n-                    TemporalOrder::NeverBefore => false, // Can never be the source of the loaded value.\n-                    TemporalOrder::MaybeBefore | TemporalOrder::DefinitivelyBefore => true,\n-                }\n-            })\n-            .collect::<Vec<Inst>>()\n-    }\n-\n-    fn potential_loads_of_store(&self, ctx: &Context, store: Inst) -> Vec<Inst> {\n-        self.stack_load\n-            .iter()\n-            .cloned()\n-            .filter(|&load| {\n-                match spatial_overlap(&ctx.func, store, load) {\n-                    SpatialOverlap::No => false, // Can never be the source of the loaded value.\n-                    SpatialOverlap::Partial | SpatialOverlap::Full => true,\n-                }\n-            })\n-            .filter(|&load| {\n-                match temporal_order(ctx, store, load) {\n-                    TemporalOrder::NeverBefore => false, // Can never be the source of the loaded value.\n-                    TemporalOrder::MaybeBefore | TemporalOrder::DefinitivelyBefore => true,\n-                }\n-            })\n-            .collect::<Vec<Inst>>()\n-    }\n-\n-    fn remove_unused_stack_addr(func: &mut Function, inst: Inst) {\n-        func.dfg.detach_results(inst);\n-        func.dfg.replace(inst).nop();\n-    }\n-\n-    fn remove_unused_load(func: &mut Function, load: Inst) {\n-        func.dfg.detach_results(load);\n-        func.dfg.replace(load).nop();\n-    }\n-\n-    fn remove_dead_store(&mut self, func: &mut Function, store: Inst) {\n-        func.dfg.replace(store).nop();\n-        self.stack_store.remove(&store);\n-    }\n-\n-    fn change_load_to_alias(&mut self, func: &mut Function, load: Inst, value: Value) {\n-        let loaded_value = func.dfg.inst_results(load)[0];\n-        let loaded_type = func.dfg.value_type(loaded_value);\n-\n-        if func.dfg.value_type(value) == loaded_type {\n-            func.dfg.detach_results(load);\n-            func.dfg.replace(load).nop();\n-            func.dfg.change_to_alias(loaded_value, value);\n-        } else {\n-            func.dfg.replace(load).bitcast(loaded_type, value);\n-        }\n-\n-        self.stack_load.remove(&load);\n-    }\n-}\n-\n-struct OptimizeContext<'a> {\n-    ctx: &'a mut Context,\n-    stack_slot_usage_map: BTreeMap<OrdStackSlot, StackSlotUsage>,\n-}\n-\n-impl<'a> OptimizeContext<'a> {\n-    fn for_context(ctx: &'a mut Context) -> Self {\n-        ctx.flowgraph(); // Compute cfg and domtree.\n-\n-        // Record all stack_addr, stack_load and stack_store instructions.\n-        let mut stack_slot_usage_map = BTreeMap::<OrdStackSlot, StackSlotUsage>::new();\n-\n-        let mut cursor = FuncCursor::new(&mut ctx.func);\n-        while let Some(_block) = cursor.next_block() {\n-            while let Some(inst) = cursor.next_inst() {\n-                match cursor.func.dfg[inst] {\n-                    InstructionData::StackLoad {\n-                        opcode: Opcode::StackAddr,\n-                        stack_slot,\n-                        offset: _,\n-                    } => {\n-                        stack_slot_usage_map\n-                            .entry(OrdStackSlot(stack_slot))\n-                            .or_insert_with(StackSlotUsage::default)\n-                            .stack_addr\n-                            .insert(inst);\n-                    }\n-                    InstructionData::StackLoad {\n-                        opcode: Opcode::StackLoad,\n-                        stack_slot,\n-                        offset: _,\n-                    } => {\n-                        stack_slot_usage_map\n-                            .entry(OrdStackSlot(stack_slot))\n-                            .or_insert_with(StackSlotUsage::default)\n-                            .stack_load\n-                            .insert(inst);\n-                    }\n-                    InstructionData::StackStore {\n-                        opcode: Opcode::StackStore,\n-                        arg: _,\n-                        stack_slot,\n-                        offset: _,\n-                    } => {\n-                        stack_slot_usage_map\n-                            .entry(OrdStackSlot(stack_slot))\n-                            .or_insert_with(StackSlotUsage::default)\n-                            .stack_store\n-                            .insert(inst);\n-                    }\n-                    _ => {}\n-                }\n-            }\n-        }\n-\n-        OptimizeContext { ctx, stack_slot_usage_map }\n-    }\n-}\n-\n-pub(super) fn optimize_function(\n-    ctx: &mut Context,\n-    #[cfg_attr(not(debug_assertions), allow(unused_variables))]\n-    clif_comments: &mut crate::pretty_clif::CommentWriter,\n-) {\n-    combine_stack_addr_with_load_store(&mut ctx.func);\n-\n-    let mut opt_ctx = OptimizeContext::for_context(ctx);\n-\n-    // FIXME Repeat following instructions until fixpoint.\n-\n-    remove_unused_stack_addr_and_stack_load(&mut opt_ctx);\n-\n-    #[cfg(debug_assertions)]\n-    {\n-        for (&OrdStackSlot(stack_slot), usage) in &opt_ctx.stack_slot_usage_map {\n-            clif_comments.add_comment(stack_slot, format!(\"used by: {:?}\", usage));\n-        }\n-    }\n-\n-    for (stack_slot, users) in opt_ctx.stack_slot_usage_map.iter_mut() {\n-        if users.stack_addr.is_empty().not() {\n-            // Stack addr leaked; there may be unknown loads and stores.\n-            // FIXME use stacked borrows to optimize\n-            continue;\n-        }\n-\n-        for load in users.stack_load.clone().into_iter() {\n-            let potential_stores = users.potential_stores_for_load(&opt_ctx.ctx, load);\n-\n-            #[cfg(debug_assertions)]\n-            for &store in &potential_stores {\n-                clif_comments.add_comment(\n-                    load,\n-                    format!(\n-                        \"Potential store -> load forwarding {} -> {} ({:?}, {:?})\",\n-                        opt_ctx.ctx.func.dfg.display_inst(store, None),\n-                        opt_ctx.ctx.func.dfg.display_inst(load, None),\n-                        spatial_overlap(&opt_ctx.ctx.func, store, load),\n-                        temporal_order(&opt_ctx.ctx, store, load),\n-                    ),\n-                );\n-            }\n-\n-            match *potential_stores {\n-                [] => {\n-                    #[cfg(debug_assertions)]\n-                    clif_comments\n-                        .add_comment(load, \"[BUG?] Reading uninitialized memory\".to_string());\n-                }\n-                [store]\n-                    if spatial_overlap(&opt_ctx.ctx.func, store, load) == SpatialOverlap::Full\n-                        && temporal_order(&opt_ctx.ctx, store, load)\n-                            == TemporalOrder::DefinitivelyBefore =>\n-                {\n-                    // Only one store could have been the origin of the value.\n-                    let stored_value = opt_ctx.ctx.func.dfg.inst_args(store)[0];\n-\n-                    #[cfg(debug_assertions)]\n-                    clif_comments\n-                        .add_comment(load, format!(\"Store to load forward {} -> {}\", store, load));\n-\n-                    users.change_load_to_alias(&mut opt_ctx.ctx.func, load, stored_value);\n-                }\n-                _ => {} // FIXME implement this\n-            }\n-        }\n-\n-        for store in users.stack_store.clone().into_iter() {\n-            let potential_loads = users.potential_loads_of_store(&opt_ctx.ctx, store);\n-\n-            #[cfg(debug_assertions)]\n-            for &load in &potential_loads {\n-                clif_comments.add_comment(\n-                    store,\n-                    format!(\n-                        \"Potential load from store {} <- {} ({:?}, {:?})\",\n-                        opt_ctx.ctx.func.dfg.display_inst(load, None),\n-                        opt_ctx.ctx.func.dfg.display_inst(store, None),\n-                        spatial_overlap(&opt_ctx.ctx.func, store, load),\n-                        temporal_order(&opt_ctx.ctx, store, load),\n-                    ),\n-                );\n-            }\n-\n-            if potential_loads.is_empty() {\n-                // Never loaded; can safely remove all stores and the stack slot.\n-                // FIXME also remove stores when there is always a next store before a load.\n-\n-                #[cfg(debug_assertions)]\n-                clif_comments.add_comment(\n-                    store,\n-                    format!(\n-                        \"Remove dead stack store {} of {}\",\n-                        opt_ctx.ctx.func.dfg.display_inst(store, None),\n-                        stack_slot.0\n-                    ),\n-                );\n-\n-                users.remove_dead_store(&mut opt_ctx.ctx.func, store);\n-            }\n-        }\n-\n-        if users.stack_store.is_empty() && users.stack_load.is_empty() {\n-            opt_ctx.ctx.func.stack_slots[stack_slot.0].size = 0;\n-        }\n-    }\n-}\n-\n-fn combine_stack_addr_with_load_store(func: &mut Function) {\n-    // Turn load and store into stack_load and stack_store when possible.\n-    let mut cursor = FuncCursor::new(func);\n-    while let Some(_block) = cursor.next_block() {\n-        while let Some(inst) = cursor.next_inst() {\n-            match cursor.func.dfg[inst] {\n-                InstructionData::Load { opcode: Opcode::Load, arg: addr, flags: _, offset } => {\n-                    if cursor.func.dfg.ctrl_typevar(inst) == types::I128\n-                        || cursor.func.dfg.ctrl_typevar(inst).is_vector()\n-                    {\n-                        continue; // WORKAROUD: stack_load.i128 not yet implemented\n-                    }\n-                    if let Some((stack_slot, stack_addr_offset)) =\n-                        try_get_stack_slot_and_offset_for_addr(cursor.func, addr)\n-                    {\n-                        if let Some(combined_offset) = offset.try_add_i64(stack_addr_offset.into())\n-                        {\n-                            let ty = cursor.func.dfg.ctrl_typevar(inst);\n-                            cursor.func.dfg.replace(inst).stack_load(\n-                                ty,\n-                                stack_slot,\n-                                combined_offset,\n-                            );\n-                        }\n-                    }\n-                }\n-                InstructionData::Store {\n-                    opcode: Opcode::Store,\n-                    args: [value, addr],\n-                    flags: _,\n-                    offset,\n-                } => {\n-                    if cursor.func.dfg.ctrl_typevar(inst) == types::I128\n-                        || cursor.func.dfg.ctrl_typevar(inst).is_vector()\n-                    {\n-                        continue; // WORKAROUND: stack_store.i128 not yet implemented\n-                    }\n-                    if let Some((stack_slot, stack_addr_offset)) =\n-                        try_get_stack_slot_and_offset_for_addr(cursor.func, addr)\n-                    {\n-                        if let Some(combined_offset) = offset.try_add_i64(stack_addr_offset.into())\n-                        {\n-                            cursor.func.dfg.replace(inst).stack_store(\n-                                value,\n-                                stack_slot,\n-                                combined_offset,\n-                            );\n-                        }\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n-    }\n-}\n-\n-fn remove_unused_stack_addr_and_stack_load(opt_ctx: &mut OptimizeContext<'_>) {\n-    // FIXME incrementally rebuild on each call?\n-    let mut stack_addr_load_insts_users = FxHashMap::<Inst, FxHashSet<Inst>>::default();\n-\n-    let mut cursor = FuncCursor::new(&mut opt_ctx.ctx.func);\n-    while let Some(_block) = cursor.next_block() {\n-        while let Some(inst) = cursor.next_inst() {\n-            for &arg in cursor.func.dfg.inst_args(inst) {\n-                if let ValueDef::Result(arg_origin, 0) = cursor.func.dfg.value_def(arg) {\n-                    match cursor.func.dfg[arg_origin].opcode() {\n-                        Opcode::StackAddr | Opcode::StackLoad => {\n-                            stack_addr_load_insts_users\n-                                .entry(arg_origin)\n-                                .or_insert_with(FxHashSet::default)\n-                                .insert(inst);\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    #[cfg(debug_assertions)]\n-    for inst in stack_addr_load_insts_users.keys() {\n-        let mut is_recorded_stack_addr_or_stack_load = false;\n-        for stack_slot_users in opt_ctx.stack_slot_usage_map.values() {\n-            is_recorded_stack_addr_or_stack_load |= stack_slot_users.stack_addr.contains(inst)\n-                || stack_slot_users.stack_load.contains(inst);\n-        }\n-        assert!(is_recorded_stack_addr_or_stack_load);\n-    }\n-\n-    // Replace all unused stack_addr and stack_load instructions with nop.\n-    let mut func = &mut opt_ctx.ctx.func;\n-\n-    for stack_slot_users in opt_ctx.stack_slot_usage_map.values_mut() {\n-        stack_slot_users\n-            .stack_addr\n-            .drain_filter(|inst| {\n-                stack_addr_load_insts_users.get(inst).map(|users| users.is_empty()).unwrap_or(true)\n-            })\n-            .for_each(|inst| StackSlotUsage::remove_unused_stack_addr(&mut func, inst));\n-\n-        stack_slot_users\n-            .stack_load\n-            .drain_filter(|inst| {\n-                stack_addr_load_insts_users.get(inst).map(|users| users.is_empty()).unwrap_or(true)\n-            })\n-            .for_each(|inst| StackSlotUsage::remove_unused_load(&mut func, inst));\n-    }\n-}\n-\n-fn try_get_stack_slot_and_offset_for_addr(\n-    func: &Function,\n-    addr: Value,\n-) -> Option<(StackSlot, Offset32)> {\n-    if let ValueDef::Result(addr_inst, 0) = func.dfg.value_def(addr) {\n-        if let InstructionData::StackLoad { opcode: Opcode::StackAddr, stack_slot, offset } =\n-            func.dfg[addr_inst]\n-        {\n-            return Some((stack_slot, offset));\n-        }\n-    }\n-    None\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-enum SpatialOverlap {\n-    No,\n-    Partial,\n-    Full,\n-}\n-\n-fn spatial_overlap(func: &Function, src: Inst, dest: Inst) -> SpatialOverlap {\n-    fn inst_info(func: &Function, inst: Inst) -> (StackSlot, Offset32, u32) {\n-        match func.dfg[inst] {\n-            InstructionData::StackLoad { opcode: Opcode::StackAddr, stack_slot, offset }\n-            | InstructionData::StackLoad { opcode: Opcode::StackLoad, stack_slot, offset }\n-            | InstructionData::StackStore {\n-                opcode: Opcode::StackStore,\n-                stack_slot,\n-                offset,\n-                arg: _,\n-            } => (stack_slot, offset, func.dfg.ctrl_typevar(inst).bytes()),\n-            _ => unreachable!(\"{:?}\", func.dfg[inst]),\n-        }\n-    }\n-\n-    debug_assert_ne!(src, dest);\n-\n-    let (src_ss, src_offset, src_size) = inst_info(func, src);\n-    let (dest_ss, dest_offset, dest_size) = inst_info(func, dest);\n-\n-    if src_ss != dest_ss {\n-        return SpatialOverlap::No;\n-    }\n-\n-    if src_offset == dest_offset && src_size == dest_size {\n-        return SpatialOverlap::Full;\n-    }\n-\n-    let src_end: i64 = src_offset.try_add_i64(i64::from(src_size)).unwrap().into();\n-    let dest_end: i64 = dest_offset.try_add_i64(i64::from(dest_size)).unwrap().into();\n-    if src_end <= dest_offset.into() || dest_end <= src_offset.into() {\n-        return SpatialOverlap::No;\n-    }\n-\n-    SpatialOverlap::Partial\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-enum TemporalOrder {\n-    /// `src` will never be executed before `dest`.\n-    NeverBefore,\n-\n-    /// `src` may be executed before `dest`.\n-    MaybeBefore,\n-\n-    /// `src` will always be executed before `dest`.\n-    /// There may still be other instructions in between.\n-    DefinitivelyBefore,\n-}\n-\n-fn temporal_order(ctx: &Context, src: Inst, dest: Inst) -> TemporalOrder {\n-    debug_assert_ne!(src, dest);\n-\n-    if ctx.domtree.dominates(src, dest, &ctx.func.layout) {\n-        TemporalOrder::DefinitivelyBefore\n-    } else if ctx.domtree.dominates(src, dest, &ctx.func.layout) {\n-        TemporalOrder::NeverBefore\n-    } else {\n-        TemporalOrder::MaybeBefore\n-    }\n-}"}, {"sha": "31d827f83bfab94543e32a1ffbe0f3918b6d62fd", "filename": "compiler/rustc_codegen_cranelift/src/pointer.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpointer.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -39,8 +39,7 @@ impl Pointer {\n         Pointer { base: PointerBase::Dangling(align), offset: Offset32::new(0) }\n     }\n \n-    #[cfg(debug_assertions)]\n-    pub(crate) fn base_and_offset(self) -> (PointerBase, Offset32) {\n+    pub(crate) fn debug_base_and_offset(self) -> (PointerBase, Offset32) {\n         (self.base, self.offset)\n     }\n "}, {"sha": "cd8c5b516083611ee316c93c816c523d29863fa3", "filename": "compiler/rustc_codegen_cranelift/src/pretty_clif.rs", "status": "modified", "additions": 40, "deletions": 35, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -69,13 +69,15 @@ use crate::prelude::*;\n \n #[derive(Debug)]\n pub(crate) struct CommentWriter {\n+    enabled: bool,\n     global_comments: Vec<String>,\n     entity_comments: FxHashMap<AnyEntity, String>,\n }\n \n impl CommentWriter {\n     pub(crate) fn new<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> Self {\n-        let global_comments = if cfg!(debug_assertions) {\n+        let enabled = should_write_ir(tcx);\n+        let global_comments = if enabled {\n             vec![\n                 format!(\"symbol {}\", tcx.symbol_name(instance).name),\n                 format!(\"instance {:?}\", instance),\n@@ -86,13 +88,17 @@ impl CommentWriter {\n             vec![]\n         };\n \n-        CommentWriter { global_comments, entity_comments: FxHashMap::default() }\n+        CommentWriter { enabled, global_comments, entity_comments: FxHashMap::default() }\n     }\n }\n \n-#[cfg(debug_assertions)]\n impl CommentWriter {\n+    pub(crate) fn enabled(&self) -> bool {\n+        self.enabled\n+    }\n+\n     pub(crate) fn add_global_comment<S: Into<String>>(&mut self, comment: S) {\n+        debug_assert!(self.enabled);\n         self.global_comments.push(comment.into());\n     }\n \n@@ -101,6 +107,8 @@ impl CommentWriter {\n         entity: E,\n         comment: S,\n     ) {\n+        debug_assert!(self.enabled);\n+\n         use std::collections::hash_map::Entry;\n         match self.entity_comments.entry(entity.into()) {\n             Entry::Occupied(mut occ) => {\n@@ -179,7 +187,6 @@ impl FuncWriter for &'_ CommentWriter {\n     }\n }\n \n-#[cfg(debug_assertions)]\n impl FunctionCx<'_, '_, '_> {\n     pub(crate) fn add_global_comment<S: Into<String>>(&mut self, comment: S) {\n         self.clif_comments.add_global_comment(comment);\n@@ -198,29 +205,26 @@ pub(crate) fn should_write_ir(tcx: TyCtxt<'_>) -> bool {\n     tcx.sess.opts.output_types.contains_key(&OutputType::LlvmAssembly)\n }\n \n-pub(crate) fn write_ir_file<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    name: &str,\n+pub(crate) fn write_ir_file(\n+    tcx: TyCtxt<'_>,\n+    name: impl FnOnce() -> String,\n     write: impl FnOnce(&mut dyn Write) -> std::io::Result<()>,\n ) {\n     if !should_write_ir(tcx) {\n         return;\n     }\n \n-    let clif_output_dir = tcx.output_filenames(LOCAL_CRATE).with_extension(\"clif\");\n+    let clif_output_dir = tcx.output_filenames(()).with_extension(\"clif\");\n \n     match std::fs::create_dir(&clif_output_dir) {\n         Ok(()) => {}\n         Err(err) if err.kind() == std::io::ErrorKind::AlreadyExists => {}\n         res @ Err(_) => res.unwrap(),\n     }\n \n-    let clif_file_name = clif_output_dir.join(name);\n+    let clif_file_name = clif_output_dir.join(name());\n \n-    let res: std::io::Result<()> = try {\n-        let mut file = std::fs::File::create(clif_file_name)?;\n-        write(&mut file)?;\n-    };\n+    let res = std::fs::File::create(clif_file_name).and_then(|mut file| write(&mut file));\n     if let Err(err) = res {\n         tcx.sess.warn(&format!(\"error writing ir file: {}\", err));\n     }\n@@ -234,30 +238,31 @@ pub(crate) fn write_clif_file<'tcx>(\n     context: &cranelift_codegen::Context,\n     mut clif_comments: &CommentWriter,\n ) {\n-    write_ir_file(tcx, &format!(\"{}.{}.clif\", tcx.symbol_name(instance).name, postfix), |file| {\n-        let value_ranges =\n-            isa.map(|isa| context.build_value_labels_ranges(isa).expect(\"value location ranges\"));\n+    write_ir_file(\n+        tcx,\n+        || format!(\"{}.{}.clif\", tcx.symbol_name(instance).name, postfix),\n+        |file| {\n+            let value_ranges = isa\n+                .map(|isa| context.build_value_labels_ranges(isa).expect(\"value location ranges\"));\n \n-        let mut clif = String::new();\n-        cranelift_codegen::write::decorate_function(\n-            &mut clif_comments,\n-            &mut clif,\n-            &context.func,\n-            &DisplayFunctionAnnotations {\n-                isa: Some(&*crate::build_isa(tcx.sess)),\n-                value_ranges: value_ranges.as_ref(),\n-            },\n-        )\n-        .unwrap();\n+            let mut clif = String::new();\n+            cranelift_codegen::write::decorate_function(\n+                &mut clif_comments,\n+                &mut clif,\n+                &context.func,\n+                &DisplayFunctionAnnotations { isa, value_ranges: value_ranges.as_ref() },\n+            )\n+            .unwrap();\n \n-        writeln!(file, \"test compile\")?;\n-        writeln!(file, \"set is_pic\")?;\n-        writeln!(file, \"set enable_simd\")?;\n-        writeln!(file, \"target {} haswell\", crate::target_triple(tcx.sess))?;\n-        writeln!(file)?;\n-        file.write_all(clif.as_bytes())?;\n-        Ok(())\n-    });\n+            writeln!(file, \"test compile\")?;\n+            writeln!(file, \"set is_pic\")?;\n+            writeln!(file, \"set enable_simd\")?;\n+            writeln!(file, \"target {} haswell\", crate::target_triple(tcx.sess))?;\n+            writeln!(file)?;\n+            file.write_all(clif.as_bytes())?;\n+            Ok(())\n+        },\n+    );\n }\n \n impl fmt::Debug for FunctionCx<'_, '_, '_> {"}, {"sha": "819c8b51558a051321ef9f1670c2771f6937b301", "filename": "compiler/rustc_codegen_cranelift/src/trap.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -4,7 +4,6 @@ use crate::prelude::*;\n \n fn codegen_print(fx: &mut FunctionCx<'_, '_, '_>, msg: &str) {\n     let puts = fx\n-        .cx\n         .module\n         .declare_function(\n             \"puts\",\n@@ -16,14 +15,12 @@ fn codegen_print(fx: &mut FunctionCx<'_, '_, '_>, msg: &str) {\n             },\n         )\n         .unwrap();\n-    let puts = fx.cx.module.declare_func_in_func(puts, &mut fx.bcx.func);\n-    #[cfg(debug_assertions)]\n-    {\n+    let puts = fx.module.declare_func_in_func(puts, &mut fx.bcx.func);\n+    if fx.clif_comments.enabled() {\n         fx.add_comment(puts, \"puts\");\n     }\n \n-    let symbol_name = fx.tcx.symbol_name(fx.instance);\n-    let real_msg = format!(\"trap at {:?} ({}): {}\\0\", fx.instance, symbol_name, msg);\n+    let real_msg = format!(\"trap at {:?} ({}): {}\\0\", fx.instance, fx.symbol_name, msg);\n     let msg_ptr = fx.anonymous_str(\"trap\", &real_msg);\n     fx.bcx.ins().call(puts, &[msg_ptr]);\n }"}, {"sha": "9a572c3501f925b7adc726c64e30755e9ade2fef", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -2,7 +2,6 @@\n \n use crate::prelude::*;\n \n-use cranelift_codegen::entity::EntityRef;\n use cranelift_codegen::ir::immediates::Offset32;\n \n fn codegen_field<'tcx>(\n@@ -414,7 +413,7 @@ impl<'tcx> CPlace<'tcx> {\n         self,\n         fx: &mut FunctionCx<'_, '_, 'tcx>,\n         from: CValue<'tcx>,\n-        #[cfg_attr(not(debug_assertions), allow(unused_variables))] method: &'static str,\n+        method: &'static str,\n     ) {\n         fn transmute_value<'tcx>(\n             fx: &mut FunctionCx<'_, '_, 'tcx>,\n@@ -462,8 +461,7 @@ impl<'tcx> CPlace<'tcx> {\n \n         assert_eq!(self.layout().size, from.layout().size);\n \n-        #[cfg(debug_assertions)]\n-        {\n+        if fx.clif_comments.enabled() {\n             use cranelift_codegen::cursor::{Cursor, CursorPosition};\n             let cur_block = match fx.bcx.cursor().position() {\n                 CursorPosition::After(block) => block,\n@@ -556,7 +554,7 @@ impl<'tcx> CPlace<'tcx> {\n                 let src_align = src_layout.align.abi.bytes() as u8;\n                 let dst_align = dst_layout.align.abi.bytes() as u8;\n                 fx.bcx.emit_small_memory_copy(\n-                    fx.cx.module.target_config(),\n+                    fx.module.target_config(),\n                     to_addr,\n                     from_addr,\n                     size,\n@@ -707,6 +705,19 @@ pub(crate) fn assert_assignable<'tcx>(\n             }\n             // dyn for<'r> Trait<'r> -> dyn Trait<'_> is allowed\n         }\n+        (&ty::Adt(adt_def_a, substs_a), &ty::Adt(adt_def_b, substs_b))\n+            if adt_def_a.did == adt_def_b.did =>\n+        {\n+            let mut types_a = substs_a.types();\n+            let mut types_b = substs_b.types();\n+            loop {\n+                match (types_a.next(), types_b.next()) {\n+                    (Some(a), Some(b)) => assert_assignable(fx, a, b),\n+                    (None, None) => return,\n+                    (Some(_), None) | (None, Some(_)) => panic!(\"{:#?}/{:#?}\", from_ty, to_ty),\n+                }\n+            }\n+        }\n         _ => {\n             assert_eq!(\n                 from_ty, to_ty,"}, {"sha": "bbf07ffc85dbdb7c2a6bd970a735ea69f180eb2b", "filename": "compiler/rustc_codegen_cranelift/src/vtable.rs", "status": "modified", "additions": 10, "deletions": 28, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -1,6 +1,6 @@\n //! Codegen vtables and vtable accesses.\n //!\n-//! See librustc_codegen_llvm/meth.rs for reference\n+//! See `rustc_codegen_ssa/src/meth.rs` for reference.\n // FIXME dedup this logic between miri, cg_llvm and cg_clif\n \n use crate::prelude::*;\n@@ -72,15 +72,15 @@ pub(crate) fn get_vtable<'tcx>(\n     layout: TyAndLayout<'tcx>,\n     trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n ) -> Value {\n-    let data_id = if let Some(data_id) = fx.cx.vtables.get(&(layout.ty, trait_ref)) {\n+    let data_id = if let Some(data_id) = fx.vtables.get(&(layout.ty, trait_ref)) {\n         *data_id\n     } else {\n         let data_id = build_vtable(fx, layout, trait_ref);\n-        fx.cx.vtables.insert((layout.ty, trait_ref), data_id);\n+        fx.vtables.insert((layout.ty, trait_ref), data_id);\n         data_id\n     };\n \n-    let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+    let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n     fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n }\n \n@@ -94,7 +94,7 @@ fn build_vtable<'tcx>(\n \n     let drop_in_place_fn = import_function(\n         tcx,\n-        fx.cx.module,\n+        fx.module,\n         Instance::resolve_drop_in_place(tcx, layout.ty).polymorphize(fx.tcx),\n     );\n \n@@ -111,7 +111,7 @@ fn build_vtable<'tcx>(\n         opt_mth.map(|(def_id, substs)| {\n             import_function(\n                 tcx,\n-                fx.cx.module,\n+                fx.module,\n                 Instance::resolve_for_vtable(tcx, ParamEnv::reveal_all(), def_id, substs)\n                     .unwrap()\n                     .polymorphize(fx.tcx),\n@@ -132,34 +132,16 @@ fn build_vtable<'tcx>(\n \n     for (i, component) in components.into_iter().enumerate() {\n         if let Some(func_id) = component {\n-            let func_ref = fx.cx.module.declare_func_in_data(func_id, &mut data_ctx);\n+            let func_ref = fx.module.declare_func_in_data(func_id, &mut data_ctx);\n             data_ctx.write_function_addr((i * usize_size) as u32, func_ref);\n         }\n     }\n \n     data_ctx.set_align(fx.tcx.data_layout.pointer_align.pref.bytes());\n \n-    let data_id = fx\n-        .cx\n-        .module\n-        .declare_data(\n-            &format!(\n-                \"__vtable.{}.for.{:?}.{}\",\n-                trait_ref\n-                    .as_ref()\n-                    .map(|trait_ref| format!(\"{:?}\", trait_ref.skip_binder()).into())\n-                    .unwrap_or(std::borrow::Cow::Borrowed(\"???\")),\n-                layout.ty,\n-                fx.cx.vtables.len(),\n-            ),\n-            Linkage::Local,\n-            false,\n-            false,\n-        )\n-        .unwrap();\n-\n-    // FIXME don't duplicate definitions in lazy jit mode\n-    let _ = fx.cx.module.define_data(data_id, &data_ctx);\n+    let data_id = fx.module.declare_anonymous_data(false, false).unwrap();\n+\n+    fx.module.define_data(data_id, &data_ctx).unwrap();\n \n     data_id\n }"}, {"sha": "0aef77129d8c6c818f269e39ff1d0fd2ed999bf3", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 76, "deletions": 4, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -14,7 +14,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_middle::ty::layout::TyAndLayout;\n use rustc_middle::{bug, span_bug};\n-use rustc_span::{Pos, Span};\n+use rustc_span::{Pos, Span, Symbol};\n use rustc_target::abi::*;\n use rustc_target::asm::*;\n \n@@ -125,15 +125,39 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n \n         // Collect the types of output operands\n         let mut constraints = vec![];\n+        let mut clobbers = vec![];\n         let mut output_types = vec![];\n         let mut op_idx = FxHashMap::default();\n         for (idx, op) in operands.iter().enumerate() {\n             match *op {\n                 InlineAsmOperandRef::Out { reg, late, place } => {\n+                    let is_target_supported = |reg_class: InlineAsmRegClass| {\n+                        for &(_, feature) in reg_class.supported_types(asm_arch) {\n+                            if let Some(feature) = feature {\n+                                if self.tcx.sess.target_features.contains(&Symbol::intern(feature))\n+                                {\n+                                    return true;\n+                                }\n+                            } else {\n+                                // Register class is unconditionally supported\n+                                return true;\n+                            }\n+                        }\n+                        false\n+                    };\n+\n                     let mut layout = None;\n                     let ty = if let Some(ref place) = place {\n                         layout = Some(&place.layout);\n                         llvm_fixup_output_type(self.cx, reg.reg_class(), &place.layout)\n+                    } else if !is_target_supported(reg.reg_class()) {\n+                        // We turn discarded outputs into clobber constraints\n+                        // if the target feature needed by the register class is\n+                        // disabled. This is necessary otherwise LLVM will try\n+                        // to actually allocate a register for the dummy output.\n+                        assert!(matches!(reg, InlineAsmRegOrRegClass::Reg(_)));\n+                        clobbers.push(format!(\"~{}\", reg_to_llvm(reg, None)));\n+                        continue;\n                     } else {\n                         // If the output is discarded, we don't really care what\n                         // type is used. We're just using this to tell LLVM to\n@@ -244,6 +268,7 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             }\n         }\n \n+        constraints.append(&mut clobbers);\n         if !options.contains(InlineAsmOptions::PRESERVES_FLAGS) {\n             match asm_arch {\n                 InlineAsmArch::AArch64 | InlineAsmArch::Arm => {\n@@ -258,6 +283,7 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 }\n                 InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {}\n                 InlineAsmArch::Nvptx64 => {}\n+                InlineAsmArch::PowerPC | InlineAsmArch::PowerPC64 => {}\n                 InlineAsmArch::Hexagon => {}\n                 InlineAsmArch::Mips | InlineAsmArch::Mips64 => {}\n                 InlineAsmArch::SpirV => {}\n@@ -330,10 +356,49 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n }\n \n impl AsmMethods for CodegenCx<'ll, 'tcx> {\n-    fn codegen_global_asm(&self, ga: &hir::GlobalAsm) {\n-        let asm = ga.asm.as_str();\n+    fn codegen_global_asm(\n+        &self,\n+        template: &[InlineAsmTemplatePiece],\n+        operands: &[GlobalAsmOperandRef],\n+        options: InlineAsmOptions,\n+        _line_spans: &[Span],\n+    ) {\n+        let asm_arch = self.tcx.sess.asm_arch.unwrap();\n+\n+        // Default to Intel syntax on x86\n+        let intel_syntax = matches!(asm_arch, InlineAsmArch::X86 | InlineAsmArch::X86_64)\n+            && !options.contains(InlineAsmOptions::ATT_SYNTAX);\n+\n+        // Build the template string\n+        let mut template_str = String::new();\n+        if intel_syntax {\n+            template_str.push_str(\".intel_syntax\\n\");\n+        }\n+        for piece in template {\n+            match *piece {\n+                InlineAsmTemplatePiece::String(ref s) => template_str.push_str(s),\n+                InlineAsmTemplatePiece::Placeholder { operand_idx, modifier: _, span: _ } => {\n+                    match operands[operand_idx] {\n+                        GlobalAsmOperandRef::Const { ref string } => {\n+                            // Const operands get injected directly into the\n+                            // template. Note that we don't need to escape $\n+                            // here unlike normal inline assembly.\n+                            template_str.push_str(string);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        if intel_syntax {\n+            template_str.push_str(\"\\n.att_syntax\\n\");\n+        }\n+\n         unsafe {\n-            llvm::LLVMRustAppendModuleInlineAsm(self.llmod, asm.as_ptr().cast(), asm.len());\n+            llvm::LLVMRustAppendModuleInlineAsm(\n+                self.llmod,\n+                template_str.as_ptr().cast(),\n+                template_str.len(),\n+            );\n         }\n     }\n }\n@@ -515,6 +580,9 @@ fn reg_to_llvm(reg: InlineAsmRegOrRegClass, layout: Option<&TyAndLayout<'tcx>>)\n             InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg16) => \"h\",\n             InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg32) => \"r\",\n             InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg64) => \"l\",\n+            InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::reg_nonzero) => \"b\",\n+            InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::freg) => \"f\",\n             InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg) => \"r\",\n             InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => \"f\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::reg) => \"r\",\n@@ -565,6 +633,7 @@ fn modifier_to_llvm(\n         InlineAsmRegClass::Hexagon(_) => None,\n         InlineAsmRegClass::Mips(_) => None,\n         InlineAsmRegClass::Nvptx(_) => None,\n+        InlineAsmRegClass::PowerPC(_) => None,\n         InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg)\n         | InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => None,\n         InlineAsmRegClass::X86(X86InlineAsmRegClass::reg)\n@@ -626,6 +695,9 @@ fn dummy_output_type(cx: &CodegenCx<'ll, 'tcx>, reg: InlineAsmRegClass) -> &'ll\n         InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg16) => cx.type_i16(),\n         InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg32) => cx.type_i32(),\n         InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg64) => cx.type_i64(),\n+        InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::reg) => cx.type_i32(),\n+        InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::reg_nonzero) => cx.type_i32(),\n+        InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::freg) => cx.type_f64(),\n         InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg) => cx.type_i32(),\n         InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => cx.type_f32(),\n         InlineAsmRegClass::X86(X86InlineAsmRegClass::reg)"}, {"sha": "6a032b9be723bc379ad9515a4a17e19f55b15050", "filename": "compiler/rustc_codegen_llvm/src/attributes.rs", "status": "modified", "additions": 33, "deletions": 48, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -4,16 +4,15 @@ use std::ffi::CString;\n \n use cstr::cstr;\n use rustc_codegen_ssa::traits::*;\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_hir::def_id::DefId;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::ty::layout::HasTyCtxt;\n-use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt};\n-use rustc_session::config::{OptLevel, SanitizerSet};\n+use rustc_session::config::OptLevel;\n use rustc_session::Session;\n-use rustc_target::spec::StackProbeType;\n+use rustc_target::spec::abi::Abi;\n+use rustc_target::spec::{SanitizerSet, StackProbeType};\n \n use crate::attributes;\n use crate::llvm::AttributePlace::Function;\n@@ -254,6 +253,7 @@ pub fn from_fn_attrs(cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value, instance: ty::\n         attributes::emit_uwtable(llfn, true);\n     }\n \n+    // FIXME: none of these three functions interact with source level attributes.\n     set_frame_pointer_elimination(cx, llfn);\n     set_instrument_function(cx, llfn);\n     set_probestack(cx, llfn);\n@@ -279,6 +279,9 @@ pub fn from_fn_attrs(cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value, instance: ty::\n     if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::CMSE_NONSECURE_ENTRY) {\n         llvm::AddFunctionAttrString(llfn, Function, cstr!(\"cmse_nonsecure_entry\"));\n     }\n+    if let Some(align) = codegen_fn_attrs.alignment {\n+        llvm::set_alignment(llfn, align as usize);\n+    }\n     sanitize(cx, codegen_fn_attrs.no_sanitize, llfn);\n \n     // Always annotate functions with the target-cpu they are compiled for.\n@@ -289,7 +292,7 @@ pub fn from_fn_attrs(cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value, instance: ty::\n     // The target doesn't care; the subtarget reads our attribute.\n     apply_tune_cpu_attr(cx, llfn);\n \n-    let function_features = codegen_fn_attrs\n+    let mut function_features = codegen_fn_attrs\n         .target_features\n         .iter()\n         .map(|f| {\n@@ -301,23 +304,10 @@ pub fn from_fn_attrs(cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value, instance: ty::\n             InstructionSetAttr::ArmT32 => \"+thumb-mode\".to_string(),\n         }))\n         .collect::<Vec<String>>();\n-    if !function_features.is_empty() {\n-        let mut global_features = llvm_util::llvm_global_features(cx.tcx.sess);\n-        global_features.extend(function_features.into_iter());\n-        let features = global_features.join(\",\");\n-        let val = CString::new(features).unwrap();\n-        llvm::AddFunctionAttrStringValue(\n-            llfn,\n-            llvm::AttributePlace::Function,\n-            cstr!(\"target-features\"),\n-            &val,\n-        );\n-    }\n \n-    // Note that currently the `wasm-import-module` doesn't do anything, but\n-    // eventually LLVM 7 should read this and ferry the appropriate import\n-    // module to the output file.\n-    if cx.tcx.sess.target.arch == \"wasm32\" {\n+    if cx.tcx.sess.target.is_like_wasm {\n+        // If this function is an import from the environment but the wasm\n+        // import has a specific module/name, apply them here.\n         if let Some(module) = wasm_import_module(cx.tcx, instance.def_id()) {\n             llvm::AddFunctionAttrStringValue(\n                 llfn,\n@@ -336,36 +326,31 @@ pub fn from_fn_attrs(cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value, instance: ty::\n                 &name,\n             );\n         }\n-    }\n-}\n \n-pub fn provide_both(providers: &mut Providers) {\n-    providers.wasm_import_module_map = |tcx, cnum| {\n-        // Build up a map from DefId to a `NativeLib` structure, where\n-        // `NativeLib` internally contains information about\n-        // `#[link(wasm_import_module = \"...\")]` for example.\n-        let native_libs = tcx.native_libraries(cnum);\n-\n-        let def_id_to_native_lib = native_libs\n-            .iter()\n-            .filter_map(|lib| lib.foreign_module.map(|id| (id, lib)))\n-            .collect::<FxHashMap<_, _>>();\n-\n-        let mut ret = FxHashMap::default();\n-        for (def_id, lib) in tcx.foreign_modules(cnum).iter() {\n-            let module = def_id_to_native_lib.get(&def_id).and_then(|s| s.wasm_import_module);\n-            let module = match module {\n-                Some(s) => s,\n-                None => continue,\n-            };\n-            ret.extend(lib.foreign_items.iter().map(|id| {\n-                assert_eq!(id.krate, cnum);\n-                (*id, module.to_string())\n-            }));\n+        // The `\"wasm\"` abi on wasm targets automatically enables the\n+        // `+multivalue` feature because the purpose of the wasm abi is to match\n+        // the WebAssembly specification, which has this feature. This won't be\n+        // needed when LLVM enables this `multivalue` feature by default.\n+        if !cx.tcx.is_closure(instance.def_id()) {\n+            let abi = cx.tcx.fn_sig(instance.def_id()).abi();\n+            if abi == Abi::Wasm {\n+                function_features.push(\"+multivalue\".to_string());\n+            }\n         }\n+    }\n \n-        ret\n-    };\n+    if !function_features.is_empty() {\n+        let mut global_features = llvm_util::llvm_global_features(cx.tcx.sess);\n+        global_features.extend(function_features.into_iter());\n+        let features = global_features.join(\",\");\n+        let val = CString::new(features).unwrap();\n+        llvm::AddFunctionAttrStringValue(\n+            llfn,\n+            llvm::AttributePlace::Function,\n+            cstr!(\"target-features\"),\n+            &val,\n+        );\n+    }\n }\n \n fn wasm_import_module(tcx: TyCtxt<'_>, id: DefId) -> Option<CString> {"}, {"sha": "261affe2c427e1f01aa63dfe57cad8d5a7a4e9f3", "filename": "compiler/rustc_codegen_llvm/src/back/archive.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -100,8 +100,9 @@ impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n \n     /// Adds all of the contents of a native library to this archive. This will\n     /// search in the relevant locations for a library named `name`.\n-    fn add_native_library(&mut self, name: Symbol) {\n-        let location = find_library(name, &self.config.lib_search_paths, self.config.sess);\n+    fn add_native_library(&mut self, name: Symbol, verbatim: bool) {\n+        let location =\n+            find_library(name, verbatim, &self.config.lib_search_paths, self.config.sess);\n         self.add_archive(&location, |_| false).unwrap_or_else(|e| {\n             self.config.sess.fatal(&format!(\n                 \"failed to add native library {}: {}\","}, {"sha": "f612785e5a416c582321e4efa0b7c1aec41e91b6", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -568,10 +568,11 @@ fn thin_lto(\n \n pub(crate) fn run_pass_manager(\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n+    diag_handler: &Handler,\n     module: &ModuleCodegen<ModuleLlvm>,\n     config: &ModuleConfig,\n     thin: bool,\n-) {\n+) -> Result<(), FatalError> {\n     let _timer = cgcx.prof.extra_verbose_generic_activity(\"LLVM_lto_optimize\", &module.name[..]);\n \n     // Now we have one massive module inside of llmod. Time to run the\n@@ -584,15 +585,16 @@ pub(crate) fn run_pass_manager(\n         if write::should_use_new_llvm_pass_manager(config) {\n             let opt_stage = if thin { llvm::OptStage::ThinLTO } else { llvm::OptStage::FatLTO };\n             let opt_level = config.opt_level.unwrap_or(config::OptLevel::No);\n-            // See comment below for why this is necessary.\n-            let opt_level = if let config::OptLevel::No = opt_level {\n-                config::OptLevel::Less\n-            } else {\n-                opt_level\n-            };\n-            write::optimize_with_new_llvm_pass_manager(cgcx, module, config, opt_level, opt_stage);\n+            write::optimize_with_new_llvm_pass_manager(\n+                cgcx,\n+                diag_handler,\n+                module,\n+                config,\n+                opt_level,\n+                opt_stage,\n+            )?;\n             debug!(\"lto done\");\n-            return;\n+            return Ok(());\n         }\n \n         let pm = llvm::LLVMCreatePassManager();\n@@ -603,26 +605,10 @@ pub(crate) fn run_pass_manager(\n             llvm::LLVMRustAddPass(pm, pass.unwrap());\n         }\n \n-        // When optimizing for LTO we don't actually pass in `-O0`, but we force\n-        // it to always happen at least with `-O1`.\n-        //\n-        // With ThinLTO we mess around a lot with symbol visibility in a way\n-        // that will actually cause linking failures if we optimize at O0 which\n-        // notable is lacking in dead code elimination. To ensure we at least\n-        // get some optimizations and correctly link we forcibly switch to `-O1`\n-        // to get dead code elimination.\n-        //\n-        // Note that in general this shouldn't matter too much as you typically\n-        // only turn on ThinLTO when you're compiling with optimizations\n-        // otherwise.\n         let opt_level = config\n             .opt_level\n             .map(|x| to_llvm_opt_settings(x).0)\n             .unwrap_or(llvm::CodeGenOptLevel::None);\n-        let opt_level = match opt_level {\n-            llvm::CodeGenOptLevel::None => llvm::CodeGenOptLevel::Less,\n-            level => level,\n-        };\n         with_llvm_pmb(module.module_llvm.llmod(), config, opt_level, false, &mut |b| {\n             if thin {\n                 llvm::LLVMRustPassManagerBuilderPopulateThinLTOPassManager(b, pm);\n@@ -650,6 +636,7 @@ pub(crate) fn run_pass_manager(\n         llvm::LLVMDisposePassManager(pm);\n     }\n     debug!(\"lto done\");\n+    Ok(())\n }\n \n pub struct ModuleBuffer(&'static mut llvm::ModuleBuffer);\n@@ -872,7 +859,7 @@ pub unsafe fn optimize_thin_module(\n         {\n             info!(\"running thin lto passes over {}\", module.name);\n             let config = cgcx.config(module.kind);\n-            run_pass_manager(cgcx, &module, config, true);\n+            run_pass_manager(cgcx, &diag_handler, &module, config, true)?;\n             save_temp_bitcode(cgcx, &module, \"thin-lto-after-pm\");\n         }\n     }"}, {"sha": "5b4a187a1d56f16ed41afc7964987339718a8f58", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -20,14 +20,13 @@ use rustc_codegen_ssa::{CompiledModule, ModuleCodegen};\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_errors::{FatalError, Handler, Level};\n use rustc_fs_util::{link_or_copy, path_to_c_string};\n-use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::bug;\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::config::{self, Lto, OutputType, Passes, SanitizerSet, SwitchWithOptPath};\n+use rustc_session::config::{self, Lto, OutputType, Passes, SwitchWithOptPath};\n use rustc_session::Session;\n use rustc_span::symbol::sym;\n use rustc_span::InnerSpan;\n-use rustc_target::spec::{CodeModel, RelocModel, SplitDebuginfo};\n+use rustc_target::spec::{CodeModel, RelocModel, SanitizerSet, SplitDebuginfo};\n use tracing::debug;\n \n use libc::{c_char, c_int, c_uint, c_void, size_t};\n@@ -92,13 +91,12 @@ pub fn create_informational_target_machine(sess: &Session) -> &'static mut llvm:\n \n pub fn create_target_machine(tcx: TyCtxt<'_>, mod_name: &str) -> &'static mut llvm::TargetMachine {\n     let split_dwarf_file = if tcx.sess.target_can_use_split_dwarf() {\n-        tcx.output_filenames(LOCAL_CRATE)\n-            .split_dwarf_path(tcx.sess.split_debuginfo(), Some(mod_name))\n+        tcx.output_filenames(()).split_dwarf_path(tcx.sess.split_debuginfo(), Some(mod_name))\n     } else {\n         None\n     };\n     let config = TargetMachineFactoryConfig { split_dwarf_file };\n-    target_machine_factory(&tcx.sess, tcx.backend_optimization_level(LOCAL_CRATE))(config)\n+    target_machine_factory(&tcx.sess, tcx.backend_optimization_level(()))(config)\n         .unwrap_or_else(|err| llvm_err(tcx.sess.diagnostic(), &err).raise())\n }\n \n@@ -170,10 +168,7 @@ pub fn target_machine_factory(\n     // On the wasm target once the `atomics` feature is enabled that means that\n     // we're no longer single-threaded, or otherwise we don't want LLVM to\n     // lower atomic operations to single-threaded operations.\n-    if singlethread\n-        && sess.target.llvm_target.contains(\"wasm32\")\n-        && sess.target_features.contains(&sym::atomics)\n-    {\n+    if singlethread && sess.target.is_like_wasm && sess.target_features.contains(&sym::atomics) {\n         singlethread = false;\n     }\n \n@@ -413,16 +408,17 @@ fn get_pgo_use_path(config: &ModuleConfig) -> Option<CString> {\n \n pub(crate) fn should_use_new_llvm_pass_manager(config: &ModuleConfig) -> bool {\n     // The new pass manager is disabled by default.\n-    config.new_llvm_pass_manager\n+    config.new_llvm_pass_manager.unwrap_or(false)\n }\n \n pub(crate) unsafe fn optimize_with_new_llvm_pass_manager(\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n+    diag_handler: &Handler,\n     module: &ModuleCodegen<ModuleLlvm>,\n     config: &ModuleConfig,\n     opt_level: config::OptLevel,\n     opt_stage: llvm::OptStage,\n-) {\n+) -> Result<(), FatalError> {\n     let unroll_loops =\n         opt_level != config::OptLevel::Size && opt_level != config::OptLevel::SizeMin;\n     let using_thin_buffers = opt_stage == llvm::OptStage::PreLinkThinLTO || config.bitcode_needed();\n@@ -452,13 +448,12 @@ pub(crate) unsafe fn optimize_with_new_llvm_pass_manager(\n         std::ptr::null_mut()\n     };\n \n+    let extra_passes = config.passes.join(\",\");\n+\n     // FIXME: NewPM doesn't provide a facility to pass custom InlineParams.\n     // We would have to add upstream support for this first, before we can support\n     // config.inline_threshold and our more aggressive default thresholds.\n-    // FIXME: NewPM uses an different and more explicit way to textually represent\n-    // pass pipelines. It would probably make sense to expose this, but it would\n-    // require a different format than the current -C passes.\n-    llvm::LLVMRustOptimizeWithNewPassManager(\n+    let result = llvm::LLVMRustOptimizeWithNewPassManager(\n         module.module_llvm.llmod(),\n         &*module.module_llvm.tm,\n         to_pass_builder_opt_level(opt_level),\n@@ -475,10 +470,15 @@ pub(crate) unsafe fn optimize_with_new_llvm_pass_manager(\n         sanitizer_options.as_ref(),\n         pgo_gen_path.as_ref().map_or(std::ptr::null(), |s| s.as_ptr()),\n         pgo_use_path.as_ref().map_or(std::ptr::null(), |s| s.as_ptr()),\n+        config.instrument_coverage,\n+        config.instrument_gcov,\n         llvm_selfprofiler,\n         selfprofile_before_pass_callback,\n         selfprofile_after_pass_callback,\n+        extra_passes.as_ptr().cast(),\n+        extra_passes.len(),\n     );\n+    result.into_result().map_err(|()| llvm_err(diag_handler, \"failed to run LLVM passes\"))\n }\n \n // Unsafe due to LLVM calls.\n@@ -487,7 +487,7 @@ pub(crate) unsafe fn optimize(\n     diag_handler: &Handler,\n     module: &ModuleCodegen<ModuleLlvm>,\n     config: &ModuleConfig,\n-) {\n+) -> Result<(), FatalError> {\n     let _timer = cgcx.prof.generic_activity_with_arg(\"LLVM_module_optimize\", &module.name[..]);\n \n     let llmod = module.module_llvm.llmod();\n@@ -512,8 +512,14 @@ pub(crate) unsafe fn optimize(\n                 _ if cgcx.opts.cg.linker_plugin_lto.enabled() => llvm::OptStage::PreLinkThinLTO,\n                 _ => llvm::OptStage::PreLinkNoLTO,\n             };\n-            optimize_with_new_llvm_pass_manager(cgcx, module, config, opt_level, opt_stage);\n-            return;\n+            return optimize_with_new_llvm_pass_manager(\n+                cgcx,\n+                diag_handler,\n+                module,\n+                config,\n+                opt_level,\n+                opt_stage,\n+            );\n         }\n \n         if cgcx.prof.llvm_recording_enabled() {\n@@ -560,6 +566,18 @@ pub(crate) unsafe fn optimize(\n                 }\n             }\n \n+            // Instrumentation must be inserted before optimization,\n+            // otherwise LLVM may optimize some functions away which\n+            // breaks llvm-cov.\n+            //\n+            // This mirrors what Clang does in lib/CodeGen/BackendUtil.cpp.\n+            if config.instrument_gcov {\n+                llvm::LLVMRustAddPass(mpm, find_pass(\"insert-gcov-profiling\").unwrap());\n+            }\n+            if config.instrument_coverage {\n+                llvm::LLVMRustAddPass(mpm, find_pass(\"instrprof\").unwrap());\n+            }\n+\n             add_sanitizer_passes(config, &mut extra_passes);\n \n             // Some options cause LLVM bitcode to be emitted, which uses ThinLTOBuffers, so we need\n@@ -636,6 +654,7 @@ pub(crate) unsafe fn optimize(\n         llvm::LLVMDisposePassManager(fpm);\n         llvm::LLVMDisposePassManager(mpm);\n     }\n+    Ok(())\n }\n \n unsafe fn add_sanitizer_passes(config: &ModuleConfig, passes: &mut Vec<&'static mut llvm::Pass>) {\n@@ -1041,7 +1060,7 @@ pub unsafe fn with_llvm_pmb(\n     // thresholds copied from clang.\n     match (opt_level, opt_size, inline_threshold) {\n         (.., Some(t)) => {\n-            llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, t as u32);\n+            llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, t);\n         }\n         (llvm::CodeGenOptLevel::Aggressive, ..) => {\n             llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, 275);"}, {"sha": "b296db64ee9bd2ca3cf09507e167e643e39cec17", "filename": "compiler/rustc_codegen_llvm/src/base.rs", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -18,7 +18,6 @@ use crate::builder::Builder;\n use crate::common;\n use crate::context::CodegenCx;\n use crate::llvm;\n-use crate::metadata;\n use crate::value::Value;\n \n use rustc_codegen_ssa::base::maybe_create_entry_wrapper;\n@@ -32,8 +31,9 @@ use rustc_middle::middle::cstore::EncodedMetadata;\n use rustc_middle::middle::exported_symbols;\n use rustc_middle::mir::mono::{Linkage, Visibility};\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::config::{DebugInfo, SanitizerSet};\n+use rustc_session::config::DebugInfo;\n use rustc_span::symbol::Symbol;\n+use rustc_target::spec::SanitizerSet;\n \n use std::ffi::CString;\n use std::time::Instant;\n@@ -46,6 +46,22 @@ pub fn write_compressed_metadata<'tcx>(\n     use snap::write::FrameEncoder;\n     use std::io::Write;\n \n+    // Historical note:\n+    //\n+    // When using link.exe it was seen that the section name `.note.rustc`\n+    // was getting shortened to `.note.ru`, and according to the PE and COFF\n+    // specification:\n+    //\n+    // > Executable images do not use a string table and do not support\n+    // > section names longer than 8\u00a0characters\n+    //\n+    // https://docs.microsoft.com/en-us/windows/win32/debug/pe-format\n+    //\n+    // As a result, we choose a slightly shorter name! As to why\n+    // `.note.rustc` works on MinGW, see\n+    // https://github.com/llvm/llvm-project/blob/llvmorg-12.0.0/lld/COFF/Writer.cpp#L1190-L1197\n+    let section_name = if tcx.sess.target.is_like_osx { \"__DATA,.rustc\" } else { \".rustc\" };\n+\n     let (metadata_llcx, metadata_llmod) = (&*llvm_module.llcx, llvm_module.llmod());\n     let mut compressed = tcx.metadata_encoding_version();\n     FrameEncoder::new(&mut compressed).write_all(&metadata.raw_data).unwrap();\n@@ -58,7 +74,6 @@ pub fn write_compressed_metadata<'tcx>(\n         unsafe { llvm::LLVMAddGlobal(metadata_llmod, common::val_ty(llconst), buf.as_ptr()) };\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n-        let section_name = metadata::metadata_section_name(&tcx.sess.target);\n         let name = SmallCStr::new(section_name);\n         llvm::LLVMSetSection(llglobal, name.as_ptr());\n \n@@ -203,3 +218,27 @@ pub fn visibility_to_llvm(linkage: Visibility) -> llvm::Visibility {\n         Visibility::Protected => llvm::Visibility::Protected,\n     }\n }\n+\n+pub fn linkage_from_llvm(linkage: llvm::Linkage) -> Linkage {\n+    match linkage {\n+        llvm::Linkage::ExternalLinkage => Linkage::External,\n+        llvm::Linkage::AvailableExternallyLinkage => Linkage::AvailableExternally,\n+        llvm::Linkage::LinkOnceAnyLinkage => Linkage::LinkOnceAny,\n+        llvm::Linkage::LinkOnceODRLinkage => Linkage::LinkOnceODR,\n+        llvm::Linkage::WeakAnyLinkage => Linkage::WeakAny,\n+        llvm::Linkage::WeakODRLinkage => Linkage::WeakODR,\n+        llvm::Linkage::AppendingLinkage => Linkage::Appending,\n+        llvm::Linkage::InternalLinkage => Linkage::Internal,\n+        llvm::Linkage::PrivateLinkage => Linkage::Private,\n+        llvm::Linkage::ExternalWeakLinkage => Linkage::ExternalWeak,\n+        llvm::Linkage::CommonLinkage => Linkage::Common,\n+    }\n+}\n+\n+pub fn visibility_from_llvm(linkage: llvm::Visibility) -> Visibility {\n+    match linkage {\n+        llvm::Visibility::Default => Visibility::Default,\n+        llvm::Visibility::Hidden => Visibility::Hidden,\n+        llvm::Visibility::Protected => Visibility::Protected,\n+    }\n+}"}, {"sha": "bc9d99ed4a122a2a9480e97587e6f393b9da54f9", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 68, "deletions": 97, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -2,6 +2,7 @@ use crate::common::Funclet;\n use crate::context::CodegenCx;\n use crate::llvm::{self, BasicBlock, False};\n use crate::llvm::{AtomicOrdering, AtomicRmwBinOp, SynchronizationScope};\n+use crate::llvm_util;\n use crate::type_::Type;\n use crate::type_of::LayoutLlvmExt;\n use crate::value::Value;\n@@ -16,7 +17,7 @@ use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::layout::TyAndLayout;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n-use rustc_span::{sym, Span};\n+use rustc_span::Span;\n use rustc_target::abi::{self, Align, Size};\n use rustc_target::spec::{HasTargetSpec, Target};\n use std::borrow::Cow;\n@@ -117,24 +118,16 @@ macro_rules! builder_methods_for_value_instructions {\n }\n \n impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n-    fn new_block<'b>(cx: &'a CodegenCx<'ll, 'tcx>, llfn: &'ll Value, name: &'b str) -> Self {\n-        let mut bx = Builder::with_cx(cx);\n-        let llbb = unsafe {\n-            let name = SmallCStr::new(name);\n-            llvm::LLVMAppendBasicBlockInContext(cx.llcx, llfn, name.as_ptr())\n-        };\n-        bx.position_at_end(llbb);\n+    fn build(cx: &'a CodegenCx<'ll, 'tcx>, llbb: &'ll BasicBlock) -> Self {\n+        let bx = Builder::with_cx(cx);\n+        unsafe {\n+            llvm::LLVMPositionBuilderAtEnd(bx.llbuilder, llbb);\n+        }\n         bx\n     }\n \n-    fn with_cx(cx: &'a CodegenCx<'ll, 'tcx>) -> Self {\n-        // Create a fresh builder from the crate context.\n-        let llbuilder = unsafe { llvm::LLVMCreateBuilderInContext(cx.llcx) };\n-        Builder { llbuilder, cx }\n-    }\n-\n-    fn build_sibling_block(&self, name: &str) -> Self {\n-        Builder::new_block(self.cx, self.llfn(), name)\n+    fn cx(&self) -> &CodegenCx<'ll, 'tcx> {\n+        self.cx\n     }\n \n     fn llbb(&self) -> &'ll BasicBlock {\n@@ -143,12 +136,22 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n     fn set_span(&mut self, _span: Span) {}\n \n-    fn position_at_end(&mut self, llbb: &'ll BasicBlock) {\n+    fn append_block(cx: &'a CodegenCx<'ll, 'tcx>, llfn: &'ll Value, name: &str) -> &'ll BasicBlock {\n         unsafe {\n-            llvm::LLVMPositionBuilderAtEnd(self.llbuilder, llbb);\n+            let name = SmallCStr::new(name);\n+            llvm::LLVMAppendBasicBlockInContext(cx.llcx, llfn, name.as_ptr())\n         }\n     }\n \n+    fn append_sibling_block(&mut self, name: &str) -> &'ll BasicBlock {\n+        Self::append_block(self.cx, self.llfn(), name)\n+    }\n+\n+    fn build_sibling_block(&mut self, name: &str) -> Self {\n+        let llbb = self.append_sibling_block(name);\n+        Self::build(self.cx, llbb)\n+    }\n+\n     fn ret_void(&mut self) {\n         unsafe {\n             llvm::LLVMBuildRetVoid(self.llbuilder);\n@@ -261,39 +264,39 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn fadd_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         unsafe {\n             let instr = llvm::LLVMBuildFAdd(self.llbuilder, lhs, rhs, UNNAMED);\n-            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            llvm::LLVMRustSetFastMath(instr);\n             instr\n         }\n     }\n \n     fn fsub_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         unsafe {\n             let instr = llvm::LLVMBuildFSub(self.llbuilder, lhs, rhs, UNNAMED);\n-            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            llvm::LLVMRustSetFastMath(instr);\n             instr\n         }\n     }\n \n     fn fmul_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         unsafe {\n             let instr = llvm::LLVMBuildFMul(self.llbuilder, lhs, rhs, UNNAMED);\n-            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            llvm::LLVMRustSetFastMath(instr);\n             instr\n         }\n     }\n \n     fn fdiv_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         unsafe {\n             let instr = llvm::LLVMBuildFDiv(self.llbuilder, lhs, rhs, UNNAMED);\n-            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            llvm::LLVMRustSetFastMath(instr);\n             instr\n         }\n     }\n \n     fn frem_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         unsafe {\n             let instr = llvm::LLVMBuildFRem(self.llbuilder, lhs, rhs, UNNAMED);\n-            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            llvm::LLVMRustSetFastMath(instr);\n             instr\n         }\n     }\n@@ -669,81 +672,47 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn fptoui_sat(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> Option<&'ll Value> {\n-        // WebAssembly has saturating floating point to integer casts if the\n-        // `nontrapping-fptoint` target feature is activated. We'll use those if\n-        // they are available.\n-        if self.sess().target.arch == \"wasm32\"\n-            && self.sess().target_features.contains(&sym::nontrapping_dash_fptoint)\n-        {\n+        if llvm_util::get_version() >= (12, 0, 0) && !self.fptoint_sat_broken_in_llvm() {\n             let src_ty = self.cx.val_ty(val);\n             let float_width = self.cx.float_width(src_ty);\n             let int_width = self.cx.int_width(dest_ty);\n-            let name = match (int_width, float_width) {\n-                (32, 32) => Some(\"llvm.wasm.trunc.saturate.unsigned.i32.f32\"),\n-                (32, 64) => Some(\"llvm.wasm.trunc.saturate.unsigned.i32.f64\"),\n-                (64, 32) => Some(\"llvm.wasm.trunc.saturate.unsigned.i64.f32\"),\n-                (64, 64) => Some(\"llvm.wasm.trunc.saturate.unsigned.i64.f64\"),\n-                _ => None,\n-            };\n-            if let Some(name) = name {\n-                let intrinsic = self.get_intrinsic(name);\n-                return Some(self.call(intrinsic, &[val], None));\n-            }\n+            let name = format!(\"llvm.fptoui.sat.i{}.f{}\", int_width, float_width);\n+            let intrinsic = self.get_intrinsic(&name);\n+            return Some(self.call(intrinsic, &[val], None));\n         }\n+\n         None\n     }\n \n     fn fptosi_sat(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> Option<&'ll Value> {\n-        // WebAssembly has saturating floating point to integer casts if the\n-        // `nontrapping-fptoint` target feature is activated. We'll use those if\n-        // they are available.\n-        if self.sess().target.arch == \"wasm32\"\n-            && self.sess().target_features.contains(&sym::nontrapping_dash_fptoint)\n-        {\n+        if llvm_util::get_version() >= (12, 0, 0) && !self.fptoint_sat_broken_in_llvm() {\n             let src_ty = self.cx.val_ty(val);\n             let float_width = self.cx.float_width(src_ty);\n             let int_width = self.cx.int_width(dest_ty);\n-            let name = match (int_width, float_width) {\n-                (32, 32) => Some(\"llvm.wasm.trunc.saturate.signed.i32.f32\"),\n-                (32, 64) => Some(\"llvm.wasm.trunc.saturate.signed.i32.f64\"),\n-                (64, 32) => Some(\"llvm.wasm.trunc.saturate.signed.i64.f32\"),\n-                (64, 64) => Some(\"llvm.wasm.trunc.saturate.signed.i64.f64\"),\n-                _ => None,\n-            };\n-            if let Some(name) = name {\n-                let intrinsic = self.get_intrinsic(name);\n-                return Some(self.call(intrinsic, &[val], None));\n-            }\n+            let name = format!(\"llvm.fptosi.sat.i{}.f{}\", int_width, float_width);\n+            let intrinsic = self.get_intrinsic(&name);\n+            return Some(self.call(intrinsic, &[val], None));\n         }\n-        None\n-    }\n \n-    fn fptosui_may_trap(&self, val: &'ll Value, dest_ty: &'ll Type) -> bool {\n-        // Most of the time we'll be generating the `fptosi` or `fptoui`\n-        // instruction for floating-point-to-integer conversions. These\n-        // instructions by definition in LLVM do not trap. For the WebAssembly\n-        // target, however, we'll lower in some cases to intrinsic calls instead\n-        // which may trap. If we detect that this is a situation where we'll be\n-        // using the intrinsics then we report that the call map trap, which\n-        // callers might need to handle.\n-        if !self.wasm_and_missing_nontrapping_fptoint() {\n-            return false;\n-        }\n-        let src_ty = self.cx.val_ty(val);\n-        let float_width = self.cx.float_width(src_ty);\n-        let int_width = self.cx.int_width(dest_ty);\n-        matches!((int_width, float_width), (32, 32) | (32, 64) | (64, 32) | (64, 64))\n+        None\n     }\n \n     fn fptoui(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        // When we can, use the native wasm intrinsics which have tighter\n-        // codegen. Note that this has a semantic difference in that the\n-        // intrinsic can trap whereas `fptoui` never traps. That difference,\n-        // however, is handled by `fptosui_may_trap` above.\n+        // On WebAssembly the `fptoui` and `fptosi` instructions currently have\n+        // poor codegen. The reason for this is that the corresponding wasm\n+        // instructions, `i32.trunc_f32_s` for example, will trap when the float\n+        // is out-of-bounds, infinity, or nan. This means that LLVM\n+        // automatically inserts control flow around `fptoui` and `fptosi`\n+        // because the LLVM instruction `fptoui` is defined as producing a\n+        // poison value, not having UB on out-of-bounds values.\n         //\n-        // Note that we skip the wasm intrinsics for vector types where `fptoui`\n-        // must be used instead.\n-        if self.wasm_and_missing_nontrapping_fptoint() {\n+        // This method, however, is only used with non-saturating casts that\n+        // have UB on out-of-bounds values. This means that it's ok if we use\n+        // the raw wasm instruction since out-of-bounds values can do whatever\n+        // we like. To ensure that LLVM picks the right instruction we choose\n+        // the raw wasm intrinsic functions which avoid LLVM inserting all the\n+        // other control flow automatically.\n+        if self.sess().target.arch == \"wasm32\" {\n             let src_ty = self.cx.val_ty(val);\n             if self.cx.type_kind(src_ty) != TypeKind::Vector {\n                 let float_width = self.cx.float_width(src_ty);\n@@ -765,7 +734,8 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn fptosi(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        if self.wasm_and_missing_nontrapping_fptoint() {\n+        // see `fptoui` above for why wasm is different here\n+        if self.sess().target.arch == \"wasm32\" {\n             let src_ty = self.cx.val_ty(val);\n             if self.cx.type_kind(src_ty) != TypeKind::Vector {\n                 let float_width = self.cx.float_width(src_ty);\n@@ -1176,14 +1146,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         unsafe { llvm::LLVMBuildZExt(self.llbuilder, val, dest_ty, UNNAMED) }\n     }\n \n-    fn cx(&self) -> &CodegenCx<'ll, 'tcx> {\n-        self.cx\n-    }\n-\n-    unsafe fn delete_basic_block(&mut self, bb: &'ll BasicBlock) {\n-        llvm::LLVMDeleteBasicBlock(bb);\n-    }\n-\n     fn do_not_inline(&mut self, llret: &'ll Value) {\n         llvm::Attribute::NoInline.apply_callsite(llvm::AttributePlace::Function, llret);\n     }\n@@ -1197,6 +1159,12 @@ impl StaticBuilderMethods for Builder<'a, 'll, 'tcx> {\n }\n \n impl Builder<'a, 'll, 'tcx> {\n+    fn with_cx(cx: &'a CodegenCx<'ll, 'tcx>) -> Self {\n+        // Create a fresh builder from the crate context.\n+        let llbuilder = unsafe { llvm::LLVMCreateBuilderInContext(cx.llcx) };\n+        Builder { llbuilder, cx }\n+    }\n+\n     pub fn llfn(&self) -> &'ll Value {\n         unsafe { llvm::LLVMGetBasicBlockParent(self.llbb()) }\n     }\n@@ -1242,14 +1210,14 @@ impl Builder<'a, 'll, 'tcx> {\n     pub fn vector_reduce_fadd_fast(&mut self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceFAdd(self.llbuilder, acc, src);\n-            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            llvm::LLVMRustSetFastMath(instr);\n             instr\n         }\n     }\n     pub fn vector_reduce_fmul_fast(&mut self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceFMul(self.llbuilder, acc, src);\n-            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            llvm::LLVMRustSetFastMath(instr);\n             instr\n         }\n     }\n@@ -1282,15 +1250,15 @@ impl Builder<'a, 'll, 'tcx> {\n         unsafe {\n             let instr =\n                 llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ true);\n-            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            llvm::LLVMRustSetFastMath(instr);\n             instr\n         }\n     }\n     pub fn vector_reduce_fmax_fast(&mut self, src: &'ll Value) -> &'ll Value {\n         unsafe {\n             let instr =\n                 llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ true);\n-            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            llvm::LLVMRustSetFastMath(instr);\n             instr\n         }\n     }\n@@ -1420,8 +1388,11 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn wasm_and_missing_nontrapping_fptoint(&self) -> bool {\n-        self.sess().target.arch == \"wasm32\"\n-            && !self.sess().target_features.contains(&sym::nontrapping_dash_fptoint)\n+    fn fptoint_sat_broken_in_llvm(&self) -> bool {\n+        match self.tcx.sess.target.arch.as_str() {\n+            // FIXME - https://bugs.llvm.org/show_bug.cgi?id=50083\n+            \"riscv64\" => llvm_util::get_version() < (13, 0, 0),\n+            _ => false,\n+        }\n     }\n }"}, {"sha": "b26969a50120f1de8369b073739933d77ffafbfa", "filename": "compiler/rustc_codegen_llvm/src/callee.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -14,6 +14,7 @@ use tracing::debug;\n \n use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt};\n use rustc_middle::ty::{self, Instance, TypeFoldable};\n+use rustc_target::spec::RelocModel;\n \n /// Codegens a reference to a fn/method item, monomorphizing and\n /// inlining as it goes.\n@@ -170,17 +171,19 @@ pub fn get_fn(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'tcx>) -> &'ll Value\n                     }\n                 }\n             }\n-        }\n \n-        // MinGW: For backward compatibility we rely on the linker to decide whether it\n-        // should use dllimport for functions.\n-        if cx.use_dll_storage_attrs\n-            && tcx.is_dllimport_foreign_item(instance_def_id)\n-            && tcx.sess.target.env != \"gnu\"\n-        {\n-            unsafe {\n+            // MinGW: For backward compatibility we rely on the linker to decide whether it\n+            // should use dllimport for functions.\n+            if cx.use_dll_storage_attrs\n+                && tcx.is_dllimport_foreign_item(instance_def_id)\n+                && tcx.sess.target.env != \"gnu\"\n+            {\n                 llvm::LLVMSetDLLStorageClass(llfn, llvm::DLLStorageClass::DllImport);\n             }\n+\n+            if cx.tcx.sess.relocation_model() == RelocModel::Static {\n+                llvm::LLVMRustSetDSOLocal(llfn, true);\n+            }\n         }\n \n         llfn"}, {"sha": "245842df1b060080cc9a825ad08053ace9aa612a", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -17,6 +17,7 @@ use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::ty::{self, Instance, Ty};\n use rustc_middle::{bug, span_bug};\n use rustc_target::abi::{AddressSpace, Align, HasDataLayout, LayoutOf, Primitive, Scalar, Size};\n+use rustc_target::spec::RelocModel;\n use tracing::debug;\n \n pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll Value {\n@@ -282,6 +283,12 @@ impl CodegenCx<'ll, 'tcx> {\n             }\n         }\n \n+        if self.tcx.sess.relocation_model() == RelocModel::Static {\n+            unsafe {\n+                llvm::LLVMRustSetDSOLocal(g, true);\n+            }\n+        }\n+\n         self.instances.borrow_mut().insert(instance, g);\n         g\n     }\n@@ -363,6 +370,12 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n             set_global_alignment(&self, g, self.align_of(ty));\n             llvm::LLVMSetInitializer(g, v);\n \n+            let linkage = base::linkage_from_llvm(llvm::LLVMRustGetLinkage(g));\n+            let visibility = base::visibility_from_llvm(llvm::LLVMRustGetVisibility(g));\n+            if self.should_assume_dso_local(linkage, visibility) {\n+                llvm::LLVMRustSetDSOLocal(g, true);\n+            }\n+\n             // As an optimization, all shared statics which do not have interior\n             // mutability are placed into read-only memory.\n             if !is_mutable && self.type_is_freeze(ty) {"}, {"sha": "f5c54b11c08e73d93fdff88bea8812cf3b6c94f6", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -503,14 +503,6 @@ impl CodegenCx<'b, 'tcx> {\n         let t_f32 = self.type_f32();\n         let t_f64 = self.type_f64();\n \n-        ifn!(\"llvm.wasm.trunc.saturate.unsigned.i32.f32\", fn(t_f32) -> t_i32);\n-        ifn!(\"llvm.wasm.trunc.saturate.unsigned.i32.f64\", fn(t_f64) -> t_i32);\n-        ifn!(\"llvm.wasm.trunc.saturate.unsigned.i64.f32\", fn(t_f32) -> t_i64);\n-        ifn!(\"llvm.wasm.trunc.saturate.unsigned.i64.f64\", fn(t_f64) -> t_i64);\n-        ifn!(\"llvm.wasm.trunc.saturate.signed.i32.f32\", fn(t_f32) -> t_i32);\n-        ifn!(\"llvm.wasm.trunc.saturate.signed.i32.f64\", fn(t_f64) -> t_i32);\n-        ifn!(\"llvm.wasm.trunc.saturate.signed.i64.f32\", fn(t_f32) -> t_i64);\n-        ifn!(\"llvm.wasm.trunc.saturate.signed.i64.f64\", fn(t_f64) -> t_i64);\n         ifn!(\"llvm.wasm.trunc.unsigned.i32.f32\", fn(t_f32) -> t_i32);\n         ifn!(\"llvm.wasm.trunc.unsigned.i32.f64\", fn(t_f64) -> t_i32);\n         ifn!(\"llvm.wasm.trunc.unsigned.i64.f32\", fn(t_f32) -> t_i64);\n@@ -520,6 +512,28 @@ impl CodegenCx<'b, 'tcx> {\n         ifn!(\"llvm.wasm.trunc.signed.i64.f32\", fn(t_f32) -> t_i64);\n         ifn!(\"llvm.wasm.trunc.signed.i64.f64\", fn(t_f64) -> t_i64);\n \n+        ifn!(\"llvm.fptosi.sat.i8.f32\", fn(t_f32) -> t_i8);\n+        ifn!(\"llvm.fptosi.sat.i16.f32\", fn(t_f32) -> t_i16);\n+        ifn!(\"llvm.fptosi.sat.i32.f32\", fn(t_f32) -> t_i32);\n+        ifn!(\"llvm.fptosi.sat.i64.f32\", fn(t_f32) -> t_i64);\n+        ifn!(\"llvm.fptosi.sat.i128.f32\", fn(t_f32) -> t_i128);\n+        ifn!(\"llvm.fptosi.sat.i8.f64\", fn(t_f64) -> t_i8);\n+        ifn!(\"llvm.fptosi.sat.i16.f64\", fn(t_f64) -> t_i16);\n+        ifn!(\"llvm.fptosi.sat.i32.f64\", fn(t_f64) -> t_i32);\n+        ifn!(\"llvm.fptosi.sat.i64.f64\", fn(t_f64) -> t_i64);\n+        ifn!(\"llvm.fptosi.sat.i128.f64\", fn(t_f64) -> t_i128);\n+\n+        ifn!(\"llvm.fptoui.sat.i8.f32\", fn(t_f32) -> t_i8);\n+        ifn!(\"llvm.fptoui.sat.i16.f32\", fn(t_f32) -> t_i16);\n+        ifn!(\"llvm.fptoui.sat.i32.f32\", fn(t_f32) -> t_i32);\n+        ifn!(\"llvm.fptoui.sat.i64.f32\", fn(t_f32) -> t_i64);\n+        ifn!(\"llvm.fptoui.sat.i128.f32\", fn(t_f32) -> t_i128);\n+        ifn!(\"llvm.fptoui.sat.i8.f64\", fn(t_f64) -> t_i8);\n+        ifn!(\"llvm.fptoui.sat.i16.f64\", fn(t_f64) -> t_i16);\n+        ifn!(\"llvm.fptoui.sat.i32.f64\", fn(t_f64) -> t_i32);\n+        ifn!(\"llvm.fptoui.sat.i64.f64\", fn(t_f64) -> t_i64);\n+        ifn!(\"llvm.fptoui.sat.i128.f64\", fn(t_f64) -> t_i128);\n+\n         ifn!(\"llvm.trap\", fn() -> void);\n         ifn!(\"llvm.debugtrap\", fn() -> void);\n         ifn!(\"llvm.frameaddress\", fn(t_i32) -> i8p);"}, {"sha": "d2a2e739ff31ef450117a7729737b14e4fcef61c", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -6,7 +6,7 @@ use llvm::coverageinfo::CounterMappingRegion;\n use rustc_codegen_ssa::coverageinfo::map::{Counter, CounterExpression};\n use rustc_codegen_ssa::traits::{ConstMethods, CoverageInfoMethods};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n-use rustc_hir::def_id::{DefId, DefIdSet, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, DefIdSet};\n use rustc_llvm::RustString;\n use rustc_middle::mir::coverage::CodeRegion;\n use rustc_span::Symbol;\n@@ -248,7 +248,7 @@ fn save_function_record(\n ///\n /// We can find the unused functions (including generic functions) by the set difference of all MIR\n /// `DefId`s (`tcx` query `mir_keys`) minus the codegenned `DefId`s (`tcx` query\n-/// `collect_and_partition_mono_items`).\n+/// `codegened_and_inlined_items`).\n ///\n /// *HOWEVER* the codegenned `DefId`s are partitioned across multiple `CodegenUnit`s (CGUs), and\n /// this function is processing a `function_coverage_map` for the functions (`Instance`/`DefId`)\n@@ -265,7 +265,7 @@ fn add_unused_functions<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n     let ignore_unused_generics = tcx.sess.instrument_coverage_except_unused_generics();\n \n     let all_def_ids: DefIdSet = tcx\n-        .mir_keys(LOCAL_CRATE)\n+        .mir_keys(())\n         .iter()\n         .filter_map(|local_def_id| {\n             let def_id = local_def_id.to_def_id();\n@@ -276,11 +276,12 @@ fn add_unused_functions<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n         })\n         .collect();\n \n-    let codegenned_def_ids = tcx.codegened_and_inlined_items(LOCAL_CRATE);\n+    let codegenned_def_ids = tcx.codegened_and_inlined_items(());\n \n     let mut unused_def_ids_by_file: FxHashMap<Symbol, Vec<DefId>> = FxHashMap::default();\n     for &non_codegenned_def_id in all_def_ids.difference(codegenned_def_ids) {\n-        // Make sure the non-codegenned (unused) function has a file_name\n+        // Make sure the non-codegenned (unused) function has at least one MIR\n+        // `Coverage` statement with a code region, and return its file name.\n         if let Some(non_codegenned_file_name) = tcx.covered_file_name(non_codegenned_def_id) {\n             let def_ids =\n                 unused_def_ids_by_file.entry(*non_codegenned_file_name).or_insert_with(Vec::new);"}, {"sha": "019bf4a09a7870000ef18d685fa297c39642e595", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mod.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -223,7 +223,8 @@ fn declare_unused_fn(cx: &CodegenCx<'ll, 'tcx>, def_id: &DefId) -> Instance<'tcx\n \n fn codegen_unused_fn_and_counter(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'tcx>) {\n     let llfn = cx.get_fn(instance);\n-    let mut bx = Builder::new_block(cx, llfn, \"unused_function\");\n+    let llbb = Builder::append_block(cx, llfn, \"unused_function\");\n+    let mut bx = Builder::build(cx, llbb);\n     let fn_name = bx.get_pgo_func_name_var(instance);\n     let hash = bx.const_u64(0);\n     let num_counters = bx.const_u32(1);\n@@ -250,13 +251,9 @@ fn add_unused_function_coverage(\n             // Insert at least one real counter so the LLVM CoverageMappingReader will find expected\n             // definitions.\n             function_coverage.add_counter(UNUSED_FUNCTION_COUNTER_ID, code_region.clone());\n+        } else {\n+            function_coverage.add_unreachable_region(code_region.clone());\n         }\n-        // Add a Zero Counter for every code region.\n-        //\n-        // Even though the first coverage region already has an actual Counter, `llvm-cov` will not\n-        // always report it. Re-adding an unreachable region (zero counter) for the same region\n-        // seems to help produce the expected coverage.\n-        function_coverage.add_unreachable_region(code_region.clone());\n     }\n \n     if let Some(coverage_context) = cx.coverage_context() {"}, {"sha": "0db6659f8e256e467d46213c7363b55384d3d021", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 45, "deletions": 43, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -309,6 +309,7 @@ impl RecursiveTypeDescription<'ll, 'tcx> {\n                     unfinished_type,\n                     member_holding_stub,\n                     member_descriptions,\n+                    None,\n                 );\n                 MetadataCreationResult::new(metadata_stub, true)\n             }\n@@ -759,12 +760,12 @@ fn hex_encode(data: &[u8]) -> String {\n }\n \n pub fn file_metadata(cx: &CodegenCx<'ll, '_>, source_file: &SourceFile) -> &'ll DIFile {\n-    debug!(\"file_metadata: file_name: {}\", source_file.name);\n+    debug!(\"file_metadata: file_name: {:?}\", source_file.name);\n \n     let hash = Some(&source_file.src_hash);\n-    let file_name = Some(source_file.name.to_string());\n+    let file_name = Some(source_file.name.prefer_remapped().to_string());\n     let directory = if source_file.is_real_file() && !source_file.is_imported() {\n-        Some(cx.sess().working_dir.0.to_string_lossy().to_string())\n+        Some(cx.sess().working_dir.to_string_lossy(false).to_string())\n     } else {\n         // If the path comes from an upstream crate we assume it has been made\n         // independent of the compiler's working directory one way or another.\n@@ -992,11 +993,12 @@ pub fn compile_unit_metadata(\n     let producer = format!(\"clang LLVM ({})\", rustc_producer);\n \n     let name_in_debuginfo = name_in_debuginfo.to_string_lossy();\n-    let work_dir = tcx.sess.working_dir.0.to_string_lossy();\n+    let work_dir = tcx.sess.working_dir.to_string_lossy(false);\n     let flags = \"\\0\";\n-    let out_dir = &tcx.output_filenames(LOCAL_CRATE).out_directory;\n+    let output_filenames = tcx.output_filenames(());\n+    let out_dir = &output_filenames.out_directory;\n     let split_name = if tcx.sess.target_can_use_split_dwarf() {\n-        tcx.output_filenames(LOCAL_CRATE)\n+        output_filenames\n             .split_dwarf_path(tcx.sess.split_debuginfo(), Some(codegen_unit_name))\n             .map(|f| out_dir.join(f))\n     } else {\n@@ -1057,15 +1059,12 @@ pub fn compile_unit_metadata(\n         if tcx.sess.opts.debugging_opts.profile {\n             let cu_desc_metadata =\n                 llvm::LLVMRustMetadataAsValue(debug_context.llcontext, unit_metadata);\n-            let default_gcda_path = &tcx.output_filenames(LOCAL_CRATE).with_extension(\"gcda\");\n+            let default_gcda_path = &output_filenames.with_extension(\"gcda\");\n             let gcda_path =\n                 tcx.sess.opts.debugging_opts.profile_emit.as_ref().unwrap_or(default_gcda_path);\n \n             let gcov_cu_info = [\n-                path_to_mdstring(\n-                    debug_context.llcontext,\n-                    &tcx.output_filenames(LOCAL_CRATE).with_extension(\"gcno\"),\n-                ),\n+                path_to_mdstring(debug_context.llcontext, &output_filenames.with_extension(\"gcno\")),\n                 path_to_mdstring(debug_context.llcontext, &gcda_path),\n                 cu_desc_metadata,\n             ];\n@@ -1083,9 +1082,9 @@ pub fn compile_unit_metadata(\n             );\n         }\n \n-        // Insert `llvm.ident` metadata on the wasm32 targets since that will\n+        // Insert `llvm.ident` metadata on the wasm targets since that will\n         // get hooked up to the \"producer\" sections `processed-by` information.\n-        if tcx.sess.opts.target_triple.triple().starts_with(\"wasm32\") {\n+        if tcx.sess.target.is_like_wasm {\n             let name_metadata = llvm::LLVMMDStringInContext(\n                 debug_context.llcontext,\n                 rustc_producer.as_ptr().cast(),\n@@ -1459,6 +1458,7 @@ struct EnumMemberDescriptionFactory<'ll, 'tcx> {\n     layout: TyAndLayout<'tcx>,\n     tag_type_metadata: Option<&'ll DIType>,\n     containing_scope: &'ll DIScope,\n+    common_members: Vec<Option<&'ll DIType>>,\n     span: Span,\n }\n \n@@ -1493,10 +1493,6 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n         } else {\n             type_metadata(cx, self.enum_type, self.span)\n         };\n-        let flags = match self.enum_type.kind() {\n-            ty::Generator(..) => DIFlags::FlagArtificial,\n-            _ => DIFlags::FlagZero,\n-        };\n \n         match self.layout.variants {\n             Variants::Single { index } => {\n@@ -1523,14 +1519,15 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                     self.enum_type,\n                     variant_type_metadata,\n                     member_descriptions,\n+                    Some(&self.common_members),\n                 );\n                 vec![MemberDescription {\n                     name: if fallback { String::new() } else { variant_info.variant_name() },\n                     type_metadata: variant_type_metadata,\n                     offset: Size::ZERO,\n                     size: self.layout.size,\n                     align: self.layout.align.abi,\n-                    flags,\n+                    flags: DIFlags::FlagZero,\n                     discriminant: None,\n                     source_info: variant_info.source_info(cx),\n                 }]\n@@ -1572,6 +1569,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                             self.enum_type,\n                             variant_type_metadata,\n                             member_descriptions,\n+                            Some(&self.common_members),\n                         );\n \n                         MemberDescription {\n@@ -1584,7 +1582,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                             offset: Size::ZERO,\n                             size: self.layout.size,\n                             align: self.layout.align.abi,\n-                            flags,\n+                            flags: DIFlags::FlagZero,\n                             discriminant: Some(\n                                 self.layout.ty.discriminant_for_variant(cx.tcx, i).unwrap().val\n                                     as u64,\n@@ -1621,6 +1619,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                         self.enum_type,\n                         variant_type_metadata,\n                         variant_member_descriptions,\n+                        Some(&self.common_members),\n                     );\n \n                     // Encode the information about the null variant in the union\n@@ -1667,7 +1666,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                         offset: Size::ZERO,\n                         size: variant.size,\n                         align: variant.align.abi,\n-                        flags,\n+                        flags: DIFlags::FlagZero,\n                         discriminant: None,\n                         source_info: variant_info.source_info(cx),\n                     }]\n@@ -1695,6 +1694,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                                 self.enum_type,\n                                 variant_type_metadata,\n                                 member_descriptions,\n+                                Some(&self.common_members),\n                             );\n \n                             let niche_value = if i == dataful_variant {\n@@ -1717,7 +1717,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                                 offset: Size::ZERO,\n                                 size: self.layout.size,\n                                 align: self.layout.align.abi,\n-                                flags,\n+                                flags: DIFlags::FlagZero,\n                                 discriminant: niche_value,\n                                 source_info: variant_info.source_info(cx),\n                             }\n@@ -1849,13 +1849,6 @@ impl<'tcx> VariantInfo<'_, 'tcx> {\n         }\n         None\n     }\n-\n-    fn is_artificial(&self) -> bool {\n-        match self {\n-            VariantInfo::Generator { .. } => true,\n-            VariantInfo::Adt(..) => false,\n-        }\n-    }\n }\n \n /// Returns a tuple of (1) `type_metadata_stub` of the variant, (2) a\n@@ -1881,8 +1874,7 @@ fn describe_enum_variant(\n             &variant_name,\n             unique_type_id,\n             Some(containing_scope),\n-            // FIXME(tmandry): This doesn't seem to have any effect.\n-            if variant.is_artificial() { DIFlags::FlagArtificial } else { DIFlags::FlagZero },\n+            DIFlags::FlagZero,\n         )\n     });\n \n@@ -1945,11 +1937,6 @@ fn prepare_enum_metadata(\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n     let tcx = cx.tcx;\n     let enum_name = compute_debuginfo_type_name(tcx, enum_type, false);\n-    // FIXME(tmandry): This doesn't seem to have any effect.\n-    let enum_flags = match enum_type.kind() {\n-        ty::Generator(..) => DIFlags::FlagArtificial,\n-        _ => DIFlags::FlagZero,\n-    };\n \n     let containing_scope = get_namespace_for_item(cx, enum_def_id);\n     // FIXME: This should emit actual file metadata for the enum, but we\n@@ -2082,7 +2069,7 @@ fn prepare_enum_metadata(\n                     UNKNOWN_LINE_NUMBER,\n                     layout.size.bits(),\n                     layout.align.abi.bits() as u32,\n-                    enum_flags,\n+                    DIFlags::FlagZero,\n                     None,\n                     0, // RuntimeLang\n                     unique_type_id_str.as_ptr().cast(),\n@@ -2102,6 +2089,7 @@ fn prepare_enum_metadata(\n                 layout,\n                 tag_type_metadata: discriminant_type_metadata,\n                 containing_scope,\n+                common_members: vec![],\n                 span,\n             }),\n         );\n@@ -2171,7 +2159,7 @@ fn prepare_enum_metadata(\n         }\n     };\n \n-    let mut outer_fields = match layout.variants {\n+    let outer_fields = match layout.variants {\n         Variants::Single { .. } => vec![],\n         Variants::Multiple { .. } => {\n             let tuple_mdf = TupleMemberDescriptionFactory {\n@@ -2203,18 +2191,21 @@ fn prepare_enum_metadata(\n             UNKNOWN_LINE_NUMBER,\n             layout.size.bits(),\n             layout.align.abi.bits() as u32,\n-            enum_flags,\n+            DIFlags::FlagZero,\n             discriminator_metadata,\n             empty_array,\n             variant_part_unique_type_id_str.as_ptr().cast(),\n             variant_part_unique_type_id_str.len(),\n         )\n     };\n-    outer_fields.push(Some(variant_part));\n \n     let struct_wrapper = {\n         // The variant part must be wrapped in a struct according to DWARF.\n-        let type_array = create_DIArray(DIB(cx), &outer_fields);\n+        // All fields except the discriminant (including `outer_fields`)\n+        // should be put into structures inside the variant part, which gives\n+        // an equivalent layout but offers us much better integration with\n+        // debuggers.\n+        let type_array = create_DIArray(DIB(cx), &[Some(variant_part)]);\n \n         let type_map = debug_context(cx).type_map.borrow();\n         let unique_type_id_str = type_map.get_unique_type_id_as_string(unique_type_id);\n@@ -2229,7 +2220,7 @@ fn prepare_enum_metadata(\n                 UNKNOWN_LINE_NUMBER,\n                 layout.size.bits(),\n                 layout.align.abi.bits() as u32,\n-                enum_flags,\n+                DIFlags::FlagZero,\n                 None,\n                 type_array,\n                 0,\n@@ -2251,6 +2242,7 @@ fn prepare_enum_metadata(\n             layout,\n             tag_type_metadata: None,\n             containing_scope,\n+            common_members: outer_fields,\n             span,\n         }),\n     )\n@@ -2283,7 +2275,13 @@ fn composite_type_metadata(\n         DIFlags::FlagZero,\n     );\n     // ... and immediately create and add the member descriptions.\n-    set_members_of_composite_type(cx, composite_type, composite_type_metadata, member_descriptions);\n+    set_members_of_composite_type(\n+        cx,\n+        composite_type,\n+        composite_type_metadata,\n+        member_descriptions,\n+        None,\n+    );\n \n     composite_type_metadata\n }\n@@ -2293,6 +2291,7 @@ fn set_members_of_composite_type(\n     composite_type: Ty<'tcx>,\n     composite_type_metadata: &'ll DICompositeType,\n     member_descriptions: Vec<MemberDescription<'ll>>,\n+    common_members: Option<&Vec<Option<&'ll DIType>>>,\n ) {\n     // In some rare cases LLVM metadata uniquing would lead to an existing type\n     // description being used instead of a new one created in\n@@ -2311,10 +2310,13 @@ fn set_members_of_composite_type(\n         }\n     }\n \n-    let member_metadata: Vec<_> = member_descriptions\n+    let mut member_metadata: Vec<_> = member_descriptions\n         .into_iter()\n         .map(|desc| Some(desc.into_metadata(cx, composite_type_metadata)))\n         .collect();\n+    if let Some(other_members) = common_members {\n+        member_metadata.extend(other_members.iter());\n+    }\n \n     let type_params = compute_type_parameters(cx, composite_type);\n     unsafe {"}, {"sha": "2b99a2ebad979227ff6b6068f6cf69da962ff8d6", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -23,7 +23,7 @@ use rustc_codegen_ssa::mir::debuginfo::{DebugScope, FunctionDebugContext, Variab\n use rustc_codegen_ssa::traits::*;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n-use rustc_hir::def_id::{DefId, DefIdMap, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, DefIdMap};\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir;\n use rustc_middle::ty::layout::HasTyCtxt;\n@@ -343,8 +343,8 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         if self.sess().opts.optimize != config::OptLevel::No {\n             spflags |= DISPFlags::SPFlagOptimized;\n         }\n-        if let Some((id, _)) = self.tcx.entry_fn(LOCAL_CRATE) {\n-            if id.to_def_id() == def_id {\n+        if let Some((id, _)) = self.tcx.entry_fn(()) {\n+            if id == def_id {\n                 spflags |= DISPFlags::SPFlagMainSubprogram;\n             }\n         }"}, {"sha": "22d513d66d1cc87aeb4a84abc7473ed09d7650b8", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -678,7 +678,8 @@ fn gen_fn<'ll, 'tcx>(\n     cx.apply_target_cpu_attr(llfn);\n     // FIXME(eddyb) find a nicer way to do this.\n     unsafe { llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::InternalLinkage) };\n-    let bx = Builder::new_block(cx, llfn, \"entry-block\");\n+    let llbb = Builder::append_block(cx, llfn, \"entry-block\");\n+    let bx = Builder::build(cx, llbb);\n     codegen(bx);\n     llfn\n }\n@@ -1053,46 +1054,48 @@ fn generic_simd_intrinsic(\n         let vec_ty = bx.type_vector(elem_ty, in_len);\n \n         let (intr_name, fn_ty) = match name {\n-            sym::simd_fsqrt => (\"sqrt\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_fsin => (\"sin\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_fcos => (\"cos\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_fabs => (\"fabs\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_floor => (\"floor\", bx.type_func(&[vec_ty], vec_ty)),\n             sym::simd_ceil => (\"ceil\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_fexp => (\"exp\", bx.type_func(&[vec_ty], vec_ty)),\n+            sym::simd_fabs => (\"fabs\", bx.type_func(&[vec_ty], vec_ty)),\n+            sym::simd_fcos => (\"cos\", bx.type_func(&[vec_ty], vec_ty)),\n             sym::simd_fexp2 => (\"exp2\", bx.type_func(&[vec_ty], vec_ty)),\n+            sym::simd_fexp => (\"exp\", bx.type_func(&[vec_ty], vec_ty)),\n             sym::simd_flog10 => (\"log10\", bx.type_func(&[vec_ty], vec_ty)),\n             sym::simd_flog2 => (\"log2\", bx.type_func(&[vec_ty], vec_ty)),\n             sym::simd_flog => (\"log\", bx.type_func(&[vec_ty], vec_ty)),\n+            sym::simd_floor => (\"floor\", bx.type_func(&[vec_ty], vec_ty)),\n+            sym::simd_fma => (\"fma\", bx.type_func(&[vec_ty, vec_ty, vec_ty], vec_ty)),\n             sym::simd_fpowi => (\"powi\", bx.type_func(&[vec_ty, bx.type_i32()], vec_ty)),\n             sym::simd_fpow => (\"pow\", bx.type_func(&[vec_ty, vec_ty], vec_ty)),\n-            sym::simd_fma => (\"fma\", bx.type_func(&[vec_ty, vec_ty, vec_ty], vec_ty)),\n+            sym::simd_fsin => (\"sin\", bx.type_func(&[vec_ty], vec_ty)),\n+            sym::simd_fsqrt => (\"sqrt\", bx.type_func(&[vec_ty], vec_ty)),\n+            sym::simd_round => (\"round\", bx.type_func(&[vec_ty], vec_ty)),\n+            sym::simd_trunc => (\"trunc\", bx.type_func(&[vec_ty], vec_ty)),\n             _ => return_error!(\"unrecognized intrinsic `{}`\", name),\n         };\n-\n         let llvm_name = &format!(\"llvm.{0}.v{1}{2}\", intr_name, in_len, elem_ty_str);\n         let f = bx.declare_cfn(&llvm_name, llvm::UnnamedAddr::No, fn_ty);\n         let c = bx.call(f, &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(), None);\n-        unsafe { llvm::LLVMRustSetHasUnsafeAlgebra(c) };\n         Ok(c)\n     }\n \n     if std::matches!(\n         name,\n-        sym::simd_fsqrt\n-            | sym::simd_fsin\n-            | sym::simd_fcos\n+        sym::simd_ceil\n             | sym::simd_fabs\n-            | sym::simd_floor\n-            | sym::simd_ceil\n-            | sym::simd_fexp\n+            | sym::simd_fcos\n             | sym::simd_fexp2\n+            | sym::simd_fexp\n             | sym::simd_flog10\n             | sym::simd_flog2\n             | sym::simd_flog\n-            | sym::simd_fpowi\n-            | sym::simd_fpow\n+            | sym::simd_floor\n             | sym::simd_fma\n+            | sym::simd_fpow\n+            | sym::simd_fpowi\n+            | sym::simd_fsin\n+            | sym::simd_fsqrt\n+            | sym::simd_round\n+            | sym::simd_trunc\n     ) {\n         return simd_simple_float_intrinsic(name, in_elem, in_ty, in_len, bx, span, args);\n     }"}, {"sha": "728f1224dd86eb566f312a419c4b4c5e4fa4ad1f", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -8,12 +8,11 @@\n #![feature(bool_to_option)]\n #![feature(const_cstr_unchecked)]\n #![feature(crate_visibility_modifier)]\n-#![feature(extended_key_value_attributes)]\n+#![cfg_attr(bootstrap, feature(extended_key_value_attributes))]\n #![feature(extern_types)]\n #![feature(in_band_lifetimes)]\n #![feature(iter_zip)]\n #![feature(nll)]\n-#![cfg_attr(bootstrap, feature(or_patterns))]\n #![recursion_limit = \"256\"]\n \n use back::write::{create_informational_target_machine, create_target_machine};\n@@ -69,7 +68,6 @@ pub mod llvm {\n }\n \n mod llvm_util;\n-mod metadata;\n mod mono_item;\n mod type_;\n mod type_of;\n@@ -162,7 +160,7 @@ impl WriteBackendMethods for LlvmCodegenBackend {\n         module: &ModuleCodegen<Self::Module>,\n         config: &ModuleConfig,\n     ) -> Result<(), FatalError> {\n-        Ok(back::write::optimize(cgcx, diag_handler, module, config))\n+        back::write::optimize(cgcx, diag_handler, module, config)\n     }\n     unsafe fn optimize_thin(\n         cgcx: &CodegenContext<Self>,\n@@ -189,8 +187,9 @@ impl WriteBackendMethods for LlvmCodegenBackend {\n         module: &ModuleCodegen<Self::Module>,\n         config: &ModuleConfig,\n         thin: bool,\n-    ) {\n-        back::lto::run_pass_manager(cgcx, module, config, thin)\n+    ) -> Result<(), FatalError> {\n+        let diag_handler = cgcx.create_diag_handler();\n+        back::lto::run_pass_manager(cgcx, &diag_handler, module, config, thin)\n     }\n }\n \n@@ -250,16 +249,11 @@ impl CodegenBackend for LlvmCodegenBackend {\n     }\n \n     fn metadata_loader(&self) -> Box<MetadataLoaderDyn> {\n-        Box::new(metadata::LlvmMetadataLoader)\n+        Box::new(rustc_codegen_ssa::back::metadata::DefaultMetadataLoader)\n     }\n \n-    fn provide(&self, providers: &mut ty::query::Providers) {\n-        attributes::provide_both(providers);\n-    }\n-\n-    fn provide_extern(&self, providers: &mut ty::query::Providers) {\n-        attributes::provide_both(providers);\n-    }\n+    fn provide(&self, _providers: &mut ty::query::Providers) {}\n+    fn provide_extern(&self, _providers: &mut ty::query::Providers) {}\n \n     fn codegen_crate<'tcx>(\n         &self,\n@@ -270,6 +264,7 @@ impl CodegenBackend for LlvmCodegenBackend {\n         Box::new(rustc_codegen_ssa::base::codegen_crate(\n             LlvmCodegenBackend(()),\n             tcx,\n+            crate::llvm_util::target_cpu(tcx.sess).to_string(),\n             metadata,\n             need_metadata_module,\n         ))\n@@ -305,13 +300,11 @@ impl CodegenBackend for LlvmCodegenBackend {\n \n         // Run the linker on any artifacts that resulted from the LLVM run.\n         // This should produce either a finished executable or library.\n-        let target_cpu = crate::llvm_util::target_cpu(sess);\n         link_binary::<LlvmArchiveBuilder<'_>>(\n             sess,\n             &codegen_results,\n             outputs,\n             &codegen_results.crate_name.as_str(),\n-            target_cpu,\n         );\n \n         Ok(())"}, {"sha": "966be4a53fd5a12d3f6a5ea6ef524e7b57d49409", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 29, "deletions": 36, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -54,7 +54,7 @@ pub enum CallConv {\n }\n \n /// LLVMRustLinkage\n-#[derive(PartialEq)]\n+#[derive(Copy, Clone, PartialEq)]\n #[repr(C)]\n pub enum Linkage {\n     ExternalLinkage = 0,\n@@ -72,6 +72,7 @@ pub enum Linkage {\n \n // LLVMRustVisibility\n #[repr(C)]\n+#[derive(Copy, Clone)]\n pub enum Visibility {\n     Default = 0,\n     Hidden = 1,\n@@ -190,33 +191,6 @@ pub enum RealPredicate {\n     RealPredicateTrue = 15,\n }\n \n-impl RealPredicate {\n-    pub fn from_generic(realpred: rustc_codegen_ssa::common::RealPredicate) -> Self {\n-        match realpred {\n-            rustc_codegen_ssa::common::RealPredicate::RealPredicateFalse => {\n-                RealPredicate::RealPredicateFalse\n-            }\n-            rustc_codegen_ssa::common::RealPredicate::RealOEQ => RealPredicate::RealOEQ,\n-            rustc_codegen_ssa::common::RealPredicate::RealOGT => RealPredicate::RealOGT,\n-            rustc_codegen_ssa::common::RealPredicate::RealOGE => RealPredicate::RealOGE,\n-            rustc_codegen_ssa::common::RealPredicate::RealOLT => RealPredicate::RealOLT,\n-            rustc_codegen_ssa::common::RealPredicate::RealOLE => RealPredicate::RealOLE,\n-            rustc_codegen_ssa::common::RealPredicate::RealONE => RealPredicate::RealONE,\n-            rustc_codegen_ssa::common::RealPredicate::RealORD => RealPredicate::RealORD,\n-            rustc_codegen_ssa::common::RealPredicate::RealUNO => RealPredicate::RealUNO,\n-            rustc_codegen_ssa::common::RealPredicate::RealUEQ => RealPredicate::RealUEQ,\n-            rustc_codegen_ssa::common::RealPredicate::RealUGT => RealPredicate::RealUGT,\n-            rustc_codegen_ssa::common::RealPredicate::RealUGE => RealPredicate::RealUGE,\n-            rustc_codegen_ssa::common::RealPredicate::RealULT => RealPredicate::RealULT,\n-            rustc_codegen_ssa::common::RealPredicate::RealULE => RealPredicate::RealULE,\n-            rustc_codegen_ssa::common::RealPredicate::RealUNE => RealPredicate::RealUNE,\n-            rustc_codegen_ssa::common::RealPredicate::RealPredicateTrue => {\n-                RealPredicate::RealPredicateTrue\n-            }\n-        }\n-    }\n-}\n-\n /// LLVMTypeKind\n #[derive(Copy, Clone, PartialEq, Debug)]\n #[repr(C)]\n@@ -711,7 +685,7 @@ pub mod coverageinfo {\n     }\n \n     impl CounterMappingRegion {\n-        pub fn code_region(\n+        crate fn code_region(\n             counter: coverage_map::Counter,\n             file_id: u32,\n             start_line: u32,\n@@ -731,7 +705,10 @@ pub mod coverageinfo {\n             }\n         }\n \n-        pub fn expansion_region(\n+        // This function might be used in the future; the LLVM API is still evolving, as is coverage\n+        // support.\n+        #[allow(dead_code)]\n+        crate fn expansion_region(\n             file_id: u32,\n             expanded_file_id: u32,\n             start_line: u32,\n@@ -751,7 +728,10 @@ pub mod coverageinfo {\n             }\n         }\n \n-        pub fn skipped_region(\n+        // This function might be used in the future; the LLVM API is still evolving, as is coverage\n+        // support.\n+        #[allow(dead_code)]\n+        crate fn skipped_region(\n             file_id: u32,\n             start_line: u32,\n             start_col: u32,\n@@ -770,7 +750,10 @@ pub mod coverageinfo {\n             }\n         }\n \n-        pub fn gap_region(\n+        // This function might be used in the future; the LLVM API is still evolving, as is coverage\n+        // support.\n+        #[allow(dead_code)]\n+        crate fn gap_region(\n             counter: coverage_map::Counter,\n             file_id: u32,\n             start_line: u32,\n@@ -1031,6 +1014,7 @@ extern \"C\" {\n     pub fn LLVMSetSection(Global: &Value, Section: *const c_char);\n     pub fn LLVMRustGetVisibility(Global: &Value) -> Visibility;\n     pub fn LLVMRustSetVisibility(Global: &Value, Viz: Visibility);\n+    pub fn LLVMRustSetDSOLocal(Global: &Value, is_dso_local: bool);\n     pub fn LLVMGetAlignment(Global: &Value) -> c_uint;\n     pub fn LLVMSetAlignment(Global: &Value, Bytes: c_uint);\n     pub fn LLVMSetDLLStorageClass(V: &Value, C: DLLStorageClass);\n@@ -1096,7 +1080,6 @@ extern \"C\" {\n         Fn: &'a Value,\n         Name: *const c_char,\n     ) -> &'a BasicBlock;\n-    pub fn LLVMDeleteBasicBlock(BB: &BasicBlock);\n \n     // Operations on instructions\n     pub fn LLVMIsAInstruction(Val: &Value) -> Option<&Value>;\n@@ -1371,7 +1354,7 @@ extern \"C\" {\n     pub fn LLVMBuildNeg(B: &Builder<'a>, V: &'a Value, Name: *const c_char) -> &'a Value;\n     pub fn LLVMBuildFNeg(B: &Builder<'a>, V: &'a Value, Name: *const c_char) -> &'a Value;\n     pub fn LLVMBuildNot(B: &Builder<'a>, V: &'a Value, Name: *const c_char) -> &'a Value;\n-    pub fn LLVMRustSetHasUnsafeAlgebra(Instr: &Value);\n+    pub fn LLVMRustSetFastMath(Instr: &Value);\n \n     // Memory\n     pub fn LLVMBuildAlloca(B: &Builder<'a>, Ty: &'a Type, Name: *const c_char) -> &'a Value;\n@@ -2145,7 +2128,13 @@ extern \"C\" {\n     pub fn LLVMRustHasFeature(T: &TargetMachine, s: *const c_char) -> bool;\n \n     pub fn LLVMRustPrintTargetCPUs(T: &TargetMachine);\n-    pub fn LLVMRustPrintTargetFeatures(T: &TargetMachine);\n+    pub fn LLVMRustGetTargetFeaturesCount(T: &TargetMachine) -> size_t;\n+    pub fn LLVMRustGetTargetFeature(\n+        T: &TargetMachine,\n+        Index: size_t,\n+        Feature: &mut *const c_char,\n+        Desc: &mut *const c_char,\n+    );\n \n     pub fn LLVMRustGetHostCPUName(len: *mut usize) -> *const c_char;\n     pub fn LLVMRustCreateTargetMachine(\n@@ -2214,10 +2203,14 @@ extern \"C\" {\n         SanitizerOptions: Option<&SanitizerOptions>,\n         PGOGenPath: *const c_char,\n         PGOUsePath: *const c_char,\n+        InstrumentCoverage: bool,\n+        InstrumentGCOV: bool,\n         llvm_selfprofiler: *mut c_void,\n         begin_callback: SelfProfileBeforePassCallback,\n         end_callback: SelfProfileAfterPassCallback,\n-    );\n+        ExtraPasses: *const c_char,\n+        ExtraPassesLen: size_t,\n+    ) -> LLVMRustResult;\n     pub fn LLVMRustPrintModule(\n         M: &'a Module,\n         Output: *const c_char,"}, {"sha": "387062a671d253c900a5b9b0647c8b83f18c0463", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 98, "deletions": 21, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -10,6 +10,7 @@ use rustc_span::symbol::Symbol;\n use rustc_target::spec::{MergeFunctions, PanicStrategy};\n use std::ffi::{CStr, CString};\n \n+use std::ptr;\n use std::slice;\n use std::str;\n use std::sync::atomic::{AtomicBool, Ordering};\n@@ -151,6 +152,12 @@ pub fn to_llvm_feature<'a>(sess: &Session, s: &'a str) -> &'a str {\n         (\"x86\", \"avx512vpclmulqdq\") => \"vpclmulqdq\",\n         (\"aarch64\", \"fp\") => \"fp-armv8\",\n         (\"aarch64\", \"fp16\") => \"fullfp16\",\n+        (\"aarch64\", \"fhm\") => \"fp16fml\",\n+        (\"aarch64\", \"rcpc2\") => \"rcpc-immo\",\n+        (\"aarch64\", \"dpb\") => \"ccpp\",\n+        (\"aarch64\", \"dpb2\") => \"ccdp\",\n+        (\"aarch64\", \"frintts\") => \"fptoint\",\n+        (\"aarch64\", \"fcma\") => \"complxnum\",\n         (_, s) => s,\n     }\n }\n@@ -192,15 +199,77 @@ pub fn print_passes() {\n     }\n }\n \n+fn llvm_target_features(tm: &llvm::TargetMachine) -> Vec<(&str, &str)> {\n+    let len = unsafe { llvm::LLVMRustGetTargetFeaturesCount(tm) };\n+    let mut ret = Vec::with_capacity(len);\n+    for i in 0..len {\n+        unsafe {\n+            let mut feature = ptr::null();\n+            let mut desc = ptr::null();\n+            llvm::LLVMRustGetTargetFeature(tm, i, &mut feature, &mut desc);\n+            if feature.is_null() || desc.is_null() {\n+                bug!(\"LLVM returned a `null` target feature string\");\n+            }\n+            let feature = CStr::from_ptr(feature).to_str().unwrap_or_else(|e| {\n+                bug!(\"LLVM returned a non-utf8 feature string: {}\", e);\n+            });\n+            let desc = CStr::from_ptr(desc).to_str().unwrap_or_else(|e| {\n+                bug!(\"LLVM returned a non-utf8 feature string: {}\", e);\n+            });\n+            ret.push((feature, desc));\n+        }\n+    }\n+    ret\n+}\n+\n+fn print_target_features(sess: &Session, tm: &llvm::TargetMachine) {\n+    let mut target_features = llvm_target_features(tm);\n+    let mut rustc_target_features = supported_target_features(sess)\n+        .iter()\n+        .filter_map(|(feature, _gate)| {\n+            let llvm_feature = to_llvm_feature(sess, *feature);\n+            // LLVM asserts that these are sorted. LLVM and Rust both use byte comparison for these strings.\n+            target_features.binary_search_by_key(&llvm_feature, |(f, _d)| *f).ok().map(|index| {\n+                let (_f, desc) = target_features.remove(index);\n+                (*feature, desc)\n+            })\n+        })\n+        .collect::<Vec<_>>();\n+    rustc_target_features.extend_from_slice(&[(\n+        \"crt-static\",\n+        \"Enables C Run-time Libraries to be statically linked\",\n+    )]);\n+    let max_feature_len = target_features\n+        .iter()\n+        .chain(rustc_target_features.iter())\n+        .map(|(feature, _desc)| feature.len())\n+        .max()\n+        .unwrap_or(0);\n+\n+    println!(\"Features supported by rustc for this target:\");\n+    for (feature, desc) in &rustc_target_features {\n+        println!(\"    {1:0$} - {2}.\", max_feature_len, feature, desc);\n+    }\n+    println!(\"\\nCode-generation features supported by LLVM for this target:\");\n+    for (feature, desc) in &target_features {\n+        println!(\"    {1:0$} - {2}.\", max_feature_len, feature, desc);\n+    }\n+    if target_features.len() == 0 {\n+        println!(\"    Target features listing is not supported by this LLVM version.\");\n+    }\n+    println!(\"\\nUse +feature to enable a feature, or -feature to disable it.\");\n+    println!(\"For example, rustc -C target-cpu=mycpu -C target-feature=+feature1,-feature2\\n\");\n+    println!(\"Code-generation features cannot be used in cfg or #[target_feature],\");\n+    println!(\"and may be renamed or removed in a future version of LLVM or rustc.\\n\");\n+}\n+\n pub(crate) fn print(req: PrintRequest, sess: &Session) {\n     require_inited();\n     let tm = create_informational_target_machine(sess);\n-    unsafe {\n-        match req {\n-            PrintRequest::TargetCPUs => llvm::LLVMRustPrintTargetCPUs(tm),\n-            PrintRequest::TargetFeatures => llvm::LLVMRustPrintTargetFeatures(tm),\n-            _ => bug!(\"rustc_codegen_llvm can't handle print request: {:?}\", req),\n-        }\n+    match req {\n+        PrintRequest::TargetCPUs => unsafe { llvm::LLVMRustPrintTargetCPUs(tm) },\n+        PrintRequest::TargetFeatures => print_target_features(sess, tm),\n+        _ => bug!(\"rustc_codegen_llvm can't handle print request: {:?}\", req),\n     }\n }\n \n@@ -276,24 +345,32 @@ pub fn llvm_global_features(sess: &Session) -> Vec<String> {\n         Some(_) | None => {}\n     };\n \n+    let filter = |s: &str| {\n+        if s.is_empty() {\n+            return None;\n+        }\n+        let feature = if s.starts_with(\"+\") || s.starts_with(\"-\") {\n+            &s[1..]\n+        } else {\n+            return Some(s.to_string());\n+        };\n+        // Rustc-specific feature requests like `+crt-static` or `-crt-static`\n+        // are not passed down to LLVM.\n+        if RUSTC_SPECIFIC_FEATURES.contains(&feature) {\n+            return None;\n+        }\n+        // ... otherwise though we run through `to_llvm_feature` feature when\n+        // passing requests down to LLVM. This means that all in-language\n+        // features also work on the command line instead of having two\n+        // different names when the LLVM name and the Rust name differ.\n+        Some(format!(\"{}{}\", &s[..1], to_llvm_feature(sess, feature)))\n+    };\n+\n     // Features implied by an implicit or explicit `--target`.\n-    features.extend(\n-        sess.target\n-            .features\n-            .split(',')\n-            .filter(|f| !f.is_empty() && !RUSTC_SPECIFIC_FEATURES.iter().any(|s| f.contains(s)))\n-            .map(String::from),\n-    );\n+    features.extend(sess.target.features.split(',').filter_map(&filter));\n \n     // -Ctarget-features\n-    features.extend(\n-        sess.opts\n-            .cg\n-            .target_feature\n-            .split(',')\n-            .filter(|f| !f.is_empty() && !RUSTC_SPECIFIC_FEATURES.iter().any(|s| f.contains(s)))\n-            .map(String::from),\n-    );\n+    features.extend(sess.opts.cg.target_feature.split(',').filter_map(&filter));\n \n     features\n }"}, {"sha": "b007df5730621e7e368067afcd68a5055f721f15", "filename": "compiler/rustc_codegen_llvm/src/metadata.rs", "status": "removed", "additions": 0, "deletions": 112, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/3b2b5b2914d40aa011d189bfe546084cdee53dbe/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b2b5b2914d40aa011d189bfe546084cdee53dbe/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmetadata.rs?ref=3b2b5b2914d40aa011d189bfe546084cdee53dbe", "patch": "@@ -1,112 +0,0 @@\n-use crate::llvm;\n-use crate::llvm::archive_ro::ArchiveRO;\n-use crate::llvm::{mk_section_iter, False, ObjectFile};\n-use rustc_middle::middle::cstore::MetadataLoader;\n-use rustc_target::spec::Target;\n-\n-use rustc_codegen_ssa::METADATA_FILENAME;\n-use rustc_data_structures::owning_ref::OwningRef;\n-use rustc_data_structures::rustc_erase_owner;\n-use tracing::debug;\n-\n-use rustc_fs_util::path_to_c_string;\n-use std::path::Path;\n-use std::slice;\n-\n-pub use rustc_data_structures::sync::MetadataRef;\n-\n-pub struct LlvmMetadataLoader;\n-\n-impl MetadataLoader for LlvmMetadataLoader {\n-    fn get_rlib_metadata(&self, _: &Target, filename: &Path) -> Result<MetadataRef, String> {\n-        // Use ArchiveRO for speed here, it's backed by LLVM and uses mmap\n-        // internally to read the file. We also avoid even using a memcpy by\n-        // just keeping the archive along while the metadata is in use.\n-        let archive =\n-            ArchiveRO::open(filename).map(|ar| OwningRef::new(Box::new(ar))).map_err(|e| {\n-                debug!(\"llvm didn't like `{}`: {}\", filename.display(), e);\n-                format!(\"failed to read rlib metadata in '{}': {}\", filename.display(), e)\n-            })?;\n-        let buf: OwningRef<_, [u8]> = archive.try_map(|ar| {\n-            ar.iter()\n-                .filter_map(|s| s.ok())\n-                .find(|sect| sect.name() == Some(METADATA_FILENAME))\n-                .map(|s| s.data())\n-                .ok_or_else(|| {\n-                    debug!(\"didn't find '{}' in the archive\", METADATA_FILENAME);\n-                    format!(\"failed to read rlib metadata: '{}'\", filename.display())\n-                })\n-        })?;\n-        Ok(rustc_erase_owner!(buf))\n-    }\n-\n-    fn get_dylib_metadata(&self, target: &Target, filename: &Path) -> Result<MetadataRef, String> {\n-        unsafe {\n-            let buf = path_to_c_string(filename);\n-            let mb = llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf.as_ptr())\n-                .ok_or_else(|| format!(\"error reading library: '{}'\", filename.display()))?;\n-            let of =\n-                ObjectFile::new(mb).map(|of| OwningRef::new(Box::new(of))).ok_or_else(|| {\n-                    format!(\"provided path not an object file: '{}'\", filename.display())\n-                })?;\n-            let buf = of.try_map(|of| search_meta_section(of, target, filename))?;\n-            Ok(rustc_erase_owner!(buf))\n-        }\n-    }\n-}\n-\n-fn search_meta_section<'a>(\n-    of: &'a ObjectFile,\n-    target: &Target,\n-    filename: &Path,\n-) -> Result<&'a [u8], String> {\n-    unsafe {\n-        let si = mk_section_iter(of.llof);\n-        while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n-            let mut name_buf = None;\n-            let name_len = llvm::LLVMRustGetSectionName(si.llsi, &mut name_buf);\n-            let name = name_buf.map_or_else(\n-                String::new, // We got a NULL ptr, ignore `name_len`.\n-                |buf| {\n-                    String::from_utf8(\n-                        slice::from_raw_parts(buf.as_ptr() as *const u8, name_len as usize)\n-                            .to_vec(),\n-                    )\n-                    .unwrap()\n-                },\n-            );\n-            debug!(\"get_metadata_section: name {}\", name);\n-            if read_metadata_section_name(target) == name {\n-                let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n-                let csz = llvm::LLVMGetSectionSize(si.llsi) as usize;\n-                // The buffer is valid while the object file is around\n-                let buf: &'a [u8] = slice::from_raw_parts(cbuf as *const u8, csz);\n-                return Ok(buf);\n-            }\n-            llvm::LLVMMoveToNextSection(si.llsi);\n-        }\n-    }\n-    Err(format!(\"metadata not found: '{}'\", filename.display()))\n-}\n-\n-pub fn metadata_section_name(target: &Target) -> &'static str {\n-    // Historical note:\n-    //\n-    // When using link.exe it was seen that the section name `.note.rustc`\n-    // was getting shortened to `.note.ru`, and according to the PE and COFF\n-    // specification:\n-    //\n-    // > Executable images do not use a string table and do not support\n-    // > section names longer than 8\u00a0characters\n-    //\n-    // https://docs.microsoft.com/en-us/windows/win32/debug/pe-format\n-    //\n-    // As a result, we choose a slightly shorter name! As to why\n-    // `.note.rustc` works on MinGW, that's another good question...\n-\n-    if target.is_like_osx { \"__DATA,.rustc\" } else { \".rustc\" }\n-}\n-\n-fn read_metadata_section_name(_target: &Target) -> &'static str {\n-    \".rustc\"\n-}"}, {"sha": "fc1f364e9c6bc9baee49a661c6b8a4a4dd31774c", "filename": "compiler/rustc_codegen_llvm/src/mono_item.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -10,7 +10,9 @@ pub use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::mir::mono::{Linkage, Visibility};\n use rustc_middle::ty::layout::FnAbiExt;\n use rustc_middle::ty::{self, Instance, TypeFoldable};\n+use rustc_session::config::CrateType;\n use rustc_target::abi::LayoutOf;\n+use rustc_target::spec::RelocModel;\n use tracing::debug;\n \n impl PreDefineMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n@@ -35,6 +37,9 @@ impl PreDefineMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         unsafe {\n             llvm::LLVMRustSetLinkage(g, base::linkage_to_llvm(linkage));\n             llvm::LLVMRustSetVisibility(g, base::visibility_to_llvm(visibility));\n+            if self.should_assume_dso_local(linkage, visibility) {\n+                llvm::LLVMRustSetDSOLocal(g, true);\n+            }\n         }\n \n         self.instances.borrow_mut().insert(instance, g);\n@@ -79,6 +84,42 @@ impl PreDefineMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n         attributes::from_fn_attrs(self, lldecl, instance);\n \n+        unsafe {\n+            if self.should_assume_dso_local(linkage, visibility) {\n+                llvm::LLVMRustSetDSOLocal(lldecl, true);\n+            }\n+        }\n+\n         self.instances.borrow_mut().insert(instance, lldecl);\n     }\n }\n+\n+impl CodegenCx<'ll, 'tcx> {\n+    /// Whether a definition (NB: not declaration!) can be assumed to be local to a group of\n+    /// libraries that form a single DSO or executable.\n+    pub(crate) unsafe fn should_assume_dso_local(\n+        &self,\n+        linkage: Linkage,\n+        visibility: Visibility,\n+    ) -> bool {\n+        if matches!(linkage, Linkage::Internal | Linkage::Private) {\n+            return true;\n+        }\n+\n+        if visibility != Visibility::Default && linkage != Linkage::ExternalWeak {\n+            return true;\n+        }\n+\n+        // Static relocation model should force copy relocations everywhere.\n+        if self.tcx.sess.relocation_model() == RelocModel::Static {\n+            return true;\n+        }\n+\n+        // Symbols from executables can't really be imported any further.\n+        if self.tcx.sess.crate_types().iter().all(|ty| *ty == CrateType::Executable) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+}"}, {"sha": "68f40d5f8639593c86dd35f092ad3c1895f80463", "filename": "compiler/rustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2FCargo.toml?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -9,13 +9,12 @@ test = false\n \n [dependencies]\n bitflags = \"1.2.1\"\n-cc = \"1.0.1\"\n+cc = \"1.0.67\"\n itertools = \"0.9\"\n-memmap2 = \"0.2.1\"\n tracing = \"0.1\"\n libc = \"0.2.50\"\n-jobserver = \"0.1.11\"\n-tempfile = \"3.1\"\n+jobserver = \"0.1.22\"\n+tempfile = \"3.2\"\n pathdiff = \"0.2.0\"\n \n rustc_serialize = { path = \"../rustc_serialize\" }\n@@ -34,3 +33,8 @@ rustc_index = { path = \"../rustc_index\" }\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_session = { path = \"../rustc_session\" }\n+\n+[dependencies.object]\n+version = \"0.22.0\"\n+default-features = false\n+features = [\"read_core\", \"elf\", \"macho\", \"pe\", \"unaligned\", \"archive\"]"}, {"sha": "c197d48d4ea64da30bbea8ef8ff51978f08a74fa", "filename": "compiler/rustc_codegen_ssa/src/back/archive.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -4,11 +4,19 @@ use rustc_span::symbol::Symbol;\n use std::io;\n use std::path::{Path, PathBuf};\n \n-pub fn find_library(name: Symbol, search_paths: &[PathBuf], sess: &Session) -> PathBuf {\n+pub fn find_library(\n+    name: Symbol,\n+    verbatim: bool,\n+    search_paths: &[PathBuf],\n+    sess: &Session,\n+) -> PathBuf {\n     // On Windows, static libraries sometimes show up as libfoo.a and other\n     // times show up as foo.lib\n-    let oslibname =\n-        format!(\"{}{}{}\", sess.target.staticlib_prefix, name, sess.target.staticlib_suffix);\n+    let oslibname = if verbatim {\n+        name.to_string()\n+    } else {\n+        format!(\"{}{}{}\", sess.target.staticlib_prefix, name, sess.target.staticlib_suffix)\n+    };\n     let unixlibname = format!(\"lib{}.a\", name);\n \n     for path in search_paths {\n@@ -45,7 +53,7 @@ pub trait ArchiveBuilder<'a> {\n         lto: bool,\n         skip_objects: bool,\n     ) -> io::Result<()>;\n-    fn add_native_library(&mut self, name: Symbol);\n+    fn add_native_library(&mut self, name: Symbol, verbatim: bool);\n     fn update_symbols(&mut self);\n \n     fn build(self);"}, {"sha": "32275e9b073481d97b4b7c41fc960ac500743fc8", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 81, "deletions": 64, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -6,7 +6,7 @@ use rustc_hir::def_id::CrateNum;\n use rustc_middle::middle::cstore::{EncodedMetadata, LibSource};\n use rustc_middle::middle::dependency_format::Linkage;\n use rustc_session::config::{self, CFGuard, CrateType, DebugInfo};\n-use rustc_session::config::{OutputFilenames, OutputType, PrintRequest, SanitizerSet};\n+use rustc_session::config::{OutputFilenames, OutputType, PrintRequest};\n use rustc_session::output::{check_file_is_writeable, invalid_output_for_target, out_filename};\n use rustc_session::search_paths::PathKind;\n use rustc_session::utils::NativeLibKind;\n@@ -16,7 +16,7 @@ use rustc_session::{filesearch, Session};\n use rustc_span::symbol::Symbol;\n use rustc_target::spec::crt_objects::{CrtObjects, CrtObjectsFallback};\n use rustc_target::spec::{LinkOutputKind, LinkerFlavor, LldFlavor, SplitDebuginfo};\n-use rustc_target::spec::{PanicStrategy, RelocModel, RelroLevel, Target};\n+use rustc_target::spec::{PanicStrategy, RelocModel, RelroLevel, SanitizerSet, Target};\n \n use super::archive::ArchiveBuilder;\n use super::command::Command;\n@@ -50,7 +50,6 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n     codegen_results: &CodegenResults,\n     outputs: &OutputFilenames,\n     crate_name: &str,\n-    target_cpu: &str,\n ) {\n     let _timer = sess.timer(\"link_binary\");\n     let output_metadata = sess.opts.output_types.contains_key(&OutputType::Metadata);\n@@ -100,7 +99,6 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n                         &out_filename,\n                         codegen_results,\n                         path.as_ref(),\n-                        target_cpu,\n                     );\n                 }\n             }\n@@ -329,15 +327,15 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n     // metadata of the rlib we're generating somehow.\n     for lib in codegen_results.crate_info.used_libraries.iter() {\n         match lib.kind {\n-            NativeLibKind::StaticBundle => {}\n-            NativeLibKind::StaticNoBundle\n-            | NativeLibKind::Dylib\n-            | NativeLibKind::Framework\n+            NativeLibKind::Static { bundle: None | Some(true), .. } => {}\n+            NativeLibKind::Static { bundle: Some(false), .. }\n+            | NativeLibKind::Dylib { .. }\n+            | NativeLibKind::Framework { .. }\n             | NativeLibKind::RawDylib\n             | NativeLibKind::Unspecified => continue,\n         }\n         if let Some(name) = lib.name {\n-            ab.add_native_library(name);\n+            ab.add_native_library(name, lib.verbatim.unwrap_or(false));\n         }\n     }\n \n@@ -430,9 +428,10 @@ fn link_staticlib<'a, B: ArchiveBuilder<'a>>(\n         // Clearly this is not sufficient for a general purpose feature, and\n         // we'd want to read from the library's metadata to determine which\n         // object files come from where and selectively skip them.\n-        let skip_object_files = native_libs\n-            .iter()\n-            .any(|lib| lib.kind == NativeLibKind::StaticBundle && !relevant_lib(sess, lib));\n+        let skip_object_files = native_libs.iter().any(|lib| {\n+            matches!(lib.kind, NativeLibKind::Static { bundle: None | Some(true), .. })\n+                && !relevant_lib(sess, lib)\n+        });\n         ab.add_rlib(\n             path,\n             &name.as_str(),\n@@ -531,7 +530,6 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n     out_filename: &Path,\n     codegen_results: &CodegenResults,\n     tmpdir: &Path,\n-    target_cpu: &str,\n ) {\n     info!(\"preparing {:?} to {:?}\", crate_type, out_filename);\n     let (linker_path, flavor) = linker_and_flavor(sess);\n@@ -543,7 +541,6 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n         tmpdir,\n         out_filename,\n         codegen_results,\n-        target_cpu,\n     );\n \n     linker::disable_localization(&mut cmd);\n@@ -922,28 +919,20 @@ fn link_sanitizer_runtime(sess: &Session, linker: &mut dyn Linker, name: &str) {\n         .map(|channel| format!(\"-{}\", channel))\n         .unwrap_or_default();\n \n-    match sess.opts.target_triple.triple() {\n-        \"aarch64-apple-darwin\" | \"x86_64-apple-darwin\" => {\n-            // On Apple platforms, the sanitizer is always built as a dylib, and\n-            // LLVM will link to `@rpath/*.dylib`, so we need to specify an\n-            // rpath to the library as well (the rpath should be absolute, see\n-            // PR #41352 for details).\n-            let filename = format!(\"rustc{}_rt.{}\", channel, name);\n-            let path = find_sanitizer_runtime(&sess, &filename);\n-            let rpath = path.to_str().expect(\"non-utf8 component in path\");\n-            linker.args(&[\"-Wl,-rpath\", \"-Xlinker\", rpath]);\n-            linker.link_dylib(Symbol::intern(&filename));\n-        }\n-        \"aarch64-fuchsia\"\n-        | \"aarch64-unknown-linux-gnu\"\n-        | \"x86_64-fuchsia\"\n-        | \"x86_64-unknown-freebsd\"\n-        | \"x86_64-unknown-linux-gnu\" => {\n-            let filename = format!(\"librustc{}_rt.{}.a\", channel, name);\n-            let path = find_sanitizer_runtime(&sess, &filename).join(&filename);\n-            linker.link_whole_rlib(&path);\n-        }\n-        _ => {}\n+    if sess.target.is_like_osx {\n+        // On Apple platforms, the sanitizer is always built as a dylib, and\n+        // LLVM will link to `@rpath/*.dylib`, so we need to specify an\n+        // rpath to the library as well (the rpath should be absolute, see\n+        // PR #41352 for details).\n+        let filename = format!(\"rustc{}_rt.{}\", channel, name);\n+        let path = find_sanitizer_runtime(&sess, &filename);\n+        let rpath = path.to_str().expect(\"non-utf8 component in path\");\n+        linker.args(&[\"-Wl,-rpath\", \"-Xlinker\", rpath]);\n+        linker.link_dylib(Symbol::intern(&filename), false, true);\n+    } else {\n+        let filename = format!(\"librustc{}_rt.{}.a\", channel, name);\n+        let path = find_sanitizer_runtime(&sess, &filename).join(&filename);\n+        linker.link_whole_rlib(&path);\n     }\n }\n \n@@ -1088,21 +1077,25 @@ fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLib]) {\n         .filter_map(|lib| {\n             let name = lib.name?;\n             match lib.kind {\n-                NativeLibKind::StaticNoBundle\n-                | NativeLibKind::Dylib\n+                NativeLibKind::Static { bundle: Some(false), .. }\n+                | NativeLibKind::Dylib { .. }\n                 | NativeLibKind::Unspecified => {\n+                    let verbatim = lib.verbatim.unwrap_or(false);\n                     if sess.target.is_like_msvc {\n-                        Some(format!(\"{}.lib\", name))\n+                        Some(format!(\"{}{}\", name, if verbatim { \"\" } else { \".lib\" }))\n+                    } else if sess.target.linker_is_gnu {\n+                        Some(format!(\"-l{}{}\", if verbatim { \":\" } else { \"\" }, name))\n                     } else {\n                         Some(format!(\"-l{}\", name))\n                     }\n                 }\n-                NativeLibKind::Framework => {\n+                NativeLibKind::Framework { .. } => {\n                     // ld-only syntax, since there are no frameworks in MSVC\n                     Some(format!(\"-framework {}\", name))\n                 }\n                 // These are included, no need to print them\n-                NativeLibKind::StaticBundle | NativeLibKind::RawDylib => None,\n+                NativeLibKind::Static { bundle: None | Some(true), .. }\n+                | NativeLibKind::RawDylib => None,\n             }\n         })\n         .collect();\n@@ -1419,15 +1412,10 @@ fn add_link_script(cmd: &mut dyn Linker, sess: &Session, tmpdir: &Path, crate_ty\n     }\n }\n \n-/// Add arbitrary \"user defined\" args defined from command line and by `#[link_args]` attributes.\n+/// Add arbitrary \"user defined\" args defined from command line.\n /// FIXME: Determine where exactly these args need to be inserted.\n-fn add_user_defined_link_args(\n-    cmd: &mut dyn Linker,\n-    sess: &Session,\n-    codegen_results: &CodegenResults,\n-) {\n+fn add_user_defined_link_args(cmd: &mut dyn Linker, sess: &Session) {\n     cmd.args(&sess.opts.cg.link_args);\n-    cmd.args(&*codegen_results.crate_info.link_args);\n }\n \n /// Add arbitrary \"late link\" args defined by the target spec.\n@@ -1584,7 +1572,7 @@ fn add_rpath_args(\n         let target_triple = sess.opts.target_triple.triple();\n         let mut get_install_prefix_lib_path = || {\n             let install_prefix = option_env!(\"CFG_PREFIX\").expect(\"CFG_PREFIX\");\n-            let tlib = filesearch::relative_target_lib_path(&sess.sysroot, target_triple);\n+            let tlib = rustc_target::target_rustlib_path(&sess.sysroot, target_triple).join(\"lib\");\n             let mut path = PathBuf::from(install_prefix);\n             path.push(&tlib);\n \n@@ -1617,14 +1605,13 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     tmpdir: &Path,\n     out_filename: &Path,\n     codegen_results: &CodegenResults,\n-    target_cpu: &str,\n ) -> Command {\n     let crt_objects_fallback = crt_objects_fallback(sess, crate_type);\n     let base_cmd = get_linker(sess, path, flavor, crt_objects_fallback);\n     // FIXME: Move `/LIBPATH` addition for uwp targets from the linker construction\n     // to the linker args construction.\n     assert!(base_cmd.get_args().is_empty() || sess.target.vendor == \"uwp\");\n-    let cmd = &mut *codegen_results.linker_info.to_linker(base_cmd, &sess, flavor, target_cpu);\n+    let cmd = &mut *codegen_results.linker_info.to_linker(base_cmd, &sess, flavor);\n     let link_output_kind = link_output_kind(sess, crate_type);\n \n     // NO-OPT-OUT, OBJECT-FILES-MAYBE, CUSTOMIZATION-POINT\n@@ -1651,6 +1638,10 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n         cmd.add_eh_frame_header();\n     }\n \n+    // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n+    // Make the binary compatible with data execution prevention schemes.\n+    cmd.add_no_exec();\n+\n     // NO-OPT-OUT, OBJECT-FILES-NO\n     // Avoid linking to dynamic libraries unless they satisfy some undefined symbols\n     // at the point at which they are specified on the command line.\n@@ -1765,7 +1756,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     add_rpath_args(cmd, sess, codegen_results, out_filename);\n \n     // OBJECT-FILES-MAYBE, CUSTOMIZATION-POINT\n-    add_user_defined_link_args(cmd, sess, codegen_results);\n+    add_user_defined_link_args(cmd, sess);\n \n     // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n     cmd.finalize();\n@@ -1812,16 +1803,30 @@ fn add_local_native_libraries(\n         codegen_results.crate_info.used_libraries.iter().filter(|l| relevant_lib(sess, l));\n \n     let search_path = archive_search_paths(sess);\n+    let mut last = (NativeLibKind::Unspecified, None);\n     for lib in relevant_libs {\n         let name = match lib.name {\n             Some(l) => l,\n             None => continue,\n         };\n+\n+        // Skip if this library is the same as the last.\n+        last = if (lib.kind, lib.name) == last { continue } else { (lib.kind, lib.name) };\n+\n+        let verbatim = lib.verbatim.unwrap_or(false);\n         match lib.kind {\n-            NativeLibKind::Dylib | NativeLibKind::Unspecified => cmd.link_dylib(name),\n-            NativeLibKind::Framework => cmd.link_framework(name),\n-            NativeLibKind::StaticNoBundle => cmd.link_staticlib(name),\n-            NativeLibKind::StaticBundle => cmd.link_whole_staticlib(name, &search_path),\n+            NativeLibKind::Dylib { as_needed } => {\n+                cmd.link_dylib(name, verbatim, as_needed.unwrap_or(true))\n+            }\n+            NativeLibKind::Unspecified => cmd.link_dylib(name, verbatim, true),\n+            NativeLibKind::Framework { as_needed } => {\n+                cmd.link_framework(name, as_needed.unwrap_or(true))\n+            }\n+            NativeLibKind::Static { bundle: None | Some(true), .. }\n+            | NativeLibKind::Static { whole_archive: Some(true), .. } => {\n+                cmd.link_whole_staticlib(name, verbatim, &search_path);\n+            }\n+            NativeLibKind::Static { .. } => cmd.link_staticlib(name, verbatim),\n             NativeLibKind::RawDylib => {\n                 // FIXME(#58713): Proper handling for raw dylibs.\n                 bug!(\"raw_dylib feature not yet implemented\");\n@@ -2005,9 +2010,10 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n         // there's a static library that's not relevant we skip all object\n         // files.\n         let native_libs = &codegen_results.crate_info.native_libraries[&cnum];\n-        let skip_native = native_libs\n-            .iter()\n-            .any(|lib| lib.kind == NativeLibKind::StaticBundle && !relevant_lib(sess, lib));\n+        let skip_native = native_libs.iter().any(|lib| {\n+            matches!(lib.kind, NativeLibKind::Static { bundle: None | Some(true), .. })\n+                && !relevant_lib(sess, lib)\n+        });\n \n         if (!are_upstream_rust_objects_already_included(sess)\n             || ignored_for_lto(sess, &codegen_results.crate_info, cnum))\n@@ -2136,6 +2142,7 @@ fn add_upstream_native_libraries(\n         .expect(\"failed to find crate type in dependency format list\");\n \n     let crates = &codegen_results.crate_info.used_crates_static;\n+    let mut last = (NativeLibKind::Unspecified, None);\n     for &(cnum, _) in crates {\n         for lib in codegen_results.crate_info.native_libraries[&cnum].iter() {\n             let name = match lib.name {\n@@ -2145,22 +2152,32 @@ fn add_upstream_native_libraries(\n             if !relevant_lib(sess, &lib) {\n                 continue;\n             }\n+\n+            // Skip if this library is the same as the last.\n+            last = if (lib.kind, lib.name) == last { continue } else { (lib.kind, lib.name) };\n+\n+            let verbatim = lib.verbatim.unwrap_or(false);\n             match lib.kind {\n-                NativeLibKind::Dylib | NativeLibKind::Unspecified => cmd.link_dylib(name),\n-                NativeLibKind::Framework => cmd.link_framework(name),\n-                NativeLibKind::StaticNoBundle => {\n+                NativeLibKind::Dylib { as_needed } => {\n+                    cmd.link_dylib(name, verbatim, as_needed.unwrap_or(true))\n+                }\n+                NativeLibKind::Unspecified => cmd.link_dylib(name, verbatim, true),\n+                NativeLibKind::Framework { as_needed } => {\n+                    cmd.link_framework(name, as_needed.unwrap_or(true))\n+                }\n+                NativeLibKind::Static { bundle: Some(false), .. } => {\n                     // Link \"static-nobundle\" native libs only if the crate they originate from\n                     // is being linked statically to the current crate.  If it's linked dynamically\n                     // or is an rlib already included via some other dylib crate, the symbols from\n                     // native libs will have already been included in that dylib.\n                     if data[cnum.as_usize() - 1] == Linkage::Static {\n-                        cmd.link_staticlib(name)\n+                        cmd.link_staticlib(name, verbatim)\n                     }\n                 }\n                 // ignore statically included native libraries here as we've\n                 // already included them when we included the rust library\n                 // previously\n-                NativeLibKind::StaticBundle => {}\n+                NativeLibKind::Static { bundle: None | Some(true), .. } => {}\n                 NativeLibKind::RawDylib => {\n                     // FIXME(#58713): Proper handling for raw dylibs.\n                     bug!(\"raw_dylib feature not yet implemented\");"}, {"sha": "4dc9a3f5e41be181199eb2e5b74b762705d557f8", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 138, "deletions": 71, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -37,12 +37,14 @@ pub fn disable_localization(linker: &mut Command) {\n /// need out of the shared crate context before we get rid of it.\n #[derive(Encodable, Decodable)]\n pub struct LinkerInfo {\n+    target_cpu: String,\n     exports: FxHashMap<CrateType, Vec<String>>,\n }\n \n impl LinkerInfo {\n-    pub fn new(tcx: TyCtxt<'_>) -> LinkerInfo {\n+    pub fn new(tcx: TyCtxt<'_>, target_cpu: String) -> LinkerInfo {\n         LinkerInfo {\n+            target_cpu,\n             exports: tcx\n                 .sess\n                 .crate_types()\n@@ -57,38 +59,31 @@ impl LinkerInfo {\n         cmd: Command,\n         sess: &'a Session,\n         flavor: LinkerFlavor,\n-        target_cpu: &'a str,\n     ) -> Box<dyn Linker + 'a> {\n         match flavor {\n             LinkerFlavor::Lld(LldFlavor::Link) | LinkerFlavor::Msvc => {\n                 Box::new(MsvcLinker { cmd, sess, info: self }) as Box<dyn Linker>\n             }\n             LinkerFlavor::Em => Box::new(EmLinker { cmd, sess, info: self }) as Box<dyn Linker>,\n-            LinkerFlavor::Gcc => Box::new(GccLinker {\n-                cmd,\n-                sess,\n-                info: self,\n-                hinted_static: false,\n-                is_ld: false,\n-                target_cpu,\n-            }) as Box<dyn Linker>,\n+            LinkerFlavor::Gcc => {\n+                Box::new(GccLinker { cmd, sess, info: self, hinted_static: false, is_ld: false })\n+                    as Box<dyn Linker>\n+            }\n \n             LinkerFlavor::Lld(LldFlavor::Ld)\n             | LinkerFlavor::Lld(LldFlavor::Ld64)\n-            | LinkerFlavor::Ld => Box::new(GccLinker {\n-                cmd,\n-                sess,\n-                info: self,\n-                hinted_static: false,\n-                is_ld: true,\n-                target_cpu,\n-            }) as Box<dyn Linker>,\n+            | LinkerFlavor::Ld => {\n+                Box::new(GccLinker { cmd, sess, info: self, hinted_static: false, is_ld: true })\n+                    as Box<dyn Linker>\n+            }\n \n             LinkerFlavor::Lld(LldFlavor::Wasm) => {\n                 Box::new(WasmLd::new(cmd, sess, self)) as Box<dyn Linker>\n             }\n \n-            LinkerFlavor::PtxLinker => Box::new(PtxLinker { cmd, sess }) as Box<dyn Linker>,\n+            LinkerFlavor::PtxLinker => {\n+                Box::new(PtxLinker { cmd, sess, info: self }) as Box<dyn Linker>\n+            }\n         }\n     }\n }\n@@ -103,18 +98,19 @@ impl LinkerInfo {\n pub trait Linker {\n     fn cmd(&mut self) -> &mut Command;\n     fn set_output_kind(&mut self, output_kind: LinkOutputKind, out_filename: &Path);\n-    fn link_dylib(&mut self, lib: Symbol);\n+    fn link_dylib(&mut self, lib: Symbol, verbatim: bool, as_needed: bool);\n     fn link_rust_dylib(&mut self, lib: Symbol, path: &Path);\n-    fn link_framework(&mut self, framework: Symbol);\n-    fn link_staticlib(&mut self, lib: Symbol);\n+    fn link_framework(&mut self, framework: Symbol, as_needed: bool);\n+    fn link_staticlib(&mut self, lib: Symbol, verbatim: bool);\n     fn link_rlib(&mut self, lib: &Path);\n     fn link_whole_rlib(&mut self, lib: &Path);\n-    fn link_whole_staticlib(&mut self, lib: Symbol, search_path: &[PathBuf]);\n+    fn link_whole_staticlib(&mut self, lib: Symbol, verbatim: bool, search_path: &[PathBuf]);\n     fn include_path(&mut self, path: &Path);\n     fn framework_path(&mut self, path: &Path);\n     fn output_filename(&mut self, path: &Path);\n     fn add_object(&mut self, path: &Path);\n     fn gc_sections(&mut self, keep_metadata: bool);\n+    fn no_gc_sections(&mut self);\n     fn full_relro(&mut self);\n     fn partial_relro(&mut self);\n     fn no_relro(&mut self);\n@@ -130,6 +126,7 @@ pub trait Linker {\n     fn group_end(&mut self);\n     fn linker_plugin_lto(&mut self);\n     fn add_eh_frame_header(&mut self) {}\n+    fn add_no_exec(&mut self) {}\n     fn add_as_needed(&mut self) {}\n     fn finalize(&mut self);\n }\n@@ -155,7 +152,6 @@ pub struct GccLinker<'a> {\n     hinted_static: bool, // Keeps track of the current hinting mode.\n     // Link as ld\n     is_ld: bool,\n-    target_cpu: &'a str,\n }\n \n impl<'a> GccLinker<'a> {\n@@ -185,7 +181,7 @@ impl<'a> GccLinker<'a> {\n         // * On OSX they have their own linker, not binutils'\n         // * For WebAssembly the only functional linker is LLD, which doesn't\n         //   support hint flags\n-        !self.sess.target.is_like_osx && self.sess.target.arch != \"wasm32\"\n+        !self.sess.target.is_like_osx && !self.sess.target.is_like_wasm\n     }\n \n     // Some platforms take hints about whether a library is static or dynamic.\n@@ -227,8 +223,7 @@ impl<'a> GccLinker<'a> {\n         };\n \n         self.linker_arg(&format!(\"-plugin-opt={}\", opt_level));\n-        let target_cpu = self.target_cpu;\n-        self.linker_arg(&format!(\"-plugin-opt=mcpu={}\", target_cpu));\n+        self.linker_arg(&format!(\"-plugin-opt=mcpu={}\", self.info.target_cpu));\n     }\n \n     fn build_dylib(&mut self, out_filename: &Path) {\n@@ -286,8 +281,11 @@ impl<'a> Linker for GccLinker<'a> {\n                 }\n             }\n             LinkOutputKind::DynamicPicExe => {\n-                // `-pie` works for both gcc wrapper and ld.\n-                self.cmd.arg(\"-pie\");\n+                // noop on windows w/ gcc & ld, error w/ lld\n+                if !self.sess.target.is_like_windows {\n+                    // `-pie` works for both gcc wrapper and ld.\n+                    self.cmd.arg(\"-pie\");\n+                }\n             }\n             LinkOutputKind::StaticNoPicExe => {\n                 // `-static` works for both gcc wrapper and ld.\n@@ -337,13 +335,40 @@ impl<'a> Linker for GccLinker<'a> {\n         }\n     }\n \n-    fn link_dylib(&mut self, lib: Symbol) {\n+    fn link_dylib(&mut self, lib: Symbol, verbatim: bool, as_needed: bool) {\n+        if self.sess.target.os == \"illumos\" && lib.as_str() == \"c\" {\n+            // libc will be added via late_link_args on illumos so that it will\n+            // appear last in the library search order.\n+            // FIXME: This should be replaced by a more complete and generic\n+            // mechanism for controlling the order of library arguments passed\n+            // to the linker.\n+            return;\n+        }\n+        if !as_needed {\n+            if self.sess.target.is_like_osx {\n+                // FIXME(81490): ld64 doesn't support these flags but macOS 11\n+                // has -needed-l{} / -needed_library {}\n+                // but we have no way to detect that here.\n+                self.sess.warn(\"`as-needed` modifier not implemented yet for ld64\");\n+            } else if self.sess.target.linker_is_gnu && !self.sess.target.is_like_windows {\n+                self.linker_arg(\"--no-as-needed\");\n+            } else {\n+                self.sess.warn(\"`as-needed` modifier not supported for current linker\");\n+            }\n+        }\n         self.hint_dynamic();\n-        self.cmd.arg(format!(\"-l{}\", lib));\n+        self.cmd.arg(format!(\"-l{}{}\", if verbatim { \":\" } else { \"\" }, lib));\n+        if !as_needed {\n+            if self.sess.target.is_like_osx {\n+                // See above FIXME comment\n+            } else if self.sess.target.linker_is_gnu && !self.sess.target.is_like_windows {\n+                self.linker_arg(\"--as-needed\");\n+            }\n+        }\n     }\n-    fn link_staticlib(&mut self, lib: Symbol) {\n+    fn link_staticlib(&mut self, lib: Symbol, verbatim: bool) {\n         self.hint_static();\n-        self.cmd.arg(format!(\"-l{}\", lib));\n+        self.cmd.arg(format!(\"-l{}{}\", if verbatim { \":\" } else { \"\" }, lib));\n     }\n     fn link_rlib(&mut self, lib: &Path) {\n         self.hint_static();\n@@ -377,8 +402,14 @@ impl<'a> Linker for GccLinker<'a> {\n         self.cmd.arg(format!(\"-l{}\", lib));\n     }\n \n-    fn link_framework(&mut self, framework: Symbol) {\n+    fn link_framework(&mut self, framework: Symbol, as_needed: bool) {\n         self.hint_dynamic();\n+        if !as_needed {\n+            // FIXME(81490): ld64 as of macOS 11 supports the -needed_framework\n+            // flag but we have no way to detect that here.\n+            // self.cmd.arg(\"-needed_framework\").sym_arg(framework);\n+            self.sess.warn(\"`as-needed` modifier not implemented yet for ld64\");\n+        }\n         self.cmd.arg(\"-framework\").sym_arg(framework);\n     }\n \n@@ -388,17 +419,21 @@ impl<'a> Linker for GccLinker<'a> {\n     // don't otherwise explicitly reference them. This can occur for\n     // libraries which are just providing bindings, libraries with generic\n     // functions, etc.\n-    fn link_whole_staticlib(&mut self, lib: Symbol, search_path: &[PathBuf]) {\n+    fn link_whole_staticlib(&mut self, lib: Symbol, verbatim: bool, search_path: &[PathBuf]) {\n         self.hint_static();\n         let target = &self.sess.target;\n         if !target.is_like_osx {\n-            self.linker_arg(\"--whole-archive\").cmd.arg(format!(\"-l{}\", lib));\n+            self.linker_arg(\"--whole-archive\").cmd.arg(format!(\n+                \"-l{}{}\",\n+                if verbatim { \":\" } else { \"\" },\n+                lib\n+            ));\n             self.linker_arg(\"--no-whole-archive\");\n         } else {\n             // -force_load is the macOS equivalent of --whole-archive, but it\n             // involves passing the full path to the library to link.\n             self.linker_arg(\"-force_load\");\n-            let lib = archive::find_library(lib, search_path, &self.sess);\n+            let lib = archive::find_library(lib, verbatim, search_path, &self.sess);\n             self.linker_arg(&lib);\n         }\n     }\n@@ -431,19 +466,25 @@ impl<'a> Linker for GccLinker<'a> {\n         // insert it here.\n         if self.sess.target.is_like_osx {\n             self.linker_arg(\"-dead_strip\");\n-        } else if self.sess.target.is_like_solaris {\n-            self.linker_arg(\"-zignore\");\n \n         // If we're building a dylib, we don't use --gc-sections because LLVM\n         // has already done the best it can do, and we also don't want to\n         // eliminate the metadata. If we're building an executable, however,\n         // --gc-sections drops the size of hello world from 1.8MB to 597K, a 67%\n         // reduction.\n-        } else if !keep_metadata {\n+        } else if self.sess.target.linker_is_gnu && !keep_metadata {\n             self.linker_arg(\"--gc-sections\");\n         }\n     }\n \n+    fn no_gc_sections(&mut self) {\n+        if self.sess.target.is_like_osx {\n+            self.linker_arg(\"-no_dead_strip\");\n+        } else if self.sess.target.linker_is_gnu {\n+            self.linker_arg(\"--no-gc-sections\");\n+        }\n+    }\n+\n     fn optimize(&mut self) {\n         if !self.sess.target.linker_is_gnu {\n             return;\n@@ -643,9 +684,21 @@ impl<'a> Linker for GccLinker<'a> {\n         self.linker_arg(\"--eh-frame-hdr\");\n     }\n \n+    fn add_no_exec(&mut self) {\n+        if self.sess.target.is_like_windows {\n+            self.linker_arg(\"--nxcompat\");\n+        } else if self.sess.target.linker_is_gnu {\n+            self.linker_arg(\"-znoexecstack\");\n+        }\n+    }\n+\n     fn add_as_needed(&mut self) {\n-        if self.sess.target.linker_is_gnu {\n+        if self.sess.target.linker_is_gnu && !self.sess.target.is_like_windows {\n             self.linker_arg(\"--as-needed\");\n+        } else if self.sess.target.is_like_solaris {\n+            // -z ignore is the Solaris equivalent to the GNU ld --as-needed option\n+            self.linker_arg(\"-z\");\n+            self.linker_arg(\"ignore\");\n         }\n     }\n }\n@@ -699,8 +752,12 @@ impl<'a> Linker for MsvcLinker<'a> {\n         }\n     }\n \n-    fn link_dylib(&mut self, lib: Symbol) {\n-        self.cmd.arg(&format!(\"{}.lib\", lib));\n+    fn no_gc_sections(&mut self) {\n+        self.cmd.arg(\"/OPT:NOREF,NOICF\");\n+    }\n+\n+    fn link_dylib(&mut self, lib: Symbol, verbatim: bool, _as_needed: bool) {\n+        self.cmd.arg(format!(\"{}{}\", lib, if verbatim { \"\" } else { \".lib\" }));\n     }\n \n     fn link_rust_dylib(&mut self, lib: Symbol, path: &Path) {\n@@ -709,13 +766,13 @@ impl<'a> Linker for MsvcLinker<'a> {\n         // check to see if the file is there and just omit linking to it if it's\n         // not present.\n         let name = format!(\"{}.dll.lib\", lib);\n-        if fs::metadata(&path.join(&name)).is_ok() {\n+        if path.join(&name).exists() {\n             self.cmd.arg(name);\n         }\n     }\n \n-    fn link_staticlib(&mut self, lib: Symbol) {\n-        self.cmd.arg(&format!(\"{}.lib\", lib));\n+    fn link_staticlib(&mut self, lib: Symbol, verbatim: bool) {\n+        self.cmd.arg(format!(\"{}{}\", lib, if verbatim { \"\" } else { \".lib\" }));\n     }\n \n     fn full_relro(&mut self) {\n@@ -753,16 +810,14 @@ impl<'a> Linker for MsvcLinker<'a> {\n     fn framework_path(&mut self, _path: &Path) {\n         bug!(\"frameworks are not supported on windows\")\n     }\n-    fn link_framework(&mut self, _framework: Symbol) {\n+    fn link_framework(&mut self, _framework: Symbol, _as_needed: bool) {\n         bug!(\"frameworks are not supported on windows\")\n     }\n \n-    fn link_whole_staticlib(&mut self, lib: Symbol, _search_path: &[PathBuf]) {\n-        self.link_staticlib(lib);\n-        self.cmd.arg(format!(\"/WHOLEARCHIVE:{}.lib\", lib));\n+    fn link_whole_staticlib(&mut self, lib: Symbol, verbatim: bool, _search_path: &[PathBuf]) {\n+        self.cmd.arg(format!(\"/WHOLEARCHIVE:{}{}\", lib, if verbatim { \"\" } else { \".lib\" }));\n     }\n     fn link_whole_rlib(&mut self, path: &Path) {\n-        self.link_rlib(path);\n         let mut arg = OsString::from(\"/WHOLEARCHIVE:\");\n         arg.push(path);\n         self.cmd.arg(arg);\n@@ -885,6 +940,10 @@ impl<'a> Linker for MsvcLinker<'a> {\n     fn linker_plugin_lto(&mut self) {\n         // Do nothing\n     }\n+\n+    fn add_no_exec(&mut self) {\n+        self.cmd.arg(\"/NXCOMPAT\");\n+    }\n }\n \n pub struct EmLinker<'a> {\n@@ -904,7 +963,7 @@ impl<'a> Linker for EmLinker<'a> {\n         self.cmd.arg(\"-L\").arg(path);\n     }\n \n-    fn link_staticlib(&mut self, lib: Symbol) {\n+    fn link_staticlib(&mut self, lib: Symbol, _verbatim: bool) {\n         self.cmd.arg(\"-l\").sym_arg(lib);\n     }\n \n@@ -916,14 +975,14 @@ impl<'a> Linker for EmLinker<'a> {\n         self.cmd.arg(path);\n     }\n \n-    fn link_dylib(&mut self, lib: Symbol) {\n+    fn link_dylib(&mut self, lib: Symbol, verbatim: bool, _as_needed: bool) {\n         // Emscripten always links statically\n-        self.link_staticlib(lib);\n+        self.link_staticlib(lib, verbatim);\n     }\n \n-    fn link_whole_staticlib(&mut self, lib: Symbol, _search_path: &[PathBuf]) {\n+    fn link_whole_staticlib(&mut self, lib: Symbol, verbatim: bool, _search_path: &[PathBuf]) {\n         // not supported?\n-        self.link_staticlib(lib);\n+        self.link_staticlib(lib, verbatim);\n     }\n \n     fn link_whole_rlib(&mut self, lib: &Path) {\n@@ -932,7 +991,7 @@ impl<'a> Linker for EmLinker<'a> {\n     }\n \n     fn link_rust_dylib(&mut self, lib: Symbol, _path: &Path) {\n-        self.link_dylib(lib);\n+        self.link_dylib(lib, false, true);\n     }\n \n     fn link_rlib(&mut self, lib: &Path) {\n@@ -955,14 +1014,18 @@ impl<'a> Linker for EmLinker<'a> {\n         bug!(\"frameworks are not supported on Emscripten\")\n     }\n \n-    fn link_framework(&mut self, _framework: Symbol) {\n+    fn link_framework(&mut self, _framework: Symbol, _as_needed: bool) {\n         bug!(\"frameworks are not supported on Emscripten\")\n     }\n \n     fn gc_sections(&mut self, _keep_metadata: bool) {\n         // noop\n     }\n \n+    fn no_gc_sections(&mut self) {\n+        // noop\n+    }\n+\n     fn optimize(&mut self) {\n         // Emscripten performs own optimizations\n         self.cmd.arg(match self.sess.opts.optimize {\n@@ -1106,11 +1169,11 @@ impl<'a> Linker for WasmLd<'a> {\n         }\n     }\n \n-    fn link_dylib(&mut self, lib: Symbol) {\n+    fn link_dylib(&mut self, lib: Symbol, _verbatim: bool, _as_needed: bool) {\n         self.cmd.arg(\"-l\").sym_arg(lib);\n     }\n \n-    fn link_staticlib(&mut self, lib: Symbol) {\n+    fn link_staticlib(&mut self, lib: Symbol, _verbatim: bool) {\n         self.cmd.arg(\"-l\").sym_arg(lib);\n     }\n \n@@ -1144,11 +1207,11 @@ impl<'a> Linker for WasmLd<'a> {\n         self.cmd.arg(\"-l\").sym_arg(lib);\n     }\n \n-    fn link_framework(&mut self, _framework: Symbol) {\n+    fn link_framework(&mut self, _framework: Symbol, _as_needed: bool) {\n         panic!(\"frameworks not supported\")\n     }\n \n-    fn link_whole_staticlib(&mut self, lib: Symbol, _search_path: &[PathBuf]) {\n+    fn link_whole_staticlib(&mut self, lib: Symbol, _verbatim: bool, _search_path: &[PathBuf]) {\n         self.cmd.arg(\"-l\").sym_arg(lib);\n     }\n \n@@ -1160,6 +1223,10 @@ impl<'a> Linker for WasmLd<'a> {\n         self.cmd.arg(\"--gc-sections\");\n     }\n \n+    fn no_gc_sections(&mut self) {\n+        self.cmd.arg(\"--no-gc-sections\");\n+    }\n+\n     fn optimize(&mut self) {\n         self.cmd.arg(match self.sess.opts.optimize {\n             OptLevel::No => \"-O0\",\n@@ -1237,7 +1304,7 @@ fn exported_symbols(tcx: TyCtxt<'_>, crate_type: CrateType) -> Vec<String> {\n         }\n     }\n \n-    let formats = tcx.dependency_formats(LOCAL_CRATE);\n+    let formats = tcx.dependency_formats(());\n     let deps = formats.iter().find_map(|(t, list)| (*t == crate_type).then_some(list)).unwrap();\n \n     for (index, dep_format) in deps.iter().enumerate() {\n@@ -1263,6 +1330,7 @@ fn exported_symbols(tcx: TyCtxt<'_>, crate_type: CrateType) -> Vec<String> {\n pub struct PtxLinker<'a> {\n     cmd: Command,\n     sess: &'a Session,\n+    info: &'a LinkerInfo,\n }\n \n impl<'a> Linker for PtxLinker<'a> {\n@@ -1308,33 +1376,30 @@ impl<'a> Linker for PtxLinker<'a> {\n \n     fn finalize(&mut self) {\n         // Provide the linker with fallback to internal `target-cpu`.\n-        self.cmd.arg(\"--fallback-arch\").arg(match self.sess.opts.cg.target_cpu {\n-            Some(ref s) => s,\n-            None => &self.sess.target.cpu,\n-        });\n+        self.cmd.arg(\"--fallback-arch\").arg(&self.info.target_cpu);\n     }\n \n-    fn link_dylib(&mut self, _lib: Symbol) {\n+    fn link_dylib(&mut self, _lib: Symbol, _verbatim: bool, _as_needed: bool) {\n         panic!(\"external dylibs not supported\")\n     }\n \n     fn link_rust_dylib(&mut self, _lib: Symbol, _path: &Path) {\n         panic!(\"external dylibs not supported\")\n     }\n \n-    fn link_staticlib(&mut self, _lib: Symbol) {\n+    fn link_staticlib(&mut self, _lib: Symbol, _verbatim: bool) {\n         panic!(\"staticlibs not supported\")\n     }\n \n-    fn link_whole_staticlib(&mut self, _lib: Symbol, _search_path: &[PathBuf]) {\n+    fn link_whole_staticlib(&mut self, _lib: Symbol, _verbatim: bool, _search_path: &[PathBuf]) {\n         panic!(\"staticlibs not supported\")\n     }\n \n     fn framework_path(&mut self, _path: &Path) {\n         panic!(\"frameworks not supported\")\n     }\n \n-    fn link_framework(&mut self, _framework: Symbol) {\n+    fn link_framework(&mut self, _framework: Symbol, _as_needed: bool) {\n         panic!(\"frameworks not supported\")\n     }\n \n@@ -1346,6 +1411,8 @@ impl<'a> Linker for PtxLinker<'a> {\n \n     fn gc_sections(&mut self, _keep_metadata: bool) {}\n \n+    fn no_gc_sections(&mut self) {}\n+\n     fn pgo_gen(&mut self) {}\n \n     fn no_crt_objects(&mut self) {}"}, {"sha": "d6ae689f254b1508b2f48d7ce75b5378ce43838f", "filename": "compiler/rustc_codegen_ssa/src/back/lto.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flto.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -2,6 +2,7 @@ use super::write::CodegenContext;\n use crate::traits::*;\n use crate::ModuleCodegen;\n \n+use rustc_data_structures::memmap::Mmap;\n use rustc_errors::FatalError;\n \n use std::ffi::CString;\n@@ -71,7 +72,7 @@ impl<B: WriteBackendMethods> LtoModuleCodegen<B> {\n                 let module = module.take().unwrap();\n                 {\n                     let config = cgcx.config(module.kind);\n-                    B::run_lto_pass_manager(cgcx, &module, config, false);\n+                    B::run_lto_pass_manager(cgcx, &module, config, false)?;\n                 }\n                 Ok(module)\n             }\n@@ -93,7 +94,7 @@ impl<B: WriteBackendMethods> LtoModuleCodegen<B> {\n pub enum SerializedModule<M: ModuleBufferMethods> {\n     Local(M),\n     FromRlib(Vec<u8>),\n-    FromUncompressedFile(memmap2::Mmap),\n+    FromUncompressedFile(Mmap),\n }\n \n impl<M: ModuleBufferMethods> SerializedModule<M> {"}, {"sha": "37d1f8ecc8328367aaac17c6f3d4568bc0a70233", "filename": "compiler/rustc_codegen_ssa/src/back/metadata.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -0,0 +1,71 @@\n+//! Reading of the rustc metadata for rlibs and dylibs\n+\n+use std::fs::File;\n+use std::path::Path;\n+\n+use rustc_data_structures::memmap::Mmap;\n+use rustc_data_structures::owning_ref::OwningRef;\n+use rustc_data_structures::rustc_erase_owner;\n+use rustc_data_structures::sync::MetadataRef;\n+use rustc_middle::middle::cstore::MetadataLoader;\n+use rustc_target::spec::Target;\n+\n+use crate::METADATA_FILENAME;\n+\n+/// The default metadata loader. This is used by cg_llvm and cg_clif.\n+///\n+/// # Metadata location\n+///\n+/// <dl>\n+/// <dt>rlib</dt>\n+/// <dd>The metadata can be found in the `lib.rmeta` file inside of the ar archive.</dd>\n+/// <dt>dylib</dt>\n+/// <dd>The metadata can be found in the `.rustc` section of the shared library.</dd>\n+/// </dl>\n+pub struct DefaultMetadataLoader;\n+\n+fn load_metadata_with(\n+    path: &Path,\n+    f: impl for<'a> FnOnce(&'a [u8]) -> Result<&'a [u8], String>,\n+) -> Result<MetadataRef, String> {\n+    let file =\n+        File::open(path).map_err(|e| format!(\"failed to open file '{}': {}\", path.display(), e))?;\n+    let data = unsafe { Mmap::map(file) }\n+        .map_err(|e| format!(\"failed to mmap file '{}': {}\", path.display(), e))?;\n+    let metadata = OwningRef::new(data).try_map(f)?;\n+    return Ok(rustc_erase_owner!(metadata.map_owner_box()));\n+}\n+\n+impl MetadataLoader for DefaultMetadataLoader {\n+    fn get_rlib_metadata(&self, _target: &Target, path: &Path) -> Result<MetadataRef, String> {\n+        load_metadata_with(path, |data| {\n+            let archive = object::read::archive::ArchiveFile::parse(&*data)\n+                .map_err(|e| format!(\"failed to parse rlib '{}': {}\", path.display(), e))?;\n+\n+            for entry_result in archive.members() {\n+                let entry = entry_result\n+                    .map_err(|e| format!(\"failed to parse rlib '{}': {}\", path.display(), e))?;\n+                if entry.name() == METADATA_FILENAME.as_bytes() {\n+                    return Ok(entry.data());\n+                }\n+            }\n+\n+            Err(format!(\"metadata not found in rlib '{}'\", path.display()))\n+        })\n+    }\n+\n+    fn get_dylib_metadata(&self, _target: &Target, path: &Path) -> Result<MetadataRef, String> {\n+        use object::{Object, ObjectSection};\n+\n+        load_metadata_with(path, |data| {\n+            let file = object::File::parse(&data)\n+                .map_err(|e| format!(\"failed to parse dylib '{}': {}\", path.display(), e))?;\n+            file.section_by_name(\".rustc\")\n+                .ok_or_else(|| format!(\"no .rustc section in '{}'\", path.display()))?\n+                .data()\n+                .map_err(|e| {\n+                    format!(\"failed to read .rustc section in '{}': {}\", path.display(), e)\n+                })\n+        })\n+    }\n+}"}, {"sha": "d11ed54eb209f969ffe88f1709379ab7b6fac785", "filename": "compiler/rustc_codegen_ssa/src/back/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmod.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -3,6 +3,7 @@ pub mod command;\n pub mod link;\n pub mod linker;\n pub mod lto;\n+pub mod metadata;\n pub mod rpath;\n pub mod symbol_export;\n pub mod write;"}, {"sha": "14d6f0ba147b53773c15ed6509d46d4270ef4f89", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 44, "deletions": 20, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -4,7 +4,7 @@ use rustc_ast::expand::allocator::ALLOCATOR_METHODS;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n-use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::Node;\n use rustc_index::vec::IndexVec;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n@@ -15,7 +15,8 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n use rustc_middle::ty::Instance;\n use rustc_middle::ty::{SymbolName, TyCtxt};\n-use rustc_session::config::{CrateType, SanitizerSet};\n+use rustc_session::config::CrateType;\n+use rustc_target::spec::SanitizerSet;\n \n pub fn threshold(tcx: TyCtxt<'_>) -> SymbolExportLevel {\n     crates_export_threshold(&tcx.sess.crate_types())\n@@ -59,7 +60,7 @@ fn reachable_non_generics_provider(tcx: TyCtxt<'_>, cnum: CrateNum) -> DefIdMap<\n         tcx.is_panic_runtime(LOCAL_CRATE) || tcx.is_compiler_builtins(LOCAL_CRATE);\n \n     let mut reachable_non_generics: DefIdMap<_> = tcx\n-        .reachable_set(LOCAL_CRATE)\n+        .reachable_set(())\n         .iter()\n         .filter_map(|&def_id| {\n             // We want to ignore some FFI functions that are not exposed from\n@@ -132,12 +133,12 @@ fn reachable_non_generics_provider(tcx: TyCtxt<'_>, cnum: CrateNum) -> DefIdMap<\n         })\n         .collect();\n \n-    if let Some(id) = tcx.proc_macro_decls_static(LOCAL_CRATE) {\n-        reachable_non_generics.insert(id, SymbolExportLevel::C);\n+    if let Some(id) = tcx.proc_macro_decls_static(()) {\n+        reachable_non_generics.insert(id.to_def_id(), SymbolExportLevel::C);\n     }\n \n-    if let Some(id) = tcx.plugin_registrar_fn(LOCAL_CRATE) {\n-        reachable_non_generics.insert(id, SymbolExportLevel::C);\n+    if let Some(id) = tcx.plugin_registrar_fn(()) {\n+        reachable_non_generics.insert(id.to_def_id(), SymbolExportLevel::C);\n     }\n \n     reachable_non_generics\n@@ -173,7 +174,7 @@ fn exported_symbols_provider_local(\n         .map(|(&def_id, &level)| (ExportedSymbol::NonGeneric(def_id), level))\n         .collect();\n \n-    if tcx.entry_fn(LOCAL_CRATE).is_some() {\n+    if tcx.entry_fn(()).is_some() {\n         let exported_symbol = ExportedSymbol::NoDefId(SymbolName::new(tcx, \"main\"));\n \n         symbols.push((exported_symbol, SymbolExportLevel::C));\n@@ -229,7 +230,7 @@ fn exported_symbols_provider_local(\n         // external linkage is enough for monomorphization to be linked to.\n         let need_visibility = tcx.sess.target.dynamic_linking && !tcx.sess.target.only_cdylib;\n \n-        let (_, cgus) = tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n+        let (_, cgus) = tcx.collect_and_partition_mono_items(());\n \n         for (mono_item, &(linkage, visibility)) in cgus.iter().flat_map(|cgu| cgu.items().iter()) {\n             if linkage != Linkage::External {\n@@ -274,11 +275,9 @@ fn exported_symbols_provider_local(\n \n fn upstream_monomorphizations_provider(\n     tcx: TyCtxt<'_>,\n-    cnum: CrateNum,\n+    (): (),\n ) -> DefIdMap<FxHashMap<SubstsRef<'_>, CrateNum>> {\n-    debug_assert!(cnum == LOCAL_CRATE);\n-\n-    let cnums = tcx.all_crate_nums(LOCAL_CRATE);\n+    let cnums = tcx.all_crate_nums(());\n \n     let mut instances: DefIdMap<FxHashMap<_, _>> = Default::default();\n \n@@ -340,7 +339,7 @@ fn upstream_monomorphizations_for_provider(\n     def_id: DefId,\n ) -> Option<&FxHashMap<SubstsRef<'_>, CrateNum>> {\n     debug_assert!(!def_id.is_local());\n-    tcx.upstream_monomorphizations(LOCAL_CRATE).get(&def_id)\n+    tcx.upstream_monomorphizations(()).get(&def_id)\n }\n \n fn upstream_drop_glue_for_provider<'tcx>(\n@@ -354,12 +353,8 @@ fn upstream_drop_glue_for_provider<'tcx>(\n     }\n }\n \n-fn is_unreachable_local_definition_provider(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    if let Some(def_id) = def_id.as_local() {\n-        !tcx.reachable_set(LOCAL_CRATE).contains(&def_id)\n-    } else {\n-        bug!(\"is_unreachable_local_definition called with non-local DefId: {:?}\", def_id)\n-    }\n+fn is_unreachable_local_definition_provider(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n+    !tcx.reachable_set(()).contains(&def_id)\n }\n \n pub fn provide(providers: &mut Providers) {\n@@ -369,11 +364,13 @@ pub fn provide(providers: &mut Providers) {\n     providers.upstream_monomorphizations = upstream_monomorphizations_provider;\n     providers.is_unreachable_local_definition = is_unreachable_local_definition_provider;\n     providers.upstream_drop_glue_for = upstream_drop_glue_for_provider;\n+    providers.wasm_import_module_map = wasm_import_module_map;\n }\n \n pub fn provide_extern(providers: &mut Providers) {\n     providers.is_reachable_non_generic = is_reachable_non_generic_provider_extern;\n     providers.upstream_monomorphizations_for = upstream_monomorphizations_for_provider;\n+    providers.wasm_import_module_map = wasm_import_module_map;\n }\n \n fn symbol_export_level(tcx: TyCtxt<'_>, sym_def_id: DefId) -> SymbolExportLevel {\n@@ -441,3 +438,30 @@ pub fn symbol_name_for_instance_in_crate<'tcx>(\n         ExportedSymbol::NoDefId(symbol_name) => symbol_name.to_string(),\n     }\n }\n+\n+fn wasm_import_module_map(tcx: TyCtxt<'_>, cnum: CrateNum) -> FxHashMap<DefId, String> {\n+    // Build up a map from DefId to a `NativeLib` structure, where\n+    // `NativeLib` internally contains information about\n+    // `#[link(wasm_import_module = \"...\")]` for example.\n+    let native_libs = tcx.native_libraries(cnum);\n+\n+    let def_id_to_native_lib = native_libs\n+        .iter()\n+        .filter_map(|lib| lib.foreign_module.map(|id| (id, lib)))\n+        .collect::<FxHashMap<_, _>>();\n+\n+    let mut ret = FxHashMap::default();\n+    for (def_id, lib) in tcx.foreign_modules(cnum).iter() {\n+        let module = def_id_to_native_lib.get(&def_id).and_then(|s| s.wasm_import_module);\n+        let module = match module {\n+            Some(s) => s,\n+            None => continue,\n+        };\n+        ret.extend(lib.foreign_items.iter().map(|id| {\n+            assert_eq!(id.krate, cnum);\n+            (*id, module.to_string())\n+        }));\n+    }\n+\n+    ret\n+}"}, {"sha": "49774dc6d5c7d4626dfcfd556d6a98cd169e93c5", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 24, "deletions": 30, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -10,6 +10,7 @@ use crate::{\n use crate::traits::*;\n use jobserver::{Acquired, Client};\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::profiling::TimingGuard;\n use rustc_data_structures::profiling::VerboseTimingGuard;\n@@ -27,12 +28,12 @@ use rustc_middle::middle::exported_symbols::SymbolExportLevel;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::cgu_reuse_tracker::CguReuseTracker;\n use rustc_session::config::{self, CrateType, Lto, OutputFilenames, OutputType};\n-use rustc_session::config::{Passes, SanitizerSet, SwitchWithOptPath};\n+use rustc_session::config::{Passes, SwitchWithOptPath};\n use rustc_session::Session;\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{BytePos, FileName, InnerSpan, Pos, Span};\n-use rustc_target::spec::{MergeFunctions, PanicStrategy};\n+use rustc_target::spec::{MergeFunctions, PanicStrategy, SanitizerSet};\n \n use std::any::Any;\n use std::fs;\n@@ -83,6 +84,8 @@ pub struct ModuleConfig {\n \n     pub pgo_gen: SwitchWithOptPath,\n     pub pgo_use: Option<PathBuf>,\n+    pub instrument_coverage: bool,\n+    pub instrument_gcov: bool,\n \n     pub sanitizer: SanitizerSet,\n     pub sanitizer_recover: SanitizerSet,\n@@ -106,8 +109,8 @@ pub struct ModuleConfig {\n     pub vectorize_loop: bool,\n     pub vectorize_slp: bool,\n     pub merge_functions: bool,\n-    pub inline_threshold: Option<usize>,\n-    pub new_llvm_pass_manager: bool,\n+    pub inline_threshold: Option<u32>,\n+    pub new_llvm_pass_manager: Option<bool>,\n     pub emit_lifetime_markers: bool,\n }\n \n@@ -164,25 +167,7 @@ impl ModuleConfig {\n         };\n \n         ModuleConfig {\n-            passes: if_regular!(\n-                {\n-                    let mut passes = sess.opts.cg.passes.clone();\n-                    // compiler_builtins overrides the codegen-units settings,\n-                    // which is incompatible with -Zprofile which requires that\n-                    // only a single codegen unit is used per crate.\n-                    if sess.opts.debugging_opts.profile && !is_compiler_builtins {\n-                        passes.push(\"insert-gcov-profiling\".to_owned());\n-                    }\n-\n-                    // The rustc option `-Zinstrument_coverage` injects intrinsic calls to\n-                    // `llvm.instrprof.increment()`, which requires the LLVM `instrprof` pass.\n-                    if sess.instrument_coverage() {\n-                        passes.push(\"instrprof\".to_owned());\n-                    }\n-                    passes\n-                },\n-                vec![]\n-            ),\n+            passes: if_regular!(sess.opts.cg.passes.clone(), vec![]),\n \n             opt_level: opt_level_and_size,\n             opt_size: opt_level_and_size,\n@@ -192,6 +177,14 @@ impl ModuleConfig {\n                 SwitchWithOptPath::Disabled\n             ),\n             pgo_use: if_regular!(sess.opts.cg.profile_use.clone(), None),\n+            instrument_coverage: if_regular!(sess.instrument_coverage(), false),\n+            instrument_gcov: if_regular!(\n+                // compiler_builtins overrides the codegen-units settings,\n+                // which is incompatible with -Zprofile which requires that\n+                // only a single codegen unit is used per crate.\n+                sess.opts.debugging_opts.profile && !is_compiler_builtins,\n+                false\n+            ),\n \n             sanitizer: if_regular!(sess.opts.debugging_opts.sanitizer, SanitizerSet::empty()),\n             sanitizer_recover: if_regular!(\n@@ -426,6 +419,7 @@ fn need_pre_lto_bitcode_for_incr_comp(sess: &Session) -> bool {\n pub fn start_async_codegen<B: ExtraBackendMethods>(\n     backend: B,\n     tcx: TyCtxt<'_>,\n+    target_cpu: String,\n     metadata: EncodedMetadata,\n     total_cgus: usize,\n ) -> OngoingCodegen<B> {\n@@ -448,7 +442,7 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n         subsystem.to_string()\n     });\n \n-    let linker_info = LinkerInfo::new(tcx);\n+    let linker_info = LinkerInfo::new(tcx, target_cpu);\n     let crate_info = CrateInfo::new(tcx);\n \n     let regular_config =\n@@ -488,7 +482,7 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n         codegen_worker_receive,\n         shared_emitter_main,\n         future: coordinator_thread,\n-        output_filenames: tcx.output_filenames(LOCAL_CRATE),\n+        output_filenames: tcx.output_filenames(()),\n     }\n }\n \n@@ -1048,7 +1042,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         // If we know that we won\u2019t be doing codegen, create target machines without optimisation.\n         config::OptLevel::No\n     } else {\n-        tcx.backend_optimization_level(LOCAL_CRATE)\n+        tcx.backend_optimization_level(())\n     };\n     let cgcx = CodegenContext::<B> {\n         backend: backend.clone(),\n@@ -1067,7 +1061,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         cgu_reuse_tracker: sess.cgu_reuse_tracker.clone(),\n         coordinator_send,\n         diag_emitter: shared_emitter.clone(),\n-        output_filenames: tcx.output_filenames(LOCAL_CRATE),\n+        output_filenames: tcx.output_filenames(()),\n         regular_module_config: regular_config,\n         metadata_module_config: metadata_config,\n         allocator_module_config: allocator_config,\n@@ -1093,7 +1087,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n     //   only place where we have access to the compiler `Session`.\n     // - LLVM work can be done on any thread.\n     // - Codegen can only happen on the main thread.\n-    // - Each thread doing substantial work most be in possession of a `Token`\n+    // - Each thread doing substantial work must be in possession of a `Token`\n     //   from the `Jobserver`.\n     // - The compiler process always holds one `Token`. Any additional `Tokens`\n     //   have to be requested from the `Jobserver`.\n@@ -1145,7 +1139,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n     // if possible. These two goals are at odds with each other: If memory\n     // consumption were not an issue, we could just let the main thread produce\n     // LLVM WorkItems at full speed, assuring maximal utilization of\n-    // Tokens/LLVM worker threads. However, since codegen usual is faster\n+    // Tokens/LLVM worker threads. However, since codegen is usually faster\n     // than LLVM processing, the queue of LLVM WorkItems would fill up and each\n     // WorkItem potentially holds on to a substantial amount of memory.\n     //\n@@ -1958,7 +1952,7 @@ pub fn submit_pre_lto_module_to_llvm<B: ExtraBackendMethods>(\n         .unwrap_or_else(|e| panic!(\"failed to open bitcode file `{}`: {}\", bc_path.display(), e));\n \n     let mmap = unsafe {\n-        memmap2::Mmap::map(&file).unwrap_or_else(|e| {\n+        Mmap::map(file).unwrap_or_else(|e| {\n             panic!(\"failed to mmap bitcode file `{}`: {}\", bc_path.display(), e)\n         })\n     };"}, {"sha": "b44e74d5ae8209d430a523b82286781049c05aa8", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -15,7 +15,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::profiling::{get_resident_set_size, print_time_passes_entry};\n use rustc_data_structures::sync::{par_iter, ParallelIterator};\n use rustc_hir as hir;\n-use rustc_hir::def_id::{LocalDefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::lang_items::LangItem;\n use rustc_index::vec::Idx;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrs;\n@@ -347,26 +347,31 @@ pub fn codegen_instance<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     cx: &'a Bx::CodegenCx,\n ) -> Option<Bx::Function> {\n-    let main_def_id = cx.tcx().entry_fn(LOCAL_CRATE).map(|(def_id, _)| def_id)?;\n-    let instance = Instance::mono(cx.tcx(), main_def_id.to_def_id());\n+    let (main_def_id, entry_type) = cx.tcx().entry_fn(())?;\n+    let main_is_local = main_def_id.is_local();\n+    let instance = Instance::mono(cx.tcx(), main_def_id);\n \n-    if !cx.codegen_unit().contains_item(&MonoItem::Fn(instance)) {\n+    if main_is_local {\n         // We want to create the wrapper in the same codegen unit as Rust's main\n         // function.\n+        if !cx.codegen_unit().contains_item(&MonoItem::Fn(instance)) {\n+            return None;\n+        }\n+    } else if !cx.codegen_unit().is_primary() {\n+        // We want to create the wrapper only when the codegen unit is the primary one\n         return None;\n     }\n \n     let main_llfn = cx.get_fn_addr(instance);\n \n-    return cx.tcx().entry_fn(LOCAL_CRATE).map(|(_, et)| {\n-        let use_start_lang_item = EntryFnType::Start != et;\n-        create_entry_fn::<Bx>(cx, main_llfn, main_def_id, use_start_lang_item)\n-    });\n+    let use_start_lang_item = EntryFnType::Start != entry_type;\n+    let entry_fn = create_entry_fn::<Bx>(cx, main_llfn, main_def_id, use_start_lang_item);\n+    return Some(entry_fn);\n \n     fn create_entry_fn<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         cx: &'a Bx::CodegenCx,\n         rust_main: Bx::Value,\n-        rust_main_def_id: LocalDefId,\n+        rust_main_def_id: DefId,\n         use_start_lang_item: bool,\n     ) -> Bx::Function {\n         // The entry function is either `int main(void)` or `int main(int argc, char **argv)`,\n@@ -403,7 +408,8 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         cx.set_frame_pointer_elimination(llfn);\n         cx.apply_target_cpu_attr(llfn);\n \n-        let mut bx = Bx::new_block(&cx, llfn, \"top\");\n+        let llbb = Bx::append_block(&cx, llfn, \"top\");\n+        let mut bx = Bx::build(&cx, llbb);\n \n         bx.insert_reference_to_gdb_debug_scripts_section_global();\n \n@@ -461,12 +467,13 @@ fn get_argc_argv<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n pub fn codegen_crate<B: ExtraBackendMethods>(\n     backend: B,\n     tcx: TyCtxt<'tcx>,\n+    target_cpu: String,\n     metadata: EncodedMetadata,\n     need_metadata_module: bool,\n ) -> OngoingCodegen<B> {\n     // Skip crate items and just output metadata in -Z no-codegen mode.\n     if tcx.sess.opts.debugging_opts.no_codegen || !tcx.sess.opts.output_types.should_codegen() {\n-        let ongoing_codegen = start_async_codegen(backend, tcx, metadata, 1);\n+        let ongoing_codegen = start_async_codegen(backend, tcx, target_cpu, metadata, 1);\n \n         ongoing_codegen.codegen_finished(tcx);\n \n@@ -479,7 +486,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n \n     // Run the monomorphization collector and partition the collected items into\n     // codegen units.\n-    let codegen_units = tcx.collect_and_partition_mono_items(LOCAL_CRATE).1;\n+    let codegen_units = tcx.collect_and_partition_mono_items(()).1;\n \n     // Force all codegen_unit queries so they are already either red or green\n     // when compile_codegen_unit accesses them. We are not able to re-execute\n@@ -492,7 +499,8 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n         }\n     }\n \n-    let ongoing_codegen = start_async_codegen(backend.clone(), tcx, metadata, codegen_units.len());\n+    let ongoing_codegen =\n+        start_async_codegen(backend.clone(), tcx, target_cpu, metadata, codegen_units.len());\n     let ongoing_codegen = AbortCodegenOnDrop::<B>(Some(ongoing_codegen));\n \n     // Codegen an allocator shim, if necessary.\n@@ -503,7 +511,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     // linkage, then it's already got an allocator shim and we'll be using that\n     // one instead. If nothing exists then it's our job to generate the\n     // allocator!\n-    let any_dynamic_crate = tcx.dependency_formats(LOCAL_CRATE).iter().any(|(_, list)| {\n+    let any_dynamic_crate = tcx.dependency_formats(()).iter().any(|(_, list)| {\n         use rustc_middle::middle::dependency_format::Linkage;\n         list.iter().any(|&linkage| linkage == Linkage::Dynamic)\n     });\n@@ -754,14 +762,13 @@ impl CrateInfo {\n             is_no_builtins: Default::default(),\n             native_libraries: Default::default(),\n             used_libraries: tcx.native_libraries(LOCAL_CRATE).iter().map(Into::into).collect(),\n-            link_args: tcx.link_args(LOCAL_CRATE),\n             crate_name: Default::default(),\n             used_crates_dynamic: cstore::used_crates(tcx, LinkagePreference::RequireDynamic),\n             used_crates_static: cstore::used_crates(tcx, LinkagePreference::RequireStatic),\n             used_crate_source: Default::default(),\n             lang_item_to_crate: Default::default(),\n             missing_lang_items: Default::default(),\n-            dependency_formats: tcx.dependency_formats(LOCAL_CRATE),\n+            dependency_formats: tcx.dependency_formats(()),\n         };\n         let lang_items = tcx.lang_items();\n "}, {"sha": "1fa60612d26a35e3f1a8b908b12a18da7d7bc813", "filename": "compiler/rustc_codegen_ssa/src/common.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -4,7 +4,8 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::LangItem;\n-use rustc_middle::ty::{Ty, TyCtxt};\n+use rustc_middle::mir::interpret::ConstValue;\n+use rustc_middle::ty::{self, layout::TyAndLayout, Ty, TyCtxt};\n use rustc_session::Session;\n use rustc_span::Span;\n \n@@ -194,3 +195,30 @@ pub fn shift_mask_val<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n pub fn span_invalid_monomorphization_error(a: &Session, b: Span, c: &str) {\n     struct_span_err!(a, b, E0511, \"{}\", c).emit();\n }\n+\n+pub fn asm_const_to_str<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    sp: Span,\n+    const_value: ConstValue<'tcx>,\n+    ty_and_layout: TyAndLayout<'tcx>,\n+) -> String {\n+    let scalar = match const_value {\n+        ConstValue::Scalar(s) => s,\n+        _ => {\n+            span_bug!(sp, \"expected Scalar for promoted asm const, but got {:#?}\", const_value)\n+        }\n+    };\n+    let value = scalar.assert_bits(ty_and_layout.size);\n+    match ty_and_layout.ty.kind() {\n+        ty::Uint(_) => value.to_string(),\n+        ty::Int(int_ty) => match int_ty.normalize(tcx.sess.target.pointer_width) {\n+            ty::IntTy::I8 => (value as i8).to_string(),\n+            ty::IntTy::I16 => (value as i16).to_string(),\n+            ty::IntTy::I32 => (value as i32).to_string(),\n+            ty::IntTy::I64 => (value as i64).to_string(),\n+            ty::IntTy::I128 => (value as i128).to_string(),\n+            ty::IntTy::Isize => unreachable!(),\n+        },\n+        _ => span_bug!(sp, \"asm const has bad type {}\", ty_and_layout.ty),\n+    }\n+}"}, {"sha": "962c01c2ee7a6fd25cb9633523056319f21643ac", "filename": "compiler/rustc_codegen_ssa/src/coverageinfo/ffi.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fffi.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -24,21 +24,39 @@ pub enum CounterKind {\n pub struct Counter {\n     // Important: The layout (order and types of fields) must match its C++ counterpart.\n     pub kind: CounterKind,\n-    pub id: u32,\n+    id: u32,\n }\n \n impl Counter {\n+    /// Constructs a new `Counter` of kind `Zero`. For this `CounterKind`, the\n+    /// `id` is not used.\n     pub fn zero() -> Self {\n         Self { kind: CounterKind::Zero, id: 0 }\n     }\n \n+    /// Constructs a new `Counter` of kind `CounterValueReference`, and converts\n+    /// the given 1-based counter_id to the required 0-based equivalent for\n+    /// the `Counter` encoding.\n     pub fn counter_value_reference(counter_id: CounterValueReference) -> Self {\n-        Self { kind: CounterKind::CounterValueReference, id: counter_id.into() }\n+        Self { kind: CounterKind::CounterValueReference, id: counter_id.zero_based_index() }\n     }\n \n+    /// Constructs a new `Counter` of kind `Expression`.\n     pub fn expression(mapped_expression_index: MappedExpressionIndex) -> Self {\n         Self { kind: CounterKind::Expression, id: mapped_expression_index.into() }\n     }\n+\n+    /// Returns true if the `Counter` kind is `Zero`.\n+    pub fn is_zero(&self) -> bool {\n+        matches!(self.kind, CounterKind::Zero)\n+    }\n+\n+    /// An explicitly-named function to get the ID value, making it more obvious\n+    /// that the stored value is now 0-based.\n+    pub fn zero_based_id(&self) -> u32 {\n+        debug_assert!(!self.is_zero(), \"`id` is undefined for CounterKind::Zero\");\n+        self.id\n+    }\n }\n \n /// Aligns with [llvm::coverage::CounterExpression::ExprKind](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L147)"}, {"sha": "08442c588f87902ba3dede3d04cd3f7cf87f8090", "filename": "compiler/rustc_codegen_ssa/src/coverageinfo/map.rs", "status": "modified", "additions": 65, "deletions": 16, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -49,9 +49,9 @@ impl<'tcx> FunctionCoverage<'tcx> {\n     }\n \n     fn create(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>, is_used: bool) -> Self {\n-        let coverageinfo = tcx.coverageinfo(instance.def_id());\n+        let coverageinfo = tcx.coverageinfo(instance.def);\n         debug!(\n-            \"FunctionCoverage::new(instance={:?}) has coverageinfo={:?}. is_used={}\",\n+            \"FunctionCoverage::create(instance={:?}) has coverageinfo={:?}. is_used={}\",\n             instance, coverageinfo, is_used\n         );\n         Self {\n@@ -163,9 +163,7 @@ impl<'tcx> FunctionCoverage<'tcx> {\n         self.counters.iter_enumerated().filter_map(|(index, entry)| {\n             // Option::map() will return None to filter out missing counters. This may happen\n             // if, for example, a MIR-instrumented counter is removed during an optimization.\n-            entry.as_ref().map(|region| {\n-                (Counter::counter_value_reference(index as CounterValueReference), region)\n-            })\n+            entry.as_ref().map(|region| (Counter::counter_value_reference(index), region))\n         })\n     }\n \n@@ -206,9 +204,15 @@ impl<'tcx> FunctionCoverage<'tcx> {\n             if id == ExpressionOperandId::ZERO {\n                 Some(Counter::zero())\n             } else if id.index() < self.counters.len() {\n+                debug_assert!(\n+                    id.index() > 0,\n+                    \"ExpressionOperandId indexes for counters are 1-based, but this id={}\",\n+                    id.index()\n+                );\n                 // Note: Some codegen-injected Counters may be only referenced by `Expression`s,\n                 // and may not have their own `CodeRegion`s,\n                 let index = CounterValueReference::from(id.index());\n+                // Note, the conversion to LLVM `Counter` adjusts the index to be zero-based.\n                 Some(Counter::counter_value_reference(index))\n             } else {\n                 let index = self.expression_index(u32::from(id));\n@@ -233,19 +237,60 @@ impl<'tcx> FunctionCoverage<'tcx> {\n             let optional_region = &expression.region;\n             let Expression { lhs, op, rhs, .. } = *expression;\n \n-            if let Some(Some((lhs_counter, rhs_counter))) =\n-                id_to_counter(&new_indexes, lhs).map(|lhs_counter| {\n+            if let Some(Some((lhs_counter, mut rhs_counter))) = id_to_counter(&new_indexes, lhs)\n+                .map(|lhs_counter| {\n                     id_to_counter(&new_indexes, rhs).map(|rhs_counter| (lhs_counter, rhs_counter))\n                 })\n             {\n+                if lhs_counter.is_zero() && op.is_subtract() {\n+                    // The left side of a subtraction was probably optimized out. As an example,\n+                    // a branch condition might be evaluated as a constant expression, and the\n+                    // branch could be removed, dropping unused counters in the process.\n+                    //\n+                    // Since counters are unsigned, we must assume the result of the expression\n+                    // can be no more and no less than zero. An expression known to evaluate to zero\n+                    // does not need to be added to the coverage map.\n+                    //\n+                    // Coverage test `loops_branches.rs` includes multiple variations of branches\n+                    // based on constant conditional (literal `true` or `false`), and demonstrates\n+                    // that the expected counts are still correct.\n+                    debug!(\n+                        \"Expression subtracts from zero (assume unreachable): \\\n+                        original_index={:?}, lhs={:?}, op={:?}, rhs={:?}, region={:?}\",\n+                        original_index, lhs, op, rhs, optional_region,\n+                    );\n+                    rhs_counter = Counter::zero();\n+                }\n                 debug_assert!(\n-                    (lhs_counter.id as usize)\n-                        < usize::max(self.counters.len(), self.expressions.len())\n+                    lhs_counter.is_zero()\n+                        // Note: with `as usize` the ID _could_ overflow/wrap if `usize = u16`\n+                        || ((lhs_counter.zero_based_id() as usize)\n+                            <= usize::max(self.counters.len(), self.expressions.len())),\n+                    \"lhs id={} > both counters.len()={} and expressions.len()={}\n+                    ({:?} {:?} {:?})\",\n+                    lhs_counter.zero_based_id(),\n+                    self.counters.len(),\n+                    self.expressions.len(),\n+                    lhs_counter,\n+                    op,\n+                    rhs_counter,\n                 );\n+\n                 debug_assert!(\n-                    (rhs_counter.id as usize)\n-                        < usize::max(self.counters.len(), self.expressions.len())\n+                    rhs_counter.is_zero()\n+                        // Note: with `as usize` the ID _could_ overflow/wrap if `usize = u16`\n+                        || ((rhs_counter.zero_based_id() as usize)\n+                            <= usize::max(self.counters.len(), self.expressions.len())),\n+                    \"rhs id={} > both counters.len()={} and expressions.len()={}\n+                    ({:?} {:?} {:?})\",\n+                    rhs_counter.zero_based_id(),\n+                    self.counters.len(),\n+                    self.expressions.len(),\n+                    lhs_counter,\n+                    op,\n+                    rhs_counter,\n                 );\n+\n                 // Both operands exist. `Expression` operands exist in `self.expressions` and have\n                 // been assigned a `new_index`.\n                 let mapped_expression_index =\n@@ -268,11 +313,15 @@ impl<'tcx> FunctionCoverage<'tcx> {\n                     expression_regions.push((Counter::expression(mapped_expression_index), region));\n                 }\n             } else {\n-                debug!(\n-                    \"Ignoring expression with one or more missing operands: \\\n-                    original_index={:?}, lhs={:?}, op={:?}, rhs={:?}, region={:?}\",\n-                    original_index, lhs, op, rhs, optional_region,\n-                )\n+                bug!(\n+                    \"expression has one or more missing operands \\\n+                      original_index={:?}, lhs={:?}, op={:?}, rhs={:?}, region={:?}\",\n+                    original_index,\n+                    lhs,\n+                    op,\n+                    rhs,\n+                    optional_region,\n+                );\n             }\n         }\n         (counter_expressions, expression_regions.into_iter())"}, {"sha": "6c4bb021cb3a4b971251fc82390d8608bba94508", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -6,7 +6,6 @@\n #![feature(try_blocks)]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n-#![cfg_attr(bootstrap, feature(or_patterns))]\n #![feature(associated_type_bounds)]\n #![feature(iter_zip)]\n #![recursion_limit = \"256\"]\n@@ -114,11 +113,12 @@ pub struct NativeLib {\n     pub kind: NativeLibKind,\n     pub name: Option<Symbol>,\n     pub cfg: Option<ast::MetaItem>,\n+    pub verbatim: Option<bool>,\n }\n \n impl From<&cstore::NativeLib> for NativeLib {\n     fn from(lib: &cstore::NativeLib) -> Self {\n-        NativeLib { kind: lib.kind, name: lib.name, cfg: lib.cfg.clone() }\n+        NativeLib { kind: lib.kind, name: lib.name, cfg: lib.cfg.clone(), verbatim: lib.verbatim }\n     }\n }\n \n@@ -139,7 +139,6 @@ pub struct CrateInfo {\n     pub native_libraries: FxHashMap<CrateNum, Vec<NativeLib>>,\n     pub crate_name: FxHashMap<CrateNum, String>,\n     pub used_libraries: Vec<NativeLib>,\n-    pub link_args: Lrc<Vec<String>>,\n     pub used_crate_source: FxHashMap<CrateNum, Lrc<CrateSource>>,\n     pub used_crates_static: Vec<(CrateNum, LibSource)>,\n     pub used_crates_dynamic: Vec<(CrateNum, LibSource)>,"}, {"sha": "93200bd1f264a4465faf3e8e1366a6779f3fa1a4", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 139, "deletions": 79, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -12,7 +12,6 @@ use crate::MemFlags;\n use rustc_ast as ast;\n use rustc_hir::lang_items::LangItem;\n use rustc_index::vec::Idx;\n-use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::mir::AssertKind;\n use rustc_middle::mir::{self, SwitchTargets};\n use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt};\n@@ -21,7 +20,7 @@ use rustc_middle::ty::{self, Instance, Ty, TypeFoldable};\n use rustc_span::source_map::Span;\n use rustc_span::{sym, Symbol};\n use rustc_target::abi::call::{ArgAbi, FnAbi, PassMode};\n-use rustc_target::abi::{self, LayoutOf};\n+use rustc_target::abi::{self, HasDataLayout, LayoutOf};\n use rustc_target::spec::abi::Abi;\n \n /// Used by `FunctionCx::codegen_terminator` for emitting common patterns\n@@ -33,13 +32,34 @@ struct TerminatorCodegenHelper<'tcx> {\n }\n \n impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n-    /// Returns the associated funclet from `FunctionCx::funclets` for the\n-    /// `funclet_bb` member if it is not `None`.\n+    /// Returns the appropriate `Funclet` for the current funclet, if on MSVC,\n+    /// either already previously cached, or newly created, by `landing_pad_for`.\n     fn funclet<'b, Bx: BuilderMethods<'a, 'tcx>>(\n         &self,\n-        fx: &'b FunctionCx<'a, 'tcx, Bx>,\n+        fx: &'b mut FunctionCx<'a, 'tcx, Bx>,\n     ) -> Option<&'b Bx::Funclet> {\n-        self.funclet_bb.and_then(|funcl| fx.funclets[funcl].as_ref())\n+        let funclet_bb = self.funclet_bb?;\n+        if base::wants_msvc_seh(fx.cx.tcx().sess) {\n+            // If `landing_pad_for` hasn't been called yet to create the `Funclet`,\n+            // it has to be now. This may not seem necessary, as RPO should lead\n+            // to all the unwind edges being visited (and so to `landing_pad_for`\n+            // getting called for them), before building any of the blocks inside\n+            // the funclet itself - however, if MIR contains edges that end up not\n+            // being needed in the LLVM IR after monomorphization, the funclet may\n+            // be unreachable, and we don't have yet a way to skip building it in\n+            // such an eventuality (which may be a better solution than this).\n+            if fx.funclets[funclet_bb].is_none() {\n+                fx.landing_pad_for(funclet_bb);\n+            }\n+\n+            Some(\n+                fx.funclets[funclet_bb]\n+                    .as_ref()\n+                    .expect(\"landing_pad_for didn't also create funclets entry\"),\n+            )\n+        } else {\n+            None\n+        }\n     }\n \n     fn lltarget<Bx: BuilderMethods<'a, 'tcx>>(\n@@ -48,17 +68,17 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         target: mir::BasicBlock,\n     ) -> (Bx::BasicBlock, bool) {\n         let span = self.terminator.source_info.span;\n-        let lltarget = fx.blocks[target];\n+        let lltarget = fx.llbb(target);\n         let target_funclet = fx.cleanup_kinds[target].funclet_bb(target);\n         match (self.funclet_bb, target_funclet) {\n             (None, None) => (lltarget, false),\n             (Some(f), Some(t_f)) if f == t_f || !base::wants_msvc_seh(fx.cx.tcx().sess) => {\n                 (lltarget, false)\n             }\n-            // jump *into* cleanup - need a landing pad if GNU\n-            (None, Some(_)) => (fx.landing_pad_to(target), false),\n+            // jump *into* cleanup - need a landing pad if GNU, cleanup pad if MSVC\n+            (None, Some(_)) => (fx.landing_pad_for(target), false),\n             (Some(_), None) => span_bug!(span, \"{:?} - jump out of cleanup?\", self.terminator),\n-            (Some(_), Some(_)) => (fx.landing_pad_to(target), true),\n+            (Some(_), Some(_)) => (fx.landing_pad_for(target), true),\n         }\n     }\n \n@@ -113,13 +133,13 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         // If there is a cleanup block and the function we're calling can unwind, then\n         // do an invoke, otherwise do a call.\n         if let Some(cleanup) = cleanup.filter(|_| fn_abi.can_unwind) {\n-            let ret_bx = if let Some((_, target)) = destination {\n-                fx.blocks[target]\n+            let ret_llbb = if let Some((_, target)) = destination {\n+                fx.llbb(target)\n             } else {\n                 fx.unreachable_block()\n             };\n             let invokeret =\n-                bx.invoke(fn_ptr, &llargs, ret_bx, self.llblock(fx, cleanup), self.funclet(fx));\n+                bx.invoke(fn_ptr, &llargs, ret_llbb, self.llblock(fx, cleanup), self.funclet(fx));\n             bx.apply_attrs_callsite(&fn_abi, invokeret);\n \n             if let Some((ret_dest, target)) = destination {\n@@ -366,7 +386,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         // Create the failure block and the conditional branch to it.\n         let lltarget = helper.llblock(self, target);\n-        let panic_block = self.new_block(\"panic\");\n+        let panic_block = bx.build_sibling_block(\"panic\");\n         if expected {\n             bx.cond_br(cond, lltarget, panic_block.llbb());\n         } else {\n@@ -822,41 +842,16 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     InlineAsmOperandRef::InOut { reg, late, in_value, out_place }\n                 }\n                 mir::InlineAsmOperand::Const { ref value } => {\n-                    if let mir::Operand::Constant(constant) = value {\n-                        let const_value = self\n-                            .eval_mir_constant(constant)\n-                            .unwrap_or_else(|_| span_bug!(span, \"asm const cannot be resolved\"));\n-                        let ty = constant.ty();\n-                        let size = bx.layout_of(ty).size;\n-                        let scalar = match const_value {\n-                            ConstValue::Scalar(s) => s,\n-                            _ => span_bug!(\n-                                span,\n-                                \"expected Scalar for promoted asm const, but got {:#?}\",\n-                                const_value\n-                            ),\n-                        };\n-                        let value = scalar.assert_bits(size);\n-                        let string = match ty.kind() {\n-                            ty::Uint(_) => value.to_string(),\n-                            ty::Int(int_ty) => {\n-                                match int_ty.normalize(bx.tcx().sess.target.pointer_width) {\n-                                    ty::IntTy::I8 => (value as i8).to_string(),\n-                                    ty::IntTy::I16 => (value as i16).to_string(),\n-                                    ty::IntTy::I32 => (value as i32).to_string(),\n-                                    ty::IntTy::I64 => (value as i64).to_string(),\n-                                    ty::IntTy::I128 => (value as i128).to_string(),\n-                                    ty::IntTy::Isize => unreachable!(),\n-                                }\n-                            }\n-                            ty::Float(ty::FloatTy::F32) => f32::from_bits(value as u32).to_string(),\n-                            ty::Float(ty::FloatTy::F64) => f64::from_bits(value as u64).to_string(),\n-                            _ => span_bug!(span, \"asm const has bad type {}\", ty),\n-                        };\n-                        InlineAsmOperandRef::Const { string }\n-                    } else {\n-                        span_bug!(span, \"asm const is not a constant\");\n-                    }\n+                    let const_value = self\n+                        .eval_mir_constant(value)\n+                        .unwrap_or_else(|_| span_bug!(span, \"asm const cannot be resolved\"));\n+                    let string = common::asm_const_to_str(\n+                        bx.tcx(),\n+                        span,\n+                        const_value,\n+                        bx.layout_of(value.ty()),\n+                    );\n+                    InlineAsmOperandRef::Const { string }\n                 }\n                 mir::InlineAsmOperand::SymFn { ref value } => {\n                     let literal = self.monomorphize(value.literal);\n@@ -1148,7 +1143,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n             let caller = tcx.sess.source_map().lookup_char_pos(topmost.lo());\n             let const_loc = tcx.const_caller_location((\n-                Symbol::intern(&caller.file.name.to_string()),\n+                Symbol::intern(&caller.file.name.prefer_remapped().to_string_lossy()),\n                 caller.line as u32,\n                 caller.col_display as u32 + 1,\n             ));\n@@ -1196,38 +1191,88 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         }\n     }\n \n-    /// Returns the landing-pad wrapper around the given basic block.\n-    ///\n-    /// No-op in MSVC SEH scheme.\n-    fn landing_pad_to(&mut self, target_bb: mir::BasicBlock) -> Bx::BasicBlock {\n-        if let Some(block) = self.landing_pads[target_bb] {\n-            return block;\n+    /// Returns the landing/cleanup pad wrapper around the given basic block.\n+    // FIXME(eddyb) rename this to `eh_pad_for`.\n+    fn landing_pad_for(&mut self, bb: mir::BasicBlock) -> Bx::BasicBlock {\n+        if let Some(landing_pad) = self.landing_pads[bb] {\n+            return landing_pad;\n         }\n \n-        let block = self.blocks[target_bb];\n-        let landing_pad = self.landing_pad_uncached(block);\n-        self.landing_pads[target_bb] = Some(landing_pad);\n+        let landing_pad = self.landing_pad_for_uncached(bb);\n+        self.landing_pads[bb] = Some(landing_pad);\n         landing_pad\n     }\n \n-    fn landing_pad_uncached(&mut self, target_bb: Bx::BasicBlock) -> Bx::BasicBlock {\n+    // FIXME(eddyb) rename this to `eh_pad_for_uncached`.\n+    fn landing_pad_for_uncached(&mut self, bb: mir::BasicBlock) -> Bx::BasicBlock {\n+        let llbb = self.llbb(bb);\n         if base::wants_msvc_seh(self.cx.sess()) {\n-            span_bug!(self.mir.span, \"landing pad was not inserted?\")\n-        }\n-\n-        let mut bx = self.new_block(\"cleanup\");\n+            let funclet;\n+            let ret_llbb;\n+            match self.mir[bb].terminator.as_ref().map(|t| &t.kind) {\n+                // This is a basic block that we're aborting the program for,\n+                // notably in an `extern` function. These basic blocks are inserted\n+                // so that we assert that `extern` functions do indeed not panic,\n+                // and if they do we abort the process.\n+                //\n+                // On MSVC these are tricky though (where we're doing funclets). If\n+                // we were to do a cleanuppad (like below) the normal functions like\n+                // `longjmp` would trigger the abort logic, terminating the\n+                // program. Instead we insert the equivalent of `catch(...)` for C++\n+                // which magically doesn't trigger when `longjmp` files over this\n+                // frame.\n+                //\n+                // Lots more discussion can be found on #48251 but this codegen is\n+                // modeled after clang's for:\n+                //\n+                //      try {\n+                //          foo();\n+                //      } catch (...) {\n+                //          bar();\n+                //      }\n+                Some(&mir::TerminatorKind::Abort) => {\n+                    let mut cs_bx = self.new_block(&format!(\"cs_funclet{:?}\", bb));\n+                    let mut cp_bx = self.new_block(&format!(\"cp_funclet{:?}\", bb));\n+                    ret_llbb = cs_bx.llbb();\n+\n+                    let cs = cs_bx.catch_switch(None, None, 1);\n+                    cs_bx.add_handler(cs, cp_bx.llbb());\n+\n+                    // The \"null\" here is actually a RTTI type descriptor for the\n+                    // C++ personality function, but `catch (...)` has no type so\n+                    // it's null. The 64 here is actually a bitfield which\n+                    // represents that this is a catch-all block.\n+                    let null = cp_bx.const_null(\n+                        cp_bx.type_i8p_ext(cp_bx.cx().data_layout().instruction_address_space),\n+                    );\n+                    let sixty_four = cp_bx.const_i32(64);\n+                    funclet = cp_bx.catch_pad(cs, &[null, sixty_four, null]);\n+                    cp_bx.br(llbb);\n+                }\n+                _ => {\n+                    let mut cleanup_bx = self.new_block(&format!(\"funclet_{:?}\", bb));\n+                    ret_llbb = cleanup_bx.llbb();\n+                    funclet = cleanup_bx.cleanup_pad(None, &[]);\n+                    cleanup_bx.br(llbb);\n+                }\n+            }\n+            self.funclets[bb] = Some(funclet);\n+            ret_llbb\n+        } else {\n+            let mut bx = self.new_block(\"cleanup\");\n \n-        let llpersonality = self.cx.eh_personality();\n-        let llretty = self.landing_pad_type();\n-        let lp = bx.landing_pad(llretty, llpersonality, 1);\n-        bx.set_cleanup(lp);\n+            let llpersonality = self.cx.eh_personality();\n+            let llretty = self.landing_pad_type();\n+            let lp = bx.landing_pad(llretty, llpersonality, 1);\n+            bx.set_cleanup(lp);\n \n-        let slot = self.get_personality_slot(&mut bx);\n-        slot.storage_live(&mut bx);\n-        Pair(bx.extract_value(lp, 0), bx.extract_value(lp, 1)).store(&mut bx, slot);\n+            let slot = self.get_personality_slot(&mut bx);\n+            slot.storage_live(&mut bx);\n+            Pair(bx.extract_value(lp, 0), bx.extract_value(lp, 1)).store(&mut bx, slot);\n \n-        bx.br(target_bb);\n-        bx.llbb()\n+            bx.br(llbb);\n+            bx.llbb()\n+        }\n     }\n \n     fn landing_pad_type(&self) -> Bx::Type {\n@@ -1244,14 +1289,29 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         })\n     }\n \n-    pub fn new_block(&self, name: &str) -> Bx {\n-        Bx::new_block(self.cx, self.llfn, name)\n+    // FIXME(eddyb) replace with `build_sibling_block`/`append_sibling_block`\n+    // (which requires having a `Bx` already, and not all callers do).\n+    fn new_block(&self, name: &str) -> Bx {\n+        let llbb = Bx::append_block(self.cx, self.llfn, name);\n+        Bx::build(self.cx, llbb)\n+    }\n+\n+    /// Get the backend `BasicBlock` for a MIR `BasicBlock`, either already\n+    /// cached in `self.cached_llbbs`, or created on demand (and cached).\n+    // FIXME(eddyb) rename `llbb` and other `ll`-prefixed things to use a\n+    // more backend-agnostic prefix such as `cg` (i.e. this would be `cgbb`).\n+    pub fn llbb(&mut self, bb: mir::BasicBlock) -> Bx::BasicBlock {\n+        self.cached_llbbs[bb].unwrap_or_else(|| {\n+            // FIXME(eddyb) only name the block if `fewer_names` is `false`.\n+            let llbb = Bx::append_block(self.cx, self.llfn, &format!(\"{:?}\", bb));\n+            self.cached_llbbs[bb] = Some(llbb);\n+            llbb\n+        })\n     }\n \n-    pub fn build_block(&self, bb: mir::BasicBlock) -> Bx {\n-        let mut bx = Bx::with_cx(self.cx);\n-        bx.position_at_end(self.blocks[bb]);\n-        bx\n+    pub fn build_block(&mut self, bb: mir::BasicBlock) -> Bx {\n+        let llbb = self.llbb(bb);\n+        Bx::build(self.cx, llbb)\n     }\n \n     fn make_return_dest("}, {"sha": "a283bf1de763a9da378109d255792eeef0d2f8ff", "filename": "compiler/rustc_codegen_ssa/src/mir/coverageinfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -31,12 +31,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         bx.add_coverage_counter(instance, id, code_region);\n                     }\n \n-                    let coverageinfo = bx.tcx().coverageinfo(instance.def_id());\n+                    let coverageinfo = bx.tcx().coverageinfo(instance.def);\n \n                     let fn_name = bx.get_pgo_func_name_var(instance);\n                     let hash = bx.const_u64(function_source_hash);\n                     let num_counters = bx.const_u32(coverageinfo.num_counters);\n-                    let index = bx.const_u32(u32::from(id));\n+                    let index = bx.const_u32(id.zero_based_index());\n                     debug!(\n                         \"codegen intrinsic instrprof.increment(fn_name={:?}, hash={:?}, num_counters={:?}, index={:?})\",\n                         fn_name, hash, num_counters, index,"}, {"sha": "6bb20545f07bea36fed1ea8a0092aa0ef2c4d327", "filename": "compiler/rustc_codegen_ssa/src/mir/debuginfo.rs", "status": "modified", "additions": 39, "deletions": 15, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -6,7 +6,7 @@ use rustc_middle::ty;\n use rustc_session::config::DebugInfo;\n use rustc_span::symbol::{kw, Symbol};\n use rustc_span::{BytePos, Span};\n-use rustc_target::abi::{LayoutOf, Size};\n+use rustc_target::abi::Size;\n \n use super::operand::{OperandRef, OperandValue};\n use super::place::PlaceRef;\n@@ -265,33 +265,25 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 None => continue,\n             };\n \n-            let mut layout = base.layout;\n             let mut direct_offset = Size::ZERO;\n             // FIXME(eddyb) use smallvec here.\n             let mut indirect_offsets = vec![];\n+            let mut place = base;\n \n             for elem in &var.projection[..] {\n                 match *elem {\n                     mir::ProjectionElem::Deref => {\n                         indirect_offsets.push(Size::ZERO);\n-                        layout = bx.cx().layout_of(\n-                            layout\n-                                .ty\n-                                .builtin_deref(true)\n-                                .unwrap_or_else(|| {\n-                                    span_bug!(var.source_info.span, \"cannot deref `{}`\", layout.ty)\n-                                })\n-                                .ty,\n-                        );\n+                        place = place.project_deref(bx);\n                     }\n                     mir::ProjectionElem::Field(field, _) => {\n                         let i = field.index();\n                         let offset = indirect_offsets.last_mut().unwrap_or(&mut direct_offset);\n-                        *offset += layout.fields.offset(i);\n-                        layout = layout.field(bx.cx(), i);\n+                        *offset += place.layout.fields.offset(i);\n+                        place = place.project_field(bx, i);\n                     }\n                     mir::ProjectionElem::Downcast(_, variant) => {\n-                        layout = layout.for_variant(bx.cx(), variant);\n+                        place = place.project_downcast(bx, variant);\n                     }\n                     _ => span_bug!(\n                         var.source_info.span,\n@@ -301,7 +293,39 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 }\n             }\n \n-            bx.dbg_var_addr(dbg_var, dbg_loc, base.llval, direct_offset, &indirect_offsets);\n+            // When targeting MSVC, create extra allocas for arguments instead of pointing multiple\n+            // dbg_var_addr() calls into the same alloca with offsets. MSVC uses CodeView records\n+            // not DWARF and LLVM doesn't support translating the resulting\n+            // [DW_OP_deref, DW_OP_plus_uconst, offset, DW_OP_deref] debug info to CodeView.\n+            // Creating extra allocas on the stack makes the resulting debug info simple enough\n+            // that LLVM can generate correct CodeView records and thus the values appear in the\n+            // debugger. (#83709)\n+            let should_create_individual_allocas = bx.cx().sess().target.is_like_msvc\n+                && self.mir.local_kind(local) == mir::LocalKind::Arg\n+                // LLVM can handle simple things but anything more complex than just a direct\n+                // offset or one indirect offset of 0 is too complex for it to generate CV records\n+                // correctly.\n+                && (direct_offset != Size::ZERO\n+                    || !matches!(&indirect_offsets[..], [Size::ZERO] | []));\n+\n+            if should_create_individual_allocas {\n+                // Create a variable which will be a pointer to the actual value\n+                let ptr_ty = bx.tcx().mk_ty(ty::RawPtr(ty::TypeAndMut {\n+                    mutbl: mir::Mutability::Mut,\n+                    ty: place.layout.ty,\n+                }));\n+                let ptr_layout = bx.layout_of(ptr_ty);\n+                let alloca = PlaceRef::alloca(bx, ptr_layout);\n+                bx.set_var_name(alloca.llval, &(var.name.to_string() + \".dbg.spill\"));\n+\n+                // Write the pointer to the variable\n+                bx.store(place.llval, alloca.llval, alloca.align);\n+\n+                // Point the debug info to `*alloca` for the current variable\n+                bx.dbg_var_addr(dbg_var, dbg_loc, alloca.llval, Size::ZERO, &[Size::ZERO]);\n+            } else {\n+                bx.dbg_var_addr(dbg_var, dbg_loc, base.llval, direct_offset, &indirect_offsets);\n+            }\n         }\n     }\n "}, {"sha": "3bbc481b61093fccfa1fe09ae051095f6ebb5aac", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 29, "deletions": 114, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -1,19 +1,16 @@\n-use crate::base;\n use crate::traits::*;\n use rustc_errors::ErrorReported;\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt, TyAndLayout};\n use rustc_middle::ty::{self, Instance, Ty, TypeFoldable};\n use rustc_target::abi::call::{FnAbi, PassMode};\n-use rustc_target::abi::HasDataLayout;\n \n use std::iter;\n \n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n \n-use self::analyze::CleanupKind;\n use self::debuginfo::{FunctionDebugContext, PerLocalVarDebugInfo};\n use self::place::PlaceRef;\n use rustc_middle::mir::traversal;\n@@ -43,18 +40,22 @@ pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n     /// then later loaded when generating the DIVERGE_BLOCK.\n     personality_slot: Option<PlaceRef<'tcx, Bx::Value>>,\n \n-    /// A `Block` for each MIR `BasicBlock`\n-    blocks: IndexVec<mir::BasicBlock, Bx::BasicBlock>,\n+    /// A backend `BasicBlock` for each MIR `BasicBlock`, created lazily\n+    /// as-needed (e.g. RPO reaching it or another block branching to it).\n+    // FIXME(eddyb) rename `llbbs` and other `ll`-prefixed things to use a\n+    // more backend-agnostic prefix such as `cg` (i.e. this would be `cgbbs`).\n+    cached_llbbs: IndexVec<mir::BasicBlock, Option<Bx::BasicBlock>>,\n \n     /// The funclet status of each basic block\n     cleanup_kinds: IndexVec<mir::BasicBlock, analyze::CleanupKind>,\n \n-    /// When targeting MSVC, this stores the cleanup info for each funclet\n-    /// BB. This is initialized as we compute the funclets' head block in RPO.\n+    /// When targeting MSVC, this stores the cleanup info for each funclet BB.\n+    /// This is initialized at the same time as the `landing_pads` entry for the\n+    /// funclets' head block, i.e. when needed by an unwind / `cleanup_ret` edge.\n     funclets: IndexVec<mir::BasicBlock, Option<Bx::Funclet>>,\n \n-    /// This stores the landing-pad block for a given BB, computed lazily on GNU\n-    /// and eagerly on MSVC.\n+    /// This stores the cached landing/cleanup pad block for a given BB.\n+    // FIXME(eddyb) rename this to `eh_pads`.\n     landing_pads: IndexVec<mir::BasicBlock, Option<Bx::BasicBlock>>,\n \n     /// Cached unreachable block\n@@ -143,7 +144,8 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n     let debug_context = cx.create_function_debug_context(instance, &fn_abi, llfn, &mir);\n \n-    let mut bx = Bx::new_block(cx, llfn, \"start\");\n+    let start_llbb = Bx::append_block(cx, llfn, \"start\");\n+    let mut bx = Bx::build(cx, start_llbb);\n \n     if mir.basic_blocks().iter().any(|bb| bb.is_cleanup) {\n         bx.set_personality_fn(cx.eh_personality());\n@@ -153,31 +155,30 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     // Allocate a `Block` for every basic block, except\n     // the start block, if nothing loops back to it.\n     let reentrant_start_block = !mir.predecessors()[mir::START_BLOCK].is_empty();\n-    let block_bxs: IndexVec<mir::BasicBlock, Bx::BasicBlock> = mir\n-        .basic_blocks()\n-        .indices()\n-        .map(|bb| {\n-            if bb == mir::START_BLOCK && !reentrant_start_block {\n-                bx.llbb()\n-            } else {\n-                bx.build_sibling_block(&format!(\"{:?}\", bb)).llbb()\n-            }\n-        })\n-        .collect();\n+    let cached_llbbs: IndexVec<mir::BasicBlock, Option<Bx::BasicBlock>> =\n+        mir.basic_blocks()\n+            .indices()\n+            .map(|bb| {\n+                if bb == mir::START_BLOCK && !reentrant_start_block {\n+                    Some(start_llbb)\n+                } else {\n+                    None\n+                }\n+            })\n+            .collect();\n \n-    let (landing_pads, funclets) = create_funclets(&mir, &mut bx, &cleanup_kinds, &block_bxs);\n     let mut fx = FunctionCx {\n         instance,\n         mir,\n         llfn,\n         fn_abi,\n         cx,\n         personality_slot: None,\n-        blocks: block_bxs,\n+        cached_llbbs,\n         unreachable_block: None,\n         cleanup_kinds,\n-        landing_pads,\n-        funclets,\n+        landing_pads: IndexVec::from_elem(None, mir.basic_blocks()),\n+        funclets: IndexVec::from_fn_n(|_| None, mir.basic_blocks().len()),\n         locals: IndexVec::new(),\n         debug_context,\n         per_local_var_debug_info: None,\n@@ -248,100 +249,14 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n     // Branch to the START block, if it's not the entry block.\n     if reentrant_start_block {\n-        bx.br(fx.blocks[mir::START_BLOCK]);\n+        bx.br(fx.llbb(mir::START_BLOCK));\n     }\n \n-    let rpo = traversal::reverse_postorder(&mir);\n-    let mut visited = BitSet::new_empty(mir.basic_blocks().len());\n-\n     // Codegen the body of each block using reverse postorder\n-    for (bb, _) in rpo {\n-        visited.insert(bb.index());\n+    // FIXME(eddyb) reuse RPO iterator between `analysis` and this.\n+    for (bb, _) in traversal::reverse_postorder(&mir) {\n         fx.codegen_block(bb);\n     }\n-\n-    // Remove blocks that haven't been visited, or have no\n-    // predecessors.\n-    for bb in mir.basic_blocks().indices() {\n-        // Unreachable block\n-        if !visited.contains(bb.index()) {\n-            debug!(\"codegen_mir: block {:?} was not visited\", bb);\n-            unsafe {\n-                bx.delete_basic_block(fx.blocks[bb]);\n-            }\n-        }\n-    }\n-}\n-\n-fn create_funclets<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n-    mir: &'tcx mir::Body<'tcx>,\n-    bx: &mut Bx,\n-    cleanup_kinds: &IndexVec<mir::BasicBlock, CleanupKind>,\n-    block_bxs: &IndexVec<mir::BasicBlock, Bx::BasicBlock>,\n-) -> (\n-    IndexVec<mir::BasicBlock, Option<Bx::BasicBlock>>,\n-    IndexVec<mir::BasicBlock, Option<Bx::Funclet>>,\n-) {\n-    iter::zip(block_bxs.iter_enumerated(), cleanup_kinds)\n-        .map(|((bb, &llbb), cleanup_kind)| {\n-            match *cleanup_kind {\n-                CleanupKind::Funclet if base::wants_msvc_seh(bx.sess()) => {}\n-                _ => return (None, None),\n-            }\n-\n-            let funclet;\n-            let ret_llbb;\n-            match mir[bb].terminator.as_ref().map(|t| &t.kind) {\n-                // This is a basic block that we're aborting the program for,\n-                // notably in an `extern` function. These basic blocks are inserted\n-                // so that we assert that `extern` functions do indeed not panic,\n-                // and if they do we abort the process.\n-                //\n-                // On MSVC these are tricky though (where we're doing funclets). If\n-                // we were to do a cleanuppad (like below) the normal functions like\n-                // `longjmp` would trigger the abort logic, terminating the\n-                // program. Instead we insert the equivalent of `catch(...)` for C++\n-                // which magically doesn't trigger when `longjmp` files over this\n-                // frame.\n-                //\n-                // Lots more discussion can be found on #48251 but this codegen is\n-                // modeled after clang's for:\n-                //\n-                //      try {\n-                //          foo();\n-                //      } catch (...) {\n-                //          bar();\n-                //      }\n-                Some(&mir::TerminatorKind::Abort) => {\n-                    let mut cs_bx = bx.build_sibling_block(&format!(\"cs_funclet{:?}\", bb));\n-                    let mut cp_bx = bx.build_sibling_block(&format!(\"cp_funclet{:?}\", bb));\n-                    ret_llbb = cs_bx.llbb();\n-\n-                    let cs = cs_bx.catch_switch(None, None, 1);\n-                    cs_bx.add_handler(cs, cp_bx.llbb());\n-\n-                    // The \"null\" here is actually a RTTI type descriptor for the\n-                    // C++ personality function, but `catch (...)` has no type so\n-                    // it's null. The 64 here is actually a bitfield which\n-                    // represents that this is a catch-all block.\n-                    let null = bx.const_null(\n-                        bx.type_i8p_ext(bx.cx().data_layout().instruction_address_space),\n-                    );\n-                    let sixty_four = bx.const_i32(64);\n-                    funclet = cp_bx.catch_pad(cs, &[null, sixty_four, null]);\n-                    cp_bx.br(llbb);\n-                }\n-                _ => {\n-                    let mut cleanup_bx = bx.build_sibling_block(&format!(\"funclet_{:?}\", bb));\n-                    ret_llbb = cleanup_bx.llbb();\n-                    funclet = cleanup_bx.cleanup_pad(None, &[]);\n-                    cleanup_bx.br(llbb);\n-                }\n-            };\n-\n-            (Some(ret_llbb), Some(funclet))\n-        })\n-        .unzip()\n }\n \n /// Produces, for each argument, a `Value` pointing at the"}, {"sha": "a9e7ebf6d43f72f178551e95592679bd8f683a0a", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -402,6 +402,18 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         downcast\n     }\n \n+    pub fn project_deref<Bx: BuilderMethods<'a, 'tcx, Value = V>>(&self, bx: &mut Bx) -> Self {\n+        let target_ty = self.layout.ty.builtin_deref(true).expect(\"failed to deref\");\n+        let layout = bx.layout_of(target_ty.ty);\n+\n+        PlaceRef {\n+            llval: bx.load(self.llval, self.align),\n+            llextra: None,\n+            layout,\n+            align: layout.align.abi,\n+        }\n+    }\n+\n     pub fn storage_live<Bx: BuilderMethods<'a, 'tcx, Value = V>>(&self, bx: &mut Bx) {\n         bx.lifetime_start(self.llval, self.layout.size);\n     }"}, {"sha": "530de3de9e870e9604afe0526ea6e4f59dc0a346", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 36, "deletions": 136, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -11,10 +11,9 @@ use rustc_apfloat::{ieee, Float, Round, Status};\n use rustc_hir::lang_items::LangItem;\n use rustc_middle::mir;\n use rustc_middle::ty::cast::{CastTy, IntTy};\n-use rustc_middle::ty::layout::{HasTyCtxt, TyAndLayout};\n+use rustc_middle::ty::layout::HasTyCtxt;\n use rustc_middle::ty::{self, adjustment::PointerCast, Instance, Ty, TyCtxt};\n use rustc_span::source_map::{Span, DUMMY_SP};\n-use rustc_span::symbol::sym;\n use rustc_target::abi::{Abi, Int, LayoutOf, Variants};\n \n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n@@ -187,9 +186,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     mir::CastKind::Pointer(PointerCast::ReifyFnPointer) => {\n                         match *operand.layout.ty.kind() {\n                             ty::FnDef(def_id, substs) => {\n-                                if bx.cx().tcx().has_attr(def_id, sym::rustc_args_required_const) {\n-                                    bug!(\"reifying a fn ptr that requires const arguments\");\n-                                }\n                                 let instance = ty::Instance::resolve_for_fn_ptr(\n                                     bx.tcx(),\n                                     ty::ParamEnv::reveal_all(),\n@@ -385,10 +381,10 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                 bx.inttoptr(usize_llval, ll_t_out)\n                             }\n                             (CastTy::Float, CastTy::Int(IntTy::I)) => {\n-                                cast_float_to_int(&mut bx, true, llval, ll_t_in, ll_t_out, cast)\n+                                cast_float_to_int(&mut bx, true, llval, ll_t_in, ll_t_out)\n                             }\n                             (CastTy::Float, CastTy::Int(_)) => {\n-                                cast_float_to_int(&mut bx, false, llval, ll_t_in, ll_t_out, cast)\n+                                cast_float_to_int(&mut bx, false, llval, ll_t_in, ll_t_out)\n                             }\n                             _ => bug!(\"unsupported cast: {:?} to {:?}\", operand.layout.ty, cast.ty),\n                         };\n@@ -790,7 +786,6 @@ fn cast_float_to_int<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     x: Bx::Value,\n     float_ty: Bx::Type,\n     int_ty: Bx::Type,\n-    int_layout: TyAndLayout<'tcx>,\n ) -> Bx::Value {\n     if let Some(false) = bx.cx().sess().opts.debugging_opts.saturating_float_casts {\n         return if signed { bx.fptosi(x, int_ty) } else { bx.fptoui(x, int_ty) };\n@@ -891,134 +886,39 @@ fn cast_float_to_int<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     let int_min = bx.cx().const_uint_big(int_ty, int_min(signed, int_width) as u128);\n     let zero = bx.cx().const_uint(int_ty, 0);\n \n-    // The codegen here differs quite a bit depending on whether our builder's\n-    // `fptosi` and `fptoui` instructions may trap for out-of-bounds values. If\n-    // they don't trap then we can start doing everything inline with a\n-    // `select` instruction because it's ok to execute `fptosi` and `fptoui`\n-    // even if we don't use the results.\n-    if !bx.fptosui_may_trap(x, int_ty) {\n-        // Step 1 ...\n-        let fptosui_result = if signed { bx.fptosi(x, int_ty) } else { bx.fptoui(x, int_ty) };\n-        let less_or_nan = bx.fcmp(RealPredicate::RealULT, x, f_min);\n-        let greater = bx.fcmp(RealPredicate::RealOGT, x, f_max);\n-\n-        // Step 2: We use two comparisons and two selects, with %s1 being the\n-        // result:\n-        //     %less_or_nan = fcmp ult %x, %f_min\n-        //     %greater = fcmp olt %x, %f_max\n-        //     %s0 = select %less_or_nan, int_ty::MIN, %fptosi_result\n-        //     %s1 = select %greater, int_ty::MAX, %s0\n-        // Note that %less_or_nan uses an *unordered* comparison. This\n-        // comparison is true if the operands are not comparable (i.e., if x is\n-        // NaN). The unordered comparison ensures that s1 becomes int_ty::MIN if\n-        // x is NaN.\n-        //\n-        // Performance note: Unordered comparison can be lowered to a \"flipped\"\n-        // comparison and a negation, and the negation can be merged into the\n-        // select. Therefore, it not necessarily any more expensive than a\n-        // ordered (\"normal\") comparison. Whether these optimizations will be\n-        // performed is ultimately up to the backend, but at least x86 does\n-        // perform them.\n-        let s0 = bx.select(less_or_nan, int_min, fptosui_result);\n-        let s1 = bx.select(greater, int_max, s0);\n-\n-        // Step 3: NaN replacement.\n-        // For unsigned types, the above step already yielded int_ty::MIN == 0 if x is NaN.\n-        // Therefore we only need to execute this step for signed integer types.\n-        if signed {\n-            // LLVM has no isNaN predicate, so we use (x == x) instead\n-            let cmp = bx.fcmp(RealPredicate::RealOEQ, x, x);\n-            bx.select(cmp, s1, zero)\n-        } else {\n-            s1\n-        }\n+    // Step 1 ...\n+    let fptosui_result = if signed { bx.fptosi(x, int_ty) } else { bx.fptoui(x, int_ty) };\n+    let less_or_nan = bx.fcmp(RealPredicate::RealULT, x, f_min);\n+    let greater = bx.fcmp(RealPredicate::RealOGT, x, f_max);\n+\n+    // Step 2: We use two comparisons and two selects, with %s1 being the\n+    // result:\n+    //     %less_or_nan = fcmp ult %x, %f_min\n+    //     %greater = fcmp olt %x, %f_max\n+    //     %s0 = select %less_or_nan, int_ty::MIN, %fptosi_result\n+    //     %s1 = select %greater, int_ty::MAX, %s0\n+    // Note that %less_or_nan uses an *unordered* comparison. This\n+    // comparison is true if the operands are not comparable (i.e., if x is\n+    // NaN). The unordered comparison ensures that s1 becomes int_ty::MIN if\n+    // x is NaN.\n+    //\n+    // Performance note: Unordered comparison can be lowered to a \"flipped\"\n+    // comparison and a negation, and the negation can be merged into the\n+    // select. Therefore, it not necessarily any more expensive than a\n+    // ordered (\"normal\") comparison. Whether these optimizations will be\n+    // performed is ultimately up to the backend, but at least x86 does\n+    // perform them.\n+    let s0 = bx.select(less_or_nan, int_min, fptosui_result);\n+    let s1 = bx.select(greater, int_max, s0);\n+\n+    // Step 3: NaN replacement.\n+    // For unsigned types, the above step already yielded int_ty::MIN == 0 if x is NaN.\n+    // Therefore we only need to execute this step for signed integer types.\n+    if signed {\n+        // LLVM has no isNaN predicate, so we use (x == x) instead\n+        let cmp = bx.fcmp(RealPredicate::RealOEQ, x, x);\n+        bx.select(cmp, s1, zero)\n     } else {\n-        // In this case we cannot execute `fptosi` or `fptoui` and then later\n-        // discard the result. The builder is telling us that these instructions\n-        // will trap on out-of-bounds values, so we need to use basic blocks and\n-        // control flow to avoid executing the `fptosi` and `fptoui`\n-        // instructions.\n-        //\n-        // The general idea of what we're constructing here is, for f64 -> i32:\n-        //\n-        //      ;; block so far... %0 is the argument\n-        //      %result = alloca i32, align 4\n-        //      %inbound_lower = fcmp oge double %0, 0xC1E0000000000000\n-        //      %inbound_upper = fcmp ole double %0, 0x41DFFFFFFFC00000\n-        //      ;; match (inbound_lower, inbound_upper) {\n-        //      ;;     (true, true) => %0 can be converted without trapping\n-        //      ;;     (false, false) => %0 is a NaN\n-        //      ;;     (true, false) => %0 is too large\n-        //      ;;     (false, true) => %0 is too small\n-        //      ;; }\n-        //      ;;\n-        //      ;; The (true, true) check, go to %convert if so.\n-        //      %inbounds = and i1 %inbound_lower, %inbound_upper\n-        //      br i1 %inbounds, label %convert, label %specialcase\n-        //\n-        //  convert:\n-        //      %cvt = call i32 @llvm.wasm.trunc.signed.i32.f64(double %0)\n-        //      store i32 %cvt, i32* %result, align 4\n-        //      br label %done\n-        //\n-        //  specialcase:\n-        //      ;; Handle the cases where the number is NaN, too large or too small\n-        //\n-        //      ;; Either (true, false) or (false, true)\n-        //      %is_not_nan = or i1 %inbound_lower, %inbound_upper\n-        //      ;; Figure out which saturated value we are interested in if not `NaN`\n-        //      %saturated = select i1 %inbound_lower, i32 2147483647, i32 -2147483648\n-        //      ;; Figure out between saturated and NaN representations\n-        //      %result_nan = select i1 %is_not_nan, i32 %saturated, i32 0\n-        //      store i32 %result_nan, i32* %result, align 4\n-        //      br label %done\n-        //\n-        //  done:\n-        //      %r = load i32, i32* %result, align 4\n-        //      ;; ...\n-        let done = bx.build_sibling_block(\"float_cast_done\");\n-        let mut convert = bx.build_sibling_block(\"float_cast_convert\");\n-        let mut specialcase = bx.build_sibling_block(\"float_cast_specialcase\");\n-\n-        let result = PlaceRef::alloca(bx, int_layout);\n-        result.storage_live(bx);\n-\n-        // Use control flow to figure out whether we can execute `fptosi` in a\n-        // basic block, or whether we go to a different basic block to implement\n-        // the saturating logic.\n-        let inbound_lower = bx.fcmp(RealPredicate::RealOGE, x, f_min);\n-        let inbound_upper = bx.fcmp(RealPredicate::RealOLE, x, f_max);\n-        let inbounds = bx.and(inbound_lower, inbound_upper);\n-        bx.cond_br(inbounds, convert.llbb(), specialcase.llbb());\n-\n-        // Translation of the `convert` basic block\n-        let cvt = if signed { convert.fptosi(x, int_ty) } else { convert.fptoui(x, int_ty) };\n-        convert.store(cvt, result.llval, result.align);\n-        convert.br(done.llbb());\n-\n-        // Translation of the `specialcase` basic block. Note that like above\n-        // we try to be a bit clever here for unsigned conversions. In those\n-        // cases the `int_min` is zero so we don't need two select instructions,\n-        // just one to choose whether we need `int_max` or not. If\n-        // `inbound_lower` is true then we're guaranteed to not be `NaN` and\n-        // since we're greater than zero we must be saturating to `int_max`. If\n-        // `inbound_lower` is false then we're either NaN or less than zero, so\n-        // we saturate to zero.\n-        let result_nan = if signed {\n-            let is_not_nan = specialcase.or(inbound_lower, inbound_upper);\n-            let saturated = specialcase.select(inbound_lower, int_max, int_min);\n-            specialcase.select(is_not_nan, saturated, zero)\n-        } else {\n-            specialcase.select(inbound_lower, int_max, int_min)\n-        };\n-        specialcase.store(result_nan, result.llval, result.align);\n-        specialcase.br(done.llbb());\n-\n-        // Translation of the `done` basic block, positioning ourselves to\n-        // continue from that point as well.\n-        *bx = done;\n-        let ret = bx.load(result.llval, result.align);\n-        result.storage_dead(bx);\n-        ret\n+        s1\n     }\n }"}, {"sha": "48d753e0d843564f7d110c16d0ecad2f14206974", "filename": "compiler/rustc_codegen_ssa/src/mono_item.rs", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmono_item.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -1,10 +1,11 @@\n use crate::base;\n+use crate::common;\n use crate::traits::*;\n use rustc_hir as hir;\n+use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::mir::mono::{Linkage, Visibility};\n use rustc_middle::ty::layout::HasTyCtxt;\n-\n-use rustc_middle::mir::mono::MonoItem;\n+use rustc_target::abi::LayoutOf;\n \n pub trait MonoItemExt<'a, 'tcx> {\n     fn define<Bx: BuilderMethods<'a, 'tcx>>(&self, cx: &'a Bx::CodegenCx);\n@@ -32,8 +33,35 @@ impl<'a, 'tcx: 'a> MonoItemExt<'a, 'tcx> for MonoItem<'tcx> {\n             }\n             MonoItem::GlobalAsm(item_id) => {\n                 let item = cx.tcx().hir().item(item_id);\n-                if let hir::ItemKind::GlobalAsm(ref ga) = item.kind {\n-                    cx.codegen_global_asm(ga);\n+                if let hir::ItemKind::GlobalAsm(ref asm) = item.kind {\n+                    let operands: Vec<_> = asm\n+                        .operands\n+                        .iter()\n+                        .map(|(op, op_sp)| match *op {\n+                            hir::InlineAsmOperand::Const { ref anon_const } => {\n+                                let anon_const_def_id =\n+                                    cx.tcx().hir().local_def_id(anon_const.hir_id).to_def_id();\n+                                let const_value =\n+                                    cx.tcx().const_eval_poly(anon_const_def_id).unwrap_or_else(\n+                                        |_| span_bug!(*op_sp, \"asm const cannot be resolved\"),\n+                                    );\n+                                let ty = cx\n+                                    .tcx()\n+                                    .typeck_body(anon_const.body)\n+                                    .node_type(anon_const.hir_id);\n+                                let string = common::asm_const_to_str(\n+                                    cx.tcx(),\n+                                    *op_sp,\n+                                    const_value,\n+                                    cx.layout_of(ty),\n+                                );\n+                                GlobalAsmOperandRef::Const { string }\n+                            }\n+                            _ => span_bug!(*op_sp, \"invalid operand type for global_asm!\"),\n+                        })\n+                        .collect();\n+\n+                    cx.codegen_global_asm(asm.template, &operands, asm.options, asm.line_spans);\n                 } else {\n                     span_bug!(item.span, \"Mismatch between hir::Item type and MonoItem type\")\n                 }"}, {"sha": "98d550d732fe21ddd4d323ade5f27abdf358aa65", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 79, "deletions": 3, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -17,6 +17,8 @@ const ARM_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     (\"neon\", Some(sym::arm_target_feature)),\n     (\"crc\", Some(sym::arm_target_feature)),\n     (\"crypto\", Some(sym::arm_target_feature)),\n+    (\"aes\", Some(sym::arm_target_feature)),\n+    (\"sha2\", Some(sym::arm_target_feature)),\n     (\"v5te\", Some(sym::arm_target_feature)),\n     (\"v6\", Some(sym::arm_target_feature)),\n     (\"v6k\", Some(sym::arm_target_feature)),\n@@ -26,28 +28,102 @@ const ARM_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     (\"vfp2\", Some(sym::arm_target_feature)),\n     (\"vfp3\", Some(sym::arm_target_feature)),\n     (\"vfp4\", Some(sym::arm_target_feature)),\n+    (\"fp-armv8\", Some(sym::arm_target_feature)),\n     // This is needed for inline assembly, but shouldn't be stabilized as-is\n     // since it should be enabled per-function using #[instruction_set], not\n     // #[target_feature].\n     (\"thumb-mode\", Some(sym::arm_target_feature)),\n ];\n \n+// Commented features are not available in LLVM 10.0, or have since been renamed\n const AARCH64_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n-    (\"fp\", Some(sym::aarch64_target_feature)),\n+    // FEAT_AdvSimd\n     (\"neon\", Some(sym::aarch64_target_feature)),\n+    // FEAT_FP\n+    (\"fp\", Some(sym::aarch64_target_feature)),\n+    // FEAT_FP16\n+    (\"fp16\", Some(sym::aarch64_target_feature)),\n+    // FEAT_SVE\n     (\"sve\", Some(sym::aarch64_target_feature)),\n+    // FEAT_CRC\n     (\"crc\", Some(sym::aarch64_target_feature)),\n+    // Cryptographic extension\n     (\"crypto\", Some(sym::aarch64_target_feature)),\n+    // FEAT_RAS\n     (\"ras\", Some(sym::aarch64_target_feature)),\n+    // FEAT_LSE\n     (\"lse\", Some(sym::aarch64_target_feature)),\n+    // FEAT_RDM\n     (\"rdm\", Some(sym::aarch64_target_feature)),\n-    (\"fp16\", Some(sym::aarch64_target_feature)),\n+    // FEAT_RCPC\n     (\"rcpc\", Some(sym::aarch64_target_feature)),\n+    // FEAT_RCPC2\n+    (\"rcpc2\", Some(sym::aarch64_target_feature)),\n+    // FEAT_DotProd\n     (\"dotprod\", Some(sym::aarch64_target_feature)),\n+    // FEAT_TME\n     (\"tme\", Some(sym::aarch64_target_feature)),\n+    // FEAT_FHM\n+    (\"fhm\", Some(sym::aarch64_target_feature)),\n+    // FEAT_DIT\n+    (\"dit\", Some(sym::aarch64_target_feature)),\n+    // FEAT_FLAGM\n+    // (\"flagm\", Some(sym::aarch64_target_feature)),\n+    // FEAT_SSBS\n+    (\"ssbs\", Some(sym::aarch64_target_feature)),\n+    // FEAT_SB\n+    (\"sb\", Some(sym::aarch64_target_feature)),\n+    // FEAT_PAUTH\n+    // (\"pauth\", Some(sym::aarch64_target_feature)),\n+    // FEAT_DPB\n+    (\"dpb\", Some(sym::aarch64_target_feature)),\n+    // FEAT_DPB2\n+    (\"dpb2\", Some(sym::aarch64_target_feature)),\n+    // FEAT_SVE2\n+    (\"sve2\", Some(sym::aarch64_target_feature)),\n+    // FEAT_SVE2_AES\n+    (\"sve2-aes\", Some(sym::aarch64_target_feature)),\n+    // FEAT_SVE2_SM4\n+    (\"sve2-sm4\", Some(sym::aarch64_target_feature)),\n+    // FEAT_SVE2_SHA3\n+    (\"sve2-sha3\", Some(sym::aarch64_target_feature)),\n+    // FEAT_SVE2_BitPerm\n+    (\"sve2-bitperm\", Some(sym::aarch64_target_feature)),\n+    // FEAT_FRINTTS\n+    (\"frintts\", Some(sym::aarch64_target_feature)),\n+    // FEAT_I8MM\n+    // (\"i8mm\", Some(sym::aarch64_target_feature)),\n+    // FEAT_F32MM\n+    // (\"f32mm\", Some(sym::aarch64_target_feature)),\n+    // FEAT_F64MM\n+    // (\"f64mm\", Some(sym::aarch64_target_feature)),\n+    // FEAT_BF16\n+    // (\"bf16\", Some(sym::aarch64_target_feature)),\n+    // FEAT_RAND\n+    (\"rand\", Some(sym::aarch64_target_feature)),\n+    // FEAT_BTI\n+    (\"bti\", Some(sym::aarch64_target_feature)),\n+    // FEAT_MTE\n+    (\"mte\", Some(sym::aarch64_target_feature)),\n+    // FEAT_JSCVT\n+    (\"jsconv\", Some(sym::aarch64_target_feature)),\n+    // FEAT_FCMA\n+    (\"fcma\", Some(sym::aarch64_target_feature)),\n+    // FEAT_AES\n+    (\"aes\", Some(sym::aarch64_target_feature)),\n+    // FEAT_SHA1 & FEAT_SHA256\n+    (\"sha2\", Some(sym::aarch64_target_feature)),\n+    // FEAT_SHA512 & FEAT_SHA3\n+    (\"sha3\", Some(sym::aarch64_target_feature)),\n+    // FEAT_SM3 & FEAT_SM4\n+    (\"sm4\", Some(sym::aarch64_target_feature)),\n     (\"v8.1a\", Some(sym::aarch64_target_feature)),\n     (\"v8.2a\", Some(sym::aarch64_target_feature)),\n     (\"v8.3a\", Some(sym::aarch64_target_feature)),\n+    (\"v8.4a\", Some(sym::aarch64_target_feature)),\n+    (\"v8.5a\", Some(sym::aarch64_target_feature)),\n+    // (\"v8.6a\", Some(sym::aarch64_target_feature)),\n+    // (\"v8.7a\", Some(sym::aarch64_target_feature)),\n ];\n \n const X86_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n@@ -160,7 +236,7 @@ pub fn supported_target_features(sess: &Session) -> &'static [(&'static str, Opt\n         \"mips\" | \"mips64\" => MIPS_ALLOWED_FEATURES,\n         \"powerpc\" | \"powerpc64\" => POWERPC_ALLOWED_FEATURES,\n         \"riscv32\" | \"riscv64\" => RISCV_ALLOWED_FEATURES,\n-        \"wasm32\" => WASM_ALLOWED_FEATURES,\n+        \"wasm32\" | \"wasm64\" => WASM_ALLOWED_FEATURES,\n         _ => &[],\n     }\n }"}, {"sha": "86f2781a7663b6a605c06764e75a4c0e26aa055b", "filename": "compiler/rustc_codegen_ssa/src/traits/asm.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fasm.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -3,7 +3,7 @@ use crate::mir::operand::OperandRef;\n use crate::mir::place::PlaceRef;\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_hir::def_id::DefId;\n-use rustc_hir::{GlobalAsm, LlvmInlineAsmInner};\n+use rustc_hir::LlvmInlineAsmInner;\n use rustc_middle::ty::Instance;\n use rustc_span::Span;\n use rustc_target::asm::InlineAsmRegOrRegClass;\n@@ -36,6 +36,11 @@ pub enum InlineAsmOperandRef<'tcx, B: BackendTypes + ?Sized> {\n     },\n }\n \n+#[derive(Debug)]\n+pub enum GlobalAsmOperandRef {\n+    Const { string: String },\n+}\n+\n pub trait AsmBuilderMethods<'tcx>: BackendTypes {\n     /// Take an inline assembly expression and splat it out via LLVM\n     fn codegen_llvm_inline_asm(\n@@ -57,5 +62,11 @@ pub trait AsmBuilderMethods<'tcx>: BackendTypes {\n }\n \n pub trait AsmMethods {\n-    fn codegen_global_asm(&self, ga: &GlobalAsm);\n+    fn codegen_global_asm(\n+        &self,\n+        template: &[InlineAsmTemplatePiece],\n+        operands: &[GlobalAsmOperandRef],\n+        options: InlineAsmOptions,\n+        line_spans: &[Span],\n+    );\n }"}, {"sha": "29b2db5d4d7af2696726f7865dd62c3885b8443c", "filename": "compiler/rustc_codegen_ssa/src/traits/builder.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -40,14 +40,21 @@ pub trait BuilderMethods<'a, 'tcx>:\n     + HasParamEnv<'tcx>\n     + HasTargetSpec\n {\n-    fn new_block<'b>(cx: &'a Self::CodegenCx, llfn: Self::Function, name: &'b str) -> Self;\n-    fn with_cx(cx: &'a Self::CodegenCx) -> Self;\n-    fn build_sibling_block(&self, name: &str) -> Self;\n+    fn build(cx: &'a Self::CodegenCx, llbb: Self::BasicBlock) -> Self;\n+\n     fn cx(&self) -> &Self::CodegenCx;\n     fn llbb(&self) -> Self::BasicBlock;\n+\n     fn set_span(&mut self, span: Span);\n \n-    fn position_at_end(&mut self, llbb: Self::BasicBlock);\n+    // FIXME(eddyb) replace uses of this with `append_sibling_block`.\n+    fn append_block(cx: &'a Self::CodegenCx, llfn: Self::Function, name: &str) -> Self::BasicBlock;\n+\n+    fn append_sibling_block(&mut self, name: &str) -> Self::BasicBlock;\n+\n+    // FIXME(eddyb) replace with callers using `append_sibling_block`.\n+    fn build_sibling_block(&mut self, name: &str) -> Self;\n+\n     fn ret_void(&mut self);\n     fn ret(&mut self, v: Self::Value);\n     fn br(&mut self, dest: Self::BasicBlock);\n@@ -171,7 +178,6 @@ pub trait BuilderMethods<'a, 'tcx>:\n     fn sext(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n     fn fptoui_sat(&mut self, val: Self::Value, dest_ty: Self::Type) -> Option<Self::Value>;\n     fn fptosi_sat(&mut self, val: Self::Value, dest_ty: Self::Type) -> Option<Self::Value>;\n-    fn fptosui_may_trap(&self, val: Self::Value, dest_ty: Self::Type) -> bool;\n     fn fptoui(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n     fn fptosi(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n     fn uitofp(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n@@ -292,6 +298,5 @@ pub trait BuilderMethods<'a, 'tcx>:\n     ) -> Self::Value;\n     fn zext(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n \n-    unsafe fn delete_basic_block(&mut self, bb: Self::BasicBlock);\n     fn do_not_inline(&mut self, llret: Self::Value);\n }"}, {"sha": "c529fbbf518b667a9ed02953f9bf67cfcff6b61b", "filename": "compiler/rustc_codegen_ssa/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmod.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -29,7 +29,7 @@ mod type_;\n mod write;\n \n pub use self::abi::AbiBuilderMethods;\n-pub use self::asm::{AsmBuilderMethods, AsmMethods, InlineAsmOperandRef};\n+pub use self::asm::{AsmBuilderMethods, AsmMethods, GlobalAsmOperandRef, InlineAsmOperandRef};\n pub use self::backend::{Backend, BackendTypes, CodegenBackend, ExtraBackendMethods};\n pub use self::builder::{BuilderMethods, OverflowOp};\n pub use self::consts::ConstMethods;"}, {"sha": "93fbee2b49bb57a84c9921982cf00e5543e6e15a", "filename": "compiler/rustc_codegen_ssa/src/traits/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fwrite.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -58,7 +58,7 @@ pub trait WriteBackendMethods: 'static + Sized + Clone {\n         llmod: &ModuleCodegen<Self::Module>,\n         config: &ModuleConfig,\n         thin: bool,\n-    );\n+    ) -> Result<(), FatalError>;\n }\n \n pub trait ThinBufferMethods: Send + Sync {"}, {"sha": "aa95ecbdaf9323eaac4f3d14ddb3ac89b30756fb", "filename": "compiler/rustc_data_structures/Cargo.toml", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2FCargo.toml?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -8,7 +8,7 @@ edition = \"2018\"\n doctest = false\n \n [dependencies]\n-arrayvec = { version = \"0.5.1\", default-features = false }\n+arrayvec = { version = \"0.7\", default-features = false }\n ena = \"0.14\"\n indexmap = \"1.5.1\"\n tracing = \"0.1\"\n@@ -17,7 +17,7 @@ rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_graphviz = { path = \"../rustc_graphviz\" }\n cfg-if = \"0.1.2\"\n-crossbeam-utils = { version = \"0.7\", features = [\"nightly\"] }\n+crossbeam-utils = { version = \"0.8\", features = [\"nightly\"] }\n stable_deref_trait = \"1.0.0\"\n rayon = { version = \"0.3.1\", package = \"rustc-rayon\" }\n rayon-core = { version = \"0.3.1\", package = \"rustc-rayon-core\" }\n@@ -28,11 +28,13 @@ bitflags = \"1.2.1\"\n measureme = \"9.1.0\"\n libc = \"0.2\"\n stacker = \"0.1.12\"\n-tempfile = \"3.0.5\"\n+tempfile = \"3.2\"\n \n [dependencies.parking_lot]\n version = \"0.11\"\n-features = [\"nightly\"]\n \n [target.'cfg(windows)'.dependencies]\n winapi = { version = \"0.3\", features = [\"fileapi\", \"psapi\"] }\n+\n+[target.'cfg(not(target_arch = \"wasm32\"))'.dependencies]\n+memmap2 = \"0.2.1\""}, {"sha": "adbb98fa750476f7a66b72fd5322af51898315e1", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -84,6 +84,7 @@ pub mod snapshot_map;\n pub mod stable_map;\n pub mod svh;\n pub use ena::snapshot_vec;\n+pub mod memmap;\n pub mod sorted_map;\n pub mod stable_set;\n #[macro_use]"}, {"sha": "26b26415eea0f85c0088385ed7da2096b0330a52", "filename": "compiler/rustc_data_structures/src/memmap.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -0,0 +1,47 @@\n+use std::fs::File;\n+use std::io;\n+use std::ops::Deref;\n+\n+use crate::owning_ref::StableAddress;\n+\n+/// A trivial wrapper for [`memmap2::Mmap`] that implements [`StableAddress`].\n+#[cfg(not(target_arch = \"wasm32\"))]\n+pub struct Mmap(memmap2::Mmap);\n+\n+#[cfg(target_arch = \"wasm32\")]\n+pub struct Mmap(Vec<u8>);\n+\n+#[cfg(not(target_arch = \"wasm32\"))]\n+impl Mmap {\n+    #[inline]\n+    pub unsafe fn map(file: File) -> io::Result<Self> {\n+        memmap2::Mmap::map(&file).map(Mmap)\n+    }\n+}\n+\n+#[cfg(target_arch = \"wasm32\")]\n+impl Mmap {\n+    #[inline]\n+    pub unsafe fn map(mut file: File) -> io::Result<Self> {\n+        use std::io::Read;\n+\n+        let mut data = Vec::new();\n+        file.read_to_end(&mut data)?;\n+        Ok(Mmap(data))\n+    }\n+}\n+\n+impl Deref for Mmap {\n+    type Target = [u8];\n+\n+    #[inline]\n+    fn deref(&self) -> &[u8] {\n+        &*self.0\n+    }\n+}\n+\n+// SAFETY: On architectures other than WASM, mmap is used as backing storage. The address of this\n+// memory map is stable. On WASM, `Vec<u8>` is used as backing storage. The `Mmap` type doesn't\n+// export any function that can cause the `Vec` to be re-allocated. As such the address of the\n+// bytes inside this `Vec` is stable.\n+unsafe impl StableAddress for Mmap {}"}, {"sha": "29d685ab530d63f035f889d0b007a1a6751d7dae", "filename": "compiler/rustc_data_structures/src/obligation_forest/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -336,12 +336,13 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n     // Returns Err(()) if we already know this obligation failed.\n     fn register_obligation_at(&mut self, obligation: O, parent: Option<usize>) -> Result<(), ()> {\n-        if self.done_cache.contains(&obligation.as_cache_key()) {\n+        let cache_key = obligation.as_cache_key();\n+        if self.done_cache.contains(&cache_key) {\n             debug!(\"register_obligation_at: ignoring already done obligation: {:?}\", obligation);\n             return Ok(());\n         }\n \n-        match self.active_cache.entry(obligation.as_cache_key()) {\n+        match self.active_cache.entry(cache_key.clone()) {\n             Entry::Occupied(o) => {\n                 let node = &mut self.nodes[*o.get()];\n                 if let Some(parent_index) = parent {\n@@ -365,7 +366,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     && self\n                         .error_cache\n                         .get(&obligation_tree_id)\n-                        .map(|errors| errors.contains(&obligation.as_cache_key()))\n+                        .map(|errors| errors.contains(&cache_key))\n                         .unwrap_or(false);\n \n                 if already_failed {"}, {"sha": "e249886e9bc016f78661a0043bf5288388fd1634", "filename": "compiler/rustc_data_structures/src/sso/map.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -18,11 +18,8 @@ use std::ops::Index;\n // for reasonably small arrays that stay\n // small in vast majority of cases.\n //\n-// '8' is choosen as a sane default, to be\n+// '8' is chosen as a sane default, to be\n // reevaluated later.\n-//\n-// Note: As of now ArrayVec design prevents\n-//       us from making it user-customizable.\n const SSO_ARRAY_SIZE: usize = 8;\n \n /// Small-storage-optimized implementation of a map.\n@@ -70,7 +67,7 @@ const SSO_ARRAY_SIZE: usize = 8;\n \n #[derive(Clone)]\n pub enum SsoHashMap<K, V> {\n-    Array(ArrayVec<[(K, V); SSO_ARRAY_SIZE]>),\n+    Array(ArrayVec<(K, V), SSO_ARRAY_SIZE>),\n     Map(FxHashMap<K, V>),\n }\n \n@@ -411,7 +408,7 @@ where\n \n impl<K, V> IntoIterator for SsoHashMap<K, V> {\n     type IntoIter = EitherIter<\n-        <ArrayVec<[(K, V); 8]> as IntoIterator>::IntoIter,\n+        <ArrayVec<(K, V), 8> as IntoIterator>::IntoIter,\n         <FxHashMap<K, V> as IntoIterator>::IntoIter,\n     >;\n     type Item = <Self::IntoIter as Iterator>::Item;\n@@ -441,7 +438,7 @@ fn adapt_array_mut_it<K, V>(pair: &'a mut (K, V)) -> (&'a K, &'a mut V) {\n impl<'a, K, V> IntoIterator for &'a SsoHashMap<K, V> {\n     type IntoIter = EitherIter<\n         std::iter::Map<\n-            <&'a ArrayVec<[(K, V); 8]> as IntoIterator>::IntoIter,\n+            <&'a ArrayVec<(K, V), 8> as IntoIterator>::IntoIter,\n             fn(&'a (K, V)) -> (&'a K, &'a V),\n         >,\n         <&'a FxHashMap<K, V> as IntoIterator>::IntoIter,\n@@ -459,7 +456,7 @@ impl<'a, K, V> IntoIterator for &'a SsoHashMap<K, V> {\n impl<'a, K, V> IntoIterator for &'a mut SsoHashMap<K, V> {\n     type IntoIter = EitherIter<\n         std::iter::Map<\n-            <&'a mut ArrayVec<[(K, V); 8]> as IntoIterator>::IntoIter,\n+            <&'a mut ArrayVec<(K, V), 8> as IntoIterator>::IntoIter,\n             fn(&'a mut (K, V)) -> (&'a K, &'a mut V),\n         >,\n         <&'a mut FxHashMap<K, V> as IntoIterator>::IntoIter,"}, {"sha": "ce90fbacaa46c9094d21287fad2e55603788052a", "filename": "compiler/rustc_data_structures/src/svh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_data_structures%2Fsrc%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_data_structures%2Fsrc%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsvh.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -19,7 +19,7 @@ pub struct Svh {\n impl Svh {\n     /// Creates a new `Svh` given the hash. If you actually want to\n     /// compute the SVH from some HIR, you want the `calculate_svh`\n-    /// function found in `librustc_incremental`.\n+    /// function found in `rustc_incremental`.\n     pub fn new(hash: u64) -> Svh {\n         Svh { hash }\n     }"}, {"sha": "d44ccd368b3cbb507c630fca26432c7a7da39da2", "filename": "compiler/rustc_data_structures/src/tagged_ptr/drop.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -42,18 +42,9 @@ where\n     pub fn pointer_ref(&self) -> &P::Target {\n         self.raw.pointer_ref()\n     }\n-    pub fn pointer_mut(&mut self) -> &mut P::Target\n-    where\n-        P: std::ops::DerefMut,\n-    {\n-        self.raw.pointer_mut()\n-    }\n     pub fn tag(&self) -> T {\n         self.raw.tag()\n     }\n-    pub fn set_tag(&mut self, tag: T) {\n-        self.raw.set_tag(tag);\n-    }\n }\n \n impl<P, T, const COMPARE_PACKED: bool> std::ops::Deref for TaggedPtr<P, T, COMPARE_PACKED>"}, {"sha": "00e304734983ff15a0cb3e78dd76a8649f692508", "filename": "compiler/rustc_data_structures/src/thin_vec.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -1,5 +1,7 @@\n use crate::stable_hasher::{HashStable, StableHasher};\n \n+use std::iter::FromIterator;\n+\n /// A vector type optimized for cases where this size is usually 0 (cf. `SmallVector`).\n /// The `Option<Box<..>>` wrapping allows us to represent a zero sized vector with `None`,\n /// which uses only a single (null) pointer.\n@@ -10,6 +12,14 @@ impl<T> ThinVec<T> {\n     pub fn new() -> Self {\n         ThinVec(None)\n     }\n+\n+    pub fn iter(&self) -> std::slice::Iter<'_, T> {\n+        self.into_iter()\n+    }\n+\n+    pub fn iter_mut(&mut self) -> std::slice::IterMut<'_, T> {\n+        self.into_iter()\n+    }\n }\n \n impl<T> From<Vec<T>> for ThinVec<T> {\n@@ -46,6 +56,42 @@ impl<T> ::std::ops::DerefMut for ThinVec<T> {\n     }\n }\n \n+impl<T> FromIterator<T> for ThinVec<T> {\n+    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {\n+        // `Vec::from_iter()` should not allocate if the iterator is empty.\n+        let vec: Vec<_> = iter.into_iter().collect();\n+        if vec.is_empty() { ThinVec(None) } else { ThinVec(Some(Box::new(vec))) }\n+    }\n+}\n+\n+impl<T> IntoIterator for ThinVec<T> {\n+    type Item = T;\n+    type IntoIter = std::vec::IntoIter<T>;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        // This is still performant because `Vec::new()` does not allocate.\n+        self.0.map_or_else(Vec::new, |ptr| *ptr).into_iter()\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a ThinVec<T> {\n+    type Item = &'a T;\n+    type IntoIter = std::slice::Iter<'a, T>;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.as_ref().iter()\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a mut ThinVec<T> {\n+    type Item = &'a mut T;\n+    type IntoIter = std::slice::IterMut<'a, T>;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.as_mut().iter_mut()\n+    }\n+}\n+\n impl<T> Extend<T> for ThinVec<T> {\n     fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n         match *self {\n@@ -80,3 +126,6 @@ impl<T> Default for ThinVec<T> {\n         Self(None)\n     }\n }\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "5abfd939373c7668ff5657be21343c220f18cba3", "filename": "compiler/rustc_data_structures/src/thin_vec/tests.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec%2Ftests.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -0,0 +1,42 @@\n+use super::*;\n+\n+impl<T> ThinVec<T> {\n+    fn into_vec(self) -> Vec<T> {\n+        self.into()\n+    }\n+}\n+\n+#[test]\n+fn test_from_iterator() {\n+    assert_eq!(std::iter::empty().collect::<ThinVec<String>>().into_vec(), Vec::<String>::new());\n+    assert_eq!(std::iter::once(42).collect::<ThinVec<_>>().into_vec(), vec![42]);\n+    assert_eq!(vec![1, 2].into_iter().collect::<ThinVec<_>>().into_vec(), vec![1, 2]);\n+    assert_eq!(vec![1, 2, 3].into_iter().collect::<ThinVec<_>>().into_vec(), vec![1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_into_iterator_owned() {\n+    assert_eq!(ThinVec::new().into_iter().collect::<Vec<String>>(), Vec::<String>::new());\n+    assert_eq!(ThinVec::from(vec![1]).into_iter().collect::<Vec<_>>(), vec![1]);\n+    assert_eq!(ThinVec::from(vec![1, 2]).into_iter().collect::<Vec<_>>(), vec![1, 2]);\n+    assert_eq!(ThinVec::from(vec![1, 2, 3]).into_iter().collect::<Vec<_>>(), vec![1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_into_iterator_ref() {\n+    assert_eq!(ThinVec::new().iter().collect::<Vec<&String>>(), Vec::<&String>::new());\n+    assert_eq!(ThinVec::from(vec![1]).iter().collect::<Vec<_>>(), vec![&1]);\n+    assert_eq!(ThinVec::from(vec![1, 2]).iter().collect::<Vec<_>>(), vec![&1, &2]);\n+    assert_eq!(ThinVec::from(vec![1, 2, 3]).iter().collect::<Vec<_>>(), vec![&1, &2, &3]);\n+}\n+\n+#[test]\n+fn test_into_iterator_ref_mut() {\n+    assert_eq!(ThinVec::new().iter_mut().collect::<Vec<&mut String>>(), Vec::<&mut String>::new());\n+    assert_eq!(ThinVec::from(vec![1]).iter_mut().collect::<Vec<_>>(), vec![&mut 1]);\n+    assert_eq!(ThinVec::from(vec![1, 2]).iter_mut().collect::<Vec<_>>(), vec![&mut 1, &mut 2]);\n+    assert_eq!(\n+        ThinVec::from(vec![1, 2, 3]).iter_mut().collect::<Vec<_>>(),\n+        vec![&mut 1, &mut 2, &mut 3],\n+    );\n+}"}, {"sha": "10317f1afff673e3db6f0355fcc26591205c2dde", "filename": "compiler/rustc_data_structures/src/work_queue.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_data_structures%2Fsrc%2Fwork_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_data_structures%2Fsrc%2Fwork_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fwork_queue.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -41,10 +41,4 @@ impl<T: Idx> WorkQueue<T> {\n             None\n         }\n     }\n-\n-    /// Returns `true` if nothing is enqueued.\n-    #[inline]\n-    pub fn is_empty(&self) -> bool {\n-        self.deque.is_empty()\n-    }\n }"}, {"sha": "c9b36dd0c24ca9cd40c39a3bada9207640cc2c31", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 93, "deletions": 118, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -21,7 +21,6 @@ use rustc_data_structures::sync::SeqCst;\n use rustc_errors::registry::{InvalidErrorCode, Registry};\n use rustc_errors::{ErrorReported, PResult};\n use rustc_feature::find_gated_cfg;\n-use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_interface::util::{self, collect_crate_types, get_builtin_codegen_backend};\n use rustc_interface::{interface, Queries};\n use rustc_lint::LintStore;\n@@ -35,7 +34,7 @@ use rustc_session::config::{ErrorOutputType, Input, OutputType, PrintRequest, Tr\n use rustc_session::getopts;\n use rustc_session::lint::{Lint, LintId};\n use rustc_session::{config, DiagnosticOutput, Session};\n-use rustc_session::{early_error, early_warn};\n+use rustc_session::{early_error, early_error_no_abort, early_warn};\n use rustc_span::source_map::{FileLoader, FileName};\n use rustc_span::symbol::sym;\n \n@@ -133,6 +132,7 @@ pub fn diagnostics_registry() -> Registry {\n     Registry::new(&rustc_error_codes::DIAGNOSTICS)\n }\n \n+/// This is the primary entry point for rustc.\n pub struct RunCompiler<'a, 'b> {\n     at_args: &'a [String],\n     callbacks: &'b mut (dyn Callbacks + Send),\n@@ -146,6 +146,10 @@ impl<'a, 'b> RunCompiler<'a, 'b> {\n     pub fn new(at_args: &'a [String], callbacks: &'b mut (dyn Callbacks + Send)) -> Self {\n         Self { at_args, callbacks, file_loader: None, emitter: None, make_codegen_backend: None }\n     }\n+\n+    /// Set a custom codegen backend.\n+    ///\n+    /// Used by cg_clif.\n     pub fn set_make_codegen_backend(\n         &mut self,\n         make_codegen_backend: Option<\n@@ -155,17 +159,27 @@ impl<'a, 'b> RunCompiler<'a, 'b> {\n         self.make_codegen_backend = make_codegen_backend;\n         self\n     }\n+\n+    /// Emit diagnostics to the specified location.\n+    ///\n+    /// Used by RLS.\n     pub fn set_emitter(&mut self, emitter: Option<Box<dyn Write + Send>>) -> &mut Self {\n         self.emitter = emitter;\n         self\n     }\n+\n+    /// Load files from sources other than the file system.\n+    ///\n+    /// Used by RLS.\n     pub fn set_file_loader(\n         &mut self,\n         file_loader: Option<Box<dyn FileLoader + Send + Sync>>,\n     ) -> &mut Self {\n         self.file_loader = file_loader;\n         self\n     }\n+\n+    /// Parse args and run the compiler.\n     pub fn run(self) -> interface::Result<()> {\n         run_compiler(\n             self.at_args,\n@@ -176,8 +190,6 @@ impl<'a, 'b> RunCompiler<'a, 'b> {\n         )\n     }\n }\n-// Parse args and run the compiler. This is the primary entry point for rustc.\n-// The FileLoader provides a way to load files from sources other than the file system.\n fn run_compiler(\n     at_args: &[String],\n     callbacks: &mut (dyn Callbacks + Send),\n@@ -196,46 +208,43 @@ fn run_compiler(\n     };\n \n     let sopts = config::build_session_options(&matches);\n-    let cfg = interface::parse_cfgspecs(matches.opt_strs(\"cfg\"));\n-\n-    // We wrap `make_codegen_backend` in another `Option` such that `dummy_config` can take\n-    // ownership of it when necessary, while also allowing the non-dummy config to take ownership\n-    // when `dummy_config` is not used.\n-    let mut make_codegen_backend = Some(make_codegen_backend);\n-\n-    let mut dummy_config = |sopts, cfg, diagnostic_output| {\n-        let mut config = interface::Config {\n-            opts: sopts,\n-            crate_cfg: cfg,\n-            input: Input::File(PathBuf::new()),\n-            input_path: None,\n-            output_file: None,\n-            output_dir: None,\n-            file_loader: None,\n-            diagnostic_output,\n-            stderr: None,\n-            lint_caps: Default::default(),\n-            parse_sess_created: None,\n-            register_lints: None,\n-            override_queries: None,\n-            make_codegen_backend: make_codegen_backend.take().unwrap(),\n-            registry: diagnostics_registry(),\n-        };\n-        callbacks.config(&mut config);\n-        config\n-    };\n \n     if let Some(ref code) = matches.opt_str(\"explain\") {\n         handle_explain(diagnostics_registry(), code, sopts.error_format);\n         return Ok(());\n     }\n \n+    let cfg = interface::parse_cfgspecs(matches.opt_strs(\"cfg\"));\n     let (odir, ofile) = make_output(&matches);\n-    let (input, input_file_path, input_err) = match make_input(&matches.free) {\n-        Some(v) => v,\n-        None => match matches.free.len() {\n+    let mut config = interface::Config {\n+        opts: sopts,\n+        crate_cfg: cfg,\n+        input: Input::File(PathBuf::new()),\n+        input_path: None,\n+        output_file: ofile,\n+        output_dir: odir,\n+        file_loader,\n+        diagnostic_output,\n+        stderr: None,\n+        lint_caps: Default::default(),\n+        parse_sess_created: None,\n+        register_lints: None,\n+        override_queries: None,\n+        make_codegen_backend,\n+        registry: diagnostics_registry(),\n+    };\n+\n+    match make_input(config.opts.error_format, &matches.free) {\n+        Err(ErrorReported) => return Err(ErrorReported),\n+        Ok(Some((input, input_file_path))) => {\n+            config.input = input;\n+            config.input_path = input_file_path;\n+\n+            callbacks.config(&mut config);\n+        }\n+        Ok(None) => match matches.free.len() {\n             0 => {\n-                let config = dummy_config(sopts, cfg, diagnostic_output);\n+                callbacks.config(&mut config);\n                 interface::run_compiler(config, |compiler| {\n                     let sopts = &compiler.session().opts;\n                     if sopts.describe_lints {\n@@ -257,8 +266,8 @@ fn run_compiler(\n                         &***compiler.codegen_backend(),\n                         compiler.session(),\n                         None,\n-                        &odir,\n-                        &ofile,\n+                        &compiler.output_dir(),\n+                        &compiler.output_file(),\n                     );\n \n                     if should_stop == Compilation::Stop {\n@@ -270,7 +279,7 @@ fn run_compiler(\n             }\n             1 => panic!(\"make_input should have provided valid inputs\"),\n             _ => early_error(\n-                sopts.error_format,\n+                config.opts.error_format,\n                 &format!(\n                     \"multiple input filenames provided (first two filenames are `{}` and `{}`)\",\n                     matches.free[0], matches.free[1],\n@@ -279,35 +288,6 @@ fn run_compiler(\n         },\n     };\n \n-    if let Some(err) = input_err {\n-        // Immediately stop compilation if there was an issue reading\n-        // the input (for example if the input stream is not UTF-8).\n-        interface::run_compiler(dummy_config(sopts, cfg, diagnostic_output), |compiler| {\n-            compiler.session().err(&err.to_string());\n-        });\n-        return Err(ErrorReported);\n-    }\n-\n-    let mut config = interface::Config {\n-        opts: sopts,\n-        crate_cfg: cfg,\n-        input,\n-        input_path: input_file_path,\n-        output_file: ofile,\n-        output_dir: odir,\n-        file_loader,\n-        diagnostic_output,\n-        stderr: None,\n-        lint_caps: Default::default(),\n-        parse_sess_created: None,\n-        register_lints: None,\n-        override_queries: None,\n-        make_codegen_backend: make_codegen_backend.unwrap(),\n-        registry: diagnostics_registry(),\n-    };\n-\n-    callbacks.config(&mut config);\n-\n     interface::run_compiler(config, |compiler| {\n         let sess = compiler.session();\n         let should_stop = RustcDefaultCalls::print_crate_info(\n@@ -321,7 +301,6 @@ fn run_compiler(\n             RustcDefaultCalls::list_metadata(\n                 sess,\n                 &*compiler.codegen_backend().metadata_loader(),\n-                &matches,\n                 compiler.input(),\n             )\n         })\n@@ -408,11 +387,10 @@ fn run_compiler(\n                 return early_exit();\n             }\n \n-            if sess.opts.debugging_opts.save_analysis {\n-                let crate_name = queries.crate_name()?.peek().clone();\n-                queries.global_ctxt()?.peek_mut().enter(|tcx| {\n-                    let result = tcx.analysis(LOCAL_CRATE);\n-\n+            queries.global_ctxt()?.peek_mut().enter(|tcx| {\n+                let result = tcx.analysis(());\n+                if sess.opts.debugging_opts.save_analysis {\n+                    let crate_name = queries.crate_name()?.peek().clone();\n                     sess.time(\"save_analysis\", || {\n                         save::process_crate(\n                             tcx,\n@@ -425,12 +403,9 @@ fn run_compiler(\n                             ),\n                         )\n                     });\n-\n-                    result\n-                })?;\n-            }\n-\n-            queries.global_ctxt()?.peek_mut().enter(|tcx| tcx.analysis(LOCAL_CRATE))?;\n+                }\n+                result\n+            })?;\n \n             if callbacks.after_analysis(compiler, queries) == Compilation::Stop {\n                 return early_exit();\n@@ -487,19 +462,23 @@ fn make_output(matches: &getopts::Matches) -> (Option<PathBuf>, Option<PathBuf>)\n }\n \n // Extract input (string or file and optional path) from matches.\n-fn make_input(free_matches: &[String]) -> Option<(Input, Option<PathBuf>, Option<io::Error>)> {\n+fn make_input(\n+    error_format: ErrorOutputType,\n+    free_matches: &[String],\n+) -> Result<Option<(Input, Option<PathBuf>)>, ErrorReported> {\n     if free_matches.len() == 1 {\n         let ifile = &free_matches[0];\n         if ifile == \"-\" {\n             let mut src = String::new();\n-            let err = if io::stdin().read_to_string(&mut src).is_err() {\n-                Some(io::Error::new(\n-                    io::ErrorKind::InvalidData,\n+            if io::stdin().read_to_string(&mut src).is_err() {\n+                // Immediately stop compilation if there was an issue reading\n+                // the input (for example if the input stream is not UTF-8).\n+                early_error_no_abort(\n+                    error_format,\n                     \"couldn't read from stdin, as it did not contain valid UTF-8\",\n-                ))\n-            } else {\n-                None\n-            };\n+                );\n+                return Err(ErrorReported);\n+            }\n             if let Ok(path) = env::var(\"UNSTABLE_RUSTDOC_TEST_PATH\") {\n                 let line = env::var(\"UNSTABLE_RUSTDOC_TEST_LINE\").expect(\n                     \"when UNSTABLE_RUSTDOC_TEST_PATH is set \\\n@@ -508,14 +487,15 @@ fn make_input(free_matches: &[String]) -> Option<(Input, Option<PathBuf>, Option\n                 let line = isize::from_str_radix(&line, 10)\n                     .expect(\"UNSTABLE_RUSTDOC_TEST_LINE needs to be an number\");\n                 let file_name = FileName::doc_test_source_code(PathBuf::from(path), line);\n-                return Some((Input::Str { name: file_name, input: src }, None, err));\n+                Ok(Some((Input::Str { name: file_name, input: src }, None)))\n+            } else {\n+                Ok(Some((Input::Str { name: FileName::anon_source_code(&src), input: src }, None)))\n             }\n-            Some((Input::Str { name: FileName::anon_source_code(&src), input: src }, None, err))\n         } else {\n-            Some((Input::File(PathBuf::from(ifile)), Some(PathBuf::from(ifile)), None))\n+            Ok(Some((Input::File(PathBuf::from(ifile)), Some(PathBuf::from(ifile)))))\n         }\n     } else {\n-        None\n+        Ok(None)\n     }\n }\n \n@@ -616,28 +596,24 @@ fn show_content_with_pager(content: &str) {\n }\n \n impl RustcDefaultCalls {\n-    fn process_rlink(sess: &Session, compiler: &interface::Compiler) -> Result<(), ErrorReported> {\n-        if let Input::File(file) = compiler.input() {\n-            // FIXME: #![crate_type] and #![crate_name] support not implemented yet\n-            let attrs = vec![];\n-            sess.init_crate_types(collect_crate_types(sess, &attrs));\n-            let outputs = compiler.build_output_filenames(&sess, &attrs);\n-            let rlink_data = fs::read_to_string(file).unwrap_or_else(|err| {\n-                sess.fatal(&format!(\"failed to read rlink file: {}\", err));\n-            });\n-            let codegen_results: CodegenResults = json::decode(&rlink_data).unwrap_or_else(|err| {\n-                sess.fatal(&format!(\"failed to decode rlink: {}\", err));\n-            });\n-            compiler.codegen_backend().link(&sess, codegen_results, &outputs)\n-        } else {\n-            sess.fatal(\"rlink must be a file\")\n-        }\n-    }\n-\n     pub fn try_process_rlink(sess: &Session, compiler: &interface::Compiler) -> Compilation {\n         if sess.opts.debugging_opts.link_only {\n-            let result = RustcDefaultCalls::process_rlink(sess, compiler);\n-            abort_on_err(result, sess);\n+            if let Input::File(file) = compiler.input() {\n+                // FIXME: #![crate_type] and #![crate_name] support not implemented yet\n+                sess.init_crate_types(collect_crate_types(sess, &[]));\n+                let outputs = compiler.build_output_filenames(&sess, &[]);\n+                let rlink_data = fs::read_to_string(file).unwrap_or_else(|err| {\n+                    sess.fatal(&format!(\"failed to read rlink file: {}\", err));\n+                });\n+                let codegen_results: CodegenResults =\n+                    json::decode(&rlink_data).unwrap_or_else(|err| {\n+                        sess.fatal(&format!(\"failed to decode rlink: {}\", err));\n+                    });\n+                let result = compiler.codegen_backend().link(&sess, codegen_results, &outputs);\n+                abort_on_err(result, sess);\n+            } else {\n+                sess.fatal(\"rlink must be a file\")\n+            }\n             Compilation::Stop\n         } else {\n             Compilation::Continue\n@@ -647,11 +623,9 @@ impl RustcDefaultCalls {\n     pub fn list_metadata(\n         sess: &Session,\n         metadata_loader: &dyn MetadataLoader,\n-        matches: &getopts::Matches,\n         input: &Input,\n     ) -> Compilation {\n-        let r = matches.opt_strs(\"Z\");\n-        if r.iter().any(|s| *s == \"ls\") {\n+        if sess.opts.debugging_opts.ls {\n             match *input {\n                 Input::File(ref ifile) => {\n                     let path = &(*ifile);\n@@ -792,7 +766,7 @@ pub fn version(binary: &str, matches: &getopts::Matches) {\n         println!(\"host: {}\", config::host_triple());\n         println!(\"release: {}\", unw(util::release_str()));\n         if cfg!(feature = \"llvm\") {\n-            get_builtin_codegen_backend(\"llvm\")().print_version();\n+            get_builtin_codegen_backend(&None, \"llvm\")().print_version();\n         }\n     }\n }\n@@ -842,7 +816,8 @@ the command line flag directly.\n     );\n }\n \n-fn describe_lints(sess: &Session, lint_store: &LintStore, loaded_plugins: bool) {\n+/// Write to stdout lint command options, together with a list of all available lints\n+pub fn describe_lints(sess: &Session, lint_store: &LintStore, loaded_plugins: bool) {\n     println!(\n         \"\n Available lint options:\n@@ -1086,7 +1061,7 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n \n     if cg_flags.iter().any(|x| *x == \"passes=list\") {\n         if cfg!(feature = \"llvm\") {\n-            get_builtin_codegen_backend(\"llvm\")().print_passes();\n+            get_builtin_codegen_backend(&None, \"llvm\")().print_passes();\n         }\n         return None;\n     }"}, {"sha": "a2b4f3fcf734a713756ccfabe4800e3632abd567", "filename": "compiler/rustc_driver/src/pretty.rs", "status": "modified", "additions": 4, "deletions": 28, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -4,19 +4,16 @@ use rustc_ast as ast;\n use rustc_ast_pretty::pprust;\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n-use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_hir_pretty as pprust_hir;\n use rustc_middle::hir::map as hir_map;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_mir::util::{write_mir_graphviz, write_mir_pretty};\n-use rustc_mir_build::thir;\n use rustc_session::config::{Input, PpAstTreeMode, PpHirMode, PpMode, PpSourceMode};\n use rustc_session::Session;\n use rustc_span::symbol::Ident;\n use rustc_span::FileName;\n \n use std::cell::Cell;\n-use std::fmt::Write;\n use std::path::Path;\n \n pub use self::PpMode::*;\n@@ -74,7 +71,7 @@ where\n             f(&annotation, tcx.hir().krate())\n         }\n         PpHirMode::Typed => {\n-            abort_on_err(tcx.analysis(LOCAL_CRATE), tcx.sess);\n+            abort_on_err(tcx.analysis(()), tcx.sess);\n \n             let annotation = TypedAnnotation { tcx, maybe_typeck_results: Cell::new(None) };\n             tcx.dep_graph.with_ignore(|| f(&annotation, tcx.hir().krate()))\n@@ -108,13 +105,6 @@ trait HirPrinterSupport<'hir>: pprust_hir::PpAnn {\n     /// (Rust does not yet support upcasting from a trait object to\n     /// an object for one of its super-traits.)\n     fn pp_ann(&self) -> &dyn pprust_hir::PpAnn;\n-\n-    /// Computes an user-readable representation of a path, if possible.\n-    fn node_path(&self, id: hir::HirId) -> Option<String> {\n-        self.hir_map().and_then(|map| map.def_path_from_hir_id(id)).map(|path| {\n-            path.data.into_iter().map(|elem| elem.data.to_string()).collect::<Vec<_>>().join(\"::\")\n-        })\n-    }\n }\n \n struct NoAnn<'hir> {\n@@ -327,10 +317,6 @@ impl<'tcx> HirPrinterSupport<'tcx> for TypedAnnotation<'tcx> {\n     fn pp_ann(&self) -> &dyn pprust_hir::PpAnn {\n         self\n     }\n-\n-    fn node_path(&self, id: hir::HirId) -> Option<String> {\n-        Some(self.tcx.def_path_str(self.tcx.hir().local_def_id(id).to_def_id()))\n-    }\n }\n \n impl<'tcx> pprust_hir::PpAnn for TypedAnnotation<'tcx> {\n@@ -486,7 +472,7 @@ fn print_with_analysis(\n     ppm: PpMode,\n     ofile: Option<&Path>,\n ) -> Result<(), ErrorReported> {\n-    tcx.analysis(LOCAL_CRATE)?;\n+    tcx.analysis(())?;\n \n     let out = match ppm {\n         Mir => {\n@@ -502,18 +488,8 @@ fn print_with_analysis(\n         }\n \n         ThirTree => {\n-            let mut out = String::new();\n-            abort_on_err(rustc_typeck::check_crate(tcx), tcx.sess);\n-            debug!(\"pretty printing THIR tree\");\n-            for did in tcx.body_owners() {\n-                let hir = tcx.hir();\n-                let body = hir.body(hir.body_owned_by(hir.local_def_id_to_hir_id(did)));\n-                let arena = thir::Arena::default();\n-                let thir =\n-                    thir::build_thir(tcx, ty::WithOptConstParam::unknown(did), &arena, &body.value);\n-                let _ = writeln!(out, \"{:?}:\\n{:#?}\\n\", did, thir);\n-            }\n-            out\n+            // FIXME(rust-lang/project-thir-unsafeck#8)\n+            todo!()\n         }\n \n         _ => unreachable!(),"}, {"sha": "c343809179b0a2d1f17851875cdcf1f5a4cfce28", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -416,7 +416,6 @@ E0716: include_str!(\"./error_codes/E0716.md\"),\n E0718: include_str!(\"./error_codes/E0718.md\"),\n E0719: include_str!(\"./error_codes/E0719.md\"),\n E0720: include_str!(\"./error_codes/E0720.md\"),\n-E0723: include_str!(\"./error_codes/E0723.md\"),\n E0724: include_str!(\"./error_codes/E0724.md\"),\n E0725: include_str!(\"./error_codes/E0725.md\"),\n E0727: include_str!(\"./error_codes/E0727.md\"),\n@@ -471,6 +470,8 @@ E0778: include_str!(\"./error_codes/E0778.md\"),\n E0779: include_str!(\"./error_codes/E0779.md\"),\n E0780: include_str!(\"./error_codes/E0780.md\"),\n E0781: include_str!(\"./error_codes/E0781.md\"),\n+E0782: include_str!(\"./error_codes/E0782.md\"),\n+E0783: include_str!(\"./error_codes/E0783.md\"),\n ;\n //  E0006, // merged with E0005\n //  E0008, // cannot bind by-move into a pattern guard\n@@ -636,6 +637,7 @@ E0781: include_str!(\"./error_codes/E0781.md\"),\n     E0717, // rustc_promotable without stability attribute\n //  E0721, // `await` keyword\n     E0722, // Malformed `#[optimize]` attribute\n+//    E0723, unstable feature in `const` context\n     E0726, // non-explicit (not `'_`) elided lifetime in unsupported position\n //  E0738, // Removed; errored on `#[track_caller] fn`s in `extern \"Rust\" { ... }`.\n     E0757, // `#[ffi_const]` functions cannot be `#[ffi_pure]`"}, {"sha": "15cf09a18cbdeec42f8edf9d65cd38c3ea4f7701", "filename": "compiler/rustc_error_codes/src/error_codes/E0136.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0136.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0136.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0136.md?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -1,8 +1,10 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n More than one `main` function was found.\n \n Erroneous code example:\n \n-```compile_fail,E0136\n+```compile_fail\n fn main() {\n     // ...\n }"}, {"sha": "d4e19170f3f7b5ce699a9f2f8e2bcc4a3f543563", "filename": "compiler/rustc_error_codes/src/error_codes/E0137.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0137.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0137.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0137.md?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -1,8 +1,10 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n More than one function was declared with the `#[main]` attribute.\n \n Erroneous code example:\n \n-```compile_fail,E0137\n+```compile_fail\n #![feature(main)]\n \n #[main]\n@@ -16,7 +18,7 @@ This error indicates that the compiler found multiple functions with the\n `#[main]` attribute. This is an error because there must be a unique entry\n point into a Rust program. Example:\n \n-```\n+```compile_fail\n #![feature(main)]\n \n #[main]"}, {"sha": "5f05b59d5a6d4fd3389bf2e9b3ce91b198384c28", "filename": "compiler/rustc_error_codes/src/error_codes/E0277.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0277.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0277.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0277.md?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -29,16 +29,16 @@ trait Foo {\n     fn bar(&self);\n }\n \n-fn some_func<T: Foo>(foo: T) {\n-    foo.bar(); // we can now use this method since i32 implements the\n-               // Foo trait\n-}\n-\n // we implement the trait on the i32 type\n impl Foo for i32 {\n     fn bar(&self) {}\n }\n \n+fn some_func<T: Foo>(foo: T) {\n+    foo.bar(); // we can now use this method since i32 implements the\n+               // Foo trait\n+}\n+\n fn main() {\n     some_func(5i32); // ok!\n }"}, {"sha": "ab438e41447125634365e46ab03a5e2d8e7bbf8a", "filename": "compiler/rustc_error_codes/src/error_codes/E0379.md", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0379.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0379.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0379.md?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -3,8 +3,6 @@ A trait method was declared const.\n Erroneous code example:\n \n ```compile_fail,E0379\n-#![feature(const_fn)]\n-\n trait Foo {\n     const fn bar() -> u32; // error!\n }"}, {"sha": "d6fa51e618c4c121b502aeaeaf919fad8aff8f8d", "filename": "compiler/rustc_error_codes/src/error_codes/E0404.md", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0404.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0404.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0404.md?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -8,14 +8,15 @@ struct Foo;\n struct Bar;\n \n impl Foo for Bar {} // error: `Foo` is not a trait\n+fn baz<T: Foo>(t: T) {} // error: `Foo` is not a trait\n ```\n \n Another erroneous code example:\n \n ```compile_fail,E0404\n-struct Foo;\n+type Foo = Iterator<Item=String>;\n \n-fn bar<T: Foo>(t: T) {} // error: `Foo` is not a trait\n+fn bar<T: Foo>(t: T) {} // error: `Foo` is a type alias\n ```\n \n Please verify that the trait's name was not misspelled or that the right\n@@ -30,14 +31,27 @@ struct Bar;\n impl Foo for Bar { // ok!\n     // functions implementation\n }\n+\n+fn baz<T: Foo>(t: T) {} // ok!\n ```\n \n-or:\n+Alternatively, you could introduce a new trait with your desired restrictions\n+as a super trait:\n \n ```\n-trait Foo {\n-    // some functions\n-}\n+# trait Foo {}\n+# struct Bar;\n+# impl Foo for Bar {}\n+trait Qux: Foo {} // Anything that implements Qux also needs to implement Foo\n+fn baz<T: Qux>(t: T) {} // also ok!\n+```\n+\n+Finally, if you are on nightly and want to use a trait alias\n+instead of a type alias, you should use `#![feature(trait_alias)]`:\n+\n+```\n+#![feature(trait_alias)]\n+trait Foo = Iterator<Item=String>;\n \n fn bar<T: Foo>(t: T) {} // ok!\n ```"}, {"sha": "3178bf21919e855e029d920c1c87056bc7b7d179", "filename": "compiler/rustc_error_codes/src/error_codes/E0554.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0554.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0554.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0554.md?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -4,8 +4,8 @@ beta compilers will not comply.\n Erroneous code example:\n \n ```ignore (depends on release channel)\n-#![feature(non_ascii_idents)] // error: `#![feature]` may not be used on the\n-                              //        stable release channel\n+#![feature(lang_items)] // error: `#![feature]` may not be used on the\n+                        //        stable release channel\n ```\n \n If you need the feature, make sure to use a nightly release of the compiler"}, {"sha": "bc2244219156cae0f4c725b39a23f21d93448365", "filename": "compiler/rustc_error_codes/src/error_codes/E0723.md", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3b2b5b2914d40aa011d189bfe546084cdee53dbe/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0723.md", "raw_url": "https://github.com/rust-lang/rust/raw/3b2b5b2914d40aa011d189bfe546084cdee53dbe/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0723.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0723.md?ref=3b2b5b2914d40aa011d189bfe546084cdee53dbe", "patch": "@@ -1,20 +0,0 @@\n-An unstable feature in `const` contexts was used.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0723\n-const fn foo<T: Copy>(_: T) { // error!\n-   // ...\n-}\n-```\n-\n-To enable this feature on a nightly version of rustc, add the `const_fn`\n-feature flag:\n-\n-```\n-#![feature(const_fn)]\n-\n-const fn foo<T: Copy>(_: T) { // ok!\n-   // ...\n-}\n-```"}, {"sha": "acddb69aaba56cd8d62571c1c29881afa52b43e0", "filename": "compiler/rustc_error_codes/src/error_codes/E0754.md", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0754.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0754.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0754.md?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -3,7 +3,6 @@ A non-ASCII identifier was used in an invalid context.\n Erroneous code examples:\n \n ```compile_fail,E0754\n-# #![feature(non_ascii_idents)]\n \n mod \u0159\u0173\u015b\u0165; // error!\n \n@@ -17,8 +16,6 @@ Non-ASCII can be used as module names if it is inlined or if a `#[path]`\n attribute is specified. For example:\n \n ```\n-# #![feature(non_ascii_idents)]\n-\n mod \u0159\u0173\u015b\u0165 { // ok!\n     const IS_GREAT: bool = true;\n }"}, {"sha": "152627cf6545f5efb4b12f02dea2d4d4c4394371", "filename": "compiler/rustc_error_codes/src/error_codes/E0764.md", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0764.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0764.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0764.md?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -3,7 +3,6 @@ A mutable reference was used in a constant.\n Erroneous code example:\n \n ```compile_fail,E0764\n-#![feature(const_fn)]\n #![feature(const_mut_refs)]\n \n fn main() {\n@@ -27,7 +26,6 @@ Remember: you cannot use a function call inside a constant or static. However,\n you can totally use it in constant functions:\n \n ```\n-#![feature(const_fn)]\n #![feature(const_mut_refs)]\n \n const fn foo(x: usize) -> usize {"}, {"sha": "0f3253c050e2b3a1b0ebd9fae03aff8676bdab93", "filename": "compiler/rustc_error_codes/src/error_codes/E0782.md", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0782.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0782.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0782.md?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -0,0 +1,26 @@\n+Trait objects must include the `dyn` keyword.\n+\n+Erroneous code example:\n+\n+```edition2021,compile_fail,E0782\n+trait Foo {}\n+fn test(arg: Box<Foo>) {} // error!\n+```\n+\n+Trait objects are a way to call methods on types that are not known until\n+runtime but conform to some trait.\n+\n+Trait objects should be formed with `Box<dyn Foo>`, but in the code above\n+`dyn` is left off.\n+\n+This makes it harder to see that `arg` is a trait object and not a\n+simply a heap allocated type called `Foo`.\n+\n+To fix this issue, add `dyn` before the trait name.\n+\n+```edition2021\n+trait Foo {}\n+fn test(arg: Box<dyn Foo>) {} // ok!\n+```\n+\n+This used to be allowed before edition 2021, but is now an error."}, {"sha": "73981e59e0d95e7bb85f21060b7d5396cdd176d5", "filename": "compiler/rustc_error_codes/src/error_codes/E0783.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0783.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0783.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0783.md?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -0,0 +1,22 @@\n+The range pattern `...` is no longer allowed.\n+\n+Erroneous code example:\n+\n+```edition2021,compile_fail,E0783\n+match 2u8 {\n+    0...9 => println!(\"Got a number less than 10\"), // error!\n+    _ => println!(\"Got a number 10 or more\"),\n+}\n+```\n+\n+Older Rust code using previous editions allowed `...` to stand for exclusive\n+ranges which are now signified using `..=`.\n+\n+To make this code compile replace the `...` with `..=`.\n+\n+```edition2021\n+match 2u8 {\n+    0..=9 => println!(\"Got a number less than 10\"), // ok!\n+    _ => println!(\"Got a number 10 or more\"),\n+}\n+```"}, {"sha": "f2432f61653530d35b95e8f36c97b23b6ed52b9b", "filename": "compiler/rustc_error_codes/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_error_codes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_error_codes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Flib.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -1,5 +1,4 @@\n-#![cfg_attr(bootstrap, deny(invalid_codeblock_attributes))]\n-#![cfg_attr(not(bootstrap), deny(rustdoc::invalid_codeblock_attributes))]\n+#![deny(rustdoc::invalid_codeblock_attributes)]\n //! This library is used to gather all error codes into one place,\n //! the goal being to make their maintenance easier.\n "}, {"sha": "577baec21f064f232d96a83914619cdac7ce4004", "filename": "compiler/rustc_errors/src/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -126,7 +126,8 @@ impl AnnotateSnippetEmitterWriter {\n             }\n             // owned: line source, line index, annotations\n             type Owned = (String, usize, Vec<crate::snippet::Annotation>);\n-            let origin = primary_lo.file.name.to_string();\n+            let filename = primary_lo.file.name.prefer_local();\n+            let origin = filename.to_string_lossy();\n             let annotated_files: Vec<Owned> = annotated_files\n                 .into_iter()\n                 .flat_map(|annotated_file| {"}, {"sha": "14ccced2c6a56678fd4e6f4ac2d5d34555a57c52", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 27, "deletions": 51, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -69,10 +69,6 @@ impl DiagnosticStyledString {\n     pub fn highlighted<S: Into<String>>(t: S) -> DiagnosticStyledString {\n         DiagnosticStyledString(vec![StringPart::Highlighted(t.into())])\n     }\n-\n-    pub fn content(&self) -> String {\n-        self.0.iter().map(|x| x.content()).collect::<String>()\n-    }\n }\n \n #[derive(Debug, PartialEq, Eq)]\n@@ -81,14 +77,6 @@ pub enum StringPart {\n     Highlighted(String),\n }\n \n-impl StringPart {\n-    pub fn content(&self) -> &str {\n-        match self {\n-            &StringPart::Normal(ref s) | &StringPart::Highlighted(ref s) => s,\n-        }\n-    }\n-}\n-\n impl Diagnostic {\n     pub fn new(level: Level, message: &str) -> Self {\n         Diagnostic::new_with_code(level, None, message)\n@@ -156,7 +144,7 @@ impl Diagnostic {\n         self\n     }\n \n-    pub fn note_expected_found(\n+    crate fn note_expected_found(\n         &mut self,\n         expected_label: &dyn fmt::Display,\n         expected: DiagnosticStyledString,\n@@ -166,7 +154,7 @@ impl Diagnostic {\n         self.note_expected_found_extra(expected_label, expected, found_label, found, &\"\", &\"\")\n     }\n \n-    pub fn note_unsuccessful_coercion(\n+    crate fn note_unsuccessful_coercion(\n         &mut self,\n         expected: DiagnosticStyledString,\n         found: DiagnosticStyledString,\n@@ -256,33 +244,33 @@ impl Diagnostic {\n \n     /// Prints the span with a note above it.\n     /// This is like [`Diagnostic::note()`], but it gets its own span.\n-    pub fn span_note<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n+    crate fn span_note<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n         self.sub(Level::Note, msg, sp.into(), None);\n         self\n     }\n \n     /// Add a warning attached to this diagnostic.\n-    pub fn warn(&mut self, msg: &str) -> &mut Self {\n+    crate fn warn(&mut self, msg: &str) -> &mut Self {\n         self.sub(Level::Warning, msg, MultiSpan::new(), None);\n         self\n     }\n \n     /// Prints the span with a warning above it.\n     /// This is like [`Diagnostic::warn()`], but it gets its own span.\n-    pub fn span_warn<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n+    crate fn span_warn<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n         self.sub(Level::Warning, msg, sp.into(), None);\n         self\n     }\n \n     /// Add a help message attached to this diagnostic.\n-    pub fn help(&mut self, msg: &str) -> &mut Self {\n+    crate fn help(&mut self, msg: &str) -> &mut Self {\n         self.sub(Level::Help, msg, MultiSpan::new(), None);\n         self\n     }\n \n     /// Prints the span with some help above it.\n     /// This is like [`Diagnostic::help()`], but it gets its own span.\n-    pub fn span_help<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n+    crate fn span_help<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n         self.sub(Level::Help, msg, sp.into(), None);\n         self\n     }\n@@ -295,46 +283,32 @@ impl Diagnostic {\n         suggestion: Vec<(Span, String)>,\n         applicability: Applicability,\n     ) -> &mut Self {\n-        assert!(!suggestion.is_empty());\n-        self.suggestions.push(CodeSuggestion {\n-            substitutions: vec![Substitution {\n-                parts: suggestion\n-                    .into_iter()\n-                    .map(|(span, snippet)| SubstitutionPart { snippet, span })\n-                    .collect(),\n-            }],\n-            msg: msg.to_owned(),\n-            style: SuggestionStyle::ShowCode,\n+        self.multipart_suggestion_with_style(\n+            msg,\n+            suggestion,\n             applicability,\n-            tool_metadata: Default::default(),\n-        });\n-        self\n+            SuggestionStyle::ShowCode,\n+        )\n     }\n \n-    /// Show multiple suggestions that have multiple parts.\n-    /// See also [`Diagnostic::multipart_suggestion()`].\n-    pub fn multipart_suggestions(\n+    /// [`Diagnostic::multipart_suggestion()`] but you can set the [`SuggestionStyle`].\n+    pub fn multipart_suggestion_with_style(\n         &mut self,\n         msg: &str,\n-        suggestions: Vec<Vec<(Span, String)>>,\n+        suggestion: Vec<(Span, String)>,\n         applicability: Applicability,\n+        style: SuggestionStyle,\n     ) -> &mut Self {\n-        assert!(!suggestions.is_empty());\n-        for s in &suggestions {\n-            assert!(!s.is_empty());\n-        }\n+        assert!(!suggestion.is_empty());\n         self.suggestions.push(CodeSuggestion {\n-            substitutions: suggestions\n-                .into_iter()\n-                .map(|suggestion| Substitution {\n-                    parts: suggestion\n-                        .into_iter()\n-                        .map(|(span, snippet)| SubstitutionPart { snippet, span })\n-                        .collect(),\n-                })\n-                .collect(),\n+            substitutions: vec![Substitution {\n+                parts: suggestion\n+                    .into_iter()\n+                    .map(|(span, snippet)| SubstitutionPart { snippet, span })\n+                    .collect(),\n+            }],\n             msg: msg.to_owned(),\n-            style: SuggestionStyle::ShowCode,\n+            style,\n             applicability,\n             tool_metadata: Default::default(),\n         });\n@@ -567,7 +541,7 @@ impl Diagnostic {\n         self.code.clone()\n     }\n \n-    pub fn set_primary_message<M: Into<String>>(&mut self, msg: M) -> &mut Self {\n+    crate fn set_primary_message<M: Into<String>>(&mut self, msg: M) -> &mut Self {\n         self.message[0] = (msg.into(), Style::NoStyle);\n         self\n     }\n@@ -582,6 +556,8 @@ impl Diagnostic {\n \n     /// Convenience function for internal use, clients should use one of the\n     /// public methods above.\n+    ///\n+    /// Used by `proc_macro_server` for implementing `server::Diagnostic`.\n     pub fn sub(\n         &mut self,\n         level: Level,"}, {"sha": "282877d5dd10962f9c7be3e66e0e96189d9529fc", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -157,19 +157,6 @@ impl<'a> DiagnosticBuilder<'a> {\n         buffered_diagnostics.extend(self.into_diagnostic().map(|(diag, _)| diag));\n     }\n \n-    /// Convenience function for internal use, clients should use one of the\n-    /// span_* methods instead.\n-    pub fn sub<S: Into<MultiSpan>>(\n-        &mut self,\n-        level: Level,\n-        message: &str,\n-        span: Option<S>,\n-    ) -> &mut Self {\n-        let span = span.map(|s| s.into()).unwrap_or_else(MultiSpan::new);\n-        self.0.diagnostic.sub(level, message, span, None);\n-        self\n-    }\n-\n     /// Delay emission of this diagnostic as a bug.\n     ///\n     /// This can be useful in contexts where an error indicates a bug but\n@@ -270,20 +257,6 @@ impl<'a> DiagnosticBuilder<'a> {\n         self\n     }\n \n-    /// See [`Diagnostic::multipart_suggestions()`].\n-    pub fn multipart_suggestions(\n-        &mut self,\n-        msg: &str,\n-        suggestions: Vec<Vec<(Span, String)>>,\n-        applicability: Applicability,\n-    ) -> &mut Self {\n-        if !self.0.allow_suggestions {\n-            return self;\n-        }\n-        self.0.diagnostic.multipart_suggestions(msg, suggestions, applicability);\n-        self\n-    }\n-\n     /// See [`Diagnostic::tool_only_multipart_suggestion()`].\n     pub fn tool_only_multipart_suggestion(\n         &mut self,"}, {"sha": "d3f92bf3047b06a5db22f290b400c1753103e59b", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 30, "deletions": 13, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -195,6 +195,9 @@ pub trait Emitter {\n \n     fn emit_future_breakage_report(&mut self, _diags: Vec<(FutureBreakage, Diagnostic)>) {}\n \n+    /// Emit list of unused externs\n+    fn emit_unused_externs(&mut self, _lint_level: &str, _unused_externs: &[&str]) {}\n+\n     /// Checks if should show explanations about \"rustc --explain\"\n     fn should_show_explain(&self) -> bool {\n         true\n@@ -306,7 +309,9 @@ pub trait Emitter {\n                     // are some which do actually involve macros.\n                     ExpnKind::Inlined | ExpnKind::Desugaring(..) | ExpnKind::AstPass(..) => None,\n \n-                    ExpnKind::Macro(macro_kind, _) => Some(macro_kind),\n+                    ExpnKind::Macro { kind: macro_kind, name, proc_macro: _ } => {\n+                        Some((macro_kind, name))\n+                    }\n                 }\n             });\n \n@@ -317,13 +322,12 @@ pub trait Emitter {\n         self.render_multispans_macro_backtrace(span, children, backtrace);\n \n         if !backtrace {\n-            if let Some(macro_kind) = has_macro_spans {\n+            if let Some((macro_kind, name)) = has_macro_spans {\n+                let descr = macro_kind.descr();\n+\n                 let msg = format!(\n-                    \"this {} originates in {} {} \\\n+                    \"this {level} originates in the {descr} `{name}` \\\n                     (in Nightly builds, run with -Z macro-backtrace for more info)\",\n-                    level,\n-                    macro_kind.article(),\n-                    macro_kind.descr(),\n                 );\n \n                 children.push(SubDiagnostic {\n@@ -368,10 +372,19 @@ pub trait Emitter {\n                     new_labels\n                         .push((trace.call_site, \"in the inlined copy of this code\".to_string()));\n                 } else if always_backtrace {\n+                    let proc_macro = if let ExpnKind::Macro { kind: _, name: _, proc_macro: true } =\n+                        trace.kind\n+                    {\n+                        \"procedural macro \"\n+                    } else {\n+                        \"\"\n+                    };\n+\n                     new_labels.push((\n                         trace.def_site,\n                         format!(\n-                            \"in this expansion of `{}`{}\",\n+                            \"in this expansion of {}`{}`{}\",\n+                            proc_macro,\n                             trace.kind.descr(),\n                             if macro_backtrace.len() > 1 {\n                                 // if macro_backtrace.len() == 1 it'll be\n@@ -397,7 +410,11 @@ pub trait Emitter {\n                 // and it needs an \"in this macro invocation\" label to match that.\n                 let redundant_span = trace.call_site.contains(sp);\n \n-                if !redundant_span && matches!(trace.kind, ExpnKind::Macro(MacroKind::Bang, _))\n+                if !redundant_span\n+                    && matches!(\n+                        trace.kind,\n+                        ExpnKind::Macro { kind: MacroKind::Bang, name: _, proc_macro: _ }\n+                    )\n                     || always_backtrace\n                 {\n                     new_labels.push((\n@@ -1258,7 +1275,7 @@ impl EmitterWriter {\n                 buffer.append(0, \": \", header_style);\n             }\n             for &(ref text, _) in msg.iter() {\n-                buffer.append(0, text, header_style);\n+                buffer.append(0, &replace_tabs(text), header_style);\n             }\n         }\n \n@@ -1306,7 +1323,7 @@ impl EmitterWriter {\n                         buffer_msg_line_offset,\n                         &format!(\n                             \"{}:{}:{}\",\n-                            loc.file.name,\n+                            loc.file.name.prefer_local(),\n                             sm.doctest_offset_line(&loc.file.name, loc.line),\n                             loc.col.0 + 1,\n                         ),\n@@ -1320,7 +1337,7 @@ impl EmitterWriter {\n                         0,\n                         &format!(\n                             \"{}:{}:{}: \",\n-                            loc.file.name,\n+                            loc.file.name.prefer_local(),\n                             sm.doctest_offset_line(&loc.file.name, loc.line),\n                             loc.col.0 + 1,\n                         ),\n@@ -1344,12 +1361,12 @@ impl EmitterWriter {\n                     };\n                     format!(\n                         \"{}:{}{}\",\n-                        annotated_file.file.name,\n+                        annotated_file.file.name.prefer_local(),\n                         sm.doctest_offset_line(&annotated_file.file.name, first_line.line_index),\n                         col\n                     )\n                 } else {\n-                    annotated_file.file.name.to_string()\n+                    format!(\"{}\", annotated_file.file.name.prefer_local())\n                 };\n                 buffer.append(buffer_msg_line_offset + 1, &loc, Style::LineAndColumn);\n                 for _ in 0..max_line_num_len {"}, {"sha": "5d175a3ade9a2438671595d829616d563c3d4499", "filename": "compiler/rustc_errors/src/json.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -159,6 +159,19 @@ impl Emitter for JsonEmitter {\n         }\n     }\n \n+    fn emit_unused_externs(&mut self, lint_level: &str, unused_externs: &[&str]) {\n+        let data = UnusedExterns { lint_level, unused_extern_names: unused_externs };\n+        let result = if self.pretty {\n+            writeln!(&mut self.dst, \"{}\", as_pretty_json(&data))\n+        } else {\n+            writeln!(&mut self.dst, \"{}\", as_json(&data))\n+        }\n+        .and_then(|_| self.dst.flush());\n+        if let Err(e) = result {\n+            panic!(\"failed to print unused externs: {:?}\", e);\n+        }\n+    }\n+\n     fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n         Some(&self.sm)\n     }\n@@ -322,6 +335,18 @@ struct FutureIncompatReport {\n     future_incompat_report: Vec<FutureBreakageItem>,\n }\n \n+// NOTE: Keep this in sync with the equivalent structs in rustdoc's\n+// doctest component (as well as cargo).\n+// We could unify this struct the one in rustdoc but they have different\n+// ownership semantics, so doing so would create wasteful allocations.\n+#[derive(Encodable)]\n+struct UnusedExterns<'a, 'b, 'c> {\n+    /// The severity level of the unused dependencies lint\n+    lint_level: &'a str,\n+    /// List of unused externs by their names.\n+    unused_extern_names: &'b [&'c str],\n+}\n+\n impl Diagnostic {\n     fn from_errors_diagnostic(diag: &crate::Diagnostic, je: &JsonEmitter) -> Diagnostic {\n         let sugg = diag.suggestions.iter().map(|sugg| Diagnostic {\n@@ -443,7 +468,7 @@ impl DiagnosticSpan {\n         });\n \n         DiagnosticSpan {\n-            file_name: start.file.name.to_string(),\n+            file_name: start.file.name.prefer_local().to_string(),\n             byte_start: start.file.original_relative_byte_pos(span.lo()).0,\n             byte_end: start.file.original_relative_byte_pos(span.hi()).0,\n             line_start: start.line,"}, {"sha": "65352f0bc6e7b9f6c9e09a4dc23686779c8ed0f4", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 38, "deletions": 15, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -5,7 +5,8 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(crate_visibility_modifier)]\n #![feature(backtrace)]\n-#![feature(extended_key_value_attributes)]\n+#![cfg_attr(bootstrap, feature(extended_key_value_attributes))]\n+#![feature(format_args_capture)]\n #![feature(iter_zip)]\n #![feature(nll)]\n \n@@ -294,6 +295,7 @@ impl error::Error for ExplicitBug {}\n \n pub use diagnostic::{Diagnostic, DiagnosticId, DiagnosticStyledString, SubDiagnostic};\n pub use diagnostic_builder::DiagnosticBuilder;\n+use std::backtrace::Backtrace;\n \n /// A handler deals with errors and other compiler output.\n /// Certain errors (fatal, bug, unimpl) may cause immediate exit,\n@@ -317,11 +319,11 @@ struct HandlerInner {\n     deduplicated_err_count: usize,\n     emitter: Box<dyn Emitter + sync::Send>,\n     delayed_span_bugs: Vec<Diagnostic>,\n-    delayed_good_path_bugs: Vec<Diagnostic>,\n+    delayed_good_path_bugs: Vec<DelayedDiagnostic>,\n \n     /// This set contains the `DiagnosticId` of all emitted diagnostics to avoid\n     /// emitting the same diagnostic with extended help (`--teach`) twice, which\n-    /// would be uneccessary repetition.\n+    /// would be unnecessary repetition.\n     taught_diagnostics: FxHashSet<DiagnosticId>,\n \n     /// Used to suggest rustc --explain <error code>\n@@ -388,7 +390,7 @@ impl Drop for HandlerInner {\n         if !self.has_any_message() {\n             let bugs = std::mem::replace(&mut self.delayed_good_path_bugs, Vec::new());\n             self.flush_delayed(\n-                bugs,\n+                bugs.into_iter().map(DelayedDiagnostic::decorate).collect(),\n                 \"no warnings or errors encountered even though `delayed_good_path_bugs` issued\",\n             );\n         }\n@@ -633,19 +635,19 @@ impl Handler {\n         DiagnosticBuilder::new(self, Level::Note, msg)\n     }\n \n-    pub fn span_fatal(&self, span: impl Into<MultiSpan>, msg: &str) -> FatalError {\n+    pub fn span_fatal(&self, span: impl Into<MultiSpan>, msg: &str) -> ! {\n         self.emit_diag_at_span(Diagnostic::new(Fatal, msg), span);\n-        FatalError\n+        FatalError.raise()\n     }\n \n     pub fn span_fatal_with_code(\n         &self,\n         span: impl Into<MultiSpan>,\n         msg: &str,\n         code: DiagnosticId,\n-    ) -> FatalError {\n+    ) -> ! {\n         self.emit_diag_at_span(Diagnostic::new_with_code(Fatal, Some(code), msg), span);\n-        FatalError\n+        FatalError.raise()\n     }\n \n     pub fn span_err(&self, span: impl Into<MultiSpan>, msg: &str) {\n@@ -691,10 +693,7 @@ impl Handler {\n         db\n     }\n \n-    pub fn failure(&self, msg: &str) {\n-        self.inner.borrow_mut().failure(msg);\n-    }\n-\n+    // NOTE: intentionally doesn't raise an error so rustc_codegen_ssa only reports fatal errors in the main thread\n     pub fn fatal(&self, msg: &str) -> FatalError {\n         self.inner.borrow_mut().fatal(msg)\n     }\n@@ -769,6 +768,10 @@ impl Handler {\n         self.inner.borrow_mut().emitter.emit_future_breakage_report(diags)\n     }\n \n+    pub fn emit_unused_externs(&self, lint_level: &str, unused_externs: &[&str]) {\n+        self.inner.borrow_mut().emit_unused_externs(lint_level, unused_externs)\n+    }\n+\n     pub fn delay_as_bug(&self, diagnostic: Diagnostic) {\n         self.inner.borrow_mut().delay_as_bug(diagnostic)\n     }\n@@ -843,6 +846,10 @@ impl HandlerInner {\n         self.emitter.emit_artifact_notification(path, artifact_type);\n     }\n \n+    fn emit_unused_externs(&mut self, lint_level: &str, unused_externs: &[&str]) {\n+        self.emitter.emit_unused_externs(lint_level, unused_externs);\n+    }\n+\n     fn treat_err_as_bug(&self) -> bool {\n         self.flags.treat_err_as_bug.map_or(false, |c| self.err_count() >= c.get())\n     }\n@@ -964,12 +971,12 @@ impl HandlerInner {\n     }\n \n     fn delay_good_path_bug(&mut self, msg: &str) {\n-        let mut diagnostic = Diagnostic::new(Level::Bug, msg);\n+        let diagnostic = Diagnostic::new(Level::Bug, msg);\n         if self.flags.report_delayed_bugs {\n             self.emit_diagnostic(&diagnostic);\n         }\n-        diagnostic.note(&format!(\"delayed at {}\", std::backtrace::Backtrace::force_capture()));\n-        self.delayed_good_path_bugs.push(diagnostic);\n+        let backtrace = std::backtrace::Backtrace::force_capture();\n+        self.delayed_good_path_bugs.push(DelayedDiagnostic::with_backtrace(diagnostic, backtrace));\n     }\n \n     fn failure(&mut self, msg: &str) {\n@@ -1038,6 +1045,22 @@ impl HandlerInner {\n     }\n }\n \n+struct DelayedDiagnostic {\n+    inner: Diagnostic,\n+    note: Backtrace,\n+}\n+\n+impl DelayedDiagnostic {\n+    fn with_backtrace(diagnostic: Diagnostic, backtrace: Backtrace) -> Self {\n+        DelayedDiagnostic { inner: diagnostic, note: backtrace }\n+    }\n+\n+    fn decorate(mut self) -> Diagnostic {\n+        self.inner.note(&format!(\"delayed at {}\", self.note));\n+        self.inner\n+    }\n+}\n+\n #[derive(Copy, PartialEq, Clone, Hash, Debug, Encodable, Decodable)]\n pub enum Level {\n     Bug,"}, {"sha": "da764d993bbdb2ad7996a963677f2e696d16f771", "filename": "compiler/rustc_errors/src/registry.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_errors%2Fsrc%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_errors%2Fsrc%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fregistry.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -13,10 +13,6 @@ impl Registry {\n         Registry { long_descriptions: long_descriptions.iter().copied().collect() }\n     }\n \n-    /// This will panic if an invalid error code is passed in\n-    pub fn find_description(&self, code: &str) -> Option<&'static str> {\n-        self.long_descriptions[code]\n-    }\n     /// Returns `InvalidErrorCode` if the code requested does not exist in the\n     /// registry. Otherwise, returns an `Option` where `None` means the error\n     /// code is valid but has no extended information."}, {"sha": "3fe02bd0ceecf22bba43524631b7a32fa617eeb2", "filename": "compiler/rustc_errors/src/snippet.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_errors%2Fsrc%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_errors%2Fsrc%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fsnippet.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -121,16 +121,6 @@ impl Annotation {\n         matches!(self.annotation_type, AnnotationType::MultilineLine(_))\n     }\n \n-    pub fn is_multiline(&self) -> bool {\n-        matches!(\n-            self.annotation_type,\n-            AnnotationType::Multiline(_)\n-                | AnnotationType::MultilineStart(_)\n-                | AnnotationType::MultilineLine(_)\n-                | AnnotationType::MultilineEnd(_)\n-        )\n-    }\n-\n     pub fn len(&self) -> usize {\n         // Account for usize underflows\n         if self.end_col > self.start_col {"}, {"sha": "e262d95bb70f251bc4caf76bbaf7f823d9b5c084", "filename": "compiler/rustc_errors/src/styled_buffer.rs", "status": "modified", "additions": 55, "deletions": 35, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_errors%2Fsrc%2Fstyled_buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_errors%2Fsrc%2Fstyled_buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fstyled_buffer.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -1,39 +1,52 @@\n // Code for creating styled buffers\n \n use crate::snippet::{Style, StyledString};\n-use std::iter;\n \n #[derive(Debug)]\n pub struct StyledBuffer {\n-    text: Vec<Vec<char>>,\n-    styles: Vec<Vec<Style>>,\n+    lines: Vec<Vec<StyledChar>>,\n+}\n+\n+#[derive(Debug, Clone)]\n+struct StyledChar {\n+    chr: char,\n+    style: Style,\n+}\n+\n+impl StyledChar {\n+    const SPACE: Self = StyledChar::new(' ', Style::NoStyle);\n+\n+    const fn new(chr: char, style: Style) -> Self {\n+        StyledChar { chr, style }\n+    }\n }\n \n impl StyledBuffer {\n     pub fn new() -> StyledBuffer {\n-        StyledBuffer { text: vec![], styles: vec![] }\n+        StyledBuffer { lines: vec![] }\n     }\n \n+    /// Returns content of `StyledBuffer` splitted by lines and line styles\n     pub fn render(&self) -> Vec<Vec<StyledString>> {\n         // Tabs are assumed to have been replaced by spaces in calling code.\n-        debug_assert!(self.text.iter().all(|r| !r.contains(&'\\t')));\n+        debug_assert!(self.lines.iter().all(|r| !r.iter().any(|sc| sc.chr == '\\t')));\n \n         let mut output: Vec<Vec<StyledString>> = vec![];\n         let mut styled_vec: Vec<StyledString> = vec![];\n \n-        for (row, row_style) in iter::zip(&self.text, &self.styles) {\n+        for styled_line in &self.lines {\n             let mut current_style = Style::NoStyle;\n             let mut current_text = String::new();\n \n-            for (&c, &s) in iter::zip(row, row_style) {\n-                if s != current_style {\n+            for sc in styled_line {\n+                if sc.style != current_style {\n                     if !current_text.is_empty() {\n                         styled_vec.push(StyledString { text: current_text, style: current_style });\n                     }\n-                    current_style = s;\n+                    current_style = sc.style;\n                     current_text = String::new();\n                 }\n-                current_text.push(c);\n+                current_text.push(sc.chr);\n             }\n             if !current_text.is_empty() {\n                 styled_vec.push(StyledString { text: current_text, style: current_style });\n@@ -49,29 +62,25 @@ impl StyledBuffer {\n     }\n \n     fn ensure_lines(&mut self, line: usize) {\n-        while line >= self.text.len() {\n-            self.text.push(vec![]);\n-            self.styles.push(vec![]);\n+        if line >= self.lines.len() {\n+            self.lines.resize(line + 1, Vec::new());\n         }\n     }\n \n+    /// Sets `chr` with `style` for given `line`, `col`.\n+    /// If `line` does not exist in our buffer, adds empty lines up to the given\n+    /// and fills the last line with unstyled whitespace.\n     pub fn putc(&mut self, line: usize, col: usize, chr: char, style: Style) {\n         self.ensure_lines(line);\n-        if col < self.text[line].len() {\n-            self.text[line][col] = chr;\n-            self.styles[line][col] = style;\n-        } else {\n-            let mut i = self.text[line].len();\n-            while i < col {\n-                self.text[line].push(' ');\n-                self.styles[line].push(Style::NoStyle);\n-                i += 1;\n-            }\n-            self.text[line].push(chr);\n-            self.styles[line].push(style);\n+        if col >= self.lines[line].len() {\n+            self.lines[line].resize(col + 1, StyledChar::SPACE);\n         }\n+        self.lines[line][col] = StyledChar::new(chr, style);\n     }\n \n+    /// Sets `string` with `style` for given `line`, starting from `col`.\n+    /// If `line` does not exist in our buffer, adds empty lines up to the given\n+    /// and fills the last line with unstyled whitespace.\n     pub fn puts(&mut self, line: usize, col: usize, string: &str, style: Style) {\n         let mut n = col;\n         for c in string.chars() {\n@@ -80,32 +89,40 @@ impl StyledBuffer {\n         }\n     }\n \n+    /// For given `line` inserts `string` with `style` before old content of that line,\n+    /// adding lines if needed\n     pub fn prepend(&mut self, line: usize, string: &str, style: Style) {\n         self.ensure_lines(line);\n         let string_len = string.chars().count();\n \n-        // Push the old content over to make room for new content\n-        for _ in 0..string_len {\n-            self.styles[line].insert(0, Style::NoStyle);\n-            self.text[line].insert(0, ' ');\n+        if !self.lines[line].is_empty() {\n+            // Push the old content over to make room for new content\n+            for _ in 0..string_len {\n+                self.lines[line].insert(0, StyledChar::SPACE);\n+            }\n         }\n \n         self.puts(line, 0, string, style);\n     }\n \n+    /// For given `line` inserts `string` with `style` after old content of that line,\n+    /// adding lines if needed\n     pub fn append(&mut self, line: usize, string: &str, style: Style) {\n-        if line >= self.text.len() {\n+        if line >= self.lines.len() {\n             self.puts(line, 0, string, style);\n         } else {\n-            let col = self.text[line].len();\n+            let col = self.lines[line].len();\n             self.puts(line, col, string, style);\n         }\n     }\n \n     pub fn num_lines(&self) -> usize {\n-        self.text.len()\n+        self.lines.len()\n     }\n \n+    /// Set `style` for `line`, `col_start..col_end` range if:\n+    /// 1. That line and column range exist in `StyledBuffer`\n+    /// 2. `overwrite` is `true` or existing style is `Style::NoStyle` or `Style::Quotation`\n     pub fn set_style_range(\n         &mut self,\n         line: usize,\n@@ -119,10 +136,13 @@ impl StyledBuffer {\n         }\n     }\n \n+    /// Set `style` for `line`, `col` if:\n+    /// 1. That line and column exist in `StyledBuffer`\n+    /// 2. `overwrite` is `true` or existing style is `Style::NoStyle` or `Style::Quotation`\n     pub fn set_style(&mut self, line: usize, col: usize, style: Style, overwrite: bool) {\n-        if let Some(ref mut line) = self.styles.get_mut(line) {\n-            if let Some(s) = line.get_mut(col) {\n-                if *s == Style::NoStyle || *s == Style::Quotation || overwrite {\n+        if let Some(ref mut line) = self.lines.get_mut(line) {\n+            if let Some(StyledChar { style: s, .. }) = line.get_mut(col) {\n+                if overwrite || *s == Style::NoStyle || *s == Style::Quotation {\n                     *s = style;\n                 }\n             }"}, {"sha": "e1c218c640851fb2442b7bc6bb876a8ba0fa1450", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 45, "deletions": 70, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -3,7 +3,7 @@ use crate::module::DirOwnership;\n \n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Nonterminal};\n-use rustc_ast::tokenstream::{CanSynthesizeMissingTokens, LazyTokenStream, TokenStream};\n+use rustc_ast::tokenstream::{CanSynthesizeMissingTokens, TokenStream};\n use rustc_ast::visit::{AssocCtxt, Visitor};\n use rustc_ast::{self as ast, AstLike, Attribute, Item, NodeId, PatKind};\n use rustc_attr::{self as attr, Deprecation, Stability};\n@@ -14,7 +14,7 @@ use rustc_lint_defs::builtin::PROC_MACRO_BACK_COMPAT;\n use rustc_lint_defs::BuiltinLintDiagnostics;\n use rustc_parse::{self, nt_to_tokenstream, parser, MACRO_ARGUMENTS};\n use rustc_session::{parse::ParseSess, Limit, Session};\n-use rustc_span::def_id::DefId;\n+use rustc_span::def_id::{CrateNum, DefId};\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::{AstPass, ExpnData, ExpnId, ExpnKind};\n use rustc_span::source_map::SourceMap;\n@@ -46,26 +46,26 @@ pub enum Annotatable {\n     Variant(ast::Variant),\n }\n \n-impl AstLike for Annotatable {\n-    fn attrs(&self) -> &[Attribute] {\n+impl Annotatable {\n+    pub fn span(&self) -> Span {\n         match *self {\n-            Annotatable::Item(ref item) => &item.attrs,\n-            Annotatable::TraitItem(ref trait_item) => &trait_item.attrs,\n-            Annotatable::ImplItem(ref impl_item) => &impl_item.attrs,\n-            Annotatable::ForeignItem(ref foreign_item) => &foreign_item.attrs,\n-            Annotatable::Stmt(ref stmt) => stmt.attrs(),\n-            Annotatable::Expr(ref expr) => &expr.attrs,\n-            Annotatable::Arm(ref arm) => &arm.attrs,\n-            Annotatable::ExprField(ref field) => &field.attrs,\n-            Annotatable::PatField(ref fp) => &fp.attrs,\n-            Annotatable::GenericParam(ref gp) => &gp.attrs,\n-            Annotatable::Param(ref p) => &p.attrs,\n-            Annotatable::FieldDef(ref sf) => &sf.attrs,\n-            Annotatable::Variant(ref v) => &v.attrs(),\n+            Annotatable::Item(ref item) => item.span,\n+            Annotatable::TraitItem(ref trait_item) => trait_item.span,\n+            Annotatable::ImplItem(ref impl_item) => impl_item.span,\n+            Annotatable::ForeignItem(ref foreign_item) => foreign_item.span,\n+            Annotatable::Stmt(ref stmt) => stmt.span,\n+            Annotatable::Expr(ref expr) => expr.span,\n+            Annotatable::Arm(ref arm) => arm.span,\n+            Annotatable::ExprField(ref field) => field.span,\n+            Annotatable::PatField(ref fp) => fp.pat.span,\n+            Annotatable::GenericParam(ref gp) => gp.ident.span,\n+            Annotatable::Param(ref p) => p.span,\n+            Annotatable::FieldDef(ref sf) => sf.span,\n+            Annotatable::Variant(ref v) => v.span,\n         }\n     }\n \n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+    pub fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n         match self {\n             Annotatable::Item(item) => item.visit_attrs(f),\n             Annotatable::TraitItem(trait_item) => trait_item.visit_attrs(f),\n@@ -83,44 +83,6 @@ impl AstLike for Annotatable {\n         }\n     }\n \n-    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n-        match self {\n-            Annotatable::Item(item) => item.tokens_mut(),\n-            Annotatable::TraitItem(trait_item) => trait_item.tokens_mut(),\n-            Annotatable::ImplItem(impl_item) => impl_item.tokens_mut(),\n-            Annotatable::ForeignItem(foreign_item) => foreign_item.tokens_mut(),\n-            Annotatable::Stmt(stmt) => stmt.tokens_mut(),\n-            Annotatable::Expr(expr) => expr.tokens_mut(),\n-            Annotatable::Arm(arm) => arm.tokens_mut(),\n-            Annotatable::ExprField(field) => field.tokens_mut(),\n-            Annotatable::PatField(fp) => fp.tokens_mut(),\n-            Annotatable::GenericParam(gp) => gp.tokens_mut(),\n-            Annotatable::Param(p) => p.tokens_mut(),\n-            Annotatable::FieldDef(sf) => sf.tokens_mut(),\n-            Annotatable::Variant(v) => v.tokens_mut(),\n-        }\n-    }\n-}\n-\n-impl Annotatable {\n-    pub fn span(&self) -> Span {\n-        match *self {\n-            Annotatable::Item(ref item) => item.span,\n-            Annotatable::TraitItem(ref trait_item) => trait_item.span,\n-            Annotatable::ImplItem(ref impl_item) => impl_item.span,\n-            Annotatable::ForeignItem(ref foreign_item) => foreign_item.span,\n-            Annotatable::Stmt(ref stmt) => stmt.span,\n-            Annotatable::Expr(ref expr) => expr.span,\n-            Annotatable::Arm(ref arm) => arm.span,\n-            Annotatable::ExprField(ref field) => field.span,\n-            Annotatable::PatField(ref fp) => fp.pat.span,\n-            Annotatable::GenericParam(ref gp) => gp.ident.span,\n-            Annotatable::Param(ref p) => p.span,\n-            Annotatable::FieldDef(ref sf) => sf.span,\n-            Annotatable::Variant(ref v) => v.span,\n-        }\n-    }\n-\n     pub fn visit_with<'a, V: Visitor<'a>>(&'a self, visitor: &mut V) {\n         match self {\n             Annotatable::Item(item) => visitor.visit_item(item),\n@@ -139,7 +101,7 @@ impl Annotatable {\n         }\n     }\n \n-    crate fn into_nonterminal(self) -> Nonterminal {\n+    pub fn into_nonterminal(self) -> Nonterminal {\n         match self {\n             Annotatable::Item(item) => token::NtItem(item),\n             Annotatable::TraitItem(item) | Annotatable::ImplItem(item) => {\n@@ -161,10 +123,7 @@ impl Annotatable {\n     }\n \n     crate fn into_tokens(self, sess: &ParseSess) -> TokenStream {\n-        // Tokens of an attribute target may be invalidated by some outer `#[derive]` performing\n-        // \"full configuration\" (attributes following derives on the same item should be the most\n-        // common case), that's why synthesizing tokens is allowed.\n-        nt_to_tokenstream(&self.into_nonterminal(), sess, CanSynthesizeMissingTokens::Yes)\n+        nt_to_tokenstream(&self.into_nonterminal(), sess, CanSynthesizeMissingTokens::No)\n     }\n \n     pub fn expect_item(self) -> P<ast::Item> {\n@@ -851,8 +810,16 @@ impl SyntaxExtension {\n         descr: Symbol,\n         macro_def_id: Option<DefId>,\n     ) -> ExpnData {\n+        use SyntaxExtensionKind::*;\n+        let proc_macro = match self.kind {\n+            // User-defined proc macro\n+            Bang(..) | Attr(..) | Derive(..) => true,\n+            // Consider everthing else to be not a proc\n+            // macro for diagnostic purposes\n+            LegacyBang(..) | LegacyAttr(..) | NonMacroAttr { .. } | LegacyDerive(..) => false,\n+        };\n         ExpnData::new(\n-            ExpnKind::Macro(self.macro_kind(), descr),\n+            ExpnKind::Macro { kind: self.macro_kind(), name: descr, proc_macro },\n             parent,\n             call_site,\n             self.span,\n@@ -868,6 +835,8 @@ impl SyntaxExtension {\n /// Error type that denotes indeterminacy.\n pub struct Indeterminate;\n \n+pub type DeriveResolutions = Vec<(ast::Path, Option<Lrc<SyntaxExtension>>)>;\n+\n pub trait ResolverExpand {\n     fn next_node_id(&mut self) -> NodeId;\n \n@@ -904,17 +873,18 @@ pub trait ResolverExpand {\n     fn resolve_derives(\n         &mut self,\n         expn_id: ExpnId,\n-        derives: Vec<ast::Path>,\n         force: bool,\n+        derive_paths: &dyn Fn() -> DeriveResolutions,\n     ) -> Result<(), Indeterminate>;\n     /// Take resolutions for paths inside the `#[derive(...)]` attribute with the given `ExpnId`\n     /// back from resolver.\n-    fn take_derive_resolutions(\n-        &mut self,\n-        expn_id: ExpnId,\n-    ) -> Option<Vec<(Lrc<SyntaxExtension>, ast::Path)>>;\n+    fn take_derive_resolutions(&mut self, expn_id: ExpnId) -> Option<DeriveResolutions>;\n     /// Path resolution logic for `#[cfg_accessible(path)]`.\n     fn cfg_accessible(&mut self, expn_id: ExpnId, path: &ast::Path) -> Result<bool, Indeterminate>;\n+\n+    /// Decodes the proc-macro quoted span in the specified crate, with the specified id.\n+    /// No caching is performed.\n+    fn get_proc_macro_quoted_span(&self, krate: CrateNum, id: usize) -> Span;\n }\n \n #[derive(Clone, Default)]\n@@ -1114,13 +1084,18 @@ impl<'a> ExtCtxt<'a> {\n         // after macro expansion (that is, they are unhygienic).\n         if !path.is_absolute() {\n             let callsite = span.source_callsite();\n-            let mut result = match self.source_map().span_to_unmapped_path(callsite) {\n-                FileName::Real(name) => name.into_local_path(),\n+            let mut result = match self.source_map().span_to_filename(callsite) {\n+                FileName::Real(name) => name\n+                    .into_local_path()\n+                    .expect(\"attempting to resolve a file path in an external file\"),\n                 FileName::DocTest(path, _) => path,\n                 other => {\n                     return Err(self.struct_span_err(\n                         span,\n-                        &format!(\"cannot resolve relative path in non-file source `{}`\", other),\n+                        &format!(\n+                            \"cannot resolve relative path in non-file source `{}`\",\n+                            other.prefer_local()\n+                        ),\n                     ));\n                 }\n             };"}, {"sha": "cb8b9398283ef963b2cc68acd2f76b27d17887bc", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -253,17 +253,6 @@ impl<'a> ExtCtxt<'a> {\n         let pathexpr = self.expr_path(self.path_global(sp, fn_path));\n         self.expr_call(sp, pathexpr, args)\n     }\n-    pub fn expr_method_call(\n-        &self,\n-        span: Span,\n-        expr: P<ast::Expr>,\n-        ident: Ident,\n-        mut args: Vec<P<ast::Expr>>,\n-    ) -> P<ast::Expr> {\n-        args.insert(0, expr);\n-        let segment = ast::PathSegment::from_ident(ident.with_span_pos(span));\n-        self.expr(span, ast::ExprKind::MethodCall(segment, args, span))\n-    }\n     pub fn expr_block(&self, b: P<ast::Block>) -> P<ast::Expr> {\n         self.expr(b.span, ast::ExprKind::Block(b, None))\n     }"}, {"sha": "f9140609c0f3c86f048d0b542c4feddb75adba82", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 125, "deletions": 50, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -2,8 +2,10 @@\n \n use rustc_ast::ptr::P;\n use rustc_ast::token::{DelimToken, Token, TokenKind};\n-use rustc_ast::tokenstream::{DelimSpan, LazyTokenStream, Spacing, TokenStream, TokenTree};\n-use rustc_ast::{self as ast, AstLike, AttrItem, Attribute, MetaItem};\n+use rustc_ast::tokenstream::{AttrAnnotatedTokenStream, AttrAnnotatedTokenTree};\n+use rustc_ast::tokenstream::{DelimSpan, Spacing};\n+use rustc_ast::tokenstream::{LazyTokenStream, TokenTree};\n+use rustc_ast::{self as ast, AstLike, AttrItem, AttrStyle, Attribute, MetaItem};\n use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::map_in_place::MapInPlace;\n@@ -23,7 +25,10 @@ use rustc_span::{Span, DUMMY_SP};\n pub struct StripUnconfigured<'a> {\n     pub sess: &'a Session,\n     pub features: Option<&'a Features>,\n-    pub modified: bool,\n+    /// If `true`, perform cfg-stripping on attached tokens.\n+    /// This is only used for the input to derive macros,\n+    /// which needs eager expansion of `cfg` and `cfg_attr`\n+    pub config_tokens: bool,\n }\n \n fn get_features(\n@@ -194,7 +199,7 @@ fn get_features(\n \n // `cfg_attr`-process the crate's attributes and compute the crate's features.\n pub fn features(sess: &Session, mut krate: ast::Crate) -> (ast::Crate, Features) {\n-    let mut strip_unconfigured = StripUnconfigured { sess, features: None, modified: false };\n+    let mut strip_unconfigured = StripUnconfigured { sess, features: None, config_tokens: false };\n \n     let unconfigured_attrs = krate.attrs.clone();\n     let diag = &sess.parse_sess.span_diagnostic;\n@@ -241,24 +246,83 @@ impl<'a> StripUnconfigured<'a> {\n     pub fn configure<T: AstLike>(&mut self, mut node: T) -> Option<T> {\n         self.process_cfg_attrs(&mut node);\n         if self.in_cfg(node.attrs()) {\n+            self.try_configure_tokens(&mut node);\n             Some(node)\n         } else {\n-            self.modified = true;\n             None\n         }\n     }\n \n+    fn try_configure_tokens<T: AstLike>(&mut self, node: &mut T) {\n+        if self.config_tokens {\n+            if let Some(Some(tokens)) = node.tokens_mut() {\n+                let attr_annotated_tokens = tokens.create_token_stream();\n+                *tokens = LazyTokenStream::new(self.configure_tokens(&attr_annotated_tokens));\n+            }\n+        }\n+    }\n+\n     fn configure_krate_attrs(\n         &mut self,\n         mut attrs: Vec<ast::Attribute>,\n     ) -> Option<Vec<ast::Attribute>> {\n         attrs.flat_map_in_place(|attr| self.process_cfg_attr(attr));\n-        if self.in_cfg(&attrs) {\n-            Some(attrs)\n-        } else {\n-            self.modified = true;\n-            None\n+        if self.in_cfg(&attrs) { Some(attrs) } else { None }\n+    }\n+\n+    /// Performs cfg-expansion on `stream`, producing a new `AttrAnnotatedTokenStream`.\n+    /// This is only used during the invocation of `derive` proc-macros,\n+    /// which require that we cfg-expand their entire input.\n+    /// Normal cfg-expansion operates on parsed AST nodes via the `configure` method\n+    fn configure_tokens(&mut self, stream: &AttrAnnotatedTokenStream) -> AttrAnnotatedTokenStream {\n+        fn can_skip(stream: &AttrAnnotatedTokenStream) -> bool {\n+            stream.0.iter().all(|(tree, _spacing)| match tree {\n+                AttrAnnotatedTokenTree::Attributes(_) => false,\n+                AttrAnnotatedTokenTree::Token(_) => true,\n+                AttrAnnotatedTokenTree::Delimited(_, _, inner) => can_skip(inner),\n+            })\n         }\n+\n+        if can_skip(stream) {\n+            return stream.clone();\n+        }\n+\n+        let trees: Vec<_> = stream\n+            .0\n+            .iter()\n+            .flat_map(|(tree, spacing)| match tree.clone() {\n+                AttrAnnotatedTokenTree::Attributes(mut data) => {\n+                    let mut attrs: Vec<_> = std::mem::take(&mut data.attrs).into();\n+                    attrs.flat_map_in_place(|attr| self.process_cfg_attr(attr));\n+                    data.attrs = attrs.into();\n+\n+                    if self.in_cfg(&data.attrs) {\n+                        data.tokens = LazyTokenStream::new(\n+                            self.configure_tokens(&data.tokens.create_token_stream()),\n+                        );\n+                        Some((AttrAnnotatedTokenTree::Attributes(data), *spacing)).into_iter()\n+                    } else {\n+                        None.into_iter()\n+                    }\n+                }\n+                AttrAnnotatedTokenTree::Delimited(sp, delim, mut inner) => {\n+                    inner = self.configure_tokens(&inner);\n+                    Some((AttrAnnotatedTokenTree::Delimited(sp, delim, inner), *spacing))\n+                        .into_iter()\n+                }\n+                AttrAnnotatedTokenTree::Token(token) => {\n+                    if let TokenKind::Interpolated(nt) = token.kind {\n+                        panic!(\n+                            \"Nonterminal should have been flattened at {:?}: {:?}\",\n+                            token.span, nt\n+                        );\n+                    } else {\n+                        Some((AttrAnnotatedTokenTree::Token(token), *spacing)).into_iter()\n+                    }\n+                }\n+            })\n+            .collect();\n+        AttrAnnotatedTokenStream::new(trees)\n     }\n \n     /// Parse and expand all `cfg_attr` attributes into a list of attributes\n@@ -285,9 +349,6 @@ impl<'a> StripUnconfigured<'a> {\n             return vec![attr];\n         }\n \n-        // A `#[cfg_attr]` either gets removed, or replaced with a new attribute\n-        self.modified = true;\n-\n         let (cfg_predicate, expanded_attrs) = match self.parse_cfg_attr(&attr) {\n             None => return vec![],\n             Some(r) => r,\n@@ -311,7 +372,7 @@ impl<'a> StripUnconfigured<'a> {\n         expanded_attrs\n             .into_iter()\n             .flat_map(|(item, span)| {\n-                let orig_tokens = attr.tokens();\n+                let orig_tokens = attr.tokens().to_tokenstream();\n \n                 // We are taking an attribute of the form `#[cfg_attr(pred, attr)]`\n                 // and producing an attribute of the form `#[attr]`. We\n@@ -321,25 +382,34 @@ impl<'a> StripUnconfigured<'a> {\n \n                 // Use the `#` in `#[cfg_attr(pred, attr)]` as the `#` token\n                 // for `attr` when we expand it to `#[attr]`\n-                let pound_token = orig_tokens.trees().next().unwrap();\n-                if !matches!(pound_token, TokenTree::Token(Token { kind: TokenKind::Pound, .. })) {\n-                    panic!(\"Bad tokens for attribute {:?}\", attr);\n+                let mut orig_trees = orig_tokens.trees();\n+                let pound_token = match orig_trees.next().unwrap() {\n+                    TokenTree::Token(token @ Token { kind: TokenKind::Pound, .. }) => token,\n+                    _ => panic!(\"Bad tokens for attribute {:?}\", attr),\n+                };\n+                let pound_span = pound_token.span;\n+\n+                let mut trees = vec![(AttrAnnotatedTokenTree::Token(pound_token), Spacing::Alone)];\n+                if attr.style == AttrStyle::Inner {\n+                    // For inner attributes, we do the same thing for the `!` in `#![some_attr]`\n+                    let bang_token = match orig_trees.next().unwrap() {\n+                        TokenTree::Token(token @ Token { kind: TokenKind::Not, .. }) => token,\n+                        _ => panic!(\"Bad tokens for attribute {:?}\", attr),\n+                    };\n+                    trees.push((AttrAnnotatedTokenTree::Token(bang_token), Spacing::Alone));\n                 }\n                 // We don't really have a good span to use for the syntheized `[]`\n                 // in `#[attr]`, so just use the span of the `#` token.\n-                let bracket_group = TokenTree::Delimited(\n-                    DelimSpan::from_single(pound_token.span()),\n+                let bracket_group = AttrAnnotatedTokenTree::Delimited(\n+                    DelimSpan::from_single(pound_span),\n                     DelimToken::Bracket,\n                     item.tokens\n                         .as_ref()\n                         .unwrap_or_else(|| panic!(\"Missing tokens for {:?}\", item))\n                         .create_token_stream(),\n                 );\n-                let tokens = Some(LazyTokenStream::new(TokenStream::new(vec![\n-                    (pound_token, Spacing::Alone),\n-                    (bracket_group, Spacing::Alone),\n-                ])));\n-\n+                trees.push((bracket_group, Spacing::Alone));\n+                let tokens = Some(LazyTokenStream::new(AttrAnnotatedTokenStream::new(trees)));\n                 self.process_cfg_attr(attr::mk_attr_from_item(item, tokens, attr.style, span))\n             })\n             .collect()\n@@ -394,31 +464,9 @@ impl<'a> StripUnconfigured<'a> {\n                     return true;\n                 }\n             };\n-            let error = |span, msg, suggestion: &str| {\n-                let mut err = self.sess.parse_sess.span_diagnostic.struct_span_err(span, msg);\n-                if !suggestion.is_empty() {\n-                    err.span_suggestion(\n-                        span,\n-                        \"expected syntax is\",\n-                        suggestion.into(),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                err.emit();\n-                true\n-            };\n-            let span = meta_item.span;\n-            match meta_item.meta_item_list() {\n-                None => error(span, \"`cfg` is not followed by parentheses\", \"cfg(/* predicate */)\"),\n-                Some([]) => error(span, \"`cfg` predicate is not specified\", \"\"),\n-                Some([_, .., l]) => error(l.span(), \"multiple `cfg` predicates are specified\", \"\"),\n-                Some([single]) => match single.meta_item() {\n-                    Some(meta_item) => {\n-                        attr::cfg_matches(meta_item, &self.sess.parse_sess, self.features)\n-                    }\n-                    None => error(single.span(), \"`cfg` predicate key cannot be a literal\", \"\"),\n-                },\n-            }\n+            parse_cfg(&meta_item, &self.sess).map_or(true, |meta_item| {\n+                attr::cfg_matches(&meta_item, &self.sess.parse_sess, self.features)\n+            })\n         })\n     }\n \n@@ -457,7 +505,34 @@ impl<'a> StripUnconfigured<'a> {\n             self.sess.parse_sess.span_diagnostic.span_err(attr.span, msg);\n         }\n \n-        self.process_cfg_attrs(expr)\n+        self.process_cfg_attrs(expr);\n+        self.try_configure_tokens(&mut *expr);\n+    }\n+}\n+\n+pub fn parse_cfg<'a>(meta_item: &'a MetaItem, sess: &Session) -> Option<&'a MetaItem> {\n+    let error = |span, msg, suggestion: &str| {\n+        let mut err = sess.parse_sess.span_diagnostic.struct_span_err(span, msg);\n+        if !suggestion.is_empty() {\n+            err.span_suggestion(\n+                span,\n+                \"expected syntax is\",\n+                suggestion.into(),\n+                Applicability::HasPlaceholders,\n+            );\n+        }\n+        err.emit();\n+        None\n+    };\n+    let span = meta_item.span;\n+    match meta_item.meta_item_list() {\n+        None => error(span, \"`cfg` is not followed by parentheses\", \"cfg(/* predicate */)\"),\n+        Some([]) => error(span, \"`cfg` predicate is not specified\", \"\"),\n+        Some([_, .., l]) => error(l.span(), \"multiple `cfg` predicates are specified\", \"\"),\n+        Some([single]) => match single.meta_item() {\n+            Some(meta_item) => Some(meta_item),\n+            None => error(single.span(), \"`cfg` predicate key cannot be a literal\", \"\"),\n+        },\n     }\n }\n "}, {"sha": "f5c6bb3db654202ee1f7db9856107f58ba85fc17", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 66, "deletions": 21, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -12,15 +12,15 @@ use rustc_ast::ptr::P;\n use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n-use rustc_ast::{AstLike, AttrItem, AttrStyle, Block, Inline, ItemKind, LitKind, MacArgs};\n+use rustc_ast::{AstLike, AttrItem, Block, Inline, ItemKind, LitKind, MacArgs};\n use rustc_ast::{MacCallStmt, MacStmtStyle, MetaItemKind, ModKind, NestedMetaItem};\n use rustc_ast::{NodeId, PatKind, Path, StmtKind, Unsafe};\n use rustc_ast_pretty::pprust;\n use rustc_attr::{self as attr, is_builtin_attr};\n use rustc_data_structures::map_in_place::MapInPlace;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{Applicability, PResult};\n+use rustc_errors::{Applicability, FatalError, PResult};\n use rustc_feature::Features;\n use rustc_parse::parser::{AttemptLocalParseRecovery, ForceCollect, Parser, RecoverComma};\n use rustc_parse::validate_attr;\n@@ -361,9 +361,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     // FIXME: Avoid visiting the crate as a `Mod` item,\n     // make crate a first class expansion target instead.\n     pub fn expand_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n-        let file_path = match self.cx.source_map().span_to_unmapped_path(krate.span) {\n-            FileName::Real(name) => name.into_local_path(),\n-            other => PathBuf::from(other.to_string()),\n+        let file_path = match self.cx.source_map().span_to_filename(krate.span) {\n+            FileName::Real(name) => name\n+                .into_local_path()\n+                .expect(\"attempting to resolve a file path in an external file\"),\n+            other => PathBuf::from(other.prefer_local().to_string()),\n         };\n         let dir_path = file_path.parent().unwrap_or(&file_path).to_owned();\n         self.cx.root_path = dir_path.clone();\n@@ -414,6 +416,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         kind.article(), kind.descr()\n                     ),\n                 );\n+                // FIXME: this workaround issue #84569\n+                FatalError.raise();\n             }\n         };\n         self.cx.trace_macros_diag();\n@@ -491,6 +495,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             let fragment_kind = invoc.fragment_kind;\n             let (expanded_fragment, new_invocations) = match self.expand_invoc(invoc, &ext.kind) {\n                 ExpandResult::Ready(fragment) => {\n+                    let mut derive_invocations = Vec::new();\n                     let derive_placeholders = self\n                         .cx\n                         .resolver\n@@ -512,14 +517,14 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                                 _ => unreachable!(),\n                             };\n \n-                            invocations.reserve(derives.len());\n+                            derive_invocations.reserve(derives.len());\n                             derives\n                                 .into_iter()\n-                                .map(|(_exts, path)| {\n+                                .map(|(path, _exts)| {\n                                     // FIXME: Consider using the derive resolutions (`_exts`)\n                                     // instead of enqueuing the derives to be resolved again later.\n                                     let expn_id = ExpnId::fresh(None);\n-                                    invocations.push((\n+                                    derive_invocations.push((\n                                         Invocation {\n                                             kind: InvocationKind::Derive {\n                                                 path,\n@@ -546,7 +551,12 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         })\n                         .unwrap_or_default();\n \n-                    self.collect_invocations(fragment, &derive_placeholders)\n+                    let (fragment, collected_invocations) =\n+                        self.collect_invocations(fragment, &derive_placeholders);\n+                    // We choose to expand any derive invocations associated with this macro invocation\n+                    // *before* any macro invocations collected from the output fragment\n+                    derive_invocations.extend(collected_invocations);\n+                    (fragment, derive_invocations)\n                 }\n                 ExpandResult::Retry(invoc) => {\n                     if force {\n@@ -605,10 +615,15 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n         let invocations = {\n             let mut collector = InvocationCollector {\n+                // Non-derive macro invocations cannot see the results of cfg expansion - they\n+                // will either be removed along with the item, or invoked before the cfg/cfg_attr\n+                // attribute is expanded. Therefore, we don't need to configure the tokens\n+                // Derive macros *can* see the results of cfg-expansion - they are handled\n+                // specially in `fully_expand_fragment`\n                 cfg: StripUnconfigured {\n                     sess: &self.cx.sess,\n                     features: self.cx.ecfg.features,\n-                    modified: false,\n+                    config_tokens: false,\n                 },\n                 cx: self.cx,\n                 invocations: Vec::new(),\n@@ -703,13 +718,26 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 SyntaxExtensionKind::Attr(expander) => {\n                     self.gate_proc_macro_input(&item);\n                     self.gate_proc_macro_attr_item(span, &item);\n-                    let tokens = match attr.style {\n-                        AttrStyle::Outer => item.into_tokens(&self.cx.sess.parse_sess),\n-                        // FIXME: Properly collect tokens for inner attributes\n-                        AttrStyle::Inner => rustc_parse::fake_token_stream(\n+                    let mut fake_tokens = false;\n+                    if let Annotatable::Item(item_inner) = &item {\n+                        if let ItemKind::Mod(_, mod_kind) = &item_inner.kind {\n+                            // FIXME: Collect tokens and use them instead of generating\n+                            // fake ones. These are unstable, so it needs to be\n+                            // fixed prior to stabilization\n+                            // Fake tokens when we are invoking an inner attribute, and:\n+                            fake_tokens = matches!(attr.style, ast::AttrStyle::Inner) &&\n+                                // We are invoking an attribute on the crate root, or an outline\n+                                // module\n+                                (item_inner.ident.name.is_empty() || !matches!(mod_kind, ast::ModKind::Loaded(_, Inline::Yes, _)));\n+                        }\n+                    }\n+                    let tokens = if fake_tokens {\n+                        rustc_parse::fake_token_stream(\n                             &self.cx.sess.parse_sess,\n                             &item.into_nonterminal(),\n-                        ),\n+                        )\n+                    } else {\n+                        item.into_tokens(&self.cx.sess.parse_sess)\n                     };\n                     let attr_item = attr.unwrap_normal_item();\n                     if let MacArgs::Eq(..) = attr_item.args {\n@@ -735,7 +763,14 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                                     });\n                                 }\n                             };\n-                            fragment_kind.expect_from_annotatables(items)\n+                            if fragment_kind == AstFragmentKind::Expr && items.is_empty() {\n+                                let msg =\n+                                    \"removing an expression is not supported in this position\";\n+                                self.cx.span_err(span, msg);\n+                                fragment_kind.dummy(span)\n+                            } else {\n+                                fragment_kind.expect_from_annotatables(items)\n+                            }\n                         }\n                         Err(mut err) => {\n                             err.emit();\n@@ -884,21 +919,21 @@ pub fn parse_ast_fragment<'a>(\n         }\n         AstFragmentKind::TraitItems => {\n             let mut items = SmallVec::new();\n-            while let Some(item) = this.parse_trait_item()? {\n+            while let Some(item) = this.parse_trait_item(ForceCollect::No)? {\n                 items.extend(item);\n             }\n             AstFragment::TraitItems(items)\n         }\n         AstFragmentKind::ImplItems => {\n             let mut items = SmallVec::new();\n-            while let Some(item) = this.parse_impl_item()? {\n+            while let Some(item) = this.parse_impl_item(ForceCollect::No)? {\n                 items.extend(item);\n             }\n             AstFragment::ImplItems(items)\n         }\n         AstFragmentKind::ForeignItems => {\n             let mut items = SmallVec::new();\n-            while let Some(item) = this.parse_foreign_item()? {\n+            while let Some(item) = this.parse_foreign_item(ForceCollect::No)? {\n                 items.extend(item);\n             }\n             AstFragment::ForeignItems(items)\n@@ -1060,13 +1095,23 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     // since they will not be detected after macro expansion.\n     fn check_attributes(&mut self, attrs: &[ast::Attribute]) {\n         let features = self.cx.ecfg.features.unwrap();\n-        for attr in attrs.iter() {\n+        let mut attrs = attrs.iter().peekable();\n+        let mut span: Option<Span> = None;\n+        while let Some(attr) = attrs.next() {\n             rustc_ast_passes::feature_gate::check_attribute(attr, self.cx.sess, features);\n             validate_attr::check_meta(&self.cx.sess.parse_sess, attr);\n+\n+            let current_span = if let Some(sp) = span { sp.to(attr.span) } else { attr.span };\n+            span = Some(current_span);\n+\n+            if attrs.peek().map_or(false, |next_attr| next_attr.doc_str().is_some()) {\n+                continue;\n+            }\n+\n             if attr.doc_str().is_some() {\n                 self.cx.sess.parse_sess.buffer_lint_with_diagnostic(\n                     &UNUSED_DOC_COMMENTS,\n-                    attr.span,\n+                    current_span,\n                     ast::CRATE_NODE_ID,\n                     \"unused doc comment\",\n                     BuiltinLintDiagnostics::UnusedDocComment(attr.span),"}, {"sha": "16510b3eb07c9a1758bc157a9c2b12ab67b862a7", "filename": "compiler/rustc_expand/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Flib.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -3,7 +3,6 @@\n #![feature(decl_macro)]\n #![feature(destructuring_assignment)]\n #![feature(iter_zip)]\n-#![cfg_attr(bootstrap, feature(or_patterns))]\n #![feature(proc_macro_diagnostic)]\n #![feature(proc_macro_internals)]\n #![feature(proc_macro_span)]"}, {"sha": "5244ac36bba5de5badcc923c8728078b06e229b8", "filename": "compiler/rustc_expand/src/mbe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -69,7 +69,7 @@ enum KleeneOp {\n     ZeroOrMore,\n     /// Kleene plus (`+`) for one or more repetitions\n     OneOrMore,\n-    /// Kleene optional (`?`) for zero or one reptitions\n+    /// Kleene optional (`?`) for zero or one repetitions\n     ZeroOrOne,\n }\n "}, {"sha": "91d4a0f0d6581190759147e526ca3355369c0739", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -18,7 +18,8 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_feature::Features;\n-use rustc_lint_defs::builtin::SEMICOLON_IN_EXPRESSIONS_FROM_MACROS;\n+use rustc_lint_defs::builtin::{OR_PATTERNS_BACK_COMPAT, SEMICOLON_IN_EXPRESSIONS_FROM_MACROS};\n+use rustc_lint_defs::BuiltinLintDiagnostics;\n use rustc_parse::parser::Parser;\n use rustc_session::parse::ParseSess;\n use rustc_session::Session;\n@@ -951,8 +952,32 @@ fn check_matcher_core(\n         // Now `last` holds the complete set of NT tokens that could\n         // end the sequence before SUFFIX. Check that every one works with `suffix`.\n         for token in &last.tokens {\n-            if let TokenTree::MetaVarDecl(_, name, Some(kind)) = *token {\n+            if let TokenTree::MetaVarDecl(span, name, Some(kind)) = *token {\n                 for next_token in &suffix_first.tokens {\n+                    // Check if the old pat is used and the next token is `|`.\n+                    if let NonterminalKind::PatParam { inferred: true } = kind {\n+                        if let TokenTree::Token(token) = next_token {\n+                            if let BinOp(token) = token.kind {\n+                                if let token::BinOpToken::Or = token {\n+                                    // It is suggestion to use pat_param, for example: $x:pat -> $x:pat_param.\n+                                    let suggestion = quoted_tt_to_string(&TokenTree::MetaVarDecl(\n+                                        span,\n+                                        name,\n+                                        Some(NonterminalKind::PatParam { inferred: false }),\n+                                    ));\n+                                    sess.buffer_lint_with_diagnostic(\n+                                        &OR_PATTERNS_BACK_COMPAT,\n+                                        span,\n+                                        ast::CRATE_NODE_ID,\n+                                        &*format!(\"the meaning of the `pat` fragment specifier is changing in Rust 2021, which may affect this macro\",),\n+                                        BuiltinLintDiagnostics::OrPatternsBackCompat(\n+                                            span, suggestion,\n+                                        ),\n+                                    );\n+                                }\n+                            }\n+                        }\n+                    }\n                     match is_in_follow(next_token, kind) {\n                         IsInFollow::Yes => {}\n                         IsInFollow::No(possible) => {\n@@ -1080,7 +1105,7 @@ fn is_in_follow(tok: &mbe::TokenTree, kind: NonterminalKind) -> IsInFollow {\n                     _ => IsInFollow::No(TOKENS),\n                 }\n             }\n-            NonterminalKind::Pat2015 { .. } | NonterminalKind::Pat2021 { .. } => {\n+            NonterminalKind::PatParam { .. } => {\n                 const TOKENS: &[&str] = &[\"`=>`\", \"`,`\", \"`=`\", \"`|`\", \"`if`\", \"`in`\"];\n                 match tok {\n                     TokenTree::Token(token) => match token.kind {\n@@ -1091,6 +1116,17 @@ fn is_in_follow(tok: &mbe::TokenTree, kind: NonterminalKind) -> IsInFollow {\n                     _ => IsInFollow::No(TOKENS),\n                 }\n             }\n+            NonterminalKind::PatWithOr { .. } => {\n+                const TOKENS: &[&str] = &[\"`=>`\", \"`,`\", \"`=`\", \"`if`\", \"`in`\"];\n+                match tok {\n+                    TokenTree::Token(token) => match token.kind {\n+                        FatArrow | Comma | Eq => IsInFollow::Yes,\n+                        Ident(name, false) if name == kw::If || name == kw::In => IsInFollow::Yes,\n+                        _ => IsInFollow::No(TOKENS),\n+                    },\n+                    _ => IsInFollow::No(TOKENS),\n+                }\n+            }\n             NonterminalKind::Path | NonterminalKind::Ty => {\n                 const TOKENS: &[&str] = &[\n                     \"`{`\", \"`[`\", \"`=>`\", \"`,`\", \"`>`\", \"`=`\", \"`:`\", \"`;`\", \"`|`\", \"`as`\","}, {"sha": "aca02ef93f8b5ab571578748c73bf532b3dc9597", "filename": "compiler/rustc_expand/src/mbe/quoted.rs", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -6,8 +6,8 @@ use rustc_ast::tokenstream;\n use rustc_ast::{NodeId, DUMMY_NODE_ID};\n use rustc_ast_pretty::pprust;\n use rustc_feature::Features;\n-use rustc_session::parse::{feature_err, ParseSess};\n-use rustc_span::symbol::{kw, sym, Ident};\n+use rustc_session::parse::ParseSess;\n+use rustc_span::symbol::{kw, Ident};\n \n use rustc_span::Span;\n \n@@ -62,21 +62,6 @@ pub(super) fn parse(\n                                 Some((frag, _)) => {\n                                     let span = token.span.with_lo(start_sp.lo());\n \n-                                    match frag.name {\n-                                        sym::pat2015 | sym::pat2021 => {\n-                                            if !features.edition_macro_pats {\n-                                                feature_err(\n-                                                    sess,\n-                                                    sym::edition_macro_pats,\n-                                                    frag.span,\n-                                                    \"`pat2015` and `pat2021` are unstable.\",\n-                                                )\n-                                                .emit();\n-                                            }\n-                                        }\n-                                        _ => {}\n-                                    }\n-\n                                     let kind =\n                                         token::NonterminalKind::from_symbol(frag.name, || {\n                                             span.edition()"}, {"sha": "f9e7c4254bc495b29b08898fa1b8018f0c34ca61", "filename": "compiler/rustc_expand/src/mbe/transcribe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -209,7 +209,7 @@ pub(super) fn transcribe<'a>(\n                             }\n                         } else {\n                             // 0 is the initial counter (we have done 0 repretitions so far). `len`\n-                            // is the total number of reptitions we should generate.\n+                            // is the total number of repetitions we should generate.\n                             repeats.push((0, len));\n \n                             // The first time we encounter the sequence we push it to the stack. It\n@@ -362,7 +362,7 @@ impl LockstepIterSize {\n /// appropriate meta-vars in `interpolations`.\n ///\n /// Note that if `repeats` does not match the exact correct depth of a meta-var,\n-/// `lookup_cur_matched` will return `None`, which is why this still works even in the presnece of\n+/// `lookup_cur_matched` will return `None`, which is why this still works even in the presence of\n /// multiple nested matcher sequences.\n fn lockstep_iter_size(\n     tree: &mbe::TokenTree,"}, {"sha": "4d777049f0d627614d9d322fa7b47d0f175c7753", "filename": "compiler/rustc_expand/src/module.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -36,8 +36,8 @@ crate struct ParsedExternalMod {\n pub enum ModError<'a> {\n     CircularInclusion(Vec<PathBuf>),\n     ModInBlock(Option<Ident>),\n-    FileNotFound(Ident, PathBuf),\n-    MultipleCandidates(Ident, String, String),\n+    FileNotFound(Ident, PathBuf, PathBuf),\n+    MultipleCandidates(Ident, PathBuf, PathBuf),\n     ParserError(DiagnosticBuilder<'a>),\n }\n \n@@ -219,10 +219,8 @@ pub fn default_submod_path<'a>(\n             file_path: secondary_path,\n             dir_ownership: DirOwnership::Owned { relative: None },\n         }),\n-        (false, false) => Err(ModError::FileNotFound(ident, default_path)),\n-        (true, true) => {\n-            Err(ModError::MultipleCandidates(ident, default_path_str, secondary_path_str))\n-        }\n+        (false, false) => Err(ModError::FileNotFound(ident, default_path, secondary_path)),\n+        (true, true) => Err(ModError::MultipleCandidates(ident, default_path, secondary_path)),\n     }\n }\n \n@@ -249,7 +247,7 @@ impl ModError<'_> {\n                 }\n                 err\n             }\n-            ModError::FileNotFound(ident, default_path) => {\n+            ModError::FileNotFound(ident, default_path, secondary_path) => {\n                 let mut err = struct_span_err!(\n                     diag,\n                     span,\n@@ -258,21 +256,22 @@ impl ModError<'_> {\n                     ident,\n                 );\n                 err.help(&format!(\n-                    \"to create the module `{}`, create file \\\"{}\\\"\",\n+                    \"to create the module `{}`, create file \\\"{}\\\" or \\\"{}\\\"\",\n                     ident,\n                     default_path.display(),\n+                    secondary_path.display(),\n                 ));\n                 err\n             }\n-            ModError::MultipleCandidates(ident, default_path_short, secondary_path_short) => {\n+            ModError::MultipleCandidates(ident, default_path, secondary_path) => {\n                 let mut err = struct_span_err!(\n                     diag,\n                     span,\n                     E0761,\n-                    \"file for module `{}` found at both {} and {}\",\n+                    \"file for module `{}` found at both \\\"{}\\\" and \\\"{}\\\"\",\n                     ident,\n-                    default_path_short,\n-                    secondary_path_short,\n+                    default_path.display(),\n+                    secondary_path.display(),\n                 );\n                 err.help(\"delete or rename one of them to remove the ambiguity\");\n                 err"}, {"sha": "494b3fb61ee970d38f1535c83dcd185f202beea1", "filename": "compiler/rustc_expand/src/proc_macro.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -9,12 +9,14 @@ use rustc_data_structures::sync::Lrc;\n use rustc_errors::ErrorReported;\n use rustc_parse::nt_to_tokenstream;\n use rustc_parse::parser::ForceCollect;\n+use rustc_span::def_id::CrateNum;\n use rustc_span::{Span, DUMMY_SP};\n \n const EXEC_STRATEGY: pm::bridge::server::SameThread = pm::bridge::server::SameThread;\n \n pub struct BangProcMacro {\n     pub client: pm::bridge::client::Client<fn(pm::TokenStream) -> pm::TokenStream>,\n+    pub krate: CrateNum,\n }\n \n impl base::ProcMacro for BangProcMacro {\n@@ -24,7 +26,7 @@ impl base::ProcMacro for BangProcMacro {\n         span: Span,\n         input: TokenStream,\n     ) -> Result<TokenStream, ErrorReported> {\n-        let server = proc_macro_server::Rustc::new(ecx);\n+        let server = proc_macro_server::Rustc::new(ecx, self.krate);\n         self.client.run(&EXEC_STRATEGY, server, input, ecx.ecfg.proc_macro_backtrace).map_err(|e| {\n             let mut err = ecx.struct_span_err(span, \"proc macro panicked\");\n             if let Some(s) = e.as_str() {\n@@ -38,6 +40,7 @@ impl base::ProcMacro for BangProcMacro {\n \n pub struct AttrProcMacro {\n     pub client: pm::bridge::client::Client<fn(pm::TokenStream, pm::TokenStream) -> pm::TokenStream>,\n+    pub krate: CrateNum,\n }\n \n impl base::AttrProcMacro for AttrProcMacro {\n@@ -48,7 +51,7 @@ impl base::AttrProcMacro for AttrProcMacro {\n         annotation: TokenStream,\n         annotated: TokenStream,\n     ) -> Result<TokenStream, ErrorReported> {\n-        let server = proc_macro_server::Rustc::new(ecx);\n+        let server = proc_macro_server::Rustc::new(ecx, self.krate);\n         self.client\n             .run(&EXEC_STRATEGY, server, annotation, annotated, ecx.ecfg.proc_macro_backtrace)\n             .map_err(|e| {\n@@ -64,6 +67,7 @@ impl base::AttrProcMacro for AttrProcMacro {\n \n pub struct ProcMacroDerive {\n     pub client: pm::bridge::client::Client<fn(pm::TokenStream) -> pm::TokenStream>,\n+    pub krate: CrateNum,\n }\n \n impl MultiItemModifier for ProcMacroDerive {\n@@ -94,10 +98,10 @@ impl MultiItemModifier for ProcMacroDerive {\n         {\n             TokenTree::token(token::Interpolated(Lrc::new(item)), DUMMY_SP).into()\n         } else {\n-            nt_to_tokenstream(&item, &ecx.sess.parse_sess, CanSynthesizeMissingTokens::Yes)\n+            nt_to_tokenstream(&item, &ecx.sess.parse_sess, CanSynthesizeMissingTokens::No)\n         };\n \n-        let server = proc_macro_server::Rustc::new(ecx);\n+        let server = proc_macro_server::Rustc::new(ecx, self.krate);\n         let stream =\n             match self.client.run(&EXEC_STRATEGY, server, input, ecx.ecfg.proc_macro_backtrace) {\n                 Ok(stream) => stream,"}, {"sha": "92315c4d4f6c7f02e5221c2805706fe8ba12d8b6", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 99, "deletions": 13, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -1,19 +1,20 @@\n-use crate::base::ExtCtxt;\n+use crate::base::{ExtCtxt, ResolverExpand};\n \n use rustc_ast as ast;\n-use rustc_ast::token;\n-use rustc_ast::token::Nonterminal;\n-use rustc_ast::token::NtIdent;\n+use rustc_ast::token::{self, Nonterminal, NtIdent, TokenKind};\n use rustc_ast::tokenstream::{self, CanSynthesizeMissingTokens};\n use rustc_ast::tokenstream::{DelimSpan, Spacing::*, TokenStream, TreeAndSpacing};\n use rustc_ast_pretty::pprust;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::Diagnostic;\n use rustc_lint_defs::builtin::PROC_MACRO_BACK_COMPAT;\n use rustc_lint_defs::BuiltinLintDiagnostics;\n use rustc_parse::lexer::nfc_normalize;\n use rustc_parse::{nt_to_tokenstream, parse_stream_from_source_str};\n use rustc_session::parse::ParseSess;\n+use rustc_span::def_id::CrateNum;\n+use rustc_span::hygiene::ExpnId;\n use rustc_span::hygiene::ExpnKind;\n use rustc_span::symbol::{self, kw, sym, Symbol};\n use rustc_span::{BytePos, FileName, MultiSpan, Pos, RealFileName, SourceFile, Span};\n@@ -355,22 +356,34 @@ pub struct Literal {\n }\n \n pub(crate) struct Rustc<'a> {\n+    resolver: &'a dyn ResolverExpand,\n     sess: &'a ParseSess,\n     def_site: Span,\n     call_site: Span,\n     mixed_site: Span,\n     span_debug: bool,\n+    krate: CrateNum,\n+    expn_id: ExpnId,\n+    rebased_spans: FxHashMap<usize, Span>,\n }\n \n impl<'a> Rustc<'a> {\n-    pub fn new(cx: &'a ExtCtxt<'_>) -> Self {\n+    pub fn new(cx: &'a ExtCtxt<'_>, krate: CrateNum) -> Self {\n         let expn_data = cx.current_expansion.id.expn_data();\n+        let def_site = cx.with_def_site_ctxt(expn_data.def_site);\n+        let call_site = cx.with_call_site_ctxt(expn_data.call_site);\n+        let mixed_site = cx.with_mixed_site_ctxt(expn_data.call_site);\n+        let sess = cx.parse_sess();\n         Rustc {\n-            sess: &cx.sess.parse_sess,\n-            def_site: cx.with_def_site_ctxt(expn_data.def_site),\n-            call_site: cx.with_call_site_ctxt(expn_data.call_site),\n-            mixed_site: cx.with_mixed_site_ctxt(expn_data.call_site),\n+            resolver: cx.resolver,\n+            sess,\n+            def_site,\n+            call_site,\n+            mixed_site,\n             span_debug: cx.ecfg.span_debug,\n+            krate,\n+            expn_id: cx.current_expansion.id,\n+            rebased_spans: FxHashMap::default(),\n         }\n     }\n \n@@ -526,6 +539,33 @@ impl server::Ident for Rustc<'_> {\n }\n \n impl server::Literal for Rustc<'_> {\n+    fn from_str(&mut self, s: &str) -> Result<Self::Literal, ()> {\n+        let override_span = None;\n+        let stream = parse_stream_from_source_str(\n+            FileName::proc_macro_source_code(s),\n+            s.to_owned(),\n+            self.sess,\n+            override_span,\n+        );\n+        if stream.len() != 1 {\n+            return Err(());\n+        }\n+        let tree = stream.into_trees().next().unwrap();\n+        let token = match tree {\n+            tokenstream::TokenTree::Token(token) => token,\n+            tokenstream::TokenTree::Delimited { .. } => return Err(()),\n+        };\n+        let span_data = token.span.data();\n+        if (span_data.hi.0 - span_data.lo.0) as usize != s.len() {\n+            // There is a comment or whitespace adjacent to the literal.\n+            return Err(());\n+        }\n+        let lit = match token.kind {\n+            TokenKind::Literal(lit) => lit,\n+            _ => return Err(()),\n+        };\n+        Ok(Literal { lit, span: self.call_site })\n+    }\n     fn debug_kind(&mut self, literal: &Self::Literal) -> String {\n         format!(\"{:?}\", literal.lit.kind)\n     }\n@@ -623,10 +663,11 @@ impl server::SourceFile for Rustc<'_> {\n         match file.name {\n             FileName::Real(ref name) => name\n                 .local_path()\n+                .expect(\"attempting to get a file path in an imported file in `proc_macro::SourceFile::path`\")\n                 .to_str()\n                 .expect(\"non-UTF8 file path in `proc_macro::SourceFile::path`\")\n                 .to_string(),\n-            _ => file.name.to_string(),\n+            _ => file.name.prefer_local().to_string(),\n         }\n     }\n     fn is_real(&mut self, file: &Self::SourceFile) -> bool {\n@@ -713,6 +754,51 @@ impl server::Span for Rustc<'_> {\n     fn source_text(&mut self, span: Self::Span) -> Option<String> {\n         self.sess.source_map().span_to_snippet(span).ok()\n     }\n+    /// Saves the provided span into the metadata of\n+    /// *the crate we are currently compiling*, which must\n+    /// be a proc-macro crate. This id can be passed to\n+    /// `recover_proc_macro_span` when our current crate\n+    /// is *run* as a proc-macro.\n+    ///\n+    /// Let's suppose that we have two crates - `my_client`\n+    /// and `my_proc_macro`. The `my_proc_macro` crate\n+    /// contains a procedural macro `my_macro`, which\n+    /// is implemented as: `quote! { \"hello\" }`\n+    ///\n+    /// When we *compile* `my_proc_macro`, we will execute\n+    /// the `quote` proc-macro. This will save the span of\n+    /// \"hello\" into the metadata of `my_proc_macro`. As a result,\n+    /// the body of `my_proc_macro` (after expansion) will end\n+    /// up containg a call that looks like this:\n+    /// `proc_macro::Ident::new(\"hello\", proc_macro::Span::recover_proc_macro_span(0))`\n+    ///\n+    /// where `0` is the id returned by this function.\n+    /// When `my_proc_macro` *executes* (during the compilation of `my_client`),\n+    /// the call to `recover_proc_macro_span` will load the corresponding\n+    /// span from the metadata of `my_proc_macro` (which we have access to,\n+    /// since we've loaded `my_proc_macro` from disk in order to execute it).\n+    /// In this way, we have obtained a span pointing into `my_proc_macro`\n+    fn save_span(&mut self, mut span: Self::Span) -> usize {\n+        // Throw away the `SyntaxContext`, since we currently\n+        // skip serializing `SyntaxContext`s for proc-macro crates\n+        span = span.with_ctxt(rustc_span::SyntaxContext::root());\n+        self.sess.save_proc_macro_span(span)\n+    }\n+    fn recover_proc_macro_span(&mut self, id: usize) -> Self::Span {\n+        let resolver = self.resolver;\n+        let krate = self.krate;\n+        let expn_id = self.expn_id;\n+        *self.rebased_spans.entry(id).or_insert_with(|| {\n+            let raw_span = resolver.get_proc_macro_quoted_span(krate, id);\n+            // Ignore the deserialized `SyntaxContext` entirely.\n+            // FIXME: Preserve the macro backtrace from the serialized span\n+            // For example, if a proc-macro crate has code like\n+            // `macro_one!() -> macro_two!() -> quote!()`, we might\n+            // want to 'concatenate' this backtrace with the backtrace from\n+            // our current call site.\n+            raw_span.with_def_site_ctxt(expn_id)\n+        })\n+    }\n }\n \n // See issue #74616 for details\n@@ -722,10 +808,10 @@ fn ident_name_compatibility_hack(\n     rustc: &mut Rustc<'_>,\n ) -> Option<(rustc_span::symbol::Ident, bool)> {\n     if let NtIdent(ident, is_raw) = nt {\n-        if let ExpnKind::Macro(_, macro_name) = orig_span.ctxt().outer_expn_data().kind {\n+        if let ExpnKind::Macro { name: macro_name, .. } = orig_span.ctxt().outer_expn_data().kind {\n             let source_map = rustc.sess.source_map();\n             let filename = source_map.span_to_filename(orig_span);\n-            if let FileName::Real(RealFileName::Named(path)) = filename {\n+            if let FileName::Real(RealFileName::LocalPath(path)) = filename {\n                 let matches_prefix = |prefix, filename| {\n                     // Check for a path that ends with 'prefix*/src/<filename>'\n                     let mut iter = path.components().rev();\n@@ -788,7 +874,7 @@ fn ident_name_compatibility_hack(\n                 if macro_name == sym::tuple_from_req && matches_prefix(\"actix-web\", \"extract.rs\") {\n                     let snippet = source_map.span_to_snippet(orig_span);\n                     if snippet.as_deref() == Ok(\"$T\") {\n-                        if let FileName::Real(RealFileName::Named(macro_path)) =\n+                        if let FileName::Real(RealFileName::LocalPath(macro_path)) =\n                             source_map.span_to_filename(rustc.def_site)\n                         {\n                             if macro_path.to_string_lossy().contains(\"pin-project-internal-0.\") {"}, {"sha": "8b546e7e4a343a1bb39fe177457bd85459ca8fd6", "filename": "compiler/rustc_expand/src/tokenstream/tests.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_expand%2Fsrc%2Ftokenstream%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_expand%2Fsrc%2Ftokenstream%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Ftokenstream%2Ftests.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -1,7 +1,7 @@\n use crate::tests::string_to_stream;\n \n use rustc_ast::token;\n-use rustc_ast::tokenstream::{TokenStream, TokenStreamBuilder, TokenTree};\n+use rustc_ast::tokenstream::{Spacing, TokenStream, TokenStreamBuilder, TokenTree};\n use rustc_span::with_default_session_globals;\n use rustc_span::{BytePos, Span, Symbol};\n use smallvec::smallvec;\n@@ -14,6 +14,10 @@ fn sp(a: u32, b: u32) -> Span {\n     Span::with_root_ctxt(BytePos(a), BytePos(b))\n }\n \n+fn joint(tree: TokenTree) -> TokenStream {\n+    TokenStream::new(vec![(tree, Spacing::Joint)])\n+}\n+\n #[test]\n fn test_concat() {\n     with_default_session_globals(|| {\n@@ -99,8 +103,8 @@ fn test_is_empty() {\n fn test_dotdotdot() {\n     with_default_session_globals(|| {\n         let mut builder = TokenStreamBuilder::new();\n-        builder.push(TokenTree::token(token::Dot, sp(0, 1)).joint());\n-        builder.push(TokenTree::token(token::Dot, sp(1, 2)).joint());\n+        builder.push(joint(TokenTree::token(token::Dot, sp(0, 1))));\n+        builder.push(joint(TokenTree::token(token::Dot, sp(1, 2))));\n         builder.push(TokenTree::token(token::Dot, sp(2, 3)));\n         let stream = builder.build();\n         assert!(stream.eq_unspanned(&string_to_ts(\"...\")));"}, {"sha": "945406aed4bb0b1788726710838deb96d2e40eb8", "filename": "compiler/rustc_feature/src/accepted.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -276,9 +276,15 @@ declare_features! (\n     /// The smallest useful subset of `const_generics`.\n     (accepted, min_const_generics, \"1.51.0\", Some(74878), None),\n     /// The `unsafe_op_in_unsafe_fn` lint (allowed by default): no longer treat an unsafe function as an unsafe block.\n-    (accepted, unsafe_block_in_unsafe_fn, \"1.51.0\", Some(71668), None),\n+    (accepted, unsafe_block_in_unsafe_fn, \"1.52.0\", Some(71668), None),\n     /// Allows the use of or-patterns (e.g., `0 | 1`).\n     (accepted, or_patterns, \"1.53.0\", Some(54883), None),\n+    /// Allows defining identifiers beyond ASCII.\n+    (accepted, non_ascii_idents, \"1.53.0\", Some(55467), None),\n+    /// Allows arbitrary expressions in key-value attributes at parse time.\n+    (accepted, extended_key_value_attributes, \"1.54.0\", Some(78835), None),\n+    /// Allows unsizing coercions in `const fn`.\n+    (accepted, const_fn_unsize, \"1.54.0\", Some(64992), None),\n \n     // -------------------------------------------------------------------------\n     // feature-group-end: accepted features"}, {"sha": "ac1974eb4c690e76050e5aec7a2d2ff321caa60a", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 50, "deletions": 25, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b", "patch": "@@ -63,6 +63,10 @@ macro_rules! declare_features {\n                     _ => panic!(\"`{}` was not listed in `declare_features`\", feature),\n                 }\n             }\n+\n+            pub fn unordered_const_ty_params(&self) -> bool {\n+                self.const_generics || self.const_generics_defaults\n+            }\n         }\n     };\n }\n@@ -134,9 +138,6 @@ declare_features! (\n     /// Allows using the `box $expr` syntax.\n     (active, box_syntax, \"1.0.0\", Some(49733), None),\n \n-    /// Allows using `#[main]` to replace the entrypoint `#[lang = \"start\"]` calls.\n-    (active, main, \"1.0.0\", Some(29634), None),\n-\n     /// Allows using `#[start]` on a function indicating that it is the program entrypoint.\n     (active, start, \"1.0.0\", Some(29633), None),\n \n@@ -216,6 +217,10 @@ declare_features! (\n     /// Renamed from `optin_builtin_traits`.\n     (active, auto_traits, \"1.50.0\", Some(13231), None),\n \n+    /// Allows `#[doc(notable_trait)]`.\n+    /// Renamed from `doc_spotlight`.\n+    (active, doc_notable_trait, \"1.52.0\", Some(45040), None),\n+\n     // no-tracking-issue-end\n \n     // -------------------------------------------------------------------------\n@@ -254,12 +259,6 @@ declare_features! (\n     // feature-group-start: actual feature gates\n     // -------------------------------------------------------------------------\n \n-    /// Allows using the `#[link_args]` attribute.\n-    (active, link_args, \"1.0.0\", Some(29596), None),\n-\n-    /// Allows defining identifiers beyond ASCII.\n-    (active, non_ascii_idents, \"1.0.0\", Some(55467), None),\n-\n     /// Allows using `#[plugin_registrar]` on functions.\n     (active, plugin_registrar, \"1.0.0\", Some(29597), None),\n \n@@ -275,9 +274,6 @@ declare_features! (\n     /// Allows using non lexical lifetimes (RFC 2094).\n     (active, nll, \"1.0.0\", Some(43234), None),\n \n-    /// Allows the definition of `const` functions with some advanced features.\n-    (active, const_fn, \"1.2.0\", Some(57563), None),\n-\n     /// Allows associated type defaults.\n     (active, associated_type_defaults, \"1.2.0\", Some(29661), None),\n \n@@ -374,9 +370,6 @@ declare_features! (\n     /// Allows `#[doc(masked)]`.\n     (active, doc_masked, \"1.21.0\", Some(44027), None),\n \n-    /// Allows `#[doc(spotlight)]`.\n-    (active, doc_spotlight, \"1.22.0\", Some(45040), None),\n-\n     /// Allows `#[doc(include = \"some-file\")]`.\n     (active, external_doc, \"1.22.0\", Some(44732), None),\n \n@@ -608,12 +601,6 @@ declare_features! (\n     /// Allows capturing disjoint fields in a closure/generator (RFC 2229).\n     (active, capture_disjoint_fields, \"1.49.0\", Some(53488), None),\n \n-    /// Allows arbitrary expressions in key-value attributes at parse time.\n-    (active, extended_key_value_attributes, \"1.50.0\", Some(78835), None),\n-\n-    /// `:pat2015` and `:pat2021` macro matchers.\n-    (active, edition_macro_pats, \"1.51.0\", Some(54883), None),\n-\n     /// Allows const generics to have default values (e.g. `struct Foo<const N: usize = 3>(...);`).\n     (active, const_generics_defaults, \"1.51.0\", Some(44580), None),\n \n@@ -632,18 +619,55 @@ declare_features! (\n     /// Allows macro attributes to observe output of `#[derive]`.\n     (active, macro_attributes_in_derive_output, \"1.51.0\", Some(81119), None),\n \n-    /// Allows `pub` on `macro_rules` items.\n-    (active, pub_macro_rules, \"1.52.0\", Some(78855), None),\n-\n     /// Allows the use of type alias impl trait in function return positions\n     (active, min_type_alias_impl_trait, \"1.52.0\", Some(63063), None),\n \n     /// Allows associated types in inherent impls.\n     (active, inherent_associated_types, \"1.52.0\", Some(8995), None),\n \n+    // Allows setting the threshold for the `large_assignments` lint.\n+    (active, large_assignments, \"1.52.0\", Some(83518), None),\n+\n     /// Allows `extern \"C-unwind\" fn` to enable unwinding across ABI boundaries.\n     (active, c_unwind, \"1.52.0\", Some(74990), None),\n \n+    /// Allows using `#[repr(align(...))]` on function items\n+    (active, fn_align, \"1.53.0\", Some(82232), None),\n+\n+    /// Allows `extern \"wasm\" fn`\n+    (active, wasm_abi, \"1.53.0\", Some(83788), None),\n+\n+    /// Allows function attribute `#[no_coverage]`, to bypass coverage\n+    /// instrumentation of that function.\n+    (active, no_coverage, \"1.53.0\", Some(84605), None),\n+\n+    /// Allows trait bounds in `const fn`.\n+    (active, const_fn_trait_bound, \"1.53.0\", Some(57563), None),\n+\n+    /// Allows `async {}` expressions in const contexts.\n+    (active, const_async_blocks, \"1.53.0\", Some(85368), None),\n+\n+    /// Allows using imported `main` function\n+    (active, imported_main, \"1.53.0\", Some(28937), None),\n+\n+    /// Allows specifying modifiers in the link attribute: `#[link(modifiers = \"...\")]`\n+    (active, native_link_modifiers, \"1.53.0\", Some(81490), None),\n+\n+    /// Allows specifying the bundle link modifier\n+    (active, native_link_modifiers_bundle, \"1.53.0\", Some(81490), None),\n+\n+    /// Allows specifying the verbatim link modifier\n+    (active, native_link_modifiers_verbatim, \"1.53.0\", Some(81490), None),\n+\n+    /// Allows specifying the whole-archive link modifier\n+    (active, native_link_modifiers_whole_archive, \"1.53.0\", Some(81490), None),\n+\n+    /// Allows specifying the as-needed link modifier\n+    (active, native_link_modifiers_as_needed, \"1.53.0\", Some(81490), None),\n+\n+    /// Allows unnamed fields of struct and union type\n+    (active, unnamed_fields, \"1.53.0\", Some(49804), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------\n@@ -668,9 +692,10 @@ pub const INCOMPLETE_FEATURES: &[Symbol] = &[\n     sym::repr128,\n     sym::unsized_locals,\n     sym::capture_disjoint_fields,\n-    sym::const_generics_defaults,\n     sym::inherent_associated_types,\n     sym::type_alias_impl_trait,\n+    sym::rustc_insignificant_dtor,\n+    sym::unnamed_fields,\n ];\n \n /// Some features are not allowed to be used together at the same time, if"}, {"sha": "e7e128f8a9b21e23bdbc4f74874e6462c9bcf6e2", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "654d2408580fe932e23195dd659267b4d9e50860", "filename": "compiler/rustc_feature/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_feature%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_feature%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Flib.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "138398825af586123ec3c59e07c4fdd96f556113", "filename": "compiler/rustc_feature/src/removed.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "db70beb59141b52682b0bbe9b3caa154472768bb", "filename": "compiler/rustc_graphviz/src/lib.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "a297bac86c410406c116d5679130ff033a3df6b1", "filename": "compiler/rustc_graphviz/src/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_graphviz%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_graphviz%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_graphviz%2Fsrc%2Ftests.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "b05ca381b8ab6e9263be40f01a2e17fa2258073c", "filename": "compiler/rustc_hir/src/arena.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_hir%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_hir%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Farena.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "de10d88c1d250b8e6e6462a2e3fc0b8e2b3b96c6", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 142, "deletions": 13, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "647d735fb86326c09657b5a4261cfb1c2a5e60c3", "filename": "compiler/rustc_hir/src/definitions.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "91fd97a0d4020150e23f8ecdca355c43d8957ad8", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 30, "deletions": 55, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "0b25ebc27bd3f9d671432daa8da9548b0a5633ae", "filename": "compiler/rustc_hir/src/hir_id.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "c08f1f53218d625c6062bbe39caf7a89186a1490", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "0b8535f8ca54968d13e37c91d127cf86fb591dd5", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "6a12c917436222a93977f3d27fb4f894c4dc920a", "filename": "compiler/rustc_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flib.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "b1f78a83e7407a01451ee175414f5fcafacc78e2", "filename": "compiler/rustc_hir/src/pat_util.rs", "status": "modified", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "0232654aaa5242c72ad8e2211f93ad6414ee6f3f", "filename": "compiler/rustc_hir/src/stable_hash_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "58c3065240c9495770ebb6d6cf9d7cfc48f78930", "filename": "compiler/rustc_hir/src/weak_lang_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_hir%2Fsrc%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_hir%2Fsrc%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fweak_lang_items.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "2b932b7c9537ee51a7cb1d007719463707e98150", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 132, "deletions": 142, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "b5680beae142d503f6afef41bc540a6b0926e4f4", "filename": "compiler/rustc_incremental/src/assert_dep_graph.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "8220eb6c6570f5bfbe29df85a1dd35907e6579f5", "filename": "compiler/rustc_incremental/src/assert_module_sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "f089cbcfca6e5f150a2bdc40776eb3ab0d1bbc6f", "filename": "compiler/rustc_incremental/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_incremental%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_incremental%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Flib.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "e7bd488af8ebf69cbd654ce5c4a0baa78b488099", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 2, "deletions": 38, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "30c6c408bc7c00f033a830945c6abf7f360e4e58", "filename": "compiler/rustc_incremental/src/persist/fs.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "bd3b5239f7bda7245735a1ccd3ea7a7539ceb169", "filename": "compiler/rustc_incremental/src/persist/load.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "1336189bc0d26118586dcf1f891d2798c95f2005", "filename": "compiler/rustc_incremental/src/persist/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fmod.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "1484088837a4be1cf03c61a5e8fc9bbb46b2c54e", "filename": "compiler/rustc_incremental/src/persist/save.rs", "status": "modified", "additions": 82, "deletions": 23, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "4b1f0b86475a28469d453ba201f48743d3ddc40e", "filename": "compiler/rustc_index/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_index%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_index%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2FCargo.toml?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "df777502c44a4a6d922e4a78f9084439339df920", "filename": "compiler/rustc_index/src/bit_set.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "4c73b7bf612c7c07f9ca7de161f7b4f2ffe11577", "filename": "compiler/rustc_index/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_index%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_index%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Flib.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "1b1a59a254e6fbd0bfb41e745037e49cb667babf", "filename": "compiler/rustc_index/src/vec.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fvec.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "c68705da413f829401cb03eb7b78d9346d04a16c", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "b8ecc949588fb0658d3e79b7c416018d220773c1", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "553a11d4393f94ba0f3e1e14fdd1e8463745265a", "filename": "compiler/rustc_infer/src/infer/canonical/substitute.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "30214e94203d81d078d413709ea2365f8b8487fa", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "45ba50bb6349cc9d177d81f6534601508bebdf87", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "680f6af63f26c6528bdf9dacb62f58ac88de2c5a", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "d9a1193aac4bafc0f02516e3480ea48a2f1dd3c1", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "58eb1e9aa12cb0aa4e61980155ace21c0ca33b8b", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "0878f8550da35a6a3d7abf830039bbc4943124ad", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "02662043dba798088284696de403c25f30476984", "filename": "compiler/rustc_infer/src/infer/glb.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "d460222df8ad0f82508f7ae52cdd6fa9f63c029d", "filename": "compiler/rustc_infer/src/infer/higher_ranked/mod.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "4fa8f2f1a6a426c82ec5bb6f9348a54a2e23f164", "filename": "compiler/rustc_infer/src/infer/lub.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "f39431f2494b1868f53c19f58ff893eb0c93a614", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "077d2cc20a25c3fdaf7bc8f20c4325f024baf5d1", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "9e04773c5fa2056c9bb4865d9051e938b5a0f86b", "filename": "compiler/rustc_infer/src/infer/outlives/env.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "3e2978fd170aea36526f911f1faa6486dc38a1cf", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "4935913016262bbabe29e320bba3c5072e77747b", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 42, "deletions": 56, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "48b8ee17594e3bd10708b88b8978a2417fb75572", "filename": "compiler/rustc_infer/src/infer/resolve.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "bf5f328233dfd7832ba421924214d53fec58df8d", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "683c1df783e63e2d85e1cb4126755bfb6f43484e", "filename": "compiler/rustc_infer/src/infer/type_variable.rs", "status": "modified", "additions": 2, "deletions": 54, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "5ad2519a93c5f04a256a414c17e8ca9cba99c1d0", "filename": "compiler/rustc_infer/src/infer/undo_log.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "f3e5830c1982d570d3b0b17a6980dc8124341482", "filename": "compiler/rustc_infer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Flib.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "a33234a91faff47333f0c07dd49e7e7398d5ab52", "filename": "compiler/rustc_infer/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "1cde4802a40b00e67a6beca539603033dca99f91", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "194464dd0bf9c974c76392cd03c100569d9eebfb", "filename": "compiler/rustc_interface/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2FCargo.toml?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "3b852b8ccf9d0ffffb47e80769ac77abe64113da", "filename": "compiler/rustc_interface/src/callbacks.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_interface%2Fsrc%2Fcallbacks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_interface%2Fsrc%2Fcallbacks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fcallbacks.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "70ffff1ab99809f522bb4289788706acc71d63ba", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 31, "deletions": 42, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "88cf6275ebbd07ff72a4c0b8f42351c456462bed", "filename": "compiler/rustc_interface/src/proc_macro_decls.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "92d05e4806871e5e50be8113c761697f2d313a84", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "bea7d0fb81f95d924292e977b1345d5e2a491637", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 234, "deletions": 91, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "7b1660b501bf85cec7027b9cd1984c0b79b34e4a", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "b9781581ff75d2507b46bbd88c0a92bd4499f202", "filename": "compiler/rustc_lexer/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Flib.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "e7275374b8915f39bb1976d30f649fc298ff8b97", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 155, "deletions": 36, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "c1d6a4f1de1ffa4789e366d57de329e711b81dde", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "eb2e495f73d3c31a5392afe7ed590b802129c0fc", "filename": "compiler/rustc_lint/src/early.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fearly.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "0398d4a99618a9fe1498bea256be428c69956945", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "e504662bb5eae73ebb3069bd47da4f37c85e6f13", "filename": "compiler/rustc_lint/src/late.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flate.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "91cdef9b089fa7544b31c255378049d140a467ff", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 45, "deletions": 55, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "45ed6872f1885edcc4b7a4083b372c6f654239ec", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "301e607fc58ada7bb586eafb47bdb994895224bc", "filename": "compiler/rustc_lint/src/non_ascii_idents.rs", "status": "modified", "additions": 9, "deletions": 28, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "c91dc37b374f861d221f149d5b7badd552333dce", "filename": "compiler/rustc_lint/src/non_fmt_panic.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "15246971bae02e82175430a15b2b5f92a65ba82f", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 117, "deletions": 14, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "70475563a4abe4921881c11bfe2f5ace6428c0a0", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "7a34788de91a766a67a9c93c3cbce9c676eb2ca0", "filename": "compiler/rustc_llvm/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2FCargo.toml?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "3595e37cf96255253f8916c2ce91f24f3ad1a7c9", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 62, "deletions": 24, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "2e135fbe2bd8fe7b271c496288c66c730565faf4", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "29fa0b7006992acf4d7b6295075ced47a07575fb", "filename": "compiler/rustc_metadata/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2FCargo.toml?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "e9ae22f8cedbc47926fd0ed4aa39e9ae0469fa10", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 39, "deletions": 5, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "1a900ccbf65faeed61a07c03f4e26755eee44eeb", "filename": "compiler/rustc_metadata/src/dynamic_lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_metadata%2Fsrc%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_metadata%2Fsrc%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fdynamic_lib.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "15c9eda9902c412d842dd3f874a9da077d2f5b87", "filename": "compiler/rustc_metadata/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flib.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "9e1ac33368c7fdad810b923f1455f56feebe34f9", "filename": "compiler/rustc_metadata/src/link_args.rs", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/3b2b5b2914d40aa011d189bfe546084cdee53dbe/compiler%2Frustc_metadata%2Fsrc%2Flink_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b2b5b2914d40aa011d189bfe546084cdee53dbe/compiler%2Frustc_metadata%2Fsrc%2Flink_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flink_args.rs?ref=3b2b5b2914d40aa011d189bfe546084cdee53dbe"}, {"sha": "6e7360950908e9dbd164ff0c7f7ecfebb93f4b91", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 37, "deletions": 19, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "bc342119efb991caee85c946c82fa7c9f5331a41", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 100, "deletions": 22, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "b27eef376c49e6f7a5e714d6512e4e41d3ee9758", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 79, "deletions": 31, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "e25b22c83317433bf3d1f9186d56a78828991708", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 36, "deletions": 42, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "0c31430598a98d73e3dcc6e0a9bcd914299bae91", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 92, "deletions": 63, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "04fe5cf5890a00ad24d46855137195fc01f18efa", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "a89d00e26ac192c4a175aec0f0e3dd7881747187", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "8476929eaeced2b1d230e5e6f6d964e2e7d2a088", "filename": "compiler/rustc_middle/src/dep_graph/dep_node.rs", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "31bea8329587d7469350bd4bc8c550f2a9fbf029", "filename": "compiler/rustc_middle/src/dep_graph/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "342cc9a7397b7cbb44231448b883b3f2fbba2787", "filename": "compiler/rustc_middle/src/hir/map/collector.rs", "status": "modified", "additions": 47, "deletions": 94, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "d154b7804f052afa3f8fb02571a3a420f4e64269", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 199, "deletions": 166, "changes": 365, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "879372c65eaa1c8bf68430c38ebd1991e5858b0b", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "b2fef731b7e2059f8bcde6c5d3db8053f71400d4", "filename": "compiler/rustc_middle/src/ich/hcx.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_middle%2Fsrc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_middle%2Fsrc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fich%2Fhcx.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "2d8f661ef59e92d233000ff1dd2358221fb242c1", "filename": "compiler/rustc_middle/src/ich/impls_syntax.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_syntax.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "8e53e4ba948058bdd4351b7a93227ddf27aea74a", "filename": "compiler/rustc_middle/src/ich/impls_ty.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_ty.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "5df2f91f09fff253a70b0179873d7a35631dd988", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}, {"sha": "0b05dd5c0ba6f139c4eef5c0557628c8fa253228", "filename": "compiler/rustc_middle/src/infer/unify_key.rs", "status": "modified", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac658e106653a5aa048eec158b66c9e0485b952b/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs?ref=ac658e106653a5aa048eec158b66c9e0485b952b"}]}