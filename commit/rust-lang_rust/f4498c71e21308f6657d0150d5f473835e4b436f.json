{"sha": "f4498c71e21308f6657d0150d5f473835e4b436f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0NDk4YzcxZTIxMzA4ZjY2NTdkMDE1MGQ1ZjQ3MzgzNWU0YjQzNmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-18T01:56:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-18T01:56:41Z"}, "message": "auto merge of #11497 : huonw/rust/trie-internal-iter, r=alexcrichton\n\nThis stores the stack of iterators inline (we have a maximum depth with\r\n`uint` keys), and then uses direct pointer offsetting to manipulate it,\r\nin a blazing fast way:\r\n\r\nBefore:\r\n\r\n    bench_iter_large          ... bench:     43187 ns/iter (+/- 3082)\r\n    bench_iter_small          ... bench:       618 ns/iter (+/- 288)\r\n\r\nAfter:\r\n\r\n    bench_iter_large          ... bench:     13497 ns/iter (+/- 1575)\r\n    bench_iter_small          ... bench:       220 ns/iter (+/- 91)\r\n\r\nAlso, removes `.each_{key,value}_reverse` as an offering to\r\nplacate the gods of external iterators for my heinous sin of \r\nattempting to add new internal ones (in a previous version of this\r\nPR).", "tree": {"sha": "056558abc445547eae39e2aa143a92f131138f03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/056558abc445547eae39e2aa143a92f131138f03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4498c71e21308f6657d0150d5f473835e4b436f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4498c71e21308f6657d0150d5f473835e4b436f", "html_url": "https://github.com/rust-lang/rust/commit/f4498c71e21308f6657d0150d5f473835e4b436f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4498c71e21308f6657d0150d5f473835e4b436f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ff358c062e9f4c31e0e34d0cd9179a9af363867", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ff358c062e9f4c31e0e34d0cd9179a9af363867", "html_url": "https://github.com/rust-lang/rust/commit/2ff358c062e9f4c31e0e34d0cd9179a9af363867"}, {"sha": "0148055a56953a747362acb78efc8f0865fccc54", "url": "https://api.github.com/repos/rust-lang/rust/commits/0148055a56953a747362acb78efc8f0865fccc54", "html_url": "https://github.com/rust-lang/rust/commit/0148055a56953a747362acb78efc8f0865fccc54"}], "stats": {"total": 171, "additions": 119, "deletions": 52}, "files": [{"sha": "b48edc72871b38c26ed4f742d544dc33e87dd5c3", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 119, "deletions": 52, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/f4498c71e21308f6657d0150d5f473835e4b436f/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4498c71e21308f6657d0150d5f473835e4b436f/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=f4498c71e21308f6657d0150d5f473835e4b436f", "patch": "@@ -11,14 +11,17 @@\n //! Ordered containers with integer keys, implemented as radix tries (`TrieSet` and `TrieMap` types)\n \n use prelude::*;\n+use mem;\n use uint;\n use util::replace;\n+use unstable::intrinsics::init;\n use vec;\n \n // FIXME: #5244: need to manually update the TrieNode constructor\n static SHIFT: uint = 4;\n static SIZE: uint = 1 << SHIFT;\n static MASK: uint = SIZE - 1;\n+static NUM_CHUNKS: uint = uint::bits / SHIFT;\n \n enum Child<T> {\n     Internal(~TrieNode<T>),\n@@ -111,35 +114,27 @@ impl<T> TrieMap<T> {\n         self.root.each_reverse(f)\n     }\n \n-    /// Visit all keys in reverse order\n-    #[inline]\n-    pub fn each_key_reverse(&self, f: |&uint| -> bool) -> bool {\n-        self.each_reverse(|k, _| f(k))\n-    }\n-\n-    /// Visit all values in reverse order\n-    #[inline]\n-    pub fn each_value_reverse(&self, f: |&T| -> bool) -> bool {\n-        self.each_reverse(|_, v| f(v))\n-    }\n-\n     /// Get an iterator over the key-value pairs in the map\n     pub fn iter<'a>(&'a self) -> TrieMapIterator<'a, T> {\n-        TrieMapIterator {\n-            stack: ~[self.root.children.iter()],\n-            remaining_min: self.length,\n-            remaining_max: self.length\n-        }\n+        let mut iter = unsafe {TrieMapIterator::new()};\n+        iter.stack[0] = self.root.children.iter();\n+        iter.length = 1;\n+        iter.remaining_min = self.length;\n+        iter.remaining_max = self.length;\n+\n+        iter\n     }\n \n     /// Get an iterator over the key-value pairs in the map, with the\n     /// ability to mutate the values.\n     pub fn mut_iter<'a>(&'a mut self) -> TrieMapMutIterator<'a, T> {\n-        TrieMapMutIterator {\n-            stack: ~[self.root.children.mut_iter()],\n-            remaining_min: self.length,\n-            remaining_max: self.length\n-        }\n+        let mut iter = unsafe {TrieMapMutIterator::new()};\n+        iter.stack[0] = self.root.children.mut_iter();\n+        iter.length = 1;\n+        iter.remaining_min = self.length;\n+        iter.remaining_max = self.length;\n+\n+        iter\n     }\n }\n \n@@ -188,16 +183,16 @@ macro_rules! bound {\n \n             let key = $key;\n \n-            let mut idx = 0;\n-            let mut it = $iterator_name {\n-                stack: ~[],\n-                remaining_min: 0,\n-                remaining_max: this.length\n-            };\n+            let mut it = unsafe {$iterator_name::new()};\n+            // everything else is zero'd, as we want.\n+            it.remaining_max = this.length;\n+\n             // this addr is necessary for the `Internal` pattern.\n             addr!(loop {\n                     let children = unsafe {addr!(& $($mut_)* (*node).children)};\n-                    let child_id = chunk(key, idx);\n+                    // it.length is the current depth in the iterator and the\n+                    // current depth through the `uint` key we've traversed.\n+                    let child_id = chunk(key, it.length);\n                     let (slice_idx, ret) = match children[child_id] {\n                         Internal(ref $($mut_)* n) => {\n                             node = addr!(& $($mut_)* **n as * $($mut_)* TrieNode<T>);\n@@ -214,9 +209,10 @@ macro_rules! bound {\n                             (child_id + 1, true)\n                         }\n                     };\n-                    it.stack.push(children.$slice_from(slice_idx).$iter());\n+                    // push to the stack.\n+                    it.stack[it.length] = children.$slice_from(slice_idx).$iter();\n+                    it.length += 1;\n                     if ret { return it }\n-                    idx += 1;\n                 })\n         }\n     }\n@@ -328,7 +324,7 @@ impl TrieSet {\n     /// Visit all values in reverse order\n     #[inline]\n     pub fn each_reverse(&self, f: |&uint| -> bool) -> bool {\n-        self.map.each_key_reverse(f)\n+        self.map.each_reverse(|k, _| f(k))\n     }\n \n     /// Get an iterator over the values in the set\n@@ -479,15 +475,17 @@ fn remove<T>(count: &mut uint, child: &mut Child<T>, key: uint,\n \n /// Forward iterator over a map\n pub struct TrieMapIterator<'a, T> {\n-    priv stack: ~[vec::VecIterator<'a, Child<T>>],\n+    priv stack: [vec::VecIterator<'a, Child<T>>, .. NUM_CHUNKS],\n+    priv length: uint,\n     priv remaining_min: uint,\n     priv remaining_max: uint\n }\n \n /// Forward iterator over the key-value pairs of a map, with the\n /// values being mutable.\n pub struct TrieMapMutIterator<'a, T> {\n-    priv stack: ~[vec::VecMutIterator<'a, Child<T>>],\n+    priv stack: [vec::VecMutIterator<'a, Child<T>>, .. NUM_CHUNKS],\n+    priv length: uint,\n     priv remaining_min: uint,\n     priv remaining_max: uint\n }\n@@ -499,27 +497,96 @@ macro_rules! iterator_impl {\n     ($name:ident,\n      iter = $iter:ident,\n      mutability = $($mut_:tt)*) => {\n+        impl<'a, T> $name<'a, T> {\n+            // Create new zero'd iterator. We have a thin gilding of safety by\n+            // using init rather than uninit, so that the worst that can happen\n+            // from failing to initialise correctly after calling these is a\n+            // segfault.\n+            #[cfg(target_word_size=\"32\")]\n+            unsafe fn new() -> $name<'a, T> {\n+                $name {\n+                    remaining_min: 0,\n+                    remaining_max: 0,\n+                    length: 0,\n+                    // ick :( ... at least the compiler will tell us if we screwed up.\n+                    stack: [init(), init(), init(), init(), init(), init(), init(), init()]\n+                }\n+            }\n+\n+            #[cfg(target_word_size=\"64\")]\n+            unsafe fn new() -> $name<'a, T> {\n+                $name {\n+                    remaining_min: 0,\n+                    remaining_max: 0,\n+                    length: 0,\n+                    stack: [init(), init(), init(), init(), init(), init(), init(), init(),\n+                            init(), init(), init(), init(), init(), init(), init(), init()]\n+                }\n+            }\n+        }\n+\n         item!(impl<'a, T> Iterator<(uint, &'a $($mut_)* T)> for $name<'a, T> {\n+                // you might wonder why we're not even trying to act within the\n+                // rules, and are just manipulating raw pointers like there's no\n+                // such thing as invalid pointers and memory unsafety. The\n+                // reason is performance, without doing this we can get the\n+                // bench_iter_large microbenchmark down to about 30000 ns/iter\n+                // (using .unsafe_ref to index self.stack directly, 38000\n+                // ns/iter with [] checked indexing), but this smashes that down\n+                // to 13500 ns/iter.\n+                //\n+                // Fortunately, it's still safe...\n+                //\n+                // We have an invariant that every Internal node\n+                // corresponds to one push to self.stack, and one pop,\n+                // nested appropriately. self.stack has enough storage\n+                // to store the maximum depth of Internal nodes in the\n+                // trie (8 on 32-bit platforms, 16 on 64-bit).\n                 fn next(&mut self) -> Option<(uint, &'a $($mut_)* T)> {\n-                    while !self.stack.is_empty() {\n-                        match self.stack[self.stack.len() - 1].next() {\n-                            None => {\n-                                self.stack.pop();\n-                            }\n-                            Some(child) => {\n-                                addr!(match *child {\n-                                        Internal(ref $($mut_)* node) => {\n-                                            self.stack.push(node.children.$iter());\n-                                        }\n-                                        External(key, ref $($mut_)* value) => {\n-                                            self.remaining_max -= 1;\n-                                            if self.remaining_min > 0 {\n-                                                self.remaining_min -= 1;\n+                    let start_ptr = self.stack.as_mut_ptr();\n+\n+                    unsafe {\n+                        // write_ptr is the next place to write to the stack.\n+                        // invariant: start_ptr <= write_ptr < end of the\n+                        // vector.\n+                        let mut write_ptr = start_ptr.offset(self.length as int);\n+                        while write_ptr != start_ptr {\n+                            // indexing back one is safe, since write_ptr >\n+                            // start_ptr now.\n+                            match (*write_ptr.offset(-1)).next() {\n+                                // exhausted this iterator (i.e. finished this\n+                                // Internal node), so pop from the stack.\n+                                //\n+                                // don't bother clearing the memory, because the\n+                                // next time we use it we'll've written to it\n+                                // first.\n+                                None => write_ptr = write_ptr.offset(-1),\n+                                Some(child) => {\n+                                    addr!(match *child {\n+                                            Internal(ref $($mut_)* node) => {\n+                                                // going down a level, so push\n+                                                // to the stack (this is the\n+                                                // write referenced above)\n+                                                *write_ptr = node.children.$iter();\n+                                                write_ptr = write_ptr.offset(1);\n+                                            }\n+                                            External(key, ref $($mut_)* value) => {\n+                                                self.remaining_max -= 1;\n+                                                if self.remaining_min > 0 {\n+                                                    self.remaining_min -= 1;\n+                                                }\n+                                                // store the new length of the\n+                                                // stack, based on our current\n+                                                // position.\n+                                                self.length = (write_ptr as uint\n+                                                               - start_ptr as uint) /\n+                                                    mem::size_of_val(&*write_ptr);\n+\n+                                                return Some((key, value));\n                                             }\n-                                            return Some((key, value));\n-                                        }\n-                                        Nothing => {}\n-                                    })\n+                                            Nothing => {}\n+                                        })\n+                                }\n                             }\n                         }\n                     }"}]}