{"sha": "e152c38f65ae1aa69630b0b82e571e52b05e3302", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxNTJjMzhmNjVhZTFhYTY5NjMwYjBiODJlNTcxZTUyYjA1ZTMzMDI=", "commit": {"author": {"name": "Christian Poveda", "email": "cpovedar@fnal.gov", "date": "2019-06-20T22:01:48Z"}, "committer": {"name": "Christian Poveda", "email": "cpovedar@fnal.gov", "date": "2019-06-20T22:01:48Z"}, "message": "Fix merge issues", "tree": {"sha": "a717ab627647fe0e4a11057a58277db860a4c1b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a717ab627647fe0e4a11057a58277db860a4c1b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e152c38f65ae1aa69630b0b82e571e52b05e3302", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e152c38f65ae1aa69630b0b82e571e52b05e3302", "html_url": "https://github.com/rust-lang/rust/commit/e152c38f65ae1aa69630b0b82e571e52b05e3302", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e152c38f65ae1aa69630b0b82e571e52b05e3302/comments", "author": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "752a1a46685412202153c53ae320957cb48c751b", "url": "https://api.github.com/repos/rust-lang/rust/commits/752a1a46685412202153c53ae320957cb48c751b", "html_url": "https://github.com/rust-lang/rust/commit/752a1a46685412202153c53ae320957cb48c751b"}, {"sha": "f693d339f175b3aa23a91c62632c5f0c86886059", "url": "https://api.github.com/repos/rust-lang/rust/commits/f693d339f175b3aa23a91c62632c5f0c86886059", "html_url": "https://github.com/rust-lang/rust/commit/f693d339f175b3aa23a91c62632c5f0c86886059"}], "stats": {"total": 11989, "additions": 8009, "deletions": 3980}, "files": [{"sha": "271f9d382ff64f87d9c4290e0539d81a30335f55", "filename": ".azure-pipelines/steps/run.yml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/.azure-pipelines%2Fsteps%2Frun.yml", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/.azure-pipelines%2Fsteps%2Frun.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.azure-pipelines%2Fsteps%2Frun.yml?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -37,7 +37,8 @@ steps:\n     set -e\n     brew update\n     brew install xz\n-    brew install swig\n+    brew install swig@3\n+    brew link --force swig@3\n   displayName: Install build dependencies (OSX)\n   condition: and(succeeded(), eq(variables['Agent.OS'], 'Darwin'), eq(variables['SCRIPT'],'./x.py dist'))\n "}, {"sha": "3d185b4f0c9ff6bc56b12442f4c653be4b0e6920", "filename": ".travis.yml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -263,7 +263,8 @@ install:\n           if [[ \"$SCRIPT\" == \"./x.py dist\" ]]; then\n             travis_retry brew update &&\n             travis_retry brew install xz &&\n-            travis_retry brew install swig;\n+            travis_retry brew install swig@3 &&\n+            brew link --force swig@3;\n           fi &&\n           travis_retry curl -fo /usr/local/bin/sccache https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2018-04-02-sccache-x86_64-apple-darwin &&\n             chmod +x /usr/local/bin/sccache &&"}, {"sha": "9af1c28b3c2bd98156d78f4af7c13e216e022497", "filename": "Cargo.lock", "status": "modified", "additions": 353, "deletions": 202, "changes": 555, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -70,7 +70,7 @@ name = \"arena\"\n version = \"0.0.0\"\n dependencies = [\n  \"rustc_data_structures 0.0.0\",\n- \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -190,7 +190,7 @@ dependencies = [\n  \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"petgraph 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pretty_assertions 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"time 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.4.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -213,7 +213,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n name = \"build-manifest\"\n version = \"0.1.0\"\n dependencies = [\n- \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.4.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -266,6 +266,7 @@ dependencies = [\n  \"bufstream 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"byteorder 1.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"bytesize 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cargo-test-macro 0.1.0\",\n  \"clap 2.32.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core-foundation 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"crates-io 0.26.0\",\n@@ -279,8 +280,8 @@ dependencies = [\n  \"flate2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fs2 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fwdansi 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"git2 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"git2-curl 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"git2 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"git2-curl 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"glob 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"hex 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"home 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -290,7 +291,7 @@ dependencies = [\n  \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazycell 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libgit2-sys 0.7.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libgit2-sys 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"memchr 2.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"miow 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -303,7 +304,7 @@ dependencies = [\n  \"rustfix 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"same-file 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_ignored 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"shell-escape 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -315,18 +316,27 @@ dependencies = [\n  \"unicode-width 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url 1.7.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url_serde 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"varisat 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"walkdir 2.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"cargo-test-macro\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"quote 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.15.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"cargo_metadata\"\n version = \"0.7.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"error-chain 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.81 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -338,7 +348,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.81 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -417,7 +427,7 @@ dependencies = [\n  \"rustc-workspace-hack 1.0.0\",\n  \"rustc_tools_util 0.2.0\",\n  \"semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -437,8 +447,8 @@ dependencies = [\n  \"quine-mc_cluskey 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex-syntax 0.6.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-normalization 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url 1.7.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -506,7 +516,7 @@ dependencies = [\n  \"miow 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 1.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustfix 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"walkdir 2.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -525,7 +535,7 @@ dependencies = [\n  \"miow 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 1.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustfix 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.81 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tempfile 3.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -566,7 +576,7 @@ dependencies = [\n  \"curl 0.4.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"http 0.1.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.81 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url 1.7.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -594,7 +604,7 @@ version = \"0.3.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"crossbeam-utils 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -710,20 +720,20 @@ name = \"derive-new\"\n version = \"0.5.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 0.15.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2 0.4.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.15.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"derive_more\"\n version = \"0.13.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2 0.4.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 0.15.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.15.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -796,21 +806,13 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 1.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.81 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"strum 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"strum_macros 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"ena\"\n-version = \"0.11.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"ena\"\n version = \"0.13.0\"\n@@ -880,9 +882,9 @@ name = \"failure_derive\"\n version = \"0.1.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 0.15.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2 0.4.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.15.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"synstructure 0.10.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1034,12 +1036,12 @@ dependencies = [\n \n [[package]]\n name = \"git2\"\n-version = \"0.8.0\"\n+version = \"0.9.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libgit2-sys 0.7.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libgit2-sys 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"openssl-probe 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"openssl-sys 0.9.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1048,11 +1050,11 @@ dependencies = [\n \n [[package]]\n name = \"git2-curl\"\n-version = \"0.9.0\"\n+version = \"0.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"curl 0.4.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"git2 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"git2 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url 1.7.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -1089,7 +1091,7 @@ dependencies = [\n  \"pest_derive 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 1.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1104,11 +1106,16 @@ dependencies = [\n  \"pest_derive 2.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 1.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"walkdir 2.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"hashbrown\"\n+version = \"0.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"hashbrown\"\n version = \"0.4.0\"\n@@ -1149,9 +1156,9 @@ dependencies = [\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"mac 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"markup5ever 0.7.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 0.15.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2 0.4.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.15.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1161,7 +1168,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bytes 0.4.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fnv 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"itoa 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"itoa 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1266,7 +1273,7 @@ dependencies = [\n \n [[package]]\n name = \"itoa\"\n-version = \"0.4.3\"\n+version = \"0.4.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -1301,7 +1308,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"futures 0.1.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.81 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -1330,6 +1337,11 @@ name = \"lazycell\"\n version = \"1.2.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"leb128\"\n+version = \"0.2.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"libc\"\n version = \"0.2.54\"\n@@ -1340,11 +1352,10 @@ dependencies = [\n \n [[package]]\n name = \"libgit2-sys\"\n-version = \"0.7.11\"\n+version = \"0.8.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cc 1.0.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"curl-sys 0.4.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libssh2-sys 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libz-sys 1.0.25 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1432,7 +1443,7 @@ dependencies = [\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num-derive 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num-traits 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.81 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url 1.7.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1472,7 +1483,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"phf 0.7.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"phf_codegen 0.7.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.81 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"string_cache 0.7.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1504,7 +1515,7 @@ dependencies = [\n  \"open 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pulldown-cmark 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.81 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"shlex 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1532,7 +1543,7 @@ dependencies = [\n  \"open 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pulldown-cmark 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 1.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.81 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"shlex 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1714,9 +1725,9 @@ version = \"0.2.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"num-traits 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 0.15.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2 0.4.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.15.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1792,6 +1803,14 @@ dependencies = [\n  \"vcpkg 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"ordered-float\"\n+version = \"1.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"num-traits 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"ordermap\"\n version = \"0.3.5\"\n@@ -1856,10 +1875,28 @@ dependencies = [\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"partial_ref\"\n+version = \"0.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"partial_ref_derive 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"partial_ref_derive\"\n+version = \"0.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"proc-macro2 0.4.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.15.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"percent-encoding\"\n version = \"1.0.1\"\n@@ -1904,9 +1941,9 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"pest 2.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pest_meta 2.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 0.15.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2 0.4.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.15.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -2003,7 +2040,7 @@ dependencies = [\n \n [[package]]\n name = \"proc-macro2\"\n-version = \"0.4.24\"\n+version = \"0.4.30\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2083,15 +2120,15 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"quote\"\n-version = \"0.6.10\"\n+version = \"0.6.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2 0.4.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"racer\"\n-version = \"2.1.22\"\n+version = \"2.1.23\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2102,7 +2139,7 @@ dependencies = [\n  \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-span 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-syntax 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-syntax 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -2330,7 +2367,7 @@ dependencies = [\n  \"lsp-types 0.57.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ordslice 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"racer 2.1.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"racer 2.1.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rayon 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 1.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2343,8 +2380,8 @@ dependencies = [\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-workspace-hack 1.0.0\",\n  \"rustc_tools_util 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustfmt-nightly 1.2.2\",\n- \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustfmt-nightly 1.3.0\",\n+ \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.81 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_ignored 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2369,7 +2406,7 @@ dependencies = [\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-data 0.19.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-span 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -2384,7 +2421,7 @@ version = \"0.19.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"rls-span 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -2396,7 +2433,7 @@ name = \"rls-span\"\n version = \"0.5.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -2446,28 +2483,29 @@ dependencies = [\n  \"rustc_target 0.0.0\",\n  \"scoped-tls 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serialize 0.0.0\",\n- \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n  \"tempfile 3.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rustc-ap-arena\"\n-version = \"407.0.0\"\n+version = \"491.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"rustc-ap-rustc_data_structures 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_data_structures 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rustc-ap-graphviz\"\n-version = \"407.0.0\"\n+version = \"491.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"rustc-ap-rustc_cratesio_shim\"\n-version = \"407.0.0\"\n+version = \"491.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2477,85 +2515,104 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_data_structures\"\n-version = \"407.0.0\"\n+version = \"491.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"ena 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ena 0.13.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"indexmap 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"jobserver 0.1.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-graphviz 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_cratesio_shim 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-serialize 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-graphviz 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_cratesio_shim 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-serialize 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-rayon 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-rayon-core 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-rayon 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-rayon-core 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"stable_deref_trait 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_errors\"\n-version = \"407.0.0\"\n+version = \"491.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n+ \"annotate-snippets 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"atty 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_cratesio_shim 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_data_structures 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-serialize 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-syntax_pos 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_cratesio_shim 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_data_structures 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-serialize 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-syntax_pos 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"termcolor 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-width 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"rustc-ap-rustc_macros\"\n+version = \"491.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2 0.4.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.15.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"synstructure 0.10.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"rustc-ap-rustc_target\"\n-version = \"407.0.0\"\n+version = \"491.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_cratesio_shim 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_data_structures 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-serialize 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_cratesio_shim 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_data_structures 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-serialize 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-syntax_pos 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rustc-ap-serialize\"\n-version = \"407.0.0\"\n+version = \"491.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"indexmap 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rustc-ap-syntax\"\n-version = \"407.0.0\"\n+version = \"491.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_data_structures 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_errors 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_target 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-serialize 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-syntax_pos 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_data_structures 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_errors 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_macros 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_target 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-serialize 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-syntax_pos 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"scoped-tls 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rustc-ap-syntax_pos\"\n-version = \"407.0.0\"\n+version = \"491.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-arena 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_data_structures 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-serialize 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-arena 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_data_structures 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_macros 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-serialize 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"scoped-tls 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-width 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -2587,16 +2644,6 @@ dependencies = [\n  \"rustc_target 0.0.0\",\n ]\n \n-[[package]]\n-name = \"rustc-rayon\"\n-version = \"0.1.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"crossbeam-deque 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"either 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-rayon-core 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"rustc-rayon\"\n version = \"0.2.0\"\n@@ -2607,17 +2654,6 @@ dependencies = [\n  \"rustc-rayon-core 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"rustc-rayon-core\"\n-version = \"0.1.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"crossbeam-deque 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"rustc-rayon-core\"\n version = \"0.2.0\"\n@@ -2656,10 +2692,10 @@ dependencies = [\n  \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"scopeguard 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 0.15.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.15.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -2672,7 +2708,7 @@ dependencies = [\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_target 0.0.0\",\n- \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n@@ -2683,7 +2719,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_cratesio_shim 0.0.0\",\n- \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -2792,7 +2828,7 @@ dependencies = [\n  \"rustc-rayon-core 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_cratesio_shim 0.0.0\",\n  \"serialize 0.0.0\",\n- \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"stable_deref_trait 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -2826,7 +2862,7 @@ dependencies = [\n  \"rustc_typeck 0.0.0\",\n  \"scoped-tls 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serialize 0.0.0\",\n- \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntax 0.0.0\",\n  \"syntax_ext 0.0.0\",\n  \"syntax_pos 0.0.0\",\n@@ -2891,7 +2927,7 @@ dependencies = [\n  \"rustc_typeck 0.0.0\",\n  \"scoped-tls 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serialize 0.0.0\",\n- \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntax 0.0.0\",\n  \"syntax_ext 0.0.0\",\n  \"syntax_pos 0.0.0\",\n@@ -2934,9 +2970,9 @@ name = \"rustc_macros\"\n version = \"0.1.0\"\n dependencies = [\n  \"itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 0.15.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2 0.4.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.15.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"synstructure 0.10.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -2952,7 +2988,7 @@ dependencies = [\n  \"rustc_errors 0.0.0\",\n  \"rustc_target 0.0.0\",\n  \"serialize 0.0.0\",\n- \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"stable_deref_trait 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntax 0.0.0\",\n  \"syntax_ext 0.0.0\",\n@@ -2976,7 +3012,7 @@ dependencies = [\n  \"rustc_errors 0.0.0\",\n  \"rustc_target 0.0.0\",\n  \"serialize 0.0.0\",\n- \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n@@ -3041,7 +3077,7 @@ dependencies = [\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_metadata 0.0.0\",\n- \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n@@ -3095,7 +3131,7 @@ dependencies = [\n  \"rustc 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_target 0.0.0\",\n- \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n@@ -3121,7 +3157,7 @@ dependencies = [\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_target 0.0.0\",\n- \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n@@ -3162,14 +3198,24 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.81 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"rustfmt-config_proc_macro\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"proc-macro2 0.4.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.15.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"rustfmt-nightly\"\n-version = \"1.2.2\"\n+version = \"1.3.0\"\n dependencies = [\n  \"annotate-snippets 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"atty 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3186,13 +3232,14 @@ dependencies = [\n  \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 1.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_target 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-syntax 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-syntax_pos 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_target 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-syntax 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-syntax_pos 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-workspace-hack 1.0.0\",\n- \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.81 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustfmt-config_proc_macro 0.1.0\",\n+ \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"structopt 0.2.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"term 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-segmentation 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3254,7 +3301,7 @@ version = \"0.9.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -3264,7 +3311,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"serde\"\n-version = \"1.0.82\"\n+version = \"1.0.92\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"serde_derive 1.0.81 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3275,35 +3322,35 @@ name = \"serde_derive\"\n version = \"1.0.81\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 0.15.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2 0.4.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.15.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"serde_ignored\"\n version = \"0.0.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"serde_json\"\n version = \"1.0.33\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"itoa 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"itoa 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ryu 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"serialize\"\n version = \"0.0.0\"\n dependencies = [\n  \"indexmap 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -3356,11 +3403,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"smallvec\"\n-version = \"0.6.7\"\n+version = \"0.6.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"unreachable 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n \n [[package]]\n name = \"socket2\"\n@@ -3412,7 +3456,7 @@ dependencies = [\n  \"new_debug_unreachable 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"phf_shared 0.7.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"precomputed-hash 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"string_cache_codegen 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"string_cache_shared 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -3424,8 +3468,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"phf_generator 0.7.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"phf_shared 0.7.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2 0.4.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"string_cache_shared 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -3447,6 +3491,26 @@ name = \"strsim\"\n version = \"0.7.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"structopt\"\n+version = \"0.2.16\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"clap 2.32.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"structopt-derive 0.2.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"structopt-derive\"\n+version = \"0.2.16\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"heck 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2 0.4.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.15.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"strum\"\n version = \"0.11.0\"\n@@ -3458,9 +3522,9 @@ version = \"0.11.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"heck 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 0.15.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2 0.4.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.15.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -3475,11 +3539,11 @@ dependencies = [\n \n [[package]]\n name = \"syn\"\n-version = \"0.15.22\"\n+version = \"0.15.35\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2 0.4.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -3496,9 +3560,9 @@ name = \"synstructure\"\n version = \"0.10.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 0.15.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2 0.4.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.15.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -3515,7 +3579,7 @@ dependencies = [\n  \"rustc_target 0.0.0\",\n  \"scoped-tls 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serialize 0.0.0\",\n- \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntax_pos 0.0.0\",\n ]\n \n@@ -3528,7 +3592,7 @@ dependencies = [\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_target 0.0.0\",\n- \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n@@ -3660,7 +3724,7 @@ name = \"tidy\"\n version = \"0.1.0\"\n dependencies = [\n  \"regex 1.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -3867,15 +3931,15 @@ name = \"toml\"\n version = \"0.4.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"toml\"\n version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -4005,7 +4069,7 @@ name = \"url_serde\"\n version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url 1.7.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -4024,6 +4088,76 @@ name = \"utf8parse\"\n version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"varisat\"\n+version = \"0.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"itoa 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"leb128 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ordered-float 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"partial_ref 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"varisat-checker 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"varisat-dimacs 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"varisat-formula 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"varisat-internal-macros 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"varisat-internal-proof 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"vec_mut_scan 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"varisat-checker\"\n+version = \"0.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"hashbrown 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"varisat-dimacs 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"varisat-formula 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"varisat-internal-proof 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"varisat-dimacs\"\n+version = \"0.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"itoa 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"varisat-formula 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"varisat-formula\"\n+version = \"0.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"varisat-internal-macros\"\n+version = \"0.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"proc-macro2 0.4.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 1.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.15.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"synstructure 0.10.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"varisat-internal-proof\"\n+version = \"0.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"varisat-formula 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"vcpkg\"\n version = \"0.2.6\"\n@@ -4034,6 +4168,11 @@ name = \"vec_map\"\n version = \"0.8.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"vec_mut_scan\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"vergen\"\n version = \"3.0.4\"\n@@ -4227,7 +4366,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum dlmalloc 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f283302e035e61c23f2b86b3093e8c6273a4c3125742d6087e96ade001ca5e63\"\n \"checksum either 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3be565ca5c557d7f59e7cfcf1844f9e3033650c929c6566f511e8005f205c1d0\"\n \"checksum elasticlunr-rs 2.3.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a99a310cd1f9770e7bf8e48810c7bcbb0e078c8fb23a8c7bcf0da4c2bf61a455\"\n-\"checksum ena 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f56c93cc076508c549d9bb747f79aa9b4eb098be7b8cad8830c3137ef52d1e00\"\n \"checksum ena 0.13.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3dc01d68e08ca384955a3aeba9217102ca1aa85b6e168639bf27739f1d749d87\"\n \"checksum env_logger 0.5.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15b0a4d2e39f8420210be8b27eeda28029729e2fd4291019455016c348240c38\"\n \"checksum env_logger 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"afb070faf94c85d17d50ca44f6ad076bce18ae92f0037d350947240a36e9d42e\"\n@@ -4254,12 +4392,13 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum fwdansi 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"34dd4c507af68d37ffef962063dfa1944ce0dd4d5b82043dbab1dabe088610c3\"\n \"checksum generic-array 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ef25c5683767570c2bbd7deba372926a55eaae9982d7726ee2a1050239d45b9d\"\n \"checksum getopts 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\" = \"72327b15c228bfe31f1390f93dd5e9279587f0463836393c9df719ce62a3e450\"\n-\"checksum git2 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c7339329bfa14a00223244311560d11f8f489b453fb90092af97f267a6090ab0\"\n-\"checksum git2-curl 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d58551e903ed7e2d6fe3a2f3c7efa3a784ec29b19d0fbb035aaf0497c183fbdd\"\n+\"checksum git2 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"924b2e7d2986e625dcad89e8a429a7b3adee3c3d71e585f4a66c4f7e78715e31\"\n+\"checksum git2-curl 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f21f0550fd5d3f7c5adb94797fcd3d1002d7fc1fa349c82fe44f3c97ef80b62c\"\n \"checksum glob 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9b919933a397b79c37e33b77bb2aa3dc8eb6e165ad809e58ff75bc7db2e34574\"\n \"checksum globset 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ef4feaabe24a0a658fd9cf4a9acf6ed284f045c77df0f49020ba3245cfb7b454\"\n \"checksum handlebars 0.32.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d89ec99d1594f285d4590fc32bac5f75cdab383f1123d504d27862c644a807dd\"\n \"checksum handlebars 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d82e5750d8027a97b9640e3fefa66bbaf852a35228e1c90790efd13c4b09c166\"\n+\"checksum hashbrown 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"29fba9abe4742d586dfd0c06ae4f7e73a1c2d86b856933509b269d82cdf06e18\"\n \"checksum hashbrown 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9529213c67695ca2d146e6f263b7b72df8fa973368beadf767e8ed80c03f2f36\"\n \"checksum heck 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ea04fa3ead4e05e51a7c806fc07271fdbde4e246a6c6d1efd52e72230b771b82\"\n \"checksum hex 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"805026a5d0141ffc30abb3be3173848ad46a1b1664fe632428479619a3644d77\"\n@@ -4276,7 +4415,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum is-match 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7e5b386aef33a1c677be65237cb9d32c3f3ef56bd035949710c4bb13083eb053\"\n \"checksum itertools 0.7.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f58856976b776fedd95533137617a02fb25719f40e7d9b01c7043cd65474f450\"\n \"checksum itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5b8467d9c1cebe26feb08c640139247fac215782d35371ade9a2136ed6085358\"\n-\"checksum itoa 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1306f3464951f30e30d12373d31c79fbd52d236e5e896fd92f96ec7babbbe60b\"\n+\"checksum itoa 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"501266b7edd0174f8530248f87f99c88fbe60ca4ef3dd486835b8d8d53136f7f\"\n \"checksum jemalloc-sys 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7bef0d4ce37578dfd80b466e3d8324bd9de788e249f1accebb0c472ea4b52bdc\"\n \"checksum jobserver 0.1.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b3d51e24009d966c8285d524dbaf6d60926636b2a89caee9ce0bd612494ddc16\"\n \"checksum json 0.11.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9ad0485404155f45cce53a40d4b2d6ac356418300daed05273d9e26f91c390be\"\n@@ -4285,8 +4424,9 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum lazy_static 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"76f033c7ad61445c5b347c7382dd1237847eb1bce590fe50365dcb33d546be73\"\n \"checksum lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bc5729f27f159ddd61f4df6228e827e86643d4d3e7c32183cb30a1c08f604a14\"\n \"checksum lazycell 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b294d6fa9ee409a054354afc4352b0b9ef7ca222c69b8812cbea9e7d2bf3783f\"\n+\"checksum leb128 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3576a87f2ba00f6f106fdfcd16db1d698d648a26ad8e0573cad8537c3c362d2a\"\n \"checksum libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c6785aa7dd976f5fbf3b71cfd9cd49d7f783c1ff565a858d71031c6c313aa5c6\"\n-\"checksum libgit2-sys 0.7.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"48441cb35dc255da8ae72825689a95368bf510659ae1ad55dc4aa88cb1789bf1\"\n+\"checksum libgit2-sys 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"941a41e23f77323b8c9d2ee118aec9ee39dfc176078c18b4757d3bad049d9ff7\"\n \"checksum libnghttp2-sys 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d75d7966bda4730b722d1eab8e668df445368a24394bae9fc1e8dc0ab3dbe4f4\"\n \"checksum libssh2-sys 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"126a1f4078368b163bfdee65fbab072af08a1b374a5551b21e87ade27b1fbf9d\"\n \"checksum libz-sys 1.0.25 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2eb5e43362e38e2bca2fd5f5134c4d4564a23a5c28e9b95411652021a8675ebe\"\n@@ -4329,12 +4469,15 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum openssl-probe 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"77af24da69f9d9341038eba93a073b1fdaaa1b788221b00a69bce9e762cb32de\"\n \"checksum openssl-src 111.1.0+1.1.1a (registry+https://github.com/rust-lang/crates.io-index)\" = \"26bb632127731bf4ac49bf86a5dde12d2ca0918c2234fc39d79d4da2ccbc6da7\"\n \"checksum openssl-sys 0.9.43 (registry+https://github.com/rust-lang/crates.io-index)\" = \"33c86834957dd5b915623e94f2f4ab2c70dd8f6b70679824155d5ae21dbd495d\"\n+\"checksum ordered-float 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"18869315e81473c951eb56ad5558bbc56978562d3ecfb87abb7a1e944cea4518\"\n \"checksum ordermap 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a86ed3f5f244b372d6b1a00b72ef7f8876d0bc6a78a4c9985c53614041512063\"\n \"checksum ordslice 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dd20eec3dbe4376829cb7d80ae6ac45e0a766831dca50202ff2d40db46a8a024\"\n \"checksum owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cdf84f41639e037b484f93433aa3897863b561ed65c6e59c7073d7c561710f37\"\n \"checksum packed_simd 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"25d36de864f7218ec5633572a800109bbe5a1cc8d9d95a967f3daf93ea7e6ddc\"\n \"checksum parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ab41b4aed082705d1056416ae4468b6ea99d52599ecf3169b00088d43113e337\"\n \"checksum parking_lot_core 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"94c8c7923936b28d546dfd14d4472eaf34c99b14e1c973a32b3e6d4eb04298c9\"\n+\"checksum partial_ref 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b2b85fa89a02abf59d36821c373b5ed38c8e075505f1a08618b000fce81229bc\"\n+\"checksum partial_ref_derive 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"759319b785d033e4279ec98fb2d1fb767a1af5b6a8996086c07168169cff079b\"\n \"checksum percent-encoding 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"31010dd2e1ac33d5b46a5b413495239882813e0369f8ed8a5e266f173602f831\"\n \"checksum pest 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0fce5d8b5cc33983fc74f78ad552b5522ab41442c4ca91606e4236eb4b5ceefc\"\n \"checksum pest 2.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"54f0c72a98d8ab3c99560bfd16df8059cc10e1f9a8e83e6e3b97718dd766e9c3\"\n@@ -4352,16 +4495,16 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum precomputed-hash 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"925383efa346730478fb4838dbe9137d2a47675ad789c546d150a6e1dd4ab31c\"\n \"checksum pretty_assertions 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3a029430f0d744bc3d15dd474d591bed2402b645d024583082b9f63bb936dac6\"\n \"checksum pretty_env_logger 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"df8b3f4e0475def7d9c2e5de8e5a1306949849761e107b360d03e98eafaffd61\"\n-\"checksum proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"77619697826f31a02ae974457af0b29b723e5619e113e9397b8b82c6bd253f09\"\n+\"checksum proc-macro2 0.4.30 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cf3d2011ab5c909338f7887f4fc896d35932e29146c12c8d01da6b22a80ba759\"\n \"checksum proptest 0.9.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"24f5844db2f839e97e3021980975f6ebf8691d9b9b2ca67ed3feb38dc3edb52c\"\n \"checksum pulldown-cmark 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d6fdf85cda6cadfae5428a54661d431330b312bc767ddbc57adbedc24da66e32\"\n \"checksum pulldown-cmark 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"051e60ace841b3bfecd402fe5051c06cb3bec4a6e6fdd060a37aa8eb829a1db3\"\n \"checksum punycode 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6ddd112cca70a4d30883b2d21568a1d376ff8be4758649f64f973c6845128ad3\"\n \"checksum quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9274b940887ce9addde99c4eee6b5c44cc494b182b97e73dc8ffdcb3397fd3f0\"\n \"checksum quine-mc_cluskey 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"07589615d719a60c8dd8a4622e7946465dfef20d1a428f969e3443e7386d5f45\"\n \"checksum quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a6e920b65c65f10b2ae65c831a81a073a89edd28c7cce89475bff467ab4167a\"\n-\"checksum quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"53fa22a1994bd0f9372d7a816207d8a2677ad0325b073f5c5332760f0fb62b5c\"\n-\"checksum racer 2.1.22 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1e4323343f25bc372dc9293ac6b5cd3034b32784af1e7de9366b4db71466d8c7\"\n+\"checksum quote 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"faf4799c5d274f3868a4aae320a0a182cbd2baee377b378f080e16a23e9d80db\"\n+\"checksum racer 2.1.23 (registry+https://github.com/rust-lang/crates.io-index)\" = \"94dbdea3d959d8f76a2e303b3eadf107fd76da886b231291e649168613d432fb\"\n \"checksum rand 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"552840b97013b1a26992c11eac34bdd778e464601a4c2054b5f0bff7c6761293\"\n \"checksum rand 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ae9d223d52ae411a33cf7e54ec6034ec165df296ccd23533d671a28252b6f66a\"\n \"checksum rand_chacha 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"771b009e3a508cb67e8823dda454aaa5368c7bc1c16829fb77d3e980440dd34a\"\n@@ -4388,20 +4531,19 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum rls-data 0.19.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"76c72ea97e045be5f6290bb157ebdc5ee9f2b093831ff72adfaf59025cf5c491\"\n \"checksum rls-span 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f1cb4694410d8d2ce43ccff3682f1c782158a018d5a9a92185675677f7533eb3\"\n \"checksum rls-vfs 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ce4b57b25b4330ed5ec14028fc02141e083ddafda327e7eb598dc0569c8c83c9\"\n-\"checksum rustc-ap-arena 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5aab2fb5e5becf1c9183f6c63b8714817a3e780a20b4fe6b3920751c98a18225\"\n-\"checksum rustc-ap-graphviz 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0235ff613d4f96176ea56748010b5d8e978605cc47856ba9bb5372f4f38e9c03\"\n-\"checksum rustc-ap-rustc_cratesio_shim 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"63e04a90b0dd8597da83633961698c61a2948f50c9d4b9a71e8afafc0ba0f158\"\n-\"checksum rustc-ap-rustc_data_structures 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c03988d65fc5130787df32e8ea91738f78a8ed62b7a5bdd77f10e5cceb531d8e\"\n-\"checksum rustc-ap-rustc_errors 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8b33b9dc34f9fa50bf7e6fd14f2f3c1adc69833acf43c10f3e9795bd4d613712\"\n-\"checksum rustc-ap-rustc_target 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e6de75caef2c7acba11994614266d60238653657677934817ab368d169333cba\"\n-\"checksum rustc-ap-serialize 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cf09c60aaee892b0fd107544cfe607d8d463e7f33da34aa823566b8fd2b17f53\"\n-\"checksum rustc-ap-syntax 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"69f38cc120ff317678bbda8c4f58c1bbc1de64b615383ab01480482dde5e95a1\"\n-\"checksum rustc-ap-syntax_pos 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"20a0a201141c5c416b1924b079eeefc7b013e34ece0740ce4997f358b3684a7f\"\n+\"checksum rustc-ap-arena 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fc0ad4318f3425229ed7b117275368b83269bec75f9609d4965dcb9752483c86\"\n+\"checksum rustc-ap-graphviz 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b80b7ea7902919f397c4bb12d102abe896fced7893d09d84bcac233e555bb388\"\n+\"checksum rustc-ap-rustc_cratesio_shim 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"752463d2b80039d23e42e667a9f6fe08213bd865f6ea301fb35f8068d94955ac\"\n+\"checksum rustc-ap-rustc_data_structures 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5c3d6a14181e11c132d0ef97a6c27e1bb1d4da09682d02222393875c10d1c364\"\n+\"checksum rustc-ap-rustc_errors 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"55caea8426565de362e8df0df737e43b9f22d632e0e52710cbfe316acc6ce2f0\"\n+\"checksum rustc-ap-rustc_macros 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"071420d762d2c779d1d4972356f37f5d049dcdd6c49e78f1b037e04c5a0f1a19\"\n+\"checksum rustc-ap-rustc_target 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d5464696d0748e3019b9e5daca5fcadc53889dc2bca1dc26bf42001fd1c4194f\"\n+\"checksum rustc-ap-serialize 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9464445c11c15cf32ef27815b3ec89315b0ed73c6c771cbcf8543be59a3c1502\"\n+\"checksum rustc-ap-syntax 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ff53245ae370d8e8073dc9cc13f8921e6110d0ccd208b64c388c5653fa6b9c83\"\n+\"checksum rustc-ap-syntax_pos 491.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"41896f0eb2eb2f4ddba406939aa6b07386160fa38bee8cde3f7f0d85663e3d47\"\n \"checksum rustc-demangle 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a7f4dccf6f4891ebcc0c39f9b6eb1a83b9bf5d747cb439ec6fba4f3b977038af\"\n \"checksum rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7540fc8b0c49f096ee9c961cda096467dce8084bec6bdca2fc83895fd9b28cb8\"\n-\"checksum rustc-rayon 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8d98c51d9cbbe810c8b6693236d3412d8cd60513ff27a3e1b6af483dca0af544\"\n \"checksum rustc-rayon 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0d2e07e19601f21c59aad953c2632172ba70cb27e685771514ea66e4062b3363\"\n-\"checksum rustc-rayon-core 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"526e7b6d2707a5b9bec3927d424ad70fa3cfc68e0ac1b75e46cdbbc95adc5108\"\n \"checksum rustc-rayon-core 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"79d38ca7cbc22fa59f09d8534ea4b27f67b0facf0cbe274433aceea227a02543\"\n \"checksum rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dcf128d1287d2ea9d80910b5f1120d0b8eede3fbf1abe91c40d39ea7d51e6fda\"\n \"checksum rustc_tools_util 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b725dadae9fabc488df69a287f5a99c5eaf5d10853842a8a3dfac52476f544ee\"\n@@ -4416,7 +4558,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum scopeguard 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"94258f53601af11e6a49f722422f6e3425c52b06245a5cf9bc09908b174f5e27\"\n \"checksum semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1d7eb9ef2c18661902cc47e535f9bc51b78acd254da71d375c2f6720d9a40403\"\n \"checksum semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3\"\n-\"checksum serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6fa52f19aee12441d5ad11c9a00459122bd8f98707cadf9778c540674f1935b6\"\n+\"checksum serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\" = \"32746bf0f26eab52f06af0d0aa1984f641341d06d8d673c693871da2d188c9be\"\n \"checksum serde_derive 1.0.81 (registry+https://github.com/rust-lang/crates.io-index)\" = \"477b13b646f5b5b56fc95bedfc3b550d12141ce84f466f6c44b9a17589923885\"\n \"checksum serde_ignored 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"190e9765dcedb56be63b6e0993a006c7e3b071a016a304736e4a315dc01fb142\"\n \"checksum serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c37ccd6be3ed1fdf419ee848f7c758eb31b054d7cd3ae3600e3bae0adf569811\"\n@@ -4427,18 +4569,20 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum siphasher 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0df90a788073e8d0235a67e50441d47db7c8ad9debd91cbf43736a2a92d36537\"\n \"checksum sized-chunks 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a2a2eb3fe454976eefb479f78f9b394d34d661b647c6326a3a6e66f68bb12c26\"\n \"checksum slab 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c111b5bd5695e56cffe5129854aa230b39c93a305372fdbb2668ca2394eea9f8\"\n-\"checksum smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b73ea3738b47563803ef814925e69be00799a8c07420be8b996f8e98fb2336db\"\n+\"checksum smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ab606a9c5e214920bb66c458cd7be8ef094f813f20fe77a54cc7dbfff220d4b7\"\n \"checksum socket2 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c4d11a52082057d87cb5caa31ad812f4504b97ab44732cd8359df2e9ff9f48e7\"\n \"checksum stable_deref_trait 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ffbc596e092fe5f598b12ef46cc03754085ac2f4d8c739ad61c4ae266cc3b3fa\"\n \"checksum string_cache 0.7.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"25d70109977172b127fe834e5449e5ab1740b9ba49fa18a2020f509174f25423\"\n \"checksum string_cache_codegen 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1eea1eee654ef80933142157fdad9dd8bc43cf7c74e999e369263496f04ff4da\"\n \"checksum string_cache_shared 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b1884d1bc09741d466d9b14e6d37ac89d6909cbcac41dd9ae982d4d063bbedfc\"\n \"checksum strip-ansi-escapes 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9d63676e2abafa709460982ddc02a3bb586b6d15a49b75c212e06edd3933acee\"\n \"checksum strsim 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bb4f380125926a99e52bc279241539c018323fab05ad6368b56f93d9369ff550\"\n+\"checksum structopt 0.2.16 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fa19a5a708e22bb5be31c1b6108a2a902f909c4b9ba85cba44c06632386bc0ff\"\n+\"checksum structopt-derive 0.2.16 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c6d59d0ae8ef8de16e49e3ca7afa16024a3e0dfd974a75ef93fdc5464e34523f\"\n \"checksum strum 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f6c3a2071519ab6a48f465808c4c1ffdd00dfc8e93111d02b4fc5abab177676e\"\n \"checksum strum_macros 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8baacebd7b7c9b864d83a6ba7a246232983e277b86fa5cdec77f565715a4b136\"\n \"checksum syn 0.11.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d3b891b9015c88c576343b9b3e41c2c11a51c219ef067b264bd9c8aa9b441dad\"\n-\"checksum syn 0.15.22 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ae8b29eb5210bc5cf63ed6149cbf9adfc82ac0be023d8735c176ee74a2db4da7\"\n+\"checksum syn 0.15.35 (registry+https://github.com/rust-lang/crates.io-index)\" = \"641e117d55514d6d918490e47102f7e08d096fdde360247e4a10f7a91a8478d3\"\n \"checksum synom 0.11.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a393066ed9010ebaed60b9eafa373d4b1baac186dd7e008555b0f702b51945b6\"\n \"checksum synstructure 0.10.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"02353edf96d6e4dc81aea2d8490a7e9db177bf8acb0e951c24940bf866cb313f\"\n \"checksum tar 0.4.20 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a303ba60a099fcd2aaa646b14d2724591a96a75283e4b7ed3d1a1658909d9ae2\"\n@@ -4487,8 +4631,15 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum utf-8 0.7.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f1262dfab4c30d5cb7c07026be00ee343a6cf5027fdc0104a9160f354e5db75c\"\n \"checksum utf8-ranges 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"796f7e48bef87609f7ade7e06495a87d5cd06c7866e6a5cbfceffc558a243737\"\n \"checksum utf8parse 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8772a4ccbb4e89959023bc5b7cb8623a795caa7092d99f3aa9501b9484d4557d\"\n+\"checksum varisat 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a2640f5949bcd945ffdb030f5f336d0a5da8fe8ddab8e8230e2e030ea0623cfa\"\n+\"checksum varisat-checker 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a44da8d5e25b089d66fb3d14ae87994e2f7ba7f86ff396b7c490083d8a9a0a7b\"\n+\"checksum varisat-dimacs 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f992cf40560ad73983369414fcc5a42fb9c9e39ae7ff215c75725f9c6785f0b9\"\n+\"checksum varisat-formula 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"78d44ab5c6de769e855c77add5b0efa73ed3320b06485f04c8d3fad9b2eb9997\"\n+\"checksum varisat-internal-macros 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0e76c43d9badf53d22b0edd25667d65b7b67167e2cce249c9d1e3ca0f02dc81c\"\n+\"checksum varisat-internal-proof 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5a7553f03a4a8581410fb1813add70ce54e481d0e3eb1ca2cc1754faf46ff9ad\"\n \"checksum vcpkg 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"def296d3eb3b12371b2c7d0e83bfe1403e4db2d7a0bba324a12b21c4ee13143d\"\n \"checksum vec_map 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"05c78687fb1a80548ae3250346c3db86a80a7cdd77bda190189f2d0a0987c81a\"\n+\"checksum vec_mut_scan 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b4d5668931075a8dfe6eb3e9e585d06f0ab4d9b377663e94d135ef51933ff9f6\"\n \"checksum vergen 3.0.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6aba5e34f93dc7051dfad05b98a18e9156f27e7b431fe1d2398cb6061c0a1dba\"\n \"checksum version_check 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"914b1a6776c4c929a602fafd8bc742e06365d4bcbe48c30f9cca5824f70dc9dd\"\n \"checksum void 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6a02e4885ed3bc0f2de90ea6dd45ebcbb66dacffe03547fadbb0eeae2770887d\""}, {"sha": "6867d62a480bd2ba57a5a08767f784ad1266c423", "filename": "src/bootstrap/job.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Fbootstrap%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Fbootstrap%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fjob.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -32,6 +32,7 @@\n use std::env;\n use std::io;\n use std::mem;\n+use std::ptr;\n use crate::Build;\n \n type HANDLE = *mut u8;\n@@ -118,8 +119,8 @@ pub unsafe fn setup(build: &mut Build) {\n     SetErrorMode(mode & !SEM_NOGPFAULTERRORBOX);\n \n     // Create a new job object for us to use\n-    let job = CreateJobObjectW(0 as *mut _, 0 as *const _);\n-    assert!(job != 0 as *mut _, \"{}\", io::Error::last_os_error());\n+    let job = CreateJobObjectW(ptr::null_mut(), ptr::null());\n+    assert!(!job.is_null(), \"{}\", io::Error::last_os_error());\n \n     // Indicate that when all handles to the job object are gone that all\n     // process in the object should be killed. Note that this includes our\n@@ -166,8 +167,8 @@ pub unsafe fn setup(build: &mut Build) {\n     };\n \n     let parent = OpenProcess(PROCESS_DUP_HANDLE, FALSE, pid.parse().unwrap());\n-    assert!(parent != 0 as *mut _, \"{}\", io::Error::last_os_error());\n-    let mut parent_handle = 0 as *mut _;\n+    assert!(!parent.is_null(), \"{}\", io::Error::last_os_error());\n+    let mut parent_handle = ptr::null_mut();\n     let r = DuplicateHandle(GetCurrentProcess(), job,\n                             parent, &mut parent_handle,\n                             0, FALSE, DUPLICATE_SAME_ACCESS);"}, {"sha": "47f5edd15631a36aec6c3ff21ae95c174c988a82", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -209,7 +209,7 @@ pub fn symlink_dir(config: &Config, src: &Path, dest: &Path) -> io::Result<()> {\n             let h = CreateFileW(path.as_ptr(),\n                                 GENERIC_WRITE,\n                                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,\n-                                0 as *mut _,\n+                                ptr::null_mut(),\n                                 OPEN_EXISTING,\n                                 FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,\n                                 ptr::null_mut());"}, {"sha": "daf21670b33391d49cbe9f26d6c7fd7b347f6943", "filename": "src/ci/cpu-usage-over-time.py", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Fci%2Fcpu-usage-over-time.py", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Fci%2Fcpu-usage-over-time.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fcpu-usage-over-time.py?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -30,23 +30,8 @@\n # the second column is always zero.\n #\n # Once you've downloaded a file there's various ways to plot it and visualize\n-# it. For command line usage you can use a script like so:\n-#\n-#      set timefmt '%Y-%m-%dT%H:%M:%S'\n-#      set xdata time\n-#      set ylabel \"Idle CPU %\"\n-#      set xlabel \"Time\"\n-#      set datafile sep ','\n-#      set term png\n-#      set output \"printme.png\"\n-#      set grid\n-#      builder = \"i686-apple\"\n-#      plot \"cpu-\".builder.\".csv\" using 1:2 with lines title builder\n-#\n-# Executed as `gnuplot < ./foo.plot` it will generate a graph called\n-# `printme.png` which you can then open up. If you know how to improve this\n-# script or the viewing process that would be much appreciated :) (or even if\n-# you know how to automate it!)\n+# it. For command line usage you use the `src/etc/cpu-usage-over-time-plot.sh`\n+# script in this repository.\n \n import datetime\n import sys"}, {"sha": "0e38e2865d89372c53e6489dda43924efe03727d", "filename": "src/doc/unstable-book/src/language-features/plugin.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -132,7 +132,7 @@ The advantages over a simple `fn(&str) -> u32` are:\n In addition to procedural macros, you can define new\n [`derive`](../../reference/attributes/derive.md)-like attributes and other kinds\n of extensions.  See `Registry::register_syntax_extension` and the\n-`SyntaxExtension` enum.  For a more involved macro example, see\n+`SyntaxExtension` struct.  For a more involved macro example, see\n [`regex_macros`](https://github.com/rust-lang/regex/blob/master/regex_macros/src/lib.rs).\n \n "}, {"sha": "724a21c3fc2697838c3336ca04ecc62955d1b828", "filename": "src/etc/cpu-usage-over-time-plot.sh", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Fetc%2Fcpu-usage-over-time-plot.sh", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Fetc%2Fcpu-usage-over-time-plot.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcpu-usage-over-time-plot.sh?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -0,0 +1,49 @@\n+#!/bin/bash\n+\n+# A small script to help visualizing CPU usage over time data collected on CI\n+# using `gnuplot`.\n+#\n+# This script is expected to be called with two arguments. The first is the full\n+# commit SHA of the build you're interested in, and the second is the name of\n+# the builder. For example:\n+#\n+#  ./src/etc/cpu-usage-over-time-plot.sh e699ea096fcc2fc9ce8e8bcf884e11496a31cc9f i686-mingw-1\n+#\n+# That will generate `$builder.png` in the current directory which you can open\n+# up to see a hopefully pretty graph.\n+#\n+# Improvements to this script are greatly appreciated!\n+\n+set -ex\n+\n+bucket=rust-lang-ci-evalazure\n+commit=$1\n+builder=$2\n+\n+curl -O https://$bucket.s3.amazonaws.com/rustc-builds/$commit/cpu-$builder.csv\n+\n+gnuplot <<-EOF\n+reset\n+set timefmt '%Y-%m-%dT%H:%M:%S'\n+set xdata time\n+set ylabel \"CPU Usage %\"\n+set xlabel \"Time\"\n+set datafile sep ','\n+set term png size 3000,1000\n+set output \"$builder.png\"\n+set grid\n+\n+f(x) = mean_y\n+fit f(x) 'cpu-$builder.csv' using 1:(100-\\$2) via mean_y\n+\n+set label 1 gprintf(\"Average = %g%%\", mean_y) center font \",18\"\n+set label 1 at graph 0.50, 0.25\n+set xtics rotate by 45 offset -2,-2.4 300\n+set ytics 10\n+set boxwidth 0.5\n+\n+plot \\\\\n+   mean_y with lines linetype 1 linecolor rgb \"#ff0000\" title \"average\", \\\\\n+   \"cpu-$builder.csv\" using 1:(100-\\$2) with points pointtype 7 pointsize 0.4 title \"$builder\", \\\\\n+   \"\" using 1:(100-\\$2) smooth bezier linewidth 3 title \"bezier\"\n+EOF"}, {"sha": "0eb99423df576783912f0f25a1cccfefd435116c", "filename": "src/etc/rust-lldb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Fetc%2Frust-lldb", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Fetc%2Frust-lldb", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Frust-lldb?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -31,7 +31,7 @@ category_definition=\"type summary add --no-value --python-function lldb_rust_for\n category_enable=\"type category enable Rust\"\n \n # Call LLDB with the commands added to the argument list\n-exec \"$lldb\" --one-line-before-file=\"$script_import\" \\\n-    --one-line-before-file=\"$category_definition\" \\\n-    --one-line-before-file=\"$category_enable\" \\\n+exec \"$lldb\" --one-line-before-file \"$script_import\" \\\n+    --one-line-before-file \"$category_definition\" \\\n+    --one-line-before-file \"$category_enable\" \\\n     \"$@\""}, {"sha": "ee78839f7f00318bf12b3dfe0623d0e92df37d8b", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -1515,18 +1515,18 @@ impl<T: ?Sized> Weak<T> {\n     ///\n     /// ```\n     /// #![feature(weak_ptr_eq)]\n-    /// use std::rc::{Rc, Weak};\n+    /// use std::rc::Rc;\n     ///\n     /// let first_rc = Rc::new(5);\n     /// let first = Rc::downgrade(&first_rc);\n     /// let second = Rc::downgrade(&first_rc);\n     ///\n-    /// assert!(Weak::ptr_eq(&first, &second));\n+    /// assert!(first.ptr_eq(&second));\n     ///\n     /// let third_rc = Rc::new(5);\n     /// let third = Rc::downgrade(&third_rc);\n     ///\n-    /// assert!(!Weak::ptr_eq(&first, &third));\n+    /// assert!(!first.ptr_eq(&third));\n     /// ```\n     ///\n     /// Comparing `Weak::new`.\n@@ -1537,16 +1537,16 @@ impl<T: ?Sized> Weak<T> {\n     ///\n     /// let first = Weak::new();\n     /// let second = Weak::new();\n-    /// assert!(Weak::ptr_eq(&first, &second));\n+    /// assert!(first.ptr_eq(&second));\n     ///\n     /// let third_rc = Rc::new(());\n     /// let third = Rc::downgrade(&third_rc);\n-    /// assert!(!Weak::ptr_eq(&first, &third));\n+    /// assert!(!first.ptr_eq(&third));\n     /// ```\n     #[inline]\n     #[unstable(feature = \"weak_ptr_eq\", issue = \"55981\")]\n-    pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n-        this.ptr.as_ptr() == other.ptr.as_ptr()\n+    pub fn ptr_eq(&self, other: &Self) -> bool {\n+        self.ptr.as_ptr() == other.ptr.as_ptr()\n     }\n }\n "}, {"sha": "6c23b3179ed68254812860d4dceaf0c87a4044be", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -1349,18 +1349,18 @@ impl<T: ?Sized> Weak<T> {\n     ///\n     /// ```\n     /// #![feature(weak_ptr_eq)]\n-    /// use std::sync::{Arc, Weak};\n+    /// use std::sync::Arc;\n     ///\n     /// let first_rc = Arc::new(5);\n     /// let first = Arc::downgrade(&first_rc);\n     /// let second = Arc::downgrade(&first_rc);\n     ///\n-    /// assert!(Weak::ptr_eq(&first, &second));\n+    /// assert!(first.ptr_eq(&second));\n     ///\n     /// let third_rc = Arc::new(5);\n     /// let third = Arc::downgrade(&third_rc);\n     ///\n-    /// assert!(!Weak::ptr_eq(&first, &third));\n+    /// assert!(!first.ptr_eq(&third));\n     /// ```\n     ///\n     /// Comparing `Weak::new`.\n@@ -1371,16 +1371,16 @@ impl<T: ?Sized> Weak<T> {\n     ///\n     /// let first = Weak::new();\n     /// let second = Weak::new();\n-    /// assert!(Weak::ptr_eq(&first, &second));\n+    /// assert!(first.ptr_eq(&second));\n     ///\n     /// let third_rc = Arc::new(());\n     /// let third = Arc::downgrade(&third_rc);\n-    /// assert!(!Weak::ptr_eq(&first, &third));\n+    /// assert!(!first.ptr_eq(&third));\n     /// ```\n     #[inline]\n     #[unstable(feature = \"weak_ptr_eq\", issue = \"55981\")]\n-    pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n-        this.ptr.as_ptr() == other.ptr.as_ptr()\n+    pub fn ptr_eq(&self, other: &Self) -> bool {\n+        self.ptr.as_ptr() == other.ptr.as_ptr()\n     }\n }\n "}, {"sha": "3d16e335cd8f11870745d0dadf5e30ea2ad91c2d", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -114,8 +114,8 @@ impl<T> Default for TypedArena<T> {\n         TypedArena {\n             // We set both `ptr` and `end` to 0 so that the first call to\n             // alloc() will trigger a grow().\n-            ptr: Cell::new(0 as *mut T),\n-            end: Cell::new(0 as *mut T),\n+            ptr: Cell::new(ptr::null_mut()),\n+            end: Cell::new(ptr::null_mut()),\n             chunks: RefCell::new(vec![]),\n             _own: PhantomData,\n         }\n@@ -370,8 +370,8 @@ impl Default for DroplessArena {\n     #[inline]\n     fn default() -> DroplessArena {\n         DroplessArena {\n-            ptr: Cell::new(0 as *mut u8),\n-            end: Cell::new(0 as *mut u8),\n+            ptr: Cell::new(ptr::null_mut()),\n+            end: Cell::new(ptr::null_mut()),\n             chunks: Default::default(),\n         }\n     }"}, {"sha": "a697b7bd6e589ca8f7fd97910b4f2307ad0a2c1c", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -202,9 +202,9 @@ pub trait AsMut<T: ?Sized> {\n /// A value-to-value conversion that consumes the input value. The\n /// opposite of [`From`].\n ///\n-/// One should only implement `Into` if a conversion to a type outside the current crate is\n-/// required. Otherwise one should always prefer implementing [`From`] over `Into` because\n-/// implementing [`From`] automatically provides one with a implementation of `Into` thanks to\n+/// One should only implement [`Into`] if a conversion to a type outside the current crate is\n+/// required. Otherwise one should always prefer implementing [`From`] over [`Into`] because\n+/// implementing [`From`] automatically provides one with a implementation of [`Into`] thanks to\n /// the blanket implementation in the standard library. [`From`] cannot do these type of\n /// conversions because of Rust's orphaning rules.\n ///\n@@ -213,9 +213,9 @@ pub trait AsMut<T: ?Sized> {\n /// # Generic Implementations\n ///\n /// - [`From`]`<T> for U` implies `Into<U> for T`\n-/// - `Into` is reflexive, which means that `Into<T> for T` is implemented\n+/// - [`Into`] is reflexive, which means that `Into<T> for T` is implemented\n ///\n-/// # Implementing `Into` for conversions to external types\n+/// # Implementing [`Into`] for conversions to external types\n ///\n /// If the destination type is not part of the current crate\n /// then you can't implement [`From`] directly.\n@@ -231,7 +231,7 @@ pub trait AsMut<T: ?Sized> {\n /// ```\n /// This will fail to compile because we cannot implement a trait for a type\n /// if both the trait and the type are not defined by the current crate.\n-/// This is due to Rust's orphaning rules. To bypass this, you can implement `Into` directly:\n+/// This is due to Rust's orphaning rules. To bypass this, you can implement [`Into`] directly:\n ///\n /// ```\n /// struct Wrapper<T>(Vec<T>);\n@@ -242,19 +242,19 @@ pub trait AsMut<T: ?Sized> {\n /// }\n /// ```\n ///\n-/// It is important to understand that `Into` does not provide a [`From`] implementation\n-/// (as [`From`] does with `Into`). Therefore, you should always try to implement [`From`]\n-/// and then fall back to `Into` if [`From`] can't be implemented.\n+/// It is important to understand that [`Into`] does not provide a [`From`] implementation\n+/// (as [`From`] does with [`Into`]). Therefore, you should always try to implement [`From`]\n+/// and then fall back to [`Into`] if [`From`] can't be implemented.\n ///\n-/// Prefer using `Into` over [`From`] when specifying trait bounds on a generic function\n-/// to ensure that types that only implement `Into` can be used as well.\n+/// Prefer using [`Into`] over [`From`] when specifying trait bounds on a generic function\n+/// to ensure that types that only implement [`Into`] can be used as well.\n ///\n /// # Examples\n ///\n /// [`String`] implements `Into<Vec<u8>>`:\n ///\n /// In order to express that we want a generic function to take all arguments that can be\n-/// converted to a specified type `T`, we can use a trait bound of `Into<T>`.\n+/// converted to a specified type `T`, we can use a trait bound of [`Into`]`<T>`.\n /// For example: The function `is_hello` takes all arguments that can be converted into a\n /// `Vec<u8>`.\n ///\n@@ -273,7 +273,7 @@ pub trait AsMut<T: ?Sized> {\n /// [`Result<T, E>`]: ../../std/result/enum.Result.html\n /// [`String`]: ../../std/string/struct.String.html\n /// [`From`]: trait.From.html\n-/// [`into`]: trait.Into.html#tymethod.into\n+/// [`Into`]: trait.Into.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Into<T>: Sized {\n     /// Performs the conversion."}, {"sha": "49090fb8e43788467855248ce7feae75ec0e0d0d", "filename": "src/libcore/ffi.rs", "status": "modified", "additions": 187, "deletions": 44, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibcore%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibcore%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fffi.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -5,6 +5,8 @@\n //! Utilities related to FFI bindings.\n \n use crate::fmt;\n+use crate::marker::PhantomData;\n+use crate::ops::{Deref, DerefMut};\n \n /// Equivalent to C's `void` type when used as a [pointer].\n ///\n@@ -45,25 +47,33 @@ impl fmt::Debug for c_void {\n }\n \n /// Basic implementation of a `va_list`.\n+// The name is WIP, using `VaListImpl` for now.\n #[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n-              not(target_arch = \"x86_64\")),\n+              not(target_arch = \"x86_64\"), not(target_arch = \"asmjs\")),\n           all(target_arch = \"aarch64\", target_os = \"ios\"),\n           windows))]\n+#[repr(transparent)]\n #[unstable(feature = \"c_variadic\",\n            reason = \"the `c_variadic` feature has not been properly tested on \\\n                      all supported platforms\",\n            issue = \"44930\")]\n-extern {\n-    type VaListImpl;\n+#[lang = \"va_list\"]\n+pub struct VaListImpl<'f> {\n+    ptr: *mut c_void,\n+    _marker: PhantomData<&'f c_void>,\n }\n \n #[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n-              not(target_arch = \"x86_64\")),\n+              not(target_arch = \"x86_64\"), not(target_arch = \"asmjs\")),\n           all(target_arch = \"aarch64\", target_os = \"ios\"),\n           windows))]\n-impl fmt::Debug for VaListImpl {\n+#[unstable(feature = \"c_variadic\",\n+           reason = \"the `c_variadic` feature has not been properly tested on \\\n+                     all supported platforms\",\n+           issue = \"44930\")]\n+impl<'f> fmt::Debug for VaListImpl<'f> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"va_list* {:p}\", self)\n+        write!(f, \"va_list* {:p}\", self.ptr)\n     }\n }\n \n@@ -79,12 +89,14 @@ impl fmt::Debug for VaListImpl {\n            reason = \"the `c_variadic` feature has not been properly tested on \\\n                      all supported platforms\",\n            issue = \"44930\")]\n-struct VaListImpl {\n+#[lang = \"va_list\"]\n+pub struct VaListImpl<'f> {\n     stack: *mut c_void,\n     gr_top: *mut c_void,\n     vr_top: *mut c_void,\n     gr_offs: i32,\n     vr_offs: i32,\n+    _marker: PhantomData<&'f c_void>,\n }\n \n /// PowerPC ABI implementation of a `va_list`.\n@@ -95,12 +107,14 @@ struct VaListImpl {\n            reason = \"the `c_variadic` feature has not been properly tested on \\\n                      all supported platforms\",\n            issue = \"44930\")]\n-struct VaListImpl {\n+#[lang = \"va_list\"]\n+pub struct VaListImpl<'f> {\n     gpr: u8,\n     fpr: u8,\n     reserved: u16,\n     overflow_arg_area: *mut c_void,\n     reg_save_area: *mut c_void,\n+    _marker: PhantomData<&'f c_void>,\n }\n \n /// x86_64 ABI implementation of a `va_list`.\n@@ -111,22 +125,131 @@ struct VaListImpl {\n            reason = \"the `c_variadic` feature has not been properly tested on \\\n                      all supported platforms\",\n            issue = \"44930\")]\n-struct VaListImpl {\n+#[lang = \"va_list\"]\n+pub struct VaListImpl<'f> {\n     gp_offset: i32,\n     fp_offset: i32,\n     overflow_arg_area: *mut c_void,\n     reg_save_area: *mut c_void,\n+    _marker: PhantomData<&'f c_void>,\n }\n \n-/// A wrapper for a `va_list`\n+/// asm.js ABI implementation of a `va_list`.\n+// asm.js uses the PNaCl ABI, which specifies that a `va_list` is\n+// an array of 4 32-bit integers, according to the old PNaCl docs at\n+// https://web.archive.org/web/20130518054430/https://www.chromium.org/nativeclient/pnacl/bitcode-abi#TOC-Derived-Types\n+// and clang does the same in `CreatePNaClABIBuiltinVaListDecl` from `lib/AST/ASTContext.cpp`\n+#[cfg(all(target_arch = \"asmjs\", not(windows)))]\n+#[repr(C)]\n+#[unstable(feature = \"c_variadic\",\n+           reason = \"the `c_variadic` feature has not been properly tested on \\\n+                     all supported platforms\",\n+           issue = \"44930\")]\n #[lang = \"va_list\"]\n-#[derive(Debug)]\n+pub struct VaListImpl<'f> {\n+    inner: [crate::mem::MaybeUninit<i32>; 4],\n+    _marker: PhantomData<&'f c_void>,\n+}\n+\n+#[cfg(all(target_arch = \"asmjs\", not(windows)))]\n #[unstable(feature = \"c_variadic\",\n            reason = \"the `c_variadic` feature has not been properly tested on \\\n                      all supported platforms\",\n            issue = \"44930\")]\n+impl<'f> fmt::Debug for VaListImpl<'f> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        unsafe {\n+            write!(f, \"va_list* [{:#x}, {:#x}, {:#x}, {:#x}]\",\n+                   self.inner[0].read(), self.inner[1].read(),\n+                   self.inner[2].read(), self.inner[3].read())\n+        }\n+    }\n+}\n+\n+/// A wrapper for a `va_list`\n #[repr(transparent)]\n-pub struct VaList<'a>(&'a mut VaListImpl);\n+#[derive(Debug)]\n+#[unstable(feature = \"c_variadic\",\n+           reason = \"the `c_variadic` feature has not been properly tested on \\\n+                     all supported platforms\",\n+           issue = \"44930\")]\n+pub struct VaList<'a, 'f: 'a> {\n+    #[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n+                  not(target_arch = \"x86_64\"), not(target_arch = \"asmjs\")),\n+              all(target_arch = \"aarch64\", target_os = \"ios\"),\n+              windows))]\n+    inner: VaListImpl<'f>,\n+\n+    #[cfg(all(any(target_arch = \"aarch64\", target_arch = \"powerpc\",\n+                  target_arch = \"x86_64\", target_arch = \"asmjs\"),\n+              any(not(target_arch = \"aarch64\"), not(target_os = \"ios\")),\n+              not(windows)))]\n+    inner: &'a mut VaListImpl<'f>,\n+\n+    _marker: PhantomData<&'a mut VaListImpl<'f>>,\n+}\n+\n+#[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n+              not(target_arch = \"x86_64\"), not(target_arch = \"asmjs\")),\n+          all(target_arch = \"aarch64\", target_os = \"ios\"),\n+          windows))]\n+#[unstable(feature = \"c_variadic\",\n+           reason = \"the `c_variadic` feature has not been properly tested on \\\n+                     all supported platforms\",\n+           issue = \"44930\")]\n+impl<'f> VaListImpl<'f> {\n+    /// Convert a `VaListImpl` into a `VaList` that is binary-compatible with C's `va_list`.\n+    #[inline]\n+    pub fn as_va_list<'a>(&'a mut self) -> VaList<'a, 'f> {\n+        VaList {\n+            inner: VaListImpl { ..*self },\n+            _marker: PhantomData,\n+        }\n+    }\n+}\n+\n+#[cfg(all(any(target_arch = \"aarch64\", target_arch = \"powerpc\",\n+              target_arch = \"x86_64\", target_arch = \"asmjs\"),\n+          any(not(target_arch = \"aarch64\"), not(target_os = \"ios\")),\n+          not(windows)))]\n+#[unstable(feature = \"c_variadic\",\n+           reason = \"the `c_variadic` feature has not been properly tested on \\\n+                     all supported platforms\",\n+           issue = \"44930\")]\n+impl<'f> VaListImpl<'f> {\n+    /// Convert a `VaListImpl` into a `VaList` that is binary-compatible with C's `va_list`.\n+    #[inline]\n+    pub fn as_va_list<'a>(&'a mut self) -> VaList<'a, 'f> {\n+        VaList {\n+            inner: self,\n+            _marker: PhantomData,\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"c_variadic\",\n+           reason = \"the `c_variadic` feature has not been properly tested on \\\n+                     all supported platforms\",\n+           issue = \"44930\")]\n+impl<'a, 'f: 'a> Deref for VaList<'a, 'f> {\n+    type Target = VaListImpl<'f>;\n+\n+    #[inline]\n+    fn deref(&self) -> &VaListImpl<'f> {\n+        &self.inner\n+    }\n+}\n+\n+#[unstable(feature = \"c_variadic\",\n+           reason = \"the `c_variadic` feature has not been properly tested on \\\n+                     all supported platforms\",\n+           issue = \"44930\")]\n+impl<'a, 'f: 'a> DerefMut for VaList<'a, 'f> {\n+    #[inline]\n+    fn deref_mut(&mut self) -> &mut VaListImpl<'f> {\n+        &mut self.inner\n+    }\n+}\n \n // The VaArgSafe trait needs to be used in public interfaces, however, the trait\n // itself must not be allowed to be used outside this module. Allowing users to\n@@ -175,56 +298,76 @@ impl<T> sealed_trait::VaArgSafe for *mut T {}\n            issue = \"44930\")]\n impl<T> sealed_trait::VaArgSafe for *const T {}\n \n-impl<'a> VaList<'a> {\n+#[unstable(feature = \"c_variadic\",\n+           reason = \"the `c_variadic` feature has not been properly tested on \\\n+                     all supported platforms\",\n+           issue = \"44930\")]\n+#[cfg(not(bootstrap))]\n+impl<'f> VaListImpl<'f> {\n     /// Advance to the next arg.\n-    #[unstable(feature = \"c_variadic\",\n-               reason = \"the `c_variadic` feature has not been properly tested on \\\n-                         all supported platforms\",\n-               issue = \"44930\")]\n+    #[inline]\n     pub unsafe fn arg<T: sealed_trait::VaArgSafe>(&mut self) -> T {\n         va_arg(self)\n     }\n \n     /// Copies the `va_list` at the current location.\n-    #[unstable(feature = \"c_variadic\",\n-               reason = \"the `c_variadic` feature has not been properly tested on \\\n-                         all supported platforms\",\n-               issue = \"44930\")]\n     pub unsafe fn with_copy<F, R>(&self, f: F) -> R\n-            where F: for<'copy> FnOnce(VaList<'copy>) -> R {\n-        #[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n-                      not(target_arch = \"x86_64\")),\n-                  all(target_arch = \"aarch64\", target_os = \"ios\"),\n-                  windows))]\n-        let mut ap = va_copy(self);\n-        #[cfg(all(any(target_arch = \"aarch64\", target_arch = \"powerpc\", target_arch = \"x86_64\"),\n-                  not(windows), not(all(target_arch = \"aarch64\", target_os = \"ios\"))))]\n-        let mut ap_inner = va_copy(self);\n-        #[cfg(all(any(target_arch = \"aarch64\", target_arch = \"powerpc\", target_arch = \"x86_64\"),\n-                  not(windows), not(all(target_arch = \"aarch64\", target_os = \"ios\"))))]\n-        let mut ap = VaList(&mut ap_inner);\n-        let ret = f(VaList(ap.0));\n+            where F: for<'copy> FnOnce(VaList<'copy, 'f>) -> R {\n+        let mut ap = self.clone();\n+        let ret = f(ap.as_va_list());\n         va_end(&mut ap);\n         ret\n     }\n }\n \n+#[unstable(feature = \"c_variadic\",\n+           reason = \"the `c_variadic` feature has not been properly tested on \\\n+                     all supported platforms\",\n+           issue = \"44930\")]\n+#[cfg(not(bootstrap))]\n+impl<'f> Clone for VaListImpl<'f> {\n+    #[inline]\n+    fn clone(&self) -> Self {\n+        let mut dest = crate::mem::MaybeUninit::uninit();\n+        unsafe {\n+            va_copy(dest.as_mut_ptr(), self);\n+            dest.assume_init()\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"c_variadic\",\n+           reason = \"the `c_variadic` feature has not been properly tested on \\\n+                     all supported platforms\",\n+           issue = \"44930\")]\n+#[cfg(not(bootstrap))]\n+impl<'f> Drop for VaListImpl<'f> {\n+    fn drop(&mut self) {\n+        // FIXME: this should call `va_end`, but there's no clean way to\n+        // guarantee that `drop` always gets inlined into its caller,\n+        // so the `va_end` would get directly called from the same function as\n+        // the corresponding `va_copy`. `man va_end` states that C requires this,\n+        // and LLVM basically follows the C semantics, so we need to make sure\n+        // that `va_end` is always called from the same function as `va_copy`.\n+        // For more details, see https://github.com/rust-lang/rust/pull/59625\n+        // and https://llvm.org/docs/LangRef.html#llvm-va-end-intrinsic.\n+        //\n+        // This works for now, since `va_end` is a no-op on all current LLVM targets.\n+    }\n+}\n+\n extern \"rust-intrinsic\" {\n     /// Destroy the arglist `ap` after initialization with `va_start` or\n     /// `va_copy`.\n-    fn va_end(ap: &mut VaList<'_>);\n+    #[cfg(not(bootstrap))]\n+    fn va_end(ap: &mut VaListImpl<'_>);\n \n     /// Copies the current location of arglist `src` to the arglist `dst`.\n-    #[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n-                  not(target_arch = \"x86_64\")),\n-              all(target_arch = \"aarch64\", target_os = \"ios\"),\n-              windows))]\n-    fn va_copy<'a>(src: &VaList<'a>) -> VaList<'a>;\n-    #[cfg(all(any(target_arch = \"aarch64\", target_arch = \"powerpc\", target_arch = \"x86_64\"),\n-              not(windows), not(all(target_arch = \"aarch64\", target_os = \"ios\"))))]\n-    fn va_copy(src: &VaList<'_>) -> VaListImpl;\n+    #[cfg(not(bootstrap))]\n+    fn va_copy<'f>(dest: *mut VaListImpl<'f>, src: &VaListImpl<'f>);\n \n     /// Loads an argument of type `T` from the `va_list` `ap` and increment the\n     /// argument `ap` points to.\n-    fn va_arg<T: sealed_trait::VaArgSafe>(ap: &mut VaList<'_>) -> T;\n+    #[cfg(not(bootstrap))]\n+    fn va_arg<T: sealed_trait::VaArgSafe>(ap: &mut VaListImpl<'_>) -> T;\n }"}, {"sha": "b30eff8baa9c87347c605d87382bf0848024cd7c", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -1607,3 +1607,9 @@ pub fn maxnumf64(x: f64, y: f64) -> f64 {\n     // Identical to the `f32` case.\n     (if x < y || x != x { y } else { x }) * 1.0\n }\n+\n+/// For bootstrapping, implement unchecked_sub as just wrapping_sub.\n+#[cfg(bootstrap)]\n+pub unsafe fn unchecked_sub<T>(x: T, y: T) -> T {\n+    sub_with_overflow(x, y).0\n+}"}, {"sha": "c2edcd22f953b45d0fecc20167b3d8eea20af3a9", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -1509,6 +1509,20 @@ impl<I> DoubleEndedIterator for Skip<I> where I: DoubleEndedIterator + ExactSize\n         }\n     }\n \n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<I::Item> {\n+        let len = self.len();\n+        if n < len {\n+            self.iter.nth_back(n)\n+        } else {\n+            if len > 0 {\n+                // consume the original iterator\n+                self.iter.nth_back(len-1);\n+            }\n+            None\n+        }\n+    }\n+\n     fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {"}, {"sha": "1bfb852424d63a69f047a2c4555565203eee4d12", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -100,6 +100,7 @@\n #![feature(staged_api)]\n #![feature(std_internals)]\n #![feature(stmt_expr_attributes)]\n+#![cfg_attr(not(bootstrap), feature(transparent_unions))]\n #![feature(unboxed_closures)]\n #![feature(unsized_locals)]\n #![feature(untagged_unions)]"}, {"sha": "28e1e22ba7ff298e4800f4c5219b66cc5372442c", "filename": "src/libcore/mem/maybe_uninit.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -172,7 +172,7 @@ use crate::mem::ManuallyDrop;\n ///\n /// # Layout\n ///\n-/// `MaybeUninit<T>` is guaranteed to have the same size and alignment as `T`:\n+/// `MaybeUninit<T>` is guaranteed to have the same size, alignment, and ABI as `T`:\n ///\n /// ```rust\n /// use std::mem::{MaybeUninit, size_of, align_of};\n@@ -191,9 +191,23 @@ use crate::mem::ManuallyDrop;\n /// assert_eq!(size_of::<Option<bool>>(), 1);\n /// assert_eq!(size_of::<Option<MaybeUninit<bool>>>(), 2);\n /// ```\n+///\n+/// If `T` is FFI-safe, then so is `MaybeUninit<T>`.\n+///\n+/// While `MaybeUninit` is `#[repr(transparent)]` (indicating it guarantees the same size,\n+/// alignment, and ABI as `T`), this does *not* change any of the previous caveats. `Option<T>` and\n+/// `Option<MaybeUninit<T>>` may still have different sizes, and types containing a field of type\n+/// `T` may be laid out (and sized) differently than if that field were `MaybeUninit<T>`.\n+/// `MaybeUninit` is a union type, and `#[repr(transparent)]` on unions is unstable (see [the\n+/// tracking issue](https://github.com/rust-lang/rust/issues/60405)). Over time, the exact\n+/// guarantees of `#[repr(transparent)]` on unions may evolve, and `MaybeUninit` may or may not\n+/// remain `#[repr(transparent)]`. That said, `MaybeUninit<T>` will *always* guarantee that it has\n+/// the same size, alignment, and ABI as `T`; it's just that the way `MaybeUninit` implements that\n+/// guarantee may evolve.\n #[allow(missing_debug_implementations)]\n #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n #[derive(Copy)]\n+#[cfg_attr(not(bootstrap), repr(transparent))]\n pub union MaybeUninit<T> {\n     uninit: (),\n     value: ManuallyDrop<T>,"}, {"sha": "ba88fde6ebc97afa70aa3f7eddecafd1b93171ea", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -230,6 +230,53 @@ pub const fn null<T>() -> *const T { 0 as *const T }\n #[rustc_promotable]\n pub const fn null_mut<T>() -> *mut T { 0 as *mut T }\n \n+#[repr(C)]\n+pub(crate) union Repr<T> {\n+    pub(crate) rust: *const [T],\n+    rust_mut: *mut [T],\n+    pub(crate) raw: FatPtr<T>,\n+}\n+\n+#[repr(C)]\n+pub(crate) struct FatPtr<T> {\n+    data: *const T,\n+    pub(crate) len: usize,\n+}\n+\n+/// Forms a slice from a pointer and a length.\n+///\n+/// The `len` argument is the number of **elements**, not the number of bytes.\n+///\n+/// # Examples\n+///\n+/// ```rust\n+/// #![feature(slice_from_raw_parts)]\n+/// use std::ptr;\n+///\n+/// // create a slice pointer when starting out with a pointer to the first element\n+/// let mut x = [5, 6, 7];\n+/// let ptr = &mut x[0] as *mut _;\n+/// let slice = ptr::slice_from_raw_parts_mut(ptr, 3);\n+/// assert_eq!(unsafe { &*slice }[2], 7);\n+/// ```\n+#[inline]\n+#[unstable(feature = \"slice_from_raw_parts\", reason = \"recently added\", issue = \"36925\")]\n+pub fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n+    unsafe { Repr { raw: FatPtr { data, len } }.rust }\n+}\n+\n+/// Performs the same functionality as [`from_raw_parts`], except that a\n+/// mutable slice is returned.\n+///\n+/// See the documentation of [`from_raw_parts`] for more details.\n+///\n+/// [`from_raw_parts`]: ../../std/slice/fn.from_raw_parts.html\n+#[inline]\n+#[unstable(feature = \"slice_from_raw_parts\", reason = \"recently added\", issue = \"36925\")]\n+pub fn slice_from_raw_parts_mut<T>(data: *mut T, len: usize) -> *mut [T] {\n+    unsafe { Repr { raw: FatPtr { data, len } }.rust_mut }\n+}\n+\n /// Swaps the values at two mutable locations of the same type, without\n /// deinitializing either.\n ///"}, {"sha": "c6d44324ef5ee16a8eb81464f3420ccc3ece5fc7", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 75, "deletions": 41, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -25,7 +25,7 @@\n use crate::cmp::Ordering::{self, Less, Equal, Greater};\n use crate::cmp;\n use crate::fmt;\n-use crate::intrinsics::assume;\n+use crate::intrinsics::{assume, exact_div, unchecked_sub};\n use crate::isize;\n use crate::iter::*;\n use crate::ops::{FnMut, Try, self};\n@@ -45,19 +45,6 @@ pub mod memchr;\n mod rotate;\n mod sort;\n \n-#[repr(C)]\n-union Repr<'a, T: 'a> {\n-    rust: &'a [T],\n-    rust_mut: &'a mut [T],\n-    raw: FatPtr<T>,\n-}\n-\n-#[repr(C)]\n-struct FatPtr<T> {\n-    data: *const T,\n-    len: usize,\n-}\n-\n //\n // Extension traits\n //\n@@ -78,7 +65,7 @@ impl<T> [T] {\n     #[rustc_const_unstable(feature = \"const_slice_len\")]\n     pub const fn len(&self) -> usize {\n         unsafe {\n-            Repr { rust: self }.raw.len\n+            crate::ptr::Repr { rust: self }.raw.len\n         }\n     }\n \n@@ -2998,14 +2985,27 @@ macro_rules! is_empty {\n // unexpected way. (Tested by `codegen/slice-position-bounds-check`.)\n macro_rules! len {\n     ($self: ident) => {{\n+        #![allow(unused_unsafe)] // we're sometimes used within an unsafe block\n+\n         let start = $self.ptr;\n-        let diff = ($self.end as usize).wrapping_sub(start as usize);\n         let size = size_from_ptr(start);\n         if size == 0 {\n+            // This _cannot_ use `unchecked_sub` because we depend on wrapping\n+            // to represent the length of long ZST slice iterators.\n+            let diff = ($self.end as usize).wrapping_sub(start as usize);\n             diff\n         } else {\n-            // Using division instead of `offset_from` helps LLVM remove bounds checks\n-            diff / size\n+            // We know that `start <= end`, so can do better than `offset_from`,\n+            // which needs to deal in signed.  By setting appropriate flags here\n+            // we can tell LLVM this, which helps it remove bounds checks.\n+            // SAFETY: By the type invariant, `start <= end`\n+            let diff = unsafe { unchecked_sub($self.end as usize, start as usize) };\n+            // By also telling LLVM that the pointers are apart by an exact\n+            // multiple of the type size, it can optimize `len() == 0` down to\n+            // `start == end` instead of `(end - start) < size`.\n+            // SAFETY: By the type invariant, the pointers are aligned so the\n+            //         distance between them must be a multiple of pointee size\n+            unsafe { exact_div(diff, size) }\n         }\n     }}\n }\n@@ -3019,6 +3019,28 @@ macro_rules! iterator {\n         {$( $mut_:tt )*},\n         {$($extra:tt)*}\n     ) => {\n+        // Returns the first element and moves the start of the iterator forwards by 1.\n+        // Greatly improves performance compared to an inlined function. The iterator\n+        // must not be empty.\n+        macro_rules! next_unchecked {\n+            ($self: ident) => {& $( $mut_ )* *$self.post_inc_start(1)}\n+        }\n+\n+        // Returns the last element and moves the end of the iterator backwards by 1.\n+        // Greatly improves performance compared to an inlined function. The iterator\n+        // must not be empty.\n+        macro_rules! next_back_unchecked {\n+            ($self: ident) => {& $( $mut_ )* *$self.pre_dec_end(1)}\n+        }\n+\n+        // Shrinks the iterator when T is a ZST, by moving the end of the iterator\n+        // backwards by `n`. `n` must not exceed `self.len()`.\n+        macro_rules! zst_shrink {\n+            ($self: ident, $n: ident) => {\n+                $self.end = ($self.end as * $raw_mut u8).wrapping_offset(-$n) as * $raw_mut T;\n+            }\n+        }\n+\n         impl<'a, T> $name<'a, T> {\n             // Helper function for creating a slice from the iterator.\n             #[inline(always)]\n@@ -3028,12 +3050,11 @@ macro_rules! iterator {\n \n             // Helper function for moving the start of the iterator forwards by `offset` elements,\n             // returning the old start.\n-            // Unsafe because the offset must be in-bounds or one-past-the-end.\n+            // Unsafe because the offset must not exceed `self.len()`.\n             #[inline(always)]\n             unsafe fn post_inc_start(&mut self, offset: isize) -> * $raw_mut T {\n                 if mem::size_of::<T>() == 0 {\n-                    // This is *reducing* the length.  `ptr` never changes with ZST.\n-                    self.end = (self.end as * $raw_mut u8).wrapping_offset(-offset) as * $raw_mut T;\n+                    zst_shrink!(self, offset);\n                     self.ptr\n                 } else {\n                     let old = self.ptr;\n@@ -3044,11 +3065,11 @@ macro_rules! iterator {\n \n             // Helper function for moving the end of the iterator backwards by `offset` elements,\n             // returning the new end.\n-            // Unsafe because the offset must be in-bounds or one-past-the-end.\n+            // Unsafe because the offset must not exceed `self.len()`.\n             #[inline(always)]\n             unsafe fn pre_dec_end(&mut self, offset: isize) -> * $raw_mut T {\n                 if mem::size_of::<T>() == 0 {\n-                    self.end = (self.end as * $raw_mut u8).wrapping_offset(-offset) as * $raw_mut T;\n+                    zst_shrink!(self, offset);\n                     self.ptr\n                 } else {\n                     self.end = self.end.offset(-offset);\n@@ -3085,7 +3106,7 @@ macro_rules! iterator {\n                     if is_empty!(self) {\n                         None\n                     } else {\n-                        Some(& $( $mut_ )* *self.post_inc_start(1))\n+                        Some(next_unchecked!(self))\n                     }\n                 }\n             }\n@@ -3114,11 +3135,10 @@ macro_rules! iterator {\n                     }\n                     return None;\n                 }\n-                // We are in bounds. `offset` does the right thing even for ZSTs.\n+                // We are in bounds. `post_inc_start` does the right thing even for ZSTs.\n                 unsafe {\n-                    let elem = Some(& $( $mut_ )* *self.ptr.add(n));\n-                    self.post_inc_start((n as isize).wrapping_add(1));\n-                    elem\n+                    self.post_inc_start(n as isize);\n+                    Some(next_unchecked!(self))\n                 }\n             }\n \n@@ -3135,13 +3155,13 @@ macro_rules! iterator {\n                 let mut accum = init;\n                 unsafe {\n                     while len!(self) >= 4 {\n-                        accum = f(accum, & $( $mut_ )* *self.post_inc_start(1))?;\n-                        accum = f(accum, & $( $mut_ )* *self.post_inc_start(1))?;\n-                        accum = f(accum, & $( $mut_ )* *self.post_inc_start(1))?;\n-                        accum = f(accum, & $( $mut_ )* *self.post_inc_start(1))?;\n+                        accum = f(accum, next_unchecked!(self))?;\n+                        accum = f(accum, next_unchecked!(self))?;\n+                        accum = f(accum, next_unchecked!(self))?;\n+                        accum = f(accum, next_unchecked!(self))?;\n                     }\n                     while !is_empty!(self) {\n-                        accum = f(accum, & $( $mut_ )* *self.post_inc_start(1))?;\n+                        accum = f(accum, next_unchecked!(self))?;\n                     }\n                 }\n                 Try::from_ok(accum)\n@@ -3212,11 +3232,25 @@ macro_rules! iterator {\n                     if is_empty!(self) {\n                         None\n                     } else {\n-                        Some(& $( $mut_ )* *self.pre_dec_end(1))\n+                        Some(next_back_unchecked!(self))\n                     }\n                 }\n             }\n \n+            #[inline]\n+            fn nth_back(&mut self, n: usize) -> Option<$elem> {\n+                if n >= len!(self) {\n+                    // This iterator is now empty.\n+                    self.end = self.ptr;\n+                    return None;\n+                }\n+                // We are in bounds. `pre_dec_end` does the right thing even for ZSTs.\n+                unsafe {\n+                    self.pre_dec_end(n as isize);\n+                    Some(next_back_unchecked!(self))\n+                }\n+            }\n+\n             #[inline]\n             fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n                 Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n@@ -3225,14 +3259,14 @@ macro_rules! iterator {\n                 let mut accum = init;\n                 unsafe {\n                     while len!(self) >= 4 {\n-                        accum = f(accum, & $( $mut_ )* *self.pre_dec_end(1))?;\n-                        accum = f(accum, & $( $mut_ )* *self.pre_dec_end(1))?;\n-                        accum = f(accum, & $( $mut_ )* *self.pre_dec_end(1))?;\n-                        accum = f(accum, & $( $mut_ )* *self.pre_dec_end(1))?;\n+                        accum = f(accum, next_back_unchecked!(self))?;\n+                        accum = f(accum, next_back_unchecked!(self))?;\n+                        accum = f(accum, next_back_unchecked!(self))?;\n+                        accum = f(accum, next_back_unchecked!(self))?;\n                     }\n                     // inlining is_empty everywhere makes a huge performance difference\n                     while !is_empty!(self) {\n-                        accum = f(accum, & $( $mut_ )* *self.pre_dec_end(1))?;\n+                        accum = f(accum, next_back_unchecked!(self))?;\n                     }\n                 }\n                 Try::from_ok(accum)\n@@ -5182,7 +5216,7 @@ pub unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n     debug_assert!(data as usize % mem::align_of::<T>() == 0, \"attempt to create unaligned slice\");\n     debug_assert!(mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize,\n                   \"attempt to create slice covering half the address space\");\n-    Repr { raw: FatPtr { data, len } }.rust\n+    &*ptr::slice_from_raw_parts(data, len)\n }\n \n /// Performs the same functionality as [`from_raw_parts`], except that a\n@@ -5203,7 +5237,7 @@ pub unsafe fn from_raw_parts_mut<'a, T>(data: *mut T, len: usize) -> &'a mut [T]\n     debug_assert!(data as usize % mem::align_of::<T>() == 0, \"attempt to create unaligned slice\");\n     debug_assert!(mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize,\n                   \"attempt to create slice covering half the address space\");\n-    Repr { raw: FatPtr { data, len } }.rust_mut\n+    &mut *ptr::slice_from_raw_parts_mut(data, len)\n }\n \n /// Converts a reference to T into a slice of length 1 (without copying)."}, {"sha": "4d840ef24c8e68a2abe16763e08a8b166fc7faea", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -2333,6 +2333,40 @@ fn test_skip_try_folds() {\n     assert_eq!(iter.next_back(), Some(24));\n }\n \n+#[test]\n+fn test_skip_nth_back() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let mut it = xs.iter().skip(2);\n+    assert_eq!(it.nth_back(0), Some(&5));\n+    assert_eq!(it.nth_back(1), Some(&3));\n+    assert_eq!(it.nth_back(0), Some(&2));\n+    assert_eq!(it.nth_back(0), None);\n+\n+    let ys = [2, 3, 4, 5];\n+    let mut ity = ys.iter();\n+    let mut it = xs.iter().skip(2);\n+    assert_eq!(it.nth_back(1), ity.nth_back(1));\n+    assert_eq!(it.clone().nth(0), ity.clone().nth(0));\n+    assert_eq!(it.nth_back(0), ity.nth_back(0));\n+    assert_eq!(it.clone().nth(0), ity.clone().nth(0));\n+    assert_eq!(it.nth_back(0), ity.nth_back(0));\n+    assert_eq!(it.clone().nth(0), ity.clone().nth(0));\n+    assert_eq!(it.nth_back(0), ity.nth_back(0));\n+    assert_eq!(it.clone().nth(0), ity.clone().nth(0));\n+\n+    let mut it = xs.iter().skip(2);\n+    assert_eq!(it.nth_back(4), None);\n+    assert_eq!(it.nth_back(0), None);\n+\n+    let mut it = xs.iter();\n+    it.by_ref().skip(2).nth_back(3);\n+    assert_eq!(it.next_back(), Some(&1));\n+\n+    let mut it = xs.iter();\n+    it.by_ref().skip(2).nth_back(10);\n+    assert_eq!(it.next_back(), Some(&1));\n+}\n+\n #[test]\n fn test_take_try_folds() {\n     let f = &|acc, x| i32::checked_add(2*acc, x);"}, {"sha": "03e65d2fe0b81022ec341bdcfb4f89a54c9af5b1", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -88,6 +88,19 @@ fn test_iterator_nth() {\n     assert_eq!(iter.nth(1).unwrap(), &v[4]);\n }\n \n+#[test]\n+fn test_iterator_nth_back() {\n+    let v: &[_] = &[0, 1, 2, 3, 4];\n+    for i in 0..v.len() {\n+        assert_eq!(v.iter().nth_back(i).unwrap(), &v[v.len() - i - 1]);\n+    }\n+    assert_eq!(v.iter().nth_back(v.len()), None);\n+\n+    let mut iter = v.iter();\n+    assert_eq!(iter.nth_back(2).unwrap(), &v[2]);\n+    assert_eq!(iter.nth_back(1).unwrap(), &v[0]);\n+}\n+\n #[test]\n fn test_iterator_last() {\n     let v: &[_] = &[0, 1, 2, 3, 4];"}, {"sha": "8675632638712aa2593f77f1b1bcba0621316680", "filename": "src/libpanic_unwind/dummy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibpanic_unwind%2Fdummy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibpanic_unwind%2Fdummy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdummy.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -7,7 +7,7 @@ use core::any::Any;\n use core::intrinsics;\n \n pub fn payload() -> *mut u8 {\n-    0 as *mut u8\n+    core::ptr::null_mut()\n }\n \n pub unsafe fn cleanup(_ptr: *mut u8) -> Box<dyn Any + Send> {"}, {"sha": "809e4619812dec41c90575e81069f039e62e53d4", "filename": "src/libpanic_unwind/seh.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibpanic_unwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibpanic_unwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -104,7 +104,7 @@ mod imp {\n     pub const NAME2: [u8; 7] = [b'.', b'P', b'A', b'X', 0, 0, 0];\n \n     macro_rules! ptr {\n-        (0) => (0 as *mut u8);\n+        (0) => (core::ptr::null_mut());\n         ($e:expr) => ($e as *mut u8);\n     }\n }\n@@ -223,13 +223,13 @@ extern \"C\" {\n #[cfg_attr(not(test), lang = \"msvc_try_filter\")]\n static mut TYPE_DESCRIPTOR1: _TypeDescriptor = _TypeDescriptor {\n     pVFTable: unsafe { &TYPE_INFO_VTABLE } as *const _ as *const _,\n-    spare: 0 as *mut _,\n+    spare: core::ptr::null_mut(),\n     name: imp::NAME1,\n };\n \n static mut TYPE_DESCRIPTOR2: _TypeDescriptor = _TypeDescriptor {\n     pVFTable: unsafe { &TYPE_INFO_VTABLE } as *const _ as *const _,\n-    spare: 0 as *mut _,\n+    spare: core::ptr::null_mut(),\n     name: imp::NAME2,\n };\n "}, {"sha": "a7750edbb6f485f77d89bcc1a463f0c90abba14b", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -7,7 +7,7 @@ use crate::ty::{self, TyCtxt};\n use crate::hir::{self, PatKind};\n use crate::hir::def_id::DefId;\n \n-struct CFGBuilder<'a, 'tcx: 'a> {\n+struct CFGBuilder<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     owner_def_id: DefId,\n     tables: &'a ty::TypeckTables<'tcx>,\n@@ -42,7 +42,7 @@ pub fn construct<'tcx>(tcx: TyCtxt<'tcx>, body: &hir::Body) -> CFG {\n     let body_exit;\n \n     // Find the tables for this body.\n-    let owner_def_id = tcx.hir().local_def_id(tcx.hir().body_owner(body.id()));\n+    let owner_def_id = tcx.hir().body_owner_def_id(body.id());\n     let tables = tcx.typeck_tables_of(owner_def_id);\n \n     let mut cfg_builder = CFGBuilder {\n@@ -330,7 +330,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             hir::ExprKind::DropTemps(ref e) |\n             hir::ExprKind::Unary(_, ref e) |\n             hir::ExprKind::Field(ref e, _) |\n-            hir::ExprKind::Yield(ref e) |\n+            hir::ExprKind::Yield(ref e, _) |\n             hir::ExprKind::Repeat(ref e, _) => {\n                 self.straightline(expr, pred, Some(&**e).into_iter())\n             }\n@@ -357,7 +357,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             args: I) -> CFGIndex {\n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n         let ret = self.straightline(call_expr, func_or_rcvr_exit, args);\n-        let m = self.tcx.hir().get_module_parent_by_hir_id(call_expr.hir_id);\n+        let m = self.tcx.hir().get_module_parent(call_expr.hir_id);\n         if self.tcx.is_ty_uninhabited_from(m, self.tables.expr_ty(call_expr)) {\n             self.add_unreachable_node()\n         } else {"}, {"sha": "918120057d4d35a99b256e7ec61aba594780d1af", "filename": "src/librustc/cfg/graphviz.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fgraphviz.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -11,7 +11,7 @@ use crate::ty::TyCtxt;\n pub type Node<'a> = (cfg::CFGIndex, &'a cfg::CFGNode);\n pub type Edge<'a> = &'a cfg::CFGEdge;\n \n-pub struct LabelledCFG<'a, 'tcx: 'a> {\n+pub struct LabelledCFG<'a, 'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n     pub cfg: &'a cfg::CFG,\n     pub name: String,\n@@ -22,11 +22,11 @@ pub struct LabelledCFG<'a, 'tcx: 'a> {\n impl<'a, 'tcx> LabelledCFG<'a, 'tcx> {\n     fn local_id_to_string(&self, local_id: hir::ItemLocalId) -> String {\n         assert!(self.cfg.owner_def_id.is_local());\n-        let node_id = self.tcx.hir().hir_to_node_id(hir::HirId {\n+        let hir_id = hir::HirId {\n             owner: self.tcx.hir().def_index_to_hir_id(self.cfg.owner_def_id.index).owner,\n             local_id\n-        });\n-        let s = self.tcx.hir().node_to_string(node_id);\n+        };\n+        let s = self.tcx.hir().node_to_string(hir_id);\n \n         // Replacing newlines with \\\\l causes each line to be left-aligned,\n         // improving presentation of (long) pretty-printed expressions."}, {"sha": "82b0e50b50c481b3f02e42acdbdc6a5084c77b97", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -204,11 +204,9 @@ macro_rules! define_dep_nodes {\n         impl DepNode {\n             #[allow(unreachable_code, non_snake_case)]\n             #[inline(always)]\n-            pub fn new<'a, 'tcx>(tcx: TyCtxt<'tcx>,\n+            pub fn new<'tcx>(tcx: TyCtxt<'tcx>,\n                                        dep: DepConstructor<'tcx>)\n                                        -> DepNode\n-                where 'tcx: 'a,\n-                      'tcx: 'a\n             {\n                 match dep {\n                     $("}, {"sha": "1777d765cc8a66013c0cdc4f8a0475f7fe820f0a", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -74,7 +74,7 @@ impl<'a> FnKind<'a> {\n ///\n /// See the comments on `ItemLikeVisitor` for more details on the overall\n /// visit strategy.\n-pub enum NestedVisitorMap<'this, 'tcx: 'this> {\n+pub enum NestedVisitorMap<'this, 'tcx> {\n     /// Do not visit any nested things. When you add a new\n     /// \"non-nested\" thing, you will want to audit such uses to see if\n     /// they remain valid.\n@@ -171,7 +171,7 @@ pub trait Visitor<'v> : Sized {\n     /// but cannot supply a `Map`; see `nested_visit_map` for advice.\n     #[allow(unused_variables)]\n     fn visit_nested_item(&mut self, id: ItemId) {\n-        let opt_item = self.nested_visit_map().inter().map(|map| map.expect_item_by_hir_id(id.id));\n+        let opt_item = self.nested_visit_map().inter().map(|map| map.expect_item(id.id));\n         if let Some(item) = opt_item {\n             self.visit_item(item);\n         }\n@@ -773,7 +773,6 @@ pub fn walk_generic_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Generi\n \n pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics) {\n     walk_list!(visitor, visit_generic_param, &generics.params);\n-    visitor.visit_id(generics.where_clause.hir_id);\n     walk_list!(visitor, visit_where_predicate, &generics.where_clause.predicates);\n }\n \n@@ -1089,7 +1088,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n                 visitor.visit_expr(expr)\n             }\n         }\n-        ExprKind::Yield(ref subexpression) => {\n+        ExprKind::Yield(ref subexpression, _) => {\n             visitor.visit_expr(subexpression);\n         }\n         ExprKind::Lit(_) | ExprKind::Err => {}"}, {"sha": "c87ab6869372693e2353680df8b3c030d9a6c407", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 157, "deletions": 137, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -62,14 +62,14 @@ use syntax::errors;\n use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::print::pprust;\n use syntax::ptr::P;\n-use syntax::source_map::{self, respan, CompilerDesugaringKind, Spanned};\n+use syntax::source_map::{self, respan, ExpnInfo, CompilerDesugaringKind, Spanned};\n use syntax::source_map::CompilerDesugaringKind::IfTemporary;\n use syntax::std_inject;\n use syntax::symbol::{kw, sym, Symbol};\n use syntax::tokenstream::{TokenStream, TokenTree};\n use syntax::parse::token::{self, Token};\n use syntax::visit::{self, Visitor};\n-use syntax_pos::{DUMMY_SP, edition, Span};\n+use syntax_pos::{DUMMY_SP, Span};\n \n const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n \n@@ -95,8 +95,7 @@ pub struct LoweringContext<'a> {\n \n     modules: BTreeMap<NodeId, hir::ModuleItems>,\n \n-    is_generator: bool,\n-    is_async_body: bool,\n+    generator_kind: Option<hir::GeneratorKind>,\n \n     /// Used to get the current `fn`'s def span to point to when using `await`\n     /// outside of an `async fn`.\n@@ -142,6 +141,9 @@ pub struct LoweringContext<'a> {\n     current_hir_id_owner: Vec<(DefIndex, u32)>,\n     item_local_id_counters: NodeMap<u32>,\n     node_id_to_hir_id: IndexVec<NodeId, hir::HirId>,\n+\n+    allow_try_trait: Option<Lrc<[Symbol]>>,\n+    allow_gen_future: Option<Lrc<[Symbol]>>,\n }\n \n pub trait Resolver {\n@@ -261,12 +263,13 @@ pub fn lower_crate(\n         current_hir_id_owner: vec![(CRATE_DEF_INDEX, 0)],\n         item_local_id_counters: Default::default(),\n         node_id_to_hir_id: IndexVec::new(),\n-        is_generator: false,\n-        is_async_body: false,\n+        generator_kind: None,\n         current_item: None,\n         lifetimes_to_define: Vec::new(),\n         is_collecting_in_band_lifetimes: false,\n         in_scope_lifetimes: Vec::new(),\n+        allow_try_trait: Some([sym::try_trait][..].into()),\n+        allow_gen_future: Some([sym::gen_future][..].into()),\n     }.lower_crate(krate)\n }\n \n@@ -415,7 +418,7 @@ impl<'a> LoweringContext<'a> {\n         /// needed from arbitrary locations in the crate,\n         /// e.g., the number of lifetime generic parameters\n         /// declared for every type and trait definition.\n-        struct MiscCollector<'tcx, 'interner: 'tcx> {\n+        struct MiscCollector<'tcx, 'interner> {\n             lctx: &'tcx mut LoweringContext<'interner>,\n             hir_id_owner: Option<NodeId>,\n         }\n@@ -561,7 +564,7 @@ impl<'a> LoweringContext<'a> {\n             }\n         }\n \n-        struct ItemLowerer<'tcx, 'interner: 'tcx> {\n+        struct ItemLowerer<'tcx, 'interner> {\n             lctx: &'tcx mut LoweringContext<'interner>,\n         }\n \n@@ -605,15 +608,7 @@ impl<'a> LoweringContext<'a> {\n                 });\n \n                 if let Some(hir_id) = item_hir_id {\n-                    let item_generics = match self.lctx.items.get(&hir_id).unwrap().node {\n-                        hir::ItemKind::Impl(_, _, _, ref generics, ..)\n-                        | hir::ItemKind::Trait(_, _, ref generics, ..) => {\n-                            generics.params.clone()\n-                        }\n-                        _ => HirVec::new(),\n-                    };\n-\n-                    self.lctx.with_parent_impl_lifetime_defs(&item_generics, |this| {\n+                    self.lctx.with_parent_item_lifetime_defs(hir_id, |this| {\n                         let this = &mut ItemLowerer { lctx: this };\n                         if let ItemKind::Impl(.., ref opt_trait_ref, _, _) = item.node {\n                             this.with_trait_impl_ref(opt_trait_ref, |this| {\n@@ -790,18 +785,49 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn record_body(&mut self, arguments: HirVec<hir::Arg>, value: hir::Expr) -> hir::BodyId {\n-        if self.is_generator && self.is_async_body {\n-            span_err!(\n-                self.sess,\n-                value.span,\n-                E0727,\n-                \"`async` generators are not yet supported\",\n-            );\n-            self.sess.abort_if_errors();\n+    fn generator_movability_for_fn(\n+        &mut self,\n+        decl: &ast::FnDecl,\n+        fn_decl_span: Span,\n+        generator_kind: Option<hir::GeneratorKind>,\n+        movability: Movability,\n+    ) -> Option<hir::GeneratorMovability> {\n+        match generator_kind {\n+            Some(hir::GeneratorKind::Gen) =>  {\n+                if !decl.inputs.is_empty() {\n+                    span_err!(\n+                        self.sess,\n+                        fn_decl_span,\n+                        E0628,\n+                        \"generators cannot have explicit arguments\"\n+                    );\n+                    self.sess.abort_if_errors();\n+                }\n+                Some(match movability {\n+                    Movability::Movable => hir::GeneratorMovability::Movable,\n+                    Movability::Static => hir::GeneratorMovability::Static,\n+                })\n+            },\n+            Some(hir::GeneratorKind::Async) => {\n+                bug!(\"non-`async` closure body turned `async` during lowering\");\n+            },\n+            None => {\n+                if movability == Movability::Static {\n+                    span_err!(\n+                        self.sess,\n+                        fn_decl_span,\n+                        E0697,\n+                        \"closures cannot be static\"\n+                    );\n+                }\n+                None\n+            },\n         }\n+    }\n+\n+    fn record_body(&mut self, arguments: HirVec<hir::Arg>, value: hir::Expr) -> hir::BodyId {\n         let body = hir::Body {\n-            is_generator: self.is_generator || self.is_async_body,\n+            generator_kind: self.generator_kind,\n             arguments,\n             value,\n         };\n@@ -848,14 +874,10 @@ impl<'a> LoweringContext<'a> {\n         allow_internal_unstable: Option<Lrc<[Symbol]>>,\n     ) -> Span {\n         let mark = Mark::fresh(Mark::root());\n-        mark.set_expn_info(source_map::ExpnInfo {\n-            call_site: span,\n+        mark.set_expn_info(ExpnInfo {\n             def_site: Some(span),\n-            format: source_map::CompilerDesugaring(reason),\n             allow_internal_unstable,\n-            allow_internal_unsafe: false,\n-            local_inner_macros: false,\n-            edition: edition::Edition::from_session(),\n+            ..ExpnInfo::default(source_map::CompilerDesugaring(reason), span, self.sess.edition())\n         });\n         span.with_ctxt(SyntaxContext::empty().apply_mark(mark))\n     }\n@@ -1024,14 +1046,22 @@ impl<'a> LoweringContext<'a> {\n     // This should only be used with generics that have already had their\n     // in-band lifetimes added. In practice, this means that this function is\n     // only used when lowering a child item of a trait or impl.\n-    fn with_parent_impl_lifetime_defs<T, F>(&mut self,\n-        params: &HirVec<hir::GenericParam>,\n+    fn with_parent_item_lifetime_defs<T, F>(&mut self,\n+        parent_hir_id: hir::HirId,\n         f: F\n     ) -> T where\n         F: FnOnce(&mut LoweringContext<'_>) -> T,\n     {\n         let old_len = self.in_scope_lifetimes.len();\n-        let lt_def_names = params.iter().filter_map(|param| match param.kind {\n+\n+        let parent_generics = match self.items.get(&parent_hir_id).unwrap().node {\n+            hir::ItemKind::Impl(_, _, _, ref generics, ..)\n+            | hir::ItemKind::Trait(_, _, ref generics, ..) => {\n+                &generics.params[..]\n+            }\n+            _ => &[],\n+        };\n+        let lt_def_names = parent_generics.iter().filter_map(|param| match param.kind {\n             hir::GenericParamKind::Lifetime { .. } => Some(param.name.ident().modern()),\n             _ => None,\n         });\n@@ -1083,8 +1113,7 @@ impl<'a> LoweringContext<'a> {\n \n         lowered_generics.params = lowered_generics\n             .params\n-            .iter()\n-            .cloned()\n+            .into_iter()\n             .chain(in_band_defs)\n             .collect();\n \n@@ -1142,7 +1171,7 @@ impl<'a> LoweringContext<'a> {\n         };\n         let decl = self.lower_fn_decl(&ast_decl, None, /* impl trait allowed */ false, None);\n         let body_id = self.lower_fn_body(&ast_decl, |this| {\n-            this.is_async_body = true;\n+            this.generator_kind = Some(hir::GeneratorKind::Async);\n             body(this)\n         });\n         let generator = hir::Expr {\n@@ -1156,7 +1185,7 @@ impl<'a> LoweringContext<'a> {\n         let unstable_span = self.mark_span_with_reason(\n             CompilerDesugaringKind::Async,\n             span,\n-            Some(vec![sym::gen_future].into()),\n+            self.allow_gen_future.clone(),\n         );\n         let gen_future = self.expr_std_path(\n             unstable_span, &[sym::future, sym::from_generator], None, ThinVec::new());\n@@ -1167,12 +1196,10 @@ impl<'a> LoweringContext<'a> {\n         &mut self,\n         f: impl FnOnce(&mut LoweringContext<'_>) -> (HirVec<hir::Arg>, hir::Expr),\n     ) -> hir::BodyId {\n-        let prev_is_generator = mem::replace(&mut self.is_generator, false);\n-        let prev_is_async_body = mem::replace(&mut self.is_async_body, false);\n+        let prev_gen_kind = self.generator_kind.take();\n         let (arguments, result) = f(self);\n         let body_id = self.record_body(arguments, result);\n-        self.is_generator = prev_is_generator;\n-        self.is_async_body = prev_is_async_body;\n+        self.generator_kind = prev_gen_kind;\n         body_id\n     }\n \n@@ -1674,7 +1701,7 @@ impl<'a> LoweringContext<'a> {\n             }\n             TyKind::Mac(_) => bug!(\"`TyMac` should have been expanded by now.\"),\n             TyKind::CVarArgs => {\n-                // Create the implicit lifetime of the \"spoofed\" `VaList`.\n+                // Create the implicit lifetime of the \"spoofed\" `VaListImpl`.\n                 let span = self.sess.source_map().next_point(t.span.shrink_to_lo());\n                 let lt = self.new_implicit_lifetime(span);\n                 hir::TyKind::CVarArgs(lt)\n@@ -1727,8 +1754,8 @@ impl<'a> LoweringContext<'a> {\n                 generics: hir::Generics {\n                     params: lifetime_defs,\n                     where_clause: hir::WhereClause {\n-                        hir_id: lctx.next_id(),\n                         predicates: hir_vec![],\n+                        span,\n                     },\n                     span,\n                 },\n@@ -1788,7 +1815,7 @@ impl<'a> LoweringContext<'a> {\n         // This visitor walks over `impl Trait` bounds and creates defs for all lifetimes that\n         // appear in the bounds, excluding lifetimes that are created within the bounds.\n         // E.g., `'a`, `'b`, but not `'c` in `impl for<'c> SomeTrait<'a, 'b, 'c>`.\n-        struct ImplTraitLifetimeCollector<'r, 'a: 'r> {\n+        struct ImplTraitLifetimeCollector<'r, 'a> {\n             context: &'r mut LoweringContext<'a>,\n             parent: DefIndex,\n             exist_ty_id: NodeId,\n@@ -1799,7 +1826,7 @@ impl<'a> LoweringContext<'a> {\n             output_lifetime_params: Vec<hir::GenericParam>,\n         }\n \n-        impl<'r, 'a: 'r, 'v> hir::intravisit::Visitor<'v> for ImplTraitLifetimeCollector<'r, 'a> {\n+        impl<'r, 'a, 'v> hir::intravisit::Visitor<'v> for ImplTraitLifetimeCollector<'r, 'a> {\n             fn nested_visit_map<'this>(\n                 &'this mut self,\n             ) -> hir::intravisit::NestedVisitorMap<'this, 'v> {\n@@ -2619,8 +2646,8 @@ impl<'a> LoweringContext<'a> {\n                 generics: hir::Generics {\n                     params: generic_params,\n                     where_clause: hir::WhereClause {\n-                        hir_id: this.next_id(),\n                         predicates: hir_vec![],\n+                        span,\n                     },\n                     span,\n                 },\n@@ -2973,11 +3000,11 @@ impl<'a> LoweringContext<'a> {\n             AnonymousLifetimeMode::ReportError,\n             |this| {\n                 hir::WhereClause {\n-                    hir_id: this.lower_node_id(wc.id),\n                     predicates: wc.predicates\n                         .iter()\n                         .map(|predicate| this.lower_where_predicate(predicate))\n                         .collect(),\n+                    span: wc.span,\n                 }\n             },\n         )\n@@ -3086,8 +3113,8 @@ impl<'a> LoweringContext<'a> {\n             &NodeMap::default(),\n             itctx.reborrow(),\n         );\n-        let trait_ref = self.with_parent_impl_lifetime_defs(\n-            &bound_generic_params,\n+        let trait_ref = self.with_in_scope_lifetime_defs(\n+            &p.bound_generic_params,\n             |this| this.lower_trait_ref(&p.trait_ref, itctx),\n         );\n \n@@ -3574,8 +3601,7 @@ impl<'a> LoweringContext<'a> {\n                 // Essentially a single `use` which imports two names is desugared into\n                 // two imports.\n                 for (res, &new_node_id) in resolutions.zip([id1, id2].iter()) {\n-                    let vis = vis.clone();\n-                    let ident = ident.clone();\n+                    let ident = *ident;\n                     let mut path = path.clone();\n                     for seg in &mut path.segments {\n                         seg.id = self.sess.next_node_id();\n@@ -3588,19 +3614,7 @@ impl<'a> LoweringContext<'a> {\n                         let path =\n                             this.lower_path_extra(res, &path, ParamMode::Explicit, None);\n                         let item = hir::ItemKind::Use(P(path), hir::UseKind::Single);\n-                        let vis_kind = match vis.node {\n-                            hir::VisibilityKind::Public => hir::VisibilityKind::Public,\n-                            hir::VisibilityKind::Crate(sugar) => hir::VisibilityKind::Crate(sugar),\n-                            hir::VisibilityKind::Inherited => hir::VisibilityKind::Inherited,\n-                            hir::VisibilityKind::Restricted { ref path, hir_id: _ } => {\n-                                let path = this.renumber_segment_ids(path);\n-                                hir::VisibilityKind::Restricted {\n-                                    path,\n-                                    hir_id: this.next_id(),\n-                                }\n-                            }\n-                        };\n-                        let vis = respan(vis.span, vis_kind);\n+                        let vis = this.rebuild_vis(&vis);\n \n                         this.insert_item(\n                             hir::Item {\n@@ -3664,8 +3678,6 @@ impl<'a> LoweringContext<'a> {\n                 for &(ref use_tree, id) in trees {\n                     let new_hir_id = self.lower_node_id(id);\n \n-                    let mut vis = vis.clone();\n-                    let mut ident = ident.clone();\n                     let mut prefix = prefix.clone();\n \n                     // Give the segments new node-ids since they are being cloned.\n@@ -3679,27 +3691,16 @@ impl<'a> LoweringContext<'a> {\n                     // own its own names, we have to adjust the owner before\n                     // lowering the rest of the import.\n                     self.with_hir_id_owner(id, |this| {\n+                        let mut vis = this.rebuild_vis(&vis);\n+                        let mut ident = *ident;\n+\n                         let item = this.lower_use_tree(use_tree,\n                                                        &prefix,\n                                                        id,\n                                                        &mut vis,\n                                                        &mut ident,\n                                                        attrs);\n \n-                        let vis_kind = match vis.node {\n-                            hir::VisibilityKind::Public => hir::VisibilityKind::Public,\n-                            hir::VisibilityKind::Crate(sugar) => hir::VisibilityKind::Crate(sugar),\n-                            hir::VisibilityKind::Inherited => hir::VisibilityKind::Inherited,\n-                            hir::VisibilityKind::Restricted { ref path, hir_id: _ } => {\n-                                let path = this.renumber_segment_ids(path);\n-                                hir::VisibilityKind::Restricted {\n-                                    path: path,\n-                                    hir_id: this.next_id(),\n-                                }\n-                            }\n-                        };\n-                        let vis = respan(vis.span, vis_kind);\n-\n                         this.insert_item(\n                             hir::Item {\n                                 hir_id: new_hir_id,\n@@ -3745,15 +3746,35 @@ impl<'a> LoweringContext<'a> {\n     /// Paths like the visibility path in `pub(super) use foo::{bar, baz}` are repeated\n     /// many times in the HIR tree; for each occurrence, we need to assign distinct\n     /// `NodeId`s. (See, e.g., #56128.)\n-    fn renumber_segment_ids(&mut self, path: &P<hir::Path>) -> P<hir::Path> {\n-        debug!(\"renumber_segment_ids(path = {:?})\", path);\n-        let mut path = path.clone();\n-        for seg in path.segments.iter_mut() {\n-            if seg.hir_id.is_some() {\n-                seg.hir_id = Some(self.next_id());\n-            }\n+    fn rebuild_use_path(&mut self, path: &hir::Path) -> hir::Path {\n+        debug!(\"rebuild_use_path(path = {:?})\", path);\n+        let segments = path.segments.iter().map(|seg| hir::PathSegment {\n+            ident: seg.ident,\n+            hir_id: seg.hir_id.map(|_| self.next_id()),\n+            res: seg.res,\n+            args: None,\n+            infer_args: seg.infer_args,\n+        }).collect();\n+        hir::Path {\n+            span: path.span,\n+            res: path.res,\n+            segments,\n         }\n-        path\n+    }\n+\n+    fn rebuild_vis(&mut self, vis: &hir::Visibility) -> hir::Visibility {\n+        let vis_kind = match vis.node {\n+            hir::VisibilityKind::Public => hir::VisibilityKind::Public,\n+            hir::VisibilityKind::Crate(sugar) => hir::VisibilityKind::Crate(sugar),\n+            hir::VisibilityKind::Inherited => hir::VisibilityKind::Inherited,\n+            hir::VisibilityKind::Restricted { ref path, hir_id: _ } => {\n+                hir::VisibilityKind::Restricted {\n+                    path: P(self.rebuild_use_path(path)),\n+                    hir_id: self.next_id(),\n+                }\n+            }\n+        };\n+        respan(vis.span, vis_kind)\n     }\n \n     fn lower_trait_item(&mut self, i: &TraitItem) -> hir::TraitItem {\n@@ -4382,7 +4403,7 @@ impl<'a> LoweringContext<'a> {\n                     let unstable_span = this.mark_span_with_reason(\n                         CompilerDesugaringKind::TryBlock,\n                         body.span,\n-                        Some(vec![sym::try_trait].into()),\n+                        this.allow_try_trait.clone(),\n                     );\n                     let mut block = this.lower_block(body, true).into_inner();\n                     let tail = block.expr.take().map_or_else(\n@@ -4475,37 +4496,18 @@ impl<'a> LoweringContext<'a> {\n \n                     self.with_new_scopes(|this| {\n                         this.current_item = Some(fn_decl_span);\n-                        let mut is_generator = false;\n+                        let mut generator_kind = None;\n                         let body_id = this.lower_fn_body(decl, |this| {\n                             let e = this.lower_expr(body);\n-                            is_generator = this.is_generator;\n+                            generator_kind = this.generator_kind;\n                             e\n                         });\n-                        let generator_option = if is_generator {\n-                            if !decl.inputs.is_empty() {\n-                                span_err!(\n-                                    this.sess,\n-                                    fn_decl_span,\n-                                    E0628,\n-                                    \"generators cannot have explicit arguments\"\n-                                );\n-                                this.sess.abort_if_errors();\n-                            }\n-                            Some(match movability {\n-                                Movability::Movable => hir::GeneratorMovability::Movable,\n-                                Movability::Static => hir::GeneratorMovability::Static,\n-                            })\n-                        } else {\n-                            if movability == Movability::Static {\n-                                span_err!(\n-                                    this.sess,\n-                                    fn_decl_span,\n-                                    E0697,\n-                                    \"closures cannot be static\"\n-                                );\n-                            }\n-                            None\n-                        };\n+                        let generator_option = this.generator_movability_for_fn(\n+                            &decl,\n+                            fn_decl_span,\n+                            generator_kind,\n+                            movability,\n+                        );\n                         hir::ExprKind::Closure(\n                             this.lower_capture_clause(capture_clause),\n                             fn_decl,\n@@ -4677,12 +4679,26 @@ impl<'a> LoweringContext<'a> {\n             }\n \n             ExprKind::Yield(ref opt_expr) => {\n-                self.is_generator = true;\n+                match self.generator_kind {\n+                    Some(hir::GeneratorKind::Gen) => {},\n+                    Some(hir::GeneratorKind::Async) => {\n+                        span_err!(\n+                            self.sess,\n+                            e.span,\n+                            E0727,\n+                            \"`async` generators are not yet supported\",\n+                        );\n+                        self.sess.abort_if_errors();\n+                    },\n+                    None => {\n+                        self.generator_kind = Some(hir::GeneratorKind::Gen);\n+                    }\n+                }\n                 let expr = opt_expr\n                     .as_ref()\n                     .map(|x| self.lower_expr(x))\n                     .unwrap_or_else(|| self.expr_unit(e.span));\n-                hir::ExprKind::Yield(P(expr))\n+                hir::ExprKind::Yield(P(expr), hir::YieldSource::Yield)\n             }\n \n             ExprKind::Err => hir::ExprKind::Err,\n@@ -4968,13 +4984,13 @@ impl<'a> LoweringContext<'a> {\n                 let unstable_span = self.mark_span_with_reason(\n                     CompilerDesugaringKind::QuestionMark,\n                     e.span,\n-                    Some(vec![sym::try_trait].into()),\n+                    self.allow_try_trait.clone(),\n                 );\n                 let try_span = self.sess.source_map().end_point(e.span);\n                 let try_span = self.mark_span_with_reason(\n                     CompilerDesugaringKind::QuestionMark,\n                     try_span,\n-                    Some(vec![sym::try_trait].into()),\n+                    self.allow_try_trait.clone(),\n                 );\n \n                 // `Try::into_result(<expr>)`\n@@ -5754,19 +5770,23 @@ impl<'a> LoweringContext<'a> {\n         //         yield ();\n         //     }\n         // }\n-        if !self.is_async_body {\n-            let mut err = struct_span_err!(\n-                self.sess,\n-                await_span,\n-                E0728,\n-                \"`await` is only allowed inside `async` functions and blocks\"\n-            );\n-            err.span_label(await_span, \"only allowed inside `async` functions and blocks\");\n-            if let Some(item_sp) = self.current_item {\n-                err.span_label(item_sp, \"this is not `async`\");\n+        match self.generator_kind {\n+            Some(hir::GeneratorKind::Async) => {},\n+            Some(hir::GeneratorKind::Gen) |\n+            None => {\n+                let mut err = struct_span_err!(\n+                    self.sess,\n+                    await_span,\n+                    E0728,\n+                    \"`await` is only allowed inside `async` functions and blocks\"\n+                );\n+                err.span_label(await_span, \"only allowed inside `async` functions and blocks\");\n+                if let Some(item_sp) = self.current_item {\n+                    err.span_label(item_sp, \"this is not `async`\");\n+                }\n+                err.emit();\n+                return hir::ExprKind::Err;\n             }\n-            err.emit();\n-            return hir::ExprKind::Err;\n         }\n         let span = self.mark_span_with_reason(\n             CompilerDesugaringKind::Await,\n@@ -5776,7 +5796,7 @@ impl<'a> LoweringContext<'a> {\n         let gen_future_span = self.mark_span_with_reason(\n             CompilerDesugaringKind::Await,\n             await_span,\n-            Some(vec![sym::gen_future].into()),\n+            self.allow_gen_future.clone(),\n         );\n \n         // let mut pinned = <expr>;\n@@ -5864,7 +5884,7 @@ impl<'a> LoweringContext<'a> {\n             let unit = self.expr_unit(span);\n             let yield_expr = P(self.expr(\n                 span,\n-                hir::ExprKind::Yield(P(unit)),\n+                hir::ExprKind::Yield(P(unit), hir::YieldSource::Await),\n                 ThinVec::new(),\n             ));\n             self.stmt(span, hir::StmtKind::Expr(yield_expr))"}, {"sha": "60465c04ec62fec2edf925245384d55c08e0c7ab", "filename": "src/librustc/hir/map/hir_id_validator.rs", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -1,6 +1,5 @@\n use crate::hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n use crate::hir::{self, intravisit, HirId, ItemLocalId};\n-use syntax::ast::NodeId;\n use crate::hir::itemlikevisit::ItemLikeVisitor;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::{Lock, ParallelIterator, par_iter};\n@@ -27,19 +26,19 @@ pub fn check_crate<'hir>(hir_map: &hir::map::Map<'hir>) {\n     }\n }\n \n-struct HirIdValidator<'a, 'hir: 'a> {\n+struct HirIdValidator<'a, 'hir> {\n     hir_map: &'a hir::map::Map<'hir>,\n     owner_def_index: Option<DefIndex>,\n     hir_ids_seen: FxHashSet<ItemLocalId>,\n     errors: &'a Lock<Vec<String>>,\n }\n \n-struct OuterVisitor<'a, 'hir: 'a> {\n+struct OuterVisitor<'a, 'hir> {\n     hir_map: &'a hir::map::Map<'hir>,\n     errors: &'a Lock<Vec<String>>,\n }\n \n-impl<'a, 'hir: 'a> OuterVisitor<'a, 'hir> {\n+impl<'a, 'hir> OuterVisitor<'a, 'hir> {\n     fn new_inner_visitor(&self,\n                          hir_map: &'a hir::map::Map<'hir>)\n                          -> HirIdValidator<'a, 'hir> {\n@@ -52,7 +51,7 @@ impl<'a, 'hir: 'a> OuterVisitor<'a, 'hir> {\n     }\n }\n \n-impl<'a, 'hir: 'a> ItemLikeVisitor<'hir> for OuterVisitor<'a, 'hir> {\n+impl<'a, 'hir> ItemLikeVisitor<'hir> for OuterVisitor<'a, 'hir> {\n     fn visit_item(&mut self, i: &'hir hir::Item) {\n         let mut inner_visitor = self.new_inner_visitor(self.hir_map);\n         inner_visitor.check(i.hir_id, |this| intravisit::walk_item(this, i));\n@@ -69,7 +68,7 @@ impl<'a, 'hir: 'a> ItemLikeVisitor<'hir> for OuterVisitor<'a, 'hir> {\n     }\n }\n \n-impl<'a, 'hir: 'a> HirIdValidator<'a, 'hir> {\n+impl<'a, 'hir> HirIdValidator<'a, 'hir> {\n     #[cold]\n     #[inline(never)]\n     fn error(&self, f: impl FnOnce() -> String) {\n@@ -112,19 +111,9 @@ impl<'a, 'hir: 'a> HirIdValidator<'a, 'hir> {\n \n                 trace!(\"missing hir id {:#?}\", hir_id);\n \n-                // We are already in ICE mode here, so doing a linear search\n-                // should be fine.\n-                let (node_id, _) = self.hir_map\n-                                       .definitions()\n-                                       .node_to_hir_id\n-                                       .iter()\n-                                       .enumerate()\n-                                       .find(|&(_, &entry)| hir_id == entry)\n-                                       .expect(\"no node_to_hir_id entry\");\n-                let node_id = NodeId::from_usize(node_id);\n                 missing_items.push(format!(\"[local_id: {}, node:{}]\",\n                                            local_id,\n-                                           self.hir_map.node_to_string(node_id)));\n+                                           self.hir_map.node_to_string(hir_id)));\n             }\n             self.error(|| format!(\n                 \"ItemLocalIds not assigned densely in {}. \\\n@@ -138,13 +127,13 @@ impl<'a, 'hir: 'a> HirIdValidator<'a, 'hir> {\n                         owner: owner_def_index,\n                         local_id,\n                     })\n-                    .map(|h| format!(\"({:?} {})\", h, self.hir_map.hir_to_string(h)))\n+                    .map(|h| format!(\"({:?} {})\", h, self.hir_map.node_to_string(h)))\n                     .collect::<Vec<_>>()));\n         }\n     }\n }\n \n-impl<'a, 'hir: 'a> intravisit::Visitor<'hir> for HirIdValidator<'a, 'hir> {\n+impl<'a, 'hir> intravisit::Visitor<'hir> for HirIdValidator<'a, 'hir> {\n \n     fn nested_visit_map<'this>(&'this mut self)\n                                -> intravisit::NestedVisitorMap<'this, 'hir> {\n@@ -156,14 +145,14 @@ impl<'a, 'hir: 'a> intravisit::Visitor<'hir> for HirIdValidator<'a, 'hir> {\n \n         if hir_id == hir::DUMMY_HIR_ID {\n             self.error(|| format!(\"HirIdValidator: HirId {:?} is invalid\",\n-                                  self.hir_map.hir_to_string(hir_id)));\n+                                  self.hir_map.node_to_string(hir_id)));\n             return;\n         }\n \n         if owner != hir_id.owner {\n             self.error(|| format!(\n                 \"HirIdValidator: The recorded owner of {} is {} instead of {}\",\n-                self.hir_map.hir_to_string(hir_id),\n+                self.hir_map.node_to_string(hir_id),\n                 self.hir_map.def_path(DefId::local(hir_id.owner)).to_string_no_crate(),\n                 self.hir_map.def_path(DefId::local(owner)).to_string_no_crate()));\n         }"}, {"sha": "87da3273bd220b93fff33c5af9aacc09330689a6", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 44, "deletions": 130, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -35,7 +35,7 @@ mod def_collector;\n pub mod definitions;\n mod hir_id_validator;\n \n-/// Represents an entry and its parent `NodeId`.\n+/// Represents an entry and its parent `HirId`.\n #[derive(Copy, Clone, Debug)]\n pub struct Entry<'hir> {\n     parent: HirId,\n@@ -51,11 +51,11 @@ impl<'hir> Entry<'hir> {\n         }\n     }\n \n-    fn fn_decl(&self) -> Option<&FnDecl> {\n+    fn fn_decl(&self) -> Option<&'hir FnDecl> {\n         match self.node {\n             Node::Item(ref item) => {\n                 match item.node {\n-                    ItemKind::Fn(ref fn_decl, _, _, _) => Some(&fn_decl),\n+                    ItemKind::Fn(ref fn_decl, _, _, _) => Some(fn_decl),\n                     _ => None,\n                 }\n             }\n@@ -76,7 +76,7 @@ impl<'hir> Entry<'hir> {\n \n             Node::Expr(ref expr) => {\n                 match expr.node {\n-                    ExprKind::Closure(_, ref fn_decl, ..) => Some(&fn_decl),\n+                    ExprKind::Closure(_, ref fn_decl, ..) => Some(fn_decl),\n                     _ => None,\n                 }\n             }\n@@ -200,7 +200,7 @@ impl<'hir> Map<'hir> {\n     /// \"reveals\" the content of a node to the caller (who might not\n     /// otherwise have had access to those contents, and hence needs a\n     /// read recorded). If the function just returns a DefId or\n-    /// NodeId, no actual content was returned, so no read is needed.\n+    /// HirId, no actual content was returned, so no read is needed.\n     pub fn read(&self, hir_id: HirId) {\n         if let Some(entry) = self.lookup(hir_id) {\n             self.dep_graph.read_index(entry.dep_node);\n@@ -286,21 +286,11 @@ impl<'hir> Map<'hir> {\n         self.definitions.def_index_to_hir_id(def_index)\n     }\n \n-    #[inline]\n-    pub fn def_index_to_node_id(&self, def_index: DefIndex) -> NodeId {\n-        self.definitions.def_index_to_node_id(def_index)\n-    }\n-\n     #[inline]\n     pub fn local_def_id_to_hir_id(&self, def_id: LocalDefId) -> HirId {\n         self.definitions.def_index_to_hir_id(def_id.to_def_id().index)\n     }\n \n-    #[inline]\n-    pub fn local_def_id_to_node_id(&self, def_id: LocalDefId) -> NodeId {\n-        self.definitions.as_local_node_id(def_id.to_def_id()).unwrap()\n-    }\n-\n     fn def_kind(&self, node_id: NodeId) -> Option<DefKind> {\n         let node = if let Some(node) = self.find(node_id) {\n             node\n@@ -422,42 +412,30 @@ impl<'hir> Map<'hir> {\n         self.forest.krate.body(id)\n     }\n \n-    pub fn fn_decl(&self, node_id: ast::NodeId) -> Option<FnDecl> {\n-        let hir_id = self.node_to_hir_id(node_id);\n-        self.fn_decl_by_hir_id(hir_id)\n-    }\n-\n-    // FIXME(@ljedrz): replace the `NodeId` variant.\n-    pub fn fn_decl_by_hir_id(&self, hir_id: HirId) -> Option<FnDecl> {\n+    pub fn fn_decl_by_hir_id(&self, hir_id: HirId) -> Option<&'hir FnDecl> {\n         if let Some(entry) = self.find_entry(hir_id) {\n-            entry.fn_decl().cloned()\n+            entry.fn_decl()\n         } else {\n             bug!(\"no entry for hir_id `{}`\", hir_id)\n         }\n     }\n \n-    /// Returns the `NodeId` that corresponds to the definition of\n+    /// Returns the `HirId` that corresponds to the definition of\n     /// which this is the body of, i.e., a `fn`, `const` or `static`\n     /// item (possibly associated), a closure, or a `hir::AnonConst`.\n-    pub fn body_owner(&self, BodyId { hir_id }: BodyId) -> NodeId {\n+    pub fn body_owner(&self, BodyId { hir_id }: BodyId) -> HirId {\n         let parent = self.get_parent_node_by_hir_id(hir_id);\n         assert!(self.lookup(parent).map_or(false, |e| e.is_body_owner(hir_id)));\n-        self.hir_to_node_id(parent)\n+        parent\n     }\n \n     pub fn body_owner_def_id(&self, id: BodyId) -> DefId {\n-        self.local_def_id(self.body_owner(id))\n+        self.local_def_id_from_hir_id(self.body_owner(id))\n     }\n \n-    /// Given a `NodeId`, returns the `BodyId` associated with it,\n+    /// Given a `HirId`, returns the `BodyId` associated with it,\n     /// if the node is a body owner, otherwise returns `None`.\n-    pub fn maybe_body_owned_by(&self, id: NodeId) -> Option<BodyId> {\n-        let hir_id = self.node_to_hir_id(id);\n-        self.maybe_body_owned_by_by_hir_id(hir_id)\n-    }\n-\n-    // FIXME(@ljedrz): replace the `NodeId` variant.\n-    pub fn maybe_body_owned_by_by_hir_id(&self, hir_id: HirId) -> Option<BodyId> {\n+    pub fn maybe_body_owned_by(&self, hir_id: HirId) -> Option<BodyId> {\n         if let Some(entry) = self.find_entry(hir_id) {\n             if self.dep_graph.is_fully_enabled() {\n                 let hir_id_owner = hir_id.owner;\n@@ -473,19 +451,13 @@ impl<'hir> Map<'hir> {\n \n     /// Given a body owner's id, returns the `BodyId` associated with it.\n     pub fn body_owned_by(&self, id: HirId) -> BodyId {\n-        self.maybe_body_owned_by_by_hir_id(id).unwrap_or_else(|| {\n-            span_bug!(self.span_by_hir_id(id), \"body_owned_by: {} has no associated body\",\n-                      self.hir_to_string(id));\n+        self.maybe_body_owned_by(id).unwrap_or_else(|| {\n+            span_bug!(self.span(id), \"body_owned_by: {} has no associated body\",\n+                      self.node_to_string(id));\n         })\n     }\n \n-    pub fn body_owner_kind(&self, id: NodeId) -> BodyOwnerKind {\n-        let hir_id = self.node_to_hir_id(id);\n-        self.body_owner_kind_by_hir_id(hir_id)\n-    }\n-\n-    // FIXME(@ljedrz): replace the `NodeId` variant.\n-    pub fn body_owner_kind_by_hir_id(&self, id: HirId) -> BodyOwnerKind {\n+    pub fn body_owner_kind(&self, id: HirId) -> BodyOwnerKind {\n         match self.get_by_hir_id(id) {\n             Node::Item(&Item { node: ItemKind::Const(..), .. }) |\n             Node::TraitItem(&TraitItem { node: TraitItemKind::Const(..), .. }) |\n@@ -514,7 +486,7 @@ impl<'hir> Map<'hir> {\n             Node::Item(&Item { node: ItemKind::Trait(..), .. }) |\n             Node::Item(&Item { node: ItemKind::TraitAlias(..), .. }) => id,\n             Node::GenericParam(_) => self.get_parent_node_by_hir_id(id),\n-            _ => bug!(\"ty_param_owner: {} not a type parameter\", self.hir_to_string(id))\n+            _ => bug!(\"ty_param_owner: {} not a type parameter\", self.node_to_string(id))\n         }\n     }\n \n@@ -523,7 +495,7 @@ impl<'hir> Map<'hir> {\n             Node::Item(&Item { node: ItemKind::Trait(..), .. }) |\n             Node::Item(&Item { node: ItemKind::TraitAlias(..), .. }) => kw::SelfUpper,\n             Node::GenericParam(param) => param.name.ident().name,\n-            _ => bug!(\"ty_param_name: {} not a type parameter\", self.hir_to_string(id)),\n+            _ => bug!(\"ty_param_name: {} not a type parameter\", self.node_to_string(id)),\n         }\n     }\n \n@@ -576,7 +548,7 @@ impl<'hir> Map<'hir> {\n         let module = &self.forest.krate.modules[&node_id];\n \n         for id in &module.items {\n-            visitor.visit_item(self.expect_item_by_hir_id(*id));\n+            visitor.visit_item(self.expect_item(*id));\n         }\n \n         for id in &module.trait_items {\n@@ -709,7 +681,7 @@ impl<'hir> Map<'hir> {\n \n     /// If there is some error when walking the parents (e.g., a node does not\n     /// have a parent in the map or a node can't be found), then we return the\n-    /// last good `NodeId` we found. Note that reaching the crate root (`id == 0`),\n+    /// last good `HirId` we found. Note that reaching the crate root (`id == 0`),\n     /// is not an error, since items in the crate module have the crate root as\n     /// parent.\n     fn walk_parent_nodes<F, F2>(&self,\n@@ -745,15 +717,15 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    /// Retrieves the `NodeId` for `id`'s enclosing method, unless there's a\n+    /// Retrieves the `HirId` for `id`'s enclosing method, unless there's a\n     /// `while` or `loop` before reaching it, as block tail returns are not\n     /// available in them.\n     ///\n     /// ```\n     /// fn foo(x: usize) -> bool {\n     ///     if x == 1 {\n     ///         true  // `get_return_block` gets passed the `id` corresponding\n-    ///     } else {  // to this, it will return `foo`'s `NodeId`.\n+    ///     } else {  // to this, it will return `foo`'s `HirId`.\n     ///         false\n     ///     }\n     /// }\n@@ -793,17 +765,10 @@ impl<'hir> Map<'hir> {\n         self.walk_parent_nodes(id, match_fn, match_non_returning_block).ok()\n     }\n \n-    /// Retrieves the `NodeId` for `id`'s parent item, or `id` itself if no\n+    /// Retrieves the `HirId` for `id`'s parent item, or `id` itself if no\n     /// parent item is in this map. The \"parent item\" is the closest parent node\n     /// in the HIR which is recorded by the map and is an item, either an item\n     /// in a module, trait, or impl.\n-    pub fn get_parent(&self, id: NodeId) -> NodeId {\n-        let hir_id = self.node_to_hir_id(id);\n-        let parent_hir_id = self.get_parent_item(hir_id);\n-        self.hir_to_node_id(parent_hir_id)\n-    }\n-\n-    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn get_parent_item(&self, hir_id: HirId) -> HirId {\n         match self.walk_parent_nodes(hir_id, |node| match *node {\n             Node::Item(_) |\n@@ -819,13 +784,7 @@ impl<'hir> Map<'hir> {\n \n     /// Returns the `DefId` of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n-    pub fn get_module_parent(&self, id: NodeId) -> DefId {\n-        let hir_id = self.node_to_hir_id(id);\n-        self.get_module_parent_by_hir_id(hir_id)\n-    }\n-\n-    // FIXME(@ljedrz): replace the `NodeId` variant.\n-    pub fn get_module_parent_by_hir_id(&self, id: HirId) -> DefId {\n+    pub fn get_module_parent(&self, id: HirId) -> DefId {\n         self.local_def_id_from_hir_id(self.get_module_parent_node(id))\n     }\n \n@@ -901,23 +860,11 @@ impl<'hir> Map<'hir> {\n         Some(scope)\n     }\n \n-    pub fn get_parent_did(&self, id: NodeId) -> DefId {\n-        let hir_id = self.node_to_hir_id(id);\n-        self.get_parent_did_by_hir_id(hir_id)\n-    }\n-\n-    // FIXME(@ljedrz): replace the `NodeId` variant.\n-    pub fn get_parent_did_by_hir_id(&self, id: HirId) -> DefId {\n+    pub fn get_parent_did(&self, id: HirId) -> DefId {\n         self.local_def_id_from_hir_id(self.get_parent_item(id))\n     }\n \n-    pub fn get_foreign_abi(&self, id: NodeId) -> Abi {\n-        let hir_id = self.node_to_hir_id(id);\n-        self.get_foreign_abi_by_hir_id(hir_id)\n-    }\n-\n-    // FIXME(@ljedrz): replace the `NodeId` variant.\n-    pub fn get_foreign_abi_by_hir_id(&self, hir_id: HirId) -> Abi {\n+    pub fn get_foreign_abi(&self, hir_id: HirId) -> Abi {\n         let parent = self.get_parent_item(hir_id);\n         if let Some(entry) = self.find_entry(parent) {\n             if let Entry {\n@@ -927,33 +874,27 @@ impl<'hir> Map<'hir> {\n                 return nm.abi;\n             }\n         }\n-        bug!(\"expected foreign mod or inlined parent, found {}\", self.hir_to_string(parent))\n-    }\n-\n-    pub fn expect_item(&self, id: NodeId) -> &'hir Item {\n-        let hir_id = self.node_to_hir_id(id);\n-        self.expect_item_by_hir_id(hir_id)\n+        bug!(\"expected foreign mod or inlined parent, found {}\", self.node_to_string(parent))\n     }\n \n-    // FIXME(@ljedrz): replace the `NodeId` variant.\n-    pub fn expect_item_by_hir_id(&self, id: HirId) -> &'hir Item {\n+    pub fn expect_item(&self, id: HirId) -> &'hir Item {\n         match self.find_by_hir_id(id) { // read recorded by `find`\n             Some(Node::Item(item)) => item,\n-            _ => bug!(\"expected item, found {}\", self.hir_to_string(id))\n+            _ => bug!(\"expected item, found {}\", self.node_to_string(id))\n         }\n     }\n \n     pub fn expect_impl_item(&self, id: HirId) -> &'hir ImplItem {\n         match self.find_by_hir_id(id) {\n             Some(Node::ImplItem(item)) => item,\n-            _ => bug!(\"expected impl item, found {}\", self.hir_to_string(id))\n+            _ => bug!(\"expected impl item, found {}\", self.node_to_string(id))\n         }\n     }\n \n     pub fn expect_trait_item(&self, id: HirId) -> &'hir TraitItem {\n         match self.find_by_hir_id(id) {\n             Some(Node::TraitItem(item)) => item,\n-            _ => bug!(\"expected trait item, found {}\", self.hir_to_string(id))\n+            _ => bug!(\"expected trait item, found {}\", self.node_to_string(id))\n         }\n     }\n \n@@ -963,26 +904,26 @@ impl<'hir> Map<'hir> {\n                 match i.node {\n                     ItemKind::Struct(ref struct_def, _) |\n                     ItemKind::Union(ref struct_def, _) => struct_def,\n-                    _ => bug!(\"struct ID bound to non-struct {}\", self.hir_to_string(id))\n+                    _ => bug!(\"struct ID bound to non-struct {}\", self.node_to_string(id))\n                 }\n             }\n             Some(Node::Variant(variant)) => &variant.node.data,\n             Some(Node::Ctor(data)) => data,\n-            _ => bug!(\"expected struct or variant, found {}\", self.hir_to_string(id))\n+            _ => bug!(\"expected struct or variant, found {}\", self.node_to_string(id))\n         }\n     }\n \n     pub fn expect_variant(&self, id: HirId) -> &'hir Variant {\n         match self.find_by_hir_id(id) {\n             Some(Node::Variant(variant)) => variant,\n-            _ => bug!(\"expected variant, found {}\", self.hir_to_string(id)),\n+            _ => bug!(\"expected variant, found {}\", self.node_to_string(id)),\n         }\n     }\n \n     pub fn expect_foreign_item(&self, id: HirId) -> &'hir ForeignItem {\n         match self.find_by_hir_id(id) {\n             Some(Node::ForeignItem(item)) => item,\n-            _ => bug!(\"expected foreign item, found {}\", self.hir_to_string(id))\n+            _ => bug!(\"expected foreign item, found {}\", self.node_to_string(id))\n         }\n     }\n \n@@ -995,7 +936,7 @@ impl<'hir> Map<'hir> {\n     pub fn expect_expr_by_hir_id(&self, id: HirId) -> &'hir Expr {\n         match self.find_by_hir_id(id) { // read recorded by find\n             Some(Node::Expr(expr)) => expr,\n-            _ => bug!(\"expected expr, found {}\", self.hir_to_string(id))\n+            _ => bug!(\"expected expr, found {}\", self.node_to_string(id))\n         }\n     }\n \n@@ -1018,19 +959,13 @@ impl<'hir> Map<'hir> {\n             Node::GenericParam(param) => param.name.ident().name,\n             Node::Binding(&Pat { node: PatKind::Binding(_, _, l, _), .. }) => l.name,\n             Node::Ctor(..) => self.name_by_hir_id(self.get_parent_item(id)),\n-            _ => bug!(\"no name for {}\", self.hir_to_string(id))\n+            _ => bug!(\"no name for {}\", self.node_to_string(id))\n         }\n     }\n \n     /// Given a node ID, gets a list of attributes associated with the AST\n     /// corresponding to the node-ID.\n-    pub fn attrs(&self, id: NodeId) -> &'hir [ast::Attribute] {\n-        let hir_id = self.node_to_hir_id(id);\n-        self.attrs_by_hir_id(hir_id)\n-    }\n-\n-    // FIXME(@ljedrz): replace the `NodeId` variant.\n-    pub fn attrs_by_hir_id(&self, id: HirId) -> &'hir [ast::Attribute] {\n+    pub fn attrs(&self, id: HirId) -> &'hir [ast::Attribute] {\n         self.read(id); // reveals attributes on the node\n         let attrs = match self.find_entry(id).map(|entry| entry.node) {\n             Some(Node::Local(l)) => Some(&l.attrs[..]),\n@@ -1046,7 +981,7 @@ impl<'hir> Map<'hir> {\n             Some(Node::GenericParam(param)) => Some(&param.attrs[..]),\n             // Unit/tuple structs/variants take the attributes straight from\n             // the struct/variant definition.\n-            Some(Node::Ctor(..)) => return self.attrs_by_hir_id(self.get_parent_item(id)),\n+            Some(Node::Ctor(..)) => return self.attrs(self.get_parent_item(id)),\n             Some(Node::Crate) => Some(&self.forest.krate.attrs[..]),\n             _ => None\n         };\n@@ -1093,13 +1028,7 @@ impl<'hir> Map<'hir> {\n         })\n     }\n \n-    pub fn span(&self, id: NodeId) -> Span {\n-        let hir_id = self.node_to_hir_id(id);\n-        self.span_by_hir_id(hir_id)\n-    }\n-\n-    // FIXME(@ljedrz): replace the `NodeId` variant.\n-    pub fn span_by_hir_id(&self, hir_id: HirId) -> Span {\n+    pub fn span(&self, hir_id: HirId) -> Span {\n         self.read(hir_id); // reveals span from node\n         match self.find_entry(hir_id).map(|entry| entry.node) {\n             Some(Node::Item(item)) => item.span,\n@@ -1139,32 +1068,17 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn span_if_local(&self, id: DefId) -> Option<Span> {\n-        self.as_local_node_id(id).map(|id| self.span(id))\n+        self.as_local_hir_id(id).map(|id| self.span(id))\n     }\n \n-    pub fn node_to_string(&self, id: NodeId) -> String {\n-        hir_id_to_string(self, self.node_to_hir_id(id), true)\n-    }\n-\n-    // FIXME(@ljedrz): replace the `NodeId` variant.\n-    pub fn hir_to_string(&self, id: HirId) -> String {\n+    pub fn node_to_string(&self, id: HirId) -> String {\n         hir_id_to_string(self, id, true)\n     }\n \n-    pub fn node_to_user_string(&self, id: NodeId) -> String {\n-        hir_id_to_string(self, self.node_to_hir_id(id), false)\n-    }\n-\n-    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn hir_to_user_string(&self, id: HirId) -> String {\n         hir_id_to_string(self, id, false)\n     }\n \n-    pub fn node_to_pretty_string(&self, id: NodeId) -> String {\n-        print::to_string(self, |s| s.print_node(self.get(id)))\n-    }\n-\n-    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn hir_to_pretty_string(&self, id: HirId) -> String {\n         print::to_string(self, |s| s.print_node(self.get_by_hir_id(id)))\n     }\n@@ -1307,7 +1221,7 @@ pub fn map_crate<'hir>(sess: &crate::session::Session,\n impl<'hir> print::PpAnn for Map<'hir> {\n     fn nested(&self, state: &mut print::State<'_>, nested: print::Nested) -> io::Result<()> {\n         match nested {\n-            Nested::Item(id) => state.print_item(self.expect_item_by_hir_id(id.id)),\n+            Nested::Item(id) => state.print_item(self.expect_item(id.id)),\n             Nested::TraitItem(id) => state.print_trait_item(self.trait_item(id)),\n             Nested::ImplItem(id) => state.print_impl_item(self.impl_item(id)),\n             Nested::Body(id) => state.print_expr(&self.body(id).value),"}, {"sha": "2b46170a6d2322cc3e1313aff79b3e5d36c4c4b1", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 158, "deletions": 123, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -155,7 +155,7 @@ pub const DUMMY_HIR_ID: HirId = HirId {\n \n pub const DUMMY_ITEM_LOCAL_ID: ItemLocalId = ItemLocalId::MAX;\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Copy, HashStable)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub struct Lifetime {\n     pub hir_id: HirId,\n     pub span: Span,\n@@ -295,7 +295,7 @@ impl Lifetime {\n /// A `Path` is essentially Rust's notion of a name; for instance,\n /// `std::cmp::PartialEq`. It's represented as a sequence of identifiers,\n /// along with a bunch of supporting information.\n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, HashStable)]\n pub struct Path {\n     pub span: Span,\n     /// The resolution for the path.\n@@ -324,7 +324,7 @@ impl fmt::Display for Path {\n \n /// A segment of a path: an identifier, an optional lifetime, and a set of\n /// types.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct PathSegment {\n     /// The identifier portion of this path segment.\n     #[stable_hasher(project(name))]\n@@ -383,27 +383,23 @@ impl PathSegment {\n         }\n     }\n \n-    // FIXME: hack required because you can't create a static\n-    // `GenericArgs`, so you can't just return a `&GenericArgs`.\n-    pub fn with_generic_args<F, R>(&self, f: F) -> R\n-        where F: FnOnce(&GenericArgs) -> R\n-    {\n-        let dummy = GenericArgs::none();\n-        f(if let Some(ref args) = self.args {\n-            &args\n+    pub fn generic_args(&self) -> &GenericArgs {\n+        if let Some(ref args) = self.args {\n+            args\n         } else {\n-            &dummy\n-        })\n+            const DUMMY: &GenericArgs = &GenericArgs::none();\n+            DUMMY\n+        }\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct ConstArg {\n     pub value: AnonConst,\n     pub span: Span,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum GenericArg {\n     Lifetime(Lifetime),\n     Type(Ty),\n@@ -435,7 +431,7 @@ impl GenericArg {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct GenericArgs {\n     /// The generic arguments for this path segment.\n     pub args: HirVec<GenericArg>,\n@@ -449,7 +445,7 @@ pub struct GenericArgs {\n }\n \n impl GenericArgs {\n-    pub fn none() -> Self {\n+    pub const fn none() -> Self {\n         Self {\n             args: HirVec::new(),\n             bindings: HirVec::new(),\n@@ -509,7 +505,7 @@ pub enum TraitBoundModifier {\n /// `typeck::collect::compute_bounds` matches these against\n /// the \"special\" built-in traits (see `middle::lang_items`) and\n /// detects `Copy`, `Send` and `Sync`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum GenericBound {\n     Trait(PolyTraitRef, TraitBoundModifier),\n     Outlives(Lifetime),\n@@ -545,7 +541,7 @@ pub enum LifetimeParamKind {\n     Error,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum GenericParamKind {\n     /// A lifetime definition (e.g., `'a: 'b + 'c + 'd`).\n     Lifetime {\n@@ -560,7 +556,7 @@ pub enum GenericParamKind {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct GenericParam {\n     pub hir_id: HirId,\n     pub name: ParamName,\n@@ -580,20 +576,20 @@ pub struct GenericParamCount {\n \n /// Represents lifetimes and type parameters attached to a declaration\n /// of a function, enum, trait, etc.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct Generics {\n     pub params: HirVec<GenericParam>,\n     pub where_clause: WhereClause,\n     pub span: Span,\n }\n \n impl Generics {\n-    pub fn empty() -> Generics {\n+    pub const fn empty() -> Generics {\n         Generics {\n             params: HirVec::new(),\n             where_clause: WhereClause {\n-                hir_id: DUMMY_HIR_ID,\n                 predicates: HirVec::new(),\n+                span: DUMMY_SP,\n             },\n             span: DUMMY_SP,\n         }\n@@ -642,26 +638,25 @@ pub enum SyntheticTyParamKind {\n }\n \n /// A where-clause in a definition.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct WhereClause {\n-    pub hir_id: HirId,\n     pub predicates: HirVec<WherePredicate>,\n+    // Only valid if predicates isn't empty.\n+    span: Span,\n }\n \n impl WhereClause {\n     pub fn span(&self) -> Option<Span> {\n-        self.predicates.iter().map(|predicate| predicate.span())\n-            .fold(None, |acc, i| match (acc, i) {\n-                (None, i) => Some(i),\n-                (Some(acc), i) => {\n-                    Some(acc.to(i))\n-                }\n-            })\n+        if self.predicates.is_empty() {\n+            None\n+        } else {\n+            Some(self.span)\n+        }\n     }\n }\n \n /// A single predicate in a where-clause.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum WherePredicate {\n     /// A type binding (e.g., `for<'c> Foo: Send + Clone + 'c`).\n     BoundPredicate(WhereBoundPredicate),\n@@ -682,7 +677,7 @@ impl WherePredicate {\n }\n \n /// A type bound (e.g., `for<'c> Foo: Send + Clone + 'c`).\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct WhereBoundPredicate {\n     pub span: Span,\n     /// Any generics from a `for` binding.\n@@ -694,23 +689,23 @@ pub struct WhereBoundPredicate {\n }\n \n /// A lifetime predicate (e.g., `'a: 'b + 'c`).\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct WhereRegionPredicate {\n     pub span: Span,\n     pub lifetime: Lifetime,\n     pub bounds: GenericBounds,\n }\n \n /// An equality predicate (e.g., `T = int`); currently unsupported.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct WhereEqPredicate {\n     pub hir_id: HirId,\n     pub span: Span,\n     pub lhs_ty: P<Ty>,\n     pub rhs_ty: P<Ty>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(RustcEncodable, RustcDecodable, Debug)]\n pub struct ModuleItems {\n     // Use BTreeSets here so items are in the same order as in the\n     // list of all items in Crate\n@@ -725,7 +720,7 @@ pub struct ModuleItems {\n /// For more details, see the [rustc guide].\n ///\n /// [rustc guide]: https://rust-lang.github.io/rustc-guide/hir.html\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(RustcEncodable, RustcDecodable, Debug)]\n pub struct Crate {\n     pub module: Mod,\n     pub attrs: HirVec<Attribute>,\n@@ -820,7 +815,7 @@ impl Crate {\n /// A macro definition, in this crate or imported from another.\n ///\n /// Not parsed directly, but created on macro import or `macro_rules!` expansion.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct MacroDef {\n     pub name: Name,\n     pub vis: Visibility,\n@@ -834,7 +829,7 @@ pub struct MacroDef {\n /// A block of statements `{ .. }`, which may have a label (in this case the\n /// `targeted_by_break` field will be `true`) and may be `unsafe` by means of\n /// the `rules` being anything but `DefaultBlock`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct Block {\n     /// Statements in a block.\n     pub stmts: HirVec<Stmt>,\n@@ -852,7 +847,7 @@ pub struct Block {\n     pub targeted_by_break: bool,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, HashStable)]\n pub struct Pat {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n@@ -915,7 +910,7 @@ impl Pat {\n /// Patterns like the fields of Foo `{ x, ref y, ref mut z }`\n /// are treated the same as` x: x, y: ref y, z: ref mut z`,\n /// except `is_shorthand` is true.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct FieldPat {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n@@ -930,7 +925,7 @@ pub struct FieldPat {\n /// Explicit binding annotations given in the HIR for a binding. Note\n /// that this is not the final binding *mode* that we infer after type\n /// inference.\n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum BindingAnnotation {\n     /// No binding annotation given: this means that the final binding mode\n     /// will depend on whether we have skipped through a `&` reference\n@@ -957,7 +952,7 @@ pub enum RangeEnd {\n     Excluded,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum PatKind {\n     /// Represents a wildcard pattern (i.e., `_`).\n     Wild,\n@@ -1002,8 +997,8 @@ pub enum PatKind {\n     Slice(HirVec<P<Pat>>, Option<P<Pat>>, HirVec<P<Pat>>),\n }\n \n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, HashStable,\n-         RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, HashStable,\n+         RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Mutability {\n     MutMutable,\n     MutImmutable,\n@@ -1019,7 +1014,7 @@ impl Mutability {\n     }\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, Hash, HashStable)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Hash, HashStable)]\n pub enum BinOpKind {\n     /// The `+` operator (addition).\n     Add,\n@@ -1153,7 +1148,7 @@ impl Into<ast::BinOpKind> for BinOpKind {\n \n pub type BinOp = Spanned<BinOpKind>;\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, Hash, HashStable)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Hash, HashStable)]\n pub enum UnOp {\n     /// The `*` operator (deferencing).\n     UnDeref,\n@@ -1182,7 +1177,7 @@ impl UnOp {\n }\n \n /// A statement.\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(RustcEncodable, RustcDecodable)]\n pub struct Stmt {\n     pub hir_id: HirId,\n     pub node: StmtKind,\n@@ -1197,7 +1192,7 @@ impl fmt::Debug for Stmt {\n }\n \n /// The contents of a statement.\n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, HashStable)]\n pub enum StmtKind {\n     /// A local (`let`) binding.\n     Local(P<Local>),\n@@ -1224,7 +1219,7 @@ impl StmtKind {\n }\n \n /// Represents a `let` statement (i.e., `let <pat>:<ty> = <expr>;`).\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct Local {\n     pub pat: P<Pat>,\n     /// Type annotation, if any (otherwise the type will be inferred).\n@@ -1241,7 +1236,7 @@ pub struct Local {\n \n /// Represents a single arm of a `match` expression, e.g.\n /// `<pats> (if <guard>) => <body>`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct Arm {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n@@ -1255,12 +1250,12 @@ pub struct Arm {\n     pub body: P<Expr>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum Guard {\n     If(P<Expr>),\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct Field {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n@@ -1270,15 +1265,15 @@ pub struct Field {\n     pub is_shorthand: bool,\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum BlockCheckMode {\n     DefaultBlock,\n     UnsafeBlock(UnsafeSource),\n     PushUnsafeBlock(UnsafeSource),\n     PopUnsafeBlock(UnsafeSource),\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum UnsafeSource {\n     CompilerGenerated,\n     UserProvided,\n@@ -1306,15 +1301,15 @@ pub struct BodyId {\n ///\n /// - an `arguments` array containing the `(x, y)` pattern\n /// - a `value` containing the `x + y` expression (maybe wrapped in a block)\n-/// - `is_generator` would be false\n+/// - `generator_kind` would be `None`\n ///\n /// All bodies have an **owner**, which can be accessed via the HIR\n /// map using `body_owner_def_id()`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(RustcEncodable, RustcDecodable, Debug)]\n pub struct Body {\n     pub arguments: HirVec<Arg>,\n     pub value: Expr,\n-    pub is_generator: bool,\n+    pub generator_kind: Option<GeneratorKind>,\n }\n \n impl Body {\n@@ -1325,6 +1320,26 @@ impl Body {\n     }\n }\n \n+/// The type of source expression that caused this generator to be created.\n+// Not `IsAsync` because we want to eventually add support for `AsyncGen`\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, HashStable,\n+         RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub enum GeneratorKind {\n+    /// An `async` block or function.\n+    Async,\n+    /// A generator literal created via a `yield` inside a closure.\n+    Gen,\n+}\n+\n+impl fmt::Display for GeneratorKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(match self {\n+            GeneratorKind::Async => \"`async` object\",\n+            GeneratorKind::Gen => \"generator\",\n+        })\n+    }\n+}\n+\n #[derive(Copy, Clone, Debug)]\n pub enum BodyOwnerKind {\n     /// Functions and methods.\n@@ -1364,7 +1379,7 @@ pub struct AnonConst {\n }\n \n /// An expression\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(RustcEncodable, RustcDecodable)]\n pub struct Expr {\n     pub span: Span,\n     pub node: ExprKind,\n@@ -1475,7 +1490,7 @@ impl fmt::Debug for Expr {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum ExprKind {\n     /// A `box x` expression.\n     Box(P<Expr>),\n@@ -1531,8 +1546,8 @@ pub enum ExprKind {\n     ///\n     /// The final span is the span of the argument block `|...|`.\n     ///\n-    /// This may also be a generator literal, indicated by the final boolean,\n-    /// in that case there is an `GeneratorClause`.\n+    /// This may also be a generator literal or an `async block` as indicated by the\n+    /// `Option<GeneratorMovability>`.\n     Closure(CaptureClause, P<FnDecl>, BodyId, Span, Option<GeneratorMovability>),\n     /// A block (e.g., `'label: { ... }`).\n     Block(P<Block>, Option<Label>),\n@@ -1576,14 +1591,14 @@ pub enum ExprKind {\n     Repeat(P<Expr>, AnonConst),\n \n     /// A suspension point for generators (i.e., `yield <expr>`).\n-    Yield(P<Expr>),\n+    Yield(P<Expr>, YieldSource),\n \n     /// A placeholder for an expression that wasn't syntactically well formed in some way.\n     Err,\n }\n \n /// Represents an optionally `Self`-qualified value/type path or associated extension.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum QPath {\n     /// Path to a definition, optionally \"fully-qualified\" with a `Self`\n     /// type, if the path points to an associated item in a trait.\n@@ -1603,7 +1618,7 @@ pub enum QPath {\n }\n \n /// Hints at the original code for a let statement.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum LocalSource {\n     /// A `match _ { .. }`.\n     Normal,\n@@ -1625,7 +1640,7 @@ pub enum LocalSource {\n }\n \n /// Hints at the original code for a `match _ { .. }`.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n pub enum MatchSource {\n     /// A `match _ { .. }`.\n     Normal,\n@@ -1649,7 +1664,7 @@ pub enum MatchSource {\n }\n \n /// The loop type that yielded an `ExprKind::Loop`.\n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum LoopSource {\n     /// A `loop { .. }` loop.\n     Loop,\n@@ -1659,7 +1674,7 @@ pub enum LoopSource {\n     ForLoop,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum LoopIdError {\n     OutsideLoopScope,\n     UnlabeledCfInWhileCondition,\n@@ -1668,16 +1683,16 @@ pub enum LoopIdError {\n \n impl fmt::Display for LoopIdError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(match *self {\n+        f.write_str(match self {\n             LoopIdError::OutsideLoopScope => \"not inside loop scope\",\n             LoopIdError::UnlabeledCfInWhileCondition =>\n                 \"unlabeled control flow (break or continue) in while condition\",\n             LoopIdError::UnresolvedLabel => \"label not found\",\n-        }, f)\n+        })\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct Destination {\n     // This is `Some(_)` iff there is an explicit user-specified `label\n     pub label: Option<Label>,\n@@ -1687,29 +1702,50 @@ pub struct Destination {\n     pub target_id: Result<HirId, LoopIdError>,\n }\n \n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, HashStable,\n-         RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+/// Whether a generator contains self-references, causing it to be `!Unpin`.\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, HashStable,\n+         RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum GeneratorMovability {\n+    /// May contain self-references, `!Unpin`.\n     Static,\n+    /// Must not contain self-references, `Unpin`.\n     Movable,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n+/// The yield kind that caused an `ExprKind::Yield`.\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+pub enum YieldSource {\n+    /// An `<expr>.await`.\n+    Await,\n+    /// A plain `yield`.\n+    Yield,\n+}\n+\n+impl fmt::Display for YieldSource {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(match self {\n+            YieldSource::Await => \"`await`\",\n+            YieldSource::Yield => \"`yield`\",\n+        })\n+    }\n+}\n+\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum CaptureClause {\n     CaptureByValue,\n     CaptureByRef,\n }\n \n // N.B., if you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct MutTy {\n     pub ty: P<Ty>,\n     pub mutbl: Mutability,\n }\n \n /// Represents a method's signature in a trait declaration or implementation.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct MethodSig {\n     pub header: FnHeader,\n     pub decl: P<FnDecl>,\n@@ -1727,7 +1763,7 @@ pub struct TraitItemId {\n /// possibly including a default implementation. A trait item is\n /// either required (meaning it doesn't have an implementation, just a\n /// signature) or provided (meaning it has a default implementation).\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(RustcEncodable, RustcDecodable, Debug)]\n pub struct TraitItem {\n     pub ident: Ident,\n     pub hir_id: HirId,\n@@ -1738,7 +1774,7 @@ pub struct TraitItem {\n }\n \n /// Represents a trait method's body (or just argument names).\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum TraitMethod {\n     /// No default body in the trait, just a signature.\n     Required(HirVec<Ident>),\n@@ -1748,7 +1784,7 @@ pub enum TraitMethod {\n }\n \n /// Represents a trait method or associated constant or type\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum TraitItemKind {\n     /// An associated constant with an optional value (otherwise `impl`s must contain a value).\n     Const(P<Ty>, Option<BodyId>),\n@@ -1768,7 +1804,7 @@ pub struct ImplItemId {\n }\n \n /// Represents anything within an `impl` block\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(RustcEncodable, RustcDecodable, Debug)]\n pub struct ImplItem {\n     pub ident: Ident,\n     pub hir_id: HirId,\n@@ -1781,7 +1817,7 @@ pub struct ImplItem {\n }\n \n /// Represents various kinds of content within an `impl`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum ImplItemKind {\n     /// An associated constant of the given type, set to the constant result\n     /// of the expression\n@@ -1808,7 +1844,7 @@ pub enum ImplItemKind {\n ///    Binding(...),\n /// }\n /// ```\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct TypeBinding {\n     pub hir_id: HirId,\n     #[stable_hasher(project(name))]\n@@ -1818,7 +1854,7 @@ pub struct TypeBinding {\n }\n \n // Represents the two kinds of type bindings.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum TypeBindingKind {\n     /// E.g., `Foo<Bar: Send>`.\n     Constraint {\n@@ -1839,7 +1875,7 @@ impl TypeBinding {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(RustcEncodable, RustcDecodable)]\n pub struct Ty {\n     pub hir_id: HirId,\n     pub node: TyKind,\n@@ -1854,7 +1890,7 @@ impl fmt::Debug for Ty {\n }\n \n /// Not represented directly in the AST; referred to by name through a `ty_path`.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n pub enum PrimTy {\n     Int(IntTy),\n     Uint(UintTy),\n@@ -1864,7 +1900,7 @@ pub enum PrimTy {\n     Char,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct BareFnTy {\n     pub unsafety: Unsafety,\n     pub abi: Abi,\n@@ -1873,7 +1909,7 @@ pub struct BareFnTy {\n     pub arg_names: HirVec<Ident>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct ExistTy {\n     pub generics: Generics,\n     pub bounds: GenericBounds,\n@@ -1893,7 +1929,7 @@ pub enum ExistTyOrigin {\n }\n \n /// The various kinds of types recognized by the compiler.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum TyKind {\n     /// A variable length slice (i.e., `[T]`).\n     Slice(P<Ty>),\n@@ -1930,12 +1966,12 @@ pub enum TyKind {\n     Infer,\n     /// Placeholder for a type that has failed to be defined.\n     Err,\n-    /// Placeholder for C-variadic arguments. We \"spoof\" the `VaList` created\n+    /// Placeholder for C-variadic arguments. We \"spoof\" the `VaListImpl` created\n     /// from the variadic arguments. This type is only valid up to typeck.\n     CVarArgs(Lifetime),\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct InlineAsmOutput {\n     pub constraint: Symbol,\n     pub is_rw: bool,\n@@ -1958,14 +1994,14 @@ pub struct InlineAsm {\n }\n \n /// Represents an argument in a function header.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct Arg {\n     pub pat: P<Pat>,\n     pub hir_id: HirId,\n }\n \n /// Represents the header (not the body) of a function declaration.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct FnDecl {\n     /// The types of the function's arguments.\n     ///\n@@ -1978,7 +2014,7 @@ pub struct FnDecl {\n }\n \n /// Represents what type of implicit self a function has, if any.\n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum ImplicitSelfKind {\n     /// Represents a `fn x(self);`.\n     Imm,\n@@ -2058,11 +2094,10 @@ impl Defaultness {\n \n impl fmt::Display for Unsafety {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(match *self {\n-                              Unsafety::Normal => \"normal\",\n-                              Unsafety::Unsafe => \"unsafe\",\n-                          },\n-                          f)\n+        f.write_str(match self {\n+            Unsafety::Normal => \"normal\",\n+            Unsafety::Unsafe => \"unsafe\",\n+        })\n     }\n }\n \n@@ -2076,15 +2111,15 @@ pub enum ImplPolarity {\n \n impl fmt::Debug for ImplPolarity {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            ImplPolarity::Positive => \"positive\".fmt(f),\n-            ImplPolarity::Negative => \"negative\".fmt(f),\n-        }\n+        f.write_str(match self {\n+            ImplPolarity::Positive => \"positive\",\n+            ImplPolarity::Negative => \"negative\",\n+        })\n     }\n }\n \n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum FunctionRetTy {\n     /// Return type is not specified.\n     ///\n@@ -2114,7 +2149,7 @@ impl FunctionRetTy {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(RustcEncodable, RustcDecodable, Debug)]\n pub struct Mod {\n     /// A span from the first token past `{` to the last token until `}`.\n     /// For `mod foo;`, the inner span ranges from the first token\n@@ -2123,25 +2158,25 @@ pub struct Mod {\n     pub item_ids: HirVec<ItemId>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct ForeignMod {\n     pub abi: Abi,\n     pub items: HirVec<ForeignItem>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct GlobalAsm {\n     pub asm: Symbol,\n     #[stable_hasher(ignore)] // This is used for error reporting\n     pub ctxt: SyntaxContext,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct EnumDef {\n     pub variants: HirVec<Variant>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct VariantKind {\n     /// Name of the variant.\n     #[stable_hasher(project(name))]\n@@ -2177,10 +2212,10 @@ pub enum UseKind {\n /// References to traits in impls.\n ///\n /// `resolve` maps each `TraitRef`'s `ref_id` to its defining trait; that's all\n-/// that the `ref_id` is for. Note that `ref_id`'s value is not the `NodeId` of the\n-/// trait being referred to but just a unique `NodeId` that serves as a key\n+/// that the `ref_id` is for. Note that `ref_id`'s value is not the `HirId` of the\n+/// trait being referred to but just a unique `HirId` that serves as a key\n /// within the resolution map.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct TraitRef {\n     pub path: Path,\n     // Don't hash the ref_id. It is tracked via the thing it is used to access\n@@ -2202,7 +2237,7 @@ impl TraitRef {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct PolyTraitRef {\n     /// The `'a` in `<'a> Foo<&'a T>`.\n     pub bound_generic_params: HirVec<GenericParam>,\n@@ -2215,7 +2250,7 @@ pub struct PolyTraitRef {\n \n pub type Visibility = Spanned<VisibilityKind>;\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(RustcEncodable, RustcDecodable, Debug)]\n pub enum VisibilityKind {\n     Public,\n     Crate(CrateSugar),\n@@ -2250,7 +2285,7 @@ impl VisibilityKind {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct StructField {\n     pub span: Span,\n     #[stable_hasher(project(name))]\n@@ -2270,7 +2305,7 @@ impl StructField {\n }\n \n /// Fields and constructor IDs of enum variants and structs.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum VariantData {\n     /// A struct variant.\n     ///\n@@ -2315,7 +2350,7 @@ pub struct ItemId {\n /// An item\n ///\n /// The name might be a dummy name in case of anonymous items\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(RustcEncodable, RustcDecodable, Debug)]\n pub struct Item {\n     pub ident: Ident,\n     pub hir_id: HirId,\n@@ -2325,7 +2360,7 @@ pub struct Item {\n     pub span: Span,\n }\n \n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct FnHeader {\n     pub unsafety: Unsafety,\n     pub constness: Constness,\n@@ -2342,7 +2377,7 @@ impl FnHeader {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum ItemKind {\n     /// An `extern crate` item, with optional *original* crate name if the crate was renamed.\n     ///\n@@ -2445,7 +2480,7 @@ impl ItemKind {\n /// type or method, and whether it is public). This allows other\n /// passes to find the impl they want without loading the ID (which\n /// means fewer edges in the incremental compilation graph).\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct TraitItemRef {\n     pub id: TraitItemId,\n     #[stable_hasher(project(name))]\n@@ -2461,7 +2496,7 @@ pub struct TraitItemRef {\n /// type or method, and whether it is public). This allows other\n /// passes to find the impl they want without loading the ID (which\n /// means fewer edges in the incremental compilation graph).\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct ImplItemRef {\n     pub id: ImplItemId,\n     #[stable_hasher(project(name))]\n@@ -2480,7 +2515,7 @@ pub enum AssocItemKind {\n     Existential,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct ForeignItem {\n     #[stable_hasher(project(name))]\n     pub ident: Ident,\n@@ -2492,7 +2527,7 @@ pub struct ForeignItem {\n }\n \n /// An item within an `extern` block.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum ForeignItemKind {\n     /// A foreign function.\n     Fn(P<FnDecl>, HirVec<Ident>, Generics),"}, {"sha": "8b1984e04f55b596ad2d73207683aae84690f92b", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 53, "deletions": 61, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -625,10 +625,10 @@ impl<'a> State<'a> {\n                         self.word_space(\"for ?\")?;\n                         self.print_trait_ref(&ptr.trait_ref)?;\n                     } else {\n-                        real_bounds.push(b.clone());\n+                        real_bounds.push(b);\n                     }\n                 }\n-                self.print_bounds(\":\", &real_bounds[..])?;\n+                self.print_bounds(\":\", real_bounds)?;\n                 self.s.word(\";\")?;\n                 self.end()?; // end the outer ibox\n             }\n@@ -698,10 +698,10 @@ impl<'a> State<'a> {\n                         self.word_space(\"for ?\")?;\n                         self.print_trait_ref(&ptr.trait_ref)?;\n                     } else {\n-                        real_bounds.push(b.clone());\n+                        real_bounds.push(b);\n                     }\n                 }\n-                self.print_bounds(\":\", &real_bounds[..])?;\n+                self.print_bounds(\":\", real_bounds)?;\n                 self.print_where_clause(&generics.where_clause)?;\n                 self.s.word(\" \")?;\n                 self.bopen()?;\n@@ -724,11 +724,11 @@ impl<'a> State<'a> {\n                         self.word_space(\"for ?\")?;\n                         self.print_trait_ref(&ptr.trait_ref)?;\n                     } else {\n-                        real_bounds.push(b.clone());\n+                        real_bounds.push(b);\n                     }\n                 }\n                 self.nbsp()?;\n-                self.print_bounds(\"=\", &real_bounds[..])?;\n+                self.print_bounds(\"=\", real_bounds)?;\n                 self.print_where_clause(&generics.where_clause)?;\n                 self.s.word(\";\")?;\n             }\n@@ -1194,12 +1194,11 @@ impl<'a> State<'a> {\n         self.s.word(\".\")?;\n         self.print_ident(segment.ident)?;\n \n-        segment.with_generic_args(|generic_args| {\n-            if !generic_args.args.is_empty() || !generic_args.bindings.is_empty() {\n-                return self.print_generic_args(&generic_args, segment.infer_args, true);\n-            }\n-            Ok(())\n-        })?;\n+        let generic_args = segment.generic_args();\n+        if !generic_args.args.is_empty() || !generic_args.bindings.is_empty() {\n+            self.print_generic_args(generic_args, segment.infer_args, true)?;\n+        }\n+\n         self.print_call_post(base_args)\n     }\n \n@@ -1501,7 +1500,7 @@ impl<'a> State<'a> {\n \n                 self.pclose()?;\n             }\n-            hir::ExprKind::Yield(ref expr) => {\n+            hir::ExprKind::Yield(ref expr, _) => {\n                 self.word_space(\"yield\")?;\n                 self.print_expr_maybe_paren(&expr, parser::PREC_JUMP)?;\n             }\n@@ -1559,11 +1558,9 @@ impl<'a> State<'a> {\n                 self.s.word(\"::\")?\n             }\n             if segment.ident.name != kw::PathRoot {\n-               self.print_ident(segment.ident)?;\n-               segment.with_generic_args(|generic_args| {\n-                   self.print_generic_args(generic_args, segment.infer_args,\n-                                           colons_before_params)\n-               })?;\n+                self.print_ident(segment.ident)?;\n+                self.print_generic_args(segment.generic_args(), segment.infer_args,\n+                                        colons_before_params)?;\n             }\n         }\n \n@@ -1572,10 +1569,8 @@ impl<'a> State<'a> {\n \n     pub fn print_path_segment(&mut self, segment: &hir::PathSegment) -> io::Result<()> {\n         if segment.ident.name != kw::PathRoot {\n-           self.print_ident(segment.ident)?;\n-           segment.with_generic_args(|generic_args| {\n-               self.print_generic_args(generic_args, segment.infer_args, false)\n-           })?;\n+            self.print_ident(segment.ident)?;\n+            self.print_generic_args(segment.generic_args(), segment.infer_args, false)?;\n         }\n         Ok(())\n     }\n@@ -1600,35 +1595,29 @@ impl<'a> State<'a> {\n                     }\n                     if segment.ident.name != kw::PathRoot {\n                         self.print_ident(segment.ident)?;\n-                        segment.with_generic_args(|generic_args| {\n-                            self.print_generic_args(generic_args,\n-                                                    segment.infer_args,\n-                                                    colons_before_params)\n-                        })?;\n+                        self.print_generic_args(segment.generic_args(),\n+                                                segment.infer_args,\n+                                                colons_before_params)?;\n                     }\n                 }\n \n                 self.s.word(\">\")?;\n                 self.s.word(\"::\")?;\n                 let item_segment = path.segments.last().unwrap();\n                 self.print_ident(item_segment.ident)?;\n-                item_segment.with_generic_args(|generic_args| {\n-                    self.print_generic_args(generic_args,\n-                                            item_segment.infer_args,\n-                                            colons_before_params)\n-                })\n+                self.print_generic_args(item_segment.generic_args(),\n+                                        item_segment.infer_args,\n+                                        colons_before_params)\n             }\n             hir::QPath::TypeRelative(ref qself, ref item_segment) => {\n                 self.s.word(\"<\")?;\n                 self.print_type(qself)?;\n                 self.s.word(\">\")?;\n                 self.s.word(\"::\")?;\n                 self.print_ident(item_segment.ident)?;\n-                item_segment.with_generic_args(|generic_args| {\n-                    self.print_generic_args(generic_args,\n-                                            item_segment.infer_args,\n-                                            colons_before_params)\n-                })\n+                self.print_generic_args(item_segment.generic_args(),\n+                                        item_segment.infer_args,\n+                                        colons_before_params)\n             }\n         }\n     }\n@@ -2009,31 +1998,34 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_bounds(&mut self, prefix: &'static str, bounds: &[hir::GenericBound])\n-                        -> io::Result<()> {\n-        if !bounds.is_empty() {\n-            self.s.word(prefix)?;\n-            let mut first = true;\n-            for bound in bounds {\n-                if !(first && prefix.is_empty()) {\n-                    self.nbsp()?;\n-                }\n-                if first {\n-                    first = false;\n-                } else {\n-                    self.word_space(\"+\")?;\n-                }\n+    pub fn print_bounds<'b>(\n+        &mut self,\n+        prefix: &'static str,\n+        bounds: impl IntoIterator<Item = &'b hir::GenericBound>,\n+    ) -> io::Result<()> {\n+        let mut first = true;\n+        for bound in bounds {\n+            if first {\n+                self.s.word(prefix)?;\n+            }\n+            if !(first && prefix.is_empty()) {\n+                self.nbsp()?;\n+            }\n+            if first {\n+                first = false;\n+            } else {\n+                self.word_space(\"+\")?;\n+            }\n \n-                match bound {\n-                    GenericBound::Trait(tref, modifier) => {\n-                        if modifier == &TraitBoundModifier::Maybe {\n-                            self.s.word(\"?\")?;\n-                        }\n-                        self.print_poly_trait_ref(tref)?;\n-                    }\n-                    GenericBound::Outlives(lt) => {\n-                        self.print_lifetime(lt)?;\n+            match bound {\n+                GenericBound::Trait(tref, modifier) => {\n+                    if modifier == &TraitBoundModifier::Maybe {\n+                        self.s.word(\"?\")?;\n                     }\n+                    self.print_poly_trait_ref(tref)?;\n+                }\n+                GenericBound::Outlives(lt) => {\n+                    self.print_lifetime(lt)?;\n                 }\n             }\n         }\n@@ -2202,8 +2194,8 @@ impl<'a> State<'a> {\n         let generics = hir::Generics {\n             params: hir::HirVec::new(),\n             where_clause: hir::WhereClause {\n-                hir_id: hir::DUMMY_HIR_ID,\n                 predicates: hir::HirVec::new(),\n+                span: syntax_pos::DUMMY_SP,\n             },\n             span: syntax_pos::DUMMY_SP,\n         };"}, {"sha": "54b4435573baac2171577065d9355d78581986dd", "filename": "src/librustc/hir/upvars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fhir%2Fupvars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fhir%2Fupvars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fupvars.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -14,8 +14,8 @@ pub fn provide(providers: &mut Providers<'_>) {\n             return None;\n         }\n \n-        let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n-        let body = tcx.hir().body(tcx.hir().maybe_body_owned_by(node_id)?);\n+        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+        let body = tcx.hir().body(tcx.hir().maybe_body_owned_by(hir_id)?);\n \n         let mut local_collector = LocalCollector::default();\n         local_collector.visit_body(body);"}, {"sha": "30d76f240d1faa431cb24941d076827f4b258488", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -335,15 +335,15 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Body {\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Body {\n-            ref arguments,\n-            ref value,\n-            is_generator,\n-        } = *self;\n+            arguments,\n+            value,\n+            generator_kind,\n+        } = self;\n \n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::Ignore, |hcx| {\n             arguments.hash_stable(hcx, hasher);\n             value.hash_stable(hcx, hasher);\n-            is_generator.hash_stable(hcx, hasher);\n+            generator_kind.hash_stable(hcx, hasher);\n         });\n     }\n }"}, {"sha": "9430661f75ab79b3d19878c147a161a33c55c556", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -391,10 +391,17 @@ impl_stable_hash_for!(enum ::syntax::ast::MetaItemKind {\n     NameValue(lit)\n });\n \n+impl_stable_hash_for!(enum ::syntax_pos::hygiene::Transparency {\n+    Transparent,\n+    SemiTransparent,\n+    Opaque,\n+});\n+\n impl_stable_hash_for!(struct ::syntax_pos::hygiene::ExpnInfo {\n     call_site,\n-    def_site,\n     format,\n+    def_site,\n+    default_transparency,\n     allow_internal_unstable,\n     allow_internal_unsafe,\n     local_inner_macros,"}, {"sha": "e4aec59c1f64f229462d5e2e03b14e112951c26b", "filename": "src/librustc/infer/at.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fat.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -30,13 +30,13 @@ use super::*;\n use crate::ty::Const;\n use crate::ty::relate::{Relate, TypeRelation};\n \n-pub struct At<'a, 'tcx: 'a> {\n+pub struct At<'a, 'tcx> {\n     pub infcx: &'a InferCtxt<'a, 'tcx>,\n     pub cause: &'a ObligationCause<'tcx>,\n     pub param_env: ty::ParamEnv<'tcx>,\n }\n \n-pub struct Trace<'a, 'tcx: 'a> {\n+pub struct Trace<'a, 'tcx> {\n     at: At<'a, 'tcx>,\n     a_is_expected: bool,\n     trace: TypeTrace<'tcx>,"}, {"sha": "3d57a89493e1ea7aaf0c09d7e186c6e82ac647fb", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -14,7 +14,7 @@ use crate::mir::interpret::ConstValue;\n use std::sync::atomic::Ordering;\n use crate::ty::fold::{TypeFoldable, TypeFolder};\n use crate::ty::subst::Kind;\n-use crate::ty::{self, BoundVar, InferConst, Lift, List, Ty, TyCtxt, TypeFlags};\n+use crate::ty::{self, BoundVar, InferConst, List, Ty, TyCtxt, TypeFlags};\n use crate::ty::flags::FlagComputation;\n \n use rustc_data_structures::fx::FxHashMap;\n@@ -43,7 +43,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         query_state: &mut OriginalQueryValues<'tcx>,\n     ) -> Canonicalized<'tcx, V>\n     where\n-        V: TypeFoldable<'tcx> + Lift<'tcx>,\n+        V: TypeFoldable<'tcx>,\n     {\n         self.tcx\n             .sess\n@@ -87,7 +87,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// [c]: https://rust-lang.github.io/rustc-guide/traits/canonicalization.html#canonicalizing-the-query-result\n     pub fn canonicalize_response<V>(&self, value: &V) -> Canonicalized<'tcx, V>\n     where\n-        V: TypeFoldable<'tcx> + Lift<'tcx>,\n+        V: TypeFoldable<'tcx>,\n     {\n         let mut query_state = OriginalQueryValues::default();\n         Canonicalizer::canonicalize(\n@@ -101,7 +101,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n \n     pub fn canonicalize_user_type_annotation<V>(&self, value: &V) -> Canonicalized<'tcx, V>\n     where\n-        V: TypeFoldable<'tcx> + Lift<'tcx>,\n+        V: TypeFoldable<'tcx>,\n     {\n         let mut query_state = OriginalQueryValues::default();\n         Canonicalizer::canonicalize(\n@@ -132,7 +132,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         query_state: &mut OriginalQueryValues<'tcx>,\n     ) -> Canonicalized<'tcx, V>\n     where\n-        V: TypeFoldable<'tcx> + Lift<'tcx>,\n+        V: TypeFoldable<'tcx>,\n     {\n         self.tcx\n             .sess\n@@ -275,7 +275,7 @@ impl CanonicalizeRegionMode for CanonicalizeFreeRegionsOtherThanStatic {\n     }\n }\n \n-struct Canonicalizer<'cx, 'tcx: 'cx> {\n+struct Canonicalizer<'cx, 'tcx> {\n     infcx: Option<&'cx InferCtxt<'cx, 'tcx>>,\n     tcx: TyCtxt<'tcx>,\n     variables: SmallVec<[CanonicalVarInfo; 8]>,\n@@ -506,7 +506,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n         query_state: &mut OriginalQueryValues<'tcx>,\n     ) -> Canonicalized<'tcx, V>\n     where\n-        V: TypeFoldable<'tcx> + Lift<'tcx>,\n+        V: TypeFoldable<'tcx>,\n     {\n         let needs_canonical_flags = if canonicalize_region_mode.any() {\n             TypeFlags::KEEP_IN_LOCAL_TCX |\n@@ -520,20 +520,12 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n             TypeFlags::HAS_CT_PLACEHOLDER\n         };\n \n-        let gcx = tcx.global_tcx();\n-\n         // Fast path: nothing that needs to be canonicalized.\n         if !value.has_type_flags(needs_canonical_flags) {\n-            let out_value = gcx.lift(value).unwrap_or_else(|| {\n-                bug!(\n-                    \"failed to lift `{:?}` (nothing to canonicalize)\",\n-                    value\n-                )\n-            });\n             let canon_value = Canonical {\n                 max_universe: ty::UniverseIndex::ROOT,\n                 variables: List::empty(),\n-                value: out_value,\n+                value: value.clone(),\n             };\n             return canon_value;\n         }\n@@ -553,13 +545,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n         // Once we have canonicalized `out_value`, it should not\n         // contain anything that ties it to this inference context\n         // anymore, so it should live in the global arena.\n-        let out_value = gcx.lift(&out_value).unwrap_or_else(|| {\n-            bug!(\n-                \"failed to lift `{:?}`, canonicalized from `{:?}`\",\n-                out_value,\n-                value\n-            )\n-        });\n+        debug_assert!(!out_value.has_type_flags(TypeFlags::KEEP_IN_LOCAL_TCX));\n \n         let canonical_variables = tcx.intern_canonical_var_infos(&canonicalizer.variables);\n "}, {"sha": "b2c7bd73b6812833d0aa3d95521894ffe6fb6533", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -194,10 +194,10 @@ pub struct QueryResponse<'tcx, R> {\n     pub value: R,\n }\n \n-pub type Canonicalized<'tcx, V> = Canonical<'tcx, <V as Lift<'tcx>>::Lifted>;\n+pub type Canonicalized<'tcx, V> = Canonical<'tcx, V>;\n \n pub type CanonicalizedQueryResponse<'tcx, T> =\n-    &'tcx Canonical<'tcx, QueryResponse<'tcx, <T as Lift<'tcx>>::Lifted>>;\n+    &'tcx Canonical<'tcx, QueryResponse<'tcx, T>>;\n \n /// Indicates whether or not we were able to prove the query to be\n /// true."}, {"sha": "3e92fed005cd1f141c4d66c341ac71648395733c", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -26,7 +26,7 @@ use crate::traits::TraitEngine;\n use crate::traits::{Obligation, ObligationCause, PredicateObligation};\n use crate::ty::fold::TypeFoldable;\n use crate::ty::subst::{Kind, UnpackedKind};\n-use crate::ty::{self, BoundVar, InferConst, Lift, Ty, TyCtxt};\n+use crate::ty::{self, BoundVar, InferConst, Ty, TyCtxt};\n use crate::util::captures::Captures;\n \n impl<'tcx> InferCtxtBuilder<'tcx> {\n@@ -53,8 +53,8 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, R>>\n     where\n         K: TypeFoldable<'tcx>,\n-        R: Debug + Lift<'tcx> + TypeFoldable<'tcx>,\n-        Canonical<'tcx, <QueryResponse<'tcx, R> as Lift<'tcx>>::Lifted>: ArenaAllocatable,\n+        R: Debug + TypeFoldable<'tcx>,\n+        Canonical<'tcx, QueryResponse<'tcx, R>>: ArenaAllocatable,\n     {\n         self.enter_with_canonical(\n             DUMMY_SP,\n@@ -99,8 +99,8 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         fulfill_cx: &mut dyn TraitEngine<'tcx>,\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, T>>\n     where\n-        T: Debug + Lift<'tcx> + TypeFoldable<'tcx>,\n-        Canonical<'tcx, <QueryResponse<'tcx, T> as Lift<'tcx>>::Lifted>: ArenaAllocatable,\n+        T: Debug + TypeFoldable<'tcx>,\n+        Canonical<'tcx, QueryResponse<'tcx, T>>: ArenaAllocatable,\n     {\n         let query_response = self.make_query_response(inference_vars, answer, fulfill_cx)?;\n         let canonical_result = self.canonicalize_response(&query_response);\n@@ -126,9 +126,9 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         &self,\n         inference_vars: CanonicalVarValues<'tcx>,\n         answer: T,\n-    ) -> Canonical<'tcx, QueryResponse<'tcx, <T as Lift<'tcx>>::Lifted>>\n+    ) -> Canonical<'tcx, QueryResponse<'tcx, T>>\n     where\n-        T: Debug + Lift<'tcx> + TypeFoldable<'tcx>,\n+        T: Debug + TypeFoldable<'tcx>,\n     {\n         self.canonicalize_response(&QueryResponse {\n             var_values: inference_vars,\n@@ -147,7 +147,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         fulfill_cx: &mut dyn TraitEngine<'tcx>,\n     ) -> Result<QueryResponse<'tcx, T>, NoSolution>\n     where\n-        T: Debug + TypeFoldable<'tcx> + Lift<'tcx>,\n+        T: Debug + TypeFoldable<'tcx>,\n     {\n         let tcx = self.tcx;\n "}, {"sha": "e20b53455f49cf2ab6587743d1d77ccc62dfe560", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -44,7 +44,7 @@ use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n \n #[derive(Clone)]\n-pub struct CombineFields<'infcx, 'tcx: 'infcx> {\n+pub struct CombineFields<'infcx, 'tcx> {\n     pub infcx: &'infcx InferCtxt<'infcx, 'tcx>,\n     pub trace: TypeTrace<'tcx>,\n     pub cause: Option<ty::relate::Cause>,\n@@ -355,7 +355,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n     }\n }\n \n-struct Generalizer<'cx, 'tcx: 'cx> {\n+struct Generalizer<'cx, 'tcx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n \n     /// The span, used when creating new type variables and things."}, {"sha": "5eebe9e78d3534e0c587df72c26647509b12124f", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -11,7 +11,7 @@ use crate::mir::interpret::ConstValue;\n use crate::infer::unify_key::replace_if_possible;\n \n /// Ensures `a` is made equal to `b`. Returns `a` on success.\n-pub struct Equate<'combine, 'infcx: 'combine, 'tcx: 'infcx> {\n+pub struct Equate<'combine, 'infcx, 'tcx> {\n     fields: &'combine mut CombineFields<'infcx, 'tcx>,\n     a_is_expected: bool,\n }"}, {"sha": "321c06897de111a538e7cfbcb0aa05b18caabd7f", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -86,7 +86,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                     )\n                 };\n                 let span = scope.span(self, region_scope_tree);\n-                let tag = match self.hir().find(scope.node_id(self, region_scope_tree)) {\n+                let tag = match self.hir().find_by_hir_id(scope.hir_id(region_scope_tree)) {\n                     Some(Node::Block(_)) => \"block\",\n                     Some(Node::Expr(expr)) => match expr.node {\n                         hir::ExprKind::Call(..) => \"call\",\n@@ -191,7 +191,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         };\n         let (prefix, span) = match *region {\n             ty::ReEarlyBound(ref br) => {\n-                let mut sp = cm.def_span(self.hir().span_by_hir_id(node));\n+                let mut sp = cm.def_span(self.hir().span(node));\n                 if let Some(param) = self.hir()\n                     .get_generics(scope)\n                     .and_then(|generics| generics.get_named(br.name))\n@@ -204,7 +204,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 bound_region: ty::BoundRegion::BrNamed(_, name),\n                 ..\n             }) => {\n-                let mut sp = cm.def_span(self.hir().span_by_hir_id(node));\n+                let mut sp = cm.def_span(self.hir().span(node));\n                 if let Some(param) = self.hir()\n                     .get_generics(scope)\n                     .and_then(|generics| generics.get_named(name))\n@@ -216,11 +216,11 @@ impl<'tcx> TyCtxt<'tcx> {\n             ty::ReFree(ref fr) => match fr.bound_region {\n                 ty::BrAnon(idx) => (\n                     format!(\"the anonymous lifetime #{} defined on\", idx + 1),\n-                    self.hir().span_by_hir_id(node),\n+                    self.hir().span(node),\n                 ),\n                 _ => (\n                     format!(\"the lifetime {} as defined on\", region),\n-                    cm.def_span(self.hir().span_by_hir_id(node)),\n+                    cm.def_span(self.hir().span(node)),\n                 ),\n             },\n             _ => bug!(),\n@@ -1330,12 +1330,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     if !param.is_self() {\n                         let type_param = generics.type_param(param, self.tcx);\n                         let hir = &self.tcx.hir();\n-                        hir.as_local_node_id(type_param.def_id).map(|id| {\n+                        hir.as_local_hir_id(type_param.def_id).map(|id| {\n                             // Get the `hir::Param` to verify whether it already has any bounds.\n                             // We do this to avoid suggesting code that ends up as `T: 'a'b`,\n                             // instead we suggest `T: 'a + 'b` in that case.\n                             let mut has_bounds = false;\n-                            if let Node::GenericParam(ref param) = hir.get(id) {\n+                            if let Node::GenericParam(ref param) = hir.get_by_hir_id(id) {\n                                 has_bounds = !param.bounds.is_empty();\n                             }\n                             let sp = hir.span(id);"}, {"sha": "fe151bdec6a841ed927666103dfcf08c678b6e85", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -227,16 +227,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn need_type_info_err_in_generator(\n         &self,\n+        kind: hir::GeneratorKind,\n         span: Span,\n         ty: Ty<'tcx>,\n     ) -> DiagnosticBuilder<'tcx> {\n         let ty = self.resolve_vars_if_possible(&ty);\n         let name = self.extract_type_name(&ty, None);\n-\n-        let mut err = struct_span_err!(self.tcx.sess,\n-                       span,\n-                       E0698,\n-                       \"type inside generator must be known in this context\");\n+        let mut err = struct_span_err!(\n+            self.tcx.sess, span, E0698, \"type inside {} must be known in this context\", kind,\n+        );\n         err.span_label(span, InferCtxt::missing_type_msg(&name));\n         err\n     }"}, {"sha": "78d1d56993e062bea3ae8eec5a281bcd98e19a2d", "filename": "src/librustc/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -28,8 +28,8 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     ) -> Option<(&hir::Ty, &hir::FnDecl)> {\n         if let Some(anon_reg) = self.tcx().is_suitable_region(region) {\n             let def_id = anon_reg.def_id;\n-            if let Some(node_id) = self.tcx().hir().as_local_node_id(def_id) {\n-                let fndecl = match self.tcx().hir().get(node_id) {\n+            if let Some(hir_id) = self.tcx().hir().as_local_hir_id(def_id) {\n+                let fndecl = match self.tcx().hir().get_by_hir_id(hir_id) {\n                     Node::Item(&hir::Item {\n                         node: hir::ItemKind::Fn(ref fndecl, ..),\n                         .."}, {"sha": "1edb1c601bf1aa2d485e463777a384b563c0b799", "filename": "src/librustc/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -30,7 +30,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     }\n }\n \n-pub struct NiceRegionError<'cx, 'tcx: 'cx> {\n+pub struct NiceRegionError<'cx, 'tcx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n     error: Option<RegionResolutionError<'tcx>>,\n     regions: Option<(Span, ty::Region<'tcx>, ty::Region<'tcx>)>,"}, {"sha": "6ed2b67556ddcec5521f7167cdbe85ef6ab16e0b", "filename": "src/librustc/infer/error_reporting/nice_region_error/outlives_closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -48,11 +48,11 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             if let (&SubregionOrigin::BindingTypeIsNotValidAtDecl(ref external_span),\n                     &RegionKind::ReFree(ref free_region)) = (&sub_origin, sup_region) {\n                 let hir = &self.tcx().hir();\n-                if let Some(node_id) = hir.as_local_node_id(free_region.scope) {\n+                if let Some(hir_id) = hir.as_local_hir_id(free_region.scope) {\n                     if let Node::Expr(Expr {\n                         node: Closure(_, _, _, closure_span, None),\n                         ..\n-                    }) = hir.get(node_id) {\n+                    }) = hir.get_by_hir_id(hir_id) {\n                         let sup_sp = sup_origin.span();\n                         let origin_sp = origin.span();\n                         let mut err = self.tcx().sess.struct_span_err("}, {"sha": "f33f917392653a9715a4aa68dd4cdfd9b5b7c194", "filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -51,19 +51,19 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         };\n \n         let hir = &self.tcx().hir();\n-        if let Some(node_id) = hir.as_local_node_id(id) {\n-            if let Some(body_id) = hir.maybe_body_owned_by(node_id) {\n+        if let Some(hir_id) = hir.as_local_hir_id(id) {\n+            if let Some(body_id) = hir.maybe_body_owned_by(hir_id) {\n                 let body = hir.body(body_id);\n                 let owner_id = hir.body_owner(body_id);\n-                let fn_decl = hir.fn_decl(owner_id).unwrap();\n+                let fn_decl = hir.fn_decl_by_hir_id(owner_id).unwrap();\n                 if let Some(tables) = self.tables {\n                     body.arguments\n                         .iter()\n                         .enumerate()\n                         .filter_map(|(index, arg)| {\n                             // May return None; sometimes the tables are not yet populated.\n                             let ty_hir_id = fn_decl.inputs[index].hir_id;\n-                            let arg_ty_span = hir.span(hir.hir_to_node_id(ty_hir_id));\n+                            let arg_ty_span = hir.span(ty_hir_id);\n                             let ty = tables.node_type_opt(arg.hir_id)?;\n                             let mut found_anon_region = false;\n                             let new_arg_ty = self.tcx().fold_regions(&ty, &mut false, |r, _| {"}, {"sha": "7f4a817faf182fcadf6e6522181b6f993ccd58cf", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -41,7 +41,7 @@ use std::collections::hash_map::Entry;\n use super::InferCtxt;\n use super::unify_key::ToType;\n \n-pub struct TypeFreshener<'a, 'tcx: 'a> {\n+pub struct TypeFreshener<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     ty_freshen_count: u32,\n     const_freshen_count: u32,"}, {"sha": "658a9c1d88805934e8e73c151691a96f52104d73", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -133,7 +133,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n }\n \n-pub struct InferenceFudger<'a, 'tcx: 'a> {\n+pub struct InferenceFudger<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     type_vars: (Range<TyVid>, Vec<TypeVariableOrigin>),\n     int_vars: Range<IntVid>,"}, {"sha": "550213167470d537dd77ad9a4360c98a9acb852f", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -8,7 +8,7 @@ use crate::ty::{self, Ty, TyCtxt};\n use crate::ty::relate::{Relate, RelateResult, TypeRelation};\n \n /// \"Greatest lower bound\" (common subtype)\n-pub struct Glb<'combine, 'infcx: 'combine, 'tcx: 'infcx> {\n+pub struct Glb<'combine, 'infcx, 'tcx> {\n     fields: &'combine mut CombineFields<'infcx, 'tcx>,\n     a_is_expected: bool,\n }"}, {"sha": "68cbef4407677f5a202f2089a247f8489f1b2b3f", "filename": "src/librustc/infer/lattice.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flattice.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -27,7 +27,7 @@ use crate::ty::TyVar;\n use crate::ty::{self, Ty};\n use crate::ty::relate::{RelateResult, TypeRelation};\n \n-pub trait LatticeDir<'f, 'tcx: 'f>: TypeRelation<'tcx> {\n+pub trait LatticeDir<'f, 'tcx>: TypeRelation<'tcx> {\n     fn infcx(&self) -> &'f InferCtxt<'f, 'tcx>;\n \n     fn cause(&self) -> &ObligationCause<'tcx>;\n@@ -41,14 +41,13 @@ pub trait LatticeDir<'f, 'tcx: 'f>: TypeRelation<'tcx> {\n     fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()>;\n }\n \n-pub fn super_lattice_tys<'a, 'tcx, L>(\n+pub fn super_lattice_tys<'a, 'tcx: 'a, L>(\n     this: &mut L,\n     a: Ty<'tcx>,\n     b: Ty<'tcx>,\n ) -> RelateResult<'tcx, Ty<'tcx>>\n where\n     L: LatticeDir<'a, 'tcx>,\n-    'tcx: 'a,\n {\n     debug!(\"{}.lattice_tys({:?}, {:?})\",\n            this.tag(),"}, {"sha": "ad481417d5e5fedba094a54a3a8ca1b156c69bea", "filename": "src/librustc/infer/lexical_region_resolve/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -107,7 +107,7 @@ pub fn maybe_print_constraints_for<'a, 'tcx>(\n     }\n }\n \n-struct ConstraintGraph<'a, 'tcx: 'a> {\n+struct ConstraintGraph<'a, 'tcx> {\n     graph_name: String,\n     region_rels: &'a RegionRelations<'a, 'tcx>,\n     map: &'a BTreeMap<Constraint<'tcx>, SubregionOrigin<'tcx>>,"}, {"sha": "2613f4c7c2ae3bc2d8c855d470a4af5c9cdc09d6", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -93,7 +93,7 @@ struct RegionAndOrigin<'tcx> {\n \n type RegionGraph<'tcx> = Graph<(), Constraint<'tcx>>;\n \n-struct LexicalResolver<'cx, 'tcx: 'cx> {\n+struct LexicalResolver<'cx, 'tcx> {\n     region_rels: &'cx RegionRelations<'cx, 'tcx>,\n     var_infos: VarInfos,\n     data: RegionConstraintData<'tcx>,"}, {"sha": "156288b9e6afd899c386edef4311cfa3c84727ec", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -8,7 +8,7 @@ use crate::ty::{self, Ty, TyCtxt};\n use crate::ty::relate::{Relate, RelateResult, TypeRelation};\n \n /// \"Least upper bound\" (common supertype)\n-pub struct Lub<'combine, 'infcx: 'combine, 'tcx: 'infcx> {\n+pub struct Lub<'combine, 'infcx, 'tcx> {\n     fields: &'combine mut CombineFields<'infcx, 'tcx>,\n     a_is_expected: bool,\n }"}, {"sha": "fc46fe383c972f2ab41f6cc61c965fdd2685d225", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -585,7 +585,7 @@ impl<'tcx> InferOk<'tcx, ()> {\n }\n \n #[must_use = \"once you start a snapshot, you should always consume it\"]\n-pub struct CombinedSnapshot<'a, 'tcx: 'a> {\n+pub struct CombinedSnapshot<'a, 'tcx> {\n     projection_cache_snapshot: traits::ProjectionCacheSnapshot,\n     type_snapshot: type_variable::Snapshot<'tcx>,\n     const_snapshot: ut::Snapshot<ut::InPlace<ty::ConstVid<'tcx>>>,"}, {"sha": "21489965b1bf66d6f427d36086c03dee84abb11e", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -38,7 +38,7 @@ pub enum NormalizationStrategy {\n     Eager,\n }\n \n-pub struct TypeRelating<'me, 'tcx: 'me, D>\n+pub struct TypeRelating<'me, 'tcx, D>\n where\n     D: TypeRelatingDelegate<'tcx>,\n {\n@@ -741,7 +741,7 @@ where\n /// binder depth, and finds late-bound regions targeting the\n /// `for<..`>.  For each of those, it creates an entry in\n /// `bound_region_scope`.\n-struct ScopeInstantiator<'me, 'tcx: 'me> {\n+struct ScopeInstantiator<'me, 'tcx> {\n     next_region: &'me mut dyn FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n     // The debruijn index of the scope we are instantiating.\n     target_index: ty::DebruijnIndex,\n@@ -798,7 +798,7 @@ impl<'me, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'me, 'tcx> {\n /// scopes.\n ///\n /// [blog post]: https://is.gd/0hKvIr\n-struct TypeGeneralizer<'me, 'tcx: 'me, D>\n+struct TypeGeneralizer<'me, 'tcx, D>\n where\n     D: TypeRelatingDelegate<'tcx> + 'me,\n {"}, {"sha": "60554a30060bbc2ee39febfea04f628046ac642e", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -469,11 +469,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             definition_ty\n         );\n \n-        // We can unwrap here because our reverse mapper always\n-        // produces things with 'tcx lifetime, though the type folder\n-        // obscures that.\n-        let definition_ty = gcx.lift(&definition_ty).unwrap();\n-\n         definition_ty\n     }\n }\n@@ -723,7 +718,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n     }\n }\n \n-struct Instantiator<'a, 'tcx: 'a> {\n+struct Instantiator<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     parent_def_id: DefId,\n     body_id: hir::HirId,\n@@ -819,7 +814,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                             },\n                             _ => bug!(\n                                 \"expected (impl) item, found {}\",\n-                                tcx.hir().hir_to_string(opaque_hir_id),\n+                                tcx.hir().node_to_string(opaque_hir_id),\n                             ),\n                         };\n                         if in_definition_scope {"}, {"sha": "d555886128598ebb602ade1f90e52d861439b8ba", "filename": "src/librustc/infer/outlives/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -67,7 +67,7 @@ pub struct OutlivesEnvironment<'tcx> {\n /// because of implied bounds.\n pub type RegionBoundPairs<'tcx> = Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>;\n \n-impl<'a, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n+impl<'a, 'tcx> OutlivesEnvironment<'tcx> {\n     pub fn new(param_env: ty::ParamEnv<'tcx>) -> Self {\n         let mut env = OutlivesEnvironment {\n             param_env,"}, {"sha": "0ae4446ee63faf5044938b5a9d2bf554cbc54cad", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -226,7 +226,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n /// via a \"delegate\" of type `D` -- this is usually the `infcx`, which\n /// accrues them into the `region_obligations` code, but for NLL we\n /// use something else.\n-pub struct TypeOutlives<'cx, 'tcx: 'cx, D>\n+pub struct TypeOutlives<'cx, 'tcx, D>\n where\n     D: TypeOutlivesDelegate<'tcx>,\n {"}, {"sha": "f23e52fcfe499abccff64e67d39f89662df193f8", "filename": "src/librustc/infer/outlives/verify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -12,7 +12,7 @@ use crate::util::captures::Captures;\n /// via a \"delegate\" of type `D` -- this is usually the `infcx`, which\n /// accrues them into the `region_obligations` code, but for NLL we\n /// use something else.\n-pub struct VerifyBoundCx<'cx, 'tcx: 'cx> {\n+pub struct VerifyBoundCx<'cx, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     region_bound_pairs: &'cx RegionBoundPairs<'tcx>,\n     implicit_region_bound: Option<ty::Region<'tcx>>,"}, {"sha": "7e553d7666b22c8d10e450202b540b50aa974d61", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -12,7 +12,7 @@ use crate::ty::fold::{TypeFolder, TypeVisitor};\n /// been unified with (similar to `shallow_resolve`, but deep). This is\n /// useful for printing messages etc but also required at various\n /// points for correctness.\n-pub struct OpportunisticVarResolver<'a, 'tcx: 'a> {\n+pub struct OpportunisticVarResolver<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n }\n \n@@ -50,7 +50,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for OpportunisticVarResolver<'a, 'tcx> {\n /// The opportunistic type and region resolver is similar to the\n /// opportunistic type resolver, but also opportunistically resolves\n /// regions. It is useful for canonicalization.\n-pub struct OpportunisticTypeAndRegionResolver<'a, 'tcx: 'a> {\n+pub struct OpportunisticTypeAndRegionResolver<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n }\n \n@@ -101,7 +101,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for OpportunisticTypeAndRegionResolver<'a, 'tcx>\n /// type variables that don't yet have a value. The first unresolved type is stored.\n /// It does not construct the fully resolved type (which might\n /// involve some hashing and so forth).\n-pub struct UnresolvedTypeFinder<'a, 'tcx: 'a> {\n+pub struct UnresolvedTypeFinder<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n \n     /// Used to find the type parameter name and location for error reporting.\n@@ -171,7 +171,7 @@ where\n \n // N.B. This type is not public because the protocol around checking the\n // `err` field is not enforcable otherwise.\n-struct FullTypeResolver<'a, 'tcx: 'a> {\n+struct FullTypeResolver<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     err: Option<FixupError<'tcx>>,\n }"}, {"sha": "1452a6dee5bc1a032b4274024d6f5f7252982967", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -11,7 +11,7 @@ use crate::mir::interpret::ConstValue;\n use std::mem;\n \n /// Ensures `a` is made a subtype of `b`. Returns `a` on success.\n-pub struct Sub<'combine, 'infcx: 'combine, 'tcx: 'infcx> {\n+pub struct Sub<'combine, 'infcx, 'tcx> {\n     fields: &'combine mut CombineFields<'infcx, 'tcx>,\n     a_is_expected: bool,\n }"}, {"sha": "7f09120bbdd5eac48618102eb20bafe5bb6f2509", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -507,7 +507,7 @@ impl LintStore {\n }\n \n /// Context for lint checking after type checking.\n-pub struct LateContext<'a, 'tcx: 'a> {\n+pub struct LateContext<'a, 'tcx> {\n     /// Type context we're checking in.\n     pub tcx: TyCtxt<'tcx>,\n \n@@ -533,7 +533,7 @@ pub struct LateContext<'a, 'tcx: 'a> {\n     only_module: bool,\n }\n \n-pub struct LateContextAndPass<'a, 'tcx: 'a, T: LateLintPass<'a, 'tcx>> {\n+pub struct LateContextAndPass<'a, 'tcx, T: LateLintPass<'a, 'tcx>> {\n     context: LateContext<'a, 'tcx>,\n     pass: T,\n }\n@@ -1399,7 +1399,7 @@ fn late_lint_mod_pass<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n \n     // Visit the crate attributes\n     if hir_id == hir::CRATE_HIR_ID {\n-        walk_list!(cx, visit_attribute, tcx.hir().attrs_by_hir_id(hir::CRATE_HIR_ID));\n+        walk_list!(cx, visit_attribute, tcx.hir().attrs(hir::CRATE_HIR_ID));\n     }\n }\n "}, {"sha": "041944d887bd9431c0f3ac82eeb2d3df91e86c4b", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -762,7 +762,7 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n }\n \n pub fn maybe_lint_level_root(tcx: TyCtxt<'_>, id: hir::HirId) -> bool {\n-    let attrs = tcx.hir().attrs_by_hir_id(id);\n+    let attrs = tcx.hir().attrs(id);\n     attrs.iter().any(|attr| Level::from_symbol(attr.name_or_empty()).is_some())\n }\n "}, {"sha": "9e2038fa89ed047efd2ec480d0393f55f9220154", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -38,7 +38,7 @@ fn should_explore<'tcx>(tcx: TyCtxt<'tcx>, hir_id: hir::HirId) -> bool {\n     }\n }\n \n-struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n+struct MarkSymbolVisitor<'a, 'tcx> {\n     worklist: Vec<hir::HirId>,\n     tcx: TyCtxt<'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n@@ -292,7 +292,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         match ty.node {\n             TyKind::Def(item_id, _) => {\n-                let item = self.tcx.hir().expect_item_by_hir_id(item_id.id);\n+                let item = self.tcx.hir().expect_item(item_id.id);\n                 intravisit::walk_item(self, item);\n             }\n             _ => ()\n@@ -351,7 +351,7 @@ fn has_allow_dead_code_or_lang_attr(\n //   or\n //   2) We are not sure to be live or not\n //     * Implementation of a trait method\n-struct LifeSeeder<'k, 'tcx: 'k> {\n+struct LifeSeeder<'k, 'tcx> {\n     worklist: Vec<hir::HirId>,\n     krate: &'k hir::Crate,\n     tcx: TyCtxt<'tcx>,"}, {"sha": "d1867e8fa36b25d6c252795b1c7faddadf329b3a", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -11,7 +11,7 @@ use crate::hir::itemlikevisit::ItemLikeVisitor;\n use crate::ty::TyCtxt;\n use crate::ty::query::Providers;\n \n-struct EntryContext<'a, 'tcx: 'a> {\n+struct EntryContext<'a, 'tcx> {\n     session: &'a Session,\n \n     map: &'a hir_map::Map<'tcx>,"}, {"sha": "086ddfd7e33bfc996b41735fc479ac9e363983c0", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -229,7 +229,7 @@ impl OverloadedCallType {\n // The ExprUseVisitor type\n //\n // This is the code that actually walks the tree.\n-pub struct ExprUseVisitor<'a, 'tcx: 'a> {\n+pub struct ExprUseVisitor<'a, 'tcx> {\n     mc: mc::MemCategorizationContext<'a, 'tcx>,\n     delegate: &'a mut dyn Delegate<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -546,7 +546,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 self.consume_expr(&base);\n             }\n \n-            hir::ExprKind::Yield(ref value) => {\n+            hir::ExprKind::Yield(ref value, _) => {\n                 self.consume_expr(&value);\n             }\n         }"}, {"sha": "60e41f7eb0f7bdcc3cccfd86ac28107ff291bfc7", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -15,7 +15,7 @@ use crate::ty::{self, TyCtxt, Region};\n ///\n /// This stuff is a bit convoluted and should be refactored, but as we\n /// transition to NLL, it'll all go away anyhow.\n-pub struct RegionRelations<'a, 'tcx: 'a> {\n+pub struct RegionRelations<'a, 'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n \n     /// The context used to fetch the region maps."}, {"sha": "bf054d68b704a5ff297af58799966a8998543dd0", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -352,7 +352,7 @@ impl IrMaps<'tcx> {\n     }\n }\n \n-fn visit_fn<'a, 'tcx: 'a>(\n+fn visit_fn<'tcx>(\n     ir: &mut IrMaps<'tcx>,\n     fk: FnKind<'tcx>,\n     decl: &'tcx hir::FnDecl,\n@@ -682,7 +682,7 @@ const ACC_READ: u32 = 1;\n const ACC_WRITE: u32 = 2;\n const ACC_USE: u32 = 4;\n \n-struct Liveness<'a, 'tcx: 'a> {\n+struct Liveness<'a, 'tcx> {\n     ir: &'a mut IrMaps<'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n     s: Specials,\n@@ -1171,7 +1171,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n \n             hir::ExprKind::Call(ref f, ref args) => {\n-                let m = self.ir.tcx.hir().get_module_parent_by_hir_id(expr.hir_id);\n+                let m = self.ir.tcx.hir().get_module_parent(expr.hir_id);\n                 let succ = if self.ir.tcx.is_ty_uninhabited_from(m, self.tables.expr_ty(expr)) {\n                     self.s.exit_ln\n                 } else {\n@@ -1182,7 +1182,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n \n             hir::ExprKind::MethodCall(.., ref args) => {\n-                let m = self.ir.tcx.hir().get_module_parent_by_hir_id(expr.hir_id);\n+                let m = self.ir.tcx.hir().get_module_parent(expr.hir_id);\n                 let succ = if self.ir.tcx.is_ty_uninhabited_from(m, self.tables.expr_ty(expr)) {\n                     self.s.exit_ln\n                 } else {\n@@ -1218,7 +1218,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             hir::ExprKind::Type(ref e, _) |\n             hir::ExprKind::DropTemps(ref e) |\n             hir::ExprKind::Unary(_, ref e) |\n-            hir::ExprKind::Yield(ref e) |\n+            hir::ExprKind::Yield(ref e, _) |\n             hir::ExprKind::Repeat(ref e, _) => {\n                 self.propagate_through_expr(&e, succ)\n             }"}, {"sha": "c0f56a33eec8f031308ca6007ae2dc4af275620c", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -342,9 +342,9 @@ impl MutabilityCategory {\n     fn from_local(\n         tcx: TyCtxt<'_>,\n         tables: &ty::TypeckTables<'_>,\n-        id: ast::NodeId,\n+        id: hir::HirId,\n     ) -> MutabilityCategory {\n-        let ret = match tcx.hir().get(id) {\n+        let ret = match tcx.hir().get_by_hir_id(id) {\n             Node::Binding(p) => match p.node {\n                 PatKind::Binding(..) => {\n                     let bm = *tables.pat_binding_modes()\n@@ -500,7 +500,6 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             // FIXME\n             None if self.is_tainted_by_errors() => Err(()),\n             None => {\n-                let id = self.tcx.hir().hir_to_node_id(id);\n                 bug!(\"no type for node {}: {} in mem_categorization\",\n                      id, self.tcx.hir().node_to_string(id));\n             }\n@@ -753,15 +752,14 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             }\n \n             Res::Local(var_id) => {\n-                let var_nid = self.tcx.hir().hir_to_node_id(var_id);\n                 if self.upvars.map_or(false, |upvars| upvars.contains_key(&var_id)) {\n-                    self.cat_upvar(hir_id, span, var_nid)\n+                    self.cat_upvar(hir_id, span, var_id)\n                 } else {\n                     Ok(cmt_ {\n                         hir_id,\n                         span,\n                         cat: Categorization::Local(var_id),\n-                        mutbl: MutabilityCategory::from_local(self.tcx, self.tables, var_nid),\n+                        mutbl: MutabilityCategory::from_local(self.tcx, self.tables, var_id),\n                         ty: expr_ty,\n                         note: NoteNone\n                     })\n@@ -778,7 +776,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         &self,\n         hir_id: hir::HirId,\n         span: Span,\n-        var_id: ast::NodeId,\n+        var_id: hir::HirId,\n     ) -> McResult<cmt_<'tcx>> {\n         // An upvar can have up to 3 components. We translate first to a\n         // `Categorization::Upvar`, which is itself a fiction -- it represents the reference to the\n@@ -819,22 +817,18 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                              .unwrap_or(ty::ClosureKind::LATTICE_BOTTOM),\n \n                     None =>\n-                        self.tcx.global_tcx()\n-                                .lift(&closure_substs)\n-                                .expect(\"no inference cx, but inference variables in closure ty\")\n-                                .closure_kind(closure_def_id, self.tcx.global_tcx()),\n+                        closure_substs.closure_kind(closure_def_id, self.tcx.global_tcx()),\n                 }\n             }\n             _ => span_bug!(span, \"unexpected type for fn in mem_categorization: {:?}\", ty),\n         };\n \n-        let var_hir_id = self.tcx.hir().node_to_hir_id(var_id);\n         let upvar_id = ty::UpvarId {\n-            var_path: ty::UpvarPath { hir_id: var_hir_id },\n+            var_path: ty::UpvarPath { hir_id: var_id },\n             closure_expr_id: closure_expr_def_id.to_local(),\n         };\n \n-        let var_ty = self.node_ty(var_hir_id)?;\n+        let var_ty = self.node_ty(var_id)?;\n \n         // Mutability of original variable itself\n         let var_mutbl = MutabilityCategory::from_local(self.tcx, self.tables, var_id);"}, {"sha": "593c5e73421685c1248a0d967c592f530f0dc46a", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -65,7 +65,7 @@ fn method_might_be_inlined<'tcx>(\n }\n \n // Information needed while computing reachability.\n-struct ReachableContext<'a, 'tcx: 'a> {\n+struct ReachableContext<'a, 'tcx> {\n     // The type context.\n     tcx: TyCtxt<'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n@@ -174,12 +174,12 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                         } else {\n                             let impl_did = self.tcx\n                                                .hir()\n-                                               .get_parent_did_by_hir_id(hir_id);\n+                                               .get_parent_did(hir_id);\n                             // Check the impl. If the generics on the self\n                             // type of the impl require inlining, this method\n                             // does too.\n                             let impl_hir_id = self.tcx.hir().as_local_hir_id(impl_did).unwrap();\n-                            match self.tcx.hir().expect_item_by_hir_id(impl_hir_id).node {\n+                            match self.tcx.hir().expect_item(impl_hir_id).node {\n                                 hir::ItemKind::Impl(..) => {\n                                     let generics = self.tcx.generics_of(impl_did);\n                                     generics.requires_monomorphization(self.tcx)\n@@ -296,7 +296,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                         self.visit_nested_body(body);\n                     }\n                     hir::ImplItemKind::Method(_, body) => {\n-                        let did = self.tcx.hir().get_parent_did_by_hir_id(search_item);\n+                        let did = self.tcx.hir().get_parent_did(search_item);\n                         if method_might_be_inlined(self.tcx, impl_item, did) {\n                             self.visit_nested_body(body)\n                         }\n@@ -318,7 +318,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             _ => {\n                 bug!(\n                     \"found unexpected node kind in worklist: {} ({:?})\",\n-                    self.tcx.hir().hir_to_string(search_item),\n+                    self.tcx.hir().node_to_string(search_item),\n                     node,\n                 );\n             }\n@@ -334,13 +334,13 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n // items of non-exported traits (or maybe all local traits?) unless their respective\n // trait items are used from inlinable code through method call syntax or UFCS, or their\n // trait is a lang item.\n-struct CollectPrivateImplItemsVisitor<'a, 'tcx: 'a> {\n+struct CollectPrivateImplItemsVisitor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     access_levels: &'a privacy::AccessLevels,\n     worklist: &'a mut Vec<hir::HirId>,\n }\n \n-impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         // Anything which has custom linkage gets thrown on the worklist no\n         // matter where it is in the crate, along with \"special std symbols\""}, {"sha": "93cb6ab96f8837a062df14e49eec7bb1fe977686", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -14,7 +14,6 @@ use std::mem;\n use std::fmt;\n use rustc_macros::HashStable;\n use syntax::source_map;\n-use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n use crate::ty::{DefIdTree, TyCtxt};\n use crate::ty::query::Providers;\n@@ -169,29 +168,29 @@ impl Scope {\n         self.id\n     }\n \n-    pub fn node_id(&self, tcx: TyCtxt<'_>, scope_tree: &ScopeTree) -> ast::NodeId {\n+    pub fn hir_id(&self, scope_tree: &ScopeTree) -> hir::HirId {\n         match scope_tree.root_body {\n             Some(hir_id) => {\n-                tcx.hir().hir_to_node_id(hir::HirId {\n+                hir::HirId {\n                     owner: hir_id.owner,\n                     local_id: self.item_local_id()\n-                })\n+                }\n             }\n-            None => ast::DUMMY_NODE_ID\n+            None => hir::DUMMY_HIR_ID\n         }\n     }\n \n     /// Returns the span of this `Scope`. Note that in general the\n     /// returned span may not correspond to the span of any `NodeId` in\n     /// the AST.\n     pub fn span(&self, tcx: TyCtxt<'_>, scope_tree: &ScopeTree) -> Span {\n-        let node_id = self.node_id(tcx, scope_tree);\n-        if node_id == ast::DUMMY_NODE_ID {\n+        let hir_id = self.hir_id(scope_tree);\n+        if hir_id == hir::DUMMY_HIR_ID {\n             return DUMMY_SP;\n         }\n-        let span = tcx.hir().span(node_id);\n+        let span = tcx.hir().span(hir_id);\n         if let ScopeData::Remainder(first_statement_index) = self.data {\n-            if let Node::Block(ref blk) = tcx.hir().get(node_id) {\n+            if let Node::Block(ref blk) = tcx.hir().get_by_hir_id(hir_id) {\n                 // Want span for scope starting after the\n                 // indexed statement and ending at end of\n                 // `blk`; reuse span of `blk` and shift `lo`\n@@ -332,14 +331,23 @@ pub struct ScopeTree {\n     /// The reason is that semantically, until the `box` expression returns,\n     /// the values are still owned by their containing expressions. So\n     /// we'll see that `&x`.\n-    yield_in_scope: FxHashMap<Scope, (Span, usize)>,\n+    yield_in_scope: FxHashMap<Scope, YieldData>,\n \n     /// The number of visit_expr and visit_pat calls done in the body.\n     /// Used to sanity check visit_expr/visit_pat call count when\n     /// calculating generator interiors.\n     body_expr_count: FxHashMap<hir::BodyId, usize>,\n }\n \n+#[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n+pub struct YieldData {\n+    /// `Span` of the yield.\n+    pub span: Span,\n+    /// The number of expressions and patterns appearing before the `yield` in the body + 1.\n+    pub expr_and_pat_count: usize,\n+    pub source: hir::YieldSource,\n+}\n+\n #[derive(Debug, Copy, Clone)]\n pub struct Context {\n     /// the root of the current region tree. This is typically the id\n@@ -650,7 +658,7 @@ impl<'tcx> ScopeTree {\n         let param_owner = tcx.parent(br.def_id).unwrap();\n \n         let param_owner_id = tcx.hir().as_local_hir_id(param_owner).unwrap();\n-        let scope = tcx.hir().maybe_body_owned_by_by_hir_id(param_owner_id).map(|body_id| {\n+        let scope = tcx.hir().maybe_body_owned_by(param_owner_id).map(|body_id| {\n             tcx.hir().body(body_id).value.hir_id.local_id\n         }).unwrap_or_else(|| {\n             // The lifetime was defined on node that doesn't own a body,\n@@ -696,7 +704,7 @@ impl<'tcx> ScopeTree {\n     /// returns `Some((span, expr_count))` with the span of a yield we found and\n     /// the number of expressions and patterns appearing before the `yield` in the body + 1.\n     /// If there a are multiple yields in a scope, the one with the highest number is returned.\n-    pub fn yield_in_scope(&self, scope: Scope) -> Option<(Span, usize)> {\n+    pub fn yield_in_scope(&self, scope: Scope) -> Option<YieldData> {\n         self.yield_in_scope.get(&scope).cloned()\n     }\n \n@@ -707,14 +715,14 @@ impl<'tcx> ScopeTree {\n                                    scope: Scope,\n                                    expr_hir_id: hir::HirId,\n                                    body: &'tcx hir::Body) -> Option<Span> {\n-        self.yield_in_scope(scope).and_then(|(span, count)| {\n+        self.yield_in_scope(scope).and_then(|YieldData { span, expr_and_pat_count, .. }| {\n             let mut visitor = ExprLocatorVisitor {\n                 hir_id: expr_hir_id,\n                 result: None,\n                 expr_and_pat_count: 0,\n             };\n             visitor.visit_body(body);\n-            if count >= visitor.result.unwrap() {\n+            if expr_and_pat_count >= visitor.result.unwrap() {\n                 Some(span)\n             } else {\n                 None\n@@ -954,12 +962,16 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n \n     debug!(\"resolve_expr post-increment {}, expr = {:?}\", visitor.expr_and_pat_count, expr);\n \n-    if let hir::ExprKind::Yield(..) = expr.node {\n+    if let hir::ExprKind::Yield(_, source) = &expr.node {\n         // Mark this expr's scope and all parent scopes as containing `yield`.\n         let mut scope = Scope { id: expr.hir_id.local_id, data: ScopeData::Node };\n         loop {\n-            visitor.scope_tree.yield_in_scope.insert(scope,\n-                (expr.span, visitor.expr_and_pat_count));\n+            let data = YieldData {\n+                span: expr.span,\n+                expr_and_pat_count: visitor.expr_and_pat_count,\n+                source: *source,\n+            };\n+            visitor.scope_tree.yield_in_scope.insert(scope, data);\n \n             // Keep traversing up while we can.\n             match visitor.scope_tree.parent_map.get(&scope) {\n@@ -1303,7 +1315,7 @@ impl<'tcx> Visitor<'tcx> for RegionResolutionVisitor<'tcx> {\n             resolve_local(self, None, Some(&body.value));\n         }\n \n-        if body.is_generator {\n+        if body.generator_kind.is_some() {\n             self.scope_tree.body_expr_count.insert(body_id, self.expr_and_pat_count);\n         }\n \n@@ -1337,7 +1349,7 @@ fn region_scope_tree<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx ScopeTree\n     }\n \n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    let scope_tree = if let Some(body_id) = tcx.hir().maybe_body_owned_by_by_hir_id(id) {\n+    let scope_tree = if let Some(body_id) = tcx.hir().maybe_body_owned_by(id) {\n         let mut visitor = RegionResolutionVisitor {\n             tcx,\n             scope_tree: ScopeTree::default(),"}, {"sha": "f68e18c2bb85b64f6c21fd2b210d0047fc8b3ec0", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -217,7 +217,7 @@ impl_stable_hash_for!(struct crate::middle::resolve_lifetime::ResolveLifetimes {\n     object_lifetime_defaults\n });\n \n-struct LifetimeContext<'a, 'tcx: 'a> {\n+struct LifetimeContext<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     map: &'a mut NamedRegionMap,\n     scope: ScopeRef<'a>,\n@@ -625,7 +625,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 // `abstract type MyAnonTy<'b>: MyTrait<'b>;`\n                 //                          ^            ^ this gets resolved in the scope of\n                 //                                         the exist_ty generics\n-                let (generics, bounds) = match self.tcx.hir().expect_item_by_hir_id(item_id.id).node\n+                let (generics, bounds) = match self.tcx.hir().expect_item(item_id.id).node\n                 {\n                     // named existential types are reached via TyKind::Path\n                     // this arm is for `impl Trait` in the types of statics, constants and locals\n@@ -1160,7 +1160,7 @@ fn signal_shadowing_problem(tcx: TyCtxt<'_>, name: ast::Name, orig: Original, sh\n // Adds all labels in `b` to `ctxt.labels_in_fn`, signalling a warning\n // if one of the label shadows a lifetime or another label.\n fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n-    struct GatherLabels<'a, 'tcx: 'a> {\n+    struct GatherLabels<'a, 'tcx> {\n         tcx: TyCtxt<'tcx>,\n         scope: ScopeRef<'a>,\n         labels_in_fn: &'a mut Vec<ast::Ident>,\n@@ -1236,7 +1236,7 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n                         signal_shadowing_problem(\n                             tcx,\n                             label.name,\n-                            original_lifetime(tcx.hir().span_by_hir_id(hir_id)),\n+                            original_lifetime(tcx.hir().span(hir_id)),\n                             shadower_label(label.span),\n                         );\n                         return;\n@@ -1590,7 +1590,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             if let Some(parent_hir_id) = self.tcx.hir()\n                                 .as_local_hir_id(parent_def_id) {\n                                     // lifetimes in `derive` expansions don't count (Issue #53738)\n-                                    if self.tcx.hir().attrs_by_hir_id(parent_hir_id).iter()\n+                                    if self.tcx.hir().attrs(parent_hir_id).iter()\n                                         .any(|attr| attr.check_name(sym::automatically_derived)) {\n                                             continue;\n                                         }\n@@ -1690,7 +1690,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         // Find the start of nested early scopes, e.g., in methods.\n         let mut index = 0;\n         if let Some(parent_id) = parent_id {\n-            let parent = self.tcx.hir().expect_item_by_hir_id(parent_id);\n+            let parent = self.tcx.hir().expect_item(parent_id);\n             if sub_items_have_self_param(&parent.node) {\n                 index += 1; // Self comes before lifetimes\n             }\n@@ -1823,7 +1823,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 // Do not free early-bound regions, only late-bound ones.\n             } else if let Some(body_id) = outermost_body {\n                 let fn_id = self.tcx.hir().body_owner(body_id);\n-                match self.tcx.hir().get(fn_id) {\n+                match self.tcx.hir().get_by_hir_id(fn_id) {\n                     Node::Item(&hir::Item {\n                         node: hir::ItemKind::Fn(..),\n                         ..\n@@ -1836,7 +1836,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         node: hir::ImplItemKind::Method(..),\n                         ..\n                     }) => {\n-                        let scope = self.tcx.hir().local_def_id(fn_id);\n+                        let scope = self.tcx.hir().local_def_id_from_hir_id(fn_id);\n                         def = Region::Free(scope, def.id().unwrap());\n                     }\n                     _ => {}\n@@ -2065,7 +2065,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }) => {\n                 if let hir::ItemKind::Trait(.., ref trait_items) = self.tcx\n                     .hir()\n-                    .expect_item_by_hir_id(self.tcx.hir().get_parent_item(parent))\n+                    .expect_item(self.tcx.hir().get_parent_item(parent))\n                     .node\n                 {\n                     assoc_item_kind = trait_items\n@@ -2085,7 +2085,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }) => {\n                 if let hir::ItemKind::Impl(.., ref self_ty, ref impl_items) = self.tcx\n                     .hir()\n-                    .expect_item_by_hir_id(self.tcx.hir().get_parent_item(parent))\n+                    .expect_item(self.tcx.hir().get_parent_item(parent))\n                     .node\n                 {\n                     impl_self = Some(self_ty);\n@@ -2629,7 +2629,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         signal_shadowing_problem(\n                             self.tcx,\n                             param.name.ident().name,\n-                            original_lifetime(self.tcx.hir().span_by_hir_id(hir_id)),\n+                            original_lifetime(self.tcx.hir().span(hir_id)),\n                             shadower_lifetime(&param),\n                         );\n                         return;\n@@ -2696,7 +2696,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         debug!(\n             \"insert_lifetime: {} resolved to {:?} span={:?}\",\n-            self.tcx.hir().hir_to_string(lifetime_ref.hir_id),\n+            self.tcx.hir().node_to_string(lifetime_ref.hir_id),\n             def,\n             self.tcx.sess.source_map().span_to_string(lifetime_ref.span)\n         );"}, {"sha": "5a1e5212f8657958a3442c818d5b668ce72150b3", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -105,15 +105,15 @@ impl_stable_hash_for!(struct self::Index<'tcx> {\n });\n \n // A private tree-walker for producing an Index.\n-struct Annotator<'a, 'tcx: 'a> {\n+struct Annotator<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     index: &'a mut Index<'tcx>,\n     parent_stab: Option<&'tcx Stability>,\n     parent_depr: Option<DeprecationEntry>,\n     in_trait_impl: bool,\n }\n \n-impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n+impl<'a, 'tcx> Annotator<'a, 'tcx> {\n     // Determine the stability for a node based on its attributes and inherited\n     // stability. The stability is recorded in the index and used as the parent.\n     fn annotate<F>(&mut self, hir_id: HirId, attrs: &[Attribute],\n@@ -316,12 +316,12 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n     }\n }\n \n-struct MissingStabilityAnnotations<'a, 'tcx: 'a> {\n+struct MissingStabilityAnnotations<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     access_levels: &'a AccessLevels,\n }\n \n-impl<'a, 'tcx: 'a> MissingStabilityAnnotations<'a, 'tcx> {\n+impl<'a, 'tcx> MissingStabilityAnnotations<'a, 'tcx> {\n     fn check_missing_stability(&self, hir_id: HirId, span: Span, name: &str) {\n         let stab = self.tcx.stability().local_stability(hir_id);\n         let is_error = !self.tcx.sess.opts.test &&"}, {"sha": "b6cd24c291ac77860e1005407c1eaf9def733fe6", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -17,7 +17,7 @@ use crate::ty::TyCtxt;\n macro_rules! weak_lang_items {\n     ($($name:ident, $item:ident, $sym:ident;)*) => (\n \n-struct Context<'a, 'tcx: 'a> {\n+struct Context<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     items: &'a mut lang_items::LanguageItems,\n }"}, {"sha": "40e81119973615dd2fbd5f3de6561d2359d77107", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -2,7 +2,7 @@ use std::fmt;\n use rustc_macros::HashStable;\n use rustc_apfloat::{Float, ieee::{Double, Single}};\n \n-use crate::ty::{Ty, InferConst, ParamConst, layout::{HasDataLayout, Size}, subst::SubstsRef};\n+use crate::ty::{Ty, InferConst, ParamConst, layout::{HasDataLayout, Size, Align}, subst::SubstsRef};\n use crate::ty::PlaceholderConst;\n use crate::hir::def_id::DefId;\n \n@@ -45,7 +45,12 @@ pub enum ConstValue<'tcx> {\n \n     /// An allocation together with a pointer into the allocation.\n     /// Invariant: the pointer's `AllocId` resolves to the allocation.\n-    ByRef(Pointer, &'tcx Allocation),\n+    /// The alignment exists to allow `const_field` to have `ByRef` access to nonprimitive fields\n+    /// of `repr(packed)` structs. The alignment may be lower than the type of this constant.\n+    /// This permits reads with lower alignment than what the type would normally require.\n+    /// FIXME(RalfJ,oli-obk): The alignment checks are part of miri, but const eval doesn't really\n+    /// need them. Disabling them may be too hard though.\n+    ByRef(Pointer, Align, &'tcx Allocation),\n \n     /// Used in the HIR by using `Unevaluated` everywhere and later normalizing to one of the other\n     /// variants when the code is monomorphic enough for that."}, {"sha": "9dfd8d959a3c4d29f3a3e2564f161ac8caffd3e3", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -2104,7 +2104,7 @@ impl<'tcx> Place<'tcx> {\n /// N.B., this particular impl strategy is not the most obvious. It was\n /// chosen because it makes a measurable difference to NLL\n /// performance, as this code (`borrow_conflicts_with_place`) is somewhat hot.\n-pub enum Projections<'p, 'tcx: 'p> {\n+pub enum Projections<'p, 'tcx> {\n     Empty,\n \n     List {\n@@ -2143,7 +2143,7 @@ impl<'p, 'tcx> IntoIterator for &'p Projections<'p, 'tcx> {\n /// N.B., this is not a *true* Rust iterator -- the code above just\n /// manually invokes `next`. This is because we (sometimes) want to\n /// keep executing even after `None` has been returned.\n-pub struct ProjectionsIter<'p, 'tcx: 'p> {\n+pub struct ProjectionsIter<'p, 'tcx> {\n     pub value: &'p Projections<'p, 'tcx>,\n }\n \n@@ -2565,7 +2565,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                             let name = if tcx.sess.opts.debugging_opts.span_free_formats {\n                                 format!(\"[closure@{:?}]\", hir_id)\n                             } else {\n-                                format!(\"[closure@{:?}]\", tcx.hir().span_by_hir_id(hir_id))\n+                                format!(\"[closure@{:?}]\", tcx.hir().span(hir_id))\n                             };\n                             let mut struct_fmt = fmt.debug_struct(&name);\n \n@@ -2585,7 +2585,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                     AggregateKind::Generator(def_id, _, _) => ty::tls::with(|tcx| {\n                         if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n                             let name = format!(\"[generator@{:?}]\",\n-                                               tcx.hir().span_by_hir_id(hir_id));\n+                                               tcx.hir().span(hir_id));\n                             let mut struct_fmt = fmt.debug_struct(&name);\n \n                             if let Some(upvars) = tcx.upvars(def_id) {"}, {"sha": "432a61de6cb984cc46ae500c4bd520d53d3877fb", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -218,7 +218,7 @@ impl<'tcx> MonoItem<'tcx> {\n             MonoItem::GlobalAsm(hir_id) => {\n                 Some(hir_id)\n             }\n-        }.map(|hir_id| tcx.hir().span_by_hir_id(hir_id))\n+        }.map(|hir_id| tcx.hir().span(hir_id))\n     }\n }\n "}, {"sha": "2079a2a34e7effb5813492e1f875c47e64a7d7b3", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -122,13 +122,25 @@ impl<'tcx> Place<'tcx> {\n     where\n         D: HasLocalDecls<'tcx>,\n     {\n-        match *self {\n-            Place::Base(PlaceBase::Local(index)) =>\n-                PlaceTy::from_ty(local_decls.local_decls()[index].ty),\n-            Place::Base(PlaceBase::Static(ref data)) =>\n-                PlaceTy::from_ty(data.ty),\n-            Place::Projection(ref proj) =>\n-                proj.base.ty(local_decls, tcx).projection_ty(tcx, &proj.elem),\n+        self.iterate(|place_base, place_projections| {\n+            let mut place_ty = place_base.ty(local_decls);\n+\n+            for proj in place_projections {\n+                place_ty = place_ty.projection_ty(tcx, &proj.elem);\n+            }\n+\n+            place_ty\n+        })\n+    }\n+}\n+\n+impl<'tcx> PlaceBase<'tcx> {\n+    pub fn ty<D>(&self, local_decls: &D) -> PlaceTy<'tcx>\n+        where D: HasLocalDecls<'tcx>\n+    {\n+        match self {\n+            PlaceBase::Local(index) => PlaceTy::from_ty(local_decls.local_decls()[*index].ty),\n+            PlaceBase::Static(data) => PlaceTy::from_ty(data.ty),\n         }\n     }\n }"}, {"sha": "1416a5f0a6e9ffc713d1f2e5b11b7aa01dd3cf45", "filename": "src/librustc/mir/traversal.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftraversal.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -20,7 +20,7 @@ use super::*;\n ///\n /// A preorder traversal of this graph is either `A B D C` or `A C D B`\n #[derive(Clone)]\n-pub struct Preorder<'a, 'tcx: 'a> {\n+pub struct Preorder<'a, 'tcx> {\n     body: &'a Body<'tcx>,\n     visited: BitSet<BasicBlock>,\n     worklist: Vec<BasicBlock>,\n@@ -98,7 +98,7 @@ impl<'a, 'tcx> Iterator for Preorder<'a, 'tcx> {\n /// ```\n ///\n /// A Postorder traversal of this graph is `D B C A` or `D C B A`\n-pub struct Postorder<'a, 'tcx: 'a> {\n+pub struct Postorder<'a, 'tcx> {\n     body: &'a Body<'tcx>,\n     visited: BitSet<BasicBlock>,\n     visit_stack: Vec<(BasicBlock, Successors<'a>)>,\n@@ -251,7 +251,7 @@ impl<'a, 'tcx> Iterator for Postorder<'a, 'tcx> {\n /// constructed as few times as possible. Use the `reset` method to be able\n /// to re-use the traversal\n #[derive(Clone)]\n-pub struct ReversePostorder<'a, 'tcx: 'a> {\n+pub struct ReversePostorder<'a, 'tcx> {\n     body: &'a Body<'tcx>,\n     blocks: Vec<BasicBlock>,\n     idx: usize"}, {"sha": "97fb430a3e0519af9d9e1fa975e9b3b4fdc08140", "filename": "src/librustc/traits/codegen/mod.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -141,9 +141,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         fulfill_cx: &mut FulfillmentContext<'tcx>,\n         result: &T,\n-    ) -> T::Lifted\n+    ) -> T\n     where\n-        T: TypeFoldable<'tcx> + ty::Lift<'tcx>,\n+        T: TypeFoldable<'tcx>,\n     {\n         debug!(\"drain_fulfillment_cx_or_panic()\");\n \n@@ -155,10 +155,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n \n         let result = self.resolve_vars_if_possible(result);\n-        let result = self.tcx.erase_regions(&result);\n-\n-        self.tcx.lift_to_global(&result).unwrap_or_else(||\n-            bug!(\"Uninferred types/regions/consts in `{:?}`\", result)\n-        )\n+        self.tcx.erase_regions(&result)\n     }\n }"}, {"sha": "2555833cd77e3099305b27a7ee84915604c4f431", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -1013,10 +1013,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n     ) {\n         let hir = self.tcx.hir();\n-        let parent_node = hir.get_parent_node(\n-            hir.hir_to_node_id(obligation.cause.body_id),\n-        );\n-        let node = hir.find(parent_node);\n+        let parent_node = hir.get_parent_node_by_hir_id(obligation.cause.body_id);\n+        let node = hir.find_by_hir_id(parent_node);\n         if let Some(hir::Node::Item(hir::Item {\n             node: hir::ItemKind::Fn(decl, _, _, body_id),\n             ..\n@@ -1052,10 +1050,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 (self.tcx.sess.source_map().def_span(span), self.tcx.hir().body(id).arguments.iter()\n                     .map(|arg| {\n                         if let hir::Pat {\n-                            node: hir::PatKind::Tuple(args, _),\n+                            node: hir::PatKind::Tuple(ref args, _),\n                             span,\n                             ..\n-                        } = arg.pat.clone().into_inner() {\n+                        } = *arg.pat {\n                             ArgKind::Tuple(\n                                 Some(span),\n                                 args.iter().map(|pat| {\n@@ -1098,7 +1096,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n             Node::Ctor(ref variant_data) => {\n                 let span = variant_data.ctor_hir_id()\n-                    .map(|hir_id| self.tcx.hir().span_by_hir_id(hir_id))\n+                    .map(|hir_id| self.tcx.hir().span(hir_id))\n                     .unwrap_or(DUMMY_SP);\n                 let span = self.tcx.sess.source_map().def_span(span);\n \n@@ -1451,7 +1449,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         pred: ty::PolyTraitRef<'tcx>,\n     ) -> bool {\n-        struct ParamToVarFolder<'a, 'tcx: 'a> {\n+        struct ParamToVarFolder<'a, 'tcx> {\n             infcx: &'a InferCtxt<'a, 'tcx>,\n             var_map: FxHashMap<Ty<'tcx>, Ty<'tcx>>,\n         }"}, {"sha": "f106458c7676a93068c890ae8268848408df767c", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -224,7 +224,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n     }\n }\n \n-struct FulfillProcessor<'a, 'b: 'a, 'tcx: 'b> {\n+struct FulfillProcessor<'a, 'b, 'tcx> {\n     selcx: &'a mut SelectionContext<'b, 'tcx>,\n     register_region_obligations: bool,\n }"}, {"sha": "0f4b7aff82bce82cb1646be85f7145f00f7381e9", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -285,7 +285,7 @@ where\n     }\n }\n \n-struct AssocTypeNormalizer<'a, 'b: 'a, 'tcx: 'b> {\n+struct AssocTypeNormalizer<'a, 'b, 'tcx> {\n     selcx: &'a mut SelectionContext<'b, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     cause: ObligationCause<'tcx>,\n@@ -409,7 +409,6 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                             promoted: None\n                         };\n                         if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n-                            let substs = tcx.lift_to_global(&substs).unwrap();\n                             let evaluated = evaluated.subst(tcx, substs);\n                             return evaluated;\n                         }"}, {"sha": "5dd1b9e3d53f3a6db5d9e7b2ad831c6527ae7af4", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -73,7 +73,7 @@ pub struct NormalizationResult<'tcx> {\n     pub normalized_ty: Ty<'tcx>,\n }\n \n-struct QueryNormalizer<'cx, 'tcx: 'cx> {\n+struct QueryNormalizer<'cx, 'tcx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n     cause: &'cx ObligationCause<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -203,7 +203,6 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                             promoted: None,\n                         };\n                         if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n-                            let substs = tcx.lift_to_global(&substs).unwrap();\n                             let evaluated = evaluated.subst(tcx, substs);\n                             return evaluated;\n                         }"}, {"sha": "4a07a3120f3e83b61409caf691e7cdf72f29a64f", "filename": "src/librustc/traits/query/type_op/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -8,7 +8,7 @@ use std::rc::Rc;\n use crate::traits::query::Fallible;\n use crate::traits::ObligationCause;\n use crate::ty::fold::TypeFoldable;\n-use crate::ty::{Lift, ParamEnvAnd, TyCtxt};\n+use crate::ty::{ParamEnvAnd, TyCtxt};\n \n pub mod ascribe_user_type;\n pub mod custom;\n@@ -44,8 +44,8 @@ pub trait TypeOp<'tcx>: Sized + fmt::Debug {\n /// which produces the resulting query region constraints.\n ///\n /// [c]: https://rust-lang.github.io/rustc-guide/traits/canonicalization.html\n-pub trait QueryTypeOp<'tcx>: fmt::Debug + Sized + TypeFoldable<'tcx> + Lift<'tcx> {\n-    type QueryResponse: TypeFoldable<'tcx> + Lift<'tcx>;\n+pub trait QueryTypeOp<'tcx>: fmt::Debug + Sized + TypeFoldable<'tcx> + 'tcx {\n+    type QueryResponse: TypeFoldable<'tcx>;\n \n     /// Give query the option for a simple fast path that never\n     /// actually hits the tcx cache lookup etc. Return `Some(r)` with"}, {"sha": "3fe85d8d83eb9c39eb67d5e7ec9c4eb2e74611a9", "filename": "src/librustc/traits/query/type_op/normalize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -20,7 +20,7 @@ where\n \n impl<'tcx, T> super::QueryTypeOp<'tcx> for Normalize<T>\n where\n-    T: Normalizable<'tcx>,\n+    T: Normalizable<'tcx> + 'tcx,\n {\n     type QueryResponse = T;\n "}, {"sha": "7c4742259ac161cae85c08cb00fb93e66010d910", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -50,7 +50,7 @@ use std::iter;\n use std::rc::Rc;\n use crate::util::nodemap::{FxHashMap, FxHashSet};\n \n-pub struct SelectionContext<'cx, 'tcx: 'cx> {\n+pub struct SelectionContext<'cx, 'tcx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n \n     /// Freshener used specifically for entries on the obligation\n@@ -144,7 +144,7 @@ impl IntercrateAmbiguityCause {\n }\n \n // A stack that walks back up the stack frame.\n-struct TraitObligationStack<'prev, 'tcx: 'prev> {\n+struct TraitObligationStack<'prev, 'tcx> {\n     obligation: &'prev TraitObligation<'tcx>,\n \n     /// Trait ref from `obligation` but \"freshened\" with the\n@@ -690,14 +690,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// Evaluates the predicates in `predicates` recursively. Note that\n     /// this applies projections in the predicates, and therefore\n     /// is run within an inference probe.\n-    fn evaluate_predicates_recursively<'a, 'o, I>(\n+    fn evaluate_predicates_recursively<'o, I>(\n         &mut self,\n         stack: TraitObligationStackList<'o, 'tcx>,\n         predicates: I,\n     ) -> Result<EvaluationResult, OverflowError>\n     where\n         I: IntoIterator<Item = PredicateObligation<'tcx>>,\n-        'tcx: 'a,\n     {\n         let mut result = EvaluatedToOk;\n         for obligation in predicates {\n@@ -3789,9 +3788,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         matcher.relate(previous, current).is_ok()\n     }\n \n-    fn push_stack<'o, 's: 'o>(\n+    fn push_stack<'o>(\n         &mut self,\n-        previous_stack: TraitObligationStackList<'s, 'tcx>,\n+        previous_stack: TraitObligationStackList<'o, 'tcx>,\n         obligation: &'o TraitObligation<'tcx>,\n     ) -> TraitObligationStack<'o, 'tcx> {\n         let fresh_trait_ref = obligation\n@@ -4252,7 +4251,7 @@ impl<'tcx> ProvisionalEvaluationCache<'tcx> {\n }\n \n #[derive(Copy, Clone)]\n-struct TraitObligationStackList<'o, 'tcx: 'o> {\n+struct TraitObligationStackList<'o, 'tcx> {\n     cache: &'o ProvisionalEvaluationCache<'tcx>,\n     head: Option<&'o TraitObligationStack<'o, 'tcx>>,\n }"}, {"sha": "43bb4edd9b27d8e75d1501e9915cc93289a0a838", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -132,12 +132,7 @@ pub fn find_associated_item<'tcx>(\n                 let substs = substs.rebase_onto(tcx, trait_def_id, impl_data.substs);\n                 let substs = translate_substs(&infcx, param_env, impl_data.impl_def_id,\n                                               substs, node_item.node);\n-                let substs = infcx.tcx.erase_regions(&substs);\n-                tcx.lift(&substs).unwrap_or_else(||\n-                    bug!(\"find_method: translate_substs \\\n-                          returned {:?} which contains inference types/regions\",\n-                         substs)\n-                )\n+                infcx.tcx.erase_regions(&substs)\n             });\n             (node_item.item.def_id, substs)\n         }"}, {"sha": "2d295679be32406c2eac5c67dc8b418d8d8045cf", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -654,7 +654,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn impl_is_default(self, node_item_def_id: DefId) -> bool {\n         match self.hir().as_local_hir_id(node_item_def_id) {\n             Some(hir_id) => {\n-                let item = self.hir().expect_item_by_hir_id(hir_id);\n+                let item = self.hir().expect_item(hir_id);\n                 if let hir::ItemKind::Impl(_, _, defaultness, ..) = item.node {\n                     defaultness.is_default()\n                 } else {"}, {"sha": "b84ebd8afe8852bfdff20a09ef7ab7bd07dd8e96", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -250,11 +250,9 @@ fn validate_hir_id_for_typeck_tables(local_id_root: Option<DefId>,\n         if let Some(local_id_root) = local_id_root {\n             if hir_id.owner != local_id_root.index {\n                 ty::tls::with(|tcx| {\n-                    let node_id = tcx.hir().hir_to_node_id(hir_id);\n-\n                     bug!(\"node {} with HirId::owner {:?} cannot be placed in \\\n                           TypeckTables with local_id_root {:?}\",\n-                         tcx.hir().node_to_string(node_id),\n+                         tcx.hir().node_to_string(hir_id),\n                          DefId::local(hir_id.owner),\n                          local_id_root)\n                 });\n@@ -556,7 +554,7 @@ impl<'tcx> TypeckTables<'tcx> {\n     pub fn node_type(&self, id: hir::HirId) -> Ty<'tcx> {\n         self.node_type_opt(id).unwrap_or_else(||\n             bug!(\"node_type: no type for node `{}`\",\n-                 tls::with(|tcx| tcx.hir().hir_to_string(id)))\n+                 tls::with(|tcx| tcx.hir().node_to_string(id)))\n         )\n     }\n "}, {"sha": "b8bdde4a787380a4e110e8691c578107413fe821", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -192,9 +192,12 @@ impl<'tcx> ty::TyS<'tcx> {\n \n             ty::Adt(def, _) => format!(\"{} `{}`\", def.descr(), tcx.def_path_str(def.did)).into(),\n             ty::Foreign(def_id) => format!(\"extern type `{}`\", tcx.def_path_str(def_id)).into(),\n-            ty::Array(_, n) => match n.assert_usize(tcx) {\n-                Some(n) => format!(\"array of {} elements\", n).into(),\n-                None => \"array\".into(),\n+            ty::Array(_, n) => {\n+                let n = tcx.lift_to_global(&n).unwrap();\n+                match n.assert_usize(tcx) {\n+                    Some(n) => format!(\"array of {} elements\", n).into(),\n+                    None => \"array\".into(),\n+                }\n             }\n             ty::Slice(_) => \"slice\".into(),\n             ty::RawPtr(_) => \"*-ptr\".into(),"}, {"sha": "9ce1d2eec5d27a80e3065596216afa35addd2cdd", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -2711,7 +2711,7 @@ where\n             }\n \n             // If this is a C-variadic function, this is not the return value,\n-            // and there is one or more fixed arguments; ensure that the `VaList`\n+            // and there is one or more fixed arguments; ensure that the `VaListImpl`\n             // is ignored as an argument.\n             if sig.c_variadic {\n                 match (last_arg_idx, arg_idx) {\n@@ -2722,7 +2722,7 @@ where\n                         };\n                         match ty.sty {\n                             ty::Adt(def, _) if def.did == va_list_did => {\n-                                // This is the \"spoofed\" `VaList`. Set the arguments mode\n+                                // This is the \"spoofed\" `VaListImpl`. Set the arguments mode\n                                 // so that it will be ignored.\n                                 arg.mode = PassMode::Ignore(IgnoreMode::CVarArgs);\n                             }"}, {"sha": "361410380e8f8ad52b4e738ab9ae31c9b7d14ab1", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -277,7 +277,7 @@ impl Visibility {\n                 def => Visibility::Restricted(def.def_id()),\n             },\n             hir::VisibilityKind::Inherited => {\n-                Visibility::Restricted(tcx.hir().get_module_parent_by_hir_id(id))\n+                Visibility::Restricted(tcx.hir().get_module_parent(id))\n             }\n         }\n     }\n@@ -3016,7 +3016,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Gets the attributes of a definition.\n     pub fn get_attrs(self, did: DefId) -> Attributes<'tcx> {\n         if let Some(id) = self.hir().as_local_hir_id(did) {\n-            Attributes::Borrowed(self.hir().attrs_by_hir_id(id))\n+            Attributes::Borrowed(self.hir().attrs(id))\n         } else {\n             Attributes::Owned(self.item_attrs(did))\n         }\n@@ -3068,7 +3068,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn span_of_impl(self, impl_did: DefId) -> Result<Span, Symbol> {\n         if impl_did.is_local() {\n             let hir_id = self.hir().as_local_hir_id(impl_did).unwrap();\n-            Ok(self.hir().span_by_hir_id(hir_id))\n+            Ok(self.hir().span(hir_id))\n         } else {\n             Err(self.crate_name(impl_did.krate))\n         }\n@@ -3103,7 +3103,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let scope = match ident.span.modernize_and_adjust(self.expansion_that_defined(scope)) {\n             Some(actual_expansion) =>\n                 self.hir().definitions().parent_module_of_macro_def(actual_expansion),\n-            None => self.hir().get_module_parent_by_hir_id(block),\n+            None => self.hir().get_module_parent(block),\n         };\n         (ident, scope)\n     }\n@@ -3129,7 +3129,7 @@ fn associated_item<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> AssocItem {\n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let parent_id = tcx.hir().get_parent_item(id);\n     let parent_def_id = tcx.hir().local_def_id_from_hir_id(parent_id);\n-    let parent_item = tcx.hir().expect_item_by_hir_id(parent_id);\n+    let parent_item = tcx.hir().expect_item(parent_id);\n     match parent_item.node {\n         hir::ItemKind::Impl(.., ref impl_item_refs) => {\n             if let Some(impl_item_ref) = impl_item_refs.iter().find(|i| i.id.hir_id == id) {\n@@ -3186,7 +3186,7 @@ fn adt_sized_constraint<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> AdtSizedConst\n \n fn associated_item_def_ids<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx [DefId] {\n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    let item = tcx.hir().expect_item_by_hir_id(id);\n+    let item = tcx.hir().expect_item(id);\n     match item.node {\n         hir::ItemKind::Trait(.., ref trait_item_refs) => {\n             tcx.arena.alloc_from_iter(\n@@ -3266,7 +3266,7 @@ fn param_env<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> ParamEnv<'tcx> {\n     );\n \n     let body_id = tcx.hir().as_local_hir_id(def_id).map_or(hir::DUMMY_HIR_ID, |id| {\n-        tcx.hir().maybe_body_owned_by_by_hir_id(id).map_or(id, |body| body.hir_id)\n+        tcx.hir().maybe_body_owned_by(id).map_or(id, |body| body.hir_id)\n     });\n     let cause = traits::ObligationCause::misc(tcx.def_span(def_id), body_id);\n     traits::normalize_param_env_or_error(tcx, def_id, unnormalized_env, cause)"}, {"sha": "d143cc3e6092d00331c829ccc078698361eaf733", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -589,7 +589,7 @@ pub trait PrettyPrinter<'tcx>:\n \n                 // FIXME(eddyb) should use `def_span`.\n                 if let Some(hir_id) = self.tcx().hir().as_local_hir_id(did) {\n-                    p!(write(\"@{:?}\", self.tcx().hir().span_by_hir_id(hir_id)));\n+                    p!(write(\"@{:?}\", self.tcx().hir().span(hir_id)));\n                     let mut sep = \" \";\n                     for (&var_id, upvar_ty) in self.tcx().upvars(did)\n                         .as_ref()\n@@ -631,7 +631,7 @@ pub trait PrettyPrinter<'tcx>:\n                     if self.tcx().sess.opts.debugging_opts.span_free_formats {\n                         p!(write(\"@{:?}\", hir_id));\n                     } else {\n-                        p!(write(\"@{:?}\", self.tcx().hir().span_by_hir_id(hir_id)));\n+                        p!(write(\"@{:?}\", self.tcx().hir().span(hir_id)));\n                     }\n                     let mut sep = \" \";\n                     for (&var_id, upvar_ty) in self.tcx().upvars(did)"}, {"sha": "982886f0f157397ef415e3816d703112ea98ab21", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -505,13 +505,11 @@ impl<'a, 'tcx> DecoderWithPosition for CacheDecoder<'a, 'tcx> {\n \n // Decode something that was encoded with encode_tagged() and verify that the\n // tag matches and the correct amount of bytes was read.\n-fn decode_tagged<'a, 'tcx, D, T, V>(decoder: &mut D,\n-                                    expected_tag: T)\n-                                    -> Result<V, D::Error>\n-    where T: Decodable + Eq + ::std::fmt::Debug,\n-          V: Decodable,\n-          D: DecoderWithPosition,\n-          'tcx: 'a,\n+fn decode_tagged<D, T, V>(decoder: &mut D, expected_tag: T) -> Result<V, D::Error>\n+where\n+    T: Decodable + Eq + ::std::fmt::Debug,\n+    V: Decodable,\n+    D: DecoderWithPosition,\n {\n     let start_pos = decoder.position();\n "}, {"sha": "0f158d2982a20dc8d2d87772e6cd560fd3782ba3", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -89,7 +89,7 @@ macro_rules! profq_query_msg {\n \n /// A type representing the responsibility to execute the job in the `job` field.\n /// This will poison the relevant query if dropped.\n-pub(super) struct JobOwner<'a, 'tcx: 'a, Q: QueryDescription<'tcx> + 'a> {\n+pub(super) struct JobOwner<'a, 'tcx, Q: QueryDescription<'tcx> + 'a> {\n     cache: &'a Lock<QueryCache<'tcx, Q>>,\n     key: Q::Key,\n     job: Lrc<QueryJob<'tcx>>,\n@@ -230,7 +230,7 @@ pub struct CycleError<'tcx> {\n }\n \n /// The result of `try_get_lock`\n-pub(super) enum TryGetJob<'a, 'tcx: 'a, D: QueryDescription<'tcx> + 'a> {\n+pub(super) enum TryGetJob<'a, 'tcx, D: QueryDescription<'tcx> + 'a> {\n     /// The query is not yet started. Contains a guard to the cache eventually used to start it.\n     NotYetStarted(JobOwner<'a, 'tcx, D>),\n "}, {"sha": "4cd0fd3e824f5d5ddb887da6d1f63f8da4b59894", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -1335,7 +1335,7 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Const<'tcx> {\n impl<'tcx> TypeFoldable<'tcx> for ConstValue<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n-            ConstValue::ByRef(ptr, alloc) => ConstValue::ByRef(ptr, alloc),\n+            ConstValue::ByRef(ptr, align, alloc) => ConstValue::ByRef(ptr, align, alloc),\n             ConstValue::Infer(ic) => ConstValue::Infer(ic.fold_with(folder)),\n             ConstValue::Param(p) => ConstValue::Param(p.fold_with(folder)),\n             ConstValue::Placeholder(p) => ConstValue::Placeholder(p),"}, {"sha": "8bfbd8b854b03589506ff74ba39a709086a3bd58", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -2262,7 +2262,6 @@ impl<'tcx> Const<'tcx> {\n \n     #[inline]\n     pub fn from_bits(tcx: TyCtxt<'tcx>, bits: u128, ty: ParamEnvAnd<'tcx, Ty<'tcx>>) -> &'tcx Self {\n-        let ty = tcx.lift_to_global(&ty).unwrap();\n         let size = tcx.layout_of(ty).unwrap_or_else(|e| {\n             panic!(\"could not compute layout for {:?}: {:?}\", ty, e)\n         }).size;\n@@ -2289,7 +2288,6 @@ impl<'tcx> Const<'tcx> {\n         if self.ty != ty.value {\n             return None;\n         }\n-        let ty = tcx.lift_to_global(&ty).unwrap();\n         let size = tcx.layout_of(ty).ok()?.size;\n         self.val.try_to_bits(size)\n     }\n@@ -2300,15 +2298,14 @@ impl<'tcx> Const<'tcx> {\n     }\n \n     #[inline]\n-    pub fn assert_bits(&self, tcx: TyCtxt<'_>, ty: ParamEnvAnd<'tcx, Ty<'tcx>>) -> Option<u128> {\n+    pub fn assert_bits(&self, tcx: TyCtxt<'tcx>, ty: ParamEnvAnd<'tcx, Ty<'tcx>>) -> Option<u128> {\n         assert_eq!(self.ty, ty.value);\n-        let ty = tcx.lift_to_global(&ty).unwrap();\n         let size = tcx.layout_of(ty).ok()?.size;\n         self.val.try_to_bits(size)\n     }\n \n     #[inline]\n-    pub fn assert_bool(&self, tcx: TyCtxt<'_>) -> Option<bool> {\n+    pub fn assert_bool(&self, tcx: TyCtxt<'tcx>) -> Option<bool> {\n         self.assert_bits(tcx, ParamEnv::empty().and(tcx.types.bool)).and_then(|v| match v {\n             0 => Some(false),\n             1 => Some(true),\n@@ -2317,18 +2314,18 @@ impl<'tcx> Const<'tcx> {\n     }\n \n     #[inline]\n-    pub fn assert_usize(&self, tcx: TyCtxt<'_>) -> Option<u64> {\n+    pub fn assert_usize(&self, tcx: TyCtxt<'tcx>) -> Option<u64> {\n         self.assert_bits(tcx, ParamEnv::empty().and(tcx.types.usize)).map(|v| v as u64)\n     }\n \n     #[inline]\n-    pub fn unwrap_bits(&self, tcx: TyCtxt<'_>, ty: ParamEnvAnd<'tcx, Ty<'tcx>>) -> u128 {\n+    pub fn unwrap_bits(&self, tcx: TyCtxt<'tcx>, ty: ParamEnvAnd<'tcx, Ty<'tcx>>) -> u128 {\n         self.assert_bits(tcx, ty).unwrap_or_else(||\n             bug!(\"expected bits of {}, got {:#?}\", ty.value, self))\n     }\n \n     #[inline]\n-    pub fn unwrap_usize(&self, tcx: TyCtxt<'_>) -> u64 {\n+    pub fn unwrap_usize(&self, tcx: TyCtxt<'tcx>) -> u64 {\n         self.assert_usize(tcx).unwrap_or_else(||\n             bug!(\"expected constant usize, got {:#?}\", self))\n     }"}, {"sha": "1979b4317a7ae9281f70303c8aa816a0d1c35ffc", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -101,7 +101,7 @@ pub fn predicate_obligations<'a, 'tcx>(\n     wf.normalize()\n }\n \n-struct WfPredicates<'a, 'tcx: 'a> {\n+struct WfPredicates<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body_id: hir::HirId,"}, {"sha": "d402b0ddf6e85f3be4a3fb18c3ca159ab0a3724b", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -19,7 +19,7 @@ use syntax::{\n     mut_visit::{self, MutVisitor},\n     parse::ParseSess,\n     ptr::P,\n-    symbol::{kw, sym, Symbol}\n+    symbol::{kw, sym}\n };\n use syntax_pos::Span;\n \n@@ -58,11 +58,10 @@ impl MutVisitor for ExpandAllocatorDirectives<'_> {\n     fn flat_map_item(&mut self, item: P<Item>) -> SmallVec<[P<Item>; 1]> {\n         debug!(\"in submodule {}\", self.in_submod);\n \n-        let name = if attr::contains_name(&item.attrs, sym::global_allocator) {\n-            \"global_allocator\"\n-        } else {\n+        if !attr::contains_name(&item.attrs, sym::global_allocator) {\n             return mut_visit::noop_flat_map_item(item, self);\n-        };\n+        }\n+\n         match item.node {\n             ItemKind::Static(..) => {}\n             _ => {\n@@ -87,15 +86,9 @@ impl MutVisitor for ExpandAllocatorDirectives<'_> {\n \n         // Create a fresh Mark for the new macro expansion we are about to do\n         let mark = Mark::fresh(Mark::root());\n-        mark.set_expn_info(ExpnInfo {\n-            call_site: item.span, // use the call site of the static\n-            def_site: None,\n-            format: MacroAttribute(Symbol::intern(name)),\n-            allow_internal_unstable: Some(vec![sym::rustc_attrs].into()),\n-            allow_internal_unsafe: false,\n-            local_inner_macros: false,\n-            edition: self.sess.edition,\n-        });\n+        mark.set_expn_info(ExpnInfo::with_unstable(\n+            MacroAttribute(sym::global_allocator), item.span, self.sess.edition, &[sym::rustc_attrs]\n+        ));\n \n         // Tie the span to the macro expansion info we just created\n         let span = item.span.with_ctxt(SyntaxContext::empty().apply_mark(mark));"}, {"sha": "ace44421d3757e980dd5e12e745468ad152b4fc0", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -78,7 +78,7 @@ fn owned_ptr_base_path_rc<'tcx>(loan_path: &Rc<LoanPath<'tcx>>) -> Rc<LoanPath<'\n     }\n }\n \n-struct CheckLoanCtxt<'a, 'tcx: 'a> {\n+struct CheckLoanCtxt<'a, 'tcx> {\n     bccx: &'a BorrowckCtxt<'a, 'tcx>,\n     dfcx_loans: &'a LoanDataFlow<'tcx>,\n     move_data: &'a move_data::FlowedMoveData<'tcx>,"}, {"sha": "05c0a22900a0b3d9ee74485e7340a2a7343f19d0", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -16,11 +16,11 @@ use rustc::hir::*;\n use rustc::hir::Node;\n use log::debug;\n \n-struct GatherMoveInfo<'c, 'tcx: 'c> {\n+struct GatherMoveInfo<'c, 'tcx> {\n     id: hir::ItemLocalId,\n     kind: MoveKind,\n     cmt: &'c mc::cmt_<'tcx>,\n-    span_path_opt: Option<MovePlace<'tcx>>\n+    span_path_opt: Option<MovePlace<'tcx>>,\n }\n \n /// Represents the kind of pattern\n@@ -91,11 +91,13 @@ pub fn gather_move_from_expr<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     gather_move(bccx, move_data, move_error_collector, move_info);\n }\n \n-pub fn gather_move_from_pat<'a, 'c, 'tcx: 'c>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                              move_data: &MoveData<'tcx>,\n-                                              move_error_collector: &mut MoveErrorCollector<'tcx>,\n-                                              move_pat: &hir::Pat,\n-                                              cmt: &'c mc::cmt_<'tcx>) {\n+pub fn gather_move_from_pat<'a, 'c, 'tcx>(\n+    bccx: &BorrowckCtxt<'a, 'tcx>,\n+    move_data: &MoveData<'tcx>,\n+    move_error_collector: &mut MoveErrorCollector<'tcx>,\n+    move_pat: &hir::Pat,\n+    cmt: &'c mc::cmt_<'tcx>,\n+) {\n     let source = get_pattern_source(bccx.tcx,move_pat);\n     let pat_span_path_opt = match move_pat.node {\n         PatKind::Binding(_, _, ident, _) => {\n@@ -121,10 +123,12 @@ pub fn gather_move_from_pat<'a, 'c, 'tcx: 'c>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     gather_move(bccx, move_data, move_error_collector, move_info);\n }\n \n-fn gather_move<'a, 'c, 'tcx: 'c>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                         move_data: &MoveData<'tcx>,\n-                         move_error_collector: &mut MoveErrorCollector<'tcx>,\n-                         move_info: GatherMoveInfo<'c, 'tcx>) {\n+fn gather_move<'a, 'c, 'tcx>(\n+    bccx: &BorrowckCtxt<'a, 'tcx>,\n+    move_data: &MoveData<'tcx>,\n+    move_error_collector: &mut MoveErrorCollector<'tcx>,\n+    move_info: GatherMoveInfo<'c, 'tcx>,\n+) {\n     debug!(\"gather_move(move_id={:?}, cmt={:?})\",\n            move_info.id, move_info.cmt);\n "}, {"sha": "3122a6060fbde52216b6fa69793fd17ced4cbf55", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -38,7 +38,7 @@ pub fn guarantee_lifetime<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n ///////////////////////////////////////////////////////////////////////////\n // Private\n \n-struct GuaranteeLifetimeContext<'a, 'tcx: 'a> {\n+struct GuaranteeLifetimeContext<'a, 'tcx> {\n     bccx: &'a BorrowckCtxt<'a, 'tcx>,\n \n     // the scope of the function body for the enclosing item"}, {"sha": "887011d3476d3a1bc0e13a156724bd7556a48b9d", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -56,7 +56,7 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     (all_loans, move_data)\n }\n \n-struct GatherLoanCtxt<'a, 'tcx: 'a> {\n+struct GatherLoanCtxt<'a, 'tcx> {\n     bccx: &'a BorrowckCtxt<'a, 'tcx>,\n     move_data: move_data::MoveData<'tcx>,\n     move_error_collector: move_error::MoveErrorCollector<'tcx>,"}, {"sha": "58be2cf76c72438ee3a373d24d11ca23b00f5b33", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -88,7 +88,7 @@ fn report_move_errors<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>, errors: &[MoveErr\n             }\n         }\n         if let NoteClosureEnv(upvar_id) = error.move_from.note {\n-            err.span_label(bccx.tcx.hir().span_by_hir_id(upvar_id.var_path.hir_id),\n+            err.span_label(bccx.tcx.hir().span(upvar_id.var_path.hir_id),\n                            \"captured outer variable\");\n         }\n         err.emit();"}, {"sha": "371e6c55a7389afd6ab90457de8994d8fd32164f", "filename": "src/librustc_borrowck/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -37,7 +37,7 @@ pub fn compute_restrictions<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n ///////////////////////////////////////////////////////////////////////////\n // Private\n \n-struct RestrictionsContext<'a, 'tcx: 'a> {\n+struct RestrictionsContext<'a, 'tcx> {\n     bccx: &'a BorrowckCtxt<'a, 'tcx>,\n     span: Span,\n     loan_region: ty::Region<'tcx>,"}, {"sha": "025d5adc2b3eaa74058d4ab6b4624dbc848e82ce", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -198,7 +198,7 @@ pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n     cfg: &cfg::CFG,\n ) -> (BorrowckCtxt<'a, 'tcx>, AnalysisData<'tcx>) {\n     let owner_id = tcx.hir().body_owner(body_id);\n-    let owner_def_id = tcx.hir().local_def_id(owner_id);\n+    let owner_def_id = tcx.hir().local_def_id_from_hir_id(owner_id);\n     let tables = tcx.typeck_tables_of(owner_def_id);\n     let region_scope_tree = tcx.region_scope_tree(owner_def_id);\n     let body = tcx.hir().body(body_id);\n@@ -389,8 +389,8 @@ pub enum LoanPathElem<'tcx> {\n }\n \n fn closure_to_block(closure_id: LocalDefId, tcx: TyCtxt<'_>) -> HirId {\n-    let closure_id = tcx.hir().local_def_id_to_node_id(closure_id);\n-    match tcx.hir().get(closure_id) {\n+    let closure_id = tcx.hir().local_def_id_to_hir_id(closure_id);\n+    match tcx.hir().get_by_hir_id(closure_id) {\n         Node::Expr(expr) => match expr.node {\n             hir::ExprKind::Closure(.., body_id, _, _) => {\n                 body_id.hir_id\n@@ -552,7 +552,7 @@ pub enum bckerr_code<'tcx> {\n // Combination of an error code and the categorization of the expression\n // that caused it\n #[derive(Debug, PartialEq)]\n-pub struct BckError<'c, 'tcx: 'c> {\n+pub struct BckError<'c, 'tcx> {\n     span: Span,\n     cause: AliasableViolationKind,\n     cmt: &'c mc::cmt_<'tcx>,\n@@ -699,7 +699,7 @@ impl BorrowckCtxt<'_, 'tcx> {\n             }\n \n             move_data::MoveExpr |\n-            move_data::MovePat => (self.tcx.hir().span_by_hir_id(hir_id), \"\"),\n+            move_data::MovePat => (self.tcx.hir().span(hir_id), \"\"),\n \n             move_data::Captured =>\n                 (match self.tcx.hir().expect_expr_by_hir_id(hir_id).node {\n@@ -828,7 +828,7 @@ impl BorrowckCtxt<'_, 'tcx> {\n                         let mut db = self.cannot_assign(error_span, &descr, Origin::Ast);\n                         if let mc::NoteClosureEnv(upvar_id) = err.cmt.note {\n                             let hir_id = upvar_id.var_path.hir_id;\n-                            let sp = self.tcx.hir().span_by_hir_id(hir_id);\n+                            let sp = self.tcx.hir().span(hir_id);\n                             let fn_closure_msg = \"`Fn` closures cannot capture their enclosing \\\n                                                   environment for modifications\";\n                             match (self.tcx.sess.source_map().span_to_snippet(sp), &err.cmt.cat) {\n@@ -896,8 +896,7 @@ impl BorrowckCtxt<'_, 'tcx> {\n                 // to implement two traits for \"one operator\" is not very intuitive for\n                 // many programmers.\n                 if err.cmt.note == mc::NoteIndex {\n-                    let node_id = self.tcx.hir().hir_to_node_id(err.cmt.hir_id);\n-                    let node =  self.tcx.hir().get(node_id);\n+                    let node = self.tcx.hir().get_by_hir_id(err.cmt.hir_id);\n \n                     // This pattern probably always matches.\n                     if let Node::Expr(\n@@ -1022,8 +1021,8 @@ impl BorrowckCtxt<'_, 'tcx> {\n                 }\n \n                 if let ty::ReScope(scope) = *super_scope {\n-                    let node_id = scope.node_id(self.tcx, &self.region_scope_tree);\n-                    match self.tcx.hir().find(node_id) {\n+                    let hir_id = scope.hir_id(&self.region_scope_tree);\n+                    match self.tcx.hir().find_by_hir_id(hir_id) {\n                         Some(Node::Stmt(_)) => {\n                             if *sub_scope != ty::ReStatic {\n                                 db.note(\"consider using a `let` binding to increase its lifetime\");\n@@ -1118,7 +1117,7 @@ impl BorrowckCtxt<'_, 'tcx> {\n                     \"consider changing this closure to take self by mutable reference\"\n                 };\n                 let hir_id = self.tcx.hir().local_def_id_to_hir_id(id);\n-                let help_span = self.tcx.hir().span_by_hir_id(hir_id);\n+                let help_span = self.tcx.hir().span(hir_id);\n                 self.cannot_act_on_capture_in_sharable_fn(span,\n                                                           prefix,\n                                                           (help_span, help_msg),\n@@ -1224,7 +1223,7 @@ impl BorrowckCtxt<'_, 'tcx> {\n             Some(ImmutabilityBlame::LocalDeref(hir_id)) => {\n                 match self.local_binding_mode(hir_id) {\n                     ty::BindByReference(..) => {\n-                        let let_span = self.tcx.hir().span_by_hir_id(hir_id);\n+                        let let_span = self.tcx.hir().span(hir_id);\n                         let suggestion = suggest_ref_mut(self.tcx, let_span);\n                         if let Some(replace_str) = suggestion {\n                             db.span_suggestion(\n@@ -1272,7 +1271,7 @@ impl BorrowckCtxt<'_, 'tcx> {\n                             db: &mut DiagnosticBuilder<'_>,\n                             borrowed_hir_id: hir::HirId,\n                             binding_hir_id: hir::HirId) {\n-        let let_span = self.tcx.hir().span_by_hir_id(binding_hir_id);\n+        let let_span = self.tcx.hir().span(binding_hir_id);\n         if let ty::BindByValue(..) = self.local_binding_mode(binding_hir_id) {\n             if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(let_span) {\n                 let (ty, is_implicit_self) = self.local_ty(binding_hir_id);\n@@ -1290,7 +1289,7 @@ impl BorrowckCtxt<'_, 'tcx> {\n                 {\n                     let borrow_expr_id = self.tcx.hir().get_parent_node_by_hir_id(borrowed_hir_id);\n                     db.span_suggestion(\n-                        self.tcx.hir().span_by_hir_id(borrow_expr_id),\n+                        self.tcx.hir().span(borrow_expr_id),\n                         \"consider removing the `&mut`, as it is an \\\n                         immutable binding to a mutable reference\",\n                         snippet,\n@@ -1361,7 +1360,7 @@ impl BorrowckCtxt<'_, 'tcx> {\n                 if *kind == ty::ClosureKind::Fn {\n                     let closure_hir_id =\n                         self.tcx.hir().local_def_id_to_hir_id(upvar_id.closure_expr_id);\n-                    db.span_help(self.tcx.hir().span_by_hir_id(closure_hir_id),\n+                    db.span_help(self.tcx.hir().span(closure_hir_id),\n                                  \"consider changing this closure to take \\\n                                   self by mutable reference\");\n                 }\n@@ -1370,7 +1369,7 @@ impl BorrowckCtxt<'_, 'tcx> {\n                 if let Categorization::Deref(..) = err.cmt.cat {\n                     db.span_label(*error_span, \"cannot borrow as mutable\");\n                 } else if let Categorization::Local(local_id) = err.cmt.cat {\n-                    let span = self.tcx.hir().span_by_hir_id(local_id);\n+                    let span = self.tcx.hir().span(local_id);\n                     if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n                         if snippet.starts_with(\"ref mut \") || snippet.starts_with(\"&mut \") {\n                             db.span_label(*error_span, \"cannot reborrow mutably\");\n@@ -1509,13 +1508,12 @@ impl<'tcx> fmt::Debug for LoanPath<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.kind {\n             LpVar(id) => {\n-                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir().hir_to_string(id)))\n+                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir().node_to_string(id)))\n             }\n \n             LpUpvar(ty::UpvarId{ var_path: ty::UpvarPath {hir_id: var_id}, closure_expr_id }) => {\n                 let s = ty::tls::with(|tcx| {\n-                    let var_node_id = tcx.hir().hir_to_node_id(var_id);\n-                    tcx.hir().node_to_string(var_node_id)\n+                    tcx.hir().node_to_string(var_id)\n                 });\n                 write!(f, \"$({} captured by id={:?})\", s, closure_expr_id)\n             }\n@@ -1549,8 +1547,7 @@ impl<'tcx> fmt::Display for LoanPath<'tcx> {\n \n             LpUpvar(ty::UpvarId{ var_path: ty::UpvarPath { hir_id }, closure_expr_id: _ }) => {\n                 let s = ty::tls::with(|tcx| {\n-                    let var_node_id = tcx.hir().hir_to_node_id(hir_id);\n-                    tcx.hir().node_to_string(var_node_id)\n+                    tcx.hir().node_to_string(hir_id)\n                 });\n                 write!(f, \"$({} captured by closure)\", s)\n             }"}, {"sha": "7a8a23ca76afc50834d4543faea434af4a4457d6", "filename": "src/librustc_borrowck/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fgraphviz.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -30,7 +30,7 @@ impl Variant {\n     }\n }\n \n-pub struct DataflowLabeller<'a, 'tcx: 'a> {\n+pub struct DataflowLabeller<'a, 'tcx> {\n     pub inner: cfg_dot::LabelledCFG<'a, 'tcx>,\n     pub variants: Vec<Variant>,\n     pub borrowck_ctxt: &'a BorrowckCtxt<'a, 'tcx>,"}, {"sha": "e06b4d8b3063e8cd7a3666853be08d171dd0421f", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -27,7 +27,7 @@ use std::iter::TrustedLen;\n \n // All Builders must have an llfn associated with them\n #[must_use]\n-pub struct Builder<'a, 'll: 'a, 'tcx: 'll> {\n+pub struct Builder<'a, 'll, 'tcx> {\n     pub llbuilder: &'ll mut llvm::Builder<'ll>,\n     pub cx: &'a CodegenCx<'ll, 'tcx>,\n }"}, {"sha": "f21f203fcc99f0abea1f89e242014445b3dc37a5", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -11,7 +11,7 @@ use crate::value::Value;\n use rustc_codegen_ssa::traits::*;\n \n use crate::consts::const_alloc_to_llvm;\n-use rustc::ty::layout::{HasDataLayout, LayoutOf, self, TyLayout, Size};\n+use rustc::ty::layout::{HasDataLayout, LayoutOf, self, TyLayout, Size, Align};\n use rustc::mir::interpret::{Scalar, GlobalAlloc, Allocation};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n \n@@ -344,19 +344,20 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn from_const_alloc(\n         &self,\n         layout: TyLayout<'tcx>,\n+        align: Align,\n         alloc: &Allocation,\n         offset: Size,\n     ) -> PlaceRef<'tcx, &'ll Value> {\n         let init = const_alloc_to_llvm(self, alloc);\n-        let base_addr = self.static_addr_of(init, layout.align.abi, None);\n+        let base_addr = self.static_addr_of(init, align, None);\n \n         let llval = unsafe { llvm::LLVMConstInBoundsGEP(\n             self.const_bitcast(base_addr, self.type_i8p()),\n             &self.const_usize(offset.bytes()),\n             1,\n         )};\n         let llval = self.const_bitcast(llval, self.type_ptr_to(layout.llvm_type(self)));\n-        PlaceRef::new_sized(llval, layout, alloc.align)\n+        PlaceRef::new_sized(llval, layout, align)\n     }\n \n     fn const_ptrcast(&self, val: &'ll Value, ty: &'ll Type) -> &'ll Value {"}, {"sha": "4bf91bbed60eaeec8c0c64d37ea7ad58504db011", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -71,7 +71,9 @@ pub fn codegen_static_initializer(\n     let static_ = cx.tcx.const_eval(param_env.and(cid))?;\n \n     let alloc = match static_.val {\n-        ConstValue::ByRef(ptr, alloc) if ptr.offset.bytes() == 0 => alloc,\n+        ConstValue::ByRef(ptr, align, alloc) if ptr.offset.bytes() == 0 && align == alloc.align => {\n+            alloc\n+        },\n         _ => bug!(\"static const eval returned {:#?}\", static_),\n     };\n     Ok((const_alloc_to_llvm(cx, alloc), alloc))"}, {"sha": "6a61b180de430ff844063b2a9747218b153796bc", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -34,7 +34,7 @@ use crate::abi::Abi;\n /// There is one `CodegenCx` per compilation unit. Each one has its own LLVM\n /// `llvm::Context` so that several compilation units may be optimized in parallel.\n /// All other LLVM data structures in the `CodegenCx` are tied to that `llvm::Context`.\n-pub struct CodegenCx<'ll, 'tcx: 'll> {\n+pub struct CodegenCx<'ll, 'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n     pub check_overflow: bool,\n     pub use_dll_storage_attrs: bool,"}, {"sha": "7831c200114a5d2254f648ed43a06245dca61960", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 35, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -146,15 +146,8 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 self.va_end(args[0].immediate())\n             }\n             \"va_copy\" => {\n-                let va_list = match (tcx.lang_items().va_list(), &result.layout.ty.sty) {\n-                    (Some(did), ty::Adt(def, _)) if def.did == did => args[0].immediate(),\n-                    (Some(_), _)  => self.load(args[0].immediate(),\n-                                               tcx.data_layout.pointer_align.abi),\n-                    (None, _) => bug!(\"`va_list` language item must be defined\")\n-                };\n                 let intrinsic = self.cx().get_intrinsic(&(\"llvm.va_copy\"));\n-                self.call(intrinsic, &[llresult, va_list], None);\n-                return;\n+                self.call(intrinsic, &[args[0].immediate(), args[1].immediate()], None)\n             }\n             \"va_arg\" => {\n                 match fn_ty.ret.layout.abi {\n@@ -743,37 +736,12 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         self.call(expect, &[cond, self.const_bool(expected)], None)\n     }\n \n-    fn va_start(&mut self, list: &'ll Value) -> &'ll Value {\n-        let target = &self.cx.tcx.sess.target.target;\n-        let arch = &target.arch;\n-        // A pointer to the architecture specific structure is passed to this\n-        // function. For pointer variants (i686, RISC-V, Windows, etc), we\n-        // should do do nothing, as the address to the pointer is needed. For\n-        // architectures with a architecture specific structure (`Aarch64`,\n-        // `X86_64`, etc), this function should load the structure from the\n-        // address provided.\n-        let va_list = match &**arch {\n-            _ if target.options.is_like_windows => list,\n-            \"aarch64\" if target.target_os == \"ios\" => list,\n-            \"aarch64\" | \"x86_64\" | \"powerpc\" =>\n-                self.load(list, self.tcx().data_layout.pointer_align.abi),\n-            _ => list,\n-        };\n+    fn va_start(&mut self, va_list: &'ll Value) -> &'ll Value {\n         let intrinsic = self.cx().get_intrinsic(\"llvm.va_start\");\n         self.call(intrinsic, &[va_list], None)\n     }\n \n-    fn va_end(&mut self, list: &'ll Value) -> &'ll Value {\n-        let target = &self.cx.tcx.sess.target.target;\n-        let arch = &target.arch;\n-        // See the comment in `va_start` for the purpose of the following.\n-        let va_list = match &**arch {\n-            _ if target.options.is_like_windows => list,\n-            \"aarch64\" if target.target_os == \"ios\" => list,\n-            \"aarch64\" | \"x86_64\" | \"powerpc\" =>\n-                self.load(list, self.tcx().data_layout.pointer_align.abi),\n-            _ => list,\n-        };\n+    fn va_end(&mut self, va_list: &'ll Value) -> &'ll Value {\n         let intrinsic = self.cx().get_intrinsic(\"llvm.va_end\");\n         self.call(intrinsic, &[va_list], None)\n     }"}, {"sha": "1eb6e9a5283bd2e81ed564c06db4e3b5bd552b51", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -125,7 +125,7 @@ impl ExtraBackendMethods for LlvmCodegenBackend {\n     ) {\n         unsafe { allocator::codegen(tcx, mods, kind) }\n     }\n-    fn compile_codegen_unit<'a, 'tcx: 'a>(&self, tcx: TyCtxt<'tcx>, cgu_name: InternedString) {\n+    fn compile_codegen_unit<'tcx>(&self, tcx: TyCtxt<'tcx>, cgu_name: InternedString) {\n         base::compile_codegen_unit(tcx, cgu_name);\n     }\n     fn target_machine_factory("}, {"sha": "86b0ad761af6aa3b4c0135bf006d759745d718c3", "filename": "src/librustc_codegen_llvm/va_arg.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_llvm%2Fva_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_llvm%2Fva_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fva_arg.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -132,16 +132,6 @@ pub(super) fn emit_va_arg(\n         // For all other architecture/OS combinations fall back to using\n         // the LLVM va_arg instruction.\n         // https://llvm.org/docs/LangRef.html#va-arg-instruction\n-        _ => {\n-            let va_list = if (target.arch == \"aarch64\" ||\n-                              target.arch == \"x86_64\" ||\n-                              target.arch == \"powerpc\") &&\n-                             !target.options.is_like_windows {\n-                bx.load(addr.immediate(), bx.tcx().data_layout.pointer_align.abi)\n-            } else {\n-                addr.immediate()\n-            };\n-            bx.va_arg(va_list, bx.cx.layout_of(target_ty).llvm_type(bx.cx))\n-        }\n+        _ => bx.va_arg(addr.immediate(), bx.cx.layout_of(target_ty).llvm_type(bx.cx))\n     }\n }"}, {"sha": "c8bb2e7ee9965ba5c1eb9475de66c1311c5af991", "filename": "src/librustc_codegen_ssa/README.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2FREADME.md?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -29,11 +29,11 @@ While the LLVM-specific code will be left in `rustc_codegen_llvm`, all the new t\n The two most important structures for the LLVM codegen are `CodegenCx` and `Builder`. They are parametrized by multiple lifetime parameters and the type for `Value`.\n \n ```rust\n-struct CodegenCx<'ll, 'tcx: 'll> {\n+struct CodegenCx<'ll, 'tcx> {\n   /* ... */\n }\n \n-struct Builder<'a, 'll: 'a, 'tcx: 'll> {\n+struct Builder<'a, 'll, 'tcx> {\n   cx: &'a CodegenCx<'ll, 'tcx>,\n   /* ... */\n }\n@@ -49,7 +49,7 @@ The code in `rustc_codegen_llvm` has to deal with multiple explicit lifetime par\n Although there are already many lifetime parameters in the code, making it generic uncovered situations where the borrow-checker was passing only due to the special nature of the LLVM objects manipulated (they are extern pointers). For instance, a additional lifetime parameter had to be added to `LocalAnalyser` in `analyse.rs`, leading to the definition:\n \n ```rust\n-struct LocalAnalyzer<'mir, 'a: 'mir, 'tcx: 'a> {\n+struct LocalAnalyzer<'mir, 'a, 'tcx> {\n   /* ... */\n }\n ```\n@@ -61,7 +61,7 @@ However, the two most important structures `CodegenCx` and `Builder` are not def\n Because they have to be defined by the backend, `CodegenCx` and `Builder` will be the structures implementing all the traits defining the backend's interface. These traits are defined in the folder `rustc_codegen_ssa/traits` and all the backend-agnostic code is parametrized by them. For instance, let us explain how a function in `base.rs` is parametrized:\n \n ```rust\n-pub fn codegen_instance<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+pub fn codegen_instance<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     cx: &'a Bx::CodegenCx,\n     instance: Instance<'tcx>\n ) {\n@@ -74,7 +74,7 @@ In this signature, we have the two lifetime parameters explained earlier and the\n On the trait side, here is an example with part of the definition of `BuilderMethods` in `traits/builder.rs`:\n \n ```rust\n-pub trait BuilderMethods<'a, 'tcx: 'a>:\n+pub trait BuilderMethods<'a, 'tcx>:\n     HasCodegen<'tcx>\n     + DebugInfoBuilderMethods<'tcx>\n     + ArgTypeMethods<'tcx>"}, {"sha": "47b383fddbc31ca9acddcc30ca0888cfbc827dee", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -88,13 +88,13 @@ pub fn bin_op_to_fcmp_predicate(op: hir::BinOpKind) -> RealPredicate {\n     }\n }\n \n-pub fn compare_simd_types<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+pub fn compare_simd_types<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n     lhs: Bx::Value,\n     rhs: Bx::Value,\n     t: Ty<'tcx>,\n     ret_ty: Bx::Type,\n-    op: hir::BinOpKind\n+    op: hir::BinOpKind,\n ) -> Bx::Value {\n     let signed = match t.sty {\n         ty::Float(_) => {\n@@ -152,11 +152,11 @@ pub fn unsized_info<'tcx, Cx: CodegenMethods<'tcx>>(\n }\n \n /// Coerce `src` to `dst_ty`. `src_ty` must be a thin pointer.\n-pub fn unsize_thin_ptr<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+pub fn unsize_thin_ptr<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n     src: Bx::Value,\n     src_ty: Ty<'tcx>,\n-    dst_ty: Ty<'tcx>\n+    dst_ty: Ty<'tcx>,\n ) -> (Bx::Value, Bx::Value) {\n     debug!(\"unsize_thin_ptr: {:?} => {:?}\", src_ty, dst_ty);\n     match (&src_ty.sty, &dst_ty.sty) {\n@@ -207,11 +207,11 @@ pub fn unsize_thin_ptr<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n \n /// Coerce `src`, which is a reference to a value of type `src_ty`,\n /// to a value of type `dst_ty` and store the result in `dst`\n-pub fn coerce_unsized_into<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+pub fn coerce_unsized_into<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n     src: PlaceRef<'tcx, Bx::Value>,\n-    dst: PlaceRef<'tcx, Bx::Value>\n-)  {\n+    dst: PlaceRef<'tcx, Bx::Value>,\n+) {\n     let src_ty = src.layout.ty;\n     let dst_ty = dst.layout.ty;\n     let mut coerce_ptr = || {\n@@ -266,16 +266,16 @@ pub fn coerce_unsized_into<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     }\n }\n \n-pub fn cast_shift_expr_rhs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+pub fn cast_shift_expr_rhs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n     op: hir::BinOpKind,\n     lhs: Bx::Value,\n-    rhs: Bx::Value\n+    rhs: Bx::Value,\n ) -> Bx::Value {\n     cast_shift_rhs(bx, op, lhs, rhs)\n }\n \n-fn cast_shift_rhs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+fn cast_shift_rhs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n     op: hir::BinOpKind,\n     lhs: Bx::Value,\n@@ -316,9 +316,9 @@ pub fn wants_msvc_seh(sess: &Session) -> bool {\n     sess.target.target.options.is_like_msvc\n }\n \n-pub fn from_immediate<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+pub fn from_immediate<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n-    val: Bx::Value\n+    val: Bx::Value,\n ) -> Bx::Value {\n     if bx.cx().val_ty(val) == bx.cx().type_i1() {\n         bx.zext(val, bx.cx().type_i8())\n@@ -327,7 +327,7 @@ pub fn from_immediate<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     }\n }\n \n-pub fn to_immediate<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+pub fn to_immediate<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n     val: Bx::Value,\n     layout: layout::TyLayout<'_>,\n@@ -338,7 +338,7 @@ pub fn to_immediate<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     val\n }\n \n-pub fn to_immediate_scalar<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+pub fn to_immediate_scalar<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n     val: Bx::Value,\n     scalar: &layout::Scalar,\n@@ -349,7 +349,7 @@ pub fn to_immediate_scalar<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     val\n }\n \n-pub fn memcpy_ty<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+pub fn memcpy_ty<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n     dst: Bx::Value,\n     dst_align: Align,\n@@ -387,9 +387,7 @@ pub fn codegen_instance<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n \n /// Creates the `main` function which will initialize the rust runtime and call\n /// users main function.\n-pub fn maybe_create_entry_wrapper<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n-    cx: &'a Bx::CodegenCx\n-) {\n+pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(cx: &'a Bx::CodegenCx) {\n     let (main_def_id, span) = match cx.tcx().entry_fn(LOCAL_CRATE) {\n         Some((def_id, _)) => { (def_id, cx.tcx().def_span(def_id)) },\n         None => return,\n@@ -412,7 +410,7 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n         None => {}    // Do nothing.\n     }\n \n-    fn create_entry_fn<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    fn create_entry_fn<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         cx: &'a Bx::CodegenCx,\n         sp: Span,\n         rust_main: Bx::Value,"}, {"sha": "6376512ca4025e39698ee2058fd6d98344c8de1b", "filename": "src/librustc_codegen_ssa/common.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcommon.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -137,22 +137,22 @@ pub fn langcall(tcx: TyCtxt<'_>, span: Option<Span>, msg: &str, li: LangItem) ->\n // all shifts). For 32- and 64-bit types, this matches the semantics\n // of Java. (See related discussion on #1877 and #10183.)\n \n-pub fn build_unchecked_lshift<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+pub fn build_unchecked_lshift<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n     lhs: Bx::Value,\n-    rhs: Bx::Value\n+    rhs: Bx::Value,\n ) -> Bx::Value {\n     let rhs = base::cast_shift_expr_rhs(bx, hir::BinOpKind::Shl, lhs, rhs);\n     // #1877, #10183: Ensure that input is always valid\n     let rhs = shift_mask_rhs(bx, rhs);\n     bx.shl(lhs, rhs)\n }\n \n-pub fn build_unchecked_rshift<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+pub fn build_unchecked_rshift<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n     lhs_t: Ty<'tcx>,\n     lhs: Bx::Value,\n-    rhs: Bx::Value\n+    rhs: Bx::Value,\n ) -> Bx::Value {\n     let rhs = base::cast_shift_expr_rhs(bx, hir::BinOpKind::Shr, lhs, rhs);\n     // #1877, #10183: Ensure that input is always valid\n@@ -165,20 +165,20 @@ pub fn build_unchecked_rshift<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     }\n }\n \n-fn shift_mask_rhs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+fn shift_mask_rhs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n-    rhs: Bx::Value\n+    rhs: Bx::Value,\n ) -> Bx::Value {\n     let rhs_llty = bx.val_ty(rhs);\n     let shift_val = shift_mask_val(bx, rhs_llty, rhs_llty, false);\n     bx.and(rhs, shift_val)\n }\n \n-pub fn shift_mask_val<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+pub fn shift_mask_val<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n     llty: Bx::Type,\n     mask_llty: Bx::Type,\n-    invert: bool\n+    invert: bool,\n ) -> Bx::Value {\n     let kind = bx.type_kind(llty);\n     match kind {"}, {"sha": "7fd9f67e2f45b6dc5239eaebbe02bb965acde401", "filename": "src/librustc_codegen_ssa/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fglue.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -7,10 +7,10 @@ use crate::common::IntPredicate;\n use crate::meth;\n use crate::traits::*;\n \n-pub fn size_and_align_of_dst<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+pub fn size_and_align_of_dst<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n     t: Ty<'tcx>,\n-    info: Option<Bx::Value>\n+    info: Option<Bx::Value>,\n ) -> (Bx::Value, Bx::Value) {\n     let layout = bx.layout_of(t);\n     debug!(\"size_and_align_of_dst(ty={}, info={:?}): layout: {:?}\","}, {"sha": "7fe9f5f25130a90d2b46270380326f6f37226c0b", "filename": "src/librustc_codegen_ssa/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmeth.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -12,7 +12,7 @@ pub const DESTRUCTOR: VirtualIndex = VirtualIndex(0);\n pub const SIZE: VirtualIndex = VirtualIndex(1);\n pub const ALIGN: VirtualIndex = VirtualIndex(2);\n \n-impl<'a, 'tcx: 'a> VirtualIndex {\n+impl<'a, 'tcx> VirtualIndex {\n     pub fn from_index(index: usize) -> Self {\n         VirtualIndex(index as u64 + 3)\n     }"}, {"sha": "0289150a5e42a40305175859c3cf9762cfc67b6c", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -12,8 +12,8 @@ use rustc::ty::layout::{LayoutOf, HasTyCtxt};\n use super::FunctionCx;\n use crate::traits::*;\n \n-pub fn non_ssa_locals<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n-    fx: &FunctionCx<'a, 'tcx, Bx>\n+pub fn non_ssa_locals<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n+    fx: &FunctionCx<'a, 'tcx, Bx>,\n ) -> BitSet<mir::Local> {\n     let mir = fx.mir;\n     let mut analyzer = LocalAnalyzer::new(fx);\n@@ -43,13 +43,13 @@ pub fn non_ssa_locals<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     analyzer.non_ssa_locals\n }\n \n-struct LocalAnalyzer<'mir, 'a: 'mir, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> {\n+struct LocalAnalyzer<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n     fx: &'mir FunctionCx<'a, 'tcx, Bx>,\n     dominators: Dominators<mir::BasicBlock>,\n     non_ssa_locals: BitSet<mir::Local>,\n     // The location of the first visited direct assignment to each\n     // local, or an invalid location (out of bounds `block` index).\n-    first_assignment: IndexVec<mir::Local, Location>\n+    first_assignment: IndexVec<mir::Local, Location>,\n }\n \n impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n@@ -94,8 +94,9 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n     }\n }\n \n-impl<'mir, 'a: 'mir, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n-    for LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n+impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n+    for LocalAnalyzer<'mir, 'a, 'tcx, Bx>\n+{\n     fn visit_assign(&mut self,\n                     place: &mir::Place<'tcx>,\n                     rvalue: &mir::Rvalue<'tcx>,"}, {"sha": "941166ccfab091360e171d958544d269ecb9f8fc", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -151,7 +151,7 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'a, 'tcx> {\n }\n \n /// Codegen implementations for some terminator variants.\n-impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n+impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     /// Generates code for a `Resume` terminator.\n     fn codegen_resume_terminator<'b>(\n         &mut self,\n@@ -503,7 +503,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             return;\n         }\n \n-        // The \"spoofed\" `VaList` added to a C-variadic functions signature\n+        // The \"spoofed\" `VaListImpl` added to a C-variadic functions signature\n         // should not be included in the `extra_args` calculation.\n         let extra_args_start_idx = sig.inputs().len() - if sig.c_variadic { 1 } else { 0 };\n         let extra_args = &args[extra_args_start_idx..];\n@@ -687,15 +687,15 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             (&args[..], None)\n         };\n \n-        // Useful determining if the current argument is the \"spoofed\" `VaList`\n+        // Useful determining if the current argument is the \"spoofed\" `VaListImpl`\n         let last_arg_idx = if sig.inputs().is_empty() {\n             None\n         } else {\n             Some(sig.inputs().len() - 1)\n         };\n         'make_args: for (i, arg) in first_args.iter().enumerate() {\n             // If this is a C-variadic function the function signature contains\n-            // an \"spoofed\" `VaList`. This argument is ignored, but we need to\n+            // an \"spoofed\" `VaListImpl`. This argument is ignored, but we need to\n             // populate it with a dummy operand so that the users real arguments\n             // are not overwritten.\n             let i = if sig.c_variadic && last_arg_idx.map(|x| i >= x).unwrap_or(false) {\n@@ -788,7 +788,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     }\n }\n \n-impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n+impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn codegen_block(\n         &mut self,\n         bb: mir::BasicBlock,"}, {"sha": "d6951b923bf7d3c4ef4090e36fd707958b42a7d1", "filename": "src/librustc_codegen_ssa/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -8,7 +8,7 @@ use crate::traits::*;\n \n use super::FunctionCx;\n \n-impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n+impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn eval_mir_constant(\n         &mut self,\n         constant: &mir::Constant<'tcx>,"}, {"sha": "e7517d6999195cfdda61b0544725cd417b21cd60", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 23, "deletions": 33, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -23,7 +23,7 @@ use rustc::mir::traversal;\n use self::operand::{OperandRef, OperandValue};\n \n /// Master context for codegenning from MIR.\n-pub struct FunctionCx<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> {\n+pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n     instance: Instance<'tcx>,\n \n     mir: &'a mir::Body<'tcx>,\n@@ -43,7 +43,7 @@ pub struct FunctionCx<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> {\n     /// don't really care about it very much. Anyway, this value\n     /// contains an alloca into which the personality is stored and\n     /// then later loaded when generating the DIVERGE_BLOCK.\n-    personality_slot: Option<PlaceRef<'tcx, Bx::Value,>>,\n+    personality_slot: Option<PlaceRef<'tcx, Bx::Value>>,\n \n     /// A `Block` for each MIR `BasicBlock`\n     blocks: IndexVec<mir::BasicBlock, Bx::BasicBlock>,\n@@ -83,11 +83,11 @@ pub struct FunctionCx<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> {\n     scopes: IndexVec<mir::SourceScope, debuginfo::MirDebugScope<Bx::DIScope>>,\n \n     /// If this function is a C-variadic function, this contains the `PlaceRef` of the\n-    /// \"spoofed\" `VaList`.\n+    /// \"spoofed\" `VaListImpl`.\n     va_list_ref: Option<PlaceRef<'tcx, Bx::Value>>,\n }\n \n-impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n+impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn monomorphize<T>(&self, value: &T) -> T\n         where T: TypeFoldable<'tcx>\n     {\n@@ -167,7 +167,7 @@ enum LocalRef<'tcx, V> {\n     Operand(Option<OperandRef<'tcx, V>>),\n }\n \n-impl<'a, 'tcx: 'a, V: CodegenObject> LocalRef<'tcx, V> {\n+impl<'a, 'tcx, V: CodegenObject> LocalRef<'tcx, V> {\n     fn new_operand<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         bx: &mut Bx,\n         layout: TyLayout<'tcx>,\n@@ -185,7 +185,7 @@ impl<'a, 'tcx: 'a, V: CodegenObject> LocalRef<'tcx, V> {\n \n ///////////////////////////////////////////////////////////////////////////\n \n-pub fn codegen_mir<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     cx: &'a Bx::CodegenCx,\n     llfn: Bx::Value,\n     mir: &'a Body<'tcx>,\n@@ -351,14 +351,15 @@ pub fn codegen_mir<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     }\n }\n \n-fn create_funclets<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+fn create_funclets<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     mir: &'a Body<'tcx>,\n     bx: &mut Bx,\n     cleanup_kinds: &IndexVec<mir::BasicBlock, CleanupKind>,\n-    block_bxs: &IndexVec<mir::BasicBlock, Bx::BasicBlock>)\n-    -> (IndexVec<mir::BasicBlock, Option<Bx::BasicBlock>>,\n-        IndexVec<mir::BasicBlock, Option<Bx::Funclet>>)\n-{\n+    block_bxs: &IndexVec<mir::BasicBlock, Bx::BasicBlock>,\n+) -> (\n+    IndexVec<mir::BasicBlock, Option<Bx::BasicBlock>>,\n+    IndexVec<mir::BasicBlock, Option<Bx::Funclet>>,\n+) {\n     block_bxs.iter_enumerated().zip(cleanup_kinds).map(|((bb, &llbb), cleanup_kind)| {\n         match *cleanup_kind {\n             CleanupKind::Funclet if base::wants_msvc_seh(bx.sess()) => {}\n@@ -420,7 +421,7 @@ fn create_funclets<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n /// Produces, for each argument, a `Value` pointing at the\n /// argument's value. As arguments are places, these are always\n /// indirect.\n-fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n     fx: &FunctionCx<'a, 'tcx, Bx>,\n     memory_locals: &BitSet<mir::Local>,\n@@ -561,35 +562,24 @@ fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n             indirect_operand.store(bx, tmp);\n             tmp\n         } else {\n+            let tmp = PlaceRef::alloca(bx, arg.layout, &name);\n             if fx.fn_ty.c_variadic && last_arg_idx.map(|idx| arg_index == idx).unwrap_or(false) {\n-                let va_list_impl = match arg_decl.ty.ty_adt_def() {\n-                    Some(adt) => adt.non_enum_variant(),\n-                    None => bug!(\"`va_list` language item improperly constructed\")\n+                let va_list_did = match tcx.lang_items().va_list() {\n+                    Some(did) => did,\n+                    None => bug!(\"`va_list` lang item required for C-variadic functions\"),\n                 };\n-                match tcx.type_of(va_list_impl.fields[0].did).sty {\n-                    ty::Ref(_, ty, _) => {\n-                        // If the underlying structure the `VaList` contains is a structure,\n-                        // we need to allocate it (e.g., X86_64 on Linux).\n-                        let tmp = PlaceRef::alloca(bx, arg.layout, &name);\n-                        if let ty::Adt(..) = ty.sty {\n-                            let layout = bx.layout_of(ty);\n-                            // Create an unnamed allocation for the backing structure\n-                            // and store it in the the spoofed `VaList`.\n-                            let backing = PlaceRef::alloca(bx, layout, \"\");\n-                            bx.store(backing.llval, tmp.llval, layout.align.abi);\n-                        }\n-                        // Call `va_start` on the spoofed `VaList`.\n+                match arg_decl.ty.sty {\n+                    ty::Adt(def, _) if def.did == va_list_did => {\n+                        // Call `va_start` on the spoofed `VaListImpl`.\n                         bx.va_start(tmp.llval);\n                         *va_list_ref = Some(tmp);\n-                        tmp\n-                    }\n-                    _ => bug!(\"improperly constructed `va_list` lang item\"),\n+                    },\n+                    _ => bug!(\"last argument of variadic function is not a `va_list`\")\n                 }\n             } else {\n-                let tmp = PlaceRef::alloca(bx, arg.layout, &name);\n                 bx.store_fn_arg(arg, &mut llarg_idx, tmp);\n-                tmp\n             }\n+            tmp\n         };\n         let upvar_debuginfo = &mir.__upvar_debuginfo_codegen_only_do_not_use;\n         arg_scope.map(|scope| {"}, {"sha": "c1626d31c780182f5adba6de03e9177e902cfd03", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -53,7 +53,7 @@ impl<V: CodegenObject> fmt::Debug for OperandRef<'tcx, V> {\n     }\n }\n \n-impl<'a, 'tcx: 'a, V: CodegenObject> OperandRef<'tcx, V> {\n+impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n     pub fn new_zst<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         bx: &mut Bx,\n         layout: TyLayout<'tcx>\n@@ -109,8 +109,8 @@ impl<'a, 'tcx: 'a, V: CodegenObject> OperandRef<'tcx, V> {\n                 let b_llval = bx.const_usize((end - start) as u64);\n                 OperandValue::Pair(a_llval, b_llval)\n             },\n-            ConstValue::ByRef(ptr, alloc) => {\n-                return bx.load_operand(bx.from_const_alloc(layout, alloc, ptr.offset));\n+            ConstValue::ByRef(ptr, align, alloc) => {\n+                return bx.load_operand(bx.from_const_alloc(layout, align, alloc, ptr.offset));\n             },\n         };\n \n@@ -266,7 +266,7 @@ impl<'a, 'tcx: 'a, V: CodegenObject> OperandRef<'tcx, V> {\n     }\n }\n \n-impl<'a, 'tcx: 'a, V: CodegenObject> OperandValue<V> {\n+impl<'a, 'tcx, V: CodegenObject> OperandValue<V> {\n     pub fn store<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         self,\n         bx: &mut Bx,\n@@ -376,7 +376,7 @@ impl<'a, 'tcx: 'a, V: CodegenObject> OperandValue<V> {\n     }\n }\n \n-impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n+impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     fn maybe_codegen_consume_direct(\n         &mut self,\n         bx: &mut Bx,"}, {"sha": "72aedb4812a21f4e18a91acfd1c6b41e8eaca449", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -26,7 +26,7 @@ pub struct PlaceRef<'tcx, V> {\n     pub align: Align,\n }\n \n-impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n+impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n     pub fn new_sized(\n         llval: V,\n         layout: TyLayout<'tcx>,\n@@ -98,7 +98,7 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n \n }\n \n-impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n+impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n     /// Access a field, at a point when the value's case is known.\n     pub fn project_field<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         self, bx: &mut Bx,\n@@ -386,7 +386,7 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n     }\n }\n \n-impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n+impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn codegen_place(\n         &mut self,\n         bx: &mut Bx,\n@@ -424,8 +424,8 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let layout = cx.layout_of(self.monomorphize(&ty));\n                 match bx.tcx().const_eval(param_env.and(cid)) {\n                     Ok(val) => match val.val {\n-                        mir::interpret::ConstValue::ByRef(ptr, alloc) => {\n-                            bx.cx().from_const_alloc(layout, alloc, ptr.offset)\n+                        mir::interpret::ConstValue::ByRef(ptr, align, alloc) => {\n+                            bx.cx().from_const_alloc(layout, align, alloc, ptr.offset)\n                         }\n                         _ => bug!(\"promoteds should have an allocation: {:?}\", val),\n                     },"}, {"sha": "4a1971e3e2ee01c99816de888027585ce4269c12", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -18,7 +18,7 @@ use super::{FunctionCx, LocalRef};\n use super::operand::{OperandRef, OperandValue};\n use super::place::PlaceRef;\n \n-impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n+impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn codegen_rvalue(\n         &mut self,\n         mut bx: Bx,\n@@ -687,7 +687,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     }\n }\n \n-impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n+impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn rvalue_creates_operand(&self, rvalue: &mir::Rvalue<'tcx>) -> bool {\n         match *rvalue {\n             mir::Rvalue::Ref(..) |\n@@ -712,7 +712,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     }\n }\n \n-fn cast_int_to_float<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+fn cast_int_to_float<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n     signed: bool,\n     x: Bx::Value,\n@@ -746,7 +746,7 @@ fn cast_int_to_float<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     }\n }\n \n-fn cast_float_to_int<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+fn cast_float_to_int<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n     signed: bool,\n     x: Bx::Value,"}, {"sha": "750b2f5b1a50f13159d30c11512172ecee5b9cda", "filename": "src/librustc_codegen_ssa/mir/statement.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -6,7 +6,7 @@ use super::LocalRef;\n use super::OperandValue;\n use crate::traits::*;\n \n-impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n+impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn codegen_statement(\n         &mut self,\n         mut bx: Bx,"}, {"sha": "4446f1a3a5ce2b28bb09e39132e38c46f168236b", "filename": "src/librustc_codegen_ssa/mono_item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmono_item.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -6,7 +6,7 @@ use crate::traits::*;\n \n use rustc::mir::mono::MonoItem;\n \n-pub trait MonoItemExt<'a, 'tcx: 'a> {\n+pub trait MonoItemExt<'a, 'tcx> {\n     fn define<Bx: BuilderMethods<'a, 'tcx>>(&self, cx: &'a Bx::CodegenCx);\n     fn predefine<Bx: BuilderMethods<'a, 'tcx>>(\n         &self,\n@@ -29,7 +29,7 @@ impl<'a, 'tcx: 'a> MonoItemExt<'a, 'tcx> for MonoItem<'tcx> {\n                 cx.codegen_static(def_id, cx.tcx().is_mutable_static(def_id));\n             }\n             MonoItem::GlobalAsm(hir_id) => {\n-                let item = cx.tcx().hir().expect_item_by_hir_id(hir_id);\n+                let item = cx.tcx().hir().expect_item(hir_id);\n                 if let hir::ItemKind::GlobalAsm(ref ga) = item.node {\n                     cx.codegen_global_asm(ga);\n                 } else {"}, {"sha": "414871be6116eeabc7259be6b90e6b0b5e6d6b12", "filename": "src/librustc_codegen_ssa/traits/backend.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -44,7 +44,7 @@ pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Se\n         mods: &mut Self::Module,\n         kind: AllocatorKind,\n     );\n-    fn compile_codegen_unit<'a, 'tcx: 'a>(&self, tcx: TyCtxt<'tcx>, cgu_name: InternedString);\n+    fn compile_codegen_unit<'tcx>(&self, tcx: TyCtxt<'tcx>, cgu_name: InternedString);\n     // If find_features is true this won't access `sess.crate_types` by assuming\n     // that `is_pie_binary` is false. When we discover LLVM target features\n     // `sess.crate_types` is uninitialized so we cannot access it."}, {"sha": "1c80e614db8d5b710f519bc2261dcc4c69e625bd", "filename": "src/librustc_codegen_ssa/traits/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -22,7 +22,7 @@ pub enum OverflowOp {\n     Mul,\n }\n \n-pub trait BuilderMethods<'a, 'tcx: 'a>:\n+pub trait BuilderMethods<'a, 'tcx>:\n     HasCodegen<'tcx>\n     + DebugInfoBuilderMethods<'tcx>\n     + ArgTypeMethods<'tcx>"}, {"sha": "46286b5329e435d138698698871fe158c006de45", "filename": "src/librustc_codegen_ssa/traits/consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -34,6 +34,7 @@ pub trait ConstMethods<'tcx>: BackendTypes {\n     fn from_const_alloc(\n         &self,\n         layout: layout::TyLayout<'tcx>,\n+        align: layout::Align,\n         alloc: &Allocation,\n         offset: layout::Size,\n     ) -> PlaceRef<'tcx, Self::Value>;"}, {"sha": "ede30a0bed756d2c29e7d93be495a9904ccc8e94", "filename": "src/librustc_codegen_ssa/traits/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -20,10 +20,10 @@ pub trait IntrinsicCallMethods<'tcx>: BackendTypes {\n     fn abort(&mut self);\n     fn assume(&mut self, val: Self::Value);\n     fn expect(&mut self, cond: Self::Value, expected: bool) -> Self::Value;\n-    /// Trait method used to inject `va_start` on the \"spoofed\" `VaList` in\n+    /// Trait method used to inject `va_start` on the \"spoofed\" `VaListImpl` in\n     /// Rust defined C-variadic functions.\n     fn va_start(&mut self, val: Self::Value) -> Self::Value;\n-    /// Trait method used to inject `va_end` on the \"spoofed\" `VaList` before\n+    /// Trait method used to inject `va_end` on the \"spoofed\" `VaListImpl` before\n     /// Rust defined C-variadic functions return.\n     fn va_end(&mut self, val: Self::Value) -> Self::Value;\n }"}, {"sha": "eb89b5c1e63709e14483fb0753393ed407c05136", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -453,7 +453,7 @@ impl<'a> pprust::PpAnn for HygieneAnnotation<'a> {\n     }\n }\n \n-struct TypedAnnotation<'a, 'tcx: 'a> {\n+struct TypedAnnotation<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     tables: Cell<&'a ty::TypeckTables<'tcx>>,\n }\n@@ -922,7 +922,8 @@ fn print_with_analysis<'tcx>(\n                                             got {:?}\",\n                                             node);\n \n-                    tcx.sess.span_fatal(tcx.hir().span(nodeid), &message)\n+                    let hir_id = tcx.hir().node_to_hir_id(nodeid);\n+                    tcx.sess.span_fatal(tcx.hir().span(hir_id), &message)\n                 }\n             }\n         }"}, {"sha": "25a27d2cbd884d953c3e28e64c7f043d2db5e519", "filename": "src/librustc_errors/lock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_errors%2Flock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_errors%2Flock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flock.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -64,7 +64,7 @@ pub fn acquire_global_lock(name: &str) -> Box<dyn Any> {\n         //\n         // This will silently create one if it doesn't already exist, or it'll\n         // open up a handle to one if it already exists.\n-        let mutex = CreateMutexA(0 as *mut _, 0, cname.as_ptr() as *const u8);\n+        let mutex = CreateMutexA(std::ptr::null_mut(), 0, cname.as_ptr() as *const u8);\n         if mutex.is_null() {\n             panic!(\"failed to create global mutex named `{}`: {}\",\n                    name,"}, {"sha": "1a4b12b03d8317716ed2e453e27545a4f68e7e82", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 212, "deletions": 102, "changes": 314, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -23,7 +23,7 @@\n \n use rustc::hir::def::{Res, DefKind};\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc::ty::{self, Ty};\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc::{lint, util};\n use hir::Node;\n use util::nodemap::HirIdSet;\n@@ -1088,7 +1088,7 @@ impl TypeAliasBounds {\n \n         // We use a HIR visitor to walk the type.\n         use rustc::hir::intravisit::{self, Visitor};\n-        struct WalkAssocTypes<'a, 'db> where 'db: 'a {\n+        struct WalkAssocTypes<'a, 'db> {\n             err: &'a mut DiagnosticBuilder<'db>\n         }\n         impl<'a, 'db, 'v> Visitor<'v> for WalkAssocTypes<'a, 'db> {\n@@ -1494,58 +1494,107 @@ impl EarlyLintPass for KeywordIdents {\n declare_lint_pass!(ExplicitOutlivesRequirements => [EXPLICIT_OUTLIVES_REQUIREMENTS]);\n \n impl ExplicitOutlivesRequirements {\n-    fn collect_outlives_bound_spans(\n-        &self,\n-        cx: &LateContext<'_, '_>,\n-        item_def_id: DefId,\n-        param_name: &str,\n-        bounds: &hir::GenericBounds,\n-        infer_static: bool\n-    ) -> Vec<(usize, Span)> {\n-        // For lack of a more elegant strategy for comparing the `ty::Predicate`s\n-        // returned by this query with the params/bounds grabbed from the HIR\u2014and\n-        // with some regrets\u2014we're going to covert the param/lifetime names to\n-        // strings\n-        let inferred_outlives = cx.tcx.inferred_outlives_of(item_def_id);\n-\n-        let ty_lt_names = inferred_outlives.iter().filter_map(|pred| {\n-            let binder = match pred {\n-                ty::Predicate::TypeOutlives(binder) => binder,\n-                _ => { return None; }\n-            };\n-            let ty_outlives_pred = binder.skip_binder();\n-            let ty_name = match ty_outlives_pred.0.sty {\n-                ty::Param(param) => param.name.to_string(),\n-                _ => { return None; }\n-            };\n-            let lt_name = match ty_outlives_pred.1 {\n-                ty::RegionKind::ReEarlyBound(region) => {\n-                    region.name.to_string()\n-                },\n-                _ => { return None; }\n-            };\n-            Some((ty_name, lt_name))\n-        }).collect::<Vec<_>>();\n-\n-        let mut bound_spans = Vec::new();\n-        for (i, bound) in bounds.iter().enumerate() {\n-            if let hir::GenericBound::Outlives(lifetime) = bound {\n-                let is_static = match lifetime.name {\n-                    hir::LifetimeName::Static => true,\n-                    _ => false\n-                };\n-                if is_static && !infer_static {\n-                    // infer-outlives for 'static is still feature-gated (tracking issue #44493)\n-                    continue;\n+    fn lifetimes_outliving_lifetime<'tcx>(\n+        inferred_outlives: &'tcx [ty::Predicate<'tcx>],\n+        index: u32,\n+    ) -> Vec<ty::Region<'tcx>> {\n+        inferred_outlives.iter().filter_map(|pred| {\n+            match pred {\n+                ty::Predicate::RegionOutlives(outlives) => {\n+                    let outlives = outlives.skip_binder();\n+                    match outlives.0 {\n+                        ty::ReEarlyBound(ebr) if ebr.index == index => {\n+                            Some(outlives.1)\n+                        }\n+                        _ => None,\n+                    }\n                 }\n+                _ => None\n+            }\n+        }).collect()\n+    }\n \n-                let lt_name = &lifetime.name.ident().to_string();\n-                if ty_lt_names.contains(&(param_name.to_owned(), lt_name.to_owned())) {\n-                    bound_spans.push((i, bound.span()));\n+    fn lifetimes_outliving_type<'tcx>(\n+        inferred_outlives: &'tcx [ty::Predicate<'tcx>],\n+        index: u32,\n+    ) -> Vec<ty::Region<'tcx>> {\n+        inferred_outlives.iter().filter_map(|pred| {\n+            match pred {\n+                ty::Predicate::TypeOutlives(outlives) => {\n+                    let outlives = outlives.skip_binder();\n+                    if outlives.0.is_param(index) {\n+                        Some(outlives.1)\n+                    } else {\n+                        None\n+                    }\n                 }\n+                _ => None\n+            }\n+        }).collect()\n+    }\n+\n+    fn collect_outlived_lifetimes<'tcx>(\n+        &self,\n+        param: &'tcx hir::GenericParam,\n+        tcx: TyCtxt<'tcx>,\n+        inferred_outlives: &'tcx [ty::Predicate<'tcx>],\n+        ty_generics: &'tcx ty::Generics,\n+    ) -> Vec<ty::Region<'tcx>> {\n+        let index = ty_generics.param_def_id_to_index[\n+            &tcx.hir().local_def_id_from_hir_id(param.hir_id)];\n+\n+        match param.kind {\n+            hir::GenericParamKind::Lifetime { .. } => {\n+                Self::lifetimes_outliving_lifetime(inferred_outlives, index)\n+            }\n+            hir::GenericParamKind::Type { .. } => {\n+                Self::lifetimes_outliving_type(inferred_outlives, index)\n             }\n+            hir::GenericParamKind::Const { .. } => Vec::new(),\n         }\n-        bound_spans\n+    }\n+\n+\n+    fn collect_outlives_bound_spans<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        bounds: &hir::GenericBounds,\n+        inferred_outlives: &[ty::Region<'tcx>],\n+        infer_static: bool,\n+    ) -> Vec<(usize, Span)> {\n+        use rustc::middle::resolve_lifetime::Region;\n+\n+        bounds\n+            .iter()\n+            .enumerate()\n+            .filter_map(|(i, bound)| {\n+                if let hir::GenericBound::Outlives(lifetime) = bound {\n+                    let is_inferred = match tcx.named_region(lifetime.hir_id) {\n+                        Some(Region::Static) if infer_static => {\n+                            inferred_outlives.iter()\n+                                .any(|r| if let ty::ReStatic = r { true } else { false })\n+                        }\n+                        Some(Region::EarlyBound(index, ..)) => inferred_outlives\n+                            .iter()\n+                            .any(|r| {\n+                                if let ty::ReEarlyBound(ebr) = r {\n+                                    ebr.index == index\n+                                } else {\n+                                    false\n+                                }\n+                            }),\n+                        _ => false,\n+                    };\n+                    if is_inferred {\n+                        Some((i, bound.span()))\n+                    } else {\n+                        None\n+                    }\n+                } else {\n+                    None\n+                }\n+            })\n+            .collect()\n     }\n \n     fn consolidate_outlives_bound_spans(\n@@ -1569,7 +1618,7 @@ impl ExplicitOutlivesRequirements {\n             let mut from_start = true;\n             for (i, bound_span) in bound_spans {\n                 match last_merged_i {\n-                    // If the first bound is inferable, our span should also eat the trailing `+`\n+                    // If the first bound is inferable, our span should also eat the leading `+`.\n                     None if i == 0 => {\n                         merged.push(bound_span.to(bounds[1].span().shrink_to_lo()));\n                         last_merged_i = Some(0);\n@@ -1607,26 +1656,48 @@ impl ExplicitOutlivesRequirements {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExplicitOutlivesRequirements {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item) {\n+        use rustc::middle::resolve_lifetime::Region;\n+\n         let infer_static = cx.tcx.features().infer_static_outlives_requirements;\n         let def_id = cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n-        if let hir::ItemKind::Struct(_, ref generics) = item.node {\n+        if let hir::ItemKind::Struct(_, ref hir_generics)\n+            | hir::ItemKind::Enum(_, ref hir_generics)\n+            | hir::ItemKind::Union(_, ref hir_generics) = item.node\n+        {\n+            let inferred_outlives = cx.tcx.inferred_outlives_of(def_id);\n+            if inferred_outlives.is_empty() {\n+                return;\n+            }\n+\n+            let ty_generics = cx.tcx.generics_of(def_id);\n+\n             let mut bound_count = 0;\n             let mut lint_spans = Vec::new();\n \n-            for param in &generics.params {\n-                let param_name = match param.kind {\n-                    hir::GenericParamKind::Lifetime { .. } => continue,\n-                    hir::GenericParamKind::Type { .. } => {\n-                        match param.name {\n-                            hir::ParamName::Fresh(_) => continue,\n-                            hir::ParamName::Error => continue,\n-                            hir::ParamName::Plain(name) => name.to_string(),\n-                        }\n+            for param in &hir_generics.params {\n+                let has_lifetime_bounds = param.bounds.iter().any(|bound| {\n+                    if let hir::GenericBound::Outlives(_) = bound {\n+                        true\n+                    } else {\n+                        false\n                     }\n-                    hir::GenericParamKind::Const { .. } => continue,\n-                };\n+                });\n+                if !has_lifetime_bounds {\n+                    continue;\n+                }\n+\n+                let relevant_lifetimes = self.collect_outlived_lifetimes(\n+                    param,\n+                    cx.tcx,\n+                    inferred_outlives,\n+                    ty_generics,\n+                );\n+                if relevant_lifetimes.is_empty() {\n+                    continue;\n+                }\n+\n                 let bound_spans = self.collect_outlives_bound_spans(\n-                    cx, def_id, &param_name, &param.bounds, infer_static\n+                    cx.tcx, &param.bounds, &relevant_lifetimes, infer_static,\n                 );\n                 bound_count += bound_spans.len();\n                 lint_spans.extend(\n@@ -1638,54 +1709,93 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExplicitOutlivesRequirements {\n \n             let mut where_lint_spans = Vec::new();\n             let mut dropped_predicate_count = 0;\n-            let num_predicates = generics.where_clause.predicates.len();\n-            for (i, where_predicate) in generics.where_clause.predicates.iter().enumerate() {\n-                if let hir::WherePredicate::BoundPredicate(predicate) = where_predicate {\n-                    let param_name = match predicate.bounded_ty.node {\n-                        hir::TyKind::Path(ref qpath) => {\n-                            if let hir::QPath::Resolved(None, ty_param_path) = qpath {\n-                                ty_param_path.segments[0].ident.to_string()\n-                            } else {\n-                                continue;\n-                            }\n-                        },\n-                        _ => { continue; }\n-                    };\n-                    let bound_spans = self.collect_outlives_bound_spans(\n-                        cx, def_id, &param_name, &predicate.bounds, infer_static\n-                    );\n-                    bound_count += bound_spans.len();\n-\n-                    let drop_predicate = bound_spans.len() == predicate.bounds.len();\n-                    if drop_predicate {\n-                        dropped_predicate_count += 1;\n-                    }\n-\n-                    // If all the bounds on a predicate were inferable and there are\n-                    // further predicates, we want to eat the trailing comma\n-                    if drop_predicate && i + 1 < num_predicates {\n-                        let next_predicate_span = generics.where_clause.predicates[i+1].span();\n-                        where_lint_spans.push(\n-                            predicate.span.to(next_predicate_span.shrink_to_lo())\n-                        );\n-                    } else {\n-                        where_lint_spans.extend(\n-                            self.consolidate_outlives_bound_spans(\n-                                predicate.span.shrink_to_lo(),\n+            let num_predicates = hir_generics.where_clause.predicates.len();\n+            for (i, where_predicate) in hir_generics.where_clause.predicates.iter().enumerate() {\n+                let (relevant_lifetimes, bounds, span) = match where_predicate {\n+                    hir::WherePredicate::RegionPredicate(predicate) => {\n+                        if let Some(Region::EarlyBound(index, ..))\n+                            = cx.tcx.named_region(predicate.lifetime.hir_id)\n+                        {\n+                            (\n+                                Self::lifetimes_outliving_lifetime(inferred_outlives, index),\n                                 &predicate.bounds,\n-                                bound_spans\n+                                predicate.span,\n                             )\n-                        );\n+                        } else {\n+                            continue;\n+                        }\n+                    }\n+                    hir::WherePredicate::BoundPredicate(predicate) => {\n+                        // FIXME we can also infer bounds on associated types,\n+                        // and should check for them here.\n+                        match predicate.bounded_ty.node {\n+                            hir::TyKind::Path(hir::QPath::Resolved(\n+                                None,\n+                                ref path,\n+                            )) => {\n+                                if let Res::Def(DefKind::TyParam, def_id) = path.res {\n+                                    let index = ty_generics.param_def_id_to_index[&def_id];\n+                                    (\n+                                        Self::lifetimes_outliving_type(inferred_outlives, index),\n+                                        &predicate.bounds,\n+                                        predicate.span,\n+                                    )\n+                                } else {\n+                                    continue;\n+                                }\n+                            },\n+                            _ => { continue; }\n+                        }\n                     }\n+                    _ => continue,\n+                };\n+                if relevant_lifetimes.is_empty() {\n+                    continue;\n+                }\n+\n+                let bound_spans = self.collect_outlives_bound_spans(\n+                    cx.tcx, bounds, &relevant_lifetimes, infer_static,\n+                );\n+                bound_count += bound_spans.len();\n+\n+                let drop_predicate = bound_spans.len() == bounds.len();\n+                if drop_predicate {\n+                    dropped_predicate_count += 1;\n+                }\n+\n+                // If all the bounds on a predicate were inferable and there are\n+                // further predicates, we want to eat the trailing comma.\n+                if drop_predicate && i + 1 < num_predicates {\n+                    let next_predicate_span = hir_generics.where_clause.predicates[i + 1].span();\n+                    where_lint_spans.push(\n+                        span.to(next_predicate_span.shrink_to_lo())\n+                    );\n+                } else {\n+                    where_lint_spans.extend(\n+                        self.consolidate_outlives_bound_spans(\n+                            span.shrink_to_lo(),\n+                            bounds,\n+                            bound_spans\n+                        )\n+                    );\n                 }\n             }\n \n             // If all predicates are inferable, drop the entire clause\n             // (including the `where`)\n             if num_predicates > 0 && dropped_predicate_count == num_predicates {\n-                let full_where_span = generics.span.shrink_to_hi()\n-                    .to(generics.where_clause.span()\n-                    .expect(\"span of (nonempty) where clause should exist\"));\n+                let where_span = hir_generics.where_clause.span()\n+                    .expect(\"span of (nonempty) where clause should exist\");\n+                // Extend the where clause back to the closing `>` of the\n+                // generics, except for tuple struct, which have the `where`\n+                // after the fields of the struct.\n+                let full_where_span = if let hir::ItemKind::Struct(hir::VariantData::Tuple(..), _)\n+                        = item.node\n+                {\n+                    where_span\n+                } else {\n+                    hir_generics.span.shrink_to_hi().to(where_span)\n+                };\n                 lint_spans.push(\n                     full_where_span\n                 );"}, {"sha": "b221b8ed30c59dc8c2a314636e4ad29fc501b6c4", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -254,7 +254,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n         let crate_ident = if let Some(name) = &cx.tcx.sess.opts.crate_name {\n             Some(Ident::from_str(name))\n         } else {\n-            attr::find_by_name(&cx.tcx.hir().attrs_by_hir_id(hir::CRATE_HIR_ID), sym::crate_name)\n+            attr::find_by_name(&cx.tcx.hir().attrs(hir::CRATE_HIR_ID), sym::crate_name)\n                 .and_then(|attr| attr.meta())\n                 .and_then(|meta| {\n                     meta.name_value_literal().and_then(|lit| {"}, {"sha": "5f052f65333bb4c8fd6a53d86c8b5aa43141dfa3", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -505,7 +505,7 @@ declare_lint! {\n \n declare_lint_pass!(ImproperCTypes => [IMPROPER_CTYPES]);\n \n-struct ImproperCTypesVisitor<'a, 'tcx: 'a> {\n+struct ImproperCTypesVisitor<'a, 'tcx> {\n     cx: &'a LateContext<'a, 'tcx>,\n }\n \n@@ -892,7 +892,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         let sig = self.cx.tcx.fn_sig(def_id);\n         let sig = self.cx.tcx.erase_late_bound_regions(&sig);\n         let inputs = if sig.c_variadic {\n-            // Don't include the spoofed `VaList` in the functions list\n+            // Don't include the spoofed `VaListImpl` in the functions list\n             // of inputs.\n             &sig.inputs()[..sig.inputs().len() - 1]\n         } else {\n@@ -921,7 +921,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImproperCTypes {\n     fn check_foreign_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::ForeignItem) {\n         let mut vis = ImproperCTypesVisitor { cx };\n-        let abi = cx.tcx.hir().get_foreign_abi_by_hir_id(it.hir_id);\n+        let abi = cx.tcx.hir().get_foreign_abi(it.hir_id);\n         if abi != Abi::RustIntrinsic && abi != Abi::PlatformIntrinsic {\n             match it.node {\n                 hir::ForeignItemKind::Fn(ref decl, _, _) => {"}, {"sha": "f84ce2f015edf3d75b70c32588e51174d59165ba", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -136,7 +136,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n             descr_post_path: &str,\n         ) -> bool {\n             if ty.is_unit() || cx.tcx.is_ty_uninhabited_from(\n-                cx.tcx.hir().get_module_parent_by_hir_id(expr.hir_id), ty)\n+                cx.tcx.hir().get_module_parent(expr.hir_id), ty)\n             {\n                 return true;\n             }"}, {"sha": "df0957254cc093fc2340954b3916ee98ff529e2c", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -26,7 +26,7 @@ use std::{cmp, fs};\n \n use syntax::ast;\n use syntax::attr;\n-use syntax::ext::base::SyntaxExtension;\n+use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n use syntax::symbol::{Symbol, sym};\n use syntax::visit;\n use syntax::{span_err, span_fatal};\n@@ -289,13 +289,13 @@ impl<'a> CrateLoader<'a> {\n         (cnum, cmeta)\n     }\n \n-    fn load_proc_macro<'b> (\n+    fn load_proc_macro<'b>(\n         &mut self,\n         locate_ctxt: &mut locator::Context<'b>,\n         path_kind: PathKind,\n     ) -> Option<(LoadResult, Option<Library>)>\n     where\n-        'a: 'b\n+        'a: 'b,\n     {\n         // Use a new locator Context so trying to load a proc macro doesn't affect the error\n         // message we emit\n@@ -611,33 +611,31 @@ impl<'a> CrateLoader<'a> {\n         };\n \n         let extensions = decls.iter().map(|&decl| {\n-            match decl {\n+            let (name, kind, helper_attrs) = match decl {\n                 ProcMacro::CustomDerive { trait_name, attributes, client } => {\n-                    let attrs = attributes.iter().cloned().map(Symbol::intern).collect::<Vec<_>>();\n-                    (trait_name, SyntaxExtension::Derive(\n-                        Box::new(ProcMacroDerive {\n-                            client,\n-                            attrs: attrs.clone(),\n-                        }),\n-                        attrs,\n-                        root.edition,\n-                    ))\n+                    let helper_attrs =\n+                        attributes.iter().cloned().map(Symbol::intern).collect::<Vec<_>>();\n+                    (\n+                        trait_name,\n+                        SyntaxExtensionKind::Derive(Box::new(ProcMacroDerive {\n+                            client, attrs: helper_attrs.clone()\n+                        })),\n+                        helper_attrs,\n+                    )\n                 }\n-                ProcMacro::Attr { name, client } => {\n-                    (name, SyntaxExtension::Attr(\n-                        Box::new(AttrProcMacro { client }),\n-                        root.edition,\n-                    ))\n-                }\n-                ProcMacro::Bang { name, client } => {\n-                    (name, SyntaxExtension::Bang {\n-                        expander: Box::new(BangProcMacro { client }),\n-                        allow_internal_unstable: None,\n-                        edition: root.edition,\n-                    })\n-                }\n-            }\n-        }).map(|(name, ext)| (Symbol::intern(name), Lrc::new(ext))).collect();\n+                ProcMacro::Attr { name, client } => (\n+                    name, SyntaxExtensionKind::Attr(Box::new(AttrProcMacro { client })), Vec::new()\n+                ),\n+                ProcMacro::Bang { name, client } => (\n+                    name, SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client })), Vec::new()\n+                )\n+            };\n+\n+            (Symbol::intern(name), Lrc::new(SyntaxExtension {\n+                helper_attrs,\n+                ..SyntaxExtension::default(kind, root.edition)\n+            }))\n+        }).collect();\n \n         // Intentionally leak the dynamic library. We can't ever unload it\n         // since the library can make things that will live arbitrarily long."}, {"sha": "04a9c4e9a1a11c1083f8d50778965b80c65f6521", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -30,9 +30,11 @@ use syntax::ast;\n use syntax::attr;\n use syntax::source_map;\n use syntax::edition::Edition;\n+use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n use syntax::parse::source_file_to_stream;\n use syntax::parse::parser::emit_unclosed_delims;\n use syntax::symbol::{Symbol, sym};\n+use syntax_ext::proc_macro_impl::BangProcMacro;\n use syntax_pos::{Span, NO_EXPANSION, FileName};\n use rustc_data_structures::bit_set::BitSet;\n \n@@ -427,14 +429,11 @@ impl cstore::CStore {\n         if let Some(ref proc_macros) = data.proc_macros {\n             return LoadedMacro::ProcMacro(proc_macros[id.index.to_proc_macro_index()].1.clone());\n         } else if data.name == sym::proc_macro && data.item_name(id.index) == sym::quote {\n-            use syntax::ext::base::SyntaxExtension;\n-            use syntax_ext::proc_macro_impl::BangProcMacro;\n-\n             let client = proc_macro::bridge::client::Client::expand1(proc_macro::quote);\n-            let ext = SyntaxExtension::Bang {\n-                expander: Box::new(BangProcMacro { client }),\n-                allow_internal_unstable: Some(vec![sym::proc_macro_def_site].into()),\n-                edition: data.root.edition,\n+            let kind = SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client }));\n+            let ext = SyntaxExtension {\n+                allow_internal_unstable: Some([sym::proc_macro_def_site][..].into()),\n+                ..SyntaxExtension::default(kind, data.root.edition)\n             };\n             return LoadedMacro::ProcMacro(Lrc::new(ext));\n         }"}, {"sha": "6a5f62aec1537f35fd5a7d43c0630ae28b78d241", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -35,10 +35,10 @@ use syntax::ext::hygiene::Mark;\n use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP, NO_EXPANSION};\n use log::debug;\n \n-pub struct DecodeContext<'a, 'tcx: 'a> {\n+pub struct DecodeContext<'a, 'tcx> {\n     opaque: opaque::Decoder<'a>,\n     cdata: Option<&'a CrateMetadata>,\n-    sess: Option<&'a Session>,\n+    sess: Option<&'tcx Session>,\n     tcx: Option<TyCtxt<'tcx>>,\n \n     // Cache the last used source_file for translating spans as an optimization.\n@@ -54,10 +54,8 @@ pub struct DecodeContext<'a, 'tcx: 'a> {\n pub trait Metadata<'a, 'tcx>: Copy {\n     fn raw_bytes(self) -> &'a [u8];\n     fn cdata(self) -> Option<&'a CrateMetadata> { None }\n-    fn sess(self) -> Option<&'a Session> { None }\n-    fn tcx(self) -> Option<TyCtxt<'tcx>> {\n-        None\n-        }\n+    fn sess(self) -> Option<&'tcx Session> { None }\n+    fn tcx(self) -> Option<TyCtxt<'tcx>> { None }\n \n     fn decoder(self, pos: usize) -> DecodeContext<'a, 'tcx> {\n         let tcx = self.tcx();\n@@ -82,13 +80,13 @@ impl<'a, 'tcx> Metadata<'a, 'tcx> for &'a MetadataBlob {\n }\n \n \n-impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a MetadataBlob, &'a Session) {\n+impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a MetadataBlob, &'tcx Session) {\n     fn raw_bytes(self) -> &'a [u8] {\n         let (blob, _) = self;\n         &blob.0\n     }\n \n-    fn sess(self) -> Option<&'a Session> {\n+    fn sess(self) -> Option<&'tcx Session> {\n         let (_, sess) = self;\n         Some(sess)\n     }\n@@ -104,14 +102,14 @@ impl<'a, 'tcx> Metadata<'a, 'tcx> for &'a CrateMetadata {\n     }\n }\n \n-impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, &'a Session) {\n+impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, &'tcx Session) {\n     fn raw_bytes(self) -> &'a [u8] {\n         self.0.raw_bytes()\n     }\n     fn cdata(self) -> Option<&'a CrateMetadata> {\n         Some(self.0)\n     }\n-    fn sess(self) -> Option<&'a Session> {\n+    fn sess(self) -> Option<&'tcx Session> {\n         Some(&self.1)\n     }\n }\n@@ -128,19 +126,19 @@ impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, TyCtxt<'tcx>) {\n     }\n }\n \n-impl<'a, 'tcx: 'a, T: Decodable> Lazy<T> {\n+impl<'a, 'tcx, T: Decodable> Lazy<T> {\n     pub fn decode<M: Metadata<'a, 'tcx>>(self, meta: M) -> T {\n         let mut dcx = meta.decoder(self.position);\n         dcx.lazy_state = LazyState::NodeStart(self.position);\n         T::decode(&mut dcx).unwrap()\n     }\n }\n \n-impl<'a, 'tcx: 'a, T: Decodable> LazySeq<T> {\n+impl<'a: 'x, 'tcx: 'x, 'x, T: Decodable> LazySeq<T> {\n     pub fn decode<M: Metadata<'a, 'tcx>>(\n         self,\n         meta: M,\n-    ) -> impl Iterator<Item = T> + Captures<'tcx> + 'a {\n+    ) -> impl Iterator<Item = T> + Captures<'a> + Captures<'tcx> + 'x {\n         let mut dcx = meta.decoder(self.position);\n         dcx.lazy_state = LazyState::NodeStart(self.position);\n         (0..self.len).map(move |_| T::decode(&mut dcx).unwrap())\n@@ -511,8 +509,9 @@ impl<'a, 'tcx> CrateMetadata {\n         if !self.is_proc_macro(index) {\n             self.entry(index).kind.def_kind()\n         } else {\n-            let kind = self.proc_macros.as_ref().unwrap()[index.to_proc_macro_index()].1.kind();\n-            Some(DefKind::Macro(kind))\n+            Some(DefKind::Macro(\n+                self.proc_macros.as_ref().unwrap()[index.to_proc_macro_index()].1.macro_kind()\n+            ))\n         }\n     }\n \n@@ -739,7 +738,7 @@ impl<'a, 'tcx> CrateMetadata {\n             if id == CRATE_DEF_INDEX {\n                 for (id, &(name, ref ext)) in proc_macros.iter().enumerate() {\n                     let res = Res::Def(\n-                        DefKind::Macro(ext.kind()),\n+                        DefKind::Macro(ext.macro_kind()),\n                         self.local_def_id(DefIndex::from_proc_macro_index(id)),\n                     );\n                     let ident = Ident::with_empty_ctxt(name);"}, {"sha": "4c279361ff5e1c657b2781670e53634a948b8e55", "filename": "src/librustc_metadata/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_metadata%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_metadata%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdynamic_lib.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -115,7 +115,7 @@ mod dl {\n     {\n         use std::sync::{Mutex, Once};\n         static INIT: Once = Once::new();\n-        static mut LOCK: *mut Mutex<()> = 0 as *mut _;\n+        static mut LOCK: *mut Mutex<()> = ptr::null_mut();\n         unsafe {\n             INIT.call_once(|| {\n                 LOCK = Box::into_raw(Box::new(Mutex::new(())));"}, {"sha": "b52b6dfbb5e1229f7f5a9fed2fe59530afbc7826", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -579,7 +579,7 @@ impl EncodeContext<'tcx> {\n         };\n \n         let enum_id = tcx.hir().as_local_hir_id(enum_did).unwrap();\n-        let enum_vis = &tcx.hir().expect_item_by_hir_id(enum_id).vis;\n+        let enum_vis = &tcx.hir().expect_item(enum_id).vis;\n \n         Entry {\n             kind: EntryKind::Variant(self.lazy(&data)),\n@@ -632,7 +632,7 @@ impl EncodeContext<'tcx> {\n         // Variant constructors have the same visibility as the parent enums, unless marked as\n         // non-exhaustive, in which case they are lowered to `pub(crate)`.\n         let enum_id = tcx.hir().as_local_hir_id(enum_did).unwrap();\n-        let enum_vis = &tcx.hir().expect_item_by_hir_id(enum_id).vis;\n+        let enum_vis = &tcx.hir().expect_item(enum_id).vis;\n         let mut ctor_vis = ty::Visibility::from_hir(enum_vis, enum_id, tcx);\n         if variant.is_field_list_non_exhaustive() && ctor_vis == ty::Visibility::Public {\n             ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n@@ -751,7 +751,7 @@ impl EncodeContext<'tcx> {\n         };\n \n         let struct_id = tcx.hir().as_local_hir_id(adt_def_id).unwrap();\n-        let struct_vis = &tcx.hir().expect_item_by_hir_id(struct_id).vis;\n+        let struct_vis = &tcx.hir().expect_item(struct_id).vis;\n         let mut ctor_vis = ty::Visibility::from_hir(struct_vis, struct_id, tcx);\n         for field in &variant.fields {\n             if ctor_vis.is_at_least(field.vis, tcx) {"}, {"sha": "40d8173ce400a8bc8653365e25a7461b8aed07c8", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -160,7 +160,7 @@ impl<'tcx> BorrowSet<'tcx> {\n     }\n }\n \n-struct GatherBorrows<'a, 'tcx: 'a> {\n+struct GatherBorrows<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n     idx_vec: IndexVec<BorrowIndex, BorrowData<'tcx>>,"}, {"sha": "dfaad95fa3cb9cf691dd7af9beb8bcad7326f237", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -1815,8 +1815,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // as the HIR doesn't have full types for closure arguments.\n                 let return_ty = *sig.output().skip_binder();\n                 let mut return_span = fn_decl.output.span();\n-                if let hir::FunctionRetTy::Return(ty) = fn_decl.output {\n-                    if let hir::TyKind::Rptr(lifetime, _) = ty.into_inner().node {\n+                if let hir::FunctionRetTy::Return(ty) = &fn_decl.output {\n+                    if let hir::TyKind::Rptr(lifetime, _) = ty.node {\n                         return_span = lifetime.span;\n                     }\n                 }"}, {"sha": "9a9310fbe05f514ee03f91388a71175584352f2f", "filename": "src/librustc_mir/borrow_check/flows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -22,7 +22,7 @@ use std::fmt;\n use std::rc::Rc;\n \n // (forced to be `pub` due to its use as an associated type below.)\n-crate struct Flows<'b, 'tcx: 'b> {\n+crate struct Flows<'b, 'tcx> {\n     borrows: FlowAtLocation<'tcx, Borrows<'b, 'tcx>>,\n     pub uninits: FlowAtLocation<'tcx, MaybeUninitializedPlaces<'b, 'tcx>>,\n     pub ever_inits: FlowAtLocation<'tcx, EverInitializedPlaces<'b, 'tcx>>,"}, {"sha": "ca8c4c58301ab0393be4168d6314a05c57719e3d", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -177,7 +177,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]),\n     ));\n \n-    let locals_are_invalidated_at_exit = tcx.hir().body_owner_kind_by_hir_id(id).is_fn_or_closure();\n+    let locals_are_invalidated_at_exit = tcx.hir().body_owner_kind(id).is_fn_or_closure();\n     let borrow_set = Rc::new(BorrowSet::build(\n             tcx, body, locals_are_invalidated_at_exit, &mdpe.move_data));\n \n@@ -423,7 +423,7 @@ fn downgrade_if_error(diag: &mut Diagnostic) {\n     }\n }\n \n-pub struct MirBorrowckCtxt<'cx, 'tcx: 'cx> {\n+pub struct MirBorrowckCtxt<'cx, 'tcx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n     body: &'cx Body<'tcx>,\n     mir_def_id: DefId,\n@@ -670,7 +670,7 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n                 // \"Lift\" into the gcx -- once regions are erased, this type should be in the\n                 // global arenas; this \"lift\" operation basically just asserts that is true, but\n                 // that is useful later.\n-                let drop_place_ty = gcx.lift(&drop_place_ty).unwrap();\n+                gcx.lift_to_global(&drop_place_ty).unwrap();\n \n                 debug!(\"visit_terminator_drop \\\n                         loc: {:?} term: {:?} drop_place: {:?} drop_place_ty: {:?} span: {:?}\",\n@@ -891,7 +891,7 @@ enum InitializationRequiringAction {\n     PartialAssignment,\n }\n \n-struct RootPlace<'d, 'tcx: 'd> {\n+struct RootPlace<'d, 'tcx> {\n     place: &'d Place<'tcx>,\n     is_local_mutation_allowed: LocalMutationIsAllowed,\n }\n@@ -1070,7 +1070,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n                 (Reservation(WriteKind::MutableBorrow(bk)), BorrowKind::Shallow)\n                 | (Reservation(WriteKind::MutableBorrow(bk)), BorrowKind::Shared) if {\n-                    tcx.migrate_borrowck()\n+                    tcx.migrate_borrowck() && this.borrow_set.location_map.contains_key(&location)\n                 } => {\n                     let bi = this.borrow_set.location_map[&location];\n                     debug!("}, {"sha": "d15229367251ae3befe6173a30c808ebae1934b1", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -422,7 +422,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 let upvar = &self.upvars[upvar_field.unwrap().index()];\n                 let upvar_hir_id = upvar.var_hir_id;\n                 let upvar_name = upvar.name;\n-                let upvar_span = self.infcx.tcx.hir().span_by_hir_id(upvar_hir_id);\n+                let upvar_span = self.infcx.tcx.hir().span(upvar_hir_id);\n \n                 let place_name = self.describe_place(move_place).unwrap();\n "}, {"sha": "fc11cd82f8a9aabd7f1e17d41f9d7b6d7cdddb48", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -304,8 +304,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n \n                 let upvar_hir_id = self.upvars[upvar_index.index()].var_hir_id;\n-                let upvar_node_id = self.infcx.tcx.hir().hir_to_node_id(upvar_hir_id);\n-                if let Some(Node::Binding(pat)) = self.infcx.tcx.hir().find(upvar_node_id) {\n+                if let Some(Node::Binding(pat)) = self.infcx.tcx.hir().find_by_hir_id(upvar_hir_id)\n+                {\n                     if let hir::PatKind::Binding(\n                         hir::BindingAnnotation::Unannotated,\n                         _,"}, {"sha": "058cdec5cea6950ee12170b4e4887e12be5a858f", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -35,7 +35,7 @@ pub(super) fn generate_constraints<'cx, 'tcx>(\n }\n \n /// 'cg = the duration of the constraint generation process itself.\n-struct ConstraintGeneration<'cg, 'cx: 'cg, 'tcx: 'cx> {\n+struct ConstraintGeneration<'cg, 'cx, 'tcx> {\n     infcx: &'cg InferCtxt<'cx, 'tcx>,\n     all_facts: &'cg mut Option<AllFacts>,\n     location_table: &'cg LocationTable,"}, {"sha": "7ab069260f9402cb27476f21185d2d443f17694e", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/find_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -27,7 +27,7 @@ crate fn find<'tcx>(\n     uf.find()\n }\n \n-struct UseFinder<'cx, 'tcx: 'cx> {\n+struct UseFinder<'cx, 'tcx> {\n     body: &'cx Body<'tcx>,\n     regioncx: &'cx Rc<RegionInferenceContext<'tcx>>,\n     tcx: TyCtxt<'tcx>,\n@@ -99,7 +99,7 @@ impl<'cx, 'tcx> UseFinder<'cx, 'tcx> {\n     }\n }\n \n-struct DefUseVisitor<'cx, 'tcx: 'cx> {\n+struct DefUseVisitor<'cx, 'tcx> {\n     body: &'cx Body<'tcx>,\n     tcx: TyCtxt<'tcx>,\n     region_vid: RegionVid,"}, {"sha": "c45c28c61465f541373c2f0a8581cf40d11d097d", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -43,7 +43,7 @@ pub(super) fn generate_invalidates<'tcx>(\n     }\n }\n \n-struct InvalidationGenerator<'cx, 'tcx: 'cx> {\n+struct InvalidationGenerator<'cx, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     all_facts: &'cx mut AllFacts,\n     location_table: &'cx LocationTable,"}, {"sha": "46b690129ea259d9b4e077b95bc482c58aa9cee6", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -230,14 +230,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 },\n \n                 ty::BoundRegion::BrEnv => {\n-                    let mir_node_id = tcx.hir()\n-                                         .as_local_node_id(mir_def_id)\n-                                         .expect(\"non-local mir\");\n+                    let mir_hir_id = tcx.hir()\n+                                        .as_local_hir_id(mir_def_id)\n+                                        .expect(\"non-local mir\");\n                     let def_ty = self.universal_regions.defining_ty;\n \n                     if let DefiningTy::Closure(def_id, substs) = def_ty {\n                         let args_span = if let hir::ExprKind::Closure(_, _, _, span, _) =\n-                            tcx.hir().expect_expr(mir_node_id).node\n+                            tcx.hir().expect_expr_by_hir_id(mir_hir_id).node\n                         {\n                             span\n                         } else {\n@@ -310,7 +310,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let scope = error_region.free_region_binding_scope(tcx);\n         let node = tcx.hir().as_local_hir_id(scope).unwrap_or(hir::DUMMY_HIR_ID);\n \n-        let span = tcx.sess.source_map().def_span(tcx.hir().span_by_hir_id(node));\n+        let span = tcx.sess.source_map().def_span(tcx.hir().span(node));\n         if let Some(param) = tcx.hir()\n             .get_generics(scope)\n             .and_then(|generics| generics.get_named(name))\n@@ -367,8 +367,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         argument_index: usize,\n         counter: &mut usize,\n     ) -> Option<RegionName> {\n-        let mir_node_id = infcx.tcx.hir().as_local_node_id(mir_def_id)?;\n-        let fn_decl = infcx.tcx.hir().fn_decl(mir_node_id)?;\n+        let mir_hir_id = infcx.tcx.hir().as_local_hir_id(mir_def_id)?;\n+        let fn_decl = infcx.tcx.hir().fn_decl_by_hir_id(mir_hir_id)?;\n         let argument_hir_ty: &hir::Ty = &fn_decl.inputs[argument_index];\n         match argument_hir_ty.node {\n             // This indicates a variable with no type annotation, like\n@@ -696,9 +696,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         highlight.highlighting_region_vid(fr, *counter);\n         let type_name = infcx.extract_type_name(&return_ty, Some(highlight));\n \n-        let mir_node_id = tcx.hir().as_local_node_id(mir_def_id).expect(\"non-local mir\");\n+        let mir_hir_id = tcx.hir().as_local_hir_id(mir_def_id).expect(\"non-local mir\");\n \n-        let (return_span, mir_description) = match tcx.hir().get(mir_node_id) {\n+        let (return_span, mir_description) = match tcx.hir().get_by_hir_id(mir_hir_id) {\n             hir::Node::Expr(hir::Expr {\n                 node: hir::ExprKind::Closure(_, return_ty, _, span, gen_move),\n                 ..\n@@ -759,9 +759,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         highlight.highlighting_region_vid(fr, *counter);\n         let type_name = infcx.extract_type_name(&yield_ty, Some(highlight));\n \n-        let mir_node_id = tcx.hir().as_local_node_id(mir_def_id).expect(\"non-local mir\");\n+        let mir_hir_id = tcx.hir().as_local_hir_id(mir_def_id).expect(\"non-local mir\");\n \n-        let yield_span = match tcx.hir().get(mir_node_id) {\n+        let yield_span = match tcx.hir().get_by_hir_id(mir_hir_id) {\n             hir::Node::Expr(hir::Expr {\n                 node: hir::ExprKind::Closure(_, _, _, span, _),\n                 .."}, {"sha": "59fc4113794a45ff8ecbaa0d68d221f768a60f19", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/var_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -73,7 +73,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         debug!(\"get_upvar_name_and_span_for_region: upvar_hir_id={:?}\", upvar_hir_id);\n \n         let upvar_name = tcx.hir().name_by_hir_id(upvar_hir_id);\n-        let upvar_span = tcx.hir().span_by_hir_id(upvar_hir_id);\n+        let upvar_span = tcx.hir().span(upvar_hir_id);\n         debug!(\"get_upvar_name_and_span_for_region: upvar_name={:?} upvar_span={:?}\",\n                upvar_name, upvar_span);\n "}, {"sha": "0cf8a0d16f622ba317dc68fea2c76e8b1b24cf46", "filename": "src/librustc_mir/borrow_check/nll/region_infer/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -29,7 +29,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n }\n \n-struct RawConstraints<'a, 'tcx: 'a> {\n+struct RawConstraints<'a, 'tcx> {\n     regioncx: &'a RegionInferenceContext<'tcx>,\n }\n \n@@ -78,7 +78,7 @@ impl<'a, 'this, 'tcx> dot::GraphWalk<'this> for RawConstraints<'a, 'tcx> {\n     }\n }\n \n-struct SccConstraints<'a, 'tcx: 'a> {\n+struct SccConstraints<'a, 'tcx> {\n     regioncx: &'a RegionInferenceContext<'tcx>,\n     nodes_per_scc: IndexVec<ConstraintSccIndex, Vec<RegionVid>>,\n }"}, {"sha": "41ed564d0f0e1a91ca73b798ae4464b8ca2b5293", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -863,8 +863,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         });\n         debug!(\"try_promote_type_test_subject: folded ty = {:?}\", ty);\n \n-        // `lift` will only fail if we failed to promote some region.\n-        let ty = gcx.lift(&ty)?;\n+        // `lift_to_global` will only fail if we failed to promote some region.\n+        gcx.lift_to_global(&ty)?;\n \n         Some(ClosureOutlivesSubject::Ty(ty))\n     }"}, {"sha": "77a4d2699fff72eff1cb1d2a16ca26c969605e1b", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -13,7 +13,7 @@ use rustc::ty::subst::UnpackedKind;\n use rustc::ty::{self, TyCtxt};\n use syntax_pos::DUMMY_SP;\n \n-crate struct ConstraintConversion<'a, 'tcx: 'a> {\n+crate struct ConstraintConversion<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     tcx: TyCtxt<'tcx>,\n     universal_regions: &'a UniversalRegions<'tcx>,"}, {"sha": "1bb3acc28f0c8d97628fb2b6fa70529a43449062", "filename": "src/librustc_mir/borrow_check/nll/type_check/free_region_relations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -219,7 +219,7 @@ impl UniversalRegionRelations<'tcx> {\n     }\n }\n \n-struct UniversalRegionRelationsBuilder<'this, 'tcx: 'this> {\n+struct UniversalRegionRelationsBuilder<'this, 'tcx> {\n     infcx: &'this InferCtxt<'this, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     universal_regions: Rc<UniversalRegions<'tcx>>,"}, {"sha": "f1d568f0cf24c85a29e57c5c2080a6f9e9a0fa5f", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/trace.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -58,12 +58,7 @@ pub(super) fn trace(\n }\n \n /// Contextual state for the type-liveness generator.\n-struct LivenessContext<'me, 'typeck, 'flow, 'tcx>\n-where\n-    'typeck: 'me,\n-    'flow: 'me,\n-    'tcx: 'typeck + 'flow,\n-{\n+struct LivenessContext<'me, 'typeck, 'flow, 'tcx> {\n     /// Current type-checker, giving us our inference context etc.\n     typeck: &'me mut TypeChecker<'typeck, 'tcx>,\n \n@@ -96,12 +91,7 @@ struct DropData<'tcx> {\n     region_constraint_data: Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>,\n }\n \n-struct LivenessResults<'me, 'typeck, 'flow, 'tcx>\n-where\n-    'typeck: 'me,\n-    'flow: 'me,\n-    'tcx: 'typeck + 'flow,\n-{\n+struct LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n     cx: LivenessContext<'me, 'typeck, 'flow, 'tcx>,\n \n     /// Set of points that define the current local."}, {"sha": "e1f5964ff9340e6b2701fe5564c9f1a298aa053c", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -251,7 +251,7 @@ enum FieldAccessError {\n /// The sanitize_XYZ methods here take an MIR object and compute its\n /// type, calling `span_mirbug` and returning an error type if there\n /// is a problem.\n-struct TypeVerifier<'a, 'b: 'a, 'tcx: 'b> {\n+struct TypeVerifier<'a, 'b, 'tcx> {\n     cx: &'a mut TypeChecker<'b, 'tcx>,\n     body: &'b Body<'tcx>,\n     last_span: Span,\n@@ -830,7 +830,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n /// constraints needed for it to be valid and well-typed. Along the\n /// way, it accrues region constraints -- these can later be used by\n /// NLL region checking.\n-struct TypeChecker<'a, 'tcx: 'a> {\n+struct TypeChecker<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     last_span: Span,\n@@ -845,7 +845,7 @@ struct TypeChecker<'a, 'tcx: 'a> {\n     universal_region_relations: &'a UniversalRegionRelations<'tcx>,\n }\n \n-struct BorrowCheckContext<'a, 'tcx: 'a> {\n+struct BorrowCheckContext<'a, 'tcx> {\n     universal_regions: &'a UniversalRegions<'tcx>,\n     location_table: &'a LocationTable,\n     all_facts: &'a mut Option<AllFacts>,\n@@ -1695,7 +1695,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         from_hir_call: bool,\n     ) {\n         debug!(\"check_call_inputs({:?}, {:?})\", sig, args);\n-        // Do not count the `VaList` argument as a \"true\" argument to\n+        // Do not count the `VaListImpl` argument as a \"true\" argument to\n         // a C-variadic function.\n         let inputs = if sig.c_variadic {\n             &sig.inputs()[..sig.inputs().len() - 1]\n@@ -1864,7 +1864,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         // `Sized` bound in no way depends on precise regions, so this\n         // shouldn't affect `is_sized`.\n         let gcx = tcx.global_tcx();\n-        let erased_ty = gcx.lift(&tcx.erase_regions(&ty)).unwrap();\n+        let erased_ty = tcx.erase_regions(&ty);\n         if !erased_ty.is_sized(gcx.at(span), self.param_env) {\n             // in current MIR construction, all non-control-flow rvalue\n             // expressions evaluate through `as_temp` or `into` a return\n@@ -2650,7 +2650,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n     fn normalize<T>(&mut self, value: T, location: impl NormalizeLocation) -> T\n     where\n-        T: type_op::normalize::Normalizable<'tcx> + Copy,\n+        T: type_op::normalize::Normalizable<'tcx> + Copy + 'tcx,\n     {\n         debug!(\"normalize(value={:?}, location={:?})\", value, location);\n         let param_env = self.param_env;"}, {"sha": "2549aa4fbff93ed1175eadfb1383e6b2f2a6255b", "filename": "src/librustc_mir/borrow_check/nll/type_check/relate_tys.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -34,7 +34,7 @@ pub(super) fn relate_types<'tcx>(\n     Ok(())\n }\n \n-struct NllTypeRelatingDelegate<'me, 'bccx: 'me, 'tcx: 'bccx> {\n+struct NllTypeRelatingDelegate<'me, 'bccx, 'tcx> {\n     infcx: &'me InferCtxt<'me, 'tcx>,\n     borrowck_context: Option<&'me mut BorrowCheckContext<'bccx, 'tcx>>,\n "}, {"sha": "fa3c7b9613e19906274cfc55df7f6f8ab2d875bc", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -363,7 +363,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n     }\n }\n \n-struct UniversalRegionsBuilder<'cx, 'tcx: 'cx> {\n+struct UniversalRegionsBuilder<'cx, 'tcx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n     mir_def_id: DefId,\n     mir_hir_id: HirId,\n@@ -471,7 +471,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         let tcx = self.infcx.tcx;\n         let closure_base_def_id = tcx.closure_base_def_id(self.mir_def_id);\n \n-        match tcx.hir().body_owner_kind_by_hir_id(self.mir_hir_id) {\n+        match tcx.hir().body_owner_kind(self.mir_hir_id) {\n             BodyOwnerKind::Closure |\n             BodyOwnerKind::Fn => {\n                 let defining_ty = if self.mir_def_id == closure_base_def_id {"}, {"sha": "0cc1dfd4def0f07e7886c095e9bd9d5bbd3cb62f", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -36,7 +36,7 @@ impl<'tcx> IsPrefixOf<'tcx> for Place<'tcx> {\n     }\n }\n \n-pub(super) struct Prefixes<'cx, 'tcx: 'cx> {\n+pub(super) struct Prefixes<'cx, 'tcx> {\n     body: &'cx Body<'tcx>,\n     tcx: TyCtxt<'tcx>,\n     kind: PrefixSet,"}, {"sha": "9c5569011df4fcdd0ccfe4e2a829cbacfaf1cafb", "filename": "src/librustc_mir/borrow_check/used_muts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -46,7 +46,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n /// MIR visitor for collecting used mutable variables.\n /// The 'visit lifetime represents the duration of the MIR walk.\n-struct GatherUsedMutsVisitor<'visit, 'cx: 'visit, 'tcx: 'cx> {\n+struct GatherUsedMutsVisitor<'visit, 'cx, 'tcx> {\n     temporary_used_locals: FxHashSet<Local>,\n     never_initialized_mut_locals: &'visit mut FxHashSet<Local>,\n     mbcx: &'visit mut MirBorrowckCtxt<'cx, 'tcx>,"}, {"sha": "243c13c2982d0fb0aadda0731742fdf9b49cc1f5", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -569,7 +569,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     // Helper to get a `-1` value of the appropriate type\n     fn neg_1_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n-        let param_ty = ty::ParamEnv::empty().and(self.hir.tcx().lift_to_global(&ty).unwrap());\n+        let param_ty = ty::ParamEnv::empty().and(ty);\n         let bits = self.hir.tcx().layout_of(param_ty).unwrap().size.bits();\n         let n = (!0u128) >> (128 - bits);\n         let literal = ty::Const::from_bits(self.hir.tcx(), n, param_ty);\n@@ -580,7 +580,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     // Helper to get the minimum value of the appropriate type\n     fn minval_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n         assert!(ty.is_signed());\n-        let param_ty = ty::ParamEnv::empty().and(self.hir.tcx().lift_to_global(&ty).unwrap());\n+        let param_ty = ty::ParamEnv::empty().and(ty);\n         let bits = self.hir.tcx().layout_of(param_ty).unwrap().size.bits();\n         let n = 1 << (bits - 1);\n         let literal = ty::Const::from_bits(self.hir.tcx(), n, param_ty);"}, {"sha": "55093f28a42e16e61682b60493500e94445fd130", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -661,7 +661,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n }\n \n #[derive(Debug)]\n-pub struct Candidate<'pat, 'tcx: 'pat> {\n+pub struct Candidate<'pat, 'tcx> {\n     // span of the original pattern that gave rise to this candidate\n     span: Span,\n \n@@ -705,7 +705,7 @@ struct Ascription<'tcx> {\n }\n \n #[derive(Clone, Debug)]\n-pub struct MatchPair<'pat, 'tcx: 'pat> {\n+pub struct MatchPair<'pat, 'tcx> {\n     // this place...\n     place: Place<'tcx>,\n "}, {"sha": "f7958434afa64b326b7941d6fb47ed56c8313562", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -55,10 +55,10 @@ pub fn mir_build<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Body<'tcx> {\n             (*body_id, ty.span)\n         }\n         Node::AnonConst(hir::AnonConst { body, hir_id, .. }) => {\n-            (*body, tcx.hir().span_by_hir_id(*hir_id))\n+            (*body, tcx.hir().span(*hir_id))\n         }\n \n-        _ => span_bug!(tcx.hir().span_by_hir_id(id), \"can't build MIR for {:?}\", def_id),\n+        _ => span_bug!(tcx.hir().span(id), \"can't build MIR for {:?}\", def_id),\n     };\n \n     tcx.infer_ctxt().enter(|infcx| {\n@@ -101,9 +101,9 @@ pub fn mir_build<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Body<'tcx> {\n                         let owner_id = tcx.hir().body_owner(body_id);\n                         let opt_ty_info;\n                         let self_arg;\n-                        if let Some(ref fn_decl) = tcx.hir().fn_decl(owner_id) {\n+                        if let Some(ref fn_decl) = tcx.hir().fn_decl_by_hir_id(owner_id) {\n                             let ty_hir_id = fn_decl.inputs[index].hir_id;\n-                            let ty_span = tcx.hir().span_by_hir_id(ty_hir_id);\n+                            let ty_span = tcx.hir().span(ty_hir_id);\n                             opt_ty_info = Some(ty_span);\n                             self_arg = if index == 0 && fn_decl.implicit_self.has_implicit_self() {\n                                 match fn_decl.implicit_self {\n@@ -126,12 +126,12 @@ pub fn mir_build<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Body<'tcx> {\n \n             let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n \n-            let (yield_ty, return_ty) = if body.is_generator {\n+            let (yield_ty, return_ty) = if body.generator_kind.is_some() {\n                 let gen_sig = match ty.sty {\n                     ty::Generator(gen_def_id, gen_substs, ..) =>\n                         gen_substs.sig(gen_def_id, tcx),\n                     _ =>\n-                        span_bug!(tcx.hir().span_by_hir_id(id),\n+                        span_bug!(tcx.hir().span(id),\n                                   \"generator w/o generator type: {:?}\", ty),\n                 };\n                 (Some(gen_sig.yield_ty), gen_sig.return_ty)\n@@ -241,7 +241,7 @@ impl BlockFrame {\n #[derive(Debug)]\n struct BlockContext(Vec<BlockFrame>);\n \n-struct Builder<'a, 'tcx: 'a> {\n+struct Builder<'a, 'tcx> {\n     hir: Cx<'a, 'tcx>,\n     cfg: CFG<'tcx>,\n \n@@ -535,7 +535,7 @@ where\n \n     let tcx = hir.tcx();\n     let tcx_hir = tcx.hir();\n-    let span = tcx_hir.span_by_hir_id(fn_id);\n+    let span = tcx_hir.span(fn_id);\n \n     let hir_tables = hir.tables();\n     let fn_def_id = tcx_hir.local_def_id_from_hir_id(fn_id);\n@@ -590,7 +590,7 @@ where\n         return_ty_span,\n         upvar_debuginfo,\n         upvar_mutbls,\n-        body.is_generator);\n+        body.generator_kind.is_some());\n \n     let call_site_scope = region::Scope {\n         id: body.value.hir_id.local_id,"}, {"sha": "3ad7b00a6653ff675d226077d3c6ecc4236dd161", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 59, "deletions": 44, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -9,7 +9,7 @@ use std::convert::TryInto;\n \n use rustc::hir::def::DefKind;\n use rustc::hir::def_id::DefId;\n-use rustc::mir::interpret::{ConstEvalErr, ErrorHandled};\n+use rustc::mir::interpret::{ConstEvalErr, ErrorHandled, ScalarMaybeUndef};\n use rustc::mir;\n use rustc::ty::{self, TyCtxt, query::TyCtxtAt};\n use rustc::ty::layout::{self, LayoutOf, VariantIdx};\n@@ -18,15 +18,14 @@ use rustc::traits::Reveal;\n use rustc::util::common::ErrorReported;\n use rustc_data_structures::fx::FxHashMap;\n \n-use syntax::ast::Mutability;\n use syntax::source_map::{Span, DUMMY_SP};\n \n use crate::interpret::{self,\n-    PlaceTy, MPlaceTy, MemPlace, OpTy, ImmTy, Immediate, Scalar,\n+    PlaceTy, MPlaceTy, OpTy, ImmTy, Immediate, Scalar,\n     RawConst, ConstValue,\n     InterpResult, InterpErrorInfo, InterpError, GlobalId, InterpretCx, StackPopCleanup,\n     Allocation, AllocId, MemoryKind, Memory,\n-    snapshot, RefTracking,\n+    snapshot, RefTracking, intern_const_alloc_recursive,\n };\n \n /// Number of steps until the detector even starts doing anything.\n@@ -63,33 +62,19 @@ pub(crate) fn eval_promoted<'mir, 'tcx>(\n     eval_body_using_ecx(&mut ecx, cid, body, param_env)\n }\n \n-fn mplace_to_const<'tcx>(\n-    ecx: &CompileTimeEvalContext<'_, 'tcx>,\n-    mplace: MPlaceTy<'tcx>,\n-) -> &'tcx ty::Const<'tcx> {\n-    let MemPlace { ptr, align, meta } = *mplace;\n-    // extract alloc-offset pair\n-    assert!(meta.is_none());\n-    let ptr = ptr.to_ptr().unwrap();\n-    let alloc = ecx.memory.get(ptr.alloc_id).unwrap();\n-    assert!(alloc.align >= align);\n-    assert!(alloc.bytes.len() as u64 - ptr.offset.bytes() >= mplace.layout.size.bytes());\n-    let mut alloc = alloc.clone();\n-    alloc.align = align;\n-    // FIXME shouldn't it be the case that `mark_static_initialized` has already\n-    // interned this?  I thought that is the entire point of that `FinishStatic` stuff?\n-    let alloc = ecx.tcx.intern_const_alloc(alloc);\n-    let val = ConstValue::ByRef(ptr, alloc);\n-    ecx.tcx.mk_const(ty::Const { val, ty: mplace.layout.ty })\n-}\n-\n fn op_to_const<'tcx>(\n     ecx: &CompileTimeEvalContext<'_, 'tcx>,\n     op: OpTy<'tcx>,\n ) -> &'tcx ty::Const<'tcx> {\n-    // We do not normalize just any data.  Only non-union scalars and slices.\n-    let normalize = match op.layout.abi {\n-        layout::Abi::Scalar(..) => op.layout.ty.ty_adt_def().map_or(true, |adt| !adt.is_union()),\n+    // We do not have value optmizations for everything.\n+    // Only scalars and slices, since they are very common.\n+    // Note that further down we turn scalars of undefined bits back to `ByRef`. These can result\n+    // from scalar unions that are initialized with one of their zero sized variants. We could\n+    // instead allow `ConstValue::Scalar` to store `ScalarMaybeUndef`, but that would affect all\n+    // the usual cases of extracting e.g. a `usize`, without there being a real use case for the\n+    // `Undef` situation.\n+    let try_as_immediate = match op.layout.abi {\n+        layout::Abi::Scalar(..) => true,\n         layout::Abi::ScalarPair(..) => match op.layout.ty.sty {\n             ty::Ref(_, inner, _) => match inner.sty {\n                 ty::Slice(elem) => elem == ecx.tcx.types.u8,\n@@ -100,16 +85,38 @@ fn op_to_const<'tcx>(\n         },\n         _ => false,\n     };\n-    let normalized_op = if normalize {\n-        Err(*ecx.read_immediate(op).expect(\"normalization works on validated constants\"))\n+    let immediate = if try_as_immediate {\n+        Err(ecx.read_immediate(op).expect(\"normalization works on validated constants\"))\n     } else {\n+        // It is guaranteed that any non-slice scalar pair is actually ByRef here.\n+        // When we come back from raw const eval, we are always by-ref. The only way our op here is\n+        // by-val is if we are in const_field, i.e., if this is (a field of) something that we\n+        // \"tried to make immediate\" before. We wouldn't do that for non-slice scalar pairs or\n+        // structs containing such.\n         op.try_as_mplace()\n     };\n-    let val = match normalized_op {\n-        Ok(mplace) => return mplace_to_const(ecx, mplace),\n-        Err(Immediate::Scalar(x)) =>\n-            ConstValue::Scalar(x.not_undef().unwrap()),\n-        Err(Immediate::ScalarPair(a, b)) => {\n+    let val = match immediate {\n+        Ok(mplace) => {\n+            let ptr = mplace.ptr.to_ptr().unwrap();\n+            let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n+            ConstValue::ByRef(ptr, mplace.align, alloc)\n+        },\n+        // see comment on `let try_as_immediate` above\n+        Err(ImmTy { imm: Immediate::Scalar(x), .. }) => match x {\n+            ScalarMaybeUndef::Scalar(s) => ConstValue::Scalar(s),\n+            ScalarMaybeUndef::Undef => {\n+                // When coming out of \"normal CTFE\", we'll always have an `Indirect` operand as\n+                // argument and we will not need this. The only way we can already have an\n+                // `Immediate` is when we are called from `const_field`, and that `Immediate`\n+                // comes from a constant so it can happen have `Undef`, because the indirect\n+                // memory that was read had undefined bytes.\n+                let mplace = op.to_mem_place();\n+                let ptr = mplace.ptr.to_ptr().unwrap();\n+                let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n+                ConstValue::ByRef(ptr, mplace.align, alloc)\n+            },\n+        },\n+        Err(ImmTy { imm: Immediate::ScalarPair(a, b), .. }) => {\n             let (data, start) = match a.not_undef().unwrap() {\n                 Scalar::Ptr(ptr) => (\n                     ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id),\n@@ -164,13 +171,12 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     ecx.run()?;\n \n     // Intern the result\n-    let mutability = if tcx.is_mutable_static(cid.instance.def_id()) ||\n-                     !layout.ty.is_freeze(tcx, param_env, body.span) {\n-        Mutability::Mutable\n-    } else {\n-        Mutability::Immutable\n-    };\n-    ecx.memory.intern_static(ret.ptr.to_ptr()?.alloc_id, mutability)?;\n+    intern_const_alloc_recursive(\n+        ecx,\n+        cid.instance.def_id(),\n+        ret,\n+        param_env,\n+    )?;\n \n     debug!(\"eval_body_using_ecx done: {:?}\", *ret);\n     Ok(ret)\n@@ -297,7 +303,7 @@ impl<K: Hash + Eq, V> interpret::AllocMap<K, V> for FxHashMap<K, V> {\n     }\n }\n \n-type CompileTimeEvalContext<'mir, 'tcx> =\n+crate type CompileTimeEvalContext<'mir, 'tcx> =\n     InterpretCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>;\n \n impl interpret::MayLeak for ! {\n@@ -526,13 +532,22 @@ fn validate_and_turn_into_const<'tcx>(\n                 mplace.into(),\n                 path,\n                 Some(&mut ref_tracking),\n-                true, // const mode\n             )?;\n         }\n         // Now that we validated, turn this into a proper constant.\n+        // Statics/promoteds are always `ByRef`, for the rest `op_to_const` decides\n+        // whether they become immediates.\n         let def_id = cid.instance.def.def_id();\n         if tcx.is_static(def_id) || cid.promoted.is_some() {\n-            Ok(mplace_to_const(&ecx, mplace))\n+            let ptr = mplace.ptr.to_ptr()?;\n+            Ok(tcx.mk_const(ty::Const {\n+                val: ConstValue::ByRef(\n+                    ptr,\n+                    mplace.align,\n+                    ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id),\n+                ),\n+                ty: mplace.layout.ty,\n+            }))\n         } else {\n             Ok(op_to_const(&ecx, mplace.into()))\n         }"}, {"sha": "37f2a915782497cd4065490a29e0254df3866ef5", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -151,7 +151,7 @@ pub(crate) fn on_all_drop_children_bits<'tcx, F>(\n         debug!(\"on_all_drop_children_bits({:?}, {:?} : {:?})\", path, place, ty);\n \n         let gcx = tcx.global_tcx();\n-        let erased_ty = gcx.lift(&tcx.erase_regions(&ty)).unwrap();\n+        let erased_ty = tcx.erase_regions(&ty);\n         if erased_ty.needs_drop(gcx, ctxt.param_env) {\n             each_child(child);\n         } else {"}, {"sha": "069ce3a78c5f9f0b4f451939beb5539e80047307", "filename": "src/librustc_mir/dataflow/impls/borrowed_locals.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -11,11 +11,11 @@ use crate::dataflow::BitDenotation;\n /// This is used to compute which locals are live during a yield expression for\n /// immovable generators.\n #[derive(Copy, Clone)]\n-pub struct HaveBeenBorrowedLocals<'a, 'tcx: 'a> {\n+pub struct HaveBeenBorrowedLocals<'a, 'tcx> {\n     body: &'a Body<'tcx>,\n }\n \n-impl<'a, 'tcx: 'a> HaveBeenBorrowedLocals<'a, 'tcx> {\n+impl<'a, 'tcx> HaveBeenBorrowedLocals<'a, 'tcx> {\n     pub fn new(body: &'a Body<'tcx>)\n                -> Self {\n         HaveBeenBorrowedLocals { body }\n@@ -97,7 +97,7 @@ impl<'a, 'tcx> InitialFlow for HaveBeenBorrowedLocals<'a, 'tcx> {\n     }\n }\n \n-struct BorrowedLocalsVisitor<'b, 'c: 'b> {\n+struct BorrowedLocalsVisitor<'b, 'c> {\n     sets: &'b mut BlockSets<'c, Local>,\n }\n "}, {"sha": "899765a1d2daa3903faf7354667e0a54bd53ef35", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -29,7 +29,7 @@ newtype_index! {\n /// `BorrowIndex`, and maps each such index to a `BorrowData`\n /// describing the borrow. These indexes are used for representing the\n /// borrows in compact bitvectors.\n-pub struct Borrows<'a, 'tcx: 'a> {\n+pub struct Borrows<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n "}, {"sha": "0a572d2093622e4b6756cd47462dd7e4f3ee61e8", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -63,7 +63,7 @@ pub(super) mod borrows;\n /// Similarly, at a given `drop` statement, the set-intersection\n /// between this data and `MaybeUninitializedPlaces` yields the set of\n /// places that would require a dynamic drop-flag at that statement.\n-pub struct MaybeInitializedPlaces<'a, 'tcx: 'a> {\n+pub struct MaybeInitializedPlaces<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n     mdpe: &'a MoveDataParamEnv<'tcx>,\n@@ -114,7 +114,7 @@ impl<'a, 'tcx> HasMoveData<'tcx> for MaybeInitializedPlaces<'a, 'tcx> {\n /// Similarly, at a given `drop` statement, the set-intersection\n /// between this data and `MaybeInitializedPlaces` yields the set of\n /// places that would require a dynamic drop-flag at that statement.\n-pub struct MaybeUninitializedPlaces<'a, 'tcx: 'a> {\n+pub struct MaybeUninitializedPlaces<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n     mdpe: &'a MoveDataParamEnv<'tcx>,\n@@ -164,19 +164,19 @@ impl<'a, 'tcx> HasMoveData<'tcx> for MaybeUninitializedPlaces<'a, 'tcx> {\n /// Similarly, at a given `drop` statement, the set-difference between\n /// this data and `MaybeInitializedPlaces` yields the set of places\n /// that would require a dynamic drop-flag at that statement.\n-pub struct DefinitelyInitializedPlaces<'a, 'tcx: 'a> {\n+pub struct DefinitelyInitializedPlaces<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n     mdpe: &'a MoveDataParamEnv<'tcx>,\n }\n \n-impl<'a, 'tcx: 'a> DefinitelyInitializedPlaces<'a, 'tcx> {\n+impl<'a, 'tcx> DefinitelyInitializedPlaces<'a, 'tcx> {\n     pub fn new(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, mdpe: &'a MoveDataParamEnv<'tcx>) -> Self {\n         DefinitelyInitializedPlaces { tcx: tcx, body: body, mdpe: mdpe }\n     }\n }\n \n-impl<'a, 'tcx: 'a> HasMoveData<'tcx> for DefinitelyInitializedPlaces<'a, 'tcx> {\n+impl<'a, 'tcx> HasMoveData<'tcx> for DefinitelyInitializedPlaces<'a, 'tcx> {\n     fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n }\n \n@@ -209,13 +209,13 @@ impl<'a, 'tcx: 'a> HasMoveData<'tcx> for DefinitelyInitializedPlaces<'a, 'tcx> {\n ///     c = S;                                 // {a, b, c, d }\n /// }\n /// ```\n-pub struct EverInitializedPlaces<'a, 'tcx: 'a> {\n+pub struct EverInitializedPlaces<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n     mdpe: &'a MoveDataParamEnv<'tcx>,\n }\n \n-impl<'a, 'tcx: 'a> EverInitializedPlaces<'a, 'tcx> {\n+impl<'a, 'tcx> EverInitializedPlaces<'a, 'tcx> {\n     pub fn new(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, mdpe: &'a MoveDataParamEnv<'tcx>) -> Self {\n         EverInitializedPlaces { tcx: tcx, body: body, mdpe: mdpe }\n     }"}, {"sha": "d7575b0f441e6dd45785e35a2dbfeb5f82557447", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -4,11 +4,11 @@ use rustc::mir::*;\n use crate::dataflow::BitDenotation;\n \n #[derive(Copy, Clone)]\n-pub struct MaybeStorageLive<'a, 'tcx: 'a> {\n+pub struct MaybeStorageLive<'a, 'tcx> {\n     body: &'a Body<'tcx>,\n }\n \n-impl<'a, 'tcx: 'a> MaybeStorageLive<'a, 'tcx> {\n+impl<'a, 'tcx> MaybeStorageLive<'a, 'tcx> {\n     pub fn new(body: &'a Body<'tcx>)\n                -> Self {\n         MaybeStorageLive { body }"}, {"sha": "0728d5b21bbd18f548ebabd5902881204543330e", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -41,9 +41,9 @@ pub(crate) mod indexes {\n     };\n }\n \n-pub(crate) struct DataflowBuilder<'a, 'tcx: 'a, BD>\n+pub(crate) struct DataflowBuilder<'a, 'tcx, BD>\n where\n-    BD: BitDenotation<'tcx>\n+    BD: BitDenotation<'tcx>,\n {\n     def_id: DefId,\n     flow_state: DataflowAnalysis<'a, 'tcx, BD>,\n@@ -86,9 +86,9 @@ pub(crate) trait Dataflow<'tcx, BD: BitDenotation<'tcx>> {\n     fn propagate(&mut self);\n }\n \n-impl<'a, 'tcx: 'a, BD> Dataflow<'tcx, BD> for DataflowBuilder<'a, 'tcx, BD>\n+impl<'a, 'tcx, BD> Dataflow<'tcx, BD> for DataflowBuilder<'a, 'tcx, BD>\n where\n-    BD: BitDenotation<'tcx>\n+    BD: BitDenotation<'tcx>,\n {\n     fn dataflow<P>(&mut self, p: P) where P: Fn(&BD, BD::Idx) -> DebugFormatted {\n         self.flow_state.build_sets();\n@@ -138,7 +138,7 @@ where\n     flow_state.run(tcx, def_id, attributes, p)\n }\n \n-impl<'a, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD>\n+impl<'a, 'tcx, BD> DataflowAnalysis<'a, 'tcx, BD>\n where\n     BD: BitDenotation<'tcx>,\n {\n@@ -179,12 +179,16 @@ where\n     }\n }\n \n-struct PropagationContext<'b, 'a: 'b, 'tcx: 'a, O> where O: 'b + BitDenotation<'tcx>\n+struct PropagationContext<'b, 'a, 'tcx, O>\n+where\n+    O: 'b + BitDenotation<'tcx>,\n {\n     builder: &'b mut DataflowAnalysis<'a, 'tcx, O>,\n }\n \n-impl<'a, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitDenotation<'tcx>\n+impl<'a, 'tcx, BD> DataflowAnalysis<'a, 'tcx, BD>\n+where\n+    BD: BitDenotation<'tcx>,\n {\n     fn propagate(&mut self) {\n         let mut temp = BitSet::new_empty(self.flow_state.sets.bits_per_block);\n@@ -234,7 +238,9 @@ impl<'a, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitDenotation<'t\n     }\n }\n \n-impl<'b, 'a: 'b, 'tcx: 'a, BD> PropagationContext<'b, 'a, 'tcx, BD> where BD: BitDenotation<'tcx>\n+impl<'b, 'a, 'tcx, BD> PropagationContext<'b, 'a, 'tcx, BD>\n+where\n+    BD: BitDenotation<'tcx>,\n {\n     fn walk_cfg(&mut self, in_out: &mut BitSet<BD::Idx>) {\n         let mut dirty_queue: WorkQueue<mir::BasicBlock> =\n@@ -265,7 +271,9 @@ fn dataflow_path(context: &str, path: &str) -> PathBuf {\n     path\n }\n \n-impl<'a, 'tcx: 'a, BD> DataflowBuilder<'a, 'tcx, BD> where BD: BitDenotation<'tcx>\n+impl<'a, 'tcx, BD> DataflowBuilder<'a, 'tcx, BD>\n+where\n+    BD: BitDenotation<'tcx>,\n {\n     fn pre_dataflow_instrumentation<P>(&self, p: P) -> io::Result<()>\n         where P: Fn(&BD, BD::Idx) -> DebugFormatted\n@@ -387,14 +395,18 @@ pub fn state_for_location<'tcx, T: BitDenotation<'tcx>>(loc: Location,\n     gen_set.to_dense()\n }\n \n-pub struct DataflowAnalysis<'a, 'tcx: 'a, O> where O: BitDenotation<'tcx>\n+pub struct DataflowAnalysis<'a, 'tcx, O>\n+where\n+    O: BitDenotation<'tcx>,\n {\n     flow_state: DataflowState<'tcx, O>,\n     dead_unwinds: &'a BitSet<mir::BasicBlock>,\n     body: &'a Body<'tcx>,\n }\n \n-impl<'a, 'tcx: 'a, O> DataflowAnalysis<'a, 'tcx, O> where O: BitDenotation<'tcx>\n+impl<'a, 'tcx, O> DataflowAnalysis<'a, 'tcx, O>\n+where\n+    O: BitDenotation<'tcx>,\n {\n     pub fn results(self) -> DataflowResults<'tcx, O> {\n         DataflowResults(self.flow_state)\n@@ -734,7 +746,10 @@ impl<'a, 'tcx, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation<'tcx>\n     }\n }\n \n-impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation<'tcx> {\n+impl<'a, 'tcx, D> DataflowAnalysis<'a, 'tcx, D>\n+where\n+    D: BitDenotation<'tcx>,\n+{\n     /// Propagates the bits of `in_out` into all the successors of `bb`,\n     /// using bitwise operator denoted by `self.operator`.\n     ///"}, {"sha": "e8386e8fef11bfd1907ba0a0ffbb2f1a04531327", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -12,7 +12,7 @@ use super::{LocationMap, MoveData, MovePath, MovePathLookup, MovePathIndex, Move\n use super::{MoveError, InitIndex, Init, InitLocation, LookupResult, InitKind};\n use super::IllegalMoveOriginKind::*;\n \n-struct MoveDataBuilder<'a, 'tcx: 'a> {\n+struct MoveDataBuilder<'a, 'tcx> {\n     body: &'a Body<'tcx>,\n     tcx: TyCtxt<'tcx>,\n     data: MoveData<'tcx>,\n@@ -253,7 +253,7 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n     }\n }\n \n-struct Gatherer<'b, 'a: 'b, 'tcx: 'a> {\n+struct Gatherer<'b, 'a, 'tcx> {\n     builder: &'b mut MoveDataBuilder<'a, 'tcx>,\n     loc: Location,\n }"}, {"sha": "bc01e3ee95b978871b92e9a878bee65bf62ba707", "filename": "src/librustc_mir/hair/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fconstant.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -18,7 +18,7 @@ crate fn lit_to_const<'tcx>(\n     use syntax::ast::*;\n \n     let trunc = |n| {\n-        let param_ty = ParamEnv::reveal_all().and(tcx.lift_to_global(&ty).unwrap());\n+        let param_ty = ParamEnv::reveal_all().and(ty);\n         let width = tcx.layout_of(param_ty).map_err(|_| LitToConstError::Reported)?.size;\n         trace!(\"trunc {} with size {} and shift {}\", n, width.bits(), 128 - width.bits());\n         let result = truncate(n, width);"}, {"sha": "d5932052d1aa3365731b5b63bf2e20217531107c", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -49,7 +49,7 @@ fn mirror_stmts<'a, 'tcx>(\n     for (index, stmt) in stmts.iter().enumerate() {\n         let hir_id = stmt.hir_id;\n         let opt_dxn_ext = cx.region_scope_tree.opt_destruction_scope(hir_id.local_id);\n-        let stmt_span = StatementSpan(cx.tcx.hir().span_by_hir_id(hir_id));\n+        let stmt_span = StatementSpan(cx.tcx.hir().span(hir_id));\n         match stmt.node {\n             hir::StmtKind::Expr(ref expr) |\n             hir::StmtKind::Semi(ref expr) => {"}, {"sha": "baf9086a4800e4a0ab184c075c5c5759f87947bd", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -763,7 +763,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n         hir::ExprKind::Array(ref fields) => ExprKind::Array { fields: fields.to_ref() },\n         hir::ExprKind::Tup(ref fields) => ExprKind::Tuple { fields: fields.to_ref() },\n \n-        hir::ExprKind::Yield(ref v) => ExprKind::Yield { value: v.to_ref() },\n+        hir::ExprKind::Yield(ref v, _) => ExprKind::Yield { value: v.to_ref() },\n         hir::ExprKind::Err => unreachable!(),\n     };\n \n@@ -908,12 +908,13 @@ fn convert_path_expr<'a, 'tcx>(\n         }\n \n         Res::Def(DefKind::ConstParam, def_id) => {\n-            let node_id = cx.tcx.hir().as_local_node_id(def_id).unwrap();\n-            let item_id = cx.tcx.hir().get_parent_node(node_id);\n-            let item_def_id = cx.tcx.hir().local_def_id(item_id);\n+            let hir_id = cx.tcx.hir().as_local_hir_id(def_id).unwrap();\n+            let item_id = cx.tcx.hir().get_parent_node_by_hir_id(hir_id);\n+            let item_def_id = cx.tcx.hir().local_def_id_from_hir_id(item_id);\n             let generics = cx.tcx.generics_of(item_def_id);\n-            let index = generics.param_def_id_to_index[&cx.tcx.hir().local_def_id(node_id)];\n-            let name = cx.tcx.hir().name(node_id).as_interned_str();\n+            let local_def_id = cx.tcx.hir().local_def_id_from_hir_id(hir_id);\n+            let index = generics.param_def_id_to_index[&local_def_id];\n+            let name = cx.tcx.hir().name_by_hir_id(hir_id).as_interned_str();\n             let val = ConstValue::Param(ty::ParamConst::new(index, name));\n             ExprKind::Literal {\n                 literal: cx.tcx.mk_const("}, {"sha": "4e197f1ed4ecf8aa82c37c9215014ea67b1bf076", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -21,7 +21,7 @@ use rustc::hir;\n use crate::hair::constant::{lit_to_const, LitToConstError};\n \n #[derive(Clone)]\n-pub struct Cx<'a, 'tcx: 'a> {\n+pub struct Cx<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     infcx: &'a InferCtxt<'a, 'tcx>,\n \n@@ -56,7 +56,7 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n         let tcx = infcx.tcx;\n         let src_def_id = tcx.hir().local_def_id_from_hir_id(src_id);\n         let tables = tcx.typeck_tables_of(src_def_id);\n-        let body_owner_kind = tcx.hir().body_owner_kind_by_hir_id(src_id);\n+        let body_owner_kind = tcx.hir().body_owner_kind(src_id);\n \n         let constness = match body_owner_kind {\n             hir::BodyOwnerKind::Const |\n@@ -65,7 +65,7 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n             hir::BodyOwnerKind::Fn => hir::Constness::NotConst,\n         };\n \n-        let attrs = tcx.hir().attrs_by_hir_id(src_id);\n+        let attrs = tcx.hir().attrs(src_id);\n \n         // Some functions always have overflow checks enabled,\n         // however, they may not get codegen'd, depending on\n@@ -190,12 +190,7 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n     }\n \n     pub fn needs_drop(&mut self, ty: Ty<'tcx>) -> bool {\n-        let (ty, param_env) = self.tcx.lift_to_global(&(ty, self.param_env)).unwrap_or_else(|| {\n-            bug!(\"MIR: Cx::needs_drop({:?}, {:?}) got \\\n-                  type with inference types/regions\",\n-                 ty, self.param_env);\n-        });\n-        ty.needs_drop(self.tcx.global_tcx(), param_env)\n+        ty.needs_drop(self.tcx.global_tcx(), self.param_env)\n     }\n \n     pub fn tcx(&self) -> TyCtxt<'tcx> {"}, {"sha": "946d66fc91d7d21b53fd4e05a419b471b4dacc7e", "filename": "src/librustc_mir/hair/cx/to_ref.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fhair%2Fcx%2Fto_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fhair%2Fcx%2Fto_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fto_ref.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -8,32 +8,33 @@ pub trait ToRef {\n     fn to_ref(self) -> Self::Output;\n }\n \n-impl<'a, 'tcx: 'a> ToRef for &'tcx hir::Expr {\n+impl<'tcx> ToRef for &'tcx hir::Expr {\n     type Output = ExprRef<'tcx>;\n \n     fn to_ref(self) -> ExprRef<'tcx> {\n         ExprRef::Hair(self)\n     }\n }\n \n-impl<'a, 'tcx: 'a> ToRef for &'tcx P<hir::Expr> {\n+impl<'tcx> ToRef for &'tcx P<hir::Expr> {\n     type Output = ExprRef<'tcx>;\n \n     fn to_ref(self) -> ExprRef<'tcx> {\n         ExprRef::Hair(&**self)\n     }\n }\n \n-impl<'a, 'tcx: 'a> ToRef for Expr<'tcx> {\n+impl<'tcx> ToRef for Expr<'tcx> {\n     type Output = ExprRef<'tcx>;\n \n     fn to_ref(self) -> ExprRef<'tcx> {\n         ExprRef::Mirror(Box::new(self))\n     }\n }\n \n-impl<'a, 'tcx: 'a, T, U> ToRef for &'tcx Option<T>\n-    where &'tcx T: ToRef<Output = U>\n+impl<'tcx, T, U> ToRef for &'tcx Option<T>\n+where\n+    &'tcx T: ToRef<Output = U>,\n {\n     type Output = Option<U>;\n \n@@ -42,8 +43,9 @@ impl<'a, 'tcx: 'a, T, U> ToRef for &'tcx Option<T>\n     }\n }\n \n-impl<'a, 'tcx: 'a, T, U> ToRef for &'tcx Vec<T>\n-    where &'tcx T: ToRef<Output = U>\n+impl<'tcx, T, U> ToRef for &'tcx Vec<T>\n+where\n+    &'tcx T: ToRef<Output = U>,\n {\n     type Output = Vec<U>;\n \n@@ -52,8 +54,9 @@ impl<'a, 'tcx: 'a, T, U> ToRef for &'tcx Vec<T>\n     }\n }\n \n-impl<'a, 'tcx: 'a, T, U> ToRef for &'tcx P<[T]>\n-    where &'tcx T: ToRef<Output = U>\n+impl<'tcx, T, U> ToRef for &'tcx P<[T]>\n+where\n+    &'tcx T: ToRef<Output = U>,\n {\n     type Output = Vec<U>;\n "}, {"sha": "974c863792eed90d1afde41332a145c004fc476b", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 40, "deletions": 35, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -215,10 +215,15 @@ impl LiteralExpander<'tcx> {\n         debug!(\"fold_const_value_deref {:?} {:?} {:?}\", val, rty, crty);\n         match (val, &crty.sty, &rty.sty) {\n             // the easy case, deref a reference\n-            (ConstValue::Scalar(Scalar::Ptr(p)), x, y) if x == y => ConstValue::ByRef(\n-                p,\n-                self.tcx.alloc_map.lock().unwrap_memory(p.alloc_id),\n-            ),\n+            (ConstValue::Scalar(Scalar::Ptr(p)), x, y) if x == y => {\n+                let alloc = self.tcx.alloc_map.lock().unwrap_memory(p.alloc_id);\n+                ConstValue::ByRef(\n+                    p,\n+                    // FIXME(oli-obk): this should be the type's layout\n+                    alloc.align,\n+                    alloc,\n+                )\n+            },\n             // unsize array to slice if pattern is array but match value or other patterns are slice\n             (ConstValue::Scalar(Scalar::Ptr(p)), ty::Array(t, n), ty::Slice(u)) => {\n                 assert_eq!(t, u);\n@@ -285,7 +290,7 @@ impl<'tcx> Pattern<'tcx> {\n \n /// A 2D matrix. Nx1 matrices are very common, which is why `SmallVec[_; 2]`\n /// works well for each row.\n-pub struct Matrix<'p, 'tcx: 'p>(Vec<SmallVec<[&'p Pattern<'tcx>; 2]>>);\n+pub struct Matrix<'p, 'tcx>(Vec<SmallVec<[&'p Pattern<'tcx>; 2]>>);\n \n impl<'p, 'tcx> Matrix<'p, 'tcx> {\n     pub fn empty() -> Self {\n@@ -349,7 +354,7 @@ impl<'p, 'tcx> FromIterator<SmallVec<[&'p Pattern<'tcx>; 2]>> for Matrix<'p, 'tc\n     }\n }\n \n-pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n+pub struct MatchCheckCtxt<'a, 'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n     /// The module in which the match occurs. This is necessary for\n     /// checking inhabited-ness of types because whether a type is (visibly)\n@@ -392,9 +397,7 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn is_non_exhaustive_variant<'p>(&self, pattern: &'p Pattern<'tcx>) -> bool\n-        where 'a: 'p\n-    {\n+    fn is_non_exhaustive_variant<'p>(&self, pattern: &'p Pattern<'tcx>) -> bool {\n         match *pattern.kind {\n             PatternKind::Variant { adt_def, variant_index, .. } => {\n                 let ref variant = adt_def.variants[variant_index];\n@@ -634,10 +637,10 @@ impl<'tcx> Witness<'tcx> {\n ///\n /// We make sure to omit constructors that are statically impossible. E.g., for\n /// `Option<!>`, we do not include `Some(_)` in the returned list of constructors.\n-fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-                                  pcx: PatternContext<'tcx>)\n-                                  -> Vec<Constructor<'tcx>>\n-{\n+fn all_constructors<'a, 'tcx>(\n+    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+    pcx: PatternContext<'tcx>,\n+) -> Vec<Constructor<'tcx>> {\n     debug!(\"all_constructors({:?})\", pcx.ty);\n     let ctors = match pcx.ty.sty {\n         ty::Bool => {\n@@ -708,10 +711,10 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     ctors\n }\n \n-fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n-    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-    patterns: I) -> u64\n-    where I: Iterator<Item=&'p Pattern<'tcx>>\n+fn max_slice_length<'p, 'a, 'tcx, I>(cx: &mut MatchCheckCtxt<'a, 'tcx>, patterns: I) -> u64\n+where\n+    I: Iterator<Item = &'p Pattern<'tcx>>,\n+    'tcx: 'p,\n {\n     // The exhaustiveness-checking paper does not include any details on\n     // checking variable-length slice patterns. However, they are matched\n@@ -985,7 +988,7 @@ enum MissingCtors<'tcx> {\n // (The split logic gives a performance win, because we always need to know if\n // the set is empty, but we rarely need the full set, and it can be expensive\n // to compute the full set.)\n-fn compute_missing_ctors<'a, 'tcx: 'a>(\n+fn compute_missing_ctors<'tcx>(\n     info: MissingCtorsInfo,\n     tcx: TyCtxt<'tcx>,\n     all_ctors: &Vec<Constructor<'tcx>>,\n@@ -1057,11 +1060,12 @@ fn compute_missing_ctors<'a, 'tcx: 'a>(\n /// relation to preceding patterns, it is not reachable) and exhaustiveness\n /// checking (if a wildcard pattern is useful in relation to a matrix, the\n /// matrix isn't exhaustive).\n-pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-                                       matrix: &Matrix<'p, 'tcx>,\n-                                       v: &[&Pattern<'tcx>],\n-                                       witness: WitnessPreference)\n-                                       -> Usefulness<'tcx> {\n+pub fn is_useful<'p, 'a, 'tcx>(\n+    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+    matrix: &Matrix<'p, 'tcx>,\n+    v: &[&Pattern<'tcx>],\n+    witness: WitnessPreference,\n+) -> Usefulness<'tcx> {\n     let &Matrix(ref rows) = matrix;\n     debug!(\"is_useful({:#?}, {:#?})\", matrix, v);\n \n@@ -1267,7 +1271,7 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n \n /// A shorthand for the `U(S(c, P), S(c, q))` operation from the paper. I.e., `is_useful` applied\n /// to the specialised version of both the pattern matrix `P` and the new pattern `q`.\n-fn is_useful_specialized<'p, 'a: 'p, 'tcx: 'a>(\n+fn is_useful_specialized<'p, 'a, 'tcx>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     &Matrix(ref m): &Matrix<'p, 'tcx>,\n     v: &[&Pattern<'tcx>],\n@@ -1311,7 +1315,7 @@ fn is_useful_specialized<'p, 'a: 'p, 'tcx: 'a>(\n /// Returns `None` in case of a catch-all, which can't be specialized.\n fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt<'_, 'tcx>,\n                           pat: &Pattern<'tcx>,\n-                          pcx: PatternContext<'_>)\n+                          pcx: PatternContext<'tcx>)\n                           -> Option<Vec<Constructor<'tcx>>>\n {\n     match *pat.kind {\n@@ -1373,10 +1377,11 @@ fn constructor_arity(cx: &MatchCheckCtxt<'a, 'tcx>, ctor: &Constructor<'tcx>, ty\n /// expanded to.\n ///\n /// For instance, a tuple pattern (43u32, 'a') has sub pattern types [u32, char].\n-fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n-                                             ctor: &Constructor<'tcx>,\n-                                             ty: Ty<'tcx>) -> Vec<Ty<'tcx>>\n-{\n+fn constructor_sub_pattern_tys<'a, 'tcx>(\n+    cx: &MatchCheckCtxt<'a, 'tcx>,\n+    ctor: &Constructor<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> Vec<Ty<'tcx>> {\n     debug!(\"constructor_sub_pattern_tys({:#?}, {:?})\", ctor, ty);\n     match ty.sty {\n         ty::Tuple(ref fs) => fs.into_iter().map(|t| t.expect_ty()).collect(),\n@@ -1431,7 +1436,7 @@ fn slice_pat_covered_by_const<'tcx>(\n     suffix: &[Pattern<'tcx>],\n ) -> Result<bool, ErrorReported> {\n     let data: &[u8] = match (const_val.val, &const_val.ty.sty) {\n-        (ConstValue::ByRef(ptr, alloc), ty::Array(t, n)) => {\n+        (ConstValue::ByRef(ptr, _, alloc), ty::Array(t, n)) => {\n             assert_eq!(*t, tcx.types.u8);\n             let n = n.assert_usize(tcx).unwrap();\n             alloc.get_bytes(&tcx, ptr, Size::from_bytes(n)).unwrap()\n@@ -1520,7 +1525,7 @@ fn should_treat_range_exhaustively(tcx: TyCtxt<'tcx>, ctor: &Constructor<'tcx>)\n /// boundaries for each interval range, sort them, then create constructors for each new interval\n /// between every pair of boundary points. (This essentially sums up to performing the intuitive\n /// merging operation depicted above.)\n-fn split_grouped_constructors<'p, 'a: 'p, 'tcx: 'a>(\n+fn split_grouped_constructors<'p, 'tcx>(\n     tcx: TyCtxt<'tcx>,\n     ctors: Vec<Constructor<'tcx>>,\n     &Matrix(ref m): &Matrix<'p, 'tcx>,\n@@ -1598,7 +1603,7 @@ fn split_grouped_constructors<'p, 'a: 'p, 'tcx: 'a>(\n }\n \n /// Checks whether there exists any shared value in either `ctor` or `pat` by intersecting them.\n-fn constructor_intersects_pattern<'p, 'a: 'p, 'tcx: 'a>(\n+fn constructor_intersects_pattern<'p, 'tcx>(\n     tcx: TyCtxt<'tcx>,\n     ctor: &Constructor<'tcx>,\n     pat: &'p Pattern<'tcx>,\n@@ -1688,7 +1693,7 @@ fn constructor_covered_by_range<'tcx>(\n     }\n }\n \n-fn patterns_for_variant<'p, 'a: 'p, 'tcx: 'a>(\n+fn patterns_for_variant<'p, 'tcx>(\n     subpatterns: &'p [FieldPattern<'tcx>],\n     wild_patterns: &[&'p Pattern<'tcx>])\n     -> SmallVec<[&'p Pattern<'tcx>; 2]>\n@@ -1711,7 +1716,7 @@ fn patterns_for_variant<'p, 'a: 'p, 'tcx: 'a>(\n /// different patterns.\n /// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n /// fields filled with wild patterns.\n-fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n+fn specialize<'p, 'a: 'p, 'tcx>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     r: &[&'p Pattern<'tcx>],\n     constructor: &Constructor<'tcx>,\n@@ -1753,7 +1758,7 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                     let (alloc, offset, n, ty) = match value.ty.sty {\n                         ty::Array(t, n) => {\n                             match value.val {\n-                                ConstValue::ByRef(ptr, alloc) => (\n+                                ConstValue::ByRef(ptr, _, alloc) => (\n                                     alloc,\n                                     ptr.offset,\n                                     n.unwrap_usize(cx.tcx),"}, {"sha": "ed850379af60b49a9d9faed48181bb343788aedd", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -47,7 +47,7 @@ fn create_e0004<'a>(sess: &'a Session, sp: Span, error_message: String) -> Diagn\n     struct_span_err!(sess, sp, E0004, \"{}\", &error_message)\n }\n \n-struct MatchVisitor<'a, 'tcx: 'a> {\n+struct MatchVisitor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body_owner: DefId,\n     tables: &'a ty::TypeckTables<'tcx>,\n@@ -161,7 +161,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             }\n         }\n \n-        let module = self.tcx.hir().get_module_parent_by_hir_id(scrut.hir_id);\n+        let module = self.tcx.hir().get_module_parent(scrut.hir_id);\n         MatchCheckCtxt::create_and_enter(self.tcx, self.param_env, module, |ref mut cx| {\n             let mut have_errors = false;\n \n@@ -193,7 +193,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             // Then, if the match has no arms, check whether the scrutinee\n             // is uninhabited.\n             let pat_ty = self.tables.node_type(scrut.hir_id);\n-            let module = self.tcx.hir().get_module_parent_by_hir_id(scrut.hir_id);\n+            let module = self.tcx.hir().get_module_parent(scrut.hir_id);\n             let mut def_span = None;\n             let mut missing_variants = vec![];\n             if inlined_arms.is_empty() {\n@@ -261,7 +261,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n     }\n \n     fn check_irrefutable(&self, pat: &'tcx Pat, origin: &str) {\n-        let module = self.tcx.hir().get_module_parent_by_hir_id(pat.hir_id);\n+        let module = self.tcx.hir().get_module_parent(pat.hir_id);\n         MatchCheckCtxt::create_and_enter(self.tcx, self.param_env, module, |ref mut cx| {\n             let mut patcx = PatternContext::new(self.tcx,\n                                                 self.param_env.and(self.identity_substs),\n@@ -439,7 +439,7 @@ fn check_arms<'a, 'tcx>(\n     }\n }\n \n-fn check_exhaustive<'p, 'a: 'p, 'tcx: 'a>(\n+fn check_exhaustive<'p, 'a, 'tcx>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     scrut_ty: Ty<'tcx>,\n     sp: Span,\n@@ -642,7 +642,7 @@ fn check_for_mutation_in_guard(cx: &MatchVisitor<'_, '_>, guard: &hir::Guard) {\n     };\n }\n \n-struct MutationChecker<'a, 'tcx: 'a> {\n+struct MutationChecker<'a, 'tcx> {\n     cx: &'a MatchVisitor<'a, 'tcx>,\n }\n \n@@ -691,7 +691,7 @@ fn check_legality_of_bindings_in_at_patterns(cx: &MatchVisitor<'_, '_>, pat: &Pa\n     AtBindingPatternVisitor { cx: cx, bindings_allowed: true }.visit_pat(pat);\n }\n \n-struct AtBindingPatternVisitor<'a, 'b:'a, 'tcx:'b> {\n+struct AtBindingPatternVisitor<'a, 'b, 'tcx> {\n     cx: &'a MatchVisitor<'b, 'tcx>,\n     bindings_allowed: bool\n }"}, {"sha": "cf597ce0b6319b2aca2b75ef524adbd955135e04", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -326,7 +326,7 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n     }\n }\n \n-pub struct PatternContext<'a, 'tcx: 'a> {\n+pub struct PatternContext<'a, 'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n     pub param_env: ty::ParamEnv<'tcx>,\n     pub tables: &'a ty::TypeckTables<'tcx>,"}, {"sha": "4afa4a0cbb3d74bba5810c1b7033fb04dfd21659", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -49,7 +49,7 @@ pub struct InterpretCx<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n \n /// A stack frame.\n #[derive(Clone)]\n-pub struct Frame<'mir, 'tcx: 'mir, Tag=(), Extra=()> {\n+pub struct Frame<'mir, 'tcx, Tag=(), Extra=()> {\n     ////////////////////////////////////////////////////////////////////////////////\n     // Function and callsite information\n     ////////////////////////////////////////////////////////////////////////////////\n@@ -195,7 +195,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf for InterpretCx<'mir, 'tcx, M>\n     }\n }\n \n-impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n     pub fn new(tcx: TyCtxtAt<'tcx>, param_env: ty::ParamEnv<'tcx>, machine: M) -> Self {\n         InterpretCx {\n             machine,\n@@ -576,7 +576,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n                     self.place_to_op(return_place)?,\n                     vec![],\n                     None,\n-                    /*const_mode*/false,\n                 )?;\n             }\n         } else {\n@@ -641,6 +640,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n         &self,\n         gid: GlobalId<'tcx>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+        // FIXME(oli-obk): make this check an assertion that it's not a static here\n+        // FIXME(RalfJ, oli-obk): document that `Place::Static` can never be anything but a static\n+        // and `ConstValue::Unevaluated` can never be a static\n         let param_env = if self.tcx.is_static(gid.instance.def_id()) {\n             ty::ParamEnv::reveal_all()\n         } else {"}, {"sha": "d998f40c86eccf4665f5b80e7a8ab38fb3b1433c", "filename": "src/librustc_mir/interpret/intern.rs", "status": "added", "additions": 333, "deletions": 0, "changes": 333, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -0,0 +1,333 @@\n+//! This module specifies the type based interner for constants.\n+//!\n+//! After a const evaluation has computed a value, before we destroy the const evaluator's session\n+//! memory, we need to extract all memory allocations to the global memory pool so they stay around.\n+\n+use rustc::ty::layout::LayoutOf;\n+use rustc::ty::{Ty, TyCtxt, ParamEnv, self};\n+use rustc::mir::interpret::{\n+    InterpResult, ErrorHandled,\n+};\n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n+use super::validity::RefTracking;\n+use rustc_data_structures::fx::FxHashSet;\n+\n+use syntax::ast::Mutability;\n+use syntax_pos::Span;\n+\n+use super::{\n+    ValueVisitor, MemoryKind, Pointer, AllocId, MPlaceTy, InterpError, Scalar,\n+};\n+use crate::const_eval::{CompileTimeInterpreter, CompileTimeEvalContext};\n+\n+struct InternVisitor<'rt, 'mir: 'rt, 'tcx: 'rt + 'mir> {\n+    /// previously encountered safe references\n+    ref_tracking: &'rt mut RefTracking<(MPlaceTy<'tcx>, Mutability, InternMode)>,\n+    ecx: &'rt mut CompileTimeEvalContext<'mir, 'tcx>,\n+    param_env: ParamEnv<'tcx>,\n+    /// The root node of the value that we're looking at. This field is never mutated and only used\n+    /// for sanity assertions that will ICE when `const_qualif` screws up.\n+    mode: InternMode,\n+    /// This field stores the mutability of the value *currently* being checked.\n+    /// It is set to mutable when an `UnsafeCell` is encountered\n+    /// When recursing across a reference, we don't recurse but store the\n+    /// value to be checked in `ref_tracking` together with the mutability at which we are checking\n+    /// the value.\n+    /// When encountering an immutable reference, we treat everything as immutable that is behind\n+    /// it.\n+    mutability: Mutability,\n+    /// A list of all encountered relocations. After type-based interning, we traverse this list to\n+    /// also intern allocations that are only referenced by a raw pointer or inside a union.\n+    leftover_relocations: &'rt mut FxHashSet<AllocId>,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Hash, Eq)]\n+enum InternMode {\n+    /// Mutable references must in fact be immutable due to their surrounding immutability in a\n+    /// `static`. In a `static mut` we start out as mutable and thus can also contain further `&mut`\n+    /// that will actually be treated as mutable.\n+    Static,\n+    /// UnsafeCell is OK in the value of a constant, but not behind references in a constant\n+    ConstBase,\n+    /// `UnsafeCell` ICEs\n+    Const,\n+}\n+\n+/// Signalling data structure to ensure we don't recurse\n+/// into the memory of other constants or statics\n+struct IsStaticOrFn;\n+\n+impl<'rt, 'mir, 'tcx> InternVisitor<'rt, 'mir, 'tcx> {\n+    /// Intern an allocation without looking at its children\n+    fn intern_shallow(\n+        &mut self,\n+        ptr: Pointer,\n+        mutability: Mutability,\n+    ) -> InterpResult<'tcx, Option<IsStaticOrFn>> {\n+        trace!(\n+            \"InternVisitor::intern {:?} with {:?}\",\n+            ptr, mutability,\n+        );\n+        // remove allocation\n+        let tcx = self.ecx.tcx;\n+        let memory = self.ecx.memory_mut();\n+        let (kind, mut alloc) = match memory.alloc_map.remove(&ptr.alloc_id) {\n+            Some(entry) => entry,\n+            None => {\n+                // if the pointer is dangling (neither in local nor global memory), we leave it\n+                // to validation to error. The `delay_span_bug` ensures that we don't forget such\n+                // a check in validation.\n+                if tcx.alloc_map.lock().get(ptr.alloc_id).is_none() {\n+                    tcx.sess.delay_span_bug(self.ecx.tcx.span, \"tried to intern dangling pointer\");\n+                }\n+                // treat dangling pointers like other statics\n+                // just to stop trying to recurse into them\n+                return Ok(Some(IsStaticOrFn));\n+            },\n+        };\n+        // This match is just a canary for future changes to `MemoryKind`, which most likely need\n+        // changes in this function.\n+        match kind {\n+            MemoryKind::Stack | MemoryKind::Vtable => {},\n+        }\n+        // Ensure llvm knows to only put this into immutable memory if the value is immutable either\n+        // by being behind a reference or by being part of a static or const without interior\n+        // mutability\n+        alloc.mutability = mutability;\n+        // link the alloc id to the actual allocation\n+        let alloc = tcx.intern_const_alloc(alloc);\n+        self.leftover_relocations.extend(alloc.relocations.iter().map(|&(_, ((), reloc))| reloc));\n+        tcx.alloc_map.lock().set_alloc_id_memory(ptr.alloc_id, alloc);\n+        Ok(None)\n+    }\n+}\n+\n+impl<'rt, 'mir, 'tcx>\n+    ValueVisitor<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>\n+for\n+    InternVisitor<'rt, 'mir, 'tcx>\n+{\n+    type V = MPlaceTy<'tcx>;\n+\n+    #[inline(always)]\n+    fn ecx(&self) -> &CompileTimeEvalContext<'mir, 'tcx> {\n+        &self.ecx\n+    }\n+\n+    fn visit_aggregate(\n+        &mut self,\n+        mplace: MPlaceTy<'tcx>,\n+        fields: impl Iterator<Item=InterpResult<'tcx, Self::V>>,\n+    ) -> InterpResult<'tcx> {\n+        if let Some(def) = mplace.layout.ty.ty_adt_def() {\n+            if Some(def.did) == self.ecx.tcx.lang_items().unsafe_cell_type() {\n+                // We are crossing over an `UnsafeCell`, we can mutate again\n+                let old = std::mem::replace(&mut self.mutability, Mutability::Mutable);\n+                assert_ne!(\n+                    self.mode, InternMode::Const,\n+                    \"UnsafeCells are not allowed behind references in constants. This should have \\\n+                    been prevented statically by const qualification. If this were allowed one \\\n+                    would be able to change a constant at one use site and other use sites may \\\n+                    arbitrarily decide to change, too.\",\n+                );\n+                let walked = self.walk_aggregate(mplace, fields);\n+                self.mutability = old;\n+                return walked;\n+            }\n+        }\n+        self.walk_aggregate(mplace, fields)\n+    }\n+\n+    fn visit_primitive(&mut self, mplace: MPlaceTy<'tcx>) -> InterpResult<'tcx> {\n+        // Handle Reference types, as these are the only relocations supported by const eval.\n+        // Raw pointers (and boxes) are handled by the `leftover_relocations` logic.\n+        let ty = mplace.layout.ty;\n+        if let ty::Ref(_, _, mutability) = ty.sty {\n+            let value = self.ecx.read_immediate(mplace.into())?;\n+            // Handle trait object vtables\n+            if let Ok(meta) = value.to_meta() {\n+                let layout = self.ecx.layout_of(ty.builtin_deref(true).unwrap().ty)?;\n+                if layout.is_unsized() {\n+                    if let ty::Dynamic(..) = self.ecx.tcx.struct_tail(layout.ty).sty {\n+                        if let Ok(vtable) = meta.unwrap().to_ptr() {\n+                            // explitly choose `Immutable` here, since vtables are immutable, even\n+                            // if the reference of the fat pointer is mutable\n+                            self.intern_shallow(vtable, Mutability::Immutable)?;\n+                        }\n+                    }\n+                }\n+            }\n+            let mplace = self.ecx.ref_to_mplace(value)?;\n+            // Check if we have encountered this pointer+layout combination before.\n+            // Only recurse for allocation-backed pointers.\n+            if let Scalar::Ptr(ptr) = mplace.ptr {\n+                // We do not have any `frozen` logic here, because it's essentially equivalent to\n+                // the mutability except for the outermost item. Only `UnsafeCell` can \"unfreeze\",\n+                // and we check that in `visit_aggregate`.\n+                // This is not an inherent limitation, but one that we know to be true, because\n+                // const qualification enforces it. We can lift it in the future.\n+                match (self.mode, mutability) {\n+                    // immutable references are fine everywhere\n+                    (_, hir::Mutability::MutImmutable) => {},\n+                    // all is \"good and well\" in the unsoundness of `static mut`\n+\n+                    // mutable references are ok in `static`. Either they are treated as immutable\n+                    // because they are behind an immutable one, or they are behind an `UnsafeCell`\n+                    // and thus ok.\n+                    (InternMode::Static, hir::Mutability::MutMutable) => {},\n+                    // we statically prevent `&mut T` via `const_qualif` and double check this here\n+                    (InternMode::ConstBase, hir::Mutability::MutMutable) |\n+                    (InternMode::Const, hir::Mutability::MutMutable) =>\n+                        bug!(\"const qualif failed to prevent mutable references\"),\n+                }\n+                // Compute the mutability with which we'll start visiting the allocation. This is\n+                // what gets changed when we encounter an `UnsafeCell`\n+                let mutability = match (self.mutability, mutability) {\n+                    // The only way a mutable reference actually works as a mutable reference is\n+                    // by being in a `static mut` directly or behind another mutable reference.\n+                    // If there's an immutable reference or we are inside a static, then our\n+                    // mutable reference is equivalent to an immutable one. As an example:\n+                    // `&&mut Foo` is semantically equivalent to `&&Foo`\n+                    (Mutability::Mutable, hir::Mutability::MutMutable) => Mutability::Mutable,\n+                    _ => Mutability::Immutable,\n+                };\n+                // Compute the mutability of the allocation\n+                let intern_mutability = intern_mutability(\n+                    self.ecx.tcx.tcx,\n+                    self.param_env,\n+                    mplace.layout.ty,\n+                    self.ecx.tcx.span,\n+                    mutability,\n+                );\n+                // Recursing behind references changes the intern mode for constants in order to\n+                // cause assertions to trigger if we encounter any `UnsafeCell`s.\n+                let mode = match self.mode {\n+                    InternMode::ConstBase => InternMode::Const,\n+                    other => other,\n+                };\n+                match self.intern_shallow(ptr, intern_mutability)? {\n+                    // No need to recurse, these are interned already and statics may have\n+                    // cycles, so we don't want to recurse there\n+                    Some(IsStaticOrFn) => {},\n+                    // intern everything referenced by this value. The mutability is taken from the\n+                    // reference. It is checked above that mutable references only happen in\n+                    // `static mut`\n+                    None => self.ref_tracking.track((mplace, mutability, mode), || ()),\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+/// Figure out the mutability of the allocation.\n+/// Mutable if it has interior mutability *anywhere* in the type.\n+fn intern_mutability<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n+    ty: Ty<'tcx>,\n+    span: Span,\n+    mutability: Mutability,\n+) -> Mutability {\n+    let has_interior_mutability = !ty.is_freeze(tcx, param_env, span);\n+    if has_interior_mutability {\n+        Mutability::Mutable\n+    } else {\n+        mutability\n+    }\n+}\n+\n+pub fn intern_const_alloc_recursive(\n+    ecx: &mut CompileTimeEvalContext<'mir, 'tcx>,\n+    def_id: DefId,\n+    ret: MPlaceTy<'tcx>,\n+    // FIXME(oli-obk): can we scrap the param env? I think we can, the final value of a const eval\n+    // must always be monomorphic, right?\n+    param_env: ty::ParamEnv<'tcx>,\n+) -> InterpResult<'tcx> {\n+    let tcx = ecx.tcx;\n+    // this `mutability` is the mutability of the place, ignoring the type\n+    let (mutability, base_intern_mode) = match tcx.static_mutability(def_id) {\n+        Some(hir::Mutability::MutImmutable) => (Mutability::Immutable, InternMode::Static),\n+        None => (Mutability::Immutable, InternMode::ConstBase),\n+        // `static mut` doesn't care about interior mutability, it's mutable anyway\n+        Some(hir::Mutability::MutMutable) => (Mutability::Mutable, InternMode::Static),\n+    };\n+\n+    // type based interning\n+    let mut ref_tracking = RefTracking::new((ret, mutability, base_intern_mode));\n+    let leftover_relocations = &mut FxHashSet::default();\n+\n+    // This mutability is the combination of the place mutability and the type mutability. If either\n+    // is mutable, `alloc_mutability` is mutable. This exists because the entire allocation needs\n+    // to be mutable if it contains an `UnsafeCell` anywhere. The other `mutability` exists so that\n+    // the visitor does not treat everything outside the `UnsafeCell` as mutable.\n+    let alloc_mutability = intern_mutability(\n+        tcx.tcx, param_env, ret.layout.ty, tcx.span, mutability,\n+    );\n+\n+    // start with the outermost allocation\n+    InternVisitor {\n+        ref_tracking: &mut ref_tracking,\n+        ecx,\n+        mode: base_intern_mode,\n+        leftover_relocations,\n+        param_env,\n+        mutability,\n+    }.intern_shallow(ret.ptr.to_ptr()?, alloc_mutability)?;\n+\n+    while let Some(((mplace, mutability, mode), _)) = ref_tracking.todo.pop() {\n+        let interned = InternVisitor {\n+            ref_tracking: &mut ref_tracking,\n+            ecx,\n+            mode,\n+            leftover_relocations,\n+            param_env,\n+            mutability,\n+        }.visit_value(mplace);\n+        if let Err(error) = interned {\n+            // This can happen when e.g. the tag of an enum is not a valid discriminant. We do have\n+            // to read enum discriminants in order to find references in enum variant fields.\n+            if let InterpError::ValidationFailure(_) = error.kind {\n+                let err = crate::const_eval::error_to_const_error(&ecx, error);\n+                match err.struct_error(ecx.tcx, \"it is undefined behavior to use this value\") {\n+                    Ok(mut diag) => {\n+                        diag.note(\"The rules on what exactly is undefined behavior aren't clear, \\\n+                            so this check might be overzealous. Please open an issue on the rust \\\n+                            compiler repository if you believe it should not be considered \\\n+                            undefined behavior\",\n+                        );\n+                        diag.emit();\n+                    }\n+                    Err(ErrorHandled::TooGeneric) |\n+                    Err(ErrorHandled::Reported) => {},\n+                }\n+            }\n+        }\n+    }\n+\n+    // Intern the rest of the allocations as mutable. These might be inside unions, padding, raw\n+    // pointers, ... So we can't intern them according to their type rules\n+\n+    let mut todo: Vec<_> = leftover_relocations.iter().cloned().collect();\n+    while let Some(alloc_id) = todo.pop() {\n+        if let Some((_, alloc)) = ecx.memory_mut().alloc_map.remove(&alloc_id) {\n+            // We can't call the `intern` method here, as its logic is tailored to safe references.\n+            // So we hand-roll the interning logic here again\n+            let alloc = tcx.intern_const_alloc(alloc);\n+            tcx.alloc_map.lock().set_alloc_id_memory(alloc_id, alloc);\n+            for &(_, ((), reloc)) in alloc.relocations.iter() {\n+                if leftover_relocations.insert(reloc) {\n+                    todo.push(reloc);\n+                }\n+            }\n+        } else if ecx.memory().dead_alloc_map.contains_key(&alloc_id) {\n+            // dangling pointer\n+            return err!(ValidationFailure(\n+                \"encountered dangling pointer in final constant\".into(),\n+            ))\n+        }\n+    }\n+    Ok(())\n+}"}, {"sha": "f207cfc6b39cde6b99238a0749ba77921f24efa3", "filename": "src/librustc_mir/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -31,9 +31,9 @@ impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n         Ok(self)\n     }\n \n-    fn print_type(self, ty: Ty<'tcx>) -> Result<Self::Type, Self::Error> {\n+    fn print_type(mut self, ty: Ty<'tcx>) -> Result<Self::Type, Self::Error> {\n         match ty.sty {\n-            // types without identity\n+            // Types without identity.\n             | ty::Bool\n             | ty::Char\n             | ty::Int(_)\n@@ -48,28 +48,33 @@ impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n             | ty::Never\n             | ty::Tuple(_)\n             | ty::Dynamic(_, _)\n-            | ty::Adt(..)\n-            | ty::Foreign(_)\n-            // should be unreachable, but there's no hurt in printing it (and better than ICEing)\n-            | ty::Error\n             => self.pretty_print_type(ty),\n-            | ty::Infer(_)\n-            | ty::Bound(_, _)\n+\n+            // Placeholders (all printed as `_` to uniformize them).\n             | ty::Param(_)\n+            | ty::Bound(..)\n             | ty::Placeholder(_)\n-            | ty::Projection(_)\n-            | ty::UnnormalizedProjection(_)\n-            | ty::GeneratorWitness(_)\n-            => bug!(\n-                \"{:#?} in `type_name` should not happen because we are always monomorphized\",\n-                ty,\n-            ),\n-            // types with identity (print the module path instead)\n-            | ty::FnDef(did, substs)\n-            | ty::Opaque(did, substs)\n-            => self.print_def_path(did, substs),\n-            ty::Closure(did, substs) => self.print_def_path(did, substs.substs),\n-            ty::Generator(did, substs, _) => self.print_def_path(did, substs.substs),\n+            | ty::Infer(_)\n+            | ty::Error\n+            => {\n+                write!(self, \"_\")?;\n+                Ok(self)\n+            }\n+\n+            // Types with identity (print the module path).\n+            | ty::Adt(&ty::AdtDef { did: def_id, .. }, substs)\n+            | ty::FnDef(def_id, substs)\n+            | ty::Opaque(def_id, substs)\n+            | ty::Projection(ty::ProjectionTy { item_def_id: def_id, substs })\n+            | ty::UnnormalizedProjection(ty::ProjectionTy { item_def_id: def_id, substs })\n+            | ty::Closure(def_id, ty::ClosureSubsts { substs })\n+            | ty::Generator(def_id, ty::GeneratorSubsts { substs }, _)\n+            => self.print_def_path(def_id, substs),\n+            ty::Foreign(def_id) => self.print_def_path(def_id, &[]),\n+\n+            ty::GeneratorWitness(_) => {\n+                bug!(\"type_name: unexpected `GeneratorWitness`\")\n+            }\n         }\n     }\n "}, {"sha": "de035ed779e2a97de3d9b034794b8dc09507d250", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 23, "deletions": 61, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -20,6 +20,7 @@ use super::{\n     Pointer, AllocId, Allocation, GlobalId, AllocationExtra,\n     InterpResult, Scalar, InterpError, GlobalAlloc, PointerArithmetic,\n     Machine, AllocMap, MayLeak, ErrorHandled, CheckInAllocMsg, InboundsCheck,\n+    InterpError::ValidationFailure,\n };\n \n #[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]\n@@ -55,12 +56,13 @@ pub struct Memory<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     /// the wrong type), so we let the machine override this type.\n     /// Either way, if the machine allows writing to a static, doing so will\n     /// create a copy of the static allocation here.\n-    alloc_map: M::MemoryMap,\n+    // FIXME: this should not be public, but interning currently needs access to it\n+    pub(super) alloc_map: M::MemoryMap,\n \n     /// To be able to compare pointers with NULL, and to check alignment for accesses\n     /// to ZSTs (where pointers may dangle), we keep track of the size even for allocations\n     /// that do not exist any more.\n-    dead_alloc_map: FxHashMap<AllocId, (Size, Align)>,\n+    pub(super) dead_alloc_map: FxHashMap<AllocId, (Size, Align)>,\n \n     /// Extra data added by the machine.\n     pub extra: M::MemoryExtra,\n@@ -452,9 +454,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         if let Ok(alloc) = self.get(id) {\n             return Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align));\n         }\n+        // can't do this in the match argument, we may get cycle errors since the lock would get\n+        // dropped after the match.\n+        let alloc = self.tcx.alloc_map.lock().get(id);\n         // Could also be a fn ptr or extern static\n-        match self.tcx.alloc_map.lock().get(id) {\n+        match alloc {\n             Some(GlobalAlloc::Function(..)) => Ok((Size::ZERO, Align::from_bytes(1).unwrap())),\n+            // `self.get` would also work, but can cause cycles if a static refers to itself\n             Some(GlobalAlloc::Static(did)) => {\n                 // The only way `get` couldn't have worked here is if this is an extern static\n                 assert!(self.tcx.is_foreign_item(did));\n@@ -463,14 +469,20 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 let layout = self.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n                 Ok((layout.size, layout.align.abi))\n             }\n-            _ => match liveness {\n-                InboundsCheck::MaybeDead => {\n-                    // Must be a deallocated pointer\n-                    Ok(*self.dead_alloc_map.get(&id).expect(\n-                        \"allocation missing in dead_alloc_map\"\n-                    ))\n-                },\n-                InboundsCheck::Live => err!(DanglingPointerDeref),\n+            _ => {\n+                if let Ok(alloc) = self.get(id) {\n+                    return Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align));\n+                }\n+                match liveness {\n+                    InboundsCheck::MaybeDead => {\n+                        // Must be a deallocated pointer\n+                        self.dead_alloc_map.get(&id).cloned().ok_or_else(||\n+                            ValidationFailure(\"allocation missing in dead_alloc_map\".to_string())\n+                                .into()\n+                        )\n+                    },\n+                    InboundsCheck::Live => err!(DanglingPointerDeref),\n+                }\n             },\n         }\n     }\n@@ -633,56 +645,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     }\n }\n \n-/// Interning (for CTFE)\n-impl<'mir, 'tcx, M> Memory<'mir, 'tcx, M>\n-where\n-    M: Machine<'mir, 'tcx, PointerTag = (), AllocExtra = (), MemoryExtra = ()>,\n-    // FIXME: Working around https://github.com/rust-lang/rust/issues/24159\n-    M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation)>,\n-{\n-    /// mark an allocation as static and initialized, either mutable or not\n-    pub fn intern_static(\n-        &mut self,\n-        alloc_id: AllocId,\n-        mutability: Mutability,\n-    ) -> InterpResult<'tcx> {\n-        trace!(\n-            \"mark_static_initialized {:?}, mutability: {:?}\",\n-            alloc_id,\n-            mutability\n-        );\n-        // remove allocation\n-        let (kind, mut alloc) = self.alloc_map.remove(&alloc_id).unwrap();\n-        match kind {\n-            MemoryKind::Machine(_) => bug!(\"Static cannot refer to machine memory\"),\n-            MemoryKind::Stack | MemoryKind::Vtable => {},\n-        }\n-        // ensure llvm knows not to put this into immutable memory\n-        alloc.mutability = mutability;\n-        let alloc = self.tcx.intern_const_alloc(alloc);\n-        self.tcx.alloc_map.lock().set_alloc_id_memory(alloc_id, alloc);\n-        // recurse into inner allocations\n-        for &(_, alloc) in alloc.relocations.values() {\n-            // FIXME: Reusing the mutability here is likely incorrect.  It is originally\n-            // determined via `is_freeze`, and data is considered frozen if there is no\n-            // `UnsafeCell` *immediately* in that data -- however, this search stops\n-            // at references.  So whenever we follow a reference, we should likely\n-            // assume immutability -- and we should make sure that the compiler\n-            // does not permit code that would break this!\n-            if self.alloc_map.contains_key(&alloc) {\n-                // Not yet interned, so proceed recursively\n-                self.intern_static(alloc, mutability)?;\n-            } else if self.dead_alloc_map.contains_key(&alloc) {\n-                // dangling pointer\n-                return err!(ValidationFailure(\n-                    \"encountered dangling pointer in final constant\".into(),\n-                ))\n-            }\n-        }\n-        Ok(())\n-    }\n-}\n-\n /// Reading and writing.\n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     pub fn copy("}, {"sha": "0293a8366d0837b6e84d904ca4817d1ac8f2f5ee", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -14,6 +14,7 @@ mod traits;\n mod validity;\n mod intrinsics;\n mod visitor;\n+mod intern;\n \n pub use rustc::mir::interpret::*; // have all the `interpret` symbols in one place: here\n \n@@ -34,3 +35,5 @@ pub use self::visitor::{ValueVisitor, MutValueVisitor};\n pub use self::validity::RefTracking;\n \n pub(super) use self::intrinsics::type_name;\n+\n+pub use self::intern::intern_const_alloc_recursive;"}, {"sha": "1b451e0b8f18f7e5c1cbc25e731d289dd97ad828", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -4,7 +4,9 @@\n use std::convert::TryInto;\n \n use rustc::{mir, ty};\n-use rustc::ty::layout::{self, Size, LayoutOf, TyLayout, HasDataLayout, IntegerExt, VariantIdx};\n+use rustc::ty::layout::{\n+    self, Size, LayoutOf, TyLayout, HasDataLayout, IntegerExt, VariantIdx,\n+};\n \n use rustc::mir::interpret::{\n     GlobalId, AllocId, CheckInAllocMsg,\n@@ -217,7 +219,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n     fn try_read_immediate_from_mplace(\n         &self,\n         mplace: MPlaceTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, Option<Immediate<M::PointerTag>>> {\n+    ) -> InterpResult<'tcx, Option<ImmTy<'tcx, M::PointerTag>>> {\n         if mplace.layout.is_unsized() {\n             // Don't touch unsized\n             return Ok(None);\n@@ -228,7 +230,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n             // Not all ZSTs have a layout we would handle below, so just short-circuit them\n             // all here.\n             self.memory.check_align(ptr, ptr_align)?;\n-            return Ok(Some(Immediate::Scalar(Scalar::zst().into())));\n+            return Ok(Some(ImmTy {\n+                imm: Immediate::Scalar(Scalar::zst().into()),\n+                layout: mplace.layout,\n+            }));\n         }\n \n         // check for integer pointers before alignment to report better errors\n@@ -239,7 +244,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n                 let scalar = self.memory\n                     .get(ptr.alloc_id)?\n                     .read_scalar(self, ptr, mplace.layout.size)?;\n-                Ok(Some(Immediate::Scalar(scalar)))\n+                Ok(Some(ImmTy {\n+                    imm: Immediate::Scalar(scalar),\n+                    layout: mplace.layout,\n+                }))\n             }\n             layout::Abi::ScalarPair(ref a, ref b) => {\n                 let (a, b) = (&a.value, &b.value);\n@@ -256,7 +264,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n                 let b_val = self.memory\n                     .get(ptr.alloc_id)?\n                     .read_scalar(self, b_ptr, b_size)?;\n-                Ok(Some(Immediate::ScalarPair(a_val, b_val)))\n+                Ok(Some(ImmTy {\n+                    imm: Immediate::ScalarPair(a_val, b_val),\n+                    layout: mplace.layout,\n+                }))\n             }\n             _ => Ok(None),\n         }\n@@ -271,13 +282,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n     pub(crate) fn try_read_immediate(\n         &self,\n         src: OpTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, Result<Immediate<M::PointerTag>, MemPlace<M::PointerTag>>> {\n+    ) -> InterpResult<'tcx, Result<ImmTy<'tcx, M::PointerTag>, MPlaceTy<'tcx, M::PointerTag>>> {\n         Ok(match src.try_as_mplace() {\n             Ok(mplace) => {\n                 if let Some(val) = self.try_read_immediate_from_mplace(mplace)? {\n                     Ok(val)\n                 } else {\n-                    Err(*mplace)\n+                    Err(mplace)\n                 }\n             },\n             Err(val) => Ok(val),\n@@ -291,7 +302,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n         op: OpTy<'tcx, M::PointerTag>\n     ) -> InterpResult<'tcx, ImmTy<'tcx, M::PointerTag>> {\n         if let Ok(imm) = self.try_read_immediate(op)? {\n-            Ok(ImmTy { imm, layout: op.layout })\n+            Ok(imm)\n         } else {\n             bug!(\"primitive read failed for type: {:?}\", op.layout.ty);\n         }\n@@ -339,9 +350,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n             return Ok(OpTy { op: Operand::Immediate(immediate), layout: field_layout });\n         }\n         let offset = op.layout.fields.offset(field);\n-        let immediate = match base {\n+        let immediate = match *base {\n             // the field covers the entire type\n-            _ if offset.bytes() == 0 && field_layout.size == op.layout.size => base,\n+            _ if offset.bytes() == 0 && field_layout.size == op.layout.size => *base,\n             // extract fields from types with `ScalarPair` ABI\n             Immediate::ScalarPair(a, b) => {\n                 let val = if offset.bytes() == 0 { a } else { b };\n@@ -527,11 +538,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n             self.layout_of(self.monomorphize(val.ty)?)\n         })?;\n         let op = match val.val {\n-            ConstValue::ByRef(ptr, _alloc) => {\n+            ConstValue::ByRef(ptr, align, _alloc) => {\n                 // We rely on mutability being set correctly in that allocation to prevent writes\n                 // where none should happen.\n                 let ptr = self.tag_static_base_pointer(ptr);\n-                Operand::Indirect(MemPlace::from_ptr(ptr, layout.align.abi))\n+                Operand::Indirect(MemPlace::from_ptr(ptr, align))\n             },\n             ConstValue::Scalar(x) =>\n                 Operand::Immediate(Immediate::Scalar(tag_scalar(x).into())),"}, {"sha": "1285549015cdd3ff1c0ba8febe3defbebcca0de6", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -232,10 +232,10 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n \n impl<'tcx, Tag: ::std::fmt::Debug + Copy> OpTy<'tcx, Tag> {\n     #[inline(always)]\n-    pub fn try_as_mplace(self) -> Result<MPlaceTy<'tcx, Tag>, Immediate<Tag>> {\n+    pub fn try_as_mplace(self) -> Result<MPlaceTy<'tcx, Tag>, ImmTy<'tcx, Tag>> {\n         match *self {\n             Operand::Indirect(mplace) => Ok(MPlaceTy { mplace, layout: self.layout }),\n-            Operand::Immediate(imm) => Err(imm),\n+            Operand::Immediate(imm) => Err(ImmTy { imm, layout: self.layout }),\n         }\n     }\n \n@@ -660,7 +660,7 @@ where\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(self.place_to_op(dest)?, vec![], None, /*const_mode*/false)?;\n+            self.validate_operand(self.place_to_op(dest)?, vec![], None)?;\n         }\n \n         Ok(())\n@@ -677,7 +677,7 @@ where\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(dest.into(), vec![], None, /*const_mode*/ false)?;\n+            self.validate_operand(dest.into(), vec![], None)?;\n         }\n \n         Ok(())\n@@ -809,7 +809,7 @@ where\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(self.place_to_op(dest)?, vec![], None, /*const_mode*/false)?;\n+            self.validate_operand(self.place_to_op(dest)?, vec![], None)?;\n         }\n \n         Ok(())\n@@ -836,7 +836,7 @@ where\n                 // Yay, we got a value that we can write directly.\n                 // FIXME: Add a check to make sure that if `src` is indirect,\n                 // it does not overlap with `dest`.\n-                return self.write_immediate_no_validate(src_val, dest);\n+                return self.write_immediate_no_validate(*src_val, dest);\n             }\n             Err(mplace) => mplace,\n         };\n@@ -897,7 +897,7 @@ where\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(dest.into(), vec![], None, /*const_mode*/false)?;\n+            self.validate_operand(dest.into(), vec![], None)?;\n         }\n \n         Ok(())"}, {"sha": "ad631793a082751b6ffc13f23e2240a58b3e9a0d", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -304,7 +304,7 @@ impl_stable_hash_for!(enum crate::interpret::eval_context::StackPopCleanup {\n });\n \n #[derive(Eq, PartialEq)]\n-struct FrameSnapshot<'a, 'tcx: 'a> {\n+struct FrameSnapshot<'a, 'tcx> {\n     instance: &'a ty::Instance<'tcx>,\n     span: &'a Span,\n     return_to_block: &'a StackPopCleanup,"}, {"sha": "d747eddd8d7ba6fe62968a8d28589c9766d83ab1", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 59, "deletions": 33, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -1,5 +1,4 @@\n use std::fmt::Write;\n-use std::hash::Hash;\n use std::ops::RangeInclusive;\n \n use syntax_pos::symbol::{sym, Symbol};\n@@ -11,6 +10,8 @@ use rustc::mir::interpret::{\n     Scalar, GlobalAlloc, InterpResult, InterpError, CheckInAllocMsg,\n };\n \n+use std::hash::Hash;\n+\n use super::{\n     OpTy, Machine, InterpretCx, ValueVisitor, MPlaceTy,\n };\n@@ -76,19 +77,34 @@ pub enum PathElem {\n }\n \n /// State for tracking recursive validation of references\n-pub struct RefTracking<T> {\n+pub struct RefTracking<T, PATH = ()> {\n     pub seen: FxHashSet<T>,\n-    pub todo: Vec<(T, Vec<PathElem>)>,\n+    pub todo: Vec<(T, PATH)>,\n }\n \n-impl<T: Copy + Eq + Hash> RefTracking<T> {\n+impl<T: Copy + Eq + Hash + std::fmt::Debug, PATH: Default> RefTracking<T, PATH> {\n+    pub fn empty() -> Self {\n+        RefTracking {\n+            seen: FxHashSet::default(),\n+            todo: vec![],\n+        }\n+    }\n     pub fn new(op: T) -> Self {\n-        let mut ref_tracking = RefTracking {\n+        let mut ref_tracking_for_consts = RefTracking {\n             seen: FxHashSet::default(),\n-            todo: vec![(op, Vec::new())],\n+            todo: vec![(op, PATH::default())],\n         };\n-        ref_tracking.seen.insert(op);\n-        ref_tracking\n+        ref_tracking_for_consts.seen.insert(op);\n+        ref_tracking_for_consts\n+    }\n+\n+    pub fn track(&mut self, op: T, path: impl FnOnce() -> PATH) {\n+        if self.seen.insert(op) {\n+            trace!(\"Recursing below ptr {:#?}\", op);\n+            let path = path();\n+            // Remember to come back to this later.\n+            self.todo.push((op, path));\n+        }\n     }\n }\n \n@@ -154,8 +170,10 @@ struct ValidityVisitor<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     /// starts must not be changed!  `visit_fields` and `visit_array` rely on\n     /// this stack discipline.\n     path: Vec<PathElem>,\n-    ref_tracking: Option<&'rt mut RefTracking<MPlaceTy<'tcx, M::PointerTag>>>,\n-    const_mode: bool,\n+    ref_tracking_for_consts: Option<&'rt mut RefTracking<\n+        MPlaceTy<'tcx, M::PointerTag>,\n+        Vec<PathElem>,\n+    >>,\n     ecx: &'rt InterpretCx<'mir, 'tcx, M>,\n }\n \n@@ -175,8 +193,8 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n                         // Sometimes the index is beyond the number of upvars (seen\n                         // for a generator).\n                         if let Some((&var_hir_id, _)) = upvars.get_index(field) {\n-                            let var_node_id = self.ecx.tcx.hir().hir_to_node_id(var_hir_id);\n-                            if let hir::Node::Binding(pat) = self.ecx.tcx.hir().get(var_node_id) {\n+                            let node = self.ecx.tcx.hir().get_by_hir_id(var_hir_id);\n+                            if let hir::Node::Binding(pat) = node {\n                                 if let hir::PatKind::Binding(_, _, ident, _) = pat.node {\n                                     name = Some(ident.name);\n                                 }\n@@ -314,7 +332,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 // types below!\n                 let size = value.layout.size;\n                 let value = value.to_scalar_or_undef();\n-                if self.const_mode {\n+                if self.ref_tracking_for_consts.is_some() {\n                     // Integers/floats in CTFE: Must be scalar bits, pointers are dangerous\n                     try_validation!(value.to_bits(size),\n                         value, self.path, \"initialized plain (non-pointer) bytes\");\n@@ -324,7 +342,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 }\n             }\n             ty::RawPtr(..) => {\n-                if self.const_mode {\n+                if self.ref_tracking_for_consts.is_some() {\n                     // Integers/floats in CTFE: For consistency with integers, we do not\n                     // accept undef.\n                     let _ptr = try_validation!(value.to_scalar_ptr(),\n@@ -393,9 +411,9 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     }\n                 }\n                 // Recursive checking\n-                if let Some(ref mut ref_tracking) = self.ref_tracking {\n-                    assert!(self.const_mode, \"We should only do recursie checking in const mode\");\n+                if let Some(ref mut ref_tracking) = self.ref_tracking_for_consts {\n                     let place = self.ecx.ref_to_mplace(value)?;\n+                    // FIXME(RalfJ): check ZST for inbound pointers\n                     if size != Size::ZERO {\n                         // Non-ZST also have to be dereferencable\n                         let ptr = try_validation!(place.ptr.to_ptr(),\n@@ -423,16 +441,15 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     // before.  Proceed recursively even for integer pointers, no\n                     // reason to skip them! They are (recursively) valid for some ZST,\n                     // but not for others (e.g., `!` is a ZST).\n-                    if ref_tracking.seen.insert(place) {\n-                        trace!(\"Recursing below ptr {:#?}\", *place);\n+                    let path = &self.path;\n+                    ref_tracking.track(place, || {\n                         // We need to clone the path anyway, make sure it gets created\n                         // with enough space for the additional `Deref`.\n-                        let mut new_path = Vec::with_capacity(self.path.len()+1);\n-                        new_path.clone_from(&self.path);\n+                        let mut new_path = Vec::with_capacity(path.len() + 1);\n+                        new_path.clone_from(path);\n                         new_path.push(PathElem::Deref);\n-                        // Remember to come back to this later.\n-                        ref_tracking.todo.push((place, new_path));\n-                    }\n+                        new_path\n+                    });\n                 }\n             }\n             ty::FnPtr(_sig) => {\n@@ -488,10 +505,17 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     let non_null =\n                         self.ecx.memory.check_align(\n                             Scalar::Ptr(ptr), Align::from_bytes(1).unwrap()\n-                        ).is_ok() ||\n-                        self.ecx.memory.get_fn(ptr).is_ok();\n+                        ).is_ok();\n                     if !non_null {\n-                        // could be NULL\n+                        // These conditions are just here to improve the diagnostics so we can\n+                        // differentiate between null pointers and dangling pointers\n+                        if self.ref_tracking_for_consts.is_some() &&\n+                            self.ecx.memory.get(ptr.alloc_id).is_err() &&\n+                            self.ecx.memory.get_fn(ptr).is_err() {\n+                            return validation_failure!(\n+                                \"encountered dangling pointer\", self.path\n+                            );\n+                        }\n                         return validation_failure!(\"a potentially NULL pointer\", self.path);\n                     }\n                     return Ok(());\n@@ -574,7 +598,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     self.ecx,\n                     ptr,\n                     size,\n-                    /*allow_ptr_and_undef*/!self.const_mode,\n+                    /*allow_ptr_and_undef*/ self.ref_tracking_for_consts.is_none(),\n                 ) {\n                     // In the happy case, we needn't check anything else.\n                     Ok(()) => {},\n@@ -612,23 +636,25 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n     /// is an indirect operand.\n     /// It will error if the bits at the destination do not match the ones described by the layout.\n     ///\n-    /// `ref_tracking` can be `None` to avoid recursive checking below references.\n+    /// `ref_tracking_for_consts` can be `None` to avoid recursive checking below references.\n     /// This also toggles between \"run-time\" (no recursion) and \"compile-time\" (with recursion)\n-    /// validation (e.g., pointer values are fine in integers at runtime).\n+    /// validation (e.g., pointer values are fine in integers at runtime) and various other const\n+    /// specific validation checks\n     pub fn validate_operand(\n         &self,\n         op: OpTy<'tcx, M::PointerTag>,\n         path: Vec<PathElem>,\n-        ref_tracking: Option<&mut RefTracking<MPlaceTy<'tcx, M::PointerTag>>>,\n-        const_mode: bool,\n+        ref_tracking_for_consts: Option<&mut RefTracking<\n+            MPlaceTy<'tcx, M::PointerTag>,\n+            Vec<PathElem>,\n+        >>,\n     ) -> InterpResult<'tcx> {\n         trace!(\"validate_operand: {:?}, {:?}\", *op, op.layout.ty);\n \n         // Construct a visitor\n         let mut visitor = ValidityVisitor {\n             path,\n-            ref_tracking,\n-            const_mode,\n+            ref_tracking_for_consts,\n             ecx: self,\n         };\n "}, {"sha": "d04dc3ab37ed3e4b83bbfed8d3b35ad887c82c18", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -81,6 +81,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tcx, M::\n         ecx.operand_field(self, field)\n     }\n }\n+\n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for MPlaceTy<'tcx, M::PointerTag> {\n     #[inline(always)]\n     fn layout(&self) -> TyLayout<'tcx> {"}, {"sha": "a7120888742d0faa0f8637003f2b99864d96aeac", "filename": "src/librustc_mir/lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flints.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -130,7 +130,7 @@ fn check_fn_for_unconditional_recursion(\n     // recurs.\n     if !reached_exit_without_self_call && !self_call_locations.is_empty() {\n         let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-        let sp = tcx.sess.source_map().def_span(tcx.hir().span_by_hir_id(hir_id));\n+        let sp = tcx.sess.source_map().def_span(tcx.hir().span(hir_id));\n         let mut db = tcx.struct_span_lint_hir(UNCONDITIONAL_RECURSION,\n                                               hir_id,\n                                               sp,"}, {"sha": "c64bb73802dc822cdf834d0441cbdb4dc0a04e44", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -345,7 +345,7 @@ fn collect_roots<'tcx>(tcx: TyCtxt<'tcx>, mode: MonoItemCollectionMode) -> Vec<M\n }\n \n // Collect all monomorphized items reachable from `starting_point`\n-fn collect_items_rec<'a, 'tcx: 'a>(\n+fn collect_items_rec<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     starting_point: MonoItem<'tcx>,\n     visited: MTRef<'_, MTLock<FxHashSet<MonoItem<'tcx>>>>,\n@@ -455,7 +455,7 @@ fn check_recursion_limit<'tcx>(\n         let error = format!(\"reached the recursion limit while instantiating `{}`\",\n                             instance);\n         if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n-            tcx.sess.span_fatal(tcx.hir().span_by_hir_id(hir_id), &error);\n+            tcx.sess.span_fatal(tcx.hir().span(hir_id), &error);\n         } else {\n             tcx.sess.fatal(&error);\n         }\n@@ -515,7 +515,7 @@ fn check_type_length_limit<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) {\n     }\n }\n \n-struct MirNeighborCollector<'a, 'tcx: 'a> {\n+struct MirNeighborCollector<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body: &'a mir::Body<'tcx>,\n     output: &'a mut Vec<MonoItem<'tcx>>,\n@@ -1262,7 +1262,7 @@ fn collect_const<'tcx>(\n         ConstValue::Scalar(Scalar::Ptr(ptr)) =>\n             collect_miri(tcx, ptr.alloc_id, output),\n         ConstValue::Slice { data: alloc, start: _, end: _ } |\n-        ConstValue::ByRef(_, alloc) => {\n+        ConstValue::ByRef(_, _, alloc) => {\n             for &((), id) in alloc.relocations.values() {\n                 collect_miri(tcx, id, output);\n             }"}, {"sha": "2bcf058ad7c35c8335766c56749bd0d18b46ddfb", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -193,7 +193,7 @@ pub trait MonoItemExt<'tcx>: fmt::Debug {\n             MonoItem::GlobalAsm(hir_id) => {\n                 Some(hir_id)\n             }\n-        }.map(|hir_id| tcx.hir().span_by_hir_id(hir_id))\n+        }.map(|hir_id| tcx.hir().span(hir_id))\n     }\n }\n "}, {"sha": "32e4d4f437a7884605833461241ca0734c0f9bad", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -766,10 +766,10 @@ fn numbered_codegen_unit_name(\n     name_builder.build_cgu_name_no_mangle(LOCAL_CRATE, &[\"cgu\"], Some(index))\n }\n \n-fn debug_dump<'a, 'b, 'tcx, I>(tcx: TyCtxt<'tcx>, label: &str, cgus: I)\n+fn debug_dump<'a, 'tcx, I>(tcx: TyCtxt<'tcx>, label: &str, cgus: I)\n where\n-    I: Iterator<Item = &'b CodegenUnit<'tcx>>,\n-    'tcx: 'a + 'b,\n+    I: Iterator<Item = &'a CodegenUnit<'tcx>>,\n+    'tcx: 'a,\n {\n     if cfg!(debug_assertions) {\n         debug!(\"{}\", label);\n@@ -794,9 +794,10 @@ where\n }\n \n #[inline(never)] // give this a place in the profiler\n-fn assert_symbols_are_distinct<'a, 'tcx: 'a, I>(tcx: TyCtxt<'tcx>, mono_items: I)\n+fn assert_symbols_are_distinct<'a, 'tcx, I>(tcx: TyCtxt<'tcx>, mono_items: I)\n where\n     I: Iterator<Item = &'a MonoItem<'tcx>>,\n+    'tcx: 'a,\n {\n     let mut symbols: Vec<_> = mono_items.map(|mono_item| {\n         (mono_item, mono_item.symbol_name(tcx))"}, {"sha": "c04672f8331e62badbd674df42a4d5a513b0d697", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -248,7 +248,7 @@ fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>)\n     body\n }\n \n-pub struct DropShimElaborator<'a, 'tcx: 'a> {\n+pub struct DropShimElaborator<'a, 'tcx> {\n     pub body: &'a Body<'tcx>,\n     pub patch: MirPatch<'tcx>,\n     pub tcx: TyCtxt<'tcx>,"}, {"sha": "9c78d761cb2ca83d226e9412d70ecbfa7cde8592", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -18,7 +18,7 @@ use std::ops::Bound;\n \n use crate::util;\n \n-pub struct UnsafetyChecker<'a, 'tcx: 'a> {\n+pub struct UnsafetyChecker<'a, 'tcx> {\n     body: &'a Body<'tcx>,\n     const_context: bool,\n     min_const_fn: bool,\n@@ -488,7 +488,7 @@ fn check_unused_unsafe<'a, 'tcx>(\n ) {\n     let body_id =\n         tcx.hir().as_local_hir_id(def_id).and_then(|hir_id| {\n-            tcx.hir().maybe_body_owned_by_by_hir_id(hir_id)\n+            tcx.hir().maybe_body_owned_by(hir_id)\n         });\n \n     let body_id = match body_id {\n@@ -527,7 +527,7 @@ fn unsafety_check_result<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> UnsafetyChec\n     let param_env = tcx.param_env(def_id);\n \n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    let (const_context, min_const_fn) = match tcx.hir().body_owner_kind_by_hir_id(id) {\n+    let (const_context, min_const_fn) = match tcx.hir().body_owner_kind(id) {\n         hir::BodyOwnerKind::Closure => (false, false),\n         hir::BodyOwnerKind::Fn => (tcx.is_const_fn(def_id), tcx.is_min_const_fn(def_id)),\n         hir::BodyOwnerKind::Const |\n@@ -591,12 +591,12 @@ fn is_enclosed(\n }\n \n fn report_unused_unsafe(tcx: TyCtxt<'_>, used_unsafe: &FxHashSet<hir::HirId>, id: hir::HirId) {\n-    let span = tcx.sess.source_map().def_span(tcx.hir().span_by_hir_id(id));\n+    let span = tcx.sess.source_map().def_span(tcx.hir().span(id));\n     let msg = \"unnecessary `unsafe` block\";\n     let mut db = tcx.struct_span_lint_hir(UNUSED_UNSAFE, id, span, msg);\n     db.span_label(span, msg);\n     if let Some((kind, id)) = is_enclosed(tcx, used_unsafe, id) {\n-        db.span_label(tcx.sess.source_map().def_span(tcx.hir().span_by_hir_id(id)),\n+        db.span_label(tcx.sess.source_map().def_span(tcx.hir().span(id)),\n                       format!(\"because it's nested under this `unsafe` {}\", kind));\n     }\n     db.emit();"}, {"sha": "5b567512a7b6fb55143ad80e837903398576cec4", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -551,7 +551,12 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         source_info: SourceInfo,\n     ) {\n         trace!(\"attepting to replace {:?} with {:?}\", rval, value);\n-        if let Err(e) = self.ecx.validate_operand(value, vec![], None, true) {\n+        if let Err(e) = self.ecx.validate_operand(\n+            value,\n+            vec![],\n+            // FIXME: is ref tracking too expensive?\n+            Some(&mut interpret::RefTracking::empty()),\n+        ) {\n             trace!(\"validation error, attempt failed: {:?}\", e);\n             return;\n         }\n@@ -562,7 +567,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         });\n \n         if let Some(Ok(imm)) = imm {\n-            match imm {\n+            match *imm {\n                 interpret::Immediate::Scalar(ScalarMaybeUndef::Scalar(scalar)) => {\n                     *rval = Rvalue::Use(\n                         self.operand_from_scalar(scalar, value.layout.ty, source_info.span));"}, {"sha": "d805c66e3c360201972840aa2e39a88725544d6a", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -164,7 +164,7 @@ impl InitializationData {\n     }\n }\n \n-struct Elaborator<'a, 'b: 'a, 'tcx: 'b> {\n+struct Elaborator<'a, 'b, 'tcx> {\n     init_data: &'a InitializationData,\n     ctxt: &'a mut ElaborateDropsCtxt<'b, 'tcx>,\n }\n@@ -285,7 +285,7 @@ impl<'a, 'b, 'tcx> DropElaborator<'a, 'tcx> for Elaborator<'a, 'b, 'tcx> {\n     }\n }\n \n-struct ElaborateDropsCtxt<'a, 'tcx: 'a> {\n+struct ElaborateDropsCtxt<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n     env: &'a MoveDataParamEnv<'tcx>,"}, {"sha": "ba8c47c665e03b3a8bc2542b4538152ba75bab44", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -616,16 +616,17 @@ fn compute_storage_conflicts(\n     storage_conflicts\n }\n \n-struct StorageConflictVisitor<'body, 'tcx: 'body, 's> {\n+struct StorageConflictVisitor<'body, 'tcx, 's> {\n     body: &'body Body<'tcx>,\n     stored_locals: &'s liveness::LiveVarSet,\n     // FIXME(tmandry): Consider using sparse bitsets here once we have good\n     // benchmarks for generators.\n     local_conflicts: BitMatrix<Local, Local>,\n }\n \n-impl<'body, 'tcx: 'body, 's> DataflowResultsConsumer<'body, 'tcx>\n-for StorageConflictVisitor<'body, 'tcx, 's> {\n+impl<'body, 'tcx, 's> DataflowResultsConsumer<'body, 'tcx>\n+    for StorageConflictVisitor<'body, 'tcx, 's>\n+{\n     type FlowState = FlowAtLocation<'tcx, MaybeStorageLive<'body, 'tcx>>;\n \n     fn body(&self) -> &'body Body<'tcx> {\n@@ -654,7 +655,7 @@ for StorageConflictVisitor<'body, 'tcx, 's> {\n     }\n }\n \n-impl<'body, 'tcx: 'body, 's> StorageConflictVisitor<'body, 'tcx, 's> {\n+impl<'body, 'tcx, 's> StorageConflictVisitor<'body, 'tcx, 's> {\n     fn apply_state(&mut self,\n                    flow_state: &FlowAtLocation<'tcx, MaybeStorageLive<'body, 'tcx>>,\n                    loc: Location) {"}, {"sha": "e2f98e46dba57a6d03c5965d1741fead6055127d", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -70,7 +70,7 @@ impl Inliner<'tcx> {\n \n         // Only do inlining into fn bodies.\n         let id = self.tcx.hir().as_local_hir_id(self.source.def_id()).unwrap();\n-        if self.tcx.hir().body_owner_kind_by_hir_id(id).is_fn_or_closure()\n+        if self.tcx.hir().body_owner_kind(id).is_fn_or_closure()\n             && self.source.promoted.is_none()\n         {\n             for (bb, bb_data) in caller_body.basic_blocks().iter_enumerated() {\n@@ -643,7 +643,7 @@ fn type_size_of<'tcx>(\n  * Updates block indices, references to locals and other control flow\n  * stuff.\n */\n-struct Integrator<'a, 'tcx: 'a> {\n+struct Integrator<'a, 'tcx> {\n     block_idx: usize,\n     args: &'a [Local],\n     local_map: IndexVec<Local, Local>,"}, {"sha": "81d91dcd0a95f58f66d6bd173832cae477f94b96", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -66,7 +66,7 @@ fn mir_keys<'tcx>(tcx: TyCtxt<'tcx>, krate: CrateNum) -> &'tcx DefIdSet {\n \n     // Additionally, tuple struct/variant constructors have MIR, but\n     // they don't have a BodyId, so we need to build them separately.\n-    struct GatherCtors<'a, 'tcx: 'a> {\n+    struct GatherCtors<'a, 'tcx> {\n         tcx: TyCtxt<'tcx>,\n         set: &'a mut DefIdSet,\n     }\n@@ -208,7 +208,7 @@ fn mir_const<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx Steal<Body<'tcx>>\n \n fn mir_validated(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx Steal<Body<'tcx>> {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    if let hir::BodyOwnerKind::Const = tcx.hir().body_owner_kind_by_hir_id(hir_id) {\n+    if let hir::BodyOwnerKind::Const = tcx.hir().body_owner_kind(hir_id) {\n         // Ensure that we compute the `mir_const_qualif` for constants at\n         // this point, before we steal the mir-const result.\n         let _ = tcx.mir_const_qualif(def_id);"}, {"sha": "d78adfe433c47684efe720cc69b39a82ae3b259a", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -147,7 +147,7 @@ pub fn collect_temps(body: &Body<'_>,\n     collector.temps\n }\n \n-struct Promoter<'a, 'tcx: 'a> {\n+struct Promoter<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     source: &'a mut Body<'tcx>,\n     promoted: Body<'tcx>,"}, {"sha": "f082b5e5a046cfedd7a0dde7c5cdf93ad9a47cf1", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -738,27 +738,29 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                 qualifs[IsNotPromotable] = true;\n \n                 if self.mode.requires_const_checking() {\n-                    if let BorrowKind::Mut { .. } = kind {\n-                        let mut err = struct_span_err!(self.tcx.sess,  self.span, E0017,\n-                                                       \"references in {}s may only refer \\\n-                                                        to immutable values\", self.mode);\n-                        err.span_label(self.span, format!(\"{}s require immutable values\",\n-                                                            self.mode));\n-                        if self.tcx.sess.teach(&err.get_code().unwrap()) {\n-                            err.note(\"References in statics and constants may only refer to \\\n-                                      immutable values.\\n\\n\\\n-                                      Statics are shared everywhere, and if they refer to \\\n-                                      mutable data one might violate memory safety since \\\n-                                      holding multiple mutable references to shared data is \\\n-                                      not allowed.\\n\\n\\\n-                                      If you really want global mutable state, try using \\\n-                                      static mut or a global UnsafeCell.\");\n+                    if !self.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n+                        if let BorrowKind::Mut { .. } = kind {\n+                            let mut err = struct_span_err!(self.tcx.sess,  self.span, E0017,\n+                                                        \"references in {}s may only refer \\\n+                                                            to immutable values\", self.mode);\n+                            err.span_label(self.span, format!(\"{}s require immutable values\",\n+                                                                self.mode));\n+                            if self.tcx.sess.teach(&err.get_code().unwrap()) {\n+                                err.note(\"References in statics and constants may only refer to \\\n+                                        immutable values.\\n\\n\\\n+                                        Statics are shared everywhere, and if they refer to \\\n+                                        mutable data one might violate memory safety since \\\n+                                        holding multiple mutable references to shared data is \\\n+                                        not allowed.\\n\\n\\\n+                                        If you really want global mutable state, try using \\\n+                                        static mut or a global UnsafeCell.\");\n+                            }\n+                            err.emit();\n+                        } else {\n+                            span_err!(self.tcx.sess, self.span, E0492,\n+                                    \"cannot borrow a constant which may contain \\\n+                                    interior mutability, create a static instead\");\n                         }\n-                        err.emit();\n-                    } else {\n-                        span_err!(self.tcx.sess, self.span, E0492,\n-                                  \"cannot borrow a constant which may contain \\\n-                                   interior mutability, create a static instead\");\n                     }\n                 }\n             } else if let BorrowKind::Mut { .. } | BorrowKind::Shared = kind {\n@@ -1503,7 +1505,7 @@ impl MirPass for QualifyAndPromoteConstants {\n         let def_id = src.def_id();\n         let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n         let mut const_promoted_temps = None;\n-        let mode = match tcx.hir().body_owner_kind_by_hir_id(id) {\n+        let mode = match tcx.hir().body_owner_kind(id) {\n             hir::BodyOwnerKind::Closure => Mode::NonConstFn,\n             hir::BodyOwnerKind::Fn => {\n                 if tcx.is_const_fn(def_id) {"}, {"sha": "f226f15c0096f2fcabaefab6ed4555298186b54e", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -63,12 +63,12 @@ impl MirPass for SimplifyCfg {\n     }\n }\n \n-pub struct CfgSimplifier<'a, 'tcx: 'a> {\n+pub struct CfgSimplifier<'a, 'tcx> {\n     basic_blocks: &'a mut IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n     pred_count: IndexVec<BasicBlock, u32>\n }\n \n-impl<'a, 'tcx: 'a> CfgSimplifier<'a, 'tcx> {\n+impl<'a, 'tcx> CfgSimplifier<'a, 'tcx> {\n     pub fn new(body: &'a mut Body<'tcx>) -> Self {\n         let mut pred_count = IndexVec::from_elem(0u32, body.basic_blocks());\n "}, {"sha": "812a024e1d91182155764469d44b861c5f636940", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -47,7 +47,7 @@ impl MirPass for UniformArrayMoveOut {\n     }\n }\n \n-struct UniformArrayMoveOutVisitor<'a, 'tcx: 'a> {\n+struct UniformArrayMoveOutVisitor<'a, 'tcx> {\n     body: &'a Body<'tcx>,\n     patch: &'a mut MirPatch<'tcx>,\n     tcx: TyCtxt<'tcx>,"}, {"sha": "815d210d36ea4fcbbfbe93e3483be9ac1254b43d", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -70,7 +70,7 @@ impl Unwind {\n     }\n }\n \n-pub trait DropElaborator<'a, 'tcx: 'a>: fmt::Debug {\n+pub trait DropElaborator<'a, 'tcx>: fmt::Debug {\n     type Path : Copy + fmt::Debug;\n \n     fn patch(&mut self) -> &mut MirPatch<'tcx>;\n@@ -90,8 +90,9 @@ pub trait DropElaborator<'a, 'tcx: 'a>: fmt::Debug {\n }\n \n #[derive(Debug)]\n-struct DropCtxt<'l, 'b: 'l, 'tcx: 'b, D>\n-    where D : DropElaborator<'b, 'tcx> + 'l\n+struct DropCtxt<'l, 'b, 'tcx, D>\n+where\n+    D: DropElaborator<'b, 'tcx> + 'l,\n {\n     elaborator: &'l mut D,\n \n@@ -110,8 +111,10 @@ pub fn elaborate_drop<'b, 'tcx, D>(\n     path: D::Path,\n     succ: BasicBlock,\n     unwind: Unwind,\n-    bb: BasicBlock)\n-    where D: DropElaborator<'b, 'tcx>\n+    bb: BasicBlock,\n+) where\n+    D: DropElaborator<'b, 'tcx>,\n+    'tcx: 'b,\n {\n     DropCtxt {\n         elaborator, source_info, place, path, succ, unwind\n@@ -121,6 +124,7 @@ pub fn elaborate_drop<'b, 'tcx, D>(\n impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n where\n     D: DropElaborator<'b, 'tcx>,\n+    'tcx: 'b,\n {\n     fn place_ty(&self, place: &Place<'tcx>) -> Ty<'tcx> {\n         place.ty(self.elaborator.body(), self.tcx()).ty"}, {"sha": "e1e4195d6d5168dd5e5cdee77180aff3caf1121e", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -39,7 +39,7 @@ enum Context {\n }\n \n #[derive(Copy, Clone)]\n-struct CheckLoopVisitor<'a, 'hir: 'a> {\n+struct CheckLoopVisitor<'a, 'hir> {\n     sess: &'a Session,\n     hir_map: &'a Map<'hir>,\n     cx: Context,"}, {"sha": "bc1151974bb70bd4367ffd2c40288e5780892f04", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -74,7 +74,7 @@ fn rvalue_promotable_map<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx ItemLo\n     tcx.arena.alloc(visitor.result)\n }\n \n-struct CheckCrateVisitor<'a, 'tcx: 'a> {\n+struct CheckCrateVisitor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     in_fn: bool,\n     in_static: bool,\n@@ -165,7 +165,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     fn check_nested_body(&mut self, body_id: hir::BodyId) -> Promotability {\n         let item_id = self.tcx.hir().body_owner(body_id);\n-        let item_def_id = self.tcx.hir().local_def_id(item_id);\n+        let item_def_id = self.tcx.hir().local_def_id_from_hir_id(item_id);\n \n         let outer_in_fn = self.in_fn;\n         let outer_tables = self.tables;\n@@ -545,7 +545,7 @@ fn check_expr_kind<'a, 'tcx>(\n         }\n \n         // Generator expressions\n-        hir::ExprKind::Yield(ref expr) => {\n+        hir::ExprKind::Yield(ref expr, _) => {\n             let _ = v.check_expr(&expr);\n             NotPromotable\n         }"}, {"sha": "16d484e2a98f2e699edc0078c41c61bdd1972544", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -4,9 +4,8 @@ use rustc::lint::{EarlyLintPassObject, LateLintPassObject, LintId, Lint};\n use rustc::session::Session;\n use rustc::util::nodemap::FxHashMap;\n \n-use syntax::ext::base::{SyntaxExtension, NamedSyntaxExtension};\n+use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind, NamedSyntaxExtension};\n use syntax::ext::base::MacroExpanderFn;\n-use syntax::ext::hygiene::Transparency;\n use syntax::symbol::{Symbol, sym};\n use syntax::ast;\n use syntax::feature_gate::AttributeType;\n@@ -89,28 +88,21 @@ impl<'a> Registry<'a> {\n         if name == sym::macro_rules {\n             panic!(\"user-defined macros may not be named `macro_rules`\");\n         }\n-        if let SyntaxExtension::LegacyBang { def_info: ref mut def_info @ None, .. } = extension {\n-            *def_info = Some((ast::CRATE_NODE_ID, self.krate_span));\n+        if extension.def_info.is_none() {\n+            extension.def_info = Some((ast::CRATE_NODE_ID, self.krate_span));\n         }\n         self.syntax_exts.push((name, extension));\n     }\n \n     /// Register a macro of the usual kind.\n     ///\n     /// This is a convenience wrapper for `register_syntax_extension`.\n-    /// It builds for you a `SyntaxExtension::LegacyBang` that calls `expander`,\n+    /// It builds for you a `SyntaxExtensionKind::LegacyBang` that calls `expander`,\n     /// and also takes care of interning the macro's name.\n     pub fn register_macro(&mut self, name: &str, expander: MacroExpanderFn) {\n-        self.register_syntax_extension(Symbol::intern(name), SyntaxExtension::LegacyBang {\n-            expander: Box::new(expander),\n-            def_info: None,\n-            transparency: Transparency::SemiTransparent,\n-            allow_internal_unstable: None,\n-            allow_internal_unsafe: false,\n-            local_inner_macros: false,\n-            unstable_feature: None,\n-            edition: self.sess.edition(),\n-        });\n+        let kind = SyntaxExtensionKind::LegacyBang(Box::new(expander));\n+        let ext = SyntaxExtension::default(kind, self.sess.edition());\n+        self.register_syntax_extension(Symbol::intern(name), ext);\n     }\n \n     /// Register a compiler lint pass."}, {"sha": "ba834bf09aa8437bf7aca6e80e642b3e3f633ac0", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -233,7 +233,7 @@ fn def_id_visibility<'tcx>(\n                 Node::Item(item) => &item.vis,\n                 Node::ForeignItem(foreign_item) => &foreign_item.vis,\n                 Node::TraitItem(..) | Node::Variant(..) => {\n-                    return def_id_visibility(tcx, tcx.hir().get_parent_did_by_hir_id(hir_id));\n+                    return def_id_visibility(tcx, tcx.hir().get_parent_did(hir_id));\n                 }\n                 Node::ImplItem(impl_item) => {\n                     match tcx.hir().get_by_hir_id(tcx.hir().get_parent_item(hir_id)) {\n@@ -255,7 +255,7 @@ fn def_id_visibility<'tcx>(\n                                 tcx, parent_did,\n                             );\n \n-                            let adt_def = tcx.adt_def(tcx.hir().get_parent_did_by_hir_id(hir_id));\n+                            let adt_def = tcx.adt_def(tcx.hir().get_parent_did(hir_id));\n                             let ctor_did = tcx.hir().local_def_id_from_hir_id(\n                                 vdata.ctor_hir_id().unwrap());\n                             let variant = adt_def.variant_with_ctor_id(ctor_did);\n@@ -294,7 +294,7 @@ fn def_id_visibility<'tcx>(\n                             // visibility to within the crate.\n                             if ctor_vis == ty::Visibility::Public {\n                                 let adt_def =\n-                                    tcx.adt_def(tcx.hir().get_parent_did_by_hir_id(hir_id));\n+                                    tcx.adt_def(tcx.hir().get_parent_did(hir_id));\n                                 if adt_def.non_enum_variant().is_field_list_non_exhaustive() {\n                                     ctor_vis =\n                                         ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n@@ -311,7 +311,7 @@ fn def_id_visibility<'tcx>(\n                 }\n                 Node::Expr(expr) => {\n                     return (ty::Visibility::Restricted(\n-                        tcx.hir().get_module_parent_by_hir_id(expr.hir_id)),\n+                        tcx.hir().get_module_parent(expr.hir_id)),\n                             expr.span, \"private\")\n                 }\n                 node => bug!(\"unexpected node kind: {:?}\", node)\n@@ -501,11 +501,11 @@ impl EmbargoVisitor<'tcx> {\n             if let Some(item) = module.res\n                 .and_then(|res| res.mod_def_id())\n                 .and_then(|def_id| self.tcx.hir().as_local_hir_id(def_id))\n-                .map(|module_hir_id| self.tcx.hir().expect_item_by_hir_id(module_hir_id))\n+                .map(|module_hir_id| self.tcx.hir().expect_item(module_hir_id))\n              {\n                 if let hir::ItemKind::Mod(m) = &item.node {\n                     for item_id in m.item_ids.as_ref() {\n-                        let item = self.tcx.hir().expect_item_by_hir_id(item_id.id);\n+                        let item = self.tcx.hir().expect_item(item_id.id);\n                         let def_id = self.tcx.hir().local_def_id_from_hir_id(item_id.id);\n                         if !self.tcx.hygienic_eq(segment.ident, item.ident, def_id) { continue; }\n                         if let hir::ItemKind::Use(..) = item.node {\n@@ -764,7 +764,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             let module = if module_id == hir::CRATE_HIR_ID {\n                 &self.tcx.hir().krate().module\n             } else if let hir::ItemKind::Mod(ref module) =\n-                          self.tcx.hir().expect_item_by_hir_id(module_id).node {\n+                          self.tcx.hir().expect_item(module_id).node {\n                 module\n             } else {\n                 unreachable!()\n@@ -842,7 +842,7 @@ impl DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n /// This pass performs remaining checks for fields in struct expressions and patterns.\n //////////////////////////////////////////////////////////////////////////////////////\n \n-struct NamePrivacyVisitor<'a, 'tcx: 'a> {\n+struct NamePrivacyVisitor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n     current_item: hir::HirId,\n@@ -969,7 +969,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n /// Checks are performed on \"semantic\" types regardless of names and their hygiene.\n ////////////////////////////////////////////////////////////////////////////////////////////\n \n-struct TypePrivacyVisitor<'a, 'tcx: 'a> {\n+struct TypePrivacyVisitor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n     current_item: DefId,\n@@ -1202,15 +1202,15 @@ impl DefIdVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n /// warnings instead of hard errors when the erroneous node is not in this old set.\n ///////////////////////////////////////////////////////////////////////////////\n \n-struct ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx: 'a> {\n+struct ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     access_levels: &'a AccessLevels,\n     in_variant: bool,\n     // Set of errors produced by this obsolete visitor.\n     old_error_set: HirIdSet,\n }\n \n-struct ObsoleteCheckTypeForPrivatenessVisitor<'a, 'b: 'a, 'tcx: 'b> {\n+struct ObsoleteCheckTypeForPrivatenessVisitor<'a, 'b, 'tcx> {\n     inner: &'a ObsoleteVisiblePrivateTypesVisitor<'b, 'tcx>,\n     /// Whether the type refers to private types.\n     contains_private: bool,\n@@ -1651,7 +1651,7 @@ impl DefIdVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'tcx> {\n     }\n }\n \n-struct PrivateItemsInPublicInterfacesVisitor<'a, 'tcx: 'a> {\n+struct PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     has_pub_restricted: bool,\n     old_error_set: &'a HirIdSet,\n@@ -1690,7 +1690,7 @@ impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n             tcx: self.tcx,\n             item_id,\n             item_def_id: self.tcx.hir().local_def_id_from_hir_id(item_id),\n-            span: self.tcx.hir().span_by_hir_id(item_id),\n+            span: self.tcx.hir().span(item_id),\n             required_visibility,\n             has_pub_restricted: self.has_pub_restricted,\n             has_old_errors,"}, {"sha": "616728d5418483a01364b5cdb1d37db32cf1b274", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -772,9 +772,8 @@ impl<'a> Resolver<'a> {\n     pub fn get_macro(&mut self, res: Res) -> Lrc<SyntaxExtension> {\n         let def_id = match res {\n             Res::Def(DefKind::Macro(..), def_id) => def_id,\n-            Res::NonMacroAttr(attr_kind) => return Lrc::new(SyntaxExtension::NonMacroAttr {\n-                mark_used: attr_kind == NonMacroAttrKind::Tool,\n-            }),\n+            Res::NonMacroAttr(attr_kind) =>\n+                return self.non_macro_attr(attr_kind == NonMacroAttrKind::Tool),\n             _ => panic!(\"expected `DefKind::Macro` or `Res::NonMacroAttr`\"),\n         };\n         if let Some(ext) = self.macro_map.get(&def_id) {\n@@ -930,7 +929,7 @@ impl<'a> Resolver<'a> {\n     }\n }\n \n-pub struct BuildReducedGraphVisitor<'a, 'b: 'a> {\n+pub struct BuildReducedGraphVisitor<'a, 'b> {\n     pub resolver: &'a mut Resolver<'b>,\n     pub current_legacy_scope: LegacyScope<'b>,\n     pub expansion: Mark,"}, {"sha": "4fee15c59b33d66cc54b7645e559027fe8f38610", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -48,7 +48,7 @@ impl<'a> UnusedImport<'a> {\n     }\n }\n \n-struct UnusedImportCheckVisitor<'a, 'b: 'a> {\n+struct UnusedImportCheckVisitor<'a, 'b> {\n     resolver: &'a mut Resolver<'b>,\n     /// All the (so far) unused imports, grouped path list\n     unused_imports: NodeMap<UnusedImport<'a>>,"}, {"sha": "e93a2315ca321193ce433e4402081b7136a86399", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -441,7 +441,7 @@ impl<'a> Resolver<'a> {\n     }\n }\n \n-impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n+impl<'a, 'b> ImportResolver<'a, 'b> {\n     /// Adds suggestions for a path that cannot be resolved.\n     pub(crate) fn make_path_suggestion(\n         &mut self,"}, {"sha": "0fbd0666ad1c13c4af4c30c955861b66c7c9656c", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -41,7 +41,7 @@ use rustc_metadata::cstore::CStore;\n use syntax::source_map::SourceMap;\n use syntax::ext::hygiene::{Mark, Transparency, SyntaxContext};\n use syntax::ast::{self, Name, NodeId, Ident, FloatTy, IntTy, UintTy};\n-use syntax::ext::base::SyntaxExtension;\n+use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::base::MacroKind;\n use syntax::symbol::{Symbol, kw, sym};\n@@ -1668,6 +1668,7 @@ pub struct Resolver<'a> {\n     macro_use_prelude: FxHashMap<Name, &'a NameBinding<'a>>,\n     pub all_macros: FxHashMap<Name, Res>,\n     macro_map: FxHashMap<DefId, Lrc<SyntaxExtension>>,\n+    non_macro_attrs: [Lrc<SyntaxExtension>; 2],\n     macro_defs: FxHashMap<Mark, DefId>,\n     local_macro_def_scopes: FxHashMap<NodeId, Module<'a>>,\n \n@@ -1735,7 +1736,7 @@ impl<'a> ResolverArenas<'a> {\n     }\n }\n \n-impl<'a, 'b: 'a> ty::DefIdTree for &'a Resolver<'b> {\n+impl<'a, 'b> ty::DefIdTree for &'a Resolver<'b> {\n     fn parent(self, id: DefId) -> Option<DefId> {\n         match id.krate {\n             LOCAL_CRATE => self.definitions.def_key(id.index).parent,\n@@ -1941,6 +1942,10 @@ impl<'a> Resolver<'a> {\n         let mut macro_defs = FxHashMap::default();\n         macro_defs.insert(Mark::root(), root_def_id);\n \n+        let non_macro_attr = |mark_used| Lrc::new(SyntaxExtension::default(\n+            SyntaxExtensionKind::NonMacroAttr { mark_used }, session.edition()\n+        ));\n+\n         Resolver {\n             session,\n \n@@ -2014,6 +2019,7 @@ impl<'a> Resolver<'a> {\n             macro_use_prelude: FxHashMap::default(),\n             all_macros: FxHashMap::default(),\n             macro_map: FxHashMap::default(),\n+            non_macro_attrs: [non_macro_attr(false), non_macro_attr(true)],\n             invocations,\n             macro_defs,\n             local_macro_def_scopes: FxHashMap::default(),\n@@ -2030,6 +2036,10 @@ impl<'a> Resolver<'a> {\n         Default::default()\n     }\n \n+    fn non_macro_attr(&self, mark_used: bool) -> Lrc<SyntaxExtension> {\n+        self.non_macro_attrs[mark_used as usize].clone()\n+    }\n+\n     /// Runs the function on each namespace.\n     fn per_ns<F: FnMut(&mut Self, Namespace)>(&mut self, mut f: F) {\n         f(self, TypeNS);"}, {"sha": "5623016c2e5e7e988b50879cd3e73cf065ac87ba", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 35, "deletions": 24, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -114,6 +114,22 @@ fn sub_namespace_match(candidate: Option<MacroKind>, requirement: Option<MacroKi\n     candidate.is_none() || requirement.is_none() || candidate == requirement\n }\n \n+// We don't want to format a path using pretty-printing,\n+// `format!(\"{}\", path)`, because that tries to insert\n+// line-breaks and is slow.\n+fn fast_print_path(path: &ast::Path) -> String {\n+    let mut path_str = String::with_capacity(64);\n+    for (i, segment) in path.segments.iter().enumerate() {\n+        if i != 0 {\n+            path_str.push_str(\"::\");\n+        }\n+        if segment.ident.name != kw::PathRoot {\n+            path_str.push_str(&segment.ident.as_str())\n+        }\n+    }\n+    path_str\n+}\n+\n impl<'a> base::Resolver for Resolver<'a> {\n     fn next_node_id(&mut self) -> ast::NodeId {\n         self.session.next_node_id()\n@@ -132,7 +148,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n     }\n \n     fn resolve_dollar_crates(&mut self, fragment: &AstFragment) {\n-        struct ResolveDollarCrates<'a, 'b: 'a> {\n+        struct ResolveDollarCrates<'a, 'b> {\n             resolver: &'a mut Resolver<'b>\n         }\n         impl<'a> Visitor<'a> for ResolveDollarCrates<'a, '_> {\n@@ -174,7 +190,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n             krate: CrateNum::BuiltinMacros,\n             index: DefIndex::from(self.macro_map.len()),\n         };\n-        let kind = ext.kind();\n+        let kind = ext.macro_kind();\n         self.macro_map.insert(def_id, ext);\n         let binding = self.arenas.alloc_name_binding(NameBinding {\n             kind: NameBindingKind::Res(Res::Def(DefKind::Macro(kind), def_id), false),\n@@ -209,14 +225,19 @@ impl<'a> base::Resolver for Resolver<'a> {\n         let parent_scope = self.invoc_parent_scope(invoc_id, derives_in_scope);\n         let (res, ext) = match self.resolve_macro_to_res(path, kind, &parent_scope, true, force) {\n             Ok((res, ext)) => (res, ext),\n-            Err(Determinacy::Determined) if kind == MacroKind::Attr => {\n-                // Replace unresolved attributes with used inert attributes for better recovery.\n-                return Ok(Some(Lrc::new(SyntaxExtension::NonMacroAttr { mark_used: true })));\n-            }\n+            // Replace unresolved attributes with used inert attributes for better recovery.\n+            Err(Determinacy::Determined) if kind == MacroKind::Attr =>\n+                (Res::Err, self.non_macro_attr(true)),\n             Err(determinacy) => return Err(determinacy),\n         };\n \n-        if let Res::Def(DefKind::Macro(_), def_id) = res {\n+        let format = match kind {\n+            MacroKind::Derive => format!(\"derive({})\", fast_print_path(path)),\n+            _ => fast_print_path(path),\n+        };\n+        invoc.expansion_data.mark.set_expn_info(ext.expn_info(invoc.span(), &format));\n+\n+        if let Res::Def(_, def_id) = res {\n             if after_derive {\n                 self.session.span_err(invoc.span(),\n                                       \"macro attributes must be placed before `#[derive]`\");\n@@ -226,7 +247,6 @@ impl<'a> base::Resolver for Resolver<'a> {\n                 self.macro_def_scope(invoc.expansion_data.mark).normal_ancestor_id;\n             self.definitions.add_parent_module_of_macro_def(invoc.expansion_data.mark,\n                                                             normal_module_def_id);\n-            invoc.expansion_data.mark.set_default_transparency(ext.default_transparency());\n         }\n \n         Ok(Some(ext))\n@@ -241,11 +261,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n     fn check_unused_macros(&self) {\n         for did in self.unused_macros.iter() {\n-            let id_span = match *self.macro_map[did] {\n-                SyntaxExtension::LegacyBang { def_info, .. } => def_info,\n-                _ => None,\n-            };\n-            if let Some((id, span)) = id_span {\n+            if let Some((id, span)) = self.macro_map[did].def_info {\n                 let lint = lint::builtin::UNUSED_MACROS;\n                 let msg = \"unused macro definition\";\n                 self.session.buffer_lint(lint, id, span, msg);\n@@ -585,17 +601,12 @@ impl<'a> Resolver<'a> {\n                         let parent_scope = ParentScope { derives: Vec::new(), ..*parent_scope };\n                         match self.resolve_macro_to_res(derive, MacroKind::Derive,\n                                                         &parent_scope, true, force) {\n-                            Ok((_, ext)) => {\n-                                if let SyntaxExtension::Derive(_, helpers, _) = &*ext {\n-                                    if helpers.contains(&ident.name) {\n-                                        let binding =\n-                                            (Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n-                                            ty::Visibility::Public, derive.span, Mark::root())\n-                                            .to_name_binding(self.arenas);\n-                                        result = Ok((binding, Flags::empty()));\n-                                        break;\n-                                    }\n-                                }\n+                            Ok((_, ext)) => if ext.helper_attrs.contains(&ident.name) {\n+                                let binding = (Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n+                                               ty::Visibility::Public, derive.span, Mark::root())\n+                                               .to_name_binding(self.arenas);\n+                                result = Ok((binding, Flags::empty()));\n+                                break;\n                             }\n                             Err(Determinacy::Determined) => {}\n                             Err(Determinacy::Undetermined) =>"}, {"sha": "f69849bb4a9ee8d8bd843f755e0d302ee5ed18cc", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -644,30 +644,30 @@ struct UnresolvedImportError {\n     suggestion: Option<Suggestion>,\n }\n \n-pub struct ImportResolver<'a, 'b: 'a> {\n+pub struct ImportResolver<'a, 'b> {\n     pub resolver: &'a mut Resolver<'b>,\n }\n \n-impl<'a, 'b: 'a> std::ops::Deref for ImportResolver<'a, 'b> {\n+impl<'a, 'b> std::ops::Deref for ImportResolver<'a, 'b> {\n     type Target = Resolver<'b>;\n     fn deref(&self) -> &Resolver<'b> {\n         self.resolver\n     }\n }\n \n-impl<'a, 'b: 'a> std::ops::DerefMut for ImportResolver<'a, 'b> {\n+impl<'a, 'b> std::ops::DerefMut for ImportResolver<'a, 'b> {\n     fn deref_mut(&mut self) -> &mut Resolver<'b> {\n         self.resolver\n     }\n }\n \n-impl<'a, 'b: 'a> ty::DefIdTree for &'a ImportResolver<'a, 'b> {\n+impl<'a, 'b> ty::DefIdTree for &'a ImportResolver<'a, 'b> {\n     fn parent(self, id: DefId) -> Option<DefId> {\n         self.resolver.parent(id)\n     }\n }\n \n-impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n+impl<'a, 'b> ImportResolver<'a, 'b> {\n     // Import resolution\n     //\n     // This is a fixed-point algorithm. We resolve imports until our efforts"}, {"sha": "a7f46e876830c47d29bd9fa872e8a12916bdb90f", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -75,7 +75,7 @@ macro_rules! access_from_vis {\n     };\n }\n \n-pub struct DumpVisitor<'l, 'tcx: 'l, 'll, O: DumpOutput> {\n+pub struct DumpVisitor<'l, 'tcx, 'll, O: DumpOutput> {\n     save_ctxt: SaveContext<'l, 'tcx>,\n     tcx: TyCtxt<'tcx>,\n     dumper: &'ll mut JsonDumper<O>,\n@@ -92,7 +92,7 @@ pub struct DumpVisitor<'l, 'tcx: 'l, 'll, O: DumpOutput> {\n     // macro_calls: FxHashSet<Span>,\n }\n \n-impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n+impl<'l, 'tcx, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n     pub fn new(\n         save_ctxt: SaveContext<'l, 'tcx>,\n         dumper: &'ll mut JsonDumper<O>,\n@@ -1311,7 +1311,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n     }\n }\n \n-impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll, O> {\n+impl<'l, 'tcx, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll, O> {\n     fn visit_mod(&mut self, m: &'l ast::Mod, span: Span, attrs: &[ast::Attribute], id: NodeId) {\n         // Since we handle explicit modules ourselves in visit_item, this should\n         // only get called for the root module of a crate."}, {"sha": "bc813b3d5a2e7584e72b143d83d3c31b4506dd51", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -51,7 +51,7 @@ use rls_data::config::Config;\n use log::{debug, error, info};\n \n \n-pub struct SaveContext<'l, 'tcx: 'l> {\n+pub struct SaveContext<'l, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     tables: &'l ty::TypeckTables<'tcx>,\n     access_levels: &'l AccessLevels,\n@@ -67,7 +67,7 @@ pub enum Data {\n     RelationData(Relation, Impl),\n }\n \n-impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n+impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n     fn span_from_span(&self, span: Span) -> SpanData {\n         use rls_span::{Column, Row};\n \n@@ -960,8 +960,8 @@ impl<'l> PathCollector<'l> {\n     }\n }\n \n-impl<'l, 'a: 'l> Visitor<'a> for PathCollector<'l> {\n-    fn visit_pat(&mut self, p: &'a ast::Pat) {\n+impl<'l> Visitor<'l> for PathCollector<'l> {\n+    fn visit_pat(&mut self, p: &'l ast::Pat) {\n         match p.node {\n             PatKind::Struct(ref path, ..) => {\n                 self.collected_paths.push((p.id, path));"}, {"sha": "bbb0825ee082afa4a706e35e557c3fe82fd93e7b", "filename": "src/librustc_traits/chalk_context/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -56,7 +56,7 @@ crate struct ChalkContext<'tcx> {\n }\n \n #[derive(Copy, Clone)]\n-crate struct ChalkInferenceContext<'cx, 'tcx: 'cx> {\n+crate struct ChalkInferenceContext<'cx, 'tcx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n }\n "}, {"sha": "59c01b8b1b7b19576806ffefeef29638d85d0f01", "filename": "src/librustc_traits/chalk_context/resolvent_ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -139,7 +139,7 @@ impl context::ResolventOps<ChalkArenas<'tcx>, ChalkArenas<'tcx>>\n     }\n }\n \n-struct AnswerSubstitutor<'cx, 'tcx: 'cx> {\n+struct AnswerSubstitutor<'cx, 'tcx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n     environment: Environment<'tcx>,\n     answer_subst: CanonicalVarValues<'tcx>,"}, {"sha": "1f9090324414b34e65f82965bcc2645c8e66a561", "filename": "src/librustc_traits/chalk_context/unify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -42,7 +42,7 @@ crate fn unify<'me, 'tcx, T: Relate<'tcx>>(\n     })\n }\n \n-struct ChalkTypeRelatingDelegate<'me, 'tcx: 'me> {\n+struct ChalkTypeRelatingDelegate<'me, 'tcx> {\n     infcx: &'me InferCtxt<'me, 'tcx>,\n     environment: Environment<'tcx>,\n     goals: Vec<InEnvironment<'tcx, Goal<'tcx>>>,"}, {"sha": "d138ce753b07e4be6eb18047e728050834faf07f", "filename": "src/librustc_traits/normalize_erasing_regions.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -37,8 +37,7 @@ fn normalize_ty_after_erasing_regions<'tcx>(\n                 );\n \n                 let normalized_value = infcx.resolve_vars_if_possible(&normalized_value);\n-                let normalized_value = infcx.tcx.erase_regions(&normalized_value);\n-                tcx.lift_to_global(&normalized_value).unwrap()\n+                infcx.tcx.erase_regions(&normalized_value)\n             }\n             Err(NoSolution) => bug!(\"could not fully normalize `{:?}`\", value),\n         }"}, {"sha": "cb30eba5b05052a264fd37827537113aa1d3124e", "filename": "src/librustc_traits/type_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_traits%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_traits%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Ftype_op.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -56,7 +56,7 @@ fn type_op_ascribe_user_type<'tcx>(\n         })\n }\n \n-struct AscribeUserTypeCx<'me, 'tcx: 'me> {\n+struct AscribeUserTypeCx<'me, 'tcx> {\n     infcx: &'me InferCtxt<'me, 'tcx>,\n     param_env: ParamEnv<'tcx>,\n     fulfill_cx: &'me mut dyn TraitEngine<'tcx>,"}, {"sha": "267f3798bd1e3d619b9e359a21f7f0c386efd7d1", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 71, "deletions": 78, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -97,15 +97,15 @@ pub enum SizedByDefault {\n     No,\n }\n \n-struct ConvertedBinding<'tcx> {\n+struct ConvertedBinding<'a, 'tcx> {\n     item_name: ast::Ident,\n-    kind: ConvertedBindingKind<'tcx>,\n+    kind: ConvertedBindingKind<'a, 'tcx>,\n     span: Span,\n }\n \n-enum ConvertedBindingKind<'tcx> {\n+enum ConvertedBindingKind<'a, 'tcx> {\n     Equality(Ty<'tcx>),\n-    Constraint(P<[hir::GenericBound]>),\n+    Constraint(&'a [hir::GenericBound]),\n }\n \n #[derive(PartialEq)]\n@@ -191,15 +191,13 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         item_segment: &hir::PathSegment)\n         -> SubstsRef<'tcx>\n     {\n-        let (substs, assoc_bindings, _) = item_segment.with_generic_args(|generic_args| {\n-            self.create_substs_for_ast_path(\n-                span,\n-                def_id,\n-                generic_args,\n-                item_segment.infer_args,\n-                None,\n-            )\n-        });\n+        let (substs, assoc_bindings, _) = self.create_substs_for_ast_path(\n+            span,\n+            def_id,\n+            item_segment.generic_args(),\n+            item_segment.infer_args,\n+            None,\n+        );\n \n         assoc_bindings.first().map(|b| Self::prohibit_assoc_ty_binding(self.tcx(), b.span));\n \n@@ -598,7 +596,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         generic_args: &'a hir::GenericArgs,\n         infer_args: bool,\n         self_ty: Option<Ty<'tcx>>)\n-        -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'tcx>>, Option<Vec<Span>>)\n+        -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, Option<Vec<Span>>)\n     {\n         // If the type is parameterized by this region, then replace this\n         // region with the current anon region binding (in other words,\n@@ -740,7 +738,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     hir::TypeBindingKind::Equality { ref ty } =>\n                         ConvertedBindingKind::Equality(self.ast_ty_to_ty(ty)),\n                     hir::TypeBindingKind::Constraint { ref bounds } =>\n-                        ConvertedBindingKind::Constraint(bounds.clone()),\n+                        ConvertedBindingKind::Constraint(bounds),\n                 };\n                 ConvertedBinding {\n                     item_name: binding.ident,\n@@ -861,21 +859,21 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         ty::TraitRef::new(trait_def_id, substs)\n     }\n \n-    fn create_substs_for_ast_trait_ref(\n+    fn create_substs_for_ast_trait_ref<'a>(\n         &self,\n         span: Span,\n         trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n-        trait_segment: &hir::PathSegment,\n-    ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'tcx>>, Option<Vec<Span>>) {\n+        trait_segment: &'a hir::PathSegment,\n+    ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, Option<Vec<Span>>) {\n         debug!(\"create_substs_for_ast_trait_ref(trait_segment={:?})\",\n                trait_segment);\n \n         let trait_def = self.tcx().trait_def(trait_def_id);\n \n         if !self.tcx().features().unboxed_closures &&\n-            trait_segment.with_generic_args(|generic_args| generic_args.parenthesized)\n-            != trait_def.paren_sugar {\n+            trait_segment.generic_args().parenthesized != trait_def.paren_sugar\n+        {\n             // For now, require that parenthetical notation be used only with `Fn()` etc.\n             let msg = if trait_def.paren_sugar {\n                 \"the precise format of `Fn`-family traits' type parameters is subject to change. \\\n@@ -887,13 +885,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                              span, GateIssue::Language, msg);\n         }\n \n-        trait_segment.with_generic_args(|generic_args| {\n-            self.create_substs_for_ast_path(span,\n-                                            trait_def_id,\n-                                            generic_args,\n-                                            trait_segment.infer_args,\n-                                            Some(self_ty))\n-        })\n+        self.create_substs_for_ast_path(span,\n+                                        trait_def_id,\n+                                        trait_segment.generic_args(),\n+                                        trait_segment.infer_args,\n+                                        Some(self_ty))\n     }\n \n     fn trait_defines_associated_type_named(&self,\n@@ -916,7 +912,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         for ab in ast_bounds {\n             if let &hir::GenericBound::Trait(ref ptr, hir::TraitBoundModifier::Maybe) = ab {\n                 if unbound.is_none() {\n-                    unbound = Some(ptr.trait_ref.clone());\n+                    unbound = Some(&ptr.trait_ref);\n                 } else {\n                     span_err!(\n                         tcx.sess,\n@@ -931,7 +927,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         let kind_id = tcx.lang_items().require(SizedTraitLangItem);\n         match unbound {\n-            Some(ref tpb) => {\n+            Some(tpb) => {\n                 // FIXME(#8559) currently requires the unbound to be built-in.\n                 if let Ok(kind_id) = kind_id {\n                     if tpb.path.res != Res::Def(DefKind::Trait, kind_id) {\n@@ -1052,7 +1048,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         &self,\n         hir_ref_id: hir::HirId,\n         trait_ref: ty::PolyTraitRef<'tcx>,\n-        binding: &ConvertedBinding<'tcx>,\n+        binding: &ConvertedBinding<'_, 'tcx>,\n         bounds: &mut Bounds<'tcx>,\n         speculative: bool,\n         dup_bindings: &mut FxHashMap<DefId, Span>,\n@@ -1169,7 +1165,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     }\n                 }), binding.span));\n             }\n-            ConvertedBindingKind::Constraint(ref ast_bounds) => {\n+            ConvertedBindingKind::Constraint(ast_bounds) => {\n                 // \"Desugar\" a constraint like `T: Iterator<Item: Debug>` to\n                 //\n                 // `<T as Iterator>::Item: Debug`\n@@ -1765,47 +1761,45 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             &self, segments: T) -> bool {\n         let mut has_err = false;\n         for segment in segments {\n-            segment.with_generic_args(|generic_args| {\n-                let (mut err_for_lt, mut err_for_ty, mut err_for_ct) = (false, false, false);\n-                for arg in &generic_args.args {\n-                    let (span, kind) = match arg {\n-                        hir::GenericArg::Lifetime(lt) => {\n-                            if err_for_lt { continue }\n-                            err_for_lt = true;\n-                            has_err = true;\n-                            (lt.span, \"lifetime\")\n-                        }\n-                        hir::GenericArg::Type(ty) => {\n-                            if err_for_ty { continue }\n-                            err_for_ty = true;\n-                            has_err = true;\n-                            (ty.span, \"type\")\n-                        }\n-                        hir::GenericArg::Const(ct) => {\n-                            if err_for_ct { continue }\n-                            err_for_ct = true;\n-                            (ct.span, \"const\")\n-                        }\n-                    };\n-                    let mut err = struct_span_err!(\n-                        self.tcx().sess,\n-                        span,\n-                        E0109,\n-                        \"{} arguments are not allowed for this type\",\n-                        kind,\n-                    );\n-                    err.span_label(span, format!(\"{} argument not allowed\", kind));\n-                    err.emit();\n-                    if err_for_lt && err_for_ty && err_for_ct {\n-                        break;\n+            let (mut err_for_lt, mut err_for_ty, mut err_for_ct) = (false, false, false);\n+            for arg in &segment.generic_args().args {\n+                let (span, kind) = match arg {\n+                    hir::GenericArg::Lifetime(lt) => {\n+                        if err_for_lt { continue }\n+                        err_for_lt = true;\n+                        has_err = true;\n+                        (lt.span, \"lifetime\")\n                     }\n-                }\n-                for binding in &generic_args.bindings {\n-                    has_err = true;\n-                    Self::prohibit_assoc_ty_binding(self.tcx(), binding.span);\n+                    hir::GenericArg::Type(ty) => {\n+                        if err_for_ty { continue }\n+                        err_for_ty = true;\n+                        has_err = true;\n+                        (ty.span, \"type\")\n+                    }\n+                    hir::GenericArg::Const(ct) => {\n+                        if err_for_ct { continue }\n+                        err_for_ct = true;\n+                        (ct.span, \"const\")\n+                    }\n+                };\n+                let mut err = struct_span_err!(\n+                    self.tcx().sess,\n+                    span,\n+                    E0109,\n+                    \"{} arguments are not allowed for this type\",\n+                    kind,\n+                );\n+                err.span_label(span, format!(\"{} argument not allowed\", kind));\n+                err.emit();\n+                if err_for_lt && err_for_ty && err_for_ct {\n                     break;\n                 }\n-            })\n+            }\n+            for binding in &segment.generic_args().bindings {\n+                has_err = true;\n+                Self::prohibit_assoc_ty_binding(self.tcx(), binding.span);\n+                break;\n+            }\n         }\n         has_err\n     }\n@@ -2001,16 +1995,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 let PathSeg(def_id, index) = path_segs.last().unwrap();\n                 self.ast_path_to_ty(span, *def_id, &path.segments[*index])\n             }\n-            Res::Def(DefKind::TyParam, did) => {\n+            Res::Def(DefKind::TyParam, def_id) => {\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(&path.segments);\n \n-                let hir_id = tcx.hir().as_local_hir_id(did).unwrap();\n+                let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n                 let item_id = tcx.hir().get_parent_node_by_hir_id(hir_id);\n                 let item_def_id = tcx.hir().local_def_id_from_hir_id(item_id);\n                 let generics = tcx.generics_of(item_def_id);\n-                let index = generics.param_def_id_to_index[\n-                    &tcx.hir().local_def_id_from_hir_id(hir_id)];\n+                let index = generics.param_def_id_to_index[&def_id];\n                 tcx.mk_ty_param(index, tcx.hir().name_by_hir_id(hir_id).as_interned_str())\n             }\n             Res::SelfTy(Some(_), None) => {\n@@ -2196,12 +2189,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         if let Some(def_id) = self.const_param_def_id(expr) {\n             // Find the name and index of the const parameter by indexing the generics of the\n             // parent item and construct a `ParamConst`.\n-            let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n-            let item_id = tcx.hir().get_parent_node(node_id);\n-            let item_def_id = tcx.hir().local_def_id(item_id);\n+            let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+            let item_id = tcx.hir().get_parent_node_by_hir_id(hir_id);\n+            let item_def_id = tcx.hir().local_def_id_from_hir_id(item_id);\n             let generics = tcx.generics_of(item_def_id);\n-            let index = generics.param_def_id_to_index[&tcx.hir().local_def_id(node_id)];\n-            let name = tcx.hir().name(node_id).as_interned_str();\n+            let index = generics.param_def_id_to_index[&tcx.hir().local_def_id_from_hir_id(hir_id)];\n+            let name = tcx.hir().name_by_hir_id(hir_id).as_interned_str();\n             const_.val = ConstValue::Param(ty::ParamConst::new(index, name));\n         }\n "}, {"sha": "ecdf28e5d7f0b7160c264ed4a29356d4bc562982", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -20,7 +20,7 @@ enum AutoderefKind {\n     Overloaded,\n }\n \n-pub struct Autoderef<'a, 'tcx: 'a> {\n+pub struct Autoderef<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     body_id: hir::HirId,\n     param_env: ty::ParamEnv<'tcx>,"}, {"sha": "42c7ff607c55a538d2d7e8aae044e0e6f10f7e6c", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -354,7 +354,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let def_span = match def {\n                         Res::Err => None,\n                         Res::Local(id) => {\n-                            Some(self.tcx.hir().span_by_hir_id(id))\n+                            Some(self.tcx.hir().span(id))\n                         },\n                         _ => def\n                             .opt_def_id()"}, {"sha": "946082746f46fe9ef55143950b3bb18b188a7eca", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -813,7 +813,7 @@ fn compare_synthetic_generics<'tcx>(\n     {\n         if impl_synthetic != trait_synthetic {\n             let impl_hir_id = tcx.hir().as_local_hir_id(impl_def_id).unwrap();\n-            let impl_span = tcx.hir().span_by_hir_id(impl_hir_id);\n+            let impl_span = tcx.hir().span(impl_hir_id);\n             let trait_span = tcx.def_span(trait_def_id);\n             let mut err = struct_span_err!(tcx.sess,\n                                            impl_span,"}, {"sha": "a2621abf44d8dd29229d8f0107aa95985f542092", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -213,7 +213,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n         // repeated `contains` calls.\n \n         if !assumptions_in_impl_context.contains(&predicate) {\n-            let item_span = tcx.hir().span_by_hir_id(self_type_hir_id);\n+            let item_span = tcx.hir().span(self_type_hir_id);\n             struct_span_err!(\n                 tcx.sess,\n                 drop_impl_span,"}, {"sha": "8ca1b85ad9aee49a54f321398196227f557c5bce", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 53, "deletions": 32, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -180,7 +180,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.diverges.set(self.diverges.get() | old_diverges);\n         self.has_errors.set(self.has_errors.get() | old_has_errors);\n \n-        debug!(\"type of {} is...\", self.tcx.hir().hir_to_string(expr.hir_id));\n+        debug!(\"type of {} is...\", self.tcx.hir().node_to_string(expr.hir_id));\n         debug!(\"... {:?}, expected is {:?}\", ty, expected);\n \n         ty\n@@ -295,7 +295,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ExprKind::Index(ref base, ref idx) => {\n                 self.check_expr_index(base, idx, needs, expr)\n             }\n-            ExprKind::Yield(ref value) => {\n+            ExprKind::Yield(ref value, _) => {\n                 self.check_expr_yield(value, expr)\n             }\n             hir::ExprKind::Err => {\n@@ -1125,7 +1125,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                     err.emit();\n                 } else {\n-                    self.report_unknown_field(adt_ty, variant, field, ast_fields, kind_name);\n+                    self.report_unknown_field(adt_ty, variant, field, ast_fields, kind_name, span);\n                 }\n \n                 tcx.types.err\n@@ -1196,6 +1196,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         field: &hir::Field,\n         skip_fields: &[hir::Field],\n         kind_name: &str,\n+        ty_span: Span\n     ) {\n         if variant.recovered {\n             return;\n@@ -1215,37 +1216,57 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             },\n             ty);\n-        // prevent all specified fields from being suggested\n-        let skip_fields = skip_fields.iter().map(|ref x| x.ident.as_str());\n-        if let Some(field_name) = Self::suggest_field_name(variant,\n-                                                           &field.ident.as_str(),\n-                                                           skip_fields.collect()) {\n-            err.span_suggestion(\n-                field.ident.span,\n-                \"a field with a similar name exists\",\n-                field_name.to_string(),\n-                Applicability::MaybeIncorrect,\n-            );\n-        } else {\n-            match ty.sty {\n-                ty::Adt(adt, ..) => {\n-                    if adt.is_enum() {\n-                        err.span_label(field.ident.span,\n-                                       format!(\"`{}::{}` does not have this field\",\n-                                               ty, variant.ident));\n-                    } else {\n-                        err.span_label(field.ident.span,\n-                                       format!(\"`{}` does not have this field\", ty));\n-                    }\n-                    let available_field_names = self.available_field_names(variant);\n-                    if !available_field_names.is_empty() {\n-                        err.note(&format!(\"available fields are: {}\",\n-                                          self.name_series_display(available_field_names)));\n+        match variant.ctor_kind {\n+            CtorKind::Fn => {\n+                err.span_label(variant.ident.span, format!(\"`{adt}` defined here\", adt=ty));\n+                err.span_label(field.ident.span, \"field does not exist\");\n+                err.span_label(ty_span, format!(\n+                        \"`{adt}` is a tuple {kind_name}, \\\n+                         use the appropriate syntax: `{adt}(/* fields */)`\",\n+                    adt=ty,\n+                    kind_name=kind_name\n+                ));\n+            }\n+            _ => {\n+                // prevent all specified fields from being suggested\n+                let skip_fields = skip_fields.iter().map(|ref x| x.ident.as_str());\n+                if let Some(field_name) = Self::suggest_field_name(\n+                    variant,\n+                    &field.ident.as_str(),\n+                    skip_fields.collect()\n+                ) {\n+                    err.span_suggestion(\n+                        field.ident.span,\n+                        \"a field with a similar name exists\",\n+                        field_name.to_string(),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                } else {\n+                    match ty.sty {\n+                        ty::Adt(adt, ..) => {\n+                            if adt.is_enum() {\n+                                err.span_label(field.ident.span, format!(\n+                                    \"`{}::{}` does not have this field\",\n+                                    ty,\n+                                    variant.ident\n+                                ));\n+                            } else {\n+                                err.span_label(field.ident.span, format!(\n+                                    \"`{}` does not have this field\",\n+                                    ty\n+                                ));\n+                            }\n+                            let available_field_names = self.available_field_names(variant);\n+                            if !available_field_names.is_empty() {\n+                                err.note(&format!(\"available fields are: {}\",\n+                                                  self.name_series_display(available_field_names)));\n+                            }\n+                        }\n+                        _ => bug!(\"non-ADT passed to report_unknown_field\")\n                     }\n-                }\n-                _ => bug!(\"non-ADT passed to report_unknown_field\")\n+                };\n             }\n-        };\n+        }\n         err.emit();\n     }\n "}, {"sha": "72f42c85eadafd7faed079eab35c9904c4cb4f66", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -6,17 +6,18 @@\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::{self, Pat, PatKind, Expr};\n-use rustc::middle::region;\n+use rustc::middle::region::{self, YieldData};\n use rustc::ty::{self, Ty};\n use syntax_pos::Span;\n use super::FnCtxt;\n use crate::util::nodemap::FxHashMap;\n \n-struct InteriorVisitor<'a, 'tcx: 'a> {\n+struct InteriorVisitor<'a, 'tcx> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     types: FxHashMap<Ty<'tcx>, usize>,\n     region_scope_tree: &'tcx region::ScopeTree,\n     expr_count: usize,\n+    kind: hir::GeneratorKind,\n }\n \n impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n@@ -27,8 +28,8 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n               source_span: Span) {\n         use syntax_pos::DUMMY_SP;\n \n-        let live_across_yield = scope.map_or(Some(DUMMY_SP), |s| {\n-            self.region_scope_tree.yield_in_scope(s).and_then(|(yield_span, expr_count)| {\n+        let live_across_yield = scope.map(|s| {\n+            self.region_scope_tree.yield_in_scope(s).and_then(|yield_data| {\n                 // If we are recording an expression that is the last yield\n                 // in the scope, or that has a postorder CFG index larger\n                 // than the one of all of the yields, then its value can't\n@@ -37,31 +38,43 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n                 // See the mega-comment at `yield_in_scope` for a proof.\n \n                 debug!(\"comparing counts yield: {} self: {}, source_span = {:?}\",\n-                       expr_count, self.expr_count, source_span);\n+                       yield_data.expr_and_pat_count, self.expr_count, source_span);\n \n-                if expr_count >= self.expr_count {\n-                    Some(yield_span)\n+                if yield_data.expr_and_pat_count >= self.expr_count {\n+                    Some(yield_data)\n                 } else {\n                     None\n                 }\n             })\n-        });\n-\n-        if let Some(yield_span) = live_across_yield {\n+        }).unwrap_or_else(|| Some(YieldData {\n+            span: DUMMY_SP,\n+            expr_and_pat_count: 0,\n+            source: match self.kind { // Guess based on the kind of the current generator.\n+                hir::GeneratorKind::Gen => hir::YieldSource::Yield,\n+                hir::GeneratorKind::Async => hir::YieldSource::Await,\n+            },\n+        }));\n+\n+        if let Some(yield_data) = live_across_yield {\n             let ty = self.fcx.resolve_vars_if_possible(&ty);\n \n             debug!(\"type in expr = {:?}, scope = {:?}, type = {:?}, count = {}, yield_span = {:?}\",\n-                   expr, scope, ty, self.expr_count, yield_span);\n+                   expr, scope, ty, self.expr_count, yield_data.span);\n \n             if let Some((unresolved_type, unresolved_type_span)) =\n                 self.fcx.unresolved_type_vars(&ty)\n             {\n+                let note = format!(\"the type is part of the {} because of this {}\",\n+                                   self.kind,\n+                                   yield_data.source);\n+\n                 // If unresolved type isn't a ty_var then unresolved_type_span is None\n                 self.fcx.need_type_info_err_in_generator(\n-                    unresolved_type_span.unwrap_or(yield_span),\n-                    unresolved_type)\n-                    .span_note(yield_span,\n-                               \"the type is part of the generator because of this `yield`\")\n+                    self.kind,\n+                    unresolved_type_span.unwrap_or(yield_data.span),\n+                    unresolved_type,\n+                )\n+                    .span_note(yield_data.span, &*note)\n                     .emit();\n             } else {\n                 // Map the type to the number of types added before it\n@@ -80,13 +93,15 @@ pub fn resolve_interior<'a, 'tcx>(\n     def_id: DefId,\n     body_id: hir::BodyId,\n     interior: Ty<'tcx>,\n+    kind: hir::GeneratorKind,\n ) {\n     let body = fcx.tcx.hir().body(body_id);\n     let mut visitor = InteriorVisitor {\n         fcx,\n         types: FxHashMap::default(),\n         region_scope_tree: fcx.tcx.region_scope_tree(def_id),\n         expr_count: 0,\n+        kind,\n     };\n     intravisit::walk_body(&mut visitor, body);\n "}, {"sha": "8c2b8d1565f2f033e0dbeede85cb654ccbe488c3", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 13, "deletions": 27, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -83,12 +83,15 @@ pub fn check_intrinsic_type<'tcx>(tcx: TyCtxt<'tcx>, it: &hir::ForeignItem) {\n     let param = |n| tcx.mk_ty_param(n, InternedString::intern(&format!(\"P{}\", n)));\n     let name = it.ident.as_str();\n \n-    let mk_va_list_ty = || {\n+    let mk_va_list_ty = |mutbl| {\n         tcx.lang_items().va_list().map(|did| {\n             let region = tcx.mk_region(ty::ReLateBound(ty::INNERMOST, ty::BrAnon(0)));\n             let env_region = ty::ReLateBound(ty::INNERMOST, ty::BrEnv);\n             let va_list_ty = tcx.type_of(did).subst(tcx, &[region.into()]);\n-            tcx.mk_mut_ref(tcx.mk_region(env_region), va_list_ty)\n+            (tcx.mk_ref(tcx.mk_region(env_region), ty::TypeAndMut {\n+                ty: va_list_ty,\n+                mutbl\n+            }), va_list_ty)\n         })\n     };\n \n@@ -340,42 +343,25 @@ pub fn check_intrinsic_type<'tcx>(tcx: TyCtxt<'tcx>, it: &hir::ForeignItem) {\n             }\n \n             \"va_start\" | \"va_end\" => {\n-                match mk_va_list_ty() {\n-                    Some(va_list_ty) => (0, vec![va_list_ty], tcx.mk_unit()),\n+                match mk_va_list_ty(hir::MutMutable) {\n+                    Some((va_list_ref_ty, _)) => (0, vec![va_list_ref_ty], tcx.mk_unit()),\n                     None => bug!(\"`va_list` language item needed for C-variadic intrinsics\")\n                 }\n             }\n \n             \"va_copy\" => {\n-                match tcx.lang_items().va_list() {\n-                    Some(did) => {\n-                        let region = tcx.mk_region(ty::ReLateBound(ty::INNERMOST, ty::BrAnon(0)));\n-                        let env_region = ty::ReLateBound(ty::INNERMOST, ty::BrEnv);\n-                        let va_list_ty = tcx.type_of(did).subst(tcx, &[region.into()]);\n-                        let ret_ty = match va_list_ty.sty {\n-                            ty::Adt(def, _) if def.is_struct() => {\n-                                let fields = &def.non_enum_variant().fields;\n-                                match tcx.type_of(fields[0].did).subst(tcx, &[region.into()]).sty {\n-                                    ty::Ref(_, element_ty, _) => match element_ty.sty {\n-                                        ty::Adt(..) => element_ty,\n-                                        _ => va_list_ty\n-                                    }\n-                                    _ => bug!(\"va_list structure is invalid\")\n-                                }\n-                            }\n-                            _ => {\n-                                bug!(\"va_list structure is invalid\")\n-                            }\n-                        };\n-                        (0, vec![tcx.mk_imm_ref(tcx.mk_region(env_region), va_list_ty)], ret_ty)\n+                match mk_va_list_ty(hir::MutImmutable) {\n+                    Some((va_list_ref_ty, va_list_ty)) => {\n+                        let va_list_ptr_ty = tcx.mk_mut_ptr(va_list_ty);\n+                        (0, vec![va_list_ptr_ty, va_list_ref_ty], tcx.mk_unit())\n                     }\n                     None => bug!(\"`va_list` language item needed for C-variadic intrinsics\")\n                 }\n             }\n \n             \"va_arg\" => {\n-                match mk_va_list_ty() {\n-                    Some(va_list_ty) => (1, vec![va_list_ty], param(0)),\n+                match mk_va_list_ty(hir::MutMutable) {\n+                    Some((va_list_ref_ty, _)) => (1, vec![va_list_ref_ty], param(0)),\n                     None => bug!(\"`va_list` language item needed for C-variadic intrinsics\")\n                 }\n             }"}, {"sha": "5943302c7088f3c5f007eb063e1e7a3fdea7780d", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -264,7 +264,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 // local binding\n                                 if let &QPath::Resolved(_, ref path) = &qpath {\n                                     if let hir::def::Res::Local(hir_id) = path.res {\n-                                        let span = tcx.hir().span_by_hir_id(hir_id);\n+                                        let span = tcx.hir().span(hir_id);\n                                         let snippet = tcx.sess.source_map().span_to_snippet(span);\n                                         let filename = tcx.sess.source_map().span_to_filename(span);\n \n@@ -370,7 +370,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         });\n \n                     if let Some((field, field_ty)) = field_receiver {\n-                        let scope = self.tcx.hir().get_module_parent_by_hir_id(self.body_id);\n+                        let scope = self.tcx.hir().get_module_parent(self.body_id);\n                         let is_accessible = field.vis.is_accessible_from(scope, self.tcx);\n \n                         if is_accessible {\n@@ -564,7 +564,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                               err: &mut DiagnosticBuilder<'_>,\n                               mut msg: String,\n                               candidates: Vec<DefId>) {\n-        let module_did = self.tcx.hir().get_module_parent_by_hir_id(self.body_id);\n+        let module_did = self.tcx.hir().get_module_parent(self.body_id);\n         let module_id = self.tcx.hir().as_local_hir_id(module_did).unwrap();\n         let krate = self.tcx.hir().krate();\n         let (span, found_use) = UsePlacementFinder::check(self.tcx, krate, module_id);\n@@ -787,7 +787,7 @@ fn compute_all_traits<'tcx>(tcx: TyCtxt<'tcx>) -> Vec<DefId> {\n \n     // Crate-local:\n \n-    struct Visitor<'a, 'tcx: 'a> {\n+    struct Visitor<'a, 'tcx> {\n         map: &'a hir_map::Map<'tcx>,\n         traits: &'a mut Vec<DefId>,\n     }\n@@ -897,7 +897,7 @@ impl hir::intravisit::Visitor<'tcx> for UsePlacementFinder<'tcx> {\n         }\n         // Find a `use` statement.\n         for item_id in &module.item_ids {\n-            let item = self.tcx.hir().expect_item_by_hir_id(item_id.id);\n+            let item = self.tcx.hir().expect_item(item_id.id);\n             match item.node {\n                 hir::ItemKind::Use(..) => {\n                     // Don't suggest placing a `use` before the prelude"}, {"sha": "0e83db48284a80e5ac3d24aff4c528d3653922c2", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 139, "deletions": 115, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -160,7 +160,7 @@ pub struct LocalTy<'tcx> {\n \n /// A wrapper for `InferCtxt`'s `in_progress_tables` field.\n #[derive(Copy, Clone)]\n-struct MaybeInProgressTables<'a, 'tcx: 'a> {\n+struct MaybeInProgressTables<'a, 'tcx> {\n     maybe_tables: Option<&'a RefCell<ty::TypeckTables<'tcx>>>,\n }\n \n@@ -193,7 +193,7 @@ impl<'a, 'tcx> MaybeInProgressTables<'a, 'tcx> {\n /// Here, the function `foo()` and the closure passed to\n /// `bar()` will each have their own `FnCtxt`, but they will\n /// share the inherited fields.\n-pub struct Inherited<'a, 'tcx: 'a> {\n+pub struct Inherited<'a, 'tcx> {\n     infcx: InferCtxt<'a, 'tcx>,\n \n     tables: MaybeInProgressTables<'a, 'tcx>,\n@@ -217,7 +217,7 @@ pub struct Inherited<'a, 'tcx: 'a> {\n \n     deferred_cast_checks: RefCell<Vec<cast::CastCheck<'tcx>>>,\n \n-    deferred_generator_interiors: RefCell<Vec<(hir::BodyId, Ty<'tcx>)>>,\n+    deferred_generator_interiors: RefCell<Vec<(hir::BodyId, Ty<'tcx>, hir::GeneratorKind)>>,\n \n     // Opaque types found in explicit return types and their\n     // associated fresh inference variable. Writeback resolves these\n@@ -512,7 +512,7 @@ impl<'tcx> EnclosingBreakables<'tcx> {\n     }\n }\n \n-pub struct FnCtxt<'a, 'tcx: 'a> {\n+pub struct FnCtxt<'a, 'tcx> {\n     body_id: hir::HirId,\n \n     /// The parameter environment used for proving trait obligations\n@@ -622,7 +622,7 @@ impl Inherited<'a, 'tcx> {\n     fn new(infcx: InferCtxt<'a, 'tcx>, def_id: DefId) -> Self {\n         let tcx = infcx.tcx;\n         let item_id = tcx.hir().as_local_hir_id(def_id);\n-        let body_id = item_id.and_then(|id| tcx.hir().maybe_body_owned_by_by_hir_id(id));\n+        let body_id = item_id.and_then(|id| tcx.hir().maybe_body_owned_by(id));\n         let implicit_region_bound = body_id.map(|body_id| {\n             let body = tcx.hir().body(body_id);\n             tcx.mk_region(ty::ReScope(region::Scope {\n@@ -821,7 +821,7 @@ fn typeck_tables_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx ty::TypeckT\n     }\n \n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    let span = tcx.hir().span_by_hir_id(id);\n+    let span = tcx.hir().span(id);\n \n     // Figure out what primary body this item has.\n     let (body_id, fn_decl) = primary_body_of(tcx, id).unwrap_or_else(|| {\n@@ -919,7 +919,7 @@ fn check_abi<'tcx>(tcx: TyCtxt<'tcx>, span: Span, abi: Abi) {\n     }\n }\n \n-struct GatherLocalsVisitor<'a, 'tcx: 'a> {\n+struct GatherLocalsVisitor<'a, 'tcx> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     parent_id: hir::HirId,\n }\n@@ -1071,7 +1071,7 @@ fn check_fn<'a, 'tcx>(\n \n     let span = body.value.span;\n \n-    if body.is_generator && can_be_generator.is_some() {\n+    if body.generator_kind.is_some() && can_be_generator.is_some() {\n         let yield_ty = fcx.next_ty_var(TypeVariableOrigin {\n             kind: TypeVariableOriginKind::TypeInference,\n             span,\n@@ -1108,12 +1108,12 @@ fn check_fn<'a, 'tcx>(\n     // We insert the deferred_generator_interiors entry after visiting the body.\n     // This ensures that all nested generators appear before the entry of this generator.\n     // resolve_generator_interiors relies on this property.\n-    let gen_ty = if can_be_generator.is_some() && body.is_generator {\n+    let gen_ty = if let (Some(_), Some(gen_kind)) = (can_be_generator, body.generator_kind) {\n         let interior = fcx.next_ty_var(TypeVariableOrigin {\n             kind: TypeVariableOriginKind::MiscVariable,\n             span,\n         });\n-        fcx.deferred_generator_interiors.borrow_mut().push((body.id(), interior));\n+        fcx.deferred_generator_interiors.borrow_mut().push((body.id(), interior, gen_kind));\n         Some(GeneratorTypes {\n             yield_ty: fcx.yield_ty.unwrap(),\n             interior,\n@@ -1193,7 +1193,7 @@ fn check_fn<'a, 'tcx>(\n                 }\n \n                 let inputs = fn_sig.inputs();\n-                let span = fcx.tcx.hir().span_by_hir_id(fn_id);\n+                let span = fcx.tcx.hir().span(fn_id);\n                 if inputs.len() == 1 {\n                     let arg_is_panic_info = match inputs[0].sty {\n                         ty::Ref(region, ty, mutbl) => match ty.sty {\n@@ -1246,7 +1246,7 @@ fn check_fn<'a, 'tcx>(\n                 }\n \n                 let inputs = fn_sig.inputs();\n-                let span = fcx.tcx.hir().span_by_hir_id(fn_id);\n+                let span = fcx.tcx.hir().span(fn_id);\n                 if inputs.len() == 1 {\n                     let arg_is_alloc_layout = match inputs[0].sty {\n                         ty::Adt(ref adt, _) => {\n@@ -1448,7 +1448,7 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt<'_>, id: DefId, span: Span)\n     };\n     let param_env = ty::ParamEnv::reveal_all();\n     if let Ok(static_) = tcx.const_eval(param_env.and(cid)) {\n-        let alloc = if let ConstValue::ByRef(_, allocation) = static_.val {\n+        let alloc = if let ConstValue::ByRef(_, _, allocation) = static_.val {\n             allocation\n         } else {\n             bug!(\"Matching on non-ByRef static\")\n@@ -1788,32 +1788,71 @@ fn check_packed_inner<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, stack: &mut Vec<De\n     false\n }\n \n+/// Emit an error when encountering more or less than one variant in a transparent enum.\n+fn bad_variant_count<'tcx>(tcx: TyCtxt<'tcx>, adt: &'tcx ty::AdtDef, sp: Span, did: DefId) {\n+    let variant_spans: Vec<_> = adt.variants.iter().map(|variant| {\n+        tcx.hir().span_if_local(variant.def_id).unwrap()\n+    }).collect();\n+    let msg = format!(\n+        \"needs exactly one variant, but has {}\",\n+        adt.variants.len(),\n+    );\n+    let mut err = struct_span_err!(tcx.sess, sp, E0731, \"transparent enum {}\", msg);\n+    err.span_label(sp, &msg);\n+    if let &[ref start.., ref end] = &variant_spans[..] {\n+        for variant_span in start {\n+            err.span_label(*variant_span, \"\");\n+        }\n+        err.span_label(*end, &format!(\"too many variants in `{}`\", tcx.def_path_str(did)));\n+    }\n+    err.emit();\n+}\n+\n+/// Emit an error when encountering more or less than one non-zero-sized field in a transparent\n+/// enum.\n+fn bad_non_zero_sized_fields<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    adt: &'tcx ty::AdtDef,\n+    field_count: usize,\n+    field_spans: impl Iterator<Item = Span>,\n+    sp: Span,\n+) {\n+    let msg = format!(\"needs exactly one non-zero-sized field, but has {}\", field_count);\n+    let mut err = struct_span_err!(\n+        tcx.sess,\n+        sp,\n+        E0690,\n+        \"{}transparent {} {}\",\n+        if adt.is_enum() { \"the variant of a \" } else { \"\" },\n+        adt.descr(),\n+        msg,\n+    );\n+    err.span_label(sp, &msg);\n+    for sp in field_spans {\n+        err.span_label(sp, \"this field is non-zero-sized\");\n+    }\n+    err.emit();\n+}\n+\n fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, def_id: DefId) {\n     let adt = tcx.adt_def(def_id);\n     if !adt.repr.transparent() {\n         return;\n     }\n+    let sp = tcx.sess.source_map().def_span(sp);\n \n     if adt.is_enum() {\n         if !tcx.features().transparent_enums {\n-            emit_feature_err(&tcx.sess.parse_sess,\n-                             sym::transparent_enums,\n-                             sp,\n-                             GateIssue::Language,\n-                             \"transparent enums are unstable\");\n+            emit_feature_err(\n+                &tcx.sess.parse_sess,\n+                sym::transparent_enums,\n+                sp,\n+                GateIssue::Language,\n+                \"transparent enums are unstable\",\n+            );\n         }\n         if adt.variants.len() != 1 {\n-            let variant_spans: Vec<_> = adt.variants.iter().map(|variant| {\n-                tcx.hir().span_if_local(variant.def_id).unwrap()\n-            }).collect();\n-            let mut err = struct_span_err!(tcx.sess, sp, E0731,\n-                            \"transparent enum needs exactly one variant, but has {}\",\n-                            adt.variants.len());\n-            if !variant_spans.is_empty() {\n-                err.span_note(variant_spans, &format!(\"the following variants exist on `{}`\",\n-                                                      tcx.def_path_str(def_id)));\n-            }\n-            err.emit();\n+            bad_variant_count(tcx, adt, sp, def_id);\n             if adt.variants.is_empty() {\n                 // Don't bother checking the fields. No variants (and thus no fields) exist.\n                 return;\n@@ -1841,28 +1880,24 @@ fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, def_id: DefId) {\n         (span, zst, align1)\n     });\n \n-    let non_zst_fields = field_infos.clone().filter(|(_span, zst, _align1)| !*zst);\n+    let non_zst_fields = field_infos.clone().filter_map(|(span, zst, _align1)| if !zst {\n+        Some(span)\n+    } else {\n+        None\n+    });\n     let non_zst_count = non_zst_fields.clone().count();\n     if non_zst_count != 1 {\n-        let field_spans: Vec<_> = non_zst_fields.map(|(span, _zst, _align1)| span).collect();\n-\n-        let mut err = struct_span_err!(tcx.sess, sp, E0690,\n-                         \"{}transparent {} needs exactly one non-zero-sized field, but has {}\",\n-                         if adt.is_enum() { \"the variant of a \" } else { \"\" },\n-                         adt.descr(),\n-                         non_zst_count);\n-        if !field_spans.is_empty() {\n-            err.span_note(field_spans,\n-                          &format!(\"the following non-zero-sized fields exist on `{}`:\",\n-                                   tcx.def_path_str(def_id)));\n-        }\n-        err.emit();\n+        bad_non_zero_sized_fields(tcx, adt, non_zst_count, non_zst_fields, sp);\n     }\n     for (span, zst, align1) in field_infos {\n         if zst && !align1 {\n-            span_err!(tcx.sess, span, E0691,\n-                      \"zero-sized field in transparent {} has alignment larger than 1\",\n-                      adt.descr());\n+            struct_span_err!(\n+                tcx.sess,\n+                span,\n+                E0691,\n+                \"zero-sized field in transparent {} has alignment larger than 1\",\n+                adt.descr(),\n+            ).span_label(span, \"has alignment larger than 1\").emit();\n         }\n     }\n }\n@@ -1909,11 +1944,11 @@ pub fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, vs: &'tcx [hir::Variant], i\n             let variant_i_hir_id = tcx.hir().as_local_hir_id(variant_did).unwrap();\n             let variant_i = tcx.hir().expect_variant(variant_i_hir_id);\n             let i_span = match variant_i.node.disr_expr {\n-                Some(ref expr) => tcx.hir().span_by_hir_id(expr.hir_id),\n-                None => tcx.hir().span_by_hir_id(variant_i_hir_id)\n+                Some(ref expr) => tcx.hir().span(expr.hir_id),\n+                None => tcx.hir().span(variant_i_hir_id)\n             };\n             let span = match v.node.disr_expr {\n-                Some(ref expr) => tcx.hir().span_by_hir_id(expr.hir_id),\n+                Some(ref expr) => tcx.hir().span(expr.hir_id),\n                 None => v.span\n             };\n             struct_span_err!(tcx.sess, span, E0081,\n@@ -2181,7 +2216,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn local_ty(&self, span: Span, nid: hir::HirId) -> LocalTy<'tcx> {\n         self.locals.borrow().get(&nid).cloned().unwrap_or_else(||\n             span_bug!(span, \"no type for local variable {}\",\n-                      self.tcx.hir().hir_to_string(nid))\n+                      self.tcx.hir().node_to_string(nid))\n         )\n     }\n \n@@ -2517,9 +2552,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Some(&t) => t,\n             None if self.is_tainted_by_errors() => self.tcx.types.err,\n             None => {\n-                let node_id = self.tcx.hir().hir_to_node_id(id);\n                 bug!(\"no type for node {}: {} in fcx {}\",\n-                     node_id, self.tcx.hir().node_to_string(node_id),\n+                     id, self.tcx.hir().node_to_string(id),\n                      self.tag());\n             }\n         }\n@@ -2599,9 +2633,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn resolve_generator_interiors(&self, def_id: DefId) {\n         let mut generators = self.deferred_generator_interiors.borrow_mut();\n-        for (body_id, interior) in generators.drain(..) {\n+        for (body_id, interior, kind) in generators.drain(..) {\n             self.select_obligations_where_possible(false);\n-            generator_interior::resolve_interior(self, def_id, body_id, interior);\n+            generator_interior::resolve_interior(self, def_id, body_id, interior, kind);\n         }\n     }\n \n@@ -3662,39 +3696,39 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     /// Given a function block's `HirId`, returns its `FnDecl` if it exists, or `None` otherwise.\n-    fn get_parent_fn_decl(&self, blk_id: hir::HirId) -> Option<(hir::FnDecl, ast::Ident)> {\n+    fn get_parent_fn_decl(&self, blk_id: hir::HirId) -> Option<(&'tcx hir::FnDecl, ast::Ident)> {\n         let parent = self.tcx.hir().get_by_hir_id(self.tcx.hir().get_parent_item(blk_id));\n         self.get_node_fn_decl(parent).map(|(fn_decl, ident, _)| (fn_decl, ident))\n     }\n \n     /// Given a function `Node`, return its `FnDecl` if it exists, or `None` otherwise.\n-    fn get_node_fn_decl(&self, node: Node<'_>) -> Option<(hir::FnDecl, ast::Ident, bool)> {\n+    fn get_node_fn_decl(&self, node: Node<'tcx>) -> Option<(&'tcx hir::FnDecl, ast::Ident, bool)> {\n         match node {\n             Node::Item(&hir::Item {\n                 ident, node: hir::ItemKind::Fn(ref decl, ..), ..\n-            }) => decl.clone().and_then(|decl| {\n+            }) => {\n                 // This is less than ideal, it will not suggest a return type span on any\n                 // method called `main`, regardless of whether it is actually the entry point,\n                 // but it will still present it as the reason for the expected type.\n                 Some((decl, ident, ident.name != sym::main))\n-            }),\n+            }\n             Node::TraitItem(&hir::TraitItem {\n                 ident, node: hir::TraitItemKind::Method(hir::MethodSig {\n                     ref decl, ..\n                 }, ..), ..\n-            }) => decl.clone().and_then(|decl| Some((decl, ident, true))),\n+            }) => Some((decl, ident, true)),\n             Node::ImplItem(&hir::ImplItem {\n                 ident, node: hir::ImplItemKind::Method(hir::MethodSig {\n                     ref decl, ..\n                 }, ..), ..\n-            }) => decl.clone().and_then(|decl| Some((decl, ident, false))),\n+            }) => Some((decl, ident, false)),\n             _ => None,\n         }\n     }\n \n     /// Given a `HirId`, return the `FnDecl` of the method it is enclosed by and whether a\n     /// suggestion can be made, `None` otherwise.\n-    pub fn get_fn_decl(&self, blk_id: hir::HirId) -> Option<(hir::FnDecl, bool)> {\n+    pub fn get_fn_decl(&self, blk_id: hir::HirId) -> Option<(&'tcx hir::FnDecl, bool)> {\n         // Get enclosing Fn, if it is a function or a trait method, unless there's a `loop` or\n         // `while` before reaching it, as block tail returns are not available in them.\n         self.tcx.hir().get_return_block(blk_id).and_then(|blk_id| {\n@@ -3923,52 +3957,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         Some(original_span.with_lo(original_span.hi() - BytePos(1)))\n     }\n \n-    // Rewrite `SelfCtor` to `Ctor`\n-    pub fn rewrite_self_ctor(\n-        &self,\n-        res: Res,\n-        span: Span,\n-    ) -> Result<Res, ErrorReported> {\n-        let tcx = self.tcx;\n-        if let Res::SelfCtor(impl_def_id) = res {\n-            let ty = self.impl_self_ty(span, impl_def_id).ty;\n-            let adt_def = ty.ty_adt_def();\n-\n-            match adt_def {\n-                Some(adt_def) if adt_def.has_ctor() => {\n-                    let variant = adt_def.non_enum_variant();\n-                    let ctor_def_id = variant.ctor_def_id.unwrap();\n-                    Ok(Res::Def(DefKind::Ctor(CtorOf::Struct, variant.ctor_kind), ctor_def_id))\n-                }\n-                _ => {\n-                    let mut err = tcx.sess.struct_span_err(span,\n-                        \"the `Self` constructor can only be used with tuple or unit structs\");\n-                    if let Some(adt_def) = adt_def {\n-                        match adt_def.adt_kind() {\n-                            AdtKind::Enum => {\n-                                err.help(\"did you mean to use one of the enum's variants?\");\n-                            },\n-                            AdtKind::Struct |\n-                            AdtKind::Union => {\n-                                err.span_suggestion(\n-                                    span,\n-                                    \"use curly brackets\",\n-                                    String::from(\"Self { /* fields */ }\"),\n-                                    Applicability::HasPlaceholders,\n-                                );\n-                            }\n-                        }\n-                    }\n-                    err.emit();\n-\n-                    Err(ErrorReported)\n-                }\n-            }\n-        } else {\n-            Ok(res)\n-        }\n-    }\n-\n     // Instantiates the given path, which must refer to an item with the given\n     // number of type parameters and type.\n     pub fn instantiate_value_path(&self,\n@@ -3988,12 +3976,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let tcx = self.tcx;\n \n-        let res = match self.rewrite_self_ctor(res, span) {\n-            Ok(res) => res,\n-            Err(ErrorReported) => return (tcx.types.err, res),\n-        };\n         let path_segs = match res {\n-            Res::Local(_) => vec![],\n+            Res::Local(_) | Res::SelfCtor(_) => vec![],\n             Res::Def(kind, def_id) =>\n                 AstConv::def_ids_for_value_path_segments(self, segments, self_ty, kind, def_id),\n             _ => bug!(\"instantiate_value_path on {:?}\", res),\n@@ -4098,13 +4082,53 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             tcx.generics_of(*def_id).has_self\n         }).unwrap_or(false);\n \n+        let (res, self_ctor_substs) = if let Res::SelfCtor(impl_def_id) = res {\n+            let ty = self.impl_self_ty(span, impl_def_id).ty;\n+            let adt_def = ty.ty_adt_def();\n+\n+            match ty.sty {\n+                ty::Adt(adt_def, substs) if adt_def.has_ctor() => {\n+                    let variant = adt_def.non_enum_variant();\n+                    let ctor_def_id = variant.ctor_def_id.unwrap();\n+                    (\n+                        Res::Def(DefKind::Ctor(CtorOf::Struct, variant.ctor_kind), ctor_def_id),\n+                        Some(substs),\n+                    )\n+                }\n+                _ => {\n+                    let mut err = tcx.sess.struct_span_err(span,\n+                        \"the `Self` constructor can only be used with tuple or unit structs\");\n+                    if let Some(adt_def) = adt_def {\n+                        match adt_def.adt_kind() {\n+                            AdtKind::Enum => {\n+                                err.help(\"did you mean to use one of the enum's variants?\");\n+                            },\n+                            AdtKind::Struct |\n+                            AdtKind::Union => {\n+                                err.span_suggestion(\n+                                    span,\n+                                    \"use curly brackets\",\n+                                    String::from(\"Self { /* fields */ }\"),\n+                                    Applicability::HasPlaceholders,\n+                                );\n+                            }\n+                        }\n+                    }\n+                    err.emit();\n+\n+                    return (tcx.types.err, res)\n+                }\n+            }\n+        } else {\n+            (res, None)\n+        };\n         let def_id = res.def_id();\n \n         // The things we are substituting into the type should not contain\n         // escaping late-bound regions, and nor should the base type scheme.\n         let ty = tcx.type_of(def_id);\n \n-        let substs = AstConv::create_substs_for_generic_args(\n+        let substs = self_ctor_substs.unwrap_or_else(|| AstConv::create_substs_for_generic_args(\n             tcx,\n             def_id,\n             &[][..],\n@@ -4174,7 +4198,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n             },\n-        );\n+        ));\n         assert!(!substs.has_escaping_bound_vars());\n         assert!(!ty.has_escaping_bound_vars());\n \n@@ -4364,7 +4388,7 @@ pub fn check_bounds_are_used<'tcx>(tcx: TyCtxt<'tcx>, generics: &ty::Generics, t\n     for (&used, param) in types_used.iter().zip(types) {\n         if !used {\n             let id = tcx.hir().as_local_hir_id(param.def_id).unwrap();\n-            let span = tcx.hir().span_by_hir_id(id);\n+            let span = tcx.hir().span(id);\n             struct_span_err!(tcx.sess, span, E0091, \"type parameter `{}` is unused\", param.name)\n                 .span_label(span, \"unused type parameter\")\n                 .emit();"}, {"sha": "5c710399446efba6bc63097365b522728220d71d", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -175,7 +175,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         if self.err_count_since_creation() == 0 {\n             // regionck assumes typeck succeeded\n-            rcx.visit_fn_body(fn_id, body, self.tcx.hir().span_by_hir_id(fn_id));\n+            rcx.visit_fn_body(fn_id, body, self.tcx.hir().span(fn_id));\n         }\n \n         rcx.resolve_regions_and_report_errors(SuppressRegionErrors::when_nll_is_enabled(self.tcx));"}, {"sha": "034ff5f8347679387d5392ff5c4dde512e0a3be2", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -70,7 +70,7 @@ impl<'tcx> CheckWfFcxBuilder<'tcx> {\n /// the types first.\n pub fn check_item_well_formed<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    let item = tcx.hir().expect_item_by_hir_id(hir_id);\n+    let item = tcx.hir().expect_item(hir_id);\n \n     debug!(\"check_item_well_formed(it.hir_id={:?}, it.name={})\",\n            item.hir_id,"}, {"sha": "6a95dec1c81bc2a58bd542f32768cd41c9fc6efc", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -34,7 +34,7 @@ use syntax_pos::Span;\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn resolve_type_vars_in_body(&self, body: &'tcx hir::Body) -> &'tcx ty::TypeckTables<'tcx> {\n         let item_id = self.tcx.hir().body_owner(body.id());\n-        let item_def_id = self.tcx.hir().local_def_id(item_id);\n+        let item_def_id = self.tcx.hir().local_def_id_from_hir_id(item_id);\n \n         // This attribute causes us to dump some writeback information\n         // in the form of errors, which is uSymbolfor unit tests.\n@@ -47,8 +47,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Type only exists for constants and statics, not functions.\n         match self.tcx.hir().body_owner_kind(item_id) {\n             hir::BodyOwnerKind::Const | hir::BodyOwnerKind::Static(_) => {\n-                let item_hir_id = self.tcx.hir().node_to_hir_id(item_id);\n-                wbcx.visit_node_id(body.value.span, item_hir_id);\n+                wbcx.visit_node_id(body.value.span, item_id);\n             }\n             hir::BodyOwnerKind::Closure | hir::BodyOwnerKind::Fn => (),\n         }\n@@ -97,7 +96,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n // there, it applies a few ad-hoc checks that were not convenient to\n // do elsewhere.\n \n-struct WritebackCx<'cx, 'tcx: 'cx> {\n+struct WritebackCx<'cx, 'tcx> {\n     fcx: &'cx FnCtxt<'cx, 'tcx>,\n \n     tables: ty::TypeckTables<'tcx>,\n@@ -399,7 +398,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             if let ty::UserType::TypeOf(_, user_substs) = c_ty.value {\n                 if self.rustc_dump_user_substs {\n                     // This is a unit-testing mechanism.\n-                    let span = self.tcx().hir().span_by_hir_id(hir_id);\n+                    let span = self.tcx().hir().span(hir_id);\n                     // We need to buffer the errors in order to guarantee a consistent\n                     // order when emitting them.\n                     let err = self.tcx().sess.struct_span_err(\n@@ -774,21 +773,21 @@ impl Locatable for Span {\n impl Locatable for DefIndex {\n     fn to_span(&self, tcx: TyCtxt<'_>) -> Span {\n         let hir_id = tcx.hir().def_index_to_hir_id(*self);\n-        tcx.hir().span_by_hir_id(hir_id)\n+        tcx.hir().span(hir_id)\n     }\n }\n \n impl Locatable for hir::HirId {\n     fn to_span(&self, tcx: TyCtxt<'_>) -> Span {\n-        tcx.hir().span_by_hir_id(*self)\n+        tcx.hir().span(*self)\n     }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n // The Resolver. This is the type folding engine that detects\n // unresolved types and so forth.\n \n-struct Resolver<'cx, 'tcx: 'cx> {\n+struct Resolver<'cx, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n     span: &'cx dyn Locatable,"}, {"sha": "8f89a77bd1a3a3423a8c864ce74980d3a77b824a", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -121,7 +121,7 @@ fn unused_crates_lint<'tcx>(tcx: TyCtxt<'tcx>) {\n \n     for extern_crate in &crates_to_lint {\n         let id = tcx.hir().as_local_hir_id(extern_crate.def_id).unwrap();\n-        let item = tcx.hir().expect_item_by_hir_id(id);\n+        let item = tcx.hir().expect_item(id);\n \n         // If the crate is fully unused, we suggest removing it altogether.\n         // We do this in any edition.\n@@ -194,7 +194,7 @@ fn unused_crates_lint<'tcx>(tcx: TyCtxt<'tcx>) {\n     }\n }\n \n-struct CollectExternCrateVisitor<'a, 'tcx: 'a> {\n+struct CollectExternCrateVisitor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     crates_to_lint: &'a mut Vec<ExternCrateToLint>,\n }"}, {"sha": "e392622060c9b9e1fac4de0e59aed5da75800480", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -88,7 +88,7 @@ fn visit_implementation_of_copy<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) {\n     debug!(\"visit_implementation_of_copy: self_type={:?} (bound)\",\n            self_type);\n \n-    let span = tcx.hir().span_by_hir_id(impl_hir_id);\n+    let span = tcx.hir().span(impl_hir_id);\n     let param_env = tcx.param_env(impl_did);\n     assert!(!self_type.has_escaping_bound_vars());\n \n@@ -98,7 +98,7 @@ fn visit_implementation_of_copy<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) {\n     match param_env.can_type_implement_copy(tcx, self_type) {\n         Ok(()) => {}\n         Err(CopyImplementationError::InfrigingFields(fields)) => {\n-            let item = tcx.hir().expect_item_by_hir_id(impl_hir_id);\n+            let item = tcx.hir().expect_item(impl_hir_id);\n             let span = if let ItemKind::Impl(.., Some(ref tr), _, _) = item.node {\n                 tr.path.span\n             } else {\n@@ -115,7 +115,7 @@ fn visit_implementation_of_copy<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) {\n             err.emit()\n         }\n         Err(CopyImplementationError::NotAnAdt) => {\n-            let item = tcx.hir().expect_item_by_hir_id(impl_hir_id);\n+            let item = tcx.hir().expect_item(impl_hir_id);\n             let span = if let ItemKind::Impl(.., ref ty, _) = item.node {\n                 ty.span\n             } else {\n@@ -161,7 +161,7 @@ fn visit_implementation_of_dispatch_from_dyn<'tcx>(tcx: TyCtxt<'tcx>, impl_did:\n         let dispatch_from_dyn_trait = tcx.lang_items().dispatch_from_dyn_trait().unwrap();\n \n         let impl_hir_id = tcx.hir().as_local_hir_id(impl_did).unwrap();\n-        let span = tcx.hir().span_by_hir_id(impl_hir_id);\n+        let span = tcx.hir().span(impl_hir_id);\n \n         let source = tcx.type_of(impl_did);\n         assert!(!source.has_escaping_bound_vars());\n@@ -343,7 +343,7 @@ pub fn coerce_unsized_info<'tcx>(gcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n            source,\n            target);\n \n-    let span = gcx.hir().span_by_hir_id(impl_hir_id);\n+    let span = gcx.hir().span(impl_hir_id);\n     let param_env = gcx.param_env(impl_did);\n     assert!(!source.has_escaping_bound_vars());\n \n@@ -480,11 +480,11 @@ pub fn coerce_unsized_info<'tcx>(gcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n                                being coerced, none found\");\n                     return err_info;\n                 } else if diff_fields.len() > 1 {\n-                    let item = gcx.hir().expect_item_by_hir_id(impl_hir_id);\n+                    let item = gcx.hir().expect_item(impl_hir_id);\n                     let span = if let ItemKind::Impl(.., Some(ref t), _, _) = item.node {\n                         t.path.span\n                     } else {\n-                        gcx.hir().span_by_hir_id(impl_hir_id)\n+                        gcx.hir().span(impl_hir_id)\n                     };\n \n                     let mut err = struct_span_err!(gcx.sess,"}, {"sha": "4e6fcfe0593e2393a5bb0f765c6fd5c310af2ec3", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -26,7 +26,7 @@ impl ItemLikeVisitor<'v> for OrphanChecker<'tcx> {\n         // \"Trait\" impl\n         if let hir::ItemKind::Impl(.., Some(_), _, _) = item.node {\n             debug!(\"coherence2::orphan check: trait impl {}\",\n-                   self.tcx.hir().hir_to_string(item.hir_id));\n+                   self.tcx.hir().node_to_string(item.hir_id));\n             let trait_ref = self.tcx.impl_trait_ref(def_id).unwrap();\n             let trait_def_id = trait_ref.def_id;\n             let cm = self.tcx.sess.source_map();"}, {"sha": "52cda4ac3c6285ecb84f60adb600e050730da87a", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -165,7 +165,7 @@ impl ItemCtxt<'tcx> {\n         ItemCtxt { tcx, item_def_id }\n     }\n \n-    pub fn to_ty(&self, ast_ty: &hir::Ty) -> Ty<'tcx> {\n+    pub fn to_ty(&self, ast_ty: &'tcx hir::Ty) -> Ty<'tcx> {\n         AstConv::ast_ty_to_ty(self, ast_ty)\n     }\n }\n@@ -338,7 +338,7 @@ impl ItemCtxt<'tcx> {\n     /// bounds for a type parameter `X` if `X::Foo` is used.\n     fn type_parameter_bounds_in_generics(\n         &self,\n-        ast_generics: &hir::Generics,\n+        ast_generics: &'tcx hir::Generics,\n         param_id: hir::HirId,\n         ty: Ty<'tcx>,\n         only_self_bounds: OnlySelfBounds,\n@@ -395,7 +395,7 @@ fn is_param<'tcx>(tcx: TyCtxt<'tcx>, ast_ty: &hir::Ty, param_id: hir::HirId) ->\n }\n \n fn convert_item<'tcx>(tcx: TyCtxt<'tcx>, item_id: hir::HirId) {\n-    let it = tcx.hir().expect_item_by_hir_id(item_id);\n+    let it = tcx.hir().expect_item(item_id);\n     debug!(\"convert: item {} with id {}\", it.ident, it.hir_id);\n     let def_id = tcx.hir().local_def_id_from_hir_id(item_id);\n     match it.node {\n@@ -742,7 +742,7 @@ fn super_predicates_of<'tcx>(\n \n fn trait_def<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx ty::TraitDef {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    let item = tcx.hir().expect_item_by_hir_id(hir_id);\n+    let item = tcx.hir().expect_item(hir_id);\n \n     let (is_auto, unsafety) = match item.node {\n         hir::ItemKind::Trait(is_auto, unsafety, ..) => (is_auto == hir::IsAuto::Yes, unsafety),\n@@ -1177,7 +1177,7 @@ pub fn checked_type_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, fail: bool) -> Op\n             ImplItemKind::Const(ref ty, _) => icx.to_ty(ty),\n             ImplItemKind::Existential(_) => {\n                 if tcx\n-                    .impl_trait_ref(tcx.hir().get_parent_did_by_hir_id(hir_id))\n+                    .impl_trait_ref(tcx.hir().get_parent_did(hir_id))\n                     .is_none()\n                 {\n                     report_assoc_ty_on_inherent_impl(tcx, item.span);\n@@ -1187,7 +1187,7 @@ pub fn checked_type_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, fail: bool) -> Op\n             }\n             ImplItemKind::Type(ref ty) => {\n                 if tcx\n-                    .impl_trait_ref(tcx.hir().get_parent_did_by_hir_id(hir_id))\n+                    .impl_trait_ref(tcx.hir().get_parent_did(hir_id))\n                     .is_none()\n                 {\n                     report_assoc_ty_on_inherent_impl(tcx, item.span);\n@@ -1272,7 +1272,7 @@ pub fn checked_type_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, fail: bool) -> Op\n             ..\n         }) => match *def {\n             VariantData::Unit(..) | VariantData::Struct(..) => {\n-                tcx.type_of(tcx.hir().get_parent_did_by_hir_id(hir_id))\n+                tcx.type_of(tcx.hir().get_parent_did(hir_id))\n             }\n             VariantData::Tuple(..) => {\n                 let substs = InternalSubsts::identity_for_item(tcx, def_id);\n@@ -1325,7 +1325,7 @@ pub fn checked_type_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, fail: bool) -> Op\n                     ..\n                 }) if e.hir_id == hir_id =>\n                 {\n-                    tcx.adt_def(tcx.hir().get_parent_did_by_hir_id(hir_id))\n+                    tcx.adt_def(tcx.hir().get_parent_did(hir_id))\n                         .repr\n                         .discr_type()\n                         .to_ty(tcx)\n@@ -1709,15 +1709,15 @@ fn fn_sig<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> ty::PolyFnSig<'tcx> {\n             node: ForeignItemKind::Fn(ref fn_decl, _, _),\n             ..\n         }) => {\n-            let abi = tcx.hir().get_foreign_abi_by_hir_id(hir_id);\n+            let abi = tcx.hir().get_foreign_abi(hir_id);\n             compute_sig_of_foreign_fn_decl(tcx, def_id, fn_decl, abi)\n         }\n \n         Ctor(data) | Variant(Spanned {\n             node: hir::VariantKind { data, ..  },\n             ..\n         }) if data.ctor_hir_id().is_some() => {\n-            let ty = tcx.type_of(tcx.hir().get_parent_did_by_hir_id(hir_id));\n+            let ty = tcx.type_of(tcx.hir().get_parent_did(hir_id));\n             let inputs = data.fields()\n                 .iter()\n                 .map(|f| tcx.type_of(tcx.hir().local_def_id_from_hir_id(f.hir_id)));\n@@ -1762,7 +1762,7 @@ fn impl_trait_ref<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Option<ty::TraitRef\n     let icx = ItemCtxt::new(tcx, def_id);\n \n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    match tcx.hir().expect_item_by_hir_id(hir_id).node {\n+    match tcx.hir().expect_item(hir_id).node {\n         hir::ItemKind::Impl(.., ref opt_trait_ref, _, _) => {\n             opt_trait_ref.as_ref().map(|ast_trait_ref| {\n                 let selfty = tcx.type_of(def_id);\n@@ -1775,7 +1775,7 @@ fn impl_trait_ref<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Option<ty::TraitRef\n \n fn impl_polarity<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> hir::ImplPolarity {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    match tcx.hir().expect_item_by_hir_id(hir_id).node {\n+    match tcx.hir().expect_item(hir_id).node {\n         hir::ItemKind::Impl(_, polarity, ..) => polarity,\n         ref item => bug!(\"impl_polarity: {:?} not an impl\", item),\n     }\n@@ -1909,7 +1909,9 @@ fn explicit_predicates_of<'tcx>(\n     let mut is_default_impl_trait = None;\n \n     let icx = ItemCtxt::new(tcx, def_id);\n-    let no_generics = hir::Generics::empty();\n+\n+    const NO_GENERICS: &hir::Generics = &hir::Generics::empty();\n+\n     let empty_trait_items = HirVec::new();\n \n     let mut predicates = UniquePredicates::new();\n@@ -1991,17 +1993,17 @@ fn explicit_predicates_of<'tcx>(\n                     }\n                 }\n \n-                _ => &no_generics,\n+                _ => NO_GENERICS,\n             }\n         }\n \n         Node::ForeignItem(item) => match item.node {\n-            ForeignItemKind::Static(..) => &no_generics,\n+            ForeignItemKind::Static(..) => NO_GENERICS,\n             ForeignItemKind::Fn(_, _, ref generics) => generics,\n-            ForeignItemKind::Type => &no_generics,\n+            ForeignItemKind::Type => NO_GENERICS,\n         },\n \n-        _ => &no_generics,\n+        _ => NO_GENERICS,\n     };\n \n     let generics = tcx.generics_of(def_id);\n@@ -2205,7 +2207,7 @@ fn explicit_predicates_of<'tcx>(\n fn predicates_from_bound<'tcx>(\n     astconv: &dyn AstConv<'tcx>,\n     param_ty: Ty<'tcx>,\n-    bound: &hir::GenericBound,\n+    bound: &'tcx hir::GenericBound,\n ) -> Vec<(ty::Predicate<'tcx>, Span)> {\n     match *bound {\n         hir::GenericBound::Trait(ref tr, hir::TraitBoundModifier::None) => {\n@@ -2227,7 +2229,7 @@ fn predicates_from_bound<'tcx>(\n fn compute_sig_of_foreign_fn_decl<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n-    decl: &hir::FnDecl,\n+    decl: &'tcx hir::FnDecl,\n     abi: abi::Abi,\n ) -> ty::PolyFnSig<'tcx> {\n     let unsafety = if abi == abi::Abi::RustIntrinsic {"}, {"sha": "115ee0f72c9c1c114762ee562994061703418fae", "filename": "src/librustc_typeck/error_codes.rs", "status": "modified", "additions": 37, "deletions": 4, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Ferror_codes.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -3793,6 +3793,40 @@ details.\n [issue #33685]: https://github.com/rust-lang/rust/issues/33685\n \"##,\n \n+E0592: r##\"\n+This error occurs when you defined methods or associated functions with same\n+name.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0592\n+struct Foo;\n+\n+impl Foo {\n+    fn bar() {} // previous definition here\n+}\n+\n+impl Foo {\n+    fn bar() {} // duplicate definition here\n+}\n+```\n+\n+A similar error is E0201. The difference is whether there is one declaration\n+block or not. To avoid this error, you must give each `fn` a unique name.\n+\n+```\n+struct Foo;\n+\n+impl Foo {\n+    fn bar() {}\n+}\n+\n+impl Foo {\n+    fn baz() {} // define with different name\n+}\n+```\n+\"##,\n+\n E0599: r##\"\n This error occurs when a method is used on a type which doesn't implement it:\n \n@@ -3904,7 +3938,7 @@ x as Vec<u8>; // error: non-primitive cast: `u8` as `std::vec::Vec<u8>`\n \n // Another example\n \n-let v = 0 as *const u8; // So here, `v` is a `*const u8`.\n+let v = core::ptr::null::<u8>(); // So here, `v` is a `*const u8`.\n v as &u8; // error: non-primitive cast: `*const u8` as `&u8`\n ```\n \n@@ -3914,7 +3948,7 @@ Only primitive types can be cast into each other. Examples:\n let x = 0u8;\n x as u32; // ok!\n \n-let v = 0 as *const u8;\n+let v = core::ptr::null::<u8>();\n v as *const i8; // ok!\n ```\n \n@@ -3954,7 +3988,7 @@ A cast between a thin and a fat pointer was attempted.\n Erroneous code example:\n \n ```compile_fail,E0607\n-let v = 0 as *const u8;\n+let v = core::ptr::null::<u8>();\n v as *const [u8];\n ```\n \n@@ -4771,7 +4805,6 @@ register_diagnostics! {\n            // but `{}` was found in the type `{}`\n     E0587, // type has conflicting packed and align representation hints\n     E0588, // packed type cannot transitively contain a `[repr(align)]` type\n-    E0592, // duplicate definitions with name `{}`\n //  E0611, // merged into E0616\n //  E0612, // merged into E0609\n //  E0613, // Removed (merged with E0609)"}, {"sha": "1c2bb8c2f0b28f5f90f01e32ccf69cf83f515db3", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -43,7 +43,7 @@ pub fn infer_predicates<'tcx>(\n     global_inferred_outlives\n }\n \n-pub struct InferVisitor<'cx, 'tcx: 'cx> {\n+pub struct InferVisitor<'cx, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     global_inferred_outlives: &'cx mut FxHashMap<DefId, RequiredPredicates<'tcx>>,\n     predicates_added: &'cx mut bool,"}, {"sha": "36f0dbcd2fcbddc01ba3e783ace2c3c4d7b93785", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -12,7 +12,7 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use super::terms::*;\n use super::terms::VarianceTerm::*;\n \n-pub struct ConstraintContext<'a, 'tcx: 'a> {\n+pub struct ConstraintContext<'a, 'tcx> {\n     pub terms_cx: TermsContext<'a, 'tcx>,\n \n     // These are pointers to common `ConstantTerm` instances"}, {"sha": "5dbd667485e98d89fe63ec98473dfbde7456a22c", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -46,7 +46,7 @@ fn variances_of<'tcx>(tcx: TyCtxt<'tcx>, item_def_id: DefId) -> &'tcx [ty::Varia\n     let id = tcx.hir().as_local_hir_id(item_def_id).expect(\"expected local def-id\");\n     let unsupported = || {\n         // Variance not relevant.\n-        span_bug!(tcx.hir().span_by_hir_id(id), \"asked to compute variance for wrong kind of item\")\n+        span_bug!(tcx.hir().span(id), \"asked to compute variance for wrong kind of item\")\n     };\n     match tcx.hir().get_by_hir_id(id) {\n         Node::Item(item) => match item.node {"}, {"sha": "3851b918c4855a7ad0962cdae39d32621ba55c67", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -14,7 +14,7 @@ use super::terms::*;\n use super::terms::VarianceTerm::*;\n use super::xform::*;\n \n-struct SolveContext<'a, 'tcx: 'a> {\n+struct SolveContext<'a, 'tcx> {\n     terms_cx: TermsContext<'a, 'tcx>,\n     constraints: Vec<Constraint<'a>>,\n "}, {"sha": "3f6eadeac333479d551915e128b0e8de401f243b", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -47,7 +47,7 @@ impl<'a> fmt::Debug for VarianceTerm<'a> {\n \n // The first pass over the crate simply builds up the set of inferreds.\n \n-pub struct TermsContext<'a, 'tcx: 'a> {\n+pub struct TermsContext<'a, 'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n     pub arena: &'a TypedArena<VarianceTerm<'a>>,\n \n@@ -129,7 +129,7 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         debug!(\"add_inferreds for item {}\",\n-               self.tcx.hir().hir_to_string(item.hir_id));\n+               self.tcx.hir().node_to_string(item.hir_id));\n \n         match item.node {\n             hir::ItemKind::Struct(ref struct_def, _) |"}, {"sha": "9259b3b5d3abb1b1ed91505ee9590550fac3616a", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -3,7 +3,7 @@\n use std::iter::once;\n \n use syntax::ast;\n-use syntax::ext::base::{MacroKind, SyntaxExtension};\n+use syntax::ext::base::MacroKind;\n use syntax::symbol::sym;\n use syntax_pos::Span;\n \n@@ -305,7 +305,7 @@ pub fn build_impl(cx: &DocContext<'_>, did: DefId, ret: &mut Vec<clean::Item>) {\n     }\n \n     let for_ = if let Some(hir_id) = tcx.hir().as_local_hir_id(did) {\n-        match tcx.hir().expect_item_by_hir_id(hir_id).node {\n+        match tcx.hir().expect_item(hir_id).node {\n             hir::ItemKind::Impl(.., ref t, _) => {\n                 t.clean(cx)\n             }\n@@ -327,7 +327,7 @@ pub fn build_impl(cx: &DocContext<'_>, did: DefId, ret: &mut Vec<clean::Item>) {\n \n     let predicates = tcx.explicit_predicates_of(did);\n     let (trait_items, generics) = if let Some(hir_id) = tcx.hir().as_local_hir_id(did) {\n-        match tcx.hir().expect_item_by_hir_id(hir_id).node {\n+        match tcx.hir().expect_item(hir_id).node {\n             hir::ItemKind::Impl(.., ref gen, _, _, ref item_ids) => {\n                 (\n                     item_ids.iter()\n@@ -470,18 +470,12 @@ fn build_macro(cx: &DocContext<'_>, did: DefId, name: ast::Name) -> clean::ItemE\n             })\n         }\n         LoadedMacro::ProcMacro(ext) => {\n-            let helpers = match &*ext {\n-                &SyntaxExtension::Derive(_, ref syms, ..) => { syms.clean(cx) }\n-                _ => Vec::new(),\n-            };\n-\n             clean::ProcMacroItem(clean::ProcMacro {\n-                kind: ext.kind(),\n-                helpers,\n+                kind: ext.macro_kind(),\n+                helpers: ext.helper_attrs.clean(cx),\n             })\n         }\n     }\n-\n }\n \n /// A trait's generics clause actually contains all of the predicates for all of"}, {"sha": "b489ccf179c0e274ffa8c12f7f0cd88fb8383751", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 49, "deletions": 61, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -159,7 +159,7 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n \n         // Clean the crate, translating the entire libsyntax AST to one that is\n         // understood by rustdoc.\n-        let mut module = self.module.clean(cx);\n+        let mut module = self.module.as_ref().unwrap().clean(cx);\n         let mut masked_crates = FxHashSet::default();\n \n         match module.inner {\n@@ -276,7 +276,7 @@ impl Clean<ExternalCrate> for CrateNum {\n         };\n         let primitives = if root.is_local() {\n             cx.tcx.hir().krate().module.item_ids.iter().filter_map(|&id| {\n-                let item = cx.tcx.hir().expect_item_by_hir_id(id.id);\n+                let item = cx.tcx.hir().expect_item(id.id);\n                 match item.node {\n                     hir::ItemKind::Mod(_) => {\n                         as_primitive(Res::Def(\n@@ -320,7 +320,7 @@ impl Clean<ExternalCrate> for CrateNum {\n         };\n         let keywords = if root.is_local() {\n             cx.tcx.hir().krate().module.item_ids.iter().filter_map(|&id| {\n-                let item = cx.tcx.hir().expect_item_by_hir_id(id.id);\n+                let item = cx.tcx.hir().expect_item(id.id);\n                 match item.node {\n                     hir::ItemKind::Mod(_) => {\n                         as_keyword(Res::Def(\n@@ -600,7 +600,7 @@ pub struct Module {\n     pub is_crate: bool,\n }\n \n-impl Clean<Item> for doctree::Module {\n+impl Clean<Item> for doctree::Module<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let name = if self.name.is_some() {\n             self.name.expect(\"No name provided\").clean(cx)\n@@ -620,7 +620,7 @@ impl Clean<Item> for doctree::Module {\n         items.extend(self.unions.iter().map(|x| x.clean(cx)));\n         items.extend(self.enums.iter().map(|x| x.clean(cx)));\n         items.extend(self.fns.iter().map(|x| x.clean(cx)));\n-        items.extend(self.foreigns.iter().flat_map(|x| x.clean(cx)));\n+        items.extend(self.foreigns.iter().map(|x| x.clean(cx)));\n         items.extend(self.mods.iter().map(|x| x.clean(cx)));\n         items.extend(self.typedefs.iter().map(|x| x.clean(cx)));\n         items.extend(self.existentials.iter().map(|x| x.clean(cx)));\n@@ -1920,10 +1920,10 @@ pub struct Function {\n     pub ret_types: Vec<Type>,\n }\n \n-impl Clean<Item> for doctree::Function {\n+impl Clean<Item> for doctree::Function<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let (generics, decl) = enter_impl_trait(cx, || {\n-            (self.generics.clean(cx), (&self.decl, self.body).clean(cx))\n+            (self.generics.clean(cx), (self.decl, self.body).clean(cx))\n         });\n \n         let did = cx.tcx.hir().local_def_id_from_hir_id(self.id);\n@@ -2128,7 +2128,7 @@ pub struct Trait {\n     pub is_auto: bool,\n }\n \n-impl Clean<Item> for doctree::Trait {\n+impl Clean<Item> for doctree::Trait<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let attrs = self.attrs.clean(cx);\n         let is_spotlight = attrs.has_doc_flag(sym::spotlight);\n@@ -2143,7 +2143,7 @@ impl Clean<Item> for doctree::Trait {\n             inner: TraitItem(Trait {\n                 auto: self.is_auto.clean(cx),\n                 unsafety: self.unsafety,\n-                items: self.items.clean(cx),\n+                items: self.items.iter().map(|ti| ti.clean(cx)).collect(),\n                 generics: self.generics.clean(cx),\n                 bounds: self.bounds.clean(cx),\n                 is_spotlight,\n@@ -2159,7 +2159,7 @@ pub struct TraitAlias {\n     pub bounds: Vec<GenericBound>,\n }\n \n-impl Clean<Item> for doctree::TraitAlias {\n+impl Clean<Item> for doctree::TraitAlias<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let attrs = self.attrs.clean(cx);\n         Item {\n@@ -2777,7 +2777,7 @@ impl Clean<Type> for hir::Ty {\n             },\n             TyKind::Tup(ref tys) => Tuple(tys.clean(cx)),\n             TyKind::Def(item_id, _) => {\n-                let item = cx.tcx.hir().expect_item_by_hir_id(item_id.id);\n+                let item = cx.tcx.hir().expect_item(item_id.id);\n                 if let hir::ItemKind::Existential(ref ty) = item.node {\n                     ImplTrait(ty.bounds.clean(cx))\n                 } else {\n@@ -2799,7 +2799,7 @@ impl Clean<Type> for hir::Ty {\n                     // Substitute private type aliases\n                     if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(def_id) {\n                         if !cx.renderinfo.borrow().access_levels.is_exported(def_id) {\n-                            alias = Some(&cx.tcx.hir().expect_item_by_hir_id(hir_id).node);\n+                            alias = Some(&cx.tcx.hir().expect_item(hir_id).node);\n                         }\n                     }\n                 };\n@@ -2809,7 +2809,8 @@ impl Clean<Type> for hir::Ty {\n                     let mut ty_substs = FxHashMap::default();\n                     let mut lt_substs = FxHashMap::default();\n                     let mut ct_substs = FxHashMap::default();\n-                    provided_params.with_generic_args(|generic_args| {\n+                    let generic_args = provided_params.generic_args();\n+                    {\n                         let mut indices: GenericParamCount = Default::default();\n                         for param in generics.params.iter() {\n                             match param.kind {\n@@ -2852,11 +2853,11 @@ impl Clean<Type> for hir::Ty {\n                                             _ => None,\n                                         }\n                                     });\n-                                    if let Some(ty) = type_.cloned() {\n+                                    if let Some(ty) = type_ {\n                                         ty_substs.insert(ty_param_def_id, ty.clean(cx));\n                                     } else if let Some(default) = default.clone() {\n                                         ty_substs.insert(ty_param_def_id,\n-                                                         default.into_inner().clean(cx));\n+                                                         default.clean(cx));\n                                     }\n                                     indices.types += 1;\n                                 }\n@@ -2876,34 +2877,34 @@ impl Clean<Type> for hir::Ty {\n                                             _ => None,\n                                         }\n                                     });\n-                                    if let Some(ct) = const_.cloned() {\n+                                    if let Some(ct) = const_ {\n                                         ct_substs.insert(const_param_def_id, ct.clean(cx));\n                                     }\n                                     // FIXME(const_generics:defaults)\n                                     indices.consts += 1;\n                                 }\n                             }\n                         }\n-                    });\n+                    }\n                     return cx.enter_alias(ty_substs, lt_substs, ct_substs, || ty.clean(cx));\n                 }\n                 resolve_type(cx, path.clean(cx), self.hir_id)\n             }\n             TyKind::Path(hir::QPath::Resolved(Some(ref qself), ref p)) => {\n-                let mut segments: Vec<_> = p.segments.clone().into();\n-                segments.pop();\n-                let trait_path = hir::Path {\n-                    span: p.span,\n+                let segments = if p.is_global() { &p.segments[1..] } else { &p.segments };\n+                let trait_segments = &segments[..segments.len() - 1];\n+                let trait_path = self::Path {\n+                    global: p.is_global(),\n                     res: Res::Def(\n                         DefKind::Trait,\n                         cx.tcx.associated_item(p.res.def_id()).container.id(),\n                     ),\n-                    segments: segments.into(),\n+                    segments: trait_segments.clean(cx),\n                 };\n                 Type::QPath {\n                     name: p.segments.last().expect(\"segments were empty\").ident.name.clean(cx),\n                     self_type: box qself.clean(cx),\n-                    trait_: box resolve_type(cx, trait_path.clean(cx), self.hir_id)\n+                    trait_: box resolve_type(cx, trait_path, self.hir_id)\n                 }\n             }\n             TyKind::Path(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n@@ -3234,7 +3235,7 @@ pub struct Union {\n     pub fields_stripped: bool,\n }\n \n-impl Clean<Item> for doctree::Struct {\n+impl Clean<Item> for doctree::Struct<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n@@ -3254,7 +3255,7 @@ impl Clean<Item> for doctree::Struct {\n     }\n }\n \n-impl Clean<Item> for doctree::Union {\n+impl Clean<Item> for doctree::Union<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n@@ -3301,7 +3302,7 @@ pub struct Enum {\n     pub variants_stripped: bool,\n }\n \n-impl Clean<Item> for doctree::Enum {\n+impl Clean<Item> for doctree::Enum<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n@@ -3325,7 +3326,7 @@ pub struct Variant {\n     pub kind: VariantKind,\n }\n \n-impl Clean<Item> for doctree::Variant {\n+impl Clean<Item> for doctree::Variant<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n@@ -3537,7 +3538,7 @@ impl Clean<PathSegment> for hir::PathSegment {\n     fn clean(&self, cx: &DocContext<'_>) -> PathSegment {\n         PathSegment {\n             name: self.ident.name.clean(cx),\n-            args: self.with_generic_args(|generic_args| generic_args.clean(cx))\n+            args: self.generic_args().clean(cx),\n         }\n     }\n }\n@@ -3630,7 +3631,7 @@ pub struct Typedef {\n     pub generics: Generics,\n }\n \n-impl Clean<Item> for doctree::Typedef {\n+impl Clean<Item> for doctree::Typedef<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n@@ -3654,7 +3655,7 @@ pub struct Existential {\n     pub generics: Generics,\n }\n \n-impl Clean<Item> for doctree::Existential {\n+impl Clean<Item> for doctree::Existential<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n@@ -3704,7 +3705,7 @@ pub struct Static {\n     pub expr: String,\n }\n \n-impl Clean<Item> for doctree::Static {\n+impl Clean<Item> for doctree::Static<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         debug!(\"cleaning static {}: {:?}\", self.name.clean(cx), self);\n         Item {\n@@ -3730,7 +3731,7 @@ pub struct Constant {\n     pub expr: String,\n }\n \n-impl Clean<Item> for doctree::Constant {\n+impl Clean<Item> for doctree::Constant<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n@@ -3800,11 +3801,11 @@ pub fn get_auto_trait_and_blanket_impls(\n         .chain(BlanketImplFinder::new(cx).get_blanket_impls(ty, param_env_def_id))\n }\n \n-impl Clean<Vec<Item>> for doctree::Impl {\n+impl Clean<Vec<Item>> for doctree::Impl<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Vec<Item> {\n         let mut ret = Vec::new();\n         let trait_ = self.trait_.clean(cx);\n-        let items = self.items.clean(cx);\n+        let items = self.items.iter().map(|ii| ii.clean(cx)).collect::<Vec<_>>();\n \n         // If this impl block is an implementation of the Deref trait, then we\n         // need to try inlining the target's inherent impl blocks as well.\n@@ -3901,7 +3902,7 @@ fn build_deref_target_impls(cx: &DocContext<'_>,\n     }\n }\n \n-impl Clean<Vec<Item>> for doctree::ExternCrate {\n+impl Clean<Vec<Item>> for doctree::ExternCrate<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Vec<Item> {\n \n         let please_inline = self.vis.node.is_pub() && self.attrs.iter().any(|a| {\n@@ -3940,7 +3941,7 @@ impl Clean<Vec<Item>> for doctree::ExternCrate {\n     }\n }\n \n-impl Clean<Vec<Item>> for doctree::Import {\n+impl Clean<Vec<Item>> for doctree::Import<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Vec<Item> {\n         // We consider inlining the documentation of `pub use` statements, but we\n         // forcefully don't inline if this is not public or if the\n@@ -4016,22 +4017,11 @@ pub struct ImportSource {\n     pub did: Option<DefId>,\n }\n \n-impl Clean<Vec<Item>> for hir::ForeignMod {\n-    fn clean(&self, cx: &DocContext<'_>) -> Vec<Item> {\n-        let mut items = self.items.clean(cx);\n-        for item in &mut items {\n-            if let ForeignFunctionItem(ref mut f) = item.inner {\n-                f.header.abi = self.abi;\n-            }\n-        }\n-        items\n-    }\n-}\n-\n-impl Clean<Item> for hir::ForeignItem {\n+impl Clean<Item> for doctree::ForeignItem<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        let inner = match self.node {\n+        let inner = match self.kind {\n             hir::ForeignItemKind::Fn(ref decl, ref names, ref generics) => {\n+                let abi = cx.tcx.hir().get_foreign_abi(self.id);\n                 let (generics, decl) = enter_impl_trait(cx, || {\n                     (generics.clean(cx), (&**decl, &names[..]).clean(cx))\n                 });\n@@ -4041,7 +4031,7 @@ impl Clean<Item> for hir::ForeignItem {\n                     generics,\n                     header: hir::FnHeader {\n                         unsafety: hir::Unsafety::Unsafe,\n-                        abi: Abi::Rust,\n+                        abi,\n                         constness: hir::Constness::NotConst,\n                         asyncness: hir::IsAsync::NotAsync,\n                     },\n@@ -4061,16 +4051,14 @@ impl Clean<Item> for hir::ForeignItem {\n             }\n         };\n \n-        let local_did = cx.tcx.hir().local_def_id_from_hir_id(self.hir_id);\n-\n         Item {\n-            name: Some(self.ident.clean(cx)),\n+            name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            def_id: local_did,\n+            source: self.whence.clean(cx),\n+            def_id: cx.tcx.hir().local_def_id_from_hir_id(self.id),\n             visibility: self.vis.clean(cx),\n-            stability: get_stability(cx, local_did),\n-            deprecation: get_deprecation(cx, local_did),\n+            stability: self.stab.clean(cx),\n+            deprecation: self.depr.clean(cx),\n             inner,\n         }\n     }\n@@ -4245,7 +4233,7 @@ pub struct Macro {\n     pub imported_from: Option<String>,\n }\n \n-impl Clean<Item> for doctree::Macro {\n+impl Clean<Item> for doctree::Macro<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let name = self.name.clean(cx);\n         Item {\n@@ -4274,7 +4262,7 @@ pub struct ProcMacro {\n     pub helpers: Vec<String>,\n }\n \n-impl Clean<Item> for doctree::ProcMacro {\n+impl Clean<Item> for doctree::ProcMacro<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n@@ -4441,7 +4429,7 @@ pub fn path_to_def_local(tcx: TyCtxt<'_>, path: &[Symbol]) -> Option<DefId> {\n         let segment = path_it.next()?;\n \n         for item_id in mem::replace(&mut items, HirVec::new()).iter() {\n-            let item = tcx.hir().expect_item_by_hir_id(item_id.id);\n+            let item = tcx.hir().expect_item(item_id.id);\n             if item.ident.name == *segment {\n                 if path_it.peek().is_none() {\n                     return Some(tcx.hir().local_def_id_from_hir_id(item_id.id))"}, {"sha": "51deb4e9b974706cc393a04d8fe9146ea1948e77", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 108, "deletions": 94, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -7,52 +7,55 @@ use syntax::ast::{Name, NodeId};\n use syntax::attr;\n use syntax::ext::base::MacroKind;\n use syntax::ptr::P;\n-use syntax::source_map::Spanned;\n use syntax_pos::{self, Span};\n \n use rustc::hir;\n use rustc::hir::def_id::CrateNum;\n \n-pub struct Module {\n+pub struct Module<'hir> {\n     pub name: Option<Name>,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n     pub where_outer: Span,\n     pub where_inner: Span,\n-    pub extern_crates: Vec<ExternCrate>,\n-    pub imports: Vec<Import>,\n-    pub structs: Vec<Struct>,\n-    pub unions: Vec<Union>,\n-    pub enums: Vec<Enum>,\n-    pub fns: Vec<Function>,\n-    pub mods: Vec<Module>,\n+    pub extern_crates: Vec<ExternCrate<'hir>>,\n+    pub imports: Vec<Import<'hir>>,\n+    pub structs: Vec<Struct<'hir>>,\n+    pub unions: Vec<Union<'hir>>,\n+    pub enums: Vec<Enum<'hir>>,\n+    pub fns: Vec<Function<'hir>>,\n+    pub mods: Vec<Module<'hir>>,\n     pub id: NodeId,\n-    pub typedefs: Vec<Typedef>,\n-    pub existentials: Vec<Existential>,\n-    pub statics: Vec<Static>,\n-    pub constants: Vec<Constant>,\n-    pub traits: Vec<Trait>,\n-    pub vis: hir::Visibility,\n+    pub typedefs: Vec<Typedef<'hir>>,\n+    pub existentials: Vec<Existential<'hir>>,\n+    pub statics: Vec<Static<'hir>>,\n+    pub constants: Vec<Constant<'hir>>,\n+    pub traits: Vec<Trait<'hir>>,\n+    pub vis: &'hir hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n-    pub impls: Vec<Impl>,\n-    pub foreigns: Vec<hir::ForeignMod>,\n-    pub macros: Vec<Macro>,\n-    pub proc_macros: Vec<ProcMacro>,\n-    pub trait_aliases: Vec<TraitAlias>,\n+    pub impls: Vec<Impl<'hir>>,\n+    pub foreigns: Vec<ForeignItem<'hir>>,\n+    pub macros: Vec<Macro<'hir>>,\n+    pub proc_macros: Vec<ProcMacro<'hir>>,\n+    pub trait_aliases: Vec<TraitAlias<'hir>>,\n     pub is_crate: bool,\n }\n \n-impl Module {\n-    pub fn new(name: Option<Name>) -> Module {\n+impl Module<'hir> {\n+    pub fn new(\n+        name: Option<Name>,\n+        attrs: &'hir hir::HirVec<ast::Attribute>,\n+        vis: &'hir hir::Visibility,\n+    ) -> Module<'hir> {\n         Module {\n             name       : name,\n             id: ast::CRATE_NODE_ID,\n-            vis: Spanned { span: syntax_pos::DUMMY_SP, node: hir::VisibilityKind::Inherited },\n+            vis,\n             stab: None,\n             depr: None,\n             where_outer: syntax_pos::DUMMY_SP,\n             where_inner: syntax_pos::DUMMY_SP,\n-            attrs      : hir::HirVec::new(),\n+            attrs,\n             extern_crates: Vec::new(),\n             imports    :   Vec::new(),\n             structs    :   Vec::new(),\n@@ -85,199 +88,210 @@ pub enum StructType {\n     Unit,\n }\n \n-pub struct Struct {\n-    pub vis: hir::Visibility,\n+pub struct Struct<'hir> {\n+    pub vis: &'hir hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n     pub id: hir::HirId,\n     pub struct_type: StructType,\n     pub name: Name,\n-    pub generics: hir::Generics,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n-    pub fields: hir::HirVec<hir::StructField>,\n+    pub generics: &'hir hir::Generics,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub fields: &'hir [hir::StructField],\n     pub whence: Span,\n }\n \n-pub struct Union {\n-    pub vis: hir::Visibility,\n+pub struct Union<'hir> {\n+    pub vis: &'hir hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n     pub id: hir::HirId,\n     pub struct_type: StructType,\n     pub name: Name,\n-    pub generics: hir::Generics,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n-    pub fields: hir::HirVec<hir::StructField>,\n+    pub generics: &'hir hir::Generics,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub fields: &'hir [hir::StructField],\n     pub whence: Span,\n }\n \n-pub struct Enum {\n-    pub vis: hir::Visibility,\n+pub struct Enum<'hir> {\n+    pub vis: &'hir hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n-    pub variants: hir::HirVec<Variant>,\n-    pub generics: hir::Generics,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n+    pub variants: Vec<Variant<'hir>>,\n+    pub generics: &'hir hir::Generics,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n     pub id: hir::HirId,\n     pub whence: Span,\n     pub name: Name,\n }\n \n-pub struct Variant {\n+pub struct Variant<'hir> {\n     pub name: Name,\n     pub id: hir::HirId,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n-    pub def: hir::VariantData,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub def: &'hir hir::VariantData,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n     pub whence: Span,\n }\n \n-pub struct Function {\n-    pub decl: hir::FnDecl,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n+pub struct Function<'hir> {\n+    pub decl: &'hir hir::FnDecl,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n     pub id: hir::HirId,\n     pub name: Name,\n-    pub vis: hir::Visibility,\n+    pub vis: &'hir hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n     pub header: hir::FnHeader,\n     pub whence: Span,\n-    pub generics: hir::Generics,\n+    pub generics: &'hir hir::Generics,\n     pub body: hir::BodyId,\n }\n \n-pub struct Typedef {\n-    pub ty: P<hir::Ty>,\n-    pub gen: hir::Generics,\n+pub struct Typedef<'hir> {\n+    pub ty: &'hir P<hir::Ty>,\n+    pub gen: &'hir hir::Generics,\n     pub name: Name,\n     pub id: hir::HirId,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n     pub whence: Span,\n-    pub vis: hir::Visibility,\n+    pub vis: &'hir hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n }\n \n-pub struct Existential {\n-    pub exist_ty: hir::ExistTy,\n+pub struct Existential<'hir> {\n+    pub exist_ty: &'hir hir::ExistTy,\n     pub name: Name,\n     pub id: hir::HirId,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n     pub whence: Span,\n-    pub vis: hir::Visibility,\n+    pub vis: &'hir hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n }\n \n #[derive(Debug)]\n-pub struct Static {\n-    pub type_: P<hir::Ty>,\n+pub struct Static<'hir> {\n+    pub type_: &'hir P<hir::Ty>,\n     pub mutability: hir::Mutability,\n     pub expr: hir::BodyId,\n     pub name: Name,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n-    pub vis: hir::Visibility,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub vis: &'hir hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n     pub id: hir::HirId,\n     pub whence: Span,\n }\n \n-pub struct Constant {\n-    pub type_: P<hir::Ty>,\n+pub struct Constant<'hir> {\n+    pub type_: &'hir P<hir::Ty>,\n     pub expr: hir::BodyId,\n     pub name: Name,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n-    pub vis: hir::Visibility,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub vis: &'hir hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n     pub id: hir::HirId,\n     pub whence: Span,\n }\n \n-pub struct Trait {\n+pub struct Trait<'hir> {\n     pub is_auto: hir::IsAuto,\n     pub unsafety: hir::Unsafety,\n     pub name: Name,\n-    pub items: hir::HirVec<hir::TraitItem>,\n-    pub generics: hir::Generics,\n-    pub bounds: hir::HirVec<hir::GenericBound>,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n+    pub items: Vec<&'hir hir::TraitItem>,\n+    pub generics: &'hir hir::Generics,\n+    pub bounds: &'hir hir::HirVec<hir::GenericBound>,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n     pub id: hir::HirId,\n     pub whence: Span,\n-    pub vis: hir::Visibility,\n+    pub vis: &'hir hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n }\n \n-pub struct TraitAlias {\n+pub struct TraitAlias<'hir> {\n     pub name: Name,\n-    pub generics: hir::Generics,\n-    pub bounds: hir::HirVec<hir::GenericBound>,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n+    pub generics: &'hir hir::Generics,\n+    pub bounds: &'hir hir::HirVec<hir::GenericBound>,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n     pub id: hir::HirId,\n     pub whence: Span,\n-    pub vis: hir::Visibility,\n+    pub vis: &'hir hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n }\n \n #[derive(Debug)]\n-pub struct Impl {\n+pub struct Impl<'hir> {\n     pub unsafety: hir::Unsafety,\n     pub polarity: hir::ImplPolarity,\n     pub defaultness: hir::Defaultness,\n-    pub generics: hir::Generics,\n-    pub trait_: Option<hir::TraitRef>,\n-    pub for_: P<hir::Ty>,\n-    pub items: hir::HirVec<hir::ImplItem>,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n+    pub generics: &'hir hir::Generics,\n+    pub trait_: &'hir Option<hir::TraitRef>,\n+    pub for_: &'hir P<hir::Ty>,\n+    pub items: Vec<&'hir hir::ImplItem>,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n     pub whence: Span,\n-    pub vis: hir::Visibility,\n+    pub vis: &'hir hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n     pub id: hir::HirId,\n }\n \n+pub struct ForeignItem<'hir> {\n+    pub vis: &'hir hir::Visibility,\n+    pub stab: Option<attr::Stability>,\n+    pub depr: Option<attr::Deprecation>,\n+    pub id: hir::HirId,\n+    pub name: Name,\n+    pub kind: &'hir hir::ForeignItemKind,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub whence: Span,\n+}\n+\n // For Macro we store the DefId instead of the NodeId, since we also create\n // these imported macro_rules (which only have a DUMMY_NODE_ID).\n-pub struct Macro {\n+pub struct Macro<'hir> {\n     pub name: Name,\n     pub def_id: hir::def_id::DefId,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n     pub whence: Span,\n     pub matchers: hir::HirVec<Span>,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n     pub imported_from: Option<Name>,\n }\n \n-pub struct ExternCrate {\n+pub struct ExternCrate<'hir> {\n     pub name: Name,\n     pub cnum: CrateNum,\n     pub path: Option<String>,\n-    pub vis: hir::Visibility,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n+    pub vis: &'hir hir::Visibility,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n     pub whence: Span,\n }\n \n-pub struct Import {\n+pub struct Import<'hir> {\n     pub name: Name,\n     pub id: hir::HirId,\n-    pub vis: hir::Visibility,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n-    pub path: hir::Path,\n+    pub vis: &'hir hir::Visibility,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n+    pub path: &'hir hir::Path,\n     pub glob: bool,\n     pub whence: Span,\n }\n \n-pub struct ProcMacro {\n+pub struct ProcMacro<'hir> {\n     pub name: Name,\n     pub id: hir::HirId,\n     pub kind: MacroKind,\n     pub helpers: Vec<Name>,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n+    pub attrs: &'hir hir::HirVec<ast::Attribute>,\n     pub whence: Span,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,"}, {"sha": "b42a78f1e226a58d1539ddd267ac161e28278bac", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -3066,7 +3066,7 @@ fn render_implementor(cx: &Context, implementor: &Impl, w: &mut fmt::Formatter<'\n         _ => false,\n     };\n     render_impl(w, cx, implementor, AssocItemLink::Anchor(None), RenderMode::Normal,\n-                implementor.impl_item.stable_since(), false, Some(use_absolute), false)?;\n+                implementor.impl_item.stable_since(), false, Some(use_absolute), false, false)?;\n     Ok(())\n }\n \n@@ -3077,7 +3077,7 @@ fn render_impls(cx: &Context, w: &mut fmt::Formatter<'_>,\n         let did = i.trait_did().unwrap();\n         let assoc_link = AssocItemLink::GotoSource(did, &i.inner_impl().provided_trait_methods);\n         render_impl(w, cx, i, assoc_link,\n-                    RenderMode::Normal, containing_item.stable_since(), true, None, false)?;\n+                    RenderMode::Normal, containing_item.stable_since(), true, None, false, true)?;\n     }\n     Ok(())\n }\n@@ -3307,7 +3307,7 @@ fn item_trait(\n                 );\n                 render_impl(w, cx, &implementor, assoc_link,\n                             RenderMode::Normal, implementor.impl_item.stable_since(), false,\n-                            None, true)?;\n+                            None, true, false)?;\n             }\n             write_loading_content(w, \"\")?;\n         }\n@@ -3979,7 +3979,7 @@ fn render_assoc_items(w: &mut fmt::Formatter<'_>,\n         };\n         for i in &non_trait {\n             render_impl(w, cx, i, AssocItemLink::Anchor(None), render_mode,\n-                        containing_item.stable_since(), true, None, false)?;\n+                        containing_item.stable_since(), true, None, false, true)?;\n         }\n     }\n     if let AssocItemRender::DerefFor { .. } = what {\n@@ -4161,7 +4161,8 @@ fn spotlight_decl(decl: &clean::FnDecl) -> Result<String, fmt::Error> {\n \n fn render_impl(w: &mut fmt::Formatter<'_>, cx: &Context, i: &Impl, link: AssocItemLink<'_>,\n                render_mode: RenderMode, outer_version: Option<&str>, show_def_docs: bool,\n-               use_absolute: Option<bool>, is_on_foreign_type: bool) -> fmt::Result {\n+               use_absolute: Option<bool>, is_on_foreign_type: bool,\n+               show_default_items: bool) -> fmt::Result {\n     if render_mode == RenderMode::Normal {\n         let id = cx.derive_id(match i.inner_impl().trait_ {\n             Some(ref t) => if is_on_foreign_type {\n@@ -4345,9 +4346,13 @@ fn render_impl(w: &mut fmt::Formatter<'_>, cx: &Context, i: &Impl, link: AssocIt\n \n     // If we've implemented a trait, then also emit documentation for all\n     // default items which weren't overridden in the implementation block.\n-    if let Some(t) = trait_ {\n-        render_default_items(w, cx, t, &i.inner_impl(),\n-                             render_mode, outer_version, show_def_docs)?;\n+    // We don't emit documentation for default items if they appear in the\n+    // Implementations on Foreign Types or Implementors sections.\n+    if show_default_items {\n+        if let Some(t) = trait_ {\n+            render_default_items(w, cx, t, &i.inner_impl(),\n+                                render_mode, outer_version, show_def_docs)?;\n+        }\n     }\n     write!(w, \"</div>\")?;\n "}, {"sha": "f6ab1290da37ce0bbaada4c5a2a0943afbf2b443", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -20,7 +20,7 @@ pub fn check_code_block_syntax(krate: clean::Crate, cx: &DocContext<'_>) -> clea\n     SyntaxChecker { cx }.fold_crate(krate)\n }\n \n-struct SyntaxChecker<'a, 'tcx: 'a> {\n+struct SyntaxChecker<'a, 'tcx> {\n     cx: &'a DocContext<'tcx>,\n }\n "}, {"sha": "68b96a408294b9429aff7b525d47d575ef6355f5", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -423,7 +423,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n \n /// Resolves a string as a macro.\n fn macro_resolve(cx: &DocContext<'_>, path_str: &str) -> Option<Res> {\n-    use syntax::ext::base::{MacroKind, SyntaxExtension};\n+    use syntax::ext::base::{MacroKind, SyntaxExtensionKind};\n     let segment = ast::PathSegment::from_ident(Ident::from_str(path_str));\n     let path = ast::Path { segments: vec![segment], span: DUMMY_SP };\n     cx.enter_resolver(|resolver| {\n@@ -433,7 +433,7 @@ fn macro_resolve(cx: &DocContext<'_>, path_str: &str) -> Option<Res> {\n             if let Res::Def(DefKind::Macro(MacroKind::ProcMacroStub), _) = res {\n                 // skip proc-macro stubs, they'll cause `get_macro` to crash\n             } else {\n-                if let SyntaxExtension::LegacyBang { .. } = *resolver.get_macro(res) {\n+                if let SyntaxExtensionKind::LegacyBang(..) = resolver.get_macro(res).kind {\n                     return Some(res.map_id(|_| panic!(\"unexpected id\")));\n                 }\n             }"}, {"sha": "ddce5cab1ebcbab259c744e8a33f1893ad12ccb6", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -878,7 +878,7 @@ impl Tester for Collector {\n     }\n }\n \n-struct HirCollector<'a, 'hir: 'a> {\n+struct HirCollector<'a, 'hir> {\n     sess: &'a session::Session,\n     collector: &'a mut Collector,\n     map: &'a hir::map::Map<'hir>,"}, {"sha": "c94149d31020a9ffbae90ca4fbfbb97c5f1e852b", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 127, "deletions": 124, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -29,8 +29,7 @@ use crate::doctree::*;\n // framework from syntax?.\n \n pub struct RustdocVisitor<'a, 'tcx> {\n-    pub module: Module,\n-    pub attrs: hir::HirVec<ast::Attribute>,\n+    pub module: Option<Module<'tcx>>,\n     pub cx: &'a core::DocContext<'tcx>,\n     view_item_stack: FxHashSet<hir::HirId>,\n     inlining: bool,\n@@ -47,8 +46,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         let mut stack = FxHashSet::default();\n         stack.insert(hir::CRATE_HIR_ID);\n         RustdocVisitor {\n-            module: Module::new(None),\n-            attrs: hir::HirVec::new(),\n+            module: None,\n             cx,\n             view_item_stack: stack,\n             inlining: false,\n@@ -77,92 +75,91 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             .and_then(|def_id| self.cx.tcx.lookup_deprecation(def_id))\n     }\n \n-    pub fn visit(&mut self, krate: &hir::Crate) {\n-        self.attrs = krate.attrs.clone();\n-\n-        self.module = self.visit_mod_contents(krate.span,\n-                                              krate.attrs.clone(),\n-                                              Spanned { span: syntax_pos::DUMMY_SP,\n+    pub fn visit(&mut self, krate: &'tcx hir::Crate) {\n+        let mut module = self.visit_mod_contents(krate.span,\n+                                              &krate.attrs,\n+                                              &Spanned { span: syntax_pos::DUMMY_SP,\n                                                         node: hir::VisibilityKind::Public },\n                                               hir::CRATE_HIR_ID,\n                                               &krate.module,\n                                               None);\n         // Attach the crate's exported macros to the top-level module:\n-        let macro_exports: Vec<_> =\n-            krate.exported_macros.iter().map(|def| self.visit_local_macro(def, None)).collect();\n-        self.module.macros.extend(macro_exports);\n-        self.module.is_crate = true;\n+        module.macros.extend(\n+            krate.exported_macros.iter().map(|def| self.visit_local_macro(def, None)),\n+        );\n+        module.is_crate = true;\n+        self.module = Some(module);\n \n         self.cx.renderinfo.borrow_mut().exact_paths = self.exact_paths.take().unwrap();\n     }\n \n-    pub fn visit_variant_data(&mut self, item: &hir::Item,\n-                              name: ast::Name, sd: &hir::VariantData,\n-                              generics: &hir::Generics) -> Struct {\n+    pub fn visit_variant_data(&mut self, item: &'tcx hir::Item,\n+                              name: ast::Name, sd: &'tcx hir::VariantData,\n+                              generics: &'tcx hir::Generics) -> Struct<'tcx> {\n         debug!(\"Visiting struct\");\n         let struct_type = struct_type_from_def(&*sd);\n         Struct {\n             id: item.hir_id,\n             struct_type,\n             name,\n-            vis: item.vis.clone(),\n+            vis: &item.vis,\n             stab: self.stability(item.hir_id),\n             depr: self.deprecation(item.hir_id),\n-            attrs: item.attrs.clone(),\n-            generics: generics.clone(),\n-            fields: sd.fields().iter().cloned().collect(),\n+            attrs: &item.attrs,\n+            generics,\n+            fields: sd.fields(),\n             whence: item.span\n         }\n     }\n \n-    pub fn visit_union_data(&mut self, item: &hir::Item,\n-                            name: ast::Name, sd: &hir::VariantData,\n-                            generics: &hir::Generics) -> Union {\n+    pub fn visit_union_data(&mut self, item: &'tcx hir::Item,\n+                            name: ast::Name, sd: &'tcx hir::VariantData,\n+                            generics: &'tcx hir::Generics) -> Union<'tcx> {\n         debug!(\"Visiting union\");\n         let struct_type = struct_type_from_def(&*sd);\n         Union {\n             id: item.hir_id,\n             struct_type,\n             name,\n-            vis: item.vis.clone(),\n+            vis: &item.vis,\n             stab: self.stability(item.hir_id),\n             depr: self.deprecation(item.hir_id),\n-            attrs: item.attrs.clone(),\n-            generics: generics.clone(),\n-            fields: sd.fields().iter().cloned().collect(),\n+            attrs: &item.attrs,\n+            generics,\n+            fields: sd.fields(),\n             whence: item.span\n         }\n     }\n \n-    pub fn visit_enum_def(&mut self, it: &hir::Item,\n-                          name: ast::Name, def: &hir::EnumDef,\n-                          params: &hir::Generics) -> Enum {\n+    pub fn visit_enum_def(&mut self, it: &'tcx hir::Item,\n+                          name: ast::Name, def: &'tcx hir::EnumDef,\n+                          generics: &'tcx hir::Generics) -> Enum<'tcx> {\n         debug!(\"Visiting enum\");\n         Enum {\n             name,\n             variants: def.variants.iter().map(|v| Variant {\n                 name: v.node.ident.name,\n                 id: v.node.id,\n-                attrs: v.node.attrs.clone(),\n+                attrs: &v.node.attrs,\n                 stab: self.stability(v.node.id),\n                 depr: self.deprecation(v.node.id),\n-                def: v.node.data.clone(),\n+                def: &v.node.data,\n                 whence: v.span,\n             }).collect(),\n-            vis: it.vis.clone(),\n+            vis: &it.vis,\n             stab: self.stability(it.hir_id),\n             depr: self.deprecation(it.hir_id),\n-            generics: params.clone(),\n-            attrs: it.attrs.clone(),\n+            generics,\n+            attrs: &it.attrs,\n             id: it.hir_id,\n             whence: it.span,\n         }\n     }\n \n-    pub fn visit_fn(&mut self, om: &mut Module, item: &hir::Item,\n-                    name: ast::Name, fd: &hir::FnDecl,\n+    pub fn visit_fn(&mut self, om: &mut Module<'tcx>, item: &'tcx hir::Item,\n+                    name: ast::Name, decl: &'tcx hir::FnDecl,\n                     header: hir::FnHeader,\n-                    gen: &hir::Generics,\n+                    generics: &'tcx hir::Generics,\n                     body: hir::BodyId) {\n         debug!(\"Visiting fn\");\n         let macro_kind = item.attrs.iter().filter_map(|a| {\n@@ -208,7 +205,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     id: item.hir_id,\n                     kind,\n                     helpers,\n-                    attrs: item.attrs.clone(),\n+                    attrs: &item.attrs,\n                     whence: item.span,\n                     stab: self.stability(item.hir_id),\n                     depr: self.deprecation(item.hir_id),\n@@ -217,38 +214,36 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             None => {\n                 om.fns.push(Function {\n                     id: item.hir_id,\n-                    vis: item.vis.clone(),\n+                    vis: &item.vis,\n                     stab: self.stability(item.hir_id),\n                     depr: self.deprecation(item.hir_id),\n-                    attrs: item.attrs.clone(),\n-                    decl: fd.clone(),\n+                    attrs: &item.attrs,\n+                    decl,\n                     name,\n                     whence: item.span,\n-                    generics: gen.clone(),\n+                    generics,\n                     header,\n                     body,\n                 });\n             }\n         }\n     }\n \n-    pub fn visit_mod_contents(&mut self, span: Span, attrs: hir::HirVec<ast::Attribute>,\n-                              vis: hir::Visibility, id: hir::HirId,\n-                              m: &hir::Mod,\n-                              name: Option<ast::Name>) -> Module {\n-        let mut om = Module::new(name);\n+    pub fn visit_mod_contents(&mut self, span: Span, attrs: &'tcx hir::HirVec<ast::Attribute>,\n+                              vis: &'tcx hir::Visibility, id: hir::HirId,\n+                              m: &'tcx hir::Mod,\n+                              name: Option<ast::Name>) -> Module<'tcx> {\n+        let mut om = Module::new(name, attrs, vis);\n         om.where_outer = span;\n         om.where_inner = m.inner;\n-        om.attrs = attrs;\n-        om.vis = vis.clone();\n         om.stab = self.stability(id);\n         om.depr = self.deprecation(id);\n         om.id = self.cx.tcx.hir().hir_to_node_id(id);\n         // Keep track of if there were any private modules in the path.\n         let orig_inside_public_path = self.inside_public_path;\n         self.inside_public_path &= vis.node.is_pub();\n         for i in &m.item_ids {\n-            let item = self.cx.tcx.hir().expect_item_by_hir_id(i.id);\n+            let item = self.cx.tcx.hir().expect_item(i.id);\n             self.visit_item(item, None, &mut om);\n         }\n         self.inside_public_path = orig_inside_public_path;\n@@ -269,13 +264,13 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                           res: Res,\n                           renamed: Option<ast::Ident>,\n                           glob: bool,\n-                          om: &mut Module,\n+                          om: &mut Module<'tcx>,\n                           please_inline: bool) -> bool {\n \n         fn inherits_doc_hidden(cx: &core::DocContext<'_>, mut node: hir::HirId) -> bool {\n             while let Some(id) = cx.tcx.hir().get_enclosing_scope(node) {\n                 node = id;\n-                if cx.tcx.hir().attrs_by_hir_id(node)\n+                if cx.tcx.hir().attrs(node)\n                     .lists(sym::doc).has_word(sym::hidden) {\n                     return true;\n                 }\n@@ -295,7 +290,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             return false;\n         };\n \n-        let use_attrs = tcx.hir().attrs_by_hir_id(id);\n+        let use_attrs = tcx.hir().attrs(id);\n         // Don't inline `doc(hidden)` imports so they can be stripped at a later stage.\n         let is_no_inline = use_attrs.lists(sym::doc).has_word(sym::no_inline) ||\n                            use_attrs.lists(sym::doc).has_word(sym::hidden);\n@@ -346,7 +341,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             Node::Item(&hir::Item { node: hir::ItemKind::Mod(ref m), .. }) if glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n                 for i in &m.item_ids {\n-                    let i = self.cx.tcx.hir().expect_item_by_hir_id(i.id);\n+                    let i = self.cx.tcx.hir().expect_item(i.id);\n                     self.visit_item(i, None, om);\n                 }\n                 self.inlining = prev;\n@@ -359,14 +354,9 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 true\n             }\n             Node::ForeignItem(it) if !glob => {\n-                // Generate a fresh `extern {}` block if we want to inline a foreign item.\n-                om.foreigns.push(hir::ForeignMod {\n-                    abi: tcx.hir().get_foreign_abi_by_hir_id(it.hir_id),\n-                    items: vec![hir::ForeignItem {\n-                        ident: renamed.unwrap_or(it.ident),\n-                        .. it.clone()\n-                    }].into(),\n-                });\n+                let prev = mem::replace(&mut self.inlining, true);\n+                self.visit_foreign_item(it, renamed, om);\n+                self.inlining = prev;\n                 true\n             }\n             Node::MacroDef(def) if !glob => {\n@@ -379,8 +369,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         ret\n     }\n \n-    pub fn visit_item(&mut self, item: &hir::Item,\n-                      renamed: Option<ast::Ident>, om: &mut Module) {\n+    pub fn visit_item(&mut self, item: &'tcx hir::Item,\n+                      renamed: Option<ast::Ident>, om: &mut Module<'tcx>) {\n         debug!(\"Visiting item {:?}\", item);\n         let ident = renamed.unwrap_or(item.ident);\n \n@@ -391,15 +381,9 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n         match item.node {\n             hir::ItemKind::ForeignMod(ref fm) => {\n-                // If inlining we only want to include public functions.\n-                om.foreigns.push(if self.inlining {\n-                    hir::ForeignMod {\n-                        abi: fm.abi,\n-                        items: fm.items.iter().filter(|i| i.vis.node.is_pub()).cloned().collect(),\n-                    }\n-                } else {\n-                    fm.clone()\n-                });\n+                for item in &fm.items {\n+                    self.visit_foreign_item(item, None, om);\n+                }\n             }\n             // If we're inlining, skip private items.\n             _ if self.inlining && !item.vis.node.is_pub() => {}\n@@ -411,8 +395,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                                 .unwrap_or(LOCAL_CRATE),\n                     name: ident.name,\n                     path: orig_name.map(|x|x.to_string()),\n-                    vis: item.vis.clone(),\n-                    attrs: item.attrs.clone(),\n+                    vis: &item.vis,\n+                    attrs: &item.attrs,\n                     whence: item.span,\n                 })\n             }\n@@ -454,17 +438,17 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 om.imports.push(Import {\n                     name: ident.name,\n                     id: item.hir_id,\n-                    vis: item.vis.clone(),\n-                    attrs: item.attrs.clone(),\n-                    path: (**path).clone(),\n+                    vis: &item.vis,\n+                    attrs: &item.attrs,\n+                    path,\n                     glob: is_glob,\n                     whence: item.span,\n                 });\n             }\n             hir::ItemKind::Mod(ref m) => {\n                 om.mods.push(self.visit_mod_contents(item.span,\n-                                                     item.attrs.clone(),\n-                                                     item.vis.clone(),\n+                                                     &item.attrs,\n+                                                     &item.vis,\n                                                      item.hir_id,\n                                                      m,\n                                                      Some(ident.name)));\n@@ -479,89 +463,89 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 self.visit_fn(om, item, ident.name, &**fd, header, gen, body),\n             hir::ItemKind::Ty(ref ty, ref gen) => {\n                 let t = Typedef {\n-                    ty: ty.clone(),\n-                    gen: gen.clone(),\n+                    ty,\n+                    gen,\n                     name: ident.name,\n                     id: item.hir_id,\n-                    attrs: item.attrs.clone(),\n+                    attrs: &item.attrs,\n                     whence: item.span,\n-                    vis: item.vis.clone(),\n+                    vis: &item.vis,\n                     stab: self.stability(item.hir_id),\n                     depr: self.deprecation(item.hir_id),\n                 };\n                 om.typedefs.push(t);\n             },\n             hir::ItemKind::Existential(ref exist_ty) => {\n                 let t = Existential {\n-                    exist_ty: exist_ty.clone(),\n+                    exist_ty,\n                     name: ident.name,\n                     id: item.hir_id,\n-                    attrs: item.attrs.clone(),\n+                    attrs: &item.attrs,\n                     whence: item.span,\n-                    vis: item.vis.clone(),\n+                    vis: &item.vis,\n                     stab: self.stability(item.hir_id),\n                     depr: self.deprecation(item.hir_id),\n                 };\n                 om.existentials.push(t);\n             },\n-            hir::ItemKind::Static(ref ty, ref mut_, ref exp) => {\n+            hir::ItemKind::Static(ref type_, mutability, expr) => {\n                 let s = Static {\n-                    type_: ty.clone(),\n-                    mutability: mut_.clone(),\n-                    expr: exp.clone(),\n+                    type_,\n+                    mutability,\n+                    expr,\n                     id: item.hir_id,\n                     name: ident.name,\n-                    attrs: item.attrs.clone(),\n+                    attrs: &item.attrs,\n                     whence: item.span,\n-                    vis: item.vis.clone(),\n+                    vis: &item.vis,\n                     stab: self.stability(item.hir_id),\n                     depr: self.deprecation(item.hir_id),\n                 };\n                 om.statics.push(s);\n             },\n-            hir::ItemKind::Const(ref ty, ref exp) => {\n+            hir::ItemKind::Const(ref type_, expr) => {\n                 let s = Constant {\n-                    type_: ty.clone(),\n-                    expr: exp.clone(),\n+                    type_,\n+                    expr,\n                     id: item.hir_id,\n                     name: ident.name,\n-                    attrs: item.attrs.clone(),\n+                    attrs: &item.attrs,\n                     whence: item.span,\n-                    vis: item.vis.clone(),\n+                    vis: &item.vis,\n                     stab: self.stability(item.hir_id),\n                     depr: self.deprecation(item.hir_id),\n                 };\n                 om.constants.push(s);\n             },\n-            hir::ItemKind::Trait(is_auto, unsafety, ref gen, ref b, ref item_ids) => {\n+            hir::ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, ref item_ids) => {\n                 let items = item_ids.iter()\n-                                    .map(|ti| self.cx.tcx.hir().trait_item(ti.id).clone())\n+                                    .map(|ti| self.cx.tcx.hir().trait_item(ti.id))\n                                     .collect();\n                 let t = Trait {\n                     is_auto,\n                     unsafety,\n                     name: ident.name,\n                     items,\n-                    generics: gen.clone(),\n-                    bounds: b.iter().cloned().collect(),\n+                    generics,\n+                    bounds,\n                     id: item.hir_id,\n-                    attrs: item.attrs.clone(),\n+                    attrs: &item.attrs,\n                     whence: item.span,\n-                    vis: item.vis.clone(),\n+                    vis: &item.vis,\n                     stab: self.stability(item.hir_id),\n                     depr: self.deprecation(item.hir_id),\n                 };\n                 om.traits.push(t);\n             },\n-            hir::ItemKind::TraitAlias(ref gen, ref b) => {\n+            hir::ItemKind::TraitAlias(ref generics, ref bounds) => {\n                 let t = TraitAlias {\n                     name: ident.name,\n-                    generics: gen.clone(),\n-                    bounds: b.iter().cloned().collect(),\n+                    generics,\n+                    bounds,\n                     id: item.hir_id,\n-                    attrs: item.attrs.clone(),\n+                    attrs: &item.attrs,\n                     whence: item.span,\n-                    vis: item.vis.clone(),\n+                    vis: &item.vis,\n                     stab: self.stability(item.hir_id),\n                     depr: self.deprecation(item.hir_id),\n                 };\n@@ -571,28 +555,28 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             hir::ItemKind::Impl(unsafety,\n                           polarity,\n                           defaultness,\n-                          ref gen,\n-                          ref tr,\n-                          ref ty,\n+                          ref generics,\n+                          ref trait_,\n+                          ref for_,\n                           ref item_ids) => {\n                 // Don't duplicate impls when inlining or if it's implementing a trait, we'll pick\n                 // them up regardless of where they're located.\n-                if !self.inlining && tr.is_none() {\n+                if !self.inlining && trait_.is_none() {\n                     let items = item_ids.iter()\n-                                        .map(|ii| self.cx.tcx.hir().impl_item(ii.id).clone())\n+                                        .map(|ii| self.cx.tcx.hir().impl_item(ii.id))\n                                         .collect();\n                     let i = Impl {\n                         unsafety,\n                         polarity,\n                         defaultness,\n-                        generics: gen.clone(),\n-                        trait_: tr.clone(),\n-                        for_: ty.clone(),\n+                        generics,\n+                        trait_,\n+                        for_,\n                         items,\n-                        attrs: item.attrs.clone(),\n+                        attrs: &item.attrs,\n                         id: item.hir_id,\n                         whence: item.span,\n-                        vis: item.vis.clone(),\n+                        vis: &item.vis,\n                         stab: self.stability(item.hir_id),\n                         depr: self.deprecation(item.hir_id),\n                     };\n@@ -602,12 +586,31 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         }\n     }\n \n+    fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem,\n+                      renamed: Option<ast::Ident>, om: &mut Module<'tcx>) {\n+        // If inlining we only want to include public functions.\n+        if self.inlining && !item.vis.node.is_pub() {\n+            return;\n+        }\n+\n+        om.foreigns.push(ForeignItem {\n+            id: item.hir_id,\n+            name: renamed.unwrap_or(item.ident).name,\n+            kind: &item.node,\n+            vis: &item.vis,\n+            stab: self.stability(item.hir_id),\n+            depr: self.deprecation(item.hir_id),\n+            attrs: &item.attrs,\n+            whence: item.span\n+        });\n+    }\n+\n     // Convert each `exported_macro` into a doc item.\n     fn visit_local_macro(\n         &self,\n-        def: &hir::MacroDef,\n+        def: &'tcx hir::MacroDef,\n         renamed: Option<ast::Name>\n-    ) -> Macro {\n+    ) -> Macro<'tcx> {\n         debug!(\"visit_local_macro: {}\", def.name);\n         let tts = def.body.trees().collect::<Vec<_>>();\n         // Extract the spans of all matchers. They represent the \"interface\" of the macro.\n@@ -616,7 +619,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         Macro {\n \n             def_id: self.cx.tcx.hir().local_def_id_from_hir_id(def.hir_id),\n-            attrs: def.attrs.clone(),\n+            attrs: &def.attrs,\n             name: renamed.unwrap_or(def.name),\n             whence: def.span,\n             matchers,"}, {"sha": "2c3bea80e349b4933529c2fb8ebab1e5e56e74c4", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -2502,7 +2502,7 @@ impl<A:ToJson> ToJson for Option<A> {\n     }\n }\n \n-struct FormatShim<'a, 'b: 'a> {\n+struct FormatShim<'a, 'b> {\n     inner: &'a mut fmt::Formatter<'b>,\n }\n "}, {"sha": "69fcfa8b39ca5e5ea4ad1b1bbcae90266a823280", "filename": "src/libstd/ffi/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibstd%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibstd%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -170,7 +170,7 @@ pub use core::ffi::c_void;\n            reason = \"the `c_variadic` feature has not been properly tested on \\\n                      all supported platforms\",\n            issue = \"44930\")]\n-pub use core::ffi::VaList;\n+pub use core::ffi::{VaList, VaListImpl};\n \n mod c_str;\n mod os_str;"}, {"sha": "05464787a05d3c594f5bdd203715bff88b460d47", "filename": "src/libstd/sys/redox/fast_thread_local.rs", "status": "modified", "additions": 1, "deletions": 108, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibstd%2Fsys%2Fredox%2Ffast_thread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibstd%2Fsys%2Fredox%2Ffast_thread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ffast_thread_local.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -1,111 +1,4 @@\n #![cfg(target_thread_local)]\n #![unstable(feature = \"thread_local_internals\", issue = \"0\")]\n \n-use crate::cell::{Cell, UnsafeCell};\n-use crate::mem;\n-use crate::ptr;\n-\n-\n-pub struct Key<T> {\n-    inner: UnsafeCell<Option<T>>,\n-\n-    // Metadata to keep track of the state of the destructor. Remember that\n-    // these variables are thread-local, not global.\n-    dtor_registered: Cell<bool>,\n-    dtor_running: Cell<bool>,\n-}\n-\n-unsafe impl<T> Sync for Key<T> { }\n-\n-impl<T> Key<T> {\n-    pub const fn new() -> Key<T> {\n-        Key {\n-            inner: UnsafeCell::new(None),\n-            dtor_registered: Cell::new(false),\n-            dtor_running: Cell::new(false)\n-        }\n-    }\n-\n-    pub fn get(&'static self) -> Option<&'static UnsafeCell<Option<T>>> {\n-        unsafe {\n-            if mem::needs_drop::<T>() && self.dtor_running.get() {\n-                return None\n-            }\n-            self.register_dtor();\n-        }\n-        Some(&self.inner)\n-    }\n-\n-    unsafe fn register_dtor(&self) {\n-        if !mem::needs_drop::<T>() || self.dtor_registered.get() {\n-            return\n-        }\n-\n-        register_dtor(self as *const _ as *mut u8,\n-                      destroy_value::<T>);\n-        self.dtor_registered.set(true);\n-    }\n-}\n-\n-pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n-    // The fallback implementation uses a vanilla OS-based TLS key to track\n-    // the list of destructors that need to be run for this thread. The key\n-    // then has its own destructor which runs all the other destructors.\n-    //\n-    // The destructor for DTORS is a little special in that it has a `while`\n-    // loop to continuously drain the list of registered destructors. It\n-    // *should* be the case that this loop always terminates because we\n-    // provide the guarantee that a TLS key cannot be set after it is\n-    // flagged for destruction.\n-    use crate::sys_common::thread_local as os;\n-\n-    static DTORS: os::StaticKey = os::StaticKey::new(Some(run_dtors));\n-    type List = Vec<(*mut u8, unsafe extern fn(*mut u8))>;\n-    if DTORS.get().is_null() {\n-        let v: Box<List> = box Vec::new();\n-        DTORS.set(Box::into_raw(v) as *mut u8);\n-    }\n-    let list: &mut List = &mut *(DTORS.get() as *mut List);\n-    list.push((t, dtor));\n-\n-    unsafe extern fn run_dtors(mut ptr: *mut u8) {\n-        while !ptr.is_null() {\n-            let list: Box<List> = Box::from_raw(ptr as *mut List);\n-            for (ptr, dtor) in list.into_iter() {\n-                dtor(ptr);\n-            }\n-            ptr = DTORS.get();\n-            DTORS.set(ptr::null_mut());\n-        }\n-    }\n-}\n-\n-pub unsafe extern fn destroy_value<T>(ptr: *mut u8) {\n-    let ptr = ptr as *mut Key<T>;\n-    // Right before we run the user destructor be sure to flag the\n-    // destructor as running for this thread so calls to `get` will return\n-    // `None`.\n-    (*ptr).dtor_running.set(true);\n-\n-    // The macOS implementation of TLS apparently had an odd aspect to it\n-    // where the pointer we have may be overwritten while this destructor\n-    // is running. Specifically if a TLS destructor re-accesses TLS it may\n-    // trigger a re-initialization of all TLS variables, paving over at\n-    // least some destroyed ones with initial values.\n-    //\n-    // This means that if we drop a TLS value in place on macOS that we could\n-    // revert the value to its original state halfway through the\n-    // destructor, which would be bad!\n-    //\n-    // Hence, we use `ptr::read` on macOS (to move to a \"safe\" location)\n-    // instead of drop_in_place.\n-    if cfg!(target_os = \"macos\") {\n-        ptr::read((*ptr).inner.get());\n-    } else {\n-        ptr::drop_in_place((*ptr).inner.get());\n-    }\n-}\n-\n-pub fn requires_move_before_drop() -> bool {\n-    false\n-}\n+pub use crate::sys_common::thread_local::register_dtor_fallback as register_dtor;"}, {"sha": "c34c2e6e786ec5bf38b09baa16524ff1a9636dc0", "filename": "src/libstd/sys/unix/fast_thread_local.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -82,7 +82,3 @@ pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n         }\n     }\n }\n-\n-pub fn requires_move_before_drop() -> bool {\n-    false\n-}"}, {"sha": "8b4b354d9fc20ce868be48418e332b3b698018b6", "filename": "src/libstd/sys/wasi/args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibstd%2Fsys%2Fwasi%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibstd%2Fsys%2Fwasi%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fargs.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -32,7 +32,7 @@ fn maybe_args() -> io::Result<Args> {\n         let (mut argc, mut argv_buf_size) = (0, 0);\n         cvt_wasi(libc::__wasi_args_sizes_get(&mut argc, &mut argv_buf_size))?;\n \n-        let mut argc = vec![0 as *mut libc::c_char; argc];\n+        let mut argc = vec![core::ptr::null_mut::<libc::c_char>(); argc];\n         let mut argv_buf = vec![0; argv_buf_size];\n         cvt_wasi(libc::__wasi_args_get(argc.as_mut_ptr(), argv_buf.as_mut_ptr()))?;\n "}, {"sha": "3dc0bb24553fd644450b36c29a148d26a30fdbad", "filename": "src/libstd/sys/wasm/thread_local_atomics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local_atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local_atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local_atomics.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -11,7 +11,7 @@ struct ThreadControlBlock {\n impl ThreadControlBlock {\n     fn new() -> ThreadControlBlock {\n         ThreadControlBlock {\n-            keys: [0 as *mut u8; MAX_KEYS],\n+            keys: [core::ptr::null_mut(); MAX_KEYS],\n         }\n     }\n "}, {"sha": "31d0bd1e72ed2056806846c362a4e98b1d3a1307", "filename": "src/libstd/sys/windows/fast_thread_local.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibstd%2Fsys%2Fwindows%2Ffast_thread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibstd%2Fsys%2Fwindows%2Ffast_thread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffast_thread_local.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -2,7 +2,3 @@\n #![cfg(target_thread_local)]\n \n pub use crate::sys_common::thread_local::register_dtor_fallback as register_dtor;\n-\n-pub fn requires_move_before_drop() -> bool {\n-    false\n-}"}, {"sha": "9b355aa2023ff64d54912ef5fb0457054fd4225f", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 183, "deletions": 107, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -2,10 +2,7 @@\n \n #![unstable(feature = \"thread_local_internals\", issue = \"0\")]\n \n-use crate::cell::UnsafeCell;\n use crate::fmt;\n-use crate::hint;\n-use crate::mem;\n \n /// A thread local storage key which owns its contents.\n ///\n@@ -92,10 +89,7 @@ pub struct LocalKey<T: 'static> {\n     // trivially devirtualizable by LLVM because the value of `inner` never\n     // changes and the constant should be readonly within a crate. This mainly\n     // only runs into problems when TLS statics are exported across crates.\n-    inner: unsafe fn() -> Option<&'static UnsafeCell<Option<T>>>,\n-\n-    // initialization routine to invoke to create a value\n-    init: fn() -> T,\n+    inner: unsafe fn() -> Option<&'static T>,\n }\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n@@ -159,10 +153,7 @@ macro_rules! __thread_local_inner {\n             #[inline]\n             fn __init() -> $t { $init }\n \n-            unsafe fn __getit() -> $crate::option::Option<\n-                &'static $crate::cell::UnsafeCell<\n-                    $crate::option::Option<$t>>>\n-            {\n+            unsafe fn __getit() -> $crate::option::Option<&'static $t> {\n                 #[cfg(all(target_arch = \"wasm32\", not(target_feature = \"atomics\")))]\n                 static __KEY: $crate::thread::__StaticLocalKeyInner<$t> =\n                     $crate::thread::__StaticLocalKeyInner::new();\n@@ -182,11 +173,11 @@ macro_rules! __thread_local_inner {\n                 static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n                     $crate::thread::__OsLocalKeyInner::new();\n \n-                __KEY.get()\n+                __KEY.get(__init)\n             }\n \n             unsafe {\n-                $crate::thread::LocalKey::new(__getit, __init)\n+                $crate::thread::LocalKey::new(__getit)\n             }\n         }\n     };\n@@ -221,11 +212,9 @@ impl<T: 'static> LocalKey<T> {\n     #[unstable(feature = \"thread_local_internals\",\n                reason = \"recently added to create a key\",\n                issue = \"0\")]\n-    pub const unsafe fn new(inner: unsafe fn() -> Option<&'static UnsafeCell<Option<T>>>,\n-                            init: fn() -> T) -> LocalKey<T> {\n+    pub const unsafe fn new(inner: unsafe fn() -> Option<&'static T>) -> LocalKey<T> {\n         LocalKey {\n             inner,\n-            init,\n         }\n     }\n \n@@ -246,37 +235,6 @@ impl<T: 'static> LocalKey<T> {\n                                  after it is destroyed\")\n     }\n \n-    unsafe fn init(&self, slot: &UnsafeCell<Option<T>>) -> &T {\n-        // Execute the initialization up front, *then* move it into our slot,\n-        // just in case initialization fails.\n-        let value = (self.init)();\n-        let ptr = slot.get();\n-\n-        // note that this can in theory just be `*ptr = Some(value)`, but due to\n-        // the compiler will currently codegen that pattern with something like:\n-        //\n-        //      ptr::drop_in_place(ptr)\n-        //      ptr::write(ptr, Some(value))\n-        //\n-        // Due to this pattern it's possible for the destructor of the value in\n-        // `ptr` (e.g., if this is being recursively initialized) to re-access\n-        // TLS, in which case there will be a `&` and `&mut` pointer to the same\n-        // value (an aliasing violation). To avoid setting the \"I'm running a\n-        // destructor\" flag we just use `mem::replace` which should sequence the\n-        // operations a little differently and make this safe to call.\n-        mem::replace(&mut *ptr, Some(value));\n-\n-        // After storing `Some` we want to get a reference to the contents of\n-        // what we just stored. While we could use `unwrap` here and it should\n-        // always work it empirically doesn't seem to always get optimized away,\n-        // which means that using something like `try_with` can pull in\n-        // panicking code and cause a large size bloat.\n-        match *ptr {\n-            Some(ref x) => x,\n-            None => hint::unreachable_unchecked(),\n-        }\n-    }\n-\n     /// Acquires a reference to the value in this TLS key.\n     ///\n     /// This will lazily initialize the value if this thread has not referenced\n@@ -293,13 +251,68 @@ impl<T: 'static> LocalKey<T> {\n         F: FnOnce(&T) -> R,\n     {\n         unsafe {\n-            let slot = (self.inner)().ok_or(AccessError {\n+            let thread_local = (self.inner)().ok_or(AccessError {\n                 _private: (),\n             })?;\n-            Ok(f(match *slot.get() {\n-                Some(ref inner) => inner,\n-                None => self.init(slot),\n-            }))\n+            Ok(f(thread_local))\n+        }\n+    }\n+}\n+\n+mod lazy {\n+    use crate::cell::UnsafeCell;\n+    use crate::mem;\n+    use crate::hint;\n+\n+    pub struct LazyKeyInner<T> {\n+        inner: UnsafeCell<Option<T>>,\n+    }\n+\n+    impl<T> LazyKeyInner<T> {\n+        pub const fn new() -> LazyKeyInner<T> {\n+            LazyKeyInner {\n+                inner: UnsafeCell::new(None),\n+            }\n+        }\n+\n+        pub unsafe fn get(&self) -> Option<&'static T> {\n+            (*self.inner.get()).as_ref()\n+        }\n+\n+        pub unsafe fn initialize<F: FnOnce() -> T>(&self, init: F) -> &'static T {\n+            // Execute the initialization up front, *then* move it into our slot,\n+            // just in case initialization fails.\n+            let value = init();\n+            let ptr = self.inner.get();\n+\n+            // note that this can in theory just be `*ptr = Some(value)`, but due to\n+            // the compiler will currently codegen that pattern with something like:\n+            //\n+            //      ptr::drop_in_place(ptr)\n+            //      ptr::write(ptr, Some(value))\n+            //\n+            // Due to this pattern it's possible for the destructor of the value in\n+            // `ptr` (e.g., if this is being recursively initialized) to re-access\n+            // TLS, in which case there will be a `&` and `&mut` pointer to the same\n+            // value (an aliasing violation). To avoid setting the \"I'm running a\n+            // destructor\" flag we just use `mem::replace` which should sequence the\n+            // operations a little differently and make this safe to call.\n+            mem::replace(&mut *ptr, Some(value));\n+\n+            // After storing `Some` we want to get a reference to the contents of\n+            // what we just stored. While we could use `unwrap` here and it should\n+            // always work it empirically doesn't seem to always get optimized away,\n+            // which means that using something like `try_with` can pull in\n+            // panicking code and cause a large size bloat.\n+            match *ptr {\n+                Some(ref x) => x,\n+                None => hint::unreachable_unchecked(),\n+            }\n+        }\n+\n+        #[allow(unused)]\n+        pub unsafe fn take(&mut self) -> Option<T> {\n+            (*self.inner.get()).take()\n         }\n     }\n }\n@@ -309,11 +322,11 @@ impl<T: 'static> LocalKey<T> {\n #[doc(hidden)]\n #[cfg(all(target_arch = \"wasm32\", not(target_feature = \"atomics\")))]\n pub mod statik {\n-    use crate::cell::UnsafeCell;\n+    use super::lazy::LazyKeyInner;\n     use crate::fmt;\n \n     pub struct Key<T> {\n-        inner: UnsafeCell<Option<T>>,\n+        inner: LazyKeyInner<T>,\n     }\n \n     unsafe impl<T> Sync for Key<T> { }\n@@ -327,32 +340,55 @@ pub mod statik {\n     impl<T> Key<T> {\n         pub const fn new() -> Key<T> {\n             Key {\n-                inner: UnsafeCell::new(None),\n+                inner: LazyKeyInner::new(),\n             }\n         }\n \n-        pub unsafe fn get(&self) -> Option<&'static UnsafeCell<Option<T>>> {\n-            Some(&*(&self.inner as *const _))\n+        pub unsafe fn get(&self, init: fn() -> T) -> Option<&'static T> {\n+            let value = match self.inner.get() {\n+                Some(ref value) => value,\n+                None => self.inner.initialize(init),\n+            };\n+            Some(value)\n         }\n     }\n }\n \n #[doc(hidden)]\n #[cfg(target_thread_local)]\n pub mod fast {\n-    use crate::cell::{Cell, UnsafeCell};\n+    use super::lazy::LazyKeyInner;\n+    use crate::cell::Cell;\n     use crate::fmt;\n     use crate::mem;\n-    use crate::ptr;\n-    use crate::sys::fast_thread_local::{register_dtor, requires_move_before_drop};\n+    use crate::sys::fast_thread_local::register_dtor;\n \n+    #[derive(Copy, Clone)]\n+    enum DtorState {\n+        Unregistered,\n+        Registered,\n+        RunningOrHasRun,\n+    }\n+\n+    // This data structure has been carefully constructed so that the fast path\n+    // only contains one branch on x86. That optimization is necessary to avoid\n+    // duplicated tls lookups on OSX.\n+    //\n+    // LLVM issue: https://bugs.llvm.org/show_bug.cgi?id=41722\n     pub struct Key<T> {\n-        inner: UnsafeCell<Option<T>>,\n+        // If `LazyKeyInner::get` returns `None`, that indicates either:\n+        //   * The value has never been initialized\n+        //   * The value is being recursively initialized\n+        //   * The value has already been destroyed or is being destroyed\n+        // To determine which kind of `None`, check `dtor_state`.\n+        //\n+        // This is very optimizer friendly for the fast path - initialized but\n+        // not yet dropped.\n+        inner: LazyKeyInner<T>,\n \n         // Metadata to keep track of the state of the destructor. Remember that\n-        // these variables are thread-local, not global.\n-        dtor_registered: Cell<bool>,\n-        dtor_running: Cell<bool>,\n+        // this variable is thread-local, not global.\n+        dtor_state: Cell<DtorState>,\n     }\n \n     impl<T> fmt::Debug for Key<T> {\n@@ -364,54 +400,75 @@ pub mod fast {\n     impl<T> Key<T> {\n         pub const fn new() -> Key<T> {\n             Key {\n-                inner: UnsafeCell::new(None),\n-                dtor_registered: Cell::new(false),\n-                dtor_running: Cell::new(false)\n+                inner: LazyKeyInner::new(),\n+                dtor_state: Cell::new(DtorState::Unregistered),\n             }\n         }\n \n-        pub unsafe fn get(&self) -> Option<&'static UnsafeCell<Option<T>>> {\n-            if mem::needs_drop::<T>() && self.dtor_running.get() {\n-                return None\n+        pub unsafe fn get<F: FnOnce() -> T>(&self, init: F) -> Option<&'static T> {\n+            match self.inner.get() {\n+                Some(val) => Some(val),\n+                None => self.try_initialize(init),\n             }\n-            self.register_dtor();\n-            Some(&*(&self.inner as *const _))\n         }\n \n-        unsafe fn register_dtor(&self) {\n-            if !mem::needs_drop::<T>() || self.dtor_registered.get() {\n-                return\n+        // `try_initialize` is only called once per fast thread local variable,\n+        // except in corner cases where thread_local dtors reference other\n+        // thread_local's, or it is being recursively initialized.\n+        //\n+        // Macos: Inlining this function can cause two `tlv_get_addr` calls to\n+        // be performed for every call to `Key::get`. The #[cold] hint makes\n+        // that less likely.\n+        // LLVM issue: https://bugs.llvm.org/show_bug.cgi?id=41722\n+        #[cold]\n+        unsafe fn try_initialize<F: FnOnce() -> T>(&self, init: F) -> Option<&'static T> {\n+            if !mem::needs_drop::<T>() || self.try_register_dtor() {\n+                Some(self.inner.initialize(init))\n+            } else {\n+                None\n             }\n+        }\n \n-            register_dtor(self as *const _ as *mut u8,\n-                          destroy_value::<T>);\n-            self.dtor_registered.set(true);\n+        // `try_register_dtor` is only called once per fast thread local\n+        // variable, except in corner cases where thread_local dtors reference\n+        // other thread_local's, or it is being recursively initialized.\n+        unsafe fn try_register_dtor(&self) -> bool {\n+            match self.dtor_state.get() {\n+                DtorState::Unregistered => {\n+                    // dtor registration happens before initialization.\n+                    register_dtor(self as *const _ as *mut u8,\n+                                destroy_value::<T>);\n+                    self.dtor_state.set(DtorState::Registered);\n+                    true\n+                }\n+                DtorState::Registered => {\n+                    // recursively initialized\n+                    true\n+                }\n+                DtorState::RunningOrHasRun => {\n+                    false\n+                }\n+            }\n         }\n     }\n \n     unsafe extern fn destroy_value<T>(ptr: *mut u8) {\n         let ptr = ptr as *mut Key<T>;\n-        // Right before we run the user destructor be sure to flag the\n-        // destructor as running for this thread so calls to `get` will return\n-        // `None`.\n-        (*ptr).dtor_running.set(true);\n \n-        // Some implementations may require us to move the value before we drop\n-        // it as it could get re-initialized in-place during destruction.\n-        //\n-        // Hence, we use `ptr::read` on those platforms (to move to a \"safe\"\n-        // location) instead of drop_in_place.\n-        if requires_move_before_drop() {\n-            ptr::read((*ptr).inner.get());\n-        } else {\n-            ptr::drop_in_place((*ptr).inner.get());\n-        }\n+        // Right before we run the user destructor be sure to set the\n+        // `Option<T>` to `None`, and `dtor_state` to `RunningOrHasRun`. This\n+        // causes future calls to `get` to run `try_initialize_drop` again,\n+        // which will now fail, and return `None`.\n+        let value = (*ptr).inner.take();\n+        (*ptr).dtor_state.set(DtorState::RunningOrHasRun);\n+        drop(value);\n     }\n }\n \n #[doc(hidden)]\n pub mod os {\n-    use crate::cell::{Cell, UnsafeCell};\n+    use super::lazy::LazyKeyInner;\n+    use crate::cell::Cell;\n     use crate::fmt;\n     use crate::marker;\n     use crate::ptr;\n@@ -432,8 +489,8 @@ pub mod os {\n     unsafe impl<T> Sync for Key<T> { }\n \n     struct Value<T: 'static> {\n+        inner: LazyKeyInner<T>,\n         key: &'static Key<T>,\n-        value: UnsafeCell<Option<T>>,\n     }\n \n     impl<T: 'static> Key<T> {\n@@ -444,24 +501,43 @@ pub mod os {\n             }\n         }\n \n-        pub unsafe fn get(&'static self) -> Option<&'static UnsafeCell<Option<T>>> {\n+        pub unsafe fn get(&'static self, init: fn() -> T) -> Option<&'static T> {\n             let ptr = self.os.get() as *mut Value<T>;\n-            if !ptr.is_null() {\n-                if ptr as usize == 1 {\n-                    return None\n+            if ptr as usize > 1 {\n+                match (*ptr).inner.get() {\n+                    Some(ref value) => return Some(value),\n+                    None => {},\n                 }\n-                return Some(&(*ptr).value);\n+            }\n+            self.try_initialize(init)\n+        }\n+\n+        // `try_initialize` is only called once per os thread local variable,\n+        // except in corner cases where thread_local dtors reference other\n+        // thread_local's, or it is being recursively initialized.\n+        unsafe fn try_initialize(&'static self, init: fn() -> T) -> Option<&'static T> {\n+            let ptr = self.os.get() as *mut Value<T>;\n+            if ptr as usize == 1 {\n+                // destructor is running\n+                return None\n             }\n \n-            // If the lookup returned null, we haven't initialized our own\n-            // local copy, so do that now.\n-            let ptr: Box<Value<T>> = box Value {\n-                key: self,\n-                value: UnsafeCell::new(None),\n+            let ptr = if ptr.is_null() {\n+                // If the lookup returned null, we haven't initialized our own\n+                // local copy, so do that now.\n+                let ptr: Box<Value<T>> = box Value {\n+                    inner: LazyKeyInner::new(),\n+                    key: self,\n+                };\n+                let ptr = Box::into_raw(ptr);\n+                self.os.set(ptr as *mut u8);\n+                ptr\n+            } else {\n+                // recursive initialization\n+                ptr\n             };\n-            let ptr = Box::into_raw(ptr);\n-            self.os.set(ptr as *mut u8);\n-            Some(&(*ptr).value)\n+\n+            Some((*ptr).inner.initialize(init))\n         }\n     }\n "}, {"sha": "b1a62ac81d03314c3d8e35418e3fac9ffc8e7d16", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -362,7 +362,6 @@ impl Default for Generics {\n         Generics {\n             params: Vec::new(),\n             where_clause: WhereClause {\n-                id: DUMMY_NODE_ID,\n                 predicates: Vec::new(),\n                 span: DUMMY_SP,\n             },\n@@ -374,7 +373,6 @@ impl Default for Generics {\n /// A where-clause in a definition.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct WhereClause {\n-    pub id: NodeId,\n     pub predicates: Vec<WherePredicate>,\n     pub span: Span,\n }"}, {"sha": "3b42e1de61497244f0fb038431d7ed9e507d8f7f", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -240,6 +240,10 @@ impl<'a> StripUnconfigured<'a> {\n         items.flat_map_in_place(|item| self.configure(item));\n     }\n \n+    pub fn configure_generic_params(&mut self, params: &mut Vec<ast::GenericParam>) {\n+        params.flat_map_in_place(|param| self.configure(param));\n+    }\n+\n     fn configure_variant_data(&mut self, vdata: &mut ast::VariantData) {\n         match vdata {\n             ast::VariantData::Struct(fields, ..) | ast::VariantData::Tuple(fields, _) =>\n@@ -301,22 +305,6 @@ impl<'a> StripUnconfigured<'a> {\n     pub fn configure_fn_decl(&mut self, fn_decl: &mut ast::FnDecl) {\n         fn_decl.inputs.flat_map_in_place(|arg| self.configure(arg));\n     }\n-\n-    /// Denies `#[cfg]` on generic parameters until we decide what to do with it.\n-    /// See issue #51279.\n-    pub fn disallow_cfg_on_generic_param(&mut self, param: &ast::GenericParam) {\n-        for attr in param.attrs() {\n-            let offending_attr = if attr.check_name(sym::cfg) {\n-                \"cfg\"\n-            } else if attr.check_name(sym::cfg_attr) {\n-                \"cfg_attr\"\n-            } else {\n-                continue;\n-            };\n-            let msg = format!(\"#[{}] cannot be applied on a generic parameter\", offending_attr);\n-            self.sess.span_diagnostic.span_err(attr.span, &msg);\n-        }\n-    }\n }\n \n impl<'a> MutVisitor for StripUnconfigured<'a> {"}, {"sha": "318a5a3a82a2e6010f9a7d1bd2d46d847eb14a2d", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 88, "deletions": 86, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -15,6 +15,7 @@ use crate::tokenstream::{self, TokenStream};\n use errors::{DiagnosticBuilder, DiagnosticId};\n use smallvec::{smallvec, SmallVec};\n use syntax_pos::{Span, MultiSpan, DUMMY_SP};\n+use syntax_pos::hygiene::{ExpnInfo, ExpnFormat};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{self, Lrc};\n@@ -548,46 +549,26 @@ impl MacroKind {\n     }\n }\n \n-/// An enum representing the different kinds of syntax extensions.\n-pub enum SyntaxExtension {\n+/// A syntax extension kind.\n+pub enum SyntaxExtensionKind {\n     /// A token-based function-like macro.\n-    Bang {\n+    Bang(\n         /// An expander with signature TokenStream -> TokenStream.\n-        expander: Box<dyn ProcMacro + sync::Sync + sync::Send>,\n-        /// Whitelist of unstable features that are treated as stable inside this macro.\n-        allow_internal_unstable: Option<Lrc<[Symbol]>>,\n-        /// Edition of the crate in which this macro is defined.\n-        edition: Edition,\n-    },\n+        Box<dyn ProcMacro + sync::Sync + sync::Send>,\n+    ),\n \n     /// An AST-based function-like macro.\n-    LegacyBang {\n+    LegacyBang(\n         /// An expander with signature TokenStream -> AST.\n-        expander: Box<dyn TTMacroExpander + sync::Sync + sync::Send>,\n-        /// Some info about the macro's definition point.\n-        def_info: Option<(ast::NodeId, Span)>,\n-        /// Hygienic properties of identifiers produced by this macro.\n-        transparency: Transparency,\n-        /// Whitelist of unstable features that are treated as stable inside this macro.\n-        allow_internal_unstable: Option<Lrc<[Symbol]>>,\n-        /// Suppresses the `unsafe_code` lint for code produced by this macro.\n-        allow_internal_unsafe: bool,\n-        /// Enables the macro helper hack (`ident!(...)` -> `$crate::ident!(...)`) for this macro.\n-        local_inner_macros: bool,\n-        /// The macro's feature name and tracking issue number if it is unstable.\n-        unstable_feature: Option<(Symbol, u32)>,\n-        /// Edition of the crate in which this macro is defined.\n-        edition: Edition,\n-    },\n+        Box<dyn TTMacroExpander + sync::Sync + sync::Send>,\n+    ),\n \n     /// A token-based attribute macro.\n     Attr(\n         /// An expander with signature (TokenStream, TokenStream) -> TokenStream.\n         /// The first TokenSteam is the attribute itself, the second is the annotated item.\n         /// The produced TokenSteam replaces the input TokenSteam.\n         Box<dyn AttrProcMacro + sync::Sync + sync::Send>,\n-        /// Edition of the crate in which this macro is defined.\n-        Edition,\n     ),\n \n     /// An AST-based attribute macro.\n@@ -599,7 +580,8 @@ pub enum SyntaxExtension {\n     ),\n \n     /// A trivial attribute \"macro\" that does nothing,\n-    /// only keeps the attribute and marks it as known.\n+    /// only keeps the attribute and marks it as inert,\n+    /// thus making it ineligible for further expansion.\n     NonMacroAttr {\n         /// Suppresses the `unused_attributes` lint for this attribute.\n         mark_used: bool,\n@@ -610,10 +592,6 @@ pub enum SyntaxExtension {\n         /// An expander with signature TokenStream -> TokenStream (not yet).\n         /// The produced TokenSteam is appended to the input TokenSteam.\n         Box<dyn MultiItemModifier + sync::Sync + sync::Send>,\n-        /// Names of helper attributes registered by this macro.\n-        Vec<Symbol>,\n-        /// Edition of the crate in which this macro is defined.\n-        Edition,\n     ),\n \n     /// An AST-based derive macro.\n@@ -624,42 +602,91 @@ pub enum SyntaxExtension {\n     ),\n }\n \n+/// A struct representing a macro definition in \"lowered\" form ready for expansion.\n+pub struct SyntaxExtension {\n+    /// A syntax extension kind.\n+    pub kind: SyntaxExtensionKind,\n+    /// Some info about the macro's definition point.\n+    pub def_info: Option<(ast::NodeId, Span)>,\n+    /// Hygienic properties of spans produced by this macro by default.\n+    pub default_transparency: Transparency,\n+    /// Whitelist of unstable features that are treated as stable inside this macro.\n+    pub allow_internal_unstable: Option<Lrc<[Symbol]>>,\n+    /// Suppresses the `unsafe_code` lint for code produced by this macro.\n+    pub allow_internal_unsafe: bool,\n+    /// Enables the macro helper hack (`ident!(...)` -> `$crate::ident!(...)`) for this macro.\n+    pub local_inner_macros: bool,\n+    /// The macro's feature name and tracking issue number if it is unstable.\n+    pub unstable_feature: Option<(Symbol, u32)>,\n+    /// Names of helper attributes registered by this macro.\n+    pub helper_attrs: Vec<Symbol>,\n+    /// Edition of the crate in which this macro is defined.\n+    pub edition: Edition,\n+}\n+\n+impl SyntaxExtensionKind {\n+    /// When a syntax extension is constructed,\n+    /// its transparency can often be inferred from its kind.\n+    fn default_transparency(&self) -> Transparency {\n+        match self {\n+            SyntaxExtensionKind::Bang(..) |\n+            SyntaxExtensionKind::Attr(..) |\n+            SyntaxExtensionKind::Derive(..) |\n+            SyntaxExtensionKind::NonMacroAttr { .. } => Transparency::Opaque,\n+            SyntaxExtensionKind::LegacyBang(..) |\n+            SyntaxExtensionKind::LegacyAttr(..) |\n+            SyntaxExtensionKind::LegacyDerive(..) => Transparency::SemiTransparent,\n+        }\n+    }\n+}\n+\n impl SyntaxExtension {\n     /// Returns which kind of macro calls this syntax extension.\n-    pub fn kind(&self) -> MacroKind {\n-        match *self {\n-            SyntaxExtension::Bang { .. } |\n-            SyntaxExtension::LegacyBang { .. } => MacroKind::Bang,\n-            SyntaxExtension::Attr(..) |\n-            SyntaxExtension::LegacyAttr(..) |\n-            SyntaxExtension::NonMacroAttr { .. } => MacroKind::Attr,\n-            SyntaxExtension::Derive(..) |\n-            SyntaxExtension::LegacyDerive(..) => MacroKind::Derive,\n+    pub fn macro_kind(&self) -> MacroKind {\n+        match self.kind {\n+            SyntaxExtensionKind::Bang(..) |\n+            SyntaxExtensionKind::LegacyBang(..) => MacroKind::Bang,\n+            SyntaxExtensionKind::Attr(..) |\n+            SyntaxExtensionKind::LegacyAttr(..) |\n+            SyntaxExtensionKind::NonMacroAttr { .. } => MacroKind::Attr,\n+            SyntaxExtensionKind::Derive(..) |\n+            SyntaxExtensionKind::LegacyDerive(..) => MacroKind::Derive,\n         }\n     }\n \n-    pub fn default_transparency(&self) -> Transparency {\n-        match *self {\n-            SyntaxExtension::LegacyBang { transparency, .. } => transparency,\n-            SyntaxExtension::Bang { .. } |\n-            SyntaxExtension::Attr(..) |\n-            SyntaxExtension::Derive(..) |\n-            SyntaxExtension::NonMacroAttr { .. } => Transparency::Opaque,\n-            SyntaxExtension::LegacyAttr(..) |\n-            SyntaxExtension::LegacyDerive(..) => Transparency::SemiTransparent,\n+    /// Constructs a syntax extension with default properties.\n+    pub fn default(kind: SyntaxExtensionKind, edition: Edition) -> SyntaxExtension {\n+        SyntaxExtension {\n+            def_info: None,\n+            default_transparency: kind.default_transparency(),\n+            allow_internal_unstable: None,\n+            allow_internal_unsafe: false,\n+            local_inner_macros: false,\n+            unstable_feature: None,\n+            helper_attrs: Vec::new(),\n+            edition,\n+            kind,\n         }\n     }\n \n-    pub fn edition(&self, default_edition: Edition) -> Edition {\n-        match *self {\n-            SyntaxExtension::Bang { edition, .. } |\n-            SyntaxExtension::LegacyBang { edition, .. } |\n-            SyntaxExtension::Attr(.., edition) |\n-            SyntaxExtension::Derive(.., edition) => edition,\n-            // Unstable legacy stuff\n-            SyntaxExtension::NonMacroAttr { .. } |\n-            SyntaxExtension::LegacyAttr(..) |\n-            SyntaxExtension::LegacyDerive(..) => default_edition,\n+    fn expn_format(&self, symbol: Symbol) -> ExpnFormat {\n+        match self.kind {\n+            SyntaxExtensionKind::Bang(..) |\n+            SyntaxExtensionKind::LegacyBang(..) => ExpnFormat::MacroBang(symbol),\n+            _ => ExpnFormat::MacroAttribute(symbol),\n+        }\n+    }\n+\n+    pub fn expn_info(&self, call_site: Span, format: &str) -> ExpnInfo {\n+        ExpnInfo {\n+            call_site,\n+            format: self.expn_format(Symbol::intern(format)),\n+            def_site: self.def_info.map(|(_, span)| span),\n+            default_transparency: self.default_transparency,\n+            allow_internal_unstable: self.allow_internal_unstable.clone(),\n+            allow_internal_unsafe: self.allow_internal_unsafe,\n+            local_inner_macros: self.local_inner_macros,\n+            edition: self.edition,\n         }\n     }\n }\n@@ -699,31 +726,6 @@ impl Determinacy {\n     }\n }\n \n-pub struct DummyResolver;\n-\n-impl Resolver for DummyResolver {\n-    fn next_node_id(&mut self) -> ast::NodeId { ast::DUMMY_NODE_ID }\n-\n-    fn get_module_scope(&mut self, _id: ast::NodeId) -> Mark { Mark::root() }\n-\n-    fn resolve_dollar_crates(&mut self, _fragment: &AstFragment) {}\n-    fn visit_ast_fragment_with_placeholders(&mut self, _invoc: Mark, _fragment: &AstFragment,\n-                                            _derives: &[Mark]) {}\n-    fn add_builtin(&mut self, _ident: ast::Ident, _ext: Lrc<SyntaxExtension>) {}\n-\n-    fn resolve_imports(&mut self) {}\n-    fn resolve_macro_invocation(&mut self, _invoc: &Invocation, _invoc_id: Mark, _force: bool)\n-                                -> Result<Option<Lrc<SyntaxExtension>>, Determinacy> {\n-        Err(Determinacy::Determined)\n-    }\n-    fn resolve_macro_path(&mut self, _path: &ast::Path, _kind: MacroKind, _invoc_id: Mark,\n-                          _derives_in_scope: Vec<ast::Path>, _force: bool)\n-                          -> Result<Lrc<SyntaxExtension>, Determinacy> {\n-        Err(Determinacy::Determined)\n-    }\n-    fn check_unused_macros(&self) {}\n-}\n-\n #[derive(Clone)]\n pub struct ModuleData {\n     pub mod_path: Vec<ast::Ident>,"}, {"sha": "abc451c96ae0ef9f1cdc794fb08a6e6f0f42e39b", "filename": "src/libsyntax/ext/derive.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -60,15 +60,10 @@ pub fn add_derived_markers<T>(cx: &mut ExtCtxt<'_>, span: Span, traits: &[ast::P\n     }\n     pretty_name.push(')');\n \n-    cx.current_expansion.mark.set_expn_info(ExpnInfo {\n-        call_site: span,\n-        def_site: None,\n-        format: ExpnFormat::MacroAttribute(Symbol::intern(&pretty_name)),\n-        allow_internal_unstable: Some(vec![sym::rustc_attrs, sym::structural_match].into()),\n-        allow_internal_unsafe: false,\n-        local_inner_macros: false,\n-        edition: cx.parse_sess.edition,\n-    });\n+    cx.current_expansion.mark.set_expn_info(ExpnInfo::with_unstable(\n+        ExpnFormat::MacroAttribute(Symbol::intern(&pretty_name)), span, cx.parse_sess.edition,\n+        &[sym::rustc_attrs, sym::structural_match],\n+    ));\n \n     let span = span.with_ctxt(cx.backtrace());\n     item.visit_attrs(|attrs| {"}, {"sha": "cfd67575b6fe120ac720d12bb3e776e73143b5be", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 40, "deletions": 150, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -1,7 +1,7 @@\n use crate::ast::{self, Block, Ident, LitKind, NodeId, PatKind, Path};\n use crate::ast::{MacStmtStyle, StmtKind, ItemKind};\n use crate::attr::{self, HasAttrs};\n-use crate::source_map::{ExpnInfo, MacroBang, MacroAttribute, dummy_spanned, respan};\n+use crate::source_map::{dummy_spanned, respan};\n use crate::config::StripUnconfigured;\n use crate::ext::base::*;\n use crate::ext::derive::{add_derived_markers, collect_derives};\n@@ -22,7 +22,6 @@ use crate::util::map_in_place::MapInPlace;\n use errors::{Applicability, FatalError};\n use smallvec::{smallvec, SmallVec};\n use syntax_pos::{Span, DUMMY_SP, FileName};\n-use syntax_pos::hygiene::ExpnFormat;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n@@ -189,23 +188,6 @@ impl AstFragmentKind {\n     }\n }\n \n-fn macro_bang_format(path: &ast::Path) -> ExpnFormat {\n-    // We don't want to format a path using pretty-printing,\n-    // `format!(\"{}\", path)`, because that tries to insert\n-    // line-breaks and is slow.\n-    let mut path_str = String::with_capacity(64);\n-    for (i, segment) in path.segments.iter().enumerate() {\n-        if i != 0 {\n-            path_str.push_str(\"::\");\n-        }\n-        if segment.ident.name != kw::PathRoot {\n-            path_str.push_str(&segment.ident.as_str())\n-        }\n-    }\n-\n-    MacroBang(Symbol::intern(&path_str))\n-}\n-\n pub struct Invocation {\n     pub kind: InvocationKind,\n     fragment_kind: AstFragmentKind,\n@@ -242,7 +224,7 @@ impl Invocation {\n     }\n }\n \n-pub struct MacroExpander<'a, 'b:'a> {\n+pub struct MacroExpander<'a, 'b> {\n     pub cx: &'a mut ExtCtxt<'b>,\n     monotonic: bool, // cf. `cx.monotonic_expander()`\n }\n@@ -388,8 +370,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         derives.push(mark);\n                         let item = match self.cx.resolver.resolve_macro_path(\n                                 path, MacroKind::Derive, Mark::root(), Vec::new(), false) {\n-                            Ok(ext) => match *ext {\n-                                SyntaxExtension::LegacyDerive(..) => item_with_markers.clone(),\n+                            Ok(ext) => match ext.kind {\n+                                SyntaxExtensionKind::LegacyDerive(..) => item_with_markers.clone(),\n                                 _ => item.clone(),\n                             },\n                             _ => item.clone(),\n@@ -509,7 +491,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     fn expand_invoc(&mut self, invoc: Invocation, ext: &SyntaxExtension) -> Option<AstFragment> {\n         if invoc.fragment_kind == AstFragmentKind::ForeignItems &&\n            !self.cx.ecfg.macros_in_extern_enabled() {\n-            if let SyntaxExtension::NonMacroAttr { .. } = *ext {} else {\n+            if let SyntaxExtensionKind::NonMacroAttr { .. } = ext.kind {} else {\n                 emit_feature_err(&self.cx.parse_sess, sym::macros_in_extern,\n                                  invoc.span(), GateIssue::Language,\n                                  \"macro invocations in `extern {}` blocks are experimental\");\n@@ -548,34 +530,22 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             _ => unreachable!(),\n         };\n \n-        if let SyntaxExtension::NonMacroAttr { mark_used: false } = *ext {} else {\n-            // Macro attrs are always used when expanded,\n-            // non-macro attrs are considered used when the field says so.\n-            attr::mark_used(&attr);\n-        }\n-        invoc.expansion_data.mark.set_expn_info(ExpnInfo {\n-            call_site: attr.span,\n-            def_site: None,\n-            format: MacroAttribute(Symbol::intern(&attr.path.to_string())),\n-            allow_internal_unstable: None,\n-            allow_internal_unsafe: false,\n-            local_inner_macros: false,\n-            edition: ext.edition(self.cx.parse_sess.edition),\n-        });\n-\n-        match *ext {\n-            SyntaxExtension::NonMacroAttr { .. } => {\n+        match &ext.kind {\n+            SyntaxExtensionKind::NonMacroAttr { mark_used } => {\n                 attr::mark_known(&attr);\n+                if *mark_used {\n+                    attr::mark_used(&attr);\n+                }\n                 item.visit_attrs(|attrs| attrs.push(attr));\n                 Some(invoc.fragment_kind.expect_from_annotatables(iter::once(item)))\n             }\n-            SyntaxExtension::LegacyAttr(ref mac) => {\n+            SyntaxExtensionKind::LegacyAttr(expander) => {\n                 let meta = attr.parse_meta(self.cx.parse_sess)\n                                .map_err(|mut e| { e.emit(); }).ok()?;\n-                let item = mac.expand(self.cx, attr.span, &meta, item);\n+                let item = expander.expand(self.cx, attr.span, &meta, item);\n                 Some(invoc.fragment_kind.expect_from_annotatables(item))\n             }\n-            SyntaxExtension::Attr(ref mac, ..) => {\n+            SyntaxExtensionKind::Attr(expander) => {\n                 self.gate_proc_macro_attr_item(attr.span, &item);\n                 let item_tok = TokenTree::token(token::Interpolated(Lrc::new(match item {\n                     Annotatable::Item(item) => token::NtItem(item),\n@@ -586,13 +556,13 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     Annotatable::Expr(expr) => token::NtExpr(expr),\n                 })), DUMMY_SP).into();\n                 let input = self.extract_proc_macro_attr_input(attr.tokens, attr.span);\n-                let tok_result = mac.expand(self.cx, attr.span, input, item_tok);\n+                let tok_result = expander.expand(self.cx, attr.span, input, item_tok);\n                 let res = self.parse_ast_fragment(tok_result, invoc.fragment_kind,\n                                                   &attr.path, attr.span);\n                 self.gate_proc_macro_expansion(attr.span, &res);\n                 res\n             }\n-            SyntaxExtension::Derive(..) | SyntaxExtension::LegacyDerive(..) => {\n+            SyntaxExtensionKind::Derive(..) | SyntaxExtensionKind::LegacyDerive(..) => {\n                 self.cx.span_err(attr.span, &format!(\"`{}` is a derive macro\", attr.path));\n                 self.cx.trace_macros_diag();\n                 invoc.fragment_kind.dummy(attr.span)\n@@ -693,29 +663,21 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                          invoc: Invocation,\n                          ext: &SyntaxExtension)\n                          -> Option<AstFragment> {\n-        let (mark, kind) = (invoc.expansion_data.mark, invoc.fragment_kind);\n+        let kind = invoc.fragment_kind;\n         let (mac, ident, span) = match invoc.kind {\n             InvocationKind::Bang { mac, ident, span } => (mac, ident, span),\n             _ => unreachable!(),\n         };\n         let path = &mac.node.path;\n \n         let ident = ident.unwrap_or_else(|| Ident::invalid());\n-        let validate_and_set_expn_info = |this: &mut Self, // arg instead of capture\n-                                          def_site_span: Option<Span>,\n-                                          allow_internal_unstable,\n-                                          allow_internal_unsafe,\n-                                          local_inner_macros,\n-                                          // can't infer this type\n-                                          unstable_feature: Option<(Symbol, u32)>,\n-                                          edition| {\n-\n+        let validate = |this: &mut Self| {\n             // feature-gate the macro invocation\n-            if let Some((feature, issue)) = unstable_feature {\n+            if let Some((feature, issue)) = ext.unstable_feature {\n                 let crate_span = this.cx.current_expansion.crate_span.unwrap();\n                 // don't stability-check macros in the same crate\n                 // (the only time this is null is for syntax extensions registered as macros)\n-                if def_site_span.map_or(false, |def_span| !crate_span.contains(def_span))\n+                if ext.def_info.map_or(false, |(_, def_span)| !crate_span.contains(def_span))\n                     && !span.allows_unstable(feature)\n                     && this.cx.ecfg.features.map_or(true, |feats| {\n                     // macro features will count as lib features\n@@ -734,62 +696,39 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 this.cx.trace_macros_diag();\n                 return Err(kind.dummy(span));\n             }\n-            mark.set_expn_info(ExpnInfo {\n-                call_site: span,\n-                def_site: def_site_span,\n-                format: macro_bang_format(path),\n-                allow_internal_unstable,\n-                allow_internal_unsafe,\n-                local_inner_macros,\n-                edition,\n-            });\n             Ok(())\n         };\n \n-        let opt_expanded = match *ext {\n-            SyntaxExtension::LegacyBang {\n-                ref expander,\n-                def_info,\n-                ref allow_internal_unstable,\n-                allow_internal_unsafe,\n-                local_inner_macros,\n-                unstable_feature,\n-                edition,\n-                ..\n-            } => {\n-                if let Err(dummy_span) = validate_and_set_expn_info(self, def_info.map(|(_, s)| s),\n-                                                                    allow_internal_unstable.clone(),\n-                                                                    allow_internal_unsafe,\n-                                                                    local_inner_macros,\n-                                                                    unstable_feature,\n-                                                                    edition) {\n+        let opt_expanded = match &ext.kind {\n+            SyntaxExtensionKind::LegacyBang(expander) => {\n+                if let Err(dummy_span) = validate(self) {\n                     dummy_span\n                 } else {\n                     kind.make_from(expander.expand(\n                         self.cx,\n                         span,\n                         mac.node.stream(),\n-                        def_info.map(|(_, s)| s),\n+                        ext.def_info.map(|(_, s)| s),\n                     ))\n                 }\n             }\n \n-            SyntaxExtension::Attr(..) |\n-            SyntaxExtension::LegacyAttr(..) |\n-            SyntaxExtension::NonMacroAttr { .. } => {\n+            SyntaxExtensionKind::Attr(..) |\n+            SyntaxExtensionKind::LegacyAttr(..) |\n+            SyntaxExtensionKind::NonMacroAttr { .. } => {\n                 self.cx.span_err(path.span,\n                                  &format!(\"`{}` can only be used in attributes\", path));\n                 self.cx.trace_macros_diag();\n                 kind.dummy(span)\n             }\n \n-            SyntaxExtension::Derive(..) | SyntaxExtension::LegacyDerive(..) => {\n+            SyntaxExtensionKind::Derive(..) | SyntaxExtensionKind::LegacyDerive(..) => {\n                 self.cx.span_err(path.span, &format!(\"`{}` is a derive macro\", path));\n                 self.cx.trace_macros_diag();\n                 kind.dummy(span)\n             }\n \n-            SyntaxExtension::Bang { ref expander, ref allow_internal_unstable, edition } => {\n+            SyntaxExtensionKind::Bang(expander) => {\n                 if ident.name != kw::Invalid {\n                     let msg =\n                         format!(\"macro {}! expects no ident argument, given '{}'\", path, ident);\n@@ -798,19 +737,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     kind.dummy(span)\n                 } else {\n                     self.gate_proc_macro_expansion_kind(span, kind);\n-                    invoc.expansion_data.mark.set_expn_info(ExpnInfo {\n-                        call_site: span,\n-                        // FIXME procedural macros do not have proper span info\n-                        // yet, when they do, we should use it here.\n-                        def_site: None,\n-                        format: macro_bang_format(path),\n-                        // FIXME probably want to follow macro_rules macros here.\n-                        allow_internal_unstable: allow_internal_unstable.clone(),\n-                        allow_internal_unsafe: false,\n-                        local_inner_macros: false,\n-                        edition,\n-                    });\n-\n                     let tok_result = expander.expand(self.cx, span, mac.node.stream());\n                     let result = self.parse_ast_fragment(tok_result, kind, path, span);\n                     self.gate_proc_macro_expansion(span, &result);\n@@ -867,55 +793,19 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             return None;\n         }\n \n-        let pretty_name = Symbol::intern(&format!(\"derive({})\", path));\n-        let span = path.span;\n-        let attr = ast::Attribute {\n-            path, span,\n-            tokens: TokenStream::empty(),\n-            // irrelevant:\n-            id: ast::AttrId(0), style: ast::AttrStyle::Outer, is_sugared_doc: false,\n-        };\n-\n-        let mut expn_info = ExpnInfo {\n-            call_site: span,\n-            def_site: None,\n-            format: MacroAttribute(pretty_name),\n-            allow_internal_unstable: None,\n-            allow_internal_unsafe: false,\n-            local_inner_macros: false,\n-            edition: ext.edition(self.cx.parse_sess.edition),\n-        };\n-\n-        match ext {\n-            SyntaxExtension::Derive(expander, ..) | SyntaxExtension::LegacyDerive(expander) => {\n-                let meta = match ext {\n-                    SyntaxExtension::Derive(..) => ast::MetaItem { // FIXME(jseyfried) avoid this\n-                        path: Path::from_ident(Ident::invalid()),\n-                        span: DUMMY_SP,\n-                        node: ast::MetaItemKind::Word,\n-                    },\n-                    _ => {\n-                        expn_info.allow_internal_unstable = Some(vec![\n-                            sym::rustc_attrs,\n-                            Symbol::intern(\"derive_clone_copy\"),\n-                            Symbol::intern(\"derive_eq\"),\n-                            // RustcDeserialize and RustcSerialize\n-                            Symbol::intern(\"libstd_sys_internals\"),\n-                        ].into());\n-                        attr.meta()?\n-                    }\n-                };\n-\n-                invoc.expansion_data.mark.set_expn_info(expn_info);\n-                let span = span.with_ctxt(self.cx.backtrace());\n+        match &ext.kind {\n+            SyntaxExtensionKind::Derive(expander) |\n+            SyntaxExtensionKind::LegacyDerive(expander) => {\n+                let meta = ast::MetaItem { node: ast::MetaItemKind::Word, span: path.span, path };\n+                let span = meta.span.with_ctxt(self.cx.backtrace());\n                 let items = expander.expand(self.cx, span, &meta, item);\n                 Some(invoc.fragment_kind.expect_from_annotatables(items))\n             }\n             _ => {\n-                let msg = &format!(\"macro `{}` may not be used for derive attributes\", attr.path);\n-                self.cx.span_err(span, msg);\n+                let msg = &format!(\"macro `{}` may not be used for derive attributes\", path);\n+                self.cx.span_err(path.span, msg);\n                 self.cx.trace_macros_diag();\n-                invoc.fragment_kind.dummy(span)\n+                invoc.fragment_kind.dummy(path.span)\n             }\n         }\n     }\n@@ -1031,7 +921,7 @@ impl<'a> Parser<'a> {\n     }\n }\n \n-struct InvocationCollector<'a, 'b: 'a> {\n+struct InvocationCollector<'a, 'b> {\n     cx: &'a mut ExtCtxt<'b>,\n     cfg: StripUnconfigured<'a>,\n     invocations: Vec<Invocation>,\n@@ -1439,9 +1329,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         }\n     }\n \n-    fn visit_generic_param(&mut self, param: &mut ast::GenericParam) {\n-        self.cfg.disallow_cfg_on_generic_param(&param);\n-        noop_visit_generic_param(param, self)\n+    fn visit_generic_params(&mut self, params: &mut Vec<ast::GenericParam>) {\n+        self.cfg.configure_generic_params(params);\n+        noop_visit_generic_params(params, self);\n     }\n \n     fn visit_attribute(&mut self, at: &mut ast::Attribute) {"}, {"sha": "b2b8bfb09b45e9206603929424642976a6390644", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -69,7 +69,7 @@ pub fn placeholder(kind: AstFragmentKind, id: ast::NodeId) -> AstFragment {\n     }\n }\n \n-pub struct PlaceholderExpander<'a, 'b: 'a> {\n+pub struct PlaceholderExpander<'a, 'b> {\n     expanded_fragments: FxHashMap<ast::NodeId, AstFragment>,\n     cx: &'a mut ExtCtxt<'b>,\n     monotonic: bool,"}, {"sha": "d5da4c920bc4f3a8626fc6e93524301268dc7a2d", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -156,7 +156,7 @@ type NamedMatchVec = SmallVec<[NamedMatch; 4]>;\n /// all the elements in that `SmallVec` strictly outlive the root stack slot\n /// lifetime. By separating `'tt` from `'root`, we can show that.\n #[derive(Clone)]\n-struct MatcherPos<'root, 'tt: 'root> {\n+struct MatcherPos<'root, 'tt> {\n     /// The token or sequence of tokens that make up the matcher\n     top_elts: TokenTreeOrTokenTreeSlice<'tt>,\n \n@@ -233,7 +233,7 @@ impl<'root, 'tt> MatcherPos<'root, 'tt> {\n // Therefore, the initial MatcherPos is always allocated on the stack,\n // subsequent ones (of which there aren't that many) are allocated on the heap,\n // and this type is used to encapsulate both cases.\n-enum MatcherPosHandle<'root, 'tt: 'root> {\n+enum MatcherPosHandle<'root, 'tt> {\n     Ref(&'root mut MatcherPos<'root, 'tt>),\n     Box(Box<MatcherPos<'root, 'tt>>),\n }"}, {"sha": "7f051c260ec822a88b50dea9e0293bb160e46ff0", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -1,6 +1,7 @@\n use crate::{ast, attr};\n use crate::edition::Edition;\n-use crate::ext::base::{DummyResult, ExtCtxt, MacResult, SyntaxExtension, TTMacroExpander};\n+use crate::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n+use crate::ext::base::{DummyResult, ExtCtxt, MacResult, TTMacroExpander};\n use crate::ext::expand::{AstFragment, AstFragmentKind};\n use crate::ext::hygiene::Transparency;\n use crate::ext::tt::macro_parser::{Success, Error, Failure};\n@@ -376,7 +377,7 @@ pub fn compile(\n         valid,\n     });\n \n-    let transparency = if attr::contains_name(&def.attrs, sym::rustc_transparent_macro) {\n+    let default_transparency = if attr::contains_name(&def.attrs, sym::rustc_transparent_macro) {\n         Transparency::Transparent\n     } else if body.legacy {\n         Transparency::SemiTransparent\n@@ -426,14 +427,15 @@ pub fn compile(\n         }\n     });\n \n-    SyntaxExtension::LegacyBang {\n-        expander,\n+    SyntaxExtension {\n+        kind: SyntaxExtensionKind::LegacyBang(expander),\n         def_info: Some((def.id, def.span)),\n-        transparency,\n+        default_transparency,\n         allow_internal_unstable,\n         allow_internal_unsafe,\n         local_inner_macros,\n         unstable_feature,\n+        helper_attrs: Vec::new(),\n         edition,\n     }\n }"}, {"sha": "337b84247361d8021d0ab88166afaf0ce3c8314a", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -12,6 +12,8 @@\n #![deny(unused_lifetimes)]\n \n #![feature(bind_by_move_pattern_guards)]\n+#![feature(const_fn)]\n+#![feature(const_transmute)]\n #![feature(crate_visibility_modifier)]\n #![feature(label_break_value)]\n #![feature(nll)]"}, {"sha": "5a5b633e3151ffa55d0f2e539b6cead4376107d2", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -750,8 +750,7 @@ pub fn noop_visit_generics<T: MutVisitor>(generics: &mut Generics, vis: &mut T)\n }\n \n pub fn noop_visit_where_clause<T: MutVisitor>(wc: &mut WhereClause, vis: &mut T) {\n-    let WhereClause { id, predicates, span } = wc;\n-    vis.visit_id(id);\n+    let WhereClause { predicates, span } = wc;\n     visit_vec(predicates, |predicate| vis.visit_where_predicate(predicate));\n     vis.visit_span(span);\n }"}, {"sha": "fa697e06d269dcc47bf192a60374a9d5bb5525ae", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -5075,7 +5075,6 @@ impl<'a> Parser<'a> {\n         Ok(ast::Generics {\n             params,\n             where_clause: WhereClause {\n-                id: ast::DUMMY_NODE_ID,\n                 predicates: Vec::new(),\n                 span: DUMMY_SP,\n             },\n@@ -5334,7 +5333,6 @@ impl<'a> Parser<'a> {\n     /// ```\n     fn parse_where_clause(&mut self) -> PResult<'a, WhereClause> {\n         let mut where_clause = WhereClause {\n-            id: ast::DUMMY_NODE_ID,\n             predicates: Vec::new(),\n             span: self.prev_span.to(self.prev_span),\n         };"}, {"sha": "0aac4f83658b9d9735dc46200286d0e76ca48fe8", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -3042,7 +3042,6 @@ impl<'a> State<'a> {\n         let generics = ast::Generics {\n             params: Vec::new(),\n             where_clause: ast::WhereClause {\n-                id: ast::DUMMY_NODE_ID,\n                 predicates: Vec::new(),\n                 span: syntax_pos::DUMMY_SP,\n             },"}, {"sha": "f0cfa5a84a827ddc3fcb4d54fa4d5b42ad495a42", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -133,8 +133,15 @@ impl<T: Encodable> Encodable for P<T> {\n }\n \n impl<T> P<[T]> {\n-    pub fn new() -> P<[T]> {\n-        P { ptr: Default::default() }\n+    pub const fn new() -> P<[T]> {\n+        // HACK(eddyb) bypass the lack of a `const fn` to create an empty `Box<[T]>`\n+        // (as trait methods, `default` in this case, can't be `const fn` yet).\n+        P {\n+            ptr: unsafe {\n+                use std::ptr::NonNull;\n+                std::mem::transmute(NonNull::<[T; 0]>::dangling() as NonNull<[T]>)\n+            },\n+        }\n     }\n \n     #[inline(never)]"}, {"sha": "c0307263387ec6c7e8ec034f33da873f8ad40b8f", "filename": "src/libsyntax/source_map.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsource_map.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -191,6 +191,18 @@ impl SourceMap {\n     /// If a file already exists in the source_map with the same id, that file is returned\n     /// unmodified\n     pub fn new_source_file(&self, filename: FileName, src: String) -> Lrc<SourceFile> {\n+        self.try_new_source_file(filename, src)\n+            .unwrap_or_else(|OffsetOverflowError| {\n+                eprintln!(\"fatal error: rustc does not support files larger than 4GB\");\n+                errors::FatalError.raise()\n+            })\n+    }\n+\n+    fn try_new_source_file(\n+        &self,\n+        filename: FileName,\n+        src: String\n+    ) -> Result<Lrc<SourceFile>, OffsetOverflowError> {\n         let start_pos = self.next_start_pos();\n \n         // The path is used to determine the directory for loading submodules and\n@@ -212,7 +224,7 @@ impl SourceMap {\n                                                        was_remapped,\n                                                        Some(&unmapped_path));\n \n-        return match self.source_file_by_stable_id(file_id) {\n+        let lrc_sf = match self.source_file_by_stable_id(file_id) {\n             Some(lrc_sf) => lrc_sf,\n             None => {\n                 let source_file = Lrc::new(SourceFile::new(\n@@ -221,7 +233,7 @@ impl SourceMap {\n                     unmapped_path,\n                     src,\n                     Pos::from_usize(start_pos),\n-                ));\n+                )?);\n \n                 let mut files = self.files.borrow_mut();\n \n@@ -230,7 +242,8 @@ impl SourceMap {\n \n                 source_file\n             }\n-        }\n+        };\n+        Ok(lrc_sf)\n     }\n \n     /// Allocates a new SourceFile representing a source file from an external"}, {"sha": "6630bf9081546de2a712a73d7355e09debf9465a", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -16,15 +16,9 @@ use syntax_pos::{DUMMY_SP, Span};\n /// The expanded code uses the unstable `#[prelude_import]` attribute.\n fn ignored_span(sp: Span, edition: Edition) -> Span {\n     let mark = Mark::fresh(Mark::root());\n-    mark.set_expn_info(ExpnInfo {\n-        call_site: DUMMY_SP,\n-        def_site: None,\n-        format: MacroAttribute(Symbol::intern(\"std_inject\")),\n-        allow_internal_unstable: Some(vec![sym::prelude_import].into()),\n-        allow_internal_unsafe: false,\n-        local_inner_macros: false,\n-        edition,\n-    });\n+    mark.set_expn_info(ExpnInfo::with_unstable(\n+        MacroAttribute(Symbol::intern(\"std_inject\")), sp, edition, &[sym::prelude_import]\n+    ));\n     sp.with_ctxt(SyntaxContext::empty().apply_mark(mark))\n }\n "}, {"sha": "f90b76721ee16a29402eb3e432505abb288df948", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -280,15 +280,10 @@ fn generate_test_harness(sess: &ParseSess,\n         test_runner\n     };\n \n-    mark.set_expn_info(ExpnInfo {\n-        call_site: DUMMY_SP,\n-        def_site: None,\n-        format: MacroAttribute(sym::test_case),\n-        allow_internal_unstable: Some(vec![sym::main, sym::test, sym::rustc_attrs].into()),\n-        allow_internal_unsafe: false,\n-        local_inner_macros: false,\n-        edition: sess.edition,\n-    });\n+    mark.set_expn_info(ExpnInfo::with_unstable(\n+        MacroAttribute(sym::test_case), DUMMY_SP, sess.edition,\n+        &[sym::main, sym::test, sym::rustc_attrs],\n+    ));\n \n     TestHarnessGenerator {\n         cx,"}, {"sha": "444cf1263ce255abcf6cce8b83a1fcfb5078dfa7", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -339,14 +339,15 @@ pub fn combine_substructure<'a>(f: CombineSubstructureFunc<'a>)\n /// This method helps to extract all the type parameters referenced from a\n /// type. For a type parameter `<T>`, it looks for either a `TyPath` that\n /// is not global and starts with `T`, or a `TyQPath`.\n-fn find_type_parameters(ty: &ast::Ty,\n-                        ty_param_names: &[ast::Name],\n-                        span: Span,\n-                        cx: &ExtCtxt<'_>)\n-                        -> Vec<P<ast::Ty>> {\n+fn find_type_parameters(\n+    ty: &ast::Ty,\n+    ty_param_names: &[ast::Name],\n+    span: Span,\n+    cx: &ExtCtxt<'_>,\n+) -> Vec<P<ast::Ty>> {\n     use syntax::visit;\n \n-    struct Visitor<'a, 'b: 'a> {\n+    struct Visitor<'a, 'b> {\n         cx: &'a ExtCtxt<'b>,\n         span: Span,\n         ty_param_names: &'a [ast::Name],"}, {"sha": "90d826429da4db27ea777b0ce4e50ed2a55e3ac6", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -223,7 +223,6 @@ fn mk_generics(params: Vec<ast::GenericParam>, span: Span) -> Generics {\n     Generics {\n         params,\n         where_clause: ast::WhereClause {\n-            id: ast::DUMMY_NODE_ID,\n             predicates: Vec::new(),\n             span,\n         },"}, {"sha": "1fe6094fca6861eeb1f2ba417f99769b2e5ed0ef", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -2,9 +2,10 @@\n \n use rustc_data_structures::sync::Lrc;\n use syntax::ast::{self, MetaItem};\n-use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxExtension, Resolver, MultiItemModifier};\n+use syntax::edition::Edition;\n+use syntax::ext::base::{Annotatable, ExtCtxt, Resolver, MultiItemModifier};\n+use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n use syntax::ext::build::AstBuilder;\n-use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, sym};\n use syntax_pos::Span;\n@@ -67,11 +68,25 @@ macro_rules! derive_traits {\n             }\n         }\n \n-        pub fn register_builtin_derives(resolver: &mut dyn Resolver) {\n+        pub fn register_builtin_derives(resolver: &mut dyn Resolver, edition: Edition) {\n+            let allow_internal_unstable = Some([\n+                sym::core_intrinsics,\n+                sym::rustc_attrs,\n+                Symbol::intern(\"derive_clone_copy\"),\n+                Symbol::intern(\"derive_eq\"),\n+                Symbol::intern(\"libstd_sys_internals\"), // RustcDeserialize and RustcSerialize\n+            ][..].into());\n+\n             $(\n                 resolver.add_builtin(\n                     ast::Ident::with_empty_ctxt(Symbol::intern($name)),\n-                    Lrc::new(SyntaxExtension::LegacyDerive(Box::new(BuiltinDerive($func))))\n+                    Lrc::new(SyntaxExtension {\n+                        allow_internal_unstable: allow_internal_unstable.clone(),\n+                        ..SyntaxExtension::default(\n+                            SyntaxExtensionKind::LegacyDerive(Box::new(BuiltinDerive($func))),\n+                            edition,\n+                        )\n+                    }),\n                 );\n             )*\n         }\n@@ -148,24 +163,11 @@ fn hygienic_type_parameter(item: &Annotatable, base: &str) -> String {\n \n /// Constructs an expression that calls an intrinsic\n fn call_intrinsic(cx: &ExtCtxt<'_>,\n-                  mut span: Span,\n+                  span: Span,\n                   intrinsic: &str,\n                   args: Vec<P<ast::Expr>>)\n                   -> P<ast::Expr> {\n-    let intrinsic_allowed_via_allow_internal_unstable = cx\n-        .current_expansion.mark.expn_info().unwrap()\n-        .allow_internal_unstable.map_or(false, |features| features.iter().any(|&s|\n-            s == sym::core_intrinsics\n-        ));\n-    if intrinsic_allowed_via_allow_internal_unstable {\n-        span = span.with_ctxt(cx.backtrace());\n-    } else { // Avoid instability errors with user defined curstom derives, cc #36316\n-        let mut info = cx.current_expansion.mark.expn_info().unwrap();\n-        info.allow_internal_unstable = Some(vec![sym::core_intrinsics].into());\n-        let mark = Mark::fresh(Mark::root());\n-        mark.set_expn_info(info);\n-        span = span.with_ctxt(SyntaxContext::empty().apply_mark(mark));\n-    }\n+    let span = span.with_ctxt(cx.backtrace());\n     let path = cx.std_path(&[sym::intrinsics, Symbol::intern(intrinsic)]);\n     let call = cx.expr_call_global(span, path, args);\n "}, {"sha": "a5f96559ca8a24aa14a888e9c274ee451d36382b", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -31,7 +31,7 @@ enum Position {\n     Named(Symbol),\n }\n \n-struct Context<'a, 'b: 'a> {\n+struct Context<'a, 'b> {\n     ecx: &'a mut ExtCtxt<'b>,\n     /// The macro's call site. References to unstable formatting internals must\n     /// use this span to pass the stability checker."}, {"sha": "b868f5b273c4e6942671bc09f1276a5af34a4274", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 31, "deletions": 39, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -43,32 +43,31 @@ pub mod proc_macro_impl;\n use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n \n-use syntax::ext::base::{MacroExpanderFn, NamedSyntaxExtension, SyntaxExtension};\n-use syntax::ext::hygiene::Transparency;\n+use syntax::ext::base::MacroExpanderFn;\n+use syntax::ext::base::{NamedSyntaxExtension, SyntaxExtension, SyntaxExtensionKind};\n use syntax::edition::Edition;\n use syntax::symbol::{sym, Symbol};\n \n pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n                          user_exts: Vec<NamedSyntaxExtension>,\n                          edition: Edition) {\n-    deriving::register_builtin_derives(resolver);\n+    deriving::register_builtin_derives(resolver, edition);\n \n     let mut register = |name, ext| {\n         resolver.add_builtin(ast::Ident::with_empty_ctxt(name), Lrc::new(ext));\n     };\n     macro_rules! register {\n         ($( $name:ident: $f:expr, )*) => { $(\n-            register(Symbol::intern(stringify!($name)),\n-                     SyntaxExtension::LegacyBang {\n-                        expander: Box::new($f as MacroExpanderFn),\n-                        def_info: None,\n-                        transparency: Transparency::SemiTransparent,\n-                        allow_internal_unstable: None,\n-                        allow_internal_unsafe: false,\n-                        local_inner_macros: false,\n-                        unstable_feature: None,\n-                        edition,\n-                    });\n+            register(Symbol::intern(stringify!($name)), SyntaxExtension::default(\n+                SyntaxExtensionKind::LegacyBang(Box::new($f as MacroExpanderFn)), edition\n+            ));\n+        )* }\n+    }\n+    macro_rules! register_attr {\n+        ($( $name:ident: $f:expr, )*) => { $(\n+            register(Symbol::intern(stringify!($name)), SyntaxExtension::default(\n+                SyntaxExtensionKind::LegacyAttr(Box::new($f)), edition\n+            ));\n         )* }\n     }\n \n@@ -97,33 +96,26 @@ pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n         assert: assert::expand_assert,\n     }\n \n-    register(sym::test_case, SyntaxExtension::LegacyAttr(Box::new(test_case::expand)));\n-    register(sym::test, SyntaxExtension::LegacyAttr(Box::new(test::expand_test)));\n-    register(sym::bench, SyntaxExtension::LegacyAttr(Box::new(test::expand_bench)));\n+    register_attr! {\n+        test_case: test_case::expand,\n+        test: test::expand_test,\n+        bench: test::expand_bench,\n+    }\n \n     // format_args uses `unstable` things internally.\n-    register(Symbol::intern(\"format_args\"),\n-             SyntaxExtension::LegacyBang {\n-                expander: Box::new(format::expand_format_args),\n-                def_info: None,\n-                transparency: Transparency::SemiTransparent,\n-                allow_internal_unstable: Some(vec![sym::fmt_internals].into()),\n-                allow_internal_unsafe: false,\n-                local_inner_macros: false,\n-                unstable_feature: None,\n-                edition,\n-            });\n-    register(sym::format_args_nl,\n-             SyntaxExtension::LegacyBang {\n-                 expander: Box::new(format::expand_format_args_nl),\n-                 def_info: None,\n-                 transparency: Transparency::SemiTransparent,\n-                 allow_internal_unstable: Some(vec![sym::fmt_internals].into()),\n-                 allow_internal_unsafe: false,\n-                 local_inner_macros: false,\n-                 unstable_feature: None,\n-                 edition,\n-             });\n+    let allow_internal_unstable = Some([sym::fmt_internals][..].into());\n+    register(Symbol::intern(\"format_args\"), SyntaxExtension {\n+        allow_internal_unstable: allow_internal_unstable.clone(),\n+        ..SyntaxExtension::default(\n+            SyntaxExtensionKind::LegacyBang(Box::new(format::expand_format_args)), edition\n+        )\n+    });\n+    register(sym::format_args_nl, SyntaxExtension {\n+        allow_internal_unstable,\n+        ..SyntaxExtension::default(\n+            SyntaxExtensionKind::LegacyBang(Box::new(format::expand_format_args_nl)), edition\n+        )\n+    });\n \n     for (name, ext) in user_exts {\n         register(name, ext);"}, {"sha": "45e65288a24ee6a3b7614f24ef77d961812cb321", "filename": "src/libsyntax_ext/proc_macro_decls.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_decls.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -347,18 +347,10 @@ fn mk_decls(\n     custom_macros: &[ProcMacroDef],\n ) -> P<ast::Item> {\n     let mark = Mark::fresh(Mark::root());\n-    mark.set_expn_info(ExpnInfo {\n-        call_site: DUMMY_SP,\n-        def_site: None,\n-        format: MacroAttribute(sym::proc_macro),\n-        allow_internal_unstable: Some(vec![\n-            sym::rustc_attrs,\n-            Symbol::intern(\"proc_macro_internals\"),\n-        ].into()),\n-        allow_internal_unsafe: false,\n-        local_inner_macros: false,\n-        edition: cx.parse_sess.edition,\n-    });\n+    mark.set_expn_info(ExpnInfo::with_unstable(\n+        MacroAttribute(sym::proc_macro), DUMMY_SP, cx.parse_sess.edition,\n+        &[sym::rustc_attrs, Symbol::intern(\"proc_macro_internals\")],\n+    ));\n     let span = DUMMY_SP.apply_mark(mark);\n \n     let hidden = cx.meta_list_item_word(span, sym::hidden);"}, {"sha": "24d3055e7114087192cb2ccfa784ac31ebe96425", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -8,7 +8,7 @@ use syntax::attr;\n use syntax::ast;\n use syntax::print::pprust;\n use syntax::symbol::{Symbol, sym};\n-use syntax_pos::{DUMMY_SP, Span};\n+use syntax_pos::Span;\n use syntax::source_map::{ExpnInfo, MacroAttribute};\n use std::iter;\n \n@@ -62,15 +62,10 @@ pub fn expand_test_or_bench(\n \n     let (sp, attr_sp) = {\n         let mark = Mark::fresh(Mark::root());\n-        mark.set_expn_info(ExpnInfo {\n-            call_site: DUMMY_SP,\n-            def_site: None,\n-            format: MacroAttribute(sym::test),\n-            allow_internal_unstable: Some(vec![sym::rustc_attrs, sym::test].into()),\n-            allow_internal_unsafe: false,\n-            local_inner_macros: false,\n-            edition: cx.parse_sess.edition,\n-        });\n+        mark.set_expn_info(ExpnInfo::with_unstable(\n+            MacroAttribute(sym::test), attr_sp, cx.parse_sess.edition,\n+            &[sym::rustc_attrs, sym::test],\n+        ));\n         (item.span.with_ctxt(SyntaxContext::empty().apply_mark(mark)),\n          attr_sp.with_ctxt(SyntaxContext::empty().apply_mark(mark)))\n     };"}, {"sha": "6e3bc05b65e4ee38234135437b9da2b4971b9945", "filename": "src/libsyntax_ext/test_case.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax_ext%2Ftest_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax_ext%2Ftest_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_case.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -15,7 +15,7 @@ use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ast;\n use syntax::source_map::respan;\n use syntax::symbol::sym;\n-use syntax_pos::{DUMMY_SP, Span};\n+use syntax_pos::Span;\n use syntax::source_map::{ExpnInfo, MacroAttribute};\n use syntax::feature_gate;\n \n@@ -37,15 +37,10 @@ pub fn expand(\n \n     let sp = {\n         let mark = Mark::fresh(Mark::root());\n-        mark.set_expn_info(ExpnInfo {\n-            call_site: DUMMY_SP,\n-            def_site: None,\n-            format: MacroAttribute(sym::test_case),\n-            allow_internal_unstable: Some(vec![sym::test, sym::rustc_attrs].into()),\n-            allow_internal_unsafe: false,\n-            local_inner_macros: false,\n-            edition: ecx.parse_sess.edition,\n-        });\n+        mark.set_expn_info(ExpnInfo::with_unstable(\n+            MacroAttribute(sym::test_case), attr_sp, ecx.parse_sess.edition,\n+            &[sym::test, sym::rustc_attrs],\n+        ));\n         attr_sp.with_ctxt(SyntaxContext::empty().apply_mark(mark))\n     };\n "}, {"sha": "4dbd4ccda910a6ef99c4ed010cfe0e07525788be", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 44, "deletions": 29, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -59,13 +59,12 @@ pub struct Mark(u32);\n #[derive(Clone, Debug)]\n struct MarkData {\n     parent: Mark,\n-    default_transparency: Transparency,\n     expn_info: Option<ExpnInfo>,\n }\n \n /// A property of a macro expansion that determines how identifiers\n /// produced by that expansion are resolved.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub enum Transparency {\n     /// Identifier produced by a transparent expansion is always resolved at call-site.\n     /// Call-site spans in procedural macros, hygiene opt-out in `macro` should use this.\n@@ -85,12 +84,7 @@ pub enum Transparency {\n impl Mark {\n     pub fn fresh(parent: Mark) -> Self {\n         HygieneData::with(|data| {\n-            data.marks.push(MarkData {\n-                parent,\n-                // By default expansions behave like `macro_rules`.\n-                default_transparency: Transparency::SemiTransparent,\n-                expn_info: None,\n-            });\n+            data.marks.push(MarkData { parent, expn_info: None });\n             Mark(data.marks.len() as u32 - 1)\n         })\n     }\n@@ -118,20 +112,14 @@ impl Mark {\n \n     #[inline]\n     pub fn expn_info(self) -> Option<ExpnInfo> {\n-        HygieneData::with(|data| data.expn_info(self))\n+        HygieneData::with(|data| data.expn_info(self).cloned())\n     }\n \n     #[inline]\n     pub fn set_expn_info(self, info: ExpnInfo) {\n         HygieneData::with(|data| data.marks[self.0 as usize].expn_info = Some(info))\n     }\n \n-    #[inline]\n-    pub fn set_default_transparency(self, transparency: Transparency) {\n-        assert_ne!(self, Mark::root());\n-        HygieneData::with(|data| data.marks[self.0 as usize].default_transparency = transparency)\n-    }\n-\n     pub fn is_descendant_of(self, ancestor: Mark) -> bool {\n         HygieneData::with(|data| data.is_descendant_of(self, ancestor))\n     }\n@@ -172,9 +160,8 @@ impl Mark {\n     #[inline]\n     pub fn looks_like_proc_macro_derive(self) -> bool {\n         HygieneData::with(|data| {\n-            let mark_data = &data.marks[self.0 as usize];\n-            if mark_data.default_transparency == Transparency::Opaque {\n-                if let Some(expn_info) = &mark_data.expn_info {\n+            if data.default_transparency(self) == Transparency::Opaque {\n+                if let Some(expn_info) = &data.marks[self.0 as usize].expn_info {\n                     if let ExpnFormat::MacroAttribute(name) = expn_info.format {\n                         if name.as_str().starts_with(\"derive(\") {\n                             return true;\n@@ -199,9 +186,6 @@ impl HygieneData {\n         HygieneData {\n             marks: vec![MarkData {\n                 parent: Mark::root(),\n-                // If the root is opaque, then loops searching for an opaque mark\n-                // will automatically stop after reaching it.\n-                default_transparency: Transparency::Opaque,\n                 expn_info: None,\n             }],\n             syntax_contexts: vec![SyntaxContextData {\n@@ -220,8 +204,8 @@ impl HygieneData {\n         GLOBALS.with(|globals| f(&mut *globals.hygiene_data.borrow_mut()))\n     }\n \n-    fn expn_info(&self, mark: Mark) -> Option<ExpnInfo> {\n-        self.marks[mark.0 as usize].expn_info.clone()\n+    fn expn_info(&self, mark: Mark) -> Option<&ExpnInfo> {\n+        self.marks[mark.0 as usize].expn_info.as_ref()\n     }\n \n     fn is_descendant_of(&self, mut mark: Mark, ancestor: Mark) -> bool {\n@@ -235,7 +219,9 @@ impl HygieneData {\n     }\n \n     fn default_transparency(&self, mark: Mark) -> Transparency {\n-        self.marks[mark.0 as usize].default_transparency\n+        self.marks[mark.0 as usize].expn_info.as_ref().map_or(\n+            Transparency::SemiTransparent, |einfo| einfo.default_transparency\n+        )\n     }\n \n     fn modern(&self, ctxt: SyntaxContext) -> SyntaxContext {\n@@ -427,7 +413,6 @@ impl SyntaxContext {\n         HygieneData::with(|data| {\n             data.marks.push(MarkData {\n                 parent: Mark::root(),\n-                default_transparency: Transparency::SemiTransparent,\n                 expn_info: Some(expansion_info),\n             });\n \n@@ -613,7 +598,7 @@ impl SyntaxContext {\n     /// `ctxt.outer().expn_info()`.\n     #[inline]\n     pub fn outer_expn_info(self) -> Option<ExpnInfo> {\n-        HygieneData::with(|data| data.expn_info(data.outer(self)))\n+        HygieneData::with(|data| data.expn_info(data.outer(self)).cloned())\n     }\n \n     /// `ctxt.outer_and_expn_info()` is equivalent to but faster than\n@@ -622,7 +607,7 @@ impl SyntaxContext {\n     pub fn outer_and_expn_info(self) -> (Mark, Option<ExpnInfo>) {\n         HygieneData::with(|data| {\n             let outer = data.outer(self);\n-            (outer, data.expn_info(outer))\n+            (outer, data.expn_info(outer).cloned())\n         })\n     }\n \n@@ -651,6 +636,7 @@ impl fmt::Debug for SyntaxContext {\n /// Extra information for tracking spans of macro and syntax sugar expansion\n #[derive(Clone, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct ExpnInfo {\n+    // --- The part unique to each expansion.\n     /// The location of the actual macro invocation or syntax sugar , e.g.\n     /// `let x = foo!();` or `if let Some(y) = x {}`\n     ///\n@@ -661,13 +647,18 @@ pub struct ExpnInfo {\n     /// call_site span would have its own ExpnInfo, with the call_site\n     /// pointing to the `foo!` invocation.\n     pub call_site: Span,\n+    /// The format with which the macro was invoked.\n+    pub format: ExpnFormat,\n+\n+    // --- The part specific to the macro/desugaring definition.\n+    // --- FIXME: Share it between expansions with the same definition.\n     /// The span of the macro definition itself. The macro may not\n     /// have a sensible definition span (e.g., something defined\n     /// completely inside libsyntax) in which case this is None.\n     /// This span serves only informational purpose and is not used for resolution.\n     pub def_site: Option<Span>,\n-    /// The format with which the macro was invoked.\n-    pub format: ExpnFormat,\n+    /// Transparency used by `apply_mark` for mark with this expansion info by default.\n+    pub default_transparency: Transparency,\n     /// List of #[unstable]/feature-gated features that the macro is allowed to use\n     /// internally without forcing the whole crate to opt-in\n     /// to them.\n@@ -682,6 +673,30 @@ pub struct ExpnInfo {\n     pub edition: Edition,\n }\n \n+impl ExpnInfo {\n+    /// Constructs an expansion info with default properties.\n+    pub fn default(format: ExpnFormat, call_site: Span, edition: Edition) -> ExpnInfo {\n+        ExpnInfo {\n+            call_site,\n+            format,\n+            def_site: None,\n+            default_transparency: Transparency::SemiTransparent,\n+            allow_internal_unstable: None,\n+            allow_internal_unsafe: false,\n+            local_inner_macros: false,\n+            edition,\n+        }\n+    }\n+\n+    pub fn with_unstable(format: ExpnFormat, call_site: Span, edition: Edition,\n+                         allow_internal_unstable: &[Symbol]) -> ExpnInfo {\n+        ExpnInfo {\n+            allow_internal_unstable: Some(allow_internal_unstable.into()),\n+            ..ExpnInfo::default(format, call_site, edition)\n+        }\n+    }\n+}\n+\n /// The source of expansion.\n #[derive(Clone, Hash, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum ExpnFormat {"}, {"sha": "2dd409bf5bee09b86a734bd60b881b7dcbd72993", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -859,6 +859,9 @@ impl ExternalSource {\n     }\n }\n \n+#[derive(Debug)]\n+pub struct OffsetOverflowError;\n+\n /// A single source in the `SourceMap`.\n #[derive(Clone)]\n pub struct SourceFile {\n@@ -1040,7 +1043,7 @@ impl SourceFile {\n                name_was_remapped: bool,\n                unmapped_path: FileName,\n                mut src: String,\n-               start_pos: BytePos) -> SourceFile {\n+               start_pos: BytePos) -> Result<SourceFile, OffsetOverflowError> {\n         remove_bom(&mut src);\n \n         let src_hash = {\n@@ -1054,11 +1057,14 @@ impl SourceFile {\n             hasher.finish()\n         };\n         let end_pos = start_pos.to_usize() + src.len();\n+        if end_pos > u32::max_value() as usize {\n+            return Err(OffsetOverflowError);\n+        }\n \n         let (lines, multibyte_chars, non_narrow_chars) =\n             analyze_source_file::analyze_source_file(&src[..], start_pos);\n \n-        SourceFile {\n+        Ok(SourceFile {\n             name,\n             name_was_remapped,\n             unmapped_path: Some(unmapped_path),\n@@ -1072,7 +1078,7 @@ impl SourceFile {\n             multibyte_chars,\n             non_narrow_chars,\n             name_hash,\n-        }\n+        })\n     }\n \n     /// Returns the `BytePos` of the beginning of the current line."}, {"sha": "7f2afd9c5715c2b0d44cda7595ed86723a60620c", "filename": "src/test/auxiliary/rust_test_helpers.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Ftest%2Fauxiliary%2Frust_test_helpers.c", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Ftest%2Fauxiliary%2Frust_test_helpers.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Frust_test_helpers.c?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -216,20 +216,27 @@ uint64_t get_c_many_params(void *a, void *b, void *c, void *d, struct quad f) {\n }\n \n // Calculates the average of `(x + y) / n` where x: i64, y: f64. There must be exactly n pairs\n-// passed as variadic arguments.\n-double rust_interesting_average(uint64_t n, ...) {\n-    va_list pairs;\n+// passed as variadic arguments. There are two versions of this function: the\n+// variadic one, and the one that takes a `va_list`.\n+double rust_valist_interesting_average(uint64_t n, va_list pairs) {\n     double sum = 0.0;\n     int i;\n-    va_start(pairs, n);\n     for(i = 0; i < n; i += 1) {\n         sum += (double)va_arg(pairs, int64_t);\n         sum += va_arg(pairs, double);\n     }\n-    va_end(pairs);\n     return sum / n;\n }\n \n+double rust_interesting_average(uint64_t n, ...) {\n+    double sum;\n+    va_list pairs;\n+    va_start(pairs, n);\n+    sum = rust_valist_interesting_average(n, pairs);\n+    va_end(pairs);\n+    return sum;\n+}\n+\n int32_t rust_int8_to_int32(int8_t x) {\n     return (int32_t)x;\n }"}, {"sha": "4c61c4fcf68d3289d8bc3a4a4eda52256ed43cfb", "filename": "src/test/codegen/c-variadic-copy.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Ftest%2Fcodegen%2Fc-variadic-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Ftest%2Fcodegen%2Fc-variadic-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fc-variadic-copy.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -0,0 +1,16 @@\n+// Tests that `VaListImpl::clone` gets inlined into a call to `llvm.va_copy`\n+\n+#![crate_type = \"lib\"]\n+#![feature(c_variadic)]\n+#![no_std]\n+use core::ffi::VaList;\n+\n+extern \"C\" {\n+    fn foreign_c_variadic_1(_: VaList, ...);\n+}\n+\n+pub unsafe extern \"C\" fn clone_variadic(ap: VaList) {\n+    let mut ap2 = ap.clone();\n+    // CHECK: call void @llvm.va_copy\n+    foreign_c_variadic_1(ap2.as_va_list(), 42i32);\n+}"}, {"sha": "969dce80f587153ccbda12de9f3fc27a7f528fb3", "filename": "src/test/codegen/c-variadic-opt.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Ftest%2Fcodegen%2Fc-variadic-opt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Ftest%2Fcodegen%2Fc-variadic-opt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fc-variadic-opt.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -10,10 +10,21 @@ extern \"C\" {\n }\n \n // Ensure that `va_start` and `va_end` are properly injected even\n-// when the \"spoofed\" `VaList` is not used.\n+// when the \"spoofed\" `VaListImpl` is not used.\n #[no_mangle]\n pub unsafe extern \"C\" fn c_variadic_no_use(fmt: *const i8, mut ap: ...) -> i32 {\n     // CHECK: call void @llvm.va_start\n-    vprintf(fmt, ap)\n+    vprintf(fmt, ap.as_va_list())\n+    // CHECK: call void @llvm.va_end\n+}\n+\n+// Check that `VaListImpl::clone` gets inlined into a direct call to `llvm.va_copy`\n+#[no_mangle]\n+pub unsafe extern \"C\" fn c_variadic_clone(fmt: *const i8, mut ap: ...) -> i32 {\n+    // CHECK: call void @llvm.va_start\n+    let mut ap2 = ap.clone();\n+    // CHECK: call void @llvm.va_copy\n+    let res = vprintf(fmt, ap2.as_va_list());\n+    res\n     // CHECK: call void @llvm.va_end\n }"}, {"sha": "13be5ced27fa9435d4e942563a2eac83ed238148", "filename": "src/test/codegen/c-variadic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Ftest%2Fcodegen%2Fc-variadic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Ftest%2Fcodegen%2Fc-variadic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fc-variadic.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -23,7 +23,7 @@ pub unsafe extern \"C\" fn use_foreign_c_variadic_0() {\n }\n \n // Ensure that we do not remove the `va_list` passed to the foreign function when\n-// removing the \"spoofed\" `VaList` that is used by Rust defined C-variadics.\n+// removing the \"spoofed\" `VaListImpl` that is used by Rust defined C-variadics.\n pub unsafe extern \"C\" fn use_foreign_c_variadic_1_0(ap: VaList) {\n     // CHECK: invoke void ({{.*}}*, ...) @foreign_c_variadic_1({{.*}} %ap)\n     foreign_c_variadic_1(ap);"}, {"sha": "a5516833900a8c8ef74da65fc9a42753b988f0a0", "filename": "src/test/codegen/slice-iter-len-eq-zero.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Ftest%2Fcodegen%2Fslice-iter-len-eq-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Ftest%2Fcodegen%2Fslice-iter-len-eq-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fslice-iter-len-eq-zero.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -0,0 +1,14 @@\n+// no-system-llvm\n+// compile-flags: -O\n+#![crate_type = \"lib\"]\n+\n+type Demo = [u8; 3];\n+\n+// CHECK-LABEL: @slice_iter_len_eq_zero\n+#[no_mangle]\n+pub fn slice_iter_len_eq_zero(y: std::slice::Iter<'_, Demo>) -> bool {\n+    // CHECK-NOT: sub\n+    // CHECK: %2 = icmp eq i8* %1, %0\n+    // CHECK: ret i1 %2\n+    y.len() == 0\n+}"}, {"sha": "dae27c4785f15b6fd024476ebbe0221647d72f4b", "filename": "src/test/compile-fail/issue-43733-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Ftest%2Fcompile-fail%2Fissue-43733-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e152c38f65ae1aa69630b0b82e571e52b05e3302/src%2Ftest%2Fcompile-fail%2Fissue-43733-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-43733-2.rs?ref=e152c38f65ae1aa69630b0b82e571e52b05e3302", "patch": "@@ -5,15 +5,15 @@\n #[cfg(not(target_thread_local))]\n struct Key<T> {\n     _data: std::cell::UnsafeCell<Option<T>>,\n-    _flag: std::cell::Cell<bool>,\n+    _flag: std::cell::Cell<()>,\n }\n \n #[cfg(not(target_thread_local))]\n impl<T> Key<T> {\n     const fn new() -> Self {\n         Key {\n             _data: std::cell::UnsafeCell::new(None),\n-            _flag: std::cell::Cell::new(false),\n+            _flag: std::cell::Cell::new(()),\n         }\n     }\n }\n@@ -23,6 +23,6 @@ use std::thread::__FastLocalKeyInner as Key;\n \n static __KEY: Key<()> = Key::new();\n //~^ ERROR `std::cell::UnsafeCell<std::option::Option<()>>` cannot be shared between threads\n-//~| ERROR `std::cell::Cell<bool>` cannot be shared between threads safely [E0277]\n+//~| ERROR cannot be shared between threads safely [E0277]\n \n fn main() {}"}]}