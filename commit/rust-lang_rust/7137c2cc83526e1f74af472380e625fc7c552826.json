{"sha": "7137c2cc83526e1f74af472380e625fc7c552826", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxMzdjMmNjODM1MjZlMWY3NGFmNDcyMzgwZTYyNWZjN2M1NTI4MjY=", "commit": {"author": {"name": "Jakub Bukaj", "email": "jakub@jakub.cc", "date": "2014-11-17T23:23:53Z"}, "committer": {"name": "Jakub Bukaj", "email": "jakub@jakub.cc", "date": "2014-11-17T23:23:53Z"}, "message": "rollup merge of #18910: aturon/borrow-traits\n\nFollowing [the collections reform RFC](https://github.com/rust-lang/rfcs/pull/235), this PR:\n\n* Adds a new `borrow` module to libcore. The module contains traits for borrowing data (`BorrowFrom` and `BorrowFromMut`), generalized cloning (`ToOwned`), and a clone-on-write smartpointer (`Cow`).\n\n* Deprecates the `_equiv` family of methods on `HashMap` and `HashSet` by instead generalizing the \"normal\" methods like `get` and `remove` to use the new `std::borrow` infrastructure.\n\n* Generalizes `TreeMap`, `TreeSet`, `BTreeMap` and `BTreeSet` to use the new `std::borrow` infrastructure for lookups.\n\n[breaking-change]", "tree": {"sha": "cc7b9988bd93f775a5caa1be85c4bbf4eeb60662", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc7b9988bd93f775a5caa1be85c4bbf4eeb60662"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7137c2cc83526e1f74af472380e625fc7c552826", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7137c2cc83526e1f74af472380e625fc7c552826", "html_url": "https://github.com/rust-lang/rust/commit/7137c2cc83526e1f74af472380e625fc7c552826", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7137c2cc83526e1f74af472380e625fc7c552826/comments", "author": null, "committer": null, "parents": [{"sha": "fcf9fb61574a415653fa0c787058972312ce1235", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcf9fb61574a415653fa0c787058972312ce1235", "html_url": "https://github.com/rust-lang/rust/commit/fcf9fb61574a415653fa0c787058972312ce1235"}, {"sha": "46be8eb47ccd261ecb00ba25e0c24f28c8af75d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/46be8eb47ccd261ecb00ba25e0c24f28c8af75d7", "html_url": "https://github.com/rust-lang/rust/commit/46be8eb47ccd261ecb00ba25e0c24f28c8af75d7"}], "stats": {"total": 599, "additions": 385, "deletions": 214}, "files": [{"sha": "159a62f01107206b1a4f0e92be71fae111a37c92", "filename": "src/grammar/verify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7137c2cc83526e1f74af472380e625fc7c552826/src%2Fgrammar%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7137c2cc83526e1f74af472380e625fc7c552826/src%2Fgrammar%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fverify.rs?ref=7137c2cc83526e1f74af472380e625fc7c552826", "patch": "@@ -178,7 +178,7 @@ fn parse_antlr_token(s: &str, tokens: &HashMap<String, Token>) -> TokenAndSpan {\n     let toknum = m.name(\"toknum\");\n     let content = m.name(\"content\");\n \n-    let proto_tok = tokens.find_equiv(&toknum).expect(format!(\"didn't find token {} in the map\",\n+    let proto_tok = tokens.get(&toknum).expect(format!(\"didn't find token {} in the map\",\n                                                               toknum).as_slice());\n \n     let nm = parse::token::intern(content);"}, {"sha": "007e01ef9820c7bbb3f55afaec9d2e20f313f7a6", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=7137c2cc83526e1f74af472380e625fc7c552826", "patch": "@@ -21,6 +21,7 @@ use core::prelude::*;\n \n use self::StackOp::*;\n use super::node::*;\n+use core::borrow::BorrowFrom;\n use std::hash::{Writer, Hash};\n use core::default::Default;\n use core::{iter, fmt, mem};\n@@ -184,6 +185,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n     /// Returns a reference to the value corresponding to the key.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but the ordering\n+    /// on the borrowed form *must* match the ordering on the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -195,7 +199,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn get(&self, key: &K) -> Option<&V> {\n+    pub fn get<Sized? Q>(&self, key: &Q) -> Option<&V> where Q: BorrowFrom<K> + Ord {\n         let mut cur_node = &self.root;\n         loop {\n             match cur_node.search(key) {\n@@ -213,6 +217,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n     /// Returns true if the map contains a value for the specified key.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but the ordering\n+    /// on the borrowed form *must* match the ordering on the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -224,7 +231,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn contains_key(&self, key: &K) -> bool {\n+    pub fn contains_key<Sized? Q>(&self, key: &Q) -> bool where Q: BorrowFrom<K> + Ord {\n         self.get(key).is_some()\n     }\n \n@@ -236,6 +243,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n     /// Returns a mutable reference to the value corresponding to the key.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but the ordering\n+    /// on the borrowed form *must* match the ordering on the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -251,7 +261,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     // See `get` for implementation notes, this is basically a copy-paste with mut's added\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn get_mut(&mut self, key: &K) -> Option<&mut V> {\n+    pub fn get_mut<Sized? Q>(&mut self, key: &Q) -> Option<&mut V> where Q: BorrowFrom<K> + Ord {\n         // temp_node is a Borrowck hack for having a mutable value outlive a loop iteration\n         let mut temp_node = &mut self.root;\n         loop {\n@@ -410,6 +420,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// Removes a key from the map, returning the value at the key if the key\n     /// was previously in the map.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but the ordering\n+    /// on the borrowed form *must* match the ordering on the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -421,7 +434,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn remove(&mut self, key: &K) -> Option<V> {\n+    pub fn remove<Sized? Q>(&mut self, key: &Q) -> Option<V> where Q: BorrowFrom<K> + Ord {\n         // See `swap` for a more thorough description of the stuff going on in here\n         let mut stack = stack::PartialSearchStack::new(self);\n         loop {\n@@ -790,14 +803,18 @@ impl<K: Show, V: Show> Show for BTreeMap<K, V> {\n     }\n }\n \n-impl<K: Ord, V> Index<K, V> for BTreeMap<K, V> {\n-    fn index(&self, key: &K) -> &V {\n+impl<K: Ord, Sized? Q, V> Index<Q, V> for BTreeMap<K, V>\n+    where Q: BorrowFrom<K> + Ord\n+{\n+    fn index(&self, key: &Q) -> &V {\n         self.get(key).expect(\"no entry found for key\")\n     }\n }\n \n-impl<K: Ord, V> IndexMut<K, V> for BTreeMap<K, V> {\n-    fn index_mut(&mut self, key: &K) -> &mut V {\n+impl<K: Ord, Sized? Q, V> IndexMut<Q, V> for BTreeMap<K, V>\n+    where Q: BorrowFrom<K> + Ord\n+{\n+    fn index_mut(&mut self, key: &Q) -> &mut V {\n         self.get_mut(key).expect(\"no entry found for key\")\n     }\n }"}, {"sha": "bdd7aa9c61172361852907030425d7daf5f247b1", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=7137c2cc83526e1f74af472380e625fc7c552826", "patch": "@@ -19,6 +19,7 @@ use core::prelude::*;\n \n use core::{slice, mem, ptr};\n use core::iter::Zip;\n+use core::borrow::BorrowFrom;\n \n use vec;\n use vec::Vec;\n@@ -73,19 +74,19 @@ impl<K: Ord, V> Node<K, V> {\n     /// Searches for the given key in the node. If it finds an exact match,\n     /// `Found` will be yielded with the matching index. If it doesn't find an exact match,\n     /// `GoDown` will be yielded with the index of the subtree the key must lie in.\n-    pub fn search(&self, key: &K) -> SearchResult {\n+    pub fn search<Sized? Q>(&self, key: &Q) -> SearchResult where Q: BorrowFrom<K> + Ord {\n         // FIXME(Gankro): Tune when to search linear or binary based on B (and maybe K/V).\n         // For the B configured as of this writing (B = 6), binary search was *significantly*\n         // worse for uints.\n         self.search_linear(key)\n     }\n \n-    fn search_linear(&self, key: &K) -> SearchResult {\n+    fn search_linear<Sized? Q>(&self, key: &Q) -> SearchResult where Q: BorrowFrom<K> + Ord {\n         for (i, k) in self.keys.iter().enumerate() {\n-            match k.cmp(key) {\n-                Less => {},\n+            match key.cmp(BorrowFrom::borrow_from(k)) {\n+                Greater => {},\n                 Equal => return Found(i),\n-                Greater => return GoDown(i),\n+                Less => return GoDown(i),\n             }\n         }\n         GoDown(self.len())"}, {"sha": "64ae4f6a508677828aacbdf71b9f83125ca740b0", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=7137c2cc83526e1f74af472380e625fc7c552826", "patch": "@@ -15,6 +15,7 @@ use core::prelude::*;\n \n use btree_map::{BTreeMap, Keys, MoveEntries};\n use std::hash::Hash;\n+use core::borrow::BorrowFrom;\n use core::default::Default;\n use core::{iter, fmt};\n use core::iter::Peekable;\n@@ -167,6 +168,10 @@ impl<T: Ord> BTreeSet<T> {\n \n     /// Returns `true` if the set contains a value.\n     ///\n+    /// The value may be any borrowed form of the set's value type,\n+    /// but the ordering on the borrowed form *must* match the\n+    /// ordering on the value type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -177,7 +182,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn contains(&self, value: &T) -> bool {\n+    pub fn contains<Sized? Q>(&self, value: &Q) -> bool where Q: BorrowFrom<T> + Ord {\n         self.map.contains_key(value)\n     }\n \n@@ -291,6 +296,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// Removes a value from the set. Returns `true` if the value was\n     /// present in the set.\n     ///\n+    /// The value may be any borrowed form of the set's value type,\n+    /// but the ordering on the borrowed form *must* match the\n+    /// ordering on the value type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -303,7 +312,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn remove(&mut self, value: &T) -> bool {\n+    pub fn remove<Sized? Q>(&mut self, value: &Q) -> bool where Q: BorrowFrom<T> + Ord {\n         self.map.remove(value).is_some()\n     }\n }"}, {"sha": "132a07af6b67b5d758095e5edf36866387277525", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=7137c2cc83526e1f74af472380e625fc7c552826", "patch": "@@ -89,6 +89,7 @@\n \n use self::Direction::*;\n use alloc::boxed::Box;\n+use core::borrow::{BorrowFrom, BorrowFromMut};\n use core::cmp;\n use core::kinds::Sized;\n use core::mem::size_of;\n@@ -647,6 +648,16 @@ impl<T> SliceAllocPrelude<T> for [T] {\n     }\n }\n \n+#[unstable = \"trait is unstable\"]\n+impl<T> BorrowFrom<Vec<T>> for [T] {\n+    fn borrow_from(owned: &Vec<T>) -> &[T] { owned[] }\n+}\n+\n+#[unstable = \"trait is unstable\"]\n+impl<T> BorrowFromMut<Vec<T>> for [T] {\n+    fn borrow_from_mut(owned: &mut Vec<T>) -> &mut [T] { owned[mut] }\n+}\n+\n /// Unsafe operations\n pub mod raw {\n     pub use core::slice::raw::{buf_as_slice, mut_buf_as_slice};"}, {"sha": "9ae009d8f6a59a198a91ee81248f442050ef4fee", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=7137c2cc83526e1f74af472380e625fc7c552826", "patch": "@@ -54,7 +54,7 @@\n pub use self::MaybeOwned::*;\n use self::RecompositionState::*;\n use self::DecompositionType::*;\n-\n+use core::borrow::BorrowFrom;\n use core::default::Default;\n use core::fmt;\n use core::cmp;\n@@ -604,6 +604,11 @@ impl<'a> fmt::Show for MaybeOwned<'a> {\n     }\n }\n \n+#[unstable = \"trait is unstable\"]\n+impl BorrowFrom<String> for str {\n+    fn borrow_from(owned: &String) -> &str { owned[] }\n+}\n+\n /// Unsafe string operations.\n pub mod raw {\n     pub use core::str::raw::{from_utf8, c_str_to_static_slice, slice_bytes};"}, {"sha": "119268c27eeac9814637396c4481a2af7240c269", "filename": "src/libcollections/tree/map.rs", "status": "modified", "additions": 39, "deletions": 15, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibcollections%2Ftree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibcollections%2Ftree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftree%2Fmap.rs?ref=7137c2cc83526e1f74af472380e625fc7c552826", "patch": "@@ -11,6 +11,8 @@\n use core::prelude::*;\n \n use alloc::boxed::Box;\n+\n+use core::borrow::BorrowFrom;\n use core::default::Default;\n use core::fmt;\n use core::fmt::Show;\n@@ -188,16 +190,16 @@ impl<K: Ord, V> Default for TreeMap<K,V> {\n     fn default() -> TreeMap<K, V> { TreeMap::new() }\n }\n \n-impl<K: Ord, V> Index<K, V> for TreeMap<K, V> {\n+impl<K: Ord, Sized? Q, V> Index<Q, V> for TreeMap<K, V> where Q: BorrowFrom<K> + Ord {\n     #[inline]\n-    fn index<'a>(&'a self, i: &K) -> &'a V {\n+    fn index<'a>(&'a self, i: &Q) -> &'a V {\n         self.get(i).expect(\"no entry found for key\")\n     }\n }\n \n-impl<K: Ord, V> IndexMut<K, V> for TreeMap<K, V> {\n+impl<K: Ord, Sized? Q, V> IndexMut<Q, V> for TreeMap<K, V> where Q: BorrowFrom<K> + Ord {\n     #[inline]\n-    fn index_mut<'a>(&'a mut self, i: &K) -> &'a mut V {\n+    fn index_mut<'a>(&'a mut self, i: &Q) -> &'a mut V {\n         self.get_mut(i).expect(\"no entry found for key\")\n     }\n }\n@@ -446,6 +448,9 @@ impl<K: Ord, V> TreeMap<K, V> {\n \n     /// Returns a reference to the value corresponding to the key.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but the ordering\n+    /// on the borrowed form *must* match the ordering on the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -458,12 +463,17 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// ```\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn get(&self, key: &K) -> Option<&V> {\n-        tree_find_with(&self.root, |k2| key.cmp(k2))\n+    pub fn get<Sized? Q>(&self, key: &Q) -> Option<&V>\n+        where Q: BorrowFrom<K> + Ord\n+    {\n+        tree_find_with(&self.root, |k2| key.cmp(BorrowFrom::borrow_from(k2)))\n     }\n \n     /// Returns true if the map contains a value for the specified key.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but the ordering\n+    /// on the borrowed form *must* match the ordering on the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -476,7 +486,9 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// ```\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn contains_key(&self, key: &K) -> bool {\n+    pub fn contains_key<Sized? Q>(&self, key: &Q) -> bool\n+        where Q: BorrowFrom<K> + Ord\n+    {\n         self.get(key).is_some()\n     }\n \n@@ -488,6 +500,9 @@ impl<K: Ord, V> TreeMap<K, V> {\n \n     /// Returns a mutable reference to the value corresponding to the key.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but the ordering\n+    /// on the borrowed form *must* match the ordering on the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -503,8 +518,10 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// ```\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn get_mut(&mut self, key: &K) -> Option<&mut V> {\n-        tree_find_with_mut(&mut self.root, |x| key.cmp(x))\n+    pub fn get_mut<Sized? Q>(&mut self, key: &Q) -> Option<&mut V>\n+        where Q: BorrowFrom<K> + Ord\n+    {\n+        tree_find_with_mut(&mut self.root, |x| key.cmp(BorrowFrom::borrow_from(x)))\n     }\n \n     /// Deprecated: Renamed to `insert`.\n@@ -545,6 +562,9 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// Removes a key from the map, returning the value at the key if the key\n     /// was previously in the map.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but the ordering\n+    /// on the borrowed form *must* match the ordering on the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -556,7 +576,9 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn remove(&mut self, key: &K) -> Option<V> {\n+    pub fn remove<Sized? Q>(&mut self, key: &Q) -> Option<V>\n+        where Q: BorrowFrom<K> + Ord\n+    {\n         let ret = remove(&mut self.root, key);\n         if ret.is_some() { self.length -= 1 }\n         ret\n@@ -589,6 +611,7 @@ impl<K, V> TreeMap<K, V> {\n     /// assert_eq!((*ua.unwrap()).as_slice(), \"Curl-Rust/0.1\");\n     /// ```\n     #[inline]\n+    #[experimental = \"likely to be renamed, may be removed\"]\n     pub fn find_with(&self, f:|&K| -> Ordering) -> Option<&V> {\n         tree_find_with(&self.root, f)\n     }\n@@ -613,6 +636,7 @@ impl<K, V> TreeMap<K, V> {\n     /// assert_eq!(t.get(&\"User-Agent\"), Some(&new_ua));\n     /// ```\n     #[inline]\n+    #[experimental = \"likely to be renamed, may be removed\"]\n     pub fn find_with_mut<'a>(&'a mut self, f:|&K| -> Ordering) -> Option<&'a mut V> {\n         tree_find_with_mut(&mut self.root, f)\n     }\n@@ -1168,10 +1192,11 @@ fn insert<K: Ord, V>(node: &mut Option<Box<TreeNode<K, V>>>,\n     }\n }\n \n-fn remove<K: Ord, V>(node: &mut Option<Box<TreeNode<K, V>>>,\n-                          key: &K) -> Option<V> {\n+fn remove<K, Sized? Q, V>(node: &mut Option<Box<TreeNode<K, V>>>, key: &Q) -> Option<V>\n+    where K: Ord, Q: BorrowFrom<K> + Ord\n+{\n     fn heir_swap<K: Ord, V>(node: &mut Box<TreeNode<K, V>>,\n-                                 child: &mut Option<Box<TreeNode<K, V>>>) {\n+                            child: &mut Option<Box<TreeNode<K, V>>>) {\n         // *could* be done without recursion, but it won't borrow check\n         for x in child.iter_mut() {\n             if x.right.is_some() {\n@@ -1188,7 +1213,7 @@ fn remove<K: Ord, V>(node: &mut Option<Box<TreeNode<K, V>>>,\n         return None; // bottom of tree\n       }\n       Some(ref mut save) => {\n-        let (ret, rebalance) = match key.cmp(&save.key) {\n+        let (ret, rebalance) = match key.cmp(BorrowFrom::borrow_from(&save.key)) {\n           Less => (remove(&mut save.left, key), true),\n           Greater => (remove(&mut save.right, key), true),\n           Equal => {\n@@ -1918,4 +1943,3 @@ mod bench {\n         bench_iter(b, 100000);\n     }\n }\n-"}, {"sha": "20823a2affc7f5d73fd887a23bf81b9b932089d2", "filename": "src/libcollections/tree/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibcollections%2Ftree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibcollections%2Ftree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftree%2Fmod.rs?ref=7137c2cc83526e1f74af472380e625fc7c552826", "patch": "@@ -33,4 +33,4 @@\n //! ```\n \n pub mod map;\n-pub mod set;\n\\ No newline at end of file\n+pub mod set;"}, {"sha": "6988b929df689ef3b1d259ab5c7fe22bda90f574", "filename": "src/libcollections/tree/set.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibcollections%2Ftree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibcollections%2Ftree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftree%2Fset.rs?ref=7137c2cc83526e1f74af472380e625fc7c552826", "patch": "@@ -10,6 +10,7 @@\n \n use core::prelude::*;\n \n+use core::borrow::BorrowFrom;\n use core::default::Default;\n use core::fmt;\n use core::fmt::Show;\n@@ -396,6 +397,10 @@ impl<T: Ord> TreeSet<T> {\n \n     /// Returns `true` if the set contains a value.\n     ///\n+    /// The value may be any borrowed form of the set's value type,\n+    /// but the ordering on the borrowed form *must* match the\n+    /// ordering on the value type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -407,7 +412,9 @@ impl<T: Ord> TreeSet<T> {\n     /// ```\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn contains(&self, value: &T) -> bool {\n+    pub fn contains<Sized? Q>(&self, value: &Q) -> bool\n+        where Q: Ord + BorrowFrom<T>\n+    {\n         self.map.contains_key(value)\n     }\n \n@@ -519,6 +526,10 @@ impl<T: Ord> TreeSet<T> {\n     /// Removes a value from the set. Returns `true` if the value was\n     /// present in the set.\n     ///\n+    /// The value may be any borrowed form of the set's value type,\n+    /// but the ordering on the borrowed form *must* match the\n+    /// ordering on the value type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -532,7 +543,11 @@ impl<T: Ord> TreeSet<T> {\n     /// ```\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn remove(&mut self, value: &T) -> bool { self.map.remove(value).is_some() }\n+    pub fn remove<Sized? Q>(&mut self, value: &Q) -> bool\n+        where Q: Ord + BorrowFrom<T>\n+    {\n+        self.map.remove(value).is_some()\n+    }\n }\n \n /// A lazy forward iterator over a set."}, {"sha": "9dcb182cd267570b259926cb1993bfbdc0f27527", "filename": "src/libcollections/trie/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibcollections%2Ftrie%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibcollections%2Ftrie%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie%2Fmod.rs?ref=7137c2cc83526e1f74af472380e625fc7c552826", "patch": "@@ -17,4 +17,4 @@\n //! `TrieMap` is ordered.\n \n pub mod map;\n-pub mod set;\n\\ No newline at end of file\n+pub mod set;"}, {"sha": "34cf55334aef3d3aeae34ea4a092115e3096390c", "filename": "src/libcore/borrow.rs", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=7137c2cc83526e1f74af472380e625fc7c552826", "patch": "@@ -0,0 +1,126 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A module for working with borrowed data.\n+//!\n+//! # The `BorrowFrom` traits\n+//!\n+//! In general, there may be several ways to \"borrow\" a piece of data.  The\n+//! typical ways of borrowing a type `T` are `&T` (a shared borrow) and `&mut T`\n+//! (a mutable borrow). But types like `Vec<T>` provide additional kinds of\n+//! borrows: the borrowed slices `&[T]` and `&mut [T]`.\n+//!\n+//! When writing generic code, it is often desirable to abstract over all ways\n+//! of borrowing data from a given type. That is the role of the `BorrowFrom`\n+//! trait: if `T: BorrowFrom<U>`, then `&T` can be borrowed from `&U`.  A given\n+//! type can be borrowed as multiple different types. In particular, `Vec<T>:\n+//! BorrowFrom<Vec<T>>` and `[T]: BorrowFrom<Vec<T>>`.\n+//!\n+//! # The `ToOwned` trait\n+//!\n+//! Some types make it possible to go from borrowed to owned, usually by\n+//! implementing the `Clone` trait. But `Clone` works only for going from `&T`\n+//! to `T`. The `ToOwned` trait generalizes `Clone` to construct owned data\n+//! from any borrow of a given type.\n+//!\n+//! # The `Cow` (clone-on-write) type\n+//!\n+//! The type `Cow` is a smart pointer providing clone-on-write functionality: it\n+//! can enclose and provide immutable access to borrowed data, and clone the\n+//! data lazily when mutation or ownership is required. The type is designed to\n+//! work with general borrowed data via the `BorrowFrom` trait.\n+//!\n+//! `Cow` implements both `Deref` and `DerefMut`, which means that you can call\n+//! methods directly on the data it encloses. The first time a mutable reference\n+//! is required, the data will be cloned (via `to_owned`) if it is not\n+//! already owned.\n+\n+#![unstable = \"recently added as part of collections reform\"]\n+\n+use clone::Clone;\n+use kinds::Sized;\n+use ops::Deref;\n+\n+/// A trait for borrowing data.\n+pub trait BorrowFrom<Sized? Owned> for Sized? {\n+    /// Immutably borrow from an owned value.\n+    fn borrow_from(owned: &Owned) -> &Self;\n+}\n+\n+/// A trait for mutably borrowing data.\n+pub trait BorrowFromMut<Sized? Owned> for Sized? : BorrowFrom<Owned> {\n+    /// Mutably borrow from an owned value.\n+    fn borrow_from_mut(owned: &mut Owned) -> &mut Self;\n+}\n+\n+impl<Sized? T> BorrowFrom<T> for T {\n+    fn borrow_from(owned: &T) -> &T { owned }\n+}\n+\n+impl<Sized? T> BorrowFromMut<T> for T {\n+    fn borrow_from_mut(owned: &mut T) -> &mut T { owned }\n+}\n+\n+impl BorrowFrom<&'static str> for str {\n+    fn borrow_from<'a>(owned: &'a &'static str) -> &'a str { &**owned }\n+}\n+\n+/// A generalization of Clone to borrowed data.\n+pub trait ToOwned<Owned> for Sized?: BorrowFrom<Owned> {\n+    /// Create owned data from borrowed data, usually by copying.\n+    fn to_owned(&self) -> Owned;\n+}\n+\n+impl<T> ToOwned<T> for T where T: Clone {\n+    fn to_owned(&self) -> T { self.clone() }\n+}\n+\n+/// A clone-on-write smart pointer.\n+pub enum Cow<'a, T, B: 'a> where B: ToOwned<T> {\n+    /// Borrowed data.\n+    Borrowed(&'a B),\n+\n+    /// Owned data.\n+    Owned(T)\n+}\n+\n+impl<'a, T, B> Cow<'a, T, B> where B: ToOwned<T> {\n+    /// Acquire a mutable reference to the owned form of the data.\n+    ///\n+    /// Copies the data if it is not already owned.\n+    pub fn to_mut(&mut self) -> &mut T {\n+        match *self {\n+            Borrowed(borrowed) => {\n+                *self = Owned(borrowed.to_owned());\n+                self.to_mut()\n+            }\n+            Owned(ref mut owned) => owned\n+        }\n+    }\n+\n+    /// Extract the owned data.\n+    ///\n+    /// Copies the data if it is not already owned.\n+    pub fn into_owned(self) -> T {\n+        match self {\n+            Borrowed(borrowed) => borrowed.to_owned(),\n+            Owned(owned) => owned\n+        }\n+    }\n+}\n+\n+impl<'a, T, B> Deref<B> for Cow<'a, T, B> where B: ToOwned<T>  {\n+    fn deref(&self) -> &B {\n+        match *self {\n+            Borrowed(borrowed) => borrowed,\n+            Owned(ref owned) => BorrowFrom::borrow_from(owned)\n+        }\n+    }\n+}"}, {"sha": "5e3c74477d15c6ba723f283a0f4b1b7defe92601", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=7137c2cc83526e1f74af472380e625fc7c552826", "patch": "@@ -108,6 +108,7 @@ pub mod default;\n pub mod any;\n pub mod atomic;\n pub mod bool;\n+pub mod borrow;\n pub mod cell;\n pub mod char;\n pub mod panicking;"}, {"sha": "b4bf5351e597bad17d9ef1aea5960d23d82c51cc", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=7137c2cc83526e1f74af472380e625fc7c552826", "patch": "@@ -638,7 +638,7 @@ shr_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64)\n  * ```\n  */\n #[lang=\"index\"]\n-pub trait Index<Index, Sized? Result> for Sized? {\n+pub trait Index<Sized? Index, Sized? Result> for Sized? {\n     /// The method for the indexing (`Foo[Bar]`) operation\n     fn index<'a>(&'a self, index: &Index) -> &'a Result;\n }\n@@ -669,7 +669,7 @@ pub trait Index<Index, Sized? Result> for Sized? {\n  * ```\n  */\n #[lang=\"index_mut\"]\n-pub trait IndexMut<Index, Result> for Sized? {\n+pub trait IndexMut<Sized? Index, Result> for Sized? {\n     /// The method for the indexing (`Foo[Bar]`) operation\n     fn index_mut<'a>(&'a mut self, index: &Index) -> &'a mut Result;\n }"}, {"sha": "e1e2abcb1b7c540e011443e6959a8b86fa3e63b4", "filename": "src/libregex/re.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=7137c2cc83526e1f74af472380e625fc7c552826", "patch": "@@ -726,7 +726,7 @@ impl<'t> Captures<'t> {\n         match self.named {\n             None => \"\",\n             Some(ref h) => {\n-                match h.find_equiv(name) {\n+                match h.get(name) {\n                     None => \"\",\n                     Some(i) => self.at(*i),\n                 }"}, {"sha": "aa6a021a210ef60580a7bac46a41c5c902cbf910", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=7137c2cc83526e1f74af472380e625fc7c552826", "patch": "@@ -165,7 +165,7 @@ impl LintStore {\n     }\n \n     fn register_renamed(&mut self, old_name: &str, new_name: &str) {\n-        let target = match self.by_name.find_equiv(new_name) {\n+        let target = match self.by_name.get(new_name) {\n             Some(&Id(lint_id)) => lint_id.clone(),\n             _ => panic!(\"invalid lint renaming of {} to {}\", old_name, new_name)\n         };\n@@ -259,7 +259,7 @@ impl LintStore {\n     fn find_lint(&self, lint_name: &str, sess: &Session, span: Option<Span>)\n                  -> Option<LintId>\n     {\n-        match self.by_name.find_equiv(lint_name) {\n+        match self.by_name.get(lint_name) {\n             Some(&Id(lint_id)) => Some(lint_id),\n             Some(&Renamed(ref new_name, lint_id)) => {\n                 let warning = format!(\"lint {} has been renamed to {}\",\n@@ -282,7 +282,7 @@ impl LintStore {\n                     match self.lint_groups.iter().map(|(&x, pair)| (x, pair.ref0().clone()))\n                                                  .collect::<FnvHashMap<&'static str,\n                                                                        Vec<LintId>>>()\n-                                                 .find_equiv(lint_name.as_slice()) {\n+                                                 .get(lint_name.as_slice()) {\n                         Some(v) => {\n                             v.iter()\n                              .map(|lint_id: &LintId|\n@@ -489,7 +489,7 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n                     match self.lints.find_lint(lint_name.get(), &self.tcx.sess, Some(span)) {\n                         Some(lint_id) => vec![(lint_id, level, span)],\n                         None => {\n-                            match self.lints.lint_groups.find_equiv(lint_name.get()) {\n+                            match self.lints.lint_groups.get(lint_name.get()) {\n                                 Some(&(ref v, _)) => v.iter()\n                                                       .map(|lint_id: &LintId|\n                                                            (*lint_id, level, span))"}, {"sha": "1cfe565fd7deecc16006162c0cba59e5824716a2", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=7137c2cc83526e1f74af472380e625fc7c552826", "patch": "@@ -321,7 +321,7 @@ fn existing_match(e: &Env, name: &str,\n         // `source` stores paths which are normalized which may be different\n         // from the strings on the command line.\n         let source = e.sess.cstore.get_used_crate_source(cnum).unwrap();\n-        match e.sess.opts.externs.find_equiv(name) {\n+        match e.sess.opts.externs.get(name) {\n             Some(locs) => {\n                 let found = locs.iter().any(|l| {\n                     let l = fs::realpath(&Path::new(l.as_slice())).ok();"}, {"sha": "e0110a81c179f0d6e3fe03086151634b9f01fe60", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=7137c2cc83526e1f74af472380e625fc7c552826", "patch": "@@ -298,7 +298,7 @@ fn item_path(item_doc: rbml::Doc) -> Vec<ast_map::PathElem> {\n fn item_name(intr: &IdentInterner, item: rbml::Doc) -> ast::Name {\n     let name = reader::get_doc(item, tag_paths_data_name);\n     let string = name.as_str_slice();\n-    match intr.find_equiv(string) {\n+    match intr.find(string) {\n         None => token::intern(string),\n         Some(val) => val,\n     }\n@@ -1449,4 +1449,3 @@ pub fn is_associated_type(cdata: Cmd, id: ast::NodeId) -> bool {\n         Some(item) => item_sort(item) == 't',\n     }\n }\n-"}, {"sha": "f7d666e48150d97bc39bf5f5c6e5a6fba2a5f909", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=7137c2cc83526e1f74af472380e625fc7c552826", "patch": "@@ -54,7 +54,7 @@ impl<'a> FileSearch<'a> {\n         debug!(\"filesearch: searching lib path\");\n         let tlib_path = make_target_lib_path(self.sysroot,\n                                     self.triple);\n-        if !visited_dirs.contains_equiv(tlib_path.as_vec()) {\n+        if !visited_dirs.contains(tlib_path.as_vec()) {\n             match f(&tlib_path) {\n                 FileMatches => found = true,\n                 FileDoesntMatch => ()\n@@ -69,9 +69,9 @@ impl<'a> FileSearch<'a> {\n                 let tlib_path = make_rustpkg_lib_path(\n                     self.sysroot, path, self.triple);\n                 debug!(\"is {} in visited_dirs? {}\", tlib_path.display(),\n-                        visited_dirs.contains_equiv(&tlib_path.as_vec().to_vec()));\n+                        visited_dirs.contains(&tlib_path.as_vec().to_vec()));\n \n-                if !visited_dirs.contains_equiv(tlib_path.as_vec()) {\n+                if !visited_dirs.contains(tlib_path.as_vec()) {\n                     visited_dirs.insert(tlib_path.as_vec().to_vec());\n                     // Don't keep searching the RUST_PATH if one match turns up --\n                     // if we did, we'd get a \"multiple matching crates\" error"}, {"sha": "30bef248b4738c6a8afe52380d1c55f25bdcb45e", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=7137c2cc83526e1f74af472380e625fc7c552826", "patch": "@@ -596,7 +596,7 @@ impl<'a> Context<'a> {\n     }\n \n     fn find_commandline_library(&mut self) -> Option<Library> {\n-        let locs = match self.sess.opts.externs.find_equiv(self.crate_name) {\n+        let locs = match self.sess.opts.externs.get(self.crate_name) {\n             Some(s) => s,\n             None => return None,\n         };"}, {"sha": "ffc8a83e42edad9fd8704502e2df1488f6daf8c1", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=7137c2cc83526e1f74af472380e625fc7c552826", "patch": "@@ -132,7 +132,7 @@ impl<'a, 'v> Visitor<'v> for LanguageItemCollector<'a> {\n     fn visit_item(&mut self, item: &ast::Item) {\n         match extract(item.attrs.as_slice()) {\n             Some(value) => {\n-                let item_index = self.item_refs.find_equiv(&value).map(|x| *x);\n+                let item_index = self.item_refs.get(value.get()).map(|x| *x);\n \n                 match item_index {\n                     Some(item_index) => {"}, {"sha": "c05e61023ed67de6f6d0c1c5d288110a1b6dd1af", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=7137c2cc83526e1f74af472380e625fc7c552826", "patch": "@@ -216,7 +216,7 @@ pub fn get_extern_fn(ccx: &CrateContext,\n                      ty: Type,\n                      output: ty::t)\n                      -> ValueRef {\n-    match externs.find_equiv(name) {\n+    match externs.get(name) {\n         Some(n) => return *n,\n         None => {}\n     }\n@@ -226,7 +226,7 @@ pub fn get_extern_fn(ccx: &CrateContext,\n }\n \n fn get_extern_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str, did: ast::DefId) -> ValueRef {\n-    match ccx.externs().borrow().find_equiv(name) {\n+    match ccx.externs().borrow().get(name) {\n         Some(n) => return *n,\n         None => ()\n     }\n@@ -3026,7 +3026,7 @@ fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<String>) {\n \n                 let name = CString::new(llvm::LLVMGetValueName(val), false);\n                 if !declared.contains(&name) &&\n-                   !reachable.contains_equiv(name.as_str().unwrap()) {\n+                   !reachable.contains(name.as_str().unwrap()) {\n                     llvm::SetLinkage(val, llvm::InternalLinkage);\n                 }\n             }"}, {"sha": "de8e80b02757b6b21bc217c3560271aabca9e410", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=7137c2cc83526e1f74af472380e625fc7c552826", "patch": "@@ -1677,7 +1677,7 @@ fn declare_local(bcx: Block,\n }\n \n fn file_metadata(cx: &CrateContext, full_path: &str) -> DIFile {\n-    match debug_context(cx).created_files.borrow().find_equiv(full_path) {\n+    match debug_context(cx).created_files.borrow().get(full_path) {\n         Some(file_metadata) => return *file_metadata,\n         None => ()\n     }"}, {"sha": "69861290b8d0d16f47d8d7d5b7e061b27f6533f2", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=7137c2cc83526e1f74af472380e625fc7c552826", "patch": "@@ -336,7 +336,7 @@ impl TypeNames {\n     }\n \n     pub fn find_type(&self, s: &str) -> Option<Type> {\n-        self.named_types.borrow().find_equiv(s).map(|x| Type::from_ref(*x))\n+        self.named_types.borrow().get(s).map(|x| Type::from_ref(*x))\n     }\n \n     pub fn type_to_string(&self, ty: Type) -> String {"}, {"sha": "8e9ac7095dae1bde2d1a85089b11a6719638d20a", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=7137c2cc83526e1f74af472380e625fc7c552826", "patch": "@@ -2122,7 +2122,7 @@ impl<'a> fmt::Show for Sidebar<'a> {\n \n         fn block(w: &mut fmt::Formatter, short: &str, longty: &str,\n                  cur: &clean::Item, cx: &Context) -> fmt::Result {\n-            let items = match cx.sidebar.find_equiv(short) {\n+            let items = match cx.sidebar.get(short) {\n                 Some(items) => items.as_slice(),\n                 None => return Ok(())\n             };"}, {"sha": "03e0452a4158d5a02d601cc3910ee7ebbd0a3d1c", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=7137c2cc83526e1f74af472380e625fc7c552826", "patch": "@@ -901,7 +901,7 @@ impl Json {\n     /// Otherwise, returns None.\n     pub fn find<'a>(&'a self, key: &str) -> Option<&'a Json>{\n         match self {\n-            &Object(ref map) => map.find_with(|s| key.cmp(s.as_slice())),\n+            &Object(ref map) => map.get(key),\n             _ => None\n         }\n     }\n@@ -926,7 +926,7 @@ impl Json {\n     pub fn search<'a>(&'a self, key: &str) -> Option<&'a Json> {\n         match self {\n             &Object(ref map) => {\n-                match map.find_with(|s| key.cmp(s.as_slice())) {\n+                match map.get(key) {\n                     Some(json_value) => Some(json_value),\n                     None => {\n                         for (_, v) in map.iter() {"}, {"sha": "69375e8d4f84e131d5044185422b130c96589472", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 66, "deletions": 84, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=7137c2cc83526e1f74af472380e625fc7c552826", "patch": "@@ -14,6 +14,7 @@ pub use self::Entry::*;\n use self::SearchResult::*;\n use self::VacantEntryState::*;\n \n+use borrow::BorrowFrom;\n use clone::Clone;\n use cmp::{max, Eq, Equiv, PartialEq};\n use default::Default;\n@@ -142,7 +143,7 @@ impl DefaultResizePolicy {\n // about the size of rust executables.\n //\n // Annotate exceedingly likely branches in `table::make_hash`\n-// and `search_hashed_generic` to reduce instruction cache pressure\n+// and `search_hashed` to reduce instruction cache pressure\n // and mispredictions once it becomes possible (blocked on issue #11092).\n //\n // Shrinking the table could simply reallocate in place after moving buckets\n@@ -286,10 +287,10 @@ pub struct HashMap<K, V, H = RandomSipHasher> {\n }\n \n /// Search for a pre-hashed key.\n-fn search_hashed_generic<K, V, M: Deref<RawTable<K, V>>>(table: M,\n-                                                         hash: &SafeHash,\n-                                                         is_match: |&K| -> bool)\n-                                                         -> SearchResult<K, V, M> {\n+fn search_hashed<K, V, M: Deref<RawTable<K, V>>>(table: M,\n+                                                 hash: &SafeHash,\n+                                                 is_match: |&K| -> bool)\n+                                                 -> SearchResult<K, V, M> {\n     let size = table.size();\n     let mut probe = Bucket::new(table, hash);\n     let ib = probe.index();\n@@ -325,11 +326,6 @@ fn search_hashed_generic<K, V, M: Deref<RawTable<K, V>>>(table: M,\n     TableRef(probe.into_table())\n }\n \n-fn search_hashed<K: Eq, V, M: Deref<RawTable<K, V>>>(table: M, hash: &SafeHash, k: &K)\n-                                                     -> SearchResult<K, V, M> {\n-    search_hashed_generic(table, hash, |k_| *k == *k_)\n-}\n-\n fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>) -> (K, V) {\n     let (empty, retkey, retval) = starting_bucket.take();\n     let mut gap = match empty.gap_peek() {\n@@ -432,26 +428,32 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     fn search_equiv<'a, Sized? Q: Hash<S> + Equiv<K>>(&'a self, q: &Q)\n                     -> Option<FullBucketImm<'a, K, V>> {\n         let hash = self.make_hash(q);\n-        search_hashed_generic(&self.table, &hash, |k| q.equiv(k)).into_option()\n+        search_hashed(&self.table, &hash, |k| q.equiv(k)).into_option()\n     }\n \n     fn search_equiv_mut<'a, Sized? Q: Hash<S> + Equiv<K>>(&'a mut self, q: &Q)\n                     -> Option<FullBucketMut<'a, K, V>> {\n         let hash = self.make_hash(q);\n-        search_hashed_generic(&mut self.table, &hash, |k| q.equiv(k)).into_option()\n+        search_hashed(&mut self.table, &hash, |k| q.equiv(k)).into_option()\n     }\n \n     /// Search for a key, yielding the index if it's found in the hashtable.\n     /// If you already have the hash for the key lying around, use\n     /// search_hashed.\n-    fn search<'a>(&'a self, k: &K) -> Option<FullBucketImm<'a, K, V>> {\n-        let hash = self.make_hash(k);\n-        search_hashed(&self.table, &hash, k).into_option()\n+    fn search<'a, Sized? Q>(&'a self, q: &Q) -> Option<FullBucketImm<'a, K, V>>\n+        where Q: BorrowFrom<K> + Eq + Hash<S>\n+    {\n+        let hash = self.make_hash(q);\n+        search_hashed(&self.table, &hash, |k| q.eq(BorrowFrom::borrow_from(k)))\n+            .into_option()\n     }\n \n-    fn search_mut<'a>(&'a mut self, k: &K) -> Option<FullBucketMut<'a, K, V>> {\n-        let hash = self.make_hash(k);\n-        search_hashed(&mut self.table, &hash, k).into_option()\n+    fn search_mut<'a, Sized? Q>(&'a mut self, q: &Q) -> Option<FullBucketMut<'a, K, V>>\n+        where Q: BorrowFrom<K> + Eq + Hash<S>\n+    {\n+        let hash = self.make_hash(q);\n+        search_hashed(&mut self.table, &hash, |k| q.eq(BorrowFrom::borrow_from(k)))\n+            .into_option()\n     }\n \n     // The caller should ensure that invariants by Robin Hood Hashing hold.\n@@ -748,18 +750,14 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         }\n     }\n \n-    /// Return true if the map contains a value for the specified key,\n-    /// using equivalence.\n-    ///\n-    /// See [pop_equiv](#method.pop_equiv) for an extended example.\n+    /// Deprecated: use `contains_key` and `BorrowFrom` instead.\n+    #[deprecated = \"use contains_key and BorrowFrom instead\"]\n     pub fn contains_key_equiv<Sized? Q: Hash<S> + Equiv<K>>(&self, key: &Q) -> bool {\n         self.search_equiv(key).is_some()\n     }\n \n-    /// Return the value corresponding to the key in the map, using\n-    /// equivalence.\n-    ///\n-    /// See [pop_equiv](#method.pop_equiv) for an extended example.\n+    /// Deprecated: use `get` and `BorrowFrom` instead.\n+    #[deprecated = \"use get and BorrowFrom instead\"]\n     pub fn find_equiv<'a, Sized? Q: Hash<S> + Equiv<K>>(&'a self, k: &Q) -> Option<&'a V> {\n         match self.search_equiv(k) {\n             None      => None,\n@@ -770,52 +768,8 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         }\n     }\n \n-    /// Remove an equivalent key from the map, returning the value at the\n-    /// key if the key was previously in the map.\n-    ///\n-    /// # Example\n-    ///\n-    /// This is a slightly silly example where we define the number's\n-    /// parity as the equivalence class. It is important that the\n-    /// values hash the same, which is why we implement `Hash`.\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    /// use std::hash::Hash;\n-    /// use std::hash::sip::SipState;\n-    ///\n-    /// #[deriving(Eq, PartialEq)]\n-    /// struct EvenOrOdd {\n-    ///     num: uint\n-    /// };\n-    ///\n-    /// impl Hash for EvenOrOdd {\n-    ///     fn hash(&self, state: &mut SipState) {\n-    ///         let parity = self.num % 2;\n-    ///         parity.hash(state);\n-    ///     }\n-    /// }\n-    ///\n-    /// impl Equiv<EvenOrOdd> for EvenOrOdd {\n-    ///     fn equiv(&self, other: &EvenOrOdd) -> bool {\n-    ///         self.num % 2 == other.num % 2\n-    ///     }\n-    /// }\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(EvenOrOdd { num: 3 }, \"foo\");\n-    ///\n-    /// assert!(map.contains_key_equiv(&EvenOrOdd { num: 1 }));\n-    /// assert!(!map.contains_key_equiv(&EvenOrOdd { num: 4 }));\n-    ///\n-    /// assert_eq!(map.find_equiv(&EvenOrOdd { num: 5 }), Some(&\"foo\"));\n-    /// assert_eq!(map.find_equiv(&EvenOrOdd { num: 2 }), None);\n-    ///\n-    /// assert_eq!(map.pop_equiv(&EvenOrOdd { num: 1 }), Some(\"foo\"));\n-    /// assert_eq!(map.pop_equiv(&EvenOrOdd { num: 2 }), None);\n-    ///\n-    /// ```\n-    #[experimental]\n+    /// Deprecated: use `remove` and `BorrowFrom` instead.\n+    #[deprecated = \"use remove and BorrowFrom instead\"]\n     pub fn pop_equiv<Sized? Q:Hash<S> + Equiv<K>>(&mut self, k: &Q) -> Option<V> {\n         if self.table.size() == 0 {\n             return None\n@@ -1036,6 +990,10 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n \n     /// Returns a reference to the value corresponding to the key.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but\n+    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -1047,7 +1005,9 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn get(&self, k: &K) -> Option<&V> {\n+    pub fn get<Sized? Q>(&self, k: &Q) -> Option<&V>\n+        where Q: Hash<S> + Eq + BorrowFrom<K>\n+    {\n         self.search(k).map(|bucket| {\n             let (_, v) = bucket.into_refs();\n             v\n@@ -1056,6 +1016,10 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n \n     /// Returns true if the map contains a value for the specified key.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but\n+    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -1067,7 +1031,9 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn contains_key(&self, k: &K) -> bool {\n+    pub fn contains_key<Sized? Q>(&self, k: &Q) -> bool\n+        where Q: Hash<S> + Eq + BorrowFrom<K>\n+    {\n         self.search(k).is_some()\n     }\n \n@@ -1079,6 +1045,10 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n \n     /// Returns a mutable reference to the value corresponding to the key.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but\n+    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -1093,7 +1063,9 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert_eq!(map[1], \"b\");\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn get_mut(&mut self, k: &K) -> Option<&mut V> {\n+    pub fn get_mut<Sized? Q>(&mut self, k: &Q) -> Option<&mut V>\n+        where Q: Hash<S> + Eq + BorrowFrom<K>\n+    {\n         match self.search_mut(k) {\n             Some(bucket) => {\n                 let (_, v) = bucket.into_mut_refs();\n@@ -1147,6 +1119,10 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// Removes a key from the map, returning the value at the key if the key\n     /// was previously in the map.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but\n+    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -1158,7 +1134,9 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn remove(&mut self, k: &K) -> Option<V> {\n+    pub fn remove<Sized? Q>(&mut self, k: &Q) -> Option<V>\n+        where Q: Hash<S> + Eq + BorrowFrom<K>\n+    {\n         if self.table.size() == 0 {\n             return None\n         }\n@@ -1271,16 +1249,20 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> Default for HashMap<K, V, H>\n     }\n }\n \n-impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Index<K, V> for HashMap<K, V, H> {\n+impl<K: Hash<S> + Eq, Sized? Q, V, S, H: Hasher<S>> Index<Q, V> for HashMap<K, V, H>\n+    where Q: BorrowFrom<K> + Hash<S> + Eq\n+{\n     #[inline]\n-    fn index<'a>(&'a self, index: &K) -> &'a V {\n+    fn index<'a>(&'a self, index: &Q) -> &'a V {\n         self.get(index).expect(\"no entry found for key\")\n     }\n }\n \n-impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> IndexMut<K, V> for HashMap<K, V, H> {\n+impl<K: Hash<S> + Eq, Sized? Q, V, S, H: Hasher<S>> IndexMut<Q, V> for HashMap<K, V, H>\n+    where Q: BorrowFrom<K> + Hash<S> + Eq\n+{\n     #[inline]\n-    fn index_mut<'a>(&'a mut self, index: &K) -> &'a mut V {\n+    fn index_mut<'a>(&'a mut self, index: &Q) -> &'a mut V {\n         match self.get_mut(index) {\n             Some(v) => v,\n             None => panic!(\"no entry found for key\")\n@@ -1962,11 +1944,11 @@ mod test_map {\n         m.insert(\"baz\".to_string(), baz);\n \n \n-        assert_eq!(m.find_equiv(\"foo\"), Some(&foo));\n-        assert_eq!(m.find_equiv(\"bar\"), Some(&bar));\n-        assert_eq!(m.find_equiv(\"baz\"), Some(&baz));\n+        assert_eq!(m.get(\"foo\"), Some(&foo));\n+        assert_eq!(m.get(\"bar\"), Some(&bar));\n+        assert_eq!(m.get(\"baz\"), Some(&baz));\n \n-        assert_eq!(m.find_equiv(\"qux\"), None);\n+        assert_eq!(m.get(\"qux\"), None);\n     }\n \n     #[test]"}, {"sha": "2fbcb464358b3c76170609de03524e5d5b40caab", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 22, "deletions": 43, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=7137c2cc83526e1f74af472380e625fc7c552826", "patch": "@@ -10,6 +10,7 @@\n //\n // ignore-lexer-test FIXME #15883\n \n+use borrow::BorrowFrom;\n use cmp::{Eq, Equiv, PartialEq};\n use core::kinds::Sized;\n use default::Default;\n@@ -184,47 +185,9 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n         self.map.reserve(n)\n     }\n \n-    /// Returns true if the hash set contains a value equivalent to the\n-    /// given query value.\n-    ///\n-    /// # Example\n-    ///\n-    /// This is a slightly silly example where we define the number's\n-    /// parity as the equivalance class. It is important that the\n-    /// values hash the same, which is why we implement `Hash`.\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    /// use std::hash::Hash;\n-    /// use std::hash::sip::SipState;\n-    ///\n-    /// #[deriving(Eq, PartialEq)]\n-    /// struct EvenOrOdd {\n-    ///     num: uint\n-    /// };\n-    ///\n-    /// impl Hash for EvenOrOdd {\n-    ///     fn hash(&self, state: &mut SipState) {\n-    ///         let parity = self.num % 2;\n-    ///         parity.hash(state);\n-    ///     }\n-    /// }\n-    ///\n-    /// impl Equiv<EvenOrOdd> for EvenOrOdd {\n-    ///     fn equiv(&self, other: &EvenOrOdd) -> bool {\n-    ///         self.num % 2 == other.num % 2\n-    ///     }\n-    /// }\n-    ///\n-    /// let mut set = HashSet::new();\n-    /// set.insert(EvenOrOdd { num: 3u });\n-    ///\n-    /// assert!(set.contains_equiv(&EvenOrOdd { num: 3u }));\n-    /// assert!(set.contains_equiv(&EvenOrOdd { num: 5u }));\n-    /// assert!(!set.contains_equiv(&EvenOrOdd { num: 4u }));\n-    /// assert!(!set.contains_equiv(&EvenOrOdd { num: 2u }));\n-    ///\n-    /// ```\n+    /// Deprecated: use `contains` and `BorrowFrom`.\n+    #[deprecated = \"use contains and BorrowFrom\"]\n+    #[allow(deprecated)]\n     pub fn contains_equiv<Sized? Q: Hash<S> + Equiv<T>>(&self, value: &Q) -> bool {\n       self.map.contains_key_equiv(value)\n     }\n@@ -427,6 +390,10 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n \n     /// Returns `true` if the set contains a value.\n     ///\n+    /// The value may be any borrowed form of the set's value type, but\n+    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// the value type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -437,7 +404,11 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn contains(&self, value: &T) -> bool { self.map.contains_key(value) }\n+    pub fn contains<Sized? Q>(&self, value: &Q) -> bool\n+        where Q: BorrowFrom<T> + Hash<S> + Eq\n+    {\n+        self.map.contains_key(value)\n+    }\n \n     /// Returns `true` if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n@@ -527,6 +498,10 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// Removes a value from the set. Returns `true` if the value was\n     /// present in the set.\n     ///\n+    /// The value may be any borrowed form of the set's value type, but\n+    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// the value type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -539,7 +514,11 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn remove(&mut self, value: &T) -> bool { self.map.remove(value).is_some() }\n+    pub fn remove<Sized? Q>(&mut self, value: &Q) -> bool\n+        where Q: BorrowFrom<T> + Hash<S> + Eq\n+    {\n+        self.map.remove(value).is_some()\n+    }\n }\n \n impl<T: Eq + Hash<S>, S, H: Hasher<S>> PartialEq for HashSet<T, H> {"}, {"sha": "7f2a4c7e36569f4881c56d1e680db9ded0c5c9f0", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=7137c2cc83526e1f74af472380e625fc7c552826", "patch": "@@ -141,6 +141,7 @@ extern crate rustrt;\n \n pub use core::any;\n pub use core::bool;\n+pub use core::borrow;\n pub use core::cell;\n pub use core::clone;\n #[cfg(not(test))] pub use core::cmp;"}, {"sha": "39ca3128ccb2babc7d94eafd1b2b55749cacd9b7", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=7137c2cc83526e1f74af472380e625fc7c552826", "patch": "@@ -554,11 +554,4 @@ mod tests {\n         assert_eq!(format!(\"{:30}\", Duration::days(1) + Duration::milliseconds(2345)),\n                    \"P1DT2.345S\".to_string());\n     }\n-\n-    #[test]\n-    fn span() {\n-        use io::timer::sleep;\n-        let dur = Duration::span(|| sleep(Duration::milliseconds(5)));\n-        assert!(dur > Duration::milliseconds(1));\n-    }\n }"}, {"sha": "4caef247aebc26f601318c8d4de23ec70cfdfe02", "filename": "src/libsyntax/diagnostics/registry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibsyntax%2Fdiagnostics%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibsyntax%2Fdiagnostics%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fregistry.rs?ref=7137c2cc83526e1f74af472380e625fc7c552826", "patch": "@@ -20,6 +20,6 @@ impl Registry {\n     }\n \n     pub fn find_description(&self, code: &str) -> Option<&'static str> {\n-        self.descriptions.find_equiv(code).map(|desc| *desc)\n+        self.descriptions.get(code).map(|desc| *desc)\n     }\n }"}, {"sha": "f1b92b4d6bc1d7406bcac881eb0c1f09a79a1889", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=7137c2cc83526e1f74af472380e625fc7c552826", "patch": "@@ -144,7 +144,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, allow_method: bool,\n             let name = interned_name.get();\n             p.expect(&token::Eq);\n             let e = p.parse_expr();\n-            match names.find_equiv(name) {\n+            match names.get(name) {\n                 None => {}\n                 Some(prev) => {\n                     ecx.span_err(e.span,\n@@ -366,7 +366,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 self.ecx.expr_path(path)\n             }\n             parse::CountIsName(n) => {\n-                let i = match self.name_positions.find_equiv(n) {\n+                let i = match self.name_positions.get(n) {\n                     Some(&i) => i,\n                     None => 0, // error already emitted elsewhere\n                 };\n@@ -410,7 +410,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     // Named arguments are converted to positional arguments at\n                     // the end of the list of arguments\n                     parse::ArgumentNamed(n) => {\n-                        let i = match self.name_positions.find_equiv(n) {\n+                        let i = match self.name_positions.get(n) {\n                             Some(&i) => i,\n                             None => 0, // error already emitted elsewhere\n                         };"}, {"sha": "ede967bba25cd20bad2a12dd2d56ae77148f3179", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=7137c2cc83526e1f74af472380e625fc7c552826", "patch": "@@ -14,9 +14,9 @@\n \n use ast::Name;\n \n+use std::borrow::BorrowFrom;\n use std::collections::HashMap;\n use std::cell::RefCell;\n-use std::cmp::Equiv;\n use std::fmt;\n use std::hash::Hash;\n use std::rc::Rc;\n@@ -75,9 +75,10 @@ impl<T: Eq + Hash + Clone + 'static> Interner<T> {\n         (*vect).len()\n     }\n \n-    pub fn find_equiv<Sized? Q: Hash + Equiv<T>>(&self, val: &Q) -> Option<Name> {\n+    pub fn find<Sized? Q>(&self, val: &Q) -> Option<Name>\n+    where Q: BorrowFrom<T> + Eq + Hash {\n         let map = self.map.borrow();\n-        match (*map).find_equiv(val) {\n+        match (*map).get(val) {\n             Some(v) => Some(*v),\n             None => None,\n         }\n@@ -117,6 +118,12 @@ impl fmt::Show for RcStr {\n     }\n }\n \n+impl BorrowFrom<RcStr> for str {\n+    fn borrow_from(owned: &RcStr) -> &str {\n+        owned.string.as_slice()\n+    }\n+}\n+\n impl RcStr {\n     pub fn new(string: &str) -> RcStr {\n         RcStr {\n@@ -149,7 +156,7 @@ impl StrInterner {\n \n     pub fn intern(&self, val: &str) -> Name {\n         let mut map = self.map.borrow_mut();\n-        match map.find_equiv(val) {\n+        match map.get(val) {\n             Some(&idx) => return idx,\n             None => (),\n         }\n@@ -195,8 +202,9 @@ impl StrInterner {\n         self.vect.borrow().len()\n     }\n \n-    pub fn find_equiv<Sized? Q:Hash + Equiv<RcStr>>(&self, val: &Q) -> Option<Name> {\n-        match (*self.map.borrow()).find_equiv(val) {\n+    pub fn find<Sized? Q>(&self, val: &Q) -> Option<Name>\n+    where Q: BorrowFrom<RcStr> + Eq + Hash {\n+        match (*self.map.borrow()).get(val) {\n             Some(v) => Some(*v),\n             None => None,\n         }"}, {"sha": "c1393767c8adcaf62af86f86b2f1e70452e9c64a", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7137c2cc83526e1f74af472380e625fc7c552826/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=7137c2cc83526e1f74af472380e625fc7c552826", "patch": "@@ -78,7 +78,7 @@ impl<T: Writer+Send> Terminal<T> for TerminfoTerminal<T> {\n         if self.num_colors > color {\n             let s = expand(self.ti\n                                .strings\n-                               .find_equiv(\"setaf\")\n+                               .get(\"setaf\")\n                                .unwrap()\n                                .as_slice(),\n                            &[Number(color as int)], &mut Variables::new());\n@@ -95,7 +95,7 @@ impl<T: Writer+Send> Terminal<T> for TerminfoTerminal<T> {\n         if self.num_colors > color {\n             let s = expand(self.ti\n                                .strings\n-                               .find_equiv(\"setab\")\n+                               .get(\"setab\")\n                                .unwrap()\n                                .as_slice(),\n                            &[Number(color as int)], &mut Variables::new());\n@@ -113,7 +113,7 @@ impl<T: Writer+Send> Terminal<T> for TerminfoTerminal<T> {\n             attr::BackgroundColor(c) => self.bg(c),\n             _ => {\n                 let cap = cap_for_attr(attr);\n-                let parm = self.ti.strings.find_equiv(cap);\n+                let parm = self.ti.strings.get(cap);\n                 if parm.is_some() {\n                     let s = expand(parm.unwrap().as_slice(),\n                                    &[],\n@@ -135,19 +135,19 @@ impl<T: Writer+Send> Terminal<T> for TerminfoTerminal<T> {\n             }\n             _ => {\n                 let cap = cap_for_attr(attr);\n-                self.ti.strings.find_equiv(cap).is_some()\n+                self.ti.strings.get(cap).is_some()\n             }\n         }\n     }\n \n     fn reset(&mut self) -> IoResult<()> {\n-        let mut cap = self.ti.strings.find_equiv(\"sgr0\");\n+        let mut cap = self.ti.strings.get(\"sgr0\");\n         if cap.is_none() {\n             // are there any terminals that have color/attrs and not sgr0?\n             // Try falling back to sgr, then op\n-            cap = self.ti.strings.find_equiv(\"sgr\");\n+            cap = self.ti.strings.get(\"sgr\");\n             if cap.is_none() {\n-                cap = self.ti.strings.find_equiv(\"op\");\n+                cap = self.ti.strings.get(\"op\");\n             }\n         }\n         let s = cap.map_or(Err(\"can't find terminfo capability `sgr0`\".to_string()), |op| {\n@@ -202,9 +202,9 @@ impl<T: Writer+Send> TerminfoTerminal<T> {\n         }\n \n         let inf = ti.unwrap();\n-        let nc = if inf.strings.find_equiv(\"setaf\").is_some()\n-                 && inf.strings.find_equiv(\"setab\").is_some() {\n-                     inf.numbers.find_equiv(\"colors\").map_or(0, |&n| n)\n+        let nc = if inf.strings.get(\"setaf\").is_some()\n+                 && inf.strings.get(\"setab\").is_some() {\n+                     inf.numbers.get(\"colors\").map_or(0, |&n| n)\n                  } else { 0 };\n \n         return Some(box TerminfoTerminal {out: out,"}, {"sha": "e39cd743ad55ac75d921912f1a419eac21df1cb3", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7137c2cc83526e1f74af472380e625fc7c552826/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7137c2cc83526e1f74af472380e625fc7c552826/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=7137c2cc83526e1f74af472380e625fc7c552826", "patch": "@@ -76,7 +76,7 @@ fn sort_and_fmt(mm: &HashMap<Vec<u8> , uint>, total: uint) -> String {\n // given a map, search for the frequency of a pattern\n fn find(mm: &HashMap<Vec<u8> , uint>, key: String) -> uint {\n    let key = key.into_ascii().as_slice().to_lowercase().into_string();\n-   match mm.find_equiv(key.as_bytes()) {\n+   match mm.get(key.as_bytes()) {\n       option::None      => { return 0u; }\n       option::Some(&num) => { return num; }\n    }"}]}