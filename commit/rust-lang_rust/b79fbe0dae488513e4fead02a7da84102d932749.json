{"sha": "b79fbe0dae488513e4fead02a7da84102d932749", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3OWZiZTBkYWU0ODg1MTNlNGZlYWQwMmE3ZGE4NDEwMmQ5MzI3NDk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-27T17:07:41Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-27T17:07:41Z"}, "message": "rollup merge of #23625: fhahn/issue-23620-ice-unicode-bytestring\n\ncloses #23620\n\nThis PR patches the issue mentioned in #23620, but there is also an ICE for invalid escape sequences in byte literals. This is due to the fact that the `scan_byte` function returns ` token::intern(\"??\") ` for invalid bytes, resulting in an ICE later on. Is there a reason for this behavior? Shouldn't `scan_byte` fail when it encounters an invalid byte?\n\nAnd I noticed a small inconsistency in the documentation. According to the formal byte literal definition in http://doc.rust-lang.org/reference.html#byte-and-byte-string-literals , a byte string literal contains `string_body *`, but according to the text (and the behavior of the lexer) it should not accept unicode escape sequences. Hence it should be replaced by `byte_body *`. If this is valid, I can add this fix to this PR.", "tree": {"sha": "cb71fd4becff68bcda0543f943d93764d4c92c60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb71fd4becff68bcda0543f943d93764d4c92c60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b79fbe0dae488513e4fead02a7da84102d932749", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b79fbe0dae488513e4fead02a7da84102d932749", "html_url": "https://github.com/rust-lang/rust/commit/b79fbe0dae488513e4fead02a7da84102d932749", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b79fbe0dae488513e4fead02a7da84102d932749/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e42521aa58be928dd62b5450c443368d29ab6a65", "url": "https://api.github.com/repos/rust-lang/rust/commits/e42521aa58be928dd62b5450c443368d29ab6a65", "html_url": "https://github.com/rust-lang/rust/commit/e42521aa58be928dd62b5450c443368d29ab6a65"}, {"sha": "afaa3b6a2066e4dacd4e7dafb5fd911bf35bdd6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/afaa3b6a2066e4dacd4e7dafb5fd911bf35bdd6c", "html_url": "https://github.com/rust-lang/rust/commit/afaa3b6a2066e4dacd4e7dafb5fd911bf35bdd6c"}], "stats": {"total": 90, "additions": 78, "deletions": 12}, "files": [{"sha": "e11e9f62a5b379c44c3363e7713776ecd7234fa1", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b79fbe0dae488513e4fead02a7da84102d932749/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b79fbe0dae488513e4fead02a7da84102d932749/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=b79fbe0dae488513e4fead02a7da84102d932749", "patch": "@@ -742,6 +742,7 @@ impl<'a> StringReader<'a> {\n         let start_bpos = self.last_pos;\n         let mut accum_int = 0;\n \n+        let mut valid = true;\n         for _ in 0..n_digits {\n             if self.is_eof() {\n                 let last_bpos = self.last_pos;\n@@ -750,13 +751,16 @@ impl<'a> StringReader<'a> {\n             if self.curr_is(delim) {\n                 let last_bpos = self.last_pos;\n                 self.err_span_(start_bpos, last_bpos, \"numeric character escape is too short\");\n+                valid = false;\n                 break;\n             }\n             let c = self.curr.unwrap_or('\\x00');\n             accum_int *= 16;\n             accum_int += c.to_digit(16).unwrap_or_else(|| {\n                 self.err_span_char(self.last_pos, self.pos,\n                               \"illegal character in numeric character escape\", c);\n+\n+                valid = false;\n                 0\n             });\n             self.bump();\n@@ -767,10 +771,11 @@ impl<'a> StringReader<'a> {\n                            self.last_pos,\n                            \"this form of character escape may only be used \\\n                             with characters in the range [\\\\x00-\\\\x7f]\");\n+            valid = false;\n         }\n \n         match char::from_u32(accum_int) {\n-            Some(_) => true,\n+            Some(_) => valid,\n             None => {\n                 let last_bpos = self.last_pos;\n                 self.err_span_(start_bpos, last_bpos, \"illegal numeric character escape\");\n@@ -799,7 +804,18 @@ impl<'a> StringReader<'a> {\n                             'n' | 'r' | 't' | '\\\\' | '\\'' | '\"' | '0' => true,\n                             'x' => self.scan_byte_escape(delim, !ascii_only),\n                             'u' if self.curr_is('{') => {\n-                                self.scan_unicode_escape(delim)\n+                            let valid = self.scan_unicode_escape(delim);\n+                            if valid && ascii_only {\n+                                self.err_span_(\n+                                    escaped_pos,\n+                                    self.last_pos,\n+                                    \"unicode escape sequences cannot be used as a byte or in \\\n+                                    a byte string\"\n+                                );\n+                                false\n+                            } else {\n+                               valid\n+                            }\n                             }\n                             '\\n' if delim == '\"' => {\n                                 self.consume_whitespace();\n@@ -869,6 +885,7 @@ impl<'a> StringReader<'a> {\n         let start_bpos = self.last_pos;\n         let mut count = 0;\n         let mut accum_int = 0;\n+        let mut valid = true;\n \n         while !self.curr_is('}') && count <= 6 {\n             let c = match self.curr {\n@@ -884,29 +901,30 @@ impl<'a> StringReader<'a> {\n                     self.fatal_span_(self.last_pos, self.pos,\n                                      \"unterminated unicode escape (needed a `}`)\");\n                 } else {\n-                    self.fatal_span_char(self.last_pos, self.pos,\n+                    self.err_span_char(self.last_pos, self.pos,\n                                    \"illegal character in unicode escape\", c);\n                 }\n+                valid = false;\n+                0\n             });\n             self.bump();\n             count += 1;\n         }\n \n         if count > 6 {\n-            self.fatal_span_(start_bpos, self.last_pos,\n+            self.err_span_(start_bpos, self.last_pos,\n                           \"overlong unicode escape (can have at most 6 hex digits)\");\n+            valid = false;\n         }\n \n         self.bump(); // past the ending }\n \n-        let mut valid = count >= 1 && count <= 6;\n-        if char::from_u32(accum_int).is_none() {\n-            valid = false;\n+        if valid && (char::from_u32(accum_int).is_none() || count == 0) {\n+            self.err_span_(start_bpos, self.last_pos, \"illegal unicode character escape\");\n+            valid= false;\n         }\n \n-        if !valid {\n-            self.fatal_span_(start_bpos, self.last_pos, \"illegal unicode character escape\");\n-        }\n+\n         valid\n     }\n \n@@ -1330,7 +1348,7 @@ impl<'a> StringReader<'a> {\n                 \"unterminated byte constant\".to_string());\n         }\n \n-        let id = if valid { self.name_from(start) } else { token::intern(\"??\") };\n+        let id = if valid { self.name_from(start) } else { token::intern(\"?\") };\n         self.bump(); // advance curr past token\n         return token::Byte(id);\n     }"}, {"sha": "7930ea75bf587b211a7c7d34841f353f5a28ffa3", "filename": "src/test/parse-fail/issue-23620-invalid-escapes.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b79fbe0dae488513e4fead02a7da84102d932749/src%2Ftest%2Fparse-fail%2Fissue-23620-invalid-escapes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b79fbe0dae488513e4fead02a7da84102d932749/src%2Ftest%2Fparse-fail%2Fissue-23620-invalid-escapes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-23620-invalid-escapes.rs?ref=b79fbe0dae488513e4fead02a7da84102d932749", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let _ = b\"\\u{a66e}\";\n+    //~^ ERROR unicode escape sequences cannot be used as a byte or in a byte string\n+\n+    let _ = b'\\u{a66e}';\n+    //~^ ERROR unicode escape sequences cannot be used as a byte or in a byte string\n+\n+    let _ = b'\\u';\n+    //~^ ERROR unknown byte escape: u\n+\n+    let _ = b'\\x5';\n+    //~^ ERROR numeric character escape is too short\n+\n+    let _ = b'\\xxy';\n+    //~^ ERROR illegal character in numeric character escape: x\n+    //~^^ ERROR illegal character in numeric character escape: y\n+\n+    let _ = '\\x5';\n+    //~^ ERROR numeric character escape is too short\n+\n+    let _ = '\\xxy';\n+    //~^ ERROR illegal character in numeric character escape: x\n+    //~^^ ERROR illegal character in numeric character escape: y\n+\n+    let _ = b\"\\u{a4a4} \\xf \\u\";\n+    //~^ ERROR unicode escape sequences cannot be used as a byte or in a byte string\n+    //~^^ ERROR illegal character in numeric character escape:\n+    //~^^^ ERROR unknown byte escape: u\n+\n+    let _ = \"\\u{ffffff} \\xf \\u\";\n+    //~^ ERROR illegal unicode character escape\n+    //~^^ ERROR illegal character in numeric character escape:\n+    //~^^^ ERROR form of character escape may only be used with characters in the range [\\x00-\\x7f]\n+    //~^^^^ ERROR unknown character escape: u\n+}"}, {"sha": "96b86f1f5635f96cc2243076085258cf455ffea3", "filename": "src/test/parse-fail/new-unicode-escapes-4.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b79fbe0dae488513e4fead02a7da84102d932749/src%2Ftest%2Fparse-fail%2Fnew-unicode-escapes-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b79fbe0dae488513e4fead02a7da84102d932749/src%2Ftest%2Fparse-fail%2Fnew-unicode-escapes-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fnew-unicode-escapes-4.rs?ref=b79fbe0dae488513e4fead02a7da84102d932749", "patch": "@@ -9,5 +9,8 @@\n // except according to those terms.\n \n pub fn main() {\n-    let s = \"\\u{lol}\"; //~ ERROR illegal character in unicode escape\n+    let s = \"\\u{lol}\";\n+     //~^ ERROR illegal character in unicode escape: l\n+     //~^^ ERROR illegal character in unicode escape: o\n+     //~^^^ ERROR illegal character in unicode escape: l\n }"}]}