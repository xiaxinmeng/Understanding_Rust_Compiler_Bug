{"sha": "c31e2e77ed955faafffe7b22859f045cc1e5deec", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzMWUyZTc3ZWQ5NTVmYWFmZmZlN2IyMjg1OWYwNDVjYzFlNWRlZWM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-04-25T20:39:05Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-04-27T16:28:48Z"}, "message": "std: Add compatibility with android-9\n\nThe Gecko folks currently use Android API level 9 for their builds, so they're\nrequesting that we move back our minimum supported API level from 18 to 9. Turns\nout, ABI-wise at least, there's not that many changes we need to take care of.\nThe `ftruncate64` API appeared in android-12 and the `log2` and `log2f` APIs\nappeared in android-18. We can have a simple shim for `ftruncate64` which falls\nback on `ftruncate` and the `log2` function can be approximated with just\n`ln(f) / ln(2)`.\n\nThis should at least get the standard library building on API level 9, although\nthe tests aren't quite happening there just yet. As we seem to be growing a\nnumber of Android compatibility shims, they're now centralized in a common\n`sys::android` module.", "tree": {"sha": "f5e315e9518b6c78f18b40a55d70bcc0da86db56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5e315e9518b6c78f18b40a55d70bcc0da86db56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c31e2e77ed955faafffe7b22859f045cc1e5deec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c31e2e77ed955faafffe7b22859f045cc1e5deec", "html_url": "https://github.com/rust-lang/rust/commit/c31e2e77ed955faafffe7b22859f045cc1e5deec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c31e2e77ed955faafffe7b22859f045cc1e5deec/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfae4dea875ddcc5f23481106a149ea15b6be1e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfae4dea875ddcc5f23481106a149ea15b6be1e5", "html_url": "https://github.com/rust-lang/rust/commit/cfae4dea875ddcc5f23481106a149ea15b6be1e5"}], "stats": {"total": 174, "additions": 138, "deletions": 36}, "files": [{"sha": "94aa3d6b513ef4d24489f34bde91cf63091b5eee", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c31e2e77ed955faafffe7b22859f045cc1e5deec/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c31e2e77ed955faafffe7b22859f045cc1e5deec/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=c31e2e77ed955faafffe7b22859f045cc1e5deec", "patch": "@@ -646,7 +646,10 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn log2(self) -> f32 {\n-        unsafe { intrinsics::log2f32(self) }\n+        #[cfg(target_os = \"android\")]\n+        return ::sys::android::log2f32(self);\n+        #[cfg(not(target_os = \"android\"))]\n+        return unsafe { intrinsics::log2f32(self) };\n     }\n \n     /// Returns the base 10 logarithm of the number."}, {"sha": "2beffb64d3dc44ecb0a75d6d1cd8a120c6aa0524", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c31e2e77ed955faafffe7b22859f045cc1e5deec/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c31e2e77ed955faafffe7b22859f045cc1e5deec/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=c31e2e77ed955faafffe7b22859f045cc1e5deec", "patch": "@@ -546,7 +546,12 @@ impl f64 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn log2(self) -> f64 {\n-        self.log_wrapper(|n| { unsafe { intrinsics::log2f64(n) } })\n+        self.log_wrapper(|n| {\n+            #[cfg(target_os = \"android\")]\n+            return ::sys::android::log2f64(n);\n+            #[cfg(not(target_os = \"android\"))]\n+            return unsafe { intrinsics::log2f64(n) };\n+        })\n     }\n \n     /// Returns the base 10 logarithm of the number."}, {"sha": "abbe3fc1846bdd090953776560123b48162aeb43", "filename": "src/libstd/sys/unix/android.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/c31e2e77ed955faafffe7b22859f045cc1e5deec/src%2Flibstd%2Fsys%2Funix%2Fandroid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c31e2e77ed955faafffe7b22859f045cc1e5deec/src%2Flibstd%2Fsys%2Funix%2Fandroid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fandroid.rs?ref=c31e2e77ed955faafffe7b22859f045cc1e5deec", "patch": "@@ -0,0 +1,119 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Android ABI-compatibility module\n+//!\n+//! The ABI of Android has changed quite a bit over time, and libstd attempts to\n+//! be both forwards and backwards compatible as much as possible. We want to\n+//! always work with the most recent version of Android, but we also want to\n+//! work with older versions of Android for whenever projects need to.\n+//!\n+//! Our current minimum supported Android version is `android-9`, e.g. Android\n+//! with API level 9. We then in theory want to work on that and all future\n+//! versions of Android!\n+//!\n+//! Some of the detection here is done at runtime via `dlopen` and\n+//! introspection. Other times no detection is performed at all and we just\n+//! provide a fallback implementation as some versions of Android we support\n+//! don't have the function.\n+//!\n+//! You'll find more details below about why each compatibility shim is needed.\n+\n+#![cfg(target_os = \"android\")]\n+\n+use libc::{c_int, sighandler_t};\n+\n+use io;\n+use sys::cvt_r;\n+\n+// The `log2` and `log2f` functions apparently appeared in android-18, or at\n+// least you can see they're not present in the android-17 header [1] and they\n+// are present in android-18 [2].\n+//\n+// [1]: https://chromium.googlesource.com/android_tools/+/20ee6d20/ndk/platforms\n+//                                       /android-17/arch-arm/usr/include/math.h\n+// [2]: https://chromium.googlesource.com/android_tools/+/20ee6d20/ndk/platforms\n+//                                       /android-18/arch-arm/usr/include/math.h\n+//\n+// Note that these shims are likely less precise than directly calling `log2`,\n+// but hopefully that should be enough for now...\n+//\n+// Note that mathematically, for any arbitrary `y`:\n+//\n+//      log_2(x) = log_y(x) / log_y(2)\n+//               = log_y(x) / (1 / log_2(y))\n+//               = log_y(x) * log_2(y)\n+//\n+// Hence because `ln` (log_e) is available on all Android we just choose `y = e`\n+// and get:\n+//\n+//      log_2(x) = ln(x) * log_2(e)\n+\n+#[cfg(not(test))]\n+pub fn log2f32(f: f32) -> f32 {\n+    f.ln() * ::f32::consts::LOG2_E\n+}\n+\n+#[cfg(not(test))]\n+pub fn log2f64(f: f64) -> f64 {\n+    f.ln() * ::f64::consts::LOG2_E\n+}\n+\n+// Back in the day [1] the `signal` function was just an inline wrapper\n+// around `bsd_signal`, but starting in API level android-20 the `signal`\n+// symbols was introduced [2]. Finally, in android-21 the API `bsd_signal` was\n+// removed [3].\n+//\n+// Basically this means that if we want to be binary compatible with multiple\n+// Android releases (oldest being 9 and newest being 21) then we need to check\n+// for both symbols and not actually link against either.\n+//\n+// [1]: https://chromium.googlesource.com/android_tools/+/20ee6d20/ndk/platforms\n+//                                       /android-18/arch-arm/usr/include/signal.h\n+// [2]: https://chromium.googlesource.com/android_tools/+/fbd420/ndk_experimental\n+//                                       /platforms/android-20/arch-arm\n+//                                       /usr/include/signal.h\n+// [3]: https://chromium.googlesource.com/android_tools/+/20ee6d/ndk/platforms\n+//                                       /android-21/arch-arm/usr/include/signal.h\n+pub unsafe fn signal(signum: c_int, handler: sighandler_t) -> sighandler_t {\n+    weak!(fn signal(c_int, sighandler_t) -> sighandler_t);\n+    weak!(fn bsd_signal(c_int, sighandler_t) -> sighandler_t);\n+\n+    let f = signal.get().or_else(|| bsd_signal.get());\n+    let f = f.expect(\"neither `signal` nor `bsd_signal` symbols found\");\n+    f(signum, handler)\n+}\n+\n+// The `ftruncate64` symbol apparently appeared in android-12, so we do some\n+// dynamic detection to see if we can figure out whether `ftruncate64` exists.\n+//\n+// If it doesn't we just fall back to `ftruncate`, generating an error for\n+// too-large values.\n+pub fn ftruncate64(fd: c_int, size: u64) -> io::Result<()> {\n+    weak!(fn ftruncate64(c_int, i64) -> c_int);\n+\n+    extern {\n+        fn ftruncate(fd: c_int, off: i32) -> c_int;\n+    }\n+\n+    unsafe {\n+        match ftruncate64.get() {\n+            Some(f) => cvt_r(|| f(fd, size as i64)).map(|_| ()),\n+            None => {\n+                if size > i32::max_value() as u64 {\n+                    Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                                       \"cannot truncate >2GB\"))\n+                } else {\n+                    cvt_r(|| ftruncate(fd, size as i32)).map(|_| ())\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "0969a59ea433813e9cc0482bee4b87260089761a", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c31e2e77ed955faafffe7b22859f045cc1e5deec/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c31e2e77ed955faafffe7b22859f045cc1e5deec/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=c31e2e77ed955faafffe7b22859f045cc1e5deec", "patch": "@@ -27,7 +27,7 @@ use sys_common::{AsInner, FromInner};\n #[cfg(any(target_os = \"linux\", target_os = \"emscripten\"))]\n use libc::{stat64, fstat64, lstat64, off64_t, ftruncate64, lseek64, dirent64, readdir64_r, open64};\n #[cfg(target_os = \"android\")]\n-use libc::{stat as stat64, fstat as fstat64, lstat as lstat64, off64_t, ftruncate64, lseek64,\n+use libc::{stat as stat64, fstat as fstat64, lstat as lstat64, off64_t, lseek64,\n            dirent as dirent64, open as open64};\n #[cfg(not(any(target_os = \"linux\",\n               target_os = \"emscripten\",\n@@ -475,10 +475,13 @@ impl File {\n     }\n \n     pub fn truncate(&self, size: u64) -> io::Result<()> {\n-        cvt_r(|| unsafe {\n+        #[cfg(target_os = \"android\")]\n+        return ::sys::android::ftruncate64(self.0.raw(), size);\n+\n+        #[cfg(not(target_os = \"android\"))]\n+        return cvt_r(|| unsafe {\n             ftruncate64(self.0.raw(), size as off64_t)\n-        })?;\n-        Ok(())\n+        }).map(|_| ());\n     }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {"}, {"sha": "12a877f7478204feb105c8ee78b51c11b4499efb", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 2, "deletions": 30, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c31e2e77ed955faafffe7b22859f045cc1e5deec/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c31e2e77ed955faafffe7b22859f045cc1e5deec/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=c31e2e77ed955faafffe7b22859f045cc1e5deec", "patch": "@@ -31,6 +31,7 @@ use ops::Neg;\n #[macro_use]\n pub mod weak;\n \n+pub mod android;\n pub mod backtrace;\n pub mod condvar;\n pub mod ext;\n@@ -91,37 +92,8 @@ pub fn init() {\n     unsafe fn reset_sigpipe() {}\n }\n \n-// Currently the minimum supported Android version of the standard library is\n-// API level 18 (android-18). Back in those days [1] the `signal` function was\n-// just an inline wrapper around `bsd_signal`, but starting in API level\n-// android-20 the `signal` symbols was introduced [2]. Finally, in android-21\n-// the API `bsd_signal` was removed [3].\n-//\n-// Basically this means that if we want to be binary compatible with multiple\n-// Android releases (oldest being 18 and newest being 21) then we need to check\n-// for both symbols and not actually link against either.\n-//\n-// Note that if we're not on android we just link against the `android` symbol\n-// itself.\n-//\n-// [1]: https://chromium.googlesource.com/android_tools/+/20ee6d20/ndk/platforms\n-//                                       /android-18/arch-arm/usr/include/signal.h\n-// [2]: https://chromium.googlesource.com/android_tools/+/fbd420/ndk_experimental\n-//                                       /platforms/android-20/arch-arm\n-//                                       /usr/include/signal.h\n-// [3]: https://chromium.googlesource.com/android_tools/+/20ee6d/ndk/platforms\n-//                                       /android-21/arch-arm/usr/include/signal.h\n #[cfg(target_os = \"android\")]\n-unsafe fn signal(signum: libc::c_int,\n-                 handler: libc::sighandler_t) -> libc::sighandler_t {\n-    weak!(fn signal(libc::c_int, libc::sighandler_t) -> libc::sighandler_t);\n-    weak!(fn bsd_signal(libc::c_int, libc::sighandler_t) -> libc::sighandler_t);\n-\n-    let f = signal.get().or_else(|| bsd_signal.get());\n-    let f = f.expect(\"neither `signal` nor `bsd_signal` symbols found\");\n-    f(signum, handler)\n-}\n-\n+pub use sys::android::signal;\n #[cfg(not(target_os = \"android\"))]\n pub use libc::signal;\n "}]}