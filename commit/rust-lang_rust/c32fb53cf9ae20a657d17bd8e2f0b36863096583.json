{"sha": "c32fb53cf9ae20a657d17bd8e2f0b36863096583", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzMmZiNTNjZjlhZTIwYTY1N2QxN2JkOGUyZjBiMzY4NjMwOTY1ODM=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-09T14:44:58Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-10T13:02:54Z"}, "message": "std: remove str::{len, slice, is_empty} in favour of methods.", "tree": {"sha": "928280b4bfcde6b9765de76f956624a735eafde9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/928280b4bfcde6b9765de76f956624a735eafde9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c32fb53cf9ae20a657d17bd8e2f0b36863096583", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c32fb53cf9ae20a657d17bd8e2f0b36863096583", "html_url": "https://github.com/rust-lang/rust/commit/c32fb53cf9ae20a657d17bd8e2f0b36863096583", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c32fb53cf9ae20a657d17bd8e2f0b36863096583/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b29cd22bce6325a60788ab84f989bd2e82fcaaf4", "url": "https://api.github.com/repos/rust-lang/rust/commits/b29cd22bce6325a60788ab84f989bd2e82fcaaf4", "html_url": "https://github.com/rust-lang/rust/commit/b29cd22bce6325a60788ab84f989bd2e82fcaaf4"}], "stats": {"total": 392, "additions": 185, "deletions": 207}, "files": [{"sha": "6d586c9b201c5b2e5d5dc038605aea117ab616f2", "filename": "doc/rust.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c32fb53cf9ae20a657d17bd8e2f0b36863096583/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/c32fb53cf9ae20a657d17bd8e2f0b36863096583/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=c32fb53cf9ae20a657d17bd8e2f0b36863096583", "patch": "@@ -803,7 +803,7 @@ An example of `use` declarations:\n \n ~~~~\n use std::float::sin;\n-use std::str::{slice, contains};\n+use std::str::{from_chars, contains};\n use std::option::Some;\n \n fn main() {\n@@ -814,8 +814,8 @@ fn main() {\n     info!(Some(1.0));\n \n     // Equivalent to\n-    // 'info!(std::str::contains(std::str::slice(\"foo\", 0, 1), \"oo\"));'\n-    info!(contains(slice(\"foo\", 0, 1), \"oo\"));\n+    // 'info!(std::str::contains(std::str::from_chars(&['f','o','o']), \"oo\"));'\n+    info!(contains(from_chars(&['f','o','o']), \"oo\"));\n }\n ~~~~\n "}, {"sha": "575df0268d6cbced6701388eab7a826fad63d3ff", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=c32fb53cf9ae20a657d17bd8e2f0b36863096583", "patch": "@@ -33,13 +33,13 @@ fn parse_expected(line_num: uint, line: ~str) -> ~[ExpectedError] {\n     let mut idx;\n     match str::find_str(line, error_tag) {\n       None => return ~[],\n-      Some(nn) => { idx = (nn as uint) + str::len(error_tag); }\n+      Some(nn) => { idx = (nn as uint) + error_tag.len(); }\n     }\n \n     // \"//~^^^ kind msg\" denotes a message expected\n     // three lines above current line:\n     let mut adjust_line = 0u;\n-    let len = str::len(line);\n+    let len = line.len();\n     while idx < len && line[idx] == ('^' as u8) {\n         adjust_line += 1u;\n         idx += 1u;\n@@ -52,12 +52,12 @@ fn parse_expected(line_num: uint, line: ~str) -> ~[ExpectedError] {\n \n     // FIXME: #4318 Instead of to_ascii and to_str_ascii, could use\n     // to_ascii_consume and to_str_consume to not do a unnecessary copy.\n-    let kind = str::slice(line, start_kind, idx);\n+    let kind = line.slice(start_kind, idx);\n     let kind = kind.to_ascii().to_lower().to_str_ascii();\n \n     // Extract msg:\n     while idx < len && line[idx] == (' ' as u8) { idx += 1u; }\n-    let msg = str::slice(line, idx, len).to_owned();\n+    let msg = line.slice(idx, len).to_owned();\n \n     debug!(\"line=%u kind=%s msg=%s\", line_num - adjust_line, kind, msg);\n "}, {"sha": "c61adff006303f2db82e926e64e6fac0d6e8d8b2", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=c32fb53cf9ae20a657d17bd8e2f0b36863096583", "patch": "@@ -177,8 +177,8 @@ fn parse_name_value_directive(line: &str,\n     let keycolon = directive + \":\";\n     match str::find_str(line, keycolon) {\n         Some(colon) => {\n-            let value = str::slice(line, colon + str::len(keycolon),\n-                                   str::len(line)).to_owned();\n+            let value = line.slice(colon + keycolon.len(),\n+                                   line.len()).to_owned();\n             debug!(\"%s: %s\", directive,  value);\n             Some(value)\n         }"}, {"sha": "111de53052cd6c52019be5948b3260594bc3c939", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=c32fb53cf9ae20a657d17bd8e2f0b36863096583", "patch": "@@ -247,7 +247,7 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n             let mut names;\n             let mut i_arg = None;\n             if cur[1] == '-' as u8 {\n-                let tail = str::slice(cur, 2, curlen);\n+                let tail = cur.slice(2, curlen);\n                 let tail_eq: ~[&str] = tail.split_iter('=').collect();\n                 if tail_eq.len() <= 1 {\n                     names = ~[Long(tail.to_owned())];"}, {"sha": "9026dc25b2d93d8b55011bb12e3be16716992396", "filename": "src/libextra/net_tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibextra%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibextra%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_tcp.rs?ref=c32fb53cf9ae20a657d17bd8e2f0b36863096583", "patch": "@@ -1809,7 +1809,7 @@ mod test {\n     }\n \n     fn buf_write<W:io::Writer>(w: &W, val: &str) {\n-        debug!(\"BUF_WRITE: val len %?\", str::len(val));\n+        debug!(\"BUF_WRITE: val len %?\", val.len());\n         do str::byte_slice(val) |b_slice| {\n             debug!(\"BUF_WRITE: b_slice len %?\",\n                             b_slice.len());"}, {"sha": "6fd6fa3acd91ba9c9eeb01c9dcc331f42ade644b", "filename": "src/libextra/net_url.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibextra%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibextra%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_url.rs?ref=c32fb53cf9ae20a657d17bd8e2f0b36863096583", "patch": "@@ -291,7 +291,7 @@ pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<~str, ~[~str]> {\n \n \n fn split_char_first(s: &str, c: char) -> (~str, ~str) {\n-    let len = str::len(s);\n+    let len = s.len();\n     let mut index = len;\n     let mut mat = 0;\n     do io::with_str_reader(s) |rdr| {\n@@ -307,16 +307,16 @@ fn split_char_first(s: &str, c: char) -> (~str, ~str) {\n         }\n     }\n     if index+mat == len {\n-        return (str::slice(s, 0, index).to_owned(), ~\"\");\n+        return (s.slice(0, index).to_owned(), ~\"\");\n     } else {\n-        return (str::slice(s, 0, index).to_owned(),\n-             str::slice(s, index + mat, str::len(s)).to_owned());\n+        return (s.slice(0, index).to_owned(),\n+             s.slice(index + mat, s.len()).to_owned());\n     }\n }\n \n fn userinfo_from_str(uinfo: &str) -> UserInfo {\n     let (user, p) = split_char_first(uinfo, ':');\n-    let pass = if str::len(p) == 0 {\n+    let pass = if p.is_empty() {\n         None\n     } else {\n         Some(p)\n@@ -333,7 +333,7 @@ fn userinfo_to_str(userinfo: &UserInfo) -> ~str {\n \n fn query_from_str(rawquery: &str) -> Query {\n     let mut query: Query = ~[];\n-    if str::len(rawquery) != 0 {\n+    if !rawquery.is_empty() {\n         for rawquery.split_iter('&').advance |p| {\n             let (k, v) = split_char_first(p, '=');\n             query.push((decode_component(k), decode_component(v)));\n@@ -373,7 +373,7 @@ pub fn get_scheme(rawurl: &str) -> Result<(~str, ~str), ~str> {\n                 return Err(~\"url: Scheme cannot be empty.\");\n             } else {\n                 return Ok((rawurl.slice(0,i).to_owned(),\n-                                rawurl.slice(i+1,str::len(rawurl)).to_owned()));\n+                                rawurl.slice(i+1,rawurl.len()).to_owned()));\n             }\n           }\n           _ => {\n@@ -475,7 +475,7 @@ fn get_authority(rawurl: &str) ->\n               }\n               Ip6Host => {\n                 if colon_count > 7 {\n-                    host = str::slice(rawurl, begin, i).to_owned();\n+                    host = rawurl.slice(begin, i).to_owned();\n                     pos = i;\n                     st = InPort;\n                 }\n@@ -492,13 +492,13 @@ fn get_authority(rawurl: &str) ->\n             colon_count = 0; // reset count\n             match st {\n               Start => {\n-                let user = str::slice(rawurl, begin, i).to_owned();\n+                let user = rawurl.slice(begin, i).to_owned();\n                 userinfo = Some(UserInfo::new(user, None));\n                 st = InHost;\n               }\n               PassHostPort => {\n-                let user = str::slice(rawurl, begin, pos).to_owned();\n-                let pass = str::slice(rawurl, pos+1, i).to_owned();\n+                let user = rawurl.slice(begin, pos).to_owned();\n+                let pass = rawurl.slice(pos+1, i).to_owned();\n                 userinfo = Some(UserInfo::new(user, Some(pass)));\n                 st = InHost;\n               }\n@@ -529,39 +529,39 @@ fn get_authority(rawurl: &str) ->\n     match st {\n       Start => {\n         if host_is_end_plus_one() {\n-            host = str::slice(rawurl, begin, end+1).to_owned();\n+            host = rawurl.slice(begin, end+1).to_owned();\n         } else {\n-            host = str::slice(rawurl, begin, end).to_owned();\n+            host = rawurl.slice(begin, end).to_owned();\n         }\n       }\n       PassHostPort | Ip6Port => {\n         if in != Digit {\n             return Err(~\"Non-digit characters in port.\");\n         }\n-        host = str::slice(rawurl, begin, pos).to_owned();\n-        port = Some(str::slice(rawurl, pos+1, end).to_owned());\n+        host = rawurl.slice(begin, pos).to_owned();\n+        port = Some(rawurl.slice(pos+1, end).to_owned());\n       }\n       Ip6Host | InHost => {\n-        host = str::slice(rawurl, begin, end).to_owned();\n+        host = rawurl.slice(begin, end).to_owned();\n       }\n       InPort => {\n         if in != Digit {\n             return Err(~\"Non-digit characters in port.\");\n         }\n-        port = Some(str::slice(rawurl, pos+1, end).to_owned());\n+        port = Some(rawurl.slice(pos+1, end).to_owned());\n       }\n     }\n \n     let rest = if host_is_end_plus_one() { ~\"\" }\n-    else { str::slice(rawurl, end, len).to_owned() };\n+    else { rawurl.slice(end, len).to_owned() };\n     return Ok((userinfo, host, port, rest));\n }\n \n \n // returns the path and unparsed part of url, or an error\n fn get_path(rawurl: &str, authority: bool) ->\n     Result<(~str, ~str), ~str> {\n-    let len = str::len(rawurl);\n+    let len = rawurl.len();\n     let mut end = len;\n     for rawurl.iter().enumerate().advance |(i,c)| {\n         match c {\n@@ -585,25 +585,25 @@ fn get_path(rawurl: &str, authority: bool) ->\n         }\n     }\n \n-    return Ok((decode_component(str::slice(rawurl, 0, end)),\n-                    str::slice(rawurl, end, len).to_owned()));\n+    return Ok((decode_component(rawurl.slice(0, end)),\n+                    rawurl.slice(end, len).to_owned()));\n }\n \n // returns the parsed query and the fragment, if present\n fn get_query_fragment(rawurl: &str) ->\n     Result<(Query, Option<~str>), ~str> {\n     if !str::starts_with(rawurl, \"?\") {\n         if str::starts_with(rawurl, \"#\") {\n-            let f = decode_component(str::slice(rawurl,\n+            let f = decode_component(rawurl.slice(\n                                                 1,\n-                                                str::len(rawurl)));\n+                                                rawurl.len()));\n             return Ok((~[], Some(f)));\n         } else {\n             return Ok((~[], None));\n         }\n     }\n-    let (q, r) = split_char_first(str::slice(rawurl, 1, rawurl.len()), '#');\n-    let f = if str::len(r) != 0 {\n+    let (q, r) = split_char_first(rawurl.slice(1, rawurl.len()), '#');\n+    let f = if r.len() != 0 {\n         Some(decode_component(r)) } else { None };\n     return Ok((query_from_str(q), f));\n }"}, {"sha": "1b58aa68f776f09196ab0d25153a437883b68915", "filename": "src/libextra/rope.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibextra%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibextra%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frope.rs?ref=c32fb53cf9ae20a657d17bd8e2f0b36863096583", "patch": "@@ -71,7 +71,7 @@ pub fn empty() -> Rope {\n  * * the function runs in linear time.\n  */\n pub fn of_str(str: @~str) -> Rope {\n-    return of_substr(str, 0u, str::len(*str));\n+    return of_substr(str, 0u, str.len());\n }\n \n /**\n@@ -98,7 +98,7 @@ pub fn of_str(str: @~str) -> Rope {\n  */\n pub fn of_substr(str: @~str, byte_offset: uint, byte_len: uint) -> Rope {\n     if byte_len == 0u { return node::Empty; }\n-    if byte_offset + byte_len  > str::len(*str) { fail!(); }\n+    if byte_offset + byte_len  > str.len() { fail!(); }\n     return node::Content(node::of_substr(str, byte_offset, byte_len));\n }\n \n@@ -657,7 +657,7 @@ pub mod node {\n      * the length of `str`.\n      */\n     pub fn of_str(str: @~str) -> @Node {\n-        return of_substr(str, 0u, str::len(*str));\n+        return of_substr(str, 0u, str.len());\n     }\n \n     /**\n@@ -705,7 +705,7 @@ pub mod node {\n      */\n     pub fn of_substr_unsafer(str: @~str, byte_start: uint, byte_len: uint,\n                              char_len: uint) -> @Node {\n-        assert!((byte_start + byte_len <= str::len(*str)));\n+        assert!((byte_start + byte_len <= str.len()));\n         let candidate = @Leaf(Leaf {\n             byte_offset: byte_start,\n             byte_len: byte_len,\n@@ -1292,9 +1292,7 @@ mod tests {\n                     node::Leaf(x) => {\n                         str::push_str(\n                             str,\n-                            str::slice(\n-                                *x.content, x.byte_offset,\n-                                x.byte_offset + x.byte_len));\n+                            x.content.slice(x.byte_offset, x.byte_offset + x.byte_len));\n                     }\n                     node::Concat(ref x) => {\n                         aux(str, x.left);\n@@ -1340,7 +1338,7 @@ mod tests {\n         assert!(rope_to_string(r) == *sample);\n \n         let mut string_iter = 0u;\n-        let string_len = str::len(*sample);\n+        let string_len = sample.len();\n         let mut rope_iter = iterator::char::start(r);\n         let mut equal = true;\n         while equal {"}, {"sha": "658621e25bdf1976ecc9bead3e42a6a2035665ed", "filename": "src/libextra/sha1.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibextra%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibextra%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsha1.rs?ref=c32fb53cf9ae20a657d17bd8e2f0b36863096583", "patch": "@@ -281,7 +281,6 @@ pub fn sha1() -> @Sha1 {\n mod tests {\n     use sha1;\n \n-    use core::str;\n     use core::vec;\n \n     #[test]\n@@ -396,7 +395,7 @@ mod tests {\n \n         // Test that it works when accepting the message in pieces\n         for tests.each |t| {\n-            let len = str::len(t.input);\n+            let len = t.input.len();\n             let mut left = len;\n             while left > 0u {\n                 let take = (left + 1u) / 2u;"}, {"sha": "f545b28c5072b0e296e4a64a20fa07337629c4a7", "filename": "src/libextra/time.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=c32fb53cf9ae20a657d17bd8e2f0b36863096583", "patch": "@@ -279,7 +279,7 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n             match strs[i] { // can't use let due to stage0 bugs\n                 (ref needle, value) => {\n                     if match_str(ss, pos, *needle) {\n-                        return Some((value, pos + str::len(*needle)));\n+                        return Some((value, pos + needle.len()));\n                     }\n                 }\n             }\n@@ -598,7 +598,7 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n                 // It's odd, but to maintain compatibility with c's\n                 // strptime we ignore the timezone.\n                 let mut pos = pos;\n-                let len = str::len(s);\n+                let len = s.len();\n                 while pos < len {\n                     let range = str::char_range_at(s, pos);\n                     pos = range.next;\n@@ -651,7 +651,7 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n             tm_nsec: 0_i32,\n         };\n         let mut pos = 0u;\n-        let len = str::len(s);\n+        let len = s.len();\n         let mut result = Err(~\"Invalid time\");\n \n         while !rdr.eof() && pos < len {"}, {"sha": "bd72f0891ddfb27582356d4aa17e995e04af1bba", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=c32fb53cf9ae20a657d17bd8e2f0b36863096583", "patch": "@@ -376,7 +376,7 @@ pub fn check_variants_T<T:Copy>(crate: @ast::crate,\n \n pub fn last_part(filename: ~str) -> ~str {\n     let ix = str::rfind_char(filename, '/').get();\n-    str::slice(filename, ix + 1u, str::len(filename) - 3u).to_owned()\n+    filename.slice(ix + 1u, filename.len() - 3u).to_owned()\n }\n \n pub enum happiness {\n@@ -434,7 +434,7 @@ pub fn check_running(exe_filename: &Path) -> happiness {\n         \"/Users/jruderman/scripts/timed_run_rust_program.py\",\n         [exe_filename.to_str()]);\n     let comb = str::from_bytes(p.output) + \"\\n\" + str::from_bytes(p.error);\n-    if str::len(comb) > 1u {\n+    if comb.len() > 1u {\n         error!(\"comb comb comb: %?\", comb);\n     }\n \n@@ -712,4 +712,3 @@ pub mod core {\n     pub use std::cmp;\n     pub use std::sys;\n }\n-"}, {"sha": "fa9e2c9a724133df9a440f0e9431d31d7731ffb5", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=c32fb53cf9ae20a657d17bd8e2f0b36863096583", "patch": "@@ -686,7 +686,7 @@ pub fn mangle(sess: Session, ss: path) -> ~str {\n     for ss.each |s| {\n         match *s { path_name(s) | path_mod(s) => {\n           let sani = sanitize(*sess.str_of(s));\n-          n += fmt!(\"%u%s\", str::len(sani), sani);\n+          n += fmt!(\"%u%s\", sani.len(), sani);\n         } }\n     }\n     n += \"E\"; // End name-sequence."}, {"sha": "6314cb6269768d666117bfc7d9a9b8d21edf1f2b", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=c32fb53cf9ae20a657d17bd8e2f0b36863096583", "patch": "@@ -186,7 +186,7 @@ fn get_rustpkg_lib_path_nearest() -> Result<Path, ~str> {\n // On Unix should be \"lib\", on windows \"bin\"\n pub fn libdir() -> ~str {\n    let libdir = env!(\"CFG_LIBDIR\");\n-   if str::is_empty(libdir) {\n+   if libdir.is_empty() {\n       fail!(\"rustc compiled without CFG_LIBDIR environment variable\");\n    }\n    libdir.to_owned()"}, {"sha": "74e001f4e1356224706087121eb87d3464ead119", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=c32fb53cf9ae20a657d17bd8e2f0b36863096583", "patch": "@@ -849,14 +849,14 @@ fn check_item_non_camel_case_types(cx: &Context, it: @ast::item) {\n \n     fn ident_without_trailing_underscores<'r>(ident: &'r str) -> &'r str {\n         match str::rfind(ident, |c| c != '_') {\n-            Some(idx) => str::slice(ident, 0, idx + 1),\n+            Some(idx) => ident.slice(0, idx + 1),\n             None => ident, // all underscores\n         }\n     }\n \n     fn ident_without_leading_underscores<'r>(ident: &'r str) -> &'r str {\n         match str::find(ident, |c| c != '_') {\n-            Some(idx) => str::slice(ident, idx, ident.len()),\n+            Some(idx) => ident.slice(idx, ident.len()),\n             None => ident // all underscores\n         }\n     }"}, {"sha": "25736afd38a0dd394cfb576dc14b3722437d65c4", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=c32fb53cf9ae20a657d17bd8e2f0b36863096583", "patch": "@@ -2575,7 +2575,7 @@ impl Resolver {\n                     if \"???\" == module_name {\n                         let span = span {\n                             lo: span.lo,\n-                            hi: span.lo + BytePos(str::len(*segment_name)),\n+                            hi: span.lo + BytePos(segment_name.len()),\n                             expn_info: span.expn_info,\n                         };\n                         self.session.span_err(span,\n@@ -4830,7 +4830,7 @@ impl Resolver {\n \n         if values.len() > 0 &&\n             values[smallest] != uint::max_value &&\n-            values[smallest] < str::len(name) + 2 &&\n+            values[smallest] < name.len() + 2 &&\n             values[smallest] <= max_distance &&\n             maybes[smallest] != name.to_owned() {\n "}, {"sha": "03ae32cf0a6cb836c63e75fbd5b46c1f09c951a4", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=c32fb53cf9ae20a657d17bd8e2f0b36863096583", "patch": "@@ -1221,7 +1221,7 @@ pub fn C_estr_slice(cx: @CrateContext, s: @~str) -> ValueRef {\n pub fn C_postr(s: &str) -> ValueRef {\n     unsafe {\n         return do str::as_c_str(s) |buf| {\n-            llvm::LLVMConstString(buf, str::len(s) as c_uint, False)\n+            llvm::LLVMConstString(buf, s.len() as c_uint, False)\n         };\n     }\n }"}, {"sha": "bc863fb363fe914b26fe45016c0f15816566935f", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=c32fb53cf9ae20a657d17bd8e2f0b36863096583", "patch": "@@ -245,8 +245,8 @@ fn get_cache(cx: @CrateContext) -> metadata_cache {\n \n fn get_file_path_and_dir(work_dir: &str, full_path: &str) -> (~str, ~str) {\n     (if str::starts_with(full_path, work_dir) {\n-        str::slice(full_path, str::len(work_dir) + 1u,\n-                   str::len(full_path)).to_owned()\n+        full_path.slice(work_dir.len() + 1u,\n+                   full_path.len()).to_owned()\n     } else {\n         full_path.to_owned()\n     }, work_dir.to_owned())"}, {"sha": "c72bf5c7f0b21661680833a4bedcbe4320a4358f", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=c32fb53cf9ae20a657d17bd8e2f0b36863096583", "patch": "@@ -485,7 +485,7 @@ pub fn parameterized(cx: ctxt,\n \n pub fn ty_to_short_str(cx: ctxt, typ: t) -> ~str {\n     let mut s = encoder::encoded_ty(cx, typ);\n-    if str::len(s) >= 32u { s = str::slice(s, 0u, 32u).to_owned(); }\n+    if s.len() >= 32u { s = s.slice(0u, 32u).to_owned(); }\n     return s;\n }\n "}, {"sha": "f66012696ae6ba425cfe17f580100a179e9b526c", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=c32fb53cf9ae20a657d17bd8e2f0b36863096583", "patch": "@@ -94,7 +94,7 @@ fn parse_desc(desc: ~str) -> Option<~str> {\n \n     match first_sentence(copy desc) {\n       Some(first_sentence) => {\n-        if str::len(first_sentence) <= max_brief_len {\n+        if first_sentence.len() <= max_brief_len {\n             Some(first_sentence)\n         } else {\n             None\n@@ -133,7 +133,7 @@ fn first_sentence_(s: &str) -> ~str {\n     };\n     match idx {\n         Some(idx) if idx > 2u => {\n-            str::to_owned(str::slice(s, 0, idx - 1))\n+            str::to_owned(s.slice(0, idx - 1))\n         }\n         _ => {\n             if str::ends_with(s, \".\") {\n@@ -165,7 +165,7 @@ pub fn paragraphs(s: &str) -> ~[~str] {\n \n             whitespace_lines = 0;\n \n-            accum = if str::is_empty(accum) {\n+            accum = if accum.is_empty() {\n                 copy *line\n             } else {\n                 accum + \"\\n\" + *line"}, {"sha": "61a8d11af7f7b8a6b2bdd0a46f16137922ac9ed9", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=c32fb53cf9ae20a657d17bd8e2f0b36863096583", "patch": "@@ -154,7 +154,7 @@ fn sectionalize(desc: Option<~str>) -> (Option<~str>, ~[doc::Section]) {\n \n fn parse_header(line: ~str) -> Option<~str> {\n     if str::starts_with(line, \"# \") {\n-        Some(str::slice(line, 2u, str::len(line)).to_owned())\n+        Some(line.slice(2u, line.len()).to_owned())\n     } else {\n         None\n     }"}, {"sha": "ba6f7184f6895cf31e639cd02c41e3ba54c01645", "filename": "src/librustdoc/unindent_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibrustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibrustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Funindent_pass.rs?ref=c32fb53cf9ae20a657d17bd8e2f0b36863096583", "patch": "@@ -83,8 +83,8 @@ fn unindent(s: &str) -> ~str {\n             if str::is_whitespace(*line) {\n                 copy *line\n             } else {\n-                assert!(str::len(*line) >= min_indent);\n-                str::slice(*line, min_indent, str::len(*line)).to_owned()\n+                assert!(line.len() >= min_indent);\n+                line.slice(min_indent, line.len()).to_owned()\n             }\n         };\n         str::connect(unindented, \"\\n\")"}, {"sha": "8ec3a4cdd811520b280f424665f06c192d74a8c2", "filename": "src/libstd/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=c32fb53cf9ae20a657d17bd8e2f0b36863096583", "patch": "@@ -748,7 +748,7 @@ impl<T:Reader> ReaderUtil for T {\n             if self.eof() && line.is_empty() { break; }\n \n             // trim the \\n, so that each_line is consistent with read_line\n-            let n = str::len(line);\n+            let n = line.len();\n             if line[n-1] == '\\n' as u8 {\n                 unsafe { str::raw::set_len(&mut line, n-1); }\n             }"}, {"sha": "ab8965a679691ba01e1945db6f197f33bfa46397", "filename": "src/libstd/os.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=c32fb53cf9ae20a657d17bd8e2f0b36863096583", "patch": "@@ -525,7 +525,7 @@ pub fn self_exe_path() -> Option<Path> {\n  */\n pub fn homedir() -> Option<Path> {\n     return match getenv(\"HOME\") {\n-        Some(ref p) => if !str::is_empty(*p) {\n+        Some(ref p) => if !p.is_empty() {\n           Some(Path(*p))\n         } else {\n           secondary()\n@@ -541,7 +541,7 @@ pub fn homedir() -> Option<Path> {\n     #[cfg(windows)]\n     fn secondary() -> Option<Path> {\n         do getenv(~\"USERPROFILE\").chain |p| {\n-            if !str::is_empty(p) {\n+            if !p.is_empty() {\n                 Some(Path(p))\n             } else {\n                 None\n@@ -566,7 +566,7 @@ pub fn tmpdir() -> Path {\n     fn getenv_nonempty(v: &str) -> Option<Path> {\n         match getenv(v) {\n             Some(x) =>\n-                if str::is_empty(x) {\n+                if x.is_empty() {\n                     None\n                 } else {\n                     Some(Path(x))\n@@ -1449,6 +1449,7 @@ mod tests {\n     use rand;\n     use run;\n     use str;\n+    use str::StrSlice;\n     use vec;\n     use libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n \n@@ -1606,7 +1607,7 @@ mod tests {\n \n     #[test]\n     fn tmpdir() {\n-        assert!(!str::is_empty(os::tmpdir().to_str()));\n+        assert!(!os::tmpdir().to_str().is_empty());\n     }\n \n     // Issue #712\n@@ -1671,7 +1672,7 @@ mod tests {\n         unsafe {\n           let tempdir = getcwd(); // would like to use $TMPDIR,\n                                   // doesn't seem to work on Linux\n-          assert!((str::len(tempdir.to_str()) > 0u));\n+          assert!((tempdir.to_str().len() > 0u));\n           let in = tempdir.push(\"in.txt\");\n           let out = tempdir.push(\"out.txt\");\n \n@@ -1686,7 +1687,7 @@ mod tests {\n           let mut buf = str::to_bytes(s) + [0 as u8];\n           do vec::as_mut_buf(buf) |b, _len| {\n               assert!((libc::fwrite(b as *c_void, 1u as size_t,\n-                                   (str::len(s) + 1u) as size_t, ostream)\n+                                   (s.len() + 1u) as size_t, ostream)\n                       == buf.len() as size_t))\n           }\n           assert_eq!(libc::fclose(ostream), (0u as c_int));"}, {"sha": "b44e79f7d03be24d31dd3e4e182c796a00592cea", "filename": "src/libstd/str.rs", "status": "modified", "additions": 89, "deletions": 107, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=c32fb53cf9ae20a657d17bd8e2f0b36863096583", "patch": "@@ -110,7 +110,7 @@ pub fn from_bytes_slice<'a>(vector: &'a [u8]) -> &'a str {\n /// Copy a slice into a new unique str\n #[inline(always)]\n pub fn to_owned(s: &str) -> ~str {\n-    unsafe { raw::slice_bytes_owned(s, 0, len(s)) }\n+    unsafe { raw::slice_bytes_owned(s, 0, s.len()) }\n }\n \n impl ToStr for ~str {\n@@ -148,7 +148,7 @@ pub fn push_char(s: &mut ~str, ch: char) {\n         else if code < max_four_b { 4u }\n         else if code < max_five_b { 5u }\n         else { 6u };\n-        let len = len(*s);\n+        let len = s.len();\n         let new_len = len + nb;\n         reserve_at_least(&mut *s, new_len);\n         let off = len;\n@@ -453,7 +453,7 @@ Section: Adding to and removing from a string\n  * If the string does not contain any characters\n  */\n pub fn pop_char(s: &mut ~str) -> char {\n-    let end = len(*s);\n+    let end = s.len();\n     assert!(end > 0u);\n     let CharRange {ch, next} = char_range_at_reverse(*s, end);\n     unsafe { raw::set_len(s, next); }\n@@ -469,7 +469,7 @@ pub fn pop_char(s: &mut ~str) -> char {\n  */\n pub fn shift_char(s: &mut ~str) -> char {\n     let CharRange {ch, next} = char_range_at(*s, 0u);\n-    *s = unsafe { raw::slice_bytes_owned(*s, next, len(*s)) };\n+    *s = unsafe { raw::slice_bytes_owned(*s, next, s.len()) };\n     return ch;\n }\n \n@@ -485,7 +485,7 @@ pub fn shift_char(s: &mut ~str) -> char {\n #[inline]\n pub fn slice_shift_char<'a>(s: &'a str) -> (char, &'a str) {\n     let CharRange {ch, next} = char_range_at(s, 0u);\n-    let next_s = unsafe { raw::slice_bytes(s, next, len(s)) };\n+    let next_s = unsafe { raw::slice_bytes(s, next, s.len()) };\n     return (ch, next_s);\n }\n \n@@ -554,7 +554,7 @@ pub fn trim_chars<'a>(s: &'a str, chars_to_trim: &[char]) -> &'a str {\n pub fn trim_left<'a>(s: &'a str) -> &'a str {\n     match find(s, |c| !char::is_whitespace(c)) {\n       None => \"\",\n-      Some(first) => unsafe { raw::slice_bytes(s, first, len(s)) }\n+      Some(first) => unsafe { raw::slice_bytes(s, first, s.len()) }\n     }\n }\n \n@@ -584,7 +584,7 @@ Section: Transforming strings\n pub fn to_bytes(s: &str) -> ~[u8] {\n     unsafe {\n         let mut v: ~[u8] = ::cast::transmute(to_owned(s));\n-        vec::raw::set_len(&mut v, len(s));\n+        vec::raw::set_len(&mut v, s.len());\n         v\n     }\n }\n@@ -618,19 +618,7 @@ pub fn to_chars(s: &str) -> ~[char] {\n  * `begin`.\n  */\n pub fn substr<'a>(s: &'a str, begin: uint, n: uint) -> &'a str {\n-    slice(s, begin, begin + count_bytes(s, begin, n))\n-}\n-\n-/**\n- * Returns a slice of the given string from the byte range [`begin`..`end`)\n- *\n- * Fails when `begin` and `end` do not point to valid characters or beyond\n- * the last character of the string\n- */\n-pub fn slice<'a>(s: &'a str, begin: uint, end: uint) -> &'a str {\n-    assert!(is_char_boundary(s, begin));\n-    assert!(is_char_boundary(s, end));\n-    unsafe { raw::slice_bytes(s, begin, end) }\n+    s.slice(begin, begin + count_bytes(s, begin, n))\n }\n \n /// An iterator over the substrings of a string, separated by `sep`.\n@@ -724,7 +712,7 @@ impl<'self, Sep: StrCharSplitSeparator> Iterator<&'self str> for StrCharSplitIte\n // See Issue #1932 for why this is a naive search\n fn iter_matches<'a,'b>(s: &'a str, sep: &'b str,\n                        f: &fn(uint, uint) -> bool) -> bool {\n-    let (sep_len, l) = (len(sep), len(s));\n+    let (sep_len, l) = (sep.len(), s.len());\n     assert!(sep_len > 0u);\n     let mut (i, match_start, match_i) = (0u, 0u, 0u);\n \n@@ -759,7 +747,7 @@ fn iter_between_matches<'a,'b>(s: &'a str,\n         if !f(last_end, from) { return false; }\n         last_end = to;\n     }\n-    return f(last_end, len(s));\n+    return f(last_end, s.len());\n }\n \n /**\n@@ -889,7 +877,7 @@ pub fn each_split_within<'a>(ss: &'a str,\n     let mut state = A;\n \n     let mut cont = true;\n-    let slice: &fn() = || { cont = it(slice(ss, slice_start, last_end)) };\n+    let slice: &fn() = || { cont = it(ss.slice(slice_start, last_end)) };\n \n     let machine: &fn((uint, char)) -> bool = |(i, c)| {\n         let whitespace = if char::is_whitespace(c)       { Ws }       else { Cr };\n@@ -902,7 +890,7 @@ pub fn each_split_within<'a>(ss: &'a str,\n             (B, Cr, UnderLim) => { B }\n             (B, Cr, OverLim)  if (i - last_start + 1) > lim\n                               => fail!(\"word starting with %? longer than limit!\",\n-                                       self::slice(ss, last_start, i + 1)),\n+                                       ss.slice(last_start, i + 1)),\n             (B, Cr, OverLim)  => { slice(); slice_start = last_start; B }\n             (B, Ws, UnderLim) => { last_end = i; C }\n             (B, Ws, OverLim)  => { last_end = i; slice(); A }\n@@ -1178,7 +1166,7 @@ Section: Iterating through strings\n /// Apply a function to each character\n pub fn map(ss: &str, ff: &fn(char) -> char) -> ~str {\n     let mut result = ~\"\";\n-    reserve(&mut result, len(ss));\n+    reserve(&mut result, ss.len());\n     for ss.iter().advance |cc| {\n         str::push_char(&mut result, ff(cc));\n     }\n@@ -1203,7 +1191,7 @@ Section: Searching\n  * or `none` if there is no match\n  */\n pub fn find_char(s: &str, c: char) -> Option<uint> {\n-    find_char_between(s, c, 0u, len(s))\n+    find_char_between(s, c, 0u, s.len())\n }\n \n /**\n@@ -1223,11 +1211,11 @@ pub fn find_char(s: &str, c: char) -> Option<uint> {\n  *\n  * # Failure\n  *\n- * `start` must be less than or equal to `len(s)`. `start` must be the\n+ * `start` must be less than or equal to `s.len()`. `start` must be the\n  * index of a character boundary, as defined by `is_char_boundary`.\n  */\n pub fn find_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n-    find_char_between(s, c, start, len(s))\n+    find_char_between(s, c, start, s.len())\n }\n \n /**\n@@ -1248,14 +1236,14 @@ pub fn find_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n  * # Failure\n  *\n  * `start` must be less than or equal to `end` and `end` must be less than\n- * or equal to `len(s)`. `start` must be the index of a character boundary,\n+ * or equal to `s.len()`. `start` must be the index of a character boundary,\n  * as defined by `is_char_boundary`.\n  */\n pub fn find_char_between(s: &str, c: char, start: uint, end: uint)\n     -> Option<uint> {\n     if c < 128u as char {\n         assert!(start <= end);\n-        assert!(end <= len(s));\n+        assert!(end <= s.len());\n         let mut i = start;\n         let b = c as u8;\n         while i < end {\n@@ -1282,7 +1270,7 @@ pub fn find_char_between(s: &str, c: char, start: uint, end: uint)\n  * or `none` if there is no match\n  */\n pub fn rfind_char(s: &str, c: char) -> Option<uint> {\n-    rfind_char_between(s, c, len(s), 0u)\n+    rfind_char_between(s, c, s.len(), 0u)\n }\n \n /**\n@@ -1302,7 +1290,7 @@ pub fn rfind_char(s: &str, c: char) -> Option<uint> {\n  *\n  * # Failure\n  *\n- * `start` must be less than or equal to `len(s)`. `start` must be\n+ * `start` must be less than or equal to `s.len()`. `start` must be\n  * the index of a character boundary, as defined by `is_char_boundary`.\n  */\n pub fn rfind_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n@@ -1327,13 +1315,13 @@ pub fn rfind_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n  * # Failure\n  *\n  * `end` must be less than or equal to `start` and `start` must be less than\n- * or equal to `len(s)`. `start` must be the index of a character boundary,\n+ * or equal to `s.len()`. `start` must be the index of a character boundary,\n  * as defined by `is_char_boundary`.\n  */\n pub fn rfind_char_between(s: &str, c: char, start: uint, end: uint) -> Option<uint> {\n     if c < 128u as char {\n         assert!(start >= end);\n-        assert!(start <= len(s));\n+        assert!(start <= s.len());\n         let mut i = start;\n         let b = c as u8;\n         while i > end {\n@@ -1361,7 +1349,7 @@ pub fn rfind_char_between(s: &str, c: char, start: uint, end: uint) -> Option<ui\n  * or `none` if there is no match\n  */\n pub fn find(s: &str, f: &fn(char) -> bool) -> Option<uint> {\n-    find_between(s, 0u, len(s), f)\n+    find_between(s, 0u, s.len(), f)\n }\n \n /**\n@@ -1381,12 +1369,12 @@ pub fn find(s: &str, f: &fn(char) -> bool) -> Option<uint> {\n  *\n  * # Failure\n  *\n- * `start` must be less than or equal to `len(s)`. `start` must be the\n+ * `start` must be less than or equal to `s.len()`. `start` must be the\n  * index of a character boundary, as defined by `is_char_boundary`.\n  */\n pub fn find_from(s: &str, start: uint, f: &fn(char)\n     -> bool) -> Option<uint> {\n-    find_between(s, start, len(s), f)\n+    find_between(s, start, s.len(), f)\n }\n \n /**\n@@ -1408,12 +1396,12 @@ pub fn find_from(s: &str, start: uint, f: &fn(char)\n  * # Failure\n  *\n  * `start` must be less than or equal to `end` and `end` must be less than\n- * or equal to `len(s)`. `start` must be the index of a character\n+ * or equal to `s.len()`. `start` must be the index of a character\n  * boundary, as defined by `is_char_boundary`.\n  */\n pub fn find_between(s: &str, start: uint, end: uint, f: &fn(char) -> bool) -> Option<uint> {\n     assert!(start <= end);\n-    assert!(end <= len(s));\n+    assert!(end <= s.len());\n     assert!(is_char_boundary(s, start));\n     let mut i = start;\n     while i < end {\n@@ -1439,7 +1427,7 @@ pub fn find_between(s: &str, start: uint, end: uint, f: &fn(char) -> bool) -> Op\n  * or `none` if there is no match\n  */\n pub fn rfind(s: &str, f: &fn(char) -> bool) -> Option<uint> {\n-    rfind_between(s, len(s), 0u, f)\n+    rfind_between(s, s.len(), 0u, f)\n }\n \n /**\n@@ -1459,7 +1447,7 @@ pub fn rfind(s: &str, f: &fn(char) -> bool) -> Option<uint> {\n  *\n  * # Failure\n  *\n- * `start` must be less than or equal to `len(s)', `start` must be the\n+ * `start` must be less than or equal to `s.len()', `start` must be the\n  * index of a character boundary, as defined by `is_char_boundary`\n  */\n pub fn rfind_from(s: &str, start: uint, f: &fn(char) -> bool) -> Option<uint> {\n@@ -1485,12 +1473,12 @@ pub fn rfind_from(s: &str, start: uint, f: &fn(char) -> bool) -> Option<uint> {\n  * # Failure\n  *\n  * `end` must be less than or equal to `start` and `start` must be less\n- * than or equal to `len(s)`. `start` must be the index of a character\n+ * than or equal to `s.len()`. `start` must be the index of a character\n  * boundary, as defined by `is_char_boundary`\n  */\n pub fn rfind_between(s: &str, start: uint, end: uint, f: &fn(char) -> bool) -> Option<uint> {\n     assert!(start >= end);\n-    assert!(start <= len(s));\n+    assert!(start <= s.len());\n     assert!(is_char_boundary(s, start));\n     let mut i = start;\n     while i > end {\n@@ -1522,7 +1510,7 @@ fn match_at<'a,'b>(haystack: &'a str, needle: &'b str, at: uint) -> bool {\n  * or `none` if there is no match\n  */\n pub fn find_str<'a,'b>(haystack: &'a str, needle: &'b str) -> Option<uint> {\n-    find_str_between(haystack, needle, 0u, len(haystack))\n+    find_str_between(haystack, needle, 0u, haystack.len())\n }\n \n /**\n@@ -1542,13 +1530,13 @@ pub fn find_str<'a,'b>(haystack: &'a str, needle: &'b str) -> Option<uint> {\n  *\n  * # Failure\n  *\n- * `start` must be less than or equal to `len(s)`\n+ * `start` must be less than or equal to `s.len()`\n  */\n pub fn find_str_from<'a,'b>(haystack: &'a str,\n                             needle: &'b str,\n                             start: uint)\n                          -> Option<uint> {\n-    find_str_between(haystack, needle, start, len(haystack))\n+    find_str_between(haystack, needle, start, haystack.len())\n }\n \n /**\n@@ -1569,16 +1557,16 @@ pub fn find_str_from<'a,'b>(haystack: &'a str,\n  * # Failure\n  *\n  * `start` must be less than or equal to `end` and `end` must be less than\n- * or equal to `len(s)`.\n+ * or equal to `s.len()`.\n  */\n pub fn find_str_between<'a,'b>(haystack: &'a str,\n                                needle: &'b str,\n                                start: uint,\n                                end:uint)\n                             -> Option<uint> {\n     // See Issue #1932 for why this is a naive search\n-    assert!(end <= len(haystack));\n-    let needle_len = len(needle);\n+    assert!(end <= haystack.len());\n+    let needle_len = needle.len();\n     if needle_len == 0u { return Some(start); }\n     if needle_len > end { return None; }\n \n@@ -1624,7 +1612,7 @@ pub fn contains_char(haystack: &str, needle: char) -> bool {\n  * * needle - The string to look for\n  */\n pub fn starts_with<'a,'b>(haystack: &'a str, needle: &'b str) -> bool {\n-    let (haystack_len, needle_len) = (len(haystack), len(needle));\n+    let (haystack_len, needle_len) = (haystack.len(), needle.len());\n     if needle_len == 0u { true }\n     else if needle_len > haystack_len { false }\n     else { match_at(haystack, needle, 0u) }\n@@ -1639,7 +1627,7 @@ pub fn starts_with<'a,'b>(haystack: &'a str, needle: &'b str) -> bool {\n  * * needle - The string to look for\n  */\n pub fn ends_with<'a,'b>(haystack: &'a str, needle: &'b str) -> bool {\n-    let (haystack_len, needle_len) = (len(haystack), len(needle));\n+    let (haystack_len, needle_len) = (haystack.len(), needle.len());\n     if needle_len == 0u { true }\n     else if needle_len > haystack_len { false }\n     else { match_at(haystack, needle, haystack_len - needle_len) }\n@@ -1649,10 +1637,6 @@ pub fn ends_with<'a,'b>(haystack: &'a str, needle: &'b str) -> bool {\n Section: String properties\n */\n \n-/// Returns true if the string has length 0\n-#[inline(always)]\n-pub fn is_empty(s: &str) -> bool { len(s) == 0u }\n-\n /**\n  * Returns true if the string contains only whitespace\n  *\n@@ -1671,15 +1655,9 @@ fn is_alphanumeric(s: &str) -> bool {\n     s.iter().all(char::is_alphanumeric)\n }\n \n-/// Returns the string length/size in bytes not counting the null terminator\n-#[inline(always)]\n-pub fn len(s: &str) -> uint {\n-    do as_buf(s) |_p, n| { n - 1u }\n-}\n-\n /// Returns the number of characters that a string holds\n #[inline(always)]\n-pub fn char_len(s: &str) -> uint { count_chars(s, 0u, len(s)) }\n+pub fn char_len(s: &str) -> uint { count_chars(s, 0u, s.len()) }\n \n /*\n Section: Misc\n@@ -1828,7 +1806,7 @@ pub fn count_chars(s: &str, start: uint, end: uint) -> uint {\n pub fn count_bytes<'b>(s: &'b str, start: uint, n: uint) -> uint {\n     assert!(is_char_boundary(s, start));\n     let mut (end, cnt) = (start, n);\n-    let l = len(s);\n+    let l = s.len();\n     while cnt > 0u {\n         assert!(end < l);\n         let next = char_range_at(s, end).next;\n@@ -1856,7 +1834,7 @@ pub fn utf8_char_width(b: u8) -> uint {\n  * character sequence.\n  */\n pub fn is_char_boundary(s: &str, index: uint) -> bool {\n-    if index == len(s) { return true; }\n+    if index == s.len() { return true; }\n     let b = s[index];\n     return b < 128u8 || b >= 192u8;\n }\n@@ -1873,7 +1851,7 @@ pub fn is_char_boundary(s: &str, index: uint) -> bool {\n  * ~~~ {.rust}\n  * let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n  * let i = 0u;\n- * while i < str::len(s) {\n+ * while i < s.len() {\n  *     let CharRange {ch, next} = str::char_range_at(s, i);\n  *     std::io::println(fmt!(\"%u: %c\",i,ch));\n  *     i = next;\n@@ -2242,7 +2220,7 @@ pub fn capacity(s: &const ~str) -> uint {\n /// Escape each char in `s` with char::escape_default.\n pub fn escape_default(s: &str) -> ~str {\n     let mut out: ~str = ~\"\";\n-    reserve_at_least(&mut out, str::len(s));\n+    reserve_at_least(&mut out, s.len());\n     for s.iter().advance |c| {\n         push_str(&mut out, char::escape_default(c));\n     }\n@@ -2252,7 +2230,7 @@ pub fn escape_default(s: &str) -> ~str {\n /// Escape each char in `s` with char::escape_unicode.\n pub fn escape_unicode(s: &str) -> ~str {\n     let mut out: ~str = ~\"\";\n-    reserve_at_least(&mut out, str::len(s));\n+    reserve_at_least(&mut out, s.len());\n     for s.iter().advance |c| {\n         push_str(&mut out, char::escape_unicode(c));\n     }\n@@ -2265,7 +2243,7 @@ pub mod raw {\n     use libc;\n     use ptr;\n     use str::raw;\n-    use str::{as_buf, is_utf8, len, reserve_at_least};\n+    use str::{as_buf, is_utf8, reserve_at_least};\n     use vec;\n \n     /// Create a Rust string from a null-terminated *u8 buffer\n@@ -2394,7 +2372,7 @@ pub mod raw {\n \n     /// Removes the last byte from a string and returns it. (Not UTF-8 safe).\n     pub unsafe fn pop_byte(s: &mut ~str) -> u8 {\n-        let len = len(*s);\n+        let len = s.len();\n         assert!((len > 0u));\n         let b = s[len - 1u];\n         set_len(s, len - 1u);\n@@ -2403,7 +2381,7 @@ pub mod raw {\n \n     /// Removes the first byte from a string and returns it. (Not UTF-8 safe).\n     pub unsafe fn shift_byte(s: &mut ~str) -> u8 {\n-        let len = len(*s);\n+        let len = s.len();\n         assert!((len > 0u));\n         let b = s[0];\n         *s = raw::slice_bytes_owned(*s, 1u, len);\n@@ -2567,7 +2545,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n     /// Returns true if the string has length 0\n     #[inline]\n-    fn is_empty(&self) -> bool { is_empty(*self) }\n+    fn is_empty(&self) -> bool { self.len() == 0 }\n     /**\n      * Returns true if the string contains only whitespace\n      *\n@@ -2584,7 +2562,9 @@ impl<'self> StrSlice<'self> for &'self str {\n     fn is_alphanumeric(&self) -> bool { is_alphanumeric(*self) }\n     /// Returns the size in bytes not counting the null terminator\n     #[inline(always)]\n-    fn len(&self) -> uint { len(*self) }\n+    fn len(&self) -> uint {\n+        do as_buf(*self) |_p, n| { n - 1u }\n+    }\n     /// Returns the number of characters that a string holds\n     #[inline]\n     fn char_len(&self) -> uint { char_len(*self) }\n@@ -2597,7 +2577,9 @@ impl<'self> StrSlice<'self> for &'self str {\n      */\n     #[inline]\n     fn slice(&self, begin: uint, end: uint) -> &'self str {\n-        slice(*self, begin, end)\n+        assert!(is_char_boundary(*self, begin));\n+        assert!(is_char_boundary(*self, end));\n+        unsafe { raw::slice_bytes(*self, begin, end) }\n     }\n     /**\n      * Splits a string into a vector of the substrings separated by a given\n@@ -2788,8 +2770,8 @@ mod tests {\n \n     #[test]\n     fn test_eq_slice() {\n-        assert!((eq_slice(slice(\"foobar\", 0, 3), \"foo\")));\n-        assert!((eq_slice(slice(\"barfoo\", 3, 6), \"foo\")));\n+        assert!((eq_slice(\"foobar\".slice(0, 3), \"foo\")));\n+        assert!((eq_slice(\"barfoo\".slice(3, 6), \"foo\")));\n         assert!((!eq_slice(\"foo1\", \"foo2\")));\n     }\n \n@@ -2803,13 +2785,13 @@ mod tests {\n \n     #[test]\n     fn test_len() {\n-        assert_eq!(len(\"\"), 0u);\n-        assert_eq!(len(\"hello world\"), 11u);\n-        assert_eq!(len(\"\\x63\"), 1u);\n-        assert_eq!(len(\"\\xa2\"), 2u);\n-        assert_eq!(len(\"\\u03c0\"), 2u);\n-        assert_eq!(len(\"\\u2620\"), 3u);\n-        assert_eq!(len(\"\\U0001d11e\"), 4u);\n+        assert_eq!(\"\".len(), 0u);\n+        assert_eq!(\"hello world\".len(), 11u);\n+        assert_eq!(\"\\x63\".len(), 1u);\n+        assert_eq!(\"\\xa2\".len(), 2u);\n+        assert_eq!(\"\\u03c0\".len(), 2u);\n+        assert_eq!(\"\\u2620\".len(), 3u);\n+        assert_eq!(\"\\U0001d11e\".len(), 4u);\n \n         assert_eq!(char_len(\"\"), 0u);\n         assert_eq!(char_len(\"hello world\"), 11u);\n@@ -2937,7 +2919,7 @@ mod tests {\n     #[test]\n     fn test_substr() {\n         fn t(a: &str, b: &str, start: int) {\n-            assert_eq!(substr(a, start as uint, len(b)), b);\n+            assert_eq!(substr(a, start as uint, b.len()), b);\n         }\n         t(\"hello\", \"llo\", 2);\n         t(\"hello\", \"el\", 1);\n@@ -3044,8 +3026,8 @@ mod tests {\n \n     #[test]\n     fn test_is_empty() {\n-        assert!((is_empty(\"\")));\n-        assert!((!is_empty(\"a\")));\n+        assert!(\"\".is_empty());\n+        assert!(!\"a\".is_empty());\n     }\n \n     #[test]\n@@ -3101,16 +3083,16 @@ mod tests {\n \n     #[test]\n     fn test_slice() {\n-        assert_eq!(\"ab\", slice(\"abc\", 0, 2));\n-        assert_eq!(\"bc\", slice(\"abc\", 1, 3));\n-        assert_eq!(\"\", slice(\"abc\", 1, 1));\n-        assert_eq!(\"\\u65e5\", slice(\"\\u65e5\\u672c\", 0, 3));\n+        assert_eq!(\"ab\", \"abc\".slice(0, 2));\n+        assert_eq!(\"bc\", \"abc\".slice(1, 3));\n+        assert_eq!(\"\", \"abc\".slice(1, 1));\n+        assert_eq!(\"\\u65e5\", \"\\u65e5\\u672c\".slice(0, 3));\n \n         let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        assert_eq!(\"\u0e1b\", slice(data, 0, 3));\n-        assert_eq!(\"\u0e23\", slice(data, 3, 6));\n-        assert_eq!(\"\", slice(data, 3, 3));\n-        assert_eq!(\"\u534e\", slice(data, 30, 33));\n+        assert_eq!(\"\u0e1b\", data.slice(0, 3));\n+        assert_eq!(\"\u0e23\", data.slice(3, 6));\n+        assert_eq!(\"\", data.slice(3, 3));\n+        assert_eq!(\"\u534e\", data.slice(30, 33));\n \n         fn a_million_letter_X() -> ~str {\n             let mut i = 0;\n@@ -3129,23 +3111,23 @@ mod tests {\n         }\n         let letters = a_million_letter_X();\n         assert!(half_a_million_letter_X() ==\n-            slice(letters, 0u, 3u * 500000u).to_owned());\n+            letters.slice(0u, 3u * 500000u).to_owned());\n     }\n \n     #[test]\n     fn test_slice_2() {\n         let ss = \"\u4e2d\u534eVi\u1ec7t Nam\";\n \n-        assert_eq!(\"\u534e\", slice(ss, 3u, 6u));\n-        assert_eq!(\"Vi\u1ec7t Nam\", slice(ss, 6u, 16u));\n+        assert_eq!(\"\u534e\", ss.slice(3u, 6u));\n+        assert_eq!(\"Vi\u1ec7t Nam\", ss.slice(6u, 16u));\n \n-        assert_eq!(\"ab\", slice(\"abc\", 0u, 2u));\n-        assert_eq!(\"bc\", slice(\"abc\", 1u, 3u));\n-        assert_eq!(\"\", slice(\"abc\", 1u, 1u));\n+        assert_eq!(\"ab\", \"abc\".slice(0u, 2u));\n+        assert_eq!(\"bc\", \"abc\".slice(1u, 3u));\n+        assert_eq!(\"\", \"abc\".slice(1u, 1u));\n \n-        assert_eq!(\"\u4e2d\", slice(ss, 0u, 3u));\n-        assert_eq!(\"\u534eV\", slice(ss, 3u, 7u));\n-        assert_eq!(\"\", slice(ss, 3u, 3u));\n+        assert_eq!(\"\u4e2d\", ss.slice(0u, 3u));\n+        assert_eq!(\"\u534eV\", ss.slice(3u, 7u));\n+        assert_eq!(\"\", ss.slice(3u, 3u));\n         /*0: \u4e2d\n           3: \u534e\n           6: V\n@@ -3162,7 +3144,7 @@ mod tests {\n     #[should_fail]\n     #[ignore(cfg(windows))]\n     fn test_slice_fail() {\n-        slice(\"\u4e2d\u534eVi\u1ec7t Nam\", 0u, 2u);\n+        \"\u4e2d\u534eVi\u1ec7t Nam\".slice(0u, 2u);\n     }\n \n     #[test]\n@@ -3420,8 +3402,8 @@ mod tests {\n     #[test]\n     fn test_subslice_offset() {\n         let a = \"kernelsprite\";\n-        let b = slice(a, 7, len(a));\n-        let c = slice(a, 0, len(a) - 6);\n+        let b = a.slice(7, a.len());\n+        let c = a.slice(0, a.len() - 6);\n         assert_eq!(subslice_offset(a, b), 7);\n         assert_eq!(subslice_offset(a, c), 0);\n \n@@ -3448,7 +3430,7 @@ mod tests {\n         let v: ~[u8] = to_bytes(s1);\n         let s2: ~str = from_bytes(v);\n         let mut i: uint = 0u;\n-        let n1: uint = len(s1);\n+        let n1: uint = s1.len();\n         let n2: uint = v.len();\n         assert_eq!(n1, n2);\n         while i < n1 {\n@@ -3601,7 +3583,7 @@ mod tests {\n     #[test]\n     fn test_to_managed() {\n         assert_eq!(\"abc\".to_managed(), @\"abc\");\n-        assert_eq!(slice(\"abcdef\", 1, 5).to_managed(), @\"bcde\");\n+        assert_eq!(\"abcdef\".slice(1, 5).to_managed(), @\"bcde\");\n     }\n \n     #[test]"}, {"sha": "9b74119b08cb5a9a0ed9bf22c733ffa35ba53f3c", "filename": "src/libstd/unstable/extfmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibstd%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibstd%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fextfmt.rs?ref=c32fb53cf9ae20a657d17bd8e2f0b36863096583", "patch": "@@ -547,7 +547,7 @@ pub mod rt {\n         let unpadded = match cv.precision {\n           CountImplied => s,\n           CountIs(max) => if (max as uint) < str::char_len(s) {\n-            str::slice(s, 0, max as uint)\n+            s.slice(0, max as uint)\n           } else {\n             s\n           }"}, {"sha": "52f6e458db3e1d2535e25773d6e008eabe9ce9df", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=c32fb53cf9ae20a657d17bd8e2f0b36863096583", "patch": "@@ -290,9 +290,9 @@ impl FileMap {\n         let begin = begin.to_uint();\n         let end = match str::find_char_from(*self.src, '\\n', begin) {\n             Some(e) => e,\n-            None => str::len(*self.src)\n+            None => self.src.len()\n         };\n-        str::slice(*self.src, begin, end).to_owned()\n+        self.src.slice(begin, end).to_owned()\n     }\n \n     pub fn record_multibyte_char(&self, pos: BytePos, bytes: uint) {\n@@ -418,7 +418,7 @@ impl CodeMap {\n         let begin = self.lookup_byte_offset(sp.lo);\n         let end = self.lookup_byte_offset(sp.hi);\n         assert_eq!(begin.fm.start_pos, end.fm.start_pos);\n-        return str::slice(*begin.fm.src,\n+        return begin.fm.src.slice(\n                           begin.pos.to_uint(), end.pos.to_uint()).to_owned();\n     }\n "}, {"sha": "58b01fe78e7b8dcc020cb5df633e89ca9aace28c", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=c32fb53cf9ae20a657d17bd8e2f0b36863096583", "patch": "@@ -14,7 +14,6 @@ use codemap::{Pos, span};\n use codemap;\n \n use core::io;\n-use core::str;\n use core::uint;\n use core::vec;\n use extra::term;\n@@ -259,7 +258,7 @@ fn highlight_lines(cm: @codemap::CodeMap,\n     if elided {\n         let last_line = display_lines[display_lines.len() - 1u];\n         let s = fmt!(\"%s:%u \", fm.name, last_line + 1u);\n-        let mut indent = str::len(s);\n+        let mut indent = s.len();\n         let mut out = ~\"\";\n         while indent > 0u { out += \" \"; indent -= 1u; }\n         out += \"...\\n\";\n@@ -277,11 +276,11 @@ fn highlight_lines(cm: @codemap::CodeMap,\n         while num > 0u { num /= 10u; digits += 1u; }\n \n         // indent past |name:## | and the 0-offset column location\n-        let left = str::len(fm.name) + digits + lo.col.to_uint() + 3u;\n+        let left = fm.name.len() + digits + lo.col.to_uint() + 3u;\n         let mut s = ~\"\";\n         // Skip is the number of characters we need to skip because they are\n         // part of the 'filename:line ' part of the previous line.\n-        let skip = str::len(fm.name) + digits + 3u;\n+        let skip = fm.name.len() + digits + 3u;\n         for skip.times() {\n             s += \" \";\n         }"}, {"sha": "a715ede766401091b47f3fcecf54372a9936176c", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=c32fb53cf9ae20a657d17bd8e2f0b36863096583", "patch": "@@ -215,7 +215,7 @@ fn trim_whitespace_prefix_and_push_line(lines: &mut ~[~str],\n     let col = col.to_uint();\n     let s1 = if all_whitespace(s, 0, uint::min(len, col)) {\n         if col < len {\n-            str::slice(s, col, len).to_owned()\n+            s.slice(col, len).to_owned()\n         } else {  ~\"\" }\n     } else { s };\n     debug!(\"pushing line: %s\", s1);\n@@ -277,7 +277,7 @@ fn read_block_comment(rdr: @mut StringReader,\n                 }\n             }\n         }\n-        if str::len(curr_line) != 0 {\n+        if curr_line.len() != 0 {\n             trim_whitespace_prefix_and_push_line(&mut lines, curr_line, col);\n         }\n     }"}, {"sha": "04635fdf4e9bff72ea3e5d37845edd2961a0635b", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=c32fb53cf9ae20a657d17bd8e2f0b36863096583", "patch": "@@ -366,7 +366,7 @@ fn scan_exponent(rdr: @mut StringReader) -> Option<~str> {\n             bump(rdr);\n         }\n         let exponent = scan_digits(rdr, 10u);\n-        if str::len(exponent) > 0u {\n+        if exponent.len() > 0u {\n             return Some(rslt + exponent);\n         } else { rdr.fatal(~\"scan_exponent: bad fp literal\"); }\n     } else { return None::<~str>; }\n@@ -434,7 +434,7 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n             tp = if signed { either::Left(ast::ty_i64) }\n                       else { either::Right(ast::ty_u64) };\n         }\n-        if str::len(num_str) == 0u {\n+        if num_str.len() == 0u {\n             rdr.fatal(~\"no valid digits found for number\");\n         }\n         let parsed = match u64::from_str_radix(num_str, base as uint) {\n@@ -499,7 +499,7 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n         }\n         return token::LIT_FLOAT_UNSUFFIXED(str_to_ident(num_str));\n     } else {\n-        if str::len(num_str) == 0u {\n+        if num_str.len() == 0u {\n             rdr.fatal(~\"no valid digits found for number\");\n         }\n         let parsed = match u64::from_str_radix(num_str, base as uint) {"}, {"sha": "10fd46ea4b628cf255d6268e655e42c26d8420ad", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=c32fb53cf9ae20a657d17bd8e2f0b36863096583", "patch": "@@ -249,7 +249,7 @@ pub fn head(s: @ps, w: &str) {\n     // outer-box is consistent\n     cbox(s, indent_unit);\n     // head-box is inconsistent\n-    ibox(s, str::len(w) + 1);\n+    ibox(s, w.len() + 1);\n     // keyword that starts the head\n     if !w.is_empty() {\n         word_nbsp(s, w);"}, {"sha": "c497a30ec5f6657e24c28a2876ab28bb869805a4", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=c32fb53cf9ae20a657d17bd8e2f0b36863096583", "patch": "@@ -81,27 +81,27 @@ fn make_random_fasta(wr: @io::Writer,\n     for uint::range(0u, n as uint) |_i| {\n         str::push_char(&mut op, select_random(myrandom_next(rng, 100u32),\n                                               copy genelist));\n-        if str::len(op) >= LINE_LENGTH() {\n+        if op.len() >= LINE_LENGTH() {\n             wr.write_line(op);\n             op = ~\"\";\n         }\n     }\n-    if str::len(op) > 0u { wr.write_line(op); }\n+    if op.len() > 0u { wr.write_line(op); }\n }\n \n fn make_repeat_fasta(wr: @io::Writer, id: ~str, desc: ~str, s: ~str, n: int) {\n     unsafe {\n         wr.write_line(~\">\" + id + \" \" + desc);\n         let mut op: ~str = ~\"\";\n-        let sl: uint = str::len(s);\n+        let sl: uint = s.len();\n         for uint::range(0u, n as uint) |i| {\n             str::raw::push_byte(&mut op, s[i % sl]);\n-            if str::len(op) >= LINE_LENGTH() {\n+            if op.len() >= LINE_LENGTH() {\n                 wr.write_line(op);\n                 op = ~\"\";\n             }\n         }\n-        if str::len(op) > 0u { wr.write_line(op); }\n+        if op.len() > 0u { wr.write_line(op); }\n     }\n }\n "}, {"sha": "ef32b0bb2dc9b41cf62bf2cd5bd251e9464bd681", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=c32fb53cf9ae20a657d17bd8e2f0b36863096583", "patch": "@@ -191,7 +191,7 @@ fn main() {\n    while !rdr.eof() {\n       let line: ~str = rdr.read_line();\n \n-      if str::len(line) == 0u { loop; }\n+      if line.len() == 0u { loop; }\n \n       match (line[0] as char, proc_mode) {\n "}, {"sha": "40a4232717db2af5088138d4cbeef24d43df3e45", "filename": "src/test/compile-fail/die-not-static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Ftest%2Fcompile-fail%2Fdie-not-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Ftest%2Fcompile-fail%2Fdie-not-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdie-not-static.rs?ref=c32fb53cf9ae20a657d17bd8e2f0b36863096583", "patch": "@@ -2,7 +2,7 @@ use std::str;\n \n fn main() {\n     let v = ~\"test\";\n-    let sslice = str::slice(v, 0, v.len());\n+    let sslice = v.slice(0, v.len());\n     //~^ ERROR borrowed value does not live long enough\n     fail!(sslice);\n }"}, {"sha": "6e1af6ff7e095c184906c412e6a50d5d7413cbe6", "filename": "src/test/run-fail/task-spawn-barefn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Ftest%2Frun-fail%2Ftask-spawn-barefn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Ftest%2Frun-fail%2Ftask-spawn-barefn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ftask-spawn-barefn.rs?ref=c32fb53cf9ae20a657d17bd8e2f0b36863096583", "patch": "@@ -20,5 +20,5 @@ fn main() {\n }\n \n fn startfn() {\n-    assert!(str::is_empty(~\"Ensure that the child task runs by failing\"));\n+    assert!(\"Ensure that the child task runs by failing\".is_empty());\n }"}, {"sha": "e01b2a42f61392685a4870d05bc14eb49b6e0a34", "filename": "src/test/run-pass/string-self-append.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Ftest%2Frun-pass%2Fstring-self-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Ftest%2Frun-pass%2Fstring-self-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstring-self-append.rs?ref=c32fb53cf9ae20a657d17bd8e2f0b36863096583", "patch": "@@ -18,8 +18,8 @@ pub fn main() {\n     let mut i = 20;\n     let mut expected_len = 1u;\n     while i > 0 {\n-        error!(str::len(a));\n-        assert_eq!(str::len(a), expected_len);\n+        error!(a.len());\n+        assert_eq!(a.len(), expected_len);\n         a = a + a; // FIXME(#3387)---can't write a += a\n         i -= 1;\n         expected_len *= 2u;"}, {"sha": "011fb4435c3e88605eaf6aa7d10666aa2ebaf780", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32fb53cf9ae20a657d17bd8e2f0b36863096583/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=c32fb53cf9ae20a657d17bd8e2f0b36863096583", "patch": "@@ -18,7 +18,7 @@ pub fn main() {\n     let chs: ~[char] = ~['e', '\u00e9', '\u20ac', 0x10000 as char];\n     let s: ~str = str::from_chars(chs);\n \n-    assert!(str::len(s) == 10u);\n+    assert!(s.len() == 10u);\n     assert!(str::char_len(s) == 4u);\n     assert!(str::to_chars(s).len() == 4u);\n     assert!(str::from_chars(str::to_chars(s)) == s);"}]}