{"sha": "7eb10c4ce113f37ddd418b95629480f5d1ad9b6a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlYjEwYzRjZTExM2YzN2RkZDQxOGI5NTYyOTQ4MGY1ZDFhZDliNmE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-09-12T22:39:28Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-09-12T22:41:22Z"}, "message": "purge the separate path for rel ops (e.g., ==) vs other bin ops", "tree": {"sha": "1c1cb425cda965328beefdd45791662a881e9b96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c1cb425cda965328beefdd45791662a881e9b96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7eb10c4ce113f37ddd418b95629480f5d1ad9b6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7eb10c4ce113f37ddd418b95629480f5d1ad9b6a", "html_url": "https://github.com/rust-lang/rust/commit/7eb10c4ce113f37ddd418b95629480f5d1ad9b6a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7eb10c4ce113f37ddd418b95629480f5d1ad9b6a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3057790f4b2b7041f187734040e856d02104ff2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3057790f4b2b7041f187734040e856d02104ff2e", "html_url": "https://github.com/rust-lang/rust/commit/3057790f4b2b7041f187734040e856d02104ff2e"}], "stats": {"total": 88, "additions": 25, "deletions": 63}, "files": [{"sha": "5cb0868a6a6ea84a95a7166e94e40934001e59a5", "filename": "src/libcore/private.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7eb10c4ce113f37ddd418b95629480f5d1ad9b6a/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eb10c4ce113f37ddd418b95629480f5d1ad9b6a/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=7eb10c4ce113f37ddd418b95629480f5d1ad9b6a", "patch": "@@ -63,7 +63,7 @@ unsafe fn chan_from_global_ptr<T: Send>(\n         // This is the proposed global channel\n         let ch = comm::recv(setup_po);\n         // 0 is our sentinal value. It is not a valid channel\n-        assert unsafe::reinterpret_cast(&ch) != 0u;\n+        assert *ch != 0;\n \n         // Install the channel\n         log(debug,~\"BEFORE COMPARE AND SWAP\");"}, {"sha": "3de631138a3a64e32d0a4b0abaef399e03d11988", "filename": "src/libcore/unsafe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7eb10c4ce113f37ddd418b95629480f5d1ad9b6a/src%2Flibcore%2Funsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eb10c4ce113f37ddd418b95629480f5d1ad9b6a/src%2Flibcore%2Funsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funsafe.rs?ref=7eb10c4ce113f37ddd418b95629480f5d1ad9b6a", "patch": "@@ -400,7 +400,7 @@ mod tests {\n \n     #[test]\n     fn test_reinterpret_cast() {\n-        assert unsafe { reinterpret_cast(&1) } == 1u;\n+        assert 1u == unsafe { reinterpret_cast(&1) };\n     }\n \n     #[test]\n@@ -431,7 +431,7 @@ mod tests {\n     #[test]\n     fn test_transmute2() {\n         unsafe {\n-            assert transmute(~\"L\") == ~[76u8, 0u8];\n+            assert ~[76u8, 0u8] == transmute(~\"L\");\n         }\n     }\n "}, {"sha": "44da6d94509828b30e854616d1a68a8a2911561f", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 22, "deletions": 60, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/7eb10c4ce113f37ddd418b95629480f5d1ad9b6a/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eb10c4ce113f37ddd418b95629480f5d1ad9b6a/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=7eb10c4ce113f37ddd418b95629480f5d1ad9b6a", "patch": "@@ -938,7 +938,6 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         call_expr_id: ast::node_id,\n         in_fty: ty::t,\n         callee_expr: @ast::expr,\n-        check_args: bool,\n         args: ~[@ast::expr]) -> {fty: ty::t, bot: bool} {\n \n         let mut bot = false;\n@@ -1028,15 +1027,10 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                     debug!(\"checking the argument\");\n                     let formal_ty = formal_tys[i];\n \n-                    if check_args {\n-                        bot |= check_expr_with_unifier(\n-                            fcx, arg, Some(formal_ty),\n-                            || demand::assign(fcx, arg.span, formal_ty, arg)\n-                        );\n-                    } else {\n-                        demand::assign(fcx, arg.span, formal_ty, arg);\n-                        bot |= ty::type_is_bot(fcx.expr_ty(arg));\n-                    }\n+                    bot |= check_expr_with_unifier(\n+                        fcx, arg, Some(formal_ty),\n+                        || demand::assign(fcx, arg.span, formal_ty, arg)\n+                    );\n                 }\n             }\n         }\n@@ -1070,7 +1064,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // Call the generic checker.\n         let fty = {\n             let r = check_call_inner(fcx, sp, call_expr_id,\n-                                     fn_ty, f, true, args);\n+                                     fn_ty, f, args);\n             bot |= r.bot;\n             r.fty\n         };\n@@ -1126,8 +1120,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n     fn lookup_op_method(fcx: @fn_ctxt, op_ex: @ast::expr,\n                         self_ex: @ast::expr, self_t: ty::t,\n-                        opname: ast::ident, check_args: bool,\n-                        args: ~[@ast::expr])\n+                        opname: ast::ident, args: ~[@ast::expr])\n         -> Option<(ty::t, bool)>\n     {\n         match method::lookup(fcx, op_ex, self_ex,\n@@ -1136,7 +1129,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             let {fty: method_ty, bot: bot} = {\n                 let method_ty = fcx.node_ty(op_ex.callee_id);\n                 check_call_inner(fcx, op_ex.span, op_ex.id,\n-                                 method_ty, op_ex, check_args, args)\n+                                 method_ty, op_ex, args)\n             };\n             fcx.ccx.method_map.insert(op_ex.id, origin);\n             Some((ty::ty_fn_ret(method_ty), bot))\n@@ -1145,52 +1138,13 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         }\n     }\n \n-    fn check_rel_op(fcx: @fn_ctxt,\n-                    expr: @ast::expr,\n-                    op: ast::binop,\n-                    lhs: @ast::expr,\n-                    rhs: @ast::expr) -> bool\n-    {\n-        // We know that only things of equal type can be compared, so\n-        // go ahead and unify the two types before we do anything else\n-        // (with other operators, we must be much more careful not to\n-        // make assumptions, due to the possibility of operator\n-        // overloading; but overloaded == still enforces the\n-        // requirement that only equal types are compared).\n-        let tcx = fcx.ccx.tcx;\n-        let lhs_bot = check_expr(fcx, lhs, None);\n-        let lhs_t = fcx.expr_ty(lhs);\n-        let rhs_bot = check_expr_with(fcx, rhs, lhs_t);\n-\n-        let lhs_t = structurally_resolved_type(fcx, lhs.span, lhs_t);\n-        if ty::is_binopable(tcx, lhs_t, op) {\n-            let result_t = ty::mk_bool(tcx);\n-            fcx.write_ty(expr.id, result_t);\n-            return lhs_bot | rhs_bot;\n-        }\n-\n-        let (result, rhs_bot) =\n-            check_user_binop(fcx, expr, lhs, lhs_t, op, false, rhs);\n-        fcx.write_ty(expr.id, result);\n-        return lhs_bot | rhs_bot;\n-    }\n-\n     // could be either a expr_binop or an expr_assign_binop\n     fn check_binop(fcx: @fn_ctxt, expr: @ast::expr,\n                    op: ast::binop,\n                    lhs: @ast::expr,\n                    rhs: @ast::expr) -> bool {\n         let tcx = fcx.ccx.tcx;\n \n-        // Relational operators are different for type inferencing\n-        // reasons.\n-        match op {\n-            ast::eq | ast::ne | ast::lt | ast::le | ast::ge | ast::gt => {\n-                return check_rel_op(fcx, expr, op, lhs, rhs);\n-            }\n-            _ => {}\n-        }\n-\n         let lhs_bot = check_expr(fcx, lhs, None);\n         let lhs_t = fcx.expr_ty(lhs);\n         let lhs_t = structurally_resolved_type(fcx, lhs.span, lhs_t);\n@@ -1208,7 +1162,16 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             let tvar = fcx.infcx().next_ty_var();\n             demand::suptype(fcx, expr.span, tvar, lhs_t);\n             let rhs_bot = check_expr_with(fcx, rhs, tvar);\n-            let result_t = lhs_t;\n+\n+            let result_t = match op {\n+                ast::eq | ast::ne | ast::lt | ast::le | ast::ge | ast::gt => {\n+                    ty::mk_bool(tcx)\n+                }\n+                _ => {\n+                    lhs_t\n+                }\n+            };\n+\n             fcx.write_ty(expr.id, result_t);\n             return {\n                 if !ast_util::lazy_binop(op) { lhs_bot | rhs_bot }\n@@ -1217,22 +1180,21 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         }\n \n         let (result, rhs_bot) =\n-            check_user_binop(fcx, expr, lhs, lhs_t, op, true, rhs);\n+            check_user_binop(fcx, expr, lhs, lhs_t, op, rhs);\n         fcx.write_ty(expr.id, result);\n         return lhs_bot | rhs_bot;\n     }\n \n     fn check_user_binop(fcx: @fn_ctxt, ex: @ast::expr,\n                         lhs_expr: @ast::expr, lhs_resolved_t: ty::t,\n-                        op: ast::binop, check_rhs: bool,\n-                        rhs: @ast::expr) -> (ty::t, bool)\n+                        op: ast::binop, rhs: @ast::expr) -> (ty::t, bool)\n     {\n         let tcx = fcx.ccx.tcx;\n         match ast_util::binop_to_method_name(op) {\n           Some(name) => {\n             match lookup_op_method(fcx, ex, lhs_expr, lhs_resolved_t,\n                                    fcx.tcx().sess.ident_of(name),\n-                                   check_rhs, ~[rhs]) {\n+                                   ~[rhs]) {\n               Some(pair) => return pair,\n               _ => ()\n             }\n@@ -1266,7 +1228,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                        ex: @ast::expr,\n                        rhs_expr: @ast::expr, rhs_t: ty::t) -> ty::t {\n         match lookup_op_method(fcx, ex, rhs_expr, rhs_t,\n-                               fcx.tcx().sess.ident_of(mname), true, ~[]) {\n+                               fcx.tcx().sess.ident_of(mname), ~[]) {\n           Some((ret_ty, _)) => ret_ty,\n           _ => {\n             fcx.ccx.tcx.sess.span_err(\n@@ -2073,7 +2035,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                   let resolved = structurally_resolved_type(fcx, expr.span,\n                                                             raw_base_t);\n                   match lookup_op_method(fcx, expr, base, resolved,\n-                                         tcx.sess.ident_of(~\"index\"), true,\n+                                         tcx.sess.ident_of(~\"index\"),\n                                          ~[idx]) {\n                       Some((ret_ty, _)) => fcx.write_ty(id, ret_ty),\n                       _ => {"}]}