{"sha": "e27b88d5bd09eb111d2936f3c6214baf1839a194", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyN2I4OGQ1YmQwOWViMTExZDI5MzZmM2M2MjE0YmFmMTgzOWExOTQ=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2014-07-29T23:31:39Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2014-07-29T23:31:39Z"}, "message": "remove seek from std::io::MemWriter, add SeekableMemWriter to librustc\n\nNot all users of MemWriter need to seek, but having MemWriter\nseekable adds between 3-29% in overhead in certain circumstances.\nThis fixes that performance gap by making a non-seekable MemWriter,\nand creating a new SeekableMemWriter for those circumstances when\nthat functionality is actually needed.\n\n```\ntest io::mem::test::bench_buf_reader                        ... bench:       682 ns/iter (+/- 85)\ntest io::mem::test::bench_buf_writer                        ... bench:       580 ns/iter (+/- 57)\ntest io::mem::test::bench_mem_reader                        ... bench:       793 ns/iter (+/- 99)\ntest io::mem::test::bench_mem_writer_001_0000               ... bench:        48 ns/iter (+/- 27)\ntest io::mem::test::bench_mem_writer_001_0010               ... bench:        65 ns/iter (+/- 27) = 153 MB/s\ntest io::mem::test::bench_mem_writer_001_0100               ... bench:       132 ns/iter (+/- 12) = 757 MB/s\ntest io::mem::test::bench_mem_writer_001_1000               ... bench:       802 ns/iter (+/- 151) = 1246 MB/s\ntest io::mem::test::bench_mem_writer_100_0000               ... bench:       481 ns/iter (+/- 28)\ntest io::mem::test::bench_mem_writer_100_0010               ... bench:      1957 ns/iter (+/- 126) = 510 MB/s\ntest io::mem::test::bench_mem_writer_100_0100               ... bench:      8222 ns/iter (+/- 434) = 1216 MB/s\ntest io::mem::test::bench_mem_writer_100_1000               ... bench:     82496 ns/iter (+/- 11191) = 1212 MB/s\ntest io::mem::test::bench_seekable_mem_writer_001_0000      ... bench:        48 ns/iter (+/- 2)\ntest io::mem::test::bench_seekable_mem_writer_001_0010      ... bench:        64 ns/iter (+/- 2) = 156 MB/s\ntest io::mem::test::bench_seekable_mem_writer_001_0100      ... bench:       129 ns/iter (+/- 7) = 775 MB/s\ntest io::mem::test::bench_seekable_mem_writer_001_1000      ... bench:       801 ns/iter (+/- 159) = 1248 MB/s\ntest io::mem::test::bench_seekable_mem_writer_100_0000      ... bench:       711 ns/iter (+/- 51)\ntest io::mem::test::bench_seekable_mem_writer_100_0010      ... bench:      2532 ns/iter (+/- 227) = 394 MB/s\ntest io::mem::test::bench_seekable_mem_writer_100_0100      ... bench:      8962 ns/iter (+/- 947) = 1115 MB/s\ntest io::mem::test::bench_seekable_mem_writer_100_1000      ... bench:     85086 ns/iter (+/- 11555) = 1175 MB/s\n```\n\n[breaking-change]", "tree": {"sha": "58df3c76e3fcab4ed2f58ba5ad95ea8827f5cce6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58df3c76e3fcab4ed2f58ba5ad95ea8827f5cce6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e27b88d5bd09eb111d2936f3c6214baf1839a194", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e27b88d5bd09eb111d2936f3c6214baf1839a194", "html_url": "https://github.com/rust-lang/rust/commit/e27b88d5bd09eb111d2936f3c6214baf1839a194", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e27b88d5bd09eb111d2936f3c6214baf1839a194/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce2824dafe2f7b0783c2d841afe27c762528d02e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce2824dafe2f7b0783c2d841afe27c762528d02e", "html_url": "https://github.com/rust-lang/rust/commit/ce2824dafe2f7b0783c2d841afe27c762528d02e"}], "stats": {"total": 671, "additions": 528, "deletions": 143}, "files": [{"sha": "82040f141593e7575a1ed9224a5f5757e8835903", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e27b88d5bd09eb111d2936f3c6214baf1839a194/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e27b88d5bd09eb111d2936f3c6214baf1839a194/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=e27b88d5bd09eb111d2936f3c6214baf1839a194", "patch": "@@ -48,6 +48,9 @@ extern crate time;\n #[phase(plugin, link)] extern crate log;\n #[phase(plugin, link)] extern crate syntax;\n \n+#[cfg(test)]\n+extern crate test;\n+\n mod diagnostics;\n \n pub mod back {\n@@ -129,6 +132,7 @@ pub mod util {\n \n     pub mod common;\n     pub mod ppaux;\n+    pub mod io;\n     pub mod nodemap;\n }\n "}, {"sha": "dbda4f58d960f91fc721e205ccdc5431acf6dc87", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e27b88d5bd09eb111d2936f3c6214baf1839a194/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e27b88d5bd09eb111d2936f3c6214baf1839a194/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=e27b88d5bd09eb111d2936f3c6214baf1839a194", "patch": "@@ -26,14 +26,14 @@ use middle::ty;\n use middle::typeck;\n use middle::stability;\n use middle;\n+use util::io::SeekableMemWriter;\n use util::nodemap::{NodeMap, NodeSet};\n \n use serialize::Encodable;\n use std::cell::RefCell;\n use std::gc::Gc;\n use std::hash::Hash;\n use std::hash;\n-use std::io::MemWriter;\n use std::mem;\n use std::collections::HashMap;\n use syntax::abi;\n@@ -61,7 +61,7 @@ pub enum InlinedItemRef<'a> {\n     IIForeignRef(&'a ast::ForeignItem)\n }\n \n-pub type Encoder<'a> = writer::Encoder<'a, MemWriter>;\n+pub type Encoder<'a> = writer::Encoder<'a, SeekableMemWriter>;\n \n pub type EncodeInlinedItem<'a> = |ecx: &EncodeContext,\n                                   ebml_w: &mut Encoder,\n@@ -1407,7 +1407,7 @@ fn encode_info_for_items(ecx: &EncodeContext,\n // Path and definition ID indexing\n \n fn encode_index<T: Hash>(ebml_w: &mut Encoder, index: Vec<entry<T>>,\n-                         write_fn: |&mut MemWriter, &T|) {\n+                         write_fn: |&mut SeekableMemWriter, &T|) {\n     let mut buckets: Vec<Vec<entry<T>>> = Vec::from_fn(256, |_| Vec::new());\n     for elt in index.move_iter() {\n         let h = hash::hash(&elt.val) as uint;\n@@ -1424,7 +1424,7 @@ fn encode_index<T: Hash>(ebml_w: &mut Encoder, index: Vec<entry<T>>,\n             ebml_w.start_tag(tag_index_buckets_bucket_elt);\n             assert!(elt.pos < 0xffff_ffff);\n             {\n-                let wr: &mut MemWriter = ebml_w.writer;\n+                let wr: &mut SeekableMemWriter = ebml_w.writer;\n                 wr.write_be_u32(elt.pos as u32);\n             }\n             write_fn(ebml_w.writer, &elt.val);\n@@ -1436,15 +1436,15 @@ fn encode_index<T: Hash>(ebml_w: &mut Encoder, index: Vec<entry<T>>,\n     ebml_w.start_tag(tag_index_table);\n     for pos in bucket_locs.iter() {\n         assert!(*pos < 0xffff_ffff);\n-        let wr: &mut MemWriter = ebml_w.writer;\n+        let wr: &mut SeekableMemWriter = ebml_w.writer;\n         wr.write_be_u32(*pos as u32);\n     }\n     ebml_w.end_tag();\n     ebml_w.end_tag();\n }\n \n-fn write_i64(writer: &mut MemWriter, &n: &i64) {\n-    let wr: &mut MemWriter = writer;\n+fn write_i64(writer: &mut SeekableMemWriter, &n: &i64) {\n+    let wr: &mut SeekableMemWriter = writer;\n     assert!(n < 0x7fff_ffff);\n     wr.write_be_u32(n as u32);\n }\n@@ -1545,14 +1545,14 @@ fn encode_lang_items(ecx: &EncodeContext, ebml_w: &mut Encoder) {\n \n                 ebml_w.start_tag(tag_lang_items_item_id);\n                 {\n-                    let wr: &mut MemWriter = ebml_w.writer;\n+                    let wr: &mut SeekableMemWriter = ebml_w.writer;\n                     wr.write_be_u32(i as u32);\n                 }\n                 ebml_w.end_tag();   // tag_lang_items_item_id\n \n                 ebml_w.start_tag(tag_lang_items_item_node_id);\n                 {\n-                    let wr: &mut MemWriter = ebml_w.writer;\n+                    let wr: &mut SeekableMemWriter = ebml_w.writer;\n                     wr.write_be_u32(id.node as u32);\n                 }\n                 ebml_w.end_tag();   // tag_lang_items_item_node_id\n@@ -1824,12 +1824,12 @@ pub static metadata_encoding_version : &'static [u8] =\n       0, 0, 0, 1 ];\n \n pub fn encode_metadata(parms: EncodeParams, krate: &Crate) -> Vec<u8> {\n-    let mut wr = MemWriter::new();\n+    let mut wr = SeekableMemWriter::new();\n     encode_metadata_inner(&mut wr, parms, krate);\n     wr.unwrap().move_iter().collect()\n }\n \n-fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate) {\n+fn encode_metadata_inner(wr: &mut SeekableMemWriter, parms: EncodeParams, krate: &Crate) {\n     struct Stats {\n         attr_bytes: u64,\n         dep_bytes: u64,\n@@ -1982,7 +1982,7 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate)\n \n // Get the encoded string for a type\n pub fn encoded_ty(tcx: &ty::ctxt, t: ty::t) -> String {\n-    let mut wr = MemWriter::new();\n+    let mut wr = SeekableMemWriter::new();\n     tyencode::enc_ty(&mut wr, &tyencode::ctxt {\n         diag: tcx.sess.diagnostic(),\n         ds: def_to_string,"}, {"sha": "f301dc3760db60200a76df86f24de4b34f83cbef", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/e27b88d5bd09eb111d2936f3c6214baf1839a194/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e27b88d5bd09eb111d2936f3c6214baf1839a194/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=e27b88d5bd09eb111d2936f3c6214baf1839a194", "patch": "@@ -15,7 +15,6 @@\n \n use std::cell::RefCell;\n use std::collections::HashMap;\n-use std::io::MemWriter;\n \n use middle::subst;\n use middle::subst::VecPerParamSpace;\n@@ -28,6 +27,8 @@ use syntax::ast::*;\n use syntax::diagnostic::SpanHandler;\n use syntax::parse::token;\n \n+use util::io::SeekableMemWriter;\n+\n macro_rules! mywrite( ($($arg:tt)*) => ({ write!($($arg)*); }) )\n \n pub struct ctxt<'a> {\n@@ -48,7 +49,7 @@ pub struct ty_abbrev {\n \n pub type abbrev_map = RefCell<HashMap<ty::t, ty_abbrev>>;\n \n-pub fn enc_ty(w: &mut MemWriter, cx: &ctxt, t: ty::t) {\n+pub fn enc_ty(w: &mut SeekableMemWriter, cx: &ctxt, t: ty::t) {\n     match cx.abbrevs.borrow_mut().find(&t) {\n         Some(a) => { w.write(a.s.as_bytes()); return; }\n         None => {}\n@@ -72,19 +73,19 @@ pub fn enc_ty(w: &mut MemWriter, cx: &ctxt, t: ty::t) {\n     }\n }\n \n-fn enc_mutability(w: &mut MemWriter, mt: ast::Mutability) {\n+fn enc_mutability(w: &mut SeekableMemWriter, mt: ast::Mutability) {\n     match mt {\n         MutImmutable => (),\n         MutMutable => mywrite!(w, \"m\"),\n     }\n }\n \n-fn enc_mt(w: &mut MemWriter, cx: &ctxt, mt: ty::mt) {\n+fn enc_mt(w: &mut SeekableMemWriter, cx: &ctxt, mt: ty::mt) {\n     enc_mutability(w, mt.mutbl);\n     enc_ty(w, cx, mt.ty);\n }\n \n-fn enc_opt<T>(w: &mut MemWriter, t: Option<T>, enc_f: |&mut MemWriter, T|) {\n+fn enc_opt<T>(w: &mut SeekableMemWriter, t: Option<T>, enc_f: |&mut SeekableMemWriter, T|) {\n     match t {\n         None => mywrite!(w, \"n\"),\n         Some(v) => {\n@@ -94,10 +95,10 @@ fn enc_opt<T>(w: &mut MemWriter, t: Option<T>, enc_f: |&mut MemWriter, T|) {\n     }\n }\n \n-fn enc_vec_per_param_space<T>(w: &mut MemWriter,\n+fn enc_vec_per_param_space<T>(w: &mut SeekableMemWriter,\n                               cx: &ctxt,\n                               v: &VecPerParamSpace<T>,\n-                              op: |&mut MemWriter, &ctxt, &T|) {\n+                              op: |&mut SeekableMemWriter, &ctxt, &T|) {\n     for &space in subst::ParamSpace::all().iter() {\n         mywrite!(w, \"[\");\n         for t in v.get_slice(space).iter() {\n@@ -107,13 +108,13 @@ fn enc_vec_per_param_space<T>(w: &mut MemWriter,\n     }\n }\n \n-pub fn enc_substs(w: &mut MemWriter, cx: &ctxt, substs: &subst::Substs) {\n+pub fn enc_substs(w: &mut SeekableMemWriter, cx: &ctxt, substs: &subst::Substs) {\n     enc_region_substs(w, cx, &substs.regions);\n     enc_vec_per_param_space(w, cx, &substs.types,\n                             |w, cx, &ty| enc_ty(w, cx, ty));\n }\n \n-fn enc_region_substs(w: &mut MemWriter, cx: &ctxt, substs: &subst::RegionSubsts) {\n+fn enc_region_substs(w: &mut SeekableMemWriter, cx: &ctxt, substs: &subst::RegionSubsts) {\n     match *substs {\n         subst::ErasedRegions => {\n             mywrite!(w, \"e\");\n@@ -126,7 +127,7 @@ fn enc_region_substs(w: &mut MemWriter, cx: &ctxt, substs: &subst::RegionSubsts)\n     }\n }\n \n-fn enc_region(w: &mut MemWriter, cx: &ctxt, r: ty::Region) {\n+fn enc_region(w: &mut SeekableMemWriter, cx: &ctxt, r: ty::Region) {\n     match r {\n         ty::ReLateBound(id, br) => {\n             mywrite!(w, \"b[{}|\", id);\n@@ -161,7 +162,7 @@ fn enc_region(w: &mut MemWriter, cx: &ctxt, r: ty::Region) {\n     }\n }\n \n-fn enc_bound_region(w: &mut MemWriter, cx: &ctxt, br: ty::BoundRegion) {\n+fn enc_bound_region(w: &mut SeekableMemWriter, cx: &ctxt, br: ty::BoundRegion) {\n     match br {\n         ty::BrAnon(idx) => {\n             mywrite!(w, \"a{}|\", idx);\n@@ -177,12 +178,12 @@ fn enc_bound_region(w: &mut MemWriter, cx: &ctxt, br: ty::BoundRegion) {\n     }\n }\n \n-pub fn enc_trait_ref(w: &mut MemWriter, cx: &ctxt, s: &ty::TraitRef) {\n+pub fn enc_trait_ref(w: &mut SeekableMemWriter, cx: &ctxt, s: &ty::TraitRef) {\n     mywrite!(w, \"{}|\", (cx.ds)(s.def_id));\n     enc_substs(w, cx, &s.substs);\n }\n \n-pub fn enc_trait_store(w: &mut MemWriter, cx: &ctxt, s: ty::TraitStore) {\n+pub fn enc_trait_store(w: &mut SeekableMemWriter, cx: &ctxt, s: ty::TraitStore) {\n     match s {\n         ty::UniqTraitStore => mywrite!(w, \"~\"),\n         ty::RegionTraitStore(re, m) => {\n@@ -193,7 +194,7 @@ pub fn enc_trait_store(w: &mut MemWriter, cx: &ctxt, s: ty::TraitStore) {\n     }\n }\n \n-fn enc_sty(w: &mut MemWriter, cx: &ctxt, st: &ty::sty) {\n+fn enc_sty(w: &mut SeekableMemWriter, cx: &ctxt, st: &ty::sty) {\n     match *st {\n         ty::ty_nil => mywrite!(w, \"n\"),\n         ty::ty_bot => mywrite!(w, \"z\"),\n@@ -293,33 +294,33 @@ fn enc_sty(w: &mut MemWriter, cx: &ctxt, st: &ty::sty) {\n     }\n }\n \n-fn enc_fn_style(w: &mut MemWriter, p: FnStyle) {\n+fn enc_fn_style(w: &mut SeekableMemWriter, p: FnStyle) {\n     match p {\n         NormalFn => mywrite!(w, \"n\"),\n         UnsafeFn => mywrite!(w, \"u\"),\n     }\n }\n \n-fn enc_abi(w: &mut MemWriter, abi: Abi) {\n+fn enc_abi(w: &mut SeekableMemWriter, abi: Abi) {\n     mywrite!(w, \"[\");\n     mywrite!(w, \"{}\", abi.name());\n     mywrite!(w, \"]\")\n }\n \n-fn enc_onceness(w: &mut MemWriter, o: Onceness) {\n+fn enc_onceness(w: &mut SeekableMemWriter, o: Onceness) {\n     match o {\n         Once => mywrite!(w, \"o\"),\n         Many => mywrite!(w, \"m\")\n     }\n }\n \n-pub fn enc_bare_fn_ty(w: &mut MemWriter, cx: &ctxt, ft: &ty::BareFnTy) {\n+pub fn enc_bare_fn_ty(w: &mut SeekableMemWriter, cx: &ctxt, ft: &ty::BareFnTy) {\n     enc_fn_style(w, ft.fn_style);\n     enc_abi(w, ft.abi);\n     enc_fn_sig(w, cx, &ft.sig);\n }\n \n-pub fn enc_closure_ty(w: &mut MemWriter, cx: &ctxt, ft: &ty::ClosureTy) {\n+pub fn enc_closure_ty(w: &mut SeekableMemWriter, cx: &ctxt, ft: &ty::ClosureTy) {\n     enc_fn_style(w, ft.fn_style);\n     enc_onceness(w, ft.onceness);\n     enc_trait_store(w, cx, ft.store);\n@@ -330,7 +331,7 @@ pub fn enc_closure_ty(w: &mut MemWriter, cx: &ctxt, ft: &ty::ClosureTy) {\n     enc_abi(w, ft.abi);\n }\n \n-fn enc_fn_sig(w: &mut MemWriter, cx: &ctxt, fsig: &ty::FnSig) {\n+fn enc_fn_sig(w: &mut SeekableMemWriter, cx: &ctxt, fsig: &ty::FnSig) {\n     mywrite!(w, \"[{}|\", fsig.binder_id);\n     for ty in fsig.inputs.iter() {\n         enc_ty(w, cx, *ty);\n@@ -344,7 +345,7 @@ fn enc_fn_sig(w: &mut MemWriter, cx: &ctxt, fsig: &ty::FnSig) {\n     enc_ty(w, cx, fsig.output);\n }\n \n-fn enc_bounds(w: &mut MemWriter, cx: &ctxt, bs: &ty::ParamBounds) {\n+fn enc_bounds(w: &mut SeekableMemWriter, cx: &ctxt, bs: &ty::ParamBounds) {\n     for bound in bs.builtin_bounds.iter() {\n         match bound {\n             ty::BoundSend => mywrite!(w, \"S\"),\n@@ -363,7 +364,7 @@ fn enc_bounds(w: &mut MemWriter, cx: &ctxt, bs: &ty::ParamBounds) {\n     mywrite!(w, \".\");\n }\n \n-pub fn enc_type_param_def(w: &mut MemWriter, cx: &ctxt, v: &ty::TypeParameterDef) {\n+pub fn enc_type_param_def(w: &mut SeekableMemWriter, cx: &ctxt, v: &ty::TypeParameterDef) {\n     mywrite!(w, \"{}:{}|{}|{}|\",\n              token::get_ident(v.ident), (cx.ds)(v.def_id),\n              v.space.to_uint(), v.index);"}, {"sha": "9a587dd77418259b7000b976386c77c0cbdfdd23", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e27b88d5bd09eb111d2936f3c6214baf1839a194/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e27b88d5bd09eb111d2936f3c6214baf1839a194/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=e27b88d5bd09eb111d2936f3c6214baf1839a194", "patch": "@@ -28,6 +28,7 @@ use middle::subst;\n use middle::subst::VecPerParamSpace;\n use middle::typeck::{MethodCall, MethodCallee, MethodOrigin};\n use middle::{ty, typeck};\n+use util::io::SeekableMemWriter;\n use util::ppaux::ty_to_string;\n \n use syntax::{ast, ast_map, ast_util, codemap, fold};\n@@ -39,7 +40,6 @@ use syntax;\n \n use libc;\n use std::io::Seek;\n-use std::io::MemWriter;\n use std::mem;\n use std::gc::GC;\n \n@@ -73,7 +73,7 @@ trait tr_intern {\n     fn tr_intern(&self, xcx: &ExtendedDecodeContext) -> ast::DefId;\n }\n \n-pub type Encoder<'a> = writer::Encoder<'a, MemWriter>;\n+pub type Encoder<'a> = writer::Encoder<'a, SeekableMemWriter>;\n \n // ______________________________________________________________________\n // Top-level methods.\n@@ -1573,10 +1573,8 @@ fn mk_ctxt() -> parse::ParseSess {\n \n #[cfg(test)]\n fn roundtrip(in_item: Option<Gc<ast::Item>>) {\n-    use std::io::MemWriter;\n-\n     let in_item = in_item.unwrap();\n-    let mut wr = MemWriter::new();\n+    let mut wr = SeekableMemWriter::new();\n     {\n         let mut ebml_w = writer::Encoder::new(&mut wr);\n         encode_item_ast(&mut ebml_w, in_item);"}, {"sha": "f153aca7fac7bf8754990ae2a60fc62840802ca9", "filename": "src/librustc/util/io.rs", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/e27b88d5bd09eb111d2936f3c6214baf1839a194/src%2Flibrustc%2Futil%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e27b88d5bd09eb111d2936f3c6214baf1839a194/src%2Flibrustc%2Futil%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fio.rs?ref=e27b88d5bd09eb111d2936f3c6214baf1839a194", "patch": "@@ -0,0 +1,232 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::io::{IoError, IoResult, SeekStyle};\n+use std::io;\n+use std::slice;\n+\n+static BUF_CAPACITY: uint = 128;\n+\n+fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64> {\n+    // compute offset as signed and clamp to prevent overflow\n+    let pos = match seek {\n+        io::SeekSet => 0,\n+        io::SeekEnd => end,\n+        io::SeekCur => cur,\n+    } as i64;\n+\n+    if offset + pos < 0 {\n+        Err(IoError {\n+            kind: io::InvalidInput,\n+            desc: \"invalid seek to a negative offset\",\n+            detail: None\n+        })\n+    } else {\n+        Ok((offset + pos) as u64)\n+    }\n+}\n+\n+/// Writes to an owned, growable byte vector that supports seeking.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// # #![allow(unused_must_use)]\n+/// use std::io::SeekableMemWriter;\n+///\n+/// let mut w = SeekableMemWriter::new();\n+/// w.write([0, 1, 2]);\n+///\n+/// assert_eq!(w.unwrap(), vec!(0, 1, 2));\n+/// ```\n+pub struct SeekableMemWriter {\n+    buf: Vec<u8>,\n+    pos: uint,\n+}\n+\n+impl SeekableMemWriter {\n+    /// Create a new `SeekableMemWriter`.\n+    #[inline]\n+    pub fn new() -> SeekableMemWriter {\n+        SeekableMemWriter::with_capacity(BUF_CAPACITY)\n+    }\n+    /// Create a new `SeekableMemWriter`, allocating at least `n` bytes for\n+    /// the internal buffer.\n+    #[inline]\n+    pub fn with_capacity(n: uint) -> SeekableMemWriter {\n+        SeekableMemWriter { buf: Vec::with_capacity(n), pos: 0 }\n+    }\n+\n+    /// Acquires an immutable reference to the underlying buffer of this\n+    /// `SeekableMemWriter`.\n+    ///\n+    /// No method is exposed for acquiring a mutable reference to the buffer\n+    /// because it could corrupt the state of this `MemWriter`.\n+    #[inline]\n+    pub fn get_ref<'a>(&'a self) -> &'a [u8] { self.buf.as_slice() }\n+\n+    /// Unwraps this `SeekableMemWriter`, returning the underlying buffer\n+    #[inline]\n+    pub fn unwrap(self) -> Vec<u8> { self.buf }\n+}\n+\n+impl Writer for SeekableMemWriter {\n+    #[inline]\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+        if self.pos == self.buf.len() {\n+            self.buf.push_all(buf)\n+        } else {\n+            // Make sure the internal buffer is as least as big as where we\n+            // currently are\n+            let difference = self.pos as i64 - self.buf.len() as i64;\n+            if difference > 0 {\n+                self.buf.grow(difference as uint, &0);\n+            }\n+\n+            // Figure out what bytes will be used to overwrite what's currently\n+            // there (left), and what will be appended on the end (right)\n+            let cap = self.buf.len() - self.pos;\n+            let (left, right) = if cap <= buf.len() {\n+                (buf.slice_to(cap), buf.slice_from(cap))\n+            } else {\n+                (buf, &[])\n+            };\n+\n+            // Do the necessary writes\n+            if left.len() > 0 {\n+                slice::bytes::copy_memory(self.buf.mut_slice_from(self.pos), left);\n+            }\n+            if right.len() > 0 {\n+                self.buf.push_all(right);\n+            }\n+        }\n+\n+        // Bump us forward\n+        self.pos += buf.len();\n+        Ok(())\n+    }\n+}\n+\n+impl Seek for SeekableMemWriter {\n+    #[inline]\n+    fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n+\n+    #[inline]\n+    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n+        let new = try!(combine(style, self.pos, self.buf.len(), pos));\n+        self.pos = new as uint;\n+        Ok(())\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::SeekableMemWriter;\n+    use std::io;\n+    use test::Bencher;\n+\n+    #[test]\n+    fn test_seekable_mem_writer() {\n+        let mut writer = SeekableMemWriter::new();\n+        assert_eq!(writer.tell(), Ok(0));\n+        writer.write([0]).unwrap();\n+        assert_eq!(writer.tell(), Ok(1));\n+        writer.write([1, 2, 3]).unwrap();\n+        writer.write([4, 5, 6, 7]).unwrap();\n+        assert_eq!(writer.tell(), Ok(8));\n+        assert_eq!(writer.get_ref(), &[0, 1, 2, 3, 4, 5, 6, 7]);\n+\n+        writer.seek(0, io::SeekSet).unwrap();\n+        assert_eq!(writer.tell(), Ok(0));\n+        writer.write([3, 4]).unwrap();\n+        assert_eq!(writer.get_ref(), &[3, 4, 2, 3, 4, 5, 6, 7]);\n+\n+        writer.seek(1, io::SeekCur).unwrap();\n+        writer.write([0, 1]).unwrap();\n+        assert_eq!(writer.get_ref(), &[3, 4, 2, 0, 1, 5, 6, 7]);\n+\n+        writer.seek(-1, io::SeekEnd).unwrap();\n+        writer.write([1, 2]).unwrap();\n+        assert_eq!(writer.get_ref(), &[3, 4, 2, 0, 1, 5, 6, 1, 2]);\n+\n+        writer.seek(1, io::SeekEnd).unwrap();\n+        writer.write([1]).unwrap();\n+        assert_eq!(writer.get_ref(), &[3, 4, 2, 0, 1, 5, 6, 1, 2, 0, 1]);\n+    }\n+\n+    #[test]\n+    fn seek_past_end() {\n+        let mut r = SeekableMemWriter::new();\n+        r.seek(10, io::SeekSet).unwrap();\n+        assert!(r.write([3]).is_ok());\n+    }\n+\n+    #[test]\n+    fn seek_before_0() {\n+        let mut r = SeekableMemWriter::new();\n+        assert!(r.seek(-1, io::SeekSet).is_err());\n+    }\n+\n+    fn do_bench_seekable_mem_writer(b: &mut Bencher, times: uint, len: uint) {\n+        let src: Vec<u8> = Vec::from_elem(len, 5);\n+\n+        b.bytes = (times * len) as u64;\n+        b.iter(|| {\n+            let mut wr = SeekableMemWriter::new();\n+            for _ in range(0, times) {\n+                wr.write(src.as_slice()).unwrap();\n+            }\n+\n+            let v = wr.unwrap();\n+            assert_eq!(v.len(), times * len);\n+            assert!(v.iter().all(|x| *x == 5));\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_seekable_mem_writer_001_0000(b: &mut Bencher) {\n+        do_bench_seekable_mem_writer(b, 1, 0)\n+    }\n+\n+    #[bench]\n+    fn bench_seekable_mem_writer_001_0010(b: &mut Bencher) {\n+        do_bench_seekable_mem_writer(b, 1, 10)\n+    }\n+\n+    #[bench]\n+    fn bench_seekable_mem_writer_001_0100(b: &mut Bencher) {\n+        do_bench_seekable_mem_writer(b, 1, 100)\n+    }\n+\n+    #[bench]\n+    fn bench_seekable_mem_writer_001_1000(b: &mut Bencher) {\n+        do_bench_seekable_mem_writer(b, 1, 1000)\n+    }\n+\n+    #[bench]\n+    fn bench_seekable_mem_writer_100_0000(b: &mut Bencher) {\n+        do_bench_seekable_mem_writer(b, 100, 0)\n+    }\n+\n+    #[bench]\n+    fn bench_seekable_mem_writer_100_0010(b: &mut Bencher) {\n+        do_bench_seekable_mem_writer(b, 100, 10)\n+    }\n+\n+    #[bench]\n+    fn bench_seekable_mem_writer_100_0100(b: &mut Bencher) {\n+        do_bench_seekable_mem_writer(b, 100, 100)\n+    }\n+\n+    #[bench]\n+    fn bench_seekable_mem_writer_100_1000(b: &mut Bencher) {\n+        do_bench_seekable_mem_writer(b, 100, 1000)\n+    }\n+}"}, {"sha": "c3434466836175f85242aabbbbff81c343fc3469", "filename": "src/libserialize/ebml.rs", "status": "modified", "additions": 118, "deletions": 2, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/e27b88d5bd09eb111d2936f3c6214baf1839a194/src%2Flibserialize%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e27b88d5bd09eb111d2936f3c6214baf1839a194/src%2Flibserialize%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Febml.rs?ref=e27b88d5bd09eb111d2936f3c6214baf1839a194", "patch": "@@ -1023,8 +1023,124 @@ mod tests {\n     use ebml::writer;\n     use {Encodable, Decodable};\n \n-    use std::io::MemWriter;\n+    use std::io::{IoError, IoResult, SeekStyle};\n+    use std::io;\n     use std::option::{None, Option, Some};\n+    use std::slice;\n+\n+    static BUF_CAPACITY: uint = 128;\n+\n+    fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64> {\n+        // compute offset as signed and clamp to prevent overflow\n+        let pos = match seek {\n+            io::SeekSet => 0,\n+            io::SeekEnd => end,\n+            io::SeekCur => cur,\n+        } as i64;\n+\n+        if offset + pos < 0 {\n+            Err(IoError {\n+                kind: io::InvalidInput,\n+                desc: \"invalid seek to a negative offset\",\n+                detail: None\n+            })\n+        } else {\n+            Ok((offset + pos) as u64)\n+        }\n+    }\n+\n+    /// Writes to an owned, growable byte vector that supports seeking.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # #![allow(unused_must_use)]\n+    /// use std::io::SeekableMemWriter;\n+    ///\n+    /// let mut w = SeekableMemWriter::new();\n+    /// w.write([0, 1, 2]);\n+    ///\n+    /// assert_eq!(w.unwrap(), vec!(0, 1, 2));\n+    /// ```\n+    pub struct SeekableMemWriter {\n+        buf: Vec<u8>,\n+        pos: uint,\n+    }\n+\n+    impl SeekableMemWriter {\n+        /// Create a new `SeekableMemWriter`.\n+        #[inline]\n+        pub fn new() -> SeekableMemWriter {\n+            SeekableMemWriter::with_capacity(BUF_CAPACITY)\n+        }\n+        /// Create a new `SeekableMemWriter`, allocating at least `n` bytes for\n+        /// the internal buffer.\n+        #[inline]\n+        pub fn with_capacity(n: uint) -> SeekableMemWriter {\n+            SeekableMemWriter { buf: Vec::with_capacity(n), pos: 0 }\n+        }\n+\n+        /// Acquires an immutable reference to the underlying buffer of this\n+        /// `SeekableMemWriter`.\n+        ///\n+        /// No method is exposed for acquiring a mutable reference to the buffer\n+        /// because it could corrupt the state of this `MemWriter`.\n+        #[inline]\n+        pub fn get_ref<'a>(&'a self) -> &'a [u8] { self.buf.as_slice() }\n+\n+        /// Unwraps this `SeekableMemWriter`, returning the underlying buffer\n+        #[inline]\n+        pub fn unwrap(self) -> Vec<u8> { self.buf }\n+    }\n+\n+    impl Writer for SeekableMemWriter {\n+        #[inline]\n+        fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+            if self.pos == self.buf.len() {\n+                self.buf.push_all(buf)\n+            } else {\n+                // Make sure the internal buffer is as least as big as where we\n+                // currently are\n+                let difference = self.pos as i64 - self.buf.len() as i64;\n+                if difference > 0 {\n+                    self.buf.grow(difference as uint, &0);\n+                }\n+\n+                // Figure out what bytes will be used to overwrite what's currently\n+                // there (left), and what will be appended on the end (right)\n+                let cap = self.buf.len() - self.pos;\n+                let (left, right) = if cap <= buf.len() {\n+                    (buf.slice_to(cap), buf.slice_from(cap))\n+                } else {\n+                    (buf, &[])\n+                };\n+\n+                // Do the necessary writes\n+                if left.len() > 0 {\n+                    slice::bytes::copy_memory(self.buf.mut_slice_from(self.pos), left);\n+                }\n+                if right.len() > 0 {\n+                    self.buf.push_all(right);\n+                }\n+            }\n+\n+            // Bump us forward\n+            self.pos += buf.len();\n+            Ok(())\n+        }\n+    }\n+\n+    impl Seek for SeekableMemWriter {\n+        #[inline]\n+        fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n+\n+        #[inline]\n+        fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n+            let new = try!(combine(style, self.pos, self.buf.len(), pos));\n+            self.pos = new as uint;\n+            Ok(())\n+        }\n+    }\n \n     #[test]\n     fn test_vuint_at() {\n@@ -1078,7 +1194,7 @@ mod tests {\n     fn test_option_int() {\n         fn test_v(v: Option<int>) {\n             debug!(\"v == {}\", v);\n-            let mut wr = MemWriter::new();\n+            let mut wr = SeekableMemWriter::new();\n             {\n                 let mut ebml_w = writer::Encoder::new(&mut wr);\n                 let _ = v.encode(&mut ebml_w);"}, {"sha": "f9f8ce377ec016d824dc7340b3dabe90b010c76a", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e27b88d5bd09eb111d2936f3c6214baf1839a194/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e27b88d5bd09eb111d2936f3c6214baf1839a194/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=e27b88d5bd09eb111d2936f3c6214baf1839a194", "patch": "@@ -955,7 +955,7 @@ mod test {\n         }\n     ) )\n \n-    struct TempDir(Path);\n+    pub struct TempDir(Path);\n \n     impl TempDir {\n         fn join(&self, path: &str) -> Path {"}, {"sha": "8a60233cb5cfbf6034dd7a92eaaed113504a03cb", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 6, "deletions": 71, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/e27b88d5bd09eb111d2936f3c6214baf1839a194/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e27b88d5bd09eb111d2936f3c6214baf1839a194/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=e27b88d5bd09eb111d2936f3c6214baf1839a194", "patch": "@@ -22,6 +22,8 @@ use slice;\n use slice::{Vector, ImmutableVector, MutableVector};\n use vec::Vec;\n \n+static BUF_CAPACITY: uint = 128;\n+\n fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64> {\n     // compute offset as signed and clamp to prevent overflow\n     let pos = match seek {\n@@ -56,27 +58,23 @@ fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64>\n /// ```\n pub struct MemWriter {\n     buf: Vec<u8>,\n-    pos: uint,\n }\n \n impl MemWriter {\n     /// Create a new `MemWriter`.\n     #[inline]\n     pub fn new() -> MemWriter {\n-        MemWriter::with_capacity(128)\n+        MemWriter::with_capacity(BUF_CAPACITY)\n     }\n     /// Create a new `MemWriter`, allocating at least `n` bytes for\n     /// the internal buffer.\n     #[inline]\n     pub fn with_capacity(n: uint) -> MemWriter {\n-        MemWriter { buf: Vec::with_capacity(n), pos: 0 }\n+        MemWriter { buf: Vec::with_capacity(n) }\n     }\n \n     /// Acquires an immutable reference to the underlying buffer of this\n     /// `MemWriter`.\n-    ///\n-    /// No method is exposed for acquiring a mutable reference to the buffer\n-    /// because it could corrupt the state of this `MemWriter`.\n     #[inline]\n     pub fn get_ref<'a>(&'a self) -> &'a [u8] { self.buf.as_slice() }\n \n@@ -88,44 +86,7 @@ impl MemWriter {\n impl Writer for MemWriter {\n     #[inline]\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        // Make sure the internal buffer is as least as big as where we\n-        // currently are\n-        let difference = self.pos as i64 - self.buf.len() as i64;\n-        if difference > 0 {\n-            self.buf.grow(difference as uint, &0);\n-        }\n-\n-        // Figure out what bytes will be used to overwrite what's currently\n-        // there (left), and what will be appended on the end (right)\n-        let cap = self.buf.len() - self.pos;\n-        let (left, right) = if cap <= buf.len() {\n-            (buf.slice_to(cap), buf.slice_from(cap))\n-        } else {\n-            (buf, &[])\n-        };\n-\n-        // Do the necessary writes\n-        if left.len() > 0 {\n-            slice::bytes::copy_memory(self.buf.mut_slice_from(self.pos), left);\n-        }\n-        if right.len() > 0 {\n-            self.buf.push_all(right);\n-        }\n-\n-        // Bump us forward\n-        self.pos += buf.len();\n-        Ok(())\n-    }\n-}\n-\n-impl Seek for MemWriter {\n-    #[inline]\n-    fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n-\n-    #[inline]\n-    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n-        let new = try!(combine(style, self.pos, self.buf.len(), pos));\n-        self.pos = new as uint;\n+        self.buf.push_all(buf);\n         Ok(())\n     }\n }\n@@ -381,30 +342,10 @@ mod test {\n     #[test]\n     fn test_mem_writer() {\n         let mut writer = MemWriter::new();\n-        assert_eq!(writer.tell(), Ok(0));\n         writer.write([0]).unwrap();\n-        assert_eq!(writer.tell(), Ok(1));\n         writer.write([1, 2, 3]).unwrap();\n         writer.write([4, 5, 6, 7]).unwrap();\n-        assert_eq!(writer.tell(), Ok(8));\n         assert_eq!(writer.get_ref(), &[0, 1, 2, 3, 4, 5, 6, 7]);\n-\n-        writer.seek(0, SeekSet).unwrap();\n-        assert_eq!(writer.tell(), Ok(0));\n-        writer.write([3, 4]).unwrap();\n-        assert_eq!(writer.get_ref(), &[3, 4, 2, 3, 4, 5, 6, 7]);\n-\n-        writer.seek(1, SeekCur).unwrap();\n-        writer.write([0, 1]).unwrap();\n-        assert_eq!(writer.get_ref(), &[3, 4, 2, 0, 1, 5, 6, 7]);\n-\n-        writer.seek(-1, SeekEnd).unwrap();\n-        writer.write([1, 2]).unwrap();\n-        assert_eq!(writer.get_ref(), &[3, 4, 2, 0, 1, 5, 6, 1, 2]);\n-\n-        writer.seek(1, SeekEnd).unwrap();\n-        writer.write([1]).unwrap();\n-        assert_eq!(writer.get_ref(), &[3, 4, 2, 0, 1, 5, 6, 1, 2, 0, 1]);\n     }\n \n     #[test]\n@@ -570,10 +511,6 @@ mod test {\n         r.seek(10, SeekSet).unwrap();\n         assert!(r.read(&mut []).is_err());\n \n-        let mut r = MemWriter::new();\n-        r.seek(10, SeekSet).unwrap();\n-        assert!(r.write([3]).is_ok());\n-\n         let mut buf = [0];\n         let mut r = BufWriter::new(buf);\n         r.seek(10, SeekSet).unwrap();\n@@ -589,9 +526,6 @@ mod test {\n         let mut r = MemReader::new(vec!(10));\n         assert!(r.seek(-1, SeekSet).is_err());\n \n-        let mut r = MemWriter::new();\n-        assert!(r.seek(-1, SeekSet).is_err());\n-\n         let mut buf = [0];\n         let mut r = BufWriter::new(buf);\n         assert!(r.seek(-1, SeekSet).is_err());\n@@ -614,6 +548,7 @@ mod test {\n     fn do_bench_mem_writer(b: &mut Bencher, times: uint, len: uint) {\n         let src: Vec<u8> = Vec::from_elem(len, 5);\n \n+        b.bytes = (times * len) as u64;\n         b.iter(|| {\n             let mut wr = MemWriter::new();\n             for _ in range(0, times) {"}, {"sha": "f35885c0ae2badbe3b918370ffdceb8bff947a0e", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e27b88d5bd09eb111d2936f3c6214baf1839a194/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e27b88d5bd09eb111d2936f3c6214baf1839a194/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e27b88d5bd09eb111d2936f3c6214baf1839a194", "patch": "@@ -137,7 +137,7 @@ pub fn to_string(f: |&mut State| -> IoResult<()>) -> String {\n         // downcasts.\n         let (_, wr): (uint, Box<MemWriter>) = mem::transmute_copy(&s.s.out);\n         let result =\n-            String::from_utf8(Vec::from_slice(wr.get_ref())).unwrap();\n+            String::from_utf8(Vec::from_slice(wr.get_ref().as_slice())).unwrap();\n         mem::forget(wr);\n         result.to_string()\n     }"}, {"sha": "037afce9b167a7c5a404ff3906af076d7ffa8bca", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e27b88d5bd09eb111d2936f3c6214baf1839a194/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e27b88d5bd09eb111d2936f3c6214baf1839a194/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=e27b88d5bd09eb111d2936f3c6214baf1839a194", "patch": "@@ -790,16 +790,12 @@ mod test {\n \n     #[test]\n     fn test_serialize_round_trip() {\n-        use serialize::ebml::Doc;\n-        use serialize::ebml::writer::Encoder;\n-        use serialize::ebml::reader::Decoder;\n+        use serialize::json;\n         use serialize::{Encodable, Decodable};\n \n         let u = Uuid::new_v4();\n-        let mut wr = MemWriter::new();\n-        let _ = u.encode(&mut Encoder::new(&mut wr));\n-        let doc = Doc::new(wr.get_ref());\n-        let u2 = Decodable::decode(&mut Decoder::new(doc)).unwrap();\n+        let s = json::encode(&u);\n+        let u2 = json::decode(s.as_slice()).unwrap();\n         assert_eq!(u, u2);\n     }\n "}, {"sha": "9eef83184e139e49d049bedc996a6068e53a8138", "filename": "src/test/run-pass/deriving-encodable-decodable-cell-refcell.rs", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e27b88d5bd09eb111d2936f3c6214baf1839a194/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable-cell-refcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e27b88d5bd09eb111d2936f3c6214baf1839a194/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable-cell-refcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable-cell-refcell.rs?ref=e27b88d5bd09eb111d2936f3c6214baf1839a194", "patch": "@@ -16,9 +16,7 @@ extern crate serialize;\n use std::cell::{Cell, RefCell};\n use std::io::MemWriter;\n use serialize::{Encodable, Decodable};\n-use serialize::ebml;\n-use serialize::ebml::writer::Encoder;\n-use serialize::ebml::reader::Decoder;\n+use serialize::json;\n \n #[deriving(Encodable, Decodable)]\n struct A {\n@@ -36,20 +34,8 @@ fn main() {\n         foo: Cell::new(true),\n         bar: RefCell::new( A { baz: 2 } )\n     };\n-    let mut w = MemWriter::new();\n-    {\n-        let mut e = Encoder::new(&mut w);\n-        match obj.encode(&mut e) {\n-            Ok(()) => (),\n-            Err(e) => fail!(\"Failed to encode: {}\", e)\n-        };\n-    }\n-    let doc = ebml::Doc::new(w.get_ref());\n-    let mut dec = Decoder::new(doc);\n-    let obj2: B = match Decodable::decode(&mut dec) {\n-        Ok(v) => v,\n-        Err(e) => fail!(\"Failed to decode: {}\", e)\n-    };\n+    let s = json::encode(&obj);\n+    let obj2: B = json::decode(s.as_slice()).unwrap();\n     assert!(obj.foo.get() == obj2.foo.get());\n     assert!(obj.bar.borrow().baz == obj2.bar.borrow().baz);\n }"}, {"sha": "d7f487b629b5eb05817ad3f93631d0606eb1fba8", "filename": "src/test/run-pass/issue-11881.rs", "status": "modified", "additions": 122, "deletions": 5, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/e27b88d5bd09eb111d2936f3c6214baf1839a194/src%2Ftest%2Frun-pass%2Fissue-11881.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e27b88d5bd09eb111d2936f3c6214baf1839a194/src%2Ftest%2Frun-pass%2Fissue-11881.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11881.rs?ref=e27b88d5bd09eb111d2936f3c6214baf1839a194", "patch": "@@ -10,10 +10,127 @@\n \n extern crate serialize;\n \n+use std::io;\n+use std::io::{IoError, IoResult, SeekStyle};\n+use std::slice;\n+\n use serialize::{Encodable, Encoder};\n use serialize::json;\n use serialize::ebml::writer;\n-use std::io::MemWriter;\n+\n+static BUF_CAPACITY: uint = 128;\n+\n+fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64> {\n+    // compute offset as signed and clamp to prevent overflow\n+    let pos = match seek {\n+        io::SeekSet => 0,\n+        io::SeekEnd => end,\n+        io::SeekCur => cur,\n+    } as i64;\n+\n+    if offset + pos < 0 {\n+        Err(IoError {\n+            kind: io::InvalidInput,\n+            desc: \"invalid seek to a negative offset\",\n+            detail: None\n+        })\n+    } else {\n+        Ok((offset + pos) as u64)\n+    }\n+}\n+\n+/// Writes to an owned, growable byte vector that supports seeking.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// # #![allow(unused_must_use)]\n+/// use std::io::SeekableMemWriter;\n+///\n+/// let mut w = SeekableMemWriter::new();\n+/// w.write([0, 1, 2]);\n+///\n+/// assert_eq!(w.unwrap(), vec!(0, 1, 2));\n+/// ```\n+pub struct SeekableMemWriter {\n+    buf: Vec<u8>,\n+    pos: uint,\n+}\n+\n+impl SeekableMemWriter {\n+    /// Create a new `SeekableMemWriter`.\n+    #[inline]\n+    pub fn new() -> SeekableMemWriter {\n+        SeekableMemWriter::with_capacity(BUF_CAPACITY)\n+    }\n+    /// Create a new `SeekableMemWriter`, allocating at least `n` bytes for\n+    /// the internal buffer.\n+    #[inline]\n+    pub fn with_capacity(n: uint) -> SeekableMemWriter {\n+        SeekableMemWriter { buf: Vec::with_capacity(n), pos: 0 }\n+    }\n+\n+    /// Acquires an immutable reference to the underlying buffer of this\n+    /// `SeekableMemWriter`.\n+    ///\n+    /// No method is exposed for acquiring a mutable reference to the buffer\n+    /// because it could corrupt the state of this `MemWriter`.\n+    #[inline]\n+    pub fn get_ref<'a>(&'a self) -> &'a [u8] { self.buf.as_slice() }\n+\n+    /// Unwraps this `SeekableMemWriter`, returning the underlying buffer\n+    #[inline]\n+    pub fn unwrap(self) -> Vec<u8> { self.buf }\n+}\n+\n+impl Writer for SeekableMemWriter {\n+    #[inline]\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+        if self.pos == self.buf.len() {\n+            self.buf.push_all(buf)\n+        } else {\n+            // Make sure the internal buffer is as least as big as where we\n+            // currently are\n+            let difference = self.pos as i64 - self.buf.len() as i64;\n+            if difference > 0 {\n+                self.buf.grow(difference as uint, &0);\n+            }\n+\n+            // Figure out what bytes will be used to overwrite what's currently\n+            // there (left), and what will be appended on the end (right)\n+            let cap = self.buf.len() - self.pos;\n+            let (left, right) = if cap <= buf.len() {\n+                (buf.slice_to(cap), buf.slice_from(cap))\n+            } else {\n+                (buf, &[])\n+            };\n+\n+            // Do the necessary writes\n+            if left.len() > 0 {\n+                slice::bytes::copy_memory(self.buf.mut_slice_from(self.pos), left);\n+            }\n+            if right.len() > 0 {\n+                self.buf.push_all(right);\n+            }\n+        }\n+\n+        // Bump us forward\n+        self.pos += buf.len();\n+        Ok(())\n+    }\n+}\n+\n+impl Seek for SeekableMemWriter {\n+    #[inline]\n+    fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n+\n+    #[inline]\n+    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n+        let new = try!(combine(style, self.pos, self.buf.len(), pos));\n+        self.pos = new as uint;\n+        Ok(())\n+    }\n+}\n \n #[deriving(Encodable)]\n struct Foo {\n@@ -34,21 +151,21 @@ enum WireProtocol {\n fn encode_json<'a,\n                T: Encodable<json::Encoder<'a>,\n                             std::io::IoError>>(val: &T,\n-                                               wr: &'a mut MemWriter) {\n+                                               wr: &'a mut SeekableMemWriter) {\n     let mut encoder = json::Encoder::new(wr);\n     val.encode(&mut encoder);\n }\n fn encode_ebml<'a,\n-               T: Encodable<writer::Encoder<'a, MemWriter>,\n+               T: Encodable<writer::Encoder<'a, SeekableMemWriter>,\n                             std::io::IoError>>(val: &T,\n-                                               wr: &'a mut MemWriter) {\n+                                               wr: &'a mut SeekableMemWriter) {\n     let mut encoder = writer::Encoder::new(wr);\n     val.encode(&mut encoder);\n }\n \n pub fn main() {\n     let target = Foo{baz: false,};\n-    let mut wr = MemWriter::new();\n+    let mut wr = SeekableMemWriter::new();\n     let proto = JSON;\n     match proto {\n         JSON => encode_json(&target, &mut wr),"}]}