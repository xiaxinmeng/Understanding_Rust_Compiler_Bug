{"sha": "b3c72713def77769107488d91f600f805bd68419", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzYzcyNzEzZGVmNzc3NjkxMDc0ODhkOTFmNjAwZjgwNWJkNjg0MTk=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-25T01:25:57Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-25T01:25:57Z"}, "message": "tutorial: Swap order of data type/function sections. Add method discussion", "tree": {"sha": "f27703510b5f6d37da97f52462ab8add428f037c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f27703510b5f6d37da97f52462ab8add428f037c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3c72713def77769107488d91f600f805bd68419", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3c72713def77769107488d91f600f805bd68419", "html_url": "https://github.com/rust-lang/rust/commit/b3c72713def77769107488d91f600f805bd68419", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3c72713def77769107488d91f600f805bd68419/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9902135bdd5c5ca3c3f04c39a4057c0d0244fc33", "url": "https://api.github.com/repos/rust-lang/rust/commits/9902135bdd5c5ca3c3f04c39a4057c0d0244fc33", "html_url": "https://github.com/rust-lang/rust/commit/9902135bdd5c5ca3c3f04c39a4057c0d0244fc33"}], "stats": {"total": 158, "additions": 100, "deletions": 58}, "files": [{"sha": "a6aa156cda720e532055542113bb3cab7854cc10", "filename": "doc/tutorial.md", "status": "modified", "additions": 100, "deletions": 58, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/b3c72713def77769107488d91f600f805bd68419/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3c72713def77769107488d91f600f805bd68419/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=b3c72713def77769107488d91f600f805bd68419", "patch": "@@ -651,60 +651,6 @@ For more involved iteration, such as going over the elements of a\n collection, Rust uses higher-order functions. We'll come back to those\n in a moment.\n \n-# Functions\n-\n-Like all other static declarations, such as `type`, functions can be\n-declared both at the top level and inside other functions (or modules,\n-which we'll come back to [later](#modules-and-crates)).\n-\n-We've already seen several function definitions. They are introduced\n-with the `fn` keyword, the type of arguments are specified following\n-colons and the return type follows the arrow.\n-\n-~~~~\n-fn repeat(string: &str, count: int) -> ~str {\n-    let mut result = ~\"\";\n-    for count.times {\n-        result += string;\n-    }\n-    return result;\n-}\n-~~~~\n-\n-The `return` keyword immediately returns from the body of a function. It\n-is optionally followed by an expression to return. A function can\n-also return a value by having its top level block produce an\n-expression.\n-\n-~~~~\n-# const copernicus: int = 0;\n-fn int_to_str(i: int) -> ~str {\n-    if i == copernicus {\n-        return ~\"tube sock\";\n-    } else {\n-        return ~\"violin\";\n-    }\n-}\n-~~~~\n-\n-~~~~\n-# const copernicus: int = 0;\n-fn int_to_str(i: int) -> ~str {\n-    if i == copernicus { ~\"tube sock\" }\n-    else { ~\"violin\" }\n-}\n-~~~~\n-\n-Functions that do not return a value are said to return nil, `()`,\n-and both the return type and the return value may be omitted from\n-the definition. The following two functions are equivalent.\n-\n-~~~~\n-fn do_nothing_the_hard_way() -> () { return (); }\n-\n-fn do_nothing_the_easy_way() { }\n-~~~~\n-\n # Basic datatypes\n \n The core datatypes of Rust are structs, enums (tagged unions, algebraic data\n@@ -890,13 +836,109 @@ match mytup {\n }\n ~~~~\n \n+# Functions and methods\n+\n+We've already seen several function definitions. Like all other static\n+declarations, such as `type`, functions can be declared both at the\n+top level and inside other functions (or modules, which we'll come\n+back to [later](#modules-and-crates)). They are introduced with the\n+`fn` keyword, the type of arguments are specified following colons and\n+the return type follows the arrow.\n+\n+~~~~\n+fn repeat(string: &str, count: int) -> ~str {\n+    let mut result = ~\"\";\n+    for count.times {\n+        result += string;\n+    }\n+    return result;\n+}\n+~~~~\n+\n+The `return` keyword immediately returns from the body of a function. It\n+is optionally followed by an expression to return. A function can\n+also return a value by having its top level block produce an\n+expression.\n+\n+~~~~\n+# const copernicus: int = 0;\n+fn int_to_str(i: int) -> ~str {\n+    if i == copernicus {\n+        return ~\"tube sock\";\n+    } else {\n+        return ~\"violin\";\n+    }\n+}\n+~~~~\n+\n+~~~~\n+# const copernicus: int = 0;\n+fn int_to_str(i: int) -> ~str {\n+    if i == copernicus { ~\"tube sock\" }\n+    else { ~\"violin\" }\n+}\n+~~~~\n+\n+Functions that do not return a value are said to return nil, `()`,\n+and both the return type and the return value may be omitted from\n+the definition. The following two functions are equivalent.\n+\n+~~~~\n+fn do_nothing_the_hard_way() -> () { return (); }\n+\n+fn do_nothing_the_easy_way() { }\n+~~~~\n+\n+Methods are like functions, except that they are defined for a specific\n+'self' type (like 'this' in C++). Calling a method is done with\n+dot notation, as in `my_vec.len()`. Methods may be defined on most\n+Rust types with the `impl` keyword. As an example, lets define a draw\n+method on our `Shape` enum.\n+\n+~~~\n+struct Point {\n+    x: float,\n+    y: float\n+}\n+\n+enum Shape {\n+    Circle(Point, float),\n+    Rectangle(Point, Point)\n+}\n+\n+impl Shape {\n+    fn draw() {\n+        match self {\n+            Circle(p, f) => draw_circle(p, f),\n+            Rectangle(p1, p2) => draw_rectangle(p1, p2)\n+        }\n+    }\n+}\n+\n+let s = Circle(Point { x: 1f, y: 2f }, 3f };\n+s.draw();\n+~~~\n+\n+This defines an _implementation_ for `Shape` containing a single\n+method, `draw`. If we wanted we could add additional methods to the\n+same impl.  In most most respects the `draw` method is defined like\n+any other function, with the exception of the name `self`. `self` is a\n+special value that is automatically defined in each method, referring\n+to the value being operated on. We'll discuss methods more in the\n+context of [traits and generics](#generics).\n+\n+> ***Note:*** The method definition syntax will change to require\n+> declaring the self type explicitly, as the first argument.\n+\n # The Rust memory model\n \n At this junction let's take a detour to explain the concepts involved\n-in Rust's memory model. Rust has a very particular approach to\n-memory management that plays a significant role in shaping the \"feel\"\n-of the language. Understanding the memory landscape will illuminate\n-several of Rust's unique features as we encounter them.\n+in Rust's memory model. We've seen some of Rust's pointer sigils (`@`,\n+`~`, and `&`) float by in a few examples, and we aren't going to get\n+much further without explaining them. Rust has a very particular\n+approach to memory management that plays a significant role in shaping\n+the \"feel\" of the language. Understanding the memory landscape will\n+illuminate several of Rust's unique features as we encounter them.\n \n Rust has three competing goals that inform its view of memory:\n "}]}