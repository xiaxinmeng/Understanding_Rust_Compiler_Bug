{"sha": "4cbf23c192517cfebb0d754987aae95bc683b7a4", "node_id": "C_kwDOAAsO6NoAKDRjYmYyM2MxOTI1MTdjZmViYjBkNzU0OTg3YWFlOTViYzY4M2I3YTQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-12T13:29:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-12T13:29:25Z"}, "message": "Auto merge of #12747 - jonas-schievink:proc-macro-abi-1.63, r=jonas-schievink\n\nfix: Update 1.63 proc macro ABI to match rustc\n\nThis updates us to the ABI used by rustc 1.63.0-beta.5, which will likely be the ABI of the next stable Rust release. It should also work on nightly (for now, but future changes won't be supported until the rustc version is bumped).\n\ncc https://github.com/rust-lang/rust-analyzer/issues/12600", "tree": {"sha": "2210f0866bba7f2cfca73032aa10bd81536c7e96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2210f0866bba7f2cfca73032aa10bd81536c7e96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4cbf23c192517cfebb0d754987aae95bc683b7a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4cbf23c192517cfebb0d754987aae95bc683b7a4", "html_url": "https://github.com/rust-lang/rust/commit/4cbf23c192517cfebb0d754987aae95bc683b7a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4cbf23c192517cfebb0d754987aae95bc683b7a4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "caf23f29144b371035b864a1017dbc32573ad56d", "url": "https://api.github.com/repos/rust-lang/rust/commits/caf23f29144b371035b864a1017dbc32573ad56d", "html_url": "https://github.com/rust-lang/rust/commit/caf23f29144b371035b864a1017dbc32573ad56d"}, {"sha": "ebfbb314c03cd8e70198eebf5a96ece8a2f79e51", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebfbb314c03cd8e70198eebf5a96ece8a2f79e51", "html_url": "https://github.com/rust-lang/rust/commit/ebfbb314c03cd8e70198eebf5a96ece8a2f79e51"}], "stats": {"total": 424, "additions": 264, "deletions": 160}, "files": [{"sha": "102027d14a98450abf65c749076ec7b03f731b3c", "filename": "crates/proc-macro-srv/src/abis/abi_1_63/proc_macro/bridge/client.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4cbf23c192517cfebb0d754987aae95bc683b7a4/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbf23c192517cfebb0d754987aae95bc683b7a4/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fclient.rs?ref=4cbf23c192517cfebb0d754987aae95bc683b7a4", "patch": "@@ -178,8 +178,6 @@ define_handles! {\n     'owned:\n     FreeFunctions,\n     TokenStream,\n-    TokenStreamBuilder,\n-    TokenStreamIter,\n     Group,\n     Literal,\n     SourceFile,\n@@ -204,12 +202,6 @@ impl Clone for TokenStream {\n     }\n }\n \n-impl Clone for TokenStreamIter {\n-    fn clone(&self) -> Self {\n-        self.clone()\n-    }\n-}\n-\n impl Clone for Group {\n     fn clone(&self) -> Self {\n         self.clone()"}, {"sha": "c219a9465d39f2d091133298a697049cd0712c67", "filename": "crates/proc-macro-srv/src/abis/abi_1_63/proc_macro/bridge/handle.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4cbf23c192517cfebb0d754987aae95bc683b7a4/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbf23c192517cfebb0d754987aae95bc683b7a4/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fhandle.rs?ref=4cbf23c192517cfebb0d754987aae95bc683b7a4", "patch": "@@ -1,7 +1,7 @@\n //! Server-side handles and storage for per-handle data.\n \n use std::collections::{BTreeMap, HashMap};\n-use std::hash::Hash;\n+use std::hash::{BuildHasher, Hash};\n use std::num::NonZeroU32;\n use std::ops::{Index, IndexMut};\n use std::sync::atomic::{AtomicUsize, Ordering};\n@@ -51,15 +51,31 @@ impl<T> IndexMut<Handle> for OwnedStore<T> {\n     }\n }\n \n+// HACK(eddyb) deterministic `std::collections::hash_map::RandomState` replacement\n+// that doesn't require adding any dependencies to `proc_macro` (like `rustc-hash`).\n+#[derive(Clone)]\n+struct NonRandomState;\n+\n+impl BuildHasher for NonRandomState {\n+    type Hasher = std::collections::hash_map::DefaultHasher;\n+    #[inline]\n+    fn build_hasher(&self) -> Self::Hasher {\n+        Self::Hasher::new()\n+    }\n+}\n+\n /// Like `OwnedStore`, but avoids storing any value more than once.\n pub(super) struct InternedStore<T: 'static> {\n     owned: OwnedStore<T>,\n-    interner: HashMap<T, Handle>,\n+    interner: HashMap<T, Handle, NonRandomState>,\n }\n \n impl<T: Copy + Eq + Hash> InternedStore<T> {\n     pub(super) fn new(counter: &'static AtomicUsize) -> Self {\n-        InternedStore { owned: OwnedStore::new(counter), interner: HashMap::new() }\n+        InternedStore {\n+            owned: OwnedStore::new(counter),\n+            interner: HashMap::with_hasher(NonRandomState),\n+        }\n     }\n \n     pub(super) fn alloc(&mut self, x: T) -> Handle {"}, {"sha": "4967da4931a28758c03226f211931b6e540ecf09", "filename": "crates/proc-macro-srv/src/abis/abi_1_63/proc_macro/bridge/mod.rs", "status": "modified", "additions": 76, "deletions": 60, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/4cbf23c192517cfebb0d754987aae95bc683b7a4/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbf23c192517cfebb0d754987aae95bc683b7a4/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fmod.rs?ref=4cbf23c192517cfebb0d754987aae95bc683b7a4", "patch": "@@ -60,33 +60,29 @@ macro_rules! with_api {\n             TokenStream {\n                 fn drop($self: $S::TokenStream);\n                 fn clone($self: &$S::TokenStream) -> $S::TokenStream;\n-                fn new() -> $S::TokenStream;\n                 fn is_empty($self: &$S::TokenStream) -> bool;\n                 fn expand_expr($self: &$S::TokenStream) -> Result<$S::TokenStream, ()>;\n                 fn from_str(src: &str) -> $S::TokenStream;\n                 fn to_string($self: &$S::TokenStream) -> String;\n                 fn from_token_tree(\n                     tree: TokenTree<$S::Group, $S::Punct, $S::Ident, $S::Literal>,\n                 ) -> $S::TokenStream;\n-                fn into_iter($self: $S::TokenStream) -> $S::TokenStreamIter;\n-            },\n-            TokenStreamBuilder {\n-                fn drop($self: $S::TokenStreamBuilder);\n-                fn new() -> $S::TokenStreamBuilder;\n-                fn push($self: &mut $S::TokenStreamBuilder, stream: $S::TokenStream);\n-                fn build($self: $S::TokenStreamBuilder) -> $S::TokenStream;\n-            },\n-            TokenStreamIter {\n-                fn drop($self: $S::TokenStreamIter);\n-                fn clone($self: &$S::TokenStreamIter) -> $S::TokenStreamIter;\n-                fn next(\n-                    $self: &mut $S::TokenStreamIter,\n-                ) -> Option<TokenTree<$S::Group, $S::Punct, $S::Ident, $S::Literal>>;\n+                fn concat_trees(\n+                    base: Option<$S::TokenStream>,\n+                    trees: Vec<TokenTree<$S::Group, $S::Punct, $S::Ident, $S::Literal>>,\n+                ) -> $S::TokenStream;\n+                fn concat_streams(\n+                    base: Option<$S::TokenStream>,\n+                    streams: Vec<$S::TokenStream>,\n+                ) -> $S::TokenStream;\n+                fn into_trees(\n+                    $self: $S::TokenStream\n+                ) -> Vec<TokenTree<$S::Group, $S::Punct, $S::Ident, $S::Literal>>;\n             },\n             Group {\n                 fn drop($self: $S::Group);\n                 fn clone($self: &$S::Group) -> $S::Group;\n-                fn new(delimiter: Delimiter, stream: $S::TokenStream) -> $S::Group;\n+                fn new(delimiter: Delimiter, stream: Option<$S::TokenStream>) -> $S::Group;\n                 fn delimiter($self: &$S::Group) -> Delimiter;\n                 fn stream($self: &$S::Group) -> $S::TokenStream;\n                 fn span($self: &$S::Group) -> $S::Span;\n@@ -311,29 +307,18 @@ impl<'a, T, M> Unmark for &'a mut Marked<T, M> {\n     }\n }\n \n-impl<T: Mark> Mark for Option<T> {\n-    type Unmarked = Option<T::Unmarked>;\n-    fn mark(unmarked: Self::Unmarked) -> Self {\n-        unmarked.map(T::mark)\n-    }\n-}\n-impl<T: Unmark> Unmark for Option<T> {\n-    type Unmarked = Option<T::Unmarked>;\n-    fn unmark(self) -> Self::Unmarked {\n-        self.map(T::unmark)\n-    }\n-}\n-\n-impl<T: Mark, E: Mark> Mark for Result<T, E> {\n-    type Unmarked = Result<T::Unmarked, E::Unmarked>;\n+impl<T: Mark> Mark for Vec<T> {\n+    type Unmarked = Vec<T::Unmarked>;\n     fn mark(unmarked: Self::Unmarked) -> Self {\n-        unmarked.map(T::mark).map_err(E::mark)\n+        // Should be a no-op due to std's in-place collect optimizations.\n+        unmarked.into_iter().map(T::mark).collect()\n     }\n }\n-impl<T: Unmark, E: Unmark> Unmark for Result<T, E> {\n-    type Unmarked = Result<T::Unmarked, E::Unmarked>;\n+impl<T: Unmark> Unmark for Vec<T> {\n+    type Unmarked = Vec<T::Unmarked>;\n     fn unmark(self) -> Self::Unmarked {\n-        self.map(T::unmark).map_err(E::unmark)\n+        // Should be a no-op due to std's in-place collect optimizations.\n+        self.into_iter().map(T::unmark).collect()\n     }\n }\n \n@@ -367,7 +352,6 @@ mark_noop! {\n     Level,\n     LineColumn,\n     Spacing,\n-    Bound<usize>,\n }\n \n rpc_encode_decode!(\n@@ -394,6 +378,61 @@ rpc_encode_decode!(\n     }\n );\n \n+macro_rules! mark_compound {\n+    (enum $name:ident <$($T:ident),+> { $($variant:ident $(($field:ident))?),* $(,)? }) => {\n+        impl<$($T: Mark),+> Mark for $name <$($T),+> {\n+            type Unmarked = $name <$($T::Unmarked),+>;\n+            fn mark(unmarked: Self::Unmarked) -> Self {\n+                match unmarked {\n+                    $($name::$variant $(($field))? => {\n+                        $name::$variant $((Mark::mark($field)))?\n+                    })*\n+                }\n+            }\n+        }\n+\n+        impl<$($T: Unmark),+> Unmark for $name <$($T),+> {\n+            type Unmarked = $name <$($T::Unmarked),+>;\n+            fn unmark(self) -> Self::Unmarked {\n+                match self {\n+                    $($name::$variant $(($field))? => {\n+                        $name::$variant $((Unmark::unmark($field)))?\n+                    })*\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+macro_rules! compound_traits {\n+    ($($t:tt)*) => {\n+        rpc_encode_decode!($($t)*);\n+        mark_compound!($($t)*);\n+    };\n+}\n+\n+compound_traits!(\n+    enum Bound<T> {\n+        Included(x),\n+        Excluded(x),\n+        Unbounded,\n+    }\n+);\n+\n+compound_traits!(\n+    enum Option<T> {\n+        Some(t),\n+        None,\n+    }\n+);\n+\n+compound_traits!(\n+    enum Result<T, E> {\n+        Ok(t),\n+        Err(e),\n+    }\n+);\n+\n #[derive(Clone)]\n pub enum TokenTree<G, P, I, L> {\n     Group(G),\n@@ -402,30 +441,7 @@ pub enum TokenTree<G, P, I, L> {\n     Literal(L),\n }\n \n-impl<G: Mark, P: Mark, I: Mark, L: Mark> Mark for TokenTree<G, P, I, L> {\n-    type Unmarked = TokenTree<G::Unmarked, P::Unmarked, I::Unmarked, L::Unmarked>;\n-    fn mark(unmarked: Self::Unmarked) -> Self {\n-        match unmarked {\n-            TokenTree::Group(tt) => TokenTree::Group(G::mark(tt)),\n-            TokenTree::Punct(tt) => TokenTree::Punct(P::mark(tt)),\n-            TokenTree::Ident(tt) => TokenTree::Ident(I::mark(tt)),\n-            TokenTree::Literal(tt) => TokenTree::Literal(L::mark(tt)),\n-        }\n-    }\n-}\n-impl<G: Unmark, P: Unmark, I: Unmark, L: Unmark> Unmark for TokenTree<G, P, I, L> {\n-    type Unmarked = TokenTree<G::Unmarked, P::Unmarked, I::Unmarked, L::Unmarked>;\n-    fn unmark(self) -> Self::Unmarked {\n-        match self {\n-            TokenTree::Group(tt) => TokenTree::Group(tt.unmark()),\n-            TokenTree::Punct(tt) => TokenTree::Punct(tt.unmark()),\n-            TokenTree::Ident(tt) => TokenTree::Ident(tt.unmark()),\n-            TokenTree::Literal(tt) => TokenTree::Literal(tt.unmark()),\n-        }\n-    }\n-}\n-\n-rpc_encode_decode!(\n+compound_traits!(\n     enum TokenTree<G, P, I, L> {\n         Group(tt),\n         Punct(tt),"}, {"sha": "e9d7a46c06f6d270d66e848788e9f01fbd776e54", "filename": "crates/proc-macro-srv/src/abis/abi_1_63/proc_macro/bridge/rpc.rs", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/4cbf23c192517cfebb0d754987aae95bc683b7a4/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Frpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbf23c192517cfebb0d754987aae95bc683b7a4/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Frpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Frpc.rs?ref=4cbf23c192517cfebb0d754987aae95bc683b7a4", "patch": "@@ -4,7 +4,6 @@ use std::any::Any;\n use std::char;\n use std::io::Write;\n use std::num::NonZeroU32;\n-use std::ops::Bound;\n use std::str;\n \n pub(super) type Writer = super::buffer::Buffer;\n@@ -43,15 +42,17 @@ macro_rules! rpc_encode_decode {\n             }\n         }\n     };\n-    (struct $name:ident { $($field:ident),* $(,)? }) => {\n-        impl<S> Encode<S> for $name {\n+    (struct $name:ident $(<$($T:ident),+>)? { $($field:ident),* $(,)? }) => {\n+        impl<S, $($($T: Encode<S>),+)?> Encode<S> for $name $(<$($T),+>)? {\n             fn encode(self, w: &mut Writer, s: &mut S) {\n                 $(self.$field.encode(w, s);)*\n             }\n         }\n \n-        impl<S> DecodeMut<'_, '_, S> for $name {\n-            fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n+        impl<'a, S, $($($T: for<'s> DecodeMut<'a, 's, S>),+)?> DecodeMut<'a, '_, S>\n+            for $name $(<$($T),+>)?\n+        {\n+            fn decode(r: &mut Reader<'a>, s: &mut S) -> Self {\n                 $name {\n                     $($field: DecodeMut::decode(r, s)),*\n                 }\n@@ -184,28 +185,6 @@ impl<'a, S, A: for<'s> DecodeMut<'a, 's, S>, B: for<'s> DecodeMut<'a, 's, S>> De\n     }\n }\n \n-rpc_encode_decode!(\n-    enum Bound<T> {\n-        Included(x),\n-        Excluded(x),\n-        Unbounded,\n-    }\n-);\n-\n-rpc_encode_decode!(\n-    enum Option<T> {\n-        None,\n-        Some(x),\n-    }\n-);\n-\n-rpc_encode_decode!(\n-    enum Result<T, E> {\n-        Ok(x),\n-        Err(e),\n-    }\n-);\n-\n impl<S> Encode<S> for &[u8] {\n     fn encode(self, w: &mut Writer, s: &mut S) {\n         self.len().encode(w, s);\n@@ -246,6 +225,26 @@ impl<S> DecodeMut<'_, '_, S> for String {\n     }\n }\n \n+impl<S, T: Encode<S>> Encode<S> for Vec<T> {\n+    fn encode(self, w: &mut Writer, s: &mut S) {\n+        self.len().encode(w, s);\n+        for x in self {\n+            x.encode(w, s);\n+        }\n+    }\n+}\n+\n+impl<'a, S, T: for<'s> DecodeMut<'a, 's, S>> DecodeMut<'a, '_, S> for Vec<T> {\n+    fn decode(r: &mut Reader<'a>, s: &mut S) -> Self {\n+        let len = usize::decode(r, s);\n+        let mut vec = Vec::with_capacity(len);\n+        for _ in 0..len {\n+            vec.push(T::decode(r, s));\n+        }\n+        vec\n+    }\n+}\n+\n /// Simplified version of panic payloads, ignoring\n /// types other than `&'static str` and `String`.\n pub enum PanicMessage {"}, {"sha": "0fb3c6985894789c86770c043aceeabcf8924bfa", "filename": "crates/proc-macro-srv/src/abis/abi_1_63/proc_macro/bridge/server.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4cbf23c192517cfebb0d754987aae95bc683b7a4/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbf23c192517cfebb0d754987aae95bc683b7a4/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fserver.rs?ref=4cbf23c192517cfebb0d754987aae95bc683b7a4", "patch": "@@ -8,8 +8,6 @@ use super::client::HandleStore;\n pub trait Types {\n     type FreeFunctions: 'static;\n     type TokenStream: 'static + Clone;\n-    type TokenStreamBuilder: 'static;\n-    type TokenStreamIter: 'static + Clone;\n     type Group: 'static + Clone;\n     type Punct: 'static + Copy + Eq + Hash;\n     type Ident: 'static + Copy + Eq + Hash;\n@@ -275,13 +273,17 @@ fn run_server<\n }\n \n impl client::Client<super::super::TokenStream, super::super::TokenStream> {\n-    pub fn run<S: Server>(\n+    pub fn run<S>(\n         &self,\n         strategy: &impl ExecutionStrategy,\n         server: S,\n         input: S::TokenStream,\n         force_show_panics: bool,\n-    ) -> Result<S::TokenStream, PanicMessage> {\n+    ) -> Result<S::TokenStream, PanicMessage>\n+    where\n+        S: Server,\n+        S::TokenStream: Default,\n+    {\n         let client::Client { get_handle_counters, run, _marker } = *self;\n         run_server(\n             strategy,\n@@ -291,7 +293,7 @@ impl client::Client<super::super::TokenStream, super::super::TokenStream> {\n             run,\n             force_show_panics,\n         )\n-        .map(<MarkedTypes<S> as Types>::TokenStream::unmark)\n+        .map(|s| <Option<<MarkedTypes<S> as Types>::TokenStream>>::unmark(s).unwrap_or_default())\n     }\n }\n \n@@ -301,14 +303,18 @@ impl\n         super::super::TokenStream,\n     >\n {\n-    pub fn run<S: Server>(\n+    pub fn run<S>(\n         &self,\n         strategy: &impl ExecutionStrategy,\n         server: S,\n         input: S::TokenStream,\n         input2: S::TokenStream,\n         force_show_panics: bool,\n-    ) -> Result<S::TokenStream, PanicMessage> {\n+    ) -> Result<S::TokenStream, PanicMessage>\n+    where\n+        S: Server,\n+        S::TokenStream: Default,\n+    {\n         let client::Client { get_handle_counters, run, _marker } = *self;\n         run_server(\n             strategy,\n@@ -321,6 +327,6 @@ impl\n             run,\n             force_show_panics,\n         )\n-        .map(<MarkedTypes<S> as Types>::TokenStream::unmark)\n+        .map(|s| <Option<<MarkedTypes<S> as Types>::TokenStream>>::unmark(s).unwrap_or_default())\n     }\n }"}, {"sha": "c50a16bf4d1d813723dc43d08336743c5755a9ea", "filename": "crates/proc-macro-srv/src/abis/abi_1_63/proc_macro/mod.rs", "status": "modified", "additions": 78, "deletions": 18, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/4cbf23c192517cfebb0d754987aae95bc683b7a4/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbf23c192517cfebb0d754987aae95bc683b7a4/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fmod.rs?ref=4cbf23c192517cfebb0d754987aae95bc683b7a4", "patch": "@@ -47,7 +47,7 @@ pub fn is_available() -> bool {\n /// This is both the input and output of `#[proc_macro]`, `#[proc_macro_attribute]`\n /// and `#[proc_macro_derive]` definitions.\n #[derive(Clone)]\n-pub struct TokenStream(bridge::client::TokenStream);\n+pub struct TokenStream(Option<bridge::client::TokenStream>);\n \n /// Error returned from `TokenStream::from_str`.\n #[non_exhaustive]\n@@ -78,12 +78,12 @@ impl error::Error for ExpandError {}\n impl TokenStream {\n     /// Returns an empty `TokenStream` containing no token trees.\n     pub fn new() -> TokenStream {\n-        TokenStream(bridge::client::TokenStream::new())\n+        TokenStream(None)\n     }\n \n     /// Checks if this `TokenStream` is empty.\n     pub fn is_empty(&self) -> bool {\n-        self.0.is_empty()\n+        self.0.as_ref().map(|h| h.is_empty()).unwrap_or(true)\n     }\n \n     /// Parses this `TokenStream` as an expression and attempts to expand any\n@@ -97,8 +97,9 @@ impl TokenStream {\n     /// specific behavior for any error condition, and what conditions are\n     /// considered errors, is unspecified and may change in the future.\n     pub fn expand_expr(&self) -> Result<TokenStream, ExpandError> {\n-        match bridge::client::TokenStream::expand_expr(&self.0) {\n-            Ok(stream) => Ok(TokenStream(stream)),\n+        let stream = self.0.as_ref().ok_or(ExpandError)?;\n+        match bridge::client::TokenStream::expand_expr(stream) {\n+            Ok(stream) => Ok(TokenStream(Some(stream))),\n             Err(_) => Err(ExpandError),\n         }\n     }\n@@ -115,7 +116,7 @@ impl FromStr for TokenStream {\n     type Err = LexError;\n \n     fn from_str(src: &str) -> Result<TokenStream, LexError> {\n-        Ok(TokenStream(bridge::client::TokenStream::from_str(src)))\n+        Ok(TokenStream(Some(bridge::client::TokenStream::from_str(src))))\n     }\n }\n \n@@ -144,15 +145,64 @@ impl Default for TokenStream {\n \n pub use quote::{quote, quote_span};\n \n+fn tree_to_bridge_tree(\n+    tree: TokenTree,\n+) -> bridge::TokenTree<\n+    bridge::client::Group,\n+    bridge::client::Punct,\n+    bridge::client::Ident,\n+    bridge::client::Literal,\n+> {\n+    match tree {\n+        TokenTree::Group(tt) => bridge::TokenTree::Group(tt.0),\n+        TokenTree::Punct(tt) => bridge::TokenTree::Punct(tt.0),\n+        TokenTree::Ident(tt) => bridge::TokenTree::Ident(tt.0),\n+        TokenTree::Literal(tt) => bridge::TokenTree::Literal(tt.0),\n+    }\n+}\n+\n /// Creates a token stream containing a single token tree.\n impl From<TokenTree> for TokenStream {\n     fn from(tree: TokenTree) -> TokenStream {\n-        TokenStream(bridge::client::TokenStream::from_token_tree(match tree {\n-            TokenTree::Group(tt) => bridge::TokenTree::Group(tt.0),\n-            TokenTree::Punct(tt) => bridge::TokenTree::Punct(tt.0),\n-            TokenTree::Ident(tt) => bridge::TokenTree::Ident(tt.0),\n-            TokenTree::Literal(tt) => bridge::TokenTree::Literal(tt.0),\n-        }))\n+        TokenStream(Some(bridge::client::TokenStream::from_token_tree(tree_to_bridge_tree(tree))))\n+    }\n+}\n+\n+/// Non-generic helper for implementing `FromIterator<TokenStream>` and\n+/// `Extend<TokenStream>` with less monomorphization in calling crates.\n+struct ConcatStreamsHelper {\n+    streams: Vec<bridge::client::TokenStream>,\n+}\n+\n+impl ConcatStreamsHelper {\n+    fn new(capacity: usize) -> Self {\n+        ConcatStreamsHelper { streams: Vec::with_capacity(capacity) }\n+    }\n+\n+    fn push(&mut self, stream: TokenStream) {\n+        if let Some(stream) = stream.0 {\n+            self.streams.push(stream);\n+        }\n+    }\n+\n+    fn build(mut self) -> TokenStream {\n+        if self.streams.len() <= 1 {\n+            TokenStream(self.streams.pop())\n+        } else {\n+            TokenStream(Some(bridge::client::TokenStream::concat_streams(None, self.streams)))\n+        }\n+    }\n+\n+    fn append_to(mut self, stream: &mut TokenStream) {\n+        if self.streams.is_empty() {\n+            return;\n+        }\n+        let base = stream.0.take();\n+        if base.is_none() && self.streams.len() == 1 {\n+            stream.0 = self.streams.pop();\n+        } else {\n+            stream.0 = Some(bridge::client::TokenStream::concat_streams(base, self.streams));\n+        }\n     }\n }\n \n@@ -167,9 +217,10 @@ impl iter::FromIterator<TokenTree> for TokenStream {\n /// from multiple token streams into a single stream.\n impl iter::FromIterator<TokenStream> for TokenStream {\n     fn from_iter<I: IntoIterator<Item = TokenStream>>(streams: I) -> Self {\n-        let mut builder = bridge::client::TokenStreamBuilder::new();\n-        streams.into_iter().for_each(|stream| builder.push(stream.0));\n-        TokenStream(builder.build())\n+        let iter = streams.into_iter();\n+        let mut builder = ConcatStreamsHelper::new(iter.size_hint().0);\n+        iter.for_each(|stream| builder.push(stream));\n+        builder.build()\n     }\n }\n \n@@ -194,7 +245,16 @@ pub mod token_stream {\n     /// The iteration is \"shallow\", e.g., the iterator doesn't recurse into delimited groups,\n     /// and returns whole groups as token trees.\n     #[derive(Clone)]\n-    pub struct IntoIter(bridge::client::TokenStreamIter);\n+    pub struct IntoIter(\n+        std::vec::IntoIter<\n+            bridge::TokenTree<\n+                bridge::client::Group,\n+                bridge::client::Punct,\n+                bridge::client::Ident,\n+                bridge::client::Literal,\n+            >,\n+        >,\n+    );\n \n     impl Iterator for IntoIter {\n         type Item = TokenTree;\n@@ -214,7 +274,7 @@ pub mod token_stream {\n         type IntoIter = IntoIter;\n \n         fn into_iter(self) -> IntoIter {\n-            IntoIter(self.0.into_iter())\n+            IntoIter(self.0.map(|v| v.into_trees()).unwrap_or_default().into_iter())\n         }\n     }\n }\n@@ -560,7 +620,7 @@ impl Group {\n     /// Note that the returned token stream does not include the delimiter\n     /// returned above.\n     pub fn stream(&self) -> TokenStream {\n-        TokenStream(self.0.stream())\n+        TokenStream(Some(self.0.stream()))\n     }\n \n     /// Returns the span for the delimiters of this token stream, spanning the"}, {"sha": "7fd422ca292165b1ca4c2091b7de488330180d6f", "filename": "crates/proc-macro-srv/src/abis/abi_1_63/rustc_server.rs", "status": "modified", "additions": 51, "deletions": 36, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/4cbf23c192517cfebb0d754987aae95bc683b7a4/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Frustc_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbf23c192517cfebb0d754987aae95bc683b7a4/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Frustc_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Frustc_server.rs?ref=4cbf23c192517cfebb0d754987aae95bc683b7a4", "patch": "@@ -23,14 +23,14 @@ type Spacing = tt::Spacing;\n type Literal = tt::Literal;\n type Span = tt::TokenId;\n \n-#[derive(Debug, Clone)]\n+#[derive(Debug, Default, Clone)]\n pub struct TokenStream {\n     pub token_trees: Vec<TokenTree>,\n }\n \n impl TokenStream {\n     pub fn new() -> Self {\n-        TokenStream { token_trees: Default::default() }\n+        TokenStream::default()\n     }\n \n     pub fn with_subtree(subtree: tt::Subtree) -> Self {\n@@ -276,8 +276,6 @@ pub struct Rustc {\n impl server::Types for Rustc {\n     type FreeFunctions = FreeFunctions;\n     type TokenStream = TokenStream;\n-    type TokenStreamBuilder = TokenStreamBuilder;\n-    type TokenStreamIter = TokenStreamIter;\n     type Group = Group;\n     type Punct = Punct;\n     type Ident = IdentId;\n@@ -297,10 +295,6 @@ impl server::FreeFunctions for Rustc {\n }\n \n impl server::TokenStream for Rustc {\n-    fn new(&mut self) -> Self::TokenStream {\n-        Self::TokenStream::new()\n-    }\n-\n     fn is_empty(&mut self, stream: &Self::TokenStream) -> bool {\n         stream.is_empty()\n     }\n@@ -344,41 +338,55 @@ impl server::TokenStream for Rustc {\n         }\n     }\n \n-    fn into_iter(&mut self, stream: Self::TokenStream) -> Self::TokenStreamIter {\n-        let trees: Vec<TokenTree> = stream.into_iter().collect();\n-        TokenStreamIter { trees: trees.into_iter() }\n-    }\n-\n     fn expand_expr(&mut self, self_: &Self::TokenStream) -> Result<Self::TokenStream, ()> {\n         Ok(self_.clone())\n     }\n-}\n \n-impl server::TokenStreamBuilder for Rustc {\n-    fn new(&mut self) -> Self::TokenStreamBuilder {\n-        Self::TokenStreamBuilder::new()\n-    }\n-    fn push(&mut self, builder: &mut Self::TokenStreamBuilder, stream: Self::TokenStream) {\n-        builder.push(stream)\n+    fn concat_trees(\n+        &mut self,\n+        base: Option<Self::TokenStream>,\n+        trees: Vec<bridge::TokenTree<Self::Group, Self::Punct, Self::Ident, Self::Literal>>,\n+    ) -> Self::TokenStream {\n+        let mut builder = TokenStreamBuilder::new();\n+        if let Some(base) = base {\n+            builder.push(base);\n+        }\n+        for tree in trees {\n+            builder.push(self.from_token_tree(tree));\n+        }\n+        builder.build()\n     }\n-    fn build(&mut self, builder: Self::TokenStreamBuilder) -> Self::TokenStream {\n+\n+    fn concat_streams(\n+        &mut self,\n+        base: Option<Self::TokenStream>,\n+        streams: Vec<Self::TokenStream>,\n+    ) -> Self::TokenStream {\n+        let mut builder = TokenStreamBuilder::new();\n+        if let Some(base) = base {\n+            builder.push(base);\n+        }\n+        for stream in streams {\n+            builder.push(stream);\n+        }\n         builder.build()\n     }\n-}\n \n-impl server::TokenStreamIter for Rustc {\n-    fn next(\n+    fn into_trees(\n         &mut self,\n-        iter: &mut Self::TokenStreamIter,\n-    ) -> Option<bridge::TokenTree<Self::Group, Self::Punct, Self::Ident, Self::Literal>> {\n-        iter.trees.next().map(|tree| match tree {\n-            TokenTree::Subtree(group) => bridge::TokenTree::Group(group),\n-            TokenTree::Leaf(tt::Leaf::Ident(ident)) => {\n-                bridge::TokenTree::Ident(IdentId(self.ident_interner.intern(&IdentData(ident))))\n-            }\n-            TokenTree::Leaf(tt::Leaf::Literal(literal)) => bridge::TokenTree::Literal(literal),\n-            TokenTree::Leaf(tt::Leaf::Punct(punct)) => bridge::TokenTree::Punct(punct),\n-        })\n+        stream: Self::TokenStream,\n+    ) -> Vec<bridge::TokenTree<Self::Group, Self::Punct, Self::Ident, Self::Literal>> {\n+        stream\n+            .into_iter()\n+            .map(|tree| match tree {\n+                tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) => {\n+                    bridge::TokenTree::Ident(IdentId(self.ident_interner.intern(&IdentData(ident))))\n+                }\n+                tt::TokenTree::Leaf(tt::Leaf::Literal(lit)) => bridge::TokenTree::Literal(lit),\n+                tt::TokenTree::Leaf(tt::Leaf::Punct(punct)) => bridge::TokenTree::Punct(punct),\n+                tt::TokenTree::Subtree(subtree) => bridge::TokenTree::Group(subtree),\n+            })\n+            .collect()\n     }\n }\n \n@@ -416,8 +424,15 @@ fn spacing_to_external(spacing: Spacing) -> bridge::Spacing {\n }\n \n impl server::Group for Rustc {\n-    fn new(&mut self, delimiter: bridge::Delimiter, stream: Self::TokenStream) -> Self::Group {\n-        Self::Group { delimiter: delim_to_internal(delimiter), token_trees: stream.token_trees }\n+    fn new(\n+        &mut self,\n+        delimiter: bridge::Delimiter,\n+        stream: Option<Self::TokenStream>,\n+    ) -> Self::Group {\n+        Self::Group {\n+            delimiter: delim_to_internal(delimiter),\n+            token_trees: stream.unwrap_or_default().token_trees,\n+        }\n     }\n     fn delimiter(&mut self, group: &Self::Group) -> bridge::Delimiter {\n         delim_to_external(group.delimiter)"}]}