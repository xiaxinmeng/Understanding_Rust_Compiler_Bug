{"sha": "c5a6b51e442287d31b12591225d2e81a4345074d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1YTZiNTFlNDQyMjg3ZDMxYjEyNTkxMjI1ZDJlODFhNDM0NTA3NGQ=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-06-22T17:28:06Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-07-07T08:52:29Z"}, "message": "Update Cargo.lock and move size_and_align_of_dst back", "tree": {"sha": "b36df30f1b8b255b2ff1f08a715746540b6a7e3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b36df30f1b8b255b2ff1f08a715746540b6a7e3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5a6b51e442287d31b12591225d2e81a4345074d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5a6b51e442287d31b12591225d2e81a4345074d", "html_url": "https://github.com/rust-lang/rust/commit/c5a6b51e442287d31b12591225d2e81a4345074d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5a6b51e442287d31b12591225d2e81a4345074d/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c61531dc55296f7c4b58e52b1d3b53dbaa0713cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/c61531dc55296f7c4b58e52b1d3b53dbaa0713cc", "html_url": "https://github.com/rust-lang/rust/commit/c61531dc55296f7c4b58e52b1d3b53dbaa0713cc"}], "stats": {"total": 239, "additions": 132, "deletions": 107}, "files": [{"sha": "7e55642814bbae137443c37989e008cdb0669a8f", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 3, "deletions": 101, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/c5a6b51e442287d31b12591225d2e81a4345074d/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5a6b51e442287d31b12591225d2e81a4345074d/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=c5a6b51e442287d31b12591225d2e81a4345074d", "patch": "@@ -12,7 +12,9 @@\n \n //! Code that is useful in various codegen modules.\n \n-use llvm::{self, ValueRef, ContextRef, TypeKind, True, False, Bool, OperandBundleDef};\n+use llvm;\n+use llvm::{ValueRef, ContextRef, TypeKind};\n+use llvm::{True, False, Bool, OperandBundleDef};\n use rustc::hir::def_id::DefId;\n use rustc::middle::lang_items::LangItem;\n use abi;\n@@ -27,8 +29,6 @@ use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{HasDataLayout, LayoutOf};\n use rustc::hir;\n \n-use meth;\n-\n use libc::{c_uint, c_char};\n use std::iter;\n \n@@ -448,101 +448,3 @@ pub fn ty_fn_sig<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         _ => bug!(\"unexpected type {:?} to ty_fn_sig\", ty)\n     }\n }\n-\n-pub fn size_and_align_of_dst<'a, 'tcx>(bx: &Builder<'a, 'tcx>, t: Ty<'tcx>, info: ValueRef)\n-                                       -> (ValueRef, ValueRef) {\n-    debug!(\"calculate size of DST: {}; with lost info: {:?}\",\n-           t, Value(info));\n-    if bx.cx.type_is_sized(t) {\n-        let (size, align) = bx.cx.size_and_align_of(t);\n-        debug!(\"size_and_align_of_dst t={} info={:?} size: {:?} align: {:?}\",\n-               t, Value(info), size, align);\n-        let size = C_usize(bx.cx, size.bytes());\n-        let align = C_usize(bx.cx, align.abi());\n-        return (size, align);\n-    }\n-    assert!(!info.is_null());\n-    match t.sty {\n-        ty::TyDynamic(..) => {\n-            // load size/align from vtable\n-            (meth::SIZE.get_usize(bx, info), meth::ALIGN.get_usize(bx, info))\n-        }\n-        ty::TySlice(_) | ty::TyStr => {\n-            let unit = t.sequence_element_type(bx.tcx());\n-            // The info in this case is the length of the str, so the size is that\n-            // times the unit size.\n-            let (size, align) = bx.cx.size_and_align_of(unit);\n-            (bx.mul(info, C_usize(bx.cx, size.bytes())),\n-             C_usize(bx.cx, align.abi()))\n-        }\n-        _ => {\n-            let cx = bx.cx;\n-            // First get the size of all statically known fields.\n-            // Don't use size_of because it also rounds up to alignment, which we\n-            // want to avoid, as the unsized field's alignment could be smaller.\n-            assert!(!t.is_simd());\n-            let layout = cx.layout_of(t);\n-            debug!(\"DST {} layout: {:?}\", t, layout);\n-\n-            let i = layout.fields.count() - 1;\n-            let sized_size = layout.fields.offset(i).bytes();\n-            let sized_align = layout.align.abi();\n-            debug!(\"DST {} statically sized prefix size: {} align: {}\",\n-                   t, sized_size, sized_align);\n-            let sized_size = C_usize(cx, sized_size);\n-            let sized_align = C_usize(cx, sized_align);\n-\n-            // Recurse to get the size of the dynamically sized field (must be\n-            // the last field).\n-            let field_ty = layout.field(cx, i).ty;\n-            let (unsized_size, mut unsized_align) = size_and_align_of_dst(bx, field_ty, info);\n-\n-            // FIXME (#26403, #27023): We should be adding padding\n-            // to `sized_size` (to accommodate the `unsized_align`\n-            // required of the unsized field that follows) before\n-            // summing it with `sized_size`. (Note that since #26403\n-            // is unfixed, we do not yet add the necessary padding\n-            // here. But this is where the add would go.)\n-\n-            // Return the sum of sizes and max of aligns.\n-            let size = bx.add(sized_size, unsized_size);\n-\n-            // Packed types ignore the alignment of their fields.\n-            if let ty::TyAdt(def, _) = t.sty {\n-                if def.repr.packed() {\n-                    unsized_align = sized_align;\n-                }\n-            }\n-\n-            // Choose max of two known alignments (combined value must\n-            // be aligned according to more restrictive of the two).\n-            let align = match (const_to_opt_u128(sized_align, false),\n-                               const_to_opt_u128(unsized_align, false)) {\n-                (Some(sized_align), Some(unsized_align)) => {\n-                    // If both alignments are constant, (the sized_align should always be), then\n-                    // pick the correct alignment statically.\n-                    C_usize(cx, ::std::cmp::max(sized_align, unsized_align) as u64)\n-                }\n-                _ => bx.select(bx.icmp(llvm::IntUGT, sized_align, unsized_align),\n-                                sized_align,\n-                                unsized_align)\n-            };\n-\n-            // Issue #27023: must add any necessary padding to `size`\n-            // (to make it a multiple of `align`) before returning it.\n-            //\n-            // Namely, the returned size should be, in C notation:\n-            //\n-            //   `size + ((size & (align-1)) ? align : 0)`\n-            //\n-            // emulated via the semi-standard fast bit trick:\n-            //\n-            //   `(size + (align-1)) & -align`\n-\n-            let addend = bx.sub(align, C_usize(bx.cx, 1));\n-            let size = bx.and(bx.add(size, addend), bx.neg(align));\n-\n-            (size, align)\n-        }\n-    }\n-}"}, {"sha": "c7275d094018567f7221192ea2cec1c20ecaf7a7", "filename": "src/librustc_codegen_llvm/glue.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/c5a6b51e442287d31b12591225d2e81a4345074d/src%2Flibrustc_codegen_llvm%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5a6b51e442287d31b12591225d2e81a4345074d/src%2Flibrustc_codegen_llvm%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fglue.rs?ref=c5a6b51e442287d31b12591225d2e81a4345074d", "patch": "@@ -0,0 +1,122 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//!\n+//\n+// Code relating to drop glue.\n+\n+use std;\n+\n+use builder::Builder;\n+use common::*;\n+use llvm::{ValueRef};\n+use llvm;\n+use meth;\n+use rustc::ty::layout::LayoutOf;\n+use rustc::ty::{self, Ty};\n+use value::Value;\n+\n+pub fn size_and_align_of_dst<'a, 'tcx>(bx: &Builder<'a, 'tcx>, t: Ty<'tcx>, info: ValueRef)\n+                                       -> (ValueRef, ValueRef) {\n+    debug!(\"calculate size of DST: {}; with lost info: {:?}\",\n+           t, Value(info));\n+    if bx.cx.type_is_sized(t) {\n+        let (size, align) = bx.cx.size_and_align_of(t);\n+        debug!(\"size_and_align_of_dst t={} info={:?} size: {:?} align: {:?}\",\n+               t, Value(info), size, align);\n+        let size = C_usize(bx.cx, size.bytes());\n+        let align = C_usize(bx.cx, align.abi());\n+        return (size, align);\n+    }\n+    assert!(!info.is_null());\n+    match t.sty {\n+        ty::TyDynamic(..) => {\n+            // load size/align from vtable\n+            (meth::SIZE.get_usize(bx, info), meth::ALIGN.get_usize(bx, info))\n+        }\n+        ty::TySlice(_) | ty::TyStr => {\n+            let unit = t.sequence_element_type(bx.tcx());\n+            // The info in this case is the length of the str, so the size is that\n+            // times the unit size.\n+            let (size, align) = bx.cx.size_and_align_of(unit);\n+            (bx.mul(info, C_usize(bx.cx, size.bytes())),\n+             C_usize(bx.cx, align.abi()))\n+        }\n+        _ => {\n+            let cx = bx.cx;\n+            // First get the size of all statically known fields.\n+            // Don't use size_of because it also rounds up to alignment, which we\n+            // want to avoid, as the unsized field's alignment could be smaller.\n+            assert!(!t.is_simd());\n+            let layout = cx.layout_of(t);\n+            debug!(\"DST {} layout: {:?}\", t, layout);\n+\n+            let i = layout.fields.count() - 1;\n+            let sized_size = layout.fields.offset(i).bytes();\n+            let sized_align = layout.align.abi();\n+            debug!(\"DST {} statically sized prefix size: {} align: {}\",\n+                   t, sized_size, sized_align);\n+            let sized_size = C_usize(cx, sized_size);\n+            let sized_align = C_usize(cx, sized_align);\n+\n+            // Recurse to get the size of the dynamically sized field (must be\n+            // the last field).\n+            let field_ty = layout.field(cx, i).ty;\n+            let (unsized_size, mut unsized_align) = size_and_align_of_dst(bx, field_ty, info);\n+\n+            // FIXME (#26403, #27023): We should be adding padding\n+            // to `sized_size` (to accommodate the `unsized_align`\n+            // required of the unsized field that follows) before\n+            // summing it with `sized_size`. (Note that since #26403\n+            // is unfixed, we do not yet add the necessary padding\n+            // here. But this is where the add would go.)\n+\n+            // Return the sum of sizes and max of aligns.\n+            let size = bx.add(sized_size, unsized_size);\n+\n+            // Packed types ignore the alignment of their fields.\n+            if let ty::TyAdt(def, _) = t.sty {\n+                if def.repr.packed() {\n+                    unsized_align = sized_align;\n+                }\n+            }\n+\n+            // Choose max of two known alignments (combined value must\n+            // be aligned according to more restrictive of the two).\n+            let align = match (const_to_opt_u128(sized_align, false),\n+                               const_to_opt_u128(unsized_align, false)) {\n+                (Some(sized_align), Some(unsized_align)) => {\n+                    // If both alignments are constant, (the sized_align should always be), then\n+                    // pick the correct alignment statically.\n+                    C_usize(cx, std::cmp::max(sized_align, unsized_align) as u64)\n+                }\n+                _ => bx.select(bx.icmp(llvm::IntUGT, sized_align, unsized_align),\n+                                sized_align,\n+                                unsized_align)\n+            };\n+\n+            // Issue #27023: must add any necessary padding to `size`\n+            // (to make it a multiple of `align`) before returning it.\n+            //\n+            // Namely, the returned size should be, in C notation:\n+            //\n+            //   `size + ((size & (align-1)) ? align : 0)`\n+            //\n+            // emulated via the semi-standard fast bit trick:\n+            //\n+            //   `(size + (align-1)) & -align`\n+\n+            let addend = bx.sub(align, C_usize(bx.cx, 1));\n+            let size = bx.and(bx.add(size, addend), bx.neg(align));\n+\n+            (size, align)\n+        }\n+    }\n+}"}, {"sha": "6bb5456f9034f7ee91d3c45b24a8e6055b322a46", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c5a6b51e442287d31b12591225d2e81a4345074d/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5a6b51e442287d31b12591225d2e81a4345074d/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=c5a6b51e442287d31b12591225d2e81a4345074d", "patch": "@@ -19,6 +19,7 @@ use mir::operand::{OperandRef, OperandValue};\n use base::*;\n use common::*;\n use declare;\n+use glue;\n use type_::Type;\n use type_of::LayoutLlvmExt;\n use rustc::ty::{self, Ty};\n@@ -145,7 +146,7 @@ pub fn codegen_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n             let tp_ty = substs.type_at(0);\n             if let OperandValue::Pair(_, meta) = args[0].val {\n                 let (llsize, _) =\n-                    size_and_align_of_dst(bx, tp_ty, meta);\n+                    glue::size_and_align_of_dst(bx, tp_ty, meta);\n                 llsize\n             } else {\n                 C_usize(cx, cx.size_of(tp_ty).bytes())\n@@ -159,7 +160,7 @@ pub fn codegen_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n             let tp_ty = substs.type_at(0);\n             if let OperandValue::Pair(_, meta) = args[0].val {\n                 let (_, llalign) =\n-                    size_and_align_of_dst(bx, tp_ty, meta);\n+                    glue::size_and_align_of_dst(bx, tp_ty, meta);\n                 llalign\n             } else {\n                 C_usize(cx, cx.align_of(tp_ty).abi())"}, {"sha": "eee4e5f8f7a099b3392e7e5b813a9e671550a487", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c5a6b51e442287d31b12591225d2e81a4345074d/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5a6b51e442287d31b12591225d2e81a4345074d/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=c5a6b51e442287d31b12591225d2e81a4345074d", "patch": "@@ -109,6 +109,7 @@ mod consts;\n mod context;\n mod debuginfo;\n mod declare;\n+mod glue;\n mod intrinsic;\n mod llvm_util;\n mod metadata;"}, {"sha": "2a1e3980adbcfaa58ee83880d10818127ce5d8cb", "filename": "src/librustc_codegen_llvm/mir/place.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c5a6b51e442287d31b12591225d2e81a4345074d/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5a6b51e442287d31b12591225d2e81a4345074d/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs?ref=c5a6b51e442287d31b12591225d2e81a4345074d", "patch": "@@ -16,13 +16,12 @@ use rustc::mir::tcx::PlaceTy;\n use rustc_data_structures::indexed_vec::Idx;\n use base;\n use builder::Builder;\n-use common::{\n-    CodegenCx, C_undef, C_usize, C_u8, C_u32, C_uint, C_null, C_uint_big,size_and_align_of_dst\n-};\n+use common::{CodegenCx, C_undef, C_usize, C_u8, C_u32, C_uint, C_null, C_uint_big};\n use consts;\n use type_of::LayoutLlvmExt;\n use type_::Type;\n use value::Value;\n+use glue;\n \n use std::ptr;\n \n@@ -223,7 +222,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n         let unaligned_offset = C_usize(cx, offset.bytes());\n \n         // Get the alignment of the field\n-        let (_, unsized_align) = size_and_align_of_dst(bx, field.ty, meta);\n+        let (_, unsized_align) = glue::size_and_align_of_dst(bx, field.ty, meta);\n \n         // Bump the unaligned offset up to the appropriate alignment using the\n         // following expression:"}]}