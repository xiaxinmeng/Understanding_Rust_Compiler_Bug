{"sha": "cf34b31704257ef79cd0f9286314c10fa15b7bf9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmMzRiMzE3MDQyNTdlZjc5Y2QwZjkyODYzMTRjMTBmYTE1YjdiZjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-11T16:37:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-11T16:37:01Z"}, "message": "auto merge of #5825 : danluu/rust/rngdoc, r=erickt\n\nThis adds an example for most of the methods in Rng.\r\n\r\nAs a total newcomer to Rust, it took a while to figure out how to do basic things like use library functions, because there aren't many usage examples, and most examples that Google turns up are out of date. Something like this would have saved me a bit of time.\r\n\r\nThis might be a bit verbose. Some alternative options would be to consolidate all the examples into one section, or to only have code for the specific function call inline.", "tree": {"sha": "cdad6841ea9999a6f5c21a2ded5fdd884678e678", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cdad6841ea9999a6f5c21a2ded5fdd884678e678"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf34b31704257ef79cd0f9286314c10fa15b7bf9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf34b31704257ef79cd0f9286314c10fa15b7bf9", "html_url": "https://github.com/rust-lang/rust/commit/cf34b31704257ef79cd0f9286314c10fa15b7bf9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf34b31704257ef79cd0f9286314c10fa15b7bf9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3c8f524b855682887c6e9c7b6ca4238e256c2b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3c8f524b855682887c6e9c7b6ca4238e256c2b0", "html_url": "https://github.com/rust-lang/rust/commit/a3c8f524b855682887c6e9c7b6ca4238e256c2b0"}, {"sha": "aff558998ef98b4c80cace32538ba23ee67a4d6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/aff558998ef98b4c80cace32538ba23ee67a4d6d", "html_url": "https://github.com/rust-lang/rust/commit/aff558998ef98b4c80cace32538ba23ee67a4d6d"}], "stats": {"total": 192, "additions": 183, "deletions": 9}, "files": [{"sha": "c6400ccded8a675e61d19921d9136cc4b3d22685", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 183, "deletions": 9, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/cf34b31704257ef79cd0f9286314c10fa15b7bf9/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf34b31704257ef79cd0f9286314c10fa15b7bf9/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=cf34b31704257ef79cd0f9286314c10fa15b7bf9", "patch": "@@ -150,7 +150,21 @@ pub struct Weighted<T> {\n \n pub trait RngUtil {\n     fn gen<T:Rand>(&self) -> T;\n-    /// Return a random int\n+    /**\n+     * Return a random int\n+     *\n+     * *Example*\n+     *\n+     * ~~~\n+     *\n+     * use core::rand::RngUtil;\n+     *\n+     * fn main() {\n+     *     rng = rand::Rng();\n+     *     println(fmt!(\"%d\",rng.gen_int()));\n+     * }\n+     * ~~~\n+     */\n     fn gen_int(&self) -> int;\n     fn gen_int_range(&self, start: int, end: int) -> int;\n     /// Return a random i8\n@@ -176,7 +190,21 @@ pub trait RngUtil {\n     fn gen_u32(&self) -> u32;\n     /// Return a random u64\n     fn gen_u64(&self) -> u64;\n-    /// Return a random float in the interval [0,1]\n+    /**\n+     * Return random float in the interval [0,1]\n+     *\n+     * *Example*\n+     *\n+     * ~~~\n+     *\n+     * use core::rand::RngUtil;\n+     *\n+     * fn main() {\n+     *     rng = rand::Rng();\n+     *     println(fmt!(\"%f\",rng.gen_float()));\n+     * }\n+     * ~~~\n+     */\n     fn gen_float(&self) -> float;\n     /// Return a random f32 in the interval [0,1]\n     fn gen_f32(&self) -> f32;\n@@ -188,38 +216,184 @@ pub trait RngUtil {\n      * Return a char randomly chosen from chars, failing if chars is empty\n      */\n     fn gen_char_from(&self, chars: &str) -> char;\n-    /// Return a random bool\n+    /**\n+     * Return a random bool\n+     *\n+     * *Example*\n+     *\n+     * ~~~\n+     *\n+     * use core::rand::RngUtil;\n+     *\n+     * fn main() {\n+     *     rng = rand::Rng();\n+     *     println(fmt!(\"%b\",rng.gen_bool()));\n+     * }\n+     * ~~~\n+     */\n     fn gen_bool(&self) -> bool;\n-    /// Return a bool with a 1 in n chance of true\n+    /**\n+     * Return a bool with a 1 in n chance of true\n+     *\n+     * *Example*\n+     *\n+     * ~~~\n+     *\n+     * use core::rand::RngUtil;\n+     *\n+     * fn main() {\n+     *     rng = rand::Rng();\n+     *     println(fmt!(\"%b\",rng.gen_weighted_bool(3)));\n+     * }\n+     * ~~~\n+     */\n     fn gen_weighted_bool(&self, n: uint) -> bool;\n     /**\n      * Return a random string of the specified length composed of A-Z,a-z,0-9\n+     *\n+     * *Example*\n+     *\n+     * ~~~\n+     *\n+     * use core::rand::RngUtil;\n+     *\n+     * fn main() {\n+     *     rng = rand::Rng();\n+     *     println(rng.gen_str(8));\n+     * }\n+     * ~~~\n      */\n     fn gen_str(&self, len: uint) -> ~str;\n-    /// Return a random byte string of the specified length\n+    /**\n+     * Return a random byte string of the specified length\n+     *\n+     * *Example*\n+     *\n+     * ~~~\n+     *\n+     * use core::rand::RngUtil;\n+     *\n+     * fn main() {\n+     *     rng = rand::Rng();\n+     *     println(fmt!(\"%?\",rng.gen_bytes(8)));\n+     * }\n+     * ~~~\n+     */\n     fn gen_bytes(&self, len: uint) -> ~[u8];\n-    /// Choose an item randomly, failing if values is empty\n+    ///\n+    /**\n+     * Choose an item randomly, failing if values is empty\n+     *\n+     * *Example*\n+     *\n+     * ~~~\n+     *\n+     * use core::rand::RngUtil;\n+     *\n+     * fn main() {\n+     *     rng = rand::Rng();\n+     *     println(fmt!(\"%d\",rng.choose([1,2,4,8,16,32])));\n+     * }\n+     * ~~~\n+     */\n     fn choose<T:Copy>(&self, values: &[T]) -> T;\n     /// Choose Some(item) randomly, returning None if values is empty\n     fn choose_option<T:Copy>(&self, values: &[T]) -> Option<T>;\n     /**\n      * Choose an item respecting the relative weights, failing if the sum of\n      * the weights is 0\n+     *\n+     * *Example*\n+     *\n+     * ~~~\n+     *\n+     * use core::rand::RngUtil;\n+     *\n+     * fn main() {\n+     *     rng = rand::Rng();\n+     *     let x = [rand::Weighted {weight: 4, item: 'a'},\n+     *              rand::Weighted {weight: 2, item: 'b'},\n+     *              rand::Weighted {weight: 2, item: 'c'}];\n+     *     println(fmt!(\"%c\",rng.choose_weighted(x)));\n+     * }\n+     * ~~~\n      */\n     fn choose_weighted<T:Copy>(&self, v : &[Weighted<T>]) -> T;\n     /**\n      * Choose Some(item) respecting the relative weights, returning none if\n      * the sum of the weights is 0\n+     *\n+     * *Example*\n+     *\n+     * ~~~\n+     *\n+     * use core::rand::RngUtil;\n+     *\n+     * fn main() {\n+     *     rng = rand::Rng();\n+     *     let x = [rand::Weighted {weight: 4, item: 'a'},\n+     *              rand::Weighted {weight: 2, item: 'b'},\n+     *              rand::Weighted {weight: 2, item: 'c'}];\n+     *     println(fmt!(\"%?\",rng.choose_weighted_option(x)));\n+     * }\n+     * ~~~\n      */\n     fn choose_weighted_option<T:Copy>(&self, v: &[Weighted<T>]) -> Option<T>;\n     /**\n      * Return a vec containing copies of the items, in order, where\n      * the weight of the item determines how many copies there are\n+     *\n+     * *Example*\n+     *\n+     * ~~~\n+     *\n+     * use core::rand::RngUtil;\n+     *\n+     * fn main() {\n+     *     rng = rand::Rng();\n+     *     let x = [rand::Weighted {weight: 4, item: 'a'},\n+     *              rand::Weighted {weight: 2, item: 'b'},\n+     *              rand::Weighted {weight: 2, item: 'c'}];\n+     *     println(fmt!(\"%?\",rng.weighted_vec(x)));\n+     * }\n+     * ~~~\n      */\n     fn weighted_vec<T:Copy>(&self, v: &[Weighted<T>]) -> ~[T];\n-    /// Shuffle a vec\n+    /**\n+     * Shuffle a vec\n+     *\n+     * *Example*\n+     *\n+     * ~~~\n+     *\n+     * use core::rand::RngUtil;\n+     *\n+     * fn main() {\n+     *     rng = rand::Rng();\n+     *     println(fmt!(\"%?\",rng.shuffle([1,2,3])));\n+     * }\n+     * ~~~\n+     */\n     fn shuffle<T:Copy>(&self, values: &[T]) -> ~[T];\n-    /// Shuffle a mutable vec in place\n+    /**\n+     * Shuffle a mutable vec in place\n+     *\n+     * *Example*\n+     *\n+     * ~~~\n+     *\n+     * use core::rand::RngUtil;\n+     *\n+     * fn main() {\n+     *     rng = rand::Rng();\n+     *     let mut y = [1,2,3];\n+     *     rng.shuffle_mut(y);\n+     *     println(fmt!(\"%?\",y));\n+     *     rng.shuffle_mut(y);\n+     *     println(fmt!(\"%?\",y));\n+     * }\n+     * ~~~\n+     */\n     fn shuffle_mut<T>(&self, values: &mut [T]);\n }\n \n@@ -337,7 +511,7 @@ impl RngUtil for @Rng {\n         self.next() & 1u32 == 1u32\n     }\n \n-    /// Return a bool with a 1 in n chance of true\n+    /// Return a bool with a 1-in-n chance of true\n     fn gen_weighted_bool(&self, n: uint) -> bool {\n         if n == 0u {\n             true"}]}