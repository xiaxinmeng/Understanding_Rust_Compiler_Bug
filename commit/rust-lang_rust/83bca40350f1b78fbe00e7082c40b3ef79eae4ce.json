{"sha": "83bca40350f1b78fbe00e7082c40b3ef79eae4ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzYmNhNDAzNTBmMWI3OGZiZTAwZTcwODJjNDBiM2VmNzllYWU0Y2U=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2017-09-16T17:24:08Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2017-10-20T14:04:32Z"}, "message": "Add short message-format", "tree": {"sha": "d77d1ee5462154a044af8099dfec8e3e71ed9ab0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d77d1ee5462154a044af8099dfec8e3e71ed9ab0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83bca40350f1b78fbe00e7082c40b3ef79eae4ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83bca40350f1b78fbe00e7082c40b3ef79eae4ce", "html_url": "https://github.com/rust-lang/rust/commit/83bca40350f1b78fbe00e7082c40b3ef79eae4ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83bca40350f1b78fbe00e7082c40b3ef79eae4ce/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0e0a38101e750737e431b894167a8202ca8f46c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0e0a38101e750737e431b894167a8202ca8f46c", "html_url": "https://github.com/rust-lang/rust/commit/c0e0a38101e750737e431b894167a8202ca8f46c"}], "stats": {"total": 372, "additions": 223, "deletions": 149}, "files": [{"sha": "2710094d4c1fecacde782066eccaf648d4a41f93", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/83bca40350f1b78fbe00e7082c40b3ef79eae4ce/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83bca40350f1b78fbe00e7082c40b3ef79eae4ce/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=83bca40350f1b78fbe00e7082c40b3ef79eae4ce", "patch": "@@ -156,6 +156,7 @@ impl OutputType {\n pub enum ErrorOutputType {\n     HumanReadable(ColorConfig),\n     Json,\n+    Short(ColorConfig),\n }\n \n impl Default for ErrorOutputType {\n@@ -1362,7 +1363,7 @@ pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n         opt::multi(\"Z\", \"\", \"Set internal debugging options\", \"FLAG\"),\n         opt::opt_s(\"\", \"error-format\",\n                       \"How errors and other messages are produced\",\n-                      \"human|json\"),\n+                      \"human|json|short\"),\n         opt::opt_s(\"\", \"color\", \"Configure coloring of output:\n                                  auto   = colorize, if output goes to a tty (default);\n                                  always = always colorize output;\n@@ -1429,15 +1430,16 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n     // opt_present because the latter will panic.\n     let error_format = if matches.opts_present(&[\"error-format\".to_owned()]) {\n         match matches.opt_str(\"error-format\").as_ref().map(|s| &s[..]) {\n-            Some(\"human\")   => ErrorOutputType::HumanReadable(color),\n-            Some(\"json\") => ErrorOutputType::Json,\n+            Some(\"human\") => ErrorOutputType::HumanReadable(color),\n+            Some(\"json\")  => ErrorOutputType::Json,\n+            Some(\"short\") => ErrorOutputType::Short(color),\n \n             None => ErrorOutputType::HumanReadable(color),\n \n             Some(arg) => {\n                 early_error(ErrorOutputType::HumanReadable(color),\n-                            &format!(\"argument for --error-format must be human or json (instead \\\n-                                      was `{}`)\",\n+                            &format!(\"argument for --error-format must be `human`, `json` or \\\n+                                      `short` (instead was `{}`)\",\n                                      arg))\n             }\n         }"}, {"sha": "050487bcc002236ebdbb034d9618e5fd549c677e", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/83bca40350f1b78fbe00e7082c40b3ef79eae4ce/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83bca40350f1b78fbe00e7082c40b3ef79eae4ce/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=83bca40350f1b78fbe00e7082c40b3ef79eae4ce", "patch": "@@ -711,19 +711,23 @@ pub fn build_session_with_codemap(sopts: config::Options,\n \n     let emitter: Box<Emitter> = match (sopts.error_format, emitter_dest) {\n         (config::ErrorOutputType::HumanReadable(color_config), None) => {\n-            Box::new(EmitterWriter::stderr(color_config,\n-                                           Some(codemap.clone())))\n+            Box::new(EmitterWriter::stderr(color_config, Some(codemap.clone()), false))\n         }\n         (config::ErrorOutputType::HumanReadable(_), Some(dst)) => {\n-            Box::new(EmitterWriter::new(dst,\n-                                        Some(codemap.clone())))\n+            Box::new(EmitterWriter::new(dst, Some(codemap.clone()), false))\n         }\n         (config::ErrorOutputType::Json, None) => {\n             Box::new(JsonEmitter::stderr(Some(registry), codemap.clone()))\n         }\n         (config::ErrorOutputType::Json, Some(dst)) => {\n             Box::new(JsonEmitter::new(dst, Some(registry), codemap.clone()))\n         }\n+        (config::ErrorOutputType::Short(color_config), None) => {\n+            Box::new(EmitterWriter::stderr(color_config, Some(codemap.clone()), true))\n+        }\n+        (config::ErrorOutputType::Short(_), Some(dst)) => {\n+            Box::new(EmitterWriter::new(dst, Some(codemap.clone()), true))\n+        }\n     };\n \n     let diagnostic_handler =\n@@ -867,10 +871,12 @@ pub enum IncrCompSession {\n pub fn early_error(output: config::ErrorOutputType, msg: &str) -> ! {\n     let emitter: Box<Emitter> = match output {\n         config::ErrorOutputType::HumanReadable(color_config) => {\n-            Box::new(EmitterWriter::stderr(color_config,\n-                                           None))\n+            Box::new(EmitterWriter::stderr(color_config, None, false))\n         }\n         config::ErrorOutputType::Json => Box::new(JsonEmitter::basic()),\n+        config::ErrorOutputType::Short(color_config) => {\n+            Box::new(EmitterWriter::stderr(color_config, None, true))\n+        }\n     };\n     let handler = errors::Handler::with_emitter(true, false, emitter);\n     handler.emit(&MultiSpan::new(), msg, errors::Level::Fatal);\n@@ -880,10 +886,12 @@ pub fn early_error(output: config::ErrorOutputType, msg: &str) -> ! {\n pub fn early_warn(output: config::ErrorOutputType, msg: &str) {\n     let emitter: Box<Emitter> = match output {\n         config::ErrorOutputType::HumanReadable(color_config) => {\n-            Box::new(EmitterWriter::stderr(color_config,\n-                                           None))\n+            Box::new(EmitterWriter::stderr(color_config, None, false))\n         }\n         config::ErrorOutputType::Json => Box::new(JsonEmitter::basic()),\n+        config::ErrorOutputType::Short(color_config) => {\n+            Box::new(EmitterWriter::stderr(color_config, None, true))\n+        }\n     };\n     let handler = errors::Handler::with_emitter(true, false, emitter);\n     handler.emit(&MultiSpan::new(), msg, errors::Level::Warning);"}, {"sha": "fc503f4eb4be16ac33422a19e07da7f61f76d358", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/83bca40350f1b78fbe00e7082c40b3ef79eae4ce/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83bca40350f1b78fbe00e7082c40b3ef79eae4ce/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=83bca40350f1b78fbe00e7082c40b3ef79eae4ce", "patch": "@@ -138,7 +138,9 @@ pub fn run<F>(run_compiler: F) -> isize\n                 }\n                 None => {\n                     let emitter =\n-                        errors::emitter::EmitterWriter::stderr(errors::ColorConfig::Auto, None);\n+                        errors::emitter::EmitterWriter::stderr(errors::ColorConfig::Auto,\n+                                                               None,\n+                                                               true);\n                     let handler = errors::Handler::with_emitter(true, false, Box::new(emitter));\n                     handler.emit(&MultiSpan::new(),\n                                  \"aborting due to previous error(s)\",\n@@ -1208,7 +1210,9 @@ pub fn monitor<F: FnOnce() + Send + 'static>(f: F) {\n         // Thread panicked without emitting a fatal diagnostic\n         if !value.is::<errors::FatalError>() {\n             let emitter =\n-                Box::new(errors::emitter::EmitterWriter::stderr(errors::ColorConfig::Auto, None));\n+                Box::new(errors::emitter::EmitterWriter::stderr(errors::ColorConfig::Auto,\n+                                                                None,\n+                                                                false));\n             let handler = errors::Handler::with_emitter(true, false, emitter);\n \n             // a .span_bug or .bug call has already printed what"}, {"sha": "5db5a9a1133d8dcb2fe5307c8b72c92e656da606", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 164, "deletions": 130, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/83bca40350f1b78fbe00e7082c40b3ef79eae4ce/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83bca40350f1b78fbe00e7082c40b3ef79eae4ce/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=83bca40350f1b78fbe00e7082c40b3ef79eae4ce", "patch": "@@ -107,6 +107,7 @@ impl ColorConfig {\n pub struct EmitterWriter {\n     dst: Destination,\n     cm: Option<Rc<CodeMapper>>,\n+    short_message: bool,\n }\n \n struct FileWithAnnotatedLines {\n@@ -116,25 +117,34 @@ struct FileWithAnnotatedLines {\n }\n \n impl EmitterWriter {\n-    pub fn stderr(color_config: ColorConfig, code_map: Option<Rc<CodeMapper>>) -> EmitterWriter {\n+    pub fn stderr(color_config: ColorConfig,\n+                  code_map: Option<Rc<CodeMapper>>,\n+                  short_message: bool)\n+                  -> EmitterWriter {\n         if color_config.use_color() {\n             let dst = Destination::from_stderr();\n             EmitterWriter {\n                 dst,\n                 cm: code_map,\n+                short_message: short_message,\n             }\n         } else {\n             EmitterWriter {\n                 dst: Raw(Box::new(io::stderr())),\n                 cm: code_map,\n+                short_message: short_message,\n             }\n         }\n     }\n \n-    pub fn new(dst: Box<Write + Send>, code_map: Option<Rc<CodeMapper>>) -> EmitterWriter {\n+    pub fn new(dst: Box<Write + Send>,\n+               code_map: Option<Rc<CodeMapper>>,\n+               short_message: bool)\n+               -> EmitterWriter {\n         EmitterWriter {\n             dst: Raw(dst),\n             cm: code_map,\n+            short_message: short_message,\n         }\n     }\n \n@@ -671,7 +681,7 @@ impl EmitterWriter {\n                         Style::LabelSecondary\n                     };\n                     Some((p, style))\n-                },\n+                }\n                 _ => None\n             }\n \n@@ -689,11 +699,13 @@ impl EmitterWriter {\n                     }\n                 }\n             }\n-            for span_label in msp.span_labels() {\n-                if span_label.span != DUMMY_SP {\n-                    let hi = cm.lookup_char_pos(span_label.span.hi());\n-                    if hi.line > max {\n-                        max = hi.line;\n+            if !self.short_message {\n+                for span_label in msp.span_labels() {\n+                    if span_label.span != DUMMY_SP {\n+                        let hi = cm.lookup_char_pos(span_label.span.hi());\n+                        if hi.line > max {\n+                            max = hi.line;\n+                        }\n                     }\n                 }\n             }\n@@ -881,7 +893,8 @@ impl EmitterWriter {\n                             -> io::Result<()> {\n         let mut buffer = StyledBuffer::new();\n \n-        if msp.primary_spans().is_empty() && msp.span_labels().is_empty() && is_secondary {\n+        if msp.primary_spans().is_empty() && msp.span_labels().is_empty() && is_secondary\n+           && !self.short_message {\n             // This is a secondary message with no span info\n             for _ in 0..max_line_num_len {\n                 buffer.prepend(0, \" \", Style::NoStyle);\n@@ -916,12 +929,12 @@ impl EmitterWriter {\n             if primary_span != &&DUMMY_SP {\n                 (cm.lookup_char_pos(primary_span.lo()), cm)\n             } else {\n-                emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n+                emit_to_destination(&buffer.render(), level, &mut self.dst, self.short_message)?;\n                 return Ok(());\n             }\n         } else {\n             // If we don't have span information, emit and exit\n-            emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n+            emit_to_destination(&buffer.render(), level, &mut self.dst, self.short_message)?;\n             return Ok(());\n         };\n         if let Ok(pos) =\n@@ -940,18 +953,24 @@ impl EmitterWriter {\n             // to do this, we need to know if this span will be primary\n             let is_primary = primary_lo.file.name == annotated_file.file.name;\n             if is_primary {\n-                // remember where we are in the output buffer for easy reference\n-                let buffer_msg_line_offset = buffer.num_lines();\n-\n-                buffer.prepend(buffer_msg_line_offset, \"--> \", Style::LineNumber);\n                 let loc = primary_lo.clone();\n-                buffer.append(buffer_msg_line_offset,\n-                              &format!(\"{}:{}:{}\", loc.file.name, loc.line, loc.col.0 + 1),\n-                              Style::LineAndColumn);\n-                for _ in 0..max_line_num_len {\n-                    buffer.prepend(buffer_msg_line_offset, \" \", Style::NoStyle);\n+                if !self.short_message {\n+                    // remember where we are in the output buffer for easy reference\n+                    let buffer_msg_line_offset = buffer.num_lines();\n+\n+                    buffer.prepend(buffer_msg_line_offset, \"--> \", Style::LineNumber);\n+                    buffer.append(buffer_msg_line_offset,\n+                                  &format!(\"{}:{}:{}\", loc.file.name, loc.line, loc.col.0 + 1),\n+                                  Style::LineAndColumn);\n+                    for _ in 0..max_line_num_len {\n+                        buffer.prepend(buffer_msg_line_offset, \" \", Style::NoStyle);\n+                    }\n+                } else {\n+                    buffer.prepend(0,\n+                                   &format!(\"{}:{}:{} - \", loc.file.name, loc.line, loc.col.0 + 1),\n+                                   Style::LineAndColumn);\n                 }\n-            } else {\n+            } else if !self.short_message {\n                 // remember where we are in the output buffer for easy reference\n                 let buffer_msg_line_offset = buffer.num_lines();\n \n@@ -968,104 +987,111 @@ impl EmitterWriter {\n                 }\n             }\n \n-            // Put in the spacer between the location and annotated source\n-            let buffer_msg_line_offset = buffer.num_lines();\n-            draw_col_separator_no_space(&mut buffer, buffer_msg_line_offset, max_line_num_len + 1);\n+            if !self.short_message {\n+                // Put in the spacer between the location and annotated source\n+                let buffer_msg_line_offset = buffer.num_lines();\n+                draw_col_separator_no_space(&mut buffer,\n+                                            buffer_msg_line_offset,\n+                                            max_line_num_len + 1);\n \n-            // Contains the vertical lines' positions for active multiline annotations\n-            let mut multilines = HashMap::new();\n+                // Contains the vertical lines' positions for active multiline annotations\n+                let mut multilines = HashMap::new();\n \n-            // Next, output the annotate source for this file\n-            for line_idx in 0..annotated_file.lines.len() {\n-                let previous_buffer_line = buffer.num_lines();\n+                // Next, output the annotate source for this file\n+                for line_idx in 0..annotated_file.lines.len() {\n+                    let previous_buffer_line = buffer.num_lines();\n \n-                let width_offset = 3 + max_line_num_len;\n-                let code_offset = if annotated_file.multiline_depth == 0 {\n-                    width_offset\n-                } else {\n-                    width_offset + annotated_file.multiline_depth + 1\n-                };\n+                    let width_offset = 3 + max_line_num_len;\n+                    let code_offset = if annotated_file.multiline_depth == 0 {\n+                        width_offset\n+                    } else {\n+                        width_offset + annotated_file.multiline_depth + 1\n+                    };\n \n-                let depths = self.render_source_line(&mut buffer,\n-                                                     annotated_file.file.clone(),\n-                                                     &annotated_file.lines[line_idx],\n-                                                     width_offset,\n-                                                     code_offset);\n+                    let depths = self.render_source_line(&mut buffer,\n+                                                         annotated_file.file.clone(),\n+                                                         &annotated_file.lines[line_idx],\n+                                                         width_offset,\n+                                                         code_offset);\n \n-                let mut to_add = HashMap::new();\n+                    let mut to_add = HashMap::new();\n \n-                for (depth, style) in depths {\n-                    if multilines.get(&depth).is_some() {\n-                        multilines.remove(&depth);\n-                    } else {\n-                        to_add.insert(depth, style);\n+                    for (depth, style) in depths {\n+                        if multilines.get(&depth).is_some() {\n+                            multilines.remove(&depth);\n+                        } else {\n+                            to_add.insert(depth, style);\n+                        }\n                     }\n-                }\n \n-                // Set the multiline annotation vertical lines to the left of\n-                // the code in this line.\n-                for (depth, style) in &multilines {\n-                    for line in previous_buffer_line..buffer.num_lines() {\n-                        draw_multiline_line(&mut buffer,\n-                                            line,\n-                                            width_offset,\n-                                            *depth,\n-                                            *style);\n-                    }\n-                }\n-                // check to see if we need to print out or elide lines that come between\n-                // this annotated line and the next one.\n-                if line_idx < (annotated_file.lines.len() - 1) {\n-                    let line_idx_delta = annotated_file.lines[line_idx + 1].line_index -\n-                                         annotated_file.lines[line_idx].line_index;\n-                    if line_idx_delta > 2 {\n-                        let last_buffer_line_num = buffer.num_lines();\n-                        buffer.puts(last_buffer_line_num, 0, \"...\", Style::LineNumber);\n-\n-                        // Set the multiline annotation vertical lines on `...` bridging line.\n-                        for (depth, style) in &multilines {\n+                    // Set the multiline annotation vertical lines to the left of\n+                    // the code in this line.\n+                    for (depth, style) in &multilines {\n+                        for line in previous_buffer_line..buffer.num_lines() {\n                             draw_multiline_line(&mut buffer,\n-                                                last_buffer_line_num,\n+                                                line,\n                                                 width_offset,\n                                                 *depth,\n                                                 *style);\n                         }\n-                    } else if line_idx_delta == 2 {\n-                        let unannotated_line = annotated_file.file\n-                            .get_line(annotated_file.lines[line_idx].line_index)\n-                            .unwrap_or_else(|| Cow::from(\"\"));\n-\n-                        let last_buffer_line_num = buffer.num_lines();\n-\n-                        buffer.puts(last_buffer_line_num,\n-                                    0,\n-                                    &(annotated_file.lines[line_idx + 1].line_index - 1)\n-                                        .to_string(),\n-                                    Style::LineNumber);\n-                        draw_col_separator(&mut buffer, last_buffer_line_num, 1 + max_line_num_len);\n-                        buffer.puts(last_buffer_line_num,\n-                                    code_offset,\n-                                    &unannotated_line,\n-                                    Style::Quotation);\n-\n-                        for (depth, style) in &multilines {\n-                            draw_multiline_line(&mut buffer,\n-                                                last_buffer_line_num,\n-                                                width_offset,\n-                                                *depth,\n-                                                *style);\n+                    }\n+                    // check to see if we need to print out or elide lines that come between\n+                    // this annotated line and the next one.\n+                    if line_idx < (annotated_file.lines.len() - 1) {\n+                        let line_idx_delta = annotated_file.lines[line_idx + 1].line_index -\n+                                             annotated_file.lines[line_idx].line_index;\n+                        if line_idx_delta > 2 {\n+                            let last_buffer_line_num = buffer.num_lines();\n+                            buffer.puts(last_buffer_line_num, 0, \"...\", Style::LineNumber);\n+\n+                            // Set the multiline annotation vertical lines on `...` bridging line.\n+                            for (depth, style) in &multilines {\n+                                draw_multiline_line(&mut buffer,\n+                                                    last_buffer_line_num,\n+                                                    width_offset,\n+                                                    *depth,\n+                                                    *style);\n+                            }\n+                        } else if line_idx_delta == 2 {\n+                            let unannotated_line = annotated_file.file\n+                                .get_line(annotated_file.lines[line_idx].line_index)\n+                                .unwrap_or_else(|| Cow::from(\"\"));\n+\n+                            let last_buffer_line_num = buffer.num_lines();\n+\n+                            buffer.puts(last_buffer_line_num,\n+                                        0,\n+                                        &(annotated_file.lines[line_idx + 1].line_index - 1)\n+                                            .to_string(),\n+                                        Style::LineNumber);\n+                            draw_col_separator(&mut buffer,\n+                                               last_buffer_line_num,\n+                                               1 + max_line_num_len);\n+                            buffer.puts(last_buffer_line_num,\n+                                        code_offset,\n+                                        &unannotated_line,\n+                                        Style::Quotation);\n+\n+                            for (depth, style) in &multilines {\n+                                draw_multiline_line(&mut buffer,\n+                                                    last_buffer_line_num,\n+                                                    width_offset,\n+                                                    *depth,\n+                                                    *style);\n+                            }\n                         }\n                     }\n-                }\n \n-                multilines.extend(&to_add);\n+                    multilines.extend(&to_add);\n+                }\n             }\n         }\n \n         // final step: take our styled buffer, render it, then output it\n-        emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n+        emit_to_destination(&buffer.render(), level, &mut self.dst, self.short_message)?;\n \n         Ok(())\n+\n     }\n     fn emit_suggestion_default(&mut self,\n                                suggestion: &CodeSuggestion,\n@@ -1141,7 +1167,7 @@ impl EmitterWriter {\n                 let msg = format!(\"and {} other candidates\", suggestions.len() - MAX_SUGGESTIONS);\n                 buffer.puts(row_num, 0, &msg, Style::NoStyle);\n             }\n-            emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n+            emit_to_destination(&buffer.render(), level, &mut self.dst, self.short_message)?;\n         }\n         Ok(())\n     }\n@@ -1158,42 +1184,47 @@ impl EmitterWriter {\n             Ok(()) => {\n                 if !children.is_empty() {\n                     let mut buffer = StyledBuffer::new();\n-                    draw_col_separator_no_space(&mut buffer, 0, max_line_num_len + 1);\n-                    match emit_to_destination(&buffer.render(), level, &mut self.dst) {\n+                    if !self.short_message {\n+                        draw_col_separator_no_space(&mut buffer, 0, max_line_num_len + 1);\n+                    }\n+                    match emit_to_destination(&buffer.render(), level, &mut self.dst,\n+                                              self.short_message) {\n                         Ok(()) => (),\n                         Err(e) => panic!(\"failed to emit error: {}\", e)\n                     }\n                 }\n-                for child in children {\n-                    match child.render_span {\n-                        Some(FullSpan(ref msp)) => {\n-                            match self.emit_message_default(msp,\n-                                                            &child.styled_message(),\n-                                                            &None,\n-                                                            &child.level,\n-                                                            max_line_num_len,\n-                                                            true) {\n-                                Err(e) => panic!(\"failed to emit error: {}\", e),\n-                                _ => ()\n+                if !self.short_message {\n+                    for child in children {\n+                        match child.render_span {\n+                            Some(FullSpan(ref msp)) => {\n+                                match self.emit_message_default(msp,\n+                                                                &child.styled_message(),\n+                                                                &None,\n+                                                                &child.level,\n+                                                                max_line_num_len,\n+                                                                true) {\n+                                    Err(e) => panic!(\"failed to emit error: {}\", e),\n+                                    _ => ()\n+                                }\n                             }\n-                        },\n-                        Some(Suggestion(ref cs)) => {\n-                            match self.emit_suggestion_default(cs,\n-                                                               &child.level,\n-                                                               max_line_num_len) {\n-                                Err(e) => panic!(\"failed to emit error: {}\", e),\n-                                _ => ()\n+                            Some(Suggestion(ref cs)) => {\n+                                match self.emit_suggestion_default(cs,\n+                                                                   &child.level,\n+                                                                   max_line_num_len) {\n+                                    Err(e) => panic!(\"failed to emit error: {}\", e),\n+                                    _ => ()\n+                                }\n                             }\n-                        },\n-                        None => {\n-                            match self.emit_message_default(&child.span,\n-                                                            &child.styled_message(),\n-                                                            &None,\n-                                                            &child.level,\n-                                                            max_line_num_len,\n-                                                            true) {\n-                                Err(e) => panic!(\"failed to emit error: {}\", e),\n-                                _ => (),\n+                            None => {\n+                                match self.emit_message_default(&child.span,\n+                                                                &child.styled_message(),\n+                                                                &None,\n+                                                                &child.level,\n+                                                                max_line_num_len,\n+                                                                true) {\n+                                    Err(e) => panic!(\"failed to emit error: {}\", e),\n+                                    _ => (),\n+                                }\n                             }\n                         }\n                     }\n@@ -1263,7 +1294,8 @@ fn overlaps(a1: &Annotation, a2: &Annotation, padding: usize) -> bool {\n \n fn emit_to_destination(rendered_buffer: &Vec<Vec<StyledString>>,\n                        lvl: &Level,\n-                       dst: &mut Destination)\n+                       dst: &mut Destination,\n+                       short_message: bool)\n                        -> io::Result<()> {\n     use lock;\n \n@@ -1286,7 +1318,9 @@ fn emit_to_destination(rendered_buffer: &Vec<Vec<StyledString>>,\n             write!(dst, \"{}\", part.text)?;\n             dst.reset_attrs()?;\n         }\n-        write!(dst, \"\\n\")?;\n+        if !short_message {\n+            write!(dst, \"\\n\")?;\n+        }\n     }\n     dst.flush()?;\n     Ok(())"}, {"sha": "adb3e4d3ed654f4c9d4289174401d58fe505def7", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83bca40350f1b78fbe00e7082c40b3ef79eae4ce/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83bca40350f1b78fbe00e7082c40b3ef79eae4ce/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=83bca40350f1b78fbe00e7082c40b3ef79eae4ce", "patch": "@@ -279,7 +279,7 @@ impl Handler {\n                             treat_err_as_bug: bool,\n                             cm: Option<Rc<CodeMapper>>)\n                             -> Handler {\n-        let emitter = Box::new(EmitterWriter::stderr(color_config, cm));\n+        let emitter = Box::new(EmitterWriter::stderr(color_config, cm, false));\n         Handler::with_emitter(can_emit_warnings, treat_err_as_bug, emitter)\n     }\n "}, {"sha": "9316805b9322abf6ea84759058393cd7c25dbfc4", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83bca40350f1b78fbe00e7082c40b3ef79eae4ce/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83bca40350f1b78fbe00e7082c40b3ef79eae4ce/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=83bca40350f1b78fbe00e7082c40b3ef79eae4ce", "patch": "@@ -238,7 +238,8 @@ fn run_test(test: &str, cratename: &str, filename: &str, cfgs: Vec<String>, libs\n     let data = Arc::new(Mutex::new(Vec::new()));\n     let codemap = Rc::new(CodeMap::new(sessopts.file_path_mapping()));\n     let emitter = errors::emitter::EmitterWriter::new(box Sink(data.clone()),\n-                                                      Some(codemap.clone()));\n+                                                      Some(codemap.clone()),\n+                                                      false);\n     let old = io::set_panic(Some(box Sink(data.clone())));\n     let _bomb = Bomb(data.clone(), old.unwrap_or(box io::stdout()));\n "}, {"sha": "d9c3dbb630d0cb9890b41920f3884c542062bcfb", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83bca40350f1b78fbe00e7082c40b3ef79eae4ce/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83bca40350f1b78fbe00e7082c40b3ef79eae4ce/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=83bca40350f1b78fbe00e7082c40b3ef79eae4ce", "patch": "@@ -1721,7 +1721,9 @@ mod tests {\n     use std::rc::Rc;\n \n     fn mk_sess(cm: Rc<CodeMap>) -> ParseSess {\n-        let emitter = errors::emitter::EmitterWriter::new(Box::new(io::sink()), Some(cm.clone()));\n+        let emitter = errors::emitter::EmitterWriter::new(Box::new(io::sink()),\n+                                                          Some(cm.clone()),\n+                                                          false);\n         ParseSess {\n             span_diagnostic: errors::Handler::with_emitter(true, false, Box::new(emitter)),\n             unstable_features: UnstableFeatures::from_environment(),"}, {"sha": "a29250ea5f19f749c2b76542c2c2113ddd433651", "filename": "src/libsyntax/test_snippet.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83bca40350f1b78fbe00e7082c40b3ef79eae4ce/src%2Flibsyntax%2Ftest_snippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83bca40350f1b78fbe00e7082c40b3ef79eae4ce/src%2Flibsyntax%2Ftest_snippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest_snippet.rs?ref=83bca40350f1b78fbe00e7082c40b3ef79eae4ce", "patch": "@@ -60,7 +60,8 @@ fn test_harness(file_text: &str, span_labels: Vec<SpanLabel>, expected_output: &\n     }\n \n     let emitter = EmitterWriter::new(Box::new(Shared { data: output.clone() }),\n-                                     Some(code_map.clone()));\n+                                     Some(code_map.clone()),\n+                                     false);\n     let handler = Handler::with_emitter(true, false, Box::new(emitter));\n     handler.span_err(msp, \"foo\");\n "}, {"sha": "3e6802c51c3a695bff14dcacdd25178d38cf42f5", "filename": "src/test/ui/short-error-format.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/83bca40350f1b78fbe00e7082c40b3ef79eae4ce/src%2Ftest%2Fui%2Fshort-error-format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83bca40350f1b78fbe00e7082c40b3ef79eae4ce/src%2Ftest%2Fui%2Fshort-error-format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fshort-error-format.rs?ref=83bca40350f1b78fbe00e7082c40b3ef79eae4ce", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: --error-format=short\n+\n+fn foo(_: u32) {}\n+\n+fn main() {\n+    foo(\"Bonjour\".to_owned());\n+    let x = 0u32;\n+    x.salut();\n+}"}, {"sha": "debe60b463226d8f5d9bc8da3e3930f24b580b5d", "filename": "src/test/ui/short-error-format.stderr", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83bca40350f1b78fbe00e7082c40b3ef79eae4ce/src%2Ftest%2Fui%2Fshort-error-format.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83bca40350f1b78fbe00e7082c40b3ef79eae4ce/src%2Ftest%2Fui%2Fshort-error-format.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fshort-error-format.stderr?ref=83bca40350f1b78fbe00e7082c40b3ef79eae4ce", "patch": "@@ -0,0 +1,3 @@\n+$DIR/short-error-format.rs:16:9 - error[E0308]: mismatched types\n+$DIR/short-error-format.rs:18:7 - error[E0599]: no method named `salut` found for type `u32` in the current scope\n+error: aborting due to 2 previous errors"}]}