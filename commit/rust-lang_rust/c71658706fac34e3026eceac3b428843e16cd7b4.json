{"sha": "c71658706fac34e3026eceac3b428843e16cd7b4", "node_id": "C_kwDOAAsO6NoAKGM3MTY1ODcwNmZhYzM0ZTMwMjZlY2VhYzNiNDI4ODQzZTE2Y2Q3YjQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-09T16:54:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-09T16:54:02Z"}, "message": "Auto merge of #104192 - Dylan-DPC:rollup-jjo1o80, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #103570 (Stabilize integer logarithms)\n - #103694 (Add documentation examples for `pointer::mask`)\n - #103919 (Unescaping cleanups)\n - #103933 (Promote {aarch64,i686,x86_64}-unknown-uefi to Tier 2)\n - #103952 (Don't intra linkcheck reference)\n - #104111 (rustdoc: Add mutable to the description)\n - #104125 (Const Compare for Tuples)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "41da8ca5361c24e0bda8031e43494eab1df2b2fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41da8ca5361c24e0bda8031e43494eab1df2b2fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c71658706fac34e3026eceac3b428843e16cd7b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c71658706fac34e3026eceac3b428843e16cd7b4", "html_url": "https://github.com/rust-lang/rust/commit/c71658706fac34e3026eceac3b428843e16cd7b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c71658706fac34e3026eceac3b428843e16cd7b4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc9b259b5e94e4543b96dca236e3a1af5ec496c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc9b259b5e94e4543b96dca236e3a1af5ec496c9", "html_url": "https://github.com/rust-lang/rust/commit/cc9b259b5e94e4543b96dca236e3a1af5ec496c9"}, {"sha": "062f2fc50fa6c4d9acd652766123b7f766fab2ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/062f2fc50fa6c4d9acd652766123b7f766fab2ff", "html_url": "https://github.com/rust-lang/rust/commit/062f2fc50fa6c4d9acd652766123b7f766fab2ff"}], "stats": {"total": 706, "additions": 340, "deletions": 366}, "files": [{"sha": "8f342175f7d37133f67b288b672b1eaa9e3bfaec", "filename": "compiler/rustc_ast/src/util/literal.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -2,12 +2,9 @@\n \n use crate::ast::{self, Lit, LitKind};\n use crate::token::{self, Token};\n-\n-use rustc_lexer::unescape::{unescape_byte, unescape_char};\n-use rustc_lexer::unescape::{unescape_byte_literal, unescape_literal, Mode};\n+use rustc_lexer::unescape::{byte_from_char, unescape_byte, unescape_char, unescape_literal, Mode};\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n-\n use std::ascii;\n \n pub enum LitError {\n@@ -109,13 +106,11 @@ impl LitKind {\n                 let s = symbol.as_str();\n                 let mut buf = Vec::with_capacity(s.len());\n                 let mut error = Ok(());\n-                unescape_byte_literal(&s, Mode::ByteStr, &mut |_, unescaped_byte| {\n-                    match unescaped_byte {\n-                        Ok(c) => buf.push(c),\n-                        Err(err) => {\n-                            if err.is_fatal() {\n-                                error = Err(LitError::LexerError);\n-                            }\n+                unescape_literal(&s, Mode::ByteStr, &mut |_, c| match c {\n+                    Ok(c) => buf.push(byte_from_char(c)),\n+                    Err(err) => {\n+                        if err.is_fatal() {\n+                            error = Err(LitError::LexerError);\n                         }\n                     }\n                 });\n@@ -127,13 +122,11 @@ impl LitKind {\n                 let bytes = if s.contains('\\r') {\n                     let mut buf = Vec::with_capacity(s.len());\n                     let mut error = Ok(());\n-                    unescape_byte_literal(&s, Mode::RawByteStr, &mut |_, unescaped_byte| {\n-                        match unescaped_byte {\n-                            Ok(c) => buf.push(c),\n-                            Err(err) => {\n-                                if err.is_fatal() {\n-                                    error = Err(LitError::LexerError);\n-                                }\n+                    unescape_literal(&s, Mode::RawByteStr, &mut |_, c| match c {\n+                        Ok(c) => buf.push(byte_from_char(c)),\n+                        Err(err) => {\n+                            if err.is_fatal() {\n+                                error = Err(LitError::LexerError);\n                             }\n                         }\n                     });"}, {"sha": "d4140cb295f32d6977993329036bdd654319115d", "filename": "compiler/rustc_lexer/src/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Flib.rs?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -205,13 +205,13 @@ pub enum RawStrError {\n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n pub enum Base {\n     /// Literal starts with \"0b\".\n-    Binary,\n+    Binary = 2,\n     /// Literal starts with \"0o\".\n-    Octal,\n-    /// Literal starts with \"0x\".\n-    Hexadecimal,\n+    Octal = 8,\n     /// Literal doesn't contain a prefix.\n-    Decimal,\n+    Decimal = 10,\n+    /// Literal starts with \"0x\".\n+    Hexadecimal = 16,\n }\n \n /// `rustc` allows files to have a shebang, e.g. \"#!/usr/bin/rustrun\","}, {"sha": "e405013dcabf83047cb34a88c635e6d4d7ec8a28", "filename": "compiler/rustc_lexer/src/unescape.rs", "status": "modified", "additions": 51, "deletions": 79, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -52,10 +52,8 @@ pub enum EscapeError {\n \n     /// Unicode escape code in byte literal.\n     UnicodeEscapeInByte,\n-    /// Non-ascii character in byte literal.\n+    /// Non-ascii character in byte literal, byte string literal, or raw byte string literal.\n     NonAsciiCharInByte,\n-    /// Non-ascii character in byte string literal.\n-    NonAsciiCharInByteString,\n \n     /// After a line ending with '\\', the next line contains whitespace\n     /// characters that are not skipped.\n@@ -78,54 +76,33 @@ impl EscapeError {\n /// Takes a contents of a literal (without quotes) and produces a\n /// sequence of escaped characters or errors.\n /// Values are returned through invoking of the provided callback.\n-pub fn unescape_literal<F>(literal_text: &str, mode: Mode, callback: &mut F)\n+pub fn unescape_literal<F>(src: &str, mode: Mode, callback: &mut F)\n where\n     F: FnMut(Range<usize>, Result<char, EscapeError>),\n {\n     match mode {\n         Mode::Char | Mode::Byte => {\n-            let mut chars = literal_text.chars();\n-            let result = unescape_char_or_byte(&mut chars, mode);\n-            // The Chars iterator moved forward.\n-            callback(0..(literal_text.len() - chars.as_str().len()), result);\n+            let mut chars = src.chars();\n+            let res = unescape_char_or_byte(&mut chars, mode == Mode::Byte);\n+            callback(0..(src.len() - chars.as_str().len()), res);\n         }\n-        Mode::Str | Mode::ByteStr => unescape_str_or_byte_str(literal_text, mode, callback),\n-        // NOTE: Raw strings do not perform any explicit character escaping, here we\n-        // only translate CRLF to LF and produce errors on bare CR.\n+        Mode::Str | Mode::ByteStr => unescape_str_or_byte_str(src, mode == Mode::ByteStr, callback),\n         Mode::RawStr | Mode::RawByteStr => {\n-            unescape_raw_str_or_raw_byte_str(literal_text, mode, callback)\n+            unescape_raw_str_or_raw_byte_str(src, mode == Mode::RawByteStr, callback)\n         }\n     }\n }\n \n-/// Takes a contents of a byte, byte string or raw byte string (without quotes)\n-/// and produces a sequence of bytes or errors.\n-/// Values are returned through invoking of the provided callback.\n-pub fn unescape_byte_literal<F>(literal_text: &str, mode: Mode, callback: &mut F)\n-where\n-    F: FnMut(Range<usize>, Result<u8, EscapeError>),\n-{\n-    debug_assert!(mode.is_bytes());\n-    unescape_literal(literal_text, mode, &mut |range, result| {\n-        callback(range, result.map(byte_from_char));\n-    })\n-}\n-\n /// Takes a contents of a char literal (without quotes), and returns an\n-/// unescaped char or an error\n-pub fn unescape_char(literal_text: &str) -> Result<char, (usize, EscapeError)> {\n-    let mut chars = literal_text.chars();\n-    unescape_char_or_byte(&mut chars, Mode::Char)\n-        .map_err(|err| (literal_text.len() - chars.as_str().len(), err))\n+/// unescaped char or an error.\n+pub fn unescape_char(src: &str) -> Result<char, EscapeError> {\n+    unescape_char_or_byte(&mut src.chars(), false)\n }\n \n /// Takes a contents of a byte literal (without quotes), and returns an\n /// unescaped byte or an error.\n-pub fn unescape_byte(literal_text: &str) -> Result<u8, (usize, EscapeError)> {\n-    let mut chars = literal_text.chars();\n-    unescape_char_or_byte(&mut chars, Mode::Byte)\n-        .map(byte_from_char)\n-        .map_err(|err| (literal_text.len() - chars.as_str().len(), err))\n+pub fn unescape_byte(src: &str) -> Result<u8, EscapeError> {\n+    unescape_char_or_byte(&mut src.chars(), true).map(byte_from_char)\n }\n \n /// What kind of literal do we parse.\n@@ -147,20 +124,17 @@ impl Mode {\n         }\n     }\n \n-    pub fn is_bytes(self) -> bool {\n+    pub fn is_byte(self) -> bool {\n         match self {\n             Mode::Byte | Mode::ByteStr | Mode::RawByteStr => true,\n             Mode::Char | Mode::Str | Mode::RawStr => false,\n         }\n     }\n }\n \n-fn scan_escape(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n+fn scan_escape(chars: &mut Chars<'_>, is_byte: bool) -> Result<char, EscapeError> {\n     // Previous character was '\\\\', unescape what follows.\n-\n-    let second_char = chars.next().ok_or(EscapeError::LoneSlash)?;\n-\n-    let res = match second_char {\n+    let res = match chars.next().ok_or(EscapeError::LoneSlash)? {\n         '\"' => '\"',\n         'n' => '\\n',\n         'r' => '\\r',\n@@ -181,7 +155,7 @@ fn scan_escape(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n             let value = hi * 16 + lo;\n \n             // For a non-byte literal verify that it is within ASCII range.\n-            if !mode.is_bytes() && !is_ascii(value) {\n+            if !is_byte && !is_ascii(value) {\n                 return Err(EscapeError::OutOfRangeHexEscape);\n             }\n             let value = value as u8;\n@@ -217,7 +191,7 @@ fn scan_escape(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n \n                         // Incorrect syntax has higher priority for error reporting\n                         // than unallowed value for a literal.\n-                        if mode.is_bytes() {\n+                        if is_byte {\n                             return Err(EscapeError::UnicodeEscapeInByte);\n                         }\n \n@@ -249,23 +223,22 @@ fn scan_escape(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n }\n \n #[inline]\n-fn ascii_check(first_char: char, mode: Mode) -> Result<char, EscapeError> {\n-    if mode.is_bytes() && !first_char.is_ascii() {\n+fn ascii_check(c: char, is_byte: bool) -> Result<char, EscapeError> {\n+    if is_byte && !c.is_ascii() {\n         // Byte literal can't be a non-ascii character.\n         Err(EscapeError::NonAsciiCharInByte)\n     } else {\n-        Ok(first_char)\n+        Ok(c)\n     }\n }\n \n-fn unescape_char_or_byte(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n-    debug_assert!(mode == Mode::Char || mode == Mode::Byte);\n-    let first_char = chars.next().ok_or(EscapeError::ZeroChars)?;\n-    let res = match first_char {\n-        '\\\\' => scan_escape(chars, mode),\n+fn unescape_char_or_byte(chars: &mut Chars<'_>, is_byte: bool) -> Result<char, EscapeError> {\n+    let c = chars.next().ok_or(EscapeError::ZeroChars)?;\n+    let res = match c {\n+        '\\\\' => scan_escape(chars, is_byte),\n         '\\n' | '\\t' | '\\'' => Err(EscapeError::EscapeOnlyChar),\n         '\\r' => Err(EscapeError::BareCarriageReturn),\n-        _ => ascii_check(first_char, mode),\n+        _ => ascii_check(c, is_byte),\n     }?;\n     if chars.next().is_some() {\n         return Err(EscapeError::MoreThanOneChar);\n@@ -275,20 +248,20 @@ fn unescape_char_or_byte(chars: &mut Chars<'_>, mode: Mode) -> Result<char, Esca\n \n /// Takes a contents of a string literal (without quotes) and produces a\n /// sequence of escaped characters or errors.\n-fn unescape_str_or_byte_str<F>(src: &str, mode: Mode, callback: &mut F)\n+fn unescape_str_or_byte_str<F>(src: &str, is_byte: bool, callback: &mut F)\n where\n     F: FnMut(Range<usize>, Result<char, EscapeError>),\n {\n-    debug_assert!(mode == Mode::Str || mode == Mode::ByteStr);\n-    let initial_len = src.len();\n     let mut chars = src.chars();\n-    while let Some(first_char) = chars.next() {\n-        let start = initial_len - chars.as_str().len() - first_char.len_utf8();\n \n-        let unescaped_char = match first_char {\n+    // The `start` and `end` computation here is complicated because\n+    // `skip_ascii_whitespace` makes us to skip over chars without counting\n+    // them in the range computation.\n+    while let Some(c) = chars.next() {\n+        let start = src.len() - chars.as_str().len() - c.len_utf8();\n+        let res = match c {\n             '\\\\' => {\n-                let second_char = chars.clone().next();\n-                match second_char {\n+                match chars.clone().next() {\n                     Some('\\n') => {\n                         // Rust language specification requires us to skip whitespaces\n                         // if unescaped '\\' character is followed by '\\n'.\n@@ -297,17 +270,17 @@ where\n                         skip_ascii_whitespace(&mut chars, start, callback);\n                         continue;\n                     }\n-                    _ => scan_escape(&mut chars, mode),\n+                    _ => scan_escape(&mut chars, is_byte),\n                 }\n             }\n             '\\n' => Ok('\\n'),\n             '\\t' => Ok('\\t'),\n             '\"' => Err(EscapeError::EscapeOnlyChar),\n             '\\r' => Err(EscapeError::BareCarriageReturn),\n-            _ => ascii_check(first_char, mode),\n+            _ => ascii_check(c, is_byte),\n         };\n-        let end = initial_len - chars.as_str().len();\n-        callback(start..end, unescaped_char);\n+        let end = src.len() - chars.as_str().len();\n+        callback(start..end, res);\n     }\n \n     fn skip_ascii_whitespace<F>(chars: &mut Chars<'_>, start: usize, callback: &mut F)\n@@ -340,30 +313,29 @@ where\n /// Takes a contents of a string literal (without quotes) and produces a\n /// sequence of characters or errors.\n /// NOTE: Raw strings do not perform any explicit character escaping, here we\n-/// only translate CRLF to LF and produce errors on bare CR.\n-fn unescape_raw_str_or_raw_byte_str<F>(literal_text: &str, mode: Mode, callback: &mut F)\n+/// only produce errors on bare CR.\n+fn unescape_raw_str_or_raw_byte_str<F>(src: &str, is_byte: bool, callback: &mut F)\n where\n     F: FnMut(Range<usize>, Result<char, EscapeError>),\n {\n-    debug_assert!(mode == Mode::RawStr || mode == Mode::RawByteStr);\n-    let initial_len = literal_text.len();\n-\n-    let mut chars = literal_text.chars();\n-    while let Some(curr) = chars.next() {\n-        let start = initial_len - chars.as_str().len() - curr.len_utf8();\n+    let mut chars = src.chars();\n \n-        let result = match curr {\n+    // The `start` and `end` computation here matches the one in\n+    // `unescape_str_or_byte_str` for consistency, even though this function\n+    // doesn't have to worry about skipping any chars.\n+    while let Some(c) = chars.next() {\n+        let start = src.len() - chars.as_str().len() - c.len_utf8();\n+        let res = match c {\n             '\\r' => Err(EscapeError::BareCarriageReturnInRawString),\n-            c if mode.is_bytes() && !c.is_ascii() => Err(EscapeError::NonAsciiCharInByteString),\n-            c => Ok(c),\n+            _ => ascii_check(c, is_byte),\n         };\n-        let end = initial_len - chars.as_str().len();\n-\n-        callback(start..end, result);\n+        let end = src.len() - chars.as_str().len();\n+        callback(start..end, res);\n     }\n }\n \n-fn byte_from_char(c: char) -> u8 {\n+#[inline]\n+pub fn byte_from_char(c: char) -> u8 {\n     let res = c as u32;\n     debug_assert!(res <= u8::MAX as u32, \"guaranteed because of Mode::ByteStr\");\n     res as u8"}, {"sha": "c7ca8fd16ae479cf7978913e8a0ea961cde2afc1", "filename": "compiler/rustc_lexer/src/unescape/tests.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/compiler%2Frustc_lexer%2Fsrc%2Funescape%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/compiler%2Frustc_lexer%2Fsrc%2Funescape%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Funescape%2Ftests.rs?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -3,8 +3,7 @@ use super::*;\n #[test]\n fn test_unescape_char_bad() {\n     fn check(literal_text: &str, expected_error: EscapeError) {\n-        let actual_result = unescape_char(literal_text).map_err(|(_offset, err)| err);\n-        assert_eq!(actual_result, Err(expected_error));\n+        assert_eq!(unescape_char(literal_text), Err(expected_error));\n     }\n \n     check(\"\", EscapeError::ZeroChars);\n@@ -68,8 +67,7 @@ fn test_unescape_char_bad() {\n #[test]\n fn test_unescape_char_good() {\n     fn check(literal_text: &str, expected_char: char) {\n-        let actual_result = unescape_char(literal_text);\n-        assert_eq!(actual_result, Ok(expected_char));\n+        assert_eq!(unescape_char(literal_text), Ok(expected_char));\n     }\n \n     check(\"a\", 'a');\n@@ -149,8 +147,7 @@ fn test_unescape_str_good() {\n #[test]\n fn test_unescape_byte_bad() {\n     fn check(literal_text: &str, expected_error: EscapeError) {\n-        let actual_result = unescape_byte(literal_text).map_err(|(_offset, err)| err);\n-        assert_eq!(actual_result, Err(expected_error));\n+        assert_eq!(unescape_byte(literal_text), Err(expected_error));\n     }\n \n     check(\"\", EscapeError::ZeroChars);\n@@ -219,8 +216,7 @@ fn test_unescape_byte_bad() {\n #[test]\n fn test_unescape_byte_good() {\n     fn check(literal_text: &str, expected_byte: u8) {\n-        let actual_result = unescape_byte(literal_text);\n-        assert_eq!(actual_result, Ok(expected_byte));\n+        assert_eq!(unescape_byte(literal_text), Ok(expected_byte));\n     }\n \n     check(\"a\", b'a');\n@@ -246,10 +242,10 @@ fn test_unescape_byte_good() {\n fn test_unescape_byte_str_good() {\n     fn check(literal_text: &str, expected: &[u8]) {\n         let mut buf = Ok(Vec::with_capacity(literal_text.len()));\n-        unescape_byte_literal(literal_text, Mode::ByteStr, &mut |range, c| {\n+        unescape_literal(literal_text, Mode::ByteStr, &mut |range, c| {\n             if let Ok(b) = &mut buf {\n                 match c {\n-                    Ok(c) => b.push(c),\n+                    Ok(c) => b.push(byte_from_char(c)),\n                     Err(e) => buf = Err((range, e)),\n                 }\n             }\n@@ -280,18 +276,13 @@ fn test_unescape_raw_str() {\n \n #[test]\n fn test_unescape_raw_byte_str() {\n-    fn check(literal: &str, expected: &[(Range<usize>, Result<u8, EscapeError>)]) {\n+    fn check(literal: &str, expected: &[(Range<usize>, Result<char, EscapeError>)]) {\n         let mut unescaped = Vec::with_capacity(literal.len());\n-        unescape_byte_literal(literal, Mode::RawByteStr, &mut |range, res| {\n-            unescaped.push((range, res))\n-        });\n+        unescape_literal(literal, Mode::RawByteStr, &mut |range, res| unescaped.push((range, res)));\n         assert_eq!(unescaped, expected);\n     }\n \n     check(\"\\r\", &[(0..1, Err(EscapeError::BareCarriageReturnInRawString))]);\n-    check(\"\ud83e\udd80\", &[(0..4, Err(EscapeError::NonAsciiCharInByteString))]);\n-    check(\n-        \"\ud83e\udd80a\",\n-        &[(0..4, Err(EscapeError::NonAsciiCharInByteString)), (4..5, Ok(byte_from_char('a')))],\n-    );\n+    check(\"\ud83e\udd80\", &[(0..4, Err(EscapeError::NonAsciiCharInByte))]);\n+    check(\"\ud83e\udd80a\", &[(0..4, Err(EscapeError::NonAsciiCharInByte)), (4..5, Ok('a'))]);\n }"}, {"sha": "645262bd2f1d37dcf5d714b618457e94e3a3f81b", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 48, "deletions": 59, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -353,112 +353,115 @@ impl<'a> StringReader<'a> {\n     fn cook_lexer_literal(\n         &self,\n         start: BytePos,\n-        suffix_start: BytePos,\n+        end: BytePos,\n         kind: rustc_lexer::LiteralKind,\n     ) -> (token::LitKind, Symbol) {\n-        // prefix means `\"` or `br\"` or `r###\"`, ...\n-        let (lit_kind, mode, prefix_len, postfix_len) = match kind {\n+        match kind {\n             rustc_lexer::LiteralKind::Char { terminated } => {\n                 if !terminated {\n                     self.sess.span_diagnostic.span_fatal_with_code(\n-                        self.mk_sp(start, suffix_start),\n+                        self.mk_sp(start, end),\n                         \"unterminated character literal\",\n                         error_code!(E0762),\n                     )\n                 }\n-                (token::Char, Mode::Char, 1, 1) // ' '\n+                self.cook_quoted(token::Char, Mode::Char, start, end, 1, 1) // ' '\n             }\n             rustc_lexer::LiteralKind::Byte { terminated } => {\n                 if !terminated {\n                     self.sess.span_diagnostic.span_fatal_with_code(\n-                        self.mk_sp(start + BytePos(1), suffix_start),\n+                        self.mk_sp(start + BytePos(1), end),\n                         \"unterminated byte constant\",\n                         error_code!(E0763),\n                     )\n                 }\n-                (token::Byte, Mode::Byte, 2, 1) // b' '\n+                self.cook_quoted(token::Byte, Mode::Byte, start, end, 2, 1) // b' '\n             }\n             rustc_lexer::LiteralKind::Str { terminated } => {\n                 if !terminated {\n                     self.sess.span_diagnostic.span_fatal_with_code(\n-                        self.mk_sp(start, suffix_start),\n+                        self.mk_sp(start, end),\n                         \"unterminated double quote string\",\n                         error_code!(E0765),\n                     )\n                 }\n-                (token::Str, Mode::Str, 1, 1) // \" \"\n+                self.cook_quoted(token::Str, Mode::Str, start, end, 1, 1) // \" \"\n             }\n             rustc_lexer::LiteralKind::ByteStr { terminated } => {\n                 if !terminated {\n                     self.sess.span_diagnostic.span_fatal_with_code(\n-                        self.mk_sp(start + BytePos(1), suffix_start),\n+                        self.mk_sp(start + BytePos(1), end),\n                         \"unterminated double quote byte string\",\n                         error_code!(E0766),\n                     )\n                 }\n-                (token::ByteStr, Mode::ByteStr, 2, 1) // b\" \"\n+                self.cook_quoted(token::ByteStr, Mode::ByteStr, start, end, 2, 1) // b\" \"\n             }\n             rustc_lexer::LiteralKind::RawStr { n_hashes } => {\n                 if let Some(n_hashes) = n_hashes {\n                     let n = u32::from(n_hashes);\n-                    (token::StrRaw(n_hashes), Mode::RawStr, 2 + n, 1 + n) // r##\" \"##\n+                    let kind = token::StrRaw(n_hashes);\n+                    self.cook_quoted(kind, Mode::RawStr, start, end, 2 + n, 1 + n) // r##\" \"##\n                 } else {\n                     self.report_raw_str_error(start, 1);\n                 }\n             }\n             rustc_lexer::LiteralKind::RawByteStr { n_hashes } => {\n                 if let Some(n_hashes) = n_hashes {\n                     let n = u32::from(n_hashes);\n-                    (token::ByteStrRaw(n_hashes), Mode::RawByteStr, 3 + n, 1 + n) // br##\" \"##\n+                    let kind = token::ByteStrRaw(n_hashes);\n+                    self.cook_quoted(kind, Mode::RawByteStr, start, end, 3 + n, 1 + n) // br##\" \"##\n                 } else {\n                     self.report_raw_str_error(start, 2);\n                 }\n             }\n             rustc_lexer::LiteralKind::Int { base, empty_int } => {\n-                return if empty_int {\n+                if empty_int {\n                     self.sess\n                         .span_diagnostic\n                         .struct_span_err_with_code(\n-                            self.mk_sp(start, suffix_start),\n+                            self.mk_sp(start, end),\n                             \"no valid digits found for number\",\n                             error_code!(E0768),\n                         )\n                         .emit();\n                     (token::Integer, sym::integer(0))\n                 } else {\n-                    self.validate_int_literal(base, start, suffix_start);\n-                    (token::Integer, self.symbol_from_to(start, suffix_start))\n-                };\n+                    if matches!(base, Base::Binary | Base::Octal) {\n+                        let base = base as u32;\n+                        let s = self.str_from_to(start + BytePos(2), end);\n+                        for (idx, c) in s.char_indices() {\n+                            if c != '_' && c.to_digit(base).is_none() {\n+                                self.err_span_(\n+                                    start + BytePos::from_usize(2 + idx),\n+                                    start + BytePos::from_usize(2 + idx + c.len_utf8()),\n+                                    &format!(\"invalid digit for a base {} literal\", base),\n+                                );\n+                            }\n+                        }\n+                    }\n+                    (token::Integer, self.symbol_from_to(start, end))\n+                }\n             }\n             rustc_lexer::LiteralKind::Float { base, empty_exponent } => {\n                 if empty_exponent {\n                     self.err_span_(start, self.pos, \"expected at least one digit in exponent\");\n                 }\n-\n                 match base {\n-                    Base::Hexadecimal => self.err_span_(\n-                        start,\n-                        suffix_start,\n-                        \"hexadecimal float literal is not supported\",\n-                    ),\n+                    Base::Hexadecimal => {\n+                        self.err_span_(start, end, \"hexadecimal float literal is not supported\")\n+                    }\n                     Base::Octal => {\n-                        self.err_span_(start, suffix_start, \"octal float literal is not supported\")\n+                        self.err_span_(start, end, \"octal float literal is not supported\")\n                     }\n                     Base::Binary => {\n-                        self.err_span_(start, suffix_start, \"binary float literal is not supported\")\n+                        self.err_span_(start, end, \"binary float literal is not supported\")\n                     }\n-                    _ => (),\n+                    _ => {}\n                 }\n-\n-                let id = self.symbol_from_to(start, suffix_start);\n-                return (token::Float, id);\n+                (token::Float, self.symbol_from_to(start, end))\n             }\n-        };\n-        let content_start = start + BytePos(prefix_len);\n-        let content_end = suffix_start - BytePos(postfix_len);\n-        let id = self.symbol_from_to(content_start, content_end);\n-        self.validate_literal_escape(mode, content_start, content_end, prefix_len, postfix_len);\n-        (lit_kind, id)\n+        }\n     }\n \n     #[inline]\n@@ -649,20 +652,22 @@ impl<'a> StringReader<'a> {\n         )\n     }\n \n-    fn validate_literal_escape(\n+    fn cook_quoted(\n         &self,\n+        kind: token::LitKind,\n         mode: Mode,\n-        content_start: BytePos,\n-        content_end: BytePos,\n+        start: BytePos,\n+        end: BytePos,\n         prefix_len: u32,\n         postfix_len: u32,\n-    ) {\n+    ) -> (token::LitKind, Symbol) {\n+        let content_start = start + BytePos(prefix_len);\n+        let content_end = end - BytePos(postfix_len);\n         let lit_content = self.str_from_to(content_start, content_end);\n         unescape::unescape_literal(lit_content, mode, &mut |range, result| {\n             // Here we only check for errors. The actual unescaping is done later.\n             if let Err(err) = result {\n-                let span_with_quotes = self\n-                    .mk_sp(content_start - BytePos(prefix_len), content_end + BytePos(postfix_len));\n+                let span_with_quotes = self.mk_sp(start, end);\n                 let (start, end) = (range.start as u32, range.end as u32);\n                 let lo = content_start + BytePos(start);\n                 let hi = lo + BytePos(end - start);\n@@ -678,23 +683,7 @@ impl<'a> StringReader<'a> {\n                 );\n             }\n         });\n-    }\n-\n-    fn validate_int_literal(&self, base: Base, content_start: BytePos, content_end: BytePos) {\n-        let base = match base {\n-            Base::Binary => 2,\n-            Base::Octal => 8,\n-            _ => return,\n-        };\n-        let s = self.str_from_to(content_start + BytePos(2), content_end);\n-        for (idx, c) in s.char_indices() {\n-            let idx = idx as u32;\n-            if c != '_' && c.to_digit(base).is_none() {\n-                let lo = content_start + BytePos(2 + idx);\n-                let hi = content_start + BytePos(2 + idx + c.len_utf8() as u32);\n-                self.err_span_(lo, hi, &format!(\"invalid digit for a base {} literal\", base));\n-            }\n-        }\n+        (kind, Symbol::intern(lit_content))\n     }\n }\n "}, {"sha": "6373f5b4fd6ff36f32f99b14bd80ec9326663dfc", "filename": "compiler/rustc_parse/src/lexer/unescape_error_reporting.rs", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -108,7 +108,7 @@ pub(crate) fn emit_unescape_error(\n             }\n \n             if !has_help {\n-                let (prefix, msg) = if mode.is_bytes() {\n+                let (prefix, msg) = if mode.is_byte() {\n                     (\"b\", \"if you meant to write a byte string literal, use double quotes\")\n                 } else {\n                     (\"\", \"if you meant to write a `str` literal, use double quotes\")\n@@ -142,7 +142,7 @@ pub(crate) fn emit_unescape_error(\n         EscapeError::EscapeOnlyChar => {\n             let (c, char_span) = last_char();\n \n-            let msg = if mode.is_bytes() {\n+            let msg = if mode.is_byte() {\n                 \"byte constant must be escaped\"\n             } else {\n                 \"character constant must be escaped\"\n@@ -182,11 +182,11 @@ pub(crate) fn emit_unescape_error(\n             let (c, span) = last_char();\n \n             let label =\n-                if mode.is_bytes() { \"unknown byte escape\" } else { \"unknown character escape\" };\n+                if mode.is_byte() { \"unknown byte escape\" } else { \"unknown character escape\" };\n             let ec = escaped_char(c);\n             let mut diag = handler.struct_span_err(span, &format!(\"{}: `{}`\", label, ec));\n             diag.span_label(span, label);\n-            if c == '{' || c == '}' && !mode.is_bytes() {\n+            if c == '{' || c == '}' && !mode.is_byte() {\n                 diag.help(\n                     \"if used in a formatting string, curly braces are escaped with `{{` and `}}`\",\n                 );\n@@ -196,7 +196,7 @@ pub(crate) fn emit_unescape_error(\n                      version control settings\",\n                 );\n             } else {\n-                if !mode.is_bytes() {\n+                if !mode.is_byte() {\n                     diag.span_suggestion(\n                         span_with_quotes,\n                         \"if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\",\n@@ -231,16 +231,23 @@ pub(crate) fn emit_unescape_error(\n                 .emit();\n         }\n         EscapeError::NonAsciiCharInByte => {\n-            assert!(mode.is_bytes());\n             let (c, span) = last_char();\n-            let mut err = handler.struct_span_err(span, \"non-ASCII character in byte constant\");\n+            let desc = match mode {\n+                Mode::Byte => \"byte literal\",\n+                Mode::ByteStr => \"byte string literal\",\n+                Mode::RawByteStr => \"raw byte string literal\",\n+                _ => panic!(\"non-is_byte literal paired with NonAsciiCharInByte\"),\n+            };\n+            let mut err = handler.struct_span_err(span, format!(\"non-ASCII character in {}\", desc));\n             let postfix = if unicode_width::UnicodeWidthChar::width(c).unwrap_or(1) == 0 {\n                 format!(\" but is {:?}\", c)\n             } else {\n                 String::new()\n             };\n-            err.span_label(span, &format!(\"byte constant must be ASCII{}\", postfix));\n-            if (c as u32) <= 0xFF {\n+            err.span_label(span, &format!(\"must be ASCII{}\", postfix));\n+            // Note: the \\\\xHH suggestions are not given for raw byte string\n+            // literals, because they are araw and so cannot use any escapes.\n+            if (c as u32) <= 0xFF && mode != Mode::RawByteStr {\n                 err.span_suggestion(\n                     span,\n                     &format!(\n@@ -250,9 +257,9 @@ pub(crate) fn emit_unescape_error(\n                     format!(\"\\\\x{:X}\", c as u32),\n                     Applicability::MaybeIncorrect,\n                 );\n-            } else if matches!(mode, Mode::Byte) {\n+            } else if mode == Mode::Byte {\n                 err.span_label(span, \"this multibyte character does not fit into a single byte\");\n-            } else if matches!(mode, Mode::ByteStr) {\n+            } else if mode != Mode::RawByteStr {\n                 let mut utf8 = String::new();\n                 utf8.push(c);\n                 err.span_suggestion(\n@@ -270,19 +277,6 @@ pub(crate) fn emit_unescape_error(\n             }\n             err.emit();\n         }\n-        EscapeError::NonAsciiCharInByteString => {\n-            assert!(mode.is_bytes());\n-            let (c, span) = last_char();\n-            let postfix = if unicode_width::UnicodeWidthChar::width(c).unwrap_or(1) == 0 {\n-                format!(\" but is {:?}\", c)\n-            } else {\n-                String::new()\n-            };\n-            handler\n-                .struct_span_err(span, \"raw byte string must be ASCII\")\n-                .span_label(span, &format!(\"must be ASCII{}\", postfix))\n-                .emit();\n-        }\n         EscapeError::OutOfRangeHexEscape => {\n             handler\n                 .struct_span_err(span, \"out of range hex escape\")"}, {"sha": "f1244d93285e30ba8777f0de2719eead94a960d2", "filename": "library/core/benches/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/library%2Fcore%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/library%2Fcore%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fbenches%2Flib.rs?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -1,7 +1,6 @@\n // wasm32 does not support benches (no time).\n #![cfg(not(target_arch = \"wasm32\"))]\n #![feature(flt2dec)]\n-#![feature(int_log)]\n #![feature(test)]\n #![feature(trusted_random_access)]\n #![feature(iter_array_chunks)]"}, {"sha": "404ddff4f9dab44cde4497c18671480afce09bd4", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -2271,15 +2271,16 @@ macro_rules! int_impl {\n         /// # Panics\n         ///\n         /// This function will panic if `self` is less than or equal to zero,\n-        /// or if `base` is less then 2.\n+        /// or if `base` is less than 2.\n         ///\n         /// # Examples\n         ///\n         /// ```\n-        /// #![feature(int_log)]\n         #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".ilog(5), 1);\")]\n         /// ```\n-        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_allow_const_fn_unstable(const_option)]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -2298,10 +2299,11 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```\n-        /// #![feature(int_log)]\n         #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".ilog2(), 1);\")]\n         /// ```\n-        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_allow_const_fn_unstable(const_option)]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -2319,10 +2321,11 @@ macro_rules! int_impl {\n         /// # Example\n         ///\n         /// ```\n-        /// #![feature(int_log)]\n         #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".ilog10(), 1);\")]\n         /// ```\n-        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_allow_const_fn_unstable(const_option)]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -2343,10 +2346,10 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```\n-        /// #![feature(int_log)]\n         #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_ilog(5), Some(1));\")]\n         /// ```\n-        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -2379,10 +2382,10 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```\n-        /// #![feature(int_log)]\n         #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_ilog2(), Some(1));\")]\n         /// ```\n-        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -2403,10 +2406,10 @@ macro_rules! int_impl {\n         /// # Example\n         ///\n         /// ```\n-        /// #![feature(int_log)]\n         #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_ilog10(), Some(1));\")]\n         /// ```\n-        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]"}, {"sha": "5b7521220acdb2d99ac15aeac715d45c7d4cde1b", "filename": "library/core/src/num/nonzero.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -460,14 +460,14 @@ macro_rules! nonzero_unsigned_operations {\n                 /// # Examples\n                 ///\n                 /// ```\n-                /// #![feature(int_log)]\n                 #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                 ///\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(7).unwrap().ilog2(), 2);\")]\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(8).unwrap().ilog2(), 3);\")]\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(9).unwrap().ilog2(), 3);\")]\n                 /// ```\n-                #[unstable(feature = \"int_log\", issue = \"70887\")]\n+                #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+                #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n                 #[must_use = \"this returns the result of the operation, \\\n                               without modifying the original\"]\n                 #[inline]\n@@ -485,14 +485,14 @@ macro_rules! nonzero_unsigned_operations {\n                 /// # Examples\n                 ///\n                 /// ```\n-                /// #![feature(int_log)]\n                 #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                 ///\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(99).unwrap().ilog10(), 1);\")]\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(100).unwrap().ilog10(), 2);\")]\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(101).unwrap().ilog10(), 2);\")]\n                 /// ```\n-                #[unstable(feature = \"int_log\", issue = \"70887\")]\n+                #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+                #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n                 #[must_use = \"this returns the result of the operation, \\\n                               without modifying the original\"]\n                 #[inline]"}, {"sha": "0563f28278d36e8da710808b0cf6ac7246632be2", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -692,15 +692,16 @@ macro_rules! uint_impl {\n         ///\n         /// # Panics\n         ///\n-        /// This function will panic if `self` is zero, or if `base` is less then 2.\n+        /// This function will panic if `self` is zero, or if `base` is less than 2.\n         ///\n         /// # Examples\n         ///\n         /// ```\n-        /// #![feature(int_log)]\n         #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".ilog(5), 1);\")]\n         /// ```\n-        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_allow_const_fn_unstable(const_option)]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -719,10 +720,11 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```\n-        /// #![feature(int_log)]\n         #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".ilog2(), 1);\")]\n         /// ```\n-        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_allow_const_fn_unstable(const_option)]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -740,10 +742,11 @@ macro_rules! uint_impl {\n         /// # Example\n         ///\n         /// ```\n-        /// #![feature(int_log)]\n         #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".ilog10(), 1);\")]\n         /// ```\n-        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_allow_const_fn_unstable(const_option)]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -764,10 +767,10 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```\n-        /// #![feature(int_log)]\n         #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_ilog(5), Some(1));\")]\n         /// ```\n-        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -800,10 +803,10 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```\n-        /// #![feature(int_log)]\n         #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_ilog2(), Some(1));\")]\n         /// ```\n-        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -822,10 +825,10 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```\n-        /// #![feature(int_log)]\n         #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_ilog10(), Some(1));\")]\n         /// ```\n-        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]"}, {"sha": "926d2ae51139864944c44d843ba81f6c176d9bd5", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -568,6 +568,31 @@ impl<T: ?Sized> *const T {\n     ///\n     /// For non-`Sized` pointees this operation changes only the data pointer,\n     /// leaving the metadata untouched.\n+    ///\n+    /// ## Examples\n+    ///\n+    /// ```\n+    /// #![feature(ptr_mask, strict_provenance)]\n+    /// let v = 17_u32;\n+    /// let ptr: *const u32 = &v;\n+    ///\n+    /// // `u32` is 4 bytes aligned,\n+    /// // which means that lower 2 bits are always 0.\n+    /// let tag_mask = 0b11;\n+    /// let ptr_mask = !tag_mask;\n+    ///\n+    /// // We can store something in these lower bits\n+    /// let tagged_ptr = ptr.map_addr(|a| a | 0b10);\n+    ///\n+    /// // Get the \"tag\" back\n+    /// let tag = tagged_ptr.addr() & tag_mask;\n+    /// assert_eq!(tag, 0b10);\n+    ///\n+    /// // Note that `tagged_ptr` is unaligned, it's UB to read from it.\n+    /// // To get original pointer `mask` can be used:\n+    /// let masked_ptr = tagged_ptr.mask(ptr_mask);\n+    /// assert_eq!(unsafe { *masked_ptr }, 17);\n+    /// ```\n     #[unstable(feature = \"ptr_mask\", issue = \"98290\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n     #[inline(always)]"}, {"sha": "f71696e9ca0fa9e1b072d6e0f31c1386cc6508e3", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -588,6 +588,34 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// For non-`Sized` pointees this operation changes only the data pointer,\n     /// leaving the metadata untouched.\n+    ///\n+    /// ## Examples\n+    ///\n+    /// ```\n+    /// #![feature(ptr_mask, strict_provenance)]\n+    /// let mut v = 17_u32;\n+    /// let ptr: *mut u32 = &mut v;\n+    ///\n+    /// // `u32` is 4 bytes aligned,\n+    /// // which means that lower 2 bits are always 0.\n+    /// let tag_mask = 0b11;\n+    /// let ptr_mask = !tag_mask;\n+    ///\n+    /// // We can store something in these lower bits\n+    /// let tagged_ptr = ptr.map_addr(|a| a | 0b10);\n+    ///\n+    /// // Get the \"tag\" back\n+    /// let tag = tagged_ptr.addr() & tag_mask;\n+    /// assert_eq!(tag, 0b10);\n+    ///\n+    /// // Note that `tagged_ptr` is unaligned, it's UB to read from/write to it.\n+    /// // To get original pointer `mask` can be used:\n+    /// let masked_ptr = tagged_ptr.mask(ptr_mask);\n+    /// assert_eq!(unsafe { *masked_ptr }, 17);\n+    ///\n+    /// unsafe { *masked_ptr = 0 };\n+    /// assert_eq!(v, 0);\n+    /// ```\n     #[unstable(feature = \"ptr_mask\", issue = \"98290\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n     #[inline(always)]"}, {"sha": "0f58bc643d9655a8aaa299f61efcecf462a5d29e", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -3667,7 +3667,8 @@ impl<T> [T] {\n         unsafe { self.align_to() }\n     }\n \n-    /// Split a slice into a prefix, a middle of aligned SIMD types, and a suffix.\n+    /// Split a mutable slice into a mutable prefix, a middle of aligned SIMD types,\n+    /// and a mutable suffix.\n     ///\n     /// This is a safe wrapper around [`slice::align_to_mut`], so has the same weak\n     /// postconditions as that method.  You're only assured that"}, {"sha": "28275798f751ed16d151649d491985b0de83c7ac", "filename": "library/core/src/tuple.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/library%2Fcore%2Fsrc%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/library%2Fcore%2Fsrc%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftuple.rs?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -22,7 +22,8 @@ macro_rules! tuple_impls {\n         maybe_tuple_doc! {\n             $($T)+ @\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<$($T:PartialEq),+> PartialEq for ($($T,)+)\n+            #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n+            impl<$($T: ~const PartialEq),+> const PartialEq for ($($T,)+)\n             where\n                 last_type!($($T,)+): ?Sized\n             {\n@@ -40,7 +41,7 @@ macro_rules! tuple_impls {\n         maybe_tuple_doc! {\n             $($T)+ @\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<$($T:Eq),+> Eq for ($($T,)+)\n+            impl<$($T: Eq),+> Eq for ($($T,)+)\n             where\n                 last_type!($($T,)+): ?Sized\n             {}\n@@ -49,7 +50,8 @@ macro_rules! tuple_impls {\n         maybe_tuple_doc! {\n             $($T)+ @\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<$($T:PartialOrd + PartialEq),+> PartialOrd for ($($T,)+)\n+            #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n+            impl<$($T: ~const PartialOrd + ~const PartialEq),+> const PartialOrd for ($($T,)+)\n             where\n                 last_type!($($T,)+): ?Sized\n             {\n@@ -79,7 +81,8 @@ macro_rules! tuple_impls {\n         maybe_tuple_doc! {\n             $($T)+ @\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<$($T:Ord),+> Ord for ($($T,)+)\n+            #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n+            impl<$($T: ~const Ord),+> const Ord for ($($T,)+)\n             where\n                 last_type!($($T,)+): ?Sized\n             {"}, {"sha": "a7db2a02bd74383ad2e8cfa4fb800d52f7e8307a", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -64,7 +64,6 @@\n #![feature(try_trait_v2)]\n #![feature(slice_internals)]\n #![feature(slice_partition_dedup)]\n-#![feature(int_log)]\n #![feature(iter_advance_by)]\n #![feature(iter_array_chunks)]\n #![feature(iter_collect_into)]"}, {"sha": "e1adabaac9b568b32723e98201603bc30187ff47", "filename": "src/ci/docker/host-x86_64/dist-various-2/Dockerfile", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2FDockerfile?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -118,6 +118,9 @@ ENV TARGETS=$TARGETS,armv7-unknown-linux-gnueabi\n ENV TARGETS=$TARGETS,armv7-unknown-linux-musleabi\n ENV TARGETS=$TARGETS,i686-unknown-freebsd\n ENV TARGETS=$TARGETS,x86_64-unknown-none\n+ENV TARGETS=$TARGETS,aarch64-unknown-uefi\n+ENV TARGETS=$TARGETS,i686-unknown-uefi\n+ENV TARGETS=$TARGETS,x86_64-unknown-uefi\n \n # As per https://bugs.launchpad.net/ubuntu/+source/gcc-defaults/+bug/1300211\n # we need asm in the search path for gcc-8 (for gnux32) but not in the search path of the"}, {"sha": "5b4e436da7d57cf522b66b72b62b4c633857949e", "filename": "src/doc/rustc/src/platform-support.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -128,6 +128,7 @@ target | std | notes\n [`aarch64-linux-android`](platform-support/android.md) | \u2713 | ARM64 Android\n `aarch64-unknown-none-softfloat` | * | Bare ARM64, softfloat\n `aarch64-unknown-none` | * | Bare ARM64, hardfloat\n+[`aarch64-unknown-uefi`](platform-support/unknown-uefi.md) | * | ARM64 UEFI\n [`arm-linux-androideabi`](platform-support/android.md) | \u2713 | ARMv7 Android\n `arm-unknown-linux-musleabi` | \u2713 | ARMv6 Linux with MUSL\n `arm-unknown-linux-musleabihf` | \u2713 | ARMv6 Linux with MUSL, hardfloat\n@@ -149,6 +150,7 @@ target | std | notes\n [`i686-linux-android`](platform-support/android.md) | \u2713 | 32-bit x86 Android\n `i686-unknown-freebsd` | \u2713 | 32-bit FreeBSD\n `i686-unknown-linux-musl` | \u2713 | 32-bit Linux with MUSL\n+[`i686-unknown-uefi`](platform-support/unknown-uefi.md) | * | 32-bit UEFI\n `mips-unknown-linux-musl` | \u2713 | MIPS Linux with MUSL\n `mips64-unknown-linux-muslabi64` | \u2713 | MIPS64 Linux, n64 ABI, MUSL\n `mips64el-unknown-linux-muslabi64` | \u2713 | MIPS64 (LE) Linux, n64 ABI, MUSL\n@@ -181,6 +183,7 @@ target | std | notes\n `x86_64-unknown-linux-gnux32` | \u2713 | 64-bit Linux (x32 ABI) (kernel 4.15, glibc 2.27)\n [`x86_64-unknown-none`](platform-support/x86_64-unknown-none.md) | * | Freestanding/bare-metal x86_64, softfloat\n `x86_64-unknown-redox` | \u2713 | Redox OS\n+[`x86_64-unknown-uefi`](platform-support/unknown-uefi.md) | * | 64-bit UEFI\n \n [Fortanix ABI]: https://edp.fortanix.com/\n \n@@ -213,7 +216,6 @@ target | std | host | notes\n [`aarch64-pc-windows-gnullvm`](platform-support/pc-windows-gnullvm.md) | \u2713 | \u2713 |\n `aarch64-unknown-freebsd` | \u2713 | \u2713 | ARM64 FreeBSD\n `aarch64-unknown-hermit` | \u2713 |  | ARM64 HermitCore\n-[`aarch64-unknown-uefi`](platform-support/unknown-uefi.md) | * |  | ARM64 UEFI\n `aarch64-unknown-linux-gnu_ilp32` | \u2713 | \u2713 | ARM64 Linux (ILP32 ABI)\n `aarch64-unknown-netbsd` | \u2713 | \u2713 |\n [`aarch64-unknown-openbsd`](platform-support/openbsd.md) | \u2713 | \u2713 | ARM64 OpenBSD\n@@ -252,7 +254,6 @@ target | std | host | notes\n `i686-unknown-haiku` | \u2713 | \u2713 | 32-bit Haiku\n `i686-unknown-netbsd` | \u2713 | \u2713 | NetBSD/i386 with SSE2\n [`i686-unknown-openbsd`](platform-support/openbsd.md) | \u2713 | \u2713 | 32-bit OpenBSD\n-[`i686-unknown-uefi`](platform-support/unknown-uefi.md) | * |  | 32-bit UEFI\n `i686-uwp-windows-gnu` | ? |  |\n `i686-uwp-windows-msvc` | ? |  |\n `i686-wrs-vxworks` | ? |  |\n@@ -311,7 +312,6 @@ target | std | host | notes\n `x86_64-unknown-l4re-uclibc` | ? |  |\n `x86_64-unknown-none-linuxkernel` | * |  | Linux kernel modules\n [`x86_64-unknown-openbsd`](platform-support/openbsd.md) | \u2713 | \u2713 | 64-bit OpenBSD\n-[`x86_64-unknown-uefi`](platform-support/unknown-uefi.md) | * |  | 64-bit UEFI\n `x86_64-uwp-windows-gnu` | \u2713 |  |\n `x86_64-uwp-windows-msvc` | \u2713 |  |\n `x86_64-wrs-vxworks` | ? |  |"}, {"sha": "e2bdf73a92990cc4879e44ad7cb3ab6118c8adf3", "filename": "src/doc/rustc/src/platform-support/unknown-uefi.md", "status": "modified", "additions": 8, "deletions": 30, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Funknown-uefi.md", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Funknown-uefi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Funknown-uefi.md?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -1,6 +1,6 @@\n # `*-unknown-uefi`\n \n-**Tier: 3**\n+**Tier: 2**\n \n Unified Extensible Firmware Interface (UEFI) targets for application, driver,\n and core UEFI binaries.\n@@ -72,28 +72,14 @@ target = [\"x86_64-unknown-uefi\"]\n \n ## Building Rust programs\n \n-Rust does not yet ship pre-compiled artifacts for this target. To compile for\n-this target, you will either need to build Rust with the target enabled (see\n-\"Building rust for UEFI targets\" above), or build your own copy of `core` by\n-using `build-std`, `cargo-buildx`, or similar.\n-\n-A native build with the unstable `build-std`-feature can be achieved via:\n-\n-```sh\n-cargo +nightly build \\\n-    -Zbuild-std=core,compiler_builtins \\\n-    -Zbuild-std-features=compiler-builtins-mem \\\n-    --target x86_64-unknown-uefi\n-```\n-\n-Alternatively, you can install `cargo-xbuild` via\n-`cargo install --force cargo-xbuild` and build for the UEFI targets via:\n+Starting with Rust 1.67, precompiled artifacts are provided via\n+`rustup`. For example, to use `x86_64-unknown-uefi`:\n \n ```sh\n-cargo \\\n-    +nightly \\\n-    xbuild \\\n-    --target x86_64-unknown-uefi\n+# install cross-compile toolchain\n+rustup target add x86_64-unknown-uefi\n+# target flag may be used with any cargo or rustc command\n+cargo build --target x86_64-unknown-uefi\n ```\n \n ## Testing\n@@ -167,18 +153,10 @@ The following code is a valid UEFI application returning immediately upon\n execution with an exit code of 0. A panic handler is provided. This is executed\n by rust on panic. For simplicity, we simply end up in an infinite loop.\n \n-Note that as of rust-1.31.0, all features used here are stabilized. No unstable\n-features are required, nor do we rely on nightly compilers. However, if you do\n-not compile rustc for the UEFI targets, you need a nightly compiler to support\n-the `-Z build-std` flag.\n-\n This example can be compiled as binary crate via `cargo`:\n \n ```sh\n-cargo +nightly build \\\n-    -Zbuild-std=core,compiler_builtins \\\n-    -Zbuild-std-features=compiler-builtins-mem \\\n-    --target x86_64-unknown-uefi\n+cargo build --target x86_64-unknown-uefi\n ```\n \n ```rust,ignore (platform-specific,eh-personality-is-unstable)"}, {"sha": "e14e2fc05ad39235c7589b830caa423d901621e8", "filename": "src/test/ui/attributes/key-value-non-ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftest%2Fui%2Fattributes%2Fkey-value-non-ascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftest%2Fui%2Fattributes%2Fkey-value-non-ascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fkey-value-non-ascii.rs?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -1,4 +1,4 @@\n #![feature(rustc_attrs)]\n \n-#[rustc_dummy = b\"\ufb03.rs\"] //~ ERROR non-ASCII character in byte constant\n+#[rustc_dummy = b\"\ufb03.rs\"] //~ ERROR non-ASCII character in byte string literal\n fn main() {}"}, {"sha": "23d482de6a868e36c6587c130514b8340a989ef7", "filename": "src/test/ui/attributes/key-value-non-ascii.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftest%2Fui%2Fattributes%2Fkey-value-non-ascii.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftest%2Fui%2Fattributes%2Fkey-value-non-ascii.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fkey-value-non-ascii.stderr?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -1,8 +1,8 @@\n-error: non-ASCII character in byte constant\n+error: non-ASCII character in byte string literal\n   --> $DIR/key-value-non-ascii.rs:3:19\n    |\n LL | #[rustc_dummy = b\"\ufb03.rs\"]\n-   |                   ^ byte constant must be ASCII\n+   |                   ^ must be ASCII\n    |\n help: if you meant to use the UTF-8 encoding of '\ufb03', use \\xHH escapes\n    |"}, {"sha": "b507492970ab3a27286feac128e290f3a8e2efa0", "filename": "src/test/ui/consts/fn_trait_refs.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftest%2Fui%2Fconsts%2Ffn_trait_refs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftest%2Fui%2Fconsts%2Ffn_trait_refs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Ffn_trait_refs.rs?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -1,4 +1,4 @@\n-// build-pass\n+// check-pass\n \n #![feature(const_fn_trait_ref_impls)]\n #![feature(fn_traits)]\n@@ -60,21 +60,18 @@ const fn test(i: i32) -> i32 {\n     i + 1\n }\n \n-const fn main() {\n+fn main() {\n     const fn one() -> i32 {\n         1\n     };\n     const fn two() -> i32 {\n         2\n     };\n+    const _: () = {\n+        let test_one = test_fn(one);\n+        assert!(test_one == (1, 1, 1));\n \n-    // FIXME(const_cmp_tuple)\n-    let test_one = test_fn(one);\n-    assert!(test_one.0 == 1);\n-    assert!(test_one.1 == 1);\n-    assert!(test_one.2 == 1);\n-\n-    let test_two = test_fn_mut(two);\n-    assert!(test_two.0 == 1);\n-    assert!(test_two.1 == 1);\n+        let test_two = test_fn_mut(two);\n+        assert!(test_two == (2, 2));\n+    };\n }"}, {"sha": "896dc1a1a5fba5821ef54705062b87d5a6214f03", "filename": "src/test/ui/parser/byte-literals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftest%2Fui%2Fparser%2Fbyte-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftest%2Fui%2Fparser%2Fbyte-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbyte-literals.rs?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -7,6 +7,6 @@ pub fn main() {\n     b'\\x0Z';  //~ ERROR invalid character in numeric character escape: `Z`\n     b'\t';  //~ ERROR byte constant must be escaped\n     b''';  //~ ERROR byte constant must be escaped\n-    b'\u00e9';  //~ ERROR non-ASCII character in byte constant\n+    b'\u00e9';  //~ ERROR non-ASCII character in byte literal\n     b'a  //~ ERROR unterminated byte constant [E0763]\n }"}, {"sha": "efa55ae05bd37b6ac506af989d517eaf4837e57a", "filename": "src/test/ui/parser/byte-literals.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftest%2Fui%2Fparser%2Fbyte-literals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftest%2Fui%2Fparser%2Fbyte-literals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbyte-literals.stderr?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -32,11 +32,11 @@ error: byte constant must be escaped: `'`\n LL |     b''';\n    |       ^ help: escape the character: `\\'`\n \n-error: non-ASCII character in byte constant\n+error: non-ASCII character in byte literal\n   --> $DIR/byte-literals.rs:10:7\n    |\n LL |     b'\u00e9';\n-   |       ^ byte constant must be ASCII\n+   |       ^ must be ASCII\n    |\n help: if you meant to use the unicode code point for '\u00e9', use a \\xHH escape\n    |"}, {"sha": "30a4f50c4e40b694cb5152627f0a1987c814dd5f", "filename": "src/test/ui/parser/byte-string-literals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftest%2Fui%2Fparser%2Fbyte-string-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftest%2Fui%2Fparser%2Fbyte-string-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbyte-string-literals.rs?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -3,7 +3,7 @@ static FOO: &'static [u8] = b\"\\f\";  //~ ERROR unknown byte escape\n pub fn main() {\n     b\"\\f\";  //~ ERROR unknown byte escape\n     b\"\\x0Z\";  //~ ERROR invalid character in numeric character escape: `Z`\n-    b\"\u00e9\";  //~ ERROR non-ASCII character in byte constant\n-    br##\"\u00e9\"##;  //~ ERROR raw byte string must be ASCII\n+    b\"\u00e9\";  //~ ERROR non-ASCII character in byte string literal\n+    br##\"\u00e9\"##;  //~ ERROR non-ASCII character in raw byte string literal\n     b\"a  //~ ERROR unterminated double quote byte string\n }"}, {"sha": "5b96cc3d18abc37332f5ce9648d3dd9f844513b8", "filename": "src/test/ui/parser/byte-string-literals.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftest%2Fui%2Fparser%2Fbyte-string-literals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftest%2Fui%2Fparser%2Fbyte-string-literals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbyte-string-literals.stderr?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -20,18 +20,18 @@ error: invalid character in numeric character escape: `Z`\n LL |     b\"\\x0Z\";\n    |          ^ invalid character in numeric character escape\n \n-error: non-ASCII character in byte constant\n+error: non-ASCII character in byte string literal\n   --> $DIR/byte-string-literals.rs:6:7\n    |\n LL |     b\"\u00e9\";\n-   |       ^ byte constant must be ASCII\n+   |       ^ must be ASCII\n    |\n help: if you meant to use the unicode code point for '\u00e9', use a \\xHH escape\n    |\n LL |     b\"\\xE9\";\n    |       ~~~~\n \n-error: raw byte string must be ASCII\n+error: non-ASCII character in raw byte string literal\n   --> $DIR/byte-string-literals.rs:7:10\n    |\n LL |     br##\"\u00e9\"##;"}, {"sha": "1b859fee596adf6934dbbdcec51644c2442daf0a", "filename": "src/test/ui/parser/raw/raw-byte-string-literals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-literals.rs?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -2,6 +2,6 @@\n \n pub fn main() {\n     br\"a\r\"; //~ ERROR bare CR not allowed in raw string\n-    br\"\u00e9\";  //~ ERROR raw byte string must be ASCII\n+    br\"\u00e9\";  //~ ERROR non-ASCII character in raw byte string literal\n     br##~\"a\"~##;  //~ ERROR only `#` is allowed in raw string delimitation\n }"}, {"sha": "a2f27d1ed70aee56808edb7302ebad643bcf94f9", "filename": "src/test/ui/parser/raw/raw-byte-string-literals.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-literals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-literals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-byte-string-literals.stderr?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -4,7 +4,7 @@ error: bare CR not allowed in raw string\n LL |     br\"a\r\";\n    |         ^\n \n-error: raw byte string must be ASCII\n+error: non-ASCII character in raw byte string literal\n   --> $DIR/raw-byte-string-literals.rs:5:8\n    |\n LL |     br\"\u00e9\";"}, {"sha": "df099bb62ad1ec5103a80ae2a08a64b4d114f544", "filename": "src/test/ui/parser/unicode-control-codepoints.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftest%2Fui%2Fparser%2Funicode-control-codepoints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftest%2Fui%2Fparser%2Funicode-control-codepoints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Funicode-control-codepoints.rs?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -14,15 +14,15 @@ fn main() {\n     println!(\"{:?}\", r##\"/*\u202e } \u2066if isAdmin\u2069 \u2066 begin admins only \"##);\n     //~^ ERROR unicode codepoint changing visible direction of text present in literal\n     println!(\"{:?}\", b\"/*\u202e } \u2066if isAdmin\u2069 \u2066 begin admins only \");\n-    //~^ ERROR non-ASCII character in byte constant\n-    //~| ERROR non-ASCII character in byte constant\n-    //~| ERROR non-ASCII character in byte constant\n-    //~| ERROR non-ASCII character in byte constant\n+    //~^ ERROR non-ASCII character in byte string literal\n+    //~| ERROR non-ASCII character in byte string literal\n+    //~| ERROR non-ASCII character in byte string literal\n+    //~| ERROR non-ASCII character in byte string literal\n     println!(\"{:?}\", br##\"/*\u202e } \u2066if isAdmin\u2069 \u2066 begin admins only \"##);\n-    //~^ ERROR raw byte string must be ASCII\n-    //~| ERROR raw byte string must be ASCII\n-    //~| ERROR raw byte string must be ASCII\n-    //~| ERROR raw byte string must be ASCII\n+    //~^ ERROR non-ASCII character in raw byte string literal\n+    //~| ERROR non-ASCII character in raw byte string literal\n+    //~| ERROR non-ASCII character in raw byte string literal\n+    //~| ERROR non-ASCII character in raw byte string literal\n     println!(\"{:?}\", '\u202e');\n     //~^ ERROR unicode codepoint changing visible direction of text present in literal\n }"}, {"sha": "fc071a941914210c110a8c13ec43b053d5a60e1d", "filename": "src/test/ui/parser/unicode-control-codepoints.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftest%2Fui%2Fparser%2Funicode-control-codepoints.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftest%2Fui%2Fparser%2Funicode-control-codepoints.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Funicode-control-codepoints.stderr?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -14,69 +14,69 @@ LL |     println!(\"{:?}\", b\"us\\u{202B}e\\u{202A}r\");\n    |\n    = help: unicode escape sequences cannot be used as a byte or in a byte string\n \n-error: non-ASCII character in byte constant\n+error: non-ASCII character in byte string literal\n   --> $DIR/unicode-control-codepoints.rs:16:26\n    |\n LL |     println!(\"{:?}\", b\"/* } if isAdmin  begin admins only \");\n-   |                          ^ byte constant must be ASCII but is '\\u{202e}'\n+   |                          ^ must be ASCII but is '\\u{202e}'\n    |\n help: if you meant to use the UTF-8 encoding of '\\u{202e}', use \\xHH escapes\n    |\n LL |     println!(\"{:?}\", b\"/*\\xE2\\x80\\xAE } if isAdmin  begin admins only \");\n    |                          ~~~~~~~~~~~~\n \n-error: non-ASCII character in byte constant\n+error: non-ASCII character in byte string literal\n   --> $DIR/unicode-control-codepoints.rs:16:30\n    |\n LL |     println!(\"{:?}\", b\"/* } if isAdmin  begin admins only \");\n-   |                             ^ byte constant must be ASCII but is '\\u{2066}'\n+   |                             ^ must be ASCII but is '\\u{2066}'\n    |\n help: if you meant to use the UTF-8 encoding of '\\u{2066}', use \\xHH escapes\n    |\n LL |     println!(\"{:?}\", b\"/* } \\xE2\\x81\\xA6if isAdmin  begin admins only \");\n    |                             ~~~~~~~~~~~~\n \n-error: non-ASCII character in byte constant\n+error: non-ASCII character in byte string literal\n   --> $DIR/unicode-control-codepoints.rs:16:41\n    |\n LL |     println!(\"{:?}\", b\"/* } if isAdmin  begin admins only \");\n-   |                                       ^ byte constant must be ASCII but is '\\u{2069}'\n+   |                                       ^ must be ASCII but is '\\u{2069}'\n    |\n help: if you meant to use the UTF-8 encoding of '\\u{2069}', use \\xHH escapes\n    |\n LL |     println!(\"{:?}\", b\"/* } if isAdmin\\xE2\\x81\\xA9  begin admins only \");\n    |                                       ~~~~~~~~~~~~\n \n-error: non-ASCII character in byte constant\n+error: non-ASCII character in byte string literal\n   --> $DIR/unicode-control-codepoints.rs:16:43\n    |\n LL |     println!(\"{:?}\", b\"/* } if isAdmin  begin admins only \");\n-   |                                        ^ byte constant must be ASCII but is '\\u{2066}'\n+   |                                        ^ must be ASCII but is '\\u{2066}'\n    |\n help: if you meant to use the UTF-8 encoding of '\\u{2066}', use \\xHH escapes\n    |\n LL |     println!(\"{:?}\", b\"/* } if isAdmin \\xE2\\x81\\xA6 begin admins only \");\n    |                                        ~~~~~~~~~~~~\n \n-error: raw byte string must be ASCII\n+error: non-ASCII character in raw byte string literal\n   --> $DIR/unicode-control-codepoints.rs:21:29\n    |\n LL |     println!(\"{:?}\", br##\"/* } if isAdmin  begin admins only \"##);\n    |                             ^ must be ASCII but is '\\u{202e}'\n \n-error: raw byte string must be ASCII\n+error: non-ASCII character in raw byte string literal\n   --> $DIR/unicode-control-codepoints.rs:21:33\n    |\n LL |     println!(\"{:?}\", br##\"/* } if isAdmin  begin admins only \"##);\n    |                                ^ must be ASCII but is '\\u{2066}'\n \n-error: raw byte string must be ASCII\n+error: non-ASCII character in raw byte string literal\n   --> $DIR/unicode-control-codepoints.rs:21:44\n    |\n LL |     println!(\"{:?}\", br##\"/* } if isAdmin  begin admins only \"##);\n    |                                          ^ must be ASCII but is '\\u{2069}'\n \n-error: raw byte string must be ASCII\n+error: non-ASCII character in raw byte string literal\n   --> $DIR/unicode-control-codepoints.rs:21:46\n    |\n LL |     println!(\"{:?}\", br##\"/* } if isAdmin  begin admins only \"##);"}, {"sha": "c4105186244db3bd170af04d24875401755c386a", "filename": "src/test/ui/suggestions/multibyte-escapes.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftest%2Fui%2Fsuggestions%2Fmultibyte-escapes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftest%2Fui%2Fsuggestions%2Fmultibyte-escapes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmultibyte-escapes.rs?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -2,17 +2,17 @@\n \n fn main() {\n     b'\u00b5';\n-    //~^ ERROR: non-ASCII character in byte constant\n+    //~^ ERROR: non-ASCII character in byte literal\n     //~| HELP: if you meant to use the unicode code point for '\u00b5', use a \\xHH escape\n-    //~| NOTE: byte constant must be ASCII\n+    //~| NOTE: must be ASCII\n \n     b'\u5b57';\n-    //~^ ERROR: non-ASCII character in byte constant\n+    //~^ ERROR: non-ASCII character in byte literal\n     //~| NOTE: this multibyte character does not fit into a single byte\n-    //~| NOTE: byte constant must be ASCII\n+    //~| NOTE: must be ASCII\n \n     b\"\u5b57\";\n-    //~^ ERROR: non-ASCII character in byte constant\n+    //~^ ERROR: non-ASCII character in byte string literal\n     //~| HELP: if you meant to use the UTF-8 encoding of '\u5b57', use \\xHH escapes\n-    //~| NOTE: byte constant must be ASCII\n+    //~| NOTE: must be ASCII\n }"}, {"sha": "1e7c43e6538f697f6820fab8f9eaea5297329604", "filename": "src/test/ui/suggestions/multibyte-escapes.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftest%2Fui%2Fsuggestions%2Fmultibyte-escapes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftest%2Fui%2Fsuggestions%2Fmultibyte-escapes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmultibyte-escapes.stderr?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -1,28 +1,28 @@\n-error: non-ASCII character in byte constant\n+error: non-ASCII character in byte literal\n   --> $DIR/multibyte-escapes.rs:4:7\n    |\n LL |     b'\u00b5';\n-   |       ^ byte constant must be ASCII\n+   |       ^ must be ASCII\n    |\n help: if you meant to use the unicode code point for '\u00b5', use a \\xHH escape\n    |\n LL |     b'\\xB5';\n    |       ~~~~\n \n-error: non-ASCII character in byte constant\n+error: non-ASCII character in byte literal\n   --> $DIR/multibyte-escapes.rs:9:7\n    |\n LL |     b'\u5b57';\n    |       ^^\n    |       |\n-   |       byte constant must be ASCII\n+   |       must be ASCII\n    |       this multibyte character does not fit into a single byte\n \n-error: non-ASCII character in byte constant\n+error: non-ASCII character in byte string literal\n   --> $DIR/multibyte-escapes.rs:14:7\n    |\n LL |     b\"\u5b57\";\n-   |       ^^ byte constant must be ASCII\n+   |       ^^ must be ASCII\n    |\n help: if you meant to use the UTF-8 encoding of '\u5b57', use \\xHH escapes\n    |"}, {"sha": "0551e835bb0e75ec71288c34b5c894245d354f8a", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -60,6 +60,7 @@ static TARGETS: &[&str] = &[\n     \"aarch64-unknown-none\",\n     \"aarch64-unknown-none-softfloat\",\n     \"aarch64-unknown-redox\",\n+    \"aarch64-unknown-uefi\",\n     \"arm-linux-androideabi\",\n     \"arm-unknown-linux-gnueabi\",\n     \"arm-unknown-linux-gnueabihf\",\n@@ -95,6 +96,7 @@ static TARGETS: &[&str] = &[\n     \"i686-unknown-freebsd\",\n     \"i686-unknown-linux-gnu\",\n     \"i686-unknown-linux-musl\",\n+    \"i686-unknown-uefi\",\n     \"m68k-unknown-linux-gnu\",\n     \"mips-unknown-linux-gnu\",\n     \"mips-unknown-linux-musl\",\n@@ -151,6 +153,7 @@ static TARGETS: &[&str] = &[\n     \"x86_64-unknown-none\",\n     \"x86_64-unknown-redox\",\n     \"x86_64-unknown-hermit\",\n+    \"x86_64-unknown-uefi\",\n ];\n \n /// This allows the manifest to contain rust-docs for hosts that don't build"}, {"sha": "4170c32f1fe253350e5bed1e1881f0dfb0131f64", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 27, "deletions": 30, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -55,30 +55,6 @@ const LINKCHECK_EXCEPTIONS: &[(&str, &[&str])] = &[\n \n #[rustfmt::skip]\n const INTRA_DOC_LINK_EXCEPTIONS: &[(&str, &[&str])] = &[\n-    // This will never have links that are not in other pages.\n-    // To avoid repeating the exceptions twice, an empty list means all broken links are allowed.\n-    (\"reference/print.html\", &[]),\n-    // All the reference 'links' are actually ENBF highlighted as code\n-    (\"reference/comments.html\", &[\n-         \"/</code> <code>!\",\n-         \"*</code> <code>!\",\n-    ]),\n-    (\"reference/identifiers.html\", &[\n-         \"a</code>-<code>z</code> <code>A</code>-<code>Z\",\n-         \"a</code>-<code>z</code> <code>A</code>-<code>Z</code> <code>0</code>-<code>9</code> <code>_\",\n-         \"a</code>-<code>z</code> <code>A</code>-<code>Z</code>]\u00a0[<code>a</code>-<code>z</code> <code>A</code>-<code>Z</code> <code>0</code>-<code>9</code> <code>_\",\n-    ]),\n-    (\"reference/tokens.html\", &[\n-         \"0</code>-<code>1\",\n-         \"0</code>-<code>7\",\n-         \"0</code>-<code>9\",\n-         \"0</code>-<code>9\",\n-         \"0</code>-<code>9</code> <code>a</code>-<code>f</code> <code>A</code>-<code>F\",\n-    ]),\n-    (\"reference/notation.html\", &[\n-         \"b</code> <code>B\",\n-         \"a</code>-<code>z\",\n-    ]),\n     // This is being used in the sense of 'inclusive range', not a markdown link\n     (\"core/ops/struct.RangeInclusive.html\", &[\"begin</code>, <code>end\"]),\n     (\"std/ops/struct.RangeInclusive.html\", &[\"begin</code>, <code>end\"]),\n@@ -365,6 +341,33 @@ impl Checker {\n             }\n         });\n \n+        self.check_intra_doc_links(file, &pretty_path, &source, report);\n+\n+        // we don't need the source anymore,\n+        // so drop to reduce memory-usage\n+        match self.cache.get_mut(&pretty_path).unwrap() {\n+            FileEntry::HtmlFile { source, .. } => *source = Rc::new(String::new()),\n+            _ => unreachable!(\"must be html file\"),\n+        }\n+    }\n+\n+    fn check_intra_doc_links(\n+        &mut self,\n+        file: &Path,\n+        pretty_path: &str,\n+        source: &str,\n+        report: &mut Report,\n+    ) {\n+        let relative = file.strip_prefix(&self.root).expect(\"should always be relative to root\");\n+        // Don't check the reference. It has several legitimate things that\n+        // look like [<code>\u2026</code>]. The reference has its own broken link\n+        // checker in its CI which handles this using pulldown_cmark.\n+        //\n+        // This checks both the end of the root (when checking just the\n+        // reference directory) or the beginning (when checking all docs).\n+        if self.root.ends_with(\"reference\") || relative.starts_with(\"reference\") {\n+            return;\n+        }\n         // Search for intra-doc links that rustdoc didn't warn about\n         // FIXME(#77199, 77200) Rustdoc should just warn about these directly.\n         // NOTE: only looks at one line at a time; in practice this should find most links\n@@ -379,12 +382,6 @@ impl Checker {\n                 }\n             }\n         }\n-        // we don't need the source anymore,\n-        // so drop to reduce memory-usage\n-        match self.cache.get_mut(&pretty_path).unwrap() {\n-            FileEntry::HtmlFile { source, .. } => *source = Rc::new(String::new()),\n-            _ => unreachable!(\"must be html file\"),\n-        }\n     }\n \n     /// Load a file from disk, or from the cache if available."}, {"sha": "8028ce753548888ca1aef048e896e0af0e134f33", "filename": "src/tools/miri/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -3,7 +3,6 @@\n #![feature(never_type)]\n #![feature(try_blocks)]\n #![feature(io_error_more)]\n-#![feature(int_log)]\n #![feature(variant_count)]\n #![feature(yeet_expr)]\n #![feature(is_some_and)]"}, {"sha": "0ec1f8e9c693581300e8d0659eba6b63be59a2d5", "filename": "src/tools/miri/tests/pass/integer-ops.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Finteger-ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Finteger-ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Finteger-ops.rs?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -1,5 +1,4 @@\n //@compile-flags: -Coverflow-checks=off\n-#![feature(int_log)]\n #![allow(arithmetic_overflow)]\n \n pub fn main() {"}, {"sha": "1eea2346451dd42038a9edcb5bdfe3cd368bb20c", "filename": "src/tools/rust-analyzer/crates/syntax/src/validation.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c71658706fac34e3026eceac3b428843e16cd7b4/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fvalidation.rs?ref=c71658706fac34e3026eceac3b428843e16cd7b4", "patch": "@@ -5,9 +5,7 @@\n mod block;\n \n use rowan::Direction;\n-use rustc_lexer::unescape::{\n-    self, unescape_byte, unescape_byte_literal, unescape_char, unescape_literal, Mode,\n-};\n+use rustc_lexer::unescape::{self, unescape_byte, unescape_char, unescape_literal, Mode};\n \n use crate::{\n     algo,\n@@ -143,7 +141,7 @@ fn validate_literal(literal: ast::Literal, acc: &mut Vec<SyntaxError>) {\n         ast::LiteralKind::ByteString(s) => {\n             if !s.is_raw() {\n                 if let Some(without_quotes) = unquote(text, 2, '\"') {\n-                    unescape_byte_literal(without_quotes, Mode::ByteStr, &mut |range, char| {\n+                    unescape_literal(without_quotes, Mode::ByteStr, &mut |range, char| {\n                         if let Err(err) = char {\n                             push_err(2, (range.start, err));\n                         }"}]}