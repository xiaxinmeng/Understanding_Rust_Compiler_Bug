{"sha": "2ba9d2a888aeb8978d94050bf01e6b68271fd82e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiYTlkMmE4ODhhZWI4OTc4ZDk0MDUwYmYwMWU2YjY4MjcxZmQ4MmU=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-09-18T17:19:26Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-09-26T23:20:24Z"}, "message": "libsyntax: implement auto_serialize2 for enums, records, and structs", "tree": {"sha": "42e3f7deb5817ce5b27de6133544cc5eb0dba08d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42e3f7deb5817ce5b27de6133544cc5eb0dba08d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ba9d2a888aeb8978d94050bf01e6b68271fd82e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ba9d2a888aeb8978d94050bf01e6b68271fd82e", "html_url": "https://github.com/rust-lang/rust/commit/2ba9d2a888aeb8978d94050bf01e6b68271fd82e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ba9d2a888aeb8978d94050bf01e6b68271fd82e/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "780b23af73540dad0ec78488949bbcd380efd71e", "url": "https://api.github.com/repos/rust-lang/rust/commits/780b23af73540dad0ec78488949bbcd380efd71e", "html_url": "https://github.com/rust-lang/rust/commit/780b23af73540dad0ec78488949bbcd380efd71e"}], "stats": {"total": 620, "additions": 620, "deletions": 0}, "files": [{"sha": "cef38d5ca97f301eeb758762ea45ad62bdc31437", "filename": "src/libsyntax/ext/auto_serialize2.rs", "status": "added", "additions": 616, "deletions": 0, "changes": 616, "blob_url": "https://github.com/rust-lang/rust/blob/2ba9d2a888aeb8978d94050bf01e6b68271fd82e/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba9d2a888aeb8978d94050bf01e6b68271fd82e/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs?ref=2ba9d2a888aeb8978d94050bf01e6b68271fd82e", "patch": "@@ -0,0 +1,616 @@\n+/*\n+\n+The compiler code necessary to implement the #[auto_serialize2]\n+extension.  The idea here is that type-defining items may be tagged\n+with #[auto_serialize2], which will cause us to generate a little\n+companion module with the same name as the item.\n+\n+For example, a type like:\n+\n+    type node_id = uint;\n+\n+would generate two functions like:\n+\n+    impl node_id: Serializable {\n+        fn serialize<S: Serializer>(s: S) {\n+            s.emit_uint(self)\n+        }\n+\n+        static fn deserialize<D: Deserializer>(d: D) -> node_id {\n+            d.read_uint()\n+        }\n+    }\n+\n+Other interesting scenarios are whe the item has type parameters or\n+references other non-built-in types.  A type definition like:\n+\n+    type spanned<T> = {node: T, span: span};\n+\n+would yield functions like:\n+\n+    impl<T: Serializable> spanned<T>: Serializable {\n+        fn serialize<S: Serializer>(s: S) {\n+            do s.emit_rec {\n+                s.emit_rec_field(\"node\", 0, self.node.serialize(s));\n+                s.emit_rec_field(\"span\", 1, self.span.serialize(s));\n+            }\n+        }\n+\n+        static fn deserialize<D: Deserializer>(d: D) -> spanned<T> {\n+            do d.read_rec {\n+                {\n+                    node: d.read_rec_field(~\"node\", 0, || deserialize(d)),\n+                    span: d.read_rec_field(~\"span\", 1, || deserialize(d)),\n+                }\n+            }\n+        }\n+    }\n+\n+FIXME (#2810)--Hygiene. Search for \"__\" strings.  We also assume \"std\" is the\n+standard library.\n+\n+Misc notes:\n+-----------\n+\n+I use move mode arguments for ast nodes that will get inserted as is\n+into the tree.  This is intended to prevent us from inserting the same\n+node twice.\n+\n+*/\n+\n+use base::*;\n+use codemap::span;\n+use std::map;\n+use std::map::HashMap;\n+\n+export expand;\n+\n+// Transitional reexports so qquote can find the paths it is looking for\n+mod syntax {\n+    pub use ext;\n+    pub use parse;\n+}\n+\n+fn expand(cx: ext_ctxt,\n+          span: span,\n+          _mitem: ast::meta_item,\n+          in_items: ~[@ast::item]) -> ~[@ast::item] {\n+    fn not_auto_serialize2(a: ast::attribute) -> bool {\n+        attr::get_attr_name(a) != ~\"auto_serialize2\"\n+    }\n+\n+    fn filter_attrs(item: @ast::item) -> @ast::item {\n+        @{attrs: vec::filter(item.attrs, not_auto_serialize2),\n+          .. *item}\n+    }\n+\n+    do vec::flat_map(in_items) |item| {\n+        match item.node {\n+            ast::item_ty(@{node: ast::ty_rec(fields), _}, tps) => {\n+                ~[\n+                    filter_attrs(item),\n+                    mk_rec_impl(cx, item.span, item.ident, fields, tps),\n+                ]\n+            },\n+            ast::item_class(@{ fields, _}, tps) => {\n+                ~[\n+                    filter_attrs(item),\n+                    mk_struct_impl(cx, item.span, item.ident, fields, tps),\n+                ]\n+            },\n+            ast::item_enum(enum_def, tps) => {\n+                ~[\n+                    filter_attrs(item),\n+                    mk_enum_impl(cx, item.span, item.ident, enum_def, tps),\n+                ]\n+            },\n+            _ => {\n+                cx.span_err(span, ~\"#[auto_serialize2] can only be applied \\\n+                                    to structs, record types, and enum \\\n+                                    definitions\");\n+                ~[item]\n+            }\n+        }\n+    }\n+}\n+\n+fn mk_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    tps: ~[ast::ty_param],\n+    ser_body: @ast::stmt,\n+    deser_body: @ast::expr\n+) -> @ast::item {\n+    // Make a path to the std::serialization2::Serializable trait.\n+    let path = cx.path(\n+        span,\n+        ~[\n+            cx.ident_of(~\"std\"),\n+            cx.ident_of(~\"serialization2\"),\n+            cx.ident_of(~\"Serializable\"),\n+        ]\n+    );\n+\n+    // All the type parameters need to bound to\n+    // std::serialization::Serializable.\n+    let trait_tps = do tps.map |tp| {\n+        let t_bound = ast::bound_trait(@{\n+            id: cx.next_id(),\n+            node: ast::ty_path(path, cx.next_id()),\n+            span: span,\n+        });\n+\n+        {\n+            ident: tp.ident,\n+            id: cx.next_id(),\n+            bounds: @vec::append(~[t_bound], *tp.bounds)\n+        }\n+    };\n+\n+    let opt_trait = Some(@{\n+        path: path,\n+        ref_id: cx.next_id(),\n+        impl_id: cx.next_id(),\n+    });\n+\n+    let ty = cx.ty_path(\n+        span,\n+        ~[ident],\n+        tps.map(|tp| cx.ty_path(span, ~[tp.ident], ~[]))\n+    );\n+\n+    let methods = ~[\n+        mk_ser_method(cx, span, cx.blk(span, ~[ser_body])),\n+        mk_deser_method(cx, span, ty, cx.expr_blk(deser_body)),\n+    ];\n+\n+    @{\n+        // This is a new-style impl declaration.\n+        // XXX: clownshoes\n+        ident: ast::token::special_idents::clownshoes_extensions,\n+        attrs: ~[],\n+        id: cx.next_id(),\n+        node: ast::item_impl(trait_tps, opt_trait, ty, methods),\n+        vis: ast::public,\n+        span: span,\n+    }\n+}\n+\n+fn mk_ser_method(\n+    cx: ext_ctxt,\n+    span: span,\n+    ser_body: ast::blk\n+) -> @ast::method {\n+    let ser_bound = cx.ty_path(\n+        span,\n+        ~[\n+            cx.ident_of(~\"std\"),\n+            cx.ident_of(~\"serialization2\"),\n+            cx.ident_of(~\"Serializer\"),\n+        ],\n+        ~[]\n+    );\n+\n+    let ser_tps = ~[{\n+        ident: cx.ident_of(~\"__S\"),\n+        id: cx.next_id(),\n+        bounds: @~[ast::bound_trait(ser_bound)],\n+    }];\n+\n+    let ser_inputs = ~[{\n+        mode: ast::expl(ast::by_ref),\n+        ty: cx.ty_path(span, ~[cx.ident_of(~\"__S\")], ~[]),\n+        ident: cx.ident_of(~\"__s\"),\n+        id: cx.next_id(),\n+    }];\n+\n+    let ser_output = @{\n+        id: cx.next_id(),\n+        node: ast::ty_nil,\n+        span: span,\n+    };\n+\n+    let ser_decl = {\n+        inputs: ser_inputs,\n+        output: ser_output,\n+        cf: ast::return_val,\n+    };\n+\n+    @{\n+        ident: cx.ident_of(~\"serialize\"),\n+        attrs: ~[],\n+        tps: ser_tps,\n+        self_ty: { node: ast::sty_by_ref, span: span },\n+        purity: ast::impure_fn,\n+        decl: ser_decl,\n+        body: ser_body,\n+        id: cx.next_id(),\n+        span: span,\n+        self_id: cx.next_id(),\n+        vis: ast::public,\n+    }\n+}\n+\n+fn mk_deser_method(\n+    cx: ext_ctxt,\n+    span: span,\n+    ty: @ast::ty,\n+    deser_body: ast::blk\n+) -> @ast::method {\n+    let deser_bound = cx.ty_path(\n+        span,\n+        ~[\n+            cx.ident_of(~\"std\"),\n+            cx.ident_of(~\"serialization2\"),\n+            cx.ident_of(~\"Deserializer\"),\n+        ],\n+        ~[]\n+    );\n+\n+    let deser_tps = ~[{\n+        ident: cx.ident_of(~\"__D\"),\n+        id: cx.next_id(),\n+        bounds: @~[ast::bound_trait(deser_bound)],\n+    }];\n+\n+    let deser_inputs = ~[{\n+        mode: ast::expl(ast::by_ref),\n+        ty: cx.ty_path(span, ~[cx.ident_of(~\"__D\")], ~[]),\n+        ident: cx.ident_of(~\"__d\"),\n+        id: cx.next_id(),\n+    }];\n+\n+    let deser_decl = {\n+        inputs: deser_inputs,\n+        output: ty,\n+        cf: ast::return_val,\n+    };\n+\n+    @{\n+        ident: cx.ident_of(~\"deserialize\"),\n+        attrs: ~[],\n+        tps: deser_tps,\n+        self_ty: { node: ast::sty_static, span: span },\n+        purity: ast::impure_fn,\n+        decl: deser_decl,\n+        body: deser_body,\n+        id: cx.next_id(),\n+        span: span,\n+        self_id: cx.next_id(),\n+        vis: ast::public,\n+    }\n+}\n+\n+fn mk_rec_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    fields: ~[ast::ty_field],\n+    tps: ~[ast::ty_param]\n+) -> @ast::item {\n+    // Records and structs don't have the same fields types, but they share\n+    // enough that if we extract the right subfields out we can share the\n+    // serialization generator code.\n+    let fields = do fields.map |field| {\n+        {\n+            span: field.span,\n+            ident: field.node.ident,\n+            mutbl: field.node.mt.mutbl,\n+        }\n+    };\n+\n+    let ser_body = mk_ser_fields(cx, span, fields);\n+    let deser_body = do mk_deser_fields(cx, span, fields) |fields| {\n+         ast::expr_rec(fields, None)\n+    };\n+\n+    mk_impl(cx, span, ident, tps, ser_body, deser_body)\n+}\n+\n+fn mk_struct_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    fields: ~[@ast::struct_field],\n+    tps: ~[ast::ty_param]\n+) -> @ast::item {\n+    // Records and structs don't have the same fields types, but they share\n+    // enough that if we extract the right subfields out we can share the\n+    // serialization generator code.\n+    let fields = do fields.map |field| {\n+        let (ident, mutbl) = match field.node.kind {\n+            ast::named_field(ident, mutbl, _) => (ident, mutbl),\n+            _ => fail ~\"[auto_serialize2] does not support \\\n+                        unnamed fields\",\n+        };\n+\n+        {\n+            span: field.span,\n+            ident: ident,\n+            mutbl: match mutbl {\n+                ast::class_mutable => ast::m_mutbl,\n+                ast::class_immutable => ast::m_imm,\n+            },\n+        }\n+    };\n+\n+    let ser_body = mk_ser_fields(cx, span, fields);\n+    let deser_body = do mk_deser_fields(cx, span, fields) |fields| {\n+        ast::expr_struct(cx.path(span, ~[ident]), fields, None)\n+    };\n+\n+    mk_impl(cx, span, ident, tps, ser_body, deser_body)\n+}\n+\n+fn mk_ser_fields(\n+    cx: ext_ctxt,\n+    span: span,\n+    fields: ~[{ span: span, ident: ast::ident, mutbl: ast::mutability }]\n+) -> @ast::stmt {\n+    let ext_cx = cx; // required for #ast{}\n+\n+    let stmts = do fields.mapi |idx, field| {\n+        let name = cx.lit_str(field.span, @cx.str_of(field.ident));\n+        let idx = cx.lit_uint(field.span, idx);\n+\n+        // XXX: The next couple stanzas are just to write\n+        // `self.$(name).serialize(s)`. It'd be nice if the #ast macro could\n+        // write this for us, but it doesn't appear to support quaziquoting a\n+        // value inside a field chain.\n+        let expr_self = cx.expr(\n+            span,\n+            ast::expr_path(\n+                cx.path(span, ~[cx.ident_of(~\"self\")])\n+            )\n+        );\n+\n+        let expr_name = cx.expr(\n+            span,\n+            ast::expr_field(expr_self, field.ident, ~[])\n+        );\n+\n+        let expr_serialize = cx.expr(\n+            span,\n+            ast::expr_field(expr_name, cx.ident_of(~\"serialize\"), ~[])\n+        );\n+\n+        let expr_arg = cx.expr(\n+            span,\n+            ast::expr_path(\n+                cx.path(span, ~[cx.ident_of(~\"__s\")])\n+            )\n+        );\n+\n+        let expr = cx.expr(\n+            span,\n+            ast::expr_call(expr_serialize, ~[expr_arg], false)\n+        );\n+\n+        #ast[stmt]{ __s.emit_rec_field($(name), $(idx), || $(expr))) }\n+    };\n+\n+    let fields_lambda = cx.lambda(cx.blk(span, stmts));\n+    #ast[stmt]{ __s.emit_rec($(fields_lambda)) }\n+}\n+\n+fn mk_deser_fields(\n+    cx: ext_ctxt,\n+    span: span,\n+    fields: ~[{ span: span, ident: ast::ident, mutbl: ast::mutability }],\n+    f: fn(~[ast::field]) -> ast::expr_\n+) -> @ast::expr {\n+    let ext_cx = cx; // required for #ast{}\n+\n+    let fields = do fields.mapi |idx, field| {\n+        let name = cx.lit_str(\n+            field.span,\n+            @cx.str_of(field.ident)\n+        );\n+        let idx = cx.lit_uint(field.span, idx);\n+        let expr = #ast{\n+             __d.read_rec_field($(name), $(idx), || deserialize(__d))\n+        };\n+\n+        {\n+            node: { mutbl: field.mutbl, ident: field.ident, expr: expr },\n+            span: field.span,\n+        }\n+    };\n+\n+    let fields_expr = cx.expr(span, f(fields));\n+    let fields_lambda = cx.lambda(cx.expr_blk(fields_expr));\n+    #ast{ __d.read_rec($(fields_lambda)) }\n+}\n+\n+fn mk_enum_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    enum_def: ast::enum_def,\n+    tps: ~[ast::ty_param]\n+) -> @ast::item {\n+    let ser_body = mk_enum_ser_body(\n+        cx,\n+        ident,\n+        span,\n+        enum_def.variants\n+    );\n+\n+    let deser_body = mk_enum_deser_body(\n+        cx,\n+        ident,\n+        span,\n+        enum_def.variants\n+    );\n+\n+    mk_impl(cx, span, ident, tps, ser_body, deser_body)\n+}\n+\n+fn ser_variant(\n+    cx: ext_ctxt,\n+    v_span: span,\n+    v_name: ast::ident,\n+    v_idx: @ast::expr,\n+    args: ~[ast::variant_arg]\n+) -> ast::arm {\n+    let ext_cx = cx; // required for #ast{}\n+\n+    // Name the variant arguments.\n+    let names = args.mapi(|i, _arg| cx.ident_of(fmt!(\"__v%u\", i)));\n+\n+    // Bind the names to the variant argument type.\n+    let pats = args.mapi(|i, arg| cx.binder_pat(arg.ty.span, names[i]));\n+\n+    let pat_node = if pats.is_empty() {\n+        ast::pat_ident(\n+            ast::bind_by_implicit_ref,\n+            cx.path(v_span, ~[v_name]),\n+            None\n+        )\n+    } else {\n+        ast::pat_enum(\n+            cx.path(v_span, ~[v_name]),\n+            Some(pats)\n+        )\n+    };\n+\n+    let pat = @{\n+        id: cx.next_id(),\n+        node: pat_node,\n+        span: v_span,\n+    };\n+\n+    // Create the s.emit_variant_arg statements.\n+    let stmts = do args.mapi |a_idx, _arg| {\n+        let v = cx.var_ref(v_span, names[a_idx]);\n+        let a_idx = cx.lit_uint(v_span, a_idx);\n+\n+        #ast[stmt]{\n+            __s.emit_enum_variant_arg($(a_idx), || $(v).serialize(__s));\n+        }\n+    };\n+\n+    let v_name = cx.lit_str(v_span, @cx.str_of(v_name));\n+    let v_sz = cx.lit_uint(v_span, stmts.len());\n+    let lambda = cx.lambda(cx.blk(v_span, stmts));\n+    let body = #ast{\n+         __s.emit_enum_variant($(v_name), $(v_idx), $(v_sz), $(lambda))\n+    };\n+\n+    { pats: ~[pat], guard: None, body: cx.expr_blk(body) }\n+}\n+\n+fn mk_enum_ser_body(\n+    cx: ext_ctxt,\n+    e_name: ast::ident,\n+    e_span: span,\n+    variants: ~[ast::variant]\n+) -> @ast::stmt {\n+    let ext_cx = cx; // required for #ast{}\n+\n+    let arms = do variants.mapi |v_idx, variant| {\n+        let v_span = variant.span;\n+        let v_name = variant.node.name;\n+        let v_idx = cx.lit_uint(v_span, v_idx);\n+\n+        match variant.node.kind {\n+            ast::tuple_variant_kind(args) =>\n+                ser_variant(cx, v_span, v_name, v_idx, args),\n+            ast::struct_variant_kind(*) =>\n+                fail ~\"struct variants unimplemented\",\n+            ast::enum_variant_kind(*) =>\n+                fail ~\"enum variants unimplemented\",\n+        }\n+    };\n+\n+    let match_expr = cx.expr(\n+        e_span,\n+        ast::expr_match(#ast{ self }, arms)\n+    );\n+    let e_name = cx.lit_str(e_span, @cx.str_of(e_name));\n+\n+    #ast[stmt]{ __s.emit_enum($(e_name), || $(match_expr)) }\n+}\n+\n+fn mk_enum_deser_body(\n+    cx: ext_ctxt,\n+    e_name: ast::ident,\n+    e_span: span,\n+    variants: ~[ast::variant]\n+) -> @ast::expr {\n+    let ext_cx = cx; // required for #ast{}\n+\n+    let mut arms = do variants.mapi |v_idx, variant| {\n+        let v_span = variant.span;\n+        let v_name = variant.node.name;\n+\n+        let body = match variant.node.kind {\n+            ast::tuple_variant_kind(args) => {\n+                let tys = args.map(|a| a.ty);\n+\n+                if tys.is_empty() {\n+                    // for a nullary variant v, do \"v\"\n+                    cx.var_ref(v_span, v_name)\n+                } else {\n+                    // for an n-ary variant v, do \"v(a_1, ..., a_n)\"\n+\n+                    let arg_exprs = do tys.mapi |a_idx, _ty| {\n+                        let a_idx = cx.lit_uint(v_span, a_idx);\n+                        #ast{\n+                            __d.read_enum_variant_arg($(a_idx), || {\n+                                deserialize(__d)\n+                            })\n+                        }\n+                    };\n+\n+                    cx.expr(\n+                        v_span,\n+                        ast::expr_call(\n+                            cx.var_ref(v_span, v_name),\n+                            arg_exprs,\n+                            false\n+                        )\n+                    )\n+                }\n+            },\n+            ast::struct_variant_kind(*) =>\n+                fail ~\"struct variants unimplemented\",\n+            ast::enum_variant_kind(*) =>\n+                fail ~\"enum variants unimplemented\",\n+        };\n+\n+        let pat = @{\n+            id: cx.next_id(),\n+            node: ast::pat_lit(cx.lit_uint(v_span, v_idx)),\n+            span: v_span,\n+        };\n+\n+        {\n+            pats: ~[pat],\n+            guard: None,\n+            body: cx.expr_blk(body),\n+        }\n+    };\n+\n+    let impossible_case = {\n+        pats: ~[@{ id: cx.next_id(), node: ast::pat_wild, span: e_span}],\n+        guard: None,\n+\n+        // FIXME(#3198): proper error message\n+        body: cx.expr_blk(cx.expr(e_span, ast::expr_fail(None))),\n+    };\n+\n+    vec::push(arms, impossible_case);\n+\n+    let e_name = cx.lit_str(e_span, @cx.str_of(e_name));\n+    let alt_expr = cx.expr(e_span, ast::expr_match(#ast{ i }, arms));\n+\n+    #ast{\n+        __d.read_enum($(e_name), || {\n+            __d.read_enum_variant(|i| {\n+                $(alt_expr)\n+            })\n+        })\n+    }\n+}"}, {"sha": "1cbcd0f6ddb9bae1b0d5b255ddb2ea33f0235888", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ba9d2a888aeb8978d94050bf01e6b68271fd82e/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba9d2a888aeb8978d94050bf01e6b68271fd82e/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=2ba9d2a888aeb8978d94050bf01e6b68271fd82e", "patch": "@@ -82,6 +82,8 @@ fn syntax_expander_table() -> HashMap<~str, syntax_extension> {\n     syntax_expanders.insert(~\"fmt\", builtin(ext::fmt::expand_syntax_ext));\n     syntax_expanders.insert(~\"auto_serialize\",\n                             item_decorator(ext::auto_serialize::expand));\n+    syntax_expanders.insert(~\"auto_serialize2\",\n+                            item_decorator(ext::auto_serialize2::expand));\n     syntax_expanders.insert(~\"env\", builtin(ext::env::expand_syntax_ext));\n     syntax_expanders.insert(~\"concat_idents\",\n                             builtin(ext::concat_idents::expand_syntax_ext));"}, {"sha": "a8ae9bd63a103049d7f5c7f79177720524b5a6b0", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ba9d2a888aeb8978d94050bf01e6b68271fd82e/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/2ba9d2a888aeb8978d94050bf01e6b68271fd82e/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=2ba9d2a888aeb8978d94050bf01e6b68271fd82e", "patch": "@@ -129,6 +129,8 @@ mod ext {\n     #[legacy_exports]\n     mod auto_serialize;\n     #[legacy_exports]\n+    mod auto_serialize2;\n+    #[legacy_exports]\n     mod source_util;\n \n     mod pipes {"}]}