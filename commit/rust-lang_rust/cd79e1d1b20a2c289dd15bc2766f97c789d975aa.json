{"sha": "cd79e1d1b20a2c289dd15bc2766f97c789d975aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkNzllMWQxYjIwYTJjMjg5ZGQxNWJjMjc2NmY5N2M3ODlkOTc1YWE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-27T00:47:29Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-27T00:47:29Z"}, "message": "libcore: De-export ptr, send_map, and task::local_data", "tree": {"sha": "5174f772cb4018576cf8eb615b675edd681d0443", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5174f772cb4018576cf8eb615b675edd681d0443"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd79e1d1b20a2c289dd15bc2766f97c789d975aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd79e1d1b20a2c289dd15bc2766f97c789d975aa", "html_url": "https://github.com/rust-lang/rust/commit/cd79e1d1b20a2c289dd15bc2766f97c789d975aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd79e1d1b20a2c289dd15bc2766f97c789d975aa/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c91821d356b87dcbede651a1130ea758bf6a5265", "url": "https://api.github.com/repos/rust-lang/rust/commits/c91821d356b87dcbede651a1130ea758bf6a5265", "html_url": "https://github.com/rust-lang/rust/commit/c91821d356b87dcbede651a1130ea758bf6a5265"}], "stats": {"total": 133, "additions": 51, "deletions": 82}, "files": [{"sha": "72fa2cda1a7cbf9d8d7e8c810f55f4a9c931205b", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 24, "deletions": 45, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/cd79e1d1b20a2c289dd15bc2766f97c789d975aa/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd79e1d1b20a2c289dd15bc2766f97c789d975aa/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=cd79e1d1b20a2c289dd15bc2766f97c789d975aa", "patch": "@@ -1,26 +1,5 @@\n //! Unsafe pointer utility functions\n \n-export addr_of;\n-export to_unsafe_ptr;\n-export to_const_unsafe_ptr;\n-export to_mut_unsafe_ptr;\n-export mut_addr_of;\n-export offset;\n-export const_offset;\n-export mut_offset;\n-export null;\n-export mut_null;\n-export is_null;\n-export is_not_null;\n-export memcpy;\n-export memmove;\n-export memset;\n-export to_uint;\n-export ref_eq;\n-export buf_len;\n-export position;\n-export Ptr;\n-\n use cmp::{Eq, Ord};\n use libc::{c_void, size_t};\n \n@@ -49,47 +28,47 @@ extern mod rusti {\n \n /// Get an unsafe pointer to a value\n #[inline(always)]\n-pure fn addr_of<T>(val: T) -> *T { unsafe { rusti::addr_of(val) } }\n+pub pure fn addr_of<T>(val: T) -> *T { unsafe { rusti::addr_of(val) } }\n \n /// Get an unsafe mut pointer to a value\n #[inline(always)]\n-pure fn mut_addr_of<T>(val: T) -> *mut T {\n+pub pure fn mut_addr_of<T>(val: T) -> *mut T {\n     unsafe {\n         cast::reinterpret_cast(&rusti::addr_of(val))\n     }\n }\n \n /// Calculate the offset from a pointer\n #[inline(always)]\n-fn offset<T>(ptr: *T, count: uint) -> *T {\n+pub fn offset<T>(ptr: *T, count: uint) -> *T {\n     unsafe {\n         (ptr as uint + count * sys::size_of::<T>()) as *T\n     }\n }\n \n /// Calculate the offset from a const pointer\n #[inline(always)]\n-fn const_offset<T>(ptr: *const T, count: uint) -> *const T {\n+pub fn const_offset<T>(ptr: *const T, count: uint) -> *const T {\n     unsafe {\n         (ptr as uint + count * sys::size_of::<T>()) as *T\n     }\n }\n \n /// Calculate the offset from a mut pointer\n #[inline(always)]\n-fn mut_offset<T>(ptr: *mut T, count: uint) -> *mut T {\n+pub fn mut_offset<T>(ptr: *mut T, count: uint) -> *mut T {\n     (ptr as uint + count * sys::size_of::<T>()) as *mut T\n }\n \n /// Return the offset of the first null pointer in `buf`.\n #[inline(always)]\n-unsafe fn buf_len<T>(buf: **T) -> uint {\n+pub unsafe fn buf_len<T>(buf: **T) -> uint {\n     position(buf, |i| i == null())\n }\n \n /// Return the first offset `i` such that `f(buf[i]) == true`.\n #[inline(always)]\n-unsafe fn position<T>(buf: *T, f: fn(T) -> bool) -> uint {\n+pub unsafe fn position<T>(buf: *T, f: fn(T) -> bool) -> uint {\n     let mut i = 0u;\n     loop {\n         if f(*offset(buf, i)) { return i; }\n@@ -99,17 +78,17 @@ unsafe fn position<T>(buf: *T, f: fn(T) -> bool) -> uint {\n \n /// Create an unsafe null pointer\n #[inline(always)]\n-pure fn null<T>() -> *T { unsafe { cast::reinterpret_cast(&0u) } }\n+pub pure fn null<T>() -> *T { unsafe { cast::reinterpret_cast(&0u) } }\n \n /// Create an unsafe mutable null pointer\n #[inline(always)]\n-pure fn mut_null<T>() -> *mut T { unsafe { cast::reinterpret_cast(&0u) } }\n+pub pure fn mut_null<T>() -> *mut T { unsafe { cast::reinterpret_cast(&0u) } }\n \n /// Returns true if the pointer is equal to the null pointer.\n-pure fn is_null<T>(ptr: *const T) -> bool { ptr == null() }\n+pub pure fn is_null<T>(ptr: *const T) -> bool { ptr == null() }\n \n /// Returns true if the pointer is not equal to the null pointer.\n-pure fn is_not_null<T>(ptr: *const T) -> bool { !is_null(ptr) }\n+pub pure fn is_not_null<T>(ptr: *const T) -> bool { !is_null(ptr) }\n \n /**\n  * Copies data from one location to another\n@@ -118,7 +97,7 @@ pure fn is_not_null<T>(ptr: *const T) -> bool { !is_null(ptr) }\n  * and destination may not overlap.\n  */\n #[inline(always)]\n-unsafe fn memcpy<T>(dst: *mut T, src: *const T, count: uint) {\n+pub unsafe fn memcpy<T>(dst: *mut T, src: *const T, count: uint) {\n     let n = count * sys::size_of::<T>();\n     libc_::memcpy(dst as *mut c_void, src as *c_void, n as size_t);\n }\n@@ -130,13 +109,13 @@ unsafe fn memcpy<T>(dst: *mut T, src: *const T, count: uint) {\n  * and destination may overlap.\n  */\n #[inline(always)]\n-unsafe fn memmove<T>(dst: *mut T, src: *const T, count: uint)  {\n+pub unsafe fn memmove<T>(dst: *mut T, src: *const T, count: uint) {\n     let n = count * sys::size_of::<T>();\n     libc_::memmove(dst as *mut c_void, src as *c_void, n as size_t);\n }\n \n #[inline(always)]\n-unsafe fn memset<T>(dst: *mut T, c: int, count: uint)  {\n+pub unsafe fn memset<T>(dst: *mut T, c: int, count: uint) {\n     let n = count * sys::size_of::<T>();\n     libc_::memset(dst as *mut c_void, c as libc::c_int, n as size_t);\n }\n@@ -148,7 +127,7 @@ unsafe fn memset<T>(dst: *mut T, c: int, count: uint)  {\n   reinterpret_cast.\n */\n #[inline(always)]\n-fn to_unsafe_ptr<T>(thing: &T) -> *T {\n+pub fn to_unsafe_ptr<T>(thing: &T) -> *T {\n     unsafe { cast::reinterpret_cast(&thing) }\n }\n \n@@ -158,7 +137,7 @@ fn to_unsafe_ptr<T>(thing: &T) -> *T {\n   reinterpret_cast.\n */\n #[inline(always)]\n-fn to_const_unsafe_ptr<T>(thing: &const T) -> *const T {\n+pub fn to_const_unsafe_ptr<T>(thing: &const T) -> *const T {\n     unsafe { cast::reinterpret_cast(&thing) }\n }\n \n@@ -168,7 +147,7 @@ fn to_const_unsafe_ptr<T>(thing: &const T) -> *const T {\n   reinterpret_cast.\n */\n #[inline(always)]\n-fn to_mut_unsafe_ptr<T>(thing: &mut T) -> *mut T {\n+pub fn to_mut_unsafe_ptr<T>(thing: &mut T) -> *mut T {\n     unsafe { cast::reinterpret_cast(&thing) }\n }\n \n@@ -180,17 +159,17 @@ fn to_mut_unsafe_ptr<T>(thing: &mut T) -> *mut T {\n   (I couldn't think of a cutesy name for this one.)\n */\n #[inline(always)]\n-fn to_uint<T>(thing: &T) -> uint unsafe {\n+pub fn to_uint<T>(thing: &T) -> uint unsafe {\n     cast::reinterpret_cast(&thing)\n }\n \n /// Determine if two borrowed pointers point to the same thing.\n #[inline(always)]\n-fn ref_eq<T>(thing: &a/T, other: &b/T) -> bool {\n+pub fn ref_eq<T>(thing: &a/T, other: &b/T) -> bool {\n     to_uint(thing) == to_uint(other)\n }\n \n-trait Ptr {\n+pub trait Ptr {\n     pure fn is_null() -> bool;\n     pure fn is_not_null() -> bool;\n }\n@@ -253,7 +232,7 @@ impl<T:Ord> &const T : Ord {\n }\n \n #[test]\n-fn test() {\n+pub fn test() {\n     unsafe {\n         type Pair = {mut fst: int, mut snd: int};\n         let p = {mut fst: 10, mut snd: 20};\n@@ -285,7 +264,7 @@ fn test() {\n }\n \n #[test]\n-fn test_position() {\n+pub fn test_position() {\n     use str::as_c_str;\n     use libc::c_char;\n \n@@ -298,7 +277,7 @@ fn test_position() {\n }\n \n #[test]\n-fn test_buf_len() {\n+pub fn test_buf_len() {\n     let s0 = ~\"hello\";\n     let s1 = ~\"there\";\n     let s2 = ~\"thing\";\n@@ -316,7 +295,7 @@ fn test_buf_len() {\n }\n \n #[test]\n-fn test_is_null() {\n+pub fn test_is_null() {\n    let p: *int = ptr::null();\n    assert p.is_null();\n    assert !p.is_not_null();"}, {"sha": "ac9a012c373c210722bc6b9a9e58004ff11c4481", "filename": "src/libcore/send_map.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cd79e1d1b20a2c289dd15bc2766f97c789d975aa/src%2Flibcore%2Fsend_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd79e1d1b20a2c289dd15bc2766f97c789d975aa/src%2Flibcore%2Fsend_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsend_map.rs?ref=cd79e1d1b20a2c289dd15bc2766f97c789d975aa", "patch": "@@ -12,7 +12,7 @@ use cmp::Eq;\n use hash::Hash;\n use to_bytes::IterBytes;\n \n-trait SendMap<K:Eq Hash, V: Copy> {\n+pub trait SendMap<K:Eq Hash, V: Copy> {\n     // FIXME(#3148)  ^^^^ once find_ref() works, we can drop V:copy\n \n     fn insert(&mut self, +k: K, +v: V) -> bool;\n@@ -31,17 +31,15 @@ trait SendMap<K:Eq Hash, V: Copy> {\n }\n \n /// Open addressing with linear probing.\n-mod linear {\n-    #[legacy_exports];\n-    export LinearMap, linear_map, linear_map_with_capacity, public_methods;\n-\n+pub mod linear {\n     const initial_capacity: uint = 32u; // 2^5\n+\n     struct Bucket<K:Eq Hash,V> {\n         hash: uint,\n         key: K,\n         value: V,\n     }\n-    struct LinearMap<K:Eq Hash,V> {\n+    pub struct LinearMap<K:Eq Hash,V> {\n         k0: u64,\n         k1: u64,\n         resize_at: uint,\n@@ -60,11 +58,11 @@ mod linear {\n         ((capacity as float) * 3. / 4.) as uint\n     }\n \n-    fn LinearMap<K:Eq Hash,V>() -> LinearMap<K,V> {\n+    pub fn LinearMap<K:Eq Hash,V>() -> LinearMap<K,V> {\n         linear_map_with_capacity(32)\n     }\n \n-    fn linear_map_with_capacity<K:Eq Hash,V>(\n+    pub fn linear_map_with_capacity<K:Eq Hash,V>(\n         initial_capacity: uint) -> LinearMap<K,V> {\n         let r = rand::Rng();\n         linear_map_with_capacity_and_keys(r.gen_u64(), r.gen_u64(),\n@@ -366,13 +364,11 @@ mod linear {\n }\n \n #[test]\n-mod test {\n-    #[legacy_exports];\n-\n+pub mod test {\n     use linear::LinearMap;\n \n     #[test]\n-    fn inserts() {\n+    pub fn inserts() {\n         let mut m = ~LinearMap();\n         assert m.insert(1, 2);\n         assert m.insert(2, 4);\n@@ -381,7 +377,7 @@ mod test {\n     }\n \n     #[test]\n-    fn overwrite() {\n+    pub fn overwrite() {\n         let mut m = ~LinearMap();\n         assert m.insert(1, 2);\n         assert m.get(&1) == 2;\n@@ -390,7 +386,7 @@ mod test {\n     }\n \n     #[test]\n-    fn conflicts() {\n+    pub fn conflicts() {\n         let mut m = linear::linear_map_with_capacity(4);\n         assert m.insert(1, 2);\n         assert m.insert(5, 3);\n@@ -401,7 +397,7 @@ mod test {\n     }\n \n     #[test]\n-    fn conflict_remove() {\n+    pub fn conflict_remove() {\n         let mut m = linear::linear_map_with_capacity(4);\n         assert m.insert(1, 2);\n         assert m.insert(5, 3);\n@@ -412,7 +408,7 @@ mod test {\n     }\n \n     #[test]\n-    fn empty() {\n+    pub fn empty() {\n         let mut m = linear::linear_map_with_capacity(4);\n         assert m.insert(1, 2);\n         assert !m.is_empty();\n@@ -421,7 +417,7 @@ mod test {\n     }\n \n     #[test]\n-    fn iterate() {\n+    pub fn iterate() {\n         let mut m = linear::linear_map_with_capacity(4);\n         for uint::range(0, 32) |i| {\n             assert m.insert(i, i*2);\n@@ -435,7 +431,7 @@ mod test {\n     }\n \n     #[test]\n-    fn find_ref() {\n+    pub fn find_ref() {\n         let mut m = ~LinearMap();\n         assert m.find_ref(&1).is_none();\n         m.insert(1, 2);"}, {"sha": "313ad16fa0fb71d0bb53eed14dab4ef2a35f46e1", "filename": "src/libcore/task/local_data.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cd79e1d1b20a2c289dd15bc2766f97c789d975aa/src%2Flibcore%2Ftask%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd79e1d1b20a2c289dd15bc2766f97c789d975aa/src%2Flibcore%2Ftask%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data.rs?ref=cd79e1d1b20a2c289dd15bc2766f97c789d975aa", "patch": "@@ -16,12 +16,6 @@ magic.\n \n */\n \n-export LocalDataKey;\n-export local_data_pop;\n-export local_data_get;\n-export local_data_set;\n-export local_data_modify;\n-\n use local_data_priv::{\n     local_pop,\n     local_get,\n@@ -43,13 +37,13 @@ use local_data_priv::{\n  *\n  * These two cases aside, the interface is safe.\n  */\n-type LocalDataKey<T: Owned> = &fn(+v: @T);\n+pub type LocalDataKey<T: Owned> = &fn(+v: @T);\n \n /**\n  * Remove a task-local data value from the table, returning the\n  * reference that was originally created to insert it.\n  */\n-unsafe fn local_data_pop<T: Owned>(\n+pub unsafe fn local_data_pop<T: Owned>(\n     key: LocalDataKey<T>) -> Option<@T> {\n \n     local_pop(rt::rust_get_task(), key)\n@@ -58,7 +52,7 @@ unsafe fn local_data_pop<T: Owned>(\n  * Retrieve a task-local data value. It will also be kept alive in the\n  * table until explicitly removed.\n  */\n-unsafe fn local_data_get<T: Owned>(\n+pub unsafe fn local_data_get<T: Owned>(\n     key: LocalDataKey<T>) -> Option<@T> {\n \n     local_get(rt::rust_get_task(), key)\n@@ -67,7 +61,7 @@ unsafe fn local_data_get<T: Owned>(\n  * Store a value in task-local data. If this key already has a value,\n  * that value is overwritten (and its destructor is run).\n  */\n-unsafe fn local_data_set<T: Owned>(\n+pub unsafe fn local_data_set<T: Owned>(\n     key: LocalDataKey<T>, +data: @T) {\n \n     local_set(rt::rust_get_task(), key, data)\n@@ -76,15 +70,15 @@ unsafe fn local_data_set<T: Owned>(\n  * Modify a task-local data value. If the function returns 'None', the\n  * data is removed (and its reference dropped).\n  */\n-unsafe fn local_data_modify<T: Owned>(\n+pub unsafe fn local_data_modify<T: Owned>(\n     key: LocalDataKey<T>,\n     modify_fn: fn(Option<@T>) -> Option<@T>) {\n \n     local_modify(rt::rust_get_task(), key, modify_fn)\n }\n \n #[test]\n-fn test_tls_multitask() unsafe {\n+pub fn test_tls_multitask() unsafe {\n     fn my_key(+_x: @~str) { }\n     local_data_set(my_key, @~\"parent data\");\n     do task::spawn unsafe {\n@@ -100,15 +94,15 @@ fn test_tls_multitask() unsafe {\n }\n \n #[test]\n-fn test_tls_overwrite() unsafe {\n+pub fn test_tls_overwrite() unsafe {\n     fn my_key(+_x: @~str) { }\n     local_data_set(my_key, @~\"first data\");\n     local_data_set(my_key, @~\"next data\"); // Shouldn't leak.\n     assert *(local_data_get(my_key).get()) == ~\"next data\";\n }\n \n #[test]\n-fn test_tls_pop() unsafe {\n+pub fn test_tls_pop() unsafe {\n     fn my_key(+_x: @~str) { }\n     local_data_set(my_key, @~\"weasel\");\n     assert *(local_data_pop(my_key).get()) == ~\"weasel\";\n@@ -117,7 +111,7 @@ fn test_tls_pop() unsafe {\n }\n \n #[test]\n-fn test_tls_modify() unsafe {\n+pub fn test_tls_modify() unsafe {\n     fn my_key(+_x: @~str) { }\n     local_data_modify(my_key, |data| {\n         match data {\n@@ -136,7 +130,7 @@ fn test_tls_modify() unsafe {\n }\n \n #[test]\n-fn test_tls_crust_automorestack_memorial_bug() unsafe {\n+pub fn test_tls_crust_automorestack_memorial_bug() unsafe {\n     // This might result in a stack-canary clobber if the runtime fails to set\n     // sp_limit to 0 when calling the cleanup extern - it might automatically\n     // jump over to the rust stack, which causes next_c_sp to get recorded as\n@@ -149,7 +143,7 @@ fn test_tls_crust_automorestack_memorial_bug() unsafe {\n }\n \n #[test]\n-fn test_tls_multiple_types() unsafe {\n+pub fn test_tls_multiple_types() unsafe {\n     fn str_key(+_x: @~str) { }\n     fn box_key(+_x: @@()) { }\n     fn int_key(+_x: @int) { }\n@@ -161,7 +155,7 @@ fn test_tls_multiple_types() unsafe {\n }\n \n #[test]\n-fn test_tls_overwrite_multiple_types() {\n+pub fn test_tls_overwrite_multiple_types() {\n     fn str_key(+_x: @~str) { }\n     fn box_key(+_x: @@()) { }\n     fn int_key(+_x: @int) { }\n@@ -177,7 +171,7 @@ fn test_tls_overwrite_multiple_types() {\n #[test]\n #[should_fail]\n #[ignore(cfg(windows))]\n-fn test_tls_cleanup_on_failure() unsafe {\n+pub fn test_tls_cleanup_on_failure() unsafe {\n     fn str_key(+_x: @~str) { }\n     fn box_key(+_x: @@()) { }\n     fn int_key(+_x: @int) { }"}]}