{"sha": "74bc7fda8c1cdb8bbf29d9901cbfc31a2e0da86b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0YmM3ZmRhOGMxY2RiOGJiZjI5ZDk5MDFjYmZjMzFhMmUwZGE4NmI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-03-08T12:36:49Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-03-09T03:46:33Z"}, "message": "Overhaul coercion to use the lazy InferOk obligations passing.", "tree": {"sha": "bbeb1f4feff00ec22a53883267c53f928c24b472", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bbeb1f4feff00ec22a53883267c53f928c24b472"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74bc7fda8c1cdb8bbf29d9901cbfc31a2e0da86b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74bc7fda8c1cdb8bbf29d9901cbfc31a2e0da86b", "html_url": "https://github.com/rust-lang/rust/commit/74bc7fda8c1cdb8bbf29d9901cbfc31a2e0da86b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74bc7fda8c1cdb8bbf29d9901cbfc31a2e0da86b/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "319890487a531c38b8afd4cdabcdac2c7dd8dc5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/319890487a531c38b8afd4cdabcdac2c7dd8dc5b", "html_url": "https://github.com/rust-lang/rust/commit/319890487a531c38b8afd4cdabcdac2c7dd8dc5b"}], "stats": {"total": 208, "additions": 99, "deletions": 109}, "files": [{"sha": "1aab4853a4f641f6efd096c191365258b75d46c9", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/74bc7fda8c1cdb8bbf29d9901cbfc31a2e0da86b/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bc7fda8c1cdb8bbf29d9901cbfc31a2e0da86b/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=74bc7fda8c1cdb8bbf29d9901cbfc31a2e0da86b", "patch": "@@ -12,6 +12,7 @@ use astconv::AstConv;\n \n use super::FnCtxt;\n \n+use rustc::infer::InferOk;\n use rustc::traits;\n use rustc::ty::{self, Ty, TraitRef};\n use rustc::ty::{ToPredicate, TypeFoldable};\n@@ -149,6 +150,14 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n \n     pub fn finalize<'b, I>(self, pref: LvaluePreference, exprs: I)\n         where I: IntoIterator<Item = &'b hir::Expr>\n+    {\n+        let fcx = self.fcx;\n+        fcx.register_infer_ok_obligations(self.finalize_as_infer_ok(pref, exprs));\n+    }\n+\n+    pub fn finalize_as_infer_ok<'b, I>(self, pref: LvaluePreference, exprs: I)\n+                                       -> InferOk<'tcx, ()>\n+        where I: IntoIterator<Item = &'b hir::Expr>\n     {\n         let methods: Vec<_> = self.steps\n             .iter()\n@@ -176,8 +185,9 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        for obligation in self.obligations {\n-            self.fcx.register_predicate(obligation);\n+        InferOk {\n+            value: (),\n+            obligations: self.obligations\n         }\n     }\n }"}, {"sha": "651058728816ef231cbfee9c5c6d98582dfee155", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 87, "deletions": 107, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/74bc7fda8c1cdb8bbf29d9901cbfc31a2e0da86b/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bc7fda8c1cdb8bbf29d9901cbfc31a2e0da86b/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=74bc7fda8c1cdb8bbf29d9901cbfc31a2e0da86b", "patch": "@@ -64,7 +64,8 @@ use check::FnCtxt;\n \n use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use rustc::infer::{Coercion, InferOk, TypeTrace};\n+use rustc::infer::{Coercion, InferResult, InferOk, TypeTrace};\n+use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::traits::{self, ObligationCause, ObligationCauseCode};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use rustc::ty::{self, LvaluePreference, TypeAndMut,\n@@ -75,17 +76,14 @@ use rustc::ty::relate::RelateResult;\n use rustc::ty::subst::Subst;\n use syntax::abi;\n use syntax::feature_gate;\n-use util::common::indent;\n \n-use std::cell::RefCell;\n use std::collections::VecDeque;\n use std::ops::Deref;\n \n struct Coerce<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n     cause: ObligationCause<'tcx>,\n     use_lub: bool,\n-    unsizing_obligations: RefCell<Vec<traits::PredicateObligation<'tcx>>>,\n }\n \n impl<'a, 'gcx, 'tcx> Deref for Coerce<'a, 'gcx, 'tcx> {\n@@ -95,7 +93,7 @@ impl<'a, 'gcx, 'tcx> Deref for Coerce<'a, 'gcx, 'tcx> {\n     }\n }\n \n-type CoerceResult<'tcx> = RelateResult<'tcx, (Ty<'tcx>, Adjust<'tcx>)>;\n+type CoerceResult<'tcx> = InferResult<'tcx, Adjustment<'tcx>>;\n \n fn coerce_mutbls<'tcx>(from_mutbl: hir::Mutability,\n                        to_mutbl: hir::Mutability)\n@@ -108,44 +106,53 @@ fn coerce_mutbls<'tcx>(from_mutbl: hir::Mutability,\n     }\n }\n \n+fn identity<'tcx>() -> Adjust<'tcx> {\n+    Adjust::DerefRef {\n+        autoderefs: 0,\n+        autoref: None,\n+        unsize: false,\n+    }\n+}\n+\n+fn success<'tcx>(kind: Adjust<'tcx>,\n+                 target: Ty<'tcx>,\n+                 obligations: traits::PredicateObligations<'tcx>)\n+                 -> CoerceResult<'tcx> {\n+    Ok(InferOk {\n+        value: Adjustment {\n+            kind,\n+            target\n+        },\n+        obligations\n+    })\n+}\n+\n impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n     fn new(fcx: &'f FnCtxt<'f, 'gcx, 'tcx>, cause: ObligationCause<'tcx>) -> Self {\n         Coerce {\n             fcx: fcx,\n             cause: cause,\n             use_lub: false,\n-            unsizing_obligations: RefCell::new(vec![]),\n         }\n     }\n \n-    fn unify(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+    fn unify(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n         self.commit_if_ok(|_| {\n             let trace = TypeTrace::types(&self.cause, false, a, b);\n             if self.use_lub {\n                 self.lub(false, trace, &a, &b)\n-                    .map(|ok| self.register_infer_ok_obligations(ok))\n             } else {\n                 self.sub(false, trace, &a, &b)\n-                    .map(|InferOk { value, obligations }| {\n-                        self.fcx.register_predicates(obligations);\n-                        value\n-                    })\n             }\n         })\n     }\n \n-    /// Unify two types (using sub or lub) and produce a noop coercion.\n-    fn unify_and_identity(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n-        self.unify(&a, &b).and_then(|ty| self.identity(ty))\n-    }\n-\n-    /// Synthesize an identity adjustment.\n-    fn identity(&self, ty: Ty<'tcx>) -> CoerceResult<'tcx> {\n-        Ok((ty, Adjust::DerefRef {\n-            autoderefs: 0,\n-            autoref: None,\n-            unsize: false,\n-        }))\n+    /// Unify two types (using sub or lub) and produce a specific coercion.\n+    fn unify_and(&self, a: Ty<'tcx>, b: Ty<'tcx>, kind: Adjust<'tcx>)\n+                 -> CoerceResult<'tcx> {\n+        self.unify(&a, &b).and_then(|InferOk { value: ty, obligations }| {\n+            success(kind, ty, obligations)\n+        })\n     }\n \n     fn coerce<'a, E, I>(&self, exprs: &E, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx>\n@@ -158,11 +165,11 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n         // Just ignore error types.\n         if a.references_error() || b.references_error() {\n-            return self.identity(b);\n+            return success(identity(), b, vec![]);\n         }\n \n         if a.is_never() {\n-            return Ok((b, Adjust::NeverToAny));\n+            return success(Adjust::NeverToAny, b, vec![]);\n         }\n \n         // Consider coercing the subtype to a DST\n@@ -208,7 +215,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             }\n             _ => {\n                 // Otherwise, just use unification rules.\n-                self.unify_and_identity(a, b)\n+                self.unify_and(a, b, identity())\n             }\n         }\n     }\n@@ -240,15 +247,15 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 coerce_mutbls(mt_a.mutbl, mt_b.mutbl)?;\n                 (r_a, mt_a)\n             }\n-            _ => return self.unify_and_identity(a, b),\n+            _ => return self.unify_and(a, b, identity()),\n         };\n \n         let span = self.cause.span;\n \n         let mut first_error = None;\n         let mut r_borrow_var = None;\n         let mut autoderef = self.autoderef(span, a);\n-        let mut success = None;\n+        let mut found = None;\n \n         for (referent_ty, autoderefs) in autoderef.by_ref() {\n             if autoderefs == 0 {\n@@ -346,8 +353,8 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                                                   mutbl: mt_b.mutbl, // [1] above\n                                               });\n             match self.unify(derefd_ty_a, b) {\n-                Ok(ty) => {\n-                    success = Some((ty, autoderefs));\n+                Ok(ok) => {\n+                    found = Some((ok, autoderefs));\n                     break;\n                 }\n                 Err(err) => {\n@@ -363,7 +370,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         // (e.g., in example above, the failure from relating `Vec<T>`\n         // to the target type), since that should be the least\n         // confusing.\n-        let (ty, autoderefs) = match success {\n+        let (InferOk { value: ty, mut obligations }, autoderefs) = match found {\n             Some(d) => d,\n             None => {\n                 let err = first_error.expect(\"coerce_borrowed_pointer had no error\");\n@@ -372,12 +379,6 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             }\n         };\n \n-        // This commits the obligations to the fulfillcx. After this succeeds,\n-        // this snapshot can't be rolled back.\n-        autoderef.finalize(LvaluePreference::from_mutbl(mt_b.mutbl), exprs());\n-\n-        // Now apply the autoref. We have to extract the region out of\n-        // the final ref type we got.\n         if ty == a && mt_a.mutbl == hir::MutImmutable && autoderefs == 1 {\n             // As a special case, if we would produce `&'a *x`, that's\n             // a total no-op. We end up with the type `&'a T` just as\n@@ -391,8 +392,11 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             // `self.x`, but we auto-coerce it to `foo(&mut *self.x)`,\n             // which is a borrow.\n             assert_eq!(mt_b.mutbl, hir::MutImmutable); // can only coerce &T -> &U\n-            return self.identity(ty);\n+            return success(identity(), ty, obligations);\n         }\n+\n+        // Now apply the autoref. We have to extract the region out of\n+        // the final ref type we got.\n         let r_borrow = match ty.sty {\n             ty::TyRef(r_borrow, _) => r_borrow,\n             _ => span_bug!(span, \"expected a ref type, got {:?}\", ty),\n@@ -402,11 +406,15 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                ty,\n                autoderefs,\n                autoref);\n-        Ok((ty, Adjust::DerefRef {\n+\n+        let pref = LvaluePreference::from_mutbl(mt_b.mutbl);\n+        obligations.extend(autoderef.finalize_as_infer_ok(pref, exprs()).obligations);\n+\n+        success(Adjust::DerefRef {\n             autoderefs: autoderefs,\n             autoref: autoref,\n             unsize: false,\n-        }))\n+        }, ty, obligations)\n     }\n \n \n@@ -451,7 +459,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n         // Use a FIFO queue for this custom fulfillment procedure.\n         let mut queue = VecDeque::new();\n-        let mut leftover_predicates = vec![];\n+        let mut obligations = vec![];\n \n         // Create an obligation for `Source: CoerceUnsized<Target>`.\n         let cause = ObligationCause::misc(self.cause.span, self.body_id);\n@@ -467,7 +475,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             let trait_ref = match obligation.predicate {\n                 ty::Predicate::Trait(ref tr) if traits.contains(&tr.def_id()) => tr.clone(),\n                 _ => {\n-                    leftover_predicates.push(obligation);\n+                    obligations.push(obligation);\n                     continue;\n                 }\n             };\n@@ -495,33 +503,30 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             }\n         }\n \n-        *self.unsizing_obligations.borrow_mut() = leftover_predicates;\n-\n-        let adjustment = Adjust::DerefRef {\n+        success(Adjust::DerefRef {\n             autoderefs: if reborrow.is_some() { 1 } else { 0 },\n             autoref: reborrow,\n             unsize: true,\n-        };\n-        debug!(\"Success, coerced with {:?}\", adjustment);\n-        Ok((target, adjustment))\n+        }, target, obligations)\n     }\n \n     fn coerce_from_safe_fn(&self,\n                            a: Ty<'tcx>,\n                            fn_ty_a: ty::PolyFnSig<'tcx>,\n-                           b: Ty<'tcx>)\n+                           b: Ty<'tcx>,\n+                           to_unsafe: Adjust<'tcx>,\n+                           normal: Adjust<'tcx>)\n                            -> CoerceResult<'tcx> {\n         if let ty::TyFnPtr(fn_ty_b) = b.sty {\n             match (fn_ty_a.unsafety(), fn_ty_b.unsafety()) {\n                 (hir::Unsafety::Normal, hir::Unsafety::Unsafe) => {\n                     let unsafe_a = self.tcx.safe_to_unsafe_fn_ty(fn_ty_a);\n-                    return self.unify_and_identity(unsafe_a, b)\n-                        .map(|(ty, _)| (ty, Adjust::UnsafeFnPointer));\n+                    return self.unify_and(unsafe_a, b, to_unsafe);\n                 }\n                 _ => {}\n             }\n         }\n-        self.unify_and_identity(a, b)\n+        self.unify_and(a, b, normal)\n     }\n \n     fn coerce_from_fn_pointer(&self,\n@@ -536,7 +541,8 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         let b = self.shallow_resolve(b);\n         debug!(\"coerce_from_fn_pointer(a={:?}, b={:?})\", a, b);\n \n-        self.coerce_from_safe_fn(a, fn_ty_a, b)\n+        self.coerce_from_safe_fn(a, fn_ty_a, b,\n+            Adjust::UnsafeFnPointer, identity())\n     }\n \n     fn coerce_from_fn_item(&self,\n@@ -554,10 +560,10 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         match b.sty {\n             ty::TyFnPtr(_) => {\n                 let a_fn_pointer = self.tcx.mk_fn_ptr(fn_ty_a);\n-                self.coerce_from_safe_fn(a_fn_pointer, fn_ty_a, b)\n-                    .map(|(ty, _)| (ty, Adjust::ReifyFnPointer))\n+                self.coerce_from_safe_fn(a_fn_pointer, fn_ty_a, b,\n+                    Adjust::ReifyFnPointer, Adjust::ReifyFnPointer)\n             }\n-            _ => self.unify_and_identity(a, b),\n+            _ => self.unify_and(a, b, identity()),\n         }\n     }\n \n@@ -582,7 +588,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                                                    self.cause.span,\n                                                    feature_gate::GateIssue::Language,\n                                                    feature_gate::CLOSURE_TO_FN_COERCION);\n-                    return self.unify_and_identity(a, b);\n+                    return self.unify_and(a, b, identity());\n                 }\n                 // We coerce the closure, which has fn type\n                 //     `extern \"rust-call\" fn((arg0,arg1,...)) -> _`\n@@ -607,10 +613,9 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 let pointer_ty = self.tcx.mk_fn_ptr(converted_sig);\n                 debug!(\"coerce_closure_to_fn(a={:?}, b={:?}, pty={:?})\",\n                        a, b, pointer_ty);\n-                self.unify_and_identity(pointer_ty, b)\n-                    .map(|(ty, _)| (ty, Adjust::ClosureFnPointer))\n+                self.unify_and(pointer_ty, b, Adjust::ClosureFnPointer)\n             }\n-            _ => self.unify_and_identity(a, b),\n+            _ => self.unify_and(a, b, identity()),\n         }\n     }\n \n@@ -625,7 +630,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             ty::TyRef(_, mt) => (true, mt),\n             ty::TyRawPtr(mt) => (false, mt),\n             _ => {\n-                return self.unify_and_identity(a, b);\n+                return self.unify_and(a, b, identity());\n             }\n         };\n \n@@ -634,50 +639,22 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             mutbl: mutbl_b,\n             ty: mt_a.ty,\n         });\n-        let (ty, noop) = self.unify_and_identity(a_unsafe, b)?;\n         coerce_mutbls(mt_a.mutbl, mutbl_b)?;\n-\n         // Although references and unsafe ptrs have the same\n         // representation, we still register an Adjust::DerefRef so that\n         // regionck knows that the region for `a` must be valid here.\n-        Ok((ty,\n-            if is_ref {\n-                Adjust::DerefRef {\n-                    autoderefs: 1,\n-                    autoref: Some(AutoBorrow::RawPtr(mutbl_b)),\n-                    unsize: false,\n-                }\n-            } else if mt_a.mutbl != mutbl_b {\n-                Adjust::MutToConstPointer\n-            } else {\n-                noop\n-            }))\n-    }\n-}\n-\n-fn apply<'a, 'b, 'gcx, 'tcx, E, I>(coerce: &mut Coerce<'a, 'gcx, 'tcx>,\n-                                   exprs: &E,\n-                                   a: Ty<'tcx>,\n-                                   b: Ty<'tcx>)\n-                                   -> RelateResult<'tcx, Adjustment<'tcx>>\n-    where E: Fn() -> I,\n-          I: IntoIterator<Item = &'b hir::Expr>\n-{\n-\n-    let (ty, adjust) = indent(|| coerce.coerce(exprs, a, b))?;\n-\n-    let fcx = coerce.fcx;\n-    if let Adjust::DerefRef { unsize: true, .. } = adjust {\n-        let mut obligations = coerce.unsizing_obligations.borrow_mut();\n-        for obligation in obligations.drain(..) {\n-            fcx.register_predicate(obligation);\n-        }\n+        self.unify_and(a_unsafe, b, if is_ref {\n+            Adjust::DerefRef {\n+                autoderefs: 1,\n+                autoref: Some(AutoBorrow::RawPtr(mutbl_b)),\n+                unsize: false,\n+            }\n+        } else if mt_a.mutbl != mutbl_b {\n+            Adjust::MutToConstPointer\n+        } else {\n+            identity()\n+        })\n     }\n-\n-    Ok(Adjustment {\n-        kind: adjust,\n-        target: ty\n-    })\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n@@ -694,9 +671,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"coercion::try({:?}: {:?} -> {:?})\", expr, source, target);\n \n         let cause = self.cause(expr.span, ObligationCauseCode::ExprAssignable);\n-        let mut coerce = Coerce::new(self, cause);\n+        let coerce = Coerce::new(self, cause);\n         self.commit_if_ok(|_| {\n-            let adjustment = apply(&mut coerce, &|| Some(expr), source, target)?;\n+            let ok = coerce.coerce(&|| Some(expr), source, target)?;\n+            let adjustment = self.register_infer_ok_obligations(ok);\n             if !adjustment.is_identity() {\n                 debug!(\"Success, coerced with {:?}\", adjustment);\n                 match self.tables.borrow().adjustments.get(&expr.id) {\n@@ -773,9 +751,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // but only if the new expression has no coercion already applied to it.\n         let mut first_error = None;\n         if !self.tables.borrow().adjustments.contains_key(&new.id) {\n-            let result = self.commit_if_ok(|_| apply(&mut coerce, &|| Some(new), new_ty, prev_ty));\n+            let result = self.commit_if_ok(|_| coerce.coerce(&|| Some(new), new_ty, prev_ty));\n             match result {\n-                Ok(adjustment) => {\n+                Ok(ok) => {\n+                    let adjustment = self.register_infer_ok_obligations(ok);\n                     if !adjustment.is_identity() {\n                         self.write_adjustment(new.id, adjustment);\n                     }\n@@ -816,7 +795,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        match self.commit_if_ok(|_| apply(&mut coerce, &exprs, prev_ty, new_ty)) {\n+        match self.commit_if_ok(|_| coerce.coerce(&exprs, prev_ty, new_ty)) {\n             Err(_) => {\n                 // Avoid giving strange errors on failed attempts.\n                 if let Some(e) = first_error {\n@@ -828,7 +807,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     })\n                 }\n             }\n-            Ok(adjustment) => {\n+            Ok(ok) => {\n+                let adjustment = self.register_infer_ok_obligations(ok);\n                 if !adjustment.is_identity() {\n                     let mut tables = self.tables.borrow_mut();\n                     for expr in exprs() {"}]}