{"sha": "bcd18f977bee4db79d42d54cc7edce19c942b963", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjZDE4Zjk3N2JlZTRkYjc5ZDQyZDU0Y2M3ZWRjZTE5Yzk0MmI5NjM=", "commit": {"author": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2020-09-04T04:46:02Z"}, "committer": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2020-09-14T09:35:54Z"}, "message": "Move free functions to a new module", "tree": {"sha": "85be95ece4bcee8f2aa3356d710f131277c0f5d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85be95ece4bcee8f2aa3356d710f131277c0f5d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bcd18f977bee4db79d42d54cc7edce19c942b963", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bcd18f977bee4db79d42d54cc7edce19c942b963", "html_url": "https://github.com/rust-lang/rust/commit/bcd18f977bee4db79d42d54cc7edce19c942b963", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bcd18f977bee4db79d42d54cc7edce19c942b963/comments", "author": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f376443b8f2e8935c33f1edd08586ec7f29a900c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f376443b8f2e8935c33f1edd08586ec7f29a900c", "html_url": "https://github.com/rust-lang/rust/commit/f376443b8f2e8935c33f1edd08586ec7f29a900c"}], "stats": {"total": 345, "additions": 172, "deletions": 173}, "files": [{"sha": "87ce4e0e12b72b1dd00ea736a5dea273968fb59d", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 12, "deletions": 172, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/bcd18f977bee4db79d42d54cc7edce19c942b963/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcd18f977bee4db79d42d54cc7edce19c942b963/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=bcd18f977bee4db79d42d54cc7edce19c942b963", "patch": "@@ -17,15 +17,12 @@\n //\n // * Inherent methods. This is where most of the slice API resides.\n // * Implementations of a few common traits with important slice ops.\n-// * Definitions of a bunch of iterators.\n-// * Free functions.\n // * The `raw` and `bytes` submodules.\n // * Boilerplate trait implementations.\n \n use crate::cmp;\n use crate::cmp::Ordering::{self, Equal, Greater, Less};\n-use crate::intrinsics::{assume, is_aligned_and_not_null};\n-use crate::iter::*;\n+use crate::intrinsics::assume;\n use crate::marker::{self, Copy, Sized};\n use crate::mem;\n use crate::ops::{self, Bound, FnMut, Range, RangeBounds};\n@@ -44,6 +41,7 @@ use crate::result::Result::{Err, Ok};\n pub mod memchr;\n \n mod iter;\n+mod raw;\n mod rotate;\n mod sort;\n \n@@ -71,6 +69,16 @@ pub use iter::{ArrayChunks, ArrayChunksMut};\n #[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n pub use iter::{SplitInclusive, SplitInclusiveMut};\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use raw::{from_raw_parts, from_raw_parts_mut};\n+\n+#[stable(feature = \"from_ref\", since = \"1.28.0\")]\n+pub use raw::{from_mut, from_ref};\n+\n+// This function is public only because there is no other way to unit test heapsort.\n+#[unstable(feature = \"sort_internals\", reason = \"internal to sort module\", issue = \"none\")]\n+pub use sort::heapsort;\n+\n //\n // Extension traits\n //\n@@ -3806,174 +3814,6 @@ impl<T> Default for &mut [T] {\n     }\n }\n \n-//\n-// Free functions\n-//\n-\n-/// Forms a slice from a pointer and a length.\n-///\n-/// The `len` argument is the number of **elements**, not the number of bytes.\n-///\n-/// # Safety\n-///\n-/// Behavior is undefined if any of the following conditions are violated:\n-///\n-/// * `data` must be [valid] for reads for `len * mem::size_of::<T>()` many bytes,\n-///   and it must be properly aligned. This means in particular:\n-///\n-///     * The entire memory range of this slice must be contained within a single allocated object!\n-///       Slices can never span across multiple allocated objects. See [below](#incorrect-usage)\n-///       for an example incorrectly not taking this into account.\n-///     * `data` must be non-null and aligned even for zero-length slices. One\n-///       reason for this is that enum layout optimizations may rely on references\n-///       (including slices of any length) being aligned and non-null to distinguish\n-///       them from other data. You can obtain a pointer that is usable as `data`\n-///       for zero-length slices using [`NonNull::dangling()`].\n-///\n-/// * `data` must point to `len` consecutive properly initialized values of type `T`.\n-///\n-/// * The memory referenced by the returned slice must not be mutated for the duration\n-///   of lifetime `'a`, except inside an `UnsafeCell`.\n-///\n-/// * The total size `len * mem::size_of::<T>()` of the slice must be no larger than `isize::MAX`.\n-///   See the safety documentation of [`pointer::offset`].\n-///\n-/// # Caveat\n-///\n-/// The lifetime for the returned slice is inferred from its usage. To\n-/// prevent accidental misuse, it's suggested to tie the lifetime to whichever\n-/// source lifetime is safe in the context, such as by providing a helper\n-/// function taking the lifetime of a host value for the slice, or by explicit\n-/// annotation.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::slice;\n-///\n-/// // manifest a slice for a single element\n-/// let x = 42;\n-/// let ptr = &x as *const _;\n-/// let slice = unsafe { slice::from_raw_parts(ptr, 1) };\n-/// assert_eq!(slice[0], 42);\n-/// ```\n-///\n-/// ### Incorrect usage\n-///\n-/// The following `join_slices` function is **unsound** \u26a0\ufe0f\n-///\n-/// ```rust,no_run\n-/// use std::slice;\n-///\n-/// fn join_slices<'a, T>(fst: &'a [T], snd: &'a [T]) -> &'a [T] {\n-///     let fst_end = fst.as_ptr().wrapping_add(fst.len());\n-///     let snd_start = snd.as_ptr();\n-///     assert_eq!(fst_end, snd_start, \"Slices must be contiguous!\");\n-///     unsafe {\n-///         // The assertion above ensures `fst` and `snd` are contiguous, but they might\n-///         // still be contained within _different allocated objects_, in which case\n-///         // creating this slice is undefined behavior.\n-///         slice::from_raw_parts(fst.as_ptr(), fst.len() + snd.len())\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     // `a` and `b` are different allocated objects...\n-///     let a = 42;\n-///     let b = 27;\n-///     // ... which may nevertheless be laid out contiguously in memory: | a | b |\n-///     let _ = join_slices(slice::from_ref(&a), slice::from_ref(&b)); // UB\n-/// }\n-/// ```\n-///\n-/// [valid]: ptr#safety\n-/// [`NonNull::dangling()`]: ptr::NonNull::dangling\n-/// [`pointer::offset`]: ../../std/primitive.pointer.html#method.offset\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n-    debug_assert!(is_aligned_and_not_null(data), \"attempt to create unaligned or null slice\");\n-    debug_assert!(\n-        mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize,\n-        \"attempt to create slice covering at least half the address space\"\n-    );\n-    // SAFETY: the caller must uphold the safety contract for `from_raw_parts`.\n-    unsafe { &*ptr::slice_from_raw_parts(data, len) }\n-}\n-\n-/// Performs the same functionality as [`from_raw_parts`], except that a\n-/// mutable slice is returned.\n-///\n-/// # Safety\n-///\n-/// Behavior is undefined if any of the following conditions are violated:\n-///\n-/// * `data` must be [valid] for boths reads and writes for `len * mem::size_of::<T>()` many bytes,\n-///   and it must be properly aligned. This means in particular:\n-///\n-///     * The entire memory range of this slice must be contained within a single allocated object!\n-///       Slices can never span across multiple allocated objects.\n-///     * `data` must be non-null and aligned even for zero-length slices. One\n-///       reason for this is that enum layout optimizations may rely on references\n-///       (including slices of any length) being aligned and non-null to distinguish\n-///       them from other data. You can obtain a pointer that is usable as `data`\n-///       for zero-length slices using [`NonNull::dangling()`].\n-///\n-/// * `data` must point to `len` consecutive properly initialized values of type `T`.\n-///\n-/// * The memory referenced by the returned slice must not be accessed through any other pointer\n-///   (not derived from the return value) for the duration of lifetime `'a`.\n-///   Both read and write accesses are forbidden.\n-///\n-/// * The total size `len * mem::size_of::<T>()` of the slice must be no larger than `isize::MAX`.\n-///   See the safety documentation of [`pointer::offset`].\n-///\n-/// [valid]: ptr#safety\n-/// [`NonNull::dangling()`]: ptr::NonNull::dangling\n-/// [`pointer::offset`]: ../../std/primitive.pointer.html#method.offset\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub unsafe fn from_raw_parts_mut<'a, T>(data: *mut T, len: usize) -> &'a mut [T] {\n-    debug_assert!(is_aligned_and_not_null(data), \"attempt to create unaligned or null slice\");\n-    debug_assert!(\n-        mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize,\n-        \"attempt to create slice covering at least half the address space\"\n-    );\n-    // SAFETY: the caller must uphold the safety contract for `from_raw_parts_mut`.\n-    unsafe { &mut *ptr::slice_from_raw_parts_mut(data, len) }\n-}\n-\n-/// Converts a reference to T into a slice of length 1 (without copying).\n-#[stable(feature = \"from_ref\", since = \"1.28.0\")]\n-pub fn from_ref<T>(s: &T) -> &[T] {\n-    // SAFETY: a reference is guaranteed to be valid for reads. The returned\n-    // reference cannot be mutated as it is an immutable reference.\n-    // `mem::size_of::<T>()` cannot be larger than `isize::MAX`.\n-    // Thus the call to `from_raw_parts` is safe.\n-    unsafe { from_raw_parts(s, 1) }\n-}\n-\n-/// Converts a reference to T into a slice of length 1 (without copying).\n-#[stable(feature = \"from_ref\", since = \"1.28.0\")]\n-pub fn from_mut<T>(s: &mut T) -> &mut [T] {\n-    // SAFETY: a mutable reference is guaranteed to be valid for writes.\n-    // The reference cannot be accessed by another pointer as it is an mutable reference.\n-    // `mem::size_of::<T>()` cannot be larger than `isize::MAX`.\n-    // Thus the call to `from_raw_parts_mut` is safe.\n-    unsafe { from_raw_parts_mut(s, 1) }\n-}\n-\n-// This function is public only because there is no other way to unit test heapsort.\n-#[unstable(feature = \"sort_internals\", reason = \"internal to sort module\", issue = \"none\")]\n-#[doc(hidden)]\n-pub fn heapsort<T, F>(v: &mut [T], mut is_less: F)\n-where\n-    F: FnMut(&T, &T) -> bool,\n-{\n-    sort::heapsort(v, &mut is_less);\n-}\n-\n-//\n // Comparison traits\n //\n "}, {"sha": "a5811c5e47289f7a5a7f9356ec436a9a3e265806", "filename": "library/core/src/slice/raw.rs", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/bcd18f977bee4db79d42d54cc7edce19c942b963/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcd18f977bee4db79d42d54cc7edce19c942b963/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs?ref=bcd18f977bee4db79d42d54cc7edce19c942b963", "patch": "@@ -0,0 +1,158 @@\n+//! Free functions to create `&[T]` and `&mut [T]`.\n+\n+use crate::intrinsics::is_aligned_and_not_null;\n+use crate::mem;\n+use crate::ptr;\n+\n+/// Forms a slice from a pointer and a length.\n+///\n+/// The `len` argument is the number of **elements**, not the number of bytes.\n+///\n+/// # Safety\n+///\n+/// Behavior is undefined if any of the following conditions are violated:\n+///\n+/// * `data` must be [valid] for reads for `len * mem::size_of::<T>()` many bytes,\n+///   and it must be properly aligned. This means in particular:\n+///\n+///     * The entire memory range of this slice must be contained within a single allocated object!\n+///       Slices can never span across multiple allocated objects. See [below](#incorrect-usage)\n+///       for an example incorrectly not taking this into account.\n+///     * `data` must be non-null and aligned even for zero-length slices. One\n+///       reason for this is that enum layout optimizations may rely on references\n+///       (including slices of any length) being aligned and non-null to distinguish\n+///       them from other data. You can obtain a pointer that is usable as `data`\n+///       for zero-length slices using [`NonNull::dangling()`].\n+///\n+/// * `data` must point to `len` consecutive properly initialized values of type `T`.\n+///\n+/// * The memory referenced by the returned slice must not be mutated for the duration\n+///   of lifetime `'a`, except inside an `UnsafeCell`.\n+///\n+/// * The total size `len * mem::size_of::<T>()` of the slice must be no larger than `isize::MAX`.\n+///   See the safety documentation of [`pointer::offset`].\n+///\n+/// # Caveat\n+///\n+/// The lifetime for the returned slice is inferred from its usage. To\n+/// prevent accidental misuse, it's suggested to tie the lifetime to whichever\n+/// source lifetime is safe in the context, such as by providing a helper\n+/// function taking the lifetime of a host value for the slice, or by explicit\n+/// annotation.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::slice;\n+///\n+/// // manifest a slice for a single element\n+/// let x = 42;\n+/// let ptr = &x as *const _;\n+/// let slice = unsafe { slice::from_raw_parts(ptr, 1) };\n+/// assert_eq!(slice[0], 42);\n+/// ```\n+///\n+/// ### Incorrect usage\n+///\n+/// The following `join_slices` function is **unsound** \u26a0\ufe0f\n+///\n+/// ```rust,no_run\n+/// use std::slice;\n+///\n+/// fn join_slices<'a, T>(fst: &'a [T], snd: &'a [T]) -> &'a [T] {\n+///     let fst_end = fst.as_ptr().wrapping_add(fst.len());\n+///     let snd_start = snd.as_ptr();\n+///     assert_eq!(fst_end, snd_start, \"Slices must be contiguous!\");\n+///     unsafe {\n+///         // The assertion above ensures `fst` and `snd` are contiguous, but they might\n+///         // still be contained within _different allocated objects_, in which case\n+///         // creating this slice is undefined behavior.\n+///         slice::from_raw_parts(fst.as_ptr(), fst.len() + snd.len())\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     // `a` and `b` are different allocated objects...\n+///     let a = 42;\n+///     let b = 27;\n+///     // ... which may nevertheless be laid out contiguously in memory: | a | b |\n+///     let _ = join_slices(slice::from_ref(&a), slice::from_ref(&b)); // UB\n+/// }\n+/// ```\n+///\n+/// [valid]: ptr#safety\n+/// [`NonNull::dangling()`]: ptr::NonNull::dangling\n+/// [`pointer::offset`]: ../../std/primitive.pointer.html#method.offset\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n+    debug_assert!(is_aligned_and_not_null(data), \"attempt to create unaligned or null slice\");\n+    debug_assert!(\n+        mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize,\n+        \"attempt to create slice covering at least half the address space\"\n+    );\n+    // SAFETY: the caller must uphold the safety contract for `from_raw_parts`.\n+    unsafe { &*ptr::slice_from_raw_parts(data, len) }\n+}\n+\n+/// Performs the same functionality as [`from_raw_parts`], except that a\n+/// mutable slice is returned.\n+///\n+/// # Safety\n+///\n+/// Behavior is undefined if any of the following conditions are violated:\n+///\n+/// * `data` must be [valid] for boths reads and writes for `len * mem::size_of::<T>()` many bytes,\n+///   and it must be properly aligned. This means in particular:\n+///\n+///     * The entire memory range of this slice must be contained within a single allocated object!\n+///       Slices can never span across multiple allocated objects.\n+///     * `data` must be non-null and aligned even for zero-length slices. One\n+///       reason for this is that enum layout optimizations may rely on references\n+///       (including slices of any length) being aligned and non-null to distinguish\n+///       them from other data. You can obtain a pointer that is usable as `data`\n+///       for zero-length slices using [`NonNull::dangling()`].\n+///\n+/// * `data` must point to `len` consecutive properly initialized values of type `T`.\n+///\n+/// * The memory referenced by the returned slice must not be accessed through any other pointer\n+///   (not derived from the return value) for the duration of lifetime `'a`.\n+///   Both read and write accesses are forbidden.\n+///\n+/// * The total size `len * mem::size_of::<T>()` of the slice must be no larger than `isize::MAX`.\n+///   See the safety documentation of [`pointer::offset`].\n+///\n+/// [valid]: ptr#safety\n+/// [`NonNull::dangling()`]: ptr::NonNull::dangling\n+/// [`pointer::offset`]: ../../std/primitive.pointer.html#method.offset\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub unsafe fn from_raw_parts_mut<'a, T>(data: *mut T, len: usize) -> &'a mut [T] {\n+    debug_assert!(is_aligned_and_not_null(data), \"attempt to create unaligned or null slice\");\n+    debug_assert!(\n+        mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize,\n+        \"attempt to create slice covering at least half the address space\"\n+    );\n+    // SAFETY: the caller must uphold the safety contract for `from_raw_parts_mut`.\n+    unsafe { &mut *ptr::slice_from_raw_parts_mut(data, len) }\n+}\n+\n+/// Converts a reference to T into a slice of length 1 (without copying).\n+#[stable(feature = \"from_ref\", since = \"1.28.0\")]\n+pub fn from_ref<T>(s: &T) -> &[T] {\n+    // SAFETY: a reference is guaranteed to be valid for reads. The returned\n+    // reference cannot be mutated as it is an immutable reference.\n+    // `mem::size_of::<T>()` cannot be larger than `isize::MAX`.\n+    // Thus the call to `from_raw_parts` is safe.\n+    unsafe { from_raw_parts(s, 1) }\n+}\n+\n+/// Converts a reference to T into a slice of length 1 (without copying).\n+#[stable(feature = \"from_ref\", since = \"1.28.0\")]\n+pub fn from_mut<T>(s: &mut T) -> &mut [T] {\n+    // SAFETY: a mutable reference is guaranteed to be valid for writes.\n+    // The reference cannot be accessed by another pointer as it is an mutable reference.\n+    // `mem::size_of::<T>()` cannot be larger than `isize::MAX`.\n+    // Thus the call to `from_raw_parts_mut` is safe.\n+    unsafe { from_raw_parts_mut(s, 1) }\n+}"}, {"sha": "8c14651bd826cd4881f545a8d16d9446bf234037", "filename": "library/core/src/slice/sort.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bcd18f977bee4db79d42d54cc7edce19c942b963/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcd18f977bee4db79d42d54cc7edce19c942b963/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs?ref=bcd18f977bee4db79d42d54cc7edce19c942b963", "patch": "@@ -180,7 +180,8 @@ where\n \n /// Sorts `v` using heapsort, which guarantees *O*(*n* \\* log(*n*)) worst-case.\n #[cold]\n-pub fn heapsort<T, F>(v: &mut [T], is_less: &mut F)\n+#[unstable(feature = \"sort_internals\", reason = \"internal to sort module\", issue = \"none\")]\n+pub fn heapsort<T, F>(v: &mut [T], mut is_less: F)\n where\n     F: FnMut(&T, &T) -> bool,\n {"}]}