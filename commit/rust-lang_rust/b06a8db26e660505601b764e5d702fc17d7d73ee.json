{"sha": "b06a8db26e660505601b764e5d702fc17d7d73ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwNmE4ZGIyNmU2NjA1MDU2MDFiNzY0ZTVkNzAyZmMxN2Q3ZDczZWU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-29T08:07:27Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-29T08:09:53Z"}, "message": "audit the relocations code, and clean it up a little", "tree": {"sha": "60a60c4a536abfb4126a134f06593e0058567c35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60a60c4a536abfb4126a134f06593e0058567c35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b06a8db26e660505601b764e5d702fc17d7d73ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b06a8db26e660505601b764e5d702fc17d7d73ee", "html_url": "https://github.com/rust-lang/rust/commit/b06a8db26e660505601b764e5d702fc17d7d73ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b06a8db26e660505601b764e5d702fc17d7d73ee/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "365b90c6373336365e5464e22862ede0831117ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/365b90c6373336365e5464e22862ede0831117ae", "html_url": "https://github.com/rust-lang/rust/commit/365b90c6373336365e5464e22862ede0831117ae"}], "stats": {"total": 68, "additions": 45, "deletions": 23}, "files": [{"sha": "d40dbae09d2cb60f8b27420e38b9453aeb39ec21", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b06a8db26e660505601b764e5d702fc17d7d73ee/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06a8db26e660505601b764e5d702fc17d7d73ee/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=b06a8db26e660505601b764e5d702fc17d7d73ee", "patch": "@@ -496,7 +496,9 @@ pub struct Allocation {\n     /// Note that the bytes of a pointer represent the offset of the pointer\n     pub bytes: Vec<u8>,\n     /// Maps from byte addresses to allocations.\n-    /// Only the first byte of a pointer is inserted into the map.\n+    /// Only the first byte of a pointer is inserted into the map; i.e.,\n+    /// every entry in this map applies to `pointer_size` consecutive bytes starting\n+    /// at the given offset.\n     pub relocations: Relocations,\n     /// Denotes undefined memory. Reading from undefined memory is forbidden in miri\n     pub undef_mask: UndefMask,"}, {"sha": "18e96bf2040bad88085ad403c5fb007c1f8399a4", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 42, "deletions": 22, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b06a8db26e660505601b764e5d702fc17d7d73ee/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06a8db26e660505601b764e5d702fc17d7d73ee/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=b06a8db26e660505601b764e5d702fc17d7d73ee", "patch": "@@ -504,7 +504,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     /// The last argument controls whether we error out when there are undefined\n     /// or pointer bytes.  You should never call this, call `get_bytes` or\n-    /// `get_bytes_unchecked` instead,\n+    /// `get_bytes_with_undef_and_ptr` instead,\n     fn get_bytes_internal(\n         &self,\n         ptr: Pointer,\n@@ -519,9 +519,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n         if check_defined_and_ptr {\n             self.check_defined(ptr, size)?;\n-            if self.relocations(ptr, size)?.len() != 0 {\n-                return err!(ReadPointerAsBytes);\n-            }\n+            self.check_relocations(ptr, size)?;\n+        } else {\n+            // We still don't want relocations on the *edges*\n+            self.check_relocation_edges(ptr, size)?;\n         }\n \n         let alloc = self.get(ptr.alloc_id)?;\n@@ -537,6 +538,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     }\n \n     /// It is the caller's responsibility to handle undefined and pointer bytes.\n+    /// However, this still checks that there are no relocations on the egdes.\n     #[inline]\n     fn get_bytes_with_undef_and_ptr(\n         &self,\n@@ -547,6 +549,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         self.get_bytes_internal(ptr, size, align, false)\n     }\n \n+    /// Just calling this already marks everything as defined and removes relocations,\n+    /// so be sure to actually put data there!\n     fn get_bytes_mut(\n         &mut self,\n         ptr: Pointer,\n@@ -654,11 +658,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n         let src = src.to_ptr()?;\n         let dest = dest.to_ptr()?;\n-        self.check_relocation_edges(src, size)?;\n \n         // first copy the relocations to a temporary buffer, because\n         // `get_bytes_mut` will clear the relocations, which is correct,\n         // since we don't want to keep any relocations at the target.\n+        // (`get_bytes_with_undef_and_ptr` below checks that there are no\n+        // relocations overlapping the edges; those would not be handled correctly).\n         let relocations = {\n             let relocations = self.relocations(src, size)?;\n             let mut new_relocations = Vec::with_capacity(relocations.len() * (length as usize));\n@@ -676,7 +681,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             new_relocations\n         };\n \n-        // This also checks alignment.\n+        // This also checks alignment, and relocation edges on the src.\n         let src_bytes = self.get_bytes_with_undef_and_ptr(src, size, src_align)?.as_ptr();\n         let dest_bytes = self.get_bytes_mut(dest, size * length, dest_align)?.as_mut_ptr();\n \n@@ -710,8 +715,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             }\n         }\n \n+        // copy definedness to the destination\n         self.copy_undef_mask(src, dest, size, length)?;\n-        // copy back the relocations\n+        // copy the relocations to the destination\n         self.get_mut(dest.alloc_id)?.relocations.insert_presorted(relocations);\n \n         Ok(())\n@@ -724,9 +730,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         match alloc.bytes[offset..].iter().position(|&c| c == 0) {\n             Some(size) => {\n                 let p1 = Size::from_bytes((size + 1) as u64);\n-                if self.relocations(ptr, p1)?.len() != 0 {\n-                    return err!(ReadPointerAsBytes);\n-                }\n+                self.check_relocations(ptr, p1)?;\n                 self.check_defined(ptr, p1)?;\n                 Ok(&alloc.bytes[offset..offset + size])\n             }\n@@ -777,9 +781,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         ptr_align: Align,\n         size: Size\n     ) -> EvalResult<'tcx, ScalarMaybeUndef> {\n-        // Make sure we don't read part of a pointer as a pointer\n-        self.check_relocation_edges(ptr, size)?;\n-        // get_bytes_unchecked tests alignment\n+        // get_bytes_unchecked tests alignment and relocation edges\n         let bytes = self.get_bytes_with_undef_and_ptr(\n             ptr, size, ptr_align.min(self.int_align(size))\n         )?;\n@@ -794,9 +796,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         let bits = read_target_uint(self.tcx.data_layout.endian, bytes).unwrap();\n         // See if we got a pointer\n         if size != self.pointer_size() {\n-            if self.relocations(ptr, size)?.len() != 0 {\n-                return err!(ReadPointerAsBytes);\n-            }\n+            // *Now* better make sure that the inside also is free of relocations.\n+            self.check_relocations(ptr, size)?;\n         } else {\n             let alloc = self.get(ptr.alloc_id)?;\n             match alloc.relocations.get(&ptr.offset) {\n@@ -887,16 +888,35 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n /// Relocations\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n+    /// Return all relocations overlapping with the given ptr-offset pair.\n     fn relocations(\n         &self,\n         ptr: Pointer,\n         size: Size,\n     ) -> EvalResult<'tcx, &[(Size, AllocId)]> {\n+        // We have to go back `pointer_size - 1` bytes, as that one would still overlap with\n+        // the beginning of this range.\n         let start = ptr.offset.bytes().saturating_sub(self.pointer_size().bytes() - 1);\n-        let end = ptr.offset + size;\n+        let end = ptr.offset + size; // this does overflow checking\n         Ok(self.get(ptr.alloc_id)?.relocations.range(Size::from_bytes(start)..end))\n     }\n \n+    /// Check that there ar eno relocations overlapping with the given range.\n+    #[inline(always)]\n+    fn check_relocations(&self, ptr: Pointer, size: Size) -> EvalResult<'tcx> {\n+        if self.relocations(ptr, size)?.len() != 0 {\n+            err!(ReadPointerAsBytes)\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n+    /// Remove all relocations inside the given range.\n+    /// If there are relocations overlapping with the edges, they\n+    /// are removed as well *and* the bytes they cover are marked as\n+    /// uninitialized.  This is a somewhat odd \"spooky action at a distance\",\n+    /// but it allows strictly more code to run than if we would just error\n+    /// immediately in that case.\n     fn clear_relocations(&mut self, ptr: Pointer, size: Size) -> EvalResult<'tcx> {\n         // Find the start and end of the given range and its outermost relocations.\n         let (first, last) = {\n@@ -929,12 +949,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n+    /// Error if there are relocations overlapping with the egdes of the\n+    /// given memory range.\n+    #[inline]\n     fn check_relocation_edges(&self, ptr: Pointer, size: Size) -> EvalResult<'tcx> {\n-        let overlapping_start = self.relocations(ptr, Size::ZERO)?.len();\n-        let overlapping_end = self.relocations(ptr.offset(size, self)?, Size::ZERO)?.len();\n-        if overlapping_start + overlapping_end != 0 {\n-            return err!(ReadPointerAsBytes);\n-        }\n+        self.check_relocations(ptr, Size::ZERO)?;\n+        self.check_relocations(ptr.offset(size, self)?, Size::ZERO)?;\n         Ok(())\n     }\n }"}]}