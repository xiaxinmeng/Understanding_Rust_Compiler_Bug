{"sha": "7c2979e26f23739b62fcda7500d4c5eac092c42c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjMjk3OWUyNmYyMzczOWI2MmZjZGE3NTAwZDRjNWVhYzA5MmM0MmM=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-05-07T00:08:41Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-14T00:35:12Z"}, "message": "Starting on support for anonymous objects.  Just syntax so far.", "tree": {"sha": "64bd9f4fb3176e0d352d9770efb009c9eb8d0d27", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64bd9f4fb3176e0d352d9770efb009c9eb8d0d27"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c2979e26f23739b62fcda7500d4c5eac092c42c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c2979e26f23739b62fcda7500d4c5eac092c42c", "html_url": "https://github.com/rust-lang/rust/commit/7c2979e26f23739b62fcda7500d4c5eac092c42c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c2979e26f23739b62fcda7500d4c5eac092c42c/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae784df3ce0c354fde00a6d9a4a50d642bdb3560", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae784df3ce0c354fde00a6d9a4a50d642bdb3560", "html_url": "https://github.com/rust-lang/rust/commit/ae784df3ce0c354fde00a6d9a4a50d642bdb3560"}], "stats": {"total": 96, "additions": 96, "deletions": 0}, "files": [{"sha": "51977b5f7fbfcec4d0b4a475ab76fdfcc70abe4b", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7c2979e26f23739b62fcda7500d4c5eac092c42c/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c2979e26f23739b62fcda7500d4c5eac092c42c/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=7c2979e26f23739b62fcda7500d4c5eac092c42c", "patch": "@@ -296,6 +296,7 @@ tag expr_ {\n     expr_check(@expr, ann);\n     expr_port(ann);\n     expr_chan(@expr, ann);\n+    expr_anon_obj(anon_obj, vec[ty_param], obj_def_ids, ann);\n }\n \n type lit = spanned[lit_];\n@@ -371,6 +372,25 @@ type _obj = rec(vec[obj_field] fields,\n                 vec[@method] methods,\n                 option::t[@method] dtor);\n \n+\n+// Hmm.  An anon_obj might extend an existing object, in which case it'll\n+// probably add fields and methods.\n+type anon_obj = rec(option.t[vec[obj_field]] fields,\n+                    vec[@method] methods,\n+                    option.t[ident] with_obj);\n+\n+tag mod_index_entry {\n+    mie_view_item(@view_item);\n+    mie_item(@item);\n+    mie_tag_variant(@item /* tag item */, uint /* variant index */);\n+}\n+\n+tag native_mod_index_entry {\n+    nmie_view_item(@view_item);\n+    nmie_item(@native_item);\n+}\n+\n+type mod_index = hashmap[ident,mod_index_entry];\n type _mod = rec(vec[@view_item] view_items,\n                 vec[@item] items);\n "}, {"sha": "f395ea16f3d62418a8d23e7ffb2a8d8e0641f562", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7c2979e26f23739b62fcda7500d4c5eac092c42c/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c2979e26f23739b62fcda7500d4c5eac092c42c/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=7c2979e26f23739b62fcda7500d4c5eac092c42c", "patch": "@@ -799,6 +799,56 @@ fn parse_bottom_expr(parser p) -> @ast::expr {\n         }\n \n         ex = ast::expr_rec(fields, base, p.get_ann());\n+    }\n+    // Anonymous object\n+    else if (eat_word(p, \"obj\")) {\n+\n+        // FIXME: Can anonymous objects have ty params?\n+        auto ty_params = parse_ty_params(p);\n+\n+        // Only make people type () if they're actually adding new fields\n+        let option.t[vec[ast.obj_field]] fields = none[vec[ast.obj_field]];\n+        if (p.peek() == token.LPAREN) {\n+            auto pf = parse_obj_field;\n+            hi = p.get_hi_pos();\n+            expect(p, token.LPAREN);\n+            fields = some[vec[ast.obj_field]]\n+                (parse_seq_to_end[ast.obj_field] \n+                 (token.RPAREN,\n+                  some(token.COMMA),\n+                  pf, hi, p));\n+        }\n+\n+        let vec[@ast.method] meths = vec();\n+        let option.t[ast.ident] with_obj = none[ast.ident];\n+\n+        expect(p, token.LBRACE);\n+        while (p.peek() != token.RBRACE) {\n+            alt (p.peek()) {\n+                case (token.WITH) { \n+                    with_obj = some[ast.ident](parse_ident(p));\n+                }\n+                case (_) {\n+                    // fall through\n+                }\n+            }\n+        }\n+        hi = p.get_hi_pos();\n+        expect(p, token.RBRACE);\n+\n+        // fields and methods may be *additional* or *overriding* fields\n+        // and methods if there's a with_obj, or they may be the *only*\n+        // fields and methods if there's no with_obj.\n+\n+        // We don't need to pull \".node\" out of fields because it's not a\n+        // \"spanned\".\n+        let ast.anon_obj ob = rec(fields=fields,\n+                                  methods=meths,\n+                                  with_obj=with_obj);\n+\n+        auto odid = rec(ty=p.next_def_id(), ctor=p.next_def_id());\n+\n+        ex = ast.expr_anon_obj(ob, ty_params, odid, ast.ann_none);\n     } else if (eat_word(p, \"bind\")) {\n         auto e = parse_expr_res(p, RESTRICT_NO_CALL_EXPRS);\n         fn parse_expr_opt(parser p) -> option::t[@ast::expr] {"}, {"sha": "bf68ddd1e428939d6325d334a667a8a4da7e6efe", "filename": "src/test/run-pass/method-overriding.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7c2979e26f23739b62fcda7500d4c5eac092c42c/src%2Ftest%2Frun-pass%2Fmethod-overriding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c2979e26f23739b62fcda7500d4c5eac092c42c/src%2Ftest%2Frun-pass%2Fmethod-overriding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-overriding.rs?ref=7c2979e26f23739b62fcda7500d4c5eac092c42c", "patch": "@@ -0,0 +1,26 @@\n+// xfail-boot\n+// xfail-stage0\n+use std;\n+import std._vec.len;\n+fn main() {\n+\n+    obj a() {\n+        fn foo() -> int {\n+            ret 2;\n+        }\n+        fn bar() -> int {\n+            ret self.foo();\n+        }\n+    }\n+\n+    auto my_a = a();\n+\n+    // Step 1 is to add support for this \"with\" syntax\n+    auto my_b = obj { \n+        fn baz() -> int { \n+            ret self.foo(); \n+        } \n+        with my_a \n+    };\n+    \n+}"}]}