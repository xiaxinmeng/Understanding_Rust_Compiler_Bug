{"sha": "cae91d7c8c21aa860bda29c62207a6726837952b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhZTkxZDdjOGMyMWFhODYwYmRhMjljNjIyMDdhNjcyNjgzNzk1MmI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-05-17T18:57:07Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-05-24T16:00:39Z"}, "message": "std: Stabilize APIs for the 1.10 release\n\nThis commit applies the FCP decisions made by the libs team for the 1.10 cycle,\nincluding both new stabilizations and deprecations. Specifically, the list of\nAPIs is:\n\nStabilized:\n\n* `os::windows::fs::OpenOptionsExt::access_mode`\n* `os::windows::fs::OpenOptionsExt::share_mode`\n* `os::windows::fs::OpenOptionsExt::custom_flags`\n* `os::windows::fs::OpenOptionsExt::attributes`\n* `os::windows::fs::OpenOptionsExt::security_qos_flags`\n* `os::unix::fs::OpenOptionsExt::custom_flags`\n* `sync::Weak::new`\n* `Default for sync::Weak`\n* `panic::set_hook`\n* `panic::take_hook`\n* `panic::PanicInfo`\n* `panic::PanicInfo::payload`\n* `panic::PanicInfo::location`\n* `panic::Location`\n* `panic::Location::file`\n* `panic::Location::line`\n* `ffi::CStr::from_bytes_with_nul`\n* `ffi::CStr::from_bytes_with_nul_unchecked`\n* `ffi::FromBytesWithNulError`\n* `fs::Metadata::modified`\n* `fs::Metadata::accessed`\n* `fs::Metadata::created`\n* `sync::atomic::Atomic{Usize,Isize,Bool,Ptr}::compare_exchange`\n* `sync::atomic::Atomic{Usize,Isize,Bool,Ptr}::compare_exchange_weak`\n* `collections::{btree,hash}_map::{Occupied,Vacant,}Entry::key`\n* `os::unix::net::{UnixStream, UnixListener, UnixDatagram, SocketAddr}`\n* `SocketAddr::is_unnamed`\n* `SocketAddr::as_pathname`\n* `UnixStream::connect`\n* `UnixStream::pair`\n* `UnixStream::try_clone`\n* `UnixStream::local_addr`\n* `UnixStream::peer_addr`\n* `UnixStream::set_read_timeout`\n* `UnixStream::set_write_timeout`\n* `UnixStream::read_timeout`\n* `UnixStream::write_Timeout`\n* `UnixStream::set_nonblocking`\n* `UnixStream::take_error`\n* `UnixStream::shutdown`\n* Read/Write/RawFd impls for `UnixStream`\n* `UnixListener::bind`\n* `UnixListener::accept`\n* `UnixListener::try_clone`\n* `UnixListener::local_addr`\n* `UnixListener::set_nonblocking`\n* `UnixListener::take_error`\n* `UnixListener::incoming`\n* RawFd impls for `UnixListener`\n* `UnixDatagram::bind`\n* `UnixDatagram::unbound`\n* `UnixDatagram::pair`\n* `UnixDatagram::connect`\n* `UnixDatagram::try_clone`\n* `UnixDatagram::local_addr`\n* `UnixDatagram::peer_addr`\n* `UnixDatagram::recv_from`\n* `UnixDatagram::recv`\n* `UnixDatagram::send_to`\n* `UnixDatagram::send`\n* `UnixDatagram::set_read_timeout`\n* `UnixDatagram::set_write_timeout`\n* `UnixDatagram::read_timeout`\n* `UnixDatagram::write_timeout`\n* `UnixDatagram::set_nonblocking`\n* `UnixDatagram::take_error`\n* `UnixDatagram::shutdown`\n* RawFd impls for `UnixDatagram`\n* `{BTree,Hash}Map::values_mut`\n* `<[_]>::binary_search_by_key`\n\nDeprecated:\n\n* `StaticCondvar` - this, and all other static synchronization primitives\n                    below, are usable today through the lazy-static crate on\n                    stable Rust today. Additionally, we'd like the non-static\n                    versions to be directly usable in a static context one day,\n                    so they're unlikely to be the final forms of the APIs in any\n                    case.\n* `CONDVAR_INIT`\n* `StaticMutex`\n* `MUTEX_INIT`\n* `StaticRwLock`\n* `RWLOCK_INIT`\n* `iter::Peekable::is_empty`\n\nCloses #27717\nCloses #27720\ncc #27784 (but encode methods still exist)\nCloses #30014\nCloses #30425\nCloses #30449\nCloses #31190\nCloses #31399\nCloses #31767\nCloses #32111\nCloses #32281\nCloses #32312\nCloses #32551\nCloses #33018", "tree": {"sha": "3c1a8d50e4fded7eaa1830188b013d3d5f998100", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c1a8d50e4fded7eaa1830188b013d3d5f998100"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cae91d7c8c21aa860bda29c62207a6726837952b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cae91d7c8c21aa860bda29c62207a6726837952b", "html_url": "https://github.com/rust-lang/rust/commit/cae91d7c8c21aa860bda29c62207a6726837952b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cae91d7c8c21aa860bda29c62207a6726837952b/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30422de32d905dca54e503ec7990c4d7d11334da", "url": "https://api.github.com/repos/rust-lang/rust/commits/30422de32d905dca54e503ec7990c4d7d11334da", "html_url": "https://github.com/rust-lang/rust/commit/30422de32d905dca54e503ec7990c4d7d11334da"}], "stats": {"total": 1061, "additions": 567, "deletions": 494}, "files": [{"sha": "d0a51e320cc2f8508a36b9c7006dafd3916207aa", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -592,6 +592,31 @@ impl<T: ?Sized> Drop for Arc<T> {\n     }\n }\n \n+impl<T> Weak<T> {\n+    /// Constructs a new `Weak<T>` without an accompanying instance of T.\n+    ///\n+    /// This allocates memory for T, but does not initialize it. Calling\n+    /// Weak<T>::upgrade() on the return value always gives None.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Weak;\n+    ///\n+    /// let empty: Weak<i64> = Weak::new();\n+    /// ```\n+    #[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\n+    pub fn new() -> Weak<T> {\n+        unsafe {\n+            Weak { ptr: Shared::new(Box::into_raw(box ArcInner {\n+                strong: atomic::AtomicUsize::new(0),\n+                weak: atomic::AtomicUsize::new(1),\n+                data: uninitialized(),\n+            }))}\n+        }\n+    }\n+}\n+\n impl<T: ?Sized> Weak<T> {\n     /// Upgrades a weak reference to a strong reference.\n     ///\n@@ -682,6 +707,13 @@ impl<T: ?Sized> Clone for Weak<T> {\n     }\n }\n \n+#[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\n+impl<T> Default for Weak<T> {\n+    fn default() -> Weak<T> {\n+        Weak::new()\n+    }\n+}\n+\n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n impl<T: ?Sized> Drop for Weak<T> {\n     /// Drops the `Weak<T>`.\n@@ -907,35 +939,6 @@ impl<T> From<T> for Arc<T> {\n     }\n }\n \n-impl<T> Weak<T> {\n-    /// Constructs a new `Weak<T>` without an accompanying instance of T.\n-    ///\n-    /// This allocates memory for T, but does not initialize it. Calling\n-    /// Weak<T>::upgrade() on the return value always gives None.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(downgraded_weak)]\n-    ///\n-    /// use std::sync::Weak;\n-    ///\n-    /// let empty: Weak<i64> = Weak::new();\n-    /// ```\n-    #[unstable(feature = \"downgraded_weak\",\n-               reason = \"recently added\",\n-               issue = \"30425\")]\n-    pub fn new() -> Weak<T> {\n-        unsafe {\n-            Weak { ptr: Shared::new(Box::into_raw(box ArcInner {\n-                strong: atomic::AtomicUsize::new(0),\n-                weak: atomic::AtomicUsize::new(1),\n-                data: uninitialized(),\n-            }))}\n-        }\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use std::clone::Clone;"}, {"sha": "0293d5402c4c983f08f03cc5207b0a51b5f5de1d", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -90,7 +90,6 @@\n #![feature(unique)]\n #![feature(unsafe_no_drop_flag, filling_drop)]\n #![feature(unsize)]\n-#![feature(extended_compare_and_swap)]\n \n #![cfg_attr(not(test), feature(raw, fn_traits, placement_new_protocol))]\n #![cfg_attr(test, feature(test, box_heap))]"}, {"sha": "b92f5af05e31592b13d2f4b284d5997d58c3d450", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 31, "deletions": 28, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -720,6 +720,33 @@ impl<T: ?Sized> !marker::Sync for Weak<T> {}\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Weak<U>> for Weak<T> {}\n \n+impl<T> Weak<T> {\n+    /// Constructs a new `Weak<T>` without an accompanying instance of T.\n+    ///\n+    /// This allocates memory for T, but does not initialize it. Calling\n+    /// Weak<T>::upgrade() on the return value always gives None.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Weak;\n+    ///\n+    /// let empty: Weak<i64> = Weak::new();\n+    /// ```\n+    #[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\n+    pub fn new() -> Weak<T> {\n+        unsafe {\n+            Weak {\n+                ptr: Shared::new(Box::into_raw(box RcBox {\n+                    strong: Cell::new(0),\n+                    weak: Cell::new(1),\n+                    value: uninitialized(),\n+                })),\n+            }\n+        }\n+    }\n+}\n+\n impl<T: ?Sized> Weak<T> {\n     /// Upgrades a weak reference to a strong reference.\n     ///\n@@ -823,34 +850,10 @@ impl<T: ?Sized + fmt::Debug> fmt::Debug for Weak<T> {\n     }\n }\n \n-impl<T> Weak<T> {\n-    /// Constructs a new `Weak<T>` without an accompanying instance of T.\n-    ///\n-    /// This allocates memory for T, but does not initialize it. Calling\n-    /// Weak<T>::upgrade() on the return value always gives None.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(downgraded_weak)]\n-    ///\n-    /// use std::rc::Weak;\n-    ///\n-    /// let empty: Weak<i64> = Weak::new();\n-    /// ```\n-    #[unstable(feature = \"downgraded_weak\",\n-               reason = \"recently added\",\n-               issue=\"30425\")]\n-    pub fn new() -> Weak<T> {\n-        unsafe {\n-            Weak {\n-                ptr: Shared::new(Box::into_raw(box RcBox {\n-                    strong: Cell::new(0),\n-                    weak: Cell::new(1),\n-                    value: uninitialized(),\n-                })),\n-            }\n-        }\n+#[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\n+impl<T> Default for Weak<T> {\n+    fn default() -> Weak<T> {\n+        Weak::new()\n     }\n }\n "}, {"sha": "ec2f4a9f7f0b82208b230a687c95cd28e8c51a7e", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -286,7 +286,7 @@ pub struct Values<'a, K: 'a, V: 'a> {\n }\n \n /// A mutable iterator over a BTreeMap's values.\n-#[unstable(feature = \"map_values_mut\", reason = \"recently added\", issue = \"32551\")]\n+#[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n pub struct ValuesMut<'a, K: 'a, V: 'a> {\n     inner: IterMut<'a, K, V>,\n }\n@@ -1144,7 +1144,7 @@ impl<'a, K, V> Iterator for Range<'a, K, V> {\n     }\n }\n \n-#[unstable(feature = \"map_values_mut\", reason = \"recently added\", issue = \"32551\")]\n+#[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n impl<'a, K, V> Iterator for ValuesMut<'a, K, V> {\n     type Item = &'a mut V;\n \n@@ -1157,14 +1157,14 @@ impl<'a, K, V> Iterator for ValuesMut<'a, K, V> {\n     }\n }\n \n-#[unstable(feature = \"map_values_mut\", reason = \"recently added\", issue = \"32551\")]\n+#[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n impl<'a, K, V> DoubleEndedIterator for ValuesMut<'a, K, V> {\n     fn next_back(&mut self) -> Option<&'a mut V> {\n         self.inner.next_back().map(|(_, v)| v)\n     }\n }\n \n-#[unstable(feature = \"map_values_mut\", reason = \"recently added\", issue = \"32551\")]\n+#[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n impl<'a, K, V> ExactSizeIterator for ValuesMut<'a, K, V> {\n     fn len(&self) -> usize {\n         self.inner.len()\n@@ -1575,7 +1575,6 @@ impl<K, V> BTreeMap<K, V> {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// # #![feature(map_values_mut)]\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut a = BTreeMap::new();\n@@ -1590,8 +1589,8 @@ impl<K, V> BTreeMap<K, V> {\n     /// assert_eq!(values, [String::from(\"hello!\"),\n     ///                     String::from(\"goodbye!\")]);\n     /// ```\n-    #[unstable(feature = \"map_values_mut\", reason = \"recently added\", issue = \"32551\")]\n-    pub fn values_mut<'a>(&'a mut self) -> ValuesMut<'a, K, V> {\n+    #[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n+    pub fn values_mut(&mut self) -> ValuesMut<K, V> {\n         ValuesMut { inner: self.iter_mut() }\n     }\n \n@@ -1656,7 +1655,7 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n     }\n \n     /// Returns a reference to this entry's key.\n-    #[unstable(feature = \"map_entry_keys\", issue = \"32281\")]\n+    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n     pub fn key(&self) -> &K {\n         match *self {\n             Occupied(ref entry) => entry.key(),\n@@ -1668,7 +1667,7 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n     /// Gets a reference to the key that would be used when inserting a value\n     /// through the VacantEntry.\n-    #[unstable(feature = \"map_entry_keys\", issue = \"32281\")]\n+    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n     pub fn key(&self) -> &K {\n         &self.key\n     }\n@@ -1718,7 +1717,7 @@ impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n \n impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n     /// Gets a reference to the key in the entry.\n-    #[unstable(feature = \"map_entry_keys\", issue = \"32281\")]\n+    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n     pub fn key(&self) -> &K {\n         self.handle.reborrow().into_kv().0\n     }"}, {"sha": "6ab66fc217b46247f57dc548f35b394e63b4f312", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -27,7 +27,6 @@\n        test(no_crate_inject, attr(allow(unused_variables), deny(warnings))))]\n \n #![cfg_attr(test, allow(deprecated))] // rand\n-#![cfg_attr(not(test), feature(slice_binary_search_by_key))] // impl [T]\n #![cfg_attr(not(stage0), deny(warnings))]\n \n #![feature(alloc)]"}, {"sha": "2857a670e80fd6ba43313a4fa1c718cd8798a76a", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -759,7 +759,6 @@ impl<T> [T] {\n     /// fourth could match any position in `[1,4]`.\n     ///\n     /// ```rust\n-    /// #![feature(slice_binary_search_by_key)]\n     /// let s = [(0, 0), (2, 1), (4, 1), (5, 1), (3, 1),\n     ///          (1, 2), (2, 3), (4, 5), (5, 8), (3, 13),\n     ///          (1, 21), (2, 34), (4, 55)];\n@@ -770,7 +769,7 @@ impl<T> [T] {\n     /// let r = s.binary_search_by_key(&1, |&(a,b)| b);\n     /// assert!(match r { Ok(1...4) => true, _ => false, });\n     /// ```\n-    #[unstable(feature = \"slice_binary_search_by_key\", reason = \"recently added\", issue = \"33018\")]\n+    #[stable(feature = \"slice_binary_search_by_key\", since = \"1.10.0\")]\n     #[inline]\n     pub fn binary_search_by_key<B, F>(&self, b: &B, f: F) -> Result<usize, usize>\n         where F: FnMut(&T) -> B,"}, {"sha": "bae21f1bd9b8fe41454d2bee5ce5758ede1a0ecc", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -22,8 +22,6 @@\n #![feature(enumset)]\n #![feature(iter_arith)]\n #![feature(linked_list_contains)]\n-#![feature(map_entry_keys)]\n-#![feature(map_values_mut)]\n #![feature(pattern)]\n #![feature(rand)]\n #![feature(step_by)]"}, {"sha": "550cee1d5a9c6a1f1bea029dab2f8da5642ef31a", "filename": "src/libcore/char.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -15,11 +15,9 @@\n #![allow(non_snake_case)]\n #![stable(feature = \"core_char\", since = \"1.2.0\")]\n \n-use iter::Iterator;\n+use prelude::v1::*;\n+\n use mem::transmute;\n-use option::Option::{None, Some};\n-use option::Option;\n-use slice::SliceExt;\n \n // UTF-8 ranges and tags for encoding characters\n const TAG_CONT: u8    = 0b1000_0000;"}, {"sha": "f964527b4b41f6b4773abb2ac7181c43cc5491d5", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -1125,6 +1125,7 @@ impl<I: Iterator> Peekable<I> {\n     /// ```\n     #[unstable(feature = \"peekable_is_empty\", issue = \"32111\")]\n     #[inline]\n+    #[rustc_deprecated(since = \"1.10.0\", reason = \"replaced by .peek().is_none()\")]\n     pub fn is_empty(&mut self) -> bool {\n         self.peek().is_none()\n     }"}, {"sha": "0a2ccb37b550703ed79bb098d6c5c5e37cb03eca", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -106,6 +106,10 @@ pub trait SliceExt {\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn binary_search_by<F>(&self, f: F) -> Result<usize, usize>\n         where F: FnMut(&Self::Item) -> Ordering;\n+    #[stable(feature = \"slice_binary_search_by_key\", since = \"1.10.0\")]\n+    fn binary_search_by_key<B, F>(&self, b: &B, f: F) -> Result<usize, usize>\n+        where F: FnMut(&Self::Item) -> B,\n+              B: Ord;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn len(&self) -> usize;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n@@ -157,11 +161,6 @@ pub trait SliceExt {\n     fn clone_from_slice(&mut self, src: &[Self::Item]) where Self::Item: Clone;\n     #[stable(feature = \"copy_from_slice\", since = \"1.9.0\")]\n     fn copy_from_slice(&mut self, src: &[Self::Item]) where Self::Item: Copy;\n-\n-    #[unstable(feature = \"slice_binary_search_by_key\", reason = \"recently added\", issue = \"33018\")]\n-    fn binary_search_by_key<B, F>(&self, b: &B, f: F) -> Result<usize, usize>\n-        where F: FnMut(&Self::Item) -> B,\n-              B: Ord;\n }\n \n // Use macros to be generic over const/mut"}, {"sha": "e1c9b8a2ca0b6870d537dbf3da733b9511740935", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -294,7 +294,6 @@ impl AtomicBool {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(extended_compare_and_swap)]\n     /// use std::sync::atomic::{AtomicBool, Ordering};\n     ///\n     /// let some_bool = AtomicBool::new(true);\n@@ -313,7 +312,7 @@ impl AtomicBool {\n     /// assert_eq!(some_bool.load(Ordering::Relaxed), false);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"extended_compare_and_swap\", reason = \"recently added\", issue = \"31767\")]\n+    #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n     pub fn compare_exchange(&self,\n                             current: bool,\n                             new: bool,\n@@ -342,7 +341,6 @@ impl AtomicBool {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(extended_compare_and_swap)]\n     /// use std::sync::atomic::{AtomicBool, Ordering};\n     ///\n     /// let val = AtomicBool::new(false);\n@@ -357,7 +355,7 @@ impl AtomicBool {\n     /// }\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"extended_compare_and_swap\", reason = \"recently added\", issue = \"31767\")]\n+    #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n     pub fn compare_exchange_weak(&self,\n                                  current: bool,\n                                  new: bool,\n@@ -640,7 +638,6 @@ impl<T> AtomicPtr<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(extended_compare_and_swap)]\n     /// use std::sync::atomic::{AtomicPtr, Ordering};\n     ///\n     /// let ptr = &mut 5;\n@@ -653,7 +650,7 @@ impl<T> AtomicPtr<T> {\n     ///                                       Ordering::SeqCst, Ordering::Relaxed);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"extended_compare_and_swap\", reason = \"recently added\", issue = \"31767\")]\n+    #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n     pub fn compare_exchange(&self,\n                             current: *mut T,\n                             new: *mut T,\n@@ -688,7 +685,6 @@ impl<T> AtomicPtr<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(extended_compare_and_swap)]\n     /// use std::sync::atomic::{AtomicPtr, Ordering};\n     ///\n     /// let some_ptr = AtomicPtr::new(&mut 5);\n@@ -703,7 +699,7 @@ impl<T> AtomicPtr<T> {\n     /// }\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"extended_compare_and_swap\", reason = \"recently added\", issue = \"31767\")]\n+    #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n     pub fn compare_exchange_weak(&self,\n                                  current: *mut T,\n                                  new: *mut T,\n@@ -896,7 +892,6 @@ macro_rules! atomic_int {\n             /// # Examples\n             ///\n             /// ```\n-            /// # #![feature(extended_compare_and_swap)]\n             /// use std::sync::atomic::{AtomicIsize, Ordering};\n             ///\n             /// let some_isize = AtomicIsize::new(5);\n@@ -940,7 +935,6 @@ macro_rules! atomic_int {\n             /// # Examples\n             ///\n             /// ```\n-            /// # #![feature(extended_compare_and_swap)]\n             /// use std::sync::atomic::{AtomicIsize, Ordering};\n             ///\n             /// let val = AtomicIsize::new(4);\n@@ -1110,14 +1104,14 @@ atomic_int! {\n #[cfg(any(stage0, target_has_atomic = \"ptr\"))]\n atomic_int!{\n     stable(feature = \"rust1\", since = \"1.0.0\"),\n-    unstable(feature = \"extended_compare_and_swap\", reason = \"recently added\", issue = \"31767\"),\n+    stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\"),\n     stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n     isize AtomicIsize ATOMIC_ISIZE_INIT\n }\n #[cfg(any(stage0, target_has_atomic = \"ptr\"))]\n atomic_int!{\n     stable(feature = \"rust1\", since = \"1.0.0\"),\n-    unstable(feature = \"extended_compare_and_swap\", reason = \"recently added\", issue = \"31767\"),\n+    stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\"),\n     stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n     usize AtomicUsize ATOMIC_USIZE_INIT\n }"}, {"sha": "54fca291e5ec2c464e8a8896c257d422c3eea12a", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -902,15 +902,6 @@ fn test_range_step() {\n     assert_eq!((isize::MIN..isize::MAX).step_by(1).size_hint(), (usize::MAX, Some(usize::MAX)));\n }\n \n-#[test]\n-fn test_peekable_is_empty() {\n-    let a = [1];\n-    let mut it = a.iter().peekable();\n-    assert!( !it.is_empty() );\n-    it.next();\n-    assert!( it.is_empty() );\n-}\n-\n #[test]\n fn test_repeat() {\n     let mut it = repeat(42);"}, {"sha": "88d73df937f7e26d28ce5810d177421b77274a9a", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -24,7 +24,6 @@\n #![feature(iter_arith)]\n #![feature(libc)]\n #![feature(nonzero)]\n-#![feature(peekable_is_empty)]\n #![feature(rand)]\n #![feature(raw)]\n #![feature(slice_patterns)]"}, {"sha": "a71f6efe54ebcaa5b6afe194e90d02ce521b26f6", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 15, "deletions": 35, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -170,20 +170,16 @@\n #![deny(missing_docs)]\n #![cfg_attr(not(stage0), deny(warnings))]\n \n-#![feature(box_syntax)]\n-#![feature(const_fn)]\n #![feature(staged_api)]\n-#![feature(static_mutex)]\n \n use std::cell::RefCell;\n use std::fmt;\n use std::io::{self, Stderr};\n use std::io::prelude::*;\n use std::mem;\n use std::env;\n-use std::ptr;\n use std::slice;\n-use std::sync::{Once, StaticMutex};\n+use std::sync::{Once, Mutex, ONCE_INIT};\n \n use directive::LOG_LEVEL_NAMES;\n \n@@ -199,18 +195,13 @@ pub const MAX_LOG_LEVEL: u32 = 255;\n /// The default logging level of a crate if no other is specified.\n const DEFAULT_LOG_LEVEL: u32 = 1;\n \n-static LOCK: StaticMutex = StaticMutex::new();\n+static mut LOCK: *mut Mutex<(Vec<directive::LogDirective>, Option<String>)> = 0 as *mut _;\n \n /// An unsafe constant that is the maximum logging level of any module\n /// specified. This is the first line of defense to determining whether a\n /// logging statement should be run.\n static mut LOG_LEVEL: u32 = MAX_LOG_LEVEL;\n \n-static mut DIRECTIVES: *mut Vec<directive::LogDirective> = ptr::null_mut();\n-\n-/// Optional filter.\n-static mut FILTER: *mut String = ptr::null_mut();\n-\n /// Debug log level\n pub const DEBUG: u32 = 4;\n /// Info log level\n@@ -287,25 +278,21 @@ pub fn log(level: u32, loc: &'static LogLocation, args: fmt::Arguments) {\n     // Test the literal string from args against the current filter, if there\n     // is one.\n     unsafe {\n-        let _g = LOCK.lock();\n-        match FILTER as usize {\n-            0 => {}\n-            n => {\n-                let filter = mem::transmute::<_, &String>(n);\n-                if !args.to_string().contains(filter) {\n-                    return;\n-                }\n+        let filter = (*LOCK).lock().unwrap();\n+        if let Some(ref filter) = filter.1 {\n+            if !args.to_string().contains(filter) {\n+                return;\n             }\n         }\n     }\n \n     // Completely remove the local logger from TLS in case anyone attempts to\n     // frob the slot while we're doing the logging. This will destroy any logger\n     // set during logging.\n-    let mut logger: Box<Logger + Send> = LOCAL_LOGGER.with(|s| s.borrow_mut().take())\n-                                                     .unwrap_or_else(|| {\n-                                                         box DefaultLogger { handle: io::stderr() }\n-                                                     });\n+    let logger = LOCAL_LOGGER.with(|s| s.borrow_mut().take());\n+    let mut logger = logger.unwrap_or_else(|| {\n+        Box::new(DefaultLogger { handle: io::stderr() })\n+    });\n     logger.log(&LogRecord {\n         level: LogLevel(level),\n         args: args,\n@@ -363,7 +350,7 @@ pub struct LogLocation {\n /// module's log statement should be emitted or not.\n #[doc(hidden)]\n pub fn mod_enabled(level: u32, module: &str) -> bool {\n-    static INIT: Once = Once::new();\n+    static INIT: Once = ONCE_INIT;\n     INIT.call_once(init);\n \n     // It's possible for many threads are in this function, only one of them\n@@ -378,10 +365,9 @@ pub fn mod_enabled(level: u32, module: &str) -> bool {\n     // This assertion should never get tripped unless we're in an at_exit\n     // handler after logging has been torn down and a logging attempt was made.\n \n-    let _g = LOCK.lock();\n     unsafe {\n-        assert!(DIRECTIVES as usize != 0);\n-        enabled(level, module, (*DIRECTIVES).iter())\n+        let directives = (*LOCK).lock().unwrap();\n+        enabled(level, module, directives.0.iter())\n     }\n }\n \n@@ -422,14 +408,8 @@ fn init() {\n     unsafe {\n         LOG_LEVEL = max_level;\n \n-        assert!(FILTER.is_null());\n-        match filter {\n-            Some(f) => FILTER = Box::into_raw(box f),\n-            None => {}\n-        }\n-\n-        assert!(DIRECTIVES.is_null());\n-        DIRECTIVES = Box::into_raw(box directives);\n+        assert!(LOCK.is_null());\n+        LOCK = Box::into_raw(Box::new(Mutex::new((directives, filter))));\n     }\n }\n "}, {"sha": "38e60060925e6f59c4b5df25317b59526e10cbde", "filename": "src/librustc_back/dynamic_lib.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibrustc_back%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibrustc_back%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fdynamic_lib.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -189,12 +189,16 @@ mod dl {\n     pub fn check_for_errors_in<T, F>(f: F) -> Result<T, String> where\n         F: FnOnce() -> T,\n     {\n-        use std::sync::StaticMutex;\n-        static LOCK: StaticMutex = StaticMutex::new();\n+        use std::sync::{Mutex, Once, ONCE_INIT};\n+        static INIT: Once = ONCE_INIT;\n+        static mut LOCK: *mut Mutex<()> = 0 as *mut _;\n         unsafe {\n+            INIT.call_once(|| {\n+                LOCK = Box::into_raw(Box::new(Mutex::new(())));\n+            });\n             // dlerror isn't thread safe, so we need to lock around this entire\n             // sequence\n-            let _guard = LOCK.lock();\n+            let _guard = (*LOCK).lock();\n             let _old_error = libc::dlerror();\n \n             let result = f();"}, {"sha": "6a7bc51d15a42b8886e91e331ddb4458aa5d066d", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -38,7 +38,6 @@\n #![feature(staged_api)]\n #![feature(step_by)]\n #![feature(question_mark)]\n-#![cfg_attr(unix, feature(static_mutex))]\n #![cfg_attr(test, feature(test, rand))]\n \n extern crate syntax;"}, {"sha": "4d36fea9fc5aa8ca72b0eeea1ea803b4cc26b99a", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -864,7 +864,6 @@ impl<K, V, S> HashMap<K, V, S>\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(map_values_mut)]\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map = HashMap::new();\n@@ -881,8 +880,8 @@ impl<K, V, S> HashMap<K, V, S>\n     ///     print!(\"{}\", val);\n     /// }\n     /// ```\n-    #[unstable(feature = \"map_values_mut\", reason = \"recently added\", issue = \"32551\")]\n-    pub fn values_mut<'a>(&'a mut self) -> ValuesMut<K, V> {\n+    #[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n+    pub fn values_mut(&mut self) -> ValuesMut<K, V> {\n         ValuesMut { inner: self.iter_mut() }\n     }\n \n@@ -1288,7 +1287,7 @@ pub struct Drain<'a, K: 'a, V: 'a> {\n }\n \n /// Mutable HashMap values iterator.\n-#[unstable(feature = \"map_values_mut\", reason = \"recently added\", issue = \"32551\")]\n+#[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n pub struct ValuesMut<'a, K: 'a, V: 'a> {\n     inner: IterMut<'a, K, V>\n }\n@@ -1491,14 +1490,14 @@ impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {\n     #[inline] fn len(&self) -> usize { self.inner.len() }\n }\n \n-#[unstable(feature = \"map_values_mut\", reason = \"recently added\", issue = \"32551\")]\n+#[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n impl<'a, K, V> Iterator for ValuesMut<'a, K, V> {\n     type Item = &'a mut V;\n \n     #[inline] fn next(&mut self) -> Option<(&'a mut V)> { self.inner.next().map(|(_, v)| v) }\n     #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n-#[unstable(feature = \"map_values_mut\", reason = \"recently added\", issue = \"32551\")]\n+#[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n impl<'a, K, V> ExactSizeIterator for ValuesMut<'a, K, V> {\n     #[inline] fn len(&self) -> usize { self.inner.len() }\n }\n@@ -1537,7 +1536,7 @@ impl<'a, K, V> Entry<'a, K, V> {\n     }\n \n     /// Returns a reference to this entry's key.\n-    #[unstable(feature = \"map_entry_keys\", issue = \"32281\")]\n+    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n     pub fn key(&self) -> &K {\n         match *self {\n             Occupied(ref entry) => entry.key(),\n@@ -1548,7 +1547,7 @@ impl<'a, K, V> Entry<'a, K, V> {\n \n impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// Gets a reference to the key in the entry.\n-    #[unstable(feature = \"map_entry_keys\", issue = \"32281\")]\n+    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n     pub fn key(&self) -> &K {\n         self.elem.read().0\n     }\n@@ -1596,7 +1595,7 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n     /// Gets a reference to the key that would be used when inserting a value\n     /// through the VacantEntry.\n-    #[unstable(feature = \"map_entry_keys\", issue = \"32281\")]\n+    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n     pub fn key(&self) -> &K {\n         &self.key\n     }"}, {"sha": "2bc7585f5fba913ef113f6fa9d5b390c317e54c8", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -159,6 +159,12 @@ pub struct CStr {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct NulError(usize, Vec<u8>);\n \n+/// An error returned from `CStr::from_bytes_with_nul` to indicate that a nul\n+/// byte was found too early in the slice provided or one wasn't found at all.\n+#[derive(Clone, PartialEq, Debug)]\n+#[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n+pub struct FromBytesWithNulError { _a: () }\n+\n /// An error returned from `CString::into_string` to indicate that a UTF-8 error\n /// was encountered during the conversion.\n #[derive(Clone, PartialEq, Debug)]\n@@ -461,20 +467,18 @@ impl CStr {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(cstr_from_bytes)]\n     /// use std::ffi::CStr;\n     ///\n-    /// # fn main() {\n     /// let cstr = CStr::from_bytes_with_nul(b\"hello\\0\");\n-    /// assert!(cstr.is_some());\n-    /// # }\n+    /// assert!(cstr.is_ok());\n     /// ```\n-    #[unstable(feature = \"cstr_from_bytes\", reason = \"recently added\", issue = \"31190\")]\n-    pub fn from_bytes_with_nul(bytes: &[u8]) -> Option<&CStr> {\n+    #[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n+    pub fn from_bytes_with_nul(bytes: &[u8])\n+                               -> Result<&CStr, FromBytesWithNulError> {\n         if bytes.is_empty() || memchr::memchr(0, &bytes) != Some(bytes.len() - 1) {\n-            None\n+            Err(FromBytesWithNulError { _a: () })\n         } else {\n-            Some(unsafe { Self::from_bytes_with_nul_unchecked(bytes) })\n+            Ok(unsafe { Self::from_bytes_with_nul_unchecked(bytes) })\n         }\n     }\n \n@@ -487,18 +491,15 @@ impl CStr {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(cstr_from_bytes)]\n     /// use std::ffi::{CStr, CString};\n     ///\n-    /// # fn main() {\n     /// unsafe {\n     ///     let cstring = CString::new(\"hello\").unwrap();\n     ///     let cstr = CStr::from_bytes_with_nul_unchecked(cstring.to_bytes_with_nul());\n     ///     assert_eq!(cstr, &*cstring);\n     /// }\n-    /// # }\n     /// ```\n-    #[unstable(feature = \"cstr_from_bytes\", reason = \"recently added\", issue = \"31190\")]\n+    #[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n     pub unsafe fn from_bytes_with_nul_unchecked(bytes: &[u8]) -> &CStr {\n         mem::transmute(bytes)\n     }\n@@ -742,26 +743,28 @@ mod tests {\n     fn from_bytes_with_nul() {\n         let data = b\"123\\0\";\n         let cstr = CStr::from_bytes_with_nul(data);\n-        assert_eq!(cstr.map(CStr::to_bytes), Some(&b\"123\"[..]));\n-        assert_eq!(cstr.map(CStr::to_bytes_with_nul), Some(&b\"123\\0\"[..]));\n+        assert_eq!(cstr.map(CStr::to_bytes), Ok(&b\"123\"[..]));\n+        let cstr = CStr::from_bytes_with_nul(data);\n+        assert_eq!(cstr.map(CStr::to_bytes_with_nul), Ok(&b\"123\\0\"[..]));\n \n         unsafe {\n+            let cstr = CStr::from_bytes_with_nul(data);\n             let cstr_unchecked = CStr::from_bytes_with_nul_unchecked(data);\n-            assert_eq!(cstr, Some(cstr_unchecked));\n+            assert_eq!(cstr, Ok(cstr_unchecked));\n         }\n     }\n \n     #[test]\n     fn from_bytes_with_nul_unterminated() {\n         let data = b\"123\";\n         let cstr = CStr::from_bytes_with_nul(data);\n-        assert!(cstr.is_none());\n+        assert!(cstr.is_err());\n     }\n \n     #[test]\n     fn from_bytes_with_nul_interior() {\n         let data = b\"1\\023\\0\";\n         let cstr = CStr::from_bytes_with_nul(data);\n-        assert!(cstr.is_none());\n+        assert!(cstr.is_err());\n     }\n }"}, {"sha": "ca1ff18f1cad8033fbdc261688e940366ff352f1", "filename": "src/libstd/ffi/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fmod.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -14,6 +14,8 @@\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::c_str::{CString, CStr, NulError, IntoStringError};\n+#[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n+pub use self::c_str::{FromBytesWithNulError};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::os_str::{OsString, OsStr};"}, {"sha": "125170bd47bc97c97cb6d1f24ce7f6b512ed990e", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -657,7 +657,7 @@ impl Metadata {\n     ///\n     /// This field may not be available on all platforms, and will return an\n     /// `Err` on platforms where it is not available.\n-    #[unstable(feature = \"fs_time\", issue = \"31399\")]\n+    #[stable(feature = \"fs_time\", since = \"1.10.0\")]\n     pub fn modified(&self) -> io::Result<SystemTime> {\n         self.0.modified().map(FromInner::from_inner)\n     }\n@@ -675,7 +675,7 @@ impl Metadata {\n     ///\n     /// This field may not be available on all platforms, and will return an\n     /// `Err` on platforms where it is not available.\n-    #[unstable(feature = \"fs_time\", issue = \"31399\")]\n+    #[stable(feature = \"fs_time\", since = \"1.10.0\")]\n     pub fn accessed(&self) -> io::Result<SystemTime> {\n         self.0.accessed().map(FromInner::from_inner)\n     }\n@@ -689,7 +689,7 @@ impl Metadata {\n     ///\n     /// This field may not be available on all platforms, and will return an\n     /// `Err` on platforms where it is not available.\n-    #[unstable(feature = \"fs_time\", issue = \"31399\")]\n+    #[stable(feature = \"fs_time\", since = \"1.10.0\")]\n     pub fn created(&self) -> io::Result<SystemTime> {\n         self.0.created().map(FromInner::from_inner)\n     }"}, {"sha": "11551601207506b331be7192d51836f5a18454a3", "filename": "src/libstd/io/lazy.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fio%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fio%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Flazy.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -12,11 +12,12 @@ use prelude::v1::*;\n \n use cell::Cell;\n use ptr;\n-use sync::{StaticMutex, Arc};\n+use sync::Arc;\n use sys_common;\n+use sys_common::mutex::Mutex;\n \n pub struct Lazy<T> {\n-    lock: StaticMutex,\n+    lock: Mutex,\n     ptr: Cell<*mut Arc<T>>,\n     init: fn() -> Arc<T>,\n }\n@@ -26,23 +27,25 @@ unsafe impl<T> Sync for Lazy<T> {}\n impl<T: Send + Sync + 'static> Lazy<T> {\n     pub const fn new(init: fn() -> Arc<T>) -> Lazy<T> {\n         Lazy {\n-            lock: StaticMutex::new(),\n+            lock: Mutex::new(),\n             ptr: Cell::new(ptr::null_mut()),\n             init: init\n         }\n     }\n \n     pub fn get(&'static self) -> Option<Arc<T>> {\n-        let _g = self.lock.lock();\n-        let ptr = self.ptr.get();\n         unsafe {\n-            if ptr.is_null() {\n+            self.lock.lock();\n+            let ptr = self.ptr.get();\n+            let ret = if ptr.is_null() {\n                 Some(self.init())\n             } else if ptr as usize == 1 {\n                 None\n             } else {\n                 Some((*ptr).clone())\n-            }\n+            };\n+            self.lock.unlock();\n+            return ret\n         }\n     }\n \n@@ -52,10 +55,10 @@ impl<T: Send + Sync + 'static> Lazy<T> {\n         // the at exit handler). Otherwise we just return the freshly allocated\n         // `Arc`.\n         let registered = sys_common::at_exit(move || {\n-            let g = self.lock.lock();\n+            self.lock.lock();\n             let ptr = self.ptr.get();\n             self.ptr.set(1 as *mut _);\n-            drop(g);\n+            self.lock.unlock();\n             drop(Box::from_raw(ptr))\n         });\n         let ret = (self.init)();"}, {"sha": "a7022a0a19421da3c44f7b19594128791b96706c", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -22,7 +22,7 @@ use rc::Rc;\n use sync::{Arc, Mutex, RwLock};\n use thread::Result;\n \n-#[unstable(feature = \"panic_handler\", issue = \"30449\")]\n+#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n pub use panicking::{take_hook, set_hook, PanicInfo, Location};\n \n ///"}, {"sha": "5b70b2ba1074a4814a2fcab2f8ff5ad2c5280f7a", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -27,7 +27,7 @@ use fmt;\n use intrinsics;\n use mem;\n use raw;\n-use sync::StaticRwLock;\n+use sys_common::rwlock::RWLock;\n use sync::atomic::{AtomicBool, Ordering};\n use sys::stdio::Stderr;\n use sys_common::backtrace;\n@@ -69,7 +69,7 @@ enum Hook {\n     Custom(*mut (Fn(&PanicInfo) + 'static + Sync + Send)),\n }\n \n-static HOOK_LOCK: StaticRwLock = StaticRwLock::new();\n+static HOOK_LOCK: RWLock = RWLock::new();\n static mut HOOK: Hook = Hook::Default;\n static FIRST_PANIC: AtomicBool = AtomicBool::new(true);\n \n@@ -89,17 +89,17 @@ static FIRST_PANIC: AtomicBool = AtomicBool::new(true);\n /// # Panics\n ///\n /// Panics if called from a panicking thread.\n-#[unstable(feature = \"panic_handler\", issue = \"30449\")]\n+#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n pub fn set_hook(hook: Box<Fn(&PanicInfo) + 'static + Sync + Send>) {\n     if thread::panicking() {\n         panic!(\"cannot modify the panic hook from a panicking thread\");\n     }\n \n     unsafe {\n-        let lock = HOOK_LOCK.write();\n+        HOOK_LOCK.write();\n         let old_hook = HOOK;\n         HOOK = Hook::Custom(Box::into_raw(hook));\n-        drop(lock);\n+        HOOK_LOCK.write_unlock();\n \n         if let Hook::Custom(ptr) = old_hook {\n             Box::from_raw(ptr);\n@@ -114,17 +114,17 @@ pub fn set_hook(hook: Box<Fn(&PanicInfo) + 'static + Sync + Send>) {\n /// # Panics\n ///\n /// Panics if called from a panicking thread.\n-#[unstable(feature = \"panic_handler\", issue = \"30449\")]\n+#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n pub fn take_hook() -> Box<Fn(&PanicInfo) + 'static + Sync + Send> {\n     if thread::panicking() {\n         panic!(\"cannot modify the panic hook from a panicking thread\");\n     }\n \n     unsafe {\n-        let lock = HOOK_LOCK.write();\n+        HOOK_LOCK.write();\n         let hook = HOOK;\n         HOOK = Hook::Default;\n-        drop(lock);\n+        HOOK_LOCK.write_unlock();\n \n         match hook {\n             Hook::Default => Box::new(default_hook),\n@@ -134,7 +134,7 @@ pub fn take_hook() -> Box<Fn(&PanicInfo) + 'static + Sync + Send> {\n }\n \n /// A struct providing information about a panic.\n-#[unstable(feature = \"panic_handler\", issue = \"30449\")]\n+#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n pub struct PanicInfo<'a> {\n     payload: &'a (Any + Send),\n     location: Location<'a>,\n@@ -144,7 +144,7 @@ impl<'a> PanicInfo<'a> {\n     /// Returns the payload associated with the panic.\n     ///\n     /// This will commonly, but not always, be a `&'static str` or `String`.\n-    #[unstable(feature = \"panic_handler\", issue = \"30449\")]\n+    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n     pub fn payload(&self) -> &(Any + Send) {\n         self.payload\n     }\n@@ -154,28 +154,28 @@ impl<'a> PanicInfo<'a> {\n     ///\n     /// This method will currently always return `Some`, but this may change\n     /// in future versions.\n-    #[unstable(feature = \"panic_handler\", issue = \"30449\")]\n+    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n     pub fn location(&self) -> Option<&Location> {\n         Some(&self.location)\n     }\n }\n \n /// A struct containing information about the location of a panic.\n-#[unstable(feature = \"panic_handler\", issue = \"30449\")]\n+#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n pub struct Location<'a> {\n     file: &'a str,\n     line: u32,\n }\n \n impl<'a> Location<'a> {\n     /// Returns the name of the source file from which the panic originated.\n-    #[unstable(feature = \"panic_handler\", issue = \"30449\")]\n+    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n     pub fn file(&self) -> &str {\n         self.file\n     }\n \n     /// Returns the line number from which the panic originated.\n-    #[unstable(feature = \"panic_handler\", issue = \"30449\")]\n+    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n     pub fn line(&self) -> u32 {\n         self.line\n     }\n@@ -364,11 +364,12 @@ fn rust_panic_with_hook(msg: Box<Any + Send>,\n                 line: line,\n             },\n         };\n-        let _lock = HOOK_LOCK.read();\n+        HOOK_LOCK.read();\n         match HOOK {\n             Hook::Default => default_hook(&info),\n             Hook::Custom(ptr) => (*ptr)(&info),\n         }\n+        HOOK_LOCK.read_unlock();\n     }\n \n     if panics > 0 {"}, {"sha": "bf4b119a0b6669027f1efa0638fa332428a99cd3", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -72,6 +72,7 @@ impl WaitTimeoutResult {\n /// }\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n pub struct Condvar { inner: Box<StaticCondvar> }\n \n /// Statically allocated condition variables.\n@@ -91,6 +92,11 @@ pub struct Condvar { inner: Box<StaticCondvar> }\n #[unstable(feature = \"static_condvar\",\n            reason = \"may be merged with Condvar in the future\",\n            issue = \"27717\")]\n+#[rustc_deprecated(since = \"1.10.0\",\n+                   reason = \"the lazy-static crate suffices for static sync \\\n+                             primitives and eventually this type shouldn't \\\n+                             be necessary as `Condvar::new` in a static should \\\n+                             suffice\")]\n pub struct StaticCondvar {\n     inner: sys::Condvar,\n     mutex: AtomicUsize,\n@@ -100,8 +106,15 @@ pub struct StaticCondvar {\n #[unstable(feature = \"static_condvar\",\n            reason = \"may be merged with Condvar in the future\",\n            issue = \"27717\")]\n+#[rustc_deprecated(since = \"1.10.0\",\n+                   reason = \"the lazy-static crate suffices for static sync \\\n+                             primitives and eventually this type shouldn't \\\n+                             be necessary as `Condvar::new` in a static should \\\n+                             suffice\")]\n+#[allow(deprecated)]\n pub const CONDVAR_INIT: StaticCondvar = StaticCondvar::new();\n \n+#[allow(deprecated)]\n impl Condvar {\n     /// Creates a new condition variable which is ready to be waited on and\n     /// notified.\n@@ -228,12 +241,22 @@ impl Default for Condvar {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n impl Drop for Condvar {\n     fn drop(&mut self) {\n         unsafe { self.inner.inner.destroy() }\n     }\n }\n \n+#[rustc_deprecated(since = \"1.10.0\",\n+                   reason = \"the lazy-static crate suffices for static sync \\\n+                             primitives and eventually this type shouldn't \\\n+                             be necessary as `Condvar::new` in a static should \\\n+                             suffice\")]\n+#[unstable(feature = \"static_condvar\",\n+           reason = \"may be merged with Condvar in the future\",\n+           issue = \"27717\")]\n+#[allow(deprecated)]\n impl StaticCondvar {\n     /// Creates a new condition variable\n     #[unstable(feature = \"static_condvar\",\n@@ -392,6 +415,7 @@ impl StaticCondvar {\n }\n \n #[cfg(test)]\n+#[allow(deprecated)]\n mod tests {\n     use prelude::v1::*;\n "}, {"sha": "56eb7340c890c4bf88ec97a5af75febe5ea0b078", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -25,10 +25,13 @@ pub use core::sync::atomic;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::barrier::{Barrier, BarrierWaitResult};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n pub use self::condvar::{Condvar, StaticCondvar, WaitTimeoutResult, CONDVAR_INIT};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n pub use self::mutex::MUTEX_INIT;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n pub use self::mutex::{Mutex, MutexGuard, StaticMutex};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::once::{Once, OnceState, ONCE_INIT};\n@@ -37,6 +40,7 @@ pub use sys_common::poison::{PoisonError, TryLockError, TryLockResult, LockResul\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::rwlock::{RwLockReadGuard, RwLockWriteGuard};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n pub use self::rwlock::{RwLock, StaticRwLock, RW_LOCK_INIT};\n \n pub mod mpsc;"}, {"sha": "15e69628c7a5d20df96a0aab5e24d3f79b4e6d79", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -113,6 +113,7 @@ use sys_common::poison::{self, TryLockError, TryLockResult, LockResult};\n /// *guard += 1;\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n pub struct Mutex<T: ?Sized> {\n     // Note that this static mutex is in a *box*, not inlined into the struct\n     // itself. Once a native mutex has been used once, its address can never\n@@ -156,6 +157,11 @@ unsafe impl<T: ?Sized + Send> Sync for Mutex<T> { }\n #[unstable(feature = \"static_mutex\",\n            reason = \"may be merged with Mutex in the future\",\n            issue = \"27717\")]\n+#[rustc_deprecated(since = \"1.10.0\",\n+                   reason = \"the lazy-static crate suffices for static sync \\\n+                             primitives and eventually this type shouldn't \\\n+                             be necessary as `Mutex::new` in a static should \\\n+                             suffice\")]\n pub struct StaticMutex {\n     lock: sys::Mutex,\n     poison: poison::Flag,\n@@ -168,6 +174,7 @@ pub struct StaticMutex {\n /// `Deref` and `DerefMut` implementations\n #[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n pub struct MutexGuard<'a, T: ?Sized + 'a> {\n     // funny underscores due to how Deref/DerefMut currently work (they\n     // disregard field privacy).\n@@ -184,8 +191,15 @@ impl<'a, T: ?Sized> !marker::Send for MutexGuard<'a, T> {}\n #[unstable(feature = \"static_mutex\",\n            reason = \"may be merged with Mutex in the future\",\n            issue = \"27717\")]\n+#[rustc_deprecated(since = \"1.10.0\",\n+                   reason = \"the lazy-static crate suffices for static sync \\\n+                             primitives and eventually this type shouldn't \\\n+                             be necessary as `Mutex::new` in a static should \\\n+                             suffice\")]\n+#[allow(deprecated)]\n pub const MUTEX_INIT: StaticMutex = StaticMutex::new();\n \n+#[allow(deprecated)]\n impl<T> Mutex<T> {\n     /// Creates a new mutex in an unlocked state ready for use.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -197,6 +211,7 @@ impl<T> Mutex<T> {\n     }\n }\n \n+#[allow(deprecated)]\n impl<T: ?Sized> Mutex<T> {\n     /// Acquires a mutex, blocking the current thread until it is able to do so.\n     ///\n@@ -307,6 +322,7 @@ impl<T: ?Sized> Mutex<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n impl<T: ?Sized> Drop for Mutex<T> {\n     #[unsafe_destructor_blind_to_params]\n     fn drop(&mut self) {\n@@ -346,6 +362,12 @@ static DUMMY: Dummy = Dummy(UnsafeCell::new(()));\n #[unstable(feature = \"static_mutex\",\n            reason = \"may be merged with Mutex in the future\",\n            issue = \"27717\")]\n+#[rustc_deprecated(since = \"1.10.0\",\n+                   reason = \"the lazy-static crate suffices for static sync \\\n+                             primitives and eventually this type shouldn't \\\n+                             be necessary as `Mutex::new` in a static should \\\n+                             suffice\")]\n+#[allow(deprecated)]\n impl StaticMutex {\n     /// Creates a new mutex in an unlocked state ready for use.\n     pub const fn new() -> StaticMutex {\n@@ -391,8 +413,8 @@ impl StaticMutex {\n     }\n }\n \n+#[allow(deprecated)]\n impl<'mutex, T: ?Sized> MutexGuard<'mutex, T> {\n-\n     unsafe fn new(lock: &'mutex StaticMutex, data: &'mutex UnsafeCell<T>)\n            -> LockResult<MutexGuard<'mutex, T>> {\n         poison::map_result(lock.poison.borrow(), |guard| {\n@@ -418,6 +440,7 @@ impl<'mutex, T: ?Sized> DerefMut for MutexGuard<'mutex, T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n impl<'a, T: ?Sized> Drop for MutexGuard<'a, T> {\n     #[inline]\n     fn drop(&mut self) {\n@@ -428,15 +451,18 @@ impl<'a, T: ?Sized> Drop for MutexGuard<'a, T> {\n     }\n }\n \n+#[allow(deprecated)]\n pub fn guard_lock<'a, T: ?Sized>(guard: &MutexGuard<'a, T>) -> &'a sys::Mutex {\n     &guard.__lock.lock\n }\n \n+#[allow(deprecated)]\n pub fn guard_poison<'a, T: ?Sized>(guard: &MutexGuard<'a, T>) -> &'a poison::Flag {\n     &guard.__lock.poison\n }\n \n #[cfg(test)]\n+#[allow(deprecated)]\n mod tests {\n     use prelude::v1::*;\n "}, {"sha": "e1e764bd255cbd7302cf26b2eb4368330042f060", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -66,6 +66,7 @@ use sys_common::rwlock as sys;\n /// } // write lock is dropped here\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n pub struct RwLock<T: ?Sized> {\n     inner: Box<StaticRwLock>,\n     data: UnsafeCell<T>,\n@@ -104,6 +105,11 @@ unsafe impl<T: ?Sized + Send + Sync> Sync for RwLock<T> {}\n #[unstable(feature = \"static_rwlock\",\n            reason = \"may be merged with RwLock in the future\",\n            issue = \"27717\")]\n+#[rustc_deprecated(since = \"1.10.0\",\n+                   reason = \"the lazy-static crate suffices for static sync \\\n+                             primitives and eventually this type shouldn't \\\n+                             be necessary as `RwLock::new` in a static should \\\n+                             suffice\")]\n pub struct StaticRwLock {\n     lock: sys::RWLock,\n     poison: poison::Flag,\n@@ -113,12 +119,19 @@ pub struct StaticRwLock {\n #[unstable(feature = \"static_rwlock\",\n            reason = \"may be merged with RwLock in the future\",\n            issue = \"27717\")]\n+#[rustc_deprecated(since = \"1.10.0\",\n+                   reason = \"the lazy-static crate suffices for static sync \\\n+                             primitives and eventually this type shouldn't \\\n+                             be necessary as `RwLock::new` in a static should \\\n+                             suffice\")]\n+#[allow(deprecated)]\n pub const RW_LOCK_INIT: StaticRwLock = StaticRwLock::new();\n \n /// RAII structure used to release the shared read access of a lock when\n /// dropped.\n #[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n pub struct RwLockReadGuard<'a, T: ?Sized + 'a> {\n     __lock: &'a StaticRwLock,\n     __data: &'a T,\n@@ -131,6 +144,7 @@ impl<'a, T: ?Sized> !marker::Send for RwLockReadGuard<'a, T> {}\n /// dropped.\n #[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n pub struct RwLockWriteGuard<'a, T: ?Sized + 'a> {\n     __lock: &'a StaticRwLock,\n     __data: &'a mut T,\n@@ -140,6 +154,7 @@ pub struct RwLockWriteGuard<'a, T: ?Sized + 'a> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: ?Sized> !marker::Send for RwLockWriteGuard<'a, T> {}\n \n+#[allow(deprecated)]\n impl<T> RwLock<T> {\n     /// Creates a new instance of an `RwLock<T>` which is unlocked.\n     ///\n@@ -156,6 +171,7 @@ impl<T> RwLock<T> {\n     }\n }\n \n+#[allow(deprecated)]\n impl<T: ?Sized> RwLock<T> {\n     /// Locks this rwlock with shared read access, blocking the current thread\n     /// until it can be acquired.\n@@ -325,6 +341,7 @@ impl<T: ?Sized> RwLock<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n impl<T: ?Sized> Drop for RwLock<T> {\n     #[unsafe_destructor_blind_to_params]\n     fn drop(&mut self) {\n@@ -360,6 +377,12 @@ static DUMMY: Dummy = Dummy(UnsafeCell::new(()));\n #[unstable(feature = \"static_rwlock\",\n            reason = \"may be merged with RwLock in the future\",\n            issue = \"27717\")]\n+#[rustc_deprecated(since = \"1.10.0\",\n+                   reason = \"the lazy-static crate suffices for static sync \\\n+                             primitives and eventually this type shouldn't \\\n+                             be necessary as `RwLock::new` in a static should \\\n+                             suffice\")]\n+#[allow(deprecated)]\n impl StaticRwLock {\n     /// Creates a new rwlock.\n     pub const fn new() -> StaticRwLock {\n@@ -434,6 +457,7 @@ impl StaticRwLock {\n     }\n }\n \n+#[allow(deprecated)]\n impl<'rwlock, T: ?Sized> RwLockReadGuard<'rwlock, T> {\n     unsafe fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)\n            -> LockResult<RwLockReadGuard<'rwlock, T>> {\n@@ -482,6 +506,7 @@ impl<'rwlock, T: ?Sized> RwLockReadGuard<'rwlock, T> {\n     }\n }\n \n+#[allow(deprecated)]\n impl<'rwlock, T: ?Sized> RwLockWriteGuard<'rwlock, T> {\n     unsafe fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)\n            -> LockResult<RwLockWriteGuard<'rwlock, T>> {\n@@ -562,17 +587,20 @@ impl<'rwlock, T: ?Sized> Deref for RwLockWriteGuard<'rwlock, T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'rwlock, T: ?Sized> DerefMut for RwLockWriteGuard<'rwlock, T> {\n-    fn deref_mut(&mut self) -> &mut T { self.__data\n+    fn deref_mut(&mut self) -> &mut T {\n+        self.__data\n     }\n }\n \n+#[allow(deprecated)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: ?Sized> Drop for RwLockReadGuard<'a, T> {\n     fn drop(&mut self) {\n         unsafe { self.__lock.lock.read_unlock(); }\n     }\n }\n \n+#[allow(deprecated)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: ?Sized> Drop for RwLockWriteGuard<'a, T> {\n     fn drop(&mut self) {\n@@ -582,6 +610,7 @@ impl<'a, T: ?Sized> Drop for RwLockWriteGuard<'a, T> {\n }\n \n #[cfg(test)]\n+#[allow(deprecated)]\n mod tests {\n     #![allow(deprecated)] // rand\n "}, {"sha": "e877391fb8b5629283419cfe5fb6b4fbf9dff82f", "filename": "src/libstd/sys/common/args.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fsys%2Fcommon%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fsys%2Fcommon%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fargs.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -48,32 +48,36 @@ mod imp {\n     use mem;\n     use ffi::CStr;\n \n-    use sync::StaticMutex;\n+    use sys_common::mutex::Mutex;\n \n     static mut GLOBAL_ARGS_PTR: usize = 0;\n-    static LOCK: StaticMutex = StaticMutex::new();\n+    static LOCK: Mutex = Mutex::new();\n \n     pub unsafe fn init(argc: isize, argv: *const *const u8) {\n         let args = (0..argc).map(|i| {\n             CStr::from_ptr(*argv.offset(i) as *const c_char).to_bytes().to_vec()\n         }).collect();\n \n-        let _guard = LOCK.lock();\n+        LOCK.lock();\n         let ptr = get_global_ptr();\n         assert!((*ptr).is_none());\n         (*ptr) = Some(box args);\n+        LOCK.unlock();\n     }\n \n     pub unsafe fn cleanup() {\n-        let _guard = LOCK.lock();\n+        LOCK.lock();\n         *get_global_ptr() = None;\n+        LOCK.unlock();\n     }\n \n     pub fn clone() -> Option<Vec<Vec<u8>>> {\n-        let _guard = LOCK.lock();\n         unsafe {\n+            LOCK.lock();\n             let ptr = get_global_ptr();\n-            (*ptr).as_ref().map(|s| (**s).clone())\n+            let ret = (*ptr).as_ref().map(|s| (**s).clone());\n+            LOCK.unlock();\n+            return ret\n         }\n     }\n "}, {"sha": "ca2e70b5003a12bced9cec8c489be47118a5418e", "filename": "src/libstd/sys/unix/backtrace/tracing/backtrace_fn.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fbacktrace_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fbacktrace_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fbacktrace_fn.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -18,12 +18,11 @@\n /// simple to use it should be used only on iOS devices as the only viable\n /// option.\n \n-use io;\n use io::prelude::*;\n+use io;\n use libc;\n use mem;\n-use result::Result::Ok;\n-use sync::StaticMutex;\n+use sys::mutex::Mutex;\n \n use super::super::printing::print;\n \n@@ -37,18 +36,21 @@ pub fn write(w: &mut Write) -> io::Result<()> {\n     // while it doesn't requires lock for work as everything is\n     // local, it still displays much nicer backtraces when a\n     // couple of threads panic simultaneously\n-    static LOCK: StaticMutex = StaticMutex::new();\n-    let _g = LOCK.lock();\n+    static LOCK: Mutex = Mutex::new();\n+    unsafe {\n+        LOCK.lock();\n \n-    writeln!(w, \"stack backtrace:\")?;\n-    // 100 lines should be enough\n-    const SIZE: usize = 100;\n-    let mut buf: [*mut libc::c_void; SIZE] = unsafe { mem::zeroed() };\n-    let cnt = unsafe { backtrace(buf.as_mut_ptr(), SIZE as libc::c_int) as usize};\n+        writeln!(w, \"stack backtrace:\")?;\n+        // 100 lines should be enough\n+        const SIZE: usize = 100;\n+        let mut buf: [*mut libc::c_void; SIZE] = mem::zeroed();\n+        let cnt = backtrace(buf.as_mut_ptr(), SIZE as libc::c_int) as usize;\n \n-    // skipping the first one as it is write itself\n-    for i in 1..cnt {\n-        print(w, i as isize, buf[i], buf[i])?\n+        // skipping the first one as it is write itself\n+        for i in 1..cnt {\n+            print(w, i as isize, buf[i], buf[i])?\n+        }\n+        LOCK.unlock();\n     }\n     Ok(())\n }"}, {"sha": "c1b45620ab04a8aa4e69836f9813f754bd42b90c", "filename": "src/libstd/sys/unix/backtrace/tracing/gcc_s.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fgcc_s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fgcc_s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fgcc_s.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -12,7 +12,7 @@ use io;\n use io::prelude::*;\n use libc;\n use mem;\n-use sync::StaticMutex;\n+use sys_common::mutex::Mutex;\n \n use super::super::printing::print;\n use unwind as uw;\n@@ -31,24 +31,28 @@ pub fn write(w: &mut Write) -> io::Result<()> {\n     // is semi-reasonable in terms of printing anyway, and we know that all\n     // I/O done here is blocking I/O, not green I/O, so we don't have to\n     // worry about this being a native vs green mutex.\n-    static LOCK: StaticMutex = StaticMutex::new();\n-    let _g = LOCK.lock();\n+    static LOCK: Mutex = Mutex::new();\n+    unsafe {\n+        LOCK.lock();\n \n-    writeln!(w, \"stack backtrace:\")?;\n+        writeln!(w, \"stack backtrace:\")?;\n \n-    let mut cx = Context { writer: w, last_error: None, idx: 0 };\n-    return match unsafe {\n-        uw::_Unwind_Backtrace(trace_fn,\n-                              &mut cx as *mut Context as *mut libc::c_void)\n-    } {\n-        uw::_URC_NO_REASON => {\n-            match cx.last_error {\n-                Some(err) => Err(err),\n-                None => Ok(())\n+        let mut cx = Context { writer: w, last_error: None, idx: 0 };\n+        let ret = match {\n+            uw::_Unwind_Backtrace(trace_fn,\n+                                  &mut cx as *mut Context as *mut libc::c_void)\n+        } {\n+            uw::_URC_NO_REASON => {\n+                match cx.last_error {\n+                    Some(err) => Err(err),\n+                    None => Ok(())\n+                }\n             }\n-        }\n-        _ => Ok(()),\n-    };\n+            _ => Ok(()),\n+        };\n+        LOCK.unlock();\n+        return ret\n+    }\n \n     extern fn trace_fn(ctx: *mut uw::_Unwind_Context,\n                        arg: *mut libc::c_void) -> uw::_Unwind_Reason_Code {"}, {"sha": "bb90a977433e0c5f2c37db74c1ffe8817e08c8d7", "filename": "src/libstd/sys/unix/ext/fs.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -88,9 +88,7 @@ pub trait OpenOptionsExt {\n     /// }\n     /// let file = options.open(\"foo.txt\");\n     /// ```\n-    #[unstable(feature = \"expand_open_options\",\n-               reason = \"recently added\",\n-               issue = \"30014\")]\n+    #[stable(feature = \"open_options_ext\", since = \"1.10.0\")]\n     fn custom_flags(&mut self, flags: i32) -> &mut Self;\n }\n "}, {"sha": "b5287cce4843c13a511e4a16cdbae1d7410941a2", "filename": "src/libstd/sys/unix/ext/net.rs", "status": "modified", "additions": 65, "deletions": 7, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -7,7 +7,8 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![unstable(feature = \"unix_socket\", reason = \"newly added\", issue = \"32312\")]\n+\n+#![stable(feature = \"unix_socket\", since = \"1.10.0\")]\n \n //! Unix-specific networking functionality\n \n@@ -75,6 +76,7 @@ enum AddressKind<'a> {\n \n /// An address associated with a Unix socket.\n #[derive(Clone)]\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n pub struct SocketAddr {\n     addr: libc::sockaddr_un,\n     len: libc::socklen_t,\n@@ -109,6 +111,7 @@ impl SocketAddr {\n     }\n \n     /// Returns true iff the address is unnamed.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn is_unnamed(&self) -> bool {\n         if let AddressKind::Unnamed = self.address() {\n             true\n@@ -118,6 +121,7 @@ impl SocketAddr {\n     }\n \n     /// Returns the contents of this address if it is a `pathname` address.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn as_pathname(&self) -> Option<&Path> {\n         if let AddressKind::Pathname(path) = self.address() {\n             Some(path)\n@@ -141,6 +145,7 @@ impl SocketAddr {\n     }\n }\n \n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n impl fmt::Debug for SocketAddr {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         match self.address() {\n@@ -168,8 +173,6 @@ impl<'a> fmt::Display for AsciiEscaped<'a> {\n /// # Examples\n ///\n /// ```rust,no_run\n-/// #![feature(unix_socket)]\n-///\n /// use std::os::unix::net::UnixStream;\n /// use std::io::prelude::*;\n ///\n@@ -179,8 +182,10 @@ impl<'a> fmt::Display for AsciiEscaped<'a> {\n /// stream.read_to_string(&mut response).unwrap();\n /// println!(\"{}\", response);\n /// ```\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n pub struct UnixStream(Socket);\n \n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n impl fmt::Debug for UnixStream {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let mut builder = fmt.debug_struct(\"UnixStream\");\n@@ -197,6 +202,7 @@ impl fmt::Debug for UnixStream {\n \n impl UnixStream {\n     /// Connects to the socket named by `path`.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn connect<P: AsRef<Path>>(path: P) -> io::Result<UnixStream> {\n         fn inner(path: &Path) -> io::Result<UnixStream> {\n             unsafe {\n@@ -213,6 +219,7 @@ impl UnixStream {\n     /// Creates an unnamed pair of connected sockets.\n     ///\n     /// Returns two `UnixStream`s which are connected to each other.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn pair() -> io::Result<(UnixStream, UnixStream)> {\n         let (i1, i2) = Socket::new_pair(libc::AF_UNIX, libc::SOCK_STREAM)?;\n         Ok((UnixStream(i1), UnixStream(i2)))\n@@ -224,16 +231,19 @@ impl UnixStream {\n     /// object references. Both handles will read and write the same stream of\n     /// data, and options set on one stream will be propogated to the other\n     /// stream.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn try_clone(&self) -> io::Result<UnixStream> {\n         self.0.duplicate().map(UnixStream)\n     }\n \n     /// Returns the socket address of the local half of this connection.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn local_addr(&self) -> io::Result<SocketAddr> {\n         SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n     }\n \n     /// Returns the socket address of the remote half of this connection.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n         SocketAddr::new(|addr, len| unsafe { libc::getpeername(*self.0.as_inner(), addr, len) })\n     }\n@@ -243,6 +253,7 @@ impl UnixStream {\n     /// If the provided value is `None`, then `read` calls will block\n     /// indefinitely. It is an error to pass the zero `Duration` to this\n     /// method.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n         self.0.set_timeout(timeout, libc::SO_RCVTIMEO)\n     }\n@@ -252,26 +263,31 @@ impl UnixStream {\n     /// If the provided value is `None`, then `write` calls will block\n     /// indefinitely. It is an error to pass the zero `Duration` to this\n     /// method.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n         self.0.set_timeout(timeout, libc::SO_SNDTIMEO)\n     }\n \n     /// Returns the read timeout of this socket.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n         self.0.timeout(libc::SO_RCVTIMEO)\n     }\n \n     /// Returns the write timeout of this socket.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n         self.0.timeout(libc::SO_SNDTIMEO)\n     }\n \n     /// Moves the socket into or out of nonblocking mode.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n         self.0.set_nonblocking(nonblocking)\n     }\n \n     /// Returns the value of the `SO_ERROR` option.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n         self.0.take_error()\n     }\n@@ -281,11 +297,13 @@ impl UnixStream {\n     /// This function will cause all pending and future I/O calls on the\n     /// specified portions to immediately return with an appropriate value\n     /// (see the documentation of `Shutdown`).\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n         self.0.shutdown(how)\n     }\n }\n \n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n impl io::Read for UnixStream {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         io::Read::read(&mut &*self, buf)\n@@ -296,6 +314,7 @@ impl io::Read for UnixStream {\n     }\n }\n \n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n impl<'a> io::Read for &'a UnixStream {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         self.0.read(buf)\n@@ -306,6 +325,7 @@ impl<'a> io::Read for &'a UnixStream {\n     }\n }\n \n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n impl io::Write for UnixStream {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         io::Write::write(&mut &*self, buf)\n@@ -316,6 +336,7 @@ impl io::Write for UnixStream {\n     }\n }\n \n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n impl<'a> io::Write for &'a UnixStream {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         self.0.write(buf)\n@@ -326,18 +347,21 @@ impl<'a> io::Write for &'a UnixStream {\n     }\n }\n \n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n impl AsRawFd for UnixStream {\n     fn as_raw_fd(&self) -> RawFd {\n         *self.0.as_inner()\n     }\n }\n \n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n impl FromRawFd for UnixStream {\n     unsafe fn from_raw_fd(fd: RawFd) -> UnixStream {\n         UnixStream(Socket::from_inner(fd))\n     }\n }\n \n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n impl IntoRawFd for UnixStream {\n     fn into_raw_fd(self) -> RawFd {\n         self.0.into_inner()\n@@ -349,8 +373,6 @@ impl IntoRawFd for UnixStream {\n /// # Examples\n ///\n /// ```rust,no_run\n-/// #![feature(unix_socket)]\n-///\n /// use std::thread;\n /// use std::os::unix::net::{UnixStream, UnixListener};\n ///\n@@ -377,8 +399,10 @@ impl IntoRawFd for UnixStream {\n /// // close the listener socket\n /// drop(listener);\n /// ```\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n pub struct UnixListener(Socket);\n \n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n impl fmt::Debug for UnixListener {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let mut builder = fmt.debug_struct(\"UnixListener\");\n@@ -392,6 +416,7 @@ impl fmt::Debug for UnixListener {\n \n impl UnixListener {\n     /// Creates a new `UnixListener` bound to the specified socket.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixListener> {\n         fn inner(path: &Path) -> io::Result<UnixListener> {\n             unsafe {\n@@ -412,6 +437,7 @@ impl UnixListener {\n     /// This function will block the calling thread until a new Unix connection\n     /// is established. When established, the corersponding `UnixStream` and\n     /// the remote peer's address will be returned.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn accept(&self) -> io::Result<(UnixStream, SocketAddr)> {\n         let mut storage: libc::sockaddr_un = unsafe { mem::zeroed() };\n         let mut len = mem::size_of_val(&storage) as libc::socklen_t;\n@@ -425,21 +451,25 @@ impl UnixListener {\n     /// The returned `UnixListener` is a reference to the same socket that this\n     /// object references. Both handles can be used to accept incoming\n     /// connections and options set on one listener will affect the other.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn try_clone(&self) -> io::Result<UnixListener> {\n         self.0.duplicate().map(UnixListener)\n     }\n \n     /// Returns the local socket address of this listener.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn local_addr(&self) -> io::Result<SocketAddr> {\n         SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n     }\n \n     /// Moves the socket into or out of nonblocking mode.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n         self.0.set_nonblocking(nonblocking)\n     }\n \n     /// Returns the value of the `SO_ERROR` option.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n         self.0.take_error()\n     }\n@@ -448,29 +478,34 @@ impl UnixListener {\n     ///\n     /// The iterator will never return `None` and will also not yield the\n     /// peer's `SocketAddr` structure.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn incoming<'a>(&'a self) -> Incoming<'a> {\n         Incoming { listener: self }\n     }\n }\n \n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n impl AsRawFd for UnixListener {\n     fn as_raw_fd(&self) -> RawFd {\n         *self.0.as_inner()\n     }\n }\n \n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n impl FromRawFd for UnixListener {\n     unsafe fn from_raw_fd(fd: RawFd) -> UnixListener {\n         UnixListener(Socket::from_inner(fd))\n     }\n }\n \n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n impl IntoRawFd for UnixListener {\n     fn into_raw_fd(self) -> RawFd {\n         self.0.into_inner()\n     }\n }\n \n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n impl<'a> IntoIterator for &'a UnixListener {\n     type Item = io::Result<UnixStream>;\n     type IntoIter = Incoming<'a>;\n@@ -484,10 +519,12 @@ impl<'a> IntoIterator for &'a UnixListener {\n ///\n /// It will never return `None`.\n #[derive(Debug)]\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n pub struct Incoming<'a> {\n     listener: &'a UnixListener,\n }\n \n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n impl<'a> Iterator for Incoming<'a> {\n     type Item = io::Result<UnixStream>;\n \n@@ -505,8 +542,6 @@ impl<'a> Iterator for Incoming<'a> {\n /// # Examples\n ///\n /// ```rust,no_run\n-/// #![feature(unix_socket)]\n-///\n /// use std::os::unix::net::UnixDatagram;\n ///\n /// let socket = UnixDatagram::bind(\"/path/to/my/socket\").unwrap();\n@@ -515,8 +550,10 @@ impl<'a> Iterator for Incoming<'a> {\n /// let (count, address) = socket.recv_from(&mut buf).unwrap();\n /// println!(\"socket {:?} sent {:?}\", address, &buf[..count]);\n /// ```\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n pub struct UnixDatagram(Socket);\n \n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n impl fmt::Debug for UnixDatagram {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let mut builder = fmt.debug_struct(\"UnixDatagram\");\n@@ -533,6 +570,7 @@ impl fmt::Debug for UnixDatagram {\n \n impl UnixDatagram {\n     /// Creates a Unix datagram socket bound to the given path.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixDatagram> {\n         fn inner(path: &Path) -> io::Result<UnixDatagram> {\n             unsafe {\n@@ -548,6 +586,7 @@ impl UnixDatagram {\n     }\n \n     /// Creates a Unix Datagram socket which is not bound to any address.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn unbound() -> io::Result<UnixDatagram> {\n         let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_DGRAM)?;\n         Ok(UnixDatagram(inner))\n@@ -556,6 +595,7 @@ impl UnixDatagram {\n     /// Create an unnamed pair of connected sockets.\n     ///\n     /// Returns two `UnixDatagrams`s which are connected to each other.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn pair() -> io::Result<(UnixDatagram, UnixDatagram)> {\n         let (i1, i2) = Socket::new_pair(libc::AF_UNIX, libc::SOCK_DGRAM)?;\n         Ok((UnixDatagram(i1), UnixDatagram(i2)))\n@@ -565,6 +605,7 @@ impl UnixDatagram {\n     ///\n     /// The `send` method may be used to send data to the specified address.\n     /// `recv` and `recv_from` will only receive data from that address.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn connect<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n         fn inner(d: &UnixDatagram, path: &Path) -> io::Result<()> {\n             unsafe {\n@@ -583,18 +624,21 @@ impl UnixDatagram {\n     /// The returned `UnixListener` is a reference to the same socket that this\n     /// object references. Both handles can be used to accept incoming\n     /// connections and options set on one listener will affect the other.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn try_clone(&self) -> io::Result<UnixDatagram> {\n         self.0.duplicate().map(UnixDatagram)\n     }\n \n     /// Returns the address of this socket.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn local_addr(&self) -> io::Result<SocketAddr> {\n         SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n     }\n \n     /// Returns the address of this socket's peer.\n     ///\n     /// The `connect` method will connect the socket to a peer.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n         SocketAddr::new(|addr, len| unsafe { libc::getpeername(*self.0.as_inner(), addr, len) })\n     }\n@@ -603,6 +647,7 @@ impl UnixDatagram {\n     ///\n     /// On success, returns the number of bytes read and the address from\n     /// whence the data came.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n         let mut count = 0;\n         let addr = SocketAddr::new(|addr, len| {\n@@ -629,13 +674,15 @@ impl UnixDatagram {\n     /// Receives data from the socket.\n     ///\n     /// On success, returns the number of bytes read.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn recv(&self, buf: &mut [u8]) -> io::Result<usize> {\n         self.0.read(buf)\n     }\n \n     /// Sends data on the socket to the specified address.\n     ///\n     /// On success, returns the number of bytes written.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn send_to<P: AsRef<Path>>(&self, buf: &[u8], path: P) -> io::Result<usize> {\n         fn inner(d: &UnixDatagram, buf: &[u8], path: &Path) -> io::Result<usize> {\n             unsafe {\n@@ -659,6 +706,7 @@ impl UnixDatagram {\n     /// will return an error if the socket has not already been connected.\n     ///\n     /// On success, returns the number of bytes written.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn send(&self, buf: &[u8]) -> io::Result<usize> {\n         self.0.write(buf)\n     }\n@@ -668,6 +716,7 @@ impl UnixDatagram {\n     /// If the provided value is `None`, then `recv` and `recv_from` calls will\n     /// block indefinitely. It is an error to pass the zero `Duration` to this\n     /// method.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n         self.0.set_timeout(timeout, libc::SO_RCVTIMEO)\n     }\n@@ -677,26 +726,31 @@ impl UnixDatagram {\n     /// If the provided value is `None`, then `send` and `send_to` calls will\n     /// block indefinitely. It is an error to pass the zero `Duration` to this\n     /// method.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n         self.0.set_timeout(timeout, libc::SO_SNDTIMEO)\n     }\n \n     /// Returns the read timeout of this socket.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n         self.0.timeout(libc::SO_RCVTIMEO)\n     }\n \n     /// Returns the write timeout of this socket.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n         self.0.timeout(libc::SO_SNDTIMEO)\n     }\n \n     /// Moves the socket into or out of nonblocking mode.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n         self.0.set_nonblocking(nonblocking)\n     }\n \n     /// Returns the value of the `SO_ERROR` option.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n         self.0.take_error()\n     }\n@@ -706,23 +760,27 @@ impl UnixDatagram {\n     /// This function will cause all pending and future I/O calls on the\n     /// specified portions to immediately return with an appropriate value\n     /// (see the documentation of `Shutdown`).\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n         self.0.shutdown(how)\n     }\n }\n \n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n impl AsRawFd for UnixDatagram {\n     fn as_raw_fd(&self) -> RawFd {\n         *self.0.as_inner()\n     }\n }\n \n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n impl FromRawFd for UnixDatagram {\n     unsafe fn from_raw_fd(fd: RawFd) -> UnixDatagram {\n         UnixDatagram(Socket::from_inner(fd))\n     }\n }\n \n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n impl IntoRawFd for UnixDatagram {\n     fn into_raw_fd(self) -> RawFd {\n         self.0.into_inner()"}, {"sha": "7f23ae53fcd1ac7375e0f3abe140b6d9f38f6724", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 7, "deletions": 28, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -100,31 +100,6 @@ impl FileAttr {\n     }\n }\n \n-#[cfg(any(target_os = \"ios\", target_os = \"macos\"))]\n-// FIXME: update SystemTime to store a timespec and don't lose precision\n-impl FileAttr {\n-    pub fn modified(&self) -> io::Result<SystemTime> {\n-        Ok(SystemTime::from(libc::timeval {\n-            tv_sec: self.stat.st_mtime,\n-            tv_usec: (self.stat.st_mtime_nsec / 1000) as libc::suseconds_t,\n-        }))\n-    }\n-\n-    pub fn accessed(&self) -> io::Result<SystemTime> {\n-        Ok(SystemTime::from(libc::timeval {\n-            tv_sec: self.stat.st_atime,\n-            tv_usec: (self.stat.st_atime_nsec / 1000) as libc::suseconds_t,\n-        }))\n-    }\n-\n-    pub fn created(&self) -> io::Result<SystemTime> {\n-        Ok(SystemTime::from(libc::timeval {\n-            tv_sec: self.stat.st_birthtime,\n-            tv_usec: (self.stat.st_birthtime_nsec / 1000) as libc::suseconds_t,\n-        }))\n-    }\n-}\n-\n #[cfg(target_os = \"netbsd\")]\n impl FileAttr {\n     pub fn modified(&self) -> io::Result<SystemTime> {\n@@ -149,7 +124,7 @@ impl FileAttr {\n     }\n }\n \n-#[cfg(not(any(target_os = \"ios\", target_os = \"macos\", target_os = \"netbsd\")))]\n+#[cfg(not(target_os = \"netbsd\"))]\n impl FileAttr {\n     pub fn modified(&self) -> io::Result<SystemTime> {\n         Ok(SystemTime::from(libc::timespec {\n@@ -167,7 +142,9 @@ impl FileAttr {\n \n     #[cfg(any(target_os = \"bitrig\",\n               target_os = \"freebsd\",\n-              target_os = \"openbsd\"))]\n+              target_os = \"openbsd\",\n+              target_os = \"macos\",\n+              target_os = \"ios\"))]\n     pub fn created(&self) -> io::Result<SystemTime> {\n         Ok(SystemTime::from(libc::timespec {\n             tv_sec: self.stat.st_birthtime as libc::time_t,\n@@ -177,7 +154,9 @@ impl FileAttr {\n \n     #[cfg(not(any(target_os = \"bitrig\",\n                   target_os = \"freebsd\",\n-                  target_os = \"openbsd\")))]\n+                  target_os = \"openbsd\",\n+                  target_os = \"macos\",\n+                  target_os = \"ios\")))]\n     pub fn created(&self) -> io::Result<SystemTime> {\n         Err(io::Error::new(io::ErrorKind::Other,\n                            \"creation time is not available on this platform \\"}, {"sha": "21ce6b19ceb1357ec3a9a0c58e000960e9a377db", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -27,13 +27,13 @@ use path::{self, PathBuf};\n use ptr;\n use slice;\n use str;\n-use sync::StaticMutex;\n+use sys_common::mutex::Mutex;\n use sys::cvt;\n use sys::fd;\n use vec;\n \n const TMPBUF_SZ: usize = 128;\n-static ENV_LOCK: StaticMutex = StaticMutex::new();\n+static ENV_LOCK: Mutex = Mutex::new();\n \n /// Returns the platform-specific value of errno\n #[cfg(not(target_os = \"dragonfly\"))]\n@@ -434,10 +434,11 @@ pub unsafe fn environ() -> *mut *const *const c_char {\n /// Returns a vector of (variable, value) byte-vector pairs for all the\n /// environment variables of the current process.\n pub fn env() -> Env {\n-    let _g = ENV_LOCK.lock();\n-    return unsafe {\n+    unsafe {\n+        ENV_LOCK.lock();\n         let mut environ = *environ();\n         if environ == ptr::null() {\n+            ENV_LOCK.unlock();\n             panic!(\"os::env() failure getting env string from OS: {}\",\n                    io::Error::last_os_error());\n         }\n@@ -448,8 +449,13 @@ pub fn env() -> Env {\n             }\n             environ = environ.offset(1);\n         }\n-        Env { iter: result.into_iter(), _dont_send_or_sync_me: ptr::null_mut() }\n-    };\n+        let ret = Env {\n+            iter: result.into_iter(),\n+            _dont_send_or_sync_me: ptr::null_mut(),\n+        };\n+        ENV_LOCK.unlock();\n+        return ret\n+    }\n \n     fn parse(input: &[u8]) -> Option<(OsString, OsString)> {\n         // Strategy (copied from glibc): Variable name and value are separated\n@@ -471,32 +477,40 @@ pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n     // environment variables with a nul byte can't be set, so their value is\n     // always None as well\n     let k = CString::new(k.as_bytes())?;\n-    let _g = ENV_LOCK.lock();\n-    Ok(unsafe {\n+    unsafe {\n+        ENV_LOCK.lock();\n         let s = libc::getenv(k.as_ptr()) as *const _;\n-        if s.is_null() {\n+        let ret = if s.is_null() {\n             None\n         } else {\n             Some(OsStringExt::from_vec(CStr::from_ptr(s).to_bytes().to_vec()))\n-        }\n-    })\n+        };\n+        ENV_LOCK.unlock();\n+        return Ok(ret)\n+    }\n }\n \n pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n     let k = CString::new(k.as_bytes())?;\n     let v = CString::new(v.as_bytes())?;\n-    let _g = ENV_LOCK.lock();\n-    cvt(unsafe {\n-        libc::setenv(k.as_ptr(), v.as_ptr(), 1)\n-    }).map(|_| ())\n+\n+    unsafe {\n+        ENV_LOCK.lock();\n+        let ret = cvt(libc::setenv(k.as_ptr(), v.as_ptr(), 1)).map(|_| ());\n+        ENV_LOCK.unlock();\n+        return ret\n+    }\n }\n \n pub fn unsetenv(n: &OsStr) -> io::Result<()> {\n     let nbuf = CString::new(n.as_bytes())?;\n-    let _g = ENV_LOCK.lock();\n-    cvt(unsafe {\n-        libc::unsetenv(nbuf.as_ptr())\n-    }).map(|_| ())\n+\n+    unsafe {\n+        ENV_LOCK.lock();\n+        let ret = cvt(libc::unsetenv(nbuf.as_ptr())).map(|_| ());\n+        ENV_LOCK.unlock();\n+        return ret\n+    }\n }\n \n pub fn page_size() -> usize {"}, {"sha": "68eebba9e7b9043faf8bc8f00ec70a80a9a870cd", "filename": "src/libstd/sys/unix/time.rs", "status": "modified", "additions": 130, "deletions": 188, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftime.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -8,37 +8,129 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use cmp::Ordering;\n+use time::Duration;\n+use libc;\n+\n pub use self::inner::{Instant, SystemTime, UNIX_EPOCH};\n \n const NSEC_PER_SEC: u64 = 1_000_000_000;\n \n+#[derive(Copy, Clone)]\n+struct Timespec {\n+    t: libc::timespec,\n+}\n+\n+impl Timespec {\n+    fn sub_timespec(&self, other: &Timespec) -> Result<Duration, Duration> {\n+        if self >= other {\n+            Ok(if self.t.tv_nsec >= other.t.tv_nsec {\n+                Duration::new((self.t.tv_sec - other.t.tv_sec) as u64,\n+                              (self.t.tv_nsec - other.t.tv_nsec) as u32)\n+            } else {\n+                Duration::new((self.t.tv_sec - 1 - other.t.tv_sec) as u64,\n+                              self.t.tv_nsec as u32 + (NSEC_PER_SEC as u32) -\n+                              other.t.tv_nsec as u32)\n+            })\n+        } else {\n+            match other.sub_timespec(self) {\n+                Ok(d) => Err(d),\n+                Err(d) => Ok(d),\n+            }\n+        }\n+    }\n+\n+    fn add_duration(&self, other: &Duration) -> Timespec {\n+        let secs = (self.t.tv_sec as i64).checked_add(other.as_secs() as i64);\n+        let mut secs = secs.expect(\"overflow when adding duration to time\");\n+\n+        // Nano calculations can't overflow because nanos are <1B which fit\n+        // in a u32.\n+        let mut nsec = other.subsec_nanos() + self.t.tv_nsec as u32;\n+        if nsec >= NSEC_PER_SEC as u32 {\n+            nsec -= NSEC_PER_SEC as u32;\n+            secs = secs.checked_add(1).expect(\"overflow when adding \\\n+                                               duration to time\");\n+        }\n+        Timespec {\n+            t: libc::timespec {\n+                tv_sec: secs as libc::time_t,\n+                tv_nsec: nsec as libc::c_long,\n+            },\n+        }\n+    }\n+\n+    fn sub_duration(&self, other: &Duration) -> Timespec {\n+        let secs = (self.t.tv_sec as i64).checked_sub(other.as_secs() as i64);\n+        let mut secs = secs.expect(\"overflow when subtracting duration \\\n+                                    from time\");\n+\n+        // Similar to above, nanos can't overflow.\n+        let mut nsec = self.t.tv_nsec as i32 - other.subsec_nanos() as i32;\n+        if nsec < 0 {\n+            nsec += NSEC_PER_SEC as i32;\n+            secs = secs.checked_sub(1).expect(\"overflow when subtracting \\\n+                                               duration from time\");\n+        }\n+        Timespec {\n+            t: libc::timespec {\n+                tv_sec: secs as libc::time_t,\n+                tv_nsec: nsec as libc::c_long,\n+            },\n+        }\n+    }\n+}\n+\n+impl PartialEq for Timespec {\n+    fn eq(&self, other: &Timespec) -> bool {\n+        self.t.tv_sec == other.t.tv_sec && self.t.tv_nsec == other.t.tv_nsec\n+    }\n+}\n+\n+impl Eq for Timespec {}\n+\n+impl PartialOrd for Timespec {\n+    fn partial_cmp(&self, other: &Timespec) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl Ord for Timespec {\n+    fn cmp(&self, other: &Timespec) -> Ordering {\n+        let me = (self.t.tv_sec, self.t.tv_nsec);\n+        let other = (other.t.tv_sec, other.t.tv_nsec);\n+        me.cmp(&other)\n+    }\n+}\n+\n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n mod inner {\n-    use cmp::Ordering;\n     use fmt;\n     use libc;\n-    use super::NSEC_PER_SEC;\n     use sync::Once;\n     use sys::cvt;\n     use sys_common::mul_div_u64;\n     use time::Duration;\n \n-    const USEC_PER_SEC: u64 = NSEC_PER_SEC / 1000;\n+    use super::NSEC_PER_SEC;\n+    use super::Timespec;\n \n     #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug)]\n     pub struct Instant {\n         t: u64\n     }\n \n-    #[derive(Copy, Clone)]\n+    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n     pub struct SystemTime {\n-        t: libc::timeval,\n+        t: Timespec,\n     }\n \n     pub const UNIX_EPOCH: SystemTime = SystemTime {\n-        t: libc::timeval {\n-            tv_sec: 0,\n-            tv_usec: 0,\n+        t: Timespec {\n+            t: libc::timespec {\n+                tv_sec: 0,\n+                tv_nsec: 0,\n+            },\n         },\n     };\n \n@@ -72,113 +164,50 @@ mod inner {\n \n     impl SystemTime {\n         pub fn now() -> SystemTime {\n-            let mut s = SystemTime {\n-                t: libc::timeval {\n-                    tv_sec: 0,\n-                    tv_usec: 0,\n-                },\n+            let mut s = libc::timeval {\n+                tv_sec: 0,\n+                tv_usec: 0,\n             };\n             cvt(unsafe {\n-                libc::gettimeofday(&mut s.t, 0 as *mut _)\n+                libc::gettimeofday(&mut s, 0 as *mut _)\n             }).unwrap();\n-            return s\n+            return SystemTime::from(s)\n         }\n \n         pub fn sub_time(&self, other: &SystemTime)\n                         -> Result<Duration, Duration> {\n-            if self >= other {\n-                Ok(if self.t.tv_usec >= other.t.tv_usec {\n-                    Duration::new((self.t.tv_sec - other.t.tv_sec) as u64,\n-                                  ((self.t.tv_usec -\n-                                    other.t.tv_usec) as u32) * 1000)\n-                } else {\n-                    Duration::new((self.t.tv_sec - 1 - other.t.tv_sec) as u64,\n-                                  (self.t.tv_usec as u32 + (USEC_PER_SEC as u32) -\n-                                   other.t.tv_usec as u32) * 1000)\n-                })\n-            } else {\n-                match other.sub_time(self) {\n-                    Ok(d) => Err(d),\n-                    Err(d) => Ok(d),\n-                }\n-            }\n+            self.t.sub_timespec(&other.t)\n         }\n \n         pub fn add_duration(&self, other: &Duration) -> SystemTime {\n-            let secs = (self.t.tv_sec as i64).checked_add(other.as_secs() as i64);\n-            let mut secs = secs.expect(\"overflow when adding duration to time\");\n-\n-            // Nano calculations can't overflow because nanos are <1B which fit\n-            // in a u32.\n-            let mut usec = (other.subsec_nanos() / 1000) + self.t.tv_usec as u32;\n-            if usec >= USEC_PER_SEC as u32 {\n-                usec -= USEC_PER_SEC as u32;\n-                secs = secs.checked_add(1).expect(\"overflow when adding \\\n-                                                   duration to time\");\n-            }\n-            SystemTime {\n-                t: libc::timeval {\n-                    tv_sec: secs as libc::time_t,\n-                    tv_usec: usec as libc::suseconds_t,\n-                },\n-            }\n+            SystemTime { t: self.t.add_duration(other) }\n         }\n \n         pub fn sub_duration(&self, other: &Duration) -> SystemTime {\n-            let secs = (self.t.tv_sec as i64).checked_sub(other.as_secs() as i64);\n-            let mut secs = secs.expect(\"overflow when subtracting duration \\\n-                                        from time\");\n-\n-            // Similar to above, nanos can't overflow.\n-            let mut usec = self.t.tv_usec as i32 -\n-                           (other.subsec_nanos() / 1000) as i32;\n-            if usec < 0 {\n-                usec += USEC_PER_SEC as i32;\n-                secs = secs.checked_sub(1).expect(\"overflow when subtracting \\\n-                                                   duration from time\");\n-            }\n-            SystemTime {\n-                t: libc::timeval {\n-                    tv_sec: secs as libc::time_t,\n-                    tv_usec: usec as libc::suseconds_t,\n-                },\n-            }\n+            SystemTime { t: self.t.sub_duration(other) }\n         }\n     }\n \n     impl From<libc::timeval> for SystemTime {\n         fn from(t: libc::timeval) -> SystemTime {\n-            SystemTime { t: t }\n-        }\n-    }\n-\n-    impl PartialEq for SystemTime {\n-        fn eq(&self, other: &SystemTime) -> bool {\n-            self.t.tv_sec == other.t.tv_sec && self.t.tv_usec == other.t.tv_usec\n-        }\n-    }\n-\n-    impl Eq for SystemTime {}\n-\n-    impl PartialOrd for SystemTime {\n-        fn partial_cmp(&self, other: &SystemTime) -> Option<Ordering> {\n-            Some(self.cmp(other))\n+            SystemTime::from(libc::timespec {\n+                tv_sec: t.tv_sec,\n+                tv_nsec: (t.tv_usec * 1000) as libc::c_long,\n+            })\n         }\n     }\n \n-    impl Ord for SystemTime {\n-        fn cmp(&self, other: &SystemTime) -> Ordering {\n-            let me = (self.t.tv_sec, self.t.tv_usec);\n-            let other = (other.t.tv_sec, other.t.tv_usec);\n-            me.cmp(&other)\n+    impl From<libc::timespec> for SystemTime {\n+        fn from(t: libc::timespec) -> SystemTime {\n+            SystemTime { t: Timespec { t: t } }\n         }\n     }\n \n     impl fmt::Debug for SystemTime {\n         fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n             f.debug_struct(\"SystemTime\")\n-             .field(\"tv_sec\", &self.t.tv_sec)\n-             .field(\"tv_usec\", &self.t.tv_usec)\n+             .field(\"tv_sec\", &self.t.t.tv_sec)\n+             .field(\"tv_nsec\", &self.t.t.tv_nsec)\n              .finish()\n         }\n     }\n@@ -209,17 +238,12 @@ mod inner {\n \n #[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n mod inner {\n-    use cmp::Ordering;\n     use fmt;\n     use libc;\n-    use super::NSEC_PER_SEC;\n     use sys::cvt;\n     use time::Duration;\n \n-    #[derive(Copy, Clone)]\n-    struct Timespec {\n-        t: libc::timespec,\n-    }\n+    use super::Timespec;\n \n     #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n     pub struct Instant {\n@@ -242,7 +266,7 @@ mod inner {\n \n     impl Instant {\n         pub fn now() -> Instant {\n-            Instant { t: Timespec::now(libc::CLOCK_MONOTONIC) }\n+            Instant { t: now(libc::CLOCK_MONOTONIC) }\n         }\n \n         pub fn sub_instant(&self, other: &Instant) -> Duration {\n@@ -271,7 +295,7 @@ mod inner {\n \n     impl SystemTime {\n         pub fn now() -> SystemTime {\n-            SystemTime { t: Timespec::now(libc::CLOCK_REALTIME) }\n+            SystemTime { t: now(libc::CLOCK_REALTIME) }\n         }\n \n         pub fn sub_time(&self, other: &SystemTime)\n@@ -308,98 +332,16 @@ mod inner {\n     #[cfg(target_os = \"dragonfly\")]\n     pub type clock_t = libc::c_ulong;\n \n-    impl Timespec {\n-        pub fn now(clock: clock_t) -> Timespec {\n-            let mut t = Timespec {\n-                t: libc::timespec {\n-                    tv_sec: 0,\n-                    tv_nsec: 0,\n-                }\n-            };\n-            cvt(unsafe {\n-                libc::clock_gettime(clock, &mut t.t)\n-            }).unwrap();\n-            t\n-        }\n-\n-        fn sub_timespec(&self, other: &Timespec) -> Result<Duration, Duration> {\n-            if self >= other {\n-                Ok(if self.t.tv_nsec >= other.t.tv_nsec {\n-                    Duration::new((self.t.tv_sec - other.t.tv_sec) as u64,\n-                                  (self.t.tv_nsec - other.t.tv_nsec) as u32)\n-                } else {\n-                    Duration::new((self.t.tv_sec - 1 - other.t.tv_sec) as u64,\n-                                  self.t.tv_nsec as u32 + (NSEC_PER_SEC as u32) -\n-                                  other.t.tv_nsec as u32)\n-                })\n-            } else {\n-                match other.sub_timespec(self) {\n-                    Ok(d) => Err(d),\n-                    Err(d) => Ok(d),\n-                }\n-            }\n-        }\n-\n-        fn add_duration(&self, other: &Duration) -> Timespec {\n-            let secs = (self.t.tv_sec as i64).checked_add(other.as_secs() as i64);\n-            let mut secs = secs.expect(\"overflow when adding duration to time\");\n-\n-            // Nano calculations can't overflow because nanos are <1B which fit\n-            // in a u32.\n-            let mut nsec = other.subsec_nanos() + self.t.tv_nsec as u32;\n-            if nsec >= NSEC_PER_SEC as u32 {\n-                nsec -= NSEC_PER_SEC as u32;\n-                secs = secs.checked_add(1).expect(\"overflow when adding \\\n-                                                   duration to time\");\n-            }\n-            Timespec {\n-                t: libc::timespec {\n-                    tv_sec: secs as libc::time_t,\n-                    tv_nsec: nsec as libc::c_long,\n-                },\n-            }\n-        }\n-\n-        fn sub_duration(&self, other: &Duration) -> Timespec {\n-            let secs = (self.t.tv_sec as i64).checked_sub(other.as_secs() as i64);\n-            let mut secs = secs.expect(\"overflow when subtracting duration \\\n-                                        from time\");\n-\n-            // Similar to above, nanos can't overflow.\n-            let mut nsec = self.t.tv_nsec as i32 - other.subsec_nanos() as i32;\n-            if nsec < 0 {\n-                nsec += NSEC_PER_SEC as i32;\n-                secs = secs.checked_sub(1).expect(\"overflow when subtracting \\\n-                                                   duration from time\");\n-            }\n-            Timespec {\n-                t: libc::timespec {\n-                    tv_sec: secs as libc::time_t,\n-                    tv_nsec: nsec as libc::c_long,\n-                },\n+    fn now(clock: clock_t) -> Timespec {\n+        let mut t = Timespec {\n+            t: libc::timespec {\n+                tv_sec: 0,\n+                tv_nsec: 0,\n             }\n-        }\n-    }\n-\n-    impl PartialEq for Timespec {\n-        fn eq(&self, other: &Timespec) -> bool {\n-            self.t.tv_sec == other.t.tv_sec && self.t.tv_nsec == other.t.tv_nsec\n-        }\n-    }\n-\n-    impl Eq for Timespec {}\n-\n-    impl PartialOrd for Timespec {\n-        fn partial_cmp(&self, other: &Timespec) -> Option<Ordering> {\n-            Some(self.cmp(other))\n-        }\n-    }\n-\n-    impl Ord for Timespec {\n-        fn cmp(&self, other: &Timespec) -> Ordering {\n-            let me = (self.t.tv_sec, self.t.tv_nsec);\n-            let other = (other.t.tv_sec, other.t.tv_nsec);\n-            me.cmp(&other)\n-        }\n+        };\n+        cvt(unsafe {\n+            libc::clock_gettime(clock, &mut t.t)\n+        }).unwrap();\n+        t\n     }\n }"}, {"sha": "4388a0bdff2cfb0f7f31920b021cd8221cbae0ea", "filename": "src/libstd/sys/windows/ext/fs.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -19,9 +19,7 @@ use sys;\n use sys_common::{AsInnerMut, AsInner};\n \n /// Windows-specific extensions to `OpenOptions`\n-#[unstable(feature = \"open_options_ext\",\n-           reason = \"may require more thought/methods\",\n-           issue = \"27720\")]\n+#[stable(feature = \"open_options_ext\", since = \"1.10.0\")]\n pub trait OpenOptionsExt {\n     /// Overrides the `dwDesiredAccess` argument to the call to `CreateFile`\n     /// with the specified value.\n@@ -34,14 +32,14 @@ pub trait OpenOptionsExt {\n     /// # Examples\n     ///\n     /// ```no_run\n-    /// #![feature(open_options_ext)]\n     /// use std::fs::OpenOptions;\n     /// use std::os::windows::fs::OpenOptionsExt;\n     ///\n     /// // Open without read and write permission, for example if you only need\n     /// // to call `stat()` on the file\n     /// let file = OpenOptions::new().access_mode(0).open(\"foo.txt\");\n     /// ```\n+    #[stable(feature = \"open_options_ext\", since = \"1.10.0\")]\n     fn access_mode(&mut self, access: u32) -> &mut Self;\n \n     /// Overrides the `dwShareMode` argument to the call to `CreateFile` with\n@@ -55,7 +53,6 @@ pub trait OpenOptionsExt {\n     /// # Examples\n     ///\n     /// ```no_run\n-    /// #![feature(open_options_ext)]\n     /// use std::fs::OpenOptions;\n     /// use std::os::windows::fs::OpenOptionsExt;\n     ///\n@@ -65,6 +62,7 @@ pub trait OpenOptionsExt {\n     ///                              .share_mode(0)\n     ///                              .open(\"foo.txt\");\n     /// ```\n+    #[stable(feature = \"open_options_ext\", since = \"1.10.0\")]\n     fn share_mode(&mut self, val: u32) -> &mut Self;\n \n     /// Sets extra flags for the `dwFileFlags` argument to the call to\n@@ -88,9 +86,7 @@ pub trait OpenOptionsExt {\n     /// }\n     /// let file = options.open(\"foo.txt\");\n     /// ```\n-    #[unstable(feature = \"expand_open_options\",\n-               reason = \"recently added\",\n-               issue = \"30014\")]\n+    #[stable(feature = \"open_options_ext\", since = \"1.10.0\")]\n     fn custom_flags(&mut self, flags: u32) -> &mut Self;\n \n     /// Sets the `dwFileAttributes` argument to the call to `CreateFile2` to\n@@ -111,7 +107,6 @@ pub trait OpenOptionsExt {\n     /// # Examples\n     ///\n     /// ```rust,ignore\n-    /// #![feature(open_options_ext)]\n     /// extern crate winapi;\n     /// use std::fs::OpenOptions;\n     /// use std::os::windows::fs::OpenOptionsExt;\n@@ -120,17 +115,17 @@ pub trait OpenOptionsExt {\n     ///                              .attributes(winapi::FILE_ATTRIBUTE_HIDDEN)\n     ///                              .open(\"foo.txt\");\n     /// ```\n+    #[stable(feature = \"open_options_ext\", since = \"1.10.0\")]\n     fn attributes(&mut self, val: u32) -> &mut Self;\n \n     /// Sets the `dwSecurityQosFlags` argument to the call to `CreateFile2` to\n     /// the specified value (or combines it with `custom_flags` and `attributes`\n     /// to set the `dwFlagsAndAttributes` for `CreateFile`).\n+    #[stable(feature = \"open_options_ext\", since = \"1.10.0\")]\n     fn security_qos_flags(&mut self, flags: u32) -> &mut OpenOptions;\n }\n \n-#[unstable(feature = \"open_options_ext\",\n-           reason = \"may require more thought/methods\",\n-           issue = \"27720\")]\n+#[stable(feature = \"open_options_ext\", since = \"1.10.0\")]\n impl OpenOptionsExt for OpenOptions {\n     fn access_mode(&mut self, access: u32) -> &mut OpenOptions {\n         self.as_inner_mut().access_mode(access); self"}, {"sha": "3ca75cf3643769e977e2802df9f1377ce951d22e", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae91d7c8c21aa860bda29c62207a6726837952b/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=cae91d7c8c21aa860bda29c62207a6726837952b", "patch": "@@ -24,7 +24,7 @@ use mem;\n use os::windows::ffi::OsStrExt;\n use path::Path;\n use ptr;\n-use sync::StaticMutex;\n+use sys::mutex::Mutex;\n use sys::c;\n use sys::fs::{OpenOptions, File};\n use sys::handle::Handle;\n@@ -75,6 +75,10 @@ pub struct StdioPipes {\n     pub stderr: Option<AnonPipe>,\n }\n \n+struct DropGuard<'a> {\n+    lock: &'a Mutex,\n+}\n+\n impl Command {\n     pub fn new(program: &OsStr) -> Command {\n         Command {\n@@ -173,8 +177,8 @@ impl Command {\n         //\n         // For more information, msdn also has an article about this race:\n         // http://support.microsoft.com/kb/315939\n-        static CREATE_PROCESS_LOCK: StaticMutex = StaticMutex::new();\n-        let _lock = CREATE_PROCESS_LOCK.lock();\n+        static CREATE_PROCESS_LOCK: Mutex = Mutex::new();\n+        let _guard = DropGuard::new(&CREATE_PROCESS_LOCK);\n \n         let mut pipes = StdioPipes {\n             stdin: None,\n@@ -224,6 +228,23 @@ impl fmt::Debug for Command {\n     }\n }\n \n+impl<'a> DropGuard<'a> {\n+    fn new(lock: &'a Mutex) -> DropGuard<'a> {\n+        unsafe {\n+            lock.lock();\n+            DropGuard { lock: lock }\n+        }\n+    }\n+}\n+\n+impl<'a> Drop for DropGuard<'a> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            self.lock.unlock();\n+        }\n+    }\n+}\n+\n impl Stdio {\n     fn to_handle(&self, stdio_id: c::DWORD, pipe: &mut Option<AnonPipe>)\n                  -> io::Result<Handle> {"}]}