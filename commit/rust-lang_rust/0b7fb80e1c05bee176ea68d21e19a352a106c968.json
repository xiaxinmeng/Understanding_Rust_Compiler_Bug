{"sha": "0b7fb80e1c05bee176ea68d21e19a352a106c968", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiN2ZiODBlMWMwNWJlZTE3NmVhNjhkMjFlMTlhMzUyYTEwNmM5Njg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-13T17:26:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-13T17:26:18Z"}, "message": "Auto merge of #34772 - jseyfried:cleanup_interner, r=eddyb\n\nStart cleaning up the string interner\n\nr? @eddyb", "tree": {"sha": "0db4006f136b461d7cbdc2cd8de302e69dc1cc17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0db4006f136b461d7cbdc2cd8de302e69dc1cc17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b7fb80e1c05bee176ea68d21e19a352a106c968", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b7fb80e1c05bee176ea68d21e19a352a106c968", "html_url": "https://github.com/rust-lang/rust/commit/0b7fb80e1c05bee176ea68d21e19a352a106c968", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b7fb80e1c05bee176ea68d21e19a352a106c968/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a12a70a5c516d4aa5e86de52a62f41b67ab8bc0", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a12a70a5c516d4aa5e86de52a62f41b67ab8bc0", "html_url": "https://github.com/rust-lang/rust/commit/4a12a70a5c516d4aa5e86de52a62f41b67ab8bc0"}, {"sha": "060b5c5ef273a6b74ccbd10c1d4a1debfa27d9de", "url": "https://api.github.com/repos/rust-lang/rust/commits/060b5c5ef273a6b74ccbd10c1d4a1debfa27d9de", "html_url": "https://github.com/rust-lang/rust/commit/060b5c5ef273a6b74ccbd10c1d4a1debfa27d9de"}], "stats": {"total": 540, "additions": 145, "deletions": 395}, "files": [{"sha": "ba59c2afc769d3e5112fa436f2c725047ea76173", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b7fb80e1c05bee176ea68d21e19a352a106c968/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7fb80e1c05bee176ea68d21e19a352a106c968/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=0b7fb80e1c05bee176ea68d21e19a352a106c968", "patch": "@@ -211,7 +211,7 @@ pub fn compile_input(sess: &Session,\n             }\n \n             // Discard interned strings as they are no longer required.\n-            token::get_ident_interner().clear();\n+            token::clear_ident_interner();\n \n             Ok((outputs, trans))\n         })??\n@@ -480,7 +480,7 @@ pub fn phase_1_parse_input<'a>(sess: &'a Session,\n                                input: &Input)\n                                -> PResult<'a, ast::Crate> {\n     // These may be left in an incoherent state after a previous compile.\n-    // `clear_tables` and `get_ident_interner().clear()` can be used to free\n+    // `clear_tables` and `clear_ident_interner` can be used to free\n     // memory, but they do not restore the initial state.\n     syntax::ext::mtwt::reset_tables();\n     token::reset_ident_interner();"}, {"sha": "84e040319231737c085f9e32a05bd53c567d244b", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b7fb80e1c05bee176ea68d21e19a352a106c968/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7fb80e1c05bee176ea68d21e19a352a106c968/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=0b7fb80e1c05bee176ea68d21e19a352a106c968", "patch": "@@ -97,7 +97,7 @@ use rustc::session::early_error;\n use syntax::{ast, json};\n use syntax::codemap::{CodeMap, FileLoader, RealFileLoader};\n use syntax::feature_gate::{GatedCfg, UnstableFeatures};\n-use syntax::parse::{self, PResult, token};\n+use syntax::parse::{self, PResult};\n use syntax_pos::MultiSpan;\n use errors::emitter::Emitter;\n \n@@ -201,7 +201,7 @@ pub fn run_compiler_with_file_loader<'a, L>(args: &[String],\n     };\n \n     let dep_graph = DepGraph::new(sopts.build_dep_graph());\n-    let cstore = Rc::new(CStore::new(&dep_graph, token::get_ident_interner()));\n+    let cstore = Rc::new(CStore::new(&dep_graph));\n     let codemap = Rc::new(CodeMap::with_file_loader(loader));\n     let sess = session::build_session_with_codemap(sopts,\n                                                    &dep_graph,\n@@ -432,7 +432,7 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                     return None;\n                 }\n                 let dep_graph = DepGraph::new(sopts.build_dep_graph());\n-                let cstore = Rc::new(CStore::new(&dep_graph, token::get_ident_interner()));\n+                let cstore = Rc::new(CStore::new(&dep_graph));\n                 let sess = build_session(sopts.clone(),\n                     &dep_graph,\n                     None,"}, {"sha": "911becd3f569b99fadbb0982e5ae155743a67e1f", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b7fb80e1c05bee176ea68d21e19a352a106c968/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7fb80e1c05bee176ea68d21e19a352a106c968/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=0b7fb80e1c05bee176ea68d21e19a352a106c968", "patch": "@@ -106,7 +106,7 @@ fn test_env<F>(source_string: &str,\n \n     let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();\n-    let cstore = Rc::new(CStore::new(&dep_graph, token::get_ident_interner()));\n+    let cstore = Rc::new(CStore::new(&dep_graph));\n     let sess = session::build_session_(options, &dep_graph, None, diagnostic_handler,\n                                        Rc::new(CodeMap::new()), cstore.clone());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));"}, {"sha": "d4443c6d09d7cb6b6282a7b411eb476427a1715a", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0b7fb80e1c05bee176ea68d21e19a352a106c968/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7fb80e1c05bee176ea68d21e19a352a106c968/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=0b7fb80e1c05bee176ea68d21e19a352a106c968", "patch": "@@ -557,7 +557,6 @@ impl<'a> CrateReader<'a> {\n         let source_name = format!(\"<{} macros>\", item.ident);\n         let mut macros = vec![];\n         decoder::each_exported_macro(ekrate.metadata.as_slice(),\n-                                     &self.cstore.intr,\n             |name, attrs, span, body| {\n                 // NB: Don't use parse::parse_tts_from_source_str because it parses with\n                 // quote_depth > 0."}, {"sha": "850d6c91f66ef05b2c7637d5367a221abe8fb9d1", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0b7fb80e1c05bee176ea68d21e19a352a106c968/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7fb80e1c05bee176ea68d21e19a352a106c968/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=0b7fb80e1c05bee176ea68d21e19a352a106c968", "patch": "@@ -127,7 +127,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n-        decoder::get_adt_def(&self.intr, &cdata, def.index, tcx)\n+        decoder::get_adt_def(&cdata, def.index, tcx)\n     }\n \n     fn method_arg_names(&self, did: DefId) -> Vec<String>\n@@ -140,13 +140,13 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     fn item_name(&self, def: DefId) -> ast::Name {\n         self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n-        decoder::get_item_name(&self.intr, &cdata, def.index)\n+        decoder::get_item_name(&cdata, def.index)\n     }\n \n     fn opt_item_name(&self, def: DefId) -> Option<ast::Name> {\n         self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n-        decoder::maybe_get_item_name(&self.intr, &cdata, def.index)\n+        decoder::maybe_get_item_name(&cdata, def.index)\n     }\n \n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId>\n@@ -176,7 +176,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n-        decoder::get_provided_trait_methods(self.intr.clone(), &cdata, def.index, tcx)\n+        decoder::get_provided_trait_methods(&cdata, def.index, tcx)\n     }\n \n     fn trait_item_def_ids(&self, def: DefId)\n@@ -222,7 +222,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n                              -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n         self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n-        decoder::get_associated_consts(self.intr.clone(), &cdata, def.index, tcx)\n+        decoder::get_associated_consts(&cdata, def.index, tcx)\n     }\n \n     fn impl_parent(&self, impl_def: DefId) -> Option<DefId> {\n@@ -243,11 +243,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n-        decoder::get_impl_or_trait_item(\n-            self.intr.clone(),\n-            &cdata,\n-            def.index,\n-            tcx)\n+        decoder::get_impl_or_trait_item(&cdata, def.index, tcx)\n     }\n \n     fn is_const_fn(&self, did: DefId) -> bool\n@@ -460,7 +456,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n-        decoder::get_struct_field_names(&self.intr, &cdata, def.index)\n+        decoder::get_struct_field_names(&cdata, def.index)\n     }\n \n     fn item_children(&self, def_id: DefId) -> Vec<ChildItem>\n@@ -469,14 +465,9 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         let mut result = vec![];\n         let crate_data = self.get_crate_data(def_id.krate);\n         let get_crate_data = |cnum| self.get_crate_data(cnum);\n-        decoder::each_child_of_item(\n-            self.intr.clone(), &crate_data,\n-            def_id.index, get_crate_data,\n-            |def, name, vis| result.push(ChildItem {\n-                def: def,\n-                name: name,\n-                vis: vis\n-            }));\n+        decoder::each_child_of_item(&crate_data, def_id.index, get_crate_data, |def, name, vis| {\n+            result.push(ChildItem { def: def, name: name, vis: vis });\n+        });\n         result\n     }\n \n@@ -485,13 +476,9 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         let mut result = vec![];\n         let crate_data = self.get_crate_data(cnum);\n         let get_crate_data = |cnum| self.get_crate_data(cnum);\n-        decoder::each_top_level_item_of_crate(\n-            self.intr.clone(), &crate_data, get_crate_data,\n-            |def, name, vis| result.push(ChildItem {\n-                def: def,\n-                name: name,\n-                vis: vis\n-            }));\n+        decoder::each_top_level_item_of_crate(&crate_data, get_crate_data, |def, name, vis| {\n+            result.push(ChildItem { def: def, name: name, vis: vis });\n+        });\n         result\n     }\n "}, {"sha": "6baa0ac23f3f5073103ec8f6fcb709162544a547", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b7fb80e1c05bee176ea68d21e19a352a106c968/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7fb80e1c05bee176ea68d21e19a352a106c968/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=0b7fb80e1c05bee176ea68d21e19a352a106c968", "patch": "@@ -37,7 +37,6 @@ use flate::Bytes;\n use syntax::ast;\n use syntax::attr;\n use syntax::codemap;\n-use syntax::parse::token::IdentInterner;\n use syntax_pos;\n \n pub use middle::cstore::{NativeLibraryKind, LinkagePreference};\n@@ -106,21 +105,18 @@ pub struct CStore {\n     used_libraries: RefCell<Vec<(String, NativeLibraryKind)>>,\n     used_link_args: RefCell<Vec<String>>,\n     statically_included_foreign_items: RefCell<NodeSet>,\n-    pub intr: Rc<IdentInterner>,\n     pub visible_parent_map: RefCell<DefIdMap<DefId>>,\n }\n \n impl CStore {\n-    pub fn new(dep_graph: &DepGraph,\n-               intr: Rc<IdentInterner>) -> CStore {\n+    pub fn new(dep_graph: &DepGraph) -> CStore {\n         CStore {\n             dep_graph: dep_graph.clone(),\n             metas: RefCell::new(FnvHashMap()),\n             extern_mod_crate_map: RefCell::new(FnvHashMap()),\n             used_crate_sources: RefCell::new(Vec::new()),\n             used_libraries: RefCell::new(Vec::new()),\n             used_link_args: RefCell::new(Vec::new()),\n-            intr: intr,\n             statically_included_foreign_items: RefCell::new(NodeSet()),\n             visible_parent_map: RefCell::new(FnvHashMap()),\n         }"}, {"sha": "3f5c9a6d3bd83724637bd350a38846d4d60efce5", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 45, "deletions": 85, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/0b7fb80e1c05bee176ea68d21e19a352a106c968/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7fb80e1c05bee176ea68d21e19a352a106c968/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=0b7fb80e1c05bee176ea68d21e19a352a106c968", "patch": "@@ -53,7 +53,7 @@ use rbml::reader;\n use rbml;\n use rustc_serialize::Decodable;\n use syntax::attr;\n-use syntax::parse::token::{self, IdentInterner};\n+use syntax::parse::token;\n use syntax::ast;\n use syntax::abi::Abi;\n use syntax::codemap;\n@@ -284,17 +284,14 @@ fn item_trait_ref<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata:\n     doc_trait_ref(tp, tcx, cdata)\n }\n \n-fn item_name(intr: &IdentInterner, item: rbml::Doc) -> ast::Name {\n-    maybe_item_name(intr, item).expect(\"no item in item_name\")\n+fn item_name(item: rbml::Doc) -> ast::Name {\n+    maybe_item_name(item).expect(\"no item in item_name\")\n }\n \n-fn maybe_item_name(intr: &IdentInterner, item: rbml::Doc) -> Option<ast::Name> {\n+fn maybe_item_name(item: rbml::Doc) -> Option<ast::Name> {\n     reader::maybe_get_doc(item, tag_paths_data_name).map(|name| {\n         let string = name.as_str_slice();\n-        match intr.find(string) {\n-            None => token::intern(string),\n-            Some(val) => val,\n-        }\n+        token::intern(string)\n     })\n }\n \n@@ -400,8 +397,7 @@ pub fn get_trait_def<'a, 'tcx>(cdata: Cmd,\n                       associated_type_names)\n }\n \n-pub fn get_adt_def<'a, 'tcx>(intr: &IdentInterner,\n-                             cdata: Cmd,\n+pub fn get_adt_def<'a, 'tcx>(cdata: Cmd,\n                              item_id: DefIndex,\n                              tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                              -> ty::AdtDefMaster<'tcx>\n@@ -412,9 +408,7 @@ pub fn get_adt_def<'a, 'tcx>(intr: &IdentInterner,\n             _ => bug!(\"unexpected family: {:?}\", family),\n         }\n     }\n-    fn get_enum_variants<'tcx>(intr: &IdentInterner,\n-                               cdata: Cmd,\n-                               doc: rbml::Doc) -> Vec<ty::VariantDefData<'tcx, 'tcx>> {\n+    fn get_enum_variants<'tcx>(cdata: Cmd, doc: rbml::Doc) -> Vec<ty::VariantDefData<'tcx, 'tcx>> {\n         let mut disr_val = 0;\n         reader::tagged_docs(doc, tag_items_data_item_variant).map(|p| {\n             let did = translated_def_id(cdata, p);\n@@ -428,16 +422,14 @@ pub fn get_adt_def<'a, 'tcx>(intr: &IdentInterner,\n \n             ty::VariantDefData {\n                 did: did,\n-                name: item_name(intr, item),\n-                fields: get_variant_fields(intr, cdata, item),\n+                name: item_name(item),\n+                fields: get_variant_fields(cdata, item),\n                 disr_val: ConstInt::Infer(disr),\n                 kind: expect_variant_kind(item_family(item)),\n             }\n         }).collect()\n     }\n-    fn get_variant_fields<'tcx>(intr: &IdentInterner,\n-                                cdata: Cmd,\n-                                doc: rbml::Doc) -> Vec<ty::FieldDefData<'tcx, 'tcx>> {\n+    fn get_variant_fields<'tcx>(cdata: Cmd, doc: rbml::Doc) -> Vec<ty::FieldDefData<'tcx, 'tcx>> {\n         let mut index = 0;\n         reader::tagged_docs(doc, tag_item_field).map(|f| {\n             let ff = item_family(f);\n@@ -446,24 +438,23 @@ pub fn get_adt_def<'a, 'tcx>(intr: &IdentInterner,\n                 _ => bug!(\"expected field, found {:?}\", ff)\n             };\n             ty::FieldDefData::new(item_def_id(f, cdata),\n-                                  item_name(intr, f),\n+                                  item_name(f),\n                                   struct_field_family_to_visibility(ff))\n         }).chain(reader::tagged_docs(doc, tag_item_unnamed_field).map(|f| {\n             let ff = item_family(f);\n-            let name = intr.intern(&index.to_string());\n+            let name = token::with_ident_interner(|interner| interner.intern(index.to_string()));\n             index += 1;\n             ty::FieldDefData::new(item_def_id(f, cdata), name,\n                                   struct_field_family_to_visibility(ff))\n         })).collect()\n     }\n-    fn get_struct_variant<'tcx>(intr: &IdentInterner,\n-                                cdata: Cmd,\n+    fn get_struct_variant<'tcx>(cdata: Cmd,\n                                 doc: rbml::Doc,\n                                 did: DefId) -> ty::VariantDefData<'tcx, 'tcx> {\n         ty::VariantDefData {\n             did: did,\n-            name: item_name(intr, doc),\n-            fields: get_variant_fields(intr, cdata, doc),\n+            name: item_name(doc),\n+            fields: get_variant_fields(cdata, doc),\n             disr_val: ConstInt::Infer(0),\n             kind: expect_variant_kind(item_family(doc)),\n         }\n@@ -475,15 +466,15 @@ pub fn get_adt_def<'a, 'tcx>(intr: &IdentInterner,\n     let (kind, variants) = match item_family(doc) {\n         Enum => {\n             (ty::AdtKind::Enum,\n-             get_enum_variants(intr, cdata, doc))\n+             get_enum_variants(cdata, doc))\n         }\n         Struct(..) => {\n             // Use separate constructor id for unit/tuple structs and reuse did for braced structs.\n             ctor_did = reader::maybe_get_doc(doc, tag_items_data_item_struct_ctor).map(|ctor_doc| {\n                 translated_def_id(cdata, ctor_doc)\n             });\n             (ty::AdtKind::Struct,\n-             vec![get_struct_variant(intr, cdata, doc, ctor_did.unwrap_or(did))])\n+             vec![get_struct_variant(cdata, doc, ctor_did.unwrap_or(did))])\n         }\n         _ => bug!(\"get_adt_def called on a non-ADT {:?} - {:?}\",\n                   item_family(doc), did)\n@@ -663,8 +654,7 @@ pub fn each_lang_item<F>(cdata: Cmd, mut f: F) -> bool where\n     })\n }\n \n-fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n-                                     cdata: Cmd,\n+fn each_child_of_item_or_crate<F, G>(cdata: Cmd,\n                                      item_doc: rbml::Doc,\n                                      mut get_crate_data: G,\n                                      mut callback: F) where\n@@ -690,7 +680,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n         // Get the item.\n         if let Some(child_item_doc) = crate_data.get_item(child_def_id.index) {\n             // Hand off the item to the callback.\n-            let child_name = item_name(&intr, child_item_doc);\n+            let child_name = item_name(child_item_doc);\n             let def_like = item_to_def_like(crate_data, child_item_doc, child_def_id);\n             let visibility = item_visibility(child_item_doc);\n             callback(def_like, child_name, visibility);\n@@ -711,7 +701,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n                 if let Some(impl_method_doc) = cdata.get_item(impl_item_def_id.index) {\n                     if let StaticMethod = item_family(impl_method_doc) {\n                         // Hand off the static method to the callback.\n-                        let static_method_name = item_name(&intr, impl_method_doc);\n+                        let static_method_name = item_name(impl_method_doc);\n                         let static_method_def_like = item_to_def_like(cdata, impl_method_doc,\n                                                                       impl_item_def_id);\n                         callback(static_method_def_like,\n@@ -755,54 +745,41 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n }\n \n /// Iterates over each child of the given item.\n-pub fn each_child_of_item<F, G>(intr: Rc<IdentInterner>,\n-                               cdata: Cmd,\n-                               id: DefIndex,\n-                               get_crate_data: G,\n-                               callback: F) where\n-    F: FnMut(DefLike, ast::Name, ty::Visibility),\n-    G: FnMut(ast::CrateNum) -> Rc<CrateMetadata>,\n+pub fn each_child_of_item<F, G>(cdata: Cmd, id: DefIndex, get_crate_data: G, callback: F)\n+    where F: FnMut(DefLike, ast::Name, ty::Visibility),\n+          G: FnMut(ast::CrateNum) -> Rc<CrateMetadata>,\n {\n     // Find the item.\n     let item_doc = match cdata.get_item(id) {\n         None => return,\n         Some(item_doc) => item_doc,\n     };\n \n-    each_child_of_item_or_crate(intr,\n-                                cdata,\n-                                item_doc,\n-                                get_crate_data,\n-                                callback)\n+    each_child_of_item_or_crate(cdata, item_doc, get_crate_data, callback)\n }\n \n /// Iterates over all the top-level crate items.\n-pub fn each_top_level_item_of_crate<F, G>(intr: Rc<IdentInterner>,\n-                                          cdata: Cmd,\n-                                          get_crate_data: G,\n-                                          callback: F) where\n-    F: FnMut(DefLike, ast::Name, ty::Visibility),\n-    G: FnMut(ast::CrateNum) -> Rc<CrateMetadata>,\n+pub fn each_top_level_item_of_crate<F, G>(cdata: Cmd, get_crate_data: G, callback: F)\n+    where F: FnMut(DefLike, ast::Name, ty::Visibility),\n+          G: FnMut(ast::CrateNum) -> Rc<CrateMetadata>,\n {\n     let root_doc = rbml::Doc::new(cdata.data());\n     let misc_info_doc = reader::get_doc(root_doc, tag_misc_info);\n     let crate_items_doc = reader::get_doc(misc_info_doc,\n                                           tag_misc_info_crate_items);\n \n-    each_child_of_item_or_crate(intr,\n-                                cdata,\n+    each_child_of_item_or_crate(cdata,\n                                 crate_items_doc,\n                                 get_crate_data,\n                                 callback)\n }\n \n-pub fn get_item_name(intr: &IdentInterner, cdata: Cmd, id: DefIndex) -> ast::Name {\n-    item_name(intr, cdata.lookup_item(id))\n+pub fn get_item_name(cdata: Cmd, id: DefIndex) -> ast::Name {\n+    item_name(cdata.lookup_item(id))\n }\n \n-pub fn maybe_get_item_name(intr: &IdentInterner, cdata: Cmd, id: DefIndex)\n-                         -> Option<ast::Name> {\n-    maybe_item_name(intr, cdata.lookup_item(id))\n+pub fn maybe_get_item_name(cdata: Cmd, id: DefIndex) -> Option<ast::Name> {\n+    maybe_item_name(cdata.lookup_item(id))\n }\n \n pub fn maybe_get_item_ast<'a, 'tcx>(cdata: Cmd, tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefIndex)\n@@ -955,12 +932,9 @@ pub fn get_impl_items(cdata: Cmd, impl_id: DefIndex)\n     }).collect()\n }\n \n-pub fn get_trait_name(intr: Rc<IdentInterner>,\n-                      cdata: Cmd,\n-                      id: DefIndex)\n-                      -> ast::Name {\n+pub fn get_trait_name(cdata: Cmd, id: DefIndex) -> ast::Name {\n     let doc = cdata.lookup_item(id);\n-    item_name(&intr, doc)\n+    item_name(doc)\n }\n \n pub fn is_static_method(cdata: Cmd, id: DefIndex) -> bool {\n@@ -973,10 +947,7 @@ pub fn is_static_method(cdata: Cmd, id: DefIndex) -> bool {\n     }\n }\n \n-pub fn get_impl_or_trait_item<'a, 'tcx>(intr: Rc<IdentInterner>,\n-                                        cdata: Cmd,\n-                                        id: DefIndex,\n-                                        tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+pub fn get_impl_or_trait_item<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                         -> Option<ty::ImplOrTraitItem<'tcx>> {\n     let item_doc = cdata.lookup_item(id);\n \n@@ -993,7 +964,7 @@ pub fn get_impl_or_trait_item<'a, 'tcx>(intr: Rc<IdentInterner>,\n         _ => ImplContainer(container_id),\n     };\n \n-    let name = item_name(&intr, item_doc);\n+    let name = item_name(item_doc);\n     let vis = item_visibility(item_doc);\n     let defaultness = item_defaultness(item_doc);\n \n@@ -1068,8 +1039,7 @@ pub fn get_item_variances(cdata: Cmd, id: DefIndex) -> ty::ItemVariances {\n     Decodable::decode(&mut decoder).unwrap()\n }\n \n-pub fn get_provided_trait_methods<'a, 'tcx>(intr: Rc<IdentInterner>,\n-                                            cdata: Cmd,\n+pub fn get_provided_trait_methods<'a, 'tcx>(cdata: Cmd,\n                                             id: DefIndex,\n                                             tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                             -> Vec<Rc<ty::Method<'tcx>>> {\n@@ -1080,10 +1050,7 @@ pub fn get_provided_trait_methods<'a, 'tcx>(intr: Rc<IdentInterner>,\n         let mth = cdata.lookup_item(did.index);\n \n         if item_sort(mth) == Some('p') {\n-            let trait_item = get_impl_or_trait_item(intr.clone(),\n-                                                    cdata,\n-                                                    did.index,\n-                                                    tcx);\n+            let trait_item = get_impl_or_trait_item(cdata, did.index, tcx);\n             if let Some(ty::MethodTraitItem(ref method)) = trait_item {\n                 Some((*method).clone())\n             } else {\n@@ -1095,10 +1062,7 @@ pub fn get_provided_trait_methods<'a, 'tcx>(intr: Rc<IdentInterner>,\n     }).collect()\n }\n \n-pub fn get_associated_consts<'a, 'tcx>(intr: Rc<IdentInterner>,\n-                                       cdata: Cmd,\n-                                       id: DefIndex,\n-                                       tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+pub fn get_associated_consts<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                        -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n     let item = cdata.lookup_item(id);\n \n@@ -1109,10 +1073,7 @@ pub fn get_associated_consts<'a, 'tcx>(intr: Rc<IdentInterner>,\n \n             match item_sort(ac_doc) {\n                 Some('C') | Some('c') => {\n-                    let trait_item = get_impl_or_trait_item(intr.clone(),\n-                                                            cdata,\n-                                                            did.index,\n-                                                            tcx);\n+                    let trait_item = get_impl_or_trait_item(cdata, did.index, tcx);\n                     if let Some(ty::ConstTraitItem(ref ac)) = trait_item {\n                         Some((*ac).clone())\n                     } else {\n@@ -1180,14 +1141,13 @@ fn struct_field_family_to_visibility(family: Family) -> ty::Visibility {\n     }\n }\n \n-pub fn get_struct_field_names(intr: &IdentInterner, cdata: Cmd, id: DefIndex)\n-    -> Vec<ast::Name> {\n+pub fn get_struct_field_names(cdata: Cmd, id: DefIndex) -> Vec<ast::Name> {\n     let item = cdata.lookup_item(id);\n     let mut index = 0;\n     reader::tagged_docs(item, tag_item_field).map(|an_item| {\n-        item_name(intr, an_item)\n+        item_name(an_item)\n     }).chain(reader::tagged_docs(item, tag_item_unnamed_field).map(|_| {\n-        let name = intr.intern(&index.to_string());\n+        let name = token::with_ident_interner(|interner| interner.intern(index.to_string()));\n         index += 1;\n         name\n     })).collect()\n@@ -1503,12 +1463,12 @@ pub fn get_plugin_registrar_fn(data: &[u8]) -> Option<DefIndex> {\n         .map(|doc| DefIndex::from_u32(reader::doc_as_u32(doc)))\n }\n \n-pub fn each_exported_macro<F>(data: &[u8], intr: &IdentInterner, mut f: F) where\n+pub fn each_exported_macro<F>(data: &[u8], mut f: F) where\n     F: FnMut(ast::Name, Vec<ast::Attribute>, Span, String) -> bool,\n {\n     let macros = reader::get_doc(rbml::Doc::new(data), tag_macro_defs);\n     for macro_doc in reader::tagged_docs(macros, tag_macro_def) {\n-        let name = item_name(intr, macro_doc);\n+        let name = item_name(macro_doc);\n         let attrs = get_attributes(macro_doc);\n         let span = get_macro_span(macro_doc);\n         let body = reader::get_doc(macro_doc, tag_macro_def_body);"}, {"sha": "46813d957dce3b58c5b4268592497aed9ce7aefc", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b7fb80e1c05bee176ea68d21e19a352a106c968/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7fb80e1c05bee176ea68d21e19a352a106c968/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=0b7fb80e1c05bee176ea68d21e19a352a106c968", "patch": "@@ -81,7 +81,7 @@ pub struct UniqueTypeId(ast::Name);\n // UniqueTypeIds.\n pub struct TypeMap<'tcx> {\n     // The UniqueTypeIds created so far\n-    unique_id_interner: Interner<Rc<String>>,\n+    unique_id_interner: Interner,\n     // A map from UniqueTypeId to debuginfo metadata for that type. This is a 1:1 mapping.\n     unique_id_to_metadata: FnvHashMap<UniqueTypeId, DIType>,\n     // A map from types to debuginfo metadata. This is a N:1 mapping.\n@@ -313,7 +313,7 @@ impl<'tcx> TypeMap<'tcx> {\n         // Trim to size before storing permanently\n         unique_type_id.shrink_to_fit();\n \n-        let key = self.unique_id_interner.intern(Rc::new(unique_type_id));\n+        let key = self.unique_id_interner.intern(unique_type_id);\n         self.type_to_unique_id.insert(type_, UniqueTypeId(key));\n \n         return UniqueTypeId(key);\n@@ -383,7 +383,7 @@ impl<'tcx> TypeMap<'tcx> {\n         let enum_variant_type_id = format!(\"{}::{}\",\n                                            &self.get_unique_type_id_as_string(enum_type_id),\n                                            variant_name);\n-        let interner_key = self.unique_id_interner.intern(Rc::new(enum_variant_type_id));\n+        let interner_key = self.unique_id_interner.intern(enum_variant_type_id);\n         UniqueTypeId(interner_key)\n     }\n }"}, {"sha": "8b8e658533ed09db43dad823f5e6914d7901ef2c", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b7fb80e1c05bee176ea68d21e19a352a106c968/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7fb80e1c05bee176ea68d21e19a352a106c968/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=0b7fb80e1c05bee176ea68d21e19a352a106c968", "patch": "@@ -32,7 +32,6 @@ use rustc::dep_graph::DepNode;\n use std::hash::{Hash, Hasher};\n use syntax::ast::{self, NodeId};\n use syntax::{attr,errors};\n-use syntax::parse::token;\n use type_of;\n use glue;\n use abi::{Abi, FnType};\n@@ -605,8 +604,8 @@ fn push_type_params<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     for projection in projections {\n         let projection = projection.skip_binder();\n-        let name = token::get_ident_interner().get(projection.projection_ty.item_name);\n-        output.push_str(&name[..]);\n+        let name = &projection.projection_ty.item_name.as_str();\n+        output.push_str(name);\n         output.push_str(\"=\");\n         push_unique_type_name(tcx, projection.ty, output);\n         output.push_str(\", \");"}, {"sha": "49a3991ecbe0bfb7b1a51d74bb11c1fd2b6d65e7", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b7fb80e1c05bee176ea68d21e19a352a106c968/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7fb80e1c05bee176ea68d21e19a352a106c968/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=0b7fb80e1c05bee176ea68d21e19a352a106c968", "patch": "@@ -24,7 +24,6 @@ use rustc_metadata::cstore::CStore;\n \n use syntax::{ast, codemap};\n use syntax::feature_gate::UnstableFeatures;\n-use syntax::parse::token;\n use errors;\n use errors::emitter::ColorConfig;\n \n@@ -136,7 +135,7 @@ pub fn run_core(search_paths: SearchPaths,\n \n     let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();\n-    let cstore = Rc::new(CStore::new(&dep_graph, token::get_ident_interner()));\n+    let cstore = Rc::new(CStore::new(&dep_graph));\n     let sess = session::build_session_(sessopts, &dep_graph, cpath, diagnostic_handler,\n                                        codemap, cstore.clone());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));"}, {"sha": "bb69ba6e568d573d7618602ad2f7d29ee5c52733", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b7fb80e1c05bee176ea68d21e19a352a106c968/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7fb80e1c05bee176ea68d21e19a352a106c968/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=0b7fb80e1c05bee176ea68d21e19a352a106c968", "patch": "@@ -37,7 +37,6 @@ use rustc_resolve::MakeGlobMap;\n use syntax::codemap::CodeMap;\n use errors;\n use errors::emitter::ColorConfig;\n-use syntax::parse::token;\n \n use core;\n use clean;\n@@ -82,7 +81,7 @@ pub fn run(input: &str,\n \n     let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();\n-    let cstore = Rc::new(CStore::new(&dep_graph, token::get_ident_interner()));\n+    let cstore = Rc::new(CStore::new(&dep_graph));\n     let sess = session::build_session_(sessopts,\n                                        &dep_graph,\n                                        Some(input_path.clone()),\n@@ -239,7 +238,7 @@ fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n     let diagnostic_handler = errors::Handler::with_emitter(true, false, box emitter);\n \n     let dep_graph = DepGraph::new(false);\n-    let cstore = Rc::new(CStore::new(&dep_graph, token::get_ident_interner()));\n+    let cstore = Rc::new(CStore::new(&dep_graph));\n     let sess = session::build_session_(sessopts,\n                                        &dep_graph,\n                                        None,"}, {"sha": "4656ba03e21c3e05d620855435942a31ac0a55b9", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b7fb80e1c05bee176ea68d21e19a352a106c968/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7fb80e1c05bee176ea68d21e19a352a106c968/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=0b7fb80e1c05bee176ea68d21e19a352a106c968", "patch": "@@ -259,7 +259,6 @@ pub struct Parser<'a> {\n     pub restrictions: Restrictions,\n     pub quote_depth: usize, // not (yet) related to the quasiquoter\n     pub reader: Box<Reader+'a>,\n-    pub interner: Rc<token::IdentInterner>,\n     /// The set of seen errors about obsolete syntax. Used to suppress\n     /// extra detail when the same error is seen twice\n     pub obsolete_set: HashSet<ObsoleteSyntax>,\n@@ -356,7 +355,6 @@ impl<'a> Parser<'a> {\n \n         Parser {\n             reader: rdr,\n-            interner: token::get_ident_interner(),\n             sess: sess,\n             cfg: cfg,\n             token: tok0.tok,"}, {"sha": "ab7ed223bb31820e23c59b7f2f68f84ce07e1e5b", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0b7fb80e1c05bee176ea68d21e19a352a106c968/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7fb80e1c05bee176ea68d21e19a352a106c968/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=0b7fb80e1c05bee176ea68d21e19a352a106c968", "patch": "@@ -17,11 +17,11 @@ pub use self::Token::*;\n use ast::{self, BinOpKind};\n use ext::mtwt;\n use ptr::P;\n-use util::interner::{RcStr, StrInterner};\n-use util::interner;\n+use util::interner::Interner;\n use tokenstream;\n \n use serialize::{Decodable, Decoder, Encodable, Encoder};\n+use std::cell::RefCell;\n use std::fmt;\n use std::ops::Deref;\n use std::rc::Rc;\n@@ -397,7 +397,7 @@ macro_rules! declare_keywords {(\n     }\n \n     fn mk_fresh_ident_interner() -> IdentInterner {\n-        interner::StrInterner::prefill(&[$($string,)*])\n+        Interner::prefill(&[$($string,)*])\n     }\n }}\n \n@@ -473,22 +473,25 @@ declare_keywords! {\n }\n \n // looks like we can get rid of this completely...\n-pub type IdentInterner = StrInterner;\n+pub type IdentInterner = Interner;\n \n // if an interner exists in TLS, return it. Otherwise, prepare a\n // fresh one.\n // FIXME(eddyb) #8726 This should probably use a thread-local reference.\n-pub fn get_ident_interner() -> Rc<IdentInterner> {\n-    thread_local!(static KEY: Rc<::parse::token::IdentInterner> = {\n-        Rc::new(mk_fresh_ident_interner())\n+pub fn with_ident_interner<T, F: FnOnce(&mut IdentInterner) -> T>(f: F) -> T {\n+    thread_local!(static KEY: RefCell<IdentInterner> = {\n+        RefCell::new(mk_fresh_ident_interner())\n     });\n-    KEY.with(|k| k.clone())\n+    KEY.with(|interner| f(&mut *interner.borrow_mut()))\n }\n \n /// Reset the ident interner to its initial state.\n pub fn reset_ident_interner() {\n-    let interner = get_ident_interner();\n-    interner.reset(mk_fresh_ident_interner());\n+    with_ident_interner(|interner| *interner = mk_fresh_ident_interner());\n+}\n+\n+pub fn clear_ident_interner() {\n+    with_ident_interner(|interner| *interner = IdentInterner::new());\n }\n \n /// Represents a string stored in the thread-local interner. Because the\n@@ -502,28 +505,27 @@ pub fn reset_ident_interner() {\n /// somehow.\n #[derive(Clone, PartialEq, Hash, PartialOrd, Eq, Ord)]\n pub struct InternedString {\n-    string: RcStr,\n+    string: Rc<String>,\n }\n \n impl InternedString {\n     #[inline]\n     pub fn new(string: &'static str) -> InternedString {\n         InternedString {\n-            string: RcStr::new(string),\n+            string: Rc::new(string.to_owned()),\n         }\n     }\n \n     #[inline]\n-    fn new_from_rc_str(string: RcStr) -> InternedString {\n+    fn new_from_rc_str(string: Rc<String>) -> InternedString {\n         InternedString {\n             string: string,\n         }\n     }\n \n     #[inline]\n     pub fn new_from_name(name: ast::Name) -> InternedString {\n-        let interner = get_ident_interner();\n-        InternedString::new_from_rc_str(interner.get(name))\n+        with_ident_interner(|interner| InternedString::new_from_rc_str(interner.get(name)))\n     }\n }\n \n@@ -611,13 +613,13 @@ pub fn intern_and_get_ident(s: &str) -> InternedString {\n /// Maps a string to its interned representation.\n #[inline]\n pub fn intern(s: &str) -> ast::Name {\n-    get_ident_interner().intern(s)\n+    with_ident_interner(|interner| interner.intern(s))\n }\n \n /// gensym's a new usize, using the current interner.\n #[inline]\n pub fn gensym(s: &str) -> ast::Name {\n-    get_ident_interner().gensym(s)\n+    with_ident_interner(|interner| interner.gensym(s))\n }\n \n /// Maps a string to an identifier with an empty syntax context.\n@@ -636,8 +638,7 @@ pub fn gensym_ident(s: &str) -> ast::Ident {\n // note that this guarantees that str_ptr_eq(ident_to_string(src),interner_get(fresh_name(src)));\n // that is, that the new name and the old one are connected to ptr_eq strings.\n pub fn fresh_name(src: ast::Ident) -> ast::Name {\n-    let interner = get_ident_interner();\n-    interner.gensym_copy(src.name)\n+    with_ident_interner(|interner| interner.gensym_copy(src.name))\n     // following: debug version. Could work in final except that it's incompatible with\n     // good error messages and uses of struct names in ambiguous could-be-binding\n     // locations. Also definitely destroys the guarantee given above about ptr_eq."}, {"sha": "6bb409715aa39ce999a502b8fde12b3bde60748c", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 49, "deletions": 234, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/0b7fb80e1c05bee176ea68d21e19a352a106c968/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7fb80e1c05bee176ea68d21e19a352a106c968/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=0b7fb80e1c05bee176ea68d21e19a352a106c968", "patch": "@@ -15,212 +15,72 @@\n use ast::Name;\n \n use std::borrow::Borrow;\n-use std::cell::RefCell;\n-use std::cmp::Ordering;\n use std::collections::HashMap;\n-use std::fmt;\n-use std::hash::Hash;\n-use std::ops::Deref;\n use std::rc::Rc;\n \n-pub struct Interner<T> {\n-    map: RefCell<HashMap<T, Name>>,\n-    vect: RefCell<Vec<T> >,\n-}\n-\n-// when traits can extend traits, we should extend index<Name,T> to get []\n-impl<T: Eq + Hash + Clone + 'static> Interner<T> {\n-    pub fn new() -> Interner<T> {\n-        Interner {\n-            map: RefCell::new(HashMap::new()),\n-            vect: RefCell::new(Vec::new()),\n-        }\n-    }\n-\n-    pub fn prefill(init: &[T]) -> Interner<T> {\n-        let rv = Interner::new();\n-        for v in init {\n-            rv.intern((*v).clone());\n-        }\n-        rv\n-    }\n-\n-    pub fn intern(&self, val: T) -> Name {\n-        let mut map = self.map.borrow_mut();\n-        if let Some(&idx) = (*map).get(&val) {\n-            return idx;\n-        }\n-\n-        let mut vect = self.vect.borrow_mut();\n-        let new_idx = Name((*vect).len() as u32);\n-        (*map).insert(val.clone(), new_idx);\n-        (*vect).push(val);\n-        new_idx\n-    }\n-\n-    pub fn gensym(&self, val: T) -> Name {\n-        let mut vect = self.vect.borrow_mut();\n-        let new_idx = Name((*vect).len() as u32);\n-        // leave out of .map to avoid colliding\n-        (*vect).push(val);\n-        new_idx\n-    }\n-\n-    pub fn get(&self, idx: Name) -> T {\n-        let vect = self.vect.borrow();\n-        (*vect)[idx.0 as usize].clone()\n-    }\n-\n-    pub fn len(&self) -> usize {\n-        let vect = self.vect.borrow();\n-        (*vect).len()\n-    }\n-\n-    pub fn find<Q: ?Sized>(&self, val: &Q) -> Option<Name>\n-    where T: Borrow<Q>, Q: Eq + Hash {\n-        let map = self.map.borrow();\n-        match (*map).get(val) {\n-            Some(v) => Some(*v),\n-            None => None,\n-        }\n-    }\n-\n-    pub fn clear(&self) {\n-        *self.map.borrow_mut() = HashMap::new();\n-        *self.vect.borrow_mut() = Vec::new();\n-    }\n-}\n-\n-#[derive(Clone, PartialEq, Hash, PartialOrd)]\n-pub struct RcStr {\n-    string: Rc<String>,\n-}\n-\n-impl RcStr {\n-    pub fn new(string: &str) -> RcStr {\n-        RcStr {\n-            string: Rc::new(string.to_string()),\n-        }\n-    }\n-}\n-\n-impl Eq for RcStr {}\n-\n-impl Ord for RcStr {\n-    fn cmp(&self, other: &RcStr) -> Ordering {\n-        self[..].cmp(&other[..])\n-    }\n-}\n-\n-impl fmt::Debug for RcStr {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self[..].fmt(f)\n-    }\n-}\n-\n-impl fmt::Display for RcStr {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self[..].fmt(f)\n-    }\n-}\n+#[derive(PartialEq, Eq, Hash)]\n+struct RcStr(Rc<String>);\n \n impl Borrow<str> for RcStr {\n     fn borrow(&self) -> &str {\n-        &self.string[..]\n+        &self.0\n     }\n }\n \n-impl Deref for RcStr {\n-    type Target = str;\n-\n-    fn deref(&self) -> &str { &self.string[..] }\n-}\n-\n-/// A StrInterner differs from Interner<String> in that it accepts\n-/// &str rather than RcStr, resulting in less allocation.\n-pub struct StrInterner {\n-    map: RefCell<HashMap<RcStr, Name>>,\n-    vect: RefCell<Vec<RcStr> >,\n+#[derive(Default)]\n+pub struct Interner {\n+    names: HashMap<RcStr, Name>,\n+    strings: Vec<Rc<String>>,\n }\n \n /// When traits can extend traits, we should extend index<Name,T> to get []\n-impl StrInterner {\n-    pub fn new() -> StrInterner {\n-        StrInterner {\n-            map: RefCell::new(HashMap::new()),\n-            vect: RefCell::new(Vec::new()),\n-        }\n+impl Interner {\n+    pub fn new() -> Self {\n+        Interner::default()\n     }\n \n-    pub fn prefill(init: &[&str]) -> StrInterner {\n-        let rv = StrInterner::new();\n-        for &v in init { rv.intern(v); }\n-        rv\n-    }\n-\n-    pub fn intern(&self, val: &str) -> Name {\n-        let mut map = self.map.borrow_mut();\n-        if let Some(&idx) = map.get(val) {\n-            return idx;\n+    pub fn prefill(init: &[&str]) -> Self {\n+        let mut this = Interner::new();\n+        for &string in init {\n+            this.intern(string);\n         }\n-\n-        let new_idx = Name(self.len() as u32);\n-        let val = RcStr::new(val);\n-        map.insert(val.clone(), new_idx);\n-        self.vect.borrow_mut().push(val);\n-        new_idx\n-    }\n-\n-    pub fn gensym(&self, val: &str) -> Name {\n-        let new_idx = Name(self.len() as u32);\n-        // leave out of .map to avoid colliding\n-        self.vect.borrow_mut().push(RcStr::new(val));\n-        new_idx\n+        this\n     }\n \n-    // I want these gensyms to share name pointers\n-    // with existing entries. This would be automatic,\n-    // except that the existing gensym creates its\n-    // own managed ptr using to_managed. I think that\n-    // adding this utility function is the most\n-    // lightweight way to get what I want, though not\n-    // necessarily the cleanest.\n-\n-    /// Create a gensym with the same name as an existing\n-    /// entry.\n-    pub fn gensym_copy(&self, idx : Name) -> Name {\n-        let new_idx = Name(self.len() as u32);\n-        // leave out of map to avoid colliding\n-        let mut vect = self.vect.borrow_mut();\n-        let existing = (*vect)[idx.0 as usize].clone();\n-        vect.push(existing);\n-        new_idx\n-    }\n+    pub fn intern<T: Borrow<str> + Into<String>>(&mut self, string: T) -> Name {\n+        if let Some(&name) = self.names.get(string.borrow()) {\n+            return name;\n+        }\n \n-    pub fn get(&self, idx: Name) -> RcStr {\n-        (*self.vect.borrow())[idx.0 as usize].clone()\n+        let name = Name(self.strings.len() as u32);\n+        let string = Rc::new(string.into());\n+        self.strings.push(string.clone());\n+        self.names.insert(RcStr(string), name);\n+        name\n     }\n \n-    pub fn len(&self) -> usize {\n-        self.vect.borrow().len()\n+    pub fn gensym(&mut self, string: &str) -> Name {\n+        let gensym = Name(self.strings.len() as u32);\n+        // leave out of `names` to avoid colliding\n+        self.strings.push(Rc::new(string.to_owned()));\n+        gensym\n     }\n \n-    pub fn find<Q: ?Sized>(&self, val: &Q) -> Option<Name>\n-    where RcStr: Borrow<Q>, Q: Eq + Hash {\n-        match (*self.map.borrow()).get(val) {\n-            Some(v) => Some(*v),\n-            None => None,\n-        }\n+    /// Create a gensym with the same name as an existing entry.\n+    pub fn gensym_copy(&mut self, name: Name) -> Name {\n+        let gensym = Name(self.strings.len() as u32);\n+        // leave out of `names` to avoid colliding\n+        let string = self.strings[name.0 as usize].clone();\n+        self.strings.push(string);\n+        gensym\n     }\n \n-    pub fn clear(&self) {\n-        *self.map.borrow_mut() = HashMap::new();\n-        *self.vect.borrow_mut() = Vec::new();\n+    pub fn get(&self, name: Name) -> Rc<String> {\n+        self.strings[name.0 as usize].clone()\n     }\n \n-    pub fn reset(&self, other: StrInterner) {\n-        *self.map.borrow_mut() = other.map.into_inner();\n-        *self.vect.borrow_mut() = other.vect.into_inner();\n+    pub fn find(&self, string: &str) -> Option<Name> {\n+        self.names.get(string).cloned()\n     }\n }\n \n@@ -230,53 +90,8 @@ mod tests {\n     use ast::Name;\n \n     #[test]\n-    #[should_panic]\n-    fn i1 () {\n-        let i : Interner<RcStr> = Interner::new();\n-        i.get(Name(13));\n-    }\n-\n-    #[test]\n-    fn interner_tests () {\n-        let i : Interner<RcStr> = Interner::new();\n-        // first one is zero:\n-        assert_eq!(i.intern(RcStr::new(\"dog\")), Name(0));\n-        // re-use gets the same entry:\n-        assert_eq!(i.intern(RcStr::new(\"dog\")), Name(0));\n-        // different string gets a different #:\n-        assert_eq!(i.intern(RcStr::new(\"cat\")), Name(1));\n-        assert_eq!(i.intern(RcStr::new(\"cat\")), Name(1));\n-        // dog is still at zero\n-        assert_eq!(i.intern(RcStr::new(\"dog\")), Name(0));\n-        // gensym gets 3\n-        assert_eq!(i.gensym(RcStr::new(\"zebra\") ), Name(2));\n-        // gensym of same string gets new number :\n-        assert_eq!(i.gensym (RcStr::new(\"zebra\") ), Name(3));\n-        // gensym of *existing* string gets new number:\n-        assert_eq!(i.gensym(RcStr::new(\"dog\")), Name(4));\n-        assert_eq!(i.get(Name(0)), RcStr::new(\"dog\"));\n-        assert_eq!(i.get(Name(1)), RcStr::new(\"cat\"));\n-        assert_eq!(i.get(Name(2)), RcStr::new(\"zebra\"));\n-        assert_eq!(i.get(Name(3)), RcStr::new(\"zebra\"));\n-        assert_eq!(i.get(Name(4)), RcStr::new(\"dog\"));\n-    }\n-\n-    #[test]\n-    fn i3 () {\n-        let i : Interner<RcStr> = Interner::prefill(&[\n-            RcStr::new(\"Alan\"),\n-            RcStr::new(\"Bob\"),\n-            RcStr::new(\"Carol\")\n-        ]);\n-        assert_eq!(i.get(Name(0)), RcStr::new(\"Alan\"));\n-        assert_eq!(i.get(Name(1)), RcStr::new(\"Bob\"));\n-        assert_eq!(i.get(Name(2)), RcStr::new(\"Carol\"));\n-        assert_eq!(i.intern(RcStr::new(\"Bob\")), Name(1));\n-    }\n-\n-    #[test]\n-    fn string_interner_tests() {\n-        let i : StrInterner = StrInterner::new();\n+    fn interner_tests() {\n+        let mut i: Interner = Interner::new();\n         // first one is zero:\n         assert_eq!(i.intern(\"dog\"), Name(0));\n         // re-use gets the same entry:\n@@ -294,13 +109,13 @@ mod tests {\n         assert_eq!(i.gensym(\"dog\"), Name(4));\n         // gensym tests again with gensym_copy:\n         assert_eq!(i.gensym_copy(Name(2)), Name(5));\n-        assert_eq!(i.get(Name(5)), RcStr::new(\"zebra\"));\n+        assert_eq!(*i.get(Name(5)), \"zebra\");\n         assert_eq!(i.gensym_copy(Name(2)), Name(6));\n-        assert_eq!(i.get(Name(6)), RcStr::new(\"zebra\"));\n-        assert_eq!(i.get(Name(0)), RcStr::new(\"dog\"));\n-        assert_eq!(i.get(Name(1)), RcStr::new(\"cat\"));\n-        assert_eq!(i.get(Name(2)), RcStr::new(\"zebra\"));\n-        assert_eq!(i.get(Name(3)), RcStr::new(\"zebra\"));\n-        assert_eq!(i.get(Name(4)), RcStr::new(\"dog\"));\n+        assert_eq!(*i.get(Name(6)), \"zebra\");\n+        assert_eq!(*i.get(Name(0)), \"dog\");\n+        assert_eq!(*i.get(Name(1)), \"cat\");\n+        assert_eq!(*i.get(Name(2)), \"zebra\");\n+        assert_eq!(*i.get(Name(3)), \"zebra\");\n+        assert_eq!(*i.get(Name(4)), \"dog\");\n     }\n }"}, {"sha": "2e90b51843263b48ec9f84938050e8713879b414", "filename": "src/test/run-make/execution-engine/test.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b7fb80e1c05bee176ea68d21e19a352a106c968/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7fb80e1c05bee176ea68d21e19a352a106c968/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs?ref=0b7fb80e1c05bee176ea68d21e19a352a106c968", "patch": "@@ -30,18 +30,16 @@ use std::thread::Builder;\n \n use rustc::dep_graph::DepGraph;\n use rustc::hir::map as ast_map;\n-use rustc::middle::cstore::{CrateStore, LinkagePreference};\n+use rustc::middle::cstore::LinkagePreference;\n use rustc::ty;\n use rustc::session::config::{self, basic_options, build_configuration, Input, Options};\n use rustc::session::build_session;\n use rustc_driver::{driver, abort_on_err};\n use rustc_resolve::MakeGlobMap;\n-use rustc_metadata::creader::read_local_crates;\n use rustc_metadata::cstore::CStore;\n use libc::c_void;\n \n use rustc_errors::registry::Registry;\n-use syntax::parse::token;\n \n fn main() {\n     // Currently trips an assertion on i686-msvc, presumably because the support\n@@ -226,7 +224,7 @@ fn compile_program(input: &str, sysroot: PathBuf)\n     let handle = thread.spawn(move || {\n         let opts = build_exec_options(sysroot);\n         let dep_graph = DepGraph::new(opts.build_dep_graph());\n-        let cstore = Rc::new(CStore::new(&dep_graph, token::get_ident_interner()));\n+        let cstore = Rc::new(CStore::new(&dep_graph));\n         let sess = build_session(opts,\n                                  &dep_graph,\n                                  None,"}, {"sha": "d5220316a20ff083381235e0bd499cff04721629", "filename": "src/test/run-make/issue-19371/foo.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b7fb80e1c05bee176ea68d21e19a352a106c968/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7fb80e1c05bee176ea68d21e19a352a106c968/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs?ref=0b7fb80e1c05bee176ea68d21e19a352a106c968", "patch": "@@ -23,7 +23,6 @@ use rustc::session::config::{basic_options, build_configuration, Input, OutputTy\n use rustc_driver::driver::{compile_input, CompileController, anon_src};\n use rustc_metadata::cstore::CStore;\n use rustc_errors::registry::Registry;\n-use syntax::parse::token;\n \n use std::path::PathBuf;\n use std::rc::Rc;\n@@ -57,7 +56,7 @@ fn basic_sess(sysroot: PathBuf) -> (Session, Rc<CStore>) {\n \n     let descriptions = Registry::new(&rustc::DIAGNOSTICS);\n     let dep_graph = DepGraph::new(opts.build_dep_graph());\n-    let cstore = Rc::new(CStore::new(&dep_graph, token::get_ident_interner()));\n+    let cstore = Rc::new(CStore::new(&dep_graph));\n     let sess = build_session(opts, &dep_graph, None, descriptions, cstore.clone());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     (sess, cstore)"}]}