{"sha": "4a18324a4df6bc98bec0b54d35908d7a9cdc7c32", "node_id": "C_kwDOAAsO6NoAKDRhMTgzMjRhNGRmNmJjOThiZWMwYjU0ZDM1OTA4ZDdhOWNkYzdjMzI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-05T12:50:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-05T12:50:59Z"}, "message": "Auto merge of #111113 - scottmcm:assume-align-offset, r=thomcc\n\n`assume` the runtime range of `align_offset`\n\nFound when I saw code with `align_to` having extraneous checks.\n\nDemo that LLVM can't do this today: <https://rust.godbolt.org/z/6dnG749bq>\n\n(It's filed as https://github.com/llvm/llvm-project/issues/62502.)", "tree": {"sha": "28a764500f250517e2a1c4aebd9c10ada135229f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/28a764500f250517e2a1c4aebd9c10ada135229f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a18324a4df6bc98bec0b54d35908d7a9cdc7c32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a18324a4df6bc98bec0b54d35908d7a9cdc7c32", "html_url": "https://github.com/rust-lang/rust/commit/4a18324a4df6bc98bec0b54d35908d7a9cdc7c32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a18324a4df6bc98bec0b54d35908d7a9cdc7c32/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd9a7bf848e412c81e3045245acbd5a01641a610", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd9a7bf848e412c81e3045245acbd5a01641a610", "html_url": "https://github.com/rust-lang/rust/commit/dd9a7bf848e412c81e3045245acbd5a01641a610"}, {"sha": "a1e5c65aa451473d1614fc04cf3c0e67247a17f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1e5c65aa451473d1614fc04cf3c0e67247a17f1", "html_url": "https://github.com/rust-lang/rust/commit/a1e5c65aa451473d1614fc04cf3c0e67247a17f1"}], "stats": {"total": 93, "additions": 89, "deletions": 4}, "files": [{"sha": "ed0c05a68631945770f2c13b86194e36e11ced0c", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4a18324a4df6bc98bec0b54d35908d7a9cdc7c32/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a18324a4df6bc98bec0b54d35908d7a9cdc7c32/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=4a18324a4df6bc98bec0b54d35908d7a9cdc7c32", "patch": "@@ -107,6 +107,7 @@\n #![feature(const_arguments_as_str)]\n #![feature(const_array_from_ref)]\n #![feature(const_array_into_iter_constructors)]\n+#![feature(const_assume)]\n #![feature(const_bigint_helper_methods)]\n #![feature(const_black_box)]\n #![feature(const_caller_location)]"}, {"sha": "4737ff5d756d1bb0aa91e3dc0862be33db347b13", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4a18324a4df6bc98bec0b54d35908d7a9cdc7c32/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a18324a4df6bc98bec0b54d35908d7a9cdc7c32/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=4a18324a4df6bc98bec0b54d35908d7a9cdc7c32", "patch": "@@ -1632,8 +1632,8 @@ pub(crate) const unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usiz\n     // FIXME(#75598): Direct use of these intrinsics improves codegen significantly at opt-level <=\n     // 1, where the method versions of these operations are not inlined.\n     use intrinsics::{\n-        cttz_nonzero, exact_div, mul_with_overflow, unchecked_rem, unchecked_shl, unchecked_shr,\n-        unchecked_sub, wrapping_add, wrapping_mul, wrapping_sub,\n+        assume, cttz_nonzero, exact_div, mul_with_overflow, unchecked_rem, unchecked_shl,\n+        unchecked_shr, unchecked_sub, wrapping_add, wrapping_mul, wrapping_sub,\n     };\n \n     /// Calculate multiplicative modular inverse of `x` modulo `m`.\n@@ -1724,12 +1724,18 @@ pub(crate) const unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usiz\n         // in a branch-free way and then bitwise-OR it with whatever result the `-p mod a`\n         // computation produces.\n \n+        let aligned_address = wrapping_add(addr, a_minus_one) & wrapping_sub(0, a);\n+        let byte_offset = wrapping_sub(aligned_address, addr);\n+        // FIXME: Remove the assume after <https://github.com/llvm/llvm-project/issues/62502>\n+        // SAFETY: Masking by `-a` can only affect the low bits, and thus cannot have reduced\n+        // the value by more than `a-1`, so even though the intermediate values might have\n+        // wrapped, the byte_offset is always in `[0, a)`.\n+        unsafe { assume(byte_offset < a) };\n+\n         // SAFETY: `stride == 0` case has been handled by the special case above.\n         let addr_mod_stride = unsafe { unchecked_rem(addr, stride) };\n \n         return if addr_mod_stride == 0 {\n-            let aligned_address = wrapping_add(addr, a_minus_one) & wrapping_sub(0, a);\n-            let byte_offset = wrapping_sub(aligned_address, addr);\n             // SAFETY: `stride` is non-zero. This is guaranteed to divide exactly as well, because\n             // addr has been verified to be aligned to the original type\u2019s alignment requirements.\n             unsafe { exact_div(byte_offset, stride) }"}, {"sha": "7c7660c5a55ab759153e420aca30d1eefc706600", "filename": "tests/codegen/align-offset.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/4a18324a4df6bc98bec0b54d35908d7a9cdc7c32/tests%2Fcodegen%2Falign-offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a18324a4df6bc98bec0b54d35908d7a9cdc7c32/tests%2Fcodegen%2Falign-offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Falign-offset.rs?ref=4a18324a4df6bc98bec0b54d35908d7a9cdc7c32", "patch": "@@ -0,0 +1,78 @@\n+// compile-flags: -O\n+// min-llvm-version: 15.0 (because we're using opaque pointers)\n+// ignore-debug (debug assertions in `slice::from_raw_parts` block optimizations)\n+\n+#![crate_type = \"lib\"]\n+\n+// CHECK-LABEL: @align8\n+#[no_mangle]\n+pub fn align8(p: *const u8) -> bool {\n+    // CHECK: ret i1 true\n+    p.align_offset(8) < 8\n+}\n+\n+#[repr(align(4))]\n+pub struct Align4([u8; 4]);\n+\n+// CHECK-LABEL: @align_to4\n+#[no_mangle]\n+pub fn align_to4(x: &[u8]) -> bool {\n+    // CHECK: ret i1 true\n+    let (prefix, _middle, suffix) = unsafe { x.align_to::<Align4>() };\n+    prefix.len() < 4 && suffix.len() < 4\n+}\n+\n+// CHECK-LABEL: @align_offset_byte_ptr(ptr{{.+}}%ptr)\n+#[no_mangle]\n+pub fn align_offset_byte_ptr(ptr: *const u8) -> usize {\n+    // CHECK: %[[ADDR:.+]] = ptrtoint ptr %ptr to [[USIZE:i[0-9]+]]\n+    // CHECK: %[[UP:.+]] = add [[USIZE]] %[[ADDR]], 31\n+    // CHECK: %[[ALIGNED:.+]] = and [[USIZE]] %[[UP]], -32\n+    // CHECK: %[[OFFSET:.+]] = sub [[USIZE]] %[[ALIGNED]], %[[ADDR]]\n+\n+    // Since we're offsetting a byte pointer, there's no further fixups\n+    // CHECK-NOT: shr\n+    // CHECK-NOT: div\n+    // CHECK-NOT: select\n+\n+    // CHECK: ret [[USIZE]] %[[OFFSET]]\n+    ptr.align_offset(32)\n+}\n+\n+// CHECK-LABEL: @align_offset_word_slice(ptr{{.+}}align 4{{.+}}%slice.0\n+#[no_mangle]\n+pub fn align_offset_word_slice(slice: &[Align4]) -> usize {\n+    // CHECK: %[[ADDR:.+]] = ptrtoint ptr %slice.0 to [[USIZE]]\n+    // CHECK: %[[UP:.+]] = add [[USIZE]] %[[ADDR]], 31\n+    // CHECK: %[[ALIGNED:.+]] = and [[USIZE]] %[[UP]], -32\n+    // CHECK: %[[BOFFSET:.+]] = sub [[USIZE]] %[[ALIGNED]], %[[ADDR]]\n+    // CHECK: %[[OFFSET:.+]] = lshr exact [[USIZE]] %[[BOFFSET]], 2\n+\n+    // Slices are known to be aligned, so we don't need the \"maybe -1\" path\n+    // CHECK-NOT: select\n+\n+    // CHECK: ret [[USIZE]] %[[OFFSET]]\n+    slice.as_ptr().align_offset(32)\n+}\n+\n+\n+// CHECK-LABEL: @align_offset_word_ptr(ptr{{.+}}%ptr\n+#[no_mangle]\n+pub fn align_offset_word_ptr(ptr: *const Align4) -> usize {\n+    // CHECK: %[[ADDR:.+]] = ptrtoint ptr %ptr to [[USIZE]]\n+    // CHECK: %[[UP:.+]] = add [[USIZE]] %[[ADDR]], 31\n+    // CHECK: %[[ALIGNED:.+]] = and [[USIZE]] %[[UP]], -32\n+    // CHECK: %[[BOFFSET:.+]] = sub [[USIZE]] %[[ALIGNED]], %[[ADDR]]\n+\n+    // While we can always get a *byte* offset that will work, if the original\n+    // pointer is unaligned it might be impossible to return an *element* offset\n+    // that will make it aligned. We want it to be a `select`, not a `br`, so\n+    // that the assembly will be branchless.\n+    // CHECK: %[[LOW:.+]] = and [[USIZE]] %[[ADDR]], 3\n+    // CHECK: %[[ORIGINAL_ALIGNED:.+]] = icmp eq [[USIZE]] %[[LOW]], 0\n+    // CHECK: %[[OFFSET:.+]] = lshr exact [[USIZE]] %[[BOFFSET]], 2\n+    // CHECK: %[[R:.+]] = select i1 %[[ORIGINAL_ALIGNED]], [[USIZE]] %[[OFFSET]], [[USIZE]] -1\n+\n+    // CHECK: ret [[USIZE]] %[[R]]\n+    ptr.align_offset(32)\n+}"}]}