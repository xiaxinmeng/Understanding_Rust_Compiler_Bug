{"sha": "b7e5112e88b8e73a5bff5a84f37f1d2a608e821c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3ZTUxMTJlODhiOGU3M2E1YmZmNWE4NGYzN2YxZDJhNjA4ZTgyMWM=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2015-12-29T21:37:34Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2016-03-14T22:04:37Z"}, "message": "Implement default associated type inheritance.\n\nThis commit leverages the specialization graph infrastructure to allow\nspecializing trait implementations to leave off associated types for\nwhich their parents have provided defaults.\n\nIt also modifies the type projection code to avoid projecting associated\ntypes unless either (1) all input types are fully known or (2) the\navailable associated type is \"final\", i.e. not marked `default`.\nThis restriction is required for soundness, due to examples like:\n\n```rust\ntrait Foo {\n    type Assoc;\n}\n\nimpl<T> Foo for T {\n    default type Assoc = ();\n}\n\nimpl Foo for u8 {\n    type Assoc = String;\n}\n\nfn generic<T>() -> <T as Foo>::Assoc {\n    () //~ ERROR\n}\n\nfn main() {\n    let s: String = generic::<u8>();\n    println!(\"{}\", s); // bad news\n}\n```", "tree": {"sha": "e53a74d0b0998fc2df36fbead6d2369cdb79842f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e53a74d0b0998fc2df36fbead6d2369cdb79842f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7e5112e88b8e73a5bff5a84f37f1d2a608e821c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7e5112e88b8e73a5bff5a84f37f1d2a608e821c", "html_url": "https://github.com/rust-lang/rust/commit/b7e5112e88b8e73a5bff5a84f37f1d2a608e821c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7e5112e88b8e73a5bff5a84f37f1d2a608e821c/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5dedbdaea4254a78c58c322f636ecd9175cb53fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/5dedbdaea4254a78c58c322f636ecd9175cb53fa", "html_url": "https://github.com/rust-lang/rust/commit/5dedbdaea4254a78c58c322f636ecd9175cb53fa"}], "stats": {"total": 98, "additions": 55, "deletions": 43}, "files": [{"sha": "dc279aae32cbb9d2decc3f2d9991c1dd9dc22d34", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 43, "deletions": 31, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/b7e5112e88b8e73a5bff5a84f37f1d2a608e821c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7e5112e88b8e73a5bff5a84f37f1d2a608e821c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=b7e5112e88b8e73a5bff5a84f37f1d2a608e821c", "patch": "@@ -11,6 +11,7 @@\n //! Code for projecting associated types out of trait references.\n \n use super::elaborate_predicates;\n+use super::get_impl_item_or_default;\n use super::report_overflow_error;\n use super::Obligation;\n use super::ObligationCause;\n@@ -23,8 +24,9 @@ use super::util;\n \n use middle::infer::{self, TypeOrigin};\n use middle::subst::Subst;\n-use middle::ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt};\n+use middle::ty::{self, ToPredicate, RegionEscape, HasTypeFlags, ToPolyTraitRef, Ty, TyCtxt};\n use middle::ty::fold::{TypeFoldable, TypeFolder};\n+use rustc_front::hir;\n use syntax::parse::token;\n use util::common::FN_OUTPUT_NAME;\n \n@@ -742,6 +744,28 @@ fn assemble_candidates_from_impls<'cx,'tcx>(\n \n     match vtable {\n         super::VtableImpl(data) => {\n+            if data.substs.types.needs_infer() {\n+                let assoc_ty_opt = get_impl_item_or_default(selcx.tcx(), data.impl_def_id, |cand| {\n+                    if let &ty::TypeTraitItem(ref assoc_ty) = cand {\n+                        if assoc_ty.name == obligation.predicate.item_name {\n+                            return Some(assoc_ty.defaultness);\n+                        }\n+                    }\n+                    None\n+                });\n+\n+                if let Some((defaultness, source)) = assoc_ty_opt {\n+                    if !source.is_from_trait() && defaultness == hir::Defaultness::Default {\n+                        // FIXME: is it OK to not mark as ambiguous?\n+                        return Ok(());\n+                    }\n+                } else {\n+                    selcx.tcx().sess.span_bug(obligation.cause.span,\n+                                              &format!(\"No associated type for {:?}\",\n+                                                       obligation_trait_ref));\n+                }\n+            }\n+\n             debug!(\"assemble_candidates_from_impls: impl candidate {:?}\",\n                    data);\n \n@@ -941,43 +965,31 @@ fn confirm_impl_candidate<'cx,'tcx>(\n     impl_vtable: VtableImplData<'tcx, PredicateObligation<'tcx>>)\n     -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n {\n-    // there don't seem to be nicer accessors to these:\n-    let impl_or_trait_items_map = selcx.tcx().impl_or_trait_items.borrow();\n-\n-    // Look for the associated type in the impl\n-    for impl_item in &selcx.tcx().impl_items.borrow()[&impl_vtable.impl_def_id] {\n-        if let ty::TypeTraitItem(ref assoc_ty) = impl_or_trait_items_map[&impl_item.def_id()] {\n-            if assoc_ty.name == obligation.predicate.item_name {\n-                return (assoc_ty.ty.unwrap().subst(selcx.tcx(), impl_vtable.substs),\n-                        impl_vtable.nested);\n-            }\n-        }\n-    }\n+    let VtableImplData { substs, nested, impl_def_id } = impl_vtable;\n \n-    // It is not in the impl - get the default from the trait.\n-    let trait_ref = obligation.predicate.trait_ref;\n-    for trait_item in selcx.tcx().trait_items(trait_ref.def_id).iter() {\n-        if let &ty::TypeTraitItem(ref assoc_ty) = trait_item {\n+    get_impl_item_or_default(selcx.tcx(), impl_def_id, |cand| {\n+        if let &ty::TypeTraitItem(ref assoc_ty) = cand {\n             if assoc_ty.name == obligation.predicate.item_name {\n                 if let Some(ty) = assoc_ty.ty {\n-                    return (ty.subst(selcx.tcx(), trait_ref.substs),\n-                            impl_vtable.nested);\n+                    return Some(ty)\n                 } else {\n-                    // This means that the impl is missing a\n-                    // definition for the associated type. This error\n-                    // ought to be reported by the type checker method\n-                    // `check_impl_items_against_trait`, so here we\n-                    // just return TyError.\n+                    // This means that the impl is missing a definition for the\n+                    // associated type. This error will be reported by the type\n+                    // checker method `check_impl_items_against_trait`, so here\n+                    // we just return TyError.\n                     debug!(\"confirm_impl_candidate: no associated type {:?} for {:?}\",\n                            assoc_ty.name,\n-                           trait_ref);\n-                    return (selcx.tcx().types.err, vec!());\n+                           obligation.predicate.trait_ref);\n+                    return Some(selcx.tcx().types.err);\n                 }\n             }\n         }\n-    }\n-\n-    selcx.tcx().sess.span_bug(obligation.cause.span,\n-                              &format!(\"No associated type for {:?}\",\n-                                       trait_ref));\n+        None\n+    }).map(|(ty, source)| {\n+        (ty.subst(selcx.tcx(), &source.translate_substs(selcx.tcx(), substs)), nested)\n+    }).unwrap_or_else(|| {\n+        selcx.tcx().sess.span_bug(obligation.cause.span,\n+                                  &format!(\"No associated type for {:?}\",\n+                                           obligation.predicate.trait_ref));\n+    })\n }"}, {"sha": "be2f63d1d1bc9305ac1461db666a3f5b783cee41", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b7e5112e88b8e73a5bff5a84f37f1d2a608e821c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7e5112e88b8e73a5bff5a84f37f1d2a608e821c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b7e5112e88b8e73a5bff5a84f37f1d2a608e821c", "patch": "@@ -1053,22 +1053,22 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     missing_items.push(trait_method.name);\n                 }\n             }\n-            ty::TypeTraitItem(ref associated_type) => {\n-                let is_implemented = impl_items.iter().any(|ii| {\n-                    match ii.node {\n-                        hir::ImplItemKind::Type(_) => {\n-                            ii.name == associated_type.name\n+            ty::TypeTraitItem(ref trait_assoc_ty) => {\n+                let search_result = traits::get_impl_item_or_default(tcx, impl_id, |cand| {\n+                    if let &ty::TypeTraitItem(ref assoc_ty) = cand {\n+                        if assoc_ty.name == trait_assoc_ty.name && assoc_ty.ty.is_some() {\n+                            return Some(());\n                         }\n-                        _ => false,\n                     }\n+                    None\n                 });\n-                let is_provided = associated_type.ty.is_some();\n-                if !is_implemented {\n-                    if !is_provided {\n-                        missing_items.push(associated_type.name);\n-                    } else if associated_type_overridden {\n-                        invalidated_items.push(associated_type.name);\n+\n+                if let Some((_, source)) = search_result {\n+                    if source.is_from_trait() && associated_type_overridden {\n+                        invalidated_items.push(trait_assoc_ty.name);\n                     }\n+                } else {\n+                    missing_items.push(trait_assoc_ty.name);\n                 }\n             }\n         }"}]}