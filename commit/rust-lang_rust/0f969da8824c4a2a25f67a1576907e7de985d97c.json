{"sha": "0f969da8824c4a2a25f67a1576907e7de985d97c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmOTY5ZGE4ODI0YzRhMmEyNWY2N2ExNTc2OTA3ZTdkZTk4NWQ5N2M=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-10T14:24:56Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-19T03:00:50Z"}, "message": "port some code to use dvec", "tree": {"sha": "c967d51eaa10d6de2219c0d70bb94f8ee13cc653", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c967d51eaa10d6de2219c0d70bb94f8ee13cc653"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f969da8824c4a2a25f67a1576907e7de985d97c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f969da8824c4a2a25f67a1576907e7de985d97c", "html_url": "https://github.com/rust-lang/rust/commit/0f969da8824c4a2a25f67a1576907e7de985d97c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f969da8824c4a2a25f67a1576907e7de985d97c/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf6ad6d62ab6846aa389684a220bfd8ed56570f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf6ad6d62ab6846aa389684a220bfd8ed56570f3", "html_url": "https://github.com/rust-lang/rust/commit/cf6ad6d62ab6846aa389684a220bfd8ed56570f3"}], "stats": {"total": 80, "additions": 49, "deletions": 31}, "files": [{"sha": "a1445e17212abe0817b41805aacb0d6ded5c9bc2", "filename": "src/librustsyntax/parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f969da8824c4a2a25f67a1576907e7de985d97c/src%2Flibrustsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f969da8824c4a2a25f67a1576907e7de985d97c/src%2Flibrustsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse.rs?ref=0f969da8824c4a2a25f67a1576907e7de985d97c", "patch": "@@ -139,7 +139,7 @@ fn new_parser(sess: parse_sess, cfg: ast::crate_cfg, rdr: lexer::reader,\n       mut token: tok0.tok,\n       mut span: span0,\n       mut last_span: span0,\n-      mut buffer: [],\n+      buffer: dvec::dvec(),\n       mut restriction: parser::UNRESTRICTED,\n       reader: rdr,\n       keywords: token::keyword_table(),"}, {"sha": "48d31a8c35cc5fdc1b7da2e1dc0131110782638e", "filename": "src/librustsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0f969da8824c4a2a25f67a1576907e7de985d97c/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f969da8824c4a2a25f67a1576907e7de985d97c/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fparser.rs?ref=0f969da8824c4a2a25f67a1576907e7de985d97c", "patch": "@@ -13,6 +13,7 @@ import attr::{parse_outer_attrs_or_ext,\n               parse_outer_attributes,\n               parse_optional_meta};\n import common::*;\n+import dvec::{dvec, extensions};\n \n export expect;\n export file_type;\n@@ -54,7 +55,7 @@ type parser = @{\n     mut token: token::token,\n     mut span: span,\n     mut last_span: span,\n-    mut buffer: [{tok: token::token, span: span}],\n+    buffer: dvec<{tok: token::token, span: span}>,\n     mut restriction: restriction,\n     reader: reader,\n     keywords: hashmap<str, ()>,\n@@ -64,12 +65,12 @@ type parser = @{\n impl parser for parser {\n     fn bump() {\n         self.last_span = self.span;\n-        if vec::len(self.buffer) == 0u {\n+        if self.buffer.len() == 0u {\n             let next = lexer::next_token(self.reader);\n             self.token = next.tok;\n             self.span = mk_sp(next.chpos, self.reader.chpos);\n         } else {\n-            let next = vec::shift(self.buffer);\n+            let next = self.buffer.shift();\n             self.token = next.tok;\n             self.span = next.span;\n         }\n@@ -79,10 +80,10 @@ impl parser for parser {\n         self.span = mk_sp(lo, hi);\n     }\n     fn look_ahead(distance: uint) -> token::token {\n-        while vec::len(self.buffer) < distance {\n+        while self.buffer.len() < distance {\n             let next = lexer::next_token(self.reader);\n             let sp = mk_sp(next.chpos, self.reader.chpos);\n-            vec::push(self.buffer, {tok: next.tok, span: sp});\n+            self.buffer.push({tok: next.tok, span: sp});\n         }\n         ret self.buffer[distance - 1u].tok;\n     }"}, {"sha": "882ce7b6461f39cba202e4403c4731d3bc5d2e50", "filename": "src/librustsyntax/print/pp.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0f969da8824c4a2a25f67a1576907e7de985d97c/src%2Flibrustsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f969da8824c4a2a25f67a1576907e7de985d97c/src%2Flibrustsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fprint%2Fpp.rs?ref=0f969da8824c4a2a25f67a1576907e7de985d97c", "patch": "@@ -1,4 +1,5 @@\n import io::writer_util;\n+import dvec::{dvec, extensions};\n \n /*\n  * This pretty-printer is a direct reimplementation of Philip Karlton's\n@@ -102,7 +103,6 @@ fn mk_printer(out: io::writer, linewidth: uint) -> printer {\n     let token: [mut token] = vec::to_mut(vec::from_elem(n, EOF));\n     let size: [mut int] = vec::to_mut(vec::from_elem(n, 0));\n     let scan_stack: [mut uint] = vec::to_mut(vec::from_elem(n, 0u));\n-    let print_stack: [print_stack_elt] = [];\n     @{out: out,\n       buf_len: n,\n       mut margin: linewidth as int,\n@@ -117,7 +117,7 @@ fn mk_printer(out: io::writer, linewidth: uint) -> printer {\n       mut scan_stack_empty: true,\n       mut top: 0u,\n       mut bottom: 0u,\n-      mut print_stack: print_stack,\n+      print_stack: dvec(),\n       mut pending_indentation: 0}\n }\n \n@@ -221,7 +221,7 @@ type printer = @{\n     mut top: uint, // index of top of scan_stack\n     mut bottom: uint, // index of bottom of scan_stack\n     // stack of blocks-in-progress being flushed by print\n-    mut print_stack: [print_stack_elt],\n+    print_stack: dvec<print_stack_elt>,\n     // buffered indentation to avoid writing trailing whitespace\n     mut pending_indentation: int\n };\n@@ -398,11 +398,12 @@ impl printer for printer {\n         self.pending_indentation += amount;\n     }\n     fn get_top() -> print_stack_elt {\n-        let n = vec::len(self.print_stack);\n-        let mut top: print_stack_elt =\n-            {offset: 0, pbreak: broken(inconsistent)};\n-        if n != 0u { top = self.print_stack[n - 1u]; }\n-        ret top;\n+        let n = self.print_stack.len();\n+        if n != 0u {\n+            self.print_stack[n - 1u]\n+        } else {\n+            {offset: 0, pbreak: broken(inconsistent)}\n+        }\n     }\n     fn write_str(s: str) {\n         while self.pending_indentation > 0 {\n@@ -420,16 +421,18 @@ impl printer for printer {\n             if L > self.space {\n                 let col = self.margin - self.space + b.offset;\n                 #debug(\"print BEGIN -> push broken block at col %d\", col);\n-                self.print_stack += [{offset: col, pbreak: broken(b.breaks)}];\n+                self.print_stack.push({offset: col,\n+                                       pbreak: broken(b.breaks)});\n             } else {\n                 #debug(\"print BEGIN -> push fitting block\");\n-                self.print_stack += [{offset: 0, pbreak: fits}];\n+                self.print_stack.push({offset: 0,\n+                                       pbreak: fits});\n             }\n           }\n           END {\n             #debug(\"print END -> pop END\");\n-            assert (vec::len(self.print_stack) != 0u);\n-            vec::pop(self.print_stack);\n+            assert (self.print_stack.len() != 0u);\n+            self.print_stack.pop();\n           }\n           BREAK(b) {\n             let top = self.get_top();"}, {"sha": "ca975e6fc54bc4afe95edbf9f5b7b9a117f2b03a", "filename": "src/librustsyntax/print/pprust.rs", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0f969da8824c4a2a25f67a1576907e7de985d97c/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f969da8824c4a2a25f67a1576907e7de985d97c/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fprint%2Fpprust.rs?ref=0f969da8824c4a2a25f67a1576907e7de985d97c", "patch": "@@ -7,6 +7,7 @@ import pp::{break_offset, word, printer,\n             inconsistent, eof};\n import diagnostic;\n import ast_util::operator_prec;\n+import dvec::{dvec, extensions};\n \n // The ps is stored here to prevent recursive type.\n enum ann_node {\n@@ -29,22 +30,27 @@ type ps =\n       literals: option<[comments::lit]>,\n       mut cur_cmnt: uint,\n       mut cur_lit: uint,\n-      mut boxes: [pp::breaks],\n+      boxes: dvec<pp::breaks>,\n       ann: pp_ann};\n \n-fn ibox(s: ps, u: uint) { s.boxes += [pp::inconsistent]; pp::ibox(s.s, u); }\n+fn ibox(s: ps, u: uint) {\n+    s.boxes.push(pp::inconsistent);\n+    pp::ibox(s.s, u);\n+}\n \n-fn end(s: ps) { vec::pop(s.boxes); pp::end(s.s); }\n+fn end(s: ps) {\n+    s.boxes.pop();\n+    pp::end(s.s);\n+}\n \n fn rust_printer(writer: io::writer) -> ps {\n-    let boxes: [pp::breaks] = [];\n     ret @{s: pp::mk_printer(writer, default_columns),\n           cm: none::<codemap>,\n           comments: none::<[comments::cmnt]>,\n           literals: none::<[comments::lit]>,\n           mut cur_cmnt: 0u,\n           mut cur_lit: 0u,\n-          mut boxes: boxes,\n+          boxes: dvec(),\n           ann: no_ann()};\n }\n \n@@ -59,7 +65,6 @@ const default_columns: uint = 78u;\n fn print_crate(cm: codemap, span_diagnostic: diagnostic::span_handler,\n                crate: @ast::crate, filename: str, in: io::reader,\n                out: io::writer, ann: pp_ann) {\n-    let boxes: [pp::breaks] = [];\n     let r = comments::gather_comments_and_literals(span_diagnostic,\n                                                    filename, in);\n     let s =\n@@ -69,7 +74,7 @@ fn print_crate(cm: codemap, span_diagnostic: diagnostic::span_handler,\n           literals: some(r.lits),\n           mut cur_cmnt: 0u,\n           mut cur_lit: 0u,\n-          mut boxes: boxes,\n+          boxes: dvec(),\n           ann: ann};\n     print_crate_(s, crate);\n }\n@@ -195,9 +200,15 @@ fn test_variant_to_str() {\n     assert varstr == \"principle_skinner\";\n }\n \n-fn cbox(s: ps, u: uint) { s.boxes += [pp::consistent]; pp::cbox(s.s, u); }\n+fn cbox(s: ps, u: uint) {\n+    s.boxes.push(pp::consistent);\n+    pp::cbox(s.s, u);\n+}\n \n-fn box(s: ps, u: uint, b: pp::breaks) { s.boxes += [b]; pp::box(s.s, u, b); }\n+fn box(s: ps, u: uint, b: pp::breaks) {\n+    s.boxes.push(b);\n+    pp::box(s.s, u, b);\n+}\n \n fn nbsp(s: ps) { word(s.s, \" \"); }\n \n@@ -245,7 +256,7 @@ fn is_bol(s: ps) -> bool {\n }\n \n fn in_cbox(s: ps) -> bool {\n-    let len = vec::len(s.boxes);\n+    let len = s.boxes.len();\n     if len == 0u { ret false; }\n     ret s.boxes[len - 1u] == pp::consistent;\n }"}, {"sha": "63c0b7003c2b434ac9de49b2521bfc5f80cc24d5", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0f969da8824c4a2a25f67a1576907e7de985d97c/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f969da8824c4a2a25f67a1576907e7de985d97c/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=0f969da8824c4a2a25f67a1576907e7de985d97c", "patch": "@@ -20,9 +20,12 @@ fn check_crate(tcx: ty::ctxt,\n                crate: @ast::crate) -> (root_map, mutbl_map) {\n \n     // big hack to keep this off except when I want it on\n-    let msg_level = alt os::getenv(\"RUST_BORROWCK\") {\n-      none {tcx.sess.opts.borrowck}\n-      some(v) {option::get(uint::from_str(v))}\n+    let msg_level = if tcx.sess.opts.borrowck != 0u {\n+        tcx.sess.opts.borrowck\n+    } else {\n+        os::getenv(\"RUST_BORROWCK\").map_default(0u) { |v|\n+            option::get(uint::from_str(v))\n+        }\n     };\n \n     let bccx = @{tcx: tcx,"}]}