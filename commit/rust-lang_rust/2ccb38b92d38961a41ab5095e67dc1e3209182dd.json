{"sha": "2ccb38b92d38961a41ab5095e67dc1e3209182dd", "node_id": "C_kwDOAAsO6NoAKDJjY2IzOGI5MmQzODk2MWE0MWFiNTA5NWU2N2RjMWUzMjA5MTgyZGQ", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-11-27T21:14:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-27T21:14:09Z"}, "message": "Rollup merge of #104989 - RalfJung:miri, r=RalfJung\n\nupdate Miri\n\nr? `@ghost`", "tree": {"sha": "1df147a6732c5ab84cc61df48379108af00435f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1df147a6732c5ab84cc61df48379108af00435f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ccb38b92d38961a41ab5095e67dc1e3209182dd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjg9MhCRBK7hj4Ov3rIwAAWPEIAEqhcD1GcIJiv9VNSX8O91OD\ny5NKjwxqcwHUuEGbx8nkahdr/xKSjpvNFOnm2gPcu93b7t1tRcPNTw7M8CZ2J2oE\nYE2+u55ZuKOOBoZ6KivSREejeVbqA/sPNHI+RPS790VllrBmgUjc7O75+7KGiHAD\nbXuBkvZ/xSs5y1WzV+q2fdD43mUKs9GHDpQ/Ky/j8hasxzei3dBwGW1TW5UhbmmX\ncZp85PJGXc3zPpScI1kAzIlin7E0uKRt2+hPZfyzwOHJko5jxN9HoNKdvXe8o+OE\nQdE5SLgWRdJe0Oefdli5dF8zcmfs2ZTxtOstLL81UTuzWqg+H3ZH7jCS5n905B0=\n=MmqZ\n-----END PGP SIGNATURE-----\n", "payload": "tree 1df147a6732c5ab84cc61df48379108af00435f8\nparent 5ea36cfc1c98d672a5ce92cfe5f56b64e846203b\nparent f8fbc6da3c467b27793c35c6e105053c9d092447\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1669583649 +0100\ncommitter GitHub <noreply@github.com> 1669583649 +0100\n\nRollup merge of #104989 - RalfJung:miri, r=RalfJung\n\nupdate Miri\n\nr? `@ghost`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ccb38b92d38961a41ab5095e67dc1e3209182dd", "html_url": "https://github.com/rust-lang/rust/commit/2ccb38b92d38961a41ab5095e67dc1e3209182dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ccb38b92d38961a41ab5095e67dc1e3209182dd/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ea36cfc1c98d672a5ce92cfe5f56b64e846203b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ea36cfc1c98d672a5ce92cfe5f56b64e846203b", "html_url": "https://github.com/rust-lang/rust/commit/5ea36cfc1c98d672a5ce92cfe5f56b64e846203b"}, {"sha": "f8fbc6da3c467b27793c35c6e105053c9d092447", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8fbc6da3c467b27793c35c6e105053c9d092447", "html_url": "https://github.com/rust-lang/rust/commit/f8fbc6da3c467b27793c35c6e105053c9d092447"}], "stats": {"total": 1393, "additions": 893, "deletions": 500}, "files": [{"sha": "c63f356607d0750a1406053fa1a0250d3c3fd424", "filename": "src/tools/miri/CONTRIBUTING.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2FCONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2FCONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FCONTRIBUTING.md?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -296,6 +296,13 @@ needed.\n \n ### Exporting changes to the rustc repo\n \n+Keep in mind that pushing is the most complicated job that josh has to do --\n+pulling just filters the rustc history, but pushing needs to construct a new\n+rustc history that would filter to the given Miri history! To avoid problems, it\n+is a good idea to always pull immediately before you push. In particular, you\n+should never do two josh pushes without an intermediate pull; that can lead to\n+duplicated commits.\n+\n Josh needs to be running, as described above. We will use the josh proxy to push\n to your fork of rustc. Run the following in the Miri repo, assuming we are on an\n up-to-date master branch:"}, {"sha": "64b3187305e1af975c2c8a823d038f7cb20280d7", "filename": "src/tools/miri/cargo-miri/src/phases.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fphases.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fphases.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fphases.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -281,9 +281,10 @@ pub fn phase_rustc(mut args: impl Iterator<Item = String>, phase: RustcPhase) {\n             eprintln!(\"[cargo-miri rustc] writing run info to `{}`\", filename.display());\n         }\n         info.store(&filename);\n-        // For Windows, do the same thing again with `.exe` appended to the filename.\n+        // For Windows and WASM, do the same thing again with `.exe`/`.wasm` appended to the filename.\n         // (Need to do this here as cargo moves that \"binary\" to a different place before running it.)\n         info.store(&out_filename(\"\", \".exe\"));\n+        info.store(&out_filename(\"\", \".wasm\"));\n     };\n \n     let runnable_crate = !info_query && is_runnable_crate();"}, {"sha": "dd2d2abe35b539cff216bfabbd848718d8d3c8b1", "filename": "src/tools/miri/ci.sh", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Fci.sh", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Fci.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fci.sh?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,6 +1,17 @@\n #!/bin/bash\n set -euo pipefail\n-set -x\n+\n+function begingroup {\n+  echo \"::group::$@\"\n+  set -x\n+}\n+\n+function endgroup {\n+  set +x\n+  echo \"::endgroup\"\n+}\n+\n+begingroup \"Building Miri\"\n \n # Determine configuration for installed build\n echo \"Installing release version of Miri\"\n@@ -14,14 +25,15 @@ export CARGO_EXTRA_FLAGS=\"--locked\"\n ./miri check --no-default-features # make sure this can be built\n ./miri check --all-features # and this, too\n ./miri build --all-targets # the build that all the `./miri test` below will use\n-echo\n+\n+endgroup\n \n # Test\n function run_tests {\n   if [ -n \"${MIRI_TEST_TARGET+exists}\" ]; then\n-    echo \"Testing foreign architecture $MIRI_TEST_TARGET\"\n+    begingroup \"Testing foreign architecture $MIRI_TEST_TARGET\"\n   else\n-    echo \"Testing host architecture\"\n+    begingroup \"Testing host architecture\"\n   fi\n \n   ## ui test suite\n@@ -52,7 +64,6 @@ function run_tests {\n   echo 'build.rustc-wrapper = \"thisdoesnotexist\"' > .cargo/config.toml\n   # Run the actual test\n   ${PYTHON} test-cargo-miri/run-test.py\n-  echo\n   # Clean up\n   unset RUSTC MIRI\n   rm -rf .cargo\n@@ -63,16 +74,23 @@ function run_tests {\n       cargo miri run --manifest-path bench-cargo-miri/$BENCH/Cargo.toml\n     done\n   fi\n+\n+  endgroup\n }\n \n function run_tests_minimal {\n   if [ -n \"${MIRI_TEST_TARGET+exists}\" ]; then\n-    echo \"Testing MINIMAL foreign architecture $MIRI_TEST_TARGET: only testing $@\"\n+    begingroup \"Testing MINIMAL foreign architecture $MIRI_TEST_TARGET: only testing $@\"\n   else\n-    echo \"Testing MINIMAL host architecture: only testing $@\"\n+    begingroup \"Testing MINIMAL host architecture: only testing $@\"\n   fi\n \n   ./miri test -- \"$@\"\n+\n+  # Ensure that a small smoke test of cargo-miri works.\n+  cargo miri run --manifest-path test-cargo-miri/no-std-smoke/Cargo.toml --target ${MIRI_TEST_TARGET-$HOST_TARGET}\n+\n+  endgroup\n }\n \n # host\n@@ -85,6 +103,7 @@ case $HOST_TARGET in\n     MIRI_TEST_TARGET=i686-pc-windows-msvc run_tests\n     MIRI_TEST_TARGET=x86_64-unknown-freebsd run_tests_minimal hello integer vec panic/panic concurrency/simple atomic data_race env/var\n     MIRI_TEST_TARGET=aarch64-linux-android run_tests_minimal hello integer vec panic/panic\n+    MIRI_TEST_TARGET=wasm32-wasi MIRI_NO_STD=1 run_tests_minimal no_std # supports std but miri doesn't support it\n     MIRI_TEST_TARGET=thumbv7em-none-eabihf MIRI_NO_STD=1 run_tests_minimal no_std # no_std embedded architecture\n     ;;\n   x86_64-apple-darwin)"}, {"sha": "851ef39274094b6796e2e418de59f7e192fb0c64", "filename": "src/tools/miri/rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Frust-version", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Frust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Frust-version?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1 +1 @@\n-7477c1f4f7d6bef037d523099b240d22aa1b63a0\n+454784afba5bf35b5ff14ada0e31265ad1d75e73"}, {"sha": "d669cc1362a9a7a06a31536c8899cf5ae5d3dce9", "filename": "src/tools/miri/src/concurrency/data_race.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -838,18 +838,18 @@ impl VClockAlloc {\n         &self,\n         alloc_id: AllocId,\n         range: AllocRange,\n-        global: &GlobalState,\n-        thread_mgr: &ThreadManager<'_, '_>,\n+        machine: &MiriMachine<'_, '_>,\n     ) -> InterpResult<'tcx> {\n+        let global = machine.data_race.as_ref().unwrap();\n         if global.race_detecting() {\n-            let (index, clocks) = global.current_thread_state(thread_mgr);\n+            let (index, clocks) = global.current_thread_state(&machine.threads);\n             let mut alloc_ranges = self.alloc_ranges.borrow_mut();\n             for (offset, range) in alloc_ranges.iter_mut(range.start, range.size) {\n                 if let Err(DataRace) = range.read_race_detect(&clocks, index) {\n                     // Report data-race.\n                     return Self::report_data_race(\n                         global,\n-                        thread_mgr,\n+                        &machine.threads,\n                         range,\n                         \"Read\",\n                         false,\n@@ -869,17 +869,17 @@ impl VClockAlloc {\n         alloc_id: AllocId,\n         range: AllocRange,\n         write_type: WriteType,\n-        global: &mut GlobalState,\n-        thread_mgr: &ThreadManager<'_, '_>,\n+        machine: &mut MiriMachine<'_, '_>,\n     ) -> InterpResult<'tcx> {\n+        let global = machine.data_race.as_mut().unwrap();\n         if global.race_detecting() {\n-            let (index, clocks) = global.current_thread_state(thread_mgr);\n+            let (index, clocks) = global.current_thread_state(&machine.threads);\n             for (offset, range) in self.alloc_ranges.get_mut().iter_mut(range.start, range.size) {\n                 if let Err(DataRace) = range.write_race_detect(&clocks, index, write_type) {\n                     // Report data-race\n                     return Self::report_data_race(\n                         global,\n-                        thread_mgr,\n+                        &machine.threads,\n                         range,\n                         write_type.get_descriptor(),\n                         false,\n@@ -901,10 +901,9 @@ impl VClockAlloc {\n         &mut self,\n         alloc_id: AllocId,\n         range: AllocRange,\n-        global: &mut GlobalState,\n-        thread_mgr: &ThreadManager<'_, '_>,\n+        machine: &mut MiriMachine<'_, '_>,\n     ) -> InterpResult<'tcx> {\n-        self.unique_access(alloc_id, range, WriteType::Write, global, thread_mgr)\n+        self.unique_access(alloc_id, range, WriteType::Write, machine)\n     }\n \n     /// Detect data-races for an unsynchronized deallocate operation, will not perform\n@@ -915,10 +914,9 @@ impl VClockAlloc {\n         &mut self,\n         alloc_id: AllocId,\n         range: AllocRange,\n-        global: &mut GlobalState,\n-        thread_mgr: &ThreadManager<'_, '_>,\n+        machine: &mut MiriMachine<'_, '_>,\n     ) -> InterpResult<'tcx> {\n-        self.unique_access(alloc_id, range, WriteType::Deallocate, global, thread_mgr)\n+        self.unique_access(alloc_id, range, WriteType::Deallocate, machine)\n     }\n }\n "}, {"sha": "dacb3a9b88f8f660f67bb234c552f7fbf90960f3", "filename": "src/tools/miri/src/concurrency/thread.rs", "status": "modified", "additions": 52, "deletions": 3, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -118,6 +118,13 @@ pub struct Thread<'mir, 'tcx> {\n     /// The virtual call stack.\n     stack: Vec<Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>>,\n \n+    /// The index of the topmost user-relevant frame in `stack`. This field must contain\n+    /// the value produced by `get_top_user_relevant_frame`.\n+    /// The `None` state here represents\n+    /// This field is a cache to reduce how often we call that method. The cache is manually\n+    /// maintained inside `MiriMachine::after_stack_push` and `MiriMachine::after_stack_pop`.\n+    top_user_relevant_frame: Option<usize>,\n+\n     /// The join status.\n     join_status: ThreadJoinStatus,\n \n@@ -147,6 +154,40 @@ impl<'mir, 'tcx> Thread<'mir, 'tcx> {\n     fn thread_name(&self) -> &[u8] {\n         if let Some(ref thread_name) = self.thread_name { thread_name } else { b\"<unnamed>\" }\n     }\n+\n+    /// Return the top user-relevant frame, if there is one.\n+    /// Note that the choice to return `None` here when there is no user-relevant frame is part of\n+    /// justifying the optimization that only pushes of user-relevant frames require updating the\n+    /// `top_user_relevant_frame` field.\n+    fn compute_top_user_relevant_frame(&self) -> Option<usize> {\n+        self.stack\n+            .iter()\n+            .enumerate()\n+            .rev()\n+            .find_map(|(idx, frame)| if frame.extra.is_user_relevant { Some(idx) } else { None })\n+    }\n+\n+    /// Re-compute the top user-relevant frame from scratch.\n+    pub fn recompute_top_user_relevant_frame(&mut self) {\n+        self.top_user_relevant_frame = self.compute_top_user_relevant_frame();\n+    }\n+\n+    /// Set the top user-relevant frame to the given value. Must be equal to what\n+    /// `get_top_user_relevant_frame` would return!\n+    pub fn set_top_user_relevant_frame(&mut self, frame_idx: usize) {\n+        debug_assert_eq!(Some(frame_idx), self.compute_top_user_relevant_frame());\n+        self.top_user_relevant_frame = Some(frame_idx);\n+    }\n+\n+    /// Returns the topmost frame that is considered user-relevant, or the\n+    /// top of the stack if there is no such frame, or `None` if the stack is empty.\n+    pub fn top_user_relevant_frame(&self) -> Option<usize> {\n+        debug_assert_eq!(self.top_user_relevant_frame, self.compute_top_user_relevant_frame());\n+        // This can be called upon creation of an allocation. We create allocations while setting up\n+        // parts of the Rust runtime when we do not have any stack frames yet, so we need to handle\n+        // empty stacks.\n+        self.top_user_relevant_frame.or_else(|| self.stack.len().checked_sub(1))\n+    }\n }\n \n impl<'mir, 'tcx> std::fmt::Debug for Thread<'mir, 'tcx> {\n@@ -167,6 +208,7 @@ impl<'mir, 'tcx> Default for Thread<'mir, 'tcx> {\n             state: ThreadState::Enabled,\n             thread_name: None,\n             stack: Vec::new(),\n+            top_user_relevant_frame: None,\n             join_status: ThreadJoinStatus::Joinable,\n             panic_payload: None,\n             last_error: None,\n@@ -184,8 +226,15 @@ impl<'mir, 'tcx> Thread<'mir, 'tcx> {\n \n impl VisitTags for Thread<'_, '_> {\n     fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n-        let Thread { panic_payload, last_error, stack, state: _, thread_name: _, join_status: _ } =\n-            self;\n+        let Thread {\n+            panic_payload,\n+            last_error,\n+            stack,\n+            top_user_relevant_frame: _,\n+            state: _,\n+            thread_name: _,\n+            join_status: _,\n+        } = self;\n \n         panic_payload.visit_tags(visit);\n         last_error.visit_tags(visit);\n@@ -414,7 +463,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     }\n \n     /// Get a shared borrow of the currently active thread.\n-    fn active_thread_ref(&self) -> &Thread<'mir, 'tcx> {\n+    pub fn active_thread_ref(&self) -> &Thread<'mir, 'tcx> {\n         &self.threads[self.active_thread]\n     }\n "}, {"sha": "363b647d6c684fd6e95e04a7244f7217c1073d4e", "filename": "src/tools/miri/src/eval.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -9,6 +9,7 @@ use std::thread;\n use log::info;\n \n use rustc_data_structures::fx::FxHashSet;\n+use rustc_hir::def::Namespace;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::{\n     self,\n@@ -195,7 +196,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     MiriMachine::late_init(&mut ecx, config)?;\n \n     // Make sure we have MIR. We check MIR for some stable monomorphic function in libcore.\n-    let sentinel = ecx.try_resolve_path(&[\"core\", \"ascii\", \"escape_default\"]);\n+    let sentinel = ecx.try_resolve_path(&[\"core\", \"ascii\", \"escape_default\"], Namespace::ValueNS);\n     if !matches!(sentinel, Some(s) if tcx.is_mir_available(s.def.def_id())) {\n         tcx.sess.fatal(\n             \"the current sysroot was built without `-Zalways-encode-mir`, or libcore seems missing. \\"}, {"sha": "f0d8b6768810c720fc7c367d90de6e9ef68c852e", "filename": "src/tools/miri/src/helpers.rs", "status": "modified", "additions": 79, "deletions": 86, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -2,12 +2,12 @@ pub mod convert;\n \n use std::cmp;\n use std::iter;\n-use std::mem;\n use std::num::NonZeroUsize;\n use std::time::Duration;\n \n use log::trace;\n \n+use rustc_hir::def::{DefKind, Namespace};\n use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc_middle::mir;\n use rustc_middle::ty::{\n@@ -74,48 +74,75 @@ const UNIX_IO_ERROR_TABLE: &[(&str, std::io::ErrorKind)] = {\n };\n \n /// Gets an instance for a path.\n-fn try_resolve_did<'tcx>(tcx: TyCtxt<'tcx>, path: &[&str]) -> Option<DefId> {\n-    tcx.crates(()).iter().find(|&&krate| tcx.crate_name(krate).as_str() == path[0]).and_then(\n-        |krate| {\n-            let krate = DefId { krate: *krate, index: CRATE_DEF_INDEX };\n-            let mut items = tcx.module_children(krate);\n-            let mut path_it = path.iter().skip(1).peekable();\n-\n-            while let Some(segment) = path_it.next() {\n-                for item in mem::take(&mut items).iter() {\n-                    if item.ident.name.as_str() == *segment {\n-                        if path_it.peek().is_none() {\n-                            return Some(item.res.def_id());\n-                        }\n+///\n+/// A `None` namespace indicates we are looking for a module.\n+fn try_resolve_did(tcx: TyCtxt<'_>, path: &[&str], namespace: Option<Namespace>) -> Option<DefId> {\n+    /// Yield all children of the given item, that have the given name.\n+    fn find_children<'tcx: 'a, 'a>(\n+        tcx: TyCtxt<'tcx>,\n+        item: DefId,\n+        name: &'a str,\n+    ) -> impl Iterator<Item = DefId> + 'a {\n+        tcx.module_children(item)\n+            .iter()\n+            .filter(move |item| item.ident.name.as_str() == name)\n+            .map(move |item| item.res.def_id())\n+    }\n \n-                        items = tcx.module_children(item.res.def_id());\n-                        break;\n-                    }\n-                }\n-            }\n-            None\n-        },\n-    )\n+    // Take apart the path: leading crate, a sequence of modules, and potentially a final item.\n+    let (&crate_name, path) = path.split_first().expect(\"paths must have at least one segment\");\n+    let (modules, item) = if let Some(namespace) = namespace {\n+        let (&item_name, modules) =\n+            path.split_last().expect(\"non-module paths must have at least 2 segments\");\n+        (modules, Some((item_name, namespace)))\n+    } else {\n+        (path, None)\n+    };\n+\n+    // First find the crate.\n+    let krate =\n+        tcx.crates(()).iter().find(|&&krate| tcx.crate_name(krate).as_str() == crate_name)?;\n+    let mut cur_item = DefId { krate: *krate, index: CRATE_DEF_INDEX };\n+    // Then go over the modules.\n+    for &segment in modules {\n+        cur_item = find_children(tcx, cur_item, segment)\n+            .find(|item| tcx.def_kind(item) == DefKind::Mod)?;\n+    }\n+    // Finally, look up the desired item in this module, if any.\n+    match item {\n+        Some((item_name, namespace)) =>\n+            Some(\n+                find_children(tcx, cur_item, item_name)\n+                    .find(|item| tcx.def_kind(item).ns() == Some(namespace))?,\n+            ),\n+        None => Some(cur_item),\n+    }\n }\n \n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    /// Checks if the given crate/module exists.\n+    fn have_module(&self, path: &[&str]) -> bool {\n+        try_resolve_did(*self.eval_context_ref().tcx, path, None).is_some()\n+    }\n+\n     /// Gets an instance for a path; fails gracefully if the path does not exist.\n-    fn try_resolve_path(&self, path: &[&str]) -> Option<ty::Instance<'tcx>> {\n-        let did = try_resolve_did(self.eval_context_ref().tcx.tcx, path)?;\n-        Some(ty::Instance::mono(self.eval_context_ref().tcx.tcx, did))\n+    fn try_resolve_path(&self, path: &[&str], namespace: Namespace) -> Option<ty::Instance<'tcx>> {\n+        let tcx = self.eval_context_ref().tcx.tcx;\n+        let did = try_resolve_did(tcx, path, Some(namespace))?;\n+        Some(ty::Instance::mono(tcx, did))\n     }\n \n     /// Gets an instance for a path.\n-    fn resolve_path(&self, path: &[&str]) -> ty::Instance<'tcx> {\n-        self.try_resolve_path(path)\n+    fn resolve_path(&self, path: &[&str], namespace: Namespace) -> ty::Instance<'tcx> {\n+        self.try_resolve_path(path, namespace)\n             .unwrap_or_else(|| panic!(\"failed to find required Rust item: {path:?}\"))\n     }\n \n     /// Evaluates the scalar at the specified path. Returns Some(val)\n     /// if the path could be resolved, and None otherwise\n     fn eval_path_scalar(&self, path: &[&str]) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_ref();\n-        let instance = this.resolve_path(path);\n+        let instance = this.resolve_path(path, Namespace::ValueNS);\n         let cid = GlobalId { instance, promoted: None };\n         // We don't give a span -- this isn't actually used directly by the program anyway.\n         let const_val = this.eval_global(cid, None)?;\n@@ -147,15 +174,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     /// Helper function to get the `TyAndLayout` of a `libc` type\n     fn libc_ty_layout(&self, name: &str) -> InterpResult<'tcx, TyAndLayout<'tcx>> {\n         let this = self.eval_context_ref();\n-        let ty = this.resolve_path(&[\"libc\", name]).ty(*this.tcx, ty::ParamEnv::reveal_all());\n+        let ty = this\n+            .resolve_path(&[\"libc\", name], Namespace::TypeNS)\n+            .ty(*this.tcx, ty::ParamEnv::reveal_all());\n         this.layout_of(ty)\n     }\n \n     /// Helper function to get the `TyAndLayout` of a `windows` type\n     fn windows_ty_layout(&self, name: &str) -> InterpResult<'tcx, TyAndLayout<'tcx>> {\n         let this = self.eval_context_ref();\n         let ty = this\n-            .resolve_path(&[\"std\", \"sys\", \"windows\", \"c\", name])\n+            .resolve_path(&[\"std\", \"sys\", \"windows\", \"c\", name], Namespace::TypeNS)\n             .ty(*this.tcx, ty::ParamEnv::reveal_all());\n         this.layout_of(ty)\n     }\n@@ -936,78 +965,42 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n }\n \n impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n-    pub fn current_span(&self) -> CurrentSpan<'_, 'mir, 'tcx> {\n-        CurrentSpan { current_frame_idx: None, machine: self }\n-    }\n-}\n-\n-/// A `CurrentSpan` should be created infrequently (ideally once) per interpreter step. It does\n-/// nothing on creation, but when `CurrentSpan::get` is called, searches the current stack for the\n-/// topmost frame which corresponds to a local crate, and returns the current span in that frame.\n-/// The result of that search is cached so that later calls are approximately free.\n-#[derive(Clone)]\n-pub struct CurrentSpan<'a, 'mir, 'tcx> {\n-    current_frame_idx: Option<usize>,\n-    machine: &'a MiriMachine<'mir, 'tcx>,\n-}\n-\n-impl<'a, 'mir: 'a, 'tcx: 'a + 'mir> CurrentSpan<'a, 'mir, 'tcx> {\n-    pub fn machine(&self) -> &'a MiriMachine<'mir, 'tcx> {\n-        self.machine\n-    }\n-\n-    /// Get the current span, skipping non-local frames.\n+    /// Get the current span in the topmost function which is workspace-local and not\n+    /// `#[track_caller]`.\n     /// This function is backed by a cache, and can be assumed to be very fast.\n-    pub fn get(&mut self) -> Span {\n-        let idx = self.current_frame_idx();\n-        self.stack().get(idx).map(Frame::current_span).unwrap_or(rustc_span::DUMMY_SP)\n+    /// It will work even when the stack is empty.\n+    pub fn current_span(&self) -> Span {\n+        self.top_user_relevant_frame()\n+            .map(|frame_idx| self.stack()[frame_idx].current_span())\n+            .unwrap_or(rustc_span::DUMMY_SP)\n     }\n \n     /// Returns the span of the *caller* of the current operation, again\n     /// walking down the stack to find the closest frame in a local crate, if the caller of the\n     /// current operation is not in a local crate.\n     /// This is useful when we are processing something which occurs on function-entry and we want\n     /// to point at the call to the function, not the function definition generally.\n-    pub fn get_caller(&mut self) -> Span {\n+    pub fn caller_span(&self) -> Span {\n         // We need to go down at least to the caller (len - 2), or however\n-        // far we have to go to find a frame in a local crate.\n-        let local_frame_idx = self.current_frame_idx();\n-        let stack = self.stack();\n-        let idx = cmp::min(local_frame_idx, stack.len().saturating_sub(2));\n-        stack.get(idx).map(Frame::current_span).unwrap_or(rustc_span::DUMMY_SP)\n+        // far we have to go to find a frame in a local crate which is also not #[track_caller].\n+        let frame_idx = self.top_user_relevant_frame().unwrap();\n+        let frame_idx = cmp::min(frame_idx, self.stack().len().checked_sub(2).unwrap());\n+        self.stack()[frame_idx].current_span()\n     }\n \n     fn stack(&self) -> &[Frame<'mir, 'tcx, Provenance, machine::FrameData<'tcx>>] {\n-        self.machine.threads.active_thread_stack()\n+        self.threads.active_thread_stack()\n     }\n \n-    fn current_frame_idx(&mut self) -> usize {\n-        *self\n-            .current_frame_idx\n-            .get_or_insert_with(|| Self::compute_current_frame_index(self.machine))\n+    fn top_user_relevant_frame(&self) -> Option<usize> {\n+        self.threads.active_thread_ref().top_user_relevant_frame()\n     }\n \n-    // Find the position of the inner-most frame which is part of the crate being\n-    // compiled/executed, part of the Cargo workspace, and is also not #[track_caller].\n-    #[inline(never)]\n-    fn compute_current_frame_index(machine: &MiriMachine<'_, '_>) -> usize {\n-        machine\n-            .threads\n-            .active_thread_stack()\n-            .iter()\n-            .enumerate()\n-            .rev()\n-            .find_map(|(idx, frame)| {\n-                let def_id = frame.instance.def_id();\n-                if (def_id.is_local() || machine.local_crates.contains(&def_id.krate))\n-                    && !frame.instance.def.requires_caller_location(machine.tcx)\n-                {\n-                    Some(idx)\n-                } else {\n-                    None\n-                }\n-            })\n-            .unwrap_or(0)\n+    /// This is the source of truth for the `is_user_relevant` flag in our `FrameExtra`.\n+    pub fn is_user_relevant(&self, frame: &Frame<'mir, 'tcx, Provenance>) -> bool {\n+        let def_id = frame.instance.def_id();\n+        (def_id.is_local() || self.local_crates.contains(&def_id.krate))\n+            && !frame.instance.def.requires_caller_location(self.tcx)\n     }\n }\n "}, {"sha": "8913f8aa10fcdb962e927e93858cb5f6f21ae1b6", "filename": "src/tools/miri/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -97,7 +97,7 @@ pub use crate::diagnostics::{\n pub use crate::eval::{\n     create_ecx, eval_entry, AlignmentCheck, BacktraceStyle, IsolatedOp, MiriConfig, RejectOpWith,\n };\n-pub use crate::helpers::{CurrentSpan, EvalContextExt as _};\n+pub use crate::helpers::EvalContextExt as _;\n pub use crate::intptrcast::ProvenanceMode;\n pub use crate::machine::{\n     AllocExtra, FrameData, MiriInterpCx, MiriInterpCxExt, MiriMachine, MiriMemoryKind,"}, {"sha": "edfef211dc675abcff79b316ed1f6335a18cf3df", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 33, "deletions": 46, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -50,12 +50,18 @@ pub struct FrameData<'tcx> {\n     /// for the start of this frame. When we finish executing this frame,\n     /// we use this to register a completed event with `measureme`.\n     pub timing: Option<measureme::DetachedTiming>,\n+\n+    /// Indicates whether a `Frame` is part of a workspace-local crate and is also not\n+    /// `#[track_caller]`. We compute this once on creation and store the result, as an\n+    /// optimization.\n+    /// This is used by `MiriMachine::current_span` and `MiriMachine::caller_span`\n+    pub is_user_relevant: bool,\n }\n \n impl<'tcx> std::fmt::Debug for FrameData<'tcx> {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         // Omitting `timing`, it does not support `Debug`.\n-        let FrameData { stacked_borrows, catch_unwind, timing: _ } = self;\n+        let FrameData { stacked_borrows, catch_unwind, timing: _, is_user_relevant: _ } = self;\n         f.debug_struct(\"FrameData\")\n             .field(\"stacked_borrows\", stacked_borrows)\n             .field(\"catch_unwind\", catch_unwind)\n@@ -65,7 +71,7 @@ impl<'tcx> std::fmt::Debug for FrameData<'tcx> {\n \n impl VisitTags for FrameData<'_> {\n     fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n-        let FrameData { catch_unwind, stacked_borrows, timing: _ } = self;\n+        let FrameData { catch_unwind, stacked_borrows, timing: _, is_user_relevant: _ } = self;\n \n         catch_unwind.visit_tags(visit);\n         stacked_borrows.visit_tags(visit);\n@@ -895,13 +901,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n \n         let alloc = alloc.into_owned();\n         let stacks = ecx.machine.stacked_borrows.as_ref().map(|stacked_borrows| {\n-            Stacks::new_allocation(\n-                id,\n-                alloc.size(),\n-                stacked_borrows,\n-                kind,\n-                ecx.machine.current_span(),\n-            )\n+            Stacks::new_allocation(id, alloc.size(), stacked_borrows, kind, &ecx.machine)\n         });\n         let race_alloc = ecx.machine.data_race.as_ref().map(|data_race| {\n             data_race::AllocExtra::new_allocation(\n@@ -1003,22 +1003,12 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         if let Some(data_race) = &alloc_extra.data_race {\n-            data_race.read(\n-                alloc_id,\n-                range,\n-                machine.data_race.as_ref().unwrap(),\n-                &machine.threads,\n-            )?;\n+            data_race.read(alloc_id, range, machine)?;\n         }\n         if let Some(stacked_borrows) = &alloc_extra.stacked_borrows {\n-            stacked_borrows.borrow_mut().before_memory_read(\n-                alloc_id,\n-                prov_extra,\n-                range,\n-                machine.stacked_borrows.as_ref().unwrap(),\n-                machine.current_span(),\n-                &machine.threads,\n-            )?;\n+            stacked_borrows\n+                .borrow_mut()\n+                .before_memory_read(alloc_id, prov_extra, range, machine)?;\n         }\n         if let Some(weak_memory) = &alloc_extra.weak_memory {\n             weak_memory.memory_accessed(range, machine.data_race.as_ref().unwrap());\n@@ -1035,22 +1025,10 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         if let Some(data_race) = &mut alloc_extra.data_race {\n-            data_race.write(\n-                alloc_id,\n-                range,\n-                machine.data_race.as_mut().unwrap(),\n-                &machine.threads,\n-            )?;\n+            data_race.write(alloc_id, range, machine)?;\n         }\n         if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n-            stacked_borrows.get_mut().before_memory_write(\n-                alloc_id,\n-                prov_extra,\n-                range,\n-                machine.stacked_borrows.as_ref().unwrap(),\n-                machine.current_span(),\n-                &machine.threads,\n-            )?;\n+            stacked_borrows.get_mut().before_memory_write(alloc_id, prov_extra, range, machine)?;\n         }\n         if let Some(weak_memory) = &alloc_extra.weak_memory {\n             weak_memory.memory_accessed(range, machine.data_race.as_ref().unwrap());\n@@ -1070,21 +1048,14 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n             machine.emit_diagnostic(NonHaltingDiagnostic::FreedAlloc(alloc_id));\n         }\n         if let Some(data_race) = &mut alloc_extra.data_race {\n-            data_race.deallocate(\n-                alloc_id,\n-                range,\n-                machine.data_race.as_mut().unwrap(),\n-                &machine.threads,\n-            )?;\n+            data_race.deallocate(alloc_id, range, machine)?;\n         }\n         if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n             stacked_borrows.get_mut().before_memory_deallocation(\n                 alloc_id,\n                 prove_extra,\n                 range,\n-                machine.stacked_borrows.as_ref().unwrap(),\n-                machine.current_span(),\n-                &machine.threads,\n+                machine,\n             )\n         } else {\n             Ok(())\n@@ -1126,7 +1097,9 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n             stacked_borrows: stacked_borrows.map(|sb| sb.borrow_mut().new_frame(&ecx.machine)),\n             catch_unwind: None,\n             timing,\n+            is_user_relevant: ecx.machine.is_user_relevant(&frame),\n         };\n+\n         Ok(frame.with_extra(extra))\n     }\n \n@@ -1174,6 +1147,13 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n \n     #[inline(always)]\n     fn after_stack_push(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n+        if ecx.frame().extra.is_user_relevant {\n+            // We just pushed a local frame, so we know that the topmost local frame is the topmost\n+            // frame. If we push a non-local frame, there's no need to do anything.\n+            let stack_len = ecx.active_thread_stack().len();\n+            ecx.active_thread_mut().set_top_user_relevant_frame(stack_len - 1);\n+        }\n+\n         if ecx.machine.stacked_borrows.is_some() { ecx.retag_return_place() } else { Ok(()) }\n     }\n \n@@ -1183,6 +1163,13 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         mut frame: Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>,\n         unwinding: bool,\n     ) -> InterpResult<'tcx, StackPopJump> {\n+        if frame.extra.is_user_relevant {\n+            // All that we store is whether or not the frame we just removed is local, so now we\n+            // have no idea where the next topmost local frame is. So we recompute it.\n+            // (If this ever becomes a bottleneck, we could have `push` store the previous\n+            // user-relevant frame and restore that here.)\n+            ecx.active_thread_mut().recompute_top_user_relevant_frame();\n+        }\n         let timing = frame.extra.timing.take();\n         if let Some(stacked_borrows) = &ecx.machine.stacked_borrows {\n             stacked_borrows.borrow_mut().end_call(&frame.extra);"}, {"sha": "bc7ca82997bb8e05d663fa4f08b162aa3ea39519", "filename": "src/tools/miri/src/shims/os_str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fos_str.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -18,12 +18,12 @@ pub enum PathConversion {\n }\n \n #[cfg(unix)]\n-pub fn os_str_to_bytes<'a, 'tcx>(os_str: &'a OsStr) -> InterpResult<'tcx, &'a [u8]> {\n+pub fn os_str_to_bytes<'tcx>(os_str: &OsStr) -> InterpResult<'tcx, &[u8]> {\n     Ok(os_str.as_bytes())\n }\n \n #[cfg(not(unix))]\n-pub fn os_str_to_bytes<'a, 'tcx>(os_str: &'a OsStr) -> InterpResult<'tcx, &'a [u8]> {\n+pub fn os_str_to_bytes<'tcx>(os_str: &OsStr) -> InterpResult<'tcx, &[u8]> {\n     // On non-unix platforms the best we can do to transform bytes from/to OS strings is to do the\n     // intermediate transformation into strings. Which invalidates non-utf8 paths that are actually\n     // valid.\n@@ -34,11 +34,11 @@ pub fn os_str_to_bytes<'a, 'tcx>(os_str: &'a OsStr) -> InterpResult<'tcx, &'a [u\n }\n \n #[cfg(unix)]\n-pub fn bytes_to_os_str<'a, 'tcx>(bytes: &'a [u8]) -> InterpResult<'tcx, &'a OsStr> {\n+pub fn bytes_to_os_str<'tcx>(bytes: &[u8]) -> InterpResult<'tcx, &OsStr> {\n     Ok(OsStr::from_bytes(bytes))\n }\n #[cfg(not(unix))]\n-pub fn bytes_to_os_str<'a, 'tcx>(bytes: &'a [u8]) -> InterpResult<'tcx, &'a OsStr> {\n+pub fn bytes_to_os_str<'tcx>(bytes: &[u8]) -> InterpResult<'tcx, &OsStr> {\n     let s = std::str::from_utf8(bytes)\n         .map_err(|_| err_unsup_format!(\"{:?} is not a valid utf-8 string\", bytes))?;\n     Ok(OsStr::new(s))"}, {"sha": "5fda8bd7b7de9a2c00a891e012914e9cca914f79", "filename": "src/tools/miri/src/shims/tls.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -261,6 +261,11 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // (that would be basically https://github.com/rust-lang/miri/issues/450),\n         // we specifically look up the static in libstd that we know is placed\n         // in that section.\n+        if !this.have_module(&[\"std\"]) {\n+            // Looks like we are running in a `no_std` crate.\n+            // That also means no TLS dtors callback to call.\n+            return Ok(());\n+        }\n         let thread_callback =\n             this.eval_windows(\"thread_local_key\", \"p_thread_callback\")?.to_pointer(this)?;\n         let thread_callback = this.get_ptr_fn(thread_callback)?.as_instance()?;"}, {"sha": "e048d53a17e0d498630b698711e830ec60b12ac5", "filename": "src/tools/miri/src/shims/unix/fs.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -11,7 +11,6 @@ use std::time::SystemTime;\n use log::trace;\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_middle::ty::{self, layout::LayoutOf};\n use rustc_target::abi::{Align, Size};\n \n use crate::shims::os_str::bytes_to_os_str;\n@@ -1006,12 +1005,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // as `isize`s instead of having the proper types. Thus, we have to recover the layout of\n         // `statxbuf_op` by using the `libc::statx` struct type.\n         let statxbuf = {\n-            // FIXME: This long path is required because `libc::statx` is an struct and also a\n-            // function and `resolve_path` is returning the latter.\n-            let statx_ty = this\n-                .resolve_path(&[\"libc\", \"unix\", \"linux_like\", \"linux\", \"gnu\", \"statx\"])\n-                .ty(*this.tcx, ty::ParamEnv::reveal_all());\n-            let statx_layout = this.layout_of(statx_ty)?;\n+            let statx_layout = this.libc_ty_layout(\"statx\")?;\n             MPlaceTy::from_aligned_ptr(statxbuf_ptr, statx_layout)\n         };\n \n@@ -1917,8 +1911,8 @@ struct FileMetadata {\n }\n \n impl FileMetadata {\n-    fn from_path<'tcx, 'mir>(\n-        ecx: &mut MiriInterpCx<'mir, 'tcx>,\n+    fn from_path<'tcx>(\n+        ecx: &mut MiriInterpCx<'_, 'tcx>,\n         path: &Path,\n         follow_symlink: bool,\n     ) -> InterpResult<'tcx, Option<FileMetadata>> {\n@@ -1928,8 +1922,8 @@ impl FileMetadata {\n         FileMetadata::from_meta(ecx, metadata)\n     }\n \n-    fn from_fd<'tcx, 'mir>(\n-        ecx: &mut MiriInterpCx<'mir, 'tcx>,\n+    fn from_fd<'tcx>(\n+        ecx: &mut MiriInterpCx<'_, 'tcx>,\n         fd: i32,\n     ) -> InterpResult<'tcx, Option<FileMetadata>> {\n         let option = ecx.machine.file_handler.handles.get(&fd);\n@@ -1942,8 +1936,8 @@ impl FileMetadata {\n         FileMetadata::from_meta(ecx, metadata)\n     }\n \n-    fn from_meta<'tcx, 'mir>(\n-        ecx: &mut MiriInterpCx<'mir, 'tcx>,\n+    fn from_meta<'tcx>(\n+        ecx: &mut MiriInterpCx<'_, 'tcx>,\n         metadata: Result<std::fs::Metadata, std::io::Error>,\n     ) -> InterpResult<'tcx, Option<FileMetadata>> {\n         let metadata = match metadata {"}, {"sha": "9970b79f8c7f17838822938cba38c4dbd3a541b2", "filename": "src/tools/miri/src/stacked_borrows/diagnostics.rs", "status": "modified", "additions": 58, "deletions": 68, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fdiagnostics.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -5,8 +5,7 @@ use rustc_middle::mir::interpret::{alloc_range, AllocId, AllocRange};\n use rustc_span::{Span, SpanData};\n use rustc_target::abi::Size;\n \n-use crate::helpers::CurrentSpan;\n-use crate::stacked_borrows::{err_sb_ub, AccessKind, GlobalStateInner, Permission};\n+use crate::stacked_borrows::{err_sb_ub, AccessKind, GlobalStateInner, Permission, ProtectorKind};\n use crate::*;\n \n use rustc_middle::mir::interpret::InterpError;\n@@ -110,42 +109,29 @@ pub struct TagHistory {\n     pub protected: Option<(String, SpanData)>,\n }\n \n-pub struct DiagnosticCxBuilder<'span, 'ecx, 'mir, 'tcx> {\n+pub struct DiagnosticCxBuilder<'ecx, 'mir, 'tcx> {\n     operation: Operation,\n-    // 'span cannot be merged with any other lifetime since they appear invariantly, under the\n-    // mutable ref.\n-    current_span: &'span mut CurrentSpan<'ecx, 'mir, 'tcx>,\n-    threads: &'ecx ThreadManager<'mir, 'tcx>,\n+    machine: &'ecx MiriMachine<'mir, 'tcx>,\n }\n \n-pub struct DiagnosticCx<'span, 'history, 'ecx, 'mir, 'tcx> {\n+pub struct DiagnosticCx<'history, 'ecx, 'mir, 'tcx> {\n     operation: Operation,\n-    // 'span and 'history cannot be merged, since when we call `unbuild` we need\n-    // to return the exact 'span that was used when calling `build`.\n-    current_span: &'span mut CurrentSpan<'ecx, 'mir, 'tcx>,\n-    threads: &'ecx ThreadManager<'mir, 'tcx>,\n+    machine: &'ecx MiriMachine<'mir, 'tcx>,\n     history: &'history mut AllocHistory,\n     offset: Size,\n }\n \n-impl<'span, 'ecx, 'mir, 'tcx> DiagnosticCxBuilder<'span, 'ecx, 'mir, 'tcx> {\n+impl<'ecx, 'mir, 'tcx> DiagnosticCxBuilder<'ecx, 'mir, 'tcx> {\n     pub fn build<'history>(\n         self,\n         history: &'history mut AllocHistory,\n         offset: Size,\n-    ) -> DiagnosticCx<'span, 'history, 'ecx, 'mir, 'tcx> {\n-        DiagnosticCx {\n-            operation: self.operation,\n-            current_span: self.current_span,\n-            threads: self.threads,\n-            history,\n-            offset,\n-        }\n+    ) -> DiagnosticCx<'history, 'ecx, 'mir, 'tcx> {\n+        DiagnosticCx { operation: self.operation, machine: self.machine, history, offset }\n     }\n \n     pub fn retag(\n-        current_span: &'span mut CurrentSpan<'ecx, 'mir, 'tcx>,\n-        threads: &'ecx ThreadManager<'mir, 'tcx>,\n+        machine: &'ecx MiriMachine<'mir, 'tcx>,\n         cause: RetagCause,\n         new_tag: SbTag,\n         orig_tag: ProvenanceExtra,\n@@ -154,46 +140,36 @@ impl<'span, 'ecx, 'mir, 'tcx> DiagnosticCxBuilder<'span, 'ecx, 'mir, 'tcx> {\n         let operation =\n             Operation::Retag(RetagOp { cause, new_tag, orig_tag, range, permission: None });\n \n-        DiagnosticCxBuilder { current_span, threads, operation }\n+        DiagnosticCxBuilder { machine, operation }\n     }\n \n     pub fn read(\n-        current_span: &'span mut CurrentSpan<'ecx, 'mir, 'tcx>,\n-        threads: &'ecx ThreadManager<'mir, 'tcx>,\n+        machine: &'ecx MiriMachine<'mir, 'tcx>,\n         tag: ProvenanceExtra,\n         range: AllocRange,\n     ) -> Self {\n         let operation = Operation::Access(AccessOp { kind: AccessKind::Read, tag, range });\n-        DiagnosticCxBuilder { current_span, threads, operation }\n+        DiagnosticCxBuilder { machine, operation }\n     }\n \n     pub fn write(\n-        current_span: &'span mut CurrentSpan<'ecx, 'mir, 'tcx>,\n-        threads: &'ecx ThreadManager<'mir, 'tcx>,\n+        machine: &'ecx MiriMachine<'mir, 'tcx>,\n         tag: ProvenanceExtra,\n         range: AllocRange,\n     ) -> Self {\n         let operation = Operation::Access(AccessOp { kind: AccessKind::Write, tag, range });\n-        DiagnosticCxBuilder { current_span, threads, operation }\n+        DiagnosticCxBuilder { machine, operation }\n     }\n \n-    pub fn dealloc(\n-        current_span: &'span mut CurrentSpan<'ecx, 'mir, 'tcx>,\n-        threads: &'ecx ThreadManager<'mir, 'tcx>,\n-        tag: ProvenanceExtra,\n-    ) -> Self {\n+    pub fn dealloc(machine: &'ecx MiriMachine<'mir, 'tcx>, tag: ProvenanceExtra) -> Self {\n         let operation = Operation::Dealloc(DeallocOp { tag });\n-        DiagnosticCxBuilder { current_span, threads, operation }\n+        DiagnosticCxBuilder { machine, operation }\n     }\n }\n \n-impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir, 'tcx> {\n-    pub fn unbuild(self) -> DiagnosticCxBuilder<'span, 'ecx, 'mir, 'tcx> {\n-        DiagnosticCxBuilder {\n-            operation: self.operation,\n-            current_span: self.current_span,\n-            threads: self.threads,\n-        }\n+impl<'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'history, 'ecx, 'mir, 'tcx> {\n+    pub fn unbuild(self) -> DiagnosticCxBuilder<'ecx, 'mir, 'tcx> {\n+        DiagnosticCxBuilder { machine: self.machine, operation: self.operation }\n     }\n }\n \n@@ -234,18 +210,18 @@ struct DeallocOp {\n }\n \n impl AllocHistory {\n-    pub fn new(id: AllocId, item: Item, current_span: &mut CurrentSpan<'_, '_, '_>) -> Self {\n+    pub fn new(id: AllocId, item: Item, machine: &MiriMachine<'_, '_>) -> Self {\n         Self {\n             id,\n-            base: (item, current_span.get()),\n+            base: (item, machine.current_span()),\n             creations: SmallVec::new(),\n             invalidations: SmallVec::new(),\n             protectors: SmallVec::new(),\n         }\n     }\n }\n \n-impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir, 'tcx> {\n+impl<'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'history, 'ecx, 'mir, 'tcx> {\n     pub fn start_grant(&mut self, perm: Permission) {\n         let Operation::Retag(op) = &mut self.operation else {\n             unreachable!(\"start_grant must only be called during a retag, this is: {:?}\", self.operation)\n@@ -274,21 +250,27 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n         let Operation::Retag(op) = &self.operation else {\n             unreachable!(\"log_creation must only be called during a retag\")\n         };\n-        self.history.creations.push(Creation { retag: op.clone(), span: self.current_span.get() });\n+        self.history\n+            .creations\n+            .push(Creation { retag: op.clone(), span: self.machine.current_span() });\n     }\n \n     pub fn log_invalidation(&mut self, tag: SbTag) {\n-        let mut span = self.current_span.get();\n+        let mut span = self.machine.current_span();\n         let (range, cause) = match &self.operation {\n             Operation::Retag(RetagOp { cause, range, permission, .. }) => {\n                 if *cause == RetagCause::FnEntry {\n-                    span = self.current_span.get_caller();\n+                    span = self.machine.caller_span();\n                 }\n                 (*range, InvalidationCause::Retag(permission.unwrap(), *cause))\n             }\n             Operation::Access(AccessOp { kind, range, .. }) =>\n                 (*range, InvalidationCause::Access(*kind)),\n-            _ => unreachable!(\"Tags can only be invalidated during a retag or access\"),\n+            Operation::Dealloc(_) => {\n+                // This can be reached, but never be relevant later since the entire allocation is\n+                // gone now.\n+                return;\n+            }\n         };\n         self.history.invalidations.push(Invalidation { tag, range, span, cause });\n     }\n@@ -297,7 +279,9 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n         let Operation::Retag(op) = &self.operation else {\n             unreachable!(\"Protectors can only be created during a retag\")\n         };\n-        self.history.protectors.push(Protection { tag: op.new_tag, span: self.current_span.get() });\n+        self.history\n+            .protectors\n+            .push(Protection { tag: op.new_tag, span: self.machine.current_span() });\n     }\n \n     pub fn get_logs_relevant_to(\n@@ -369,10 +353,12 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n \n     /// Report a descriptive error when `new` could not be granted from `derived_from`.\n     #[inline(never)] // This is only called on fatal code paths\n-    pub fn grant_error(&self, perm: Permission, stack: &Stack) -> InterpError<'tcx> {\n+    pub(super) fn grant_error(&self, stack: &Stack) -> InterpError<'tcx> {\n         let Operation::Retag(op) = &self.operation else {\n             unreachable!(\"grant_error should only be called during a retag\")\n         };\n+        let perm =\n+            op.permission.expect(\"`start_grant` must be called before calling `grant_error`\");\n         let action = format!(\n             \"trying to retag from {:?} for {:?} permission at {:?}[{:#x}]\",\n             op.orig_tag,\n@@ -389,9 +375,12 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n \n     /// Report a descriptive error when `access` is not permitted based on `tag`.\n     #[inline(never)] // This is only called on fatal code paths\n-    pub fn access_error(&self, stack: &Stack) -> InterpError<'tcx> {\n-        let Operation::Access(op) = &self.operation  else {\n-            unreachable!(\"access_error should only be called during an access\")\n+    pub(super) fn access_error(&self, stack: &Stack) -> InterpError<'tcx> {\n+        // Deallocation and retagging also do an access as part of their thing, so handle that here, too.\n+        let op = match &self.operation {\n+            Operation::Access(op) => op,\n+            Operation::Retag(_) => return self.grant_error(stack),\n+            Operation::Dealloc(_) => return self.dealloc_error(stack),\n         };\n         let action = format!(\n             \"attempting a {access} using {tag:?} at {alloc_id:?}[{offset:#x}]\",\n@@ -408,8 +397,13 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n     }\n \n     #[inline(never)] // This is only called on fatal code paths\n-    pub fn protector_error(&self, item: &Item) -> InterpError<'tcx> {\n+    pub(super) fn protector_error(&self, item: &Item, kind: ProtectorKind) -> InterpError<'tcx> {\n+        let protected = match kind {\n+            ProtectorKind::WeakProtector => \"weakly protected\",\n+            ProtectorKind::StrongProtector => \"strongly protected\",\n+        };\n         let call_id = self\n+            .machine\n             .threads\n             .all_stacks()\n             .flatten()\n@@ -422,19 +416,15 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n         match self.operation {\n             Operation::Dealloc(_) =>\n                 err_sb_ub(\n-                    format!(\n-                        \"deallocating while item {:?} is protected by call {:?}\",\n-                        item, call_id\n-                    ),\n+                    format!(\"deallocating while item {item:?} is {protected} by call {call_id:?}\",),\n                     None,\n                     None,\n                 ),\n             Operation::Retag(RetagOp { orig_tag: tag, .. })\n             | Operation::Access(AccessOp { tag, .. }) =>\n                 err_sb_ub(\n                     format!(\n-                        \"not granting access to tag {:?} because that would remove {:?} which is protected because it is an argument of call {:?}\",\n-                        tag, item, call_id\n+                        \"not granting access to tag {tag:?} because that would remove {item:?} which is {protected} because it is an argument of call {call_id:?}\",\n                     ),\n                     None,\n                     tag.and_then(|tag| self.get_logs_relevant_to(tag, Some(item.tag()))),\n@@ -443,14 +433,16 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n     }\n \n     #[inline(never)] // This is only called on fatal code paths\n-    pub fn dealloc_error(&self) -> InterpError<'tcx> {\n+    pub fn dealloc_error(&self, stack: &Stack) -> InterpError<'tcx> {\n         let Operation::Dealloc(op) = &self.operation else {\n             unreachable!(\"dealloc_error should only be called during a deallocation\")\n         };\n         err_sb_ub(\n             format!(\n-                \"no item granting write access for deallocation to tag {:?} at {:?} found in borrow stack\",\n-                op.tag, self.history.id,\n+                \"attempting deallocation using {tag:?} at {alloc_id:?}{cause}\",\n+                tag = op.tag,\n+                alloc_id = self.history.id,\n+                cause = error_cause(stack, op.tag),\n             ),\n             None,\n             op.tag.and_then(|tag| self.get_logs_relevant_to(tag, None)),\n@@ -478,9 +470,7 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n                 Some((orig_tag, kind))\n             }\n         };\n-        self.current_span\n-            .machine()\n-            .emit_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(*item, summary));\n+        self.machine.emit_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(*item, summary));\n     }\n }\n "}, {"sha": "4e369f4291a3f821c4315e32afe387f0352fb52c", "filename": "src/tools/miri/src/stacked_borrows/mod.rs", "status": "modified", "additions": 173, "deletions": 131, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -65,7 +65,7 @@ pub struct FrameExtra {\n     /// incremental updates of the global list of protected tags stored in the\n     /// `stacked_borrows::GlobalState` upon function return, and if we attempt to pop a protected\n     /// tag, to identify which call is responsible for protecting the tag.\n-    /// See `Stack::item_popped` for more explanation.\n+    /// See `Stack::item_invalidated` for more explanation.\n     ///\n     /// This will contain one tag per reference passed to the function, so\n     /// a size of 2 is enough for the vast majority of functions.\n@@ -91,6 +91,26 @@ pub struct Stacks {\n     modified_since_last_gc: bool,\n }\n \n+/// The flavor of the protector.\n+#[derive(Copy, Clone, Debug)]\n+enum ProtectorKind {\n+    /// Protected against aliasing violations from other pointers.\n+    ///\n+    /// Items protected like this cause UB when they are invalidated, *but* the pointer itself may\n+    /// still be used to issue a deallocation.\n+    ///\n+    /// This is required for LLVM IR pointers that are `noalias` but *not* `dereferenceable`.\n+    WeakProtector,\n+\n+    /// Protected against any kind of invalidation.\n+    ///\n+    /// Items protected like this cause UB when they are invalidated or the memory is deallocated.\n+    /// This is strictly stronger protection than `WeakProtector`.\n+    ///\n+    /// This is required for LLVM IR pointers that are `dereferenceable` (and also allows `noalias`).\n+    StrongProtector,\n+}\n+\n /// Extra global state, available to the memory access hooks.\n #[derive(Debug)]\n pub struct GlobalStateInner {\n@@ -102,12 +122,12 @@ pub struct GlobalStateInner {\n     base_ptr_tags: FxHashMap<AllocId, SbTag>,\n     /// Next unused call ID (for protectors).\n     next_call_id: CallId,\n-    /// All currently protected tags.\n+    /// All currently protected tags, and the status of their protection.\n     /// An item is protected if its tag is in this set, *and* it has the \"protected\" bit set.\n     /// We add tags to this when they are created with a protector in `reborrow`, and\n     /// we remove tags from this when the call which is protecting them returns, in\n-    /// `GlobalStateInner::end_call`. See `Stack::item_popped` for more details.\n-    protected_tags: FxHashSet<SbTag>,\n+    /// `GlobalStateInner::end_call`. See `Stack::item_invalidated` for more details.\n+    protected_tags: FxHashMap<SbTag, ProtectorKind>,\n     /// The pointer ids to trace\n     tracked_pointer_tags: FxHashSet<SbTag>,\n     /// The call ids to trace\n@@ -189,7 +209,7 @@ impl GlobalStateInner {\n             next_ptr_tag: SbTag(NonZeroU64::new(1).unwrap()),\n             base_ptr_tags: FxHashMap::default(),\n             next_call_id: NonZeroU64::new(1).unwrap(),\n-            protected_tags: FxHashSet::default(),\n+            protected_tags: FxHashMap::default(),\n             tracked_pointer_tags,\n             tracked_call_ids,\n             retag_fields,\n@@ -272,6 +292,13 @@ impl Permission {\n     }\n }\n \n+/// Determines whether an item was invalidated by a conflicting access, or by deallocation.\n+#[derive(Copy, Clone, Debug)]\n+enum ItemInvalidationCause {\n+    Conflict,\n+    Dealloc,\n+}\n+\n /// Core per-location operations: access, dealloc, reborrow.\n impl<'tcx> Stack {\n     /// Find the first write-incompatible item above the given one --\n@@ -310,10 +337,11 @@ impl<'tcx> Stack {\n     /// Within `provoking_access, the `AllocRange` refers the entire operation, and\n     /// the `Size` refers to the specific location in the `AllocRange` that we are\n     /// currently checking.\n-    fn item_popped(\n+    fn item_invalidated(\n         item: &Item,\n         global: &GlobalStateInner,\n-        dcx: &mut DiagnosticCx<'_, '_, '_, '_, 'tcx>,\n+        dcx: &mut DiagnosticCx<'_, '_, '_, 'tcx>,\n+        cause: ItemInvalidationCause,\n     ) -> InterpResult<'tcx> {\n         if !global.tracked_pointer_tags.is_empty() {\n             dcx.check_tracked_tag_popped(item, global);\n@@ -336,8 +364,14 @@ impl<'tcx> Stack {\n         // 2. Most frames protect only one or two tags. So this duplicative global turns a search\n         //    which ends up about linear in the number of protected tags in the program into a\n         //    constant time check (and a slow linear, because the tags in the frames aren't contiguous).\n-        if global.protected_tags.contains(&item.tag()) {\n-            return Err(dcx.protector_error(item).into());\n+        if let Some(&protector_kind) = global.protected_tags.get(&item.tag()) {\n+            // The only way this is okay is if the protector is weak and we are deallocating with\n+            // the right pointer.\n+            let allowed = matches!(cause, ItemInvalidationCause::Dealloc)\n+                && matches!(protector_kind, ProtectorKind::WeakProtector);\n+            if !allowed {\n+                return Err(dcx.protector_error(item, protector_kind).into());\n+            }\n         }\n         Ok(())\n     }\n@@ -350,15 +384,15 @@ impl<'tcx> Stack {\n         &mut self,\n         access: AccessKind,\n         tag: ProvenanceExtra,\n-        global: &mut GlobalStateInner,\n-        dcx: &mut DiagnosticCx<'_, '_, '_, '_, 'tcx>,\n+        global: &GlobalStateInner,\n+        dcx: &mut DiagnosticCx<'_, '_, '_, 'tcx>,\n         exposed_tags: &FxHashSet<SbTag>,\n     ) -> InterpResult<'tcx> {\n         // Two main steps: Find granting item, remove incompatible items above.\n \n         // Step 1: Find granting item.\n         let granting_idx =\n-            self.find_granting(access, tag, exposed_tags).map_err(|_| dcx.access_error(self))?;\n+            self.find_granting(access, tag, exposed_tags).map_err(|()| dcx.access_error(self))?;\n \n         // Step 2: Remove incompatible items above them.  Make sure we do not remove protected\n         // items.  Behavior differs for reads and writes.\n@@ -377,7 +411,7 @@ impl<'tcx> Stack {\n                 0\n             };\n             self.pop_items_after(first_incompatible_idx, |item| {\n-                Stack::item_popped(&item, global, dcx)?;\n+                Stack::item_invalidated(&item, global, dcx, ItemInvalidationCause::Conflict)?;\n                 dcx.log_invalidation(item.tag());\n                 Ok(())\n             })?;\n@@ -398,7 +432,7 @@ impl<'tcx> Stack {\n                 0\n             };\n             self.disable_uniques_starting_at(first_incompatible_idx, |item| {\n-                Stack::item_popped(&item, global, dcx)?;\n+                Stack::item_invalidated(&item, global, dcx, ItemInvalidationCause::Conflict)?;\n                 dcx.log_invalidation(item.tag());\n                 Ok(())\n             })?;\n@@ -437,56 +471,59 @@ impl<'tcx> Stack {\n         &mut self,\n         tag: ProvenanceExtra,\n         global: &GlobalStateInner,\n-        dcx: &mut DiagnosticCx<'_, '_, '_, '_, 'tcx>,\n+        dcx: &mut DiagnosticCx<'_, '_, '_, 'tcx>,\n         exposed_tags: &FxHashSet<SbTag>,\n     ) -> InterpResult<'tcx> {\n-        // Step 1: Make sure there is a granting item.\n-        self.find_granting(AccessKind::Write, tag, exposed_tags)\n-            .map_err(|_| dcx.dealloc_error())?;\n+        // Step 1: Make a write access.\n+        // As part of this we do regular protector checking, i.e. even weakly protected items cause UB when popped.\n+        self.access(AccessKind::Write, tag, global, dcx, exposed_tags)?;\n \n-        // Step 2: Consider all items removed. This checks for protectors.\n+        // Step 2: Pretend we remove the remaining items, checking if any are strongly protected.\n         for idx in (0..self.len()).rev() {\n             let item = self.get(idx).unwrap();\n-            Stack::item_popped(&item, global, dcx)?;\n+            Stack::item_invalidated(&item, global, dcx, ItemInvalidationCause::Dealloc)?;\n         }\n \n         Ok(())\n     }\n \n     /// Derive a new pointer from one with the given tag.\n-    /// `weak` controls whether this operation is weak or strong: weak granting does not act as\n-    /// an access, and they add the new item directly on top of the one it is derived\n-    /// from instead of all the way at the top of the stack.\n-    /// `range` refers the entire operation, and `offset` refers to the specific location in\n-    /// `range` that we are currently checking.\n+    ///\n+    /// `access` indicates which kind of memory access this retag itself should correspond to.\n     fn grant(\n         &mut self,\n         derived_from: ProvenanceExtra,\n         new: Item,\n-        global: &mut GlobalStateInner,\n-        dcx: &mut DiagnosticCx<'_, '_, '_, '_, 'tcx>,\n+        access: Option<AccessKind>,\n+        global: &GlobalStateInner,\n+        dcx: &mut DiagnosticCx<'_, '_, '_, 'tcx>,\n         exposed_tags: &FxHashSet<SbTag>,\n     ) -> InterpResult<'tcx> {\n         dcx.start_grant(new.perm());\n \n-        // Figure out which access `perm` corresponds to.\n-        let access =\n-            if new.perm().grants(AccessKind::Write) { AccessKind::Write } else { AccessKind::Read };\n-\n-        // Now we figure out which item grants our parent (`derived_from`) this kind of access.\n-        // We use that to determine where to put the new item.\n-        let granting_idx = self\n-            .find_granting(access, derived_from, exposed_tags)\n-            .map_err(|_| dcx.grant_error(new.perm(), self))?;\n-\n         // Compute where to put the new item.\n         // Either way, we ensure that we insert the new item in a way such that between\n         // `derived_from` and the new one, there are only items *compatible with* `derived_from`.\n-        let new_idx = if new.perm() == Permission::SharedReadWrite {\n-            assert!(\n-                access == AccessKind::Write,\n-                \"this case only makes sense for stack-like accesses\"\n-            );\n+        let new_idx = if let Some(access) = access {\n+            // Simple case: We are just a regular memory access, and then push our thing on top,\n+            // like a regular stack.\n+            // This ensures F2b for `Unique`, by removing offending `SharedReadOnly`.\n+            self.access(access, derived_from, global, dcx, exposed_tags)?;\n+\n+            // We insert \"as far up as possible\": We know only compatible items are remaining\n+            // on top of `derived_from`, and we want the new item at the top so that we\n+            // get the strongest possible guarantees.\n+            // This ensures U1 and F1.\n+            self.len()\n+        } else {\n+            // The tricky case: creating a new SRW permission without actually being an access.\n+            assert!(new.perm() == Permission::SharedReadWrite);\n+\n+            // First we figure out which item grants our parent (`derived_from`) this kind of access.\n+            // We use that to determine where to put the new item.\n+            let granting_idx = self\n+                .find_granting(AccessKind::Write, derived_from, exposed_tags)\n+                .map_err(|()| dcx.grant_error(self))?;\n \n             let (Some(granting_idx), ProvenanceExtra::Concrete(_)) = (granting_idx, derived_from) else {\n                 // The parent is a wildcard pointer or matched the unknown bottom.\n@@ -503,17 +540,6 @@ impl<'tcx> Stack {\n             // be popped to (i.e., we insert it above all the write-compatible items).\n             // This ensures F2b by adding the new item below any potentially existing `SharedReadOnly`.\n             self.find_first_write_incompatible(granting_idx)\n-        } else {\n-            // A \"safe\" reborrow for a pointer that actually expects some aliasing guarantees.\n-            // Here, creating a reference actually counts as an access.\n-            // This ensures F2b for `Unique`, by removing offending `SharedReadOnly`.\n-            self.access(access, derived_from, global, dcx, exposed_tags)?;\n-\n-            // We insert \"as far up as possible\": We know only compatible items are remaining\n-            // on top of `derived_from`, and we want the new item at the top so that we\n-            // get the strongest possible guarantees.\n-            // This ensures U1 and F1.\n-            self.len()\n         };\n \n         // Put the new item there.\n@@ -555,14 +581,14 @@ impl<'tcx> Stacks {\n         perm: Permission,\n         tag: SbTag,\n         id: AllocId,\n-        current_span: &mut CurrentSpan<'_, '_, '_>,\n+        machine: &MiriMachine<'_, '_>,\n     ) -> Self {\n         let item = Item::new(tag, perm, false);\n         let stack = Stack::new(item);\n \n         Stacks {\n             stacks: RangeMap::new(size, stack),\n-            history: AllocHistory::new(id, item, current_span),\n+            history: AllocHistory::new(id, item, machine),\n             exposed_tags: FxHashSet::default(),\n             modified_since_last_gc: false,\n         }\n@@ -572,10 +598,10 @@ impl<'tcx> Stacks {\n     fn for_each(\n         &mut self,\n         range: AllocRange,\n-        mut dcx_builder: DiagnosticCxBuilder<'_, '_, '_, 'tcx>,\n+        mut dcx_builder: DiagnosticCxBuilder<'_, '_, 'tcx>,\n         mut f: impl FnMut(\n             &mut Stack,\n-            &mut DiagnosticCx<'_, '_, '_, '_, 'tcx>,\n+            &mut DiagnosticCx<'_, '_, '_, 'tcx>,\n             &mut FxHashSet<SbTag>,\n         ) -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx> {\n@@ -596,7 +622,7 @@ impl Stacks {\n         size: Size,\n         state: &GlobalState,\n         kind: MemoryKind<MiriMemoryKind>,\n-        mut current_span: CurrentSpan<'_, '_, '_>,\n+        machine: &MiriMachine<'_, '_>,\n     ) -> Self {\n         let mut extra = state.borrow_mut();\n         let (base_tag, perm) = match kind {\n@@ -605,12 +631,11 @@ impl Stacks {\n             // not through a pointer). That is, whenever we directly write to a local, this will pop\n             // everything else off the stack, invalidating all previous pointers,\n             // and in particular, *all* raw pointers.\n-            MemoryKind::Stack =>\n-                (extra.base_ptr_tag(id, current_span.machine()), Permission::Unique),\n+            MemoryKind::Stack => (extra.base_ptr_tag(id, machine), Permission::Unique),\n             // Everything else is shared by default.\n-            _ => (extra.base_ptr_tag(id, current_span.machine()), Permission::SharedReadWrite),\n+            _ => (extra.base_ptr_tag(id, machine), Permission::SharedReadWrite),\n         };\n-        Stacks::new(size, perm, base_tag, id, &mut current_span)\n+        Stacks::new(size, perm, base_tag, id, machine)\n     }\n \n     #[inline(always)]\n@@ -619,9 +644,7 @@ impl Stacks {\n         alloc_id: AllocId,\n         tag: ProvenanceExtra,\n         range: AllocRange,\n-        state: &GlobalState,\n-        mut current_span: CurrentSpan<'ecx, 'mir, 'tcx>,\n-        threads: &'ecx ThreadManager<'mir, 'tcx>,\n+        machine: &'ecx MiriMachine<'mir, 'tcx>,\n     ) -> InterpResult<'tcx>\n     where\n         'tcx: 'ecx,\n@@ -632,49 +655,45 @@ impl Stacks {\n             Pointer::new(alloc_id, range.start),\n             range.size.bytes()\n         );\n-        let dcx = DiagnosticCxBuilder::read(&mut current_span, threads, tag, range);\n-        let mut state = state.borrow_mut();\n+        let dcx = DiagnosticCxBuilder::read(machine, tag, range);\n+        let state = machine.stacked_borrows.as_ref().unwrap().borrow();\n         self.for_each(range, dcx, |stack, dcx, exposed_tags| {\n-            stack.access(AccessKind::Read, tag, &mut state, dcx, exposed_tags)\n+            stack.access(AccessKind::Read, tag, &state, dcx, exposed_tags)\n         })\n     }\n \n     #[inline(always)]\n-    pub fn before_memory_write<'tcx, 'mir, 'ecx>(\n+    pub fn before_memory_write<'tcx>(\n         &mut self,\n         alloc_id: AllocId,\n         tag: ProvenanceExtra,\n         range: AllocRange,\n-        state: &GlobalState,\n-        mut current_span: CurrentSpan<'ecx, 'mir, 'tcx>,\n-        threads: &'ecx ThreadManager<'mir, 'tcx>,\n+        machine: &mut MiriMachine<'_, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         trace!(\n             \"write access with tag {:?}: {:?}, size {}\",\n             tag,\n             Pointer::new(alloc_id, range.start),\n             range.size.bytes()\n         );\n-        let dcx = DiagnosticCxBuilder::write(&mut current_span, threads, tag, range);\n-        let mut state = state.borrow_mut();\n+        let dcx = DiagnosticCxBuilder::write(machine, tag, range);\n+        let state = machine.stacked_borrows.as_ref().unwrap().borrow();\n         self.for_each(range, dcx, |stack, dcx, exposed_tags| {\n-            stack.access(AccessKind::Write, tag, &mut state, dcx, exposed_tags)\n+            stack.access(AccessKind::Write, tag, &state, dcx, exposed_tags)\n         })\n     }\n \n     #[inline(always)]\n-    pub fn before_memory_deallocation<'tcx, 'mir, 'ecx>(\n+    pub fn before_memory_deallocation<'tcx>(\n         &mut self,\n         alloc_id: AllocId,\n         tag: ProvenanceExtra,\n         range: AllocRange,\n-        state: &GlobalState,\n-        mut current_span: CurrentSpan<'ecx, 'mir, 'tcx>,\n-        threads: &'ecx ThreadManager<'mir, 'tcx>,\n+        machine: &mut MiriMachine<'_, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         trace!(\"deallocation with tag {:?}: {:?}, size {}\", tag, alloc_id, range.size.bytes());\n-        let dcx = DiagnosticCxBuilder::dealloc(&mut current_span, threads, tag);\n-        let state = state.borrow();\n+        let dcx = DiagnosticCxBuilder::dealloc(machine, tag);\n+        let state = machine.stacked_borrows.as_ref().unwrap().borrow();\n         self.for_each(range, dcx, |stack, dcx, exposed_tags| {\n             stack.dealloc(tag, &state, dcx, exposed_tags)\n         })?;\n@@ -698,7 +717,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         kind: RefKind,\n         retag_cause: RetagCause, // What caused this retag, for diagnostics only\n         new_tag: SbTag,\n-        protect: bool,\n+        protect: Option<ProtectorKind>,\n     ) -> InterpResult<'tcx, Option<AllocId>> {\n         let this = self.eval_context_mut();\n \n@@ -738,7 +757,6 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n             let (_size, _align, alloc_kind) = this.get_alloc_info(alloc_id);\n             match alloc_kind {\n                 AllocKind::LiveData => {\n-                    let current_span = &mut this.machine.current_span();\n                     // This should have alloc_extra data, but `get_alloc_extra` can still fail\n                     // if converting this alloc_id from a global to a local one\n                     // uncovers a non-supported `extern static`.\n@@ -748,20 +766,18 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                         .as_ref()\n                         .expect(\"we should have Stacked Borrows data\")\n                         .borrow_mut();\n-                    let threads = &this.machine.threads;\n                     // Note that we create a *second* `DiagnosticCxBuilder` below for the actual retag.\n                     // FIXME: can this be done cleaner?\n                     let dcx = DiagnosticCxBuilder::retag(\n-                        current_span,\n-                        threads,\n+                        &this.machine,\n                         retag_cause,\n                         new_tag,\n                         orig_tag,\n                         alloc_range(base_offset, size),\n                     );\n                     let mut dcx = dcx.build(&mut stacked_borrows.history, base_offset);\n                     dcx.log_creation();\n-                    if protect {\n+                    if protect.is_some() {\n                         dcx.log_protector();\n                     }\n                 }\n@@ -821,70 +837,89 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n             size.bytes()\n         );\n \n-        if protect {\n-            // See comment in `Stack::item_popped` for why we store the tag twice.\n+        if let Some(protect) = protect {\n+            // See comment in `Stack::item_invalidated` for why we store the tag twice.\n             this.frame_mut().extra.stacked_borrows.as_mut().unwrap().protected_tags.push(new_tag);\n-            this.machine.stacked_borrows.as_mut().unwrap().get_mut().protected_tags.insert(new_tag);\n+            this.machine\n+                .stacked_borrows\n+                .as_mut()\n+                .unwrap()\n+                .get_mut()\n+                .protected_tags\n+                .insert(new_tag, protect);\n         }\n \n         // Update the stacks.\n         // Make sure that raw pointers and mutable shared references are reborrowed \"weak\":\n         // There could be existing unique pointers reborrowed from them that should remain valid!\n-        let perm = match kind {\n-            RefKind::Unique { two_phase: false }\n-                if place.layout.ty.is_unpin(*this.tcx, this.param_env()) =>\n-            {\n-                // Only if the type is unpin do we actually enforce uniqueness\n-                Permission::Unique\n+        let (perm, access) = match kind {\n+            RefKind::Unique { two_phase } => {\n+                // Permission is Unique only if the type is `Unpin` and this is not twophase\n+                let perm = if !two_phase && place.layout.ty.is_unpin(*this.tcx, this.param_env()) {\n+                    Permission::Unique\n+                } else {\n+                    Permission::SharedReadWrite\n+                };\n+                // We do an access for all full borrows, even if `!Unpin`.\n+                let access = if !two_phase { Some(AccessKind::Write) } else { None };\n+                (perm, access)\n             }\n-            RefKind::Unique { .. } => {\n-                // Two-phase references and !Unpin references are treated as SharedReadWrite\n-                Permission::SharedReadWrite\n+            RefKind::Raw { mutable: true } => {\n+                // Creating a raw ptr does not count as an access\n+                (Permission::SharedReadWrite, None)\n             }\n-            RefKind::Raw { mutable: true } => Permission::SharedReadWrite,\n             RefKind::Shared | RefKind::Raw { mutable: false } => {\n                 // Shared references and *const are a whole different kind of game, the\n                 // permission is not uniform across the entire range!\n                 // We need a frozen-sensitive reborrow.\n                 // We have to use shared references to alloc/memory_extra here since\n                 // `visit_freeze_sensitive` needs to access the global state.\n-                let extra = this.get_alloc_extra(alloc_id)?;\n-                let mut stacked_borrows = extra\n+                let alloc_extra = this.get_alloc_extra(alloc_id)?;\n+                let mut stacked_borrows = alloc_extra\n                     .stacked_borrows\n                     .as_ref()\n                     .expect(\"we should have Stacked Borrows data\")\n                     .borrow_mut();\n-                // FIXME: can't share this with the current_span inside log_creation\n-                let mut current_span = this.machine.current_span();\n                 this.visit_freeze_sensitive(place, size, |mut range, frozen| {\n                     // Adjust range.\n                     range.start += base_offset;\n                     // We are only ever `SharedReadOnly` inside the frozen bits.\n-                    let perm = if frozen {\n-                        Permission::SharedReadOnly\n+                    let (perm, access) = if frozen {\n+                        (Permission::SharedReadOnly, Some(AccessKind::Read))\n                     } else {\n-                        Permission::SharedReadWrite\n+                        // Inside UnsafeCell, this does *not* count as an access, as there\n+                        // might actually be mutable references further up the stack that\n+                        // we have to keep alive.\n+                        (Permission::SharedReadWrite, None)\n                     };\n                     let protected = if frozen {\n-                        protect\n+                        protect.is_some()\n                     } else {\n                         // We do not protect inside UnsafeCell.\n                         // This fixes https://github.com/rust-lang/rust/issues/55005.\n                         false\n                     };\n                     let item = Item::new(new_tag, perm, protected);\n-                    let mut global = this.machine.stacked_borrows.as_ref().unwrap().borrow_mut();\n+                    let global = this.machine.stacked_borrows.as_ref().unwrap().borrow();\n                     let dcx = DiagnosticCxBuilder::retag(\n-                        &mut current_span, // FIXME avoid this `clone`\n-                        &this.machine.threads,\n+                        &this.machine,\n                         retag_cause,\n                         new_tag,\n                         orig_tag,\n                         alloc_range(base_offset, size),\n                     );\n                     stacked_borrows.for_each(range, dcx, |stack, dcx, exposed_tags| {\n-                        stack.grant(orig_tag, item, &mut global, dcx, exposed_tags)\n-                    })\n+                        stack.grant(orig_tag, item, access, &global, dcx, exposed_tags)\n+                    })?;\n+                    drop(global);\n+                    if let Some(access) = access {\n+                        assert_eq!(access, AccessKind::Read);\n+                        // Make sure the data race model also knows about this.\n+                        if let Some(data_race) = alloc_extra.data_race.as_ref() {\n+                            data_race.read(alloc_id, range, &this.machine)?;\n+                        }\n+                    }\n+                    Ok(())\n                 })?;\n                 return Ok(Some(alloc_id));\n             }\n@@ -894,27 +929,32 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         // Note that this asserts that the allocation is mutable -- but since we are creating a\n         // mutable pointer, that seems reasonable.\n         let (alloc_extra, machine) = this.get_alloc_extra_mut(alloc_id)?;\n-        let mut stacked_borrows = alloc_extra\n+        let stacked_borrows = alloc_extra\n             .stacked_borrows\n             .as_mut()\n             .expect(\"we should have Stacked Borrows data\")\n-            .borrow_mut();\n-        let item = Item::new(new_tag, perm, protect);\n+            .get_mut();\n+        let item = Item::new(new_tag, perm, protect.is_some());\n         let range = alloc_range(base_offset, size);\n-        let mut global = machine.stacked_borrows.as_ref().unwrap().borrow_mut();\n-        // FIXME: can't share this with the current_span inside log_creation\n-        let current_span = &mut machine.current_span();\n+        let global = machine.stacked_borrows.as_ref().unwrap().borrow();\n         let dcx = DiagnosticCxBuilder::retag(\n-            current_span,\n-            &machine.threads,\n+            machine,\n             retag_cause,\n             new_tag,\n             orig_tag,\n             alloc_range(base_offset, size),\n         );\n         stacked_borrows.for_each(range, dcx, |stack, dcx, exposed_tags| {\n-            stack.grant(orig_tag, item, &mut global, dcx, exposed_tags)\n+            stack.grant(orig_tag, item, access, &global, dcx, exposed_tags)\n         })?;\n+        drop(global);\n+        if let Some(access) = access {\n+            assert_eq!(access, AccessKind::Write);\n+            // Make sure the data race model also knows about this.\n+            if let Some(data_race) = alloc_extra.data_race.as_mut() {\n+                data_race.write(alloc_id, range, machine)?;\n+            }\n+        }\n \n         Ok(Some(alloc_id))\n     }\n@@ -926,7 +966,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         val: &ImmTy<'tcx, Provenance>,\n         kind: RefKind,\n         retag_cause: RetagCause, // What caused this retag, for diagnostics only\n-        protect: bool,\n+        protect: Option<ProtectorKind>,\n     ) -> InterpResult<'tcx, ImmTy<'tcx, Provenance>> {\n         let this = self.eval_context_mut();\n         // We want a place for where the ptr *points to*, so we get one.\n@@ -996,7 +1036,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 place: &PlaceTy<'tcx, Provenance>,\n                 ref_kind: RefKind,\n                 retag_cause: RetagCause,\n-                protector: bool,\n+                protector: Option<ProtectorKind>,\n             ) -> InterpResult<'tcx> {\n                 let val = self.ecx.read_immediate(&self.ecx.place_to_op(place)?)?;\n                 let val = self.ecx.retag_reference(&val, ref_kind, retag_cause, protector)?;\n@@ -1015,13 +1055,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             }\n \n             fn visit_box(&mut self, place: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n-                // Boxes do not get a protector: protectors reflect that references outlive the call\n-                // they were passed in to; that's just not the case for boxes.\n+                // Boxes get a weak protectors, since they may be deallocated.\n                 self.retag_place(\n                     place,\n                     RefKind::Unique { two_phase: false },\n                     self.retag_cause,\n-                    /*protector*/ false,\n+                    /*protector*/\n+                    (self.kind == RetagKind::FnEntry).then_some(ProtectorKind::WeakProtector),\n                 )\n             }\n \n@@ -1046,7 +1086,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                             place,\n                             ref_kind,\n                             self.retag_cause,\n-                            /*protector*/ self.kind == RetagKind::FnEntry,\n+                            /*protector*/\n+                            (self.kind == RetagKind::FnEntry)\n+                                .then_some(ProtectorKind::StrongProtector),\n                         )?;\n                     }\n                     ty::RawPtr(tym) => {\n@@ -1059,7 +1101,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                                 place,\n                                 RefKind::Raw { mutable: tym.mutbl == Mutability::Mut },\n                                 self.retag_cause,\n-                                /*protector*/ false,\n+                                /*protector*/ None,\n                             )?;\n                         }\n                     }\n@@ -1110,12 +1152,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // (The pointer type does not matter, so we use a raw pointer.)\n         let ptr_layout = this.layout_of(this.tcx.mk_mut_ptr(return_place.layout.ty))?;\n         let val = ImmTy::from_immediate(return_place.to_ref(this), ptr_layout);\n-        // Reborrow it.\n+        // Reborrow it. With protection! That is part of the point.\n         let val = this.retag_reference(\n             &val,\n             RefKind::Unique { two_phase: false },\n             RetagCause::FnReturn,\n-            /*protector*/ true,\n+            /*protector*/ Some(ProtectorKind::StrongProtector),\n         )?;\n         // And use reborrowed pointer for return place.\n         let return_place = this.ref_to_mplace(&val)?;"}, {"sha": "51a6fba6df01144d50b166bddd2f9f5a6b5033d1", "filename": "src/tools/miri/src/stacked_borrows/stack.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fstack.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -367,10 +367,10 @@ impl<'tcx> Stack {\n \n     /// Find all `Unique` elements in this borrow stack above `granting_idx`, pass a copy of them\n     /// to the `visitor`, then set their `Permission` to `Disabled`.\n-    pub fn disable_uniques_starting_at<V: FnMut(Item) -> crate::InterpResult<'tcx>>(\n+    pub fn disable_uniques_starting_at(\n         &mut self,\n         disable_start: usize,\n-        mut visitor: V,\n+        mut visitor: impl FnMut(Item) -> crate::InterpResult<'tcx>,\n     ) -> crate::InterpResult<'tcx> {\n         #[cfg(feature = \"stack-cache\")]\n         let unique_range = self.unique_range.clone();"}, {"sha": "37c996de6623c7e24c4e80a848b050586d644635", "filename": "src/tools/miri/test-cargo-miri/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2FCargo.toml?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,5 +1,6 @@\n [workspace]\n members = [\"subcrate\", \"issue-1567\", \"exported-symbol-dep\"]\n+exclude = [\"no-std-smoke\"] # it wants to be panic=\"abort\"\n \n [package]\n name = \"cargo-miri-test\""}, {"sha": "b92a05fccf80fe32fe04dbf169c617ef9373eaf9", "filename": "src/tools/miri/test-cargo-miri/no-std-smoke/Cargo.lock", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fno-std-smoke%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fno-std-smoke%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fno-std-smoke%2FCargo.lock?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -0,0 +1,7 @@\n+# This file is automatically @generated by Cargo.\n+# It is not intended for manual editing.\n+version = 3\n+\n+[[package]]\n+name = \"no-std-smoke\"\n+version = \"0.1.0\""}, {"sha": "3a056bedaa0034d831e5e943a7aa8f7517083bb4", "filename": "src/tools/miri/test-cargo-miri/no-std-smoke/Cargo.toml", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fno-std-smoke%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fno-std-smoke%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fno-std-smoke%2FCargo.toml?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -0,0 +1,14 @@\n+[package]\n+name = \"no-std-smoke\"\n+version = \"0.1.0\"\n+edition = \"2021\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]\n+\n+[profile.dev]\n+panic = 'abort'\n+\n+[profile.release]\n+panic = 'abort'"}, {"sha": "3a207b7d50aa2294dcb23fdfcac53a8a15e675fb", "filename": "src/tools/miri/test-cargo-miri/no-std-smoke/src/main.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fno-std-smoke%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fno-std-smoke%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fno-std-smoke%2Fsrc%2Fmain.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -0,0 +1,34 @@\n+// Copied from tests/pass/no-std.rs\n+\n+#![feature(start)]\n+#![no_std]\n+\n+// Plumbing to let us use `writeln!` to host stdout:\n+\n+extern \"Rust\" {\n+    fn miri_write_to_stdout(bytes: &[u8]);\n+}\n+\n+struct Host;\n+\n+use core::fmt::Write;\n+\n+impl Write for Host {\n+    fn write_str(&mut self, s: &str) -> core::fmt::Result {\n+        unsafe {\n+            miri_write_to_stdout(s.as_bytes());\n+        }\n+        Ok(())\n+    }\n+}\n+\n+#[start]\n+fn start(_: isize, _: *const *const u8) -> isize {\n+    writeln!(Host, \"hello, world!\").unwrap();\n+    0\n+}\n+\n+#[panic_handler]\n+fn panic_handler(_: &core::panic::PanicInfo) -> ! {\n+    loop {}\n+}"}, {"sha": "c728e7c0778db8dd70b9ce77acafa85c37dc24aa", "filename": "src/tools/miri/test_dependencies/Cargo.lock", "status": "modified", "additions": 54, "deletions": 40, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftest_dependencies%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftest_dependencies%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest_dependencies%2FCargo.lock?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -16,9 +16,9 @@ checksum = \"bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a\"\n \n [[package]]\n name = \"bytes\"\n-version = \"1.2.1\"\n+version = \"1.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ec8a7b6a70fde80372154c65702f00a0f56f3e1c36abbc6c440484be248856db\"\n+checksum = \"dfb24e866b15a1af2a1b663f10c6b6b8f397a84aadb828f12e5b289ec23a3a3c\"\n \n [[package]]\n name = \"cfg-if\"\n@@ -39,9 +39,9 @@ dependencies = [\n \n [[package]]\n name = \"getrandom\"\n-version = \"0.2.7\"\n+version = \"0.2.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4eb1a864a501629691edf6c15a593b7a51eebaa1e8468e9ddc623de7c9b58ec6\"\n+checksum = \"c05aeb6a22b8f62540c194aac980f2115af067bfe15a0734d7277a768d396b31\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n@@ -59,9 +59,9 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.133\"\n+version = \"0.2.137\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c0f80d65747a3e43d1596c7c5492d95d5edddaabd45a7fcdb02b95f644164966\"\n+checksum = \"fc7fcc620a3bff7cdd7a365be3376c97191aeaccc2a603e600951e452615bf89\"\n \n [[package]]\n name = \"lock_api\"\n@@ -90,9 +90,9 @@ checksum = \"2dffe52ecf27772e601905b7522cb4ef790d2cc203488bbd0e2fe85fcb74566d\"\n \n [[package]]\n name = \"mio\"\n-version = \"0.8.4\"\n+version = \"0.8.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"57ee1c23c7c63b0c9250c339ffdc69255f110b298b901b9f6c82547b7b87caaf\"\n+checksum = \"e5d732bc30207a6423068df043e3d02e0735b155ad7ce1a6f76fe2baa5b158de\"\n dependencies = [\n  \"libc\",\n  \"log\",\n@@ -105,7 +105,7 @@ name = \"miri-test-deps\"\n version = \"0.1.0\"\n dependencies = [\n  \"getrandom 0.1.16\",\n- \"getrandom 0.2.7\",\n+ \"getrandom 0.2.8\",\n  \"libc\",\n  \"num_cpus\",\n  \"page_size\",\n@@ -115,19 +115,19 @@ dependencies = [\n \n [[package]]\n name = \"num_cpus\"\n-version = \"1.13.1\"\n+version = \"1.14.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"19e64526ebdee182341572e50e9ad03965aa510cd94427a4549448f285e957a1\"\n+checksum = \"f6058e64324c71e02bc2b150e4f3bc8286db6c83092132ffa3f6b1eab0f9def5\"\n dependencies = [\n  \"hermit-abi\",\n  \"libc\",\n ]\n \n [[package]]\n name = \"page_size\"\n-version = \"0.4.2\"\n+version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"eebde548fbbf1ea81a99b128872779c437752fb99f217c45245e1a61dcd9edcd\"\n+checksum = \"1b7663cbd190cfd818d08efa8497f6cd383076688c49a391ef7c0d03cd12b561\"\n dependencies = [\n  \"libc\",\n  \"winapi\",\n@@ -145,9 +145,9 @@ dependencies = [\n \n [[package]]\n name = \"parking_lot_core\"\n-version = \"0.9.3\"\n+version = \"0.9.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"09a279cbf25cb0757810394fbc1e359949b59e348145c643a939a525692e6929\"\n+checksum = \"4dc9e0dc2adc1c69d09143aff38d3d30c5c3f0df0dad82e6d25547af174ebec0\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n@@ -164,15 +164,15 @@ checksum = \"e0a7ae3ac2f1173085d398531c705756c94a4c56843785df85a60c1a0afac116\"\n \n [[package]]\n name = \"ppv-lite86\"\n-version = \"0.2.16\"\n+version = \"0.2.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"eb9f9e6e233e5c4a35559a617bf40a4ec447db2e84c20b55a6f83167b7e57872\"\n+checksum = \"5b40af805b3121feab8a3c29f04d8ad262fa8e0561883e7653e024ae4479e6de\"\n \n [[package]]\n name = \"proc-macro2\"\n-version = \"1.0.45\"\n+version = \"1.0.47\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3edcd08cf4fea98d1ae6c9ddd3b8ccb1acac7c3693d62625969a7daa04a2ae36\"\n+checksum = \"5ea3d908b0e36316caf9e9e2c4625cdde190a7e6f440d794667ed17a1855e725\"\n dependencies = [\n  \"unicode-ident\",\n ]\n@@ -213,7 +213,7 @@ version = \"0.6.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c\"\n dependencies = [\n- \"getrandom 0.2.7\",\n+ \"getrandom 0.2.8\",\n ]\n \n [[package]]\n@@ -242,9 +242,9 @@ dependencies = [\n \n [[package]]\n name = \"smallvec\"\n-version = \"1.9.0\"\n+version = \"1.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2fd0db749597d91ff862fd1d55ea87f7855a744a8425a64695b6fca237d1dad1\"\n+checksum = \"a507befe795404456341dfab10cef66ead4c041f62b8b11bbb92bffe5d0953e0\"\n \n [[package]]\n name = \"socket2\"\n@@ -258,9 +258,9 @@ dependencies = [\n \n [[package]]\n name = \"syn\"\n-version = \"1.0.101\"\n+version = \"1.0.103\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e90cde112c4b9690b8cbe810cba9ddd8bc1d7472e2cae317b69e9438c1cba7d2\"\n+checksum = \"a864042229133ada95abf3b54fdc62ef5ccabe9515b64717bcb9a1919e59445d\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -269,9 +269,9 @@ dependencies = [\n \n [[package]]\n name = \"tokio\"\n-version = \"1.21.2\"\n+version = \"1.22.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a9e03c497dc955702ba729190dc4aac6f2a0ce97f913e5b1b5912fc5039d9099\"\n+checksum = \"d76ce4a75fb488c605c54bf610f221cea8b0dafb53333c1a67e8ee199dcd2ae3\"\n dependencies = [\n  \"autocfg\",\n  \"bytes\",\n@@ -300,9 +300,9 @@ dependencies = [\n \n [[package]]\n name = \"unicode-ident\"\n-version = \"1.0.4\"\n+version = \"1.0.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dcc811dc4066ac62f84f11307873c4850cb653bfa9b1719cee2bd2204a4bc5dd\"\n+checksum = \"6ceab39d59e4c9499d4e5a8ee0e2735b891bb7308ac83dfb4e80cad195c9f6f3\"\n \n [[package]]\n name = \"wasi\"\n@@ -340,43 +340,57 @@ checksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n \n [[package]]\n name = \"windows-sys\"\n-version = \"0.36.1\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ea04155a16a59f9eab786fe12a4a450e75cdb175f9e0d80da1e17db09f55b8d2\"\n+checksum = \"5a3e1820f08b8513f676f7ab6c1f99ff312fb97b553d30ff4dd86f9f15728aa7\"\n dependencies = [\n+ \"windows_aarch64_gnullvm\",\n  \"windows_aarch64_msvc\",\n  \"windows_i686_gnu\",\n  \"windows_i686_msvc\",\n  \"windows_x86_64_gnu\",\n+ \"windows_x86_64_gnullvm\",\n  \"windows_x86_64_msvc\",\n ]\n \n+[[package]]\n+name = \"windows_aarch64_gnullvm\"\n+version = \"0.42.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"41d2aa71f6f0cbe00ae5167d90ef3cfe66527d6f613ca78ac8024c3ccab9a19e\"\n+\n [[package]]\n name = \"windows_aarch64_msvc\"\n-version = \"0.36.1\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9bb8c3fd39ade2d67e9874ac4f3db21f0d710bee00fe7cab16949ec184eeaa47\"\n+checksum = \"dd0f252f5a35cac83d6311b2e795981f5ee6e67eb1f9a7f64eb4500fbc4dcdb4\"\n \n [[package]]\n name = \"windows_i686_gnu\"\n-version = \"0.36.1\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"180e6ccf01daf4c426b846dfc66db1fc518f074baa793aa7d9b9aaeffad6a3b6\"\n+checksum = \"fbeae19f6716841636c28d695375df17562ca208b2b7d0dc47635a50ae6c5de7\"\n \n [[package]]\n name = \"windows_i686_msvc\"\n-version = \"0.36.1\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e2e7917148b2812d1eeafaeb22a97e4813dfa60a3f8f78ebe204bcc88f12f024\"\n+checksum = \"84c12f65daa39dd2babe6e442988fc329d6243fdce47d7d2d155b8d874862246\"\n \n [[package]]\n name = \"windows_x86_64_gnu\"\n-version = \"0.36.1\"\n+version = \"0.42.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bf7b1b21b5362cbc318f686150e5bcea75ecedc74dd157d874d754a2ca44b0ed\"\n+\n+[[package]]\n+name = \"windows_x86_64_gnullvm\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4dcd171b8776c41b97521e5da127a2d86ad280114807d0b2ab1e462bc764d9e1\"\n+checksum = \"09d525d2ba30eeb3297665bd434a54297e4170c7f1a44cad4ef58095b4cd2028\"\n \n [[package]]\n name = \"windows_x86_64_msvc\"\n-version = \"0.36.1\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c811ca4a8c853ef420abd8592ba53ddbbac90410fab6903b3e79972a631f7680\"\n+checksum = \"f40009d85759725a34da6d89a94e63d7bdc50a862acf0dbc7c8e488f1edcb6f5\""}, {"sha": "3a80e8c96441962ad14ac09ada234f5413765bb5", "filename": "src/tools/miri/test_dependencies/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftest_dependencies%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftest_dependencies%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest_dependencies%2FCargo.toml?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -11,11 +11,11 @@ edition = \"2021\"\n # all dependencies (and their transitive ones) listed here can be used in `tests/`.\n tokio = { version = \"1.0\", features = [\"full\"] }\n libc = \"0.2\"\n-page_size = \"0.4.1\"\n+page_size = \"0.5\"\n num_cpus = \"1.10.1\"\n \n getrandom_1 = { package = \"getrandom\", version = \"0.1\" }\n-getrandom_2 = { package = \"getrandom\", version = \"0.2\" }\n+getrandom = { version = \"0.2\" }\n rand = { version = \"0.8\", features = [\"small_rng\"] }\n \n [workspace]"}, {"sha": "5a80d1ac5a9b1a11245cd946448be605d02b9cc4", "filename": "src/tools/miri/tests/fail/crates/tokio_mvp.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcrates%2Ftokio_mvp.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcrates%2Ftokio_mvp.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcrates%2Ftokio_mvp.stderr?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,8 +1,8 @@\n error: unsupported operation: can't call foreign function: epoll_create1\n   --> CARGO_REGISTRY/.../epoll.rs:LL:CC\n    |\n-LL |         syscall!(epoll_create1(flag)).map(|ep| Selector {\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't call foreign function: epoll_create1\n+LL |         let res = syscall!(epoll_create1(libc::EPOLL_CLOEXEC));\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't call foreign function: epoll_create1\n    |\n    = help: this is likely not a bug in the program; it indicates that the program performed an operation that the interpreter does not support\n    = note: BACKTRACE:"}, {"sha": "6040452a166cbebfe09878abf4236b52938ac0fc", "filename": "src/tools/miri/tests/fail/data_race/alloc_read_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_read_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_read_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_read_race.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,4 +1,4 @@\n-//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n #![feature(new_uninit)]\n \n use std::mem::MaybeUninit;"}, {"sha": "51d431b36f3a36af40c9ca6a128aca6bdb7fc9d9", "filename": "src/tools/miri/tests/fail/data_race/alloc_write_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_write_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_write_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_write_race.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,4 +1,4 @@\n-//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n #![feature(new_uninit)]\n \n use std::ptr::null_mut;"}, {"sha": "79c6760b7c42af4d71177abb468fceb981d6e9b4", "filename": "src/tools/miri/tests/fail/data_race/atomic_read_na_write_race1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::thread::spawn;"}, {"sha": "e069ac4ad6a83319a50597248cba798ad608fa4e", "filename": "src/tools/miri/tests/fail/data_race/atomic_read_na_write_race2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::sync::atomic::AtomicUsize;\n use std::sync::atomic::Ordering;"}, {"sha": "9c025a0153d58276cdc1152e9be746922685c1d8", "filename": "src/tools/miri/tests/fail/data_race/atomic_write_na_read_race1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::sync::atomic::AtomicUsize;\n use std::sync::atomic::Ordering;"}, {"sha": "30b3c4863740c0202ed87cc783586d5038ec51c1", "filename": "src/tools/miri/tests/fail/data_race/atomic_write_na_read_race2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::thread::spawn;"}, {"sha": "02b17cc57b61a51e2f45a0e5a5b81124f45c5970", "filename": "src/tools/miri/tests/fail/data_race/atomic_write_na_write_race1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::thread::spawn;"}, {"sha": "b5f4966d8842af1d714480c47da531bcc558d5e2", "filename": "src/tools/miri/tests/fail/data_race/atomic_write_na_write_race2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::sync::atomic::AtomicUsize;\n use std::sync::atomic::Ordering;"}, {"sha": "9922468e5f8424c67fecf0ecf362fba5841abb1f", "filename": "src/tools/miri/tests/fail/data_race/dangling_thread_async_race.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-disable-isolation -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::mem;\n use std::thread::{sleep, spawn};"}, {"sha": "8c8a6ac87f3ab550a0f0a75635de4695cfbda1b0", "filename": "src/tools/miri/tests/fail/data_race/dangling_thread_race.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_race.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-disable-isolation -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::mem;\n use std::thread::{sleep, spawn};"}, {"sha": "8e1216f5bf0a023008afd139efb1f268299347bd", "filename": "src/tools/miri/tests/fail/data_race/dealloc_read_race1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race1.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::thread::spawn;\n "}, {"sha": "38f76af9de1373d5661d5a9aca9df4aec327f355", "filename": "src/tools/miri/tests/fail/data_race/dealloc_read_race2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race2.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::thread::spawn;\n "}, {"sha": "665e5ce4a1706c8c98dae69655da6bc0f41f4480", "filename": "src/tools/miri/tests/fail/data_race/dealloc_read_race_stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,4 +1,4 @@\n-//@compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::ptr::null_mut;\n use std::sync::atomic::{AtomicPtr, Ordering};"}, {"sha": "b36c6b5ac0e45ce5a8aeba89369b6b8e6007bacf", "filename": "src/tools/miri/tests/fail/data_race/dealloc_write_race1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race1.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::thread::spawn;\n "}, {"sha": "4af8b904626d203268d6a08a52ba3ee7f9e4a4f9", "filename": "src/tools/miri/tests/fail/data_race/dealloc_write_race2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race2.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::thread::spawn;\n "}, {"sha": "f851ce95785f7e884d8ef4d8d3109409aa5882a4", "filename": "src/tools/miri/tests/fail/data_race/dealloc_write_race_stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,4 +1,4 @@\n-//@compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::ptr::null_mut;\n use std::sync::atomic::{AtomicPtr, Ordering};"}, {"sha": "27aa16a122f364207547836f73ad2bdb92b673bf", "filename": "src/tools/miri/tests/fail/data_race/enable_after_join_to_main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::thread::spawn;\n "}, {"sha": "4d436d51f9895ee1c68a35931a98c69cdda8a7e1", "filename": "src/tools/miri/tests/fail/data_race/fence_after_load.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Ffence_after_load.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Ffence_after_load.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Ffence_after_load.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-disable-isolation -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n use std::sync::atomic::{fence, AtomicUsize, Ordering};\n use std::sync::Arc;\n use std::thread;"}, {"sha": "b26ec6c41427aadb1d0ae01d31e5415520ab2eb5", "filename": "src/tools/miri/tests/fail/data_race/read_write_race.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,5 +1,5 @@\n-// We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+// We want to control preemption here. Stacked borrows interferes by having its own accesses.\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::thread::spawn;\n "}, {"sha": "2fbac173993e4dae564949efceb43d59e7f24034", "filename": "src/tools/miri/tests/fail/data_race/read_write_race_stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race_stack.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,4 +1,4 @@\n-//@compile-flags: -Zmiri-disable-isolation -Zmir-opt-level=0 -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmir-opt-level=0 -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n // Note: mir-opt-level set to 0 to prevent the read of stack_var in thread 1\n // from being optimized away and preventing the detection of the data-race."}, {"sha": "24040a9496114a37ac07d01ba48afa8b9a31576f", "filename": "src/tools/miri/tests/fail/data_race/relax_acquire_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelax_acquire_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelax_acquire_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelax_acquire_race.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,4 +1,4 @@\n-//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::thread::spawn;"}, {"sha": "2d7246858e108317a6d8b95572769721d4acbace", "filename": "src/tools/miri/tests/fail/data_race/release_seq_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,4 +1,4 @@\n-//@compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::thread::{sleep, spawn};"}, {"sha": "0f974e1c56d3fd0e032c2d53e77f5ee6e123d40c", "filename": "src/tools/miri/tests/fail/data_race/release_seq_race_same_thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,4 +1,4 @@\n-//@compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::thread::spawn;"}, {"sha": "2d13da30b46393a257c2383cf06bd0c5aa4ecd6a", "filename": "src/tools/miri/tests/fail/data_race/rmw_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frmw_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frmw_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frmw_race.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,4 +1,4 @@\n-//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::thread::spawn;"}, {"sha": "cf5c2ed81cb1d1d8e7b992c9875dda159c4046ac", "filename": "src/tools/miri/tests/fail/data_race/stack_pop_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fstack_pop_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fstack_pop_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fstack_pop_race.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,4 +1,4 @@\n-//@compile-flags: -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n use std::thread;\n \n #[derive(Copy, Clone)]"}, {"sha": "60e9ac2ac6c383f0006b410e50d0b01f6ca6d543", "filename": "src/tools/miri/tests/fail/data_race/write_write_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,5 +1,5 @@\n // We want to control preemption here.\n-//@compile-flags: -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::thread::spawn;\n "}, {"sha": "0a29dc13cba1746f66f5af7f21b75e275f68ea28", "filename": "src/tools/miri/tests/fail/data_race/write_write_race_stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,4 +1,4 @@\n-//@compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n+//@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0 -Zmiri-disable-stacked-borrows\n \n use std::ptr::null_mut;\n use std::sync::atomic::{AtomicPtr, Ordering};"}, {"sha": "268d253ad5b06c65b49b5d9ac60914c231ff0608", "filename": "src/tools/miri/tests/fail/stacked_borrows/aliasing_mut1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut1.stderr?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is strongly protected because it is an argument of call ID\n   --> $DIR/aliasing_mut1.rs:LL:CC\n    |\n LL | pub fn safe(_x: &mut i32, _y: &mut i32) {}\n-   |                           ^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n+   |                           ^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is strongly protected because it is an argument of call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "77a542f45a2566a5f61af86f328921e92d07c668", "filename": "src/tools/miri/tests/fail/stacked_borrows/aliasing_mut2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut2.stderr?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is protected because it is an argument of call ID\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is strongly protected because it is an argument of call ID\n   --> $DIR/aliasing_mut2.rs:LL:CC\n    |\n LL | pub fn safe(_x: &i32, _y: &mut i32) {}\n-   |                       ^^ not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is protected because it is an argument of call ID\n+   |                       ^^ not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is strongly protected because it is an argument of call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "e592b154a7326326da9226cf42c2876ba35f4699", "filename": "src/tools/miri/tests/fail/stacked_borrows/aliasing_mut4.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut4.stderr?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is protected because it is an argument of call ID\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is strongly protected because it is an argument of call ID\n   --> $DIR/aliasing_mut4.rs:LL:CC\n    |\n LL | pub fn safe(_x: &i32, _y: &mut Cell<i32>) {}\n-   |                       ^^ not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is protected because it is an argument of call ID\n+   |                       ^^ not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is strongly protected because it is an argument of call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "2067149b6c87cac19c52bebd30a18abb6dfff1ab", "filename": "src/tools/miri/tests/fail/stacked_borrows/box_noalias_violation.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fbox_noalias_violation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fbox_noalias_violation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fbox_noalias_violation.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -0,0 +1,14 @@\n+unsafe fn test(mut x: Box<i32>, y: *const i32) -> i32 {\n+    // We will call this in a way that x and y alias.\n+    *x = 5;\n+    std::mem::forget(x);\n+    *y //~ERROR: weakly protected\n+}\n+\n+fn main() {\n+    unsafe {\n+        let mut v = 42;\n+        let ptr = &mut v as *mut i32;\n+        test(Box::from_raw(ptr), ptr);\n+    }\n+}"}, {"sha": "3c84cbcfd5182a0b543111003d38052a8e498bb4", "filename": "src/tools/miri/tests/fail/stacked_borrows/box_noalias_violation.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fbox_noalias_violation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fbox_noalias_violation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fbox_noalias_violation.stderr?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -0,0 +1,30 @@\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is weakly protected because it is an argument of call ID\n+  --> $DIR/box_noalias_violation.rs:LL:CC\n+   |\n+LL |     *y\n+   |     ^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is weakly protected because it is an argument of call ID\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n+   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n+help: <TAG> was created by a SharedReadWrite retag at offsets [0x0..0x4]\n+  --> $DIR/box_noalias_violation.rs:LL:CC\n+   |\n+LL |         let ptr = &mut v as *mut i32;\n+   |                   ^^^^^^\n+help: <TAG> is this argument\n+  --> $DIR/box_noalias_violation.rs:LL:CC\n+   |\n+LL | unsafe fn test(mut x: Box<i32>, y: *const i32) -> i32 {\n+   |                ^^^^^\n+   = note: BACKTRACE:\n+   = note: inside `test` at $DIR/box_noalias_violation.rs:LL:CC\n+note: inside `main` at $DIR/box_noalias_violation.rs:LL:CC\n+  --> $DIR/box_noalias_violation.rs:LL:CC\n+   |\n+LL |         test(Box::from_raw(ptr), ptr);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "4036dce5bebab1a5995da3daead21bd32c365950", "filename": "src/tools/miri/tests/fail/stacked_borrows/deallocate_against_protector1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector1.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,4 +1,4 @@\n-//@error-pattern: /deallocating while item \\[Unique for .*\\] is protected/\n+//@error-pattern: /deallocating while item \\[Unique for .*\\] is strongly protected/\n \n fn inner(x: &mut i32, f: fn(&mut i32)) {\n     // `f` may mutate, but it may not deallocate!"}, {"sha": "bb3eaec1e85c0da033b0f68073849a304ae21b71", "filename": "src/tools/miri/tests/fail/stacked_borrows/deallocate_against_protector1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector1.stderr?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: deallocating while item [Unique for <TAG>] is protected by call ID\n+error: Undefined Behavior: deallocating while item [Unique for <TAG>] is strongly protected by call ID\n   --> RUSTLIB/alloc/src/alloc.rs:LL:CC\n    |\n LL |     unsafe { __rust_dealloc(ptr, layout.size(), layout.align()) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ deallocating while item [Unique for <TAG>] is protected by call ID\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ deallocating while item [Unique for <TAG>] is strongly protected by call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "fd67dccd14df6d826b0767b726fd31f827d37f3d", "filename": "src/tools/miri/tests/fail/stacked_borrows/deallocate_against_protector2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,4 +1,4 @@\n-//@error-pattern: /deallocating while item \\[SharedReadWrite for .*\\] is protected/\n+//@error-pattern: /deallocating while item \\[SharedReadWrite for .*\\] is strongly protected/\n use std::marker::PhantomPinned;\n \n pub struct NotUnpin(i32, PhantomPinned);"}, {"sha": "25bab1aa564a65a0145bb1506cda9ded5c95e453", "filename": "src/tools/miri/tests/fail/stacked_borrows/deallocate_against_protector2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.stderr?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: deallocating while item [SharedReadWrite for <TAG>] is protected by call ID\n+error: Undefined Behavior: deallocating while item [SharedReadWrite for <TAG>] is strongly protected by call ID\n   --> RUSTLIB/alloc/src/alloc.rs:LL:CC\n    |\n LL |     unsafe { __rust_dealloc(ptr, layout.size(), layout.align()) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ deallocating while item [SharedReadWrite for <TAG>] is protected by call ID\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ deallocating while item [SharedReadWrite for <TAG>] is strongly protected by call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "670dd4baad8bc675d69194a61842009bb19578c3", "filename": "src/tools/miri/tests/fail/stacked_borrows/illegal_dealloc1.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_dealloc1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_dealloc1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_dealloc1.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -0,0 +1,14 @@\n+//@error-pattern: /deallocation .* tag does not exist in the borrow stack/\n+use std::alloc::{alloc, dealloc, Layout};\n+\n+fn main() {\n+    unsafe {\n+        let x = alloc(Layout::from_size_align_unchecked(1, 1));\n+        let ptr1 = (&mut *x) as *mut u8;\n+        let ptr2 = (&mut *ptr1) as *mut u8;\n+        // Invalidate ptr2 by writing to ptr1.\n+        ptr1.write(0);\n+        // Deallocate through ptr2.\n+        dealloc(ptr2, Layout::from_size_align_unchecked(1, 1));\n+    }\n+}"}, {"sha": "3b7802901a54eb723ddf23ae38b9b557d1772a2c", "filename": "src/tools/miri/tests/fail/stacked_borrows/illegal_dealloc1.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_dealloc1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_dealloc1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_dealloc1.stderr?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -0,0 +1,30 @@\n+error: Undefined Behavior: attempting deallocation using <TAG> at ALLOC, but that tag does not exist in the borrow stack for this location\n+  --> RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   |\n+LL |     unsafe { __rust_dealloc(ptr, layout.size(), layout.align()) }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attempting deallocation using <TAG> at ALLOC, but that tag does not exist in the borrow stack for this location\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n+   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n+help: <TAG> was created by a SharedReadWrite retag at offsets [0x0..0x1]\n+  --> $DIR/illegal_deALLOC.rs:LL:CC\n+   |\n+LL |         let ptr2 = (&mut *ptr1) as *mut u8;\n+   |                    ^^^^^^^^^^^^\n+help: <TAG> was later invalidated at offsets [0x0..0x1] by a write access\n+  --> $DIR/illegal_deALLOC.rs:LL:CC\n+   |\n+LL |         ptr1.write(0);\n+   |         ^^^^^^^^^^^^^\n+   = note: BACKTRACE:\n+   = note: inside `std::alloc::dealloc` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+note: inside `main` at $DIR/illegal_deALLOC.rs:LL:CC\n+  --> $DIR/illegal_deALLOC.rs:LL:CC\n+   |\n+LL |         dealloc(ptr2, Layout::from_size_align_unchecked(1, 1));\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "7983b30ea18229ee93498d640354629d5d008175", "filename": "src/tools/miri/tests/fail/stacked_borrows/illegal_write6.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write6.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -7,6 +7,6 @@ fn main() {\n fn foo(a: &mut u32, y: *mut u32) -> u32 {\n     *a = 1;\n     let _b = &*a;\n-    unsafe { *y = 2 }; //~ ERROR: /not granting access .* because that would remove .* which is protected/\n+    unsafe { *y = 2 }; //~ ERROR: /not granting access .* because that would remove .* which is strongly protected/\n     return *a;\n }"}, {"sha": "1a627b8a883009f07818308cbe6f48f916bb21ac", "filename": "src/tools/miri/tests/fail/stacked_borrows/illegal_write6.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write6.stderr?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is strongly protected because it is an argument of call ID\n   --> $DIR/illegal_write6.rs:LL:CC\n    |\n LL |     unsafe { *y = 2 };\n-   |              ^^^^^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n+   |              ^^^^^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is strongly protected because it is an argument of call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "1ef36b7ac10fc4c5005ded98d127b7968315d580", "filename": "src/tools/miri/tests/fail/stacked_borrows/invalidate_against_protector1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector1.stderr?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is strongly protected because it is an argument of call ID\n   --> $DIR/invalidate_against_protector1.rs:LL:CC\n    |\n LL |     let _val = unsafe { *x };\n-   |                         ^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n+   |                         ^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is strongly protected because it is an argument of call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "941b936e5d7249443852d9692444911c5cd8c898", "filename": "src/tools/miri/tests/fail/stacked_borrows/invalidate_against_protector2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector2.stderr?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is protected because it is an argument of call ID\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is strongly protected because it is an argument of call ID\n   --> $DIR/invalidate_against_protector2.rs:LL:CC\n    |\n LL |     unsafe { *x = 0 };\n-   |              ^^^^^^ not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is protected because it is an argument of call ID\n+   |              ^^^^^^ not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is strongly protected because it is an argument of call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "176a859ee8af7692d4b1673d1ce96b03eff79019", "filename": "src/tools/miri/tests/fail/stacked_borrows/invalidate_against_protector3.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector3.stderr?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is protected because it is an argument of call ID\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is strongly protected because it is an argument of call ID\n   --> $DIR/invalidate_against_protector3.rs:LL:CC\n    |\n LL |     unsafe { *x = 0 };\n-   |              ^^^^^^ not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is protected because it is an argument of call ID\n+   |              ^^^^^^ not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is strongly protected because it is an argument of call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "c19bcb99cc1cee4bd5ca83381607ae019577f1b7", "filename": "src/tools/miri/tests/fail/stacked_borrows/newtype_pair_retagging.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,4 +1,4 @@\n-//@error-pattern: which is protected\n+//@error-pattern: which is strongly protected\n struct Newtype<'a>(&'a mut i32, i32);\n \n fn dealloc_while_running(_n: Newtype<'_>, dealloc: impl FnOnce()) {"}, {"sha": "70186dd3a53f3305d9b8622fadf83448f1aae9ad", "filename": "src/tools/miri/tests/fail/stacked_borrows/newtype_pair_retagging.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.stderr?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is strongly protected because it is an argument of call ID\n   --> RUSTLIB/alloc/src/boxed.rs:LL:CC\n    |\n LL |         Box(unsafe { Unique::new_unchecked(raw) }, alloc)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is strongly protected because it is an argument of call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "2bbe7122ec7478873190fc73686b02dbfe11a932", "filename": "src/tools/miri/tests/fail/stacked_borrows/newtype_retagging.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,4 +1,4 @@\n-//@error-pattern: which is protected\n+//@error-pattern: which is strongly protected\n struct Newtype<'a>(&'a mut i32);\n \n fn dealloc_while_running(_n: Newtype<'_>, dealloc: impl FnOnce()) {"}, {"sha": "69fa27c9c096fef7f6e6c1a3e6a6dfe9287165d5", "filename": "src/tools/miri/tests/fail/stacked_borrows/newtype_retagging.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.stderr?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is strongly protected because it is an argument of call ID\n   --> RUSTLIB/alloc/src/boxed.rs:LL:CC\n    |\n LL |         Box(unsafe { Unique::new_unchecked(raw) }, alloc)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is strongly protected because it is an argument of call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "d660921bfe6e2d4755bb18e3c79e8da602fd707a", "filename": "src/tools/miri/tests/fail/stacked_borrows/notunpin_dereferenceable_fakeread.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -0,0 +1,17 @@\n+//! Reborrowing a `&mut !Unpin` must still act like a (fake) read.\n+use std::marker::PhantomPinned;\n+\n+struct NotUnpin(i32, PhantomPinned);\n+\n+fn main() {\n+    unsafe {\n+        let mut x = NotUnpin(0, PhantomPinned);\n+        // Mutable borrow of `Unpin` field (with lifetime laundering)\n+        let fieldref = &mut *(&mut x.0 as *mut i32);\n+        // Mutable reborrow of the entire `x`, which is `!Unpin` but should\n+        // still count as a read since we would add `dereferenceable`.\n+        let _xref = &mut x;\n+        // That read should have invalidated `fieldref`.\n+        *fieldref = 0; //~ ERROR: /write access .* tag does not exist in the borrow stack/\n+    }\n+}"}, {"sha": "3ef8a8e0e9c6a8939975bc3829fbd16e50092577", "filename": "src/tools/miri/tests/fail/stacked_borrows/notunpin_dereferenceable_fakeread.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.stderr?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -0,0 +1,28 @@\n+error: Undefined Behavior: attempting a write access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+  --> $DIR/notunpin_dereferenceable_fakeread.rs:LL:CC\n+   |\n+LL |         *fieldref = 0;\n+   |         ^^^^^^^^^^^^^\n+   |         |\n+   |         attempting a write access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |         this error occurs as part of an access at ALLOC[0x0..0x4]\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n+   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n+help: <TAG> was created by a Unique retag at offsets [0x0..0x4]\n+  --> $DIR/notunpin_dereferenceable_fakeread.rs:LL:CC\n+   |\n+LL |         let fieldref = &mut *(&mut x.0 as *mut i32);\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: <TAG> was later invalidated at offsets [0x0..0x4] by a SharedReadWrite retag\n+  --> $DIR/notunpin_dereferenceable_fakeread.rs:LL:CC\n+   |\n+LL |         let _xref = &mut x;\n+   |                     ^^^^^^\n+   = note: BACKTRACE:\n+   = note: inside `main` at $DIR/notunpin_dereferenceable_fakeread.rs:LL:CC\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "309d7a22be64f20b3eebafe3aa9d89f0d9d09235", "filename": "src/tools/miri/tests/fail/stacked_borrows/retag_data_race_read.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_read.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_read.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_read.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -0,0 +1,31 @@\n+//! Make sure that a retag acts like a write for the data race model.\n+//@compile-flags: -Zmiri-preemption-rate=0\n+#[derive(Copy, Clone)]\n+struct SendPtr(*mut u8);\n+\n+unsafe impl Send for SendPtr {}\n+\n+fn thread_1(p: SendPtr) {\n+    let p = p.0;\n+    unsafe {\n+        let _r = &*p;\n+    }\n+}\n+\n+fn thread_2(p: SendPtr) {\n+    let p = p.0;\n+    unsafe {\n+        *p = 5; //~ ERROR: Data race detected between Write on thread `<unnamed>` and Read on thread `<unnamed>`\n+    }\n+}\n+\n+fn main() {\n+    let mut x = 0;\n+    let p = std::ptr::addr_of_mut!(x);\n+    let p = SendPtr(p);\n+\n+    let t1 = std::thread::spawn(move || thread_1(p));\n+    let t2 = std::thread::spawn(move || thread_2(p));\n+    let _ = t1.join();\n+    let _ = t2.join();\n+}"}, {"sha": "f25d689524d1b3c86a565ea215a7ec5034a5e03a", "filename": "src/tools/miri/tests/fail/stacked_borrows/retag_data_race_read.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_read.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_read.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_read.stderr?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -0,0 +1,20 @@\n+error: Undefined Behavior: Data race detected between Write on thread `<unnamed>` and Read on thread `<unnamed>` at ALLOC\n+  --> $DIR/retag_data_race_read.rs:LL:CC\n+   |\n+LL |         *p = 5;\n+   |         ^^^^^^ Data race detected between Write on thread `<unnamed>` and Read on thread `<unnamed>` at ALLOC\n+   |\n+   = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n+   = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n+   = note: BACKTRACE:\n+   = note: inside `thread_2` at $DIR/retag_data_race_read.rs:LL:CC\n+note: inside closure at $DIR/retag_data_race_read.rs:LL:CC\n+  --> $DIR/retag_data_race_read.rs:LL:CC\n+   |\n+LL |     let t2 = std::thread::spawn(move || thread_2(p));\n+   |                                         ^^^^^^^^^^^\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "9368a0a919eb3c9a6dc7eadffdea342b5b7efa56", "filename": "src/tools/miri/tests/fail/stacked_borrows/retag_data_race_write.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_write.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -0,0 +1,31 @@\n+//! Make sure that a retag acts like a write for the data race model.\n+//@compile-flags: -Zmiri-preemption-rate=0\n+#[derive(Copy, Clone)]\n+struct SendPtr(*mut u8);\n+\n+unsafe impl Send for SendPtr {}\n+\n+fn thread_1(p: SendPtr) {\n+    let p = p.0;\n+    unsafe {\n+        let _r = &mut *p;\n+    }\n+}\n+\n+fn thread_2(p: SendPtr) {\n+    let p = p.0;\n+    unsafe {\n+        *p = 5; //~ ERROR: Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>`\n+    }\n+}\n+\n+fn main() {\n+    let mut x = 0;\n+    let p = std::ptr::addr_of_mut!(x);\n+    let p = SendPtr(p);\n+\n+    let t1 = std::thread::spawn(move || thread_1(p));\n+    let t2 = std::thread::spawn(move || thread_2(p));\n+    let _ = t1.join();\n+    let _ = t2.join();\n+}"}, {"sha": "f97e6bb11e9d674a7535cfef0329d4c8397f61aa", "filename": "src/tools/miri/tests/fail/stacked_borrows/retag_data_race_write.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_write.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_write.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_write.stderr?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -0,0 +1,20 @@\n+error: Undefined Behavior: Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n+  --> $DIR/retag_data_race_write.rs:LL:CC\n+   |\n+LL |         *p = 5;\n+   |         ^^^^^^ Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n+   |\n+   = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n+   = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n+   = note: BACKTRACE:\n+   = note: inside `thread_2` at $DIR/retag_data_race_write.rs:LL:CC\n+note: inside closure at $DIR/retag_data_race_write.rs:LL:CC\n+  --> $DIR/retag_data_race_write.rs:LL:CC\n+   |\n+LL |     let t2 = std::thread::spawn(move || thread_2(p));\n+   |                                         ^^^^^^^^^^^\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "2c7bd93fbdb38ce7e58d765ee9382864f50c3319", "filename": "src/tools/miri/tests/pass-dep/getrandom_1.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fgetrandom_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fgetrandom_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fgetrandom_1.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -0,0 +1,8 @@\n+// mac-os `getrandom_1` does some pointer shenanigans\n+//@compile-flags: -Zmiri-permissive-provenance\n+\n+/// Test old version of `getrandom`.\n+fn main() {\n+    let mut data = vec![0; 16];\n+    getrandom_1::getrandom(&mut data).unwrap();\n+}"}, {"sha": "0cd8b06d63d8aac42eee735909b64b25820228d3", "filename": "src/tools/miri/tests/pass-dep/random.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Frandom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Frandom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Frandom.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,12 +1,10 @@\n-// mac-os `getrandom_1` does some pointer shenanigans\n-//@compile-flags: -Zmiri-permissive-provenance\n+//@compile-flags: -Zmiri-strict-provenance\n use rand::{rngs::SmallRng, Rng, SeedableRng};\n \n fn main() {\n-    // Test `getrandom` directly (in multiple different versions).\n+    // Test `getrandom` directly.\n     let mut data = vec![0; 16];\n-    getrandom_1::getrandom(&mut data).unwrap();\n-    getrandom_2::getrandom(&mut data).unwrap();\n+    getrandom::getrandom(&mut data).unwrap();\n \n     // Try seeding with \"real\" entropy.\n     let mut rng = SmallRng::from_entropy();"}, {"sha": "349b447569a4b8a8dab625b80c1a0e648cc933bf", "filename": "src/tools/miri/tests/pass-dep/shims/libc-getrandom-without-isolation.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-getrandom-without-isolation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-getrandom-without-isolation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-getrandom-without-isolation.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "previous_filename": "src/tools/miri/tests/pass-dep/shims/linux-getrandom-without-isolation.rs"}, {"sha": "a1436c7319d3395f0a8419d2bbc34298e5156d12", "filename": "src/tools/miri/tests/pass-dep/shims/libc-getrandom.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-getrandom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-getrandom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-getrandom.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "previous_filename": "src/tools/miri/tests/pass-dep/shims/linux-getrandom.rs"}, {"sha": "3bece7783f798db012424aa871760904a71a5546", "filename": "src/tools/miri/tests/pass/no_std.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fno_std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ccb38b92d38961a41ab5095e67dc1e3209182dd/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fno_std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fno_std.rs?ref=2ccb38b92d38961a41ab5095e67dc1e3209182dd", "patch": "@@ -1,9 +1,5 @@\n #![feature(lang_items, start)]\n #![no_std]\n-// windows tls dtors go through libstd right now, thus this test\n-// cannot pass. When windows tls dtors go through the special magic\n-// windows linker section, we can run this test on windows again.\n-//@ignore-target-windows: no-std not supported on Windows\n \n // Plumbing to let us use `writeln!` to host stdout:\n "}]}