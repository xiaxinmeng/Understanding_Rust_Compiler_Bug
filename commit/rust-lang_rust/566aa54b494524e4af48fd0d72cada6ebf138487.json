{"sha": "566aa54b494524e4af48fd0d72cada6ebf138487", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2NmFhNTRiNDk0NTI0ZTRhZjQ4ZmQwZDcyY2FkYTZlYmYxMzg0ODc=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-05-06T04:47:28Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-05-09T20:17:00Z"}, "message": "trans: Make common::fulfill_obligation only depend on SharedCrateContext.\n\nPlus make it produce a nicer dependency graph via DepTrackingMap::memoize().", "tree": {"sha": "151f4782d0398905b3d897ff772100919657327b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/151f4782d0398905b3d897ff772100919657327b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/566aa54b494524e4af48fd0d72cada6ebf138487", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/566aa54b494524e4af48fd0d72cada6ebf138487", "html_url": "https://github.com/rust-lang/rust/commit/566aa54b494524e4af48fd0d72cada6ebf138487", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/566aa54b494524e4af48fd0d72cada6ebf138487/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d24ead0f93799c7c6646739396daf68ac46d7309", "url": "https://api.github.com/repos/rust-lang/rust/commits/d24ead0f93799c7c6646739396daf68ac46d7309", "html_url": "https://github.com/rust-lang/rust/commit/d24ead0f93799c7c6646739396daf68ac46d7309"}], "stats": {"total": 147, "additions": 70, "deletions": 77}, "files": [{"sha": "098b7d163c196dcd3015ed0069e454c52a33e41c", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/566aa54b494524e4af48fd0d72cada6ebf138487/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/566aa54b494524e4af48fd0d72cada6ebf138487/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=566aa54b494524e4af48fd0d72cada6ebf138487", "patch": "@@ -678,7 +678,7 @@ pub fn custom_coerce_unsize_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n         substs: ccx.tcx().mk_substs(trait_substs)\n     });\n \n-    match fulfill_obligation(ccx, DUMMY_SP, trait_ref) {\n+    match fulfill_obligation(ccx.shared(), DUMMY_SP, trait_ref) {\n         traits::VtableImpl(traits::VtableImplData { impl_def_id, .. }) => {\n             ccx.tcx().custom_coerce_unsized_kind(impl_def_id)\n         }"}, {"sha": "db605e4dc5d68af8a948bf01e12bdf1d94889276", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/566aa54b494524e4af48fd0d72cada6ebf138487/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/566aa54b494524e4af48fd0d72cada6ebf138487/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=566aa54b494524e4af48fd0d72cada6ebf138487", "patch": "@@ -156,7 +156,7 @@ impl<'tcx> Callee<'tcx> {\n         let trait_id = method_item.container().id();\n         let trait_ref = ty::Binder(substs.to_trait_ref(tcx, trait_id));\n         let trait_ref = infer::normalize_associated_type(tcx, &trait_ref);\n-        match common::fulfill_obligation(ccx, DUMMY_SP, trait_ref) {\n+        match common::fulfill_obligation(ccx.shared(), DUMMY_SP, trait_ref) {\n             traits::VtableImpl(vtable_impl) => {\n                 let impl_did = vtable_impl.impl_def_id;\n                 let mname = tcx.item_name(def_id);"}, {"sha": "db0e04c347633894598a4b9f7eef13b324843984", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/566aa54b494524e4af48fd0d72cada6ebf138487/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/566aa54b494524e4af48fd0d72cada6ebf138487/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=566aa54b494524e4af48fd0d72cada6ebf138487", "patch": "@@ -701,7 +701,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             substs: self_type_substs,\n         }.to_poly_trait_ref();\n \n-        let substs = match fulfill_obligation(ccx, DUMMY_SP, trait_ref) {\n+        let substs = match fulfill_obligation(ccx.shared(), DUMMY_SP, trait_ref) {\n             traits::VtableImpl(data) => data.substs,\n             _ => bug!()\n         };\n@@ -844,7 +844,7 @@ fn do_static_trait_method_dispatch<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                        callee_substs);\n \n     let trait_ref = ty::Binder(rcvr_substs.to_trait_ref(tcx, trait_id));\n-    let vtbl = fulfill_obligation(ccx, DUMMY_SP, trait_ref);\n+    let vtbl = fulfill_obligation(ccx.shared(), DUMMY_SP, trait_ref);\n \n     // Now that we know which impl is being used, we can dispatch to\n     // the actual function:\n@@ -999,7 +999,7 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n         // Walk all methods of the trait, including those of its supertraits\n         for trait_ref in traits::supertraits(ccx.tcx(), poly_trait_ref) {\n-            let vtable = fulfill_obligation(ccx, DUMMY_SP, trait_ref);\n+            let vtable = fulfill_obligation(ccx.shared(), DUMMY_SP, trait_ref);\n             match vtable {\n                 traits::VtableImpl(\n                     traits::VtableImplData {"}, {"sha": "65d307cec688db0e6500e4a3f0112faa7d4c1fb2", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 57, "deletions": 61, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/566aa54b494524e4af48fd0d72cada6ebf138487/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/566aa54b494524e4af48fd0d72cada6ebf138487/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=566aa54b494524e4af48fd0d72cada6ebf138487", "patch": "@@ -20,6 +20,7 @@ use rustc::cfg;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::infer;\n+use rustc::util::common::MemoizationMap;\n use middle::lang_items::LangItem;\n use rustc::ty::subst::Substs;\n use abi::{Abi, FnType};\n@@ -54,7 +55,7 @@ use syntax::codemap::{DUMMY_SP, Span};\n use syntax::parse::token::InternedString;\n use syntax::parse::token;\n \n-pub use context::CrateContext;\n+pub use context::{CrateContext, SharedCrateContext};\n \n /// Is the type's representation size known at compile time?\n pub fn type_is_sized<'tcx>(tcx: &TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n@@ -1051,7 +1052,7 @@ pub fn expr_ty_adjusted<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, ex: &hir::Expr) ->\n /// Attempts to resolve an obligation. The result is a shallow vtable resolution -- meaning that we\n /// do not (necessarily) resolve all nested obligations on the impl. Note that type check should\n /// guarantee to us that all nested obligations *could be* resolved if we wanted to.\n-pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+pub fn fulfill_obligation<'a, 'tcx>(ccx: &SharedCrateContext<'a, 'tcx>,\n                                     span: Span,\n                                     trait_ref: ty::PolyTraitRef<'tcx>)\n                                     -> traits::Vtable<'tcx, ()>\n@@ -1061,68 +1062,63 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // Remove any references to regions; this helps improve caching.\n     let trait_ref = tcx.erase_regions(&trait_ref);\n \n-    // First check the cache.\n-    match ccx.trait_cache().borrow().get(&trait_ref) {\n-        Some(vtable) => {\n-            info!(\"Cache hit: {:?}\", trait_ref);\n-            return (*vtable).clone();\n-        }\n-        None => { }\n-    }\n-\n-    debug!(\"trans fulfill_obligation: trait_ref={:?} def_id={:?}\",\n-           trait_ref, trait_ref.def_id());\n-\n-\n-    // Do the initial selection for the obligation. This yields the\n-    // shallow result we are looking for -- that is, what specific impl.\n-    let infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables, ProjectionMode::Any);\n-    let mut selcx = SelectionContext::new(&infcx);\n-\n-    let obligation =\n-        traits::Obligation::new(traits::ObligationCause::misc(span, ast::DUMMY_NODE_ID),\n-                                trait_ref.to_poly_trait_predicate());\n-    let selection = match selcx.select(&obligation) {\n-        Ok(Some(selection)) => selection,\n-        Ok(None) => {\n-            // Ambiguity can happen when monomorphizing during trans\n-            // expands to some humongo type that never occurred\n-            // statically -- this humongo type can then overflow,\n-            // leading to an ambiguous result. So report this as an\n-            // overflow bug, since I believe this is the only case\n-            // where ambiguity can result.\n-            debug!(\"Encountered ambiguity selecting `{:?}` during trans, \\\n-                    presuming due to overflow\",\n-                   trait_ref);\n-            ccx.sess().span_fatal(\n-                span,\n-                \"reached the recursion limit during monomorphization (selection ambiguity)\");\n-        }\n-        Err(e) => {\n-            span_bug!(\n-                span,\n-                \"Encountered error `{:?}` selecting `{:?}` during trans\",\n-                e,\n-                trait_ref)\n-        }\n-    };\n-\n-    // Currently, we use a fulfillment context to completely resolve\n-    // all nested obligations. This is because they can inform the\n-    // inference of the impl's type parameters.\n-    let mut fulfill_cx = traits::FulfillmentContext::new();\n-    let vtable = selection.map(|predicate| {\n-        fulfill_cx.register_predicate_obligation(&infcx, predicate);\n-    });\n-    let vtable = infer::drain_fulfillment_cx_or_panic(\n-        span, &infcx, &mut fulfill_cx, &vtable\n-    );\n+    ccx.trait_cache().memoize(trait_ref, || {\n+        debug!(\"trans fulfill_obligation: trait_ref={:?} def_id={:?}\",\n+               trait_ref, trait_ref.def_id());\n+\n+        // Do the initial selection for the obligation. This yields the\n+        // shallow result we are looking for -- that is, what specific impl.\n+        let infcx = infer::normalizing_infer_ctxt(tcx,\n+                                                  &tcx.tables,\n+                                                  ProjectionMode::Any);\n+        let mut selcx = SelectionContext::new(&infcx);\n+\n+        let obligation_cause = traits::ObligationCause::misc(span,\n+                                                             ast::DUMMY_NODE_ID);\n+        let obligation = traits::Obligation::new(obligation_cause,\n+                                                 trait_ref.to_poly_trait_predicate());\n+\n+        let selection = match selcx.select(&obligation) {\n+            Ok(Some(selection)) => selection,\n+            Ok(None) => {\n+                // Ambiguity can happen when monomorphizing during trans\n+                // expands to some humongo type that never occurred\n+                // statically -- this humongo type can then overflow,\n+                // leading to an ambiguous result. So report this as an\n+                // overflow bug, since I believe this is the only case\n+                // where ambiguity can result.\n+                debug!(\"Encountered ambiguity selecting `{:?}` during trans, \\\n+                        presuming due to overflow\",\n+                       trait_ref);\n+                ccx.sess().span_fatal(\n+                    span,\n+                    \"reached the recursion limit during monomorphization \\\n+                     (selection ambiguity)\");\n+            }\n+            Err(e) => {\n+                span_bug!(\n+                    span,\n+                    \"Encountered error `{:?}` selecting `{:?}` during trans\",\n+                    e,\n+                    trait_ref)\n+            }\n+        };\n \n-    info!(\"Cache miss: {:?} => {:?}\", trait_ref, vtable);\n+        // Currently, we use a fulfillment context to completely resolve\n+        // all nested obligations. This is because they can inform the\n+        // inference of the impl's type parameters.\n+        let mut fulfill_cx = traits::FulfillmentContext::new();\n+        let vtable = selection.map(|predicate| {\n+            fulfill_cx.register_predicate_obligation(&infcx, predicate);\n+        });\n+        let vtable = infer::drain_fulfillment_cx_or_panic(\n+            span, &infcx, &mut fulfill_cx, &vtable\n+        );\n \n-    ccx.trait_cache().borrow_mut().insert(trait_ref, vtable.clone());\n+        info!(\"Cache miss: {:?} => {:?}\", trait_ref, vtable);\n \n-    vtable\n+        vtable\n+    })\n }\n \n /// Normalizes the predicates and checks whether they hold.  If this"}, {"sha": "d7ec448a7f0b2b5c960ca83bc14f0b00562f726f", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/566aa54b494524e4af48fd0d72cada6ebf138487/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/566aa54b494524e4af48fd0d72cada6ebf138487/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=566aa54b494524e4af48fd0d72cada6ebf138487", "patch": "@@ -84,6 +84,7 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n     use_dll_storage_attrs: bool,\n \n     translation_items: RefCell<FnvHashMap<TransItem<'tcx>, TransItemState>>,\n+    trait_cache: RefCell<DepTrackingMap<TraitSelectionCache<'tcx>>>,\n }\n \n /// The local portion of a `CrateContext`.  There is one `LocalCrateContext`\n@@ -169,8 +170,6 @@ pub struct LocalCrateContext<'tcx> {\n \n     /// Depth of the current type-of computation - used to bail out\n     type_of_depth: Cell<usize>,\n-\n-    trait_cache: RefCell<DepTrackingMap<TraitSelectionCache<'tcx>>>,\n }\n \n // Implement DepTrackingMapConfig for `trait_cache`\n@@ -423,6 +422,7 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n             available_drop_glues: RefCell::new(FnvHashMap()),\n             use_dll_storage_attrs: use_dll_storage_attrs,\n             translation_items: RefCell::new(FnvHashMap()),\n+            trait_cache: RefCell::new(DepTrackingMap::new(tcx.dep_graph.clone())),\n         }\n     }\n \n@@ -446,6 +446,10 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         &self.item_symbols\n     }\n \n+    pub fn trait_cache(&self) -> &RefCell<DepTrackingMap<TraitSelectionCache<'tcx>>> {\n+        &self.trait_cache\n+    }\n+\n     pub fn link_meta<'a>(&'a self) -> &'a LinkMeta {\n         &self.link_meta\n     }\n@@ -516,9 +520,6 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 intrinsics: RefCell::new(FnvHashMap()),\n                 n_llvm_insns: Cell::new(0),\n                 type_of_depth: Cell::new(0),\n-                trait_cache: RefCell::new(DepTrackingMap::new(shared.tcx\n-                                                                    .dep_graph\n-                                                                    .clone())),\n             };\n \n             let (int_type, opaque_vec_type, str_slice_ty, mut local_ccx) = {\n@@ -805,10 +806,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local().n_llvm_insns.set(self.local().n_llvm_insns.get() + 1);\n     }\n \n-    pub fn trait_cache(&self) -> &RefCell<DepTrackingMap<TraitSelectionCache<'tcx>>> {\n-        &self.local().trait_cache\n-    }\n-\n     pub fn obj_size_bound(&self) -> u64 {\n         self.tcx().data_layout.obj_size_bound()\n     }"}, {"sha": "06f9000c4ba9076c5ad73f8702842d6b57ffc955", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/566aa54b494524e4af48fd0d72cada6ebf138487/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/566aa54b494524e4af48fd0d72cada6ebf138487/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=566aa54b494524e4af48fd0d72cada6ebf138487", "patch": "@@ -364,7 +364,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         def_id: tcx.lang_items.drop_trait().unwrap(),\n         substs: tcx.mk_substs(Substs::empty().with_self_ty(t))\n     });\n-    let vtbl = match fulfill_obligation(bcx.ccx(), DUMMY_SP, trait_ref) {\n+    let vtbl = match fulfill_obligation(bcx.ccx().shared(), DUMMY_SP, trait_ref) {\n         traits::VtableImpl(data) => data,\n         _ => bug!(\"dtor for {:?} is not an impl???\", t)\n     };"}, {"sha": "648a232ef6946728b0963c8656bec560b68754eb", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/566aa54b494524e4af48fd0d72cada6ebf138487/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/566aa54b494524e4af48fd0d72cada6ebf138487/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=566aa54b494524e4af48fd0d72cada6ebf138487", "patch": "@@ -144,7 +144,7 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     // Not in the cache. Build it.\n     let methods = traits::supertraits(tcx, trait_ref.clone()).flat_map(|trait_ref| {\n-        let vtable = fulfill_obligation(ccx, DUMMY_SP, trait_ref.clone());\n+        let vtable = fulfill_obligation(ccx.shared(), DUMMY_SP, trait_ref.clone());\n         match vtable {\n             // Should default trait error here?\n             traits::VtableDefaultImpl(_) |"}]}