{"sha": "d7d4d7c8d5620b7b120304cc5eecf25b499e394a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3ZDRkN2M4ZDU2MjBiN2IxMjAzMDRjYzVlZWNmMjViNDk5ZTM5NGE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-08-08T22:10:19Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-08-24T17:27:38Z"}, "message": "add a `user_substs` table and store the annotations in there", "tree": {"sha": "a1ba9d1df697e80e03259426083d26072f1d67af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1ba9d1df697e80e03259426083d26072f1d67af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7d4d7c8d5620b7b120304cc5eecf25b499e394a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7d4d7c8d5620b7b120304cc5eecf25b499e394a", "html_url": "https://github.com/rust-lang/rust/commit/d7d4d7c8d5620b7b120304cc5eecf25b499e394a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7d4d7c8d5620b7b120304cc5eecf25b499e394a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1884fe35b6b30e02a65bf13a542f0798f220724f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1884fe35b6b30e02a65bf13a542f0798f220724f", "html_url": "https://github.com/rust-lang/rust/commit/1884fe35b6b30e02a65bf13a542f0798f220724f"}], "stats": {"total": 208, "additions": 202, "deletions": 6}, "files": [{"sha": "f786547e6e36ceb873e80c5d135e05f29c6df8f0", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d7d4d7c8d5620b7b120304cc5eecf25b499e394a/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d4d7c8d5620b7b120304cc5eecf25b499e394a/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=d7d4d7c8d5620b7b120304cc5eecf25b499e394a", "patch": "@@ -12,13 +12,14 @@\n \n use hir::def_id::DefId;\n use infer::canonical::Canonical;\n-use ty::{self, Lift, List, Ty, TyCtxt};\n+use ty::{self, CanonicalVar, Lift, List, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n use serialize::{self, Encodable, Encoder, Decodable, Decoder};\n use syntax_pos::{Span, DUMMY_SP};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n use rustc_data_structures::array_vec::ArrayVec;\n+use rustc_data_structures::indexed_vec::Idx;\n \n use core::intrinsics;\n use std::cmp::Ordering;\n@@ -180,8 +181,6 @@ impl<'tcx> Decodable for Kind<'tcx> {\n /// A substitution mapping generic parameters to new values.\n pub type Substs<'tcx> = List<Kind<'tcx>>;\n \n-pub type CanonicalSubsts<'gcx> = Canonical<'gcx, &'gcx Substs<'gcx>>;\n-\n impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     /// Creates a Substs that maps each generic parameter to itself.\n     pub fn identity_for_item(tcx: TyCtxt<'a, 'gcx, 'tcx>, def_id: DefId)\n@@ -342,6 +341,33 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx Substs<'tcx> {\n     }\n }\n \n+pub type CanonicalSubsts<'gcx> = Canonical<'gcx, &'gcx Substs<'gcx>>;\n+\n+impl<'gcx> CanonicalSubsts<'gcx> {\n+    /// True if this represents a substitution like\n+    ///\n+    /// ```ignore\n+    /// [?0, ?1, ?2]\n+    /// ```\n+    ///\n+    /// i.e., each thing is mapped to a canonical variable with the same index.\n+    pub fn is_identity(&self) -> bool {\n+        self.value.iter().zip(CanonicalVar::new(0)..).all(|(kind, cvar)| {\n+            match kind.unpack() {\n+                UnpackedKind::Type(ty) => match ty.sty {\n+                    ty::Infer(ty::CanonicalTy(cvar1)) => cvar == cvar1,\n+                    _ => false,\n+                },\n+\n+                UnpackedKind::Lifetime(r) => match r {\n+                    ty::ReCanonical(cvar1) => cvar == *cvar1,\n+                    _ => false,\n+                },\n+            }\n+        })\n+    }\n+}\n+\n impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Substs<'tcx> {}\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "16894478df05e961adb2fb8ff119b0ecc851f165", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 62, "deletions": 2, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/d7d4d7c8d5620b7b120304cc5eecf25b499e394a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d4d7c8d5620b7b120304cc5eecf25b499e394a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d7d4d7c8d5620b7b120304cc5eecf25b499e394a", "patch": "@@ -95,7 +95,7 @@ use rustc::infer::anon_types::AnonTypeDecl;\n use rustc::infer::type_variable::{TypeVariableOrigin};\n use rustc::middle::region;\n use rustc::mir::interpret::{GlobalId};\n-use rustc::ty::subst::{UnpackedKind, Subst, Substs};\n+use rustc::ty::subst::{CanonicalSubsts, UnpackedKind, Subst, Substs};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, TraitEngine};\n use rustc::ty::{self, Ty, TyCtxt, GenericParamDefKind, Visibility, ToPredicate, RegionKind};\n use rustc::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n@@ -122,6 +122,7 @@ use std::ops::{self, Deref};\n use rustc_target::spec::abi::Abi;\n use syntax::ast;\n use syntax::attr;\n+use syntax::source_map::DUMMY_SP;\n use syntax::source_map::original_sp;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::ptr::P;\n@@ -2058,11 +2059,47 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn write_method_call(&self,\n                              hir_id: hir::HirId,\n                              method: MethodCallee<'tcx>) {\n+        debug!(\"write_method_call(hir_id={:?}, method={:?})\", hir_id, method);\n         self.tables\n             .borrow_mut()\n             .type_dependent_defs_mut()\n             .insert(hir_id, Def::Method(method.def_id));\n+\n         self.write_substs(hir_id, method.substs);\n+\n+        // When the method is confirmed, the `method.substs` includes\n+        // parameters from not just the method, but also the impl of\n+        // the method -- in particular, the `Self` type will be fully\n+        // resolved. However, those are not something that the \"user\n+        // specified\" -- i.e., those types come from the inferred type\n+        // of the receiver, not something the user wrote. So when we\n+        // create the user-substs, we want to replace those earlier\n+        // types with just the types that the user actually wrote --\n+        // that is, those that appear on the *method itself*.\n+        //\n+        // As an example, if the user wrote something like\n+        // `foo.bar::<u32>(...)` -- the `Self` type here will be the\n+        // type of `foo` (possibly adjusted), but we don't want to\n+        // include that. We want just the `[_, u32]` part.\n+        if !method.substs.is_noop() {\n+            let method_generics = self.tcx.generics_of(method.def_id);\n+            if !method_generics.params.is_empty() {\n+                let user_substs = self.infcx.probe(|_| {\n+                    let just_method_substs = Substs::for_item(self.tcx, method.def_id, |param, _| {\n+                        let i = param.index as usize;\n+                        if i < method_generics.parent_count {\n+                            self.infcx.var_for_def(DUMMY_SP, param)\n+                        } else {\n+                            method.substs[i]\n+                        }\n+                    });\n+                    self.infcx.canonicalize_response(&just_method_substs)\n+                });\n+\n+                debug!(\"write_method_call: user_substs = {:?}\", user_substs);\n+                self.write_user_substs(hir_id, user_substs);\n+            }\n+        }\n     }\n \n     pub fn write_substs(&self, node_id: hir::HirId, substs: &'tcx Substs<'tcx>) {\n@@ -2076,6 +2113,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    pub fn write_user_substs(&self, node_id: hir::HirId, substs: CanonicalSubsts<'tcx>) {\n+        debug!(\n+            \"write_user_substs({:?}, {:?}) in fcx {}\",\n+            node_id,\n+            substs,\n+            self.tag(),\n+        );\n+\n+        if !substs.is_identity() {\n+            self.tables.borrow_mut().user_substs_mut().insert(node_id, substs);\n+        } else {\n+            debug!(\"write_user_substs: skipping identity substs\");\n+        }\n+    }\n+\n     pub fn apply_adjustments(&self, expr: &hir::Expr, adj: Vec<Adjustment<'tcx>>) {\n         debug!(\"apply_adjustments(expr={:?}, adj={:?})\", expr, adj);\n \n@@ -5083,7 +5135,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"instantiate_value_path: type of {:?} is {:?}\",\n                node_id,\n                ty_substituted);\n-        self.write_substs(self.tcx.hir.node_to_hir_id(node_id), substs);\n+        let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n+        self.write_substs(hir_id, substs);\n+\n+        if !substs.is_noop() {\n+            let user_substs = self.infcx.canonicalize_response(&substs);\n+            debug!(\"instantiate_value_path: user_substs = {:?}\", user_substs);\n+            self.write_user_substs(hir_id, user_substs);\n+        }\n+\n         ty_substituted\n     }\n "}, {"sha": "0d8401c1c86efafd66ea4c4606283f795fc21b09", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d7d4d7c8d5620b7b120304cc5eecf25b499e394a/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d4d7c8d5620b7b120304cc5eecf25b499e394a/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=d7d4d7c8d5620b7b120304cc5eecf25b499e394a", "patch": "@@ -35,7 +35,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let item_id = self.tcx.hir.body_owner(body.id());\n         let item_def_id = self.tcx.hir.local_def_id(item_id);\n \n-        let mut wbcx = WritebackCx::new(self, body);\n+        // This attribute causes us to dump some writeback information\n+        // in the form of errors, which is used for unit tests.\n+        let rustc_dump_user_substs = self.tcx.has_attr(item_def_id, \"rustc_dump_user_substs\");\n+\n+        let mut wbcx = WritebackCx::new(self, body, rustc_dump_user_substs);\n         for arg in &body.arguments {\n             wbcx.visit_node_id(arg.pat.span, arg.hir_id);\n         }\n@@ -84,19 +88,23 @@ struct WritebackCx<'cx, 'gcx: 'cx + 'tcx, 'tcx: 'cx> {\n     tables: ty::TypeckTables<'gcx>,\n \n     body: &'gcx hir::Body,\n+\n+    rustc_dump_user_substs: bool,\n }\n \n impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     fn new(\n         fcx: &'cx FnCtxt<'cx, 'gcx, 'tcx>,\n         body: &'gcx hir::Body,\n+        rustc_dump_user_substs: bool,\n     ) -> WritebackCx<'cx, 'gcx, 'tcx> {\n         let owner = fcx.tcx.hir.definitions().node_to_hir_id(body.id().node_id);\n \n         WritebackCx {\n             fcx,\n             tables: ty::TypeckTables::empty(Some(DefId::local(owner.owner))),\n             body,\n+            rustc_dump_user_substs,\n         }\n     }\n \n@@ -558,6 +566,22 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             assert!(!substs.needs_infer() && !substs.has_skol());\n             self.tables.node_substs_mut().insert(hir_id, substs);\n         }\n+\n+        // Copy over any user-substs\n+        if let Some(user_substs) = self.fcx.tables.borrow().user_substs(hir_id) {\n+            let user_substs = self.tcx().lift_to_global(&user_substs).unwrap();\n+            self.tables.user_substs_mut().insert(hir_id, user_substs);\n+\n+            // Unit-testing mechanism:\n+            if self.rustc_dump_user_substs {\n+                let node_id = self.tcx().hir.hir_to_node_id(hir_id);\n+                let span = self.tcx().hir.span(node_id);\n+                self.tcx().sess.span_err(\n+                    span,\n+                    &format!(\"user substs: {:?}\", user_substs),\n+                );\n+            }\n+        }\n     }\n \n     fn visit_adjustments(&mut self, span: Span, hir_id: hir::HirId) {"}, {"sha": "28d278360345ebb3d09d5fbac6b7cec6e1f8ea6c", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7d4d7c8d5620b7b120304cc5eecf25b499e394a/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d4d7c8d5620b7b120304cc5eecf25b499e394a/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=d7d4d7c8d5620b7b120304cc5eecf25b499e394a", "patch": "@@ -865,6 +865,12 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n                                         is just used for rustc unit tests \\\n                                         and will never be stable\",\n                                        cfg_fn!(rustc_attrs))),\n+    (\"rustc_dump_user_substs\", Whitelisted, Gated(Stability::Unstable,\n+                                       \"rustc_attrs\",\n+                                       \"the `#[rustc_error]` attribute \\\n+                                        is just used for rustc unit tests \\\n+                                        and will never be stable\",\n+                                       cfg_fn!(rustc_attrs))),\n     (\"rustc_if_this_changed\", Whitelisted, Gated(Stability::Unstable,\n                                                  \"rustc_attrs\",\n                                                  \"the `#[rustc_if_this_changed]` attribute \\"}, {"sha": "fa14009da5a1dd6542c9bc22a5fd657c22d00476", "filename": "src/test/ui/nll/user-annotations/dump-fn-method.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/d7d4d7c8d5620b7b120304cc5eecf25b499e394a/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7d4d7c8d5620b7b120304cc5eecf25b499e394a/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.rs?ref=d7d4d7c8d5620b7b120304cc5eecf25b499e394a", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Unit test for the \"user substitutions\" that are annotated on each\n+// node.\n+\n+// compile-flags:-Zverbose\n+\n+#![feature(nll)]\n+#![feature(rustc_attrs)]\n+\n+trait Bazoom<T> {\n+    fn method<U>(&self, arg: T, arg2: U) { }\n+}\n+\n+impl<T, U> Bazoom<U> for T {\n+}\n+\n+fn foo<'a, T>(_: T) { }\n+\n+#[rustc_dump_user_substs]\n+fn main() {\n+    // Here: nothing is given, so we don't have any annotation.\n+    let x = foo;\n+    x(22);\n+\n+    // Here: `u32` is given.\n+    let x = foo::<u32>; //~ ERROR [u32]\n+    x(22);\n+\n+    // Here: we only want the `T` to be given, the rest should be variables.\n+    let x = <_ as Bazoom<u32>>::method::<_>; //~ ERROR [?0, u32, ?1]\n+    x(&22, 44, 66);\n+\n+    // Here: all are given\n+    let x = <u8 as Bazoom<u16>>::method::<u32>; //~ ERROR [u8, u16, u32]\n+    x(&22, 44, 66);\n+\n+    // Here: we want in particular that *only* the method `U`\n+    // annotation is given, the rest are variables.\n+    let y = 22_u32;\n+    y.method::<u32>(44, 66); //~ ERROR [?0, ?1, u32]\n+\n+    // Here: nothing is given, so we don't have any annotation.\n+    let y = 22_u32;\n+    y.method(44, 66);\n+}"}, {"sha": "8f3a0498e24e2c4220b59d9ec637bbe41417a03c", "filename": "src/test/ui/nll/user-annotations/dump-fn-method.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d7d4d7c8d5620b7b120304cc5eecf25b499e394a/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7d4d7c8d5620b7b120304cc5eecf25b499e394a/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.stderr?ref=d7d4d7c8d5620b7b120304cc5eecf25b499e394a", "patch": "@@ -0,0 +1,26 @@\n+error: user substs: Canonical { variables: [], value: [u32] }\n+  --> $DIR/dump-fn-method.rs:35:13\n+   |\n+LL |     let x = foo::<u32>; //~ ERROR [u32]\n+   |             ^^^^^^^^^^\n+\n+error: user substs: Canonical { variables: [CanonicalVarInfo { kind: Ty(General) }, CanonicalVarInfo { kind: Ty(General) }], value: [?0, u32, ?1] }\n+  --> $DIR/dump-fn-method.rs:39:13\n+   |\n+LL |     let x = <_ as Bazoom<u32>>::method::<_>; //~ ERROR [?0, u32, ?1]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: user substs: Canonical { variables: [], value: [u8, u16, u32] }\n+  --> $DIR/dump-fn-method.rs:43:13\n+   |\n+LL |     let x = <u8 as Bazoom<u16>>::method::<u32>; //~ ERROR [u8, u16, u32]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: user substs: Canonical { variables: [CanonicalVarInfo { kind: Ty(General) }, CanonicalVarInfo { kind: Ty(General) }], value: [?0, ?1, u32] }\n+  --> $DIR/dump-fn-method.rs:49:5\n+   |\n+LL |     y.method::<u32>(44, 66); //~ ERROR [?0, ?1, u32]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+"}]}