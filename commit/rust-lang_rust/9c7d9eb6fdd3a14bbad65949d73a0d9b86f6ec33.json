{"sha": "9c7d9eb6fdd3a14bbad65949d73a0d9b86f6ec33", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljN2Q5ZWI2ZmRkM2ExNGJiYWQ2NTk0OWQ3M2EwZDliODZmNmVjMzM=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-08-06T22:13:31Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-08-13T09:13:49Z"}, "message": "debuginfo: Add support for argument shadowing.", "tree": {"sha": "6f911e58dffa2e4adb279e881076cd3c6ea64d67", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f911e58dffa2e4adb279e881076cd3c6ea64d67"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c7d9eb6fdd3a14bbad65949d73a0d9b86f6ec33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c7d9eb6fdd3a14bbad65949d73a0d9b86f6ec33", "html_url": "https://github.com/rust-lang/rust/commit/9c7d9eb6fdd3a14bbad65949d73a0d9b86f6ec33", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c7d9eb6fdd3a14bbad65949d73a0d9b86f6ec33/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33e7d95e9c4ff02b4fb949ea51a26a8bf5e9ae5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/33e7d95e9c4ff02b4fb949ea51a26a8bf5e9ae5c", "html_url": "https://github.com/rust-lang/rust/commit/33e7d95e9c4ff02b4fb949ea51a26a8bf5e9ae5c"}], "stats": {"total": 146, "additions": 110, "deletions": 36}, "files": [{"sha": "9aa18bc05f8fa884ff22abb255dcebb2cc8e24fe", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c7d9eb6fdd3a14bbad65949d73a0d9b86f6ec33/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c7d9eb6fdd3a14bbad65949d73a0d9b86f6ec33/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=9c7d9eb6fdd3a14bbad65949d73a0d9b86f6ec33", "patch": "@@ -230,8 +230,6 @@ pub struct FunctionContext {\n     ccx: @mut CrateContext,\n \n     // Used and maintained by the debuginfo module.\n-    // @jdm: Not sure if the Option-wrapper is a good idea. It allows to save some space in\n-    // non-debug builds, but generates quite a bit of noise at usage sites. What's your opinion?\n     debug_context: Option<~debuginfo::FunctionDebugContext>\n }\n "}, {"sha": "5591f7debf8e613fd52ced546759caa6966a98f2", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 51, "deletions": 34, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/9c7d9eb6fdd3a14bbad65949d73a0d9b86f6ec33/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c7d9eb6fdd3a14bbad65949d73a0d9b86f6ec33/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=9c7d9eb6fdd3a14bbad65949d73a0d9b86f6ec33", "patch": "@@ -271,32 +271,32 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n     let cx = fcx.ccx;\n \n     let fnitem = cx.tcx.items.get_copy(&fcx.id);\n-    let (ident, ret_ty, id) = match fnitem {\n+    let (ident, fn_decl, id) = match fnitem {\n         ast_map::node_item(ref item, _) => {\n             match item.node {\n-                ast::item_fn(ast::fn_decl { output: ref ty, _}, _, _, _, _) => {\n-                    (item.ident, ty, item.id)\n+                ast::item_fn(ref fn_decl, _, _, _, _) => {\n+                    (item.ident, fn_decl, item.id)\n                 }\n                 _ => fcx.ccx.sess.span_bug(item.span,\n                                            \"create_function_metadata: item bound to non-function\")\n             }\n         }\n         ast_map::node_method(\n             @ast::method {\n-                decl: ast::fn_decl { output: ref ty, _ },\n+                decl: ref fn_decl,\n                 id: id,\n                 ident: ident,\n                 _\n             },\n             _,\n             _) => {\n-            (ident, ty, id)\n+            (ident, fn_decl, id)\n         }\n         ast_map::node_expr(ref expr) => {\n             match expr.node {\n-                ast::expr_fn_block(ref decl, _) => {\n+                ast::expr_fn_block(ref fn_decl, _) => {\n                     let name = gensym_name(\"fn\");\n-                    (name, &decl.output, expr.id)\n+                    (name, fn_decl, expr.id)\n                 }\n                 _ => fcx.ccx.sess.span_bug(expr.span,\n                         \"create_function_metadata: expected an expr_fn_block here\")\n@@ -305,14 +305,14 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n         ast_map::node_trait_method(\n             @ast::provided(\n                 @ast::method {\n-                    decl: ast::fn_decl { output: ref ty, _ },\n+                    decl: ref fn_decl,\n                     id: id,\n                     ident: ident,\n                     _\n                 }),\n             _,\n             _) => {\n-            (ident, ty, id)\n+            (ident, fn_decl, id)\n         }\n         _ => fcx.ccx.sess.bug(fmt!(\"create_function_metadata: unexpected sort of node: %?\", fnitem))\n     };\n@@ -335,9 +335,9 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n     let file_metadata = file_metadata(cx, loc.file.name);\n \n     let return_type_metadata = if cx.sess.opts.extra_debuginfo {\n-        match ret_ty.node {\n+        match fn_decl.output.node {\n           ast::ty_nil => ptr::null(),\n-          _ => type_metadata(cx, ty::node_id_to_type(cx.tcx, id), ret_ty.span)\n+          _ => type_metadata(cx, ty::node_id_to_type(cx.tcx, id), fn_decl.output.span)\n         }\n     } else {\n         ptr::null()\n@@ -382,7 +382,9 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n     match *entry_block {\n         ast_map::node_block(ref block) => {\n             let scope_map = &mut fn_debug_context.scope_map;\n-            populate_scope_map(cx, block, fn_metadata, scope_map);\n+            let arg_pats = do fn_decl.inputs.map |arg_ref| { arg_ref.pat };\n+\n+            populate_scope_map(cx, arg_pats, block, fn_metadata, scope_map);\n         }\n         _ => cx.sess.span_bug(span,\n                 fmt!(\"debuginfo::create_function_metadata() - \\\n@@ -1278,9 +1280,11 @@ fn DIB(cx: &CrateContext) -> DIBuilderRef {\n // descriptors where necessary. These artificial scopes allow GDB to correctly handle name\n // shadowing.\n fn populate_scope_map(cx: &mut CrateContext,\n+                      arg_pats: &[@ast::pat],\n                       fn_entry_block: &ast::Block,\n                       fn_metadata: DISubprogram,\n                       scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n+    let def_map = cx.tcx.def_map;\n \n     struct ScopeStackEntry {\n         scope_metadata: DIScope,\n@@ -1289,6 +1293,15 @@ fn populate_scope_map(cx: &mut CrateContext,\n \n     let mut scope_stack = ~[ScopeStackEntry { scope_metadata: fn_metadata, ident: None }];\n \n+    // Push argument identifiers onto the stack so arguments integrate nicely with variable\n+    // shadowing.\n+    for &arg_pat in arg_pats.iter() {\n+        do pat_util::pat_bindings(def_map, arg_pat) |_, _, _, path_ref| {\n+            let ident = ast_util::path_to_ident(path_ref);\n+            scope_stack.push(ScopeStackEntry { scope_metadata: fn_metadata, ident: Some(ident) });\n+        }\n+    }\n+\n     walk_block(cx, fn_entry_block, &mut scope_stack, scope_map);\n \n     // local helper functions for walking the AST.\n@@ -1300,7 +1313,6 @@ fn populate_scope_map(cx: &mut CrateContext,\n                       inner_walk: &fn(&mut CrateContext,\n                                       &mut ~[ScopeStackEntry],\n                                       &mut HashMap<ast::NodeId, DIScope>)) {\n-\n         // Create a new lexical scope and push it onto the stack\n         let loc = cx.sess.codemap.lookup_char_pos(scope_span.lo);\n         let file_metadata = file_metadata(cx, loc.file.name);\n@@ -1335,7 +1347,6 @@ fn populate_scope_map(cx: &mut CrateContext,\n                   block: &ast::Block,\n                   scope_stack: &mut ~[ScopeStackEntry],\n                   scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n-\n         scope_map.insert(block.id, scope_stack.last().scope_metadata);\n \n         // The interesting things here are statements and the concluding expression.\n@@ -1361,7 +1372,6 @@ fn populate_scope_map(cx: &mut CrateContext,\n                  scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n         match *decl {\n             codemap::spanned { node: ast::decl_local(@ref local), _ } => {\n-\n                 scope_map.insert(local.id, scope_stack.last().scope_metadata);\n \n                 walk_pattern(cx, local.pat, scope_stack, scope_map);\n@@ -1383,7 +1393,7 @@ fn populate_scope_map(cx: &mut CrateContext,\n \n         // Unfortunately, we cannot just use pat_util::pat_bindings() or ast_util::walk_pat() here\n         // because we have to visit *all* nodes in order to put them into the scope map. The above\n-        // function don't do that.\n+        // functions don't do that.\n         match pat.node {\n             ast::pat_ident(_, ref path_ref, ref sub_pat_opt) => {\n \n@@ -1412,9 +1422,8 @@ fn populate_scope_map(cx: &mut CrateContext,\n \n                     // Is there already a binding with that name?\n                     let need_new_scope = scope_stack\n-                        .rev_iter()\n-                        .find_(|entry| entry.ident.iter().any(|i| *i == ident))\n-                        .is_some();\n+                        .iter()\n+                        .any(|entry| entry.ident.iter().any(|i| *i == ident));\n \n                     if need_new_scope {\n                         // Create a new lexical scope and push it onto the stack\n@@ -1574,8 +1583,10 @@ fn populate_scope_map(cx: &mut CrateContext,\n             ast::expr_if(@ref cond_exp, ref then_block, ref opt_else_exp) => {\n                 walk_expr(cx, cond_exp, scope_stack, scope_map);\n \n-                do with_new_scope(cx, then_block.span, scope_stack, scope_map) |c, s, m| {\n-                    walk_block(c, then_block, s, m);\n+                do with_new_scope(cx, then_block.span, scope_stack, scope_map) |cx,\n+                                                                                scope_stack,\n+                                                                                scope_map| {\n+                    walk_block(cx, then_block, scope_stack, scope_map);\n                 }\n \n                 match *opt_else_exp {\n@@ -1587,8 +1598,10 @@ fn populate_scope_map(cx: &mut CrateContext,\n             ast::expr_while(@ref cond_exp, ref loop_body) => {\n                 walk_expr(cx, cond_exp, scope_stack, scope_map);\n \n-                do with_new_scope(cx, loop_body.span, scope_stack, scope_map) |c, s, m| {\n-                    walk_block(c, loop_body, s, m);\n+                do with_new_scope(cx, loop_body.span, scope_stack, scope_map) |cx,\n+                                                                               scope_stack,\n+                                                                               scope_map| {\n+                    walk_block(cx, loop_body, scope_stack, scope_map);\n                 }\n             }\n \n@@ -1604,20 +1617,22 @@ fn populate_scope_map(cx: &mut CrateContext,\n \n             ast::expr_loop(ref block, _) |\n             ast::expr_block(ref block)   => {\n-                do with_new_scope(cx, block.span, scope_stack, scope_map) |c, s, m| {\n-                    walk_block(c, block, s, m);\n+                do with_new_scope(cx, block.span, scope_stack, scope_map) |cx,\n+                                                                           scope_stack,\n+                                                                           scope_map| {\n+                    walk_block(cx, block, scope_stack, scope_map);\n                 }\n             }\n \n             ast::expr_fn_block(ast::fn_decl { inputs: ref inputs, _ }, ref block) => {\n-\n-                do with_new_scope(cx, block.span, scope_stack, scope_map) |c, s, m| {\n-\n+                do with_new_scope(cx, block.span, scope_stack, scope_map) |cx,\n+                                                                           scope_stack,\n+                                                                           scope_map| {\n                     for &ast::arg { pat: pattern, _ } in inputs.iter() {\n-                        walk_pattern(c, pattern, s, m);\n+                        walk_pattern(cx, pattern, scope_stack, scope_map);\n                     }\n \n-                    walk_block(c, block, s, m);\n+                    walk_block(cx, block, scope_stack, scope_map);\n                 }\n             }\n \n@@ -1663,14 +1678,16 @@ fn populate_scope_map(cx: &mut CrateContext,\n                 for arm_ref in arms.iter() {\n                     let arm_span = arm_ref.pats[0].span;\n \n-                    do with_new_scope(cx, arm_span, scope_stack, scope_map) |c, s, m| {\n-                        walk_pattern(c, arm_ref.pats[0], s, m);\n+                    do with_new_scope(cx, arm_span, scope_stack, scope_map) |cx,\n+                                                                             scope_stack,\n+                                                                             scope_map| {\n+                        walk_pattern(cx, arm_ref.pats[0], scope_stack, scope_map);\n \n                         for &@ref guard_exp in arm_ref.guard.iter() {\n-                            walk_expr(c, guard_exp, s, m)\n+                            walk_expr(cx, guard_exp, scope_stack, scope_map)\n                         }\n \n-                        walk_block(c, &arm_ref.body, s, m);\n+                        walk_block(cx, &arm_ref.body, scope_stack, scope_map);\n                     }\n                 }\n             }"}, {"sha": "b79b65c5f80db3652f2f24fb592a247b131e82ed", "filename": "src/test/debug-info/shadowed-argument.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/9c7d9eb6fdd3a14bbad65949d73a0d9b86f6ec33/src%2Ftest%2Fdebug-info%2Fshadowed-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c7d9eb6fdd3a14bbad65949d73a0d9b86f6ec33/src%2Ftest%2Fdebug-info%2Fshadowed-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fshadowed-argument.rs?ref=9c7d9eb6fdd3a14bbad65949d73a0d9b86f6ec33", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$1 = false\n+// debugger:print y\n+// check:$2 = true\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$3 = 10\n+// debugger:print y\n+// check:$4 = true\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$5 = 10.5\n+// debugger:print y\n+// check:$6 = 20\n+// debugger:continue\n+\n+fn a_function(x: bool, y: bool) {\n+    zzz();\n+    sentinel();\n+\n+    let x = 10;\n+\n+    zzz();\n+    sentinel();\n+\n+    let x = 10.5;\n+    let y = 20;\n+\n+    zzz();\n+    sentinel();\n+}\n+\n+fn main() {\n+    a_function(false, true);\n+}\n+\n+fn zzz() {()}\n+fn sentinel() {()}"}]}