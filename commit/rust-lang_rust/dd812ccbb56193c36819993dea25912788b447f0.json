{"sha": "dd812ccbb56193c36819993dea25912788b447f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkODEyY2NiYjU2MTkzYzM2ODE5OTkzZGVhMjU5MTI3ODhiNDQ3ZjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-03T19:56:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-03T19:56:47Z"}, "message": "auto merge of #15076 : luqmana/rust/naim, r=pcwalton\n\n```Rust\r\nstruct With {\r\n    x: int,\r\n    f: NoCopy\r\n}\r\n\r\n#[no_mangle]\r\nfn bar() {\r\n    let mine = With { x: 3, f: NoCopy };\r\n    match mine {\r\n        c => {\r\n            foo(c);\r\n        }\r\n    }\r\n}\r\n\r\n#[no_mangle]\r\nfn foo(_: With) {}\r\n```\r\n\r\nBefore:\r\n```LLVM\r\ndefine internal void @bar() unnamed_addr #1 {\r\nentry-block:\r\n  %mine = alloca %\"struct.With<[]>\"\r\n  %__llmatch = alloca %\"struct.With<[]>\"*\r\n  %c = alloca %\"struct.With<[]>\"\r\n  %0 = getelementptr inbounds %\"struct.With<[]>\"* %mine, i32 0, i32 0\r\n  store i64 3, i64* %0\r\n  %1 = getelementptr inbounds %\"struct.With<[]>\"* %mine, i32 0, i32 1\r\n  store %\"struct.With<[]>\"* %mine, %\"struct.With<[]>\"** %__llmatch\r\n  br label %case_body\r\n\r\ncase_body:                                        ; preds = %entry-block\r\n  %2 = load %\"struct.With<[]>\"** %__llmatch\r\n  %3 = bitcast %\"struct.With<[]>\"* %2 to i8*\r\n  %4 = bitcast %\"struct.With<[]>\"* %c to i8*\r\n  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %4, i8* %3, i64 8, i32 8, i1 false)\r\n  %5 = load %\"struct.With<[]>\"* %c\r\n  call void @foo(%\"struct.With<[]>\" %5)\r\n  br label %join\r\n\r\njoin:                                             ; preds = %case_body\r\n  ret void\r\n}\r\n```\r\n\r\nAfter:\r\n```LLVM\r\ndefine internal void @bar() unnamed_addr #1 {\r\nentry-block:\r\n  %mine = alloca %\"struct.With<[]>\"\r\n  %c = alloca %\"struct.With<[]>\"*\r\n  %0 = getelementptr inbounds %\"struct.With<[]>\"* %mine, i32 0, i32 0\r\n  store i64 3, i64* %0\r\n  %1 = getelementptr inbounds %\"struct.With<[]>\"* %mine, i32 0, i32 1\r\n  store %\"struct.With<[]>\"* %mine, %\"struct.With<[]>\"** %c\r\n  br label %case_body\r\n\r\ncase_body:                                        ; preds = %entry-block\r\n  %2 = load %\"struct.With<[]>\"** %c\r\n  %3 = load %\"struct.With<[]>\"* %2\r\n  call void @foo(%\"struct.With<[]>\" %3)\r\n  br label %join\r\n\r\njoin:                                             ; preds = %case_body\r\n  ret void\r\n}\r\n```\r\n\r\nr? @pcwalton", "tree": {"sha": "10d92c0c6c5e48e8025398ba87fbc3e0d824783c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10d92c0c6c5e48e8025398ba87fbc3e0d824783c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd812ccbb56193c36819993dea25912788b447f0", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd812ccbb56193c36819993dea25912788b447f0", "html_url": "https://github.com/rust-lang/rust/commit/dd812ccbb56193c36819993dea25912788b447f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd812ccbb56193c36819993dea25912788b447f0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eda75bcf42ad99e3e4c99585d39705fccac606ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/eda75bcf42ad99e3e4c99585d39705fccac606ee", "html_url": "https://github.com/rust-lang/rust/commit/eda75bcf42ad99e3e4c99585d39705fccac606ee"}, {"sha": "77f72d36ecd447877634d8e5c54b8d793e34cefa", "url": "https://api.github.com/repos/rust-lang/rust/commits/77f72d36ecd447877634d8e5c54b8d793e34cefa", "html_url": "https://github.com/rust-lang/rust/commit/77f72d36ecd447877634d8e5c54b8d793e34cefa"}], "stats": {"total": 226, "additions": 89, "deletions": 137}, "files": [{"sha": "d1ec7c6500d25720ff7a875825392ff83f80a40e", "filename": "mk/platform.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dd812ccbb56193c36819993dea25912788b447f0/mk%2Fplatform.mk", "raw_url": "https://github.com/rust-lang/rust/raw/dd812ccbb56193c36819993dea25912788b447f0/mk%2Fplatform.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fplatform.mk?ref=dd812ccbb56193c36819993dea25912788b447f0", "patch": "@@ -461,6 +461,7 @@ CFG_PATH_MUNGE_i686-pc-mingw32 :=\n CFG_LDPATH_i686-pc-mingw32 :=$(CFG_LDPATH_i686-pc-mingw32):$(PATH)\n CFG_RUN_i686-pc-mingw32=PATH=\"$(CFG_LDPATH_i686-pc-mingw32):$(1)\" $(2)\n CFG_RUN_TARG_i686-pc-mingw32=$(call CFG_RUN_i686-pc-mingw32,$(HLIB$(1)_H_$(CFG_BUILD)),$(2))\n+RUSTC_FLAGS_i686-pc-mingw32=-C link-args=\"-Wl,--large-address-aware\"\n \n # i586-mingw32msvc configuration\n CC_i586-mingw32msvc=$(CFG_MINGW32_CROSS_PATH)/bin/i586-mingw32msvc-gcc"}, {"sha": "310d0f19c329a391d88b7ec242f60021fd3daecb", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 63, "deletions": 129, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/dd812ccbb56193c36819993dea25912788b447f0/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd812ccbb56193c36819993dea25912788b447f0/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=dd812ccbb56193c36819993dea25912788b447f0", "patch": "@@ -64,10 +64,12 @@\n  * We store information about the bound variables for each arm as part of the\n  * per-arm `ArmData` struct.  There is a mapping from identifiers to\n  * `BindingInfo` structs.  These structs contain the mode/id/type of the\n- * binding, but they also contain up to two LLVM values, called `llmatch` and\n- * `llbinding` respectively (the `llbinding`, as will be described shortly, is\n- * optional and only present for by-value bindings---therefore it is bundled\n- * up as part of the `TransBindingMode` type).  Both point at allocas.\n+ * binding, but they also contain an LLVM value which points at an alloca\n+ * called `llmatch`. For by value bindings that are Copy, we also create\n+ * an extra alloca that we copy the matched value to so that any changes\n+ * we do to our copy is not reflected in the original and vice-versa.\n+ * We don't do this if it's a move since the original value can't be used\n+ * and thus allowing us to cheat in not creating an extra alloca.\n  *\n  * The `llmatch` binding always stores a pointer into the value being matched\n  * which points at the data for the binding.  If the value being matched has\n@@ -83,32 +85,26 @@\n  * up against an identifier, we store the current pointer into the\n  * corresponding alloca.\n  *\n- * In addition, for each by-value binding (copy or move), we will create a\n- * second alloca (`llbinding`) that will hold the final value.  In this\n- * example, that means that `d` would have this second alloca of type `D` (and\n- * hence `llbinding` has type `D*`).\n- *\n  * Once a pattern is completely matched, and assuming that there is no guard\n  * pattern, we will branch to a block that leads to the body itself.  For any\n  * by-value bindings, this block will first load the ptr from `llmatch` (the\n- * one of type `D*`) and copy/move the value into `llbinding` (the one of type\n- * `D`).  The second alloca then becomes the value of the local variable.  For\n- * by ref bindings, the value of the local variable is simply the first\n- * alloca.\n+ * one of type `D*`) and then load a second time to get the actual value (the\n+ * one of type `D`). For by ref bindings, the value of the local variable is\n+ * simply the first alloca.\n  *\n  * So, for the example above, we would generate a setup kind of like this:\n  *\n  *        +-------+\n  *        | Entry |\n  *        +-------+\n  *            |\n- *        +-------------------------------------------+\n- *        | llmatch_c = (addr of first half of tuple) |\n- *        | llmatch_d = (addr of first half of tuple) |\n- *        +-------------------------------------------+\n+ *        +--------------------------------------------+\n+ *        | llmatch_c = (addr of first half of tuple)  |\n+ *        | llmatch_d = (addr of second half of tuple) |\n+ *        +--------------------------------------------+\n  *            |\n  *        +--------------------------------------+\n- *        | *llbinding_d = **llmatch_dlbinding_d |\n+ *        | *llbinding_d = **llmatch_d           |\n  *        +--------------------------------------+\n  *\n  * If there is a guard, the situation is slightly different, because we must\n@@ -127,22 +123,20 @@\n  *        +-------------------------------------------+\n  *            |\n  *        +-------------------------------------------------+\n- *        | *llbinding_d = **llmatch_dlbinding_d            |\n+ *        | *llbinding_d = **llmatch_d                      |\n  *        | check condition                                 |\n- *        | if false { free *llbinding_d, goto next case }  |\n+ *        | if false { goto next case }                     |\n  *        | if true { goto body }                           |\n  *        +-------------------------------------------------+\n  *\n  * The handling for the cleanups is a bit... sensitive.  Basically, the body\n  * is the one that invokes `add_clean()` for each binding.  During the guard\n  * evaluation, we add temporary cleanups and revoke them after the guard is\n- * evaluated (it could fail, after all).  Presuming the guard fails, we drop\n- * the various values we copied explicitly.  Note that guards and moves are\n+ * evaluated (it could fail, after all). Note that guards and moves are\n  * just plain incompatible.\n  *\n  * Some relevant helper functions that manage bindings:\n  * - `create_bindings_map()`\n- * - `store_non_ref_bindings()`\n  * - `insert_lllocals()`\n  *\n  *\n@@ -216,7 +210,6 @@ use middle::trans::datum;\n use middle::trans::datum::*;\n use middle::trans::expr::Dest;\n use middle::trans::expr;\n-use middle::trans::glue;\n use middle::trans::tvec;\n use middle::trans::type_of;\n use middle::trans::debuginfo;\n@@ -357,8 +350,9 @@ fn variant_opt(bcx: &Block, pat_id: ast::NodeId) -> Opt {\n }\n \n #[deriving(Clone)]\n-enum TransBindingMode {\n-    TrByValue(/*llbinding:*/ ValueRef),\n+pub enum TransBindingMode {\n+    TrByCopy(/* llbinding */ ValueRef),\n+    TrByMove,\n     TrByRef,\n }\n \n@@ -371,12 +365,12 @@ enum TransBindingMode {\n  * - `id` is the node id of the binding\n  * - `ty` is the Rust type of the binding */\n  #[deriving(Clone)]\n-struct BindingInfo {\n-    llmatch: ValueRef,\n-    trmode: TransBindingMode,\n-    id: ast::NodeId,\n-    span: Span,\n-    ty: ty::t,\n+pub struct BindingInfo {\n+    pub llmatch: ValueRef,\n+    pub trmode: TransBindingMode,\n+    pub id: ast::NodeId,\n+    pub span: Span,\n+    pub ty: ty::t,\n }\n \n type BindingsMap = HashMap<Ident, BindingInfo>;\n@@ -970,64 +964,34 @@ fn compare_values<'a>(\n     }\n }\n \n-fn store_non_ref_bindings<'a>(\n-                          bcx: &'a Block<'a>,\n-                          bindings_map: &BindingsMap,\n-                          opt_cleanup_scope: Option<cleanup::ScopeId>)\n-                          -> &'a Block<'a>\n-{\n-    /*!\n-     * For each copy/move binding, copy the value from the value being\n-     * matched into its final home.  This code executes once one of\n-     * the patterns for a given arm has completely matched.  It adds\n-     * cleanups to the `opt_cleanup_scope`, if one is provided.\n-     */\n-\n-    let fcx = bcx.fcx;\n-    let mut bcx = bcx;\n-    for (_, &binding_info) in bindings_map.iter() {\n-        match binding_info.trmode {\n-            TrByValue(lldest) => {\n-                let llval = Load(bcx, binding_info.llmatch); // get a T*\n-                let datum = Datum::new(llval, binding_info.ty, Lvalue);\n-                bcx = datum.store_to(bcx, lldest);\n-\n-                match opt_cleanup_scope {\n-                    None => {}\n-                    Some(s) => {\n-                        fcx.schedule_drop_mem(s, lldest, binding_info.ty);\n-                    }\n-                }\n-            }\n-            TrByRef => {}\n-        }\n-    }\n-    return bcx;\n-}\n-\n-fn insert_lllocals<'a>(bcx: &'a Block<'a>,\n-                       bindings_map: &BindingsMap,\n-                       cleanup_scope: cleanup::ScopeId)\n+fn insert_lllocals<'a>(mut bcx: &'a Block<'a>,\n+                       bindings_map: &BindingsMap)\n                        -> &'a Block<'a> {\n     /*!\n      * For each binding in `data.bindings_map`, adds an appropriate entry into\n-     * the `fcx.lllocals` map, scheduling cleanup in `cleanup_scope`.\n+     * the `fcx.lllocals` map\n      */\n \n-    let fcx = bcx.fcx;\n-\n     for (&ident, &binding_info) in bindings_map.iter() {\n         let llval = match binding_info.trmode {\n-            // By value bindings: use the stack slot that we\n-            // copied/moved the value into\n-            TrByValue(lldest) => lldest,\n+            // By value mut binding for a copy type: load from the ptr\n+            // into the matched value and copy to our alloca\n+            TrByCopy(llbinding) => {\n+                let llval = Load(bcx, binding_info.llmatch);\n+                let datum = Datum::new(llval, binding_info.ty, Lvalue);\n+                bcx = datum.store_to(bcx, llbinding);\n+\n+                llbinding\n+            },\n+\n+            // By value move bindings: load from the ptr into the matched value\n+            TrByMove => Load(bcx, binding_info.llmatch),\n \n             // By ref binding: use the ptr into the matched value\n             TrByRef => binding_info.llmatch\n         };\n \n         let datum = Datum::new(llval, binding_info.ty, Lvalue);\n-        fcx.schedule_drop_mem(cleanup_scope, llval, binding_info.ty);\n \n         debug!(\"binding {:?} to {}\",\n                binding_info.id,\n@@ -1037,9 +1001,7 @@ fn insert_lllocals<'a>(bcx: &'a Block<'a>,\n         if bcx.sess().opts.debuginfo == FullDebugInfo {\n             debuginfo::create_match_binding_metadata(bcx,\n                                                      ident,\n-                                                     binding_info.id,\n-                                                     binding_info.span,\n-                                                     datum);\n+                                                     binding_info);\n         }\n     }\n     bcx\n@@ -1061,28 +1023,16 @@ fn compile_guard<'a, 'b>(\n            vec_map_to_str(vals, |v| bcx.val_to_str(*v)));\n     let _indenter = indenter();\n \n-    // Lest the guard itself should fail, introduce a temporary cleanup\n-    // scope for any non-ref bindings we create.\n-    let temp_scope = bcx.fcx.push_custom_cleanup_scope();\n-\n-    let mut bcx = bcx;\n-    bcx = store_non_ref_bindings(bcx, &data.bindings_map,\n-                                 Some(cleanup::CustomScope(temp_scope)));\n-    bcx = insert_lllocals(bcx, &data.bindings_map,\n-                          cleanup::CustomScope(temp_scope));\n+    let mut bcx = insert_lllocals(bcx, &data.bindings_map);\n \n     let val = unpack_datum!(bcx, expr::trans(bcx, guard_expr));\n     let val = val.to_llbool(bcx);\n \n-    // Cancel cleanups now that the guard successfully executed.  If\n-    // the guard was false, we will drop the values explicitly\n-    // below. Otherwise, we'll add lvalue cleanups at the end.\n-    bcx.fcx.pop_custom_cleanup_scope(temp_scope);\n-\n     return with_cond(bcx, Not(bcx, val), |bcx| {\n-        // Guard does not match: free the values we copied,\n-        // and remove all bindings from the lllocals table\n-        let bcx = drop_bindings(bcx, data);\n+        // Guard does not match: remove all bindings from the lllocals table\n+        for (_, &binding_info) in data.bindings_map.iter() {\n+            bcx.fcx.lllocals.borrow_mut().remove(&binding_info.id);\n+        }\n         match chk {\n             // If the default arm is the only one left, move on to the next\n             // condition explicitly rather than (possibly) falling back to\n@@ -1096,21 +1046,6 @@ fn compile_guard<'a, 'b>(\n         };\n         bcx\n     });\n-\n-    fn drop_bindings<'a>(bcx: &'a Block<'a>, data: &ArmData)\n-                     -> &'a Block<'a> {\n-        let mut bcx = bcx;\n-        for (_, &binding_info) in data.bindings_map.iter() {\n-            match binding_info.trmode {\n-                TrByValue(llval) => {\n-                    bcx = glue::drop_ty(bcx, llval, binding_info.ty);\n-                }\n-                TrByRef => {}\n-            }\n-            bcx.fcx.lllocals.borrow_mut().remove(&binding_info.id);\n-        }\n-        return bcx;\n-    }\n }\n \n fn compile_submatch<'a, 'b>(\n@@ -1435,18 +1370,28 @@ fn create_bindings_map(bcx: &Block, pat: Gc<ast::Pat>) -> BindingsMap {\n         let ident = path_to_ident(path);\n         let variable_ty = node_id_type(bcx, p_id);\n         let llvariable_ty = type_of::type_of(ccx, variable_ty);\n+        let tcx = bcx.tcx();\n \n         let llmatch;\n         let trmode;\n         match bm {\n+            ast::BindByValue(_)\n+                if !ty::type_moves_by_default(tcx, variable_ty) => {\n+                llmatch = alloca(bcx,\n+                                 llvariable_ty.ptr_to(),\n+                                 \"__llmatch\");\n+                trmode = TrByCopy(alloca(bcx,\n+                                         llvariable_ty,\n+                                         bcx.ident(ident).as_slice()));\n+            }\n             ast::BindByValue(_) => {\n                 // in this case, the final type of the variable will be T,\n                 // but during matching we need to store a *T as explained\n                 // above\n-                llmatch = alloca(bcx, llvariable_ty.ptr_to(), \"__llmatch\");\n-                trmode = TrByValue(alloca(bcx,\n-                                          llvariable_ty,\n-                                          bcx.ident(ident).as_slice()));\n+                llmatch = alloca(bcx,\n+                                 llvariable_ty.ptr_to(),\n+                                 bcx.ident(ident).as_slice());\n+                trmode = TrByMove;\n             }\n             ast::BindByRef(_) => {\n                 llmatch = alloca(bcx,\n@@ -1532,20 +1477,9 @@ fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n     for arm_data in arm_datas.iter() {\n         let mut bcx = arm_data.bodycx;\n \n-        // If this arm has a guard, then the various by-value bindings have\n-        // already been copied into their homes.  If not, we do it here.  This\n-        // is just to reduce code space.  See extensive comment at the start\n-        // of the file for more details.\n-        if arm_data.arm.guard.is_none() {\n-            bcx = store_non_ref_bindings(bcx, &arm_data.bindings_map, None);\n-        }\n-\n-        // insert bindings into the lllocals map and add cleanups\n-        let cleanup_scope = fcx.push_custom_cleanup_scope();\n-        bcx = insert_lllocals(bcx, &arm_data.bindings_map,\n-                              cleanup::CustomScope(cleanup_scope));\n+        // insert bindings into the lllocals map\n+        bcx = insert_lllocals(bcx, &arm_data.bindings_map);\n         bcx = expr::trans_into(bcx, &*arm_data.arm.body, dest);\n-        bcx = fcx.pop_and_trans_custom_cleanup_scope(bcx, cleanup_scope);\n         arm_cxs.push(bcx);\n     }\n "}, {"sha": "1c48d66f9b81e78cfc409824cdd582050a9e91ac", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/dd812ccbb56193c36819993dea25912788b447f0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd812ccbb56193c36819993dea25912788b447f0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=dd812ccbb56193c36819993dea25912788b447f0", "patch": "@@ -187,8 +187,8 @@ use metadata::csearch;\n use middle::subst;\n use middle::trans::adt;\n use middle::trans::common::*;\n-use middle::trans::datum::{Datum, Lvalue};\n use middle::trans::machine;\n+use middle::trans::_match::{BindingInfo, TrByCopy, TrByMove, TrByRef};\n use middle::trans::type_of;\n use middle::trans::type_::Type;\n use middle::trans;\n@@ -958,22 +958,39 @@ pub fn create_captured_var_metadata(bcx: &Block,\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_match_binding_metadata(bcx: &Block,\n                                      variable_ident: ast::Ident,\n-                                     node_id: ast::NodeId,\n-                                     span: Span,\n-                                     datum: Datum<Lvalue>) {\n+                                     binding: BindingInfo) {\n     if fn_should_be_ignored(bcx.fcx) {\n         return;\n     }\n \n-    let scope_metadata = scope_metadata(bcx.fcx, node_id, span);\n+    let scope_metadata = scope_metadata(bcx.fcx, binding.id, binding.span);\n+    let aops = unsafe {\n+        [llvm::LLVMDIBuilderCreateOpDeref(bcx.ccx().int_type.to_ref())]\n+    };\n+    // Regardless of the actual type (`T`) we're always passed the stack slot (alloca)\n+    // for the binding. For ByRef bindings that's a `T*` but for ByMove bindings we\n+    // actually have `T**`. So to get the actual variable we need to dereference once\n+    // more. For ByCopy we just use the stack slot we created for the binding.\n+    let var_type = match binding.trmode {\n+        TrByCopy(llbinding) => DirectVariable {\n+            alloca: llbinding\n+        },\n+        TrByMove => IndirectVariable {\n+            alloca: binding.llmatch,\n+            address_operations: aops\n+        },\n+        TrByRef => DirectVariable {\n+            alloca: binding.llmatch\n+        }\n+    };\n \n     declare_local(bcx,\n                   variable_ident,\n-                  datum.ty,\n+                  binding.ty,\n                   scope_metadata,\n-                  DirectVariable { alloca: datum.val },\n+                  var_type,\n                   LocalVariable,\n-                  span);\n+                  binding.span);\n }\n \n /// Creates debug information for the given function argument."}]}