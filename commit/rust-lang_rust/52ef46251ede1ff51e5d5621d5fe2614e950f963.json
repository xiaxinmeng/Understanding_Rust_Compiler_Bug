{"sha": "52ef46251ede1ff51e5d5621d5fe2614e950f963", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyZWY0NjI1MWVkZTFmZjUxZTVkNTYyMWQ1ZmUyNjE0ZTk1MGY5NjM=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-08-06T09:59:40Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-08-26T04:07:32Z"}, "message": "Rebasing changes", "tree": {"sha": "481371289f467bc89a6d6dc769635dac1d47a6cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/481371289f467bc89a6d6dc769635dac1d47a6cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52ef46251ede1ff51e5d5621d5fe2614e950f963", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52ef46251ede1ff51e5d5621d5fe2614e950f963", "html_url": "https://github.com/rust-lang/rust/commit/52ef46251ede1ff51e5d5621d5fe2614e950f963", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52ef46251ede1ff51e5d5621d5fe2614e950f963/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e626375d8d2226a203bf6ea6e98dab14774c59f", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e626375d8d2226a203bf6ea6e98dab14774c59f", "html_url": "https://github.com/rust-lang/rust/commit/3e626375d8d2226a203bf6ea6e98dab14774c59f"}], "stats": {"total": 1338, "additions": 851, "deletions": 487}, "files": [{"sha": "2f0fbfadb17f3c0b9a3243156e8958b216db43c3", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -243,7 +243,8 @@ impl<T> RingBuf<T> {\n     /// buf.push(5i);\n     /// buf.push(3);\n     /// buf.push(4);\n-    /// assert_eq!(buf.iter().collect::<Vec<&int>>().as_slice(), &[&5, &3, &4]);\n+    /// let b: &[_] = &[&5, &3, &4];\n+    /// assert_eq!(buf.iter().collect::<Vec<&int>>().as_slice(), b);\n     /// ```\n     pub fn iter<'a>(&'a self) -> Items<'a, T> {\n         Items{index: 0, rindex: self.nelts, lo: self.lo, elts: self.elts.as_slice()}\n@@ -263,7 +264,8 @@ impl<T> RingBuf<T> {\n     /// for num in buf.mut_iter() {\n     ///     *num = *num - 2;\n     /// }\n-    /// assert_eq!(buf.mut_iter().collect::<Vec<&mut int>>().as_slice(), &[&mut 3, &mut 1, &mut 2]);\n+    /// let b: &[_] = &[&mut 3, &mut 1, &mut 2];\n+    /// assert_eq!(buf.mut_iter().collect::<Vec<&mut int>>().as_slice(), b);\n     /// ```\n     pub fn mut_iter<'a>(&'a mut self) -> MutItems<'a, T> {\n         let start_index = raw_index(self.lo, self.elts.len(), 0);"}, {"sha": "3f9a179872e147725f6a9c4687a8197a8d899245", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -1971,7 +1971,7 @@ mod tests {\n         use std::iter::order;\n         // official Unicode test data\n         // from http://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.txt\n-        let test_same = [\n+        let test_same: [(_, &[_]), .. 325] = [\n             (\"\\u0020\\u0020\", &[\"\\u0020\", \"\\u0020\"]), (\"\\u0020\\u0308\\u0020\", &[\"\\u0020\\u0308\",\n             \"\\u0020\"]), (\"\\u0020\\u000D\", &[\"\\u0020\", \"\\u000D\"]), (\"\\u0020\\u0308\\u000D\",\n             &[\"\\u0020\\u0308\", \"\\u000D\"]), (\"\\u0020\\u000A\", &[\"\\u0020\", \"\\u000A\"]),\n@@ -2180,7 +2180,7 @@ mod tests {\n             (\"\\u0646\\u200D\\u0020\", &[\"\\u0646\\u200D\", \"\\u0020\"]),\n         ];\n \n-        let test_diff = [\n+        let test_diff: [(_, &[_], &[_]), .. 23] = [\n             (\"\\u0020\\u0903\", &[\"\\u0020\\u0903\"], &[\"\\u0020\", \"\\u0903\"]), (\"\\u0020\\u0308\\u0903\",\n             &[\"\\u0020\\u0308\\u0903\"], &[\"\\u0020\\u0308\", \"\\u0903\"]), (\"\\u000D\\u0308\\u0903\",\n             &[\"\\u000D\", \"\\u0308\\u0903\"], &[\"\\u000D\", \"\\u0308\", \"\\u0903\"]), (\"\\u000A\\u0308\\u0903\",\n@@ -2229,9 +2229,11 @@ mod tests {\n         // test the indices iterators\n         let s = \"a\u0310e\u0301o\u0308\u0332\\r\\n\";\n         let gr_inds = s.grapheme_indices(true).collect::<Vec<(uint, &str)>>();\n-        assert_eq!(gr_inds.as_slice(), &[(0u, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")]);\n+        let b: &[_] = &[(0u, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")];\n+        assert_eq!(gr_inds.as_slice(), b);\n         let gr_inds = s.grapheme_indices(true).rev().collect::<Vec<(uint, &str)>>();\n-        assert_eq!(gr_inds.as_slice(), &[(11, \"\\r\\n\"), (6, \"o\u0308\u0332\"), (3, \"e\u0301\"), (0u, \"a\u0310\")]);\n+        let b: &[_] = &[(11, \"\\r\\n\"), (6, \"o\u0308\u0332\"), (3, \"e\u0301\"), (0u, \"a\u0310\")];\n+        assert_eq!(gr_inds.as_slice(), b);\n         let mut gr_inds = s.grapheme_indices(true);\n         let e1 = gr_inds.size_hint();\n         assert_eq!(e1, (1, Some(13)));\n@@ -2243,7 +2245,8 @@ mod tests {\n         // make sure the reverse iterator does the right thing with \"\\n\" at beginning of string\n         let s = \"\\n\\r\\n\\r\";\n         let gr = s.graphemes(true).rev().collect::<Vec<&str>>();\n-        assert_eq!(gr.as_slice(), &[\"\\r\", \"\\r\\n\", \"\\n\"]);\n+        let b: &[_] = &[\"\\r\", \"\\r\\n\", \"\\n\"];\n+        assert_eq!(gr.as_slice(), b);\n     }\n \n     #[test]"}, {"sha": "05d91a7504150589d80b4e26bc0f8f58e88b94ff", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -531,7 +531,8 @@ impl String {\n     ///\n     /// ```\n     /// let s = String::from_str(\"hello\");\n-    /// assert_eq!(s.as_bytes(), &[104, 101, 108, 108, 111]);\n+    /// let b: &[_] = &[104, 101, 108, 108, 111];\n+    /// assert_eq!(s.as_bytes(), b);\n     /// ```\n     #[inline]\n     pub fn as_bytes<'a>(&'a self) -> &'a [u8] {\n@@ -552,7 +553,8 @@ impl String {\n     ///     bytes[1] = 51;\n     ///     bytes[4] = 48;\n     /// }\n-    /// assert_eq!(s.as_bytes(), &[104, 51, 108, 108, 48]);\n+    /// let b: &[_] = &[104, 51, 108, 108, 48];\n+    /// assert_eq!(s.as_bytes(), b);\n     /// assert_eq!(s.as_slice(), \"h3ll0\")\n     /// ```\n     #[inline]"}, {"sha": "b90c6daf9ebaec834c67af7459d7ae368af07f94", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -112,12 +112,13 @@ impl Ordering {\n     /// assert_eq!(Greater.reverse(), Less);\n     ///\n     ///\n-    /// let mut data = &mut [2u, 10, 5, 8];\n+    /// let mut data: &mut [_] = &mut [2u, 10, 5, 8];\n     ///\n     /// // sort the array from largest to smallest.\n     /// data.sort_by(|a, b| a.cmp(b).reverse());\n     ///\n-    /// assert_eq!(data, &mut [10u, 8, 5, 2]);\n+    /// let b: &mut [_] = &mut [10u, 8, 5, 2];\n+    /// assert!(data == b);\n     /// ```\n     #[inline]\n     #[experimental]"}, {"sha": "7773e03416e9e61bfda18d4dab35963421c81f00", "filename": "src/libcore/option.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -530,7 +530,10 @@ impl<T> Slice<T> for Option<T> {\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n         match *self {\n             Some(ref x) => slice::ref_slice(x),\n-            None => &[]\n+            None => {\n+                let result: &[_] = &[];\n+                result\n+            }\n         }\n     }\n }"}, {"sha": "5daa693c77400267221036f4dbf2faf0a0029b13", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -58,8 +58,8 @@ pub struct TraitObject {\n }\n #[cfg(not(stage0))]\n pub struct TraitObject {\n-    pub data: *(),\n-    pub vtable: *(),\n+    pub data: *mut (),\n+    pub vtable: *mut (),\n }\n \n /// This trait is meant to map equivalences between raw structs and their"}, {"sha": "475c2e94ec778a47f220e7ac78364eba3cbc4ec4", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -1648,6 +1648,27 @@ impl<'a,T:PartialEq, V: Slice<T>> Equiv<V> for &'a [T] {\n     fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n }\n \n+#[unstable = \"waiting for DST\"]\n+impl<'a,T:PartialEq> PartialEq for &'a mut [T] {\n+    fn eq(&self, other: & &'a mut [T]) -> bool {\n+        self.len() == other.len() &&\n+        order::eq(self.iter(), other.iter())\n+    }\n+    fn ne(&self, other: & &'a mut [T]) -> bool {\n+        self.len() != other.len() ||\n+        order::ne(self.iter(), other.iter())\n+    }\n+}\n+\n+#[unstable = \"waiting for DST\"]\n+impl<'a,T:Eq> Eq for &'a mut [T] {}\n+\n+#[unstable = \"waiting for DST\"]\n+impl<'a,T:PartialEq, V: Slice<T>> Equiv<V> for &'a mut [T] {\n+    #[inline]\n+    fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n+}\n+\n #[unstable = \"waiting for DST\"]\n impl<'a,T:Ord> Ord for &'a [T] {\n     fn cmp(&self, other: & &'a [T]) -> Ordering {"}, {"sha": "99ac7cfed027f744708c0f69a404710170d2a70b", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -368,7 +368,7 @@ fn test_collect() {\n \n #[test]\n fn test_all() {\n-    let v: Box<&[int]> = box &[1i, 2, 3, 4, 5];\n+    let v: Box<[int]> = box [1i, 2, 3, 4, 5];\n     assert!(v.iter().all(|&x| x < 10));\n     assert!(!v.iter().all(|&x| x % 2 == 0));\n     assert!(!v.iter().all(|&x| x > 100));\n@@ -377,7 +377,7 @@ fn test_all() {\n \n #[test]\n fn test_any() {\n-    let v: Box<&[int]> = box &[1i, 2, 3, 4, 5];\n+    let v: Box<[int]> = box [1i, 2, 3, 4, 5];\n     assert!(v.iter().any(|&x| x < 10));\n     assert!(v.iter().any(|&x| x % 2 == 0));\n     assert!(!v.iter().any(|&x| x > 100));"}, {"sha": "b89ea4d373ddc9b1bea52cb56373fb2a4ccc62ff", "filename": "src/libdebug/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibdebug%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibdebug%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibdebug%2Freflect.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -251,7 +251,7 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n     }\n     #[cfg(not(stage0))]\n     fn visit_evec_fixed(&mut self, n: uint, sz: uint, align: uint,\n-                        inner: *TyDesc) -> bool {\n+                        inner: *const TyDesc) -> bool {\n         self.align(align);\n         if ! self.inner.visit_evec_fixed(n, sz, align, inner) {\n             return false;"}, {"sha": "20f96d24a5f5f14939b727db61b0f8962039504c", "filename": "src/libdebug/repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibdebug%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibdebug%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibdebug%2Frepr.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -342,7 +342,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n \n     #[cfg(not(stage0))]\n     fn visit_evec_fixed(&mut self, n: uint, sz: uint, _align: uint,\n-                        inner: *TyDesc) -> bool {\n+                        inner: *const TyDesc) -> bool {\n         let assumed_size = if sz == 0 { n } else { sz };\n         self.get::<()>(|this, b| {\n             this.write_vec_range(b, assumed_size, inner)"}, {"sha": "949dd08eaa343cc098db121f0f9aae587bea5f56", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -302,7 +302,7 @@ extern {}\n /// A wrapper for a nullable pointer. Don't use this except for interacting\n /// with libc. Basically Option, but without the dependence on libstd.\n // If/when libprim happens, this can be removed in favor of that\n-pub enum Nullable<type T> {\n+pub enum Nullable<T> {\n     Null,\n     NotNull(T)\n }"}, {"sha": "443bf4d34ffa159918db047a6c07bca7fb54a980", "filename": "src/librbml/io.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrbml%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrbml%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fio.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -96,7 +96,8 @@ impl Writer for SeekableMemWriter {\n             let (left, right) = if cap <= buf.len() {\n                 (buf.slice_to(cap), buf.slice_from(cap))\n             } else {\n-                (buf, &[])\n+                let result: (_, &[_]) = (buf, &[]);\n+                result\n             };\n \n             // Do the necessary writes\n@@ -142,24 +143,29 @@ mod tests {\n         writer.write([1, 2, 3]).unwrap();\n         writer.write([4, 5, 6, 7]).unwrap();\n         assert_eq!(writer.tell(), Ok(8));\n-        assert_eq!(writer.get_ref(), &[0, 1, 2, 3, 4, 5, 6, 7]);\n+        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n+        assert_eq!(writer.get_ref(), b);\n \n         writer.seek(0, io::SeekSet).unwrap();\n         assert_eq!(writer.tell(), Ok(0));\n         writer.write([3, 4]).unwrap();\n-        assert_eq!(writer.get_ref(), &[3, 4, 2, 3, 4, 5, 6, 7]);\n+        let b: &[_] = &[3, 4, 2, 3, 4, 5, 6, 7];\n+        assert_eq!(writer.get_ref(), b);\n \n         writer.seek(1, io::SeekCur).unwrap();\n         writer.write([0, 1]).unwrap();\n-        assert_eq!(writer.get_ref(), &[3, 4, 2, 0, 1, 5, 6, 7]);\n+        let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 7];\n+        assert_eq!(writer.get_ref(), b);\n \n         writer.seek(-1, io::SeekEnd).unwrap();\n         writer.write([1, 2]).unwrap();\n-        assert_eq!(writer.get_ref(), &[3, 4, 2, 0, 1, 5, 6, 1, 2]);\n+        let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 1, 2];\n+        assert_eq!(writer.get_ref(), b);\n \n         writer.seek(1, io::SeekEnd).unwrap();\n         writer.write([1]).unwrap();\n-        assert_eq!(writer.get_ref(), &[3, 4, 2, 0, 1, 5, 6, 1, 2, 0, 1]);\n+        let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 1, 2, 0, 1];\n+        assert_eq!(writer.get_ref(), b);\n     }\n \n     #[test]"}, {"sha": "739ec2cf43ffe9564ecfcdf12d40ef0de2270062", "filename": "src/librlibc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrlibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrlibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrlibc%2Flib.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -49,7 +49,7 @@\n // implementations below. If pointer arithmetic is done through integers the\n // optimizations start to break down.\n extern \"rust-intrinsic\" {\n-    fn offset<type T>(dst: *const T, offset: int) -> *const T;\n+    fn offset<T>(dst: *const T, offset: int) -> *const T;\n }\n \n #[no_mangle]"}, {"sha": "77e73c46c402cf2f6ac23962b2dc4d80124759be", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -34,7 +34,6 @@ register_diagnostics!(\n     E0015,\n     E0016,\n     E0017,\n-    E0018,\n     E0019,\n     E0020,\n     E0021,\n@@ -53,7 +52,6 @@ register_diagnostics!(\n     E0034,\n     E0035,\n     E0036,\n-    E0037,\n     E0038,\n     E0039,\n     E0040,\n@@ -80,8 +78,6 @@ register_diagnostics!(\n     E0061,\n     E0062,\n     E0063,\n-    E0064,\n-    E0065,\n     E0066,\n     E0067,\n     E0068,\n@@ -127,8 +123,6 @@ register_diagnostics!(\n     E0108,\n     E0109,\n     E0110,\n-    E0111,\n-    E0112,\n     E0113,\n     E0114,\n     E0115,"}, {"sha": "5f26a966f97e7e556258ff929e904ec63d567b24", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -477,10 +477,10 @@ fn mk_test_descs(cx: &TestCtxt) -> Gc<ast::Expr> {\n \n     box(GC) ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n-        node: ast::ExprAddrOf(box(GC) ast::MutImmutable,\n+        node: ast::ExprAddrOf(ast::MutImmutable,\n             box(GC) ast::Expr {\n                 id: ast::DUMMY_NODE_ID,\n-                node: ast::ExprVec(cx.testfns.borrow().iter().map(|test| {\n+                node: ast::ExprVec(cx.testfns.iter().map(|test| {\n                     mk_test_desc_and_fn_rec(cx, test)\n             }).collect()),\n             span: DUMMY_SP,"}, {"sha": "214401b17a1bb52956d747f68183054b9dcfa245", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -1556,6 +1556,9 @@ declare_lint!(pub UNKNOWN_CRATE_TYPE, Deny,\n declare_lint!(pub VARIANT_SIZE_DIFFERENCE, Allow,\n               \"detects enums with widely varying variant sizes\")\n \n+declare_lint!(pub TRANSMUTE_FAT_PTR, Allow,\n+              \"detects transmutes of fat pointers\")\n+\n /// Does nothing as a lint pass, but registers some `Lint`s\n /// which are used by other parts of the compiler.\n pub struct HardwiredLints;"}, {"sha": "6a8ee2675425f37edd7c39dd7777f918b948c5f9", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -1029,6 +1029,8 @@ impl<'a> rbml_writer_helpers for Encoder<'a> {\n     }\n \n     fn emit_autoref(&mut self, ecx: &e::EncodeContext, autoref: &ty::AutoRef) {\n+        use serialize::Encoder;\n+\n         self.emit_enum(\"AutoRef\", |this| {\n             match autoref {\n                 &ty::AutoPtr(r, m, None) => {\n@@ -1067,6 +1069,8 @@ impl<'a> rbml_writer_helpers for Encoder<'a> {\n     }\n \n     fn emit_auto_deref_ref(&mut self, ecx: &e::EncodeContext, auto_deref_ref: &ty::AutoDerefRef) {\n+        use serialize::Encoder;\n+\n         self.emit_struct(\"AutoDerefRef\", 2, |this| {\n             this.emit_struct_field(\"autoderefs\", 0, |this| auto_deref_ref.autoderefs.encode(this));\n             this.emit_struct_field(\"autoref\", 1, |this| {\n@@ -1081,6 +1085,8 @@ impl<'a> rbml_writer_helpers for Encoder<'a> {\n     }\n \n     fn emit_unsize_kind(&mut self, ecx: &e::EncodeContext, uk: &ty::UnsizeKind) {\n+        use serialize::Encoder;\n+\n         self.emit_enum(\"UnsizeKind\", |this| {\n             match *uk {\n                 ty::UnsizeLength(len) => {\n@@ -1286,7 +1292,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n             _ if ty::adjust_is_object(adjustment) => {\n                 let method_call = MethodCall::autoobject(id);\n                 for &method in tcx.method_map.borrow().find(&method_call).iter() {\n-                    rbml_w.tag(c::tag_table_method_map, |ebml_w| {\n+                    rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n                         rbml_w.id(id);\n                         rbml_w.tag(c::tag_table_val, |rbml_w| {\n                             encode_method_callee(ecx, rbml_w, method_call.adjustment, method)\n@@ -1297,7 +1303,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                 for &dr in tcx.vtable_map.borrow().find(&method_call).iter() {\n                     rbml_w.tag(c::tag_table_vtable_map, |rbml_w| {\n                         rbml_w.id(id);\n-                        rbml_w.tag(c::tag_table_val, |ebml_w| {\n+                        rbml_w.tag(c::tag_table_val, |rbml_w| {\n                             encode_vtable_res_with_key(ecx, rbml_w, method_call.adjustment, dr);\n                         })\n                     })\n@@ -1336,7 +1342,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         rbml_w.tag(c::tag_table_adjustments, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                rbml_w.emit_auto_adjustment(ecx, adj);\n+                rbml_w.emit_auto_adjustment(ecx, adjustment);\n             })\n         })\n     }"}, {"sha": "629aba8092c27b45ad795b2c7f52084c62fee73b", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -182,7 +182,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr, is_const: bool) {\n                     // Mutable slices are allowed.\n                     ExprVec(_) => {}\n                     _ => span_err!(v.tcx.sess, e.span, E0017,\n-                                   \"references in constants may only refer to immutable values\");\n+                                   \"references in constants may only refer to immutable values\")\n \n                 }\n           },"}, {"sha": "639f89dc3cceddbfef8d0551915dabf9e3a63cb3", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -92,7 +92,7 @@ impl<'a> IntrinsicCheckingVisitor<'a> {\n         }\n     }\n \n-    fn check_transmute(&self, span: Span, from: ty::t, to: ty::t) {\n+    fn check_transmute(&self, span: Span, from: ty::t, to: ty::t, id: ast::NodeId) {\n         if type_size_is_affected_by_type_parameters(self.tcx, from) {\n             span_err!(self.tcx.sess, span, E0139,\n                       \"cannot transmute from a type that contains type parameters\");\n@@ -106,6 +106,7 @@ impl<'a> IntrinsicCheckingVisitor<'a> {\n             span: span,\n             from: from,\n             to: to,\n+            id: id,\n         };\n         self.tcx.transmute_restrictions.borrow_mut().push(restriction);\n     }\n@@ -123,7 +124,7 @@ impl<'a> Visitor<()> for IntrinsicCheckingVisitor<'a> {\n                                     if bare_fn_ty.abi == RustIntrinsic => {\n                                 let from = *bare_fn_ty.sig.inputs.get(0);\n                                 let to = bare_fn_ty.sig.output;\n-                                self.check_transmute(expr.span, from, to);\n+                                self.check_transmute(expr.span, from, to, expr.id);\n                             }\n                             _ => {\n                                 self.tcx"}, {"sha": "2d052feb6720f03974dca1234145901767315217", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -214,7 +214,7 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n }\n \n pub fn deref_kind(tcx: &ty::ctxt, t: ty::t) -> deref_kind {\n-    debug!(\"deref_kind {}\", ty_to_str(tcx, t));\n+    debug!(\"deref_kind {}\", ty_to_string(tcx, t));\n     match opt_deref_kind(t) {\n       Some(k) => k,\n       None => {"}, {"sha": "ccc4dbb21e019df9609baa663d45e5c5a4f308b7", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -403,7 +403,7 @@ impl<T> VecPerParamSpace<T> {\n         self.content.slice(start, limit)\n     }\n \n-    fn get_mut_slice<'a>(&'a mut self, space: ParamSpace) -> &'a mut [T] {\n+    pub fn get_mut_slice<'a>(&'a mut self, space: ParamSpace) -> &'a mut [T] {\n         let (start, limit) = self.limits(space);\n         self.content.mut_slice(start, limit)\n     }"}, {"sha": "28f396c8bf795821c6d1bbc05b90be058826621e", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -280,7 +280,7 @@ fn trans_opt<'a>(mut bcx: &'a Block<'a>, o: &Opt) -> opt_result<'a> {\n     match *o {\n         lit(lit_expr) => {\n             let lit_ty = ty::node_id_to_type(bcx.tcx(), lit_expr.id);\n-            let (llval, _) = consts::const_expr(ccx, &*lit_expr, true);\n+            let (llval, _, _) = consts::const_expr(ccx, &*lit_expr, true);\n             let lit_datum = immediate_rvalue(llval, lit_ty);\n             let lit_datum = unpack_datum!(bcx, lit_datum.to_appropriate_datum(bcx));\n             return single_result(Result::new(bcx, lit_datum.val));"}, {"sha": "f3f4a88fdee4fa9c32106499091758c91a3d42f1", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 45, "deletions": 31, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -127,11 +127,11 @@ pub enum Repr {\n \n /// For structs, and struct-like parts of anything fancier.\n pub struct Struct {\n-    // If the struct is DST, then we will not know its size. We must be careful\n-    // never to use such a struct when a fixed size is required (e.g., stack\n-    // allocation).\n-    pub size: Option<u64>,\n-    pub align: Option<u64>,\n+    // If the struct is DST, then the size and alignment do not take into\n+    // account the unsized fields of the struct.\n+    pub size: u64,\n+    pub align: u64,\n+    pub sized: bool,\n     pub packed: bool,\n     pub fields: Vec<ty::t>\n }\n@@ -269,7 +269,7 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n             }).collect(), dtor);\n         }\n         _ => cx.sess().bug(format!(\"adt::represent_type called on non-ADT type: {}\",\n-                           ty_to_str(cx.tcx(), t)).as_slice())\n+                           ty_to_string(cx.tcx(), t)).as_slice())\n     }\n }\n \n@@ -288,7 +288,7 @@ pub enum PointerField {\n \n impl Case {\n     fn is_zerolen(&self, cx: &CrateContext) -> bool {\n-        mk_struct(cx, self.tys.as_slice(), false).size.unwrap() == 0\n+        mk_struct(cx, self.tys.as_slice(), false).size == 0\n     }\n \n     fn find_ptr(&self) -> Option<PointerField> {\n@@ -310,7 +310,7 @@ impl Case {\n \n                 // Box<T> could either be a thin or fat pointer depending on T\n                 ty::ty_uniq(t) => match ty::get(t).sty {\n-                    ty::ty_vec(_, None) | return Some(FatPointer(i, slice_elt_base)),\n+                    ty::ty_vec(_, None) => return Some(FatPointer(i, slice_elt_base)),\n \n                     // Box<Trait> is a pair of pointers: the actual object and a vtable\n                     ty::ty_trait(..) => return Some(FatPointer(i, trt_field_box)),\n@@ -351,18 +351,24 @@ fn mk_struct(cx: &CrateContext, tys: &[ty::t], packed: bool) -> Struct {\n         let lltys = tys.iter().map(|&ty| type_of::sizing_type_of(cx, ty)).collect::<Vec<_>>();\n         let llty_rec = Type::struct_(cx, lltys.as_slice(), packed);\n         Struct {\n-            size: Some(machine::llsize_of_alloc(cx, llty_rec) /*bad*/as u64),\n-            align: Some(machine::llalign_of_min(cx, llty_rec) /*bad*/as u64),\n+            size: machine::llsize_of_alloc(cx, llty_rec),\n+            align: machine::llalign_of_min(cx, llty_rec),\n+            sized: true,\n             packed: packed,\n             fields: Vec::from_slice(tys),\n         }\n     } else {\n+        // Ignore any dynamically sized fields.\n+        let lltys = tys.iter().filter(|&ty| ty::type_is_sized(cx.tcx(), *ty))\n+            .map(|&ty| type_of::sizing_type_of(cx, ty)).collect::<Vec<_>>();\n+        let llty_rec = Type::struct_(cx, lltys.as_slice(), packed);\n         Struct {\n-            size: None,\n-            align: None,\n+            size: machine::llsize_of_alloc(cx, llty_rec),\n+            align: machine::llalign_of_min(cx, llty_rec),\n+            sized: false,\n             packed: packed,\n             fields: Vec::from_slice(tys),\n-        }        \n+        }\n     }\n }\n \n@@ -467,31 +473,38 @@ pub fn ty_of_inttype(ity: IntType) -> ty::t {\n  * unbounded recursion; see also the comments in `trans::type_of`.\n  */\n pub fn type_of(cx: &CrateContext, r: &Repr) -> Type {\n-    generic_type_of(cx, r, None, false)\n+    generic_type_of(cx, r, None, false, false)\n }\n-pub fn sizing_type_of(cx: &CrateContext, r: &Repr) -> Type {\n-    generic_type_of(cx, r, None, true)\n+// Pass dst=true if the type you are passing is a DST. Yes, we could figure\n+// this out, but if you call this on an unsized type without realising it, you\n+// are going to get the wrong type (it will not include the unsized parts of it).\n+pub fn sizing_type_of(cx: &CrateContext, r: &Repr, dst: bool) -> Type {\n+    generic_type_of(cx, r, None, true, dst)\n }\n pub fn incomplete_type_of(cx: &CrateContext, r: &Repr, name: &str) -> Type {\n-    generic_type_of(cx, r, Some(name), false)\n+    generic_type_of(cx, r, Some(name), false, false)\n }\n pub fn finish_type_of(cx: &CrateContext, r: &Repr, llty: &mut Type) {\n     match *r {\n         CEnum(..) | General(..) | RawNullablePointer { .. } => { }\n         Univariant(ref st, _) | StructWrappedNullablePointer { nonnull: ref st, .. } =>\n-            llty.set_struct_body(struct_llfields(cx, st, false).as_slice(),\n+            llty.set_struct_body(struct_llfields(cx, st, false, false).as_slice(),\n                                  st.packed)\n     }\n }\n \n-fn generic_type_of(cx: &CrateContext, r: &Repr, name: Option<&str>, sizing: bool) -> Type {\n+fn generic_type_of(cx: &CrateContext,\n+                   r: &Repr,\n+                   name: Option<&str>,\n+                   sizing: bool,\n+                   dst: bool) -> Type {\n     match *r {\n         CEnum(ity, _, _) => ll_inttype(cx, ity),\n         RawNullablePointer { nnty, .. } => type_of::sizing_type_of(cx, nnty),\n         Univariant(ref st, _) | StructWrappedNullablePointer { nonnull: ref st, .. } => {\n             match name {\n                 None => {\n-                    Type::struct_(cx, struct_llfields(cx, st, sizing).as_slice(),\n+                    Type::struct_(cx, struct_llfields(cx, st, sizing, dst).as_slice(),\n                                   st.packed)\n                 }\n                 Some(name) => { assert_eq!(sizing, false); Type::named_struct(cx, name) }\n@@ -510,9 +523,9 @@ fn generic_type_of(cx: &CrateContext, r: &Repr, name: Option<&str>, sizing: bool\n             // of the size.\n             //\n             // FIXME #10604: this breaks when vector types are present.\n-            let size = sts.iter().map(|st| st.size.unwrap()).max().unwrap();\n-            let most_aligned = sts.iter().max_by(|st| st.align.unwrap()).unwrap();\n-            let align = most_aligned.align.unwrap();\n+            let size = sts.iter().map(|st| st.size).max().unwrap();\n+            let most_aligned = sts.iter().max_by(|st| st.align).unwrap();\n+            let align = most_aligned.align;\n             let discr_ty = ll_inttype(cx, ity);\n             let discr_size = machine::llsize_of_alloc(cx, discr_ty) as u64;\n             let align_units = (size + align - 1) / align - 1;\n@@ -543,9 +556,10 @@ fn generic_type_of(cx: &CrateContext, r: &Repr, name: Option<&str>, sizing: bool\n     }\n }\n \n-fn struct_llfields(cx: &CrateContext, st: &Struct, sizing: bool) -> Vec<Type> {\n+fn struct_llfields(cx: &CrateContext, st: &Struct, sizing: bool, dst: bool) -> Vec<Type> {\n     if sizing {\n-        st.fields.iter().map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n+        st.fields.iter().filter(|&ty| !dst || ty::type_is_sized(cx.tcx(), *ty))\n+            .map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n     } else {\n         st.fields.iter().map(|&ty| type_of::type_of(cx, ty)).collect()\n     }\n@@ -906,12 +920,12 @@ pub fn trans_const(ccx: &CrateContext, r: &Repr, discr: Disr,\n         }\n         General(ity, ref cases, _) => {\n             let case = cases.get(discr as uint);\n-            let max_sz = cases.iter().map(|x| x.size.unwrap()).max().unwrap();\n+            let max_sz = cases.iter().map(|x| x.size).max().unwrap();\n             let lldiscr = C_integral(ll_inttype(ccx, ity), discr as u64, true);\n             let contents = build_const_struct(ccx,\n                                               case,\n                                               (vec!(lldiscr)).append(vals).as_slice());\n-            C_struct(ccx, contents.append([padding(ccx, max_sz - case.size.unwrap())]).as_slice(),\n+            C_struct(ccx, contents.append([padding(ccx, max_sz - case.size)]).as_slice(),\n                      false)\n         }\n         Univariant(ref st, _dro) => {\n@@ -958,7 +972,7 @@ fn compute_struct_field_offsets(ccx: &CrateContext, st: &Struct) -> Vec<u64> {\n     for &ty in st.fields.iter() {\n         let llty = type_of::sizing_type_of(ccx, ty);\n         if !st.packed {\n-            let type_align = machine::llalign_of_min(ccx, llty) as u64;\n+            let type_align = type_of::align_of(ccx, ty) as u64;\n             offset = roundup(offset, type_align);\n         }\n         offsets.push(offset);\n@@ -1002,9 +1016,9 @@ fn build_const_struct(ccx: &CrateContext, st: &Struct, vals: &[ValueRef])\n         offset += machine::llsize_of_alloc(ccx, val_ty(val)) as u64;\n     }\n \n-    assert!(offset <= st.size.unwrap());\n-    if offset != st.size.unwrap() {\n-        cfields.push(padding(ccx, st.size.unwrap() - offset));\n+    assert!(st.sized && offset <= st.size);\n+    if offset != st.size {\n+        cfields.push(padding(ccx, st.size - offset));\n     }\n \n     cfields"}, {"sha": "8968c8cc2599f5d443b7af554c50bc964d693b4a", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 41, "deletions": 20, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -65,7 +65,7 @@ use middle::trans::glue;\n use middle::trans::inline;\n use middle::trans::intrinsic;\n use middle::trans::machine;\n-use middle::trans::machine::{llalign_of_min, llsize_of, llsize_of_real};\n+use middle::trans::machine::{llsize_of, llsize_of_real};\n use middle::trans::meth;\n use middle::trans::monomorphize;\n use middle::trans::tvec;\n@@ -394,7 +394,7 @@ pub fn malloc_raw_dyn_managed<'a>(\n     // Grab the TypeRef type of box_ptr_ty.\n     let box_ptr_ty = ty::mk_box(bcx.tcx(), t);\n     let llty = type_of(ccx, box_ptr_ty);\n-    let llalign = C_uint(ccx, llalign_of_min(ccx, llty) as uint);\n+    let llalign = C_uint(ccx, type_of::align_of(ccx, box_ptr_ty) as uint);\n \n     // Allocate space:\n     let drop_glue = glue::get_drop_glue(ccx, t);\n@@ -710,34 +710,53 @@ pub fn iter_structural_ty<'r,\n         return cx;\n     }\n \n+    let (data_ptr, info) = if ty::type_is_sized(cx.tcx(), t) {\n+        (av, None)\n+    } else {\n+        let data = GEPi(cx, av, [0, abi::slice_elt_base]);\n+        let info = GEPi(cx, av, [0, abi::slice_elt_len]);\n+        (Load(cx, data), Some(Load(cx, info)))\n+    };\n+\n     let mut cx = cx;\n     match ty::get(t).sty {\n       ty::ty_struct(..) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n           expr::with_field_tys(cx.tcx(), t, None, |discr, field_tys| {\n               for (i, field_ty) in field_tys.iter().enumerate() {\n-                  let llfld_a = adt::trans_field_ptr(cx, &*repr, av, discr, i);\n-                  cx = f(cx, llfld_a, field_ty.mt.ty);\n+                  let field_ty = field_ty.mt.ty;\n+                  let llfld_a = adt::trans_field_ptr(cx, &*repr, data_ptr, discr, i);\n+\n+                  let val = if ty::type_is_sized(cx.tcx(), field_ty) {\n+                      llfld_a\n+                  } else {\n+                      let boxed_ty = ty::mk_open(cx.tcx(), field_ty);\n+                      let scratch = datum::rvalue_scratch_datum(cx, boxed_ty, \"__fat_ptr_iter\");\n+                      Store(cx, llfld_a, GEPi(cx, scratch.val, [0, abi::slice_elt_base]));\n+                      Store(cx, info.unwrap(), GEPi(cx, scratch.val, [0, abi::slice_elt_len]));\n+                      scratch.val\n+                  };\n+                  cx = f(cx, val, field_ty);\n               }\n           })\n       }\n       ty::ty_unboxed_closure(def_id, _) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n           let upvars = ty::unboxed_closure_upvars(cx.tcx(), def_id);\n           for (i, upvar) in upvars.iter().enumerate() {\n-              let llupvar = adt::trans_field_ptr(cx, &*repr, av, 0, i);\n+              let llupvar = adt::trans_field_ptr(cx, &*repr, data_ptr, 0, i);\n               cx = f(cx, llupvar, upvar.ty);\n           }\n       }\n       ty::ty_vec(_, Some(n)) => {\n-        let (base, len) = tvec::get_fixed_base_and_len(cx, av, n);\n+        let (base, len) = tvec::get_fixed_base_and_len(cx, data_ptr, n);\n         let unit_ty = ty::sequence_element_type(cx.tcx(), t);\n         cx = tvec::iter_vec_raw(cx, base, unit_ty, len, f);\n       }\n       ty::ty_tup(ref args) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n           for (i, arg) in args.iter().enumerate() {\n-              let llfld_a = adt::trans_field_ptr(cx, &*repr, av, 0, i);\n+              let llfld_a = adt::trans_field_ptr(cx, &*repr, data_ptr, 0, i);\n               cx = f(cx, llfld_a, *arg);\n           }\n       }\n@@ -781,7 +800,7 @@ pub fn iter_structural_ty<'r,\n                       let variant_cx =\n                           iter_variant(variant_cx,\n                                        &*repr,\n-                                       av,\n+                                       data_ptr,\n                                        &**variant,\n                                        substs,\n                                        |x,y,z| f(x,y,z));\n@@ -968,7 +987,7 @@ pub fn invoke<'a>(\n     // FIXME(15064) Lang item methods may (in the reflect case) not have proper\n     // types, so doing an attribute lookup will fail.\n     let attributes = if is_lang_item {\n-        Vec::new()\n+        llvm::AttrBuilder::new()\n     } else {\n         get_fn_llvm_attributes(bcx.ccx(), fn_ty)\n     };\n@@ -1158,7 +1177,7 @@ pub fn memcpy_ty(bcx: &Block, dst: ValueRef, src: ValueRef, t: ty::t) {\n     if ty::type_is_structural(t) {\n         let llty = type_of::type_of(ccx, t);\n         let llsz = llsize_of(ccx, llty);\n-        let llalign = llalign_of_min(ccx, llty);\n+        let llalign = type_of::align_of(ccx, t);\n         call_memcpy(bcx, dst, src, llsz, llalign as u32);\n     } else {\n         store_ty(bcx, Load(bcx, src), dst, t);\n@@ -1169,20 +1188,20 @@ pub fn zero_mem(cx: &Block, llptr: ValueRef, t: ty::t) {\n     if cx.unreachable.get() { return; }\n     let _icx = push_ctxt(\"zero_mem\");\n     let bcx = cx;\n-    let ccx = cx.ccx();\n-    let llty = type_of::type_of(ccx, t);\n-    memzero(&B(bcx), llptr, llty);\n+    memzero(&B(bcx), llptr, t);\n }\n \n // Always use this function instead of storing a zero constant to the memory\n // in question. If you store a zero constant, LLVM will drown in vreg\n // allocation for large data structures, and the generated code will be\n // awful. (A telltale sign of this is large quantities of\n // `mov [byte ptr foo],0` in the generated code.)\n-fn memzero(b: &Builder, llptr: ValueRef, ty: Type) {\n+fn memzero(b: &Builder, llptr: ValueRef, ty: ty::t) {\n     let _icx = push_ctxt(\"memzero\");\n     let ccx = b.ccx;\n \n+    let llty = type_of::type_of(ccx, ty);\n+\n     let intrinsic_key = match ccx.sess().targ_cfg.arch {\n         X86 | Arm | Mips | Mipsel => \"llvm.memset.p0i8.i32\",\n         X86_64 => \"llvm.memset.p0i8.i64\"\n@@ -1191,8 +1210,8 @@ fn memzero(b: &Builder, llptr: ValueRef, ty: Type) {\n     let llintrinsicfn = ccx.get_intrinsic(&intrinsic_key);\n     let llptr = b.pointercast(llptr, Type::i8(ccx).ptr_to());\n     let llzeroval = C_u8(ccx, 0);\n-    let size = machine::llsize_of(ccx, ty);\n-    let align = C_i32(ccx, llalign_of_min(ccx, ty) as i32);\n+    let size = machine::llsize_of(ccx, llty);\n+    let align = C_i32(ccx, type_of::align_of(ccx, ty) as i32);\n     let volatile = C_bool(ccx, false);\n     b.call(llintrinsicfn, [llptr, llzeroval, size, align, volatile], None);\n }\n@@ -1223,13 +1242,14 @@ pub fn alloca_no_lifetime(cx: &Block, ty: Type, name: &str) -> ValueRef {\n     Alloca(cx, ty, name)\n }\n \n-pub fn alloca_zeroed(cx: &Block, ty: Type, name: &str) -> ValueRef {\n+pub fn alloca_zeroed(cx: &Block, ty: ty::t, name: &str) -> ValueRef {\n+    let llty = type_of::type_of(cx.ccx(), ty);\n     if cx.unreachable.get() {\n         unsafe {\n-            return llvm::LLVMGetUndef(ty.ptr_to().to_ref());\n+            return llvm::LLVMGetUndef(llty.ptr_to().to_ref());\n         }\n     }\n-    let p = alloca_no_lifetime(cx, ty, name);\n+    let p = alloca_no_lifetime(cx, llty, name);\n     let b = cx.fcx.ccx.builder();\n     b.position_before(cx.fcx.alloca_insert_pt.get().unwrap());\n     memzero(&b, p, ty);\n@@ -1648,7 +1668,8 @@ fn copy_unboxed_closure_args_to_allocas<'a>(\n     for j in range(0, args.len()) {\n         let tuple_element_type = untupled_arg_types[j];\n         let tuple_element_datum =\n-            tuple_datum.get_element(tuple_element_type,\n+            tuple_datum.get_element(bcx,\n+                                    tuple_element_type,\n                                     |llval| GEPi(bcx, llval, [0, j]));\n         let tuple_element_datum = tuple_element_datum.to_expr_datum();\n         let tuple_element_datum ="}, {"sha": "7566cfbac56c4a6268187649e354150d446f1c9a", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -970,6 +970,7 @@ fn trans_args_under_call_abi<'a>(\n             let repr_ptr = &*repr;\n             for i in range(0, field_types.len()) {\n                 let arg_datum = tuple_lvalue_datum.get_element(\n+                    bcx,\n                     *field_types.get(i),\n                     |srcval| {\n                         adt::trans_field_ptr(bcx, repr_ptr, srcval, 0, i)"}, {"sha": "05528d2b3d88e60876ff07de8f1d48cbe06e05bc", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -74,6 +74,9 @@ pub fn type_is_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n     if simple && !ty::type_is_fat_ptr(tcx, ty) {\n         return true;\n     }\n+    if !ty::type_is_sized(tcx, ty) {\n+        return false;\n+    }\n     match ty::get(ty).sty {\n         ty::ty_bot => true,\n         ty::ty_struct(..) | ty::ty_enum(..) | ty::ty_tup(..) |"}, {"sha": "b3798c9f84dd41ab6d2625f1b0864302e95b33dc", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -116,7 +116,7 @@ fn const_vec(cx: &CrateContext, e: &ast::Expr,\n     (v, llunitty, inlineable.iter().fold(true, |a, &b| a && b))\n }\n \n-pub fn const_addr_of(cx: &CrateContext, cv: ValueRef) -> ValueRef {\n+pub fn const_addr_of(cx: &CrateContext, cv: ValueRef, mutbl: ast::Mutability) -> ValueRef {\n     unsafe {\n         let gv = \"const\".with_c_str(|name| {\n             llvm::LLVMAddGlobal(cx.llmod, val_ty(cv).to_ref(), name)\n@@ -279,7 +279,7 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n                                         }\n                                         _ => cx.sess().span_bug(e.span,\n                                             format!(\"unimplemented type in const unsize: {}\",\n-                                                    ty_to_str(cx.tcx(), ty)).as_slice())\n+                                                    ty_to_string(cx.tcx(), ty)).as_slice())\n                                     }\n                                 }\n                                 _ => {\n@@ -455,7 +455,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                       _ => cx.sess().span_bug(base.span,\n                                               format!(\"index-expr base must be a vector \\\n                                                        or string type, found {}\",\n-                                                      ty_to_str(cx.tcx(), bt)).as_slice())\n+                                                      ty_to_string(cx.tcx(), bt)).as_slice())\n                   },\n                   ty::ty_rptr(_, mt) => match ty::get(mt.ty).sty {\n                       ty::ty_vec(_, Some(u)) => {\n@@ -464,12 +464,12 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                       _ => cx.sess().span_bug(base.span,\n                                               format!(\"index-expr base must be a vector \\\n                                                        or string type, found {}\",\n-                                                      ty_to_str(cx.tcx(), bt)).as_slice())\n+                                                      ty_to_string(cx.tcx(), bt)).as_slice())\n                   },\n                   _ => cx.sess().span_bug(base.span,\n                                           format!(\"index-expr base must be a vector \\\n                                                    or string type, found {}\",\n-                                                  ty_to_str(cx.tcx(), bt)).as_slice())\n+                                                  ty_to_string(cx.tcx(), bt)).as_slice())\n               };\n \n               let len = llvm::LLVMConstIntGetZExtValue(len) as u64;"}, {"sha": "9ec52341348170f3a6e5cc5f07c3744444bea46e", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -497,7 +497,7 @@ pub fn trans_fail<'a>(\n     let filename = C_str_slice(ccx, filename);\n     let line = C_int(ccx, loc.line as int);\n     let expr_file_line_const = C_struct(ccx, &[v_str, filename, line], false);\n-    let expr_file_line = consts::const_addr_of(ccx, expr_file_line_const);\n+    let expr_file_line = consts::const_addr_of(ccx, expr_file_line_const, ast::MutImmutable);\n     let args = vec!(expr_file_line);\n     let did = langcall(bcx, Some(sp), \"\", FailFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,\n@@ -525,7 +525,7 @@ pub fn trans_fail_bounds_check<'a>(\n     let filename = C_str_slice(ccx,  filename);\n     let line = C_int(ccx, loc.line as int);\n     let file_line_const = C_struct(ccx, &[filename, line], false);\n-    let file_line = consts::const_addr_of(ccx, file_line_const);\n+    let file_line = consts::const_addr_of(ccx, file_line_const, ast::MutImmutable);\n     let args = vec!(file_line, index, len);\n     let did = langcall(bcx, Some(sp), \"\", FailBoundsCheckFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,"}, {"sha": "2882eaf10be2f0977f6ceb45cdc6ccf4186dec0e", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -15,6 +15,7 @@\n \n use llvm::ValueRef;\n use middle::trans::base::*;\n+use middle::trans::build::Load;\n use middle::trans::common::*;\n use middle::trans::cleanup;\n use middle::trans::cleanup::CleanupMethods;\n@@ -119,10 +120,10 @@ pub fn lvalue_scratch_datum<'a, A>(bcx: &'a Block<'a>,\n      * does not dominate the end of `scope`.\n      */\n \n-    let llty = type_of::type_of(bcx.ccx(), ty);\n     let scratch = if zero {\n-        alloca_zeroed(bcx, llty, name)\n+        alloca_zeroed(bcx, ty, name)\n     } else {\n+        let llty = type_of::type_of(bcx.ccx(), ty);\n         alloca(bcx, llty, name)\n     };\n \n@@ -524,7 +525,7 @@ impl Datum<Lvalue> {\n             }\n             _ => bcx.tcx().sess.bug(\n                 format!(\"Unexpected unsized type in get_element: {}\",\n-                        bcx.ty_to_str(self.ty)).as_slice())\n+                        bcx.ty_to_string(self.ty)).as_slice())\n         };\n         Datum {\n             val: val,"}, {"sha": "566f71220b05f50613d7bcc77dd931fd2501dbb7", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -56,10 +56,11 @@ This file consists of three conceptual sections:\n ## Recursive Types\n \n Some kinds of types, such as structs and enums can be recursive. That means that\n-the type definition of some type X refers to some other type which in turn (transitively)\n-refers to X. This introduces cycles into the type referral graph. A naive algorithm doing\n-an on-demand, depth-first traversal of this graph when describing types, can get trapped\n-in an endless loop when it reaches such a cycle.\n+the type definition of some type X refers to some other type which in turn\n+(transitively) refers to X. This introduces cycles into the type referral graph.\n+A naive algorithm doing an on-demand, depth-first traversal of this graph when\n+describing types, can get trapped in an endless loop when it reaches such a\n+cycle.\n \n For example, the following simple type for a singly-linked list...\n \n@@ -2798,34 +2799,42 @@ fn subroutine_type_metadata(cx: &CrateContext,\n         false);\n }\n \n+// FIXME(1563) This is all a bit of a hack because 'trait pointer' is an ill-\n+// defined concept. For the case of an actual trait pointer (i.e., Box<Trait>,\n+// &Trait), trait_object_type should be the whole thing (e.g, Box<Trait>) and\n+// trait_type should be the actual trait (e.g., Trait). Where the trait is part\n+// of a DST struct, there is no trait_object_type and the results of this\n+// function will be a little bit weird.\n fn trait_pointer_metadata(cx: &CrateContext,\n-                          trait_object_type: ty::t,\n+                          trait_type: ty::t,\n+                          trait_object_type: Option<ty::t>,\n                           unique_type_id: UniqueTypeId)\n                        -> DIType {\n     // The implementation provided here is a stub. It makes sure that the trait\n     // type is assigned the correct name, size, namespace, and source location.\n     // But it does not describe the trait's methods.\n \n-    let def_id = match ty::get(trait_object_type).sty {\n+    let def_id = match ty::get(trait_type).sty {\n         ty::ty_trait(box ty::TyTrait { def_id, .. }) => def_id,\n         _ => {\n-            let pp_type_name = ppaux::ty_to_string(cx.tcx(), trait_object_type);\n+            let pp_type_name = ppaux::ty_to_string(cx.tcx(), trait_type);\n             cx.sess().bug(format!(\"debuginfo: Unexpected trait-object type in \\\n                                    trait_pointer_metadata(): {}\",\n                                    pp_type_name.as_slice()).as_slice());\n         }\n     };\n \n-    let trait_pointer_type_name =\n+    let trait_object_type = trait_object_type.unwrap_or(trait_type);\n+    let trait_type_name =\n         compute_debuginfo_type_name(cx, trait_object_type, false);\n \n     let (containing_scope, _) = get_namespace_and_span_for_item(cx, def_id);\n \n     let trait_llvm_type = type_of::type_of(cx, trait_object_type);\n \n     composite_type_metadata(cx,\n-                            trait_pointer_llvm_type,\n-                            trait_pointer_type_name.as_slice(),\n+                            trait_llvm_type,\n+                            trait_type_name.as_slice(),\n                             unique_type_id,\n                             [],\n                             containing_scope,\n@@ -2897,7 +2906,7 @@ fn type_metadata(cx: &CrateContext,\n         ty::ty_str => fixed_vec_metadata(cx, unique_type_id, ty::mk_i8(), 0, usage_site_span),\n         ty::ty_trait(..) => {\n             MetadataCreationResult::new(\n-                        trait_pointer_metadata(cx, t, unique_type_id),\n+                        trait_pointer_metadata(cx, t, None, unique_type_id),\n             false)\n         }\n         ty::ty_uniq(ty) | ty::ty_ptr(ty::mt{ty, ..}) | ty::ty_rptr(_, ty::mt{ty, ..}) => {\n@@ -2910,7 +2919,7 @@ fn type_metadata(cx: &CrateContext,\n                 }\n                 ty::ty_trait(..) => {\n                     MetadataCreationResult::new(\n-                        trait_pointer_metadata(cx, ty, unique_type_id),\n+                        trait_pointer_metadata(cx, ty, Some(t), unique_type_id),\n                         false)\n                 }\n                 _ => {\n@@ -3698,7 +3707,7 @@ fn push_debuginfo_type_name(cx: &CrateContext,\n \n             push_debuginfo_type_name(cx, inner_type, true, output);\n         },\n-        ty::ty_vec(ty::mt { ty: inner_type, .. }, optional_length) => {\n+        ty::ty_vec(inner_type, optional_length) => {\n             output.push_char('[');\n             push_debuginfo_type_name(cx, inner_type, true, output);\n \n@@ -3811,6 +3820,7 @@ fn push_debuginfo_type_name(cx: &CrateContext,\n         }\n         ty::ty_err      |\n         ty::ty_infer(_) |\n+        ty::ty_open(_) |\n         ty::ty_param(_) => {\n             cx.sess().bug(format!(\"debuginfo: Trying to create type name for \\\n                 unexpected type: {}\", ppaux::ty_to_string(cx.tcx(), t)).as_slice());"}, {"sha": "5f9788d707ac5102ab7cfb0bd3349cdab1e9af6b", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 65, "deletions": 49, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -71,7 +71,7 @@ use middle::typeck::MethodCall;\n use util::common::indenter;\n use util::ppaux::Repr;\n use util::nodemap::NodeMap;\n-use middle::trans::machine::{llalign_of_min, llsize_of, llsize_of_alloc};\n+use middle::trans::machine::{llsize_of, llsize_of_alloc};\n use middle::trans::type_::Type;\n \n use syntax::ast;\n@@ -202,8 +202,11 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n             };\n \n             if autoderefs > 0 {\n+                let lval = unpack_datum!(bcx,\n+                                         datum.to_lvalue_datum(bcx, \"auto_deref\", expr.id));\n+\n                 datum = unpack_datum!(\n-                    bcx, deref_multiple(bcx, expr, datum, autoderefs));\n+                    bcx, deref_multiple(bcx, expr, lval.to_expr_datum(), autoderefs));\n             }\n \n             match adj.autoref {\n@@ -266,35 +269,42 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n                    -> DatumBlock<'a, Expr> {\n         if !ty::type_is_sized(bcx.tcx(), datum.ty) {\n             debug!(\"Taking address of unsized type {}\",\n-                   bcx.ty_to_str(datum.ty));\n+                   bcx.ty_to_string(datum.ty));\n             ref_fat_ptr(bcx, expr, datum)\n         } else {\n             debug!(\"Taking address of sized type {}\",\n-                   bcx.ty_to_str(datum.ty));\n+                   bcx.ty_to_string(datum.ty));\n             auto_ref(bcx, datum, expr)\n         }\n     }\n \n     // Retrieve the information we are losing (making dynamic) in an unsizing\n     // adjustment.\n+    // When making a dtor, we need to do different things depending on the\n+    // ownership of the object.. mk_ty is a function for turning unsized_type\n+    // into a type to be destructed. If we want to end up with a Box pointer,\n+    // then mk_ty should make a Box pointer (T -> Box<T>), if we want a\n+    // borrowed reference then it should be T -> &T.\n     fn unsized_info<'a>(bcx: &'a Block<'a>,\n                         kind: &ty::UnsizeKind,\n                         id: ast::NodeId,\n-                        sized_ty: ty::t) -> ValueRef {\n+                        unsized_ty: ty::t,\n+                        mk_ty: |ty::t| -> ty::t) -> ValueRef {\n         match kind {\n             &ty::UnsizeLength(len) => C_uint(bcx.ccx(), len),\n-            &ty::UnsizeStruct(box ref k, tp_index) => match ty::get(sized_ty).sty {\n+            &ty::UnsizeStruct(box ref k, tp_index) => match ty::get(unsized_ty).sty {\n                 ty::ty_struct(_, ref substs) => {\n-                    let ty_substs = substs.types.get_vec(subst::TypeSpace);\n-                    let sized_ty = ty_substs.get(tp_index);\n-                    unsized_info(bcx, k, id, *sized_ty)\n+                    let ty_substs = substs.types.get_slice(subst::TypeSpace);\n+                    // The dtor for a field treats it like a value, so mk_ty\n+                    // should just be the identity function.\n+                    unsized_info(bcx, k, id, ty_substs[tp_index], |t| t)\n                 }\n                 _ => bcx.sess().bug(format!(\"UnsizeStruct with bad sty: {}\",\n-                                          bcx.ty_to_str(sized_ty)).as_slice())\n+                                          bcx.ty_to_string(unsized_ty)).as_slice())\n             },\n             &ty::UnsizeVtable(..) =>\n                 PointerCast(bcx,\n-                            meth::vtable_ptr(bcx, id, sized_ty),\n+                            meth::vtable_ptr(bcx, id, mk_ty(unsized_ty)),\n                             Type::vtable_ptr(bcx.ccx()))\n         }\n     }\n@@ -320,7 +330,16 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n             &ty::UnsizeVtable(..) =>\n                 |_bcx, val| PointerCast(bcx, val, Type::i8p(bcx.ccx()))\n         };\n-        let info = |bcx, _val| unsized_info(bcx, k, expr.id, datum_ty);\n+        let info = |bcx, _val| unsized_info(bcx,\n+                                            k,\n+                                            expr.id,\n+                                            ty::deref_or_dont(datum_ty),\n+                                            |t| ty::mk_rptr(tcx,\n+                                                            ty::ReStatic,\n+                                                            ty::mt{\n+                                                                ty: t,\n+                                                                mutbl: ast::MutImmutable\n+                                                            }));\n         into_fat_ptr(bcx, expr, datum, dest_ty, base, info)\n     }\n \n@@ -415,21 +434,26 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n         let unboxed_ty = match ty::get(datum_ty).sty {\n             ty::ty_uniq(t) => t,\n             _ => bcx.sess().bug(format!(\"Expected ty_uniq, found {}\",\n-                                        bcx.ty_to_str(datum_ty)).as_slice())\n+                                        bcx.ty_to_string(datum_ty)).as_slice())\n         };\n         let result_ty = ty::mk_uniq(tcx, ty::unsize_ty(tcx, unboxed_ty, k, expr.span));\n \n         let lval = unpack_datum!(bcx,\n                                  datum.to_lvalue_datum(bcx, \"unsize_unique_expr\", expr.id));\n \n-        let scratch = rvalue_scratch_datum(bcx, result_ty, \"__fat_ptr\");\n+        let scratch = rvalue_scratch_datum(bcx, result_ty, \"__uniq_fat_ptr\");\n         let llbox_ty = type_of::type_of(bcx.ccx(), datum_ty);\n         let base = PointerCast(bcx, get_dataptr(bcx, scratch.val), llbox_ty.ptr_to());\n         bcx = lval.store_to(bcx, base);\n \n-        let info = unsized_info(bcx, k, expr.id, unboxed_ty);\n+        let info = unsized_info(bcx, k, expr.id, unboxed_ty, |t| ty::mk_uniq(tcx, t));\n         Store(bcx, info, get_len(bcx, scratch.val));\n \n+        let scratch = unpack_datum!(bcx,\n+                                    scratch.to_expr_datum().to_lvalue_datum(bcx,\n+                                                                            \"fresh_uniq_fat_ptr\",\n+                                                                            expr.id));\n+\n         DatumBlock::new(bcx, scratch.to_expr_datum())\n     }\n \n@@ -550,27 +574,33 @@ fn trans_datum_unadjusted<'a>(bcx: &'a Block<'a>,\n         ast::ExprField(ref base, ident, _) => {\n             trans_rec_field(bcx, &**base, ident.node)\n         }\n-        ast::ExprIndex(base, idx) => {\n-            trans_index(bcx, expr.span, &**base, &**idx, MethodCall::expr(expr.id))\n+        ast::ExprIndex(ref base, ref idx) => {\n+            trans_index(bcx, expr, &**base, &**idx, MethodCall::expr(expr.id))\n         }\n         ast::ExprBox(_, ref contents) => {\n             // Special case for `Box<T>` and `Gc<T>`\n             let box_ty = expr_ty(bcx, expr);\n             let contents_ty = expr_ty(bcx, &**contents);\n             match ty::get(box_ty).sty {\n                 ty::ty_uniq(..) => {\n-                    match contents.node {\n-                        ast::ExprRepeat(..) | ast::ExprVec(..) => {\n-                            // Special case for owned vectors.\n-                            fcx.push_ast_cleanup_scope(contents.id);\n-                            let datum = unpack_datum!(\n-                                bcx, tvec::trans_uniq_vec(bcx, expr, &**contents));\n-                            bcx = fcx.pop_and_trans_ast_cleanup_scope(bcx, contents.id);\n-                            DatumBlock::new(bcx, datum)\n-                        }\n-                        _ => {\n-                            trans_uniq_expr(bcx, box_ty, &**contents, contents_ty)\n-                        }\n+                    let is_vec = match contents.node {\n+                        ast::ExprRepeat(..) | ast::ExprVec(..) => true,\n+                        ast::ExprLit(lit) => match lit.node {\n+                            ast::LitStr(..) => true,\n+                            _ => false\n+                        },\n+                        _ => false\n+                    };\n+\n+                    if is_vec {\n+                        // Special case for owned vectors.\n+                        fcx.push_ast_cleanup_scope(contents.id);\n+                        let datum = unpack_datum!(\n+                            bcx, tvec::trans_uniq_vec(bcx, expr, &**contents));\n+                        bcx = fcx.pop_and_trans_ast_cleanup_scope(bcx, contents.id);\n+                        DatumBlock::new(bcx, datum)\n+                    } else {\n+                        trans_uniq_expr(bcx, box_ty, &**contents, contents_ty)\n                     }\n                 }\n                 ty::ty_box(..) => {\n@@ -639,7 +669,6 @@ fn trans_rec_field<'a>(bcx: &'a Block<'a>,\n         if ty::type_is_sized(bcx.tcx(), d.ty) {\n             DatumBlock { datum: d.to_expr_datum(), bcx: bcx }\n         } else {\n-            debug!(\"nrc: {}\", bcx.ty_to_str(d.ty))\n             let scratch = rvalue_scratch_datum(bcx, ty::mk_open(bcx.tcx(), d.ty), \"\");\n             Store(bcx, d.val, get_dataptr(bcx, scratch.val));\n             let info = Load(bcx, get_len(bcx, base_datum.val));\n@@ -652,7 +681,7 @@ fn trans_rec_field<'a>(bcx: &'a Block<'a>,\n }\n \n fn trans_index<'a>(bcx: &'a Block<'a>,\n-                   sp: codemap::Span,\n+                   index_expr: &ast::Expr,\n                    base: &ast::Expr,\n                    idx: &ast::Expr,\n                    method_call: MethodCall)\n@@ -1326,7 +1355,8 @@ pub fn trans_adt<'a>(mut bcx: &'a Block<'a>,\n                 let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, &*base.expr, \"base\"));\n                 for &(i, t) in base.fields.iter() {\n                     let datum = base_datum.get_element(\n-                            t, |srcval| adt::trans_field_ptr(bcx, &*repr, srcval, discr, i));\n+                            bcx, t, |srcval| adt::trans_field_ptr(bcx, &*repr, srcval, discr, i));\n+                    assert!(ty::type_is_sized(bcx.tcx(), datum.ty));\n                     let dest = adt::trans_field_ptr(bcx, &*repr, addr, discr, i);\n                     bcx = datum.store_to(bcx, dest);\n                 }\n@@ -1348,21 +1378,6 @@ pub fn trans_adt<'a>(mut bcx: &'a Block<'a>,\n         fcx.schedule_drop_mem(scope, dest, e_ty);\n     }\n \n-    for base in optbase.iter() {\n-        // FIXME #6573: is it sound to use the destination's repr on the base?\n-        // And, would it ever be reasonable to be here with discr != 0?\n-        let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, &*base.expr, \"base\"));\n-        for &(i, t) in base.fields.iter() {\n-            let datum = base_datum.get_element(\n-                bcx,\n-                t,\n-                |srcval| adt::trans_field_ptr(bcx, repr, srcval, discr, i));\n-            assert!(ty::type_is_sized(bcx.tcx(), datum.ty));\n-            let dest = adt::trans_field_ptr(bcx, repr, addr, discr, i);\n-            bcx = datum.store_to(bcx, dest);\n-        }\n-    }\n-\n     adt::trans_set_discr(bcx, &*repr, addr, discr);\n \n     fcx.pop_custom_cleanup_scope(custom_cleanup_scope);\n@@ -1448,9 +1463,10 @@ fn trans_uniq_expr<'a>(bcx: &'a Block<'a>,\n                         -> DatumBlock<'a, Expr> {\n     let _icx = push_ctxt(\"trans_uniq_expr\");\n     let fcx = bcx.fcx;\n+    assert!(ty::type_is_sized(bcx.tcx(), contents_ty));\n     let llty = type_of::type_of(bcx.ccx(), contents_ty);\n     let size = llsize_of(bcx.ccx(), llty);\n-    let align = C_uint(bcx.ccx(), llalign_of_min(bcx.ccx(), llty) as uint);\n+    let align = C_uint(bcx.ccx(), type_of::align_of(bcx.ccx(), contents_ty) as uint);\n     let llty_ptr = llty.ptr_to();\n     let Result { bcx, val } = malloc_raw_dyn(bcx, llty_ptr, box_ty, size, align);\n     // Unique boxes do not allocate for zero-size types. The standard library\n@@ -1499,7 +1515,7 @@ fn trans_addr_of<'a>(bcx: &'a Block<'a>,\n     match ty::get(sub_datum.ty).sty {\n         ty::ty_open(_) => {\n             // Opened DST value, close to a fat pointer\n-            debug!(\"Closing fat pointer {}\", bcx.ty_to_str(sub_datum.ty));\n+            debug!(\"Closing fat pointer {}\", bcx.ty_to_string(sub_datum.ty));\n \n             let scratch = rvalue_scratch_datum(bcx,\n                                                ty::close_type(bcx.tcx(), sub_datum.ty),"}, {"sha": "56841cd4044b626d297a7197e5911ebed55bb14b", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 187, "deletions": 21, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -19,19 +19,21 @@ use llvm::{ValueRef, True, get_param};\n use llvm;\n use middle::lang_items::{FreeFnLangItem, ExchangeFreeFnLangItem};\n use middle::subst;\n+use middle::subst::Subst;\n use middle::trans::adt;\n use middle::trans::base::*;\n use middle::trans::build::*;\n use middle::trans::callee;\n use middle::trans::cleanup;\n use middle::trans::cleanup::CleanupMethods;\n use middle::trans::common::*;\n+use middle::trans::datum;\n use middle::trans::expr;\n use middle::trans::machine::*;\n use middle::trans::reflect;\n use middle::trans::tvec;\n use middle::trans::type_::Type;\n-use middle::trans::type_of::{type_of, sizing_type_of};\n+use middle::trans::type_of::{type_of, sizing_type_of, align_of};\n use middle::ty;\n use util::ppaux::ty_to_short_str;\n use util::ppaux;\n@@ -51,24 +53,33 @@ pub fn trans_free<'a>(cx: &'a Block<'a>, v: ValueRef) -> &'a Block<'a> {\n         Some(expr::Ignore)).bcx\n }\n \n-pub fn trans_exchange_free<'a>(cx: &'a Block<'a>, v: ValueRef, size: u64,\n-                               align: u64) -> &'a Block<'a> {\n+fn trans_exchange_free_internal<'a>(cx: &'a Block<'a>, v: ValueRef, size: ValueRef,\n+                               align: ValueRef) -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_exchange_free\");\n     let ccx = cx.ccx();\n     callee::trans_lang_call(cx,\n         langcall(cx, None, \"\", ExchangeFreeFnLangItem),\n-        [PointerCast(cx, v, Type::i8p(ccx)), C_uint(ccx, size as uint), C_uint(ccx, align as uint)],\n+        [PointerCast(cx, v, Type::i8p(ccx)), size, align],\n         Some(expr::Ignore)).bcx\n }\n \n+pub fn trans_exchange_free<'a>(cx: &'a Block<'a>, v: ValueRef, size: u64,\n+                               align: u64) -> &'a Block<'a> {\n+    trans_exchange_free_internal(cx,\n+                                 v,\n+                                 C_uint(cx.ccx(), size as uint),\n+                                 C_uint(cx.ccx(), align as uint))\n+}\n+\n pub fn trans_exchange_free_ty<'a>(bcx: &'a Block<'a>, ptr: ValueRef,\n                                   content_ty: ty::t) -> &'a Block<'a> {\n+    assert!(ty::type_is_sized(bcx.ccx().tcx(), content_ty));\n     let sizing_type = sizing_type_of(bcx.ccx(), content_ty);\n     let content_size = llsize_of_alloc(bcx.ccx(), sizing_type);\n \n     // `Box<ZeroSizeType>` does not allocate.\n     if content_size != 0 {\n-        let content_align = llalign_of_min(bcx.ccx(), sizing_type);\n+        let content_align = align_of(bcx.ccx(), content_ty);\n         trans_exchange_free(bcx, ptr, content_size, content_align)\n     } else {\n         bcx\n@@ -91,6 +102,11 @@ pub fn take_ty<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n \n pub fn get_drop_glue_type(ccx: &CrateContext, t: ty::t) -> ty::t {\n     let tcx = ccx.tcx();\n+    // Even if there is no dtor for t, there might be one deeper down and we\n+    // might need to pass in the vtable ptr.\n+    if !ty::type_is_sized(tcx, t) {\n+        return t\n+    }\n     if !ty::type_needs_drop(tcx, t) {\n         return ty::mk_i8();\n     }\n@@ -139,13 +155,21 @@ pub fn drop_ty_immediate<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n }\n \n pub fn get_drop_glue(ccx: &CrateContext, t: ty::t) -> ValueRef {\n+    debug!(\"make drop glue for {}\", ppaux::ty_to_string(ccx.tcx(), t));\n     let t = get_drop_glue_type(ccx, t);\n+    debug!(\"drop glue type {}\", ppaux::ty_to_string(ccx.tcx(), t));\n     match ccx.drop_glues.borrow().find(&t) {\n         Some(&glue) => return glue,\n         _ => { }\n     }\n \n-    let llfnty = Type::glue_fn(ccx, type_of(ccx, t).ptr_to());\n+    let llty = if ty::type_is_sized(ccx.tcx(), t) {\n+        type_of(ccx, t).ptr_to()\n+    } else {\n+        type_of(ccx, ty::mk_uniq(ccx.tcx(), t)).ptr_to()\n+    };\n+\n+    let llfnty = Type::glue_fn(ccx, llty);\n     let glue = declare_generic_glue(ccx, t, llfnty, \"drop\");\n \n     ccx.drop_glues.borrow_mut().insert(t, glue);\n@@ -208,7 +232,13 @@ fn trans_struct_drop_flag<'a>(mut bcx: &'a Block<'a>,\n                               substs: &subst::Substs)\n                               -> &'a Block<'a> {\n     let repr = adt::represent_type(bcx.ccx(), t);\n-    let drop_flag = unpack_datum!(bcx, adt::trans_drop_flag_ptr(bcx, &*repr, v0));\n+    let struct_data = if ty::type_is_sized(bcx.tcx(), t) {\n+        v0\n+    } else {\n+        let llval = GEPi(bcx, v0, [0, abi::slice_elt_base]);\n+        Load(bcx, llval)\n+    };\n+    let drop_flag = unpack_datum!(bcx, adt::trans_drop_flag_ptr(bcx, &*repr, struct_data));\n     with_cond(bcx, load_ty(bcx, drop_flag.val, ty::mk_bool()), |cx| {\n         trans_struct_drop(cx, t, v0, dtor_did, class_did, substs)\n     })\n@@ -227,13 +257,31 @@ fn trans_struct_drop<'a>(bcx: &'a Block<'a>,\n     let dtor_addr = get_res_dtor(bcx.ccx(), dtor_did, t,\n                                  class_did, substs);\n \n-    // The second argument is the \"self\" argument for drop\n+    // The first argument is the \"self\" argument for drop\n     let params = unsafe {\n         let ty = Type::from_ref(llvm::LLVMTypeOf(dtor_addr));\n         ty.element_type().func_params()\n     };\n \n-    adt::fold_variants(bcx, &*repr, v0, |variant_cx, st, value| {\n+    let fty = ty::lookup_item_type(bcx.tcx(), dtor_did).ty.subst(bcx.tcx(), substs);\n+    let self_ty = match ty::get(fty).sty {\n+        ty::ty_bare_fn(ref f) => {\n+            assert!(f.sig.inputs.len() == 1);\n+            f.sig.inputs[0]\n+        }\n+        _ => bcx.sess().bug(format!(\"Expected function type, found {}\",\n+                                    bcx.ty_to_string(fty)).as_slice())\n+    };\n+\n+    let (struct_data, info) = if ty::type_is_sized(bcx.tcx(), t) {\n+        (v0, None)\n+    } else {\n+        let data = GEPi(bcx, v0, [0, abi::slice_elt_base]);\n+        let info = GEPi(bcx, v0, [0, abi::slice_elt_len]);\n+        (Load(bcx, data), Some(Load(bcx, info)))\n+    };\n+\n+    adt::fold_variants(bcx, &*repr, struct_data, |variant_cx, st, value| {\n         // Be sure to put all of the fields into a scope so we can use an invoke\n         // instruction to call the user destructor but still call the field\n         // destructors if the user destructor fails.\n@@ -242,27 +290,107 @@ fn trans_struct_drop<'a>(bcx: &'a Block<'a>,\n         // Class dtors have no explicit args, so the params should\n         // just consist of the environment (self).\n         assert_eq!(params.len(), 1);\n-        let self_arg = PointerCast(variant_cx, value, *params.get(0));\n+        let self_arg = if ty::type_is_fat_ptr(bcx.tcx(), self_ty) {\n+            // The dtor expects a fat pointer, so make one, even if we have to fake it.\n+            let boxed_ty = ty::mk_open(bcx.tcx(), t);\n+            let scratch = datum::rvalue_scratch_datum(bcx, boxed_ty, \"__fat_ptr_drop_self\");\n+            Store(bcx, value, GEPi(bcx, scratch.val, [0, abi::slice_elt_base]));\n+            Store(bcx,\n+                  // If we just had a thin pointer, make a fat pointer by sticking\n+                  // null where we put the unsizing info. This works because t\n+                  // is a sized type, so we will only unpack the fat pointer, never\n+                  // use the fake info.\n+                  info.unwrap_or(C_null(Type::i8p(bcx.ccx()))),\n+                  GEPi(bcx, scratch.val, [0, abi::slice_elt_len]));\n+            PointerCast(variant_cx, scratch.val, *params.get(0))\n+        } else {\n+            PointerCast(variant_cx, value, *params.get(0))\n+        };\n         let args = vec!(self_arg);\n \n         // Add all the fields as a value which needs to be cleaned at the end of\n         // this scope. Iterate in reverse order so a Drop impl doesn't reverse\n         // the order in which fields get dropped.\n         for (i, ty) in st.fields.iter().enumerate().rev() {\n             let llfld_a = adt::struct_field_ptr(variant_cx, &*st, value, i, false);\n+\n+            let val = if ty::type_is_sized(bcx.tcx(), *ty) {\n+                llfld_a\n+            } else {\n+                let boxed_ty = ty::mk_open(bcx.tcx(), *ty);\n+                let scratch = datum::rvalue_scratch_datum(bcx, boxed_ty, \"__fat_ptr_drop_field\");\n+                Store(bcx, llfld_a, GEPi(bcx, scratch.val, [0, abi::slice_elt_base]));\n+                Store(bcx, info.unwrap(), GEPi(bcx, scratch.val, [0, abi::slice_elt_len]));\n+                scratch.val\n+            };\n             variant_cx.fcx.schedule_drop_mem(cleanup::CustomScope(field_scope),\n-                                             llfld_a, *ty);\n+                                             val, *ty);\n         }\n \n         let dtor_ty = ty::mk_ctor_fn(variant_cx.tcx(), ast::DUMMY_NODE_ID,\n                                      [get_drop_glue_type(bcx.ccx(), t)], ty::mk_nil());\n-        let (_, variant_cx) = invoke(variant_cx, dtor_addr, args, dtor_ty, None);\n+        let (_, variant_cx) = invoke(variant_cx, dtor_addr, args, dtor_ty, None, false);\n \n         variant_cx.fcx.pop_and_trans_custom_cleanup_scope(variant_cx, field_scope);\n         variant_cx\n     })\n }\n \n+fn size_and_align_of_dst<'a>(bcx: &'a Block<'a>, t :ty::t, info: ValueRef) -> (ValueRef, ValueRef) {\n+    debug!(\"calculate size of DST: {}; with lost info: {}\",\n+           bcx.ty_to_string(t), bcx.val_to_string(info));\n+    if ty::type_is_sized(bcx.tcx(), t) {\n+        let sizing_type = sizing_type_of(bcx.ccx(), t);\n+        let size = C_uint(bcx.ccx(), llsize_of_alloc(bcx.ccx(), sizing_type) as uint);\n+        let align = C_uint(bcx.ccx(), align_of(bcx.ccx(), t) as uint);\n+        return (size, align);\n+    }\n+    match ty::get(t).sty {\n+        ty::ty_struct(id, ref substs) => {\n+            let ccx = bcx.ccx();\n+            // First get the size of all statically known fields.\n+            // Don't use type_of::sizing_type_of because that expects t to be sized.\n+            assert!(!ty::type_is_simd(bcx.tcx(), t));\n+            let repr = adt::represent_type(ccx, t);\n+            let sizing_type = adt::sizing_type_of(ccx, &*repr, true);\n+            let sized_size = C_uint(ccx, llsize_of_alloc(ccx, sizing_type) as uint);\n+            let sized_align = C_uint(ccx, llalign_of_min(ccx, sizing_type) as uint);\n+\n+            // Recurse to get the size of the dynamically sized field (must be\n+            // the last field).\n+            let fields = ty::struct_fields(bcx.tcx(), id, substs);\n+            let last_field = fields[fields.len()-1];\n+            let field_ty = last_field.mt.ty;\n+            let (unsized_size, unsized_align) = size_and_align_of_dst(bcx, field_ty, info);\n+\n+            // Return the sum of sizes and max of aligns.\n+            let size = Add(bcx, sized_size, unsized_size);\n+            let align = Select(bcx,\n+                               ICmp(bcx, llvm::IntULT, sized_align, unsized_align),\n+                               sized_align,\n+                               unsized_align);\n+            (size, align)\n+        }\n+        ty::ty_trait(..) => {\n+            // info points to the vtable and the second entry in the vtable is the\n+            // dynamic size of the object.\n+            let info = PointerCast(bcx, info, Type::int(bcx.ccx()).ptr_to());\n+            let size_ptr = GEPi(bcx, info, [1u]);\n+            let align_ptr = GEPi(bcx, info, [2u]);\n+            (Load(bcx, size_ptr), Load(bcx, align_ptr))\n+        }\n+        ty::ty_vec(unit_ty, None) => {\n+            // The info in this case is the length of the vec, so the size is that\n+            // times the unit size.\n+            let llunit_ty = sizing_type_of(bcx.ccx(), unit_ty);\n+            let unit_size = llsize_of_alloc(bcx.ccx(), llunit_ty);\n+            (Mul(bcx, info, C_uint(bcx.ccx(), unit_size as uint)), C_uint(bcx.ccx(), 8))\n+        }\n+        _ => bcx.sess().bug(format!(\"Unexpected unsized type, found {}\",\n+                                    bcx.ty_to_string(t)).as_slice())\n+    }\n+}\n+\n fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'a> {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"make_drop_glue\");\n@@ -282,7 +410,8 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n                 ty::ty_trait(..) => {\n                     let lluniquevalue = GEPi(bcx, v0, [0, abi::trt_field_box]);\n                     // Only drop the value when it is non-null\n-                    with_cond(bcx, IsNotNull(bcx, Load(bcx, lluniquevalue)), |bcx| {\n+                    let concrete_ptr = Load(bcx, lluniquevalue);\n+                    with_cond(bcx, IsNotNull(bcx, concrete_ptr), |bcx| {\n                         let dtor_ptr = Load(bcx, GEPi(bcx, v0, [0, abi::trt_field_vtable]));\n                         let dtor = Load(bcx, dtor_ptr);\n                         Call(bcx,\n@@ -292,13 +421,21 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n                         bcx\n                     })\n                 }\n+                ty::ty_struct(..) if !ty::type_is_sized(bcx.tcx(), content_ty) => {\n+                    let llval = GEPi(bcx, v0, [0, abi::slice_elt_base]);\n+                    let llbox = Load(bcx, llval);\n+                    let not_null = IsNotNull(bcx, llbox);\n+                    with_cond(bcx, not_null, |bcx| {\n+                        let bcx = drop_ty(bcx, v0, content_ty);\n+                        let info = GEPi(bcx, v0, [0, abi::slice_elt_len]);\n+                        let info = Load(bcx, info);\n+                        let (llsize, llalign) = size_and_align_of_dst(bcx, content_ty, info);\n+                        trans_exchange_free_internal(bcx, llbox, llsize, llalign)\n+                    })\n+                }\n                 _ => {\n-                    let llval = if ty::type_is_sized(bcx.tcx(), content_ty) {\n-                        v0\n-                    } else {\n-                        // The Box is a fat pointer\n-                        GEPi(bcx, v0, [0, abi::trt_field_box])\n-                    };\n+                    assert!(ty::type_is_sized(bcx.tcx(), content_ty));\n+                    let llval = v0;\n                     let llbox = Load(bcx, llval);\n                     let not_null = IsNotNull(bcx, llbox);\n                     with_cond(bcx, not_null, |bcx| {\n@@ -312,7 +449,21 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n             let tcx = bcx.tcx();\n             match ty::ty_dtor(tcx, did) {\n                 ty::TraitDtor(dtor, true) => {\n-                    trans_struct_drop_flag(bcx, t, v0, dtor, did, substs)\n+                    // FIXME(16758) Since the struct is unsized, it is hard to\n+                    // find the drop flag (which is at the end of the struct).\n+                    // Lets just ignore the flag and pretend everything will be\n+                    // OK.\n+                    if ty::type_is_sized(bcx.tcx(), t) {\n+                        trans_struct_drop_flag(bcx, t, v0, dtor, did, substs)\n+                    } else {\n+                        // Give the user a heads up that we are doing something\n+                        // stupid and dangerous.\n+                        bcx.sess().warn(format!(\"Ignoring drop flag in destructor for {}\\\n+                                                 because the struct is unsized. See issue\\\n+                                                 #16758\",\n+                                                bcx.ty_to_string(t)).as_slice());\n+                        trans_struct_drop(bcx, t, v0, dtor, did, substs)\n+                    }\n                 }\n                 ty::TraitDtor(dtor, false) => {\n                     trans_struct_drop(bcx, t, v0, dtor, did, substs)\n@@ -340,7 +491,23 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n                 trans_exchange_free(bcx, env, 0, 8)\n             })\n         }\n+        ty::ty_trait(..) => {\n+            // No need to do a null check here (as opposed to the Box<trait case\n+            // above), because this happens for a trait field in an unsized\n+            // struct. If anything is null, it is the whole struct and we won't\n+            // get here.\n+            let lluniquevalue = GEPi(bcx, v0, [0, abi::trt_field_box]);\n+            let dtor_ptr = Load(bcx, GEPi(bcx, v0, [0, abi::trt_field_vtable]));\n+            let dtor = Load(bcx, dtor_ptr);\n+            Call(bcx,\n+                 dtor,\n+                 [PointerCast(bcx, Load(bcx, lluniquevalue), Type::i8p(bcx.ccx()))],\n+                 None);\n+            bcx\n+        }\n+        ty::ty_vec(ty, None) => tvec::make_drop_glue_unboxed(bcx, v0, ty),\n         _ => {\n+            assert!(ty::type_is_sized(bcx.tcx(), t));\n             if ty::type_needs_drop(bcx.tcx(), t) &&\n                 ty::type_is_structural(t) {\n                 iter_structural_ty(bcx, v0, t, drop_ty)\n@@ -439,7 +606,6 @@ fn declare_generic_glue(ccx: &CrateContext, t: ty::t, llfnty: Type,\n         ccx,\n         t,\n         format!(\"glue_{}\", name).as_slice());\n-    debug!(\"{} is for type {}\", fn_nm, ppaux::ty_to_string(ccx.tcx(), t));\n     let llfn = decl_cdecl_fn(ccx, fn_nm.as_slice(), llfnty, ty::mk_nil());\n     note_unique_llvm_symbol(ccx, fn_nm);\n     return llfn;"}, {"sha": "7d8e4679ae302d2ff4f3e412c93d92a89dfc9c82", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -119,6 +119,17 @@ pub fn check_intrinsics(ccx: &CrateContext) {\n                             \"s\"\n                         }).as_slice());\n         }\n+        if ty::type_is_fat_ptr(ccx.tcx(), transmute_restriction.to) ||\n+           ty::type_is_fat_ptr(ccx.tcx(), transmute_restriction.from) {\n+            ccx.sess()\n+               .add_lint(::lint::builtin::TRANSMUTE_FAT_PTR,\n+                         transmute_restriction.id,\n+                         transmute_restriction.span,\n+                         format!(\"Transmuting fat pointer types; {} to {}.\\\n+                                  Beware of relying on the compiler's representation\",\n+                                 ty_to_string(ccx.tcx(), transmute_restriction.from),\n+                                 ty_to_string(ccx.tcx(), transmute_restriction.to)));\n+        }\n     }\n     ccx.sess().abort_if_errors();\n }\n@@ -227,8 +238,7 @@ pub fn trans_intrinsic_call<'a>(mut bcx: &'a Block<'a>, node: ast::NodeId,\n         }\n         (_, \"min_align_of\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n-            let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            C_uint(ccx, machine::llalign_of_min(ccx, lltp_ty) as uint)\n+            C_uint(ccx, type_of::align_of(ccx, tp_ty) as uint)\n         }\n         (_, \"pref_align_of\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n@@ -542,7 +552,7 @@ fn copy_intrinsic(bcx: &Block, allow_overlap: bool, volatile: bool,\n                   tp_ty: ty::t, dst: ValueRef, src: ValueRef, count: ValueRef) -> ValueRef {\n     let ccx = bcx.ccx();\n     let lltp_ty = type_of::type_of(ccx, tp_ty);\n-    let align = C_i32(ccx, machine::llalign_of_min(ccx, lltp_ty) as i32);\n+    let align = C_i32(ccx, type_of::align_of(ccx, tp_ty) as i32);\n     let size = machine::llsize_of(ccx, lltp_ty);\n     let int_size = machine::llbitsize_of_real(ccx, ccx.int_type);\n     let name = if allow_overlap {\n@@ -571,7 +581,7 @@ fn memset_intrinsic(bcx: &Block, volatile: bool, tp_ty: ty::t,\n                     dst: ValueRef, val: ValueRef, count: ValueRef) -> ValueRef {\n     let ccx = bcx.ccx();\n     let lltp_ty = type_of::type_of(ccx, tp_ty);\n-    let align = C_i32(ccx, machine::llalign_of_min(ccx, lltp_ty) as i32);\n+    let align = C_i32(ccx, type_of::align_of(ccx, tp_ty) as i32);\n     let size = machine::llsize_of(ccx, lltp_ty);\n     let name = if machine::llbitsize_of_real(ccx, ccx.int_type) == 32 {\n         \"llvm.memset.p0i8.i32\""}, {"sha": "83bdcc9dead6473d6120dd07d6982a5ac914e239", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -25,6 +25,7 @@ use middle::trans::datum::*;\n use middle::trans::expr::{SaveIn, Ignore};\n use middle::trans::expr;\n use middle::trans::glue;\n+use middle::trans::machine;\n use middle::trans::monomorphize;\n use middle::trans::type_::Type;\n use middle::trans::type_of::*;\n@@ -40,6 +41,9 @@ use syntax::parse::token;\n use syntax::{ast, ast_map, visit};\n use syntax::ast_util::PostExpansionMethod;\n \n+// drop_glue pointer, size, align.\n+static VTABLE_OFFSET: uint = 3;\n+\n /**\n The main \"translation\" pass for methods.  Generates code\n for non-monomorphized methods only.  Other methods will\n@@ -450,7 +454,7 @@ pub fn trans_trait_callee_from_llval<'a>(bcx: &'a Block<'a>,\n                                     GEPi(bcx, llpair,\n                                          [0u, abi::trt_field_vtable]),\n                                     Type::vtable(ccx).ptr_to().ptr_to()));\n-    let mptr = Load(bcx, GEPi(bcx, llvtable, [0u, n_method + 1]));\n+    let mptr = Load(bcx, GEPi(bcx, llvtable, [0u, n_method + VTABLE_OFFSET]));\n     let mptr = PointerCast(bcx, mptr, llcallee_ty.ptr_to());\n \n     return Callee {\n@@ -580,9 +584,15 @@ fn get_vtable(bcx: &Block,\n         }\n     });\n \n+    let size_ty = sizing_type_of(ccx, self_ty);\n+    let size = machine::llsize_of_alloc(ccx, size_ty);\n+    let ll_size = C_uint(ccx, size as uint);\n+    let align = align_of(ccx, self_ty);\n+    let ll_align = C_uint(ccx, align as uint);\n+\n     // Generate a destructor for the vtable.\n     let drop_glue = glue::get_drop_glue(ccx, self_ty);\n-    let vtable = make_vtable(ccx, drop_glue, methods);\n+    let vtable = make_vtable(ccx, drop_glue, ll_size, ll_align, methods);\n \n     ccx.vtables.borrow_mut().insert(hash_id, vtable);\n     vtable\n@@ -591,11 +601,14 @@ fn get_vtable(bcx: &Block,\n /// Helper function to declare and initialize the vtable.\n pub fn make_vtable<I: Iterator<ValueRef>>(ccx: &CrateContext,\n                                           drop_glue: ValueRef,\n+                                          size: ValueRef,\n+                                          align: ValueRef,\n                                           ptrs: I)\n                                           -> ValueRef {\n     let _icx = push_ctxt(\"meth::make_vtable\");\n \n-    let components: Vec<_> = Some(drop_glue).move_iter().chain(ptrs).collect();\n+    let head = vec![drop_glue, size, align];\n+    let components: Vec<_> = head.move_iter().chain(ptrs).collect();\n \n     unsafe {\n         let tbl = C_struct(ccx, components.as_slice(), false);"}, {"sha": "11c641f2d75a245b8eda0762145972cf24850405", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -66,7 +66,7 @@ impl<'a, 'b> Reflector<'a, 'b> {\n     pub fn c_size_and_align(&mut self, t: ty::t) -> Vec<ValueRef> {\n         let tr = type_of(self.bcx.ccx(), t);\n         let s = machine::llsize_of_real(self.bcx.ccx(), tr);\n-        let a = machine::llalign_of_min(self.bcx.ccx(), tr);\n+        let a = align_of(self.bcx.ccx(), t);\n         return vec!(self.c_uint(s as uint),\n              self.c_uint(a as uint));\n     }\n@@ -94,7 +94,7 @@ impl<'a, 'b> Reflector<'a, 'b> {\n             ty::MethodTraitItem(ref method) => (*method).clone(),\n         };\n         let mth_ty = ty::mk_bare_fn(tcx, method.fty.clone());\n-        debug!(\"Emit call visit method: visit_{}: {}\", ty_name, ty_to_str(tcx, mth_ty));\n+        debug!(\"Emit call visit method: visit_{}: {}\", ty_name, ty_to_string(tcx, mth_ty));\n         let v = self.visitor_val;\n         debug!(\"passing {} args:\", args.len());\n         let mut bcx = self.bcx;\n@@ -154,8 +154,11 @@ impl<'a, 'b> Reflector<'a, 'b> {\n               // Unfortunately we can't do anything here because at runtime we\n               // pass around the value by pointer (*u8). But unsized pointers are\n               // fat and so we can't just cast them to *u8 and back. So we have\n-              // to work with the pointer directly (see ty_rptr/ty_uniq). See\n-              // ty_struct for where this causes issues.\n+              // to work with the pointer directly (see ty_rptr/ty_uniq).\n+              fail!(\"Can't reflect unsized type\")\n+          }\n+          // FIXME(15049) Reflection for unsized structs.\n+          ty::ty_struct(..) if !ty::type_is_sized(bcx.tcx(), t) => {\n               fail!(\"Can't reflect unsized type\")\n           }\n \n@@ -278,12 +281,7 @@ impl<'a, 'b> Reflector<'a, 'b> {\n               // because we cannot reflect unsized types (see note above). We\n               // just pretend the unsized field does not exist and print nothing.\n               // This is sub-optimal.\n-              let len = if ty::type_is_sized(tcx, t) {\n-                  fields.len()\n-              } else {\n-                  assert!(fields.len() > 0);\n-                  fields.len() - 1\n-              };\n+              let len = fields.len();\n \n               let extra = (vec!(\n                   self.c_slice(\n@@ -294,14 +292,12 @@ impl<'a, 'b> Reflector<'a, 'b> {\n               )).append(self.c_size_and_align(t).as_slice());\n               self.bracketed(\"class\", extra.as_slice(), |this| {\n                   for (i, field) in fields.iter().enumerate() {\n-                      if ty::type_is_sized(tcx, field.mt.ty) {\n-                          let extra = (vec!(\n-                            this.c_uint(i),\n-                            this.c_slice(token::get_ident(field.ident)),\n-                            this.c_bool(named_fields)\n-                          )).append(this.c_mt(&field.mt).as_slice());\n-                          this.visit(\"class_field\", extra.as_slice());\n-                      }\n+                      let extra = (vec!(\n+                        this.c_uint(i),\n+                        this.c_slice(token::get_ident(field.ident)),\n+                        this.c_bool(named_fields)\n+                      )).append(this.c_mt(&field.mt).as_slice());\n+                      this.visit(\"class_field\", extra.as_slice());\n                   }\n               })\n           }"}, {"sha": "94ca520c533f9348e8c05e6944a3dea95bccf83e", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 41, "deletions": 10, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -17,6 +17,7 @@ use middle::lang_items::StrDupUniqFnLangItem;\n use middle::trans::base::*;\n use middle::trans::base;\n use middle::trans::build::*;\n+use middle::trans::callee;\n use middle::trans::cleanup;\n use middle::trans::cleanup::CleanupMethods;\n use middle::trans::common::*;\n@@ -162,7 +163,7 @@ pub fn trans_slice_vec<'a>(bcx: &'a Block<'a>,\n     // Handle the &[...] case:\n     let vt = vec_types_from_expr(bcx, content_expr);\n     let count = elements_required(bcx, content_expr);\n-    debug!(\"    vt={}, count={:?}\", vt.to_str(ccx), count);\n+    debug!(\"    vt={}, count={:?}\", vt.to_string(ccx), count);\n     let llcount = C_uint(ccx, count);\n \n     let fixed_ty = ty::mk_vec(bcx.tcx(),\n@@ -173,7 +174,8 @@ pub fn trans_slice_vec<'a>(bcx: &'a Block<'a>,\n     let llfixed = if count == 0 {\n         // Just create a zero-sized alloca to preserve\n         // the non-null invariant of the inner slice ptr\n-        base::arrayalloca(bcx, vt.llunit_ty, llcount)\n+        let llfixed = base::arrayalloca(bcx, vt.llunit_ty, llcount);\n+        BitCast(bcx, llfixed, llfixed_ty)\n     } else {\n         // Make a fixed-length backing array and allocate it on the stack.\n         let llfixed = base::arrayalloca(bcx, vt.llunit_ty, llcount);\n@@ -231,26 +233,55 @@ pub fn trans_uniq_vec<'a>(bcx: &'a Block<'a>,\n                           content_expr: &ast::Expr)\n                           -> DatumBlock<'a, Expr> {\n     /*!\n-     * ~[...] and \"...\".to_string() allocate boxes in the exchange heap and write\n+     * Box<[...]> and \"...\".to_string() allocate boxes in the exchange heap and write\n      * the array elements into them.\n      */\n \n-    debug!(\"trans_uniq_vec(vstore_expr={})\", bcx.expr_to_string(uniq_expr));\n+    debug!(\"trans_uniq_vec(uniq_expr={})\", bcx.expr_to_string(uniq_expr));\n     let fcx = bcx.fcx;\n     let ccx = fcx.ccx;\n \n+    // Handle \"\".to_string().\n+    match content_expr.node {\n+        ast::ExprLit(lit) => {\n+            match lit.node {\n+                ast::LitStr(ref s, _) => {\n+                    let llptrval = C_cstr(ccx, (*s).clone(), false);\n+                    let llptrval = PointerCast(bcx, llptrval, Type::i8p(ccx));\n+                    let llsizeval = C_uint(ccx, s.get().len());\n+                    let typ = ty::mk_uniq(bcx.tcx(), ty::mk_str(bcx.tcx()));\n+                    let lldestval = rvalue_scratch_datum(bcx,\n+                                                         typ,\n+                                                         \"\");\n+                    let alloc_fn = langcall(bcx,\n+                                            Some(lit.span),\n+                                            \"\",\n+                                            StrDupUniqFnLangItem);\n+                    let bcx = callee::trans_lang_call(\n+                        bcx,\n+                        alloc_fn,\n+                        [ llptrval, llsizeval ],\n+                        Some(expr::SaveIn(lldestval.val))).bcx;\n+                    return DatumBlock::new(bcx, lldestval).to_expr_datumblock();\n+                }\n+                _ => {}\n+            }\n+        }\n+        _ => {}\n+    }\n+\n     let vt = vec_types_from_expr(bcx, content_expr);\n     let count = elements_required(bcx, content_expr);\n-    debug!(\"    vt={}, count={:?}\", vt.to_str(ccx), count);\n+    debug!(\"    vt={}, count={:?}\", vt.to_string(ccx), count);\n     let vec_ty = node_id_type(bcx, uniq_expr.id);\n \n     let unit_sz = nonzero_llsize_of(ccx, type_of::type_of(ccx, vt.unit_ty));\n-    let fill = Mul(bcx, C_uint(ccx, count), unit_sz);\n-    let alloc = if count < 4u {\n-        Mul(bcx, C_int(ccx, 4), unit_sz)\n+    let llcount = if count < 4u {\n+        C_int(ccx, 4)\n     } else {\n-        fill\n+        C_uint(ccx, count)\n     };\n+    let alloc = Mul(bcx, llcount, unit_sz);\n     let llty_ptr = type_of::type_of(ccx, vt.unit_ty).ptr_to();\n     let align = C_uint(ccx, 8);\n     let Result { bcx: bcx, val: dataptr } = malloc_raw_dyn(bcx,\n@@ -268,7 +299,7 @@ pub fn trans_uniq_vec<'a>(bcx: &'a Block<'a>,\n                             dataptr, cleanup::HeapExchange, vt.unit_ty);\n \n         debug!(\"    alloc_uniq_vec() returned dataptr={}, len={}\",\n-               bcx.val_to_str(dataptr), count);\n+               bcx.val_to_string(dataptr), count);\n \n         let bcx = write_content(bcx, &vt, uniq_expr,\n                                 content_expr, SaveIn(dataptr));"}, {"sha": "83c792ecf8782b43c4ad0ad89f7d4d63812dbbd1", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -14,6 +14,7 @@ use middle::subst;\n use middle::trans::adt;\n use middle::trans::common::*;\n use middle::trans::foreign;\n+use middle::trans::machine;\n use middle::ty;\n use util::ppaux;\n use util::ppaux::Repr;\n@@ -163,7 +164,7 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n     let llsizingty = match ty::get(t).sty {\n         _ if !ty::lltype_is_sized(cx.tcx(), t) => {\n             cx.sess().bug(format!(\"trying to take the sizing type of {}, an unsized type\",\n-                                  ppaux::ty_to_str(cx.tcx(), t)).as_slice())\n+                                  ppaux::ty_to_string(cx.tcx(), t)).as_slice())\n         }\n \n         ty::ty_nil | ty::ty_bot => Type::nil(cx),\n@@ -192,7 +193,7 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n \n         ty::ty_tup(..) | ty::ty_enum(..) | ty::ty_unboxed_closure(..) => {\n             let repr = adt::represent_type(cx, t);\n-            adt::sizing_type_of(cx, &*repr)\n+            adt::sizing_type_of(cx, &*repr, false)\n         }\n \n         ty::ty_struct(..) => {\n@@ -202,7 +203,7 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n                 Type::vector(&type_of(cx, et), n as u64)\n             } else {\n                 let repr = adt::represent_type(cx, t);\n-                adt::sizing_type_of(cx, &*repr)\n+                adt::sizing_type_of(cx, &*repr, false)\n             }\n         }\n \n@@ -212,7 +213,7 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n \n         ty::ty_infer(..) | ty::ty_param(..) | ty::ty_err(..) => {\n             cx.sess().bug(format!(\"fictitious type {} in sizing_type_of()\",\n-                                  ppaux::ty_to_str(cx.tcx(), t)).as_slice())\n+                                  ppaux::ty_to_string(cx.tcx(), t)).as_slice())\n         }\n         ty::ty_vec(_, None) | ty::ty_trait(..) | ty::ty_str => fail!(\"unreachable\")\n     };\n@@ -232,6 +233,14 @@ pub fn arg_type_of(cx: &CrateContext, t: ty::t) -> Type {\n // NB: If you update this, be sure to update `sizing_type_of()` as well.\n pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n     fn type_of_unsize_info(cx: &CrateContext, t: ty::t) -> Type {\n+        // It is possible to end up here with a sized type. This happens with a\n+        // struct which might be unsized, but is monomorphised to a sized type.\n+        // In this case we'll fake a fat pointer with no unsize info (we use 0).\n+        // However, its still a fat pointer, so we need some type use.\n+        if ty::type_is_sized(cx.tcx(), t) {\n+            return Type::i8p(cx);\n+        }\n+\n         match ty::get(ty::unsized_part_of_type(cx.tcx(), t)).sty {\n             ty::ty_str | ty::ty_vec(..) => Type::uint_from_ty(cx, ast::TyU),\n             ty::ty_trait(_) => Type::vtable_ptr(cx),\n@@ -367,7 +376,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n           }\n           ty::ty_trait(..) => Type::opaque_trait(cx),\n           _ => cx.sess().bug(format!(\"ty_open with sized type: {}\",\n-                                     ppaux::ty_to_str(cx.tcx(), t)).as_slice())\n+                                     ppaux::ty_to_string(cx.tcx(), t)).as_slice())\n       },\n \n       ty::ty_infer(..) => cx.sess().bug(\"type_of with ty_infer\"),\n@@ -395,6 +404,11 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n     return llty;\n }\n \n+pub fn align_of(cx: &CrateContext, t: ty::t) -> u64 {\n+    let llty = sizing_type_of(cx, t);\n+    machine::llalign_of_min(cx, llty)\n+}\n+\n // Want refinements! (Or case classes, I guess\n pub enum named_ty {\n     a_struct,"}, {"sha": "2d3096d13eae078a08be9637beafc8ed3743f96e", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 35, "deletions": 26, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -302,26 +302,23 @@ pub enum AutoRef {\n     AutoUnsafe(ast::Mutability),\n }\n \n-// Ugly little helper function. The bool in the returned tuple is true if there\n-// is an 'unsize to trait object' adjustment at the bottom of the adjustment. If\n-// that is surrounded by an AutoPtr, then we also return the region of the\n-// AutoPtr (in the third argument). The second bool is true if the adjustment is\n-// unique.\n+// Ugly little helper function. The first bool in the returned tuple is true if\n+// there is an 'unsize to trait object' adjustment at the bottom of the\n+// adjustment. If that is surrounded by an AutoPtr, then we also return the\n+// region of the AutoPtr (in the third argument). The second bool is true if the\n+// adjustment is unique.\n fn autoref_object_region(autoref: &AutoRef) -> (bool, bool, Option<Region>) {\n-    fn unsize_kind_region(k: &UnsizeKind) -> (bool, bool, Option<Region>) {\n+    fn unsize_kind_is_object(k: &UnsizeKind) -> bool {\n         match k {\n-            &UnsizeVtable(..) => (true, false, None),\n-            &UnsizeStruct(box ref k, _) => unsize_kind_region(k),\n-            _ => (false, false, None)\n+            &UnsizeVtable(..) => true,\n+            &UnsizeStruct(box ref k, _) => unsize_kind_is_object(k),\n+            _ => false\n         }\n     }\n \n     match autoref {\n-        &AutoUnsize(ref k) => unsize_kind_region(k),\n-        &AutoUnsizeUniq(ref k) => match k {\n-            &UnsizeVtable(..) => (true, true, None),\n-            _ => (false, false, None)\n-        },\n+        &AutoUnsize(ref k) => (unsize_kind_is_object(k), false, None),\n+        &AutoUnsizeUniq(ref k) => (unsize_kind_is_object(k), true, None),\n         &AutoPtr(adj_r, _, Some(box ref autoref)) => {\n             let (b, u, r) = autoref_object_region(autoref);\n             if r.is_some() || u {\n@@ -407,6 +404,8 @@ pub struct TransmuteRestriction {\n     pub from: t,\n     /// The type being transmuted to.\n     pub to: t,\n+    /// NodeIf of the transmute intrinsic.\n+    pub id: ast::NodeId,\n }\n \n /// The data structure to keep track of all the information that typechecker\n@@ -1765,7 +1764,7 @@ pub fn maybe_walk_ty(ty: t, f: |t| -> bool) {\n     }\n     match get(ty).sty {\n         ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) | ty_uint(_) | ty_float(_) |\n-        ty_str | ty_infer(_) | ty_param(_) | ty_unboxed_closure(_) | ty_err => {}\n+        ty_str | ty_infer(_) | ty_param(_) | ty_unboxed_closure(_, _) | ty_err => {}\n         ty_box(ty) | ty_uniq(ty) | ty_vec(ty, _) | ty_open(ty) => maybe_walk_ty(ty, f),\n         ty_ptr(ref tm) | ty_rptr(_, ref tm) => {\n             maybe_walk_ty(tm.ty, f);\n@@ -2941,12 +2940,12 @@ pub fn unsized_part_of_type(cx: &ctxt, ty: t) -> t {\n         ty_str | ty_trait(..) | ty_vec(..) => ty,\n         ty_struct(_, ref substs) => {\n             // Exactly one of the type parameters must be unsized.\n-            for tp in substs.types.get_vec(subst::TypeSpace).iter() {\n+            for tp in substs.types.get_slice(subst::TypeSpace).iter() {\n                 if !type_is_sized(cx, *tp) {\n                     return unsized_part_of_type(cx, *tp);\n                 }\n             }\n-            fail!(\"Unsized struct type with no unsized type params?\");\n+            fail!(\"Unsized struct type with no unsized type params? {}\", ty_to_string(cx, ty));\n         }\n         _ => {\n             assert!(type_is_sized(cx, ty),\n@@ -2990,11 +2989,21 @@ pub fn deref(t: t, explicit: bool) -> Option<mt> {\n     }\n }\n \n+pub fn deref_or_dont(t: t) -> t {\n+    match get(t).sty {\n+        ty_box(ty) | ty_uniq(ty) => {\n+            ty\n+        },\n+        ty_rptr(_, mt) | ty_ptr(mt) => mt.ty,\n+        _ => t\n+    }\n+}\n+\n pub fn close_type(cx: &ctxt, t: t) -> t {\n     match get(t).sty {\n         ty_open(t) => mk_rptr(cx, ReStatic, mt {ty: t, mutbl:ast::MutImmutable}),\n         _ => cx.sess.bug(format!(\"Trying to close a non-open type {}\",\n-                                 ty_to_str(cx, t)).as_slice())\n+                                 ty_to_string(cx, t)).as_slice())\n     }\n }\n \n@@ -3027,9 +3036,9 @@ pub fn index(ty: t) -> Option<t> {\n // This is exactly the same as the above, except it supports strings,\n // which can't actually be indexed.\n pub fn array_element_ty(t: t) -> Option<t> {\n-    match get(ty).sty {\n+    match get(t).sty {\n         ty_vec(t, _) => Some(t),\n-        ty_str => Some(ty: mk_u8()),\n+        ty_str => Some(mk_u8()),\n         _ => None\n     }\n }\n@@ -3361,20 +3370,19 @@ pub fn unsize_ty(cx: &ctxt,\n             }\n             _ => cx.sess.span_bug(span,\n                                   format!(\"UnsizeLength with bad sty: {}\",\n-                                          ty_to_str(cx, ty)).as_slice())\n+                                          ty_to_string(cx, ty)).as_slice())\n         },\n         &UnsizeStruct(box ref k, tp_index) => match get(ty).sty {\n             ty_struct(did, ref substs) => {\n-                let ty_substs = substs.types.get_vec(subst::TypeSpace);\n-                let old_ty = ty_substs.get(tp_index);\n-                let new_ty = unsize_ty(cx, *old_ty, k, span);\n+                let ty_substs = substs.types.get_slice(subst::TypeSpace);\n+                let new_ty = unsize_ty(cx, ty_substs[tp_index], k, span);\n                 let mut unsized_substs = substs.clone();\n-                *unsized_substs.types.get_mut_vec(subst::TypeSpace).get_mut(tp_index) = new_ty;\n+                unsized_substs.types.get_mut_slice(subst::TypeSpace)[tp_index] = new_ty;\n                 mk_struct(cx, did, unsized_substs)\n             }\n             _ => cx.sess.span_bug(span,\n                                   format!(\"UnsizeStruct with bad sty: {}\",\n-                                          ty_to_str(cx, ty)).as_slice())\n+                                          ty_to_string(cx, ty)).as_slice())\n         },\n         &UnsizeVtable(bounds, def_id, ref substs) => {\n             mk_trait(cx, def_id, substs.clone(), bounds)\n@@ -5333,6 +5341,7 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n             ty_tup(_) |\n             ty_param(_) |\n             ty_infer(_) |\n+            ty_open(_) |\n             ty_err => {}\n         }\n     })"}, {"sha": "2bfbc67bbeb0f93fd87acc8f301640ccc446462c", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -273,6 +273,18 @@ impl TypeFoldable for ty::Generics {\n     }\n }\n \n+impl TypeFoldable for ty::UnsizeKind {\n+    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::UnsizeKind {\n+        match *self {\n+            ty::UnsizeLength(len) => ty::UnsizeLength(len),\n+            ty::UnsizeStruct(box ref k, n) => ty::UnsizeStruct(box k.fold_with(folder), n),\n+            ty::UnsizeVtable(bounds, def_id, ref substs) => {\n+                ty::UnsizeVtable(bounds.fold_with(folder), def_id, substs.fold_with(folder))\n+            }\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // \"super\" routines: these are the default implementations for TypeFolder.\n //\n@@ -425,11 +437,11 @@ pub fn super_fold_autoref<T:TypeFolder>(this: &mut T,\n     match *autoref {\n         ty::AutoPtr(r, m, None) => ty::AutoPtr(this.fold_region(r), m, None),\n         ty::AutoPtr(r, m, Some(ref a)) => {\n-            ty::AutoPtr(this.fold_region(r), m, Some(box super_fold_autoref(this, a.clone())))\n+            ty::AutoPtr(this.fold_region(r), m, Some(box super_fold_autoref(this, &**a)))\n         }\n         ty::AutoUnsafe(m) => ty::AutoUnsafe(m),\n-        ty::AutoUnsize(ref k) => ty::AutoUnsize(k.clone()),\n-        ty::AutoUnsizeUniq(ref k) => ty::AutoUnsizeUniq(k.clone()),\n+        ty::AutoUnsize(ref k) => ty::AutoUnsize(k.fold_with(this)),\n+        ty::AutoUnsizeUniq(ref k) => ty::AutoUnsizeUniq(k.fold_with(this)),\n     }\n }\n "}, {"sha": "6bb17c90da2694350428356402e206e920d1da0b", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -947,7 +947,7 @@ impl<'a> LookupContext<'a> {\n     // [T, ..len] -> [T] or &[T] or &&[T]\n     fn auto_unsize_vec(&self, ty: ty::t, autoderefs: uint, len: uint) -> Option<MethodCallee> {\n         let tcx = self.tcx();\n-        debug!(\"auto_unsize_vec {}\", ppaux::ty_to_str(tcx, ty));\n+        debug!(\"auto_unsize_vec {}\", ppaux::ty_to_string(tcx, ty));\n \n         // First try to borrow to an unsized vec.\n         let entry = self.search_for_some_kind_of_autorefd_method(\n@@ -1330,7 +1330,7 @@ impl<'a> LookupContext<'a> {\n         match self.fcx.mk_subty(false, infer::Misc(span),\n                                 rcvr_ty, transformed_self_ty) {\n             Ok(_) => {}\n-            Err(e) => {\n+            Err(_) => {\n                 self.bug(format!(\n                         \"{} was a subtype of {} but now is not?\",\n                         self.ty_to_string(rcvr_ty),"}, {"sha": "02464e17bac84e41963d20e80538b7f0366d9b97", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 57, "deletions": 74, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -1149,7 +1149,7 @@ fn check_cast(fcx: &FnCtxt,\n     if ty::type_is_scalar(t_1) {\n         // Supply the type as a hint so as to influence integer\n         // literals and other things that might care.\n-        check_expr_with_hint(fcx, e, t_1)\n+        check_expr_with_expectation(fcx, e, ExpectCastableToType(t_1))\n     } else {\n         check_expr(fcx, e)\n     }\n@@ -2033,7 +2033,6 @@ fn check_argument_types(fcx: &FnCtxt,\n                 }\n \n                 check_expr_coercable_to_type(fcx, &**arg, formal_ty);\n-\n             }\n         }\n     }\n@@ -2428,12 +2427,12 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 // 'else' branch.\n                 let expected = match expected.only_has_type() {\n                     ExpectHasType(ety) => {\n-                        match infer::resolve_type(fcx.infcx(), ety, force_tvar) {\n+                        match infer::resolve_type(fcx.infcx(), Some(sp), ety, force_tvar) {\n                             Ok(rty) if !ty::type_is_ty_var(rty) => ExpectHasType(rty),\n                             _ => NoExpectation\n                         }\n                     }\n-                    None => None\n+                    _ => NoExpectation\n                 };\n                 check_block_with_expected(fcx, then_blk, expected);\n                 let then_ty = fcx.node_ty(then_blk.id);\n@@ -3067,23 +3066,6 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n     type ExprCheckerWithTy = fn(&FnCtxt, &ast::Expr, ty::t);\n \n-    fn check_fn_for_vec_elements_expected(fcx: &FnCtxt,\n-                                          expected: Expectation)\n-                                         -> (ExprCheckerWithTy, ty::t) {\n-        let tcx = fcx.ccx.tcx;\n-        let (coerce, t) = match expected {\n-            // If we're given an expected type, we can try to coerce to it\n-            ExpectHasType(t) if ty::type_is_vec(t) => (true, ty::sequence_element_type(tcx, t)),\n-            // Otherwise we just leave the type to be resolved later\n-            _ => (false, fcx.infcx().next_ty_var())\n-        };\n-        if coerce {\n-            (check_expr_coercable_to_type, t)\n-        } else {\n-            (check_expr_has_type, t)\n-        }\n-    }\n-\n     let tcx = fcx.ccx.tcx;\n     let id = expr.id;\n     match expr.node {\n@@ -3157,7 +3139,6 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         }\n       }\n       ast::ExprUnary(unop, ref oprnd) => {\n-        let expected = expected.only_has_type();\n         let expected_inner = expected.map(fcx, |sty| {\n             match unop {\n                 ast::UnBox | ast::UnUniq => match *sty {\n@@ -3328,7 +3309,6 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             }\n           },\n           Some(ref e) => {\n-              //check_expr_has_type(fcx, e, ret_ty);\n               check_expr_coercable_to_type(fcx, &**e, ret_ty);\n           }\n         }\n@@ -3483,12 +3463,15 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         check_cast(fcx, &**e, &**t, id, expr.span);\n       }\n       ast::ExprVec(ref args) => {\n-        let uty = unpack_expected(\n-            fcx, expected,\n-            |sty| match *sty {\n-                ty::ty_vec(ty, _) => Some(ty),\n-                _ => None\n-        });\n+        let uty = match expected {\n+            ExpectHasType(uty) => {\n+                match ty::get(uty).sty {\n+                        ty::ty_vec(ty, _) => Some(ty),\n+                        _ => None\n+                }\n+            }\n+            _ => None\n+        };\n \n         let typ = match uty {\n             Some(uty) => {\n@@ -3512,12 +3495,15 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         check_expr_has_type(fcx, &**count_expr, ty::mk_uint());\n         let count = ty::eval_repeat_count(fcx, &**count_expr);\n \n-        let uty = unpack_expected(\n-            fcx, expected,\n-            |sty| match *sty {\n-                ty::ty_vec(ty, _) => Some(ty),\n-                _ => None\n-        });\n+        let uty = match expected {\n+            ExpectHasType(uty) => {\n+                match ty::get(uty).sty {\n+                        ty::ty_vec(ty, _) => Some(ty),\n+                        _ => None\n+                }\n+            }\n+            _ => None\n+        };\n \n         let (element_ty, t) = match uty {\n             Some(uty) => {\n@@ -3552,17 +3538,14 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         let mut err_field = false;\n \n         let elt_ts = elts.iter().enumerate().map(|(i, e)| {\n-            let opt_hint = match flds {\n-                Some(ref fs) if i < fs.len() => ExpectHasType(*fs.get(i)),\n-                _ => NoExpectation\n-            };\n-            let t = match opt_hint {\n-                ExpectHasType(ety) => {\n+            let t = match flds {\n+                Some(ref fs) if i < fs.len() => {\n+                    let ety = *fs.get(i);\n                     check_expr_coercable_to_type(fcx, &**e, ety);\n                     ety\n                 }\n                 _ => {\n-                    check_expr_with_expectation(fcx, &**e, opt_hint);\n+                    check_expr_with_expectation(fcx, &**e, NoExpectation);\n                     fcx.expr_ty(&**e)\n                 }\n             };\n@@ -3942,42 +3925,42 @@ fn check_block_with_expected(fcx: &FnCtxt,\n         }\n         match blk.expr {\n             None => if any_err {\n-                fcx.write_error(blk.id);\n-            }\n-            else if any_bot {\n-                fcx.write_bot(blk.id);\n-            }\n-            else  {\n-                fcx.write_nil(blk.id);\n-            },\n-          Some(e) => {\n-            if any_bot && !warned {\n-                fcx.ccx\n-                   .tcx\n-                   .sess\n-                   .add_lint(lint::builtin::UNREACHABLE_CODE,\n-                             e.id,\n-                             e.span,\n-                             \"unreachable expression\".to_string());\n-            }\n-            let ety = match expected {\n-                ExpectHasType(ety) => {\n-                    check_expr_coercable_to_type(fcx, &*e, ety);\n-                    ety\n+                    fcx.write_error(blk.id);\n                 }\n-                _ => {\n-                    check_expr_with_expectation(fcx, &*e, expected);\n-                    fcx.expr_ty(e)\n+                else if any_bot {\n+                    fcx.write_bot(blk.id);\n                 }\n-            };\n+                else  {\n+                    fcx.write_nil(blk.id);\n+                },\n+            Some(e) => {\n+                if any_bot && !warned {\n+                    fcx.ccx\n+                       .tcx\n+                       .sess\n+                       .add_lint(lint::builtin::UNREACHABLE_CODE,\n+                                 e.id,\n+                                 e.span,\n+                                 \"unreachable expression\".to_string());\n+                }\n+                let ety = match expected {\n+                    ExpectHasType(ety) => {\n+                        check_expr_coercable_to_type(fcx, &*e, ety);\n+                        ety\n+                    }\n+                    _ => {\n+                        check_expr_with_expectation(fcx, &*e, expected);\n+                        fcx.expr_ty(&*e)\n+                    }\n+                };\n \n-            fcx.write_ty(blk.id, ety);\n-            if any_err {\n-                fcx.write_error(blk.id);\n-            } else if any_bot {\n-                fcx.write_bot(blk.id);\n+                fcx.write_ty(blk.id, ety);\n+                if any_err {\n+                    fcx.write_error(blk.id);\n+                } else if any_bot {\n+                    fcx.write_bot(blk.id);\n+                }\n             }\n-          }\n         };\n     });\n "}, {"sha": "530f8dd4b9ef66435e105e5251126eb70abd055e", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -810,7 +810,6 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                     }\n                 }\n                 AutoDerefRef(ref adj) => {\n-                    assert!(!ty::adjust_is_object(adjustment));\n                     for autoderef in range(0, adj.autoderefs) {\n                         let method_call = MethodCall::autoderef(ex.id, autoderef);\n                         match fcx.inh.method_map.borrow().find(&method_call) {\n@@ -831,9 +830,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                         }\n                     }\n                 }\n-                _ => {\n-                    assert!(!ty::adjust_is_object(adjustment));\n-                }\n+                _ => {}\n             }\n         }\n         None => {}\n@@ -867,27 +864,21 @@ fn trait_cast_types(fcx: &FnCtxt,\n                 }\n                 &ty::UnsizeStruct(box ref k, tp_index) => match ty::get(src_ty).sty {\n                     ty::ty_struct(_, ref substs) => {\n-                        let ty_substs = substs.types.get_vec(subst::TypeSpace);\n-                        let field_ty = *ty_substs.get(tp_index);\n-                        let field_ty = structurally_resolved_type(fcx, sp, field_ty);\n+                        let ty_substs = substs.types.get_slice(subst::TypeSpace);\n+                        let field_ty = structurally_resolved_type(fcx, sp, ty_substs[tp_index]);\n                         trait_cast_types_unsize(fcx, k, field_ty, sp)\n                     }\n                     _ => fail!(\"Failed to find a ty_struct to correspond with \\\n                                 UnsizeStruct whilst walking adjustment. Found {}\",\n-                                ppaux::ty_to_str(fcx.tcx(), src_ty))\n+                                ppaux::ty_to_string(fcx.tcx(), src_ty))\n                 },\n                 _ => None\n             }\n         }\n \n         match autoref {\n-            &ty::AutoUnsize(ref k) => trait_cast_types_unsize(fcx, k, src_ty, sp),\n-            &ty::AutoUnsizeUniq(ref k) => match k {\n-                &ty::UnsizeVtable(bounds, def_id, ref substs) => {\n-                    Some((src_ty, ty::mk_trait(fcx.tcx(), def_id, substs.clone(), bounds)))\n-                }\n-                _ => None\n-            },\n+            &ty::AutoUnsize(ref k) |\n+            &ty::AutoUnsizeUniq(ref k) => trait_cast_types_unsize(fcx, k, src_ty, sp),\n             &ty::AutoPtr(_, _, Some(box ref autoref)) => {\n                 trait_cast_types_autoref(fcx, autoref, src_ty, sp)\n             }"}, {"sha": "abf366381139cdead006d0d081137a2c9e6bcd10", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -199,8 +199,8 @@ impl<'f> Coerce<'f> {\n         }\n     }\n \n-    pub fn unpack_actual_value(&self, a: ty::t, f: |&ty::sty| -> CoerceResult)\n-                               -> CoerceResult {\n+    pub fn unpack_actual_value<T>(&self, a: ty::t, f: |&ty::sty| -> T)\n+                                  -> T {\n         match resolve_type(self.get_ref().infcx, None,\n                            a, try_resolve_tvar_shallow) {\n             Ok(t) => {\n@@ -306,7 +306,7 @@ impl<'f> Coerce<'f> {\n \n         let sty_b = &ty::get(b).sty;\n         match (sty_a, sty_b) {\n-            (&ty::ty_uniq(t_a), &ty::ty_rptr(_, mt_b)) => Err(ty::terr_mismatch),\n+            (&ty::ty_uniq(_), &ty::ty_rptr(..)) => Err(ty::terr_mismatch),\n             (&ty::ty_rptr(_, ty::mt{ty: t_a, ..}), &ty::ty_rptr(_, mt_b)) => {\n                 self.unpack_actual_value(t_a, |sty_a| {\n                     match self.unsize_ty(sty_a, mt_b.ty) {\n@@ -381,8 +381,8 @@ impl<'f> Coerce<'f> {\n                   if did_a == did_b => {\n                     debug!(\"unsizing a struct\");\n                     // Try unsizing each type param in turn to see if we end up with ty_b.\n-                    let ty_substs_a = substs_a.types.get_vec(subst::TypeSpace);\n-                    let ty_substs_b = substs_b.types.get_vec(subst::TypeSpace);\n+                    let ty_substs_a = substs_a.types.get_slice(subst::TypeSpace);\n+                    let ty_substs_b = substs_b.types.get_slice(subst::TypeSpace);\n                     assert!(ty_substs_a.len() == ty_substs_b.len());\n \n                     let sub = Sub(self.get_ref().clone());\n@@ -397,7 +397,7 @@ impl<'f> Coerce<'f> {\n                             Some((new_tp, k)) => {\n                                 // Check that the whole types match.\n                                 let mut new_substs = substs_a.clone();\n-                                *new_substs.types.get_mut_vec(subst::TypeSpace).get_mut(i) = new_tp;\n+                                new_substs.types.get_mut_slice(subst::TypeSpace)[i] = new_tp;\n                                 let ty = ty::mk_struct(tcx, did_a, new_substs);\n                                 if self.get_ref().infcx.try(|| sub.tys(ty, ty_b)).is_err() {\n                                     debug!(\"Unsized type parameter '{}', but still \\\n@@ -439,8 +439,7 @@ impl<'f> Coerce<'f> {\n         let r_a = self.get_ref().infcx.next_region_var(coercion);\n \n         let a_borrowed = match *sty_a {\n-            ty::ty_uniq(ty) => return Err(ty::terr_mismatch),\n-            ty::ty_rptr(_, ty::mt{ty, ..}) => match ty::get(ty).sty {\n+            ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => match ty::get(ty).sty {\n                 ty::ty_trait(box ty::TyTrait {\n                         def_id,\n                         ref substs,"}, {"sha": "5dff183108ce8f78290c96d27bb35413a4860400", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -370,7 +370,7 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n           buf.push_str(mt_to_string(cx, tm).as_slice());\n           buf\n       }\n-      ty_open(typ) => format!(\"opened<{}>\", ty_to_str(cx, typ)),\n+      ty_open(typ) => format!(\"opened<{}>\", ty_to_string(cx, typ)),\n       ty_tup(ref elems) => {\n         let strs: Vec<String> = elems.iter().map(|elem| ty_to_string(cx, *elem)).collect();\n         format!(\"({})\", strs.connect(\",\"))"}, {"sha": "bbaac7a96e9ee5df9dd3e33f3594e5aaffd89dd8", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -18,7 +18,6 @@ use std::path;\n use std::rc::Rc;\n use std::gc::{Gc, GC};\n use std::cell::{Cell, RefCell};\n-use std::strbuf::StrBuf;\n \n pub trait Encoder<E> {\n     // Primitive types:"}, {"sha": "01de001c043c748b8f65add177da2001a2b5628a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -61,7 +61,7 @@ use ast::{UnsafeFn, ViewItem, ViewItem_, ViewItemExternCrate, ViewItemUse};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::{Visibility, WhereClause, WherePredicate};\n use ast;\n-use ast_util::{as_prec, ident_to_path, lit_is_str, operator_prec};\n+use ast_util::{as_prec, ident_to_path, operator_prec};\n use ast_util;\n use attr;\n use codemap::{Span, BytePos, Spanned, spanned, mk_sp};\n@@ -2577,21 +2577,24 @@ impl<'a> Parser<'a> {\n             ex = self.mk_unary(UnUniq, e);\n           }\n           token::IDENT(_, _) => {\n-              if self.is_keyword(keywords::Box) {\n-                self.bump();\n+            if !self.is_keyword(keywords::Box) {\n+                return self.parse_dot_or_call_expr();\n+            }\n \n-                // Check for a place: `box(PLACE) EXPR`.\n-                if self.eat(&token::LPAREN) {\n-                    // Support `box() EXPR` as the default.\n-                    if !self.eat(&token::RPAREN) {\n-                        let place = self.parse_expr();\n-                        self.expect(&token::RPAREN);\n-                        let subexpression = self.parse_prefix_expr();\n-                        hi = subexpression.span.hi;\n-                        ex = ExprBox(place, subexpression);\n-                        return self.mk_expr(lo, hi, ex);\n-                    }\n+            self.bump();\n+\n+            // Check for a place: `box(PLACE) EXPR`.\n+            if self.eat(&token::LPAREN) {\n+                // Support `box() EXPR` as the default.\n+                if !self.eat(&token::RPAREN) {\n+                    let place = self.parse_expr();\n+                    self.expect(&token::RPAREN);\n+                    let subexpression = self.parse_prefix_expr();\n+                    hi = subexpression.span.hi;\n+                    ex = ExprBox(place, subexpression);\n+                    return self.mk_expr(lo, hi, ex);\n                 }\n+            }\n \n             // Otherwise, we use the unique pointer default.\n             let subexpression = self.parse_prefix_expr();"}, {"sha": "429a16ec5c89aee418cb8271ec270551f54ae065", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 5, "deletions": 32, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -268,19 +268,7 @@ pub struct Tm {\n     pub tm_nsec: i32,\n }\n \n-impl Tm {\n-    pub fn tm_zone<'a>(&'a self) -> &'a str {\n-        self.tm_zone.as_slice()\n-    }\n-}\n-\n pub fn empty_tm() -> Tm {\n-    // 64 is the max size of the timezone buffer allocated on windows\n-    // in rust_localtime. In glibc the max timezone size is supposedly 3.\n-    let mut zone = StrBuf::new();\n-    for _ in range(0, 64) {\n-        zone.push_char(' ')\n-    }\n     Tm {\n         tm_sec: 0_i32,\n         tm_min: 0_i32,\n@@ -292,7 +280,6 @@ pub fn empty_tm() -> Tm {\n         tm_yday: 0_i32,\n         tm_isdst: 0_i32,\n         tm_gmtoff: 0_i32,\n-        tm_zone: zone,\n         tm_nsec: 0_i32,\n     }\n }\n@@ -773,7 +760,6 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n           'Z' => {\n             if match_str(s, pos, \"UTC\") || match_str(s, pos, \"GMT\") {\n                 tm.tm_gmtoff = 0_i32;\n-                tm.tm_zone = \"UTC\".into_strbuf();\n                 Ok(pos + 3u)\n             } else {\n                 // It's odd, but to maintain compatibility with c's\n@@ -798,7 +784,6 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n                     let (v, pos) = item;\n                     if v == 0_i32 {\n                         tm.tm_gmtoff = 0_i32;\n-                        tm.tm_zone = \"UTC\".into_strbuf();\n                     }\n \n                     Ok(pos)\n@@ -828,7 +813,6 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n         tm_yday: 0_i32,\n         tm_isdst: 0_i32,\n         tm_gmtoff: 0_i32,\n-        tm_zone: StrBuf::new(),\n         tm_nsec: 0_i32,\n     };\n     let mut pos = 0u;\n@@ -875,7 +859,6 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n             tm_yday: tm.tm_yday,\n             tm_isdst: tm.tm_isdst,\n             tm_gmtoff: tm.tm_gmtoff,\n-            tm_zone: tm.tm_zone.clone(),\n             tm_nsec: tm.tm_nsec,\n         })\n     } else { result }\n@@ -1077,7 +1060,6 @@ pub fn strftime(format: &str, tm: &Tm) -> String {\n           'w' => (tm.tm_wday as int).to_string(),\n           'Y' => (tm.tm_year as int + 1900).to_string(),\n           'y' => format!(\"{:02d}\", (tm.tm_year as int + 1900) % 100),\n-          'Z' => tm.tm_zone.as_slice().to_owned(),\n           'z' => {\n             let sign = if tm.tm_gmtoff > 0_i32 { '+' } else { '-' };\n             let mut m = num::abs(tm.tm_gmtoff) / 60_i32;\n@@ -1203,7 +1185,6 @@ mod tests {\n         assert_eq!(utc.tm_yday, 43_i32);\n         assert_eq!(utc.tm_isdst, 0_i32);\n         assert_eq!(utc.tm_gmtoff, 0_i32);\n-        assert_eq!(utc.tm_zone(), \"UTC\");\n         assert_eq!(utc.tm_nsec, 54321_i32);\n     }\n \n@@ -1225,12 +1206,6 @@ mod tests {\n         assert_eq!(local.tm_yday, 43_i32);\n         assert_eq!(local.tm_isdst, 0_i32);\n         assert_eq!(local.tm_gmtoff, -28800_i32);\n-\n-        // FIXME (#2350): We should probably standardize on the timezone\n-        // abbreviation.\n-        let zone = local.tm_zone();\n-        assert!(zone == \"PST\" || zone == \"Pacific Standard Time\");\n-\n         assert_eq!(local.tm_nsec, 54321_i32);\n     }\n \n@@ -1273,7 +1248,6 @@ mod tests {\n             assert!(tm.tm_wday == 0_i32);\n             assert!(tm.tm_isdst == 0_i32);\n             assert!(tm.tm_gmtoff == 0_i32);\n-            assert!(tm.tm_zone() == \"\");\n             assert!(tm.tm_nsec == 0_i32);\n           }\n           Err(_) => ()\n@@ -1297,7 +1271,6 @@ mod tests {\n             assert!(tm.tm_yday == 0_i32);\n             assert!(tm.tm_isdst == 0_i32);\n             assert!(tm.tm_gmtoff == 0_i32);\n-            assert!(tm.tm_zone() == \"\");\n             assert!(tm.tm_nsec == 12340000_i32);\n           }\n         }\n@@ -1409,10 +1382,10 @@ mod tests {\n         assert!(test(\"6\", \"%w\"));\n         assert!(test(\"2009\", \"%Y\"));\n         assert!(test(\"09\", \"%y\"));\n-        assert!(strptime(\"UTC\", \"%Z\").unwrap().tm_zone() == \"UTC\");\n-        assert!(strptime(\"PST\", \"%Z\").unwrap().tm_zone() == \"\");\n-        assert!(strptime(\"-0000\", \"%z\").unwrap().tm_gmtoff == 0);\n-        assert!(strptime(\"-0800\", \"%z\").unwrap().tm_gmtoff == 0);\n+        assert!(strptime(\"-0000\", \"%z\").unwrap().tm_gmtoff ==\n+            0);\n+        assert!(strptime(\"-0800\", \"%z\").unwrap().tm_gmtoff ==\n+            0);\n         assert!(test(\"%\", \"%%\"));\n \n         // Test for #7256"}, {"sha": "c71cf5557e35f89f293056daa90de5762d71af75", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -46,9 +46,11 @@ pub trait UnicodeStrSlice<'a> {\n     ///\n     /// ```rust\n     /// let gr1 = \"a\\u0310e\\u0301o\\u0308\\u0332\".graphemes(true).collect::<Vec<&str>>();\n-    /// assert_eq!(gr1.as_slice(), &[\"a\\u0310\", \"e\\u0301\", \"o\\u0308\\u0332\"]);\n+    /// let b: &[_] = &[\"a\\u0310\", \"e\\u0301\", \"o\\u0308\\u0332\"];\n+    /// assert_eq!(gr1.as_slice(), b);\n     /// let gr2 = \"a\\r\\nb\ud83c\uddf7\ud83c\uddfa\ud83c\uddf8\ud83c\uddf9\".graphemes(true).collect::<Vec<&str>>();\n-    /// assert_eq!(gr2.as_slice(), &[\"a\", \"\\r\\n\", \"b\", \"\ud83c\uddf7\ud83c\uddfa\ud83c\uddf8\ud83c\uddf9\"]);\n+    /// let b: &[_] = &[\"a\", \"\\r\\n\", \"b\", \"\ud83c\uddf7\ud83c\uddfa\ud83c\uddf8\ud83c\uddf9\"];\n+    /// assert_eq!(gr2.as_slice(), b);\n     /// ```\n     fn graphemes(&self, is_extended: bool) -> Graphemes<'a>;\n \n@@ -59,7 +61,8 @@ pub trait UnicodeStrSlice<'a> {\n     ///\n     /// ```rust\n     /// let gr_inds = \"a\u0310e\u0301o\u0308\u0332\\r\\n\".grapheme_indices(true).collect::<Vec<(uint, &str)>>();\n-    /// assert_eq!(gr_inds.as_slice(), &[(0u, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")]);\n+    /// let b: &[_] = &[(0u, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")];\n+    /// assert_eq!(gr_inds.as_slice(), b);\n     /// ```\n     fn grapheme_indices(&self, is_extended: bool) -> GraphemeIndices<'a>;\n "}, {"sha": "b5ffdef22e968dac5531f33fd210cacbdb41bfe9", "filename": "src/liburl/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Fliburl%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Fliburl%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliburl%2Flib.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -1095,7 +1095,8 @@ mod tests {\n         t(\"\\0\", \"%00\");\n         t(\"\\n\", \"%0A\");\n \n-        t(&[0u8, 10, 37], \"%00%0A%25\");\n+        let a: &[_] = &[0u8, 10, 37];\n+        t(a, \"%00%0A%25\");\n     }\n \n     #[test]\n@@ -1130,7 +1131,8 @@ mod tests {\n         t(\"\\0\", \"%00\");\n         t(\"\\n\", \"%0A\");\n \n-        t(&[0u8, 10, 37], \"%00%0A%25\");\n+        let a: &[_] = &[0u8, 10, 37];\n+        t(a, \"%00%0A%25\");\n     }\n \n     #[test]"}, {"sha": "ba20f2c6f27f9fca7b9404cb90564be862331cdd", "filename": "src/rt/rust_builtin.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Frt%2Frust_builtin.c", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Frt%2Frust_builtin.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.c?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -127,15 +127,6 @@ rust_list_dir_wfd_fp_buf(void* wfd) {\n }\n #endif\n \n-typedef struct\n-{\n-    size_t fill;    // in bytes; if zero, heapified\n-    size_t alloc;   // in bytes\n-    uint8_t *data;\n-} rust_vec;\n-\n-typedef rust_vec rust_str_buf;\n-\n typedef struct {\n     int32_t tm_sec;\n     int32_t tm_min;\n@@ -147,7 +138,6 @@ typedef struct {\n     int32_t tm_yday;\n     int32_t tm_isdst;\n     int32_t tm_gmtoff;\n-    rust_str_buf tm_zone;\n     int32_t tm_nsec;\n } rust_tm;\n \n@@ -164,8 +154,10 @@ void rust_tm_to_tm(rust_tm* in_tm, struct tm* out_tm) {\n     out_tm->tm_isdst = in_tm->tm_isdst;\n }\n \n-void tm_to_rust_tm(struct tm* in_tm, rust_tm* out_tm, int32_t gmtoff,\n-                   const char *zone, int32_t nsec) {\n+void tm_to_rust_tm(struct tm* in_tm,\n+                   rust_tm* out_tm,\n+                   int32_t gmtoff,\n+                   int32_t nsec) {\n     out_tm->tm_sec = in_tm->tm_sec;\n     out_tm->tm_min = in_tm->tm_min;\n     out_tm->tm_hour = in_tm->tm_hour;\n@@ -177,13 +169,6 @@ void tm_to_rust_tm(struct tm* in_tm, rust_tm* out_tm, int32_t gmtoff,\n     out_tm->tm_isdst = in_tm->tm_isdst;\n     out_tm->tm_gmtoff = gmtoff;\n     out_tm->tm_nsec = nsec;\n-\n-    if (zone != NULL) {\n-        size_t size = strlen(zone);\n-        assert(out_tm->tm_zone.alloc >= size);\n-        memcpy(out_tm->tm_zone.data, zone, size);\n-        out_tm->tm_zone.fill = size;\n-    }\n }\n \n #if defined(__WIN32__)\n@@ -225,7 +210,7 @@ rust_gmtime(int64_t sec, int32_t nsec, rust_tm *timeptr) {\n     time_t s = sec;\n     GMTIME(&s, &tm);\n \n-    tm_to_rust_tm(&tm, timeptr, 0, \"UTC\", nsec);\n+    tm_to_rust_tm(&tm, timeptr, 0, nsec);\n }\n \n void\n@@ -234,28 +219,13 @@ rust_localtime(int64_t sec, int32_t nsec, rust_tm *timeptr) {\n     time_t s = sec;\n     LOCALTIME(&s, &tm);\n \n-    const char* zone = NULL;\n #if defined(__WIN32__)\n     int32_t gmtoff = -timezone;\n-    wchar_t wbuffer[64] = {0};\n-    char buffer[256] = {0};\n-    // strftime(\"%Z\") can contain non-UTF-8 characters on non-English locale (issue #9418),\n-    // so time zone should be converted from UTF-16 string.\n-    // Since wcsftime depends on setlocale() result,\n-    // instead we convert it using MultiByteToWideChar.\n-    if (strftime(buffer, sizeof(buffer) / sizeof(char), \"%Z\", &tm) > 0) {\n-        // ANSI -> UTF-16\n-        MultiByteToWideChar(CP_ACP, 0, buffer, -1, wbuffer, sizeof(wbuffer) / sizeof(wchar_t));\n-        // UTF-16 -> UTF-8\n-        WideCharToMultiByte(CP_UTF8, 0, wbuffer, -1, buffer, sizeof(buffer), NULL, NULL);\n-        zone = buffer;\n-    }\n #else\n     int32_t gmtoff = tm.tm_gmtoff;\n-    zone = tm.tm_zone;\n #endif\n \n-    tm_to_rust_tm(&tm, timeptr, gmtoff, zone, nsec);\n+    tm_to_rust_tm(&tm, timeptr, gmtoff, nsec);\n }\n \n int64_t"}, {"sha": "6b8e126db7790a51989b47f8ff98a65125090266", "filename": "src/test/compile-fail/const-cast-different-types.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Fcompile-fail%2Fconst-cast-different-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Fcompile-fail%2Fconst-cast-different-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-cast-different-types.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -9,8 +9,10 @@\n // except according to those terms.\n \n static a: &'static str = \"foo\";\n-static b: *const u8 = a as *const u8; //~ ERROR mismatched types: expected `*u8` but found `&'static str`\n-static c: *const u8 = &a as *const u8; //~ ERROR mismatched types: expected `*u8` but found `&&'static str`\n+static b: *const u8 = a as *const u8;\n+//~^ ERROR mismatched types: expected `*const u8`, found `&'static str`\n+static c: *const u8 = &a as *const u8;\n+//~^ ERROR mismatched types: expected `*const u8`, found `&&'static str`\n \n fn main() {\n }"}, {"sha": "08e51038104365e985b2d2599f8f604293600c26", "filename": "src/test/compile-fail/dst-bad-assign-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign-2.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -10,7 +10,7 @@\n \n // Forbid assignment into a dynamically sized type.\n \n-struct Fat<type T> {\n+struct Fat<Sized? T> {\n     f1: int,\n     f2: &'static str,\n     ptr: T"}, {"sha": "17149941a7e1a4c0e6787d49947cabea02e25a72", "filename": "src/test/compile-fail/dst-bad-assign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -10,7 +10,7 @@\n \n // Forbid assignment into a dynamically sized type.\n \n-struct Fat<type T> {\n+struct Fat<Sized? T> {\n     f1: int,\n     f2: &'static str,\n     ptr: T\n@@ -42,5 +42,5 @@ pub fn main() {\n     // Assignment.\n     let f5: &mut Fat<ToBar> = &mut Fat { f1: 5, f2: \"some str\", ptr: Bar1 {f :42} };\n     let z: Box<ToBar> = box Bar1 {f: 36};\n-    f5.ptr = Bar1 {f: 36}; //~ ERROR mismatched types: expected `ToBar` but found `Bar1`\n+    f5.ptr = Bar1 {f: 36}; //~ ERROR mismatched types: expected `ToBar`, found `Bar1`\n }"}, {"sha": "a609740eaebf50c1e0be78b50a774037c805eacf", "filename": "src/test/compile-fail/dst-bad-coerce1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -10,7 +10,7 @@\n \n // Attempt to change the type as well as unsizing.\n \n-struct Fat<type T> {\n+struct Fat<Sized? T> {\n     ptr: T\n }\n \n@@ -22,7 +22,7 @@ pub fn main() {\n     let f1 = Fat { ptr: [1, 2, 3] };\n     let f2: &Fat<[int, ..3]> = &f1;\n     let f3: &Fat<[uint]> = f2;\n-    //~^ ERROR mismatched types: expected `&Fat<[uint]>` but found `&Fat<[int, .. 3]>`\n+    //~^ ERROR mismatched types: expected `&Fat<[uint]>`, found `&Fat<[int, .. 3]>`\n \n     // With a trait.\n     let f1 = Fat { ptr: Foo };"}, {"sha": "118e4ce7e08340ac015bd7e0168805d82219c530", "filename": "src/test/compile-fail/dst-bad-coerce2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -10,7 +10,7 @@\n \n // Attempt to change the mutability as well as unsizing.\n \n-struct Fat<type T> {\n+struct Fat<Sized? T> {\n     ptr: T\n }\n "}, {"sha": "7cf647a26d7a7ef89fb318449d7d3a7619aa0020", "filename": "src/test/compile-fail/dst-bad-coerce3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce3.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -10,7 +10,7 @@\n \n // Attempt to extend the lifetime as well as unsizing.\n \n-struct Fat<type T> {\n+struct Fat<Sized? T> {\n     ptr: T\n }\n "}, {"sha": "9a192334997d28e47ad939fa2bef2b3af7748652", "filename": "src/test/compile-fail/dst-bad-coerce4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce4.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -10,13 +10,13 @@\n \n // Attempt to coerce from unsized to sized.\n \n-struct Fat<type T> {\n+struct Fat<Sized? T> {\n     ptr: T\n }\n \n pub fn main() {\n     // With a vec of ints.\n     let f1: &Fat<[int]> = &Fat { ptr: [1, 2, 3] };\n     let f2: &Fat<[int, ..3]> = f1;\n-    //~^ ERROR  mismatched types: expected `&Fat<[int, .. 3]>` but found `&Fat<[int]>`\n+    //~^ ERROR mismatched types: expected `&Fat<[int, .. 3]>`, found `&Fat<[int]>`\n }"}, {"sha": "cf526392283304bc0274daf84700e50577a7c8be", "filename": "src/test/compile-fail/dst-bad-deep.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Fcompile-fail%2Fdst-bad-deep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Fcompile-fail%2Fdst-bad-deep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-deep.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -13,7 +13,7 @@\n // because it would require stack allocation of an unsized temporary (*g in the\n // test).\n \n-struct Fat<type T> {\n+struct Fat<Sized? T> {\n     ptr: T\n }\n "}, {"sha": "ab9f7a8453078b0beb77decdf7120b5609e4c27a", "filename": "src/test/compile-fail/issue-3907-2.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Fcompile-fail%2Fissue-3907-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Fcompile-fail%2Fissue-3907-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3907-2.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -11,10 +11,12 @@\n // aux-build:issue_3907.rs\n extern crate issue_3907;\n \n-type Foo = issue_3907::Foo; //~ ERROR: reference to trait\n+type Foo = issue_3907::Foo;\n \n struct S {\n     name: int\n }\n \n+fn bar(_x: Foo) {} //~ ERROR variable `_x` has dynamically sized type `issue_3907::Foo`\n+\n fn main() {}"}, {"sha": "199bc3f5c29d9a22a060528fbd99efa768c6b357", "filename": "src/test/compile-fail/issue-4972.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Fcompile-fail%2Fissue-4972.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Fcompile-fail%2Fissue-4972.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4972.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -17,7 +17,7 @@ pub enum TraitWrapper {\n \n fn get_tw_map(tw: &TraitWrapper) -> &MyTrait {\n     match *tw {\n-        A(box ref map) => map, //~ ERROR mismatched types: expected `Box<MyTrait>` but found a box\n+        A(box ref map) => map, //~ ERROR type `Box<MyTrait>` cannot be dereferenced\n     }\n }\n "}, {"sha": "689b8f7c6136043d9e4dbb42342c704a716715f7", "filename": "src/test/compile-fail/issue-5035-2.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Fcompile-fail%2Fissue-5035-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Fcompile-fail%2Fissue-5035-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5035-2.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n trait I {}\n-type K = I; //~ ERROR: reference to trait\n+type K = I;\n+\n+fn foo(_x: K) {} //~ ERROR: variable `_x` has dynamically sized type `I`\n \n fn main() {}"}, {"sha": "14136d96c2dffc71dec1413da0f3217f927a5795", "filename": "src/test/compile-fail/issue-5883.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Fcompile-fail%2Fissue-5883.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Fcompile-fail%2Fissue-5883.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5883.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -16,7 +16,7 @@ struct Struct {\n \n fn new_struct(r: A) -> Struct {\n     //~^ ERROR variable `r` has dynamically sized type `A`\n-    Struct { r: r }\n+    Struct { r: r } //~ ERROR trying to initialise a dynamically sized struct\n }\n \n trait Curve {}"}, {"sha": "ef585998aa5a5b5ce83f95475c176d5c0d04783d", "filename": "src/test/compile-fail/issue-7013.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -32,7 +32,7 @@ struct A {\n \n fn main() {\n     let a = A {v: box B{v: None} as Box<Foo+Send>};\n-    //~^ ERROR cannot pack type `Box<B>` as a trait bounded by Send because the type does not fulfil\n+    //~^ ERROR cannot pack type `Box<B>`, which does not fulfill `Send`, as a trait bounded by Send\n     let v = Rc::new(RefCell::new(a));\n     let w = v.clone();\n     let b = &*v;"}, {"sha": "1500a3cbe52db8df89ba0a5b382716b16bb28543", "filename": "src/test/compile-fail/tuple-arity-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Fcompile-fail%2Ftuple-arity-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Fcompile-fail%2Ftuple-arity-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftuple-arity-mismatch.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -13,6 +13,6 @@\n fn first((value, _): (int, f64)) -> int { value }\n \n fn main() {\n-    let y = first ((1,2,3));\n+    let y = first ((1,2.0,3));\n     //~^ ERROR expected a tuple with 2 elements, found one with 3 elements\n }"}, {"sha": "7f93c8595f2a2721dd2b001848fdd9c0df606eb9", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -48,8 +48,8 @@\n                        as core::fmt::rt::Piece<'static>)] as\n                      [core::fmt::rt::Piece<'static>, .. 1]);\n              let __args_vec =\n-                 (&([] as &'static [core::fmt::Argument<'static>]) as\n-                     &'static [core::fmt::Argument<'static>]);\n+                 (&([] as [core::fmt::Argument<'static>, .. 0]) as\n+                     &'static [core::fmt::Argument<'static>, .. 0]);\n              let __args =\n                  (unsafe {\n                       ((::std::fmt::Arguments::new as\n@@ -58,7 +58,7 @@\n                                                                                                                                                [core::fmt::rt::Piece<'static>, .. 1]),\n                                                                                                                                            (__args_vec\n                                                                                                                                                as\n-                                                                                                                                               &'static [core::fmt::Argument<'static>]))\n+                                                                                                                                               &'static [core::fmt::Argument<'static>, .. 0]))\n                           as core::fmt::Arguments<'static>)\n                   } as core::fmt::Arguments<'static>);\n "}, {"sha": "77ee0df5512ef05484f444c167dba6716bab8e84", "filename": "src/test/run-make/graphviz-flowgraph/f15.dot-expected.dot", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff15.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff15.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff15.dot-expected.dot?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -47,7 +47,7 @@ digraph block {\n     N10 -> N11;\n     N11 -> N12;\n     N12 -> N13;\n-    N13 -> N7[label=\"exiting scope_0 expr break \\'outer,\\lexiting scope_1 stmt break \\'outer ;,\\lexiting scope_2 block { break \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if x == 1i { break \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if x == 1i { break \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 2i { break ; \\\"unreachable\\\"; }\\l    y -= 3;\\l}\\l,\\lexiting scope_6 expr \\'inner:\\l    loop  {\\l        if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2 { break ; \\\"unreachable\\\"; }\\l        y -= 3;\\l    }\\l,\\lexiting scope_7 stmt \\'inner:\\l    loop  {\\l        if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2 { break ; \\\"unreachable\\\"; }\\l        y -= 3;\\l    }\\l,\\lexiting scope_8 block {\\l    \\'inner:\\l        loop  {\\l            if x == 1 { break \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 2 { break ; \\\"unreachable\\\"; }\\l            y -= 3;\\l        }\\l    y -= 4;\\l    x -= 5;\\l}\\l\"];\n+    N13 -> N7[label=\"exiting scope_0 expr break \\'outer,\\lexiting scope_1 stmt break \\'outer ;,\\lexiting scope_2 block { break \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if x == 1i { break \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if x == 1i { break \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 2i { break ; \\\"unreachable\\\"; }\\l    y -= 3i;\\l}\\l,\\lexiting scope_6 expr \\'inner:\\l    loop  {\\l        if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2i { break ; \\\"unreachable\\\"; }\\l        y -= 3i;\\l    }\\l,\\lexiting scope_7 stmt \\'inner:\\l    loop  {\\l        if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2i { break ; \\\"unreachable\\\"; }\\l        y -= 3i;\\l    }\\l,\\lexiting scope_8 block {\\l    \\'inner:\\l        loop  {\\l            if x == 1i { break \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 2i { break ; \\\"unreachable\\\"; }\\l            y -= 3i;\\l        }\\l    y -= 4i;\\l    x -= 5i;\\l}\\l\"];\n     N14 -> N15;\n     N15 -> N16;\n     N12 -> N17;"}, {"sha": "b5a867e60297f8202557870ebcbedbf550a883fb", "filename": "src/test/run-make/graphviz-flowgraph/f16.dot-expected.dot", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff16.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff16.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff16.dot-expected.dot?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -29,7 +29,7 @@ digraph block {\n     N27[label=\"expr y\"];\n     N28[label=\"expr y -= 1i\"];\n     N29[label=\"block {\\l    if x == 1i { continue \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 1i { break ; \\\"unreachable\\\"; }\\l    y -= 1i;\\l}\\l\"];\n-    N30[label=\"expr 1\"];\n+    N30[label=\"expr 1i\"];\n     N31[label=\"expr y\"];\n     N32[label=\"expr y -= 1i\"];\n     N33[label=\"expr 1i\"];"}, {"sha": "6e2ae117ce7ae97d44728a4c6aa60a9cf0c49213", "filename": "src/test/run-pass/dst-dtor-1.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Frun-pass%2Fdst-dtor-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Frun-pass%2Fdst-dtor-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-dtor-1.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static mut DROP_RAN: bool = false;\n+\n+struct Foo;\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        unsafe { DROP_RAN = true; }\n+    }\n+}\n+\n+trait Trait {}\n+impl Trait for Foo {}\n+\n+struct Fat<Sized? T> {\n+    f: T\n+}\n+\n+pub fn main() {\n+    {\n+        let _x: Box<Fat<Trait>> = box Fat { f: Foo };\n+    }\n+    unsafe {\n+        assert!(DROP_RAN);\n+    }\n+}"}, {"sha": "deaf49228bc842810c92f671134d5dcb7843f530", "filename": "src/test/run-pass/dst-dtor-2.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Frun-pass%2Fdst-dtor-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Frun-pass%2Fdst-dtor-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-dtor-2.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static mut DROP_RAN: int = 0;\n+\n+struct Foo;\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        unsafe { DROP_RAN += 1; }\n+    }\n+}\n+\n+struct Fat<Sized? T> {\n+    f: T\n+}\n+\n+pub fn main() {\n+    {\n+        let _x: Box<Fat<[Foo]>> = box Fat { f: [Foo, Foo, Foo] };\n+    }\n+    unsafe {\n+        assert!(DROP_RAN == 3);\n+    }\n+}"}, {"sha": "2028ebf64c217afd68e71edeaa0a015d23183188", "filename": "src/test/run-pass/dst-struct-reflect.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Frun-pass%2Fdst-struct-reflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Frun-pass%2Fdst-struct-reflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-struct-reflect.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -8,11 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// FIXME(15049) Re-enable this test.\n+// ignore-test\n // Test that structs with unsized fields work with {:?} reflection.\n \n extern crate debug;\n \n-struct Fat<type T> {\n+struct Fat<Sized? T> {\n     f1: int,\n     f2: &'static str,\n     ptr: T"}, {"sha": "04fe6d5cefdc39b8d55382fcaca928bc43e2f4b8", "filename": "src/test/run-pass/dst-struct-sole.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Frun-pass%2Fdst-struct-sole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Frun-pass%2Fdst-struct-sole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-struct-sole.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -10,7 +10,7 @@\n \n // As dst-struct.rs, but the unsized field is the only field in the struct.\n \n-struct Fat<type T> {\n+struct Fat<Sized? T> {\n     ptr: T\n }\n "}, {"sha": "6b8e25e85590f6aaa2d57bbcf84e306885f9465e", "filename": "src/test/run-pass/dst-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Frun-pass%2Fdst-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Frun-pass%2Fdst-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-struct.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct Fat<type T> {\n+struct Fat<Sized? T> {\n     f1: int,\n     f2: &'static str,\n     ptr: T"}, {"sha": "976273095510402e0fa93ba56c80041990b11a7f", "filename": "src/test/run-pass/dst-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Frun-pass%2Fdst-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Frun-pass%2Fdst-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-trait.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct Fat<type T> {\n+struct Fat<Sized? T> {\n     f1: int,\n     f2: &'static str,\n     ptr: T"}, {"sha": "430ee16bc8a26682078697fd3d7fc92d517851a6", "filename": "src/test/run-pass/gc-vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Frun-pass%2Fgc-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Frun-pass%2Fgc-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgc-vec.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -12,11 +12,11 @@ use std::gc::{GC};\n \n fn main() {\n     // A fixed-size array allocated in a garbage-collected box\n-    let x = box(GC) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    let x = box(GC) [1i, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n     assert_eq!(x[0], 1);\n     assert_eq!(x[6], 7);\n     assert_eq!(x[9], 10);\n \n     let y = x;\n-    assert!(*y == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n+    assert!(*y == [1i, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n }"}, {"sha": "0aca74c76c3e78aace1b8cb9943886d06177aaeb", "filename": "src/test/run-pass/issue-14936.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Frun-pass%2Fissue-14936.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Frun-pass%2Fissue-14936.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14936.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -30,7 +30,8 @@ macro_rules! demo {\n                      : \"r\"(&wrap(y, \"in\", &mut history)));\n             }\n             assert_eq!((x,y), (1,1));\n-            assert_eq!(history.as_slice(), &[\"out\", \"in\"]);\n+            let b: &[_] = &[\"out\", \"in\"];\n+            assert_eq!(history.as_slice(), b);\n         }\n     }\n }"}, {"sha": "444e8bd37707e7273ed3f8221f75f723d2b41e3b", "filename": "src/test/run-pass/issue-15080.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Frun-pass%2Fissue-15080.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Frun-pass%2Fissue-15080.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15080.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    let mut x = &[1i, 2, 3, 4];\n+    let mut x: &[_] = &[1i, 2, 3, 4];\n \n     let mut result = vec!();\n     loop {"}, {"sha": "de1bb02bfefc675964c5a482975ddcc741538572", "filename": "src/test/run-pass/match-vec-alternatives.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Frun-pass%2Fmatch-vec-alternatives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Frun-pass%2Fmatch-vec-alternatives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-vec-alternatives.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -68,15 +68,21 @@ fn main() {\n     assert_eq!(match_vecs_snoc::<uint>(&[], &[]), \"both empty\");\n     assert_eq!(match_vecs_snoc(&[1i, 2, 3], &[]), \"one empty\");\n \n-    assert_eq!(match_nested_vecs_cons(None, Ok(&[4u, 2u])), \"None, Ok(at least two elements)\");\n+    assert_eq!(match_nested_vecs_cons(None, Ok::<&[_], ()>(&[4u, 2u])),\n+               \"None, Ok(at least two elements)\");\n     assert_eq!(match_nested_vecs_cons::<uint>(None, Err(())), \"None, Ok(less than one element)\");\n-    assert_eq!(match_nested_vecs_cons::<bool>(Some(&[]), Ok(&[])), \"Some(empty), Ok(empty)\");\n-    assert_eq!(match_nested_vecs_cons(Some(&[1i]), Err(())), \"Some(non-empty), any\");\n-    assert_eq!(match_nested_vecs_cons(Some(&[(42i, ())]), Ok(&[(1i, ())])), \"Some(non-empty), any\");\n+    assert_eq!(match_nested_vecs_cons::<bool>(Some::<&[_]>(&[]), Ok::<&[_], ()>(&[])),\n+               \"Some(empty), Ok(empty)\");\n+    assert_eq!(match_nested_vecs_cons(Some::<&[_]>(&[1i]), Err(())), \"Some(non-empty), any\");\n+    assert_eq!(match_nested_vecs_cons(Some::<&[_]>(&[(42i, ())]), Ok::<&[_], ()>(&[(1i, ())])),\n+               \"Some(non-empty), any\");\n \n-    assert_eq!(match_nested_vecs_snoc(None, Ok(&[4u, 2u])), \"None, Ok(at least two elements)\");\n+    assert_eq!(match_nested_vecs_snoc(None, Ok::<&[_], ()>(&[4u, 2u])),\n+               \"None, Ok(at least two elements)\");\n     assert_eq!(match_nested_vecs_snoc::<uint>(None, Err(())), \"None, Ok(less than one element)\");\n-    assert_eq!(match_nested_vecs_snoc::<bool>(Some(&[]), Ok(&[])), \"Some(empty), Ok(empty)\");\n-    assert_eq!(match_nested_vecs_snoc(Some(&[1i]), Err(())), \"Some(non-empty), any\");\n-    assert_eq!(match_nested_vecs_snoc(Some(&[(42i, ())]), Ok(&[(1i, ())])), \"Some(non-empty), any\");\n+    assert_eq!(match_nested_vecs_snoc::<bool>(Some::<&[_]>(&[]), Ok::<&[_], ()>(&[])),\n+               \"Some(empty), Ok(empty)\");\n+    assert_eq!(match_nested_vecs_snoc(Some::<&[_]>(&[1i]), Err(())), \"Some(non-empty), any\");\n+    assert_eq!(match_nested_vecs_snoc(Some::<&[_]>(&[(42i, ())]), Ok::<&[_], ()>(&[(1i, ())])),\n+               \"Some(non-empty), any\");\n }"}, {"sha": "9a76beac9e5f75c49c160750bae829f82cc5e70a", "filename": "src/test/run-pass/order-drop-with-match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Frun-pass%2Forder-drop-with-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Frun-pass%2Forder-drop-with-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Forder-drop-with-match.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -59,6 +59,7 @@ fn main() {\n         }\n     }\n     unsafe {\n-        assert_eq!(&[1, 2, 3], ORDER.as_slice());\n+        let expected: &[_] = &[1, 2, 3];\n+        assert_eq!(expected, ORDER.as_slice());\n     }\n }"}, {"sha": "e95495a42d2823bac8292c3e521469c61ee52abb", "filename": "src/test/run-pass/vec-matching.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Frun-pass%2Fvec-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Frun-pass%2Fvec-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -72,7 +72,8 @@ fn d() {\n }\n \n fn e() {\n-    match &[1i, 2, 3] {\n+    let x: &[int] = &[1i, 2, 3];\n+    match x {\n         [1, 2] => (),\n         [..] => ()\n     }"}, {"sha": "52e0ba89479f555340f95043ad9b916573f84a67", "filename": "src/test/run-pass/vec-to_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Frun-pass%2Fvec-to_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ef46251ede1ff51e5d5621d5fe2614e950f963/src%2Ftest%2Frun-pass%2Fvec-to_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-to_str.rs?ref=52ef46251ede1ff51e5d5621d5fe2614e950f963", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n pub fn main() {\n-    assert_eq!((vec!(0, 1)).to_string(), \"[0, 1]\".to_string());\n+    assert_eq!((vec!(0i, 1)).to_string(), \"[0, 1]\".to_string());\n \n-    let foo = vec!(3, 4);\n+    let foo = vec!(3i, 4);\n     let bar: &[int] = &[4, 5];\n \n     assert_eq!(foo.to_string(), \"[3, 4]\".to_string());"}]}