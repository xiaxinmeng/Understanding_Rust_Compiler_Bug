{"sha": "ebe21ac23a8a259079c9c59669c1d7da1fa88d0c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViZTIxYWMyM2E4YTI1OTA3OWM5YzU5NjY5YzFkN2RhMWZhODhkMGM=", "commit": {"author": {"name": "Oli Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2021-07-16T17:34:23Z"}, "committer": {"name": "Oli Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2021-07-16T17:37:28Z"}, "message": "Infer all inference variables via InferCx\n\nThe previous algorithm was correct for the example given in its\ndocumentation, but when the TAIT was declared as a free item\ninstead of an associated item, the generic parameters were the\nwrong ones.", "tree": {"sha": "15f01407a16b698ee3ee9e7d31008c6c7888d8cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15f01407a16b698ee3ee9e7d31008c6c7888d8cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ebe21ac23a8a259079c9c59669c1d7da1fa88d0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ebe21ac23a8a259079c9c59669c1d7da1fa88d0c", "html_url": "https://github.com/rust-lang/rust/commit/ebe21ac23a8a259079c9c59669c1d7da1fa88d0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ebe21ac23a8a259079c9c59669c1d7da1fa88d0c/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24a8d3bce38607b385f19571d5120b892b18ae9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/24a8d3bce38607b385f19571d5120b892b18ae9a", "html_url": "https://github.com/rust-lang/rust/commit/24a8d3bce38607b385f19571d5120b892b18ae9a"}], "stats": {"total": 180, "additions": 36, "deletions": 144}, "files": [{"sha": "f1fa964628b330ca901d1223b9e11f3983f25c11", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebe21ac23a8a259079c9c59669c1d7da1fa88d0c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe21ac23a8a259079c9c59669c1d7da1fa88d0c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=ebe21ac23a8a259079c9c59669c1d7da1fa88d0c", "patch": "@@ -856,7 +856,7 @@ impl<'tcx> InstantiatedPredicates<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, HashStable, TyEncodable, TyDecodable, TypeFoldable)]\n pub struct OpaqueTypeKey<'tcx> {\n     pub def_id: DefId,\n     pub substs: SubstsRef<'tcx>,"}, {"sha": "34d0908bcc74ea2df8f1aad5e16ef24a5f869537", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 1, "deletions": 116, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/ebe21ac23a8a259079c9c59669c1d7da1fa88d0c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe21ac23a8a259079c9c59669c1d7da1fa88d0c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=ebe21ac23a8a259079c9c59669c1d7da1fa88d0c", "patch": "@@ -112,11 +112,9 @@ use rustc_hir::{HirIdMap, ImplicitSelfKind, Node};\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::Idx;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::subst::{InternalSubsts, Subst, SubstsRef};\n-use rustc_middle::ty::{self, RegionKind, Ty, TyCtxt, UserType};\n+use rustc_middle::ty::{self, Ty, TyCtxt, UserType};\n use rustc_session::config;\n use rustc_session::parse::feature_err;\n use rustc_session::Session;\n@@ -321,117 +319,6 @@ fn used_trait_imports(tcx: TyCtxt<'_>, def_id: LocalDefId) -> &FxHashSet<LocalDe\n     &*tcx.typeck(def_id).used_trait_imports\n }\n \n-/// Inspects the substs of opaque types, replacing any inference variables\n-/// with proper generic parameter from the identity substs.\n-///\n-/// This is run after we normalize the function signature, to fix any inference\n-/// variables introduced by the projection of associated types. This ensures that\n-/// any opaque types used in the signature continue to refer to generic parameters,\n-/// allowing them to be considered for defining uses in the function body\n-///\n-/// For example, consider this code.\n-///\n-/// ```rust\n-/// trait MyTrait {\n-///     type MyItem;\n-///     fn use_it(self) -> Self::MyItem\n-/// }\n-/// impl<T, I> MyTrait for T where T: Iterator<Item = I> {\n-///     type MyItem = impl Iterator<Item = I>;\n-///     fn use_it(self) -> Self::MyItem {\n-///         self\n-///     }\n-/// }\n-/// ```\n-///\n-/// When we normalize the signature of `use_it` from the impl block,\n-/// we will normalize `Self::MyItem` to the opaque type `impl Iterator<Item = I>`\n-/// However, this projection result may contain inference variables, due\n-/// to the way that projection works. We didn't have any inference variables\n-/// in the signature to begin with - leaving them in will cause us to incorrectly\n-/// conclude that we don't have a defining use of `MyItem`. By mapping inference\n-/// variables back to the actual generic parameters, we will correctly see that\n-/// we have a defining use of `MyItem`\n-fn fixup_opaque_types<'tcx, T>(tcx: TyCtxt<'tcx>, val: T) -> T\n-where\n-    T: TypeFoldable<'tcx>,\n-{\n-    struct FixupFolder<'tcx> {\n-        tcx: TyCtxt<'tcx>,\n-    }\n-\n-    impl<'tcx> TypeFolder<'tcx> for FixupFolder<'tcx> {\n-        fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n-            self.tcx\n-        }\n-\n-        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-            match *ty.kind() {\n-                ty::Opaque(def_id, substs) => {\n-                    debug!(\"fixup_opaque_types: found type {:?}\", ty);\n-                    // Here, we replace any inference variables that occur within\n-                    // the substs of an opaque type. By definition, any type occurring\n-                    // in the substs has a corresponding generic parameter, which is what\n-                    // we replace it with.\n-                    // This replacement is only run on the function signature, so any\n-                    // inference variables that we come across must be the rust of projection\n-                    // (there's no other way for a user to get inference variables into\n-                    // a function signature).\n-                    if ty.needs_infer() {\n-                        let new_substs = InternalSubsts::for_item(self.tcx, def_id, |param, _| {\n-                            let old_param = substs[param.index as usize];\n-                            match old_param.unpack() {\n-                                GenericArgKind::Type(old_ty) => {\n-                                    if let ty::Infer(_) = old_ty.kind() {\n-                                        // Replace inference type with a generic parameter\n-                                        self.tcx.mk_param_from_def(param)\n-                                    } else {\n-                                        old_param.fold_with(self)\n-                                    }\n-                                }\n-                                GenericArgKind::Const(old_const) => {\n-                                    if let ty::ConstKind::Infer(_) = old_const.val {\n-                                        // This should never happen - we currently do not support\n-                                        // 'const projections', e.g.:\n-                                        // `impl<T: SomeTrait> MyTrait for T where <T as SomeTrait>::MyConst == 25`\n-                                        // which should be the only way for us to end up with a const inference\n-                                        // variable after projection. If Rust ever gains support for this kind\n-                                        // of projection, this should *probably* be changed to\n-                                        // `self.tcx.mk_param_from_def(param)`\n-                                        bug!(\n-                                            \"Found infer const: `{:?}` in opaque type: {:?}\",\n-                                            old_const,\n-                                            ty\n-                                        );\n-                                    } else {\n-                                        old_param.fold_with(self)\n-                                    }\n-                                }\n-                                GenericArgKind::Lifetime(old_region) => {\n-                                    if let RegionKind::ReVar(_) = old_region {\n-                                        self.tcx.mk_param_from_def(param)\n-                                    } else {\n-                                        old_param.fold_with(self)\n-                                    }\n-                                }\n-                            }\n-                        });\n-                        let new_ty = self.tcx.mk_opaque(def_id, new_substs);\n-                        debug!(\"fixup_opaque_types: new type: {:?}\", new_ty);\n-                        new_ty\n-                    } else {\n-                        ty\n-                    }\n-                }\n-                _ => ty.super_fold_with(self),\n-            }\n-        }\n-    }\n-\n-    debug!(\"fixup_opaque_types({:?})\", val);\n-    val.fold_with(&mut FixupFolder { tcx })\n-}\n-\n fn typeck_const_arg<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     (did, param_did): (LocalDefId, DefId),\n@@ -510,8 +397,6 @@ fn typeck_with_fallback<'tcx>(\n                 fn_sig,\n             );\n \n-            let fn_sig = fixup_opaque_types(tcx, fn_sig);\n-\n             let fcx = check_fn(&inh, param_env, fn_sig, decl, id, body, None).0;\n             fcx\n         } else {"}, {"sha": "0aa059b7de80fde78df7e570f621be4bbb307541", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ebe21ac23a8a259079c9c59669c1d7da1fa88d0c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe21ac23a8a259079c9c59669c1d7da1fa88d0c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=ebe21ac23a8a259079c9c59669c1d7da1fa88d0c", "patch": "@@ -496,6 +496,8 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n             debug_assert!(!instantiated_ty.has_escaping_bound_vars());\n \n+            let opaque_type_key = self.fcx.fully_resolve(opaque_type_key).unwrap();\n+\n             // Prevent:\n             // * `fn foo<T>() -> Foo<T>`\n             // * `fn foo<T: Bound + Other>() -> Foo<T>`\n@@ -508,6 +510,8 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             // fn foo<U>() -> Foo<U> { .. }\n             // ```\n             // figures out the concrete type with `U`, but the stored type is with `T`.\n+\n+            // FIXME: why are we calling this here? This seems too early, and duplicated.\n             let definition_ty = self.fcx.infer_opaque_definition_from_instantiation(\n                 opaque_type_key,\n                 instantiated_ty,\n@@ -529,33 +533,33 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                 }\n             }\n \n-            if !opaque_type_key.substs.needs_infer() {\n-                // We only want to add an entry into `concrete_opaque_types`\n-                // if we actually found a defining usage of this opaque type.\n-                // Otherwise, we do nothing - we'll either find a defining usage\n-                // in some other location, or we'll end up emitting an error due\n-                // to the lack of defining usage\n-                if !skip_add {\n-                    let old_concrete_ty = self\n-                        .typeck_results\n-                        .concrete_opaque_types\n-                        .insert(opaque_type_key, definition_ty);\n-                    if let Some(old_concrete_ty) = old_concrete_ty {\n-                        if old_concrete_ty != definition_ty {\n-                            span_bug!(\n-                                span,\n-                                \"`visit_opaque_types` tried to write different types for the same \\\n+            if opaque_type_key.substs.needs_infer() {\n+                span_bug!(span, \"{:#?} has inference variables\", opaque_type_key.substs)\n+            }\n+\n+            // We only want to add an entry into `concrete_opaque_types`\n+            // if we actually found a defining usage of this opaque type.\n+            // Otherwise, we do nothing - we'll either find a defining usage\n+            // in some other location, or we'll end up emitting an error due\n+            // to the lack of defining usage\n+            if !skip_add {\n+                let old_concrete_ty = self\n+                    .typeck_results\n+                    .concrete_opaque_types\n+                    .insert(opaque_type_key, definition_ty);\n+                if let Some(old_concrete_ty) = old_concrete_ty {\n+                    if old_concrete_ty != definition_ty {\n+                        span_bug!(\n+                            span,\n+                            \"`visit_opaque_types` tried to write different types for the same \\\n                                  opaque type: {:?}, {:?}, {:?}, {:?}\",\n-                                opaque_type_key.def_id,\n-                                definition_ty,\n-                                opaque_defn,\n-                                old_concrete_ty,\n-                            );\n-                        }\n+                            opaque_type_key.def_id,\n+                            definition_ty,\n+                            opaque_defn,\n+                            old_concrete_ty,\n+                        );\n                     }\n                 }\n-            } else {\n-                self.tcx().sess.delay_span_bug(span, \"`opaque_defn` has inference variables\");\n             }\n         }\n     }"}, {"sha": "b7c8a58a656290da2fabd82e5ca7133a2c586c55", "filename": "src/test/ui/type-alias-impl-trait/issue-60371.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebe21ac23a8a259079c9c59669c1d7da1fa88d0c/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe21ac23a8a259079c9c59669c1d7da1fa88d0c/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.rs?ref=ebe21ac23a8a259079c9c59669c1d7da1fa88d0c", "patch": "@@ -9,7 +9,7 @@ trait Bug {\n impl Bug for &() {\n     type Item = impl Bug; //~ ERROR `impl Trait` in type aliases is unstable\n     //~^ ERROR the trait bound `(): Bug` is not satisfied\n-    //~^^ ERROR could not find defining uses\n+    //~^^ ERROR the trait bound `(): Bug` is not satisfied\n \n     const FUN: fn() -> Self::Item = || ();\n     //~^ ERROR type alias impl trait is not permitted here"}, {"sha": "6857d5264b65ed717bc5bdf1410d3941fe57588d", "filename": "src/test/ui/type-alias-impl-trait/issue-60371.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ebe21ac23a8a259079c9c59669c1d7da1fa88d0c/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ebe21ac23a8a259079c9c59669c1d7da1fa88d0c/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr?ref=ebe21ac23a8a259079c9c59669c1d7da1fa88d0c", "patch": "@@ -25,11 +25,14 @@ LL |     type Item = impl Bug;\n    = help: the following implementations were found:\n              <&() as Bug>\n \n-error: could not find defining uses\n+error[E0277]: the trait bound `(): Bug` is not satisfied\n   --> $DIR/issue-60371.rs:10:17\n    |\n LL |     type Item = impl Bug;\n-   |                 ^^^^^^^^\n+   |                 ^^^^^^^^ the trait `Bug` is not implemented for `()`\n+   |\n+   = help: the following implementations were found:\n+             <&() as Bug>\n \n error: aborting due to 4 previous errors\n "}]}