{"sha": "56730c094cf95be58fb05b0e423673aca2a98b88", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2NzMwYzA5NGNmOTViZTU4ZmIwNWIwZTQyMzY3M2FjYTJhOThiODg=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-08-09T02:27:03Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-08-09T02:27:03Z"}, "message": "Merge remote-tracking branch 'remotes/origin/master' into remove-str-trailing-nulls", "tree": {"sha": "096a652b16d38a6f4ff65dd39657ccf308249909", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/096a652b16d38a6f4ff65dd39657ccf308249909"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56730c094cf95be58fb05b0e423673aca2a98b88", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56730c094cf95be58fb05b0e423673aca2a98b88", "html_url": "https://github.com/rust-lang/rust/commit/56730c094cf95be58fb05b0e423673aca2a98b88", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56730c094cf95be58fb05b0e423673aca2a98b88/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03cc757fe90b88895fcf911d9cce5c04a008b127", "url": "https://api.github.com/repos/rust-lang/rust/commits/03cc757fe90b88895fcf911d9cce5c04a008b127", "html_url": "https://github.com/rust-lang/rust/commit/03cc757fe90b88895fcf911d9cce5c04a008b127"}, {"sha": "936f70bd878327d867b6f8f82061d738355a47c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/936f70bd878327d867b6f8f82061d738355a47c9", "html_url": "https://github.com/rust-lang/rust/commit/936f70bd878327d867b6f8f82061d738355a47c9"}], "stats": {"total": 4685, "additions": 3789, "deletions": 896}, "files": [{"sha": "d1aa793e5fc1b83d0501baea22f99cbf542b66c8", "filename": "doc/tutorial-ffi.md", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/doc%2Ftutorial-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/doc%2Ftutorial-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-ffi.md?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -228,6 +228,48 @@ unsafe fn kaboom(ptr: *int) -> int { *ptr }\n \n This function can only be called from an `unsafe` block or another `unsafe` function.\n \n+# Accessing foreign globals\n+\n+Foreign APIs often export a global variable which could do something like track\n+global state. In order to access these variables, you declare them in `extern`\n+blocks with the `static` keyword:\n+\n+~~~{.xfail-test}\n+use std::libc;\n+\n+#[link_args = \"-lreadline\"]\n+extern {\n+    static rl_readline_version: libc::c_int;\n+}\n+\n+fn main() {\n+    println(fmt!(\"You have readline version %d installed.\",\n+                 rl_readline_version as int));\n+}\n+~~~\n+\n+Alternatively, you may need to alter global state provided by a foreign\n+interface. To do this, statics can be declared with `mut` so rust can mutate\n+them.\n+\n+~~~{.xfail-test}\n+use std::libc;\n+use std::ptr;\n+\n+#[link_args = \"-lreadline\"]\n+extern {\n+    static mut rl_prompt: *libc::c_char;\n+}\n+\n+fn main() {\n+    do \"[my-awesome-shell] $\".as_c_str |buf| {\n+        unsafe { rl_prompt = buf; }\n+        // get a line, process it\n+        unsafe { rl_prompt = ptr::null(); }\n+    }\n+}\n+~~~\n+\n # Foreign calling conventions\n \n Most foreign code exposes a C ABI, and Rust uses the platform's C calling convention by default when"}, {"sha": "d190c332e6633ade92d1a9ac944aef034caca1db", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -424,7 +424,7 @@ there is no way to \"catch\" the exception.\n All tasks are, by default, _linked_ to each other. That means that the fates\n of all tasks are intertwined: if one fails, so do all the others.\n \n-~~~\n+~~~{.xfail-test .linked-failure}\n # use std::task::spawn;\n # use std::task;\n # fn do_some_work() { loop { task::yield() } }\n@@ -447,7 +447,7 @@ pattern-match on a result to check whether it's an `Ok` result with an `int`\n field (representing a successful result) or an `Err` result (representing\n termination with an error).\n \n-~~~\n+~~~{.xfail-test .linked-failure}\n # use std::task;\n # fn some_condition() -> bool { false }\n # fn calculate_result() -> int { 0 }\n@@ -490,9 +490,10 @@ proceed). Hence, you will need different _linked failure modes_.\n By default, task failure is _bidirectionally linked_, which means that if\n either task fails, it kills the other one.\n \n-~~~\n+~~~{.xfail-test .linked-failure}\n # use std::task;\n-# fn sleep_forever() { loop { task::yield() } }\n+# use std::comm::oneshot;\n+# fn sleep_forever() { loop { let (p, c) = oneshot::<()>(); p.recv(); } }\n # do task::try {\n do spawn {\n     do spawn {\n@@ -511,11 +512,12 @@ function `task::try`, which we saw previously, uses `spawn_supervised`\n internally, with additional logic to wait for the child task to finish\n before returning. Hence:\n \n-~~~\n+~~~{.xfail-test .linked-failure}\n # use std::comm::{stream, Chan, Port};\n+# use std::comm::oneshot;\n # use std::task::{spawn, try};\n # use std::task;\n-# fn sleep_forever() { loop { task::yield() } }\n+# fn sleep_forever() { loop { let (p, c) = oneshot::<()>(); p.recv(); } }\n # do task::try {\n let (receiver, sender): (Port<int>, Chan<int>) = stream();\n do spawn {  // Bidirectionally linked\n@@ -541,9 +543,10 @@ also fail.\n Supervised task failure propagates across multiple generations even if\n an intermediate generation has already exited:\n \n-~~~\n+~~~{.xfail-test .linked-failure}\n # use std::task;\n-# fn sleep_forever() { loop { task::yield() } }\n+# use std::comm::oneshot;\n+# fn sleep_forever() { loop { let (p, c) = oneshot::<()>(); p.recv(); } }\n # fn wait_for_a_while() { for _ in range(0, 1000u) { task::yield() } }\n # do task::try::<int> {\n do task::spawn_supervised {\n@@ -560,7 +563,7 @@ fail!();  // Will kill grandchild even if child has already exited\n Finally, tasks can be configured to not propagate failure to each\n other at all, using `task::spawn_unlinked` for _isolated failure_.\n \n-~~~\n+~~~{.xfail-test .linked-failure}\n # use std::task;\n # fn random() -> uint { 100 }\n # fn sleep_for(i: uint) { for _ in range(0, i) { task::yield() } }\n@@ -588,7 +591,7 @@ that repeatedly receives a `uint` message, converts it to a string, and sends\n the string in response.  The child terminates when it receives `0`.\n Here is the function that implements the child task:\n \n-~~~~\n+~~~{.xfail-test .linked-failure}\n # use extra::comm::DuplexStream;\n # use std::uint;\n fn stringifier(channel: &DuplexStream<~str, uint>) {\n@@ -611,7 +614,7 @@ response itself is simply the stringified version of the received value,\n \n Here is the code for the parent task:\n \n-~~~~\n+~~~{.xfail-test .linked-failure}\n # use std::task::spawn;\n # use std::uint;\n # use extra::comm::DuplexStream;"}, {"sha": "40e276ae04a158e92ecaf413bfbb12734f7d42a2", "filename": "doc/tutorial.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -2288,8 +2288,8 @@ pub mod farm {\n     }\n \n     impl Farm {\n-        priv fn feed_chickens(&self) { ... }\n-        priv fn feed_cows(&self) { ... }\n+        fn feed_chickens(&self) { ... }\n+        fn feed_cows(&self) { ... }\n         pub fn add_chicken(&self, c: Chicken) { ... }\n     }\n "}, {"sha": "4262aba9a85946c2f30ee8dc6bdfa4be5dc75d5e", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -109,8 +109,8 @@ pub fn parse_config(args: ~[~str]) -> config {\n         compile_lib_path: getopts::opt_str(matches, \"compile-lib-path\"),\n         run_lib_path: getopts::opt_str(matches, \"run-lib-path\"),\n         rustc_path: opt_path(matches, \"rustc-path\"),\n-        clang_path: getopts::opt_maybe_str(matches, \"clang-path\").map(|s| Path(*s)),\n-        llvm_bin_path: getopts::opt_maybe_str(matches, \"llvm-bin-path\").map(|s| Path(*s)),\n+        clang_path: getopts::opt_maybe_str(matches, \"clang-path\").map_move(|s| Path(s)),\n+        llvm_bin_path: getopts::opt_maybe_str(matches, \"llvm-bin-path\").map_move(|s| Path(s)),\n         src_base: opt_path(matches, \"src-base\"),\n         build_base: opt_path(matches, \"build-base\"),\n         aux_base: opt_path(matches, \"aux-base\"),\n@@ -123,14 +123,14 @@ pub fn parse_config(args: ~[~str]) -> config {\n             } else {\n                 None\n             },\n-        logfile: getopts::opt_maybe_str(matches, \"logfile\").map(|s| Path(*s)),\n-        save_metrics: getopts::opt_maybe_str(matches, \"save-metrics\").map(|s| Path(*s)),\n+        logfile: getopts::opt_maybe_str(matches, \"logfile\").map_move(|s| Path(s)),\n+        save_metrics: getopts::opt_maybe_str(matches, \"save-metrics\").map_move(|s| Path(s)),\n         ratchet_metrics:\n-            getopts::opt_maybe_str(matches, \"ratchet-metrics\").map(|s| Path(*s)),\n+            getopts::opt_maybe_str(matches, \"ratchet-metrics\").map_move(|s| Path(s)),\n         ratchet_noise_percent:\n             getopts::opt_maybe_str(matches,\n-                                   \"ratchet-noise-percent\").map(|s|\n-                                                                f64::from_str(*s).unwrap()),\n+                                   \"ratchet-noise-percent\").map_move(|s|\n+                                                                     f64::from_str(s).unwrap()),\n         runtool: getopts::opt_maybe_str(matches, \"runtool\"),\n         rustcflags: getopts::opt_maybe_str(matches, \"rustcflags\"),\n         jit: getopts::opt_present(matches, \"jit\"),"}, {"sha": "9c176b504b2ee61fcb7440687d91412b294f0fad", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -162,9 +162,8 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n         round += 1;\n     }\n \n-    let mut expected =\n-        match props.pp_exact {\n-          Some(ref file) => {\n+    let mut expected = match props.pp_exact {\n+        Some(ref file) => {\n             let filepath = testfile.dir_path().push_rel(file);\n             io::read_whole_file_str(&filepath).unwrap()\n           }\n@@ -413,8 +412,8 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n         }\n     }\n \n-    for i in range(0u, found_flags.len()) {\n-        if !found_flags[i] {\n+    for (i, &flag) in found_flags.iter().enumerate() {\n+        if !flag {\n             let ee = &expected_errors[i];\n             fatal_ProcRes(fmt!(\"expected %s on line %u not found: %s\",\n                                ee.kind, ee.line, ee.msg), ProcRes);"}, {"sha": "b1180098bd2acc3ce7ed618888548b25de7acb9c", "filename": "src/etc/gedit/share/gtksourceview-3.0/language-specs/rust.lang", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Fetc%2Fgedit%2Fshare%2Fgtksourceview-3.0%2Flanguage-specs%2Frust.lang", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Fetc%2Fgedit%2Fshare%2Fgtksourceview-3.0%2Flanguage-specs%2Frust.lang", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgedit%2Fshare%2Fgtksourceview-3.0%2Flanguage-specs%2Frust.lang?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -50,6 +50,7 @@\n \t\t<keyword>for</keyword>\n \t\t<keyword>if</keyword>\n \t\t<keyword>impl</keyword>\n+\t\t<keyword>in</keyword>\n \t\t<keyword>let</keyword>\n \t\t<keyword>log</keyword>\n \t\t<keyword>loop</keyword>"}, {"sha": "69203b753cdc5c0159bf7be6e83092771b2e721a", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -611,6 +611,7 @@ mod tests {\n             }\n         }\n     }\n+\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     fn test_arc_condvar_poison() {\n         unsafe {\n@@ -846,22 +847,16 @@ mod tests {\n                 }\n                 assert_eq!(*state, 42);\n                 *state = 31337;\n-                // FIXME: #7372: hits type inference bug with iterators\n                 // send to other readers\n-                for i in range(0u, reader_convos.len()) {\n-                    match reader_convos[i] {\n-                        (ref rc, _) => rc.send(()),\n-                    }\n+                for &(ref rc, _) in reader_convos.iter() {\n+                    rc.send(())\n                 }\n             }\n             let read_mode = arc.downgrade(write_mode);\n             do (&read_mode).read |state| {\n-                // FIXME: #7372: hits type inference bug with iterators\n                 // complete handshake with other readers\n-                for i in range(0u, reader_convos.len()) {\n-                    match reader_convos[i] {\n-                        (_, ref rp) => rp.recv(),\n-                    }\n+                for &(_, ref rp) in reader_convos.iter() {\n+                    rp.recv()\n                 }\n                 wc1.send(()); // tell writer to try again\n                 assert_eq!(*state, 31337);"}, {"sha": "20a3add3e7b3d64e7a79d6b03daaa9af6ada9ec3", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -145,22 +145,24 @@ impl BigBitv {\n         let len = b.storage.len();\n         assert_eq!(self.storage.len(), len);\n         let mut changed = false;\n-        for i in range(0, len) {\n+        for (i, (a, b)) in self.storage.mut_iter()\n+                               .zip(b.storage.iter())\n+                               .enumerate() {\n             let mask = big_mask(nbits, i);\n-            let w0 = self.storage[i] & mask;\n-            let w1 = b.storage[i] & mask;\n+            let w0 = *a & mask;\n+            let w1 = *b & mask;\n             let w = op(w0, w1) & mask;\n             if w0 != w {\n                 changed = true;\n-                self.storage[i] = w;\n+                *a = w;\n             }\n         }\n         changed\n     }\n \n     #[inline]\n     pub fn each_storage(&mut self, op: &fn(v: &mut uint) -> bool) -> bool {\n-        range(0u, self.storage.len()).advance(|i| op(&mut self.storage[i]))\n+        self.storage.mut_iter().advance(|elt| op(elt))\n     }\n \n     #[inline]\n@@ -205,10 +207,9 @@ impl BigBitv {\n \n     #[inline]\n     pub fn equals(&self, b: &BigBitv, nbits: uint) -> bool {\n-        let len = b.storage.len();\n-        for i in range(0, len) {\n+        for (i, elt) in b.storage.iter().enumerate() {\n             let mask = big_mask(nbits, i);\n-            if mask & self.storage[i] != mask & b.storage[i] {\n+            if mask & self.storage[i] != mask & *elt {\n                 return false;\n             }\n         }"}, {"sha": "b0839a55795b760ccf0efdaba987c0d9edf6df35", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -164,7 +164,7 @@ impl<T> DList<T> {\n     /// Remove the first Node and return it, or None if the list is empty\n     #[inline]\n     fn pop_front_node(&mut self) -> Option<~Node<T>> {\n-        do self.list_head.take().map_consume |mut front_node| {\n+        do self.list_head.take().map_move |mut front_node| {\n             self.length -= 1;\n             match front_node.next.take() {\n                 Some(node) => self.list_head = link_with_prev(node, Rawlink::none()),\n@@ -190,7 +190,7 @@ impl<T> DList<T> {\n     /// Remove the last Node and return it, or None if the list is empty\n     #[inline]\n     fn pop_back_node(&mut self) -> Option<~Node<T>> {\n-        do self.list_tail.resolve().map_consume_default(None) |tail| {\n+        do self.list_tail.resolve().map_move_default(None) |tail| {\n             self.length -= 1;\n             self.list_tail = tail.prev;\n             match tail.prev.resolve() {\n@@ -237,7 +237,7 @@ impl<T> Deque<T> for DList<T> {\n     ///\n     /// O(1)\n     fn pop_front(&mut self) -> Option<T> {\n-        self.pop_front_node().map_consume(|~Node{value, _}| value)\n+        self.pop_front_node().map_move(|~Node{value, _}| value)\n     }\n \n     /// Add an element last in the list\n@@ -251,7 +251,7 @@ impl<T> Deque<T> for DList<T> {\n     ///\n     /// O(1)\n     fn pop_back(&mut self) -> Option<T> {\n-        self.pop_back_node().map_consume(|~Node{value, _}| value)\n+        self.pop_back_node().map_move(|~Node{value, _}| value)\n     }\n }\n \n@@ -267,7 +267,7 @@ impl<T> DList<T> {\n     /// If the list is empty, do nothing.\n     #[inline]\n     pub fn rotate_forward(&mut self) {\n-        do self.pop_back_node().map_consume |tail| {\n+        do self.pop_back_node().map_move |tail| {\n             self.push_front_node(tail)\n         };\n     }\n@@ -277,7 +277,7 @@ impl<T> DList<T> {\n     /// If the list is empty, do nothing.\n     #[inline]\n     pub fn rotate_backward(&mut self) {\n-        do self.pop_front_node().map_consume |head| {\n+        do self.pop_front_node().map_move |head| {\n             self.push_back_node(head)\n         };\n     }\n@@ -463,7 +463,7 @@ impl<'self, A> DoubleEndedIterator<&'self A> for DListIterator<'self, A> {\n         if self.nelem == 0 {\n             return None;\n         }\n-        do self.tail.resolve().map_consume |prev| {\n+        do self.tail.resolve().map_move |prev| {\n             self.nelem -= 1;\n             self.tail = prev.prev;\n             &prev.value\n@@ -477,7 +477,7 @@ impl<'self, A> Iterator<&'self mut A> for MutDListIterator<'self, A> {\n         if self.nelem == 0 {\n             return None;\n         }\n-        do self.head.resolve().map_consume |next| {\n+        do self.head.resolve().map_move |next| {\n             self.nelem -= 1;\n             self.head = match next.next {\n                 Some(ref mut node) => Rawlink::some(&mut **node),\n@@ -499,7 +499,7 @@ impl<'self, A> DoubleEndedIterator<&'self mut A> for MutDListIterator<'self, A>\n         if self.nelem == 0 {\n             return None;\n         }\n-        do self.tail.resolve().map_consume |prev| {\n+        do self.tail.resolve().map_move |prev| {\n             self.nelem -= 1;\n             self.tail = prev.prev;\n             &mut prev.value\n@@ -553,7 +553,7 @@ impl<'self, A> ListInsertion<A> for MutDListIterator<'self, A> {\n         if self.nelem == 0 {\n             return None\n         }\n-        self.head.resolve().map_consume(|head| &mut head.value)\n+        self.head.resolve().map_move(|head| &mut head.value)\n     }\n }\n "}, {"sha": "14b02688cffcfc1481ff2927727b3ab5c0981a1e", "filename": "src/libextra/fileinput.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -129,27 +129,27 @@ struct FileInput_ {\n     `Some(path)` is the file represented by `path`, `None` is\n     `stdin`. Consumed as the files are read.\n     */\n-    priv files: ~[Option<Path>],\n+    files: ~[Option<Path>],\n     /**\n     The current file: `Some(r)` for an open file, `None` before\n     starting and after reading everything.\n     */\n-    priv current_reader: Option<@io::Reader>,\n-    priv state: FileInputState,\n+    current_reader: Option<@io::Reader>,\n+    state: FileInputState,\n \n     /**\n     Used to keep track of whether we need to insert the newline at the\n     end of a file that is missing it, which is needed to separate the\n     last and first lines.\n     */\n-    priv previous_was_newline: bool\n+    previous_was_newline: bool\n }\n \n // XXX: remove this when Reader has &mut self. Should be removable via\n // \"self.fi.\" -> \"self.\" and renaming FileInput_. Documentation above\n // will likely have to be updated to use `let mut in = ...`.\n pub struct FileInput  {\n-    priv fi: @mut FileInput_\n+    fi: @mut FileInput_\n }\n \n impl FileInput {\n@@ -198,7 +198,7 @@ impl FileInput {\n         FileInput::from_vec(pathed)\n     }\n \n-    priv fn current_file_eof(&self) -> bool {\n+    fn current_file_eof(&self) -> bool {\n         match self.fi.current_reader {\n             None => false,\n             Some(r) => r.eof()\n@@ -240,7 +240,7 @@ impl FileInput {\n     Returns `true` if it had to move to the next file and did\n     so successfully.\n     */\n-    priv fn next_file_if_eof(&self) -> bool {\n+    fn next_file_if_eof(&self) -> bool {\n         match self.fi.current_reader {\n             None => self.next_file(),\n             Some(r) => {"}, {"sha": "ed8cbcd0663f3f9874afc34e6ef92a827c76eeae", "filename": "src/libextra/flate.rs", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflate.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -43,16 +43,18 @@ static LZ_NONE : c_int = 0x0;   // Huffman-coding only.\n static LZ_FAST : c_int = 0x1;   // LZ with only one probe\n static LZ_NORM : c_int = 0x80;  // LZ with 128 probes, \"normal\"\n static LZ_BEST : c_int = 0xfff; // LZ with 4095 probes, \"best\"\n+static TINFL_FLAG_PARSE_ZLIB_HEADER : c_int = 0x1; // parse zlib header and adler32 checksum\n+static TDEFL_WRITE_ZLIB_HEADER : c_int = 0x01000; // write zlib header and adler32 checksum\n \n-pub fn deflate_bytes(bytes: &[u8]) -> ~[u8] {\n+fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> ~[u8] {\n     do bytes.as_imm_buf |b, len| {\n         unsafe {\n             let mut outsz : size_t = 0;\n             let res =\n                 rustrt::tdefl_compress_mem_to_heap(b as *c_void,\n                                                    len as size_t,\n                                                    &mut outsz,\n-                                                   LZ_NORM);\n+                                                   flags);\n             assert!(res as int != 0);\n             let out = vec::raw::from_buf_raw(res as *u8,\n                                              outsz as uint);\n@@ -62,15 +64,23 @@ pub fn deflate_bytes(bytes: &[u8]) -> ~[u8] {\n     }\n }\n \n-pub fn inflate_bytes(bytes: &[u8]) -> ~[u8] {\n+pub fn deflate_bytes(bytes: &[u8]) -> ~[u8] {\n+    deflate_bytes_internal(bytes, LZ_NORM)\n+}\n+\n+pub fn deflate_bytes_zlib(bytes: &[u8]) -> ~[u8] {\n+    deflate_bytes_internal(bytes, LZ_NORM | TDEFL_WRITE_ZLIB_HEADER)\n+}\n+\n+fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> ~[u8] {\n     do bytes.as_imm_buf |b, len| {\n         unsafe {\n             let mut outsz : size_t = 0;\n             let res =\n                 rustrt::tinfl_decompress_mem_to_heap(b as *c_void,\n                                                      len as size_t,\n                                                      &mut outsz,\n-                                                     0);\n+                                                     flags);\n             assert!(res as int != 0);\n             let out = vec::raw::from_buf_raw(res as *u8,\n                                             outsz as uint);\n@@ -80,6 +90,14 @@ pub fn inflate_bytes(bytes: &[u8]) -> ~[u8] {\n     }\n }\n \n+pub fn inflate_bytes(bytes: &[u8]) -> ~[u8] {\n+    inflate_bytes_internal(bytes, 0)\n+}\n+\n+pub fn inflate_bytes_zlib(bytes: &[u8]) -> ~[u8] {\n+    inflate_bytes_internal(bytes, TINFL_FLAG_PARSE_ZLIB_HEADER)\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n@@ -109,4 +127,12 @@ mod tests {\n             assert_eq!(input, out);\n         }\n     }\n+\n+    #[test]\n+    fn test_zlib_flate() {\n+        let bytes = ~[1, 2, 3, 4, 5];\n+        let deflated = deflate_bytes(bytes);\n+        let inflated = inflate_bytes(deflated);\n+        assert_eq!(inflated, bytes);\n+    }\n }"}, {"sha": "cc65c49d73a9c2b569619591a145df84c8036d3f", "filename": "src/libextra/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffuture.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -46,7 +46,7 @@ impl<A> Drop for Future<A> {\n     fn drop(&self) {}\n }\n \n-priv enum FutureState<A> {\n+enum FutureState<A> {\n     Pending(~fn() -> A),\n     Evaluating,\n     Forced(A)"}, {"sha": "1b65528923a100c16a5c50108447d92dd1a637e1", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 90, "deletions": 39, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -114,7 +114,8 @@ pub enum Occur {\n pub struct Opt {\n     name: Name,\n     hasarg: HasArg,\n-    occur: Occur\n+    occur: Occur,\n+    aliases: ~[Opt],\n }\n \n fn mkname(nm: &str) -> Name {\n@@ -127,37 +128,37 @@ fn mkname(nm: &str) -> Name {\n \n /// Create an option that is required and takes an argument\n pub fn reqopt(name: &str) -> Opt {\n-    return Opt {name: mkname(name), hasarg: Yes, occur: Req};\n+    return Opt {name: mkname(name), hasarg: Yes, occur: Req, aliases: ~[]};\n }\n \n /// Create an option that is optional and takes an argument\n pub fn optopt(name: &str) -> Opt {\n-    return Opt {name: mkname(name), hasarg: Yes, occur: Optional};\n+    return Opt {name: mkname(name), hasarg: Yes, occur: Optional, aliases: ~[]};\n }\n \n /// Create an option that is optional and does not take an argument\n pub fn optflag(name: &str) -> Opt {\n-    return Opt {name: mkname(name), hasarg: No, occur: Optional};\n+    return Opt {name: mkname(name), hasarg: No, occur: Optional, aliases: ~[]};\n }\n \n /** Create an option that is optional, does not take an argument,\n   * and may occur multiple times.\n   */\n pub fn optflagmulti(name: &str) -> Opt {\n-    return Opt {name: mkname(name), hasarg: No, occur: Multi};\n+    return Opt {name: mkname(name), hasarg: No, occur: Multi, aliases: ~[]};\n }\n \n /// Create an option that is optional and takes an optional argument\n pub fn optflagopt(name: &str) -> Opt {\n-    return Opt {name: mkname(name), hasarg: Maybe, occur: Optional};\n+    return Opt {name: mkname(name), hasarg: Maybe, occur: Optional, aliases: ~[]};\n }\n \n /**\n  * Create an option that is optional, takes an argument, and may occur\n  * multiple times\n  */\n pub fn optmulti(name: &str) -> Opt {\n-    return Opt {name: mkname(name), hasarg: Yes, occur: Multi};\n+    return Opt {name: mkname(name), hasarg: Yes, occur: Multi, aliases: ~[]};\n }\n \n #[deriving(Clone, Eq)]\n@@ -189,7 +190,20 @@ fn name_str(nm: &Name) -> ~str {\n }\n \n fn find_opt(opts: &[Opt], nm: Name) -> Option<uint> {\n-    opts.iter().position(|opt| opt.name == nm)\n+    // search main options\n+    let pos = opts.iter().position(|opt| opt.name == nm);\n+    if pos.is_some() {\n+        return pos\n+    }\n+\n+    // search in aliases\n+    for candidate in opts.iter() {\n+        if candidate.aliases.iter().position(|opt| opt.name == nm).is_some() {\n+            return opts.iter().position(|opt| opt.name == candidate.name);\n+        }\n+    }\n+\n+    None\n }\n \n /**\n@@ -488,8 +502,6 @@ pub mod groups {\n     use getopts::{HasArg, Long, Maybe, Multi, No, Occur, Opt, Optional, Req};\n     use getopts::{Short, Yes};\n \n-    use std::vec;\n-\n     /** one group of options, e.g., both -h and --help, along with\n      * their shared description and properties\n      */\n@@ -542,6 +554,20 @@ pub mod groups {\n                 occur: Optional};\n     }\n \n+    /// Create a long option that can occur more than once and does not\n+    /// take an argument\n+    pub fn optflagmulti(short_name: &str, long_name: &str,\n+                   desc: &str) -> OptGroup {\n+        let len = short_name.len();\n+        assert!(len == 1 || len == 0);\n+        return OptGroup {short_name: short_name.to_owned(),\n+                long_name: long_name.to_owned(),\n+                hint: ~\"\",\n+                desc: desc.to_owned(),\n+                hasarg: No,\n+                occur: Multi};\n+    }\n+\n     /// Create a long option that is optional and takes an optional argument\n     pub fn optflagopt(short_name: &str, long_name: &str,\n                       desc: &str, hint: &str) -> OptGroup {\n@@ -573,40 +599,45 @@ pub mod groups {\n \n     // translate OptGroup into Opt\n     // (both short and long names correspond to different Opts)\n-    pub fn long_to_short(lopt: &OptGroup) -> ~[Opt] {\n+    pub fn long_to_short(lopt: &OptGroup) -> Opt {\n         let OptGroup{short_name: short_name,\n                      long_name: long_name,\n                      hasarg: hasarg,\n                      occur: occur,\n                      _} = (*lopt).clone();\n \n         match (short_name.len(), long_name.len()) {\n-           (0,0) => fail!(\"this long-format option was given no name\"),\n-\n-           (0,_) => ~[Opt {name: Long((long_name)),\n-                           hasarg: hasarg,\n-                           occur: occur}],\n-\n-           (1,0) => ~[Opt {name: Short(short_name.char_at(0)),\n-                           hasarg: hasarg,\n-                           occur: occur}],\n-\n-           (1,_) => ~[Opt {name: Short(short_name.char_at(0)),\n-                           hasarg: hasarg,\n-                           occur:  occur},\n-                      Opt {name:   Long((long_name)),\n-                           hasarg: hasarg,\n-                           occur:  occur}],\n-\n-           (_,_) => fail!(\"something is wrong with the long-form opt\")\n+            (0,0) => fail!(\"this long-format option was given no name\"),\n+\n+            (0,_) => Opt {name: Long((long_name)),\n+                          hasarg: hasarg,\n+                          occur: occur,\n+                          aliases: ~[]},\n+\n+            (1,0) => Opt {name: Short(short_name.char_at(0)),\n+                          hasarg: hasarg,\n+                          occur: occur,\n+                          aliases: ~[]},\n+\n+            (1,_) => Opt {name: Long((long_name)),\n+                          hasarg: hasarg,\n+                          occur:  occur,\n+                          aliases: ~[Opt {\n+                              name: Short(short_name.char_at(0)),\n+                              hasarg: hasarg,\n+                              occur:  occur,\n+                              aliases: ~[]\n+                          }]},\n+\n+            (_,_) => fail!(\"something is wrong with the long-form opt\")\n         }\n     }\n \n     /*\n      * Parse command line args with the provided long format options\n      */\n     pub fn getopts(args: &[~str], opts: &[OptGroup]) -> ::getopts::Result {\n-        ::getopts::getopts(args, vec::flat_map(opts, long_to_short))\n+        ::getopts::getopts(args, opts.map(long_to_short))\n     }\n \n     /**\n@@ -708,9 +739,9 @@ pub mod groups {\n      *  Fails during iteration if the string contains a non-whitespace\n      *  sequence longer than the limit.\n      */\n-    priv fn each_split_within<'a>(ss: &'a str,\n-                                lim: uint,\n-                                it: &fn(&'a str) -> bool) -> bool {\n+    fn each_split_within<'a>(ss: &'a str,\n+                             lim: uint,\n+                             it: &fn(&'a str) -> bool) -> bool {\n         // Just for fun, let's write this as an state machine:\n \n         enum SplitWithinState {\n@@ -778,7 +809,7 @@ pub mod groups {\n     }\n \n     #[test]\n-    priv fn test_split_within() {\n+    fn test_split_within() {\n         fn t(s: &str, i: uint, u: &[~str]) {\n             let mut v = ~[];\n             do each_split_within(s, i) |s| { v.push(s.to_owned()); true };\n@@ -1440,18 +1471,25 @@ mod tests {\n \n     #[test]\n     fn test_groups_long_to_short() {\n-        let short = ~[reqopt(\"b\"), reqopt(\"banana\")];\n+        let mut short = reqopt(\"banana\");\n+        short.aliases = ~[reqopt(\"b\")];\n         let verbose = groups::reqopt(\"b\", \"banana\", \"some bananas\", \"VAL\");\n \n         assert_eq!(groups::long_to_short(&verbose), short);\n     }\n \n     #[test]\n     fn test_groups_getopts() {\n+        let mut banana = reqopt(\"banana\");\n+        banana.aliases = ~[reqopt(\"b\")];\n+        let mut apple = optopt(\"apple\");\n+        apple.aliases = ~[optopt(\"a\")];\n+        let mut kiwi = optflag(\"kiwi\");\n+        kiwi.aliases = ~[optflag(\"k\")];\n         let short = ~[\n-            reqopt(\"b\"), reqopt(\"banana\"),\n-            optopt(\"a\"), optopt(\"apple\"),\n-            optflag(\"k\"), optflagopt(\"kiwi\"),\n+            banana,\n+            apple,\n+            kiwi,\n             optflagopt(\"p\"),\n             optmulti(\"l\")\n         ];\n@@ -1464,14 +1502,27 @@ mod tests {\n             groups::optmulti(\"l\", \"\", \"Desc\", \"VAL\"),\n         ];\n \n-        let sample_args = ~[~\"-k\", ~\"15\", ~\"--apple\", ~\"1\", ~\"k\",\n+        let sample_args = ~[~\"--kiwi\", ~\"15\", ~\"--apple\", ~\"1\", ~\"k\",\n                             ~\"-p\", ~\"16\", ~\"l\", ~\"35\"];\n \n         // FIXME #4681: sort options here?\n         assert!(getopts(sample_args, short)\n             == groups::getopts(sample_args, verbose));\n     }\n \n+    #[test]\n+    fn test_groups_aliases_long_and_short() {\n+        let opts = ~[\n+            groups::optflagmulti(\"a\", \"apple\", \"Desc\"),\n+        ];\n+\n+        let args = ~[~\"-a\", ~\"--apple\", ~\"-a\"];\n+\n+        let matches = groups::getopts(args, opts).unwrap();\n+        assert_eq!(3, opt_count(&matches, \"a\"));\n+        assert_eq!(3, opt_count(&matches, \"apple\"));\n+    }\n+\n     #[test]\n     fn test_groups_usage() {\n         let optgroups = ~["}, {"sha": "0c8701bd0b515b1db16a6dc7dc5f0b958cdb0558", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -59,13 +59,13 @@ pub mod BigDigit {\n     pub static bits: uint = 32;\n \n     pub static base: uint = 1 << bits;\n-    priv static hi_mask: uint = (-1 as uint) << bits;\n-    priv static lo_mask: uint = (-1 as uint) >> bits;\n+    static hi_mask: uint = (-1 as uint) << bits;\n+    static lo_mask: uint = (-1 as uint) >> bits;\n \n \n-    priv fn get_hi(n: uint) -> BigDigit { (n >> bits) as BigDigit }\n+    fn get_hi(n: uint) -> BigDigit { (n >> bits) as BigDigit }\n \n-    priv fn get_lo(n: uint) -> BigDigit { (n & lo_mask) as BigDigit }\n+    fn get_lo(n: uint) -> BigDigit { (n & lo_mask) as BigDigit }\n \n     /// Split one machine sized unsigned integer into two BigDigits.\n \n@@ -548,7 +548,7 @@ impl BigUint {\n \n     pub fn new(v: ~[BigDigit]) -> BigUint {\n         // omit trailing zeros\n-        let new_len = v.rposition(|n| *n != 0).map_default(0, |p| *p + 1);\n+        let new_len = v.rposition(|n| *n != 0).map_move_default(0, |p| p + 1);\n \n         if new_len == v.len() { return BigUint { data: v }; }\n         let mut v = v;\n@@ -613,15 +613,15 @@ impl BigUint {\n     }\n \n \n-    priv fn shl_unit(&self, n_unit: uint) -> BigUint {\n+    fn shl_unit(&self, n_unit: uint) -> BigUint {\n         if n_unit == 0 || self.is_zero() { return (*self).clone(); }\n \n         return BigUint::new(vec::from_elem(n_unit, ZERO_BIG_DIGIT)\n                             + self.data);\n     }\n \n \n-    priv fn shl_bits(&self, n_bits: uint) -> BigUint {\n+    fn shl_bits(&self, n_bits: uint) -> BigUint {\n         if n_bits == 0 || self.is_zero() { return (*self).clone(); }\n \n         let mut carry = 0;\n@@ -637,7 +637,7 @@ impl BigUint {\n     }\n \n \n-    priv fn shr_unit(&self, n_unit: uint) -> BigUint {\n+    fn shr_unit(&self, n_unit: uint) -> BigUint {\n         if n_unit == 0 { return (*self).clone(); }\n         if self.data.len() < n_unit { return Zero::zero(); }\n         return BigUint::from_slice(\n@@ -646,7 +646,7 @@ impl BigUint {\n     }\n \n \n-    priv fn shr_bits(&self, n_bits: uint) -> BigUint {\n+    fn shr_bits(&self, n_bits: uint) -> BigUint {\n         if n_bits == 0 || self.data.is_empty() { return (*self).clone(); }\n \n         let mut borrow = 0;\n@@ -661,7 +661,7 @@ impl BigUint {\n \n #[cfg(target_arch = \"x86_64\")]\n \n-priv fn get_radix_base(radix: uint) -> (uint, uint) {\n+fn get_radix_base(radix: uint) -> (uint, uint) {\n     assert!(1 < radix && radix <= 16);\n     match radix {\n         2  => (4294967296, 32),\n@@ -687,7 +687,7 @@ priv fn get_radix_base(radix: uint) -> (uint, uint) {\n #[cfg(target_arch = \"x86\")]\n #[cfg(target_arch = \"mips\")]\n \n-priv fn get_radix_base(radix: uint) -> (uint, uint) {\n+fn get_radix_base(radix: uint) -> (uint, uint) {\n     assert!(1 < radix && radix <= 16);\n     match radix {\n         2  => (65536, 16),\n@@ -1145,7 +1145,7 @@ impl BigInt {\n             start = 1;\n         }\n         return BigUint::parse_bytes(buf.slice(start, buf.len()), radix)\n-            .map_consume(|bu| BigInt::from_biguint(sign, bu));\n+            .map_move(|bu| BigInt::from_biguint(sign, bu));\n     }\n \n     pub fn to_uint(&self) -> uint {\n@@ -2028,7 +2028,7 @@ mod bigint_tests {\n     #[test]\n     fn test_from_str_radix() {\n         fn check(s: &str, ans: Option<int>) {\n-            let ans = ans.map(|&n| IntConvertible::from_int::<BigInt>(n));\n+            let ans = ans.map_move(|n| IntConvertible::from_int::<BigInt>(n));\n             assert_eq!(FromStrRadix::from_str_radix(s, 10), ans);\n         }\n         check(\"10\", Some(10));"}, {"sha": "a601270e8ece16c80c27031c966ed22b69578daa", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 7, "deletions": 52, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -16,7 +16,6 @@\n #[allow(missing_doc)];\n \n use std::iterator::{Iterator, IteratorUtil, Enumerate, FilterMap, Invert};\n-use std::uint;\n use std::util::replace;\n use std::vec::{VecIterator, VecMutIterator};\n use std::vec;\n@@ -29,14 +28,12 @@ pub struct SmallIntMap<T> {\n impl<V> Container for SmallIntMap<V> {\n     /// Return the number of elements in the map\n     fn len(&self) -> uint {\n-        let mut sz = 0;\n-        for i in range(0u, self.v.len()) {\n-            match self.v[i] {\n-                Some(_) => sz += 1,\n-                None => {}\n-            }\n-        }\n-        sz\n+        self.v.iter().count(|elt| elt.is_some())\n+    }\n+\n+    /// Return true if there are no elements in the map\n+    fn is_empty(&self) -> bool {\n+        self.v.iter().all(|elt| elt.is_none())\n     }\n }\n \n@@ -116,48 +113,6 @@ impl<V> SmallIntMap<V> {\n     /// Create an empty SmallIntMap\n     pub fn new() -> SmallIntMap<V> { SmallIntMap{v: ~[]} }\n \n-    /// Visit all key-value pairs in order\n-    pub fn each<'a>(&'a self, it: &fn(&uint, &'a V) -> bool) -> bool {\n-        for i in range(0u, self.v.len()) {\n-            match self.v[i] {\n-              Some(ref elt) => if !it(&i, elt) { return false; },\n-              None => ()\n-            }\n-        }\n-        true\n-    }\n-\n-    /// Visit all keys in order\n-    pub fn each_key(&self, blk: &fn(key: &uint) -> bool) -> bool {\n-        self.each(|k, _| blk(k))\n-    }\n-\n-    /// Visit all values in order\n-    pub fn each_value<'a>(&'a self, blk: &fn(value: &'a V) -> bool) -> bool {\n-        self.each(|_, v| blk(v))\n-    }\n-\n-    /// Iterate over the map and mutate the contained values\n-    pub fn mutate_values(&mut self, it: &fn(&uint, &mut V) -> bool) -> bool {\n-        for i in range(0, self.v.len()) {\n-            match self.v[i] {\n-              Some(ref mut elt) => if !it(&i, elt) { return false; },\n-              None => ()\n-            }\n-        }\n-        true\n-    }\n-\n-    /// Visit all key-value pairs in reverse order\n-    pub fn each_reverse<'a>(&'a self, it: &fn(uint, &'a V) -> bool) -> bool {\n-        do uint::range_rev(self.v.len(), 0) |i| {\n-            match self.v[i] {\n-              Some(ref elt) => it(i, elt),\n-              None => true\n-            }\n-        }\n-    }\n-\n     pub fn get<'a>(&'a self, key: &uint) -> &'a V {\n         self.find(key).expect(\"key not present\")\n     }\n@@ -203,7 +158,7 @@ impl<V> SmallIntMap<V> {\n     {\n         let values = replace(&mut self.v, ~[]);\n         values.consume_iter().enumerate().filter_map(|(i, v)| {\n-            v.map_consume(|v| (i, v))\n+            v.map_move(|v| (i, v))\n         })\n     }\n }"}, {"sha": "daafdbc37182d581a8fc82c4c36ab2939f70daa2", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -469,10 +469,7 @@ impl<T:Clone + Ord> MergeState<T> {\n                 base2: uint, len2: uint) {\n         assert!(len1 != 0 && len2 != 0 && base1+len1 == base2);\n \n-        let mut tmp = ~[];\n-        for i in range(base1, base1+len1) {\n-            tmp.push(array[i].clone());\n-        }\n+        let mut tmp = array.slice(base1, base1 + len1).to_owned();\n \n         let mut c1 = 0;\n         let mut c2 = base2;\n@@ -579,10 +576,7 @@ impl<T:Clone + Ord> MergeState<T> {\n                 base2: uint, len2: uint) {\n         assert!(len1 != 1 && len2 != 0 && base1 + len1 == base2);\n \n-        let mut tmp = ~[];\n-        for i in range(base2, base2+len2) {\n-            tmp.push(array[i].clone());\n-        }\n+        let mut tmp = array.slice(base2, base2 + len2).to_owned();\n \n         let mut c1 = base1 + len1 - 1;\n         let mut c2 = len2 - 1;"}, {"sha": "881d931fe0acc21749287991d5826564c8ded3c8", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -10,6 +10,7 @@\n \n use sort;\n use std::cmp;\n+use std::hashmap;\n use std::io;\n use std::num;\n \n@@ -222,7 +223,7 @@ impl<'self> Stats for &'self [f64] {\n \n // Helper function: extract a value representing the `pct` percentile of a sorted sample-set, using\n // linear interpolation. If samples are not sorted, return nonsensical value.\n-priv fn percentile_of_sorted(sorted_samples: &[f64],\n+fn percentile_of_sorted(sorted_samples: &[f64],\n                              pct: f64) -> f64 {\n     assert!(sorted_samples.len() != 0);\n     if sorted_samples.len() == 1 {\n@@ -352,6 +353,16 @@ pub fn write_boxplot(w: @io::Writer, s: &Summary, width_hint: uint) {\n     w.write_str(histr);\n }\n \n+/// Returns a HashMap with the number of occurences of every element in the\n+/// sequence that the iterator exposes.\n+pub fn freq_count<T: Iterator<U>, U: Eq+Hash>(mut iter: T) -> hashmap::HashMap<U, uint> {\n+    let mut map = hashmap::HashMap::new::<U, uint>();\n+    for elem in iter {\n+        map.insert_or_update_with(elem, 1, |_, count| *count += 1);\n+    }\n+    map\n+}\n+\n // Test vectors generated from R, using the script src/etc/stat-test-vectors.r.\n \n #[cfg(test)]"}, {"sha": "4172c715adb96309701da1228c37f66eb4f492b9", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -935,6 +935,7 @@ mod tests {\n         // child task must have finished by the time try returns\n         do m.lock { }\n     }\n+    #[ignore(reason = \"linked failure\")]\n     #[test] #[ignore(cfg(windows))]\n     fn test_mutex_killed_cond() {\n         // Getting killed during cond wait must not corrupt the mutex while\n@@ -961,6 +962,7 @@ mod tests {\n             assert!(!woken);\n         }\n     }\n+    #[ignore(reason = \"linked failure\")]\n     #[test] #[ignore(cfg(windows))]\n     fn test_mutex_killed_broadcast() {\n         use std::unstable::finally::Finally;"}, {"sha": "d0412b8954db2abc963e43f87979ca96503709c8", "filename": "src/libextra/term.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterm.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -75,7 +75,7 @@ pub mod attr {\n }\n \n #[cfg(not(target_os = \"win32\"))]\n-priv fn cap_for_attr(attr: attr::Attr) -> &'static str {\n+fn cap_for_attr(attr: attr::Attr) -> &'static str {\n     match attr {\n         attr::Bold               => \"bold\",\n         attr::Dim                => \"dim\",\n@@ -127,7 +127,7 @@ impl Terminal {\n         let inf = ti.unwrap();\n         let nc = if inf.strings.find_equiv(&(\"setaf\")).is_some()\n                  && inf.strings.find_equiv(&(\"setab\")).is_some() {\n-                     inf.numbers.find_equiv(&(\"colors\")).map_consume_default(0, |&n| n)\n+                     inf.numbers.find_equiv(&(\"colors\")).map_move_default(0, |&n| n)\n                  } else { 0 };\n \n         return Ok(Terminal {out: out, ti: inf, num_colors: nc});\n@@ -220,7 +220,7 @@ impl Terminal {\n                 cap = self.ti.strings.find_equiv(&(\"op\"));\n             }\n         }\n-        let s = do cap.map_consume_default(Err(~\"can't find terminfo capability `sgr0`\")) |op| {\n+        let s = do cap.map_move_default(Err(~\"can't find terminfo capability `sgr0`\")) |op| {\n             expand(*op, [], &mut Variables::new())\n         };\n         if s.is_ok() {\n@@ -234,7 +234,7 @@ impl Terminal {\n         }\n     }\n \n-    priv fn dim_if_necessary(&self, color: color::Color) -> color::Color {\n+    fn dim_if_necessary(&self, color: color::Color) -> color::Color {\n         if color >= self.num_colors && color >= 8 && color < 16 {\n             color-8\n         } else { color }"}, {"sha": "3edd7f1c66b00a60c6e7755c4d4dee338f08b6e0", "filename": "src/libextra/terminfo/parm.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparm.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -430,7 +430,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n }\n \n #[deriving(Eq)]\n-priv struct Flags {\n+struct Flags {\n     width: uint,\n     precision: uint,\n     alternate: bool,\n@@ -440,13 +440,13 @@ priv struct Flags {\n }\n \n impl Flags {\n-    priv fn new() -> Flags {\n+    fn new() -> Flags {\n         Flags{ width: 0, precision: 0, alternate: false,\n                left: false, sign: false, space: false }\n     }\n }\n \n-priv enum FormatOp {\n+enum FormatOp {\n     FormatDigit,\n     FormatOctal,\n     FormatHex,\n@@ -455,7 +455,7 @@ priv enum FormatOp {\n }\n \n impl FormatOp {\n-    priv fn from_char(c: char) -> FormatOp {\n+    fn from_char(c: char) -> FormatOp {\n         match c {\n             'd' => FormatDigit,\n             'o' => FormatOctal,\n@@ -465,7 +465,7 @@ impl FormatOp {\n             _ => fail!(\"bad FormatOp char\")\n         }\n     }\n-    priv fn to_char(self) -> char {\n+    fn to_char(self) -> char {\n         match self {\n             FormatDigit => 'd',\n             FormatOctal => 'o',\n@@ -477,7 +477,7 @@ impl FormatOp {\n }\n \n #[cfg(stage0)]\n-priv fn format(val: Param, op: FormatOp, flags: Flags) -> Result<~[u8],~str> {\n+fn format(val: Param, op: FormatOp, flags: Flags) -> Result<~[u8],~str> {\n     let mut s = match val {\n         Number(d) => {\n             match op {\n@@ -573,7 +573,7 @@ priv fn format(val: Param, op: FormatOp, flags: Flags) -> Result<~[u8],~str> {\n }\n \n #[cfg(not(stage0))]\n-priv fn format(val: Param, op: FormatOp, flags: Flags) -> Result<~[u8],~str> {\n+fn format(val: Param, op: FormatOp, flags: Flags) -> Result<~[u8],~str> {\n     let mut s = match val {\n         Number(d) => {\n             match op {"}, {"sha": "761cb1bd76f929198e5011cd8595f3840fe30996", "filename": "src/libextra/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -238,20 +238,20 @@ pub fn parse_opts(args: &[~str]) -> OptRes {\n     let run_ignored = getopts::opt_present(&matches, \"ignored\");\n \n     let logfile = getopts::opt_maybe_str(&matches, \"logfile\");\n-    let logfile = logfile.map(|s| Path(*s));\n+    let logfile = logfile.map_move(|s| Path(s));\n \n     let run_benchmarks = getopts::opt_present(&matches, \"bench\");\n     let run_tests = ! run_benchmarks ||\n         getopts::opt_present(&matches, \"test\");\n \n     let ratchet_metrics = getopts::opt_maybe_str(&matches, \"ratchet-metrics\");\n-    let ratchet_metrics = ratchet_metrics.map(|s| Path(*s));\n+    let ratchet_metrics = ratchet_metrics.map_move(|s| Path(s));\n \n     let ratchet_noise_percent = getopts::opt_maybe_str(&matches, \"ratchet-noise-percent\");\n-    let ratchet_noise_percent = ratchet_noise_percent.map(|s| f64::from_str(*s).unwrap());\n+    let ratchet_noise_percent = ratchet_noise_percent.map_move(|s| f64::from_str(s).unwrap());\n \n     let save_metrics = getopts::opt_maybe_str(&matches, \"save-metrics\");\n-    let save_metrics = save_metrics.map(|s| Path(*s));\n+    let save_metrics = save_metrics.map_move(|s| Path(s));\n \n     let test_opts = TestOpts {\n         filter: filter,"}, {"sha": "b7033196b8ac7c5161028b6d6c285ae0f0dc844e", "filename": "src/libextra/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -254,7 +254,7 @@ impl Tm {\n     }\n }\n \n-priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n+fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n     fn match_str(s: &str, pos: uint, needle: &str) -> bool {\n         let mut i = pos;\n         for ch in needle.byte_iter() {\n@@ -691,7 +691,7 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n     }\n }\n \n-priv fn do_strftime(format: &str, tm: &Tm) -> ~str {\n+fn do_strftime(format: &str, tm: &Tm) -> ~str {\n     fn parse_type(ch: char, tm: &Tm) -> ~str {\n         //FIXME (#2350): Implement missing types.\n       let die = || fmt!(\"strftime: can't understand this format %c \", ch);"}, {"sha": "4d898dfb2b4f082d6d8be4cee9562785b3e5db72", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 203, "deletions": 193, "changes": 396, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -13,7 +13,6 @@\n //! `TotalOrd`.\n \n \n-use std::num;\n use std::util::{swap, replace};\n use std::iterator::{FromIterator, Extendable};\n \n@@ -42,39 +41,23 @@ pub struct TreeMap<K, V> {\n \n impl<K: Eq + TotalOrd, V: Eq> Eq for TreeMap<K, V> {\n     fn eq(&self, other: &TreeMap<K, V>) -> bool {\n-        if self.len() != other.len() {\n-            false\n-        } else {\n-            let mut x = self.iter();\n-            let mut y = other.iter();\n-            for _ in range(0u, self.len()) {\n-                if x.next().unwrap() != y.next().unwrap() {\n-                    return false\n-                }\n-            }\n-            true\n-        }\n+        self.len() == other.len() &&\n+            self.iter().zip(other.iter()).all(|(a, b)| a == b)\n     }\n-    fn ne(&self, other: &TreeMap<K, V>) -> bool { !self.eq(other) }\n }\n \n // Lexicographical comparison\n fn lt<K: Ord + TotalOrd, V: Ord>(a: &TreeMap<K, V>,\n                                  b: &TreeMap<K, V>) -> bool {\n-    let mut x = a.iter();\n-    let mut y = b.iter();\n-\n-    let (a_len, b_len) = (a.len(), b.len());\n-    for _ in range(0u, num::min(a_len, b_len)) {\n-        let (key_a, value_a) = x.next().unwrap();\n-        let (key_b, value_b) = y.next().unwrap();\n+    // the Zip iterator is as long as the shortest of a and b.\n+    for ((key_a, value_a), (key_b, value_b)) in a.iter().zip(b.iter()) {\n         if *key_a < *key_b { return true; }\n         if *key_a > *key_b { return false; }\n         if *value_a < *value_b { return true; }\n         if *value_a > *value_b { return false; }\n     }\n \n-    a_len < b_len\n+    a.len() < b.len()\n }\n \n impl<K: Ord + TotalOrd, V: Ord> Ord for TreeMap<K, V> {\n@@ -151,36 +134,11 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n     /// Create an empty TreeMap\n     pub fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n \n-    /// Visit all keys in order\n-    pub fn each_key(&self, f: &fn(&K) -> bool) -> bool {\n-        self.iter().advance(|(k, _)| f(k))\n-    }\n-\n-    /// Visit all values in order\n-    pub fn each_value<'a>(&'a self, f: &fn(&'a V) -> bool) -> bool {\n-        self.iter().advance(|(_, v)| f(v))\n-    }\n-\n     /// Iterate over the map and mutate the contained values\n     pub fn mutate_values(&mut self, f: &fn(&K, &mut V) -> bool) -> bool {\n         mutate_values(&mut self.root, f)\n     }\n \n-    /// Visit all key-value pairs in reverse order\n-    pub fn each_reverse<'a>(&'a self, f: &fn(&'a K, &'a V) -> bool) -> bool {\n-        each_reverse(&self.root, f)\n-    }\n-\n-    /// Visit all keys in reverse order\n-    pub fn each_key_reverse(&self, f: &fn(&K) -> bool) -> bool {\n-        self.each_reverse(|k, _| f(k))\n-    }\n-\n-    /// Visit all values in reverse order\n-    pub fn each_value_reverse(&self, f: &fn(&V) -> bool) -> bool {\n-        self.each_reverse(|_, v| f(v))\n-    }\n-\n     /// Get a lazy iterator over the key-value pairs in the map.\n     /// Requires that it be frozen (immutable).\n     pub fn iter<'a>(&'a self) -> TreeMapIterator<'a, K, V> {\n@@ -192,6 +150,12 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n         }\n     }\n \n+    /// Get a lazy reverse iterator over the key-value pairs in the map.\n+    /// Requires that it be frozen (immutable).\n+    pub fn rev_iter<'a>(&'a self) -> TreeMapRevIterator<'a, K, V> {\n+        TreeMapRevIterator{iter: self.iter()}\n+    }\n+\n     /// Get a lazy iterator that should be initialized using\n     /// `iter_traverse_left`/`iter_traverse_right`/`iter_traverse_complete`.\n     fn iter_for_traversal<'a>(&'a self) -> TreeMapIterator<'a, K, V> {\n@@ -270,20 +234,18 @@ pub struct TreeMapIterator<'self, K, V> {\n     priv remaining_max: uint\n }\n \n-impl<'self, K, V> Iterator<(&'self K, &'self V)> for TreeMapIterator<'self, K, V> {\n-    /// Advance the iterator to the next node (in order) and return a\n-    /// tuple with a reference to the key and value. If there are no\n-    /// more nodes, return `None`.\n-    fn next(&mut self) -> Option<(&'self K, &'self V)> {\n+impl<'self, K, V> TreeMapIterator<'self, K, V> {\n+    #[inline(always)]\n+    fn next_(&mut self, forward: bool) -> Option<(&'self K, &'self V)> {\n         while !self.stack.is_empty() || self.node.is_some() {\n             match *self.node {\n               Some(ref x) => {\n                 self.stack.push(x);\n-                self.node = &x.left;\n+                self.node = if forward { &x.left } else { &x.right };\n               }\n               None => {\n                 let res = self.stack.pop();\n-                self.node = &res.right;\n+                self.node = if forward { &res.right } else { &res.left };\n                 self.remaining_max -= 1;\n                 if self.remaining_min > 0 {\n                     self.remaining_min -= 1;\n@@ -294,13 +256,41 @@ impl<'self, K, V> Iterator<(&'self K, &'self V)> for TreeMapIterator<'self, K, V\n         }\n         None\n     }\n+}\n+\n+impl<'self, K, V> Iterator<(&'self K, &'self V)> for TreeMapIterator<'self, K, V> {\n+    /// Advance the iterator to the next node (in order) and return a\n+    /// tuple with a reference to the key and value. If there are no\n+    /// more nodes, return `None`.\n+    fn next(&mut self) -> Option<(&'self K, &'self V)> {\n+        self.next_(true)\n+    }\n \n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n         (self.remaining_min, Some(self.remaining_max))\n     }\n }\n \n+/// Lazy backward iterator over a map\n+pub struct TreeMapRevIterator<'self, K, V> {\n+    priv iter: TreeMapIterator<'self, K, V>,\n+}\n+\n+impl<'self, K, V> Iterator<(&'self K, &'self V)> for TreeMapRevIterator<'self, K, V> {\n+    /// Advance the iterator to the next node (in order) and return a\n+    /// tuple with a reference to the key and value. If there are no\n+    /// more nodes, return `None`.\n+    fn next(&mut self) -> Option<(&'self K, &'self V)> {\n+        self.iter.next_(false)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        self.iter.size_hint()\n+    }\n+}\n+\n /// iter_traverse_left, iter_traverse_right and iter_traverse_complete are used to\n /// initialize TreeMapIterator pointing to element inside tree structure.\n ///\n@@ -391,6 +381,14 @@ impl<K, V> Iterator<(K, V)> for TreeMapConsumeIterator<K,V> {\n }\n \n impl<'self, T> Iterator<&'self T> for TreeSetIterator<'self, T> {\n+    /// Advance the iterator to the next node (in order). If there are no more nodes, return `None`.\n+    #[inline]\n+    fn next(&mut self) -> Option<&'self T> {\n+        do self.iter.next().map_move |(value, _)| { value }\n+    }\n+}\n+\n+impl<'self, T> Iterator<&'self T> for TreeSetRevIterator<'self, T> {\n     /// Advance the iterator to the next node (in order). If there are no more nodes, return `None`.\n     #[inline]\n     fn next(&mut self) -> Option<&'self T> {\n@@ -449,20 +447,7 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     /// Return true if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n     fn is_disjoint(&self, other: &TreeSet<T>) -> bool {\n-        let mut x = self.iter();\n-        let mut y = other.iter();\n-        let mut a = x.next();\n-        let mut b = y.next();\n-        while a.is_some() && b.is_some() {\n-            let a1 = a.unwrap();\n-            let b1 = b.unwrap();\n-            match a1.cmp(b1) {\n-              Less => a = x.next(),\n-              Greater => b = y.next(),\n-              Equal => return false\n-            }\n-        }\n-        true\n+        self.intersection(other).next().is_none()\n     }\n \n     /// Return true if the set is a subset of another\n@@ -521,6 +506,13 @@ impl<T: TotalOrd> TreeSet<T> {\n         TreeSetIterator{iter: self.map.iter()}\n     }\n \n+    /// Get a lazy iterator over the values in the set.\n+    /// Requires that it be frozen (immutable).\n+    #[inline]\n+    pub fn rev_iter<'a>(&'a self) -> TreeSetRevIterator<'a, T> {\n+        TreeSetRevIterator{iter: self.map.rev_iter()}\n+    }\n+\n     /// Get a lazy iterator pointing to the first value not less than `v` (greater or equal).\n     /// If all elements in the set are less than `v` empty iterator is returned.\n     #[inline]\n@@ -535,138 +527,170 @@ impl<T: TotalOrd> TreeSet<T> {\n         TreeSetIterator{iter: self.map.upper_bound_iter(v)}\n     }\n \n-    /// Visit all values in reverse order\n-    #[inline]\n-    pub fn each_reverse(&self, f: &fn(&T) -> bool) -> bool {\n-        self.map.each_key_reverse(f)\n+    /// Visit the values (in-order) representing the difference\n+    pub fn difference<'a>(&'a self, other: &'a TreeSet<T>) -> Difference<'a, T> {\n+        Difference{a: Focus::new(self.iter()), b: Focus::new(other.iter())}\n     }\n \n-    /// Visit the values (in-order) representing the difference\n-    pub fn difference(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) -> bool {\n-        let mut x = self.iter();\n-        let mut y = other.iter();\n+    /// Visit the values (in-order) representing the symmetric difference\n+    pub fn symmetric_difference<'a>(&'a self, other: &'a TreeSet<T>)\n+        -> SymDifference<'a, T> {\n+        SymDifference{a: Focus::new(self.iter()), b: Focus::new(other.iter())}\n+    }\n \n-        let mut a = x.next();\n-        let mut b = y.next();\n+    /// Visit the values (in-order) representing the intersection\n+    pub fn intersection<'a>(&'a self, other: &'a TreeSet<T>)\n+        -> Intersection<'a, T> {\n+        Intersection{a: Focus::new(self.iter()), b: Focus::new(other.iter())}\n+    }\n \n-        while a.is_some() {\n-            if b.is_none() {\n-                return f(a.unwrap()) && x.advance(f);\n-            }\n+    /// Visit the values (in-order) representing the union\n+    pub fn union<'a>(&'a self, other: &'a TreeSet<T>) -> Union<'a, T> {\n+        Union{a: Focus::new(self.iter()), b: Focus::new(other.iter())}\n+    }\n+}\n \n-            let a1 = a.unwrap();\n-            let b1 = b.unwrap();\n+/// Lazy forward iterator over a set\n+pub struct TreeSetIterator<'self, T> {\n+    priv iter: TreeMapIterator<'self, T, ()>\n+}\n \n-            let cmp = a1.cmp(b1);\n+/// Lazy backward iterator over a set\n+pub struct TreeSetRevIterator<'self, T> {\n+    priv iter: TreeMapRevIterator<'self, T, ()>\n+}\n \n-            if cmp == Less {\n-                if !f(a1) { return false; }\n-                a = x.next();\n-            } else {\n-                if cmp == Equal { a = x.next() }\n-                b = y.next();\n-            }\n-        }\n-        return true;\n-    }\n+// Encapsulate an iterator and hold its latest value until stepped forward\n+struct Focus<A, T> {\n+    priv iter: T,\n+    priv focus: Option<A>,\n+}\n \n-    /// Visit the values (in-order) representing the symmetric difference\n-    pub fn symmetric_difference(&self, other: &TreeSet<T>,\n-                            f: &fn(&T) -> bool) -> bool {\n-        let mut x = self.iter();\n-        let mut y = other.iter();\n+impl<A, T: Iterator<A>> Focus<A, T> {\n+    fn new(mut it: T) -> Focus<A, T> {\n+        Focus{focus: it.next(), iter: it}\n+    }\n+    fn step(&mut self) {\n+        self.focus = self.iter.next()\n+    }\n+}\n \n-        let mut a = x.next();\n-        let mut b = y.next();\n+/// Lazy iterator producing elements in the set difference (in-order)\n+pub struct Difference<'self, T> {\n+    priv a: Focus<&'self T, TreeSetIterator<'self, T>>,\n+    priv b: Focus<&'self T, TreeSetIterator<'self, T>>,\n+}\n \n-        while a.is_some() {\n-            if b.is_none() {\n-                return f(a.unwrap()) && x.advance(f);\n-            }\n+/// Lazy iterator producing elements in the set symmetric difference (in-order)\n+pub struct SymDifference<'self, T> {\n+    priv a: Focus<&'self T, TreeSetIterator<'self, T>>,\n+    priv b: Focus<&'self T, TreeSetIterator<'self, T>>,\n+}\n \n-            let a1 = a.unwrap();\n-            let b1 = b.unwrap();\n+/// Lazy iterator producing elements in the set intersection (in-order)\n+pub struct Intersection<'self, T> {\n+    priv a: Focus<&'self T, TreeSetIterator<'self, T>>,\n+    priv b: Focus<&'self T, TreeSetIterator<'self, T>>,\n+}\n \n-            let cmp = a1.cmp(b1);\n+/// Lazy iterator producing elements in the set intersection (in-order)\n+pub struct Union<'self, T> {\n+    priv a: Focus<&'self T, TreeSetIterator<'self, T>>,\n+    priv b: Focus<&'self T, TreeSetIterator<'self, T>>,\n+}\n \n-            if cmp == Less {\n-                if !f(a1) { return false; }\n-                a = x.next();\n-            } else {\n-                if cmp == Greater {\n-                    if !f(b1) { return false; }\n-                } else {\n-                    a = x.next();\n+impl<'self, T: TotalOrd> Iterator<&'self T> for Difference<'self, T> {\n+    fn next(&mut self) -> Option<&'self T> {\n+        loop {\n+            match (self.a.focus, self.b.focus) {\n+                (None    , _       ) => return None,\n+                (ret     , None    ) => { self.a.step(); return ret },\n+                (Some(a1), Some(b1)) => {\n+                    let cmp = a1.cmp(b1);\n+                    if cmp == Less {\n+                        self.a.step();\n+                        return Some(a1);\n+                    } else {\n+                        if cmp == Equal { self.a.step() }\n+                        self.b.step();\n+                    }\n                 }\n-                b = y.next();\n             }\n         }\n-        b.iter().advance(|&x| f(x)) && y.advance(f)\n     }\n+}\n \n-    /// Visit the values (in-order) representing the intersection\n-    pub fn intersection(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) -> bool {\n-        let mut x = self.iter();\n-        let mut y = other.iter();\n-\n-        let mut a = x.next();\n-        let mut b = y.next();\n-\n-        while a.is_some() && b.is_some() {\n-            let a1 = a.unwrap();\n-            let b1 = b.unwrap();\n-\n-            let cmp = a1.cmp(b1);\n-\n-            if cmp == Less {\n-                a = x.next();\n-            } else {\n-                if cmp == Equal {\n-                    if !f(a1) { return false }\n+impl<'self, T: TotalOrd> Iterator<&'self T> for SymDifference<'self, T> {\n+    fn next(&mut self) -> Option<&'self T> {\n+        loop {\n+            match (self.a.focus, self.b.focus) {\n+                (ret     , None    ) => { self.a.step(); return ret },\n+                (None    , ret     ) => { self.b.step(); return ret },\n+                (Some(a1), Some(b1)) => {\n+                    let cmp = a1.cmp(b1);\n+                    if cmp == Less {\n+                        self.a.step();\n+                        return Some(a1);\n+                    } else {\n+                        self.b.step();\n+                        if cmp == Greater {\n+                            return Some(b1);\n+                        } else {\n+                            self.a.step();\n+                        }\n+                    }\n                 }\n-                b = y.next();\n             }\n         }\n-        return true;\n     }\n+}\n \n-    /// Visit the values (in-order) representing the union\n-    pub fn union(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) -> bool {\n-        let mut x = self.iter();\n-        let mut y = other.iter();\n-\n-        let mut a = x.next();\n-        let mut b = y.next();\n-\n-        while a.is_some() {\n-            if b.is_none() {\n-                return f(a.unwrap()) && x.advance(f);\n+impl<'self, T: TotalOrd> Iterator<&'self T> for Intersection<'self, T> {\n+    fn next(&mut self) -> Option<&'self T> {\n+        loop {\n+            match (self.a.focus, self.b.focus) {\n+                (None    , _       ) => return None,\n+                (_       , None    ) => return None,\n+                (Some(a1), Some(b1)) => {\n+                    let cmp = a1.cmp(b1);\n+                    if cmp == Less {\n+                        self.a.step();\n+                    } else {\n+                        self.b.step();\n+                        if cmp == Equal {\n+                            return Some(a1);\n+                        }\n+                    }\n+                },\n             }\n+        }\n+    }\n+}\n \n-            let a1 = a.unwrap();\n-            let b1 = b.unwrap();\n-\n-            let cmp = a1.cmp(b1);\n-\n-            if cmp == Greater {\n-                if !f(b1) { return false; }\n-                b = y.next();\n-            } else {\n-                if !f(a1) { return false; }\n-                if cmp == Equal {\n-                    b = y.next();\n+impl<'self, T: TotalOrd> Iterator<&'self T> for Union<'self, T> {\n+    fn next(&mut self) -> Option<&'self T> {\n+        loop {\n+            match (self.a.focus, self.b.focus) {\n+                (ret     , None) => { self.a.step(); return ret },\n+                (None    , ret ) => { self.b.step(); return ret },\n+                (Some(a1), Some(b1)) => {\n+                    let cmp = a1.cmp(b1);\n+                    if cmp == Greater {\n+                        self.b.step();\n+                        return Some(b1);\n+                    } else {\n+                        self.a.step();\n+                        if cmp == Equal {\n+                            self.b.step();\n+                        }\n+                        return Some(a1);\n+                    }\n                 }\n-                a = x.next();\n             }\n         }\n-        b.iter().advance(|&x| f(x)) && y.advance(f)\n     }\n }\n \n-/// Lazy forward iterator over a set\n-pub struct TreeSetIterator<'self, T> {\n-    priv iter: TreeMapIterator<'self, T, ()>\n-}\n \n // Nodes keep track of their level in the tree, starting at 1 in the\n // leaves and with a red child sharing the level of the parent.\n@@ -687,18 +711,6 @@ impl<K: TotalOrd, V> TreeNode<K, V> {\n     }\n }\n \n-fn each<'r, K: TotalOrd, V>(node: &'r Option<~TreeNode<K, V>>,\n-                            f: &fn(&'r K, &'r V) -> bool) -> bool {\n-    node.iter().advance(|x| each(&x.left,  |k,v| f(k,v)) && f(&x.key, &x.value) &&\n-                            each(&x.right, |k,v| f(k,v)))\n-}\n-\n-fn each_reverse<'r, K: TotalOrd, V>(node: &'r Option<~TreeNode<K, V>>,\n-                                    f: &fn(&'r K, &'r V) -> bool) -> bool {\n-    node.iter().advance(|x| each_reverse(&x.right, |k,v| f(k,v)) && f(&x.key, &x.value) &&\n-                            each_reverse(&x.left,  |k,v| f(k,v)))\n-}\n-\n fn mutate_values<'r, K: TotalOrd, V>(node: &'r mut Option<~TreeNode<K, V>>,\n                                      f: &fn(&'r K, &'r mut V) -> bool)\n                                   -> bool {\n@@ -1129,7 +1141,7 @@ mod test_treemap {\n     }\n \n     #[test]\n-    fn test_each_reverse() {\n+    fn test_rev_iter() {\n         let mut m = TreeMap::new();\n \n         assert!(m.insert(3, 6));\n@@ -1139,12 +1151,11 @@ mod test_treemap {\n         assert!(m.insert(1, 2));\n \n         let mut n = 4;\n-        do m.each_reverse |k, v| {\n+        for (k, v) in m.rev_iter() {\n             assert_eq!(*k, n);\n             assert_eq!(*v, n * 2);\n             n -= 1;\n-            true\n-        };\n+        }\n     }\n \n     #[test]\n@@ -1405,7 +1416,7 @@ mod test_set {\n     }\n \n     #[test]\n-    fn test_each_reverse() {\n+    fn test_rev_iter() {\n         let mut m = TreeSet::new();\n \n         assert!(m.insert(3));\n@@ -1415,11 +1426,10 @@ mod test_set {\n         assert!(m.insert(1));\n \n         let mut n = 4;\n-        do m.each_reverse |x| {\n+        for x in m.rev_iter() {\n             assert_eq!(*x, n);\n             n -= 1;\n-            true\n-        };\n+        }\n     }\n \n     fn check(a: &[int], b: &[int], expected: &[int],\n@@ -1442,7 +1452,7 @@ mod test_set {\n     #[test]\n     fn test_intersection() {\n         fn check_intersection(a: &[int], b: &[int], expected: &[int]) {\n-            check(a, b, expected, |x, y, z| x.intersection(y, z))\n+            check(a, b, expected, |x, y, f| x.intersection(y).advance(f))\n         }\n \n         check_intersection([], [], []);\n@@ -1458,7 +1468,7 @@ mod test_set {\n     #[test]\n     fn test_difference() {\n         fn check_difference(a: &[int], b: &[int], expected: &[int]) {\n-            check(a, b, expected, |x, y, z| x.difference(y, z))\n+            check(a, b, expected, |x, y, f| x.difference(y).advance(f))\n         }\n \n         check_difference([], [], []);\n@@ -1476,7 +1486,7 @@ mod test_set {\n     fn test_symmetric_difference() {\n         fn check_symmetric_difference(a: &[int], b: &[int],\n                                       expected: &[int]) {\n-            check(a, b, expected, |x, y, z| x.symmetric_difference(y, z))\n+            check(a, b, expected, |x, y, f| x.symmetric_difference(y).advance(f))\n         }\n \n         check_symmetric_difference([], [], []);\n@@ -1491,7 +1501,7 @@ mod test_set {\n     fn test_union() {\n         fn check_union(a: &[int], b: &[int],\n                                       expected: &[int]) {\n-            check(a, b, expected, |x, y, z| x.union(y, z))\n+            check(a, b, expected, |x, y, f| x.union(y).advance(f))\n         }\n \n         check_union([], [], []);"}, {"sha": "b4ba8acae476974cff76b27e2945718900e12350", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -221,7 +221,7 @@ fn digest<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n fn digest_file(path: &Path) -> ~str {\n     let mut sha = ~Sha1::new();\n     let s = io::read_whole_file_str(path);\n-    (*sha).input_str(*s.get_ref());\n+    (*sha).input_str(s.unwrap());\n     (*sha).result_str()\n }\n \n@@ -378,7 +378,7 @@ fn test() {\n     let pth = Path(\"foo.c\");\n     {\n         let r = io::file_writer(&pth, [io::Create]);\n-        r.get_ref().write_str(\"int main() { return 0; }\");\n+        r.unwrap().write_str(\"int main() { return 0; }\");\n     }\n \n     let cx = Context::new(RWArc::new(Database::new(Path(\"db.json\"))),"}, {"sha": "010486cdf855c7747df7c33c46362d3b1cd69f95", "filename": "src/librust/rust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrust%2Frust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrust%2Frust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrust%2Frust.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -130,7 +130,7 @@ fn rustc_help() {\n fn find_cmd(command_string: &str) -> Option<Command> {\n     do COMMANDS.iter().find_ |command| {\n         command.cmd == command_string\n-    }.map_consume(|x| *x)\n+    }.map_move(|x| *x)\n }\n \n fn cmd_help(args: &[~str]) -> ValidUsage {"}, {"sha": "61ab826e9ee51f5728c25c15edbdaca8d89c355c", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -669,8 +669,7 @@ pub fn build_session_options(binary: @str,\n         } else if opt_present(matches, \"emit-llvm\") {\n             link::output_type_bitcode\n         } else { link::output_type_exe };\n-    let sysroot_opt = getopts::opt_maybe_str(matches, \"sysroot\");\n-    let sysroot_opt = sysroot_opt.map(|m| @Path(*m));\n+    let sysroot_opt = getopts::opt_maybe_str(matches, \"sysroot\").map_move(|m| @Path(m));\n     let target_opt = getopts::opt_maybe_str(matches, \"target\");\n     let target_feature_opt = getopts::opt_maybe_str(matches, \"target-feature\");\n     let save_temps = getopts::opt_present(matches, \"save-temps\");"}, {"sha": "d6584846655d2db01bc28f9cbfdabfcc699a7ce8", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -61,7 +61,9 @@ fn fold_mod(cx: @Context, m: &ast::_mod, fld: @fold::ast_fold) -> ast::_mod {\n         filter_item(cx, *a).chain(|x| fld.fold_item(x))\n     }.collect();\n     let filtered_view_items = do m.view_items.iter().filter_map |a| {\n-        filter_view_item(cx, a).map(|&x| fld.fold_view_item(x))\n+        do filter_view_item(cx, a).map_move |x| {\n+            fld.fold_view_item(x)\n+        }\n     }.collect();\n     ast::_mod {\n         view_items: filtered_view_items,\n@@ -83,7 +85,9 @@ fn fold_foreign_mod(\n ) -> ast::foreign_mod {\n     let filtered_items = nm.items.iter().filter_map(|a| filter_foreign_item(cx, *a)).collect();\n     let filtered_view_items = do nm.view_items.iter().filter_map |a| {\n-        filter_view_item(cx, a).map(|&x| fld.fold_view_item(x))\n+        do filter_view_item(cx, a).map_move |x| {\n+            fld.fold_view_item(x)\n+        }\n     }.collect();\n     ast::foreign_mod {\n         sort: nm.sort,\n@@ -138,7 +142,7 @@ fn fold_block(\n         filter_stmt(cx, *a).chain(|stmt| fld.fold_stmt(stmt))\n     }.collect();\n     let filtered_view_items = do b.view_items.iter().filter_map |a| {\n-        filter_view_item(cx, a).map(|&x| fld.fold_view_item(x))\n+        filter_view_item(cx, a).map(|x| fld.fold_view_item(*x))\n     }.collect();\n     ast::Block {\n         view_items: filtered_view_items,"}, {"sha": "e879168eabff2d55d69e0095ed4bfd4038564abe", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -2159,7 +2159,7 @@ impl TypeNames {\n     }\n \n     pub fn find_type(&self, s: &str) -> Option<Type> {\n-        self.named_types.find_equiv(&s).map_consume(|x| Type::from_ref(*x))\n+        self.named_types.find_equiv(&s).map_move(|x| Type::from_ref(*x))\n     }\n \n     // We have a depth count, because we seem to make infinite types."}, {"sha": "a5f541412ded9b84715b777e58f1c4aabdc093eb", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -133,7 +133,7 @@ pub fn add_extern_mod_stmt_cnum(cstore: &mut CStore,\n pub fn find_extern_mod_stmt_cnum(cstore: &CStore,\n                                  emod_id: ast::NodeId)\n                        -> Option<ast::CrateNum> {\n-    cstore.extern_mod_crate_map.find(&emod_id).map_consume(|x| *x)\n+    cstore.extern_mod_crate_map.find(&emod_id).map_move(|x| *x)\n }\n \n #[deriving(Clone)]"}, {"sha": "8d3571260184b679ec621756110ac3230e021c0c", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -198,8 +198,8 @@ fn item_def_id(d: ebml::Doc, cdata: cmd) -> ast::def_id {\n }\n \n fn get_provided_source(d: ebml::Doc, cdata: cmd) -> Option<ast::def_id> {\n-    do reader::maybe_get_doc(d, tag_item_method_provided_source).map |doc| {\n-        translate_def_id(cdata, reader::with_doc_data(*doc, parse_def_id))\n+    do reader::maybe_get_doc(d, tag_item_method_provided_source).map_move |doc| {\n+        translate_def_id(cdata, reader::with_doc_data(doc, parse_def_id))\n     }\n }\n \n@@ -265,10 +265,10 @@ fn item_ty_param_defs(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd,\n }\n \n fn item_ty_region_param(item: ebml::Doc) -> Option<ty::region_variance> {\n-    reader::maybe_get_doc(item, tag_region_param).map(|doc| {\n-        let mut decoder = reader::Decoder(*doc);\n+    do reader::maybe_get_doc(item, tag_region_param).map_move |doc| {\n+        let mut decoder = reader::Decoder(doc);\n         Decodable::decode(&mut decoder)\n-    })\n+    }\n }\n \n fn item_ty_param_count(item: ebml::Doc) -> uint {\n@@ -415,7 +415,7 @@ pub fn get_impl_trait(cdata: cmd,\n                        tcx: ty::ctxt) -> Option<@ty::TraitRef>\n {\n     let item_doc = lookup_item(id, cdata.data);\n-    do reader::maybe_get_doc(item_doc, tag_item_trait_ref).map |&tp| {\n+    do reader::maybe_get_doc(item_doc, tag_item_trait_ref).map_move |tp| {\n         @doc_trait_ref(tp, tcx, cdata)\n     }\n }"}, {"sha": "88e168db5584f7baabcd24290976f35e9a92cfb5", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -159,10 +159,10 @@ impl<'self> CheckLoanCtxt<'self> {\n             true\n         };\n \n-        for i in range(0u, new_loan_indices.len()) {\n-            let old_loan = &self.all_loans[new_loan_indices[i]];\n-            for j in range(i+1, new_loan_indices.len()) {\n-                let new_loan = &self.all_loans[new_loan_indices[j]];\n+        for (i, &x) in new_loan_indices.iter().enumerate() {\n+            let old_loan = &self.all_loans[x];\n+            for &y in new_loan_indices.slice_from(i+1).iter() {\n+                let new_loan = &self.all_loans[y];\n                 self.report_error_if_loans_conflict(old_loan, new_loan);\n             }\n         }"}, {"sha": "d410021063c238496b76f4ce94ce296d7468a7b6", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -286,13 +286,15 @@ pub fn opt_loan_path(cmt: mc::cmt) -> Option<@LoanPath> {\n         }\n \n         mc::cat_deref(cmt_base, _, _) => {\n-            opt_loan_path(cmt_base).map(\n-                |&lp| @LpExtend(lp, cmt.mutbl, LpDeref))\n+            do opt_loan_path(cmt_base).map_move |lp| {\n+                @LpExtend(lp, cmt.mutbl, LpDeref)\n+            }\n         }\n \n         mc::cat_interior(cmt_base, ik) => {\n-            opt_loan_path(cmt_base).map(\n-                |&lp| @LpExtend(lp, cmt.mutbl, LpInterior(ik)))\n+            do opt_loan_path(cmt_base).map_move |lp| {\n+                @LpExtend(lp, cmt.mutbl, LpInterior(ik))\n+            }\n         }\n \n         mc::cat_downcast(cmt_base) |"}, {"sha": "3b56764f2fcad1afb0f38f41df22a46f744d794c", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -493,9 +493,9 @@ pub fn compare_lit_exprs(tcx: middle::ty::ctxt, a: &expr, b: &expr) -> Option<in\n }\n \n pub fn lit_expr_eq(tcx: middle::ty::ctxt, a: &expr, b: &expr) -> Option<bool> {\n-    compare_lit_exprs(tcx, a, b).map(|&val| val == 0)\n+    compare_lit_exprs(tcx, a, b).map_move(|val| val == 0)\n }\n \n pub fn lit_eq(a: &lit, b: &lit) -> Option<bool> {\n-    compare_const_vals(&lit_to_const(a), &lit_to_const(b)).map(|&val| val == 0)\n+    compare_const_vals(&lit_to_const(a), &lit_to_const(b)).map_move(|val| val == 0)\n }"}, {"sha": "46b6d2214ae49dac47703d4c1de09fe3bb957171", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -983,10 +983,10 @@ fn bitwise(out_vec: &mut [uint],\n            op: &fn(uint, uint) -> uint) -> bool {\n     assert_eq!(out_vec.len(), in_vec.len());\n     let mut changed = false;\n-    for i in range(0u, out_vec.len()) {\n-        let old_val = out_vec[i];\n-        let new_val = op(old_val, in_vec[i]);\n-        out_vec[i] = new_val;\n+    for (out_elt, in_elt) in out_vec.mut_iter().zip(in_vec.iter()) {\n+        let old_val = *out_elt;\n+        let new_val = op(old_val, *in_elt);\n+        *out_elt = new_val;\n         changed |= (old_val != new_val);\n     }\n     changed"}, {"sha": "46394454d006f80e8f3d84cc2b58cc8c7b4cf1e2", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -187,12 +187,12 @@ impl<N,E> Graph<N,E> {\n \n     pub fn each_node(&self, f: &fn(NodeIndex, &Node<N>) -> bool) -> bool {\n         //! Iterates over all edges defined in the graph.\n-        range(0u, self.nodes.len()).advance(|i| f(NodeIndex(i), &self.nodes[i]))\n+        self.nodes.iter().enumerate().advance(|(i, node)| f(NodeIndex(i), node))\n     }\n \n     pub fn each_edge(&self, f: &fn(EdgeIndex, &Edge<E>) -> bool) -> bool {\n-        //! Iterates over all edges defined in the graph.\n-        range(0u, self.nodes.len()).advance(|i| f(EdgeIndex(i), &self.edges[i]))\n+        //! Iterates over all edges defined in the graph\n+        self.edges.iter().enumerate().advance(|(i, edge)| f(EdgeIndex(i), edge))\n     }\n \n     pub fn each_outgoing_edge(&self,"}, {"sha": "42bc435a58a944c48c30bf1b914a4a677c82784f", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -393,7 +393,7 @@ impl<'self> LanguageItemCollector<'self> {\n             return;    // Didn't match.\n         }\n \n-        let item_index = self.item_refs.find(&value).map(|x| **x);\n+        let item_index = self.item_refs.find(&value).map_move(|x| *x);\n         // prevent borrow checker from considering   ^~~~~~~~~~~\n         // self to be borrowed (annoying)\n "}, {"sha": "b39616304906bb4a02a4936c74091446bff12a57", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -607,9 +607,9 @@ impl Liveness {\n         match expr.node {\n           expr_path(_) => {\n             let def = self.tcx.def_map.get_copy(&expr.id);\n-            moves::moved_variable_node_id_from_def(def).map(\n-                |rdef| self.variable(*rdef, expr.span)\n-            )\n+            do moves::moved_variable_node_id_from_def(def).map_move |rdef| {\n+                self.variable(rdef, expr.span)\n+            }\n           }\n           _ => None\n         }\n@@ -623,9 +623,9 @@ impl Liveness {\n                                  -> Option<Variable> {\n         match self.tcx.def_map.find(&node_id) {\n           Some(&def) => {\n-            moves::moved_variable_node_id_from_def(def).map(\n-                |rdef| self.variable(*rdef, span)\n-            )\n+            do moves::moved_variable_node_id_from_def(def).map_move |rdef| {\n+                self.variable(rdef, span)\n+            }\n           }\n           None => {\n             self.tcx.sess.span_bug("}, {"sha": "4da22be4428e271f60b8de66ad1da2f1c440a853", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -111,7 +111,7 @@ impl RegionMaps {\n     pub fn opt_encl_scope(&self, id: ast::NodeId) -> Option<ast::NodeId> {\n         //! Returns the narrowest scope that encloses `id`, if any.\n \n-        self.scope_map.find(&id).map(|&x| *x)\n+        self.scope_map.find(&id).map_move(|x| *x)\n     }\n \n     pub fn encl_scope(&self, id: ast::NodeId) -> ast::NodeId {\n@@ -579,8 +579,7 @@ impl DetermineRpCtxt {\n     /// the new variance is joined with the old variance.\n     pub fn add_rp(&mut self, id: ast::NodeId, variance: region_variance) {\n         assert!(id != 0);\n-        let old_variance = self.region_paramd_items.find(&id).\n-                                map_consume(|x| *x);\n+        let old_variance = self.region_paramd_items.find(&id).map_move(|x| *x);\n         let joined_variance = match old_variance {\n           None => variance,\n           Some(v) => join_variance(v, variance)"}, {"sha": "f55fdd22c9a9f8bcd91889887db598a33fc367da", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -13,7 +13,7 @@ use driver::session::Session;\n use metadata::csearch::{each_path, get_trait_method_def_ids};\n use metadata::csearch::get_method_name_and_explicit_self;\n use metadata::csearch::get_static_methods_if_impl;\n-use metadata::csearch::get_type_name_if_impl;\n+use metadata::csearch::{get_type_name_if_impl, get_struct_fields};\n use metadata::cstore::find_extern_mod_stmt_cnum;\n use metadata::decoder::{def_like, dl_def, dl_field, dl_impl};\n use middle::lang_items::LanguageItems;\n@@ -1700,9 +1700,12 @@ impl Resolver {\n           }\n           def_struct(def_id) => {\n             debug!(\"(building reduced graph for external \\\n-                    crate) building type %s\",\n+                    crate) building type and value for %s\",\n                    final_ident);\n             child_name_bindings.define_type(privacy, def, dummy_sp());\n+            if get_struct_fields(self.session.cstore, def_id).len() == 0 {\n+                child_name_bindings.define_value(privacy, def, dummy_sp());\n+            }\n             self.structs.insert(def_id);\n           }\n           def_method(*) => {\n@@ -3358,7 +3361,7 @@ impl Resolver {\n                   // item, it's ok\n                   match def {\n                     def_ty_param(did, _)\n-                        if self.def_map.find(&did.node).map_consume(|x| *x)\n+                        if self.def_map.find(&did.node).map_move(|x| *x)\n                             == Some(def_typaram_binder(item_id)) => {\n                       // ok\n                     }"}, {"sha": "6b51832e8e337d1cdff995b9f94266cf8003b5c6", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -93,7 +93,7 @@ pub use middle::trans::context::task_llcx;\n static task_local_insn_key: local_data::Key<@~[&'static str]> = &local_data::Key;\n \n pub fn with_insn_ctxt(blk: &fn(&[&'static str])) {\n-    let opt = local_data::get(task_local_insn_key, |k| k.map(|&k| *k));\n+    let opt = local_data::get(task_local_insn_key, |k| k.map_move(|k| *k));\n     if opt.is_some() {\n         blk(*opt.unwrap());\n     }\n@@ -109,7 +109,7 @@ pub struct _InsnCtxt { _x: () }\n impl Drop for _InsnCtxt {\n     fn drop(&self) {\n         do local_data::modify(task_local_insn_key) |c| {\n-            do c.map_consume |ctx| {\n+            do c.map_move |ctx| {\n                 let mut ctx = (*ctx).clone();\n                 ctx.pop();\n                 @ctx\n@@ -121,7 +121,7 @@ impl Drop for _InsnCtxt {\n pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n     debug!(\"new InsnCtxt: %s\", s);\n     do local_data::modify(task_local_insn_key) |c| {\n-        do c.map_consume |ctx| {\n+        do c.map_move |ctx| {\n             let mut ctx = (*ctx).clone();\n             ctx.push(s);\n             @ctx\n@@ -1743,8 +1743,7 @@ pub fn copy_args_to_allocas(fcx: @mut FunctionContext,\n         _ => {}\n     }\n \n-    for arg_n in range(0u, arg_tys.len()) {\n-        let arg_ty = arg_tys[arg_n];\n+    for (arg_n, &arg_ty) in arg_tys.iter().enumerate() {\n         let raw_llarg = raw_llargs[arg_n];\n \n         // For certain mode/type combinations, the raw llarg values are passed"}, {"sha": "f5fb68a70578c2fcf60536019877e5f00e07d236", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -159,7 +159,7 @@ fn struct_ty(ty: Type,\n              padding: Option<Type>,\n              coerce: bool) -> Type {\n     let size = ty_size(ty) * 8;\n-    let mut fields = padding.map_default(~[], |p| ~[*p]);\n+    let mut fields = padding.map_move_default(~[], |p| ~[p]);\n \n     if coerce {\n         fields = vec::append(fields, coerce_to_int(size));"}, {"sha": "dd24ec3ff1ac198222cecf77cb54afb0b97cfa1d", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -145,8 +145,8 @@ fn classify_ty(ty: Type) -> ~[RegClass] {\n     }\n \n     fn all_mem(cls: &mut [RegClass]) {\n-        for i in range(0u, cls.len()) {\n-            cls[i] = Memory;\n+        for elt in cls.mut_iter() {\n+            *elt = Memory;\n         }\n     }\n "}, {"sha": "f756460bd028b74e79c3d9832832945714f4a02a", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -1011,8 +1011,7 @@ pub fn node_id_type_params(bcx: @mut Block, id: ast::NodeId) -> ~[ty::t] {\n pub fn node_vtables(bcx: @mut Block, id: ast::NodeId)\n                  -> Option<typeck::vtable_res> {\n     let raw_vtables = bcx.ccx().maps.vtable_map.find(&id);\n-    raw_vtables.map(\n-        |&vts| resolve_vtables_in_fn_ctxt(bcx.fcx, *vts))\n+    raw_vtables.map_move(|vts| resolve_vtables_in_fn_ctxt(bcx.fcx, *vts))\n }\n \n pub fn resolve_vtables_in_fn_ctxt(fcx: &FunctionContext, vts: typeck::vtable_res)"}, {"sha": "a644174731ab47940b9c08e6484e4a9468d73ebe", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -248,7 +248,7 @@ impl Drop for CrateContext {\n static task_local_llcx_key: local_data::Key<@ContextRef> = &local_data::Key;\n \n pub fn task_llcx() -> ContextRef {\n-    let opt = local_data::get(task_local_llcx_key, |k| k.map(|&k| *k));\n+    let opt = local_data::get(task_local_llcx_key, |k| k.map_move(|k| *k));\n     *opt.expect(\"task-local LLVMContextRef wasn't ever set!\")\n }\n "}, {"sha": "f2c63164c82380850f3da7db04e37b59df68bf25", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -163,7 +163,7 @@ pub fn trans_method_callee(bcx: @mut Block,\n                 data: Method(MethodData {\n                     llfn: callee_fn.llfn,\n                     llself: val,\n-                    temp_cleanup: temp_cleanups.head_opt().map(|&v| *v),\n+                    temp_cleanup: temp_cleanups.head_opt().map_move(|v| *v),\n                     self_ty: node_id_type(bcx, this.id),\n                     self_mode: mentry.self_mode,\n                 })\n@@ -340,7 +340,7 @@ pub fn trans_monomorphized_callee(bcx: @mut Block,\n               data: Method(MethodData {\n                   llfn: llfn_val,\n                   llself: llself_val,\n-                  temp_cleanup: temp_cleanups.head_opt().map(|&v| *v),\n+                  temp_cleanup: temp_cleanups.head_opt().map_move(|v| *v),\n                   self_ty: node_id_type(bcx, base.id),\n                   self_mode: mentry.self_mode,\n               })"}, {"sha": "f25bf011f5d062f56c2130bb570bc725dc40e3d8", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -206,15 +206,8 @@ pub fn type_uses_for(ccx: @mut CrateContext, fn_id: def_id, n_tps: uint)\n \n pub fn type_needs(cx: &Context, use_: uint, ty: ty::t) {\n     // Optimization -- don't descend type if all params already have this use\n-    let len = {\n-        let uses = &*cx.uses;\n-        uses.len()\n-    };\n-    for i in range(0u, len) {\n-        if cx.uses[i] & use_ != use_ {\n-            type_needs_inner(cx, use_, ty, @Nil);\n-            return;\n-        }\n+    if cx.uses.iter().any(|&elt| elt & use_ != use_) {\n+        type_needs_inner(cx, use_, ty, @Nil);\n     }\n }\n "}, {"sha": "849c35cdd2c038eec2662fbf09c77466a2edcfb0", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -3557,7 +3557,7 @@ pub fn def_has_ty_params(def: ast::def) -> bool {\n \n pub fn provided_source(cx: ctxt, id: ast::def_id)\n     -> Option<ast::def_id> {\n-    cx.provided_method_sources.find(&id).map(|x| **x)\n+    cx.provided_method_sources.find(&id).map_move(|x| *x)\n }\n \n pub fn provided_trait_methods(cx: ctxt, id: ast::def_id) -> ~[@Method] {\n@@ -3710,8 +3710,9 @@ fn struct_ctor_id(cx: ctxt, struct_did: ast::def_id) -> Option<ast::def_id> {\n         Some(&ast_map::node_item(item, _)) => {\n             match item.node {\n                 ast::item_struct(struct_def, _) => {\n-                    struct_def.ctor_id.map(|ctor_id|\n-                        ast_util::local_def(*ctor_id))\n+                    do struct_def.ctor_id.map_move |ctor_id| {\n+                        ast_util::local_def(ctor_id)\n+                    }\n                 }\n                 _ => cx.sess.bug(\"called struct_ctor_id on non-struct\")\n             }\n@@ -4443,15 +4444,15 @@ pub fn count_traits_and_supertraits(tcx: ctxt,\n }\n \n pub fn get_tydesc_ty(tcx: ctxt) -> Result<t, ~str> {\n-    do tcx.lang_items.require(TyDescStructLangItem).map |tydesc_lang_item| {\n-        tcx.intrinsic_defs.find_copy(tydesc_lang_item)\n+    do tcx.lang_items.require(TyDescStructLangItem).map_move |tydesc_lang_item| {\n+        tcx.intrinsic_defs.find_copy(&tydesc_lang_item)\n             .expect(\"Failed to resolve TyDesc\")\n     }\n }\n \n pub fn get_opaque_ty(tcx: ctxt) -> Result<t, ~str> {\n-    do tcx.lang_items.require(OpaqueStructLangItem).map |opaque_lang_item| {\n-        tcx.intrinsic_defs.find_copy(opaque_lang_item)\n+    do tcx.lang_items.require(OpaqueStructLangItem).map_move |opaque_lang_item| {\n+        tcx.intrinsic_defs.find_copy(&opaque_lang_item)\n             .expect(\"Failed to resolve Opaque\")\n     }\n }"}, {"sha": "750bd506f3e48583a66c7740b1aeb1806dba6d57", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -621,9 +621,9 @@ fn ty_of_method_or_bare_fn<AC:AstConv,RS:region_scope + Clone + 'static>(\n         in_binding_rscope(rscope,\n                           RegionParamNames(bound_lifetime_names.clone()));\n \n-    let opt_transformed_self_ty = opt_self_info.map(|&self_info| {\n+    let opt_transformed_self_ty = do opt_self_info.map_move |self_info| {\n         transform_self_ty(this, &rb, self_info)\n-    });\n+    };\n \n     let input_tys = decl.inputs.map(|a| ty_of_arg(this, &rb, a, None));\n "}, {"sha": "d8a9350e695d70404f3250bb904ab818d0eebb49", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -158,9 +158,9 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: &ast::Path,\n                 None => {\n                     fcx.infcx().type_error_message_str_with_expected(pat.span,\n                                                        |expected, actual| {\n-                                                       expected.map_default(~\"\", |e| {\n+                                                       expected.map_move_default(~\"\", |e| {\n                         fmt!(\"mismatched types: expected `%s` but found %s\",\n-                             *e, actual)})},\n+                             e, actual)})},\n                              Some(expected), ~\"a structure pattern\",\n                              None);\n                     fcx.write_error(pat.id);\n@@ -201,9 +201,9 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: &ast::Path,\n         _ => {\n             fcx.infcx().type_error_message_str_with_expected(pat.span,\n                                                |expected, actual| {\n-                                               expected.map_default(~\"\", |e| {\n+                                               expected.map_move_default(~\"\", |e| {\n                     fmt!(\"mismatched types: expected `%s` but found %s\",\n-                         *e, actual)})},\n+                         e, actual)})},\n                     Some(expected), ~\"an enum or structure pattern\",\n                     None);\n             fcx.write_error(pat.id);\n@@ -535,9 +535,9 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n                     _ => ty::terr_mismatch\n                 };\n                 fcx.infcx().type_error_message_str_with_expected(pat.span, |expected, actual| {\n-                expected.map_default(~\"\", |e| {\n+                expected.map_move_default(~\"\", |e| {\n                     fmt!(\"mismatched types: expected `%s` but found %s\",\n-                                     *e, actual)})}, Some(expected), ~\"tuple\", Some(&type_error));\n+                                     e, actual)})}, Some(expected), ~\"tuple\", Some(&type_error));\n                 fcx.write_error(pat.id);\n             }\n         }\n@@ -584,9 +584,9 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n               fcx.infcx().type_error_message_str_with_expected(\n                   pat.span,\n                   |expected, actual| {\n-                      expected.map_default(~\"\", |e| {\n+                      expected.map_move_default(~\"\", |e| {\n                           fmt!(\"mismatched types: expected `%s` but found %s\",\n-                               *e, actual)})},\n+                               e, actual)})},\n                   Some(expected),\n                   ~\"a vector pattern\",\n                   None);\n@@ -642,9 +642,9 @@ pub fn check_pointer_pat(pcx: &pat_ctxt,\n             fcx.infcx().type_error_message_str_with_expected(\n                 span,\n                 |expected, actual| {\n-                    expected.map_default(~\"\", |e| {\n+                    expected.map_move_default(~\"\", |e| {\n                         fmt!(\"mismatched types: expected `%s` but found %s\",\n-                             *e, actual)})},\n+                             e, actual)})},\n                 Some(expected),\n                 fmt!(\"%s pattern\", match pointer_kind {\n                     Managed => \"an @-box\","}, {"sha": "ae0a95688ed20dfef1b5c1607283f9518d0cd8b3", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -772,8 +772,8 @@ impl<'self> LookupContext<'self> {\n             self.tcx().sess.span_err(\n                 self.expr.span,\n                 \"multiple applicable methods in scope\");\n-            for idx in range(0u, relevant_candidates.len()) {\n-                self.report_candidate(idx, &relevant_candidates[idx].origin);\n+            for (idx, candidate) in relevant_candidates.iter().enumerate() {\n+                self.report_candidate(idx, &candidate.origin);\n             }\n         }\n "}, {"sha": "da0e219310fde2b64b3f325b892d7cd5d028acc5", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -364,8 +364,8 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n                 |br| ty::re_free(ty::FreeRegion {scope_id: body.id,\n                                                  bound_region: br}));\n         let opt_self_info =\n-            opt_self_info.map(\n-                |si| SelfInfo {self_ty: opt_self_ty.unwrap(), ..*si});\n+            opt_self_info.map_move(\n+                |si| SelfInfo {self_ty: opt_self_ty.unwrap(), .. si});\n         (isr, opt_self_info, fn_sig)\n     };\n \n@@ -536,7 +536,7 @@ pub fn check_method(ccx: @mut CrateCtxt,\n {\n     let method_def_id = local_def(method.id);\n     let method_ty = ty::method(ccx.tcx, method_def_id);\n-    let opt_self_info = method_ty.transformed_self_ty.map(|&ty| {\n+    let opt_self_info = method_ty.transformed_self_ty.map_move(|ty| {\n         SelfInfo {self_ty: ty,\n                   self_id: method.self_id,\n                   span: method.explicit_self.span}\n@@ -557,7 +557,7 @@ pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n \n     for p in fields.iter() {\n         let (id, sp) = *p;\n-        let orig_sp = field_names.find(&id).map_consume(|x| *x);\n+        let orig_sp = field_names.find(&id).map_move(|x| *x);\n         match orig_sp {\n             Some(orig_sp) => {\n                 tcx.sess.span_err(sp, fmt!(\"Duplicate field name %s in record type declaration\",\n@@ -601,7 +601,7 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n         check_bare_fn(ccx, decl, body, it.id, None);\n       }\n       ast::item_impl(_, _, _, ref ms) => {\n-        let rp = ccx.tcx.region_paramd_items.find(&it.id).map_consume(|x| *x);\n+        let rp = ccx.tcx.region_paramd_items.find(&it.id).map_move(|x| *x);\n         debug!(\"item_impl %s with id %d rp %?\",\n                ccx.tcx.sess.str_of(it.ident), it.id, rp);\n         for m in ms.iter() {\n@@ -1877,8 +1877,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         for field in ast_fields.iter() {\n             let mut expected_field_type = ty::mk_err();\n \n-            let pair = class_field_map.find(&field.ident).\n-                                       map_consume(|x| *x);\n+            let pair = class_field_map.find(&field.ident).map_move(|x| *x);\n             match pair {\n                 None => {\n                     tcx.sess.span_err(\n@@ -1962,7 +1961,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         if class_id.crate == ast::LOCAL_CRATE {\n             region_parameterized =\n                 tcx.region_paramd_items.find(&class_id.node).\n-                    map_consume(|x| *x);\n+                    map_move(|x| *x);\n             match tcx.items.find(&class_id.node) {\n                 Some(&ast_map::node_item(@ast::item {\n                         node: ast::item_struct(_, ref generics),\n@@ -2050,7 +2049,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let raw_type;\n         if enum_id.crate == ast::LOCAL_CRATE {\n             region_parameterized =\n-                tcx.region_paramd_items.find(&enum_id.node).map_consume(|x| *x);\n+                tcx.region_paramd_items.find(&enum_id.node).map_move(|x| *x);\n             match tcx.items.find(&enum_id.node) {\n                 Some(&ast_map::node_item(@ast::item {\n                         node: ast::item_enum(_, ref generics),"}, {"sha": "cb4827104b6275e7f63506060f1146cac7430ec1", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -40,9 +40,9 @@ pub fn replace_bound_regions_in_fn_sig(\n \n     debug!(\"replace_bound_regions_in_fn_sig(self_ty=%?, fn_sig=%s, \\\n             all_tys=%?)\",\n-           opt_self_ty.map(|&t| ppaux::ty_to_str(tcx, t)),\n+           opt_self_ty.map(|t| ppaux::ty_to_str(tcx, *t)),\n            ppaux::fn_sig_to_str(tcx, fn_sig),\n-           all_tys.map(|&t| ppaux::ty_to_str(tcx, t)));\n+           all_tys.map(|t| ppaux::ty_to_str(tcx, *t)));\n     let _i = indenter();\n \n     let isr = do create_bound_region_mapping(tcx, isr, all_tys) |br| {\n@@ -52,12 +52,12 @@ pub fn replace_bound_regions_in_fn_sig(\n     let new_fn_sig = ty::fold_sig(fn_sig, |t| {\n         replace_bound_regions(tcx, isr, t)\n     });\n-    let new_self_ty = opt_self_ty.map(|&t| replace_bound_regions(tcx, isr, t));\n+    let new_self_ty = opt_self_ty.map(|t| replace_bound_regions(tcx, isr, *t));\n \n     debug!(\"result of replace_bound_regions_in_fn_sig: \\\n             new_self_ty=%?, \\\n             fn_sig=%s\",\n-           new_self_ty.map(|&t| ppaux::ty_to_str(tcx, t)),\n+           new_self_ty.map(|t| ppaux::ty_to_str(tcx, *t)),\n            ppaux::fn_sig_to_str(tcx, &new_fn_sig));\n \n     return (isr, new_self_ty, new_fn_sig);"}, {"sha": "700d96727eae2f9a0f3700e0a9f4c91b09c379df", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -131,9 +131,7 @@ fn lookup_vtables_for_param(vcx: &VtableContext,\n     // ty is the value supplied for the type parameter A...\n     let mut param_result = ~[];\n \n-    do ty::each_bound_trait_and_supertraits(\n-        tcx, type_param_bounds.trait_bounds) |trait_ref|\n-    {\n+    do ty::each_bound_trait_and_supertraits(tcx, type_param_bounds.trait_bounds) |trait_ref| {\n         // ...and here trait_ref is each bound that was declared on A,\n         // expressed in terms of the type parameters.\n "}, {"sha": "c3df0d06f83dd5bd78499100c1b9093f962e8e45", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -554,8 +554,8 @@ impl CoherenceChecker {\n \n         let mut provided_names = HashSet::new();\n         // Implemented methods\n-        for i in range(0u, all_methods.len()) {\n-            provided_names.insert(all_methods[i].ident);\n+        for elt in all_methods.iter() {\n+            provided_names.insert(elt.ident);\n         }\n \n         let r = ty::trait_methods(tcx, trait_did);"}, {"sha": "907a076b1a1efce000e622877195440379157c62", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -198,7 +198,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                             trait_id: ast::NodeId)\n {\n     let tcx = ccx.tcx;\n-    let region_paramd = tcx.region_paramd_items.find(&trait_id).map(|&x| *x);\n+    let region_paramd = tcx.region_paramd_items.find(&trait_id).map_move(|x| *x);\n     match tcx.items.get_copy(&trait_id) {\n         ast_map::node_item(@ast::item {\n             node: ast::item_trait(ref generics, _, ref ms),\n@@ -817,7 +817,7 @@ pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n \n pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n     let tcx = ccx.tcx;\n-    let rp = tcx.region_paramd_items.find(&it.id).map_consume(|x| *x);\n+    let rp = tcx.region_paramd_items.find(&it.id).map_move(|x| *x);\n     debug!(\"convert: item %s with id %d rp %?\",\n            tcx.sess.str_of(it.ident), it.id, rp);\n     match it.node {\n@@ -1020,7 +1020,7 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::item) -> @ty::TraitDef {\n       Some(&def) => return def,\n       _ => {}\n     }\n-    let rp = tcx.region_paramd_items.find(&it.id).map_consume(|x| *x);\n+    let rp = tcx.region_paramd_items.find(&it.id).map_move(|x| *x);\n     match it.node {\n         ast::item_trait(ref generics, _, _) => {\n             let self_ty = ty::mk_self(tcx, def_id);\n@@ -1049,7 +1049,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n       Some(&tpt) => return tpt,\n       _ => {}\n     }\n-    let rp = tcx.region_paramd_items.find(&it.id).map_consume(|x| *x);\n+    let rp = tcx.region_paramd_items.find(&it.id).map_move(|x| *x);\n     match it.node {\n       ast::item_static(ref t, _, _) => {\n         let typ = ccx.to_ty(&empty_rscope, t);\n@@ -1086,7 +1086,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n           None => { }\n         }\n \n-        let rp = tcx.region_paramd_items.find(&it.id).map_consume(|x| *x);\n+        let rp = tcx.region_paramd_items.find(&it.id).map_move(|x| *x);\n         let region_parameterization =\n             RegionParameterization::from_variance_and_generics(rp, generics);\n         let tpt = {"}, {"sha": "7fa7daf614901006d54b2cc334c962752007d925", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -716,12 +716,13 @@ impl InferCtxt {\n                                                 err: Option<&ty::type_err>) {\n         debug!(\"hi! expected_ty = %?, actual_ty = %s\", expected_ty, actual_ty);\n \n-        let error_str = err.map_default(~\"\", |t_err|\n-                         fmt!(\" (%s)\",\n-                              ty::type_err_to_str(self.tcx, *t_err)));\n-        let resolved_expected = expected_ty.map(|&e_ty|\n-                                                { self.resolve_type_vars_if_possible(e_ty) });\n-        if !resolved_expected.map_default(false, |&e| { ty::type_is_error(e) }) {\n+        let error_str = do err.map_move_default(~\"\") |t_err| {\n+            fmt!(\" (%s)\", ty::type_err_to_str(self.tcx, t_err))\n+        };\n+        let resolved_expected = do expected_ty.map_move |e_ty| {\n+            self.resolve_type_vars_if_possible(e_ty)\n+        };\n+        if !resolved_expected.map_move_default(false, |e| { ty::type_is_error(e) }) {\n             match resolved_expected {\n                 None => self.tcx.sess.span_err(sp,\n                             fmt!(\"%s%s\", mk_msg(None, actual_ty), error_str)),"}, {"sha": "91b6a4ce3bce3820b8c26eeece0d95338d548c76", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -374,8 +374,8 @@ impl RegionVarBindings {\n     pub fn vars_created_since_snapshot(&mut self, snapshot: uint)\n                                        -> ~[RegionVid] {\n         do vec::build |push| {\n-            for i in range(snapshot, self.undo_log.len()) {\n-                match self.undo_log[i] {\n+            for &elt in self.undo_log.slice_from(snapshot).iter() {\n+                match elt {\n                     AddVar(vid) => push(vid),\n                     _ => ()\n                 }"}, {"sha": "c9e2b8dd37b9dfb02d6a3fdc83bccc19ea0b9cfa", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -215,7 +215,7 @@ impl region_scope for MethodRscope {\n pub struct type_rscope(Option<RegionParameterization>);\n \n impl type_rscope {\n-    priv fn replacement(&self) -> ty::Region {\n+    fn replacement(&self) -> ty::Region {\n         if self.is_some() {\n             ty::re_bound(ty::br_self)\n         } else {"}, {"sha": "5bc22db0ca1a76700fc93d12394c72ed7d0699d0", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -136,7 +136,7 @@ Additional help:\n \n pub fn describe_warnings() {\n     use extra::sort::Sort;\n-    printfln!(\"\n+    println(\"\n Available lint options:\n     -W <foo>           Warn about <foo>\n     -A <foo>           Allow <foo>\n@@ -157,7 +157,7 @@ Available lint options:\n     fn padded(max: uint, s: &str) -> ~str {\n         str::from_bytes(vec::from_elem(max - s.len(), ' ' as u8)) + s\n     }\n-    printfln!(\"\\nAvailable lint checks:\\n\");\n+    println(\"\\nAvailable lint checks:\\n\");\n     printfln!(\"    %s  %7.7s  %s\",\n               padded(max_key, \"name\"), \"default\", \"meaning\");\n     printfln!(\"    %s  %7.7s  %s\\n\",\n@@ -173,7 +173,7 @@ Available lint options:\n }\n \n pub fn describe_debug_flags() {\n-    printfln!(\"\\nAvailable debug options:\\n\");\n+    println(\"\\nAvailable debug options:\\n\");\n     let r = session::debugging_opts_map();\n     for tuple in r.iter() {\n         match *tuple {\n@@ -249,13 +249,12 @@ pub fn run_compiler(args: &~[~str], demitter: diagnostic::Emitter) {\n \n     let sopts = build_session_options(binary, matches, demitter);\n     let sess = build_session(sopts, demitter);\n-    let odir = getopts::opt_maybe_str(matches, \"out-dir\");\n-    let odir = odir.map(|o| Path(*o));\n-    let ofile = getopts::opt_maybe_str(matches, \"o\");\n-    let ofile = ofile.map(|o| Path(*o));\n+    let odir = getopts::opt_maybe_str(matches, \"out-dir\").map_move(|o| Path(o));\n+    let ofile = getopts::opt_maybe_str(matches, \"o\").map_move(|o| Path(o));\n     let cfg = build_configuration(sess, binary, &input);\n-    let pretty = getopts::opt_default(matches, \"pretty\", \"normal\").map(\n-                    |a| parse_pretty(sess, *a));\n+    let pretty = do getopts::opt_default(matches, \"pretty\", \"normal\").map_move |a| {\n+        parse_pretty(sess, a)\n+    };\n     match pretty {\n       Some::<pp_mode>(ppm) => {\n         pretty_print_input(sess, cfg, &input, ppm);\n@@ -299,10 +298,18 @@ bug and need to present an error.\n */\n pub fn monitor(f: ~fn(diagnostic::Emitter)) {\n     use std::comm::*;\n+\n+    // XXX: This is a hack for newsched since it doesn't support split stacks.\n+    // rustc needs a lot of stack!\n+    static STACK_SIZE: uint = 4000000;\n+\n     let (p, ch) = stream();\n     let ch = SharedChan::new(ch);\n     let ch_capture = ch.clone();\n-    match do task::try || {\n+    let mut task_builder = task::task();\n+    task_builder.supervised();\n+    task_builder.opts.stack_size = Some(STACK_SIZE);\n+    match do task_builder.try {\n         let ch = ch_capture.clone();\n         let ch_capture = ch.clone();\n         // The 'diagnostics emitter'. Every error, warning, etc. should"}, {"sha": "3598eb7c0fb9b217d8af908ae888c112567382b1", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -140,16 +140,16 @@ fn config_from_opts(\n     let result = result::Ok(config);\n     let result = do result.chain |config| {\n         let output_dir = getopts::opt_maybe_str(matches, opt_output_dir());\n-        let output_dir = output_dir.map(|s| Path(*s));\n+        let output_dir = output_dir.map_move(|s| Path(s));\n         result::Ok(Config {\n             output_dir: output_dir.unwrap_or_default(config.output_dir.clone()),\n             .. config\n         })\n     };\n     let result = do result.chain |config| {\n         let output_format = getopts::opt_maybe_str(matches, opt_output_format());\n-        do output_format.map_default(result::Ok(config.clone())) |output_format| {\n-            do parse_output_format(*output_format).chain |output_format| {\n+        do output_format.map_move_default(result::Ok(config.clone())) |output_format| {\n+            do parse_output_format(output_format).chain |output_format| {\n                 result::Ok(Config {\n                     output_format: output_format,\n                     .. config.clone()\n@@ -160,8 +160,8 @@ fn config_from_opts(\n     let result = do result.chain |config| {\n         let output_style =\n             getopts::opt_maybe_str(matches, opt_output_style());\n-        do output_style.map_default(result::Ok(config.clone())) |output_style| {\n-            do parse_output_style(*output_style).chain |output_style| {\n+        do output_style.map_move_default(result::Ok(config.clone())) |output_style| {\n+            do parse_output_style(output_style).chain |output_style| {\n                 result::Ok(Config {\n                     output_style: output_style,\n                     .. config.clone()"}, {"sha": "aba7ea1f0d753f807e7b30021f2f9724ce942533", "filename": "src/librustdoc/doc.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoc.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -54,7 +54,7 @@ pub struct CrateDoc {\n pub enum ItemTag {\n     ModTag(ModDoc),\n     NmodTag(NmodDoc),\n-    ConstTag(ConstDoc),\n+    StaticTag(StaticDoc),\n     FnTag(FnDoc),\n     EnumTag(EnumDoc),\n     TraitTag(TraitDoc),\n@@ -95,7 +95,7 @@ pub struct NmodDoc {\n     index: Option<Index>\n }\n \n-pub type ConstDoc = SimpleItemDoc;\n+pub type StaticDoc = SimpleItemDoc;\n \n pub type FnDoc = SimpleItemDoc;\n \n@@ -214,8 +214,8 @@ impl ModDoc {\n         md!(FnTag)\n     }\n \n-    pub fn consts(&self) -> ~[ConstDoc] {\n-        md!(ConstTag)\n+    pub fn statics(&self) -> ~[StaticDoc] {\n+        md!(StaticTag)\n     }\n \n     pub fn enums(&self) -> ~[EnumDoc] {\n@@ -249,7 +249,7 @@ pub trait PageUtils {\n     fn mods(&self) -> ~[ModDoc];\n     fn nmods(&self) -> ~[NmodDoc];\n     fn fns(&self) -> ~[FnDoc];\n-    fn consts(&self) -> ~[ConstDoc];\n+    fn statics(&self) -> ~[StaticDoc];\n     fn enums(&self) -> ~[EnumDoc];\n     fn traits(&self) -> ~[TraitDoc];\n     fn impls(&self) -> ~[ImplDoc];\n@@ -270,8 +270,8 @@ impl PageUtils for ~[Page] {\n         pu!(FnTag)\n     }\n \n-    fn consts(&self) -> ~[ConstDoc] {\n-        pu!(ConstTag)\n+    fn statics(&self) -> ~[StaticDoc] {\n+        pu!(StaticTag)\n     }\n \n     fn enums(&self) -> ~[EnumDoc] {\n@@ -301,7 +301,7 @@ impl Item for ItemTag {\n           &doc::ModTag(ref doc) => doc.item.clone(),\n           &doc::NmodTag(ref doc) => doc.item.clone(),\n           &doc::FnTag(ref doc) => doc.item.clone(),\n-          &doc::ConstTag(ref doc) => doc.item.clone(),\n+          &doc::StaticTag(ref doc) => doc.item.clone(),\n           &doc::EnumTag(ref doc) => doc.item.clone(),\n           &doc::TraitTag(ref doc) => doc.item.clone(),\n           &doc::ImplTag(ref doc) => doc.item.clone(),"}, {"sha": "2cab62296a4ddbdec2d051013ee1dde305bca2fd", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -101,8 +101,8 @@ fn moddoc_from_mod(\n                 ))\n               }\n               ast::item_static(*) => {\n-                Some(doc::ConstTag(\n-                    constdoc_from_const(ItemDoc)\n+                Some(doc::StaticTag(\n+                    staticdoc_from_static(ItemDoc)\n                 ))\n               }\n               ast::item_enum(enum_definition, _) => {\n@@ -165,7 +165,7 @@ fn fndoc_from_fn(itemdoc: doc::ItemDoc) -> doc::FnDoc {\n     }\n }\n \n-fn constdoc_from_const(itemdoc: doc::ItemDoc) -> doc::ConstDoc {\n+fn staticdoc_from_static(itemdoc: doc::ItemDoc) -> doc::StaticDoc {\n     doc::SimpleItemDoc {\n         item: itemdoc,\n         sig: None\n@@ -356,10 +356,10 @@ mod test {\n     }\n \n     #[test]\n-    fn should_extract_const_name_and_id() {\n+    fn should_extract_static_name_and_id() {\n         let doc = mk_doc(@\"static a: int = 0;\");\n-        assert!(doc.cratemod().consts()[0].id() != 0);\n-        assert!(doc.cratemod().consts()[0].name_() == ~\"a\");\n+        assert!(doc.cratemod().statics()[0].id() != 0);\n+        assert!(doc.cratemod().statics()[0].name_() == ~\"a\");\n     }\n \n     #[test]"}, {"sha": "589232f6e2f2f3cc447c2df44d5c770f8e0b6bf3", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -21,7 +21,7 @@ pub struct Fold<T> {\n     fold_mod: FoldMod<T>,\n     fold_nmod: FoldNmod<T>,\n     fold_fn: FoldFn<T>,\n-    fold_const: FoldConst<T>,\n+    fold_static: FoldStatic<T>,\n     fold_enum: FoldEnum<T>,\n     fold_trait: FoldTrait<T>,\n     fold_impl: FoldImpl<T>,\n@@ -39,7 +39,7 @@ impl<T:Clone> Clone for Fold<T> {\n             fold_mod: self.fold_mod,\n             fold_nmod: self.fold_nmod,\n             fold_fn: self.fold_fn,\n-            fold_const: self.fold_const,\n+            fold_static: self.fold_static,\n             fold_enum: self.fold_enum,\n             fold_trait: self.fold_trait,\n             fold_impl: self.fold_impl,\n@@ -55,7 +55,7 @@ type FoldItem<T> = @fn(fold: &Fold<T>, doc: doc::ItemDoc) -> doc::ItemDoc;\n type FoldMod<T> = @fn(fold: &Fold<T>, doc: doc::ModDoc) -> doc::ModDoc;\n type FoldNmod<T> = @fn(fold: &Fold<T>, doc: doc::NmodDoc) -> doc::NmodDoc;\n type FoldFn<T> = @fn(fold: &Fold<T>, doc: doc::FnDoc) -> doc::FnDoc;\n-type FoldConst<T> = @fn(fold: &Fold<T>, doc: doc::ConstDoc) -> doc::ConstDoc;\n+type FoldStatic<T> = @fn(fold: &Fold<T>, doc: doc::StaticDoc) -> doc::StaticDoc;\n type FoldEnum<T> = @fn(fold: &Fold<T>, doc: doc::EnumDoc) -> doc::EnumDoc;\n type FoldTrait<T> = @fn(fold: &Fold<T>, doc: doc::TraitDoc) -> doc::TraitDoc;\n type FoldImpl<T> = @fn(fold: &Fold<T>, doc: doc::ImplDoc) -> doc::ImplDoc;\n@@ -73,7 +73,7 @@ fn mk_fold<T>(\n     fold_mod: FoldMod<T>,\n     fold_nmod: FoldNmod<T>,\n     fold_fn: FoldFn<T>,\n-    fold_const: FoldConst<T>,\n+    fold_static: FoldStatic<T>,\n     fold_enum: FoldEnum<T>,\n     fold_trait: FoldTrait<T>,\n     fold_impl: FoldImpl<T>,\n@@ -88,7 +88,7 @@ fn mk_fold<T>(\n         fold_mod: fold_mod,\n         fold_nmod: fold_nmod,\n         fold_fn: fold_fn,\n-        fold_const: fold_const,\n+        fold_static: fold_static,\n         fold_enum: fold_enum,\n         fold_trait: fold_trait,\n         fold_impl: fold_impl,\n@@ -106,7 +106,7 @@ pub fn default_any_fold<T:Clone>(ctxt: T) -> Fold<T> {\n         |f, d| default_any_fold_mod(f, d),\n         |f, d| default_any_fold_nmod(f, d),\n         |f, d| default_seq_fold_fn(f, d),\n-        |f, d| default_seq_fold_const(f, d),\n+        |f, d| default_seq_fold_static(f, d),\n         |f, d| default_seq_fold_enum(f, d),\n         |f, d| default_seq_fold_trait(f, d),\n         |f, d| default_seq_fold_impl(f, d),\n@@ -124,7 +124,7 @@ pub fn default_seq_fold<T:Clone>(ctxt: T) -> Fold<T> {\n         |f, d| default_seq_fold_mod(f, d),\n         |f, d| default_seq_fold_nmod(f, d),\n         |f, d| default_seq_fold_fn(f, d),\n-        |f, d| default_seq_fold_const(f, d),\n+        |f, d| default_seq_fold_static(f, d),\n         |f, d| default_seq_fold_enum(f, d),\n         |f, d| default_seq_fold_trait(f, d),\n         |f, d| default_seq_fold_impl(f, d),\n@@ -142,7 +142,7 @@ pub fn default_par_fold<T:Clone>(ctxt: T) -> Fold<T> {\n         |f, d| default_par_fold_mod(f, d),\n         |f, d| default_par_fold_nmod(f, d),\n         |f, d| default_seq_fold_fn(f, d),\n-        |f, d| default_seq_fold_const(f, d),\n+        |f, d| default_seq_fold_static(f, d),\n         |f, d| default_seq_fold_enum(f, d),\n         |f, d| default_seq_fold_trait(f, d),\n         |f, d| default_seq_fold_impl(f, d),\n@@ -272,8 +272,8 @@ pub fn fold_ItemTag<T>(fold: &Fold<T>, doc: doc::ItemTag) -> doc::ItemTag {\n       doc::FnTag(FnDoc) => {\n         doc::FnTag((fold.fold_fn)(fold, FnDoc))\n       }\n-      doc::ConstTag(ConstDoc) => {\n-        doc::ConstTag((fold.fold_const)(fold, ConstDoc))\n+      doc::StaticTag(StaticDoc) => {\n+        doc::StaticTag((fold.fold_static)(fold, StaticDoc))\n       }\n       doc::EnumTag(EnumDoc) => {\n         doc::EnumTag((fold.fold_enum)(fold, EnumDoc))\n@@ -303,10 +303,10 @@ pub fn default_seq_fold_fn<T>(\n     }\n }\n \n-pub fn default_seq_fold_const<T>(\n+pub fn default_seq_fold_static<T>(\n     fold: &Fold<T>,\n-    doc: doc::ConstDoc\n-) -> doc::ConstDoc {\n+    doc: doc::StaticDoc\n+) -> doc::StaticDoc {\n     doc::SimpleItemDoc {\n         item: (fold.fold_item)(fold, doc.item.clone()),\n         .. doc\n@@ -374,7 +374,7 @@ fn default_fold_should_produce_same_doc() {\n }\n \n #[test]\n-fn default_fold_should_produce_same_consts() {\n+fn default_fold_should_produce_same_statics() {\n     let source = @\"static a: int = 0;\";\n     let ast = parse::from_str(source);\n     let doc = extract::extract(ast, ~\"\");"}, {"sha": "7d07b4864f50e1b57e6a50e11ef4a51bd0bd238d", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -150,8 +150,8 @@ pub fn header_kind(doc: doc::ItemTag) -> ~str {\n         doc::FnTag(_) => {\n             ~\"Function\"\n         }\n-        doc::ConstTag(_) => {\n-            ~\"Freeze\"\n+        doc::StaticTag(_) => {\n+            ~\"Static\"\n         }\n         doc::EnumTag(_) => {\n             ~\"Enum\"\n@@ -321,7 +321,7 @@ fn write_item_(ctxt: &Ctxt, doc: doc::ItemTag, write_header: bool) {\n         doc::ModTag(ModDoc) => write_mod(ctxt, ModDoc),\n         doc::NmodTag(nModDoc) => write_nmod(ctxt, nModDoc),\n         doc::FnTag(FnDoc) => write_fn(ctxt, FnDoc),\n-        doc::ConstTag(ConstDoc) => write_const(ctxt, ConstDoc),\n+        doc::StaticTag(StaticDoc) => write_static(ctxt, StaticDoc),\n         doc::EnumTag(EnumDoc) => write_enum(ctxt, EnumDoc),\n         doc::TraitTag(TraitDoc) => write_trait(ctxt, TraitDoc),\n         doc::ImplTag(ImplDoc) => write_impl(ctxt, ImplDoc),\n@@ -409,9 +409,9 @@ fn code_block(s: ~str) -> ~str {\n ~~~\", s)\n }\n \n-fn write_const(\n+fn write_static(\n     ctxt: &Ctxt,\n-    doc: doc::ConstDoc\n+    doc: doc::StaticDoc\n ) {\n     write_sig(ctxt, doc.sig.clone());\n     write_common(ctxt, doc.desc(), doc.sections());\n@@ -775,13 +775,13 @@ mod test {\n     }\n \n     #[test]\n-    fn should_write_const_header() {\n+    fn should_write_static_header() {\n         let markdown = render(~\"static a: bool = true;\");\n-        assert!(markdown.contains(\"## Freeze `a`\\n\\n\"));\n+        assert!(markdown.contains(\"## Static `a`\\n\\n\"));\n     }\n \n     #[test]\n-    fn should_write_const_description() {\n+    fn should_write_static_description() {\n         let markdown = render(\n             ~\"#[doc = \\\"b\\\"]\\\n               static a: bool = true;\");"}, {"sha": "3e380732d0f07e87aaff5be5ff76c00d5813524d", "filename": "src/librustdoc/prune_private_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustdoc%2Fprune_private_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustdoc%2Fprune_private_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_private_pass.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -202,7 +202,7 @@ mod test {\n         let doc = mk_doc(\n             ~\"impl Foo {\\\n               pub fn bar() { }\\\n-              priv fn baz() { }\\\n+              fn baz() { }\\\n               }\");\n         assert_eq!(doc.cratemod().impls()[0].methods.len(), 1);\n     }\n@@ -212,7 +212,7 @@ mod test {\n         let doc = mk_doc(\n             ~\"impl Foo {\\\n               pub fn bar() { }\\\n-              priv fn baz() { }\\\n+              fn baz() { }\\\n               }\");\n         assert_eq!(doc.cratemod().impls()[0].methods.len(), 1);\n     }\n@@ -232,7 +232,7 @@ mod test {\n         let doc = mk_doc(\n             ~\"impl Foo {\\\n               pub fn bar() { }\\\n-              priv fn baz() { }\\\n+              fn baz() { }\\\n               }\");\n         assert_eq!(doc.cratemod().impls()[0].methods.len(), 1);\n     }"}, {"sha": "ba8f37601fd567cb64660ccaf81a635f0c6d995d", "filename": "src/librustdoc/sort_item_type_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustdoc%2Fsort_item_type_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustdoc%2Fsort_item_type_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_item_type_pass.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -18,7 +18,7 @@ pub fn mk_pass() -> Pass {\n     fn by_score(item1: &doc::ItemTag, item2: &doc::ItemTag) -> bool {\n         fn score(item: &doc::ItemTag) -> int {\n             match *item {\n-              doc::ConstTag(_) => 0,\n+              doc::StaticTag(_) => 0,\n               doc::TyTag(_) => 1,\n               doc::EnumTag(_) => 2,\n               doc::StructTag(_) => 3,\n@@ -43,7 +43,7 @@ fn test() {\n \n     let source =\n         ~\"mod imod { } \\\n-         static iconst: int = 0; \\\n+         static istatic: int = 0; \\\n          fn ifn() { } \\\n          enum ienum { ivar } \\\n          trait itrait { fn a(); } \\\n@@ -54,7 +54,7 @@ fn test() {\n         let doc = extract::from_srv(srv.clone(), ~\"\");\n         let doc = (mk_pass().f)(srv.clone(), doc);\n         // hidden __std_macros module at the start.\n-        assert_eq!(doc.cratemod().items[0].name_(), ~\"iconst\");\n+        assert_eq!(doc.cratemod().items[0].name_(), ~\"istatic\");\n         assert_eq!(doc.cratemod().items[1].name_(), ~\"itype\");\n         assert_eq!(doc.cratemod().items[2].name_(), ~\"ienum\");\n         assert_eq!(doc.cratemod().items[3].name_(), ~\"istruct\");"}, {"sha": "196c7e892a8801e90b04cceb87eac3d3af7d636e", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -39,7 +39,7 @@ pub fn run(\n     let fold = Fold {\n         ctxt: srv.clone(),\n         fold_fn: fold_fn,\n-        fold_const: fold_const,\n+        fold_static: fold_static,\n         fold_enum: fold_enum,\n         fold_trait: fold_trait,\n         fold_impl: fold_impl,\n@@ -93,10 +93,10 @@ fn get_fn_sig(srv: astsrv::Srv, fn_id: doc::AstId) -> Option<~str> {\n     }\n }\n \n-fn fold_const(\n+fn fold_static(\n     fold: &fold::Fold<astsrv::Srv>,\n-    doc: doc::ConstDoc\n-) -> doc::ConstDoc {\n+    doc: doc::StaticDoc\n+) -> doc::StaticDoc {\n     let srv = fold.ctxt.clone();\n \n     doc::SimpleItemDoc {\n@@ -109,7 +109,7 @@ fn fold_const(\n                     }, _) => {\n                         pprust::ty_to_str(ty, extract::interner())\n                     }\n-                    _ => fail!(\"fold_const: id not bound to a const item\")\n+                    _ => fail!(\"fold_static: id not bound to a static item\")\n                 }\n             }}),\n         .. doc\n@@ -260,9 +260,9 @@ fn fold_impl(\n                 }, _) => {\n                     let bounds = pprust::generics_to_str(generics, extract::interner());\n                     let bounds = if bounds.is_empty() { None } else { Some(bounds) };\n-                    let trait_types = opt_trait_type.map_default(~[], |p| {\n+                    let trait_types = do opt_trait_type.map_default(~[]) |p| {\n                         ~[pprust::path_to_str(&p.path, extract::interner())]\n-                    });\n+                    };\n                     (bounds,\n                      trait_types,\n                      Some(pprust::ty_to_str(\n@@ -384,9 +384,9 @@ mod test {\n     }\n \n     #[test]\n-    fn should_add_const_types() {\n+    fn should_add_static_types() {\n         let doc = mk_doc(~\"static a: bool = true;\");\n-        assert!(doc.cratemod().consts()[0].sig == Some(~\"bool\"));\n+        assert!(doc.cratemod().statics()[0].sig == Some(~\"bool\"));\n     }\n \n     #[test]"}, {"sha": "bb863df33481211c354b5519fb223be17cd2fe06", "filename": "src/librusti/rusti.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -203,7 +203,7 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n                 }\n             }\n         }\n-        result = do blk.expr.map_consume |e| {\n+        result = do blk.expr.map_move |e| {\n             do with_pp(intr) |pp, _| { pprust::print_expr(pp, e); }\n         };\n     }\n@@ -579,16 +579,19 @@ mod tests {\n     }\n     fn run_program(_: &str) {}\n \n+    #[ignore]\n     #[test]\n     fn super_basic() {\n         run_program(\"\");\n     }\n \n+    #[ignore]\n     #[test]\n     fn regression_5937() {\n         run_program(\"use std::hashmap;\");\n     }\n \n+    #[ignore]\n     #[test]\n     fn regression_5784() {\n         run_program(\"let a = 3;\");\n@@ -604,6 +607,7 @@ mod tests {\n         \");\n     }\n \n+    #[ignore]\n     #[test]\n     fn inferred_integers_usable() {\n         run_program(\"let a = 2;\\n()\\n\");\n@@ -614,6 +618,7 @@ mod tests {\n         \");\n     }\n \n+    #[ignore]\n     #[test]\n     fn local_variables_allow_shadowing() {\n         run_program(\"\n@@ -623,6 +628,7 @@ mod tests {\n         \");\n     }\n \n+    #[ignore]\n     #[test]\n     fn string_usable() {\n         run_program(\"\n@@ -634,6 +640,7 @@ mod tests {\n         \");\n     }\n \n+    #[ignore]\n     #[test]\n     fn vectors_usable() {\n         run_program(\"\n@@ -646,6 +653,7 @@ mod tests {\n         \");\n     }\n \n+    #[ignore]\n     #[test]\n     fn structs_usable() {\n         run_program(\"\n@@ -655,6 +663,7 @@ mod tests {\n         \");\n     }\n \n+    #[ignore]\n     #[test]\n     fn mutable_variables_work() {\n         run_program(\"\n@@ -667,6 +676,7 @@ mod tests {\n         \");\n     }\n \n+    #[ignore]\n     #[test]\n     fn functions_saved() {\n         run_program(\"\n@@ -677,6 +687,7 @@ mod tests {\n         \");\n     }\n \n+    #[ignore]\n     #[test]\n     fn modules_saved() {\n         run_program(\"\n@@ -685,6 +696,7 @@ mod tests {\n         \");\n     }\n \n+    #[ignore]\n     #[test]\n     fn multiple_functions() {\n         run_program(\"\n@@ -694,6 +706,7 @@ mod tests {\n         \");\n     }\n \n+    #[ignore]\n     #[test]\n     fn multiple_items_same_name() {\n         run_program(\"\n@@ -706,13 +719,15 @@ mod tests {\n         \");\n     }\n \n+    #[ignore]\n     #[test]\n     fn simultaneous_definition_and_expression() {\n         run_program(\"\n             let a = 3; a as u8\n         \");\n     }\n \n+    #[ignore]\n     #[test]\n     fn exit_quits() {\n         let mut r = repl();"}, {"sha": "9fea866212975c02335ead93f4121c9fb039d5ee", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -998,6 +998,7 @@ fn test_rustpkg_test() {\n }\n \n #[test]\n+#[ignore(reason = \"test not yet implemented\")]\n fn test_uninstall() {\n     let workspace = create_local_package(&PkgId::new(\"foo\", &os::getcwd()));\n     let _output = command_line_test([~\"info\", ~\"foo\"], &workspace);"}, {"sha": "f2470bed7329e81fcd1df99620574989f49607cd", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -12,7 +12,7 @@\n \n use clone::Clone;\n use container::Container;\n-use iterator::{Iterator, range};\n+use iterator::Iterator;\n use option::{Option, Some, None};\n use sys;\n use unstable::raw::Repr;\n@@ -92,8 +92,8 @@ pub fn append<T:Clone>(lhs: @[T], rhs: &[T]) -> @[T] {\n         for x in lhs.iter() {\n             push((*x).clone());\n         }\n-        for i in range(0u, rhs.len()) {\n-            push(rhs[i].clone());\n+        for elt in rhs.iter() {\n+            push(elt.clone());\n         }\n     }\n }"}, {"sha": "a4de10f8c7760aae76a718f95a74aab086ad7cb7", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -314,7 +314,7 @@ mod pipesy {\n \n     #[allow(non_camel_case_types)]\n     pub mod oneshot {\n-        priv use std::kinds::Send;\n+        use std::kinds::Send;\n         use ptr::to_mut_unsafe_ptr;\n \n         pub fn init<T: Send>() -> (server::Oneshot<T>, client::Oneshot<T>) {\n@@ -341,7 +341,7 @@ mod pipesy {\n         #[allow(non_camel_case_types)]\n         pub mod client {\n \n-            priv use std::kinds::Send;\n+            use std::kinds::Send;\n \n             #[allow(non_camel_case_types)]\n             pub fn try_send<T: Send>(pipe: Oneshot<T>, x_0: T) ->\n@@ -489,7 +489,7 @@ mod pipesy {\n \n     #[allow(non_camel_case_types)]\n     pub mod streamp {\n-        priv use std::kinds::Send;\n+        use std::kinds::Send;\n \n         pub fn init<T: Send>() -> (server::Open<T>, client::Open<T>) {\n             pub use std::pipes::HasBuffer;\n@@ -501,7 +501,7 @@ mod pipesy {\n \n         #[allow(non_camel_case_types)]\n         pub mod client {\n-            priv use std::kinds::Send;\n+            use std::kinds::Send;\n \n             #[allow(non_camel_case_types)]\n             pub fn try_data<T: Send>(pipe: Open<T>, x_0: T) ->"}, {"sha": "bb74d9b3ec484b1d3730d74837359891c03ef4f5", "filename": "src/libstd/either.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Feither.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -24,7 +24,7 @@ use vec;\n use vec::{OwnedVector, ImmutableVector};\n \n /// `Either` is a type that represents one of two alternatives\n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, Eq, IterBytes)]\n pub enum Either<L, R> {\n     Left(L),\n     Right(R)"}, {"sha": "2b8807b2291724a0d6f3da92671bd8622a2382f3", "filename": "src/libstd/fmt/mod.rs", "status": "added", "additions": 368, "deletions": 0, "changes": 368, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -0,0 +1,368 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::*;\n+\n+use cast;\n+use int;\n+use rt::io::Decorator;\n+use rt::io::mem::MemWriter;\n+use rt::io;\n+use str;\n+use sys;\n+use uint;\n+use util;\n+use vec;\n+\n+pub mod parse;\n+pub mod rt;\n+\n+/// A struct to represent both where to emit formatting strings to and how they\n+/// should be formatted. A mutable version of this is passed to all formatting\n+/// traits.\n+pub struct Formatter<'self> {\n+    /// Flags for formatting (packed version of rt::Flag)\n+    flags: uint,\n+    /// Character used as 'fill' whenever there is alignment\n+    fill: char,\n+    /// Boolean indication of whether the output should be left-aligned\n+    alignleft: bool,\n+    /// Optionally specified integer width that the output should be\n+    width: Option<uint>,\n+    /// Optionally specified precision for numeric types\n+    precision: Option<uint>,\n+\n+    /// Output buffer.\n+    buf: &'self mut io::Writer,\n+\n+    priv curarg: vec::VecIterator<'self, Argument<'self>>,\n+    priv args: &'self [Argument<'self>],\n+}\n+\n+/// This struct represents the generic \"argument\" which is taken by the Xprintf\n+/// family of functions. It contains a function to format the given value. At\n+/// compile time it is ensured that the function and the value have the correct\n+/// types, and then this struct is used to canonicalize arguments to one type.\n+pub struct Argument<'self> {\n+    priv formatter: extern \"Rust\" fn(&util::Void, &mut Formatter),\n+    priv value: &'self util::Void,\n+}\n+\n+#[allow(missing_doc)]\n+pub trait Bool { fn fmt(&Self, &mut Formatter); }\n+#[allow(missing_doc)]\n+pub trait Char { fn fmt(&Self, &mut Formatter); }\n+#[allow(missing_doc)]\n+pub trait Signed { fn fmt(&Self, &mut Formatter); }\n+#[allow(missing_doc)]\n+pub trait Unsigned { fn fmt(&Self, &mut Formatter); }\n+#[allow(missing_doc)]\n+pub trait Octal { fn fmt(&Self, &mut Formatter); }\n+#[allow(missing_doc)]\n+pub trait Binary { fn fmt(&Self, &mut Formatter); }\n+#[allow(missing_doc)]\n+pub trait LowerHex { fn fmt(&Self, &mut Formatter); }\n+#[allow(missing_doc)]\n+pub trait UpperHex { fn fmt(&Self, &mut Formatter); }\n+#[allow(missing_doc)]\n+pub trait String { fn fmt(&Self, &mut Formatter); }\n+#[allow(missing_doc)]\n+pub trait Poly { fn fmt(&Self, &mut Formatter); }\n+#[allow(missing_doc)]\n+pub trait Pointer { fn fmt(&Self, &mut Formatter); }\n+\n+/// The sprintf function takes a precompiled format string and a list of\n+/// arguments, to return the resulting formatted string.\n+///\n+/// This is currently an unsafe function because the types of all arguments\n+/// aren't verified by immediate callers of this function. This currently does\n+/// not validate that the correct types of arguments are specified for each\n+/// format specifier, nor that each argument itself contains the right function\n+/// for formatting the right type value. Because of this, the function is marked\n+/// as `unsafe` if this is being called manually.\n+///\n+/// Thankfully the rust compiler provides the macro `ifmt!` which will perform\n+/// all of this validation at compile-time and provides a safe interface for\n+/// invoking this function.\n+///\n+/// # Arguments\n+///\n+///   * fmts - the precompiled format string to emit.\n+///   * args - the list of arguments to the format string. These are only the\n+///            positional arguments (not named)\n+///\n+/// Note that this function assumes that there are enough arguments for the\n+/// format string.\n+pub unsafe fn sprintf(fmt: &[rt::Piece], args: &[Argument]) -> ~str {\n+    let output = MemWriter::new();\n+    {\n+        let mut formatter = Formatter {\n+            flags: 0,\n+            width: None,\n+            precision: None,\n+            // FIXME(#8248): shouldn't need a transmute\n+            buf: cast::transmute(&output as &io::Writer),\n+            alignleft: false,\n+            fill: ' ',\n+            args: args,\n+            curarg: args.iter(),\n+        };\n+        for piece in fmt.iter() {\n+            formatter.run(piece, None);\n+        }\n+    }\n+    return str::from_bytes_owned(output.inner());\n+}\n+\n+impl<'self> Formatter<'self> {\n+    fn run(&mut self, piece: &rt::Piece, cur: Option<&str>) {\n+        let setcount = |slot: &mut Option<uint>, cnt: &parse::Count| {\n+            match *cnt {\n+                parse::CountIs(n) => { *slot = Some(n); }\n+                parse::CountImplied => { *slot = None; }\n+                parse::CountIsParam(i) => {\n+                    let v = self.args[i].value;\n+                    unsafe { *slot = Some(*(v as *util::Void as *uint)); }\n+                }\n+                parse::CountIsNextParam => {\n+                    let v = self.curarg.next().unwrap().value;\n+                    unsafe { *slot = Some(*(v as *util::Void as *uint)); }\n+                }\n+            }\n+        };\n+\n+        match *piece {\n+            rt::String(s) => { self.buf.write(s.as_bytes()); }\n+            rt::CurrentArgument(()) => { self.buf.write(cur.unwrap().as_bytes()); }\n+            rt::Argument(ref arg) => {\n+                // Fill in the format parameters into the formatter\n+                self.fill = arg.format.fill;\n+                self.alignleft = arg.format.alignleft;\n+                self.flags = arg.format.flags;\n+                setcount(&mut self.width, &arg.format.width);\n+                setcount(&mut self.precision, &arg.format.precision);\n+\n+                // Extract the correct argument\n+                let value = match arg.position {\n+                    rt::ArgumentNext => { *self.curarg.next().unwrap() }\n+                    rt::ArgumentIs(i) => self.args[i],\n+                };\n+\n+                // Then actually do some printing\n+                match arg.method {\n+                    None => { (value.formatter)(value.value, self); }\n+                    Some(ref method) => { self.execute(*method, value); }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn execute(&mut self, method: &rt::Method, arg: Argument) {\n+        match *method {\n+            // Pluralization is selection upon a numeric value specified as the\n+            // parameter.\n+            rt::Plural(offset, ref selectors, ref default) => {\n+                // This is validated at compile-time to be a pointer to a\n+                // '&uint' value.\n+                let value: &uint = unsafe { cast::transmute(arg.value) };\n+                let value = *value;\n+\n+                // First, attempt to match against explicit values without the\n+                // offsetted value\n+                for s in selectors.iter() {\n+                    match s.selector {\n+                        Right(val) if value == val => {\n+                            return self.runplural(value, s.result);\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+\n+                // Next, offset the value and attempt to match against the\n+                // keyword selectors.\n+                let value = value - match offset { Some(i) => i, None => 0 };\n+                for s in selectors.iter() {\n+                    let run = match s.selector {\n+                        Left(parse::Zero) => value == 0,\n+                        Left(parse::One) => value == 1,\n+                        Left(parse::Two) => value == 2,\n+\n+                        // XXX: Few/Many should have a user-specified boundary\n+                        //      One possible option would be in the function\n+                        //      pointer of the 'arg: Argument' struct.\n+                        Left(parse::Few) => value < 8,\n+                        Left(parse::Many) => value >= 8,\n+\n+                        Right(*) => false\n+                    };\n+                    if run {\n+                        return self.runplural(value, s.result);\n+                    }\n+                }\n+\n+                self.runplural(value, *default);\n+            }\n+\n+            // Select is just a matching against the string specified.\n+            rt::Select(ref selectors, ref default) => {\n+                // This is validated at compile-time to be a pointer to a\n+                // string slice,\n+                let value: & &str = unsafe { cast::transmute(arg.value) };\n+                let value = *value;\n+\n+                for s in selectors.iter() {\n+                    if s.selector == value {\n+                        for piece in s.result.iter() {\n+                            self.run(piece, Some(value));\n+                        }\n+                        return;\n+                    }\n+                }\n+                for piece in default.iter() {\n+                    self.run(piece, Some(value));\n+                }\n+            }\n+        }\n+    }\n+\n+    fn runplural(&mut self, value: uint, pieces: &[rt::Piece]) {\n+        do uint::to_str_bytes(value, 10) |buf| {\n+            let valuestr = str::from_bytes_slice(buf);\n+            for piece in pieces.iter() {\n+                self.run(piece, Some(valuestr));\n+            }\n+        }\n+    }\n+}\n+\n+/// This is a function which calls are emitted to by the compiler itself to\n+/// create the Argument structures that are passed into the `sprintf` function.\n+#[doc(hidden)]\n+pub fn argument<'a, T>(f: extern \"Rust\" fn(&T, &mut Formatter),\n+                       t: &'a T) -> Argument<'a> {\n+    unsafe {\n+        Argument {\n+            formatter: cast::transmute(f),\n+            value: cast::transmute(t)\n+        }\n+    }\n+}\n+\n+/// When the compiler determines that the type of an argument *must* be a string\n+/// (such as for select), then it invokes this method.\n+#[doc(hidden)]\n+pub fn argumentstr<'a>(s: &'a &str) -> Argument<'a> {\n+    argument(String::fmt, s)\n+}\n+\n+/// When the compiler determines that the type of an argument *must* be a uint\n+/// (such as for plural), then it invokes this method.\n+#[doc(hidden)]\n+pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n+    argument(Unsigned::fmt, s)\n+}\n+\n+// Implementations of the core formatting traits\n+\n+impl Bool for bool {\n+    fn fmt(b: &bool, f: &mut Formatter) {\n+        String::fmt(&(if *b {\"true\"} else {\"false\"}), f);\n+    }\n+}\n+\n+impl<'self> String for &'self str {\n+    fn fmt(s: & &'self str, f: &mut Formatter) {\n+        // XXX: formatting args\n+        f.buf.write(s.as_bytes())\n+    }\n+}\n+\n+impl Char for char {\n+    fn fmt(c: &char, f: &mut Formatter) {\n+        // XXX: formatting args\n+        // XXX: shouldn't require an allocation\n+        let mut s = ~\"\";\n+        s.push_char(*c);\n+        f.buf.write(s.as_bytes());\n+    }\n+}\n+\n+impl Signed for int {\n+    fn fmt(c: &int, f: &mut Formatter) {\n+        // XXX: formatting args\n+        do int::to_str_bytes(*c, 10) |buf| {\n+            f.buf.write(buf);\n+        }\n+    }\n+}\n+\n+impl Unsigned for uint {\n+    fn fmt(c: &uint, f: &mut Formatter) {\n+        // XXX: formatting args\n+        do uint::to_str_bytes(*c, 10) |buf| {\n+            f.buf.write(buf);\n+        }\n+    }\n+}\n+\n+impl Octal for uint {\n+    fn fmt(c: &uint, f: &mut Formatter) {\n+        // XXX: formatting args\n+        do uint::to_str_bytes(*c, 8) |buf| {\n+            f.buf.write(buf);\n+        }\n+    }\n+}\n+\n+impl LowerHex for uint {\n+    fn fmt(c: &uint, f: &mut Formatter) {\n+        // XXX: formatting args\n+        do uint::to_str_bytes(*c, 16) |buf| {\n+            f.buf.write(buf);\n+        }\n+    }\n+}\n+\n+impl UpperHex for uint {\n+    fn fmt(c: &uint, f: &mut Formatter) {\n+        // XXX: formatting args\n+        do uint::to_str_bytes(*c, 16) |buf| {\n+            let mut local = [0u8, ..16];\n+            for (l, &b) in local.mut_iter().zip(buf.iter()) {\n+                *l = match b as char {\n+                    'a' .. 'f' => (b - 'a' as u8) + 'A' as u8,\n+                    _ => b,\n+                };\n+            }\n+            f.buf.write(local.slice_to(buf.len()));\n+        }\n+    }\n+}\n+\n+impl<T> Poly for T {\n+    fn fmt(t: &T, f: &mut Formatter) {\n+        // XXX: formatting args\n+        let s = sys::log_str(t);\n+        f.buf.write(s.as_bytes());\n+    }\n+}\n+\n+// n.b. use 'const' to get an implementation for both '*mut' and '*' at the same\n+//      time.\n+impl<T> Pointer for *const T {\n+    fn fmt(t: &*const T, f: &mut Formatter) {\n+        // XXX: formatting args\n+        f.buf.write(\"0x\".as_bytes());\n+        LowerHex::fmt(&(*t as uint), f);\n+    }\n+}\n+\n+// If you expected tests to be here, look instead at the run-pass/ifmt.rs test,\n+// it's a lot easier than creating all of the rt::Piece structures here."}, {"sha": "673ea1d3fa8b586c883708503287dec3a9affd62", "filename": "src/libstd/fmt/parse.rs", "status": "added", "additions": 896, "deletions": 0, "changes": 896, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Ffmt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Ffmt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fparse.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -0,0 +1,896 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::*;\n+\n+use char;\n+use str;\n+use iterator;\n+\n+condition! { pub parse_error: ~str -> (); }\n+\n+/// A piece is a portion of the format string which represents the next part to\n+/// emit. These are emitted as a stream by the `Parser` class.\n+#[deriving(Eq)]\n+pub enum Piece<'self> {\n+    /// A literal string which should directly be emitted\n+    String(&'self str),\n+    /// A back-reference to whatever the current argument is. This is used\n+    /// inside of a method call to refer back to the original argument.\n+    CurrentArgument,\n+    /// This describes that formatting should process the next argument (as\n+    /// specified inside) for emission.\n+    Argument(Argument<'self>),\n+}\n+\n+/// Representation of an argument specification.\n+#[deriving(Eq)]\n+pub struct Argument<'self> {\n+    /// Where to find this argument\n+    position: Position<'self>,\n+    /// How to format the argument\n+    format: FormatSpec<'self>,\n+    /// If not `None`, what method to invoke on the argument\n+    method: Option<~Method<'self>>\n+}\n+\n+/// Specification for the formatting of an argument in the format string.\n+#[deriving(Eq)]\n+pub struct FormatSpec<'self> {\n+    /// Optionally specified character to fill alignment with\n+    fill: Option<char>,\n+    /// Optionally specified alignment\n+    align: Option<Alignment>,\n+    /// Packed version of various flags provided\n+    flags: uint,\n+    /// The integer precision to use\n+    precision: Count,\n+    /// The string width requested for the resulting format\n+    width: Count,\n+    /// The descriptor string representing the name of the format desired for\n+    /// this argument, this can be empty or any number of characters, although\n+    /// it is required to be one word.\n+    ty: &'self str\n+}\n+\n+/// Enum describing where an argument for a format can be located.\n+#[deriving(Eq)]\n+pub enum Position<'self> {\n+    ArgumentNext, ArgumentIs(uint), ArgumentNamed(&'self str)\n+}\n+\n+/// Enum of alignments which are supoprted.\n+#[deriving(Eq)]\n+pub enum Alignment { AlignLeft, AlignRight }\n+\n+/// Various flags which can be applied to format strings, the meaning of these\n+/// flags is defined by the formatters themselves.\n+#[deriving(Eq)]\n+pub enum Flag {\n+    FlagSignPlus,\n+    FlagSignMinus,\n+    FlagAlternate,\n+}\n+\n+/// A count is used for the precision and width parameters of an integer, and\n+/// can reference either an argument or a literal integer.\n+#[deriving(Eq)]\n+pub enum Count {\n+    CountIs(uint),\n+    CountIsParam(uint),\n+    CountIsNextParam,\n+    CountImplied,\n+}\n+\n+/// Enum describing all of the possible methods which the formatting language\n+/// currently supports.\n+#[deriving(Eq)]\n+pub enum Method<'self> {\n+    /// A plural method selects on an integer over a list of either integer or\n+    /// keyword-defined clauses. The meaning of the keywords is defined by the\n+    /// current locale.\n+    ///\n+    /// An offset is optionally present at the beginning which is used to match\n+    /// against keywords, but it is not matched against the literal integers.\n+    ///\n+    /// The final element of this enum is the default \"other\" case which is\n+    /// always required to be specified.\n+    Plural(Option<uint>, ~[PluralArm<'self>], ~[Piece<'self>]),\n+\n+    /// A select method selects over a string. Each arm is a different string\n+    /// which can be selected for.\n+    ///\n+    /// As with `Plural`, a default \"other\" case is required as well.\n+    Select(~[SelectArm<'self>], ~[Piece<'self>]),\n+}\n+\n+/// Structure representing one \"arm\" of the `plural` function.\n+#[deriving(Eq)]\n+pub struct PluralArm<'self> {\n+    /// A selector can either be specified by a keyword or with an integer\n+    /// literal.\n+    selector: Either<PluralKeyword, uint>,\n+    /// Array of pieces which are the format of this arm\n+    result: ~[Piece<'self>],\n+}\n+\n+/// Enum of the 5 CLDR plural keywords. There is one more, \"other\", but that is\n+/// specially placed in the `Plural` variant of `Method`\n+///\n+/// http://www.icu-project.org/apiref/icu4c/classicu_1_1PluralRules.html\n+#[deriving(Eq, IterBytes)]\n+pub enum PluralKeyword {\n+    Zero, One, Two, Few, Many\n+}\n+\n+/// Structure representing one \"arm\" of the `select` function.\n+#[deriving(Eq)]\n+pub struct SelectArm<'self> {\n+    /// String selector which guards this arm\n+    selector: &'self str,\n+    /// Array of pieces which are the format of this arm\n+    result: ~[Piece<'self>],\n+}\n+\n+/// The parser structure for interpreting the input format string. This is\n+/// modelled as an iterator over `Piece` structures to form a stream of tokens\n+/// being output.\n+///\n+/// This is a recursive-descent parser for the sake of simplicity, and if\n+/// necessary there's probably lots of room for improvement performance-wise.\n+pub struct Parser<'self> {\n+    priv input: &'self str,\n+    priv cur: str::CharOffsetIterator<'self>,\n+}\n+\n+impl<'self> iterator::Iterator<Piece<'self>> for Parser<'self> {\n+    fn next(&mut self) -> Option<Piece<'self>> {\n+        match self.cur.clone().next() {\n+            Some((_, '#')) => { self.cur.next(); Some(CurrentArgument) }\n+            Some((_, '{')) => {\n+                self.cur.next();\n+                let ret = Some(Argument(self.argument()));\n+                if !self.consume('}') {\n+                    self.err(~\"unterminated format string\");\n+                }\n+                ret\n+            }\n+            Some((pos, '\\\\')) => {\n+                self.cur.next();\n+                self.escape(); // ensure it's a valid escape sequence\n+                Some(String(self.string(pos + 1))) // skip the '\\' character\n+            }\n+            Some((_, '}')) | None => { None }\n+            Some((pos, _)) => {\n+                Some(String(self.string(pos)))\n+            }\n+        }\n+    }\n+}\n+\n+impl<'self> Parser<'self> {\n+    /// Creates a new parser for the given format string\n+    pub fn new<'a>(s: &'a str) -> Parser<'a> {\n+        Parser {\n+            input: s,\n+            cur: s.char_offset_iter(),\n+        }\n+    }\n+\n+    /// Notifies of an error. The message doesn't actually need to be of type\n+    /// ~str, but I think it does when this eventually uses conditions so it\n+    /// might as well start using it now.\n+    fn err(&self, msg: ~str) {\n+        parse_error::cond.raise(msg);\n+    }\n+\n+    /// Optionally consumes the specified character. If the character is not at\n+    /// the current position, then the current iterator isn't moved and false is\n+    /// returned, otherwise the character is consumed and true is returned.\n+    fn consume(&mut self, c: char) -> bool {\n+        match self.cur.clone().next() {\n+            Some((_, maybe)) if c == maybe => {\n+                self.cur.next();\n+                true\n+            }\n+            Some(*) | None => false,\n+        }\n+    }\n+\n+    /// Attempts to consume any amount of whitespace followed by a character\n+    fn wsconsume(&mut self, c: char) -> bool {\n+        self.ws(); self.consume(c)\n+    }\n+\n+    /// Consumes all whitespace characters until the first non-whitespace\n+    /// character\n+    fn ws(&mut self) {\n+        loop {\n+            match self.cur.clone().next() {\n+                Some((_, c)) if char::is_whitespace(c) => { self.cur.next(); }\n+                Some(*) | None => { return }\n+            }\n+        }\n+    }\n+\n+    /// Consumes an escape sequence, failing if there is not a valid character\n+    /// to be escaped.\n+    fn escape(&mut self) -> char {\n+        match self.cur.next() {\n+            Some((_, c @ '#')) | Some((_, c @ '{')) |\n+            Some((_, c @ '\\\\')) | Some((_, c @ '}')) => { c }\n+            Some((_, c)) => {\n+                self.err(fmt!(\"invalid escape character `%c`\", c));\n+                c\n+            }\n+            None => {\n+                self.err(~\"expected an escape sequence, but format string was \\\n+                           terminated\");\n+                ' '\n+            }\n+        }\n+    }\n+\n+    /// Parses all of a string which is to be considered a \"raw literal\" in a\n+    /// format string. This is everything outside of the braces.\n+    fn string(&mut self, start: uint) -> &'self str {\n+        loop {\n+            // we may not consume the character, so clone the iterator\n+            match self.cur.clone().next() {\n+                Some((pos, '\\\\')) | Some((pos, '#')) |\n+                Some((pos, '}')) | Some((pos, '{')) => {\n+                    return self.input.slice(start, pos);\n+                }\n+                Some(*) => { self.cur.next(); }\n+                None => {\n+                    self.cur.next();\n+                    return self.input.slice(start, self.input.len());\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Parses an Argument structure, or what's contained within braces inside\n+    /// the format string\n+    fn argument(&mut self) -> Argument<'self> {\n+        Argument {\n+            position: self.position(),\n+            format: self.format(),\n+            method: self.method(),\n+        }\n+    }\n+\n+    /// Parses a positional argument for a format. This could either be an\n+    /// integer index of an argument, a named argument, or a blank string.\n+    fn position(&mut self) -> Position<'self> {\n+        match self.integer() {\n+            Some(i) => { ArgumentIs(i) }\n+            None => {\n+                match self.cur.clone().next() {\n+                    Some((_, c)) if char::is_alphabetic(c) => {\n+                        ArgumentNamed(self.word())\n+                    }\n+                    _ => ArgumentNext\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Parses a format specifier at the current position, returning all of the\n+    /// relevant information in the FormatSpec struct.\n+    fn format(&mut self) -> FormatSpec<'self> {\n+        let mut spec = FormatSpec {\n+            fill: None,\n+            align: None,\n+            flags: 0,\n+            precision: CountImplied,\n+            width: CountImplied,\n+            ty: self.input.slice(0, 0),\n+        };\n+        if !self.consume(':') { return spec }\n+\n+        // fill character\n+        match self.cur.clone().next() {\n+            Some((_, c)) => {\n+                match self.cur.clone().skip(1).next() {\n+                    Some((_, '>')) | Some((_, '<')) => {\n+                        spec.fill = Some(c);\n+                        self.cur.next();\n+                    }\n+                    Some(*) | None => {}\n+                }\n+            }\n+            None => {}\n+        }\n+        // Alignment\n+        if self.consume('<') {\n+            spec.align = Some(AlignLeft);\n+        } else if self.consume('>') {\n+            spec.align = Some(AlignRight);\n+        }\n+        // Sign flags\n+        if self.consume('+') {\n+            spec.flags |= 1 << (FlagSignPlus as uint);\n+        } else if self.consume('-') {\n+            spec.flags |= 1 << (FlagSignMinus as uint);\n+        }\n+        // Alternate marker\n+        if self.consume('#') {\n+            spec.flags |= 1 << (FlagAlternate as uint);\n+        }\n+        // Width and precision\n+        spec.width = self.count();\n+        if self.consume('.') {\n+            if self.consume('*') {\n+                spec.precision = CountIsNextParam;\n+            } else {\n+                spec.precision = self.count();\n+            }\n+        }\n+        // Finally the actual format specifier\n+        spec.ty = self.word();\n+        return spec;\n+    }\n+\n+    /// Parses a method to be applied to the previously specified argument and\n+    /// its format. The two current supported methods are 'plural' and 'select'\n+    fn method(&mut self) -> Option<~Method<'self>> {\n+        if !self.wsconsume(',') {\n+            return None;\n+        }\n+        self.ws();\n+        match self.word() {\n+            \"select\" => {\n+                if !self.wsconsume(',') {\n+                    self.err(~\"`select` must be followed by `,`\");\n+                }\n+                Some(self.select())\n+            }\n+            \"plural\" => {\n+                if !self.wsconsume(',') {\n+                    self.err(~\"`plural` must be followed by `,`\");\n+                }\n+                Some(self.plural())\n+            }\n+            \"\" => {\n+                self.err(~\"expected method after comma\");\n+                return None;\n+            }\n+            method => {\n+                self.err(fmt!(\"unknown method: `%s`\", method));\n+                return None;\n+            }\n+        }\n+    }\n+\n+    /// Parses a 'select' statement (after the initial 'select' word)\n+    fn select(&mut self) -> ~Method<'self> {\n+        let mut other = None;\n+        let mut arms = ~[];\n+        // Consume arms one at a time\n+        loop {\n+            self.ws();\n+            let selector = self.word();\n+            if selector == \"\" {\n+                self.err(~\"cannot have an empty selector\");\n+                break\n+            }\n+            if !self.wsconsume('{') {\n+                self.err(~\"selector must be followed by `{`\");\n+            }\n+            let pieces = self.collect();\n+            if !self.wsconsume('}') {\n+                self.err(~\"selector case must be terminated by `}`\");\n+            }\n+            if selector == \"other\" {\n+                if !other.is_none() {\n+                    self.err(~\"multiple `other` statements in `select\");\n+                }\n+                other = Some(pieces);\n+            } else {\n+                arms.push(SelectArm { selector: selector, result: pieces });\n+            }\n+            self.ws();\n+            match self.cur.clone().next() {\n+                Some((_, '}')) => { break }\n+                Some(*) | None => {}\n+            }\n+        }\n+        // The \"other\" selector must be present\n+        let other = match other {\n+            Some(arm) => { arm }\n+            None => {\n+                self.err(~\"`select` statement must provide an `other` case\");\n+                ~[]\n+            }\n+        };\n+        ~Select(arms, other)\n+    }\n+\n+    /// Parses a 'plural' statement (after the initial 'plural' word)\n+    fn plural(&mut self) -> ~Method<'self> {\n+        let mut offset = None;\n+        let mut other = None;\n+        let mut arms = ~[];\n+\n+        // First, attempt to parse the 'offset:' field. We know the set of\n+        // selector words which can appear in plural arms, and the only ones\n+        // which start with 'o' are \"other\" and \"offset\", hence look two\n+        // characters deep to see if we can consume the word \"offset\"\n+        self.ws();\n+        let mut it = self.cur.clone();\n+        match it.next() {\n+            Some((_, 'o')) => {\n+                match it.next() {\n+                    Some((_, 'f')) => {\n+                        let word = self.word();\n+                        if word != \"offset\" {\n+                            self.err(fmt!(\"expected `offset`, found `%s`\",\n+                                          word));\n+                        } else {\n+                            if !self.consume(':') {\n+                                self.err(~\"`offset` must be followed by `:`\");\n+                            }\n+                            match self.integer() {\n+                                Some(i) => { offset = Some(i); }\n+                                None => {\n+                                    self.err(~\"offset must be an integer\");\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Some(*) | None => {}\n+                }\n+            }\n+            Some(*) | None => {}\n+        }\n+\n+        // Next, generate all the arms\n+        loop {\n+            let mut isother = false;\n+            let selector = if self.wsconsume('=') {\n+                match self.integer() {\n+                    Some(i) => Right(i),\n+                    None => {\n+                        self.err(~\"plural `=` selectors must be followed by an \\\n+                                   integer\");\n+                        Right(0)\n+                    }\n+                }\n+            } else {\n+                let word = self.word();\n+                match word {\n+                    \"other\" => { isother = true; Left(Zero) }\n+                    \"zero\"  => Left(Zero),\n+                    \"one\"   => Left(One),\n+                    \"two\"   => Left(Two),\n+                    \"few\"   => Left(Few),\n+                    \"many\"  => Left(Many),\n+                    word    => {\n+                        self.err(fmt!(\"unexpected plural selector `%s`\", word));\n+                        if word == \"\" {\n+                            break\n+                        } else {\n+                            Left(Zero)\n+                        }\n+                    }\n+                }\n+            };\n+            if !self.wsconsume('{') {\n+                self.err(~\"selector must be followed by `{`\");\n+            }\n+            let pieces = self.collect();\n+            if !self.wsconsume('}') {\n+                self.err(~\"selector case must be terminated by `}`\");\n+            }\n+            if isother {\n+                if !other.is_none() {\n+                    self.err(~\"multiple `other` statements in `select\");\n+                }\n+                other = Some(pieces);\n+            } else {\n+                arms.push(PluralArm { selector: selector, result: pieces });\n+            }\n+            self.ws();\n+            match self.cur.clone().next() {\n+                Some((_, '}')) => { break }\n+                Some(*) | None => {}\n+            }\n+        }\n+\n+        let other = match other {\n+            Some(arm) => { arm }\n+            None => {\n+                self.err(~\"`plural` statement must provide an `other` case\");\n+                ~[]\n+            }\n+        };\n+        ~Plural(offset, arms, other)\n+    }\n+\n+    /// Parses a Count parameter at the current position. This does not check\n+    /// for 'CountIsNextParam' because that is only used in precision, not\n+    /// width.\n+    fn count(&mut self) -> Count {\n+        match self.integer() {\n+            Some(i) => {\n+                if self.consume('$') {\n+                    CountIsParam(i)\n+                } else {\n+                    CountIs(i)\n+                }\n+            }\n+            None => { CountImplied }\n+        }\n+    }\n+\n+    /// Parses a word starting at the current position. A word is considered to\n+    /// be an alphabetic character followed by any number of alphanumeric\n+    /// characters.\n+    fn word(&mut self) -> &'self str {\n+        let start = match self.cur.clone().next() {\n+            Some((pos, c)) if char::is_alphabetic(c) => {\n+                self.cur.next();\n+                pos\n+            }\n+            Some(*) | None => { return self.input.slice(0, 0); }\n+        };\n+        let mut end;\n+        loop {\n+            match self.cur.clone().next() {\n+                Some((_, c)) if char::is_alphanumeric(c) => {\n+                    self.cur.next();\n+                }\n+                Some((pos, _)) => { end = pos; break }\n+                None => { end = self.input.len(); break }\n+            }\n+        }\n+        self.input.slice(start, end)\n+    }\n+\n+    /// Optionally parses an integer at the current position. This doesn't deal\n+    /// with overflow at all, it's just accumulating digits.\n+    fn integer(&mut self) -> Option<uint> {\n+        let mut cur = 0;\n+        let mut found = false;\n+        loop {\n+            match self.cur.clone().next() {\n+                Some((_, c)) => {\n+                    match char::to_digit(c, 10) {\n+                        Some(i) => {\n+                            cur = cur * 10 + i;\n+                            found = true;\n+                            self.cur.next();\n+                        }\n+                        None => { break }\n+                    }\n+                }\n+                None => { break }\n+            }\n+        }\n+        if found {\n+            return Some(cur);\n+        } else {\n+            return None;\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use prelude::*;\n+    use realstd::fmt::{String};\n+\n+    fn same(fmt: &'static str, p: ~[Piece<'static>]) {\n+        let mut parser = Parser::new(fmt);\n+        assert_eq!(p, parser.collect());\n+    }\n+\n+    fn fmtdflt() -> FormatSpec<'static> {\n+        return FormatSpec {\n+            fill: None,\n+            align: None,\n+            flags: 0,\n+            precision: CountImplied,\n+            width: CountImplied,\n+            ty: \"\",\n+        }\n+    }\n+\n+    fn musterr(s: &str) {\n+        Parser::new(s).next();\n+    }\n+\n+    #[test]\n+    fn simple() {\n+        same(\"asdf\", ~[String(\"asdf\")]);\n+        same(\"a\\\\{b\", ~[String(\"a\"), String(\"{b\")]);\n+        same(\"a\\\\#b\", ~[String(\"a\"), String(\"#b\")]);\n+        same(\"a\\\\}b\", ~[String(\"a\"), String(\"}b\")]);\n+        same(\"a\\\\}\", ~[String(\"a\"), String(\"}\")]);\n+        same(\"\\\\}\", ~[String(\"}\")]);\n+    }\n+\n+    #[test] #[should_fail] fn invalid01() { musterr(\"{\") }\n+    #[test] #[should_fail] fn invalid02() { musterr(\"\\\\\") }\n+    #[test] #[should_fail] fn invalid03() { musterr(\"\\\\a\") }\n+    #[test] #[should_fail] fn invalid04() { musterr(\"{3a}\") }\n+    #[test] #[should_fail] fn invalid05() { musterr(\"{:|}\") }\n+    #[test] #[should_fail] fn invalid06() { musterr(\"{:>>>}\") }\n+\n+    #[test]\n+    fn format_nothing() {\n+        same(\"{}\", ~[Argument(Argument {\n+            position: ArgumentNext,\n+            format: fmtdflt(),\n+            method: None,\n+        })]);\n+    }\n+    #[test]\n+    fn format_position() {\n+        same(\"{3}\", ~[Argument(Argument {\n+            position: ArgumentIs(3),\n+            format: fmtdflt(),\n+            method: None,\n+        })]);\n+    }\n+    #[test]\n+    fn format_position_nothing_else() {\n+        same(\"{3:}\", ~[Argument(Argument {\n+            position: ArgumentIs(3),\n+            format: fmtdflt(),\n+            method: None,\n+        })]);\n+    }\n+    #[test]\n+    fn format_type() {\n+        same(\"{3:a}\", ~[Argument(Argument {\n+            position: ArgumentIs(3),\n+            format: FormatSpec {\n+                fill: None,\n+                align: None,\n+                flags: 0,\n+                precision: CountImplied,\n+                width: CountImplied,\n+                ty: \"a\",\n+            },\n+            method: None,\n+        })]);\n+    }\n+    #[test]\n+    fn format_align_fill() {\n+        same(\"{3:>}\", ~[Argument(Argument {\n+            position: ArgumentIs(3),\n+            format: FormatSpec {\n+                fill: None,\n+                align: Some(AlignRight),\n+                flags: 0,\n+                precision: CountImplied,\n+                width: CountImplied,\n+                ty: \"\",\n+            },\n+            method: None,\n+        })]);\n+        same(\"{3:0<}\", ~[Argument(Argument {\n+            position: ArgumentIs(3),\n+            format: FormatSpec {\n+                fill: Some('0'),\n+                align: Some(AlignLeft),\n+                flags: 0,\n+                precision: CountImplied,\n+                width: CountImplied,\n+                ty: \"\",\n+            },\n+            method: None,\n+        })]);\n+        same(\"{3:*<abcd}\", ~[Argument(Argument {\n+            position: ArgumentIs(3),\n+            format: FormatSpec {\n+                fill: Some('*'),\n+                align: Some(AlignLeft),\n+                flags: 0,\n+                precision: CountImplied,\n+                width: CountImplied,\n+                ty: \"abcd\",\n+            },\n+            method: None,\n+        })]);\n+    }\n+    #[test]\n+    fn format_counts() {\n+        same(\"{:10s}\", ~[Argument(Argument {\n+            position: ArgumentNext,\n+            format: FormatSpec {\n+                fill: None,\n+                align: None,\n+                flags: 0,\n+                precision: CountImplied,\n+                width: CountIs(10),\n+                ty: \"s\",\n+            },\n+            method: None,\n+        })]);\n+        same(\"{:10$.10s}\", ~[Argument(Argument {\n+            position: ArgumentNext,\n+            format: FormatSpec {\n+                fill: None,\n+                align: None,\n+                flags: 0,\n+                precision: CountIs(10),\n+                width: CountIsParam(10),\n+                ty: \"s\",\n+            },\n+            method: None,\n+        })]);\n+        same(\"{:.*s}\", ~[Argument(Argument {\n+            position: ArgumentNext,\n+            format: FormatSpec {\n+                fill: None,\n+                align: None,\n+                flags: 0,\n+                precision: CountIsNextParam,\n+                width: CountImplied,\n+                ty: \"s\",\n+            },\n+            method: None,\n+        })]);\n+        same(\"{:.10$s}\", ~[Argument(Argument {\n+            position: ArgumentNext,\n+            format: FormatSpec {\n+                fill: None,\n+                align: None,\n+                flags: 0,\n+                precision: CountIsParam(10),\n+                width: CountImplied,\n+                ty: \"s\",\n+            },\n+            method: None,\n+        })]);\n+    }\n+    #[test]\n+    fn format_flags() {\n+        same(\"{:-}\", ~[Argument(Argument {\n+            position: ArgumentNext,\n+            format: FormatSpec {\n+                fill: None,\n+                align: None,\n+                flags: (1 << FlagSignMinus as uint),\n+                precision: CountImplied,\n+                width: CountImplied,\n+                ty: \"\",\n+            },\n+            method: None,\n+        })]);\n+        same(\"{:+#}\", ~[Argument(Argument {\n+            position: ArgumentNext,\n+            format: FormatSpec {\n+                fill: None,\n+                align: None,\n+                flags: (1 << FlagSignPlus as uint) | (1 << FlagAlternate as uint),\n+                precision: CountImplied,\n+                width: CountImplied,\n+                ty: \"\",\n+            },\n+            method: None,\n+        })]);\n+    }\n+    #[test]\n+    fn format_mixture() {\n+        same(\"abcd {3:a} efg\", ~[String(\"abcd \"), Argument(Argument {\n+            position: ArgumentIs(3),\n+            format: FormatSpec {\n+                fill: None,\n+                align: None,\n+                flags: 0,\n+                precision: CountImplied,\n+                width: CountImplied,\n+                ty: \"a\",\n+            },\n+            method: None,\n+        }), String(\" efg\")]);\n+    }\n+\n+    #[test]\n+    fn select_simple() {\n+        same(\"{, select, other { haha } }\", ~[Argument(Argument{\n+            position: ArgumentNext,\n+            format: fmtdflt(),\n+            method: Some(~Select(~[], ~[String(\" haha \")]))\n+        })]);\n+        same(\"{1, select, other { haha } }\", ~[Argument(Argument{\n+            position: ArgumentIs(1),\n+            format: fmtdflt(),\n+            method: Some(~Select(~[], ~[String(\" haha \")]))\n+        })]);\n+        same(\"{1, select, other {#} }\", ~[Argument(Argument{\n+            position: ArgumentIs(1),\n+            format: fmtdflt(),\n+            method: Some(~Select(~[], ~[CurrentArgument]))\n+        })]);\n+        same(\"{1, select, other {{2, select, other {lol}}} }\", ~[Argument(Argument{\n+            position: ArgumentIs(1),\n+            format: fmtdflt(),\n+            method: Some(~Select(~[], ~[Argument(Argument{\n+                position: ArgumentIs(2),\n+                format: fmtdflt(),\n+                method: Some(~Select(~[], ~[String(\"lol\")]))\n+            })])) // wat\n+        })]);\n+    }\n+\n+    #[test]\n+    fn select_cases() {\n+        same(\"{1, select, a{1} b{2} c{3} other{4} }\", ~[Argument(Argument{\n+            position: ArgumentIs(1),\n+            format: fmtdflt(),\n+            method: Some(~Select(~[\n+                SelectArm{ selector: \"a\", result: ~[String(\"1\")] },\n+                SelectArm{ selector: \"b\", result: ~[String(\"2\")] },\n+                SelectArm{ selector: \"c\", result: ~[String(\"3\")] },\n+            ], ~[String(\"4\")]))\n+        })]);\n+    }\n+\n+    #[test] #[should_fail] fn badselect01() {\n+        musterr(\"{select, }\")\n+    }\n+    #[test] #[should_fail] fn badselect02() {\n+        musterr(\"{1, select}\")\n+    }\n+    #[test] #[should_fail] fn badselect03() {\n+        musterr(\"{1, select, }\")\n+    }\n+    #[test] #[should_fail] fn badselect04() {\n+        musterr(\"{1, select, a {}}\")\n+    }\n+    #[test] #[should_fail] fn badselect05() {\n+        musterr(\"{1, select, other }}\")\n+    }\n+    #[test] #[should_fail] fn badselect06() {\n+        musterr(\"{1, select, other {}\")\n+    }\n+    #[test] #[should_fail] fn badselect07() {\n+        musterr(\"{select, other {}\")\n+    }\n+    #[test] #[should_fail] fn badselect08() {\n+        musterr(\"{1 select, other {}\")\n+    }\n+    #[test] #[should_fail] fn badselect09() {\n+        musterr(\"{:d select, other {}\")\n+    }\n+    #[test] #[should_fail] fn badselect10() {\n+        musterr(\"{1:d select, other {}\")\n+    }\n+\n+    #[test]\n+    fn plural_simple() {\n+        same(\"{, plural, other { haha } }\", ~[Argument(Argument{\n+            position: ArgumentNext,\n+            format: fmtdflt(),\n+            method: Some(~Plural(None, ~[], ~[String(\" haha \")]))\n+        })]);\n+        same(\"{:, plural, other { haha } }\", ~[Argument(Argument{\n+            position: ArgumentNext,\n+            format: fmtdflt(),\n+            method: Some(~Plural(None, ~[], ~[String(\" haha \")]))\n+        })]);\n+        same(\"{, plural, offset:1 =2{2} =3{3} many{yes} other{haha} }\",\n+        ~[Argument(Argument{\n+            position: ArgumentNext,\n+            format: fmtdflt(),\n+            method: Some(~Plural(Some(1), ~[\n+                PluralArm{ selector: Right(2), result: ~[String(\"2\")] },\n+                PluralArm{ selector: Right(3), result: ~[String(\"3\")] },\n+                PluralArm{ selector: Left(Many), result: ~[String(\"yes\")] }\n+            ], ~[String(\"haha\")]))\n+        })]);\n+    }\n+}"}, {"sha": "6feb1d7a848038fb1ca1bc257e1b87ad3cf045f8", "filename": "src/libstd/fmt/rt.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Ffmt%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Ffmt%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Frt.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This is an internal module used by the ifmt! runtime. These structures are\n+//! emitted to static arrays to precompile format strings ahead of time.\n+//!\n+//! These definitions are similar to their `ct` equivalents, but differ in that\n+//! these can be statically allocated and are slightly optimized for the runtime\n+\n+#[allow(missing_doc)];\n+#[doc(hidden)];\n+\n+use either::Either;\n+use fmt::parse;\n+use option::Option;\n+\n+pub enum Piece<'self> {\n+    String(&'self str),\n+    // FIXME(#8259): this shouldn't require the unit-value here\n+    CurrentArgument(()),\n+    Argument(Argument<'self>),\n+}\n+\n+pub struct Argument<'self> {\n+    position: Position,\n+    format: FormatSpec,\n+    method: Option<&'self Method<'self>>\n+}\n+\n+pub struct FormatSpec {\n+    fill: char,\n+    alignleft: bool,\n+    flags: uint,\n+    precision: parse::Count,\n+    width: parse::Count,\n+}\n+\n+pub enum Position {\n+    ArgumentNext, ArgumentIs(uint)\n+}\n+\n+pub enum Method<'self> {\n+    Plural(Option<uint>, &'self [PluralArm<'self>], &'self [Piece<'self>]),\n+    Select(&'self [SelectArm<'self>], &'self [Piece<'self>]),\n+}\n+\n+pub struct PluralArm<'self> {\n+    selector: Either<parse::PluralKeyword, uint>,\n+    result: &'self [Piece<'self>],\n+}\n+\n+pub struct SelectArm<'self> {\n+    selector: &'self str,\n+    result: &'self [Piece<'self>],\n+}"}, {"sha": "84cba254dcf23599258f50f64fdbfdc1637cff30", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -19,7 +19,7 @@ use container::{Container, Mutable, Map, MutableMap, Set, MutableSet};\n use clone::Clone;\n use cmp::{Eq, Equiv};\n use hash::Hash;\n-use iterator::{Iterator, IteratorUtil, FromIterator, Extendable, range};\n+use iterator::{Iterator, IteratorUtil, FromIterator, Extendable};\n use iterator::{FilterMap, Chain, Repeat, Zip};\n use num;\n use option::{None, Option, Some};\n@@ -238,7 +238,7 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n         let len_buckets = self.buckets.len();\n         let bucket = self.buckets[idx].take();\n \n-        let value = do bucket.map_consume |bucket| {\n+        let value = do bucket.map_move |bucket| {\n             bucket.value\n         };\n \n@@ -265,8 +265,8 @@ impl<K:Hash + Eq,V> Container for HashMap<K, V> {\n impl<K:Hash + Eq,V> Mutable for HashMap<K, V> {\n     /// Clear the map, removing all key-value pairs.\n     fn clear(&mut self) {\n-        for idx in range(0u, self.buckets.len()) {\n-            self.buckets[idx] = None;\n+        for bkt in self.buckets.mut_iter() {\n+            *bkt = None;\n         }\n         self.size = 0;\n     }\n@@ -479,7 +479,7 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n impl<K: Hash + Eq, V: Clone> HashMap<K, V> {\n     /// Like `find`, but returns a copy of the value.\n     pub fn find_copy(&self, k: &K) -> Option<V> {\n-        self.find(k).map_consume(|v| (*v).clone())\n+        self.find(k).map_move(|v| (*v).clone())\n     }\n \n     /// Like `get`, but returns a copy of the value."}, {"sha": "d10a5541e41a683fef643f9c02aa2957abf2a15c", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 36, "deletions": 7, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -18,9 +18,9 @@ implementing the `Iterator` trait.\n */\n \n use cmp;\n-use num::{Zero, One, Saturating};\n+use num::{Zero, One, Integer, Saturating};\n use option::{Option, Some, None};\n-use ops::{Add, Mul};\n+use ops::{Add, Mul, Sub};\n use cmp::Ord;\n use clone::Clone;\n use uint;\n@@ -674,7 +674,7 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n                     Some((y, y_val))\n                 }\n             }\n-        }).map_consume(|(x, _)| x)\n+        }).map_move(|(x, _)| x)\n     }\n \n     #[inline]\n@@ -689,7 +689,7 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n                     Some((y, y_val))\n                 }\n             }\n-        }).map_consume(|(x, _)| x)\n+        }).map_move(|(x, _)| x)\n     }\n }\n \n@@ -1382,7 +1382,7 @@ impl<'self, A, T: Iterator<A>, B, U: Iterator<B>> Iterator<B> for\n                     return Some(x)\n                 }\n             }\n-            match self.iter.next().map_consume(|x| (self.f)(x)) {\n+            match self.iter.next().map_move(|x| (self.f)(x)) {\n                 None => return self.backiter.chain_mut_ref(|it| it.next()),\n                 next => self.frontiter = next,\n             }\n@@ -1414,7 +1414,7 @@ impl<'self,\n                     y => return y\n                 }\n             }\n-            match self.iter.next_back().map_consume(|x| (self.f)(x)) {\n+            match self.iter.next_back().map_move(|x| (self.f)(x)) {\n                 None => return self.frontiter.chain_mut_ref(|it| it.next_back()),\n                 next => self.backiter = next,\n             }\n@@ -1531,7 +1531,7 @@ pub fn range<A: Add<A, A> + Ord + Clone + One>(start: A, stop: A) -> Range<A> {\n     Range{state: start, stop: stop, one: One::one()}\n }\n \n-impl<A: Add<A, A> + Ord + Clone + One> Iterator<A> for Range<A> {\n+impl<A: Add<A, A> + Ord + Clone> Iterator<A> for Range<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         if self.state < self.stop {\n@@ -1544,6 +1544,22 @@ impl<A: Add<A, A> + Ord + Clone + One> Iterator<A> for Range<A> {\n     }\n }\n \n+impl<A: Sub<A, A> + Integer + Ord + Clone> DoubleEndedIterator<A> for Range<A> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A> {\n+        if self.stop > self.state {\n+            // Integer doesn't technically define this rule, but we're going to assume that every\n+            // Integer is reachable from every other one by adding or subtracting enough Ones. This\n+            // seems like a reasonable-enough rule that every Integer should conform to, even if it\n+            // can't be statically checked.\n+            self.stop = self.stop - self.one;\n+            Some(self.stop.clone())\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n impl<A: Add<A, A> + Clone> Iterator<A> for Counter<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n@@ -2121,4 +2137,17 @@ mod tests {\n         check_randacc_iter(xs.iter().cycle().take_(27), 27);\n         check_randacc_iter(empty.iter().cycle(), 0);\n     }\n+\n+    #[test]\n+    fn test_double_ended_range() {\n+        assert_eq!(range(11i, 14).invert().collect::<~[int]>(), ~[13i, 12, 11]);\n+        for _ in range(10i, 0).invert() {\n+            fail!(\"unreachable\");\n+        }\n+\n+        assert_eq!(range(11u, 14).invert().collect::<~[uint]>(), ~[13u, 12, 11]);\n+        for _ in range(10u, 0).invert() {\n+            fail!(\"unreachable\");\n+        }\n+    }\n }"}, {"sha": "a73809d202c44c7eb64a47be72c228bc159f7e47", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -110,24 +110,24 @@ fn test_tls_multitask() {\n     set(my_key, @~\"parent data\");\n     do task::spawn {\n         // TLS shouldn't carry over.\n-        assert!(get(my_key, |k| k.map(|&k| *k)).is_none());\n+        assert!(get(my_key, |k| k.map_move(|k| *k)).is_none());\n         set(my_key, @~\"child data\");\n-        assert!(*(get(my_key, |k| k.map(|&k| *k)).unwrap()) ==\n+        assert!(*(get(my_key, |k| k.map_move(|k| *k)).unwrap()) ==\n                 ~\"child data\");\n         // should be cleaned up for us\n     }\n     // Must work multiple times\n-    assert!(*(get(my_key, |k| k.map(|&k| *k)).unwrap()) == ~\"parent data\");\n-    assert!(*(get(my_key, |k| k.map(|&k| *k)).unwrap()) == ~\"parent data\");\n-    assert!(*(get(my_key, |k| k.map(|&k| *k)).unwrap()) == ~\"parent data\");\n+    assert!(*(get(my_key, |k| k.map_move(|k| *k)).unwrap()) == ~\"parent data\");\n+    assert!(*(get(my_key, |k| k.map_move(|k| *k)).unwrap()) == ~\"parent data\");\n+    assert!(*(get(my_key, |k| k.map_move(|k| *k)).unwrap()) == ~\"parent data\");\n }\n \n #[test]\n fn test_tls_overwrite() {\n     static my_key: Key<@~str> = &Key;\n     set(my_key, @~\"first data\");\n     set(my_key, @~\"next data\"); // Shouldn't leak.\n-    assert!(*(get(my_key, |k| k.map(|&k| *k)).unwrap()) == ~\"next data\");\n+    assert!(*(get(my_key, |k| k.map_move(|k| *k)).unwrap()) == ~\"next data\");\n }\n \n #[test]"}, {"sha": "60527905779f035296e8a126b7dfbe9b037677a0", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -278,18 +278,22 @@ impl One for f64 {\n \n #[cfg(not(test))]\n impl Add<f64,f64> for f64 {\n+    #[inline]\n     fn add(&self, other: &f64) -> f64 { *self + *other }\n }\n #[cfg(not(test))]\n impl Sub<f64,f64> for f64 {\n+    #[inline]\n     fn sub(&self, other: &f64) -> f64 { *self - *other }\n }\n #[cfg(not(test))]\n impl Mul<f64,f64> for f64 {\n+    #[inline]\n     fn mul(&self, other: &f64) -> f64 { *self * *other }\n }\n #[cfg(not(test))]\n impl Div<f64,f64> for f64 {\n+    #[inline]\n     fn div(&self, other: &f64) -> f64 { *self / *other }\n }\n #[cfg(not(test))]"}, {"sha": "b692bedebfd54f0ed17b39f5fcc99701abec5d32", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -124,14 +124,6 @@ pub fn range_step_inclusive(start: $T, last: $T, step: $T, it: &fn($T) -> bool)\n     range_step_core(start, last, step, Closed, it)\n }\n \n-\n-#[inline]\n-/// Iterate over the range (`hi`..`lo`]\n-pub fn range_rev(hi: $T, lo: $T, it: &fn($T) -> bool) -> bool {\n-    if hi == min_value { return true; }\n-    range_step_inclusive(hi-1, lo, -1 as $T, it)\n-}\n-\n impl Num for $T {}\n \n #[cfg(not(test))]\n@@ -889,10 +881,6 @@ mod tests {\n     fn test_ranges() {\n         let mut l = ~[];\n \n-        do range_rev(14,11) |i| {\n-            l.push(i);\n-            true\n-        };\n         do range_step(20,26,2) |i| {\n             l.push(i);\n             true\n@@ -917,18 +905,14 @@ mod tests {\n             l.push(i);\n             true\n         };\n-        assert_eq!(l, ~[13,12,11,\n-                        20,22,24,\n+        assert_eq!(l, ~[20,22,24,\n                         36,34,32,\n                         max_value-2,\n                         max_value-3,max_value-1,\n                         min_value+2,\n                         min_value+3,min_value+1]);\n \n         // None of the `fail`s should execute.\n-        do range_rev(0,10) |_i| {\n-            fail!(~\"unreachable\");\n-        };\n         do range_step(10,0,1) |_i| {\n             fail!(~\"unreachable\");\n         };"}, {"sha": "1f22343ad9c36063b8dc392120a4b3c451c15e45", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -422,9 +422,9 @@ pub fn float_to_str_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Float+Round+\n \n // Some constants for from_str_bytes_common's input validation,\n // they define minimum radix values for which the character is a valid digit.\n-priv static DIGIT_P_RADIX: uint = ('p' as uint) - ('a' as uint) + 11u;\n-priv static DIGIT_I_RADIX: uint = ('i' as uint) - ('a' as uint) + 11u;\n-priv static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n+static DIGIT_P_RADIX: uint = ('p' as uint) - ('a' as uint) + 11u;\n+static DIGIT_I_RADIX: uint = ('i' as uint) - ('a' as uint) + 11u;\n+static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n \n /**\n  * Parses a byte slice as a number. This is meant to"}, {"sha": "29b8f29d87d3f866a37bff576ea9e408be768687", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -125,13 +125,6 @@ pub fn range_step_inclusive(start: $T, last: $T, step: $T_SIGNED, it: &fn($T) ->\n     range_step_core(start, last, step, Closed, it)\n }\n \n-#[inline]\n-/// Iterate over the range (`hi`..`lo`]\n-pub fn range_rev(hi: $T, lo: $T, it: &fn($T) -> bool) -> bool {\n-    if hi == min_value { return true; }\n-    range_step_inclusive(hi-1, lo, -1 as $T_SIGNED, it)\n-}\n-\n impl Num for $T {}\n \n #[cfg(not(test))]\n@@ -654,10 +647,6 @@ mod tests {\n     pub fn test_ranges() {\n         let mut l = ~[];\n \n-        do range_rev(14,11) |i| {\n-            l.push(i);\n-            true\n-        };\n         do range_step(20,26,2) |i| {\n             l.push(i);\n             true\n@@ -683,18 +672,14 @@ mod tests {\n             true\n         };\n \n-        assert_eq!(l, ~[13,12,11,\n-                        20,22,24,\n+        assert_eq!(l, ~[20,22,24,\n                         36,34,32,\n                         max_value-2,\n                         max_value-3,max_value-1,\n                         min_value+2,\n                         min_value+3,min_value+1]);\n \n         // None of the `fail`s should execute.\n-        do range_rev(0,0) |_i| {\n-            fail!(\"unreachable\");\n-        };\n         do range_step(10,0,1) |_i| {\n             fail!(\"unreachable\");\n         };"}, {"sha": "66b30d8dd031c288eb2200fd4f35d69553f5a35b", "filename": "src/libstd/option.rs", "status": "modified", "additions": 10, "deletions": 24, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -208,6 +208,12 @@ impl<T> Option<T> {\n         match *self { Some(ref mut x) => Some(f(x)), None => None }\n     }\n \n+    /// Applies a function to the contained value or returns a default\n+    #[inline]\n+    pub fn map_default<'a, U>(&'a self, def: U, f: &fn(&'a T) -> U) -> U {\n+        match *self { None => def, Some(ref t) => f(t) }\n+    }\n+\n     /// Maps a `Some` value from one type to another by a mutable reference,\n     /// or returns a default value.\n     #[inline]\n@@ -218,21 +224,15 @@ impl<T> Option<T> {\n     /// As `map`, but consumes the option and gives `f` ownership to avoid\n     /// copying.\n     #[inline]\n-    pub fn map_consume<U>(self, f: &fn(v: T) -> U) -> Option<U> {\n-        match self { None => None, Some(v) => Some(f(v)) }\n-    }\n-\n-    /// Applies a function to the contained value or returns a default\n-    #[inline]\n-    pub fn map_default<'a, U>(&'a self, def: U, f: &fn(&'a T) -> U) -> U {\n-        match *self { None => def, Some(ref t) => f(t) }\n+    pub fn map_move<U>(self, f: &fn(T) -> U) -> Option<U> {\n+        match self { Some(x) => Some(f(x)), None => None }\n     }\n \n     /// As `map_default`, but consumes the option and gives `f`\n     /// ownership to avoid copying.\n     #[inline]\n-    pub fn map_consume_default<U>(self, def: U, f: &fn(v: T) -> U) -> U {\n-        match self { None => def, Some(v) => f(v) }\n+    pub fn map_move_default<U>(self, def: U, f: &fn(T) -> U) -> U {\n+        match self { None => def, Some(t) => f(t) }\n     }\n \n     /// Take the value out of the option, leaving a `None` in its place.\n@@ -241,20 +241,6 @@ impl<T> Option<T> {\n         util::replace(self, None)\n     }\n \n-    /// As `map_consume`, but swaps a None into the original option rather\n-    /// than consuming it by-value.\n-    #[inline]\n-    pub fn take_map<U>(&mut self, blk: &fn(T) -> U) -> Option<U> {\n-        self.take().map_consume(blk)\n-    }\n-\n-    /// As `map_consume_default`, but swaps a None into the original option\n-    /// rather than consuming it by-value.\n-    #[inline]\n-    pub fn take_map_default<U> (&mut self, def: U, blk: &fn(T) -> U) -> U {\n-        self.take().map_consume_default(def, blk)\n-    }\n-\n     /// Apply a function to the contained value or do nothing.\n     /// Returns true if the contained value was mutated.\n     pub fn mutate(&mut self, f: &fn(T) -> T) -> bool {"}, {"sha": "57415e89cfb980127d149a6648c00aa54b215bb8", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -501,9 +501,7 @@ pub fn self_exe_path() -> Option<Path> {\n         }\n     }\n \n-    do load_self().map |pth| {\n-        Path(*pth).dir_path()\n-    }\n+    load_self().map_move(|path| Path(path).dir_path())\n }\n \n "}, {"sha": "5f8fa9fddbcf7c2808f06ea9247590d49d4fa297", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -610,15 +610,32 @@ impl<R: Rng> RngUtil for R {\n }\n \n /// Create a random number generator with a default algorithm and seed.\n+///\n+/// It returns the cryptographically-safest `Rng` algorithm currently\n+/// available in Rust. If you require a specifically seeded `Rng` for\n+/// consistency over time you should pick one algorithm and create the\n+/// `Rng` yourself.\n pub fn rng() -> IsaacRng {\n     IsaacRng::new()\n }\n \n+/// Create a weak random number generator with a default algorithm and seed.\n+///\n+/// It returns the fatest `Rng` algorithm currently available in Rust without\n+/// consideration for cryptography or security. If you require a specifically\n+/// seeded `Rng` for consistency over time you should pick one algorithm and\n+/// create the `Rng` yourself.\n+pub fn weak_rng() -> XorShiftRng {\n+    XorShiftRng::new()\n+}\n+\n static RAND_SIZE_LEN: u32 = 8;\n static RAND_SIZE: u32 = 1 << RAND_SIZE_LEN;\n \n /// A random number generator that uses the [ISAAC\n /// algorithm](http://en.wikipedia.org/wiki/ISAAC_%28cipher%29).\n+///\n+/// The ISAAC algorithm is suitable for cryptographic purposes.\n pub struct IsaacRng {\n     priv cnt: u32,\n     priv rsl: [u32, .. RAND_SIZE],\n@@ -794,8 +811,11 @@ impl Rng for IsaacRng {\n }\n \n /// An [Xorshift random number\n-/// generator](http://en.wikipedia.org/wiki/Xorshift). Not suitable for\n-/// cryptographic purposes.\n+/// generator](http://en.wikipedia.org/wiki/Xorshift).\n+///\n+/// The Xorshift algorithm is not suitable for cryptographic purposes\n+/// but is very fast. If you do not know for sure that it fits your\n+/// requirements, use a more secure one such as `IsaacRng`.\n pub struct XorShiftRng {\n     priv x: u32,\n     priv y: u32,"}, {"sha": "3e429c6116d4c60d2c7aa191170405433b158593", "filename": "src/libstd/result.rs", "status": "modified", "additions": 52, "deletions": 4, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -149,6 +149,40 @@ impl<T, E: ToStr> Result<T, E> {\n         }\n     }\n \n+    /// Call a method based on a previous result\n+    ///\n+    /// If `self` is `Ok` then the value is extracted and passed to `op`\n+    /// whereupon `op`s result is wrapped in `Ok` and returned. if `self` is\n+    /// `Err` then it is immediately returned.  This function can be used to\n+    /// compose the results of two functions.\n+    ///\n+    /// Example:\n+    ///\n+    ///     let res = do read_file(file).map_move |buf| {\n+    ///         parse_bytes(buf)\n+    ///     }\n+    #[inline]\n+    pub fn map_move<U>(self, op: &fn(T) -> U) -> Result<U,E> {\n+        match self {\n+          Ok(t) => Ok(op(t)),\n+          Err(e) => Err(e)\n+        }\n+    }\n+\n+    /// Call a method based on a previous result\n+    ///\n+    /// If `self` is `Err` then the value is extracted and passed to `op`\n+    /// whereupon `op`s result is wrapped in an `Err` and returned. if `self` is\n+    /// `Ok` then it is immediately returned.  This function can be used to pass\n+    /// through a successful result while handling an error.\n+    #[inline]\n+    pub fn map_err_move<F>(self, op: &fn(E) -> F) -> Result<T,F> {\n+        match self {\n+          Ok(t) => Ok(t),\n+          Err(e) => Err(op(e))\n+        }\n+    }\n+\n     /// Call a method based on a previous result\n     ///\n     /// If `self` is `Ok` then the value is extracted and passed to `op`\n@@ -312,7 +346,9 @@ pub fn iter_vec2<S, T, U: ToStr>(ss: &[S], ts: &[T],\n #[cfg(test)]\n mod tests {\n     use super::*;\n+\n     use either;\n+    use str::OwnedStr;\n \n     pub fn op1() -> Result<int, ~str> { Ok(666) }\n \n@@ -359,14 +395,26 @@ mod tests {\n \n     #[test]\n     pub fn test_impl_map() {\n-        assert_eq!(Ok::<~str, ~str>(~\"a\").map(|_x| ~\"b\"), Ok(~\"b\"));\n-        assert_eq!(Err::<~str, ~str>(~\"a\").map(|_x| ~\"b\"), Err(~\"a\"));\n+        assert_eq!(Ok::<~str, ~str>(~\"a\").map(|x| (~\"b\").append(*x)), Ok(~\"ba\"));\n+        assert_eq!(Err::<~str, ~str>(~\"a\").map(|x| (~\"b\").append(*x)), Err(~\"a\"));\n     }\n \n     #[test]\n     pub fn test_impl_map_err() {\n-        assert_eq!(Ok::<~str, ~str>(~\"a\").map_err(|_x| ~\"b\"), Ok(~\"a\"));\n-        assert_eq!(Err::<~str, ~str>(~\"a\").map_err(|_x| ~\"b\"), Err(~\"b\"));\n+        assert_eq!(Ok::<~str, ~str>(~\"a\").map_err(|x| (~\"b\").append(*x)), Ok(~\"a\"));\n+        assert_eq!(Err::<~str, ~str>(~\"a\").map_err(|x| (~\"b\").append(*x)), Err(~\"ba\"));\n+    }\n+\n+    #[test]\n+    pub fn test_impl_map_move() {\n+        assert_eq!(Ok::<~str, ~str>(~\"a\").map_move(|x| x + \"b\"), Ok(~\"ab\"));\n+        assert_eq!(Err::<~str, ~str>(~\"a\").map_move(|x| x + \"b\"), Err(~\"a\"));\n+    }\n+\n+    #[test]\n+    pub fn test_impl_map_err_move() {\n+        assert_eq!(Ok::<~str, ~str>(~\"a\").map_err_move(|x| x + \"b\"), Ok(~\"a\"));\n+        assert_eq!(Err::<~str, ~str>(~\"a\").map_err_move(|x| x + \"b\"), Err(~\"ab\"));\n     }\n \n     #[test]"}, {"sha": "936a6526508a93f4c47cf5fdf2d69f4b15c4586f", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -159,7 +159,7 @@ impl<T> ChanOne<T> {\n                     // Port is blocked. Wake it up.\n                     let recvr = BlockedTask::cast_from_uint(task_as_state);\n                     if do_resched {\n-                        do recvr.wake().map_consume |woken_task| {\n+                        do recvr.wake().map_move |woken_task| {\n                             Scheduler::run_task(woken_task);\n                         };\n                     } else {\n@@ -225,9 +225,10 @@ impl<T> Select for PortOne<T> {\n     fn optimistic_check(&mut self) -> bool {\n         // The optimistic check is never necessary for correctness. For testing\n         // purposes, making it randomly return false simulates a racing sender.\n-        use rand::{Rand, rng};\n-        let mut rng = rng();\n-        let actually_check = Rand::rand(&mut rng);\n+        use rand::{Rand};\n+        let actually_check = do Local::borrow::<Scheduler, bool> |sched| {\n+            Rand::rand(&mut sched.rng)\n+        };\n         if actually_check {\n             unsafe { (*self.packet()).state.load(Acquire) == STATE_ONE }\n         } else {\n@@ -381,7 +382,7 @@ impl<T> Drop for ChanOne<T> {\n                     // The port is blocked waiting for a message we will never send. Wake it.\n                     assert!((*this.packet()).payload.is_none());\n                     let recvr = BlockedTask::cast_from_uint(task_as_state);\n-                    do recvr.wake().map_consume |woken_task| {\n+                    do recvr.wake().map_move |woken_task| {\n                         Scheduler::run_task(woken_task);\n                     };\n                 }\n@@ -508,7 +509,11 @@ impl<T> Peekable<T> for Port<T> {\n     }\n }\n \n-impl<T> Select for Port<T> {\n+// XXX: Kind of gross. A Port<T> should be selectable so you can make an array\n+// of them, but a &Port<T> should also be selectable so you can select2 on it\n+// alongside a PortOne<U> without passing the port by value in recv_ready.\n+\n+impl<'self, T> Select for &'self Port<T> {\n     #[inline]\n     fn optimistic_check(&mut self) -> bool {\n         do self.next.with_mut_ref |pone| { pone.optimistic_check() }\n@@ -526,12 +531,29 @@ impl<T> Select for Port<T> {\n     }\n }\n \n-impl<T> SelectPort<(T, Port<T>)> for Port<T> {\n-    fn recv_ready(self) -> Option<(T, Port<T>)> {\n+impl<T> Select for Port<T> {\n+    #[inline]\n+    fn optimistic_check(&mut self) -> bool {\n+        (&*self).optimistic_check()\n+    }\n+\n+    #[inline]\n+    fn block_on(&mut self, sched: &mut Scheduler, task: BlockedTask) -> bool {\n+        (&*self).block_on(sched, task)\n+    }\n+\n+    #[inline]\n+    fn unblock_from(&mut self) -> bool {\n+        (&*self).unblock_from()\n+    }\n+}\n+\n+impl<'self, T> SelectPort<T> for &'self Port<T> {\n+    fn recv_ready(self) -> Option<T> {\n         match self.next.take().recv_ready() {\n             Some(StreamPayload { val, next }) => {\n                 self.next.put_back(next);\n-                Some((val, self))\n+                Some(val)\n             }\n             None => None\n         }"}, {"sha": "6e671742fb6fdfa7fd8c8c71b8ed58fcbd34faca", "filename": "src/libstd/rt/env.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Frt%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Frt%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fenv.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -10,7 +10,12 @@\n \n //! Runtime environment settings\n \n+use from_str::FromStr;\n use libc::{size_t, c_char, c_int};\n+use option::{Some, None};\n+use os;\n+\n+// OLD RT stuff\n \n pub struct Environment {\n     /// The number of threads to use by default\n@@ -47,3 +52,26 @@ pub fn get() -> &Environment {\n extern {\n     fn rust_get_rt_env() -> &Environment;\n }\n+\n+// NEW RT stuff\n+\n+// Note that these are all accessed without any synchronization.\n+// They are expected to be initialized once then left alone.\n+\n+static mut MIN_STACK: uint = 2000000;\n+\n+pub fn init() {\n+    unsafe {\n+        match os::getenv(\"RUST_MIN_STACK\") {\n+            Some(s) => match FromStr::from_str(s) {\n+                Some(i) => MIN_STACK = i,\n+                None => ()\n+            },\n+            None => ()\n+        }\n+    }\n+}\n+\n+pub fn min_stack() -> uint {\n+    unsafe { MIN_STACK }\n+}"}, {"sha": "277897e5d2e27b80587309d16a7ef48475939560", "filename": "src/libstd/rt/io/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Frt%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Frt%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmem.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -26,7 +26,7 @@ pub struct MemWriter {\n }\n \n impl MemWriter {\n-    pub fn new() -> MemWriter { MemWriter { buf: ~[] } }\n+    pub fn new() -> MemWriter { MemWriter { buf: vec::with_capacity(128) } }\n }\n \n impl Writer for MemWriter {"}, {"sha": "e07cb1425bf75819efa2dfc1a58568e5518fe0f3", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -402,10 +402,10 @@ impl KillHandle {\n                     || {\n                         // Prefer to check tombstones that were there first,\n                         // being \"more fair\" at the expense of tail-recursion.\n-                        others.take().map_consume_default(true, |f| f()) && {\n+                        others.take().map_move_default(true, |f| f()) && {\n                             let mut inner = this.take().unwrap();\n                             (!inner.any_child_failed) &&\n-                                inner.child_tombstones.take_map_default(true, |f| f())\n+                                inner.child_tombstones.take().map_move_default(true, |f| f())\n                         }\n                     }\n                 }\n@@ -424,7 +424,7 @@ impl KillHandle {\n                     let others = Cell::new(other_tombstones); // :(\n                     || {\n                         // Prefer fairness to tail-recursion, as in above case.\n-                        others.take().map_consume_default(true, |f| f()) &&\n+                        others.take().map_move_default(true, |f| f()) &&\n                             f.take()()\n                     }\n                 }\n@@ -493,15 +493,15 @@ impl Death {\n         { use util; util::ignore(group); }\n \n         // Step 1. Decide if we need to collect child failures synchronously.\n-        do self.on_exit.take_map |on_exit| {\n+        do self.on_exit.take().map_move |on_exit| {\n             if success {\n                 // We succeeded, but our children might not. Need to wait for them.\n                 let mut inner = self.kill_handle.take_unwrap().unwrap();\n                 if inner.any_child_failed {\n                     success = false;\n                 } else {\n                     // Lockless access to tombstones protected by unwrap barrier.\n-                    success = inner.child_tombstones.take_map_default(true, |f| f());\n+                    success = inner.child_tombstones.take().map_move_default(true, |f| f());\n                 }\n             }\n             on_exit(success);\n@@ -510,12 +510,12 @@ impl Death {\n         // Step 2. Possibly alert possibly-watching parent to failure status.\n         // Note that as soon as parent_handle goes out of scope, the parent\n         // can successfully unwrap its handle and collect our reported status.\n-        do self.watching_parent.take_map |mut parent_handle| {\n+        do self.watching_parent.take().map_move |mut parent_handle| {\n             if success {\n                 // Our handle might be None if we had an exit callback, and\n                 // already unwrapped it. But 'success' being true means no\n                 // child failed, so there's nothing to do (see below case).\n-                do self.kill_handle.take_map |own_handle| {\n+                do self.kill_handle.take().map_move |own_handle| {\n                     own_handle.reparent_children_to(&mut parent_handle);\n                 };\n             } else {\n@@ -590,7 +590,8 @@ impl Death {\n     #[inline]\n     pub fn assert_may_sleep(&self) {\n         if self.wont_sleep != 0 {\n-            rtabort!(\"illegal atomic-sleep: can't deschedule inside atomically()\");\n+            rtabort!(\"illegal atomic-sleep: attempt to reschedule while \\\n+                      using an Exclusive or LittleLock\");\n         }\n     }\n }\n@@ -614,6 +615,7 @@ mod test {\n     // Test cases don't care about the spare killed flag.\n     fn make_kill_handle() -> KillHandle { let (h,_) = KillHandle::new(); h }\n \n+    #[ignore(reason = \"linked failure\")]\n     #[test]\n     fn no_tombstone_success() {\n         do run_in_newsched_task {\n@@ -819,6 +821,7 @@ mod test {\n         }\n     }\n \n+    #[ignore(reason = \"linked failure\")]\n     #[test]\n     fn block_and_get_killed() {\n         do with_test_task |mut task| {\n@@ -830,6 +833,7 @@ mod test {\n         }\n     }\n \n+    #[ignore(reason = \"linked failure\")]\n     #[test]\n     fn block_already_killed() {\n         do with_test_task |mut task| {\n@@ -839,6 +843,7 @@ mod test {\n         }\n     }\n \n+    #[ignore(reason = \"linked failure\")]\n     #[test]\n     fn block_unkillably_and_get_killed() {\n         do with_test_task |mut task| {\n@@ -856,6 +861,7 @@ mod test {\n         }\n     }\n \n+    #[ignore(reason = \"linked failure\")]\n     #[test]\n     fn block_on_pipe() {\n         // Tests the \"killable\" path of casting to/from uint.\n@@ -869,6 +875,7 @@ mod test {\n         }\n     }\n \n+    #[ignore(reason = \"linked failure\")]\n     #[test]\n     fn block_unkillably_on_pipe() {\n         // Tests the \"indestructible\" path of casting to/from uint."}, {"sha": "7154066e7b748f4e6196567301986c766755e2bd", "filename": "src/libstd/rt/local.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Frt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Frt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -126,6 +126,7 @@ impl Local for IoFactoryObject {\n \n #[cfg(test)]\n mod test {\n+    use option::None;\n     use unstable::run_in_bare_thread;\n     use rt::test::*;\n     use super::*;\n@@ -137,7 +138,7 @@ mod test {\n         do run_in_bare_thread {\n             local_ptr::init_tls_key();\n             let mut sched = ~new_test_uv_sched();\n-            let task = ~Task::new_root(&mut sched.stack_pool, || {});\n+            let task = ~Task::new_root(&mut sched.stack_pool, None, || {});\n             Local::put(task);\n             let task: ~Task = Local::take();\n             cleanup_task(task);\n@@ -149,11 +150,11 @@ mod test {\n         do run_in_bare_thread {\n             local_ptr::init_tls_key();\n             let mut sched = ~new_test_uv_sched();\n-            let task = ~Task::new_root(&mut sched.stack_pool, || {});\n+            let task = ~Task::new_root(&mut sched.stack_pool, None, || {});\n             Local::put(task);\n             let task: ~Task = Local::take();\n             cleanup_task(task);\n-            let task = ~Task::new_root(&mut sched.stack_pool, || {});\n+            let task = ~Task::new_root(&mut sched.stack_pool, None, || {});\n             Local::put(task);\n             let task: ~Task = Local::take();\n             cleanup_task(task);\n@@ -166,7 +167,7 @@ mod test {\n         do run_in_bare_thread {\n             local_ptr::init_tls_key();\n             let mut sched = ~new_test_uv_sched();\n-            let task = ~Task::new_root(&mut sched.stack_pool, || {});\n+            let task = ~Task::new_root(&mut sched.stack_pool, None, || {});\n             Local::put(task);\n \n             unsafe {\n@@ -182,7 +183,7 @@ mod test {\n         do run_in_bare_thread {\n             local_ptr::init_tls_key();\n             let mut sched = ~new_test_uv_sched();\n-            let task = ~Task::new_root(&mut sched.stack_pool, || {});\n+            let task = ~Task::new_root(&mut sched.stack_pool, None, || {});\n             Local::put(task);\n \n             let res = do Local::borrow::<Task,bool> |_task| {"}, {"sha": "01a52892f633b95eb71484d218fbf18f43dab314", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -63,8 +63,7 @@ Several modules in `core` are clients of `rt`:\n use cell::Cell;\n use clone::Clone;\n use container::Container;\n-use iter::Times;\n-use iterator::{Iterator, IteratorUtil};\n+use iterator::{Iterator, IteratorUtil, range};\n use option::{Some, None};\n use ptr::RawPtr;\n use rt::local::Local;\n@@ -212,6 +211,7 @@ pub fn init(argc: int, argv: **u8, crate_map: *u8) {\n     // Need to propagate the unsafety to `start`.\n     unsafe {\n         args::init(argc, argv);\n+        env::init();\n         logging::init(crate_map);\n         rust_update_gc_metadata(crate_map);\n     }\n@@ -246,24 +246,32 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n \n     let main = Cell::new(main);\n \n-    // The shared list of sleeping schedulers. Schedulers wake each other\n-    // occassionally to do new work.\n+    // The shared list of sleeping schedulers.\n     let sleepers = SleeperList::new();\n-    // The shared work queue. Temporary until work stealing is implemented.\n-    let work_queue = WorkQueue::new();\n+\n+    // Create a work queue for each scheduler, ntimes. Create an extra\n+    // for the main thread if that flag is set. We won't steal from it.\n+    let mut work_queues = ~[];\n+    for _ in range(0u, nscheds) {\n+        let work_queue: WorkQueue<~Task> = WorkQueue::new();\n+        work_queues.push(work_queue);\n+    }\n \n     // The schedulers.\n     let mut scheds = ~[];\n     // Handles to the schedulers. When the main task ends these will be\n     // sent the Shutdown message to terminate the schedulers.\n     let mut handles = ~[];\n \n-    do nscheds.times {\n+    for i in range(0u, nscheds) {\n         rtdebug!(\"inserting a regular scheduler\");\n \n         // Every scheduler is driven by an I/O event loop.\n         let loop_ = ~UvEventLoop::new();\n-        let mut sched = ~Scheduler::new(loop_, work_queue.clone(), sleepers.clone());\n+        let mut sched = ~Scheduler::new(loop_,\n+                                        work_queues[i].clone(),\n+                                        work_queues.clone(),\n+                                        sleepers.clone());\n         let handle = sched.make_handle();\n \n         scheds.push(sched);\n@@ -279,9 +287,14 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n         let friend_handle = friend_sched.make_handle();\n         scheds.push(friend_sched);\n \n+        // This scheduler needs a queue that isn't part of the stealee\n+        // set.\n+        let work_queue = WorkQueue::new();\n+\n         let main_loop = ~UvEventLoop::new();\n         let mut main_sched = ~Scheduler::new_special(main_loop,\n-                                                     work_queue.clone(),\n+                                                     work_queue,\n+                                                     work_queues.clone(),\n                                                      sleepers.clone(),\n                                                      false,\n                                                      Some(friend_handle));\n@@ -330,8 +343,7 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n         // In the case where we do not use a main_thread scheduler we\n         // run the main task in one of our threads.\n \n-        let mut main_task = ~Task::new_root(&mut scheds[0].stack_pool,\n-                                            main.take());\n+        let mut main_task = ~Task::new_root(&mut scheds[0].stack_pool, None, main.take());\n         main_task.death.on_exit = Some(on_exit.take());\n         let main_task_cell = Cell::new(main_task);\n \n@@ -351,7 +363,7 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n         let sched_cell = Cell::new(sched);\n         let thread = do Thread::start {\n             let mut sched = sched_cell.take();\n-            let bootstrap_task = ~do Task::new_root(&mut sched.stack_pool) || {\n+            let bootstrap_task = ~do Task::new_root(&mut sched.stack_pool, None) || {\n                 rtdebug!(\"boostraping a non-primary scheduler\");\n             };\n             sched.bootstrap(bootstrap_task);\n@@ -368,10 +380,10 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n         let mut main_sched = main_sched.unwrap();\n \n         let home = Sched(main_sched.make_handle());\n-        let mut main_task = ~Task::new_root_homed(&mut main_sched.stack_pool,\n+        let mut main_task = ~Task::new_root_homed(&mut main_sched.stack_pool, None,\n                                                   home, main.take());\n         main_task.death.on_exit = Some(on_exit.take());\n-        rtdebug!(\"boostrapping main_task\");\n+        rtdebug!(\"bootstrapping main_task\");\n \n         main_sched.bootstrap(main_task);\n     }"}, {"sha": "ce4e64c47d2ef5cb3faefd7cd5ead4bf9400d9e3", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 123, "deletions": 54, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -13,7 +13,6 @@ use option::{Option, Some, None};\n use cast::{transmute, transmute_mut_region, transmute_mut_unsafe};\n use clone::Clone;\n use unstable::raw;\n-\n use super::sleeper_list::SleeperList;\n use super::work_queue::WorkQueue;\n use super::stack::{StackPool};\n@@ -28,6 +27,9 @@ use rt::rtio::RemoteCallback;\n use rt::metrics::SchedMetrics;\n use borrow::{to_uint};\n use cell::Cell;\n+use rand::{XorShiftRng, RngUtil};\n+use iterator::{range};\n+use vec::{OwnedVector};\n \n /// The Scheduler is responsible for coordinating execution of Coroutines\n /// on a single thread. When the scheduler is running it is owned by\n@@ -37,9 +39,11 @@ use cell::Cell;\n /// XXX: This creates too many callbacks to run_sched_once, resulting\n /// in too much allocation and too many events.\n pub struct Scheduler {\n-    /// A queue of available work. Under a work-stealing policy there\n-    /// is one per Scheduler.\n-    work_queue: WorkQueue<~Task>,\n+    /// There are N work queues, one per scheduler.\n+    priv work_queue: WorkQueue<~Task>,\n+    /// Work queues for the other schedulers. These are created by\n+    /// cloning the core work queues.\n+    work_queues: ~[WorkQueue<~Task>],\n     /// The queue of incoming messages from other schedulers.\n     /// These are enqueued by SchedHandles after which a remote callback\n     /// is triggered to handle the message.\n@@ -70,7 +74,10 @@ pub struct Scheduler {\n     run_anything: bool,\n     /// If the scheduler shouldn't run some tasks, a friend to send\n     /// them to.\n-    friend_handle: Option<SchedHandle>\n+    friend_handle: Option<SchedHandle>,\n+    /// A fast XorShift rng for scheduler use\n+    rng: XorShiftRng\n+\n }\n \n pub struct SchedHandle {\n@@ -97,17 +104,21 @@ impl Scheduler {\n \n     pub fn new(event_loop: ~EventLoopObject,\n                work_queue: WorkQueue<~Task>,\n+               work_queues: ~[WorkQueue<~Task>],\n                sleeper_list: SleeperList)\n         -> Scheduler {\n \n-        Scheduler::new_special(event_loop, work_queue, sleeper_list, true, None)\n+        Scheduler::new_special(event_loop, work_queue,\n+                               work_queues,\n+                               sleeper_list, true, None)\n \n     }\n \n     // When you create a scheduler it isn't yet \"in\" a task, so the\n     // task field is None.\n     pub fn new_special(event_loop: ~EventLoopObject,\n                        work_queue: WorkQueue<~Task>,\n+                       work_queues: ~[WorkQueue<~Task>],\n                        sleeper_list: SleeperList,\n                        run_anything: bool,\n                        friend: Option<SchedHandle>)\n@@ -120,12 +131,14 @@ impl Scheduler {\n             no_sleep: false,\n             event_loop: event_loop,\n             work_queue: work_queue,\n+            work_queues: work_queues,\n             stack_pool: StackPool::new(),\n             sched_task: None,\n             cleanup_job: None,\n             metrics: SchedMetrics::new(),\n             run_anything: run_anything,\n-            friend_handle: friend\n+            friend_handle: friend,\n+            rng: XorShiftRng::new()\n         }\n     }\n \n@@ -248,7 +261,7 @@ impl Scheduler {\n \n         // Second activity is to try resuming a task from the queue.\n \n-        let result = sched.resume_task_from_queue();\n+        let result = sched.do_work();\n         let mut sched = match result {\n             Some(sched) => {\n                 // Failed to dequeue a task, so we return.\n@@ -325,7 +338,7 @@ impl Scheduler {\n     /// As enqueue_task, but with the possibility for the blocked task to\n     /// already have been killed.\n     pub fn enqueue_blocked_task(&mut self, blocked_task: BlockedTask) {\n-        do blocked_task.wake().map_consume |task| {\n+        do blocked_task.wake().map_move |task| {\n             self.enqueue_task(task);\n         };\n     }\n@@ -415,47 +428,98 @@ impl Scheduler {\n         }\n     }\n \n-    // Resume a task from the queue - but also take into account that\n-    // it might not belong here.\n+    // Workstealing: In this iteration of the runtime each scheduler\n+    // thread has a distinct work queue. When no work is available\n+    // locally, make a few attempts to steal work from the queues of\n+    // other scheduler threads. If a few steals fail we end up in the\n+    // old \"no work\" path which is fine.\n+\n+    // First step in the process is to find a task. This function does\n+    // that by first checking the local queue, and if there is no work\n+    // there, trying to steal from the remote work queues.\n+    fn find_work(&mut self) -> Option<~Task> {\n+        rtdebug!(\"scheduler looking for work\");\n+        match self.work_queue.pop() {\n+            Some(task) => {\n+                rtdebug!(\"found a task locally\");\n+                return Some(task)\n+            }\n+            None => {\n+                // Our naive stealing, try kinda hard.\n+                rtdebug!(\"scheduler trying to steal\");\n+                let _len = self.work_queues.len();\n+                return self.try_steals(2);\n+            }\n+        }\n+    }\n+\n+    // With no backoff try stealing n times from the queues the\n+    // scheduler knows about. This naive implementation can steal from\n+    // our own queue or from other special schedulers.\n+    fn try_steals(&mut self, n: uint) -> Option<~Task> {\n+        for _ in range(0, n) {\n+            let index = self.rng.gen_uint_range(0, self.work_queues.len());\n+            let work_queues = &mut self.work_queues;\n+            match work_queues[index].steal() {\n+                Some(task) => {\n+                    rtdebug!(\"found task by stealing\"); return Some(task)\n+                }\n+                None => ()\n+            }\n+        };\n+        rtdebug!(\"giving up on stealing\");\n+        return None;\n+    }\n \n-    // If we perform a scheduler action we give away the scheduler ~\n-    // pointer, if it is still available we return it.\n+    // Given a task, execute it correctly.\n+    fn process_task(~self, task: ~Task) -> Option<~Scheduler> {\n+        let mut this = self;\n+        let mut task = task;\n \n-    fn resume_task_from_queue(~self) -> Option<~Scheduler> {\n+        rtdebug!(\"processing a task\");\n \n+        let home = task.take_unwrap_home();\n+        match home {\n+            Sched(home_handle) => {\n+                if home_handle.sched_id != this.sched_id() {\n+                    rtdebug!(\"sending task home\");\n+                    task.give_home(Sched(home_handle));\n+                    Scheduler::send_task_home(task);\n+                    return Some(this);\n+                } else {\n+                    rtdebug!(\"running task here\");\n+                    task.give_home(Sched(home_handle));\n+                    this.resume_task_immediately(task);\n+                    return None;\n+                }\n+            }\n+            AnySched if this.run_anything => {\n+                rtdebug!(\"running anysched task here\");\n+                task.give_home(AnySched);\n+                this.resume_task_immediately(task);\n+                return None;\n+            }\n+            AnySched => {\n+                rtdebug!(\"sending task to friend\");\n+                task.give_home(AnySched);\n+                this.send_to_friend(task);\n+                return Some(this);\n+            }\n+        }\n+    }\n+\n+    // Bundle the helpers together.\n+    fn do_work(~self) -> Option<~Scheduler> {\n         let mut this = self;\n \n-        match this.work_queue.pop() {\n+        rtdebug!(\"scheduler calling do work\");\n+        match this.find_work() {\n             Some(task) => {\n-                let mut task = task;\n-                let home = task.take_unwrap_home();\n-                match home {\n-                    Sched(home_handle) => {\n-                        if home_handle.sched_id != this.sched_id() {\n-                            task.give_home(Sched(home_handle));\n-                            Scheduler::send_task_home(task);\n-                            return Some(this);\n-                        } else {\n-                            this.event_loop.callback(Scheduler::run_sched_once);\n-                            task.give_home(Sched(home_handle));\n-                            this.resume_task_immediately(task);\n-                            return None;\n-                        }\n-                    }\n-                    AnySched if this.run_anything => {\n-                        this.event_loop.callback(Scheduler::run_sched_once);\n-                        task.give_home(AnySched);\n-                        this.resume_task_immediately(task);\n-                        return None;\n-                    }\n-                    AnySched => {\n-                        task.give_home(AnySched);\n-                        this.send_to_friend(task);\n-                        return Some(this);\n-                    }\n-                }\n+                rtdebug!(\"found some work! processing the task\");\n+                return this.process_task(task);\n             }\n             None => {\n+                rtdebug!(\"no work was found, returning the scheduler struct\");\n                 return Some(this);\n             }\n         }\n@@ -533,7 +597,7 @@ impl Scheduler {\n                 sched.enqueue_blocked_task(last_task);\n             }\n         };\n-        opt.map_consume(Local::put);\n+        opt.map_move(Local::put);\n     }\n \n     // The primary function for changing contexts. In the current\n@@ -711,7 +775,6 @@ impl Scheduler {\n             GiveTask(task, f) => f.to_fn()(self, task)\n         }\n     }\n-\n }\n \n // The cases for the below function.\n@@ -745,6 +808,8 @@ impl ClosureConverter for UnsafeTaskReceiver {\n \n #[cfg(test)]\n mod test {\n+    extern mod extra;\n+\n     use prelude::*;\n     use rt::test::*;\n     use unstable::run_in_bare_thread;\n@@ -833,7 +898,7 @@ mod test {\n             let mut sched = ~new_test_uv_sched();\n             let sched_handle = sched.make_handle();\n \n-            let mut task = ~do Task::new_root_homed(&mut sched.stack_pool,\n+            let mut task = ~do Task::new_root_homed(&mut sched.stack_pool, None,\n                                                 Sched(sched_handle)) {\n                 unsafe { *task_ran_ptr = true };\n                 assert!(Task::on_appropriate_sched());\n@@ -862,12 +927,15 @@ mod test {\n         do run_in_bare_thread {\n \n             let sleepers = SleeperList::new();\n-            let work_queue = WorkQueue::new();\n+            let normal_queue = WorkQueue::new();\n+            let special_queue = WorkQueue::new();\n+            let queues = ~[normal_queue.clone(), special_queue.clone()];\n \n             // Our normal scheduler\n             let mut normal_sched = ~Scheduler::new(\n                 ~UvEventLoop::new(),\n-                work_queue.clone(),\n+                normal_queue,\n+                queues.clone(),\n                 sleepers.clone());\n \n             let normal_handle = Cell::new(normal_sched.make_handle());\n@@ -877,7 +945,8 @@ mod test {\n             // Our special scheduler\n             let mut special_sched = ~Scheduler::new_special(\n                 ~UvEventLoop::new(),\n-                work_queue.clone(),\n+                special_queue.clone(),\n+                queues.clone(),\n                 sleepers.clone(),\n                 false,\n                 Some(friend_handle));\n@@ -893,21 +962,21 @@ mod test {\n             //   3) task not homed, sched requeues\n             //   4) task not home, send home\n \n-            let task1 = ~do Task::new_root_homed(&mut special_sched.stack_pool,\n+            let task1 = ~do Task::new_root_homed(&mut special_sched.stack_pool, None,\n                                                  Sched(t1_handle)) || {\n                 rtassert!(Task::on_appropriate_sched());\n             };\n             rtdebug!(\"task1 id: **%u**\", borrow::to_uint(task1));\n \n-            let task2 = ~do Task::new_root(&mut normal_sched.stack_pool) {\n+            let task2 = ~do Task::new_root(&mut normal_sched.stack_pool, None) {\n                 rtassert!(Task::on_appropriate_sched());\n             };\n \n-            let task3 = ~do Task::new_root(&mut normal_sched.stack_pool) {\n+            let task3 = ~do Task::new_root(&mut normal_sched.stack_pool, None) {\n                 rtassert!(Task::on_appropriate_sched());\n             };\n \n-            let task4 = ~do Task::new_root_homed(&mut special_sched.stack_pool,\n+            let task4 = ~do Task::new_root_homed(&mut special_sched.stack_pool, None,\n                                                  Sched(t4_handle)) {\n                 rtassert!(Task::on_appropriate_sched());\n             };\n@@ -923,7 +992,7 @@ mod test {\n             let port = Cell::new(port);\n             let chan = Cell::new(chan);\n \n-            let normal_task = ~do Task::new_root(&mut normal_sched.stack_pool) {\n+            let normal_task = ~do Task::new_root(&mut normal_sched.stack_pool, None) {\n                 rtdebug!(\"*about to submit task2*\");\n                 Scheduler::run_task(task2.take());\n                 rtdebug!(\"*about to submit task4*\");\n@@ -938,7 +1007,7 @@ mod test {\n \n             rtdebug!(\"normal task: %u\", borrow::to_uint(normal_task));\n \n-            let special_task = ~do Task::new_root(&mut special_sched.stack_pool) {\n+            let special_task = ~do Task::new_root(&mut special_sched.stack_pool, None) {\n                 rtdebug!(\"*about to submit task1*\");\n                 Scheduler::run_task(task1.take());\n                 rtdebug!(\"*about to submit task3*\");"}, {"sha": "0e8d26e9482bac99761e536d5a16da8c5867195c", "filename": "src/libstd/rt/select.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Frt%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Frt%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fselect.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -182,6 +182,7 @@ mod test {\n     fn select_stream() {\n         use util;\n         use comm::GenericChan;\n+        use iter::Times;\n \n         // Sends 10 buffered packets, and uses select to retrieve them all.\n         // Puts the port in a different spot in the vector each time.\n@@ -199,9 +200,7 @@ mod test {\n                 // get it back out\n                 util::swap(port.get_mut_ref(), &mut ports[index]);\n                 // NB. Not recv(), because optimistic_check randomly fails.\n-                let (data, new_port) = port.take_unwrap().recv_ready().unwrap();\n-                assert!(data == 31337);\n-                port = Some(new_port);\n+                assert!(port.get_ref().recv_ready().unwrap() == 31337);\n             }\n         }\n     }\n@@ -265,6 +264,7 @@ mod test {\n \n         fn select_racing_senders_helper(killable: bool, send_on_chans: ~[uint]) {\n             use rt::test::spawntask_random;\n+            use iter::Times;\n \n             do run_in_newsched_task {\n                 // A bit of stress, since ordinarily this is just smoke and mirrors."}, {"sha": "364439a452601e490e5f2580d629f21c6caeb40f", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 27, "deletions": 18, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -20,6 +20,7 @@ use libc::{c_void, uintptr_t};\n use ptr;\n use prelude::*;\n use option::{Option, Some, None};\n+use rt::env;\n use rt::kill::Death;\n use rt::local::Local;\n use rt::logging::StdErrLogger;\n@@ -85,38 +86,40 @@ impl Task {\n \n     // A helper to build a new task using the dynamically found\n     // scheduler and task. Only works in GreenTask context.\n-    pub fn build_homed_child(f: ~fn(), home: SchedHome) -> ~Task {\n+    pub fn build_homed_child(stack_size: Option<uint>, f: ~fn(), home: SchedHome) -> ~Task {\n         let f = Cell::new(f);\n         let home = Cell::new(home);\n         do Local::borrow::<Task, ~Task> |running_task| {\n             let mut sched = running_task.sched.take_unwrap();\n             let new_task = ~running_task.new_child_homed(&mut sched.stack_pool,\n+                                                         stack_size,\n                                                          home.take(),\n                                                          f.take());\n             running_task.sched = Some(sched);\n             new_task\n         }\n     }\n \n-    pub fn build_child(f: ~fn()) -> ~Task {\n-        Task::build_homed_child(f, AnySched)\n+    pub fn build_child(stack_size: Option<uint>, f: ~fn()) -> ~Task {\n+        Task::build_homed_child(stack_size, f, AnySched)\n     }\n \n-    pub fn build_homed_root(f: ~fn(), home: SchedHome) -> ~Task {\n+    pub fn build_homed_root(stack_size: Option<uint>, f: ~fn(), home: SchedHome) -> ~Task {\n         let f = Cell::new(f);\n         let home = Cell::new(home);\n         do Local::borrow::<Task, ~Task> |running_task| {\n             let mut sched = running_task.sched.take_unwrap();\n             let new_task = ~Task::new_root_homed(&mut sched.stack_pool,\n-                                                    home.take(),\n-                                                    f.take());\n+                                                 stack_size,\n+                                                 home.take(),\n+                                                 f.take());\n             running_task.sched = Some(sched);\n             new_task\n         }\n     }\n \n-    pub fn build_root(f: ~fn()) -> ~Task {\n-        Task::build_homed_root(f, AnySched)\n+    pub fn build_root(stack_size: Option<uint>, f: ~fn()) -> ~Task {\n+        Task::build_homed_root(stack_size, f, AnySched)\n     }\n \n     pub fn new_sched_task() -> Task {\n@@ -137,17 +140,20 @@ impl Task {\n     }\n \n     pub fn new_root(stack_pool: &mut StackPool,\n+                    stack_size: Option<uint>,\n                     start: ~fn()) -> Task {\n-        Task::new_root_homed(stack_pool, AnySched, start)\n+        Task::new_root_homed(stack_pool, stack_size, AnySched, start)\n     }\n \n     pub fn new_child(&mut self,\n                      stack_pool: &mut StackPool,\n+                     stack_size: Option<uint>,\n                      start: ~fn()) -> Task {\n-        self.new_child_homed(stack_pool, AnySched, start)\n+        self.new_child_homed(stack_pool, stack_size, AnySched, start)\n     }\n \n     pub fn new_root_homed(stack_pool: &mut StackPool,\n+                          stack_size: Option<uint>,\n                           home: SchedHome,\n                           start: ~fn()) -> Task {\n         Task {\n@@ -160,14 +166,15 @@ impl Task {\n             death: Death::new(),\n             destroyed: false,\n             name: None,\n-            coroutine: Some(Coroutine::new(stack_pool, start)),\n+            coroutine: Some(Coroutine::new(stack_pool, stack_size, start)),\n             sched: None,\n             task_type: GreenTask(Some(~home))\n         }\n     }\n \n     pub fn new_child_homed(&mut self,\n                            stack_pool: &mut StackPool,\n+                           stack_size: Option<uint>,\n                            home: SchedHome,\n                            start: ~fn()) -> Task {\n         Task {\n@@ -181,7 +188,7 @@ impl Task {\n             death: self.death.new_child(),\n             destroyed: false,\n             name: None,\n-            coroutine: Some(Coroutine::new(stack_pool, start)),\n+            coroutine: Some(Coroutine::new(stack_pool, stack_size, start)),\n             sched: None,\n             task_type: GreenTask(Some(~home))\n         }\n@@ -325,11 +332,13 @@ impl Drop for Task {\n \n impl Coroutine {\n \n-    pub fn new(stack_pool: &mut StackPool, start: ~fn()) -> Coroutine {\n-        static MIN_STACK_SIZE: uint = 3000000; // XXX: Too much stack\n-\n+    pub fn new(stack_pool: &mut StackPool, stack_size: Option<uint>, start: ~fn()) -> Coroutine {\n+        let stack_size = match stack_size {\n+            Some(size) => size,\n+            None => env::min_stack()\n+        };\n         let start = Coroutine::build_start_wrapper(start);\n-        let mut stack = stack_pool.take_segment(MIN_STACK_SIZE);\n+        let mut stack = stack_pool.take_segment(stack_size);\n         let initial_context = Context::new(start, &mut stack);\n         Coroutine {\n             current_stack_segment: stack,\n@@ -465,10 +474,10 @@ mod test {\n         do run_in_newsched_task() {\n             static key: local_data::Key<@~str> = &local_data::Key;\n             local_data::set(key, @~\"data\");\n-            assert!(*local_data::get(key, |k| k.map(|&k| *k)).unwrap() == ~\"data\");\n+            assert!(*local_data::get(key, |k| k.map_move(|k| *k)).unwrap() == ~\"data\");\n             static key2: local_data::Key<@~str> = &local_data::Key;\n             local_data::set(key2, @~\"data\");\n-            assert!(*local_data::get(key2, |k| k.map(|&k| *k)).unwrap() == ~\"data\");\n+            assert!(*local_data::get(key2, |k| k.map_move(|k| *k)).unwrap() == ~\"data\");\n         }\n     }\n "}, {"sha": "92366d5187fe23cae6bc7aa3126d2bda464af8e5", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -15,8 +15,8 @@ use cell::Cell;\n use clone::Clone;\n use container::Container;\n use iterator::{Iterator, range};\n-use vec::{OwnedVector, MutableVector};\n use super::io::net::ip::{SocketAddr, Ipv4Addr, Ipv6Addr};\n+use vec::{OwnedVector, MutableVector, ImmutableVector};\n use rt::sched::Scheduler;\n use unstable::run_in_bare_thread;\n use rt::thread::Thread;\n@@ -29,8 +29,12 @@ use result::{Result, Ok, Err};\n \n pub fn new_test_uv_sched() -> Scheduler {\n \n+    let queue = WorkQueue::new();\n+    let queues = ~[queue.clone()];\n+\n     let mut sched = Scheduler::new(~UvEventLoop::new(),\n-                                   WorkQueue::new(),\n+                                   queue,\n+                                   queues,\n                                    SleeperList::new());\n \n     // Don't wait for the Shutdown message\n@@ -57,7 +61,7 @@ pub fn run_in_newsched_task_core(f: ~fn()) {\n         exit_handle.take().send(Shutdown);\n         rtassert!(exit_status);\n     };\n-    let mut task = ~Task::new_root(&mut sched.stack_pool, f);\n+    let mut task = ~Task::new_root(&mut sched.stack_pool, None, f);\n     task.death.on_exit = Some(on_exit);\n \n     sched.bootstrap(task);\n@@ -164,15 +168,21 @@ pub fn run_in_mt_newsched_task(f: ~fn()) {\n         };\n \n         let sleepers = SleeperList::new();\n-        let work_queue = WorkQueue::new();\n \n         let mut handles = ~[];\n         let mut scheds = ~[];\n+        let mut work_queues = ~[];\n \n         for _ in range(0u, nthreads) {\n+            let work_queue = WorkQueue::new();\n+            work_queues.push(work_queue);\n+        }\n+\n+        for i in range(0u, nthreads) {\n             let loop_ = ~UvEventLoop::new();\n             let mut sched = ~Scheduler::new(loop_,\n-                                            work_queue.clone(),\n+                                            work_queues[i].clone(),\n+                                            work_queues.clone(),\n                                             sleepers.clone());\n             let handle = sched.make_handle();\n \n@@ -190,8 +200,7 @@ pub fn run_in_mt_newsched_task(f: ~fn()) {\n \n             rtassert!(exit_status);\n         };\n-        let mut main_task = ~Task::new_root(&mut scheds[0].stack_pool,\n-                                        f.take());\n+        let mut main_task = ~Task::new_root(&mut scheds[0].stack_pool, None, f.take());\n         main_task.death.on_exit = Some(on_exit);\n \n         let mut threads = ~[];\n@@ -209,7 +218,7 @@ pub fn run_in_mt_newsched_task(f: ~fn()) {\n \n         while !scheds.is_empty() {\n             let mut sched = scheds.pop();\n-            let bootstrap_task = ~do Task::new_root(&mut sched.stack_pool) || {\n+            let bootstrap_task = ~do Task::new_root(&mut sched.stack_pool, None) || {\n                 rtdebug!(\"bootstrapping non-primary scheduler\");\n             };\n             let bootstrap_task_cell = Cell::new(bootstrap_task);\n@@ -232,12 +241,12 @@ pub fn run_in_mt_newsched_task(f: ~fn()) {\n \n /// Test tasks will abort on failure instead of unwinding\n pub fn spawntask(f: ~fn()) {\n-    Scheduler::run_task(Task::build_child(f));\n+    Scheduler::run_task(Task::build_child(None, f));\n }\n \n /// Create a new task and run it right now. Aborts on failure\n pub fn spawntask_later(f: ~fn()) {\n-    Scheduler::run_task_later(Task::build_child(f));\n+    Scheduler::run_task_later(Task::build_child(None, f));\n }\n \n pub fn spawntask_random(f: ~fn()) {\n@@ -259,7 +268,7 @@ pub fn spawntask_try(f: ~fn()) -> Result<(),()> {\n     let chan = Cell::new(chan);\n     let on_exit: ~fn(bool) = |exit_status| chan.take().send(exit_status);\n \n-    let mut new_task = Task::build_root(f);\n+    let mut new_task = Task::build_root(None, f);\n     new_task.death.on_exit = Some(on_exit);\n \n     Scheduler::run_task(new_task);\n@@ -285,7 +294,7 @@ pub fn spawntask_thread(f: ~fn()) -> Thread {\n pub fn with_test_task(blk: ~fn(~Task) -> ~Task) {\n     do run_in_bare_thread {\n         let mut sched = ~new_test_uv_sched();\n-        let task = blk(~Task::new_root(&mut sched.stack_pool, ||{}));\n+        let task = blk(~Task::new_root(&mut sched.stack_pool, None, ||{}));\n         cleanup_task(task);\n     }\n }"}, {"sha": "83e0846c35118bd04e616bbdbf3675f40e1321f5", "filename": "src/libstd/run.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -634,7 +634,6 @@ fn spawn_process_os(prog: &str, args: &[~str],\n \n     use libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n     use libc::funcs::bsd44::getdtablesize;\n-    use int;\n \n     mod rustrt {\n         use libc::c_void;\n@@ -667,10 +666,9 @@ fn spawn_process_os(prog: &str, args: &[~str],\n             fail!(\"failure in dup3(err_fd, 2): %s\", os::last_os_error());\n         }\n         // close all other fds\n-        do int::range_rev(getdtablesize() as int, 3) |fd| {\n+        for fd in range(3, getdtablesize()).invert() {\n             close(fd as c_int);\n-            true\n-        };\n+        }\n \n         do with_dirp(dir) |dirp| {\n             if !dirp.is_null() && chdir(dirp) == -1 {\n@@ -780,14 +778,14 @@ fn with_dirp<T>(d: Option<&Path>, cb: &fn(*libc::c_char) -> T) -> T {\n }\n \n #[cfg(windows)]\n-priv fn free_handle(handle: *()) {\n+fn free_handle(handle: *()) {\n     unsafe {\n         libc::funcs::extra::kernel32::CloseHandle(cast::transmute(handle));\n     }\n }\n \n #[cfg(unix)]\n-priv fn free_handle(_handle: *()) {\n+fn free_handle(_handle: *()) {\n     // unix has no process handle object, just a pid\n }\n \n@@ -842,7 +840,7 @@ pub fn process_output(prog: &str, args: &[~str]) -> ProcessOutput {\n  * operate on a none-existant process or, even worse, on a newer process\n  * with the same id.\n  */\n-priv fn waitpid(pid: pid_t) -> int {\n+fn waitpid(pid: pid_t) -> int {\n     return waitpid_os(pid);\n \n     #[cfg(windows)]"}, {"sha": "480c0786e6e403a92b6803229673450bb3702c28", "filename": "src/libstd/std.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -178,6 +178,7 @@ pub mod rand;\n pub mod run;\n pub mod sys;\n pub mod cast;\n+pub mod fmt;\n pub mod repr;\n pub mod cleanup;\n pub mod reflect;\n@@ -217,4 +218,6 @@ mod std {\n     pub use unstable;\n     pub use str;\n     pub use os;\n+    pub use fmt;\n+    pub use to_bytes;\n }"}, {"sha": "724fbcac891bd3a7bb56024ea39e8d17accad0c0", "filename": "src/libstd/str.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -855,7 +855,7 @@ pub fn count_bytes<'b>(s: &'b str, start: uint, n: uint) -> uint {\n }\n \n // https://tools.ietf.org/html/rfc3629\n-priv static UTF8_CHAR_WIDTH: [u8, ..256] = [\n+static UTF8_CHAR_WIDTH: [u8, ..256] = [\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 0x1F\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n@@ -898,15 +898,15 @@ macro_rules! utf8_acc_cont_byte(\n )\n \n // UTF-8 tags and ranges\n-priv static TAG_CONT_U8: u8 = 128u8;\n-priv static TAG_CONT: uint = 128u;\n-priv static MAX_ONE_B: uint = 128u;\n-priv static TAG_TWO_B: uint = 192u;\n-priv static MAX_TWO_B: uint = 2048u;\n-priv static TAG_THREE_B: uint = 224u;\n-priv static MAX_THREE_B: uint = 65536u;\n-priv static TAG_FOUR_B: uint = 240u;\n-priv static MAX_UNICODE: uint = 1114112u;\n+static TAG_CONT_U8: u8 = 128u8;\n+static TAG_CONT: uint = 128u;\n+static MAX_ONE_B: uint = 128u;\n+static TAG_TWO_B: uint = 192u;\n+static MAX_TWO_B: uint = 2048u;\n+static TAG_THREE_B: uint = 224u;\n+static MAX_THREE_B: uint = 65536u;\n+static TAG_FOUR_B: uint = 240u;\n+static MAX_UNICODE: uint = 1114112u;\n \n /// Unsafe operations\n pub mod raw {\n@@ -2085,7 +2085,7 @@ impl<'self> StrSlice<'self> for &'self str {\n         } else {\n             self.matches_index_iter(needle)\n                 .next()\n-                .map_consume(|(start, _end)| start)\n+                .map_move(|(start, _end)| start)\n         }\n     }\n "}, {"sha": "02a6247428c86bfa60e2a280a92d4ebbd0b4b0f2", "filename": "src/libstd/str/ascii.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Fstr%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Fstr%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr%2Fascii.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -305,7 +305,7 @@ pub fn to_ascii_lower(string: &str) -> ~str {\n }\n \n #[inline]\n-priv fn map_bytes(string: &str, map: &'static [u8]) -> ~str {\n+fn map_bytes(string: &str, map: &'static [u8]) -> ~str {\n     let len = string.len();\n     let mut result = str::with_capacity(len);\n     unsafe {\n@@ -329,7 +329,7 @@ pub fn eq_ignore_ascii_case(a: &str, b: &str) -> bool {\n         |(byte_a, byte_b)| ASCII_LOWER_MAP[*byte_a] == ASCII_LOWER_MAP[*byte_b])\n }\n \n-priv static ASCII_LOWER_MAP: &'static [u8] = &[\n+static ASCII_LOWER_MAP: &'static [u8] = &[\n     0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n     0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n     0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n@@ -364,7 +364,7 @@ priv static ASCII_LOWER_MAP: &'static [u8] = &[\n     0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n ];\n \n-priv static ASCII_UPPER_MAP: &'static [u8] = &[\n+static ASCII_UPPER_MAP: &'static [u8] = &[\n     0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n     0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n     0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,"}, {"sha": "2e0c9c1d1ad1e01bf3b75f18e48ebee8c6820d1d", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -142,7 +142,8 @@ pub struct TaskOpts {\n     indestructible: bool,\n     notify_chan: Option<Chan<TaskResult>>,\n     name: Option<~str>,\n-    sched: SchedOpts\n+    sched: SchedOpts,\n+    stack_size: Option<uint>\n }\n \n /**\n@@ -197,7 +198,8 @@ impl TaskBuilder {\n                 indestructible: self.opts.indestructible,\n                 notify_chan: notify_chan,\n                 name: name,\n-                sched: self.opts.sched\n+                sched: self.opts.sched,\n+                stack_size: self.opts.stack_size\n             },\n             gen_body: gen_body,\n             can_not_copy: None,\n@@ -351,7 +353,8 @@ impl TaskBuilder {\n             indestructible: x.opts.indestructible,\n             notify_chan: notify_chan,\n             name: name,\n-            sched: x.opts.sched\n+            sched: x.opts.sched,\n+            stack_size: x.opts.stack_size\n         };\n         let f = match gen_body {\n             Some(gen) => {\n@@ -422,7 +425,8 @@ pub fn default_task_opts() -> TaskOpts {\n         name: None,\n         sched: SchedOpts {\n             mode: DefaultScheduler,\n-        }\n+        },\n+        stack_size: None\n     }\n }\n \n@@ -655,6 +659,7 @@ pub unsafe fn rekillable<U>(f: &fn() -> U) -> U {\n     }\n }\n \n+#[ignore(reason = \"linked failure\")]\n #[test] #[ignore(cfg(windows))]\n fn test_kill_unkillable_task() {\n     use rt::test::*;\n@@ -675,6 +680,7 @@ fn test_kill_unkillable_task() {\n     }\n }\n \n+#[ignore(reason = \"linked failure\")]\n #[test] #[ignore(cfg(windows))]\n fn test_kill_rekillable_task() {\n     use rt::test::*;\n@@ -716,6 +722,7 @@ fn test_cant_dup_task_builder() {\n #[cfg(test)]\n fn block_forever() { let (po, _ch) = stream::<()>(); po.recv(); }\n \n+#[ignore(reason = \"linked failure\")]\n #[test] #[ignore(cfg(windows))]\n fn test_spawn_unlinked_unsup_no_fail_down() { // grandchild sends on a port\n     use rt::test::run_in_newsched_task;\n@@ -734,13 +741,15 @@ fn test_spawn_unlinked_unsup_no_fail_down() { // grandchild sends on a port\n         po.recv();\n     }\n }\n+#[ignore(reason = \"linked failure\")]\n #[test] #[ignore(cfg(windows))]\n fn test_spawn_unlinked_unsup_no_fail_up() { // child unlinked fails\n     use rt::test::run_in_newsched_task;\n     do run_in_newsched_task {\n         do spawn_unlinked { fail!(); }\n     }\n }\n+#[ignore(reason = \"linked failure\")]\n #[test] #[ignore(cfg(windows))]\n fn test_spawn_unlinked_sup_no_fail_up() { // child unlinked fails\n     use rt::test::run_in_newsched_task;\n@@ -750,6 +759,7 @@ fn test_spawn_unlinked_sup_no_fail_up() { // child unlinked fails\n         do 16.times { task::yield(); }\n     }\n }\n+#[ignore(reason = \"linked failure\")]\n #[test] #[ignore(cfg(windows))]\n fn test_spawn_unlinked_sup_fail_down() {\n     use rt::test::run_in_newsched_task;\n@@ -762,6 +772,7 @@ fn test_spawn_unlinked_sup_fail_down() {\n     }\n }\n \n+#[ignore(reason = \"linked failure\")]\n #[test] #[ignore(cfg(windows))]\n fn test_spawn_linked_sup_fail_up() { // child fails; parent fails\n     use rt::test::run_in_newsched_task;\n@@ -782,6 +793,7 @@ fn test_spawn_linked_sup_fail_up() { // child fails; parent fails\n         assert!(result.is_err());\n     }\n }\n+#[ignore(reason = \"linked failure\")]\n #[test] #[ignore(cfg(windows))]\n fn test_spawn_linked_sup_fail_down() { // parent fails; child fails\n     use rt::test::run_in_newsched_task;\n@@ -798,6 +810,7 @@ fn test_spawn_linked_sup_fail_down() { // parent fails; child fails\n         assert!(result.is_err());\n     }\n }\n+#[ignore(reason = \"linked failure\")]\n #[test] #[ignore(cfg(windows))]\n fn test_spawn_linked_unsup_fail_up() { // child fails; parent fails\n     use rt::test::run_in_newsched_task;\n@@ -810,6 +823,7 @@ fn test_spawn_linked_unsup_fail_up() { // child fails; parent fails\n         assert!(result.is_err());\n     }\n }\n+#[ignore(reason = \"linked failure\")]\n #[test] #[ignore(cfg(windows))]\n fn test_spawn_linked_unsup_fail_down() { // parent fails; child fails\n     use rt::test::run_in_newsched_task;\n@@ -822,6 +836,7 @@ fn test_spawn_linked_unsup_fail_down() { // parent fails; child fails\n         assert!(result.is_err());\n     }\n }\n+#[ignore(reason = \"linked failure\")]\n #[test] #[ignore(cfg(windows))]\n fn test_spawn_linked_unsup_default_opts() { // parent fails; child fails\n     use rt::test::run_in_newsched_task;\n@@ -840,6 +855,7 @@ fn test_spawn_linked_unsup_default_opts() { // parent fails; child fails\n // A couple bonus linked failure tests - testing for failure propagation even\n // when the middle task exits successfully early before kill signals are sent.\n \n+#[ignore(reason = \"linked failure\")]\n #[test] #[ignore(cfg(windows))]\n fn test_spawn_failure_propagate_grandchild() {\n     use rt::test::run_in_newsched_task;\n@@ -856,6 +872,7 @@ fn test_spawn_failure_propagate_grandchild() {\n     }\n }\n \n+#[ignore(reason = \"linked failure\")]\n #[test] #[ignore(cfg(windows))]\n fn test_spawn_failure_propagate_secondborn() {\n     use rt::test::run_in_newsched_task;\n@@ -872,6 +889,7 @@ fn test_spawn_failure_propagate_secondborn() {\n     }\n }\n \n+#[ignore(reason = \"linked failure\")]\n #[test] #[ignore(cfg(windows))]\n fn test_spawn_failure_propagate_nephew_or_niece() {\n     use rt::test::run_in_newsched_task;\n@@ -888,6 +906,7 @@ fn test_spawn_failure_propagate_nephew_or_niece() {\n     }\n }\n \n+#[ignore(reason = \"linked failure\")]\n #[test] #[ignore(cfg(windows))]\n fn test_spawn_linked_sup_propagate_sibling() {\n     use rt::test::run_in_newsched_task;\n@@ -1191,6 +1210,7 @@ fn test_avoid_copying_the_body_unlinked() {\n     }\n }\n \n+#[ignore(reason = \"linked failure\")]\n #[test]\n #[ignore(cfg(windows))]\n #[should_fail]\n@@ -1226,6 +1246,7 @@ fn test_unkillable() {\n     po.recv();\n }\n \n+#[ignore(reason = \"linked failure\")]\n #[test]\n #[ignore(cfg(windows))]\n #[should_fail]\n@@ -1292,6 +1313,7 @@ fn test_simple_newsched_spawn() {\n     }\n }\n \n+#[ignore(reason = \"linked failure\")]\n #[test] #[ignore(cfg(windows))]\n fn test_spawn_watched() {\n     use rt::test::run_in_newsched_task;\n@@ -1314,6 +1336,7 @@ fn test_spawn_watched() {\n     }\n }\n \n+#[ignore(reason = \"linked failure\")]\n #[test] #[ignore(cfg(windows))]\n fn test_indestructible() {\n     use rt::test::run_in_newsched_task;"}, {"sha": "05a17f8539c216b93dce541651ceffa47b62cbb8", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -98,6 +98,7 @@ use rt::kill::KillHandle;\n use rt::sched::Scheduler;\n use rt::uv::uvio::UvEventLoop;\n use rt::thread::Thread;\n+use rt::work_queue::WorkQueue;\n \n #[cfg(test)] use task::default_task_opts;\n #[cfg(test)] use comm;\n@@ -500,7 +501,7 @@ impl RuntimeGlue {\n             OldTask(ptr) => rt::rust_task_kill_other(ptr),\n             NewTask(handle) => {\n                 let mut handle = handle;\n-                do handle.kill().map_consume |killed_task| {\n+                do handle.kill().map_move |killed_task| {\n                     let killed_task = Cell::new(killed_task);\n                     do Local::borrow::<Scheduler, ()> |sched| {\n                         sched.enqueue_task(killed_task.take());\n@@ -682,7 +683,7 @@ fn spawn_raw_newsched(mut opts: TaskOpts, f: ~fn()) {\n         // Child task runs this code.\n \n         // If child data is 'None', the enlist is vacuously successful.\n-        let enlist_success = do child_data.take().map_consume_default(true) |child_data| {\n+        let enlist_success = do child_data.take().map_move_default(true) |child_data| {\n             let child_data = Cell::new(child_data); // :(\n             do Local::borrow::<Task, bool> |me| {\n                 let (child_tg, ancestors, is_main) = child_data.take();\n@@ -713,19 +714,25 @@ fn spawn_raw_newsched(mut opts: TaskOpts, f: ~fn()) {\n     let mut task = unsafe {\n         if opts.sched.mode != SingleThreaded {\n             if opts.watched {\n-                Task::build_child(child_wrapper)\n+                Task::build_child(opts.stack_size, child_wrapper)\n             } else {\n-                Task::build_root(child_wrapper)\n+                Task::build_root(opts.stack_size, child_wrapper)\n             }\n         } else {\n             // Creating a 1:1 task:thread ...\n             let sched = Local::unsafe_borrow::<Scheduler>();\n             let sched_handle = (*sched).make_handle();\n \n+            // Since this is a 1:1 scheduler we create a queue not in\n+            // the stealee set. The run_anything flag is set false\n+            // which will disable stealing.\n+            let work_queue = WorkQueue::new();\n+\n             // Create a new scheduler to hold the new task\n             let new_loop = ~UvEventLoop::new();\n             let mut new_sched = ~Scheduler::new_special(new_loop,\n-                                                        (*sched).work_queue.clone(),\n+                                                        work_queue,\n+                                                        (*sched).work_queues.clone(),\n                                                         (*sched).sleeper_list.clone(),\n                                                         false,\n                                                         Some(sched_handle));\n@@ -736,16 +743,16 @@ fn spawn_raw_newsched(mut opts: TaskOpts, f: ~fn()) {\n \n             // Pin the new task to the new scheduler\n             let new_task = if opts.watched {\n-                Task::build_homed_child(child_wrapper, Sched(new_sched_handle))\n+                Task::build_homed_child(opts.stack_size, child_wrapper, Sched(new_sched_handle))\n             } else {\n-                Task::build_homed_root(child_wrapper, Sched(new_sched_handle))\n+                Task::build_homed_root(opts.stack_size, child_wrapper, Sched(new_sched_handle))\n             };\n \n             // Create a task that will later be used to join with the new scheduler\n             // thread when it is ready to terminate\n             let (thread_port, thread_chan) = oneshot();\n             let thread_port_cell = Cell::new(thread_port);\n-            let join_task = do Task::build_child() {\n+            let join_task = do Task::build_child(None) {\n                 rtdebug!(\"running join task\");\n                 let thread_port = thread_port_cell.take();\n                 let thread: Thread = thread_port.recv();\n@@ -762,8 +769,8 @@ fn spawn_raw_newsched(mut opts: TaskOpts, f: ~fn()) {\n                 let mut orig_sched_handle = orig_sched_handle_cell.take();\n                 let join_task = join_task_cell.take();\n \n-                let bootstrap_task = ~do Task::new_root(&mut new_sched.stack_pool) || {\n-                    rtdebug!(\"bootstrapping a 1:1 scheduler\");\n+                let bootstrap_task = ~do Task::new_root(&mut new_sched.stack_pool, None) || {\n+                    rtdebug!(\"boostrapping a 1:1 scheduler\");\n                 };\n                 new_sched.bootstrap(bootstrap_task);\n \n@@ -854,7 +861,7 @@ fn spawn_raw_oldsched(mut opts: TaskOpts, f: ~fn()) {\n             // Even if the below code fails to kick the child off, we must\n             // send Something on the notify channel.\n \n-            let notifier = notify_chan.map_consume(|c| AutoNotify(c));\n+            let notifier = notify_chan.map_move(|c| AutoNotify(c));\n \n             if enlist_many(OldTask(child), &child_arc, &mut ancestors) {\n                 let group = @@mut Taskgroup(child_arc, ancestors, is_main, notifier);"}, {"sha": "5ef5526e5162d4833c3aeff09056c9d94fdc80d4", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -271,8 +271,8 @@ impl<T> TrieNode<T> {\n \n impl<T> TrieNode<T> {\n     fn each<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n-        for idx in range(0u, self.children.len()) {\n-            match self.children[idx] {\n+        for elt in self.children.iter() {\n+            match *elt {\n                 Internal(ref x) => if !x.each(|i,t| f(i,t)) { return false },\n                 External(k, ref v) => if !f(&k, v) { return false },\n                 Nothing => ()\n@@ -282,13 +282,14 @@ impl<T> TrieNode<T> {\n     }\n \n     fn each_reverse<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n-        do uint::range_rev(self.children.len(), 0) |idx| {\n-            match self.children[idx] {\n-                Internal(ref x) => x.each_reverse(|i,t| f(i,t)),\n-                External(k, ref v) => f(&k, v),\n-                Nothing => true\n+        for elt in self.children.rev_iter() {\n+            match *elt {\n+                Internal(ref x) => if !x.each_reverse(|i,t| f(i,t)) { return false },\n+                External(k, ref v) => if !f(&k, v) { return false },\n+                Nothing => ()\n             }\n         }\n+        true\n     }\n \n     fn mutate_values<'a>(&'a mut self, f: &fn(&uint, &mut T) -> bool) -> bool {\n@@ -539,10 +540,9 @@ mod test_map {\n     fn test_each_break() {\n         let mut m = TrieMap::new();\n \n-        do uint::range_rev(uint::max_value, uint::max_value - 10000) |x| {\n+        for x in range(uint::max_value - 10000, uint::max_value).invert() {\n             m.insert(x, x / 2);\n-            true\n-        };\n+        }\n \n         let mut n = uint::max_value - 10000;\n         do m.each |k, v| {\n@@ -580,10 +580,9 @@ mod test_map {\n     fn test_each_reverse_break() {\n         let mut m = TrieMap::new();\n \n-        do uint::range_rev(uint::max_value, uint::max_value - 10000) |x| {\n+        for x in range(uint::max_value - 10000, uint::max_value).invert() {\n             m.insert(x, x / 2);\n-            true\n-        };\n+        }\n \n         let mut n = uint::max_value - 1;\n         do m.each_reverse |k, v| {\n@@ -634,10 +633,9 @@ mod test_map {\n         let last = uint::max_value;\n \n         let mut map = TrieMap::new();\n-        do uint::range_rev(last, first) |x| {\n+        for x in range(first, last).invert() {\n             map.insert(x, x / 2);\n-            true\n-        };\n+        }\n \n         let mut i = 0;\n         for (k, &v) in map.iter() {"}, {"sha": "c41712eb80a252aee96c48294841d042d5f4ba2a", "filename": "src/libstd/unstable/lang.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Flang.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -136,7 +136,7 @@ pub fn start(main: *u8, argc: int, argv: **c_char,\n     use os;\n \n     unsafe {\n-        let use_old_rt = os::getenv(\"RUST_NEWRT\").is_none();\n+        let use_old_rt = os::getenv(\"RUST_OLDRT\").is_some();\n         if use_old_rt {\n             return rust_start(main as *c_void, argc as c_int, argv,\n                               crate_map as *c_void) as int;"}, {"sha": "0f6d94bb77107786bfff531ad73645ea73d8f380", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -1602,8 +1602,8 @@ impl<T:Clone> OwnedCopyableVector<T> for ~[T] {\n         let new_len = self.len() + rhs.len();\n         self.reserve(new_len);\n \n-        for i in range(0u, rhs.len()) {\n-            self.push(unsafe { raw::get(rhs, i) })\n+        for elt in rhs.iter() {\n+            self.push((*elt).clone())\n         }\n     }\n "}, {"sha": "ba167fe67148ef5df984fbdf00e50495fb7f6f39", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -888,7 +888,7 @@ pub fn new_sctable_internal() -> SCTable {\n // fetch the SCTable from TLS, create one if it doesn't yet exist.\n pub fn get_sctable() -> @mut SCTable {\n     static sctable_key: local_data::Key<@@mut SCTable> = &local_data::Key;\n-    match local_data::get(sctable_key, |k| k.map(|&k| *k)) {\n+    match local_data::get(sctable_key, |k| k.map_move(|k| *k)) {\n         None => {\n             let new_table = @@mut new_sctable_internal();\n             local_data::set(sctable_key,new_table);"}, {"sha": "9edd41152f7f288ef090b2b94f555fabf4edf0b7", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -83,7 +83,7 @@ impl AttrMetaMethods for MetaItem {\n     }\n \n     pub fn name_str_pair(&self) -> Option<(@str, @str)> {\n-        self.value_str().map_consume(|s| (self.name(), s))\n+        self.value_str().map_move(|s| (self.name(), s))\n     }\n }\n "}, {"sha": "2b6cb91a5df1759771fb7e4567c270f8806a0535", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -192,7 +192,7 @@ fn print_maybe_styled(msg: &str, color: term::attr::Attr) {\n     let stderr = io::stderr();\n \n     if stderr.get_type() == io::Screen {\n-        let t = match local_data::get(tls_terminal, |v| v.map_consume(|&k|k)) {\n+        let t = match local_data::get(tls_terminal, |v| v.map_move(|k| *k)) {\n             None => {\n                 let t = term::Terminal::new(stderr);\n                 let tls = @match t {"}, {"sha": "dc20994b49facbb70d3d7ed0dd87d981c99985b4", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -139,6 +139,8 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n                                 ext::tt::macro_rules::add_new_extension));\n     syntax_expanders.insert(intern(&\"fmt\"),\n                             builtin_normal_tt(ext::fmt::expand_syntax_ext));\n+    syntax_expanders.insert(intern(&\"ifmt\"),\n+                            builtin_normal_tt(ext::ifmt::expand_syntax_ext));\n     syntax_expanders.insert(\n         intern(&\"auto_encode\"),\n         @SE(ItemDecorator(ext::auto_encode::expand_auto_encode)));\n@@ -479,7 +481,7 @@ impl <K: Eq + Hash + IterBytes + 'static, V: 'static> MapChain<K,V>{\n             ConsMapChain(ref map,_) => map\n         };\n         // strip one layer of indirection off the pointer.\n-        map.find(key).map(|r| {**r})\n+        map.find(key).map_move(|r| {*r})\n     }\n \n     // insert the binding into the top-level map"}, {"sha": "d81dca005b0a41dc99bdef621159eea0face4e9a", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -591,7 +591,7 @@ impl AstBuilder for @ExtCtxt {\n \n     fn expr_if(&self, span: span,\n                cond: @ast::expr, then: @ast::expr, els: Option<@ast::expr>) -> @ast::expr {\n-        let els = els.map(|x| self.expr_block(self.block_expr(*x)));\n+        let els = els.map_move(|x| self.expr_block(self.block_expr(x)));\n         self.expr(span, ast::expr_if(cond, self.block_expr(then), els))\n     }\n "}, {"sha": "a928680e093929f041c275f12dc8951e77801261", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -1014,7 +1014,9 @@ pub fn expand_crate(parse_sess: @mut parse::ParseSess,\n         .. *afp};\n     let f = make_fold(f_pre);\n \n-    @f.fold_crate(c)\n+    let ret = @f.fold_crate(c);\n+    parse_sess.span_diagnostic.handler().abort_if_errors();\n+    return ret;\n }\n \n // given a function from idents to idents, produce"}, {"sha": "5cf5fdba632f4ae11e0d6ca12634af43383e286c", "filename": "src/libsyntax/ext/ifmt.rs", "status": "added", "additions": 720, "deletions": 0, "changes": 720, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibsyntax%2Fext%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibsyntax%2Fext%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fifmt.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -0,0 +1,720 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ast;\n+use codemap::{span, respan};\n+use ext::base::*;\n+use ext::base;\n+use ext::build::AstBuilder;\n+use rsparse = parse;\n+use parse::token;\n+\n+use std::fmt::parse;\n+use std::hashmap::{HashMap, HashSet};\n+use std::vec;\n+\n+#[deriving(Eq)]\n+enum ArgumentType {\n+    Unknown,\n+    Known(@str),\n+    Unsigned,\n+    String,\n+}\n+\n+struct Context {\n+    ecx: @ExtCtxt,\n+    fmtsp: span,\n+\n+    // Parsed argument expressions and the types that we've found so far for\n+    // them.\n+    args: ~[@ast::expr],\n+    arg_types: ~[Option<ArgumentType>],\n+    // Parsed named expressions and the types that we've found for them so far\n+    names: HashMap<@str, @ast::expr>,\n+    name_types: HashMap<@str, ArgumentType>,\n+\n+    // Collection of the compiled `rt::Piece` structures\n+    pieces: ~[@ast::expr],\n+    name_positions: HashMap<@str, uint>,\n+    method_statics: ~[@ast::item],\n+\n+    // Updated as arguments are consumed or methods are entered\n+    nest_level: uint,\n+    next_arg: uint,\n+}\n+\n+impl Context {\n+    /// Parses the arguments from the given list of tokens, returning None if\n+    /// there's a parse error so we can continue parsing other fmt! expressions.\n+    fn parse_args(&mut self, sp: span,\n+                  tts: &[ast::token_tree]) -> Option<@ast::expr> {\n+        let p = rsparse::new_parser_from_tts(self.ecx.parse_sess(),\n+                                             self.ecx.cfg(),\n+                                             tts.to_owned());\n+        if *p.token == token::EOF {\n+            self.ecx.span_err(sp, \"ifmt! expects at least one argument\");\n+            return None;\n+        }\n+        let fmtstr = p.parse_expr();\n+        let mut named = false;\n+        while *p.token != token::EOF {\n+            if !p.eat(&token::COMMA) {\n+                self.ecx.span_err(sp, \"expected token: `,`\");\n+                return None;\n+            }\n+            if named || (token::is_ident(p.token) &&\n+                         p.look_ahead(1, |t| *t == token::EQ)) {\n+                named = true;\n+                let ident = match *p.token {\n+                    token::IDENT(i, _) => {\n+                        p.bump();\n+                        i\n+                    }\n+                    _ if named => {\n+                        self.ecx.span_err(*p.span,\n+                                          \"expected ident, positional arguments \\\n+                                           cannot follow named arguments\");\n+                        return None;\n+                    }\n+                    _ => {\n+                        self.ecx.span_err(*p.span,\n+                                          fmt!(\"expected ident for named \\\n+                                                argument, but found `%s`\",\n+                                               p.this_token_to_str()));\n+                        return None;\n+                    }\n+                };\n+                let name = self.ecx.str_of(ident);\n+                p.expect(&token::EQ);\n+                let e = p.parse_expr();\n+                match self.names.find(&name) {\n+                    None => {}\n+                    Some(prev) => {\n+                        self.ecx.span_err(e.span, fmt!(\"duplicate argument \\\n+                                                        named `%s`\", name));\n+                        self.ecx.parse_sess.span_diagnostic.span_note(\n+                            prev.span, \"previously here\");\n+                        loop\n+                    }\n+                }\n+                self.names.insert(name, e);\n+            } else {\n+                self.args.push(p.parse_expr());\n+                self.arg_types.push(None);\n+            }\n+        }\n+        return Some(fmtstr);\n+    }\n+\n+    /// Verifies one piece of a parse string. All errors are not emitted as\n+    /// fatal so we can continue giving errors about this and possibly other\n+    /// format strings.\n+    fn verify_piece(&mut self, p: &parse::Piece) {\n+        match *p {\n+            parse::String(*) => {}\n+            parse::CurrentArgument => {\n+                if self.nest_level == 0 {\n+                    self.ecx.span_err(self.fmtsp,\n+                                      \"`#` reference used with nothing to \\\n+                                       reference back to\");\n+                }\n+            }\n+            parse::Argument(ref arg) => {\n+                // argument first (it's first in the format string)\n+                let pos = match arg.position {\n+                    parse::ArgumentNext => {\n+                        let i = self.next_arg;\n+                        if self.check_positional_ok() {\n+                            self.next_arg += 1;\n+                        }\n+                        Left(i)\n+                    }\n+                    parse::ArgumentIs(i) => Left(i),\n+                    parse::ArgumentNamed(s) => Right(s.to_managed()),\n+                };\n+                let ty = if arg.format.ty == \"\" {\n+                    Unknown\n+                } else { Known(arg.format.ty.to_managed()) };\n+                self.verify_arg_type(pos, ty);\n+\n+                // width/precision next\n+                self.verify_count(arg.format.width);\n+                self.verify_count(arg.format.precision);\n+\n+                // and finally the method being applied\n+                match arg.method {\n+                    None => {}\n+                    Some(ref method) => { self.verify_method(pos, *method); }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn verify_pieces(&mut self, pieces: &[parse::Piece]) {\n+        for piece in pieces.iter() {\n+            self.verify_piece(piece);\n+        }\n+    }\n+\n+    fn verify_count(&mut self, c: parse::Count) {\n+        match c {\n+            parse::CountImplied | parse::CountIs(*) => {}\n+            parse::CountIsParam(i) => {\n+                self.verify_arg_type(Left(i), Unsigned);\n+            }\n+            parse::CountIsNextParam => {\n+                if self.check_positional_ok() {\n+                    self.verify_arg_type(Left(self.next_arg), Unsigned);\n+                    self.next_arg += 1;\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_positional_ok(&mut self) -> bool {\n+        if self.nest_level != 0 {\n+            self.ecx.span_err(self.fmtsp, \"cannot use implicit positional \\\n+                                           arguments nested inside methods\");\n+            false\n+        } else {\n+            true\n+        }\n+    }\n+\n+    fn verify_method(&mut self, pos: Either<uint, @str>, m: &parse::Method) {\n+        self.nest_level += 1;\n+        match *m {\n+            parse::Plural(_, ref arms, ref default) => {\n+                let mut seen_cases = HashSet::new();\n+                self.verify_arg_type(pos, Unsigned);\n+                for arm in arms.iter() {\n+                    if !seen_cases.insert(arm.selector) {\n+                        match arm.selector {\n+                            Left(name) => {\n+                                self.ecx.span_err(self.fmtsp,\n+                                                  fmt!(\"duplicate selector \\\n+                                                       `%?`\", name));\n+                            }\n+                            Right(idx) => {\n+                                self.ecx.span_err(self.fmtsp,\n+                                                  fmt!(\"duplicate selector \\\n+                                                       `=%u`\", idx));\n+                            }\n+                        }\n+                    }\n+                    self.verify_pieces(arm.result);\n+                }\n+                self.verify_pieces(*default);\n+            }\n+            parse::Select(ref arms, ref default) => {\n+                self.verify_arg_type(pos, String);\n+                let mut seen_cases = HashSet::new();\n+                for arm in arms.iter() {\n+                    if !seen_cases.insert(arm.selector) {\n+                        self.ecx.span_err(self.fmtsp,\n+                                          fmt!(\"duplicate selector `%s`\",\n+                                               arm.selector));\n+                    } else if arm.selector == \"\" {\n+                        self.ecx.span_err(self.fmtsp,\n+                                          \"empty selector in `select`\");\n+                    }\n+                    self.verify_pieces(arm.result);\n+                }\n+                self.verify_pieces(*default);\n+            }\n+        }\n+        self.nest_level -= 1;\n+    }\n+\n+    fn verify_arg_type(&mut self, arg: Either<uint, @str>, ty: ArgumentType) {\n+        match arg {\n+            Left(arg) => {\n+                if arg < 0 || self.args.len() <= arg {\n+                    let msg = fmt!(\"invalid reference to argument `%u` (there \\\n+                                    are %u arguments)\", arg, self.args.len());\n+                    self.ecx.span_err(self.fmtsp, msg);\n+                    return;\n+                }\n+                self.verify_same(self.args[arg].span, ty, self.arg_types[arg]);\n+                if ty != Unknown || self.arg_types[arg].is_none() {\n+                    self.arg_types[arg] = Some(ty);\n+                }\n+            }\n+\n+            Right(name) => {\n+                let span = match self.names.find(&name) {\n+                    Some(e) => e.span,\n+                    None => {\n+                        let msg = fmt!(\"There is no argument named `%s`\", name);\n+                        self.ecx.span_err(self.fmtsp, msg);\n+                        return;\n+                    }\n+                };\n+                self.verify_same(span, ty,\n+                                 self.name_types.find(&name).map(|&x| *x));\n+                if ty != Unknown || !self.name_types.contains_key(&name) {\n+                    self.name_types.insert(name, ty);\n+                }\n+                // Assign this named argument a slot in the arguments array if\n+                // it hasn't already been assigned a slot.\n+                if !self.name_positions.contains_key(&name) {\n+                    let slot = self.name_positions.len();\n+                    self.name_positions.insert(name, slot);\n+                }\n+            }\n+        }\n+    }\n+\n+    /// When we're keeping track of the types that are declared for certain\n+    /// arguments, we assume that `None` means we haven't seen this argument\n+    /// yet, `Some(None)` means that we've seen the argument, but no format was\n+    /// specified, and `Some(Some(x))` means that the argument was declared to\n+    /// have type `x`.\n+    ///\n+    /// Obviously `Some(Some(x)) != Some(Some(y))`, but we consider it true\n+    /// that: `Some(None) == Some(Some(x))`\n+    fn verify_same(&self, sp: span, ty: ArgumentType,\n+                   before: Option<ArgumentType>) {\n+        if ty == Unknown { return }\n+        let cur = match before {\n+            Some(Unknown) | None => return,\n+            Some(t) => t,\n+        };\n+        if ty == cur { return }\n+        match (cur, ty) {\n+            (Known(cur), Known(ty)) => {\n+                self.ecx.span_err(sp,\n+                                  fmt!(\"argument redeclared with type `%s` when \\\n+                                        it was previously `%s`\", ty, cur));\n+            }\n+            (Known(cur), _) => {\n+                self.ecx.span_err(sp,\n+                                  fmt!(\"argument used to format with `%s` was \\\n+                                        attempted to not be used for formatting\",\n+                                        cur));\n+            }\n+            (_, Known(ty)) => {\n+                self.ecx.span_err(sp,\n+                                  fmt!(\"argument previously used as a format \\\n+                                        argument attempted to be used as `%s`\",\n+                                        ty));\n+            }\n+            (_, _) => {\n+                self.ecx.span_err(sp, \"argument declared with multiple formats\");\n+            }\n+        }\n+    }\n+\n+    /// Translate a `parse::Piece` to a static `rt::Piece`\n+    fn trans_piece(&mut self, piece: &parse::Piece) -> @ast::expr {\n+        let sp = self.fmtsp;\n+        let rtpath = |s: &str| {\n+            ~[self.ecx.ident_of(\"std\"), self.ecx.ident_of(\"fmt\"),\n+              self.ecx.ident_of(\"rt\"), self.ecx.ident_of(s)]\n+        };\n+        let ctpath = |s: &str| {\n+            ~[self.ecx.ident_of(\"std\"), self.ecx.ident_of(\"fmt\"),\n+              self.ecx.ident_of(\"parse\"), self.ecx.ident_of(s)]\n+        };\n+        let none = || {\n+            let p = self.ecx.path(sp, ~[self.ecx.ident_of(\"None\")]);\n+            self.ecx.expr_path(p)\n+        };\n+        let some = |e: @ast::expr| {\n+            self.ecx.expr_call_ident(sp, self.ecx.ident_of(\"Some\"), ~[e])\n+        };\n+        let trans_count = |c: parse::Count| {\n+            match c {\n+                parse::CountIs(i) => {\n+                    self.ecx.expr_call_global(sp, ctpath(\"CountIs\"),\n+                                              ~[self.ecx.expr_uint(sp, i)])\n+                }\n+                parse::CountIsParam(i) => {\n+                    self.ecx.expr_call_global(sp, ctpath(\"CountIsParam\"),\n+                                              ~[self.ecx.expr_uint(sp, i)])\n+                }\n+                parse::CountImplied => {\n+                    let path = self.ecx.path_global(sp, ctpath(\"CountImplied\"));\n+                    self.ecx.expr_path(path)\n+                }\n+                parse::CountIsNextParam => {\n+                    let path = self.ecx.path_global(sp, ctpath(\"CountIsNextParam\"));\n+                    self.ecx.expr_path(path)\n+                }\n+            }\n+        };\n+        let trans_method = |method: &parse::Method| {\n+            let method = match *method {\n+                parse::Select(ref arms, ref default) => {\n+                    let arms = arms.iter().transform(|arm| {\n+                        let p = self.ecx.path_global(sp, rtpath(\"SelectArm\"));\n+                        let result = arm.result.iter().transform(|p| {\n+                            self.trans_piece(p)\n+                        }).collect();\n+                        let s = arm.selector.to_managed();\n+                        let selector = self.ecx.expr_str(sp, s);\n+                        self.ecx.expr_struct(sp, p, ~[\n+                            self.ecx.field_imm(sp,\n+                                               self.ecx.ident_of(\"selector\"),\n+                                               selector),\n+                            self.ecx.field_imm(sp, self.ecx.ident_of(\"result\"),\n+                                               self.ecx.expr_vec_slice(sp, result)),\n+                        ])\n+                    }).collect();\n+                    let default = default.iter().transform(|p| {\n+                        self.trans_piece(p)\n+                    }).collect();\n+                    self.ecx.expr_call_global(sp, rtpath(\"Select\"), ~[\n+                        self.ecx.expr_vec_slice(sp, arms),\n+                        self.ecx.expr_vec_slice(sp, default),\n+                    ])\n+                }\n+                parse::Plural(offset, ref arms, ref default) => {\n+                    let offset = match offset {\n+                        Some(i) => { some(self.ecx.expr_uint(sp, i)) }\n+                        None => { none() }\n+                    };\n+                    let arms = arms.iter().transform(|arm| {\n+                        let p = self.ecx.path_global(sp, rtpath(\"PluralArm\"));\n+                        let result = arm.result.iter().transform(|p| {\n+                            self.trans_piece(p)\n+                        }).collect();\n+                        let (lr, selarg) = match arm.selector {\n+                            Left(t) => {\n+                                let p = ctpath(fmt!(\"%?\", t));\n+                                let p = self.ecx.path_global(sp, p);\n+                                (self.ecx.ident_of(\"Left\"),\n+                                 self.ecx.expr_path(p))\n+                            }\n+                            Right(i) => {\n+                                (self.ecx.ident_of(\"Right\"),\n+                                 self.ecx.expr_uint(sp, i))\n+                            }\n+                        };\n+                        let selector = self.ecx.expr_call_ident(sp,\n+                                lr, ~[selarg]);\n+                        self.ecx.expr_struct(sp, p, ~[\n+                            self.ecx.field_imm(sp,\n+                                               self.ecx.ident_of(\"selector\"),\n+                                               selector),\n+                            self.ecx.field_imm(sp, self.ecx.ident_of(\"result\"),\n+                                               self.ecx.expr_vec_slice(sp, result)),\n+                        ])\n+                    }).collect();\n+                    let default = default.iter().transform(|p| {\n+                        self.trans_piece(p)\n+                    }).collect();\n+                    self.ecx.expr_call_global(sp, rtpath(\"Plural\"), ~[\n+                        offset,\n+                        self.ecx.expr_vec_slice(sp, arms),\n+                        self.ecx.expr_vec_slice(sp, default),\n+                    ])\n+                }\n+            };\n+            let life = self.ecx.lifetime(sp, self.ecx.ident_of(\"static\"));\n+            let ty = self.ecx.ty_path(self.ecx.path_all(\n+                sp,\n+                true,\n+                rtpath(\"Method\"),\n+                Some(life),\n+                ~[]\n+            ), None);\n+            let st = ast::item_static(ty, ast::m_imm, method);\n+            let static_name = self.ecx.ident_of(fmt!(\"__static_method_%u\",\n+                                                     self.method_statics.len()));\n+            let item = self.ecx.item(sp, static_name, ~[], st);\n+            self.method_statics.push(item);\n+            self.ecx.expr_ident(sp, static_name)\n+        };\n+\n+        match *piece {\n+            parse::String(s) => {\n+                self.ecx.expr_call_global(sp, rtpath(\"String\"),\n+                                          ~[self.ecx.expr_str(sp, s.to_managed())])\n+            }\n+            parse::CurrentArgument => {\n+                let nil = self.ecx.expr_lit(sp, ast::lit_nil);\n+                self.ecx.expr_call_global(sp, rtpath(\"CurrentArgument\"), ~[nil])\n+            }\n+            parse::Argument(ref arg) => {\n+                // Translate the position\n+                let pos = match arg.position {\n+                    // These two have a direct mapping\n+                    parse::ArgumentNext => {\n+                        let path = self.ecx.path_global(sp,\n+                                                        rtpath(\"ArgumentNext\"));\n+                        self.ecx.expr_path(path)\n+                    }\n+                    parse::ArgumentIs(i) => {\n+                        self.ecx.expr_call_global(sp, rtpath(\"ArgumentIs\"),\n+                                                  ~[self.ecx.expr_uint(sp, i)])\n+                    }\n+                    // Named arguments are converted to positional arguments at\n+                    // the end of the list of arguments\n+                    parse::ArgumentNamed(n) => {\n+                        let n = n.to_managed();\n+                        let i = match self.name_positions.find_copy(&n) {\n+                            Some(i) => i,\n+                            None => 0, // error already emitted elsewhere\n+                        };\n+                        let i = i + self.args.len();\n+                        self.ecx.expr_call_global(sp, rtpath(\"ArgumentIs\"),\n+                                                  ~[self.ecx.expr_uint(sp, i)])\n+                    }\n+                };\n+\n+                // Translate the format\n+                let fill = match arg.format.fill { Some(c) => c, None => ' ' };\n+                let fill = self.ecx.expr_lit(sp, ast::lit_int(fill as i64,\n+                                                              ast::ty_char));\n+                let align = match arg.format.align {\n+                    None | Some(parse::AlignLeft) => {\n+                        self.ecx.expr_bool(sp, true)\n+                    }\n+                    Some(parse::AlignRight) => {\n+                        self.ecx.expr_bool(sp, false)\n+                    }\n+                };\n+                let flags = self.ecx.expr_uint(sp, arg.format.flags);\n+                let prec = trans_count(arg.format.precision);\n+                let width = trans_count(arg.format.width);\n+                let path = self.ecx.path_global(sp, rtpath(\"FormatSpec\"));\n+                let fmt = self.ecx.expr_struct(sp, path, ~[\n+                    self.ecx.field_imm(sp, self.ecx.ident_of(\"fill\"), fill),\n+                    self.ecx.field_imm(sp, self.ecx.ident_of(\"alignleft\"), align),\n+                    self.ecx.field_imm(sp, self.ecx.ident_of(\"flags\"), flags),\n+                    self.ecx.field_imm(sp, self.ecx.ident_of(\"precision\"), prec),\n+                    self.ecx.field_imm(sp, self.ecx.ident_of(\"width\"), width),\n+                ]);\n+\n+                // Translate the method (if any)\n+                let method = match arg.method {\n+                    None => { none() }\n+                    Some(ref m) => {\n+                        let m = trans_method(*m);\n+                        some(self.ecx.expr_addr_of(sp, m))\n+                    }\n+                };\n+                let path = self.ecx.path_global(sp, rtpath(\"Argument\"));\n+                let s = self.ecx.expr_struct(sp, path, ~[\n+                    self.ecx.field_imm(sp, self.ecx.ident_of(\"position\"), pos),\n+                    self.ecx.field_imm(sp, self.ecx.ident_of(\"format\"), fmt),\n+                    self.ecx.field_imm(sp, self.ecx.ident_of(\"method\"), method),\n+                ]);\n+                self.ecx.expr_call_global(sp, rtpath(\"Argument\"), ~[s])\n+            }\n+        }\n+    }\n+\n+    /// Actually builds the expression which the ifmt! block will be expanded\n+    /// to\n+    fn to_expr(&self) -> @ast::expr {\n+        let mut lets = ~[];\n+        let mut locals = ~[];\n+        let mut names = vec::from_fn(self.name_positions.len(), |_| None);\n+\n+        // First, declare all of our methods that are statics\n+        for &method in self.method_statics.iter() {\n+            let decl = respan(self.fmtsp, ast::decl_item(method));\n+            lets.push(@respan(self.fmtsp,\n+                              ast::stmt_decl(@decl, self.ecx.next_id())));\n+        }\n+\n+        // Next, build up the static array which will become our precompiled\n+        // format \"string\"\n+        let fmt = self.ecx.expr_vec(self.fmtsp, self.pieces.clone());\n+        let ty = ast::ty_fixed_length_vec(\n+            self.ecx.ty_mt(\n+                self.ecx.ty_path(self.ecx.path_all(\n+                    self.fmtsp,\n+                    true, ~[\n+                        self.ecx.ident_of(\"std\"),\n+                        self.ecx.ident_of(\"fmt\"),\n+                        self.ecx.ident_of(\"rt\"),\n+                        self.ecx.ident_of(\"Piece\"),\n+                    ],\n+                    Some(self.ecx.lifetime(self.fmtsp, self.ecx.ident_of(\"static\"))),\n+                    ~[]\n+                ), None),\n+                ast::m_imm\n+            ),\n+            self.ecx.expr_uint(self.fmtsp, self.pieces.len())\n+        );\n+        let ty = self.ecx.ty(self.fmtsp, ty);\n+        let st = ast::item_static(ty, ast::m_imm, fmt);\n+        let static_name = self.ecx.ident_of(\"__static_fmtstr\");\n+        let item = self.ecx.item(self.fmtsp, static_name, ~[], st);\n+        let decl = respan(self.fmtsp, ast::decl_item(item));\n+        lets.push(@respan(self.fmtsp, ast::stmt_decl(@decl, self.ecx.next_id())));\n+\n+        // Right now there is a bug such that for the expression:\n+        //      foo(bar(&1))\n+        // the lifetime of `1` doesn't outlast the call to `bar`, so it's not\n+        // vald for the call to `foo`. To work around this all arguments to the\n+        // fmt! string are shoved into locals.\n+        for (i, &e) in self.args.iter().enumerate() {\n+            if self.arg_types[i].is_none() { loop } // error already generated\n+\n+            let name = self.ecx.ident_of(fmt!(\"__arg%u\", i));\n+            lets.push(self.ecx.stmt_let(e.span, false, name, e));\n+            locals.push(self.format_arg(e.span, Left(i), name));\n+        }\n+        for (&name, &e) in self.names.iter() {\n+            if !self.name_types.contains_key(&name) { loop }\n+\n+            let lname = self.ecx.ident_of(fmt!(\"__arg%s\", name));\n+            lets.push(self.ecx.stmt_let(e.span, false, lname, e));\n+            names[*self.name_positions.get(&name)] =\n+                Some(self.format_arg(e.span, Right(name), lname));\n+        }\n+\n+        let args = names.consume_iter().transform(|a| a.unwrap());\n+        let mut args = locals.consume_iter().chain_(args);\n+\n+        // Next, build up the actual call to the sprintf function.\n+        let result = self.ecx.expr_call_global(self.fmtsp, ~[\n+                self.ecx.ident_of(\"std\"),\n+                self.ecx.ident_of(\"fmt\"),\n+                self.ecx.ident_of(\"sprintf\"),\n+            ], ~[\n+                self.ecx.expr_ident(self.fmtsp, static_name),\n+                self.ecx.expr_vec(self.fmtsp, args.collect()),\n+            ]);\n+\n+        // sprintf is unsafe, but we just went through a lot of work to\n+        // validate that our call is save, so inject the unsafe block for the\n+        // user.\n+        let result = self.ecx.expr_block(ast::Block {\n+           view_items: ~[],\n+           stmts: ~[],\n+           expr: Some(result),\n+           id: self.ecx.next_id(),\n+           rules: ast::UnsafeBlock,\n+           span: self.fmtsp,\n+        });\n+\n+        self.ecx.expr_block(self.ecx.block(self.fmtsp, lets, Some(result)))\n+    }\n+\n+    fn format_arg(&self, sp: span, arg: Either<uint, @str>,\n+                  ident: ast::ident) -> @ast::expr {\n+        let mut ty = match arg {\n+            Left(i) => self.arg_types[i].unwrap(),\n+            Right(s) => *self.name_types.get(&s)\n+        };\n+        // Default types to '?' if nothing else is specified.\n+        if ty == Unknown {\n+            ty = Known(@\"?\");\n+        }\n+        let argptr = self.ecx.expr_addr_of(sp, self.ecx.expr_ident(sp, ident));\n+        match ty {\n+            Known(tyname) => {\n+                let fmt_trait = match tyname.as_slice() {\n+                    \"?\" => \"Poly\",\n+                    \"d\" | \"i\" => \"Signed\",\n+                    \"u\" => \"Unsigned\",\n+                    \"b\" => \"Bool\",\n+                    \"c\" => \"Char\",\n+                    \"o\" => \"Octal\",\n+                    \"x\" => \"LowerHex\",\n+                    \"X\" => \"UpperHex\",\n+                    \"s\" => \"String\",\n+                    \"p\" => \"Pointer\",\n+                    _ => {\n+                        self.ecx.span_err(sp, fmt!(\"unknown format trait \\\n+                                                    `%s`\", tyname));\n+                        \"Dummy\"\n+                    }\n+                };\n+                let format_fn = self.ecx.path_global(sp, ~[\n+                        self.ecx.ident_of(\"std\"),\n+                        self.ecx.ident_of(\"fmt\"),\n+                        self.ecx.ident_of(fmt_trait),\n+                        self.ecx.ident_of(\"fmt\"),\n+                    ]);\n+                self.ecx.expr_call_global(sp, ~[\n+                        self.ecx.ident_of(\"std\"),\n+                        self.ecx.ident_of(\"fmt\"),\n+                        self.ecx.ident_of(\"argument\"),\n+                    ], ~[self.ecx.expr_path(format_fn), argptr])\n+            }\n+            String => {\n+                self.ecx.expr_call_global(sp, ~[\n+                        self.ecx.ident_of(\"std\"),\n+                        self.ecx.ident_of(\"fmt\"),\n+                        self.ecx.ident_of(\"argumentstr\"),\n+                    ], ~[argptr])\n+            }\n+            Unsigned => {\n+                self.ecx.expr_call_global(sp, ~[\n+                        self.ecx.ident_of(\"std\"),\n+                        self.ecx.ident_of(\"fmt\"),\n+                        self.ecx.ident_of(\"argumentuint\"),\n+                    ], ~[argptr])\n+            }\n+            Unknown => { fail!() }\n+        }\n+    }\n+}\n+\n+pub fn expand_syntax_ext(ecx: @ExtCtxt, sp: span,\n+                         tts: &[ast::token_tree]) -> base::MacResult {\n+    let mut cx = Context {\n+        ecx: ecx,\n+        args: ~[],\n+        arg_types: ~[],\n+        names: HashMap::new(),\n+        name_positions: HashMap::new(),\n+        name_types: HashMap::new(),\n+        nest_level: 0,\n+        next_arg: 0,\n+        pieces: ~[],\n+        method_statics: ~[],\n+        fmtsp: sp,\n+    };\n+    let efmt = match cx.parse_args(sp, tts) {\n+        Some(e) => e,\n+        None => { return MRExpr(ecx.expr_uint(sp, 2)); }\n+    };\n+    cx.fmtsp = efmt.span;\n+    let fmt = expr_to_str(ecx, efmt,\n+                          ~\"first argument to ifmt! must be a string literal.\");\n+\n+    let mut err = false;\n+    do parse::parse_error::cond.trap(|m| {\n+        if !err {\n+            err = true;\n+            ecx.span_err(efmt.span, m);\n+        }\n+    }).inside {\n+        for piece in parse::Parser::new(fmt) {\n+            if !err {\n+                cx.verify_piece(&piece);\n+                let piece = cx.trans_piece(&piece);\n+                cx.pieces.push(piece);\n+            }\n+        }\n+    }\n+    if err { return MRExpr(efmt) }\n+\n+    // Make sure that all arguments were used and all arguments have types.\n+    for (i, ty) in cx.arg_types.iter().enumerate() {\n+        if ty.is_none() {\n+            ecx.span_err(cx.args[i].span, \"argument never used\");\n+        }\n+    }\n+    for (name, e) in cx.names.iter() {\n+        if !cx.name_types.contains_key(name) {\n+            ecx.span_err(e.span, \"named argument never used\");\n+        }\n+    }\n+\n+    MRExpr(cx.to_expr())\n+}"}, {"sha": "0a5bc00072034a052bd9a2d865d81aabfbb4f5a5", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -417,7 +417,7 @@ fn noop_fold_stmt(s: &stmt_, fld: @ast_fold) -> Option<stmt_> {\n fn noop_fold_arm(a: &arm, fld: @ast_fold) -> arm {\n     arm {\n         pats: a.pats.map(|x| fld.fold_pat(*x)),\n-        guard: a.guard.map(|x| fld.fold_expr(*x)),\n+        guard: a.guard.map_move(|x| fld.fold_expr(x)),\n         body: fld.fold_block(&a.body),\n     }\n }\n@@ -429,7 +429,7 @@ pub fn noop_fold_pat(p: &pat_, fld: @ast_fold) -> pat_ {\n             pat_ident(\n                 binding_mode,\n                 fld.fold_path(pth),\n-                sub.map(|x| fld.fold_pat(*x))\n+                sub.map_move(|x| fld.fold_pat(x))\n             )\n         }\n         pat_lit(e) => pat_lit(fld.fold_expr(e)),\n@@ -459,7 +459,7 @@ pub fn noop_fold_pat(p: &pat_, fld: @ast_fold) -> pat_ {\n         pat_vec(ref before, ref slice, ref after) => {\n             pat_vec(\n                 before.map(|x| fld.fold_pat(*x)),\n-                slice.map(|x| fld.fold_pat(*x)),\n+                slice.map_move(|x| fld.fold_pat(x)),\n                 after.map(|x| fld.fold_pat(*x))\n             )\n         }\n@@ -551,7 +551,7 @@ pub fn noop_fold_expr(e: &expr_, fld: @ast_fold) -> expr_ {\n             expr_if(\n                 fld.fold_expr(cond),\n                 fld.fold_block(tr),\n-                fl.map(|x| fld.fold_expr(*x))\n+                fl.map_move(|x| fld.fold_expr(x))\n             )\n         }\n         expr_while(cond, ref body) => {\n@@ -565,7 +565,7 @@ pub fn noop_fold_expr(e: &expr_, fld: @ast_fold) -> expr_ {\n         expr_loop(ref body, opt_ident) => {\n             expr_loop(\n                 fld.fold_block(body),\n-                opt_ident.map(|x| fld.fold_ident(*x))\n+                opt_ident.map_move(|x| fld.fold_ident(x))\n             )\n         }\n         expr_match(expr, ref arms) => {\n@@ -608,13 +608,13 @@ pub fn noop_fold_expr(e: &expr_, fld: @ast_fold) -> expr_ {\n         expr_path(ref pth) => expr_path(fld.fold_path(pth)),\n         expr_self => expr_self,\n         expr_break(ref opt_ident) => {\n-            expr_break(opt_ident.map(|x| fld.fold_ident(*x)))\n+            expr_break(opt_ident.map_move(|x| fld.fold_ident(x)))\n         }\n         expr_again(ref opt_ident) => {\n-            expr_again(opt_ident.map(|x| fld.fold_ident(*x)))\n+            expr_again(opt_ident.map_move(|x| fld.fold_ident(x)))\n         }\n         expr_ret(ref e) => {\n-            expr_ret(e.map(|x| fld.fold_expr(*x)))\n+            expr_ret(e.map_move(|x| fld.fold_expr(x)))\n         }\n         expr_log(lv, e) => {\n             expr_log(\n@@ -634,7 +634,7 @@ pub fn noop_fold_expr(e: &expr_, fld: @ast_fold) -> expr_ {\n             expr_struct(\n                 fld.fold_path(path),\n                 fields.map(|x| fold_field(*x)),\n-                maybe_expr.map(|x| fld.fold_expr(*x))\n+                maybe_expr.map_move(|x| fld.fold_expr(x))\n             )\n         },\n         expr_paren(ex) => expr_paren(fld.fold_expr(ex))\n@@ -731,7 +731,7 @@ fn noop_fold_variant(v: &variant_, fld: @ast_fold) -> variant_ {\n                 fold_variant_arg(/*bad*/ (*x).clone())\n             })\n         }\n-        struct_variant_kind(struct_def) => {\n+        struct_variant_kind(ref struct_def) => {\n             kind = struct_variant_kind(@ast::struct_def {\n                 fields: struct_def.fields.iter()\n                     .transform(|f| fld.fold_struct_field(*f)).collect(),\n@@ -776,7 +776,7 @@ fn noop_fold_local(l: @Local, fld: @ast_fold) -> @Local {\n         is_mutbl: l.is_mutbl,\n         ty: fld.fold_ty(&l.ty),\n         pat: fld.fold_pat(l.pat),\n-        init: l.init.map(|e| fld.fold_expr(*e)),\n+        init: l.init.map_move(|e| fld.fold_expr(e)),\n         id: fld.new_id(l.id),\n         span: fld.new_span(l.span),\n     }"}, {"sha": "dda5e990221eccf066d42a502637108f17bad179", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -64,6 +64,7 @@ pub enum ObsoleteSyntax {\n     ObsoleteMutWithMultipleBindings,\n     ObsoleteExternVisibility,\n     ObsoleteUnsafeExternFn,\n+    ObsoletePrivVisibility,\n }\n \n impl to_bytes::IterBytes for ObsoleteSyntax {\n@@ -253,6 +254,10 @@ impl ParserObsoleteMethods for Parser {\n                 \"external functions are always unsafe; remove the `unsafe` \\\n                  keyword\"\n             ),\n+            ObsoletePrivVisibility => (\n+                \"`priv` not necessary\",\n+                \"an item without a visibility qualifier is private by default\"\n+            ),\n         };\n \n         self.report(sp, kind, kind_str, desc);"}, {"sha": "7d6dce22fb7b423553d034f8f718c373860d68c8", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -85,7 +85,7 @@ use parse::obsolete::{ObsoleteConstItem, ObsoleteFixedLengthVectorType};\n use parse::obsolete::{ObsoleteNamedExternModule, ObsoleteMultipleLocalDecl};\n use parse::obsolete::{ObsoleteMutWithMultipleBindings};\n use parse::obsolete::{ObsoleteExternVisibility, ObsoleteUnsafeExternFn};\n-use parse::obsolete::{ParserObsoleteMethods};\n+use parse::obsolete::{ParserObsoleteMethods, ObsoletePrivVisibility};\n use parse::token::{can_begin_expr, get_ident_interner, ident_to_str, is_ident};\n use parse::token::{is_ident_or_path};\n use parse::token::{is_plain_ident, INTERPOLATED, keywords, special_idents};\n@@ -814,7 +814,7 @@ impl Parser {\n             let attrs = p.parse_outer_attributes();\n             let lo = p.span.lo;\n \n-            let vis = p.parse_visibility();\n+            let vis = p.parse_non_priv_visibility();\n             let pur = p.parse_fn_purity();\n             // NB: at the moment, trait methods are public by default; this\n             // could change.\n@@ -1313,7 +1313,7 @@ impl Parser {\n \n         // If the path might have bounds on it, they should be parsed before\n         // the parameters, e.g. module::TraitName:B1+B2<T>\n-        before_tps.map_consume(|callback| callback());\n+        before_tps.map_move(|callback| callback());\n \n         // Parse the (obsolete) trailing region parameter, if any, which will\n         // be written \"foo/&x\"\n@@ -3608,7 +3608,7 @@ impl Parser {\n         let attrs = self.parse_outer_attributes();\n         let lo = self.span.lo;\n \n-        let visa = self.parse_visibility();\n+        let visa = self.parse_non_priv_visibility();\n         let pur = self.parse_fn_purity();\n         let ident = self.parse_ident();\n         let generics = self.parse_generics();\n@@ -3871,6 +3871,18 @@ impl Parser {\n         else { inherited }\n     }\n \n+    // parse visibility, but emits an obsolete error if it's private\n+    fn parse_non_priv_visibility(&self) -> visibility {\n+        match self.parse_visibility() {\n+            public => public,\n+            inherited => inherited,\n+            private => {\n+                self.obsolete(*self.last_span, ObsoletePrivVisibility);\n+                inherited\n+            }\n+        }\n+    }\n+\n     fn parse_staticness(&self) -> bool {\n         if self.eat_keyword(keywords::Static) {\n             self.obsolete(*self.last_span, ObsoleteStaticMethod);\n@@ -4063,7 +4075,7 @@ impl Parser {\n     // parse a function declaration from a foreign module\n     fn parse_item_foreign_fn(&self,  attrs: ~[Attribute]) -> @foreign_item {\n         let lo = self.span.lo;\n-        let vis = self.parse_visibility();\n+        let vis = self.parse_non_priv_visibility();\n \n         // Parse obsolete purity.\n         let purity = self.parse_fn_purity();\n@@ -4443,7 +4455,7 @@ impl Parser {\n         maybe_whole!(iovi self, nt_item);\n         let lo = self.span.lo;\n \n-        let visibility = self.parse_visibility();\n+        let visibility = self.parse_non_priv_visibility();\n \n         // must be a view item:\n         if self.eat_keyword(keywords::Use) {\n@@ -4575,7 +4587,7 @@ impl Parser {\n         maybe_whole!(iovi self, nt_item);\n         let lo = self.span.lo;\n \n-        let visibility = self.parse_visibility();\n+        let visibility = self.parse_non_priv_visibility();\n \n         if (self.is_keyword(keywords::Const) || self.is_keyword(keywords::Static)) {\n             // FOREIGN CONST ITEM"}, {"sha": "fd491c1e890a0d8f140d56d06bd2a29e5ea34791", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -486,7 +486,7 @@ fn mk_fresh_ident_interner() -> @ident_interner {\n pub fn get_ident_interner() -> @ident_interner {\n     static key: local_data::Key<@@::parse::token::ident_interner> =\n         &local_data::Key;\n-    match local_data::get(key, |k| k.map(|&k| *k)) {\n+    match local_data::get(key, |k| k.map_move(|k| *k)) {\n         Some(interner) => *interner,\n         None => {\n             let interner = mk_fresh_ident_interner();"}, {"sha": "a5feb0483d894a24dbd75bcfa9b2a5c9818c6445", "filename": "src/libsyntax/syntax.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibsyntax%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Flibsyntax%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -73,6 +73,7 @@ pub mod ext {\n \n     pub mod cfg;\n     pub mod fmt;\n+    pub mod ifmt;\n     pub mod env;\n     pub mod bytes;\n     pub mod concat_idents;"}, {"sha": "5b8bebda9248eba37bfa25ec2f750990aaf2c4e5", "filename": "src/test/auxiliary/cci_class_5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fauxiliary%2Fcci_class_5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fauxiliary%2Fcci_class_5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_5.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -17,7 +17,7 @@ pub mod kitties {\n     }\n \n     impl cat {\n-        priv fn nap(&self) {}\n+        fn nap(&self) {}\n     }\n \n     pub fn cat(in_x : uint, in_y : int) -> cat {"}, {"sha": "a72bf307e5dd6fb22871b907795aa21f0126d82e", "filename": "src/test/auxiliary/xcrate_unit_struct.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fauxiliary%2Fxcrate_unit_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fauxiliary%2Fxcrate_unit_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fxcrate_unit_struct.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[crate_type = \"lib\"];\n+\n+// used by the rpass test\n+\n+pub struct Struct;\n+\n+pub enum Unit {\n+    Unit,\n+    Argument(Struct)\n+}\n+\n+// used by the cfail test\n+\n+pub struct StructWithFields {\n+    foo: int,\n+}\n+\n+pub enum EnumWithVariants {\n+    EnumVariant,\n+    EnumVariantArg(int)\n+}"}, {"sha": "6475012e0097e9e7180f7eb55fce18ed49fe012e", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -53,24 +53,21 @@ fn descending<M: MutableMap<uint, uint>>(map: &mut M, n_keys: uint) {\n     io::println(\" Descending integers:\");\n \n     do timed(\"insert\") {\n-        do uint::range_rev(n_keys, 0) |i| {\n+        for i in range(0, n_keys).invert() {\n             map.insert(i, i + 1);\n-            true\n-        };\n+        }\n     }\n \n     do timed(\"search\") {\n-        do uint::range_rev(n_keys, 0) |i| {\n+        for i in range(0, n_keys).invert() {\n             assert_eq!(map.find(&i).unwrap(), &(i + 1));\n-            true\n-        };\n+        }\n     }\n \n     do timed(\"remove\") {\n-        do uint::range_rev(n_keys, 0) |i| {\n+        for i in range(0, n_keys) {\n             assert!(map.remove(&i));\n-            true\n-        };\n+        }\n     }\n }\n "}, {"sha": "3d38d61bc2eb6b6337705efd6396f6c8b4f31cfc", "filename": "src/test/bench/rt-messaging-ping-pong.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -0,0 +1,82 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern mod extra;\n+\n+use std::task::spawn;\n+use std::os;\n+use std::uint;\n+use std::rt::test::spawntask_later;\n+use std::cell::Cell;\n+\n+// This is a simple bench that creates M pairs of of tasks. These\n+// tasks ping-pong back and forth over a pair of streams. This is a\n+// cannonical message-passing benchmark as it heavily strains message\n+// passing and almost nothing else.\n+\n+fn ping_pong_bench(n: uint, m: uint) {\n+\n+    // Create pairs of tasks that pingpong back and forth.\n+    fn run_pair(n: uint) {\n+            // Create a stream A->B\n+            let (pa,ca) = stream::<()>();\n+            // Create a stream B->A\n+            let (pb,cb) = stream::<()>();\n+\n+            let pa = Cell::new(pa);\n+            let ca = Cell::new(ca);\n+            let pb = Cell::new(pb);\n+            let cb = Cell::new(cb);\n+\n+        do spawntask_later() || {\n+            let chan = ca.take();\n+            let port = pb.take();\n+            do n.times {\n+                chan.send(());\n+                port.recv();\n+            }\n+        }\n+\n+        do spawntask_later() || {\n+            let chan = cb.take();\n+            let port = pa.take();\n+            do n.times {\n+                port.recv();\n+                chan.send(());\n+            }\n+        }\n+    }\n+\n+    do m.times {\n+        run_pair(n)\n+    }\n+\n+}\n+\n+\n+\n+fn main() {\n+\n+    let args = os::args();\n+    let n = if args.len() == 3 {\n+        uint::from_str(args[1]).unwrap()\n+    } else {\n+        10000\n+    };\n+\n+    let m = if args.len() == 3 {\n+        uint::from_str(args[2]).unwrap()\n+    } else {\n+        4\n+    };\n+\n+    ping_pong_bench(n, m);\n+\n+}"}, {"sha": "6669342f511a83944454c67cf5c942dcb9a4d970", "filename": "src/test/bench/rt-parfib.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fbench%2Frt-parfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fbench%2Frt-parfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-parfib.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern mod extra;\n+\n+use std::task::spawn;\n+use std::os;\n+use std::uint;\n+use std::rt::test::spawntask_later;\n+use std::cell::Cell;\n+use std::comm::*;\n+\n+// A simple implementation of parfib. One subtree is found in a new\n+// task and communicated over a oneshot pipe, the other is found\n+// locally. There is no sequential-mode threshold.\n+\n+fn parfib(n: uint) -> uint {\n+    if(n == 0 || n == 1) {\n+        return 1;\n+    }\n+\n+    let (port,chan) = oneshot::<uint>();\n+    let chan = Cell::new(chan);\n+    do spawntask_later {\n+        chan.take().send(parfib(n-1));\n+    };\n+    let m2 = parfib(n-2);\n+    return (port.recv() + m2);\n+}\n+\n+fn main() {\n+\n+    let args = os::args();\n+    let n = if args.len() == 2 {\n+        uint::from_str(args[1]).unwrap()\n+    } else {\n+        10\n+    };\n+\n+    parfib(n);\n+\n+}"}, {"sha": "ff578ed70b9c1c8c26d6c2da65a561176b1bb947", "filename": "src/test/bench/rt-spawn-rate.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fbench%2Frt-spawn-rate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fbench%2Frt-spawn-rate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-spawn-rate.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern mod extra;\n+\n+use std::task::spawn;\n+use std::os;\n+use std::uint;\n+\n+// Very simple spawn rate test. Spawn N tasks that do nothing and\n+// return.\n+\n+fn main() {\n+\n+    let args = os::args();\n+    let n = if args.len() == 2 {\n+        uint::from_str(args[1]).unwrap()\n+    } else {\n+        100000\n+    };\n+\n+    do n.times {\n+        do spawn || {};\n+    }\n+\n+}"}, {"sha": "48372c6d03b2fc3410b7ec34aaac3237d1883ece", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -1,3 +1,5 @@\n+// xfail-test reading from os::args()[1] - bogus!\n+\n use std::from_str::FromStr;\n use std::os;\n use std::vec::MutableVector;"}, {"sha": "1f1ce86404b69347896cee3050b49d0be120a2e2", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -1,3 +1,5 @@\n+// xfail-test reading from os::args()[1] - bogus!\n+\n use std::cast::transmute;\n use std::from_str::FromStr;\n use std::libc::{FILE, STDOUT_FILENO, c_int, fdopen, fputc, fputs, fwrite, size_t};"}, {"sha": "72007d2b50a98029c4260233407733ebbe4bee7a", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -1,3 +1,5 @@\n+// xfail-test reading from os::args()[1] - bogus!\n+\n use std::cast::transmute;\n use std::from_str::FromStr;\n use std::libc::{STDOUT_FILENO, c_int, fdopen, fputc};"}, {"sha": "0f43d5027a9133e6a331146ece4cafb105d6874b", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -1,3 +1,5 @@\n+// xfail-test reading from os::args()[1] - bogus!\n+\n use std::from_str::FromStr;\n use std::os;\n "}, {"sha": "d7f5e5781e0ebc6659000b389d15c79bc2d27c59", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-test reading from os::args()[1] - bogus!\n+\n use std::from_str::FromStr;\n use std::os;\n use std::vec;"}, {"sha": "7788005775f7897e20fbede324d5fb0318432326", "filename": "src/test/bench/task-perf-linked-failure.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -34,7 +34,10 @@ fn grandchild_group(num_tasks: uint) {\n \n     for _ in range(0, num_tasks) {\n         let ch = ch.clone();\n-        do task::spawn { // linked\n+        let mut t = task::task();\n+        t.linked();\n+        t.unwatched();\n+        do t.spawn { // linked\n             ch.send(());\n             let (p, _c) = stream::<()>();\n             p.recv(); // block forever"}, {"sha": "875ad0d2b62a5e8c31ce75a0e55acfa296e35199", "filename": "src/test/compile-fail/ifmt-bad-arg.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    // bad arguments to the ifmt! call\n+\n+    ifmt!();                //~ ERROR: expects at least one\n+    ifmt!(\"{}\");            //~ ERROR: invalid reference to argument\n+\n+    ifmt!(\"{1}\", 1);        //~ ERROR: invalid reference to argument `1`\n+                            //~^ ERROR: argument never used\n+    ifmt!(\"{foo}\");         //~ ERROR: no argument named `foo`\n+\n+    ifmt!(\"{}\", 1, 2);               //~ ERROR: argument never used\n+    ifmt!(\"{1}\", 1, 2);              //~ ERROR: argument never used\n+    ifmt!(\"{}\", 1, foo=2);           //~ ERROR: named argument never used\n+    ifmt!(\"{foo}\", 1, foo=2);        //~ ERROR: argument never used\n+    ifmt!(\"\", foo=2);                //~ ERROR: named argument never used\n+\n+    ifmt!(\"{0:d} {0:s}\", 1);         //~ ERROR: redeclared with type `s`\n+    ifmt!(\"{foo:d} {foo:s}\", foo=1); //~ ERROR: redeclared with type `s`\n+\n+    ifmt!(\"{foo}\", foo=1, foo=2);    //~ ERROR: duplicate argument\n+    ifmt!(\"#\");                      //~ ERROR: `#` reference used\n+    ifmt!(\"\", foo=1, 2);             //~ ERROR: positional arguments cannot follow\n+    ifmt!(\"\" 1);                     //~ ERROR: expected token: `,`\n+    ifmt!(\"\", 1 1);                  //~ ERROR: expected token: `,`\n+\n+    ifmt!(\"{0, select, a{} a{} other{}}\", \"a\");    //~ ERROR: duplicate selector\n+    ifmt!(\"{0, plural, =1{} =1{} other{}}\", 1u);   //~ ERROR: duplicate selector\n+    ifmt!(\"{0, plural, one{} one{} other{}}\", 1u); //~ ERROR: duplicate selector\n+\n+    // bad syntax of the format string\n+\n+    ifmt!(\"{\"); //~ ERROR: unterminated format string\n+    ifmt!(\"\\\\ \"); //~ ERROR: invalid escape\n+    ifmt!(\"\\\\\"); //~ ERROR: expected an escape\n+\n+    ifmt!(\"{0, }\", 1); //~ ERROR: expected method\n+    ifmt!(\"{0, foo}\", 1); //~ ERROR: unknown method\n+    ifmt!(\"{0, select}\", \"a\"); //~ ERROR: must be followed by\n+    ifmt!(\"{0, plural}\", 1); //~ ERROR: must be followed by\n+\n+    ifmt!(\"{0, select, a{{}\", 1); //~ ERROR: must be terminated\n+    ifmt!(\"{0, select, {} other{}}\", \"a\"); //~ ERROR: empty selector\n+    ifmt!(\"{0, select, other{} other{}}\", \"a\"); //~ ERROR: multiple `other`\n+    ifmt!(\"{0, plural, offset: other{}}\", \"a\"); //~ ERROR: must be an integer\n+    ifmt!(\"{0, plural, offset 1 other{}}\", \"a\"); //~ ERROR: be followed by `:`\n+    ifmt!(\"{0, plural, =a{} other{}}\", \"a\"); //~ ERROR: followed by an integer\n+    ifmt!(\"{0, plural, a{} other{}}\", \"a\"); //~ ERROR: unexpected plural\n+    ifmt!(\"{0, select, a{}}\", \"a\"); //~ ERROR: must provide an `other`\n+    ifmt!(\"{0, plural, =1{}}\", \"a\"); //~ ERROR: must provide an `other`\n+\n+    ifmt!(\"{0, plural, other{{0:s}}}\", \"a\"); //~ ERROR: previously used as\n+    ifmt!(\"{:s} {0, plural, other{}}\", \"a\"); //~ ERROR: argument used to\n+    ifmt!(\"{0, select, other{}} \\\n+           {0, plural, other{}}\", \"a\");\n+    //~^ ERROR: declared with multiple formats\n+\n+    // It should be illegal to use implicit placement arguments nested inside of\n+    // format strings because otherwise the \"internal pointer of which argument\n+    // is next\" would be invalidated if different cases had different numbers of\n+    // arguments.\n+    ifmt!(\"{0, select, other{{}}}\", \"a\"); //~ ERROR: cannot use implicit\n+    ifmt!(\"{0, plural, other{{}}}\", 1); //~ ERROR: cannot use implicit\n+    ifmt!(\"{0, plural, other{{1:.*d}}}\", 1, 2); //~ ERROR: cannot use implicit\n+}"}, {"sha": "76a697b174f5447b59cc00329e56e89729719553", "filename": "src/test/compile-fail/ifmt-bad-plural.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fcompile-fail%2Fifmt-bad-plural.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fcompile-fail%2Fifmt-bad-plural.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-bad-plural.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    ifmt!(\"{0, plural, other{}}\", \"a\");\n+    //~^ ERROR: expected uint but found\n+}"}, {"sha": "abe3b6ed65a6d577467d840fea14377df6610772", "filename": "src/test/compile-fail/ifmt-bad-select.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fcompile-fail%2Fifmt-bad-select.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fcompile-fail%2Fifmt-bad-select.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-bad-select.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    ifmt!(\"{0, select, other{}}\", 2);\n+    //~^ ERROR: expected &str but found integral\n+}"}, {"sha": "427f5ea562c7eb6c6c3389acaf3090e4dc2189e6", "filename": "src/test/compile-fail/ifmt-unimpl.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fcompile-fail%2Fifmt-unimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fcompile-fail%2Fifmt-unimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-unimpl.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    ifmt!(\"{:d}\", \"3\");\n+    //~^ ERROR: failed to find an implementation of trait std::fmt::Signed\n+}"}, {"sha": "85556f9501acb436715f0f19676ca96a3ba33006", "filename": "src/test/compile-fail/ifmt-unknown-trait.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fcompile-fail%2Fifmt-unknown-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fcompile-fail%2Fifmt-unknown-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-unknown-trait.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    ifmt!(\"{:notimplemented}\", \"3\");\n+    //~^ ERROR: unknown format trait `notimplemented`\n+}"}, {"sha": "7097615b87e74ff963b59ac0b1837b31ce21ca7d", "filename": "src/test/compile-fail/issue-3763.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fcompile-fail%2Fissue-3763.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fcompile-fail%2Fissue-3763.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3763.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -16,7 +16,7 @@ mod my_mod {\n         MyStruct {priv_field: 4}\n     }\n     impl MyStruct {\n-        priv fn happyfun(&self) {}\n+        fn happyfun(&self) {}\n     }\n }\n "}, {"sha": "cab999f621de8f37b7637f61261f3784c4b2238f", "filename": "src/test/compile-fail/issue-3993-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fcompile-fail%2Fissue-3993-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fcompile-fail%2Fissue-3993-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3993-3.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -12,8 +12,8 @@ use zoo::fly; //~ ERROR failed to resolve import\n               //~^ ERROR unresolved import: found `fly` in `zoo` but it is private\n \n mod zoo {\n-    priv type fly = ();\n-    priv fn fly() {}\n+    type fly = ();\n+    fn fly() {}\n }\n \n "}, {"sha": "53a56ad2774235357000e824e86daf9f2e656979", "filename": "src/test/compile-fail/issue-3993.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fcompile-fail%2Fissue-3993.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fcompile-fail%2Fissue-3993.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3993.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -12,7 +12,7 @@ use zoo::fly; //~ ERROR failed to resolve import\n               //~^ ERROR unresolved import: found `fly` in `zoo` but it is private\n \n mod zoo {\n-    priv fn fly() {}\n+    fn fly() {}\n }\n \n "}, {"sha": "42da53e989036447b687fb645d0d0024aa14e296", "filename": "src/test/compile-fail/private-impl-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fcompile-fail%2Fprivate-impl-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fcompile-fail%2Fprivate-impl-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-impl-method.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -14,7 +14,7 @@ mod a {\n     }\n \n     impl Foo {\n-        priv fn foo(&self) {}\n+        fn foo(&self) {}\n     }\n }\n "}, {"sha": "a31d0030f67e7be7066e6c640554070ad2a85a88", "filename": "src/test/compile-fail/private-item-simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fcompile-fail%2Fprivate-item-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fcompile-fail%2Fprivate-item-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-item-simple.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n mod a {\n-    priv fn f() {}\n+    fn f() {}\n }\n \n fn main() {"}, {"sha": "858227655955c614005dd4e23a08c5a84c571348", "filename": "src/test/compile-fail/private-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fcompile-fail%2Fprivate-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fcompile-fail%2Fprivate-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-method.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -18,7 +18,7 @@ mod kitties {\n     }\n \n     impl cat {\n-        priv fn nap(&self) {}\n+        fn nap(&self) {}\n     }\n \n     pub fn cat(in_x : uint, in_y : int) -> cat {"}, {"sha": "e71a0f05dffc5c24336de3ae80e5b2b5b536cd0a", "filename": "src/test/compile-fail/xcrate-unit-struct.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fcompile-fail%2Fxcrate-unit-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fcompile-fail%2Fxcrate-unit-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fxcrate-unit-struct.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:xcrate_unit_struct.rs\n+\n+// Make sure that when we have cross-crate unit structs we don't accidentally\n+// make values out of cross-crate structs that aren't unit.\n+\n+extern mod xcrate_unit_struct;\n+\n+fn main() {\n+    let _ = xcrate_unit_struct::StructWithFields; //~ ERROR: unresolved name\n+    let _ = xcrate_unit_struct::Struct;\n+}"}, {"sha": "3bf3507faba779d02ca9d63b3db56832d7846158", "filename": "src/test/debug-info/option-like-enum.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fdebug-info%2Foption-like-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Fdebug-info%2Foption-like-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Foption-like-enum.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+// xfail-test broken in newrt?\n \n // compile-flags:-Z extra-debug-info\n // debugger:break zzz"}, {"sha": "2841756d4a0e10e1d852b1e651e62f7903f954ac", "filename": "src/test/run-fail/assert-eq-macro-fail", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Frun-fail%2Fassert-eq-macro-fail", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Frun-fail%2Fassert-eq-macro-fail", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fassert-eq-macro-fail?ref=56730c094cf95be58fb05b0e423673aca2a98b88"}, {"sha": "a65db3ee51543db658e8db9dc155658e0a491f1c", "filename": "src/test/run-fail/extern-fail.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Frun-fail%2Fextern-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Frun-fail%2Fextern-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fextern-fail.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-test linked failure\n // error-pattern:explicit failure\n // Testing that runtime failure doesn't cause callbacks to abort abnormally.\n // Instead the failure will be delivered after the callbacks return."}, {"sha": "52dfb8aef13d56b484623c22b4250146ed8452c3", "filename": "src/test/run-fail/linked-failure.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Frun-fail%2Flinked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Frun-fail%2Flinked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -10,6 +10,7 @@\n // except according to those terms.\n \n \n+// xfail-test linked failure\n // error-pattern:1 == 2\n extern mod extra;\n "}, {"sha": "d4049f6753ee89204fd75c57be84b2dc9eac15c5", "filename": "src/test/run-fail/linked-failure2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Frun-fail%2Flinked-failure2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Frun-fail%2Flinked-failure2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure2.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -10,6 +10,7 @@\n // except according to those terms.\n \n \n+// xfail-test linked failure\n // error-pattern:fail\n \n use std::comm;"}, {"sha": "f40eae20bc0bc386b6e7276e009e22345914c2f0", "filename": "src/test/run-fail/linked-failure3.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Frun-fail%2Flinked-failure3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Frun-fail%2Flinked-failure3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure3.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -10,6 +10,7 @@\n // except according to those terms.\n \n \n+// xfail-test linked failure\n // error-pattern:fail\n \n use std::comm;"}, {"sha": "94e41f1ae682565703aeb17bf725573209866b76", "filename": "src/test/run-fail/linked-failure4.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Frun-fail%2Flinked-failure4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Frun-fail%2Flinked-failure4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure4.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -9,6 +9,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-test linked failure\n // error-pattern:1 == 2\n \n use std::comm;"}, {"sha": "12dab8e25b780755829b5d325667241f69600f0b", "filename": "src/test/run-fail/spawnfail.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Frun-fail%2Fspawnfail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Frun-fail%2Fspawnfail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fspawnfail.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-test linked failure\n // xfail-win32\n // error-pattern:explicit\n extern mod extra;"}, {"sha": "bd51ce38ec0e47bc03d38444eebc5d5437d1ec6a", "filename": "src/test/run-fail/task-comm-recv-block.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Frun-fail%2Ftask-comm-recv-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Frun-fail%2Ftask-comm-recv-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ftask-comm-recv-block.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-test linked failure\n // error-pattern:goodfail\n \n use std::comm;"}, {"sha": "a134ffe49fd02f4f1ee2e75808ae0a8c2fbff2c5", "filename": "src/test/run-pass/class-cast-to-trait-multiple-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -21,7 +21,7 @@ struct dog {\n }\n \n impl dog {\n-    priv fn bark(&self) -> int {\n+    fn bark(&self) -> int {\n       info!(\"Woof %u %d\", *self.barks, *self.volume);\n       *self.barks += 1u;\n       if *self.barks % 3u == 0u {"}, {"sha": "562642453fd27b48dbd20a4bb6b354aaa8516af5", "filename": "src/test/run-pass/ifmt.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -0,0 +1,71 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt;\n+\n+struct A;\n+struct B;\n+\n+#[fmt=\"foo\"]\n+impl fmt::Signed for A {\n+    fn fmt(_: &A, f: &mut fmt::Formatter) { f.buf.write(\"aloha\".as_bytes()); }\n+}\n+impl fmt::Signed for B {\n+    fn fmt(_: &B, f: &mut fmt::Formatter) { f.buf.write(\"adios\".as_bytes()); }\n+}\n+\n+pub fn main() {\n+    fn t(a: ~str, b: &str) { assert_eq!(a, b.to_owned()); }\n+\n+    // Make sure there's a poly formatter that takes anything\n+    t(ifmt!(\"{}\", 1), \"1\");\n+    t(ifmt!(\"{}\", A), \"{}\");\n+    t(ifmt!(\"{}\", ()), \"()\");\n+    t(ifmt!(\"{}\", @(~1, \"foo\")), \"@(~1, \\\"foo\\\")\");\n+\n+    // Various edge cases without formats\n+    t(ifmt!(\"\"), \"\");\n+    t(ifmt!(\"hello\"), \"hello\");\n+    t(ifmt!(\"hello \\\\{\"), \"hello {\");\n+\n+    // At least exercise all the formats\n+    t(ifmt!(\"{:b}\", true), \"true\");\n+    t(ifmt!(\"{:c}\", '\u2603'), \"\u2603\");\n+    t(ifmt!(\"{:d}\", 10), \"10\");\n+    t(ifmt!(\"{:i}\", 10), \"10\");\n+    t(ifmt!(\"{:u}\", 10u), \"10\");\n+    t(ifmt!(\"{:o}\", 10u), \"12\");\n+    t(ifmt!(\"{:x}\", 10u), \"a\");\n+    t(ifmt!(\"{:X}\", 10u), \"A\");\n+    t(ifmt!(\"{:s}\", \"foo\"), \"foo\");\n+    t(ifmt!(\"{:p}\", 0x1234 as *int), \"0x1234\");\n+    t(ifmt!(\"{:p}\", 0x1234 as *mut int), \"0x1234\");\n+    t(ifmt!(\"{:d}\", A), \"aloha\");\n+    t(ifmt!(\"{:d}\", B), \"adios\");\n+    t(ifmt!(\"foo {:s} \u2603\u2603\u2603\u2603\u2603\u2603\", \"bar\"), \"foo bar \u2603\u2603\u2603\u2603\u2603\u2603\");\n+    t(ifmt!(\"{1} {0}\", 0, 1), \"1 0\");\n+    t(ifmt!(\"{foo} {bar}\", foo=0, bar=1), \"0 1\");\n+    t(ifmt!(\"{foo} {1} {bar} {0}\", 0, 1, foo=2, bar=3), \"2 1 3 0\");\n+    t(ifmt!(\"{} {0:s}\", \"a\"), \"a a\");\n+    t(ifmt!(\"{} {0}\", \"a\"), \"\\\"a\\\" \\\"a\\\"\");\n+\n+    // Methods should probably work\n+    t(ifmt!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 0u), \"c0\");\n+    t(ifmt!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 1u), \"a1\");\n+    t(ifmt!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 2u), \"b2\");\n+    t(ifmt!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 3u), \"d3\");\n+    t(ifmt!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"a\"), \"aa\");\n+    t(ifmt!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"b\"), \"bb\");\n+    t(ifmt!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"c\"), \"cc\");\n+    t(ifmt!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"d\"), \"dd\");\n+    t(ifmt!(\"{1, select, a{#{0:s}} other{#{1}}}\", \"b\", \"a\"), \"ab\");\n+    t(ifmt!(\"{1, select, a{#{0}} other{#{1}}}\", \"c\", \"b\"), \"bb\");\n+}\n+"}, {"sha": "f4e2a9f36a072b5e34f6cdec6f0faeaa2e3dfb36", "filename": "src/test/run-pass/issue-3168.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Frun-pass%2Fissue-3168.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Frun-pass%2Fissue-3168.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3168.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-test linked failure\n // xfail-fast\n // xfail-win32 #7999\n "}, {"sha": "13296131236ab25080245cf119baaa2f06e22461", "filename": "src/test/run-pass/lots-a-fail.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Frun-pass%2Flots-a-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Frun-pass%2Flots-a-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flots-a-fail.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-test linked failure\n // xfail-win32 leaks\n extern mod extra;\n "}, {"sha": "ea7d4a651f75d181b88bc80fa85fa9f771e9768d", "filename": "src/test/run-pass/num-range-rev.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Frun-pass%2Fnum-range-rev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Frun-pass%2Fnum-range-rev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnum-range-rev.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -20,11 +20,11 @@ fn int_range(lo: int,  hi: int, it: &fn(int) -> bool) -> bool {\n }\n \n fn uint_range_rev(hi: uint, lo: uint, it: &fn(uint) -> bool) -> bool {\n-    uint::range_rev(hi, lo, it)\n+    range(lo, hi).invert().advance(it)\n }\n \n fn int_range_rev(hi: int,  lo: int, it: &fn(int) -> bool) -> bool {\n-    int::range_rev(hi, lo, it)\n+    range(lo, hi).invert().advance(it)\n }\n \n fn int_range_step(a: int, b: int, step: int, it: &fn(int) -> bool) -> bool {"}, {"sha": "a647e5849a8ee4036ab9eb63f7dda69904271b22", "filename": "src/test/run-pass/send-iloop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Frun-pass%2Fsend-iloop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Frun-pass%2Fsend-iloop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-iloop.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-test linked failure\n // xfail-win32\n extern mod extra;\n "}, {"sha": "b8a1aa433a30a3e6492d7876dac1162a60168919", "filename": "src/test/run-pass/task-killjoin-rsrc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-test linked failure\n // xfail-win32\n \n // A port of task-killjoin to use a class with a dtor to manage"}, {"sha": "5382ac77671392787232a58d60b1c4d8d1973f22", "filename": "src/test/run-pass/task-killjoin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Frun-pass%2Ftask-killjoin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Frun-pass%2Ftask-killjoin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-killjoin.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-test linked failure\n // xfail-win32\n \n // Create a task that is supervised by another task, join the supervised task"}, {"sha": "d6522231f65fadbb33bc356b34cf51bffbeb840e", "filename": "src/test/run-pass/xcrate-unit-struct.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Frun-pass%2Fxcrate-unit-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56730c094cf95be58fb05b0e423673aca2a98b88/src%2Ftest%2Frun-pass%2Fxcrate-unit-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fxcrate-unit-struct.rs?ref=56730c094cf95be58fb05b0e423673aca2a98b88", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:xcrate_unit_struct.rs\n+// xfail-fast\n+extern mod xcrate_unit_struct;\n+\n+use std::util;\n+\n+static s1: xcrate_unit_struct::Struct = xcrate_unit_struct::Struct;\n+static s2: xcrate_unit_struct::Unit = xcrate_unit_struct::Unit;\n+static s3: xcrate_unit_struct::Unit =\n+                xcrate_unit_struct::Argument(xcrate_unit_struct::Struct);\n+static s4: xcrate_unit_struct::Unit = xcrate_unit_struct::Argument(s1);\n+\n+fn f1(_: xcrate_unit_struct::Struct) {}\n+fn f2(_: xcrate_unit_struct::Unit) {}\n+\n+fn main() {\n+    f1(xcrate_unit_struct::Struct);\n+    f2(xcrate_unit_struct::Unit);\n+    f2(xcrate_unit_struct::Argument(xcrate_unit_struct::Struct));\n+\n+    f1(s1);\n+    f2(s2);\n+    f2(s3);\n+    f2(s4);\n+}"}]}