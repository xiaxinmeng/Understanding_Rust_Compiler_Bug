{"sha": "96dfed2b62c6e84a542f9a170133ec528e2191c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2ZGZlZDJiNjJjNmU4NGE1NDJmOWExNzAxMzNlYzUyOGUyMTkxYzI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-04-21T23:21:53Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-04-24T23:59:49Z"}, "message": "Pre-step towards issue #12624 and others: Introduce ExprUseVisitor, remove the\nmoves computation. ExprUseVisitor is a visitor that walks the AST for a\nfunction and calls a delegate to inform it where borrows, copies, and moves\noccur.\n\nIn this patch, I rewrite the gather_loans visitor to use ExprUseVisitor, but in\nfuture patches, I think we could rewrite regionck, check_loans, and possibly\nother passes to use it as well. This would refactor the repeated code between\nthose places that tries to determine where copies/moves/etc occur.", "tree": {"sha": "858758be479d75ed97b70014ce19927fa750280a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/858758be479d75ed97b70014ce19927fa750280a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96dfed2b62c6e84a542f9a170133ec528e2191c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96dfed2b62c6e84a542f9a170133ec528e2191c2", "html_url": "https://github.com/rust-lang/rust/commit/96dfed2b62c6e84a542f9a170133ec528e2191c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96dfed2b62c6e84a542f9a170133ec528e2191c2/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77a975df85694a4de07abb5f99f1159799b1160d", "url": "https://api.github.com/repos/rust-lang/rust/commits/77a975df85694a4de07abb5f99f1159799b1160d", "html_url": "https://github.com/rust-lang/rust/commit/77a975df85694a4de07abb5f99f1159799b1160d"}], "stats": {"total": 2895, "additions": 1268, "deletions": 1627}, "files": [{"sha": "2bc3ed0fce66f0635e8fbfa9fd07dc84aa7f69e7", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=96dfed2b62c6e84a542f9a170133ec528e2191c2", "patch": "@@ -23,7 +23,7 @@ use metadata::{creader, filesearch};\n use metadata::cstore::CStore;\n use metadata::creader::Loader;\n use metadata;\n-use middle::{trans, freevars, kind, ty, typeck, lint, astencode, reachable};\n+use middle::{trans, freevars, kind, ty, typeck, lint, reachable};\n use middle;\n use util::common::time;\n use util::ppaux;\n@@ -35,7 +35,6 @@ use std::cell::{Cell, RefCell};\n use std::io;\n use std::io::fs;\n use std::io::MemReader;\n-use std::mem::drop;\n use std::os;\n use getopts::{optopt, optmulti, optflag, optflagopt};\n use getopts;\n@@ -270,7 +269,6 @@ pub struct CrateAnalysis {\n     pub exported_items: middle::privacy::ExportedItems,\n     pub public_items: middle::privacy::PublicItems,\n     pub ty_cx: ty::ctxt,\n-    pub maps: astencode::Maps,\n     pub reachable: NodeSet,\n }\n \n@@ -346,21 +344,14 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n     time(time_passes, \"effect checking\", (), |_|\n          middle::effect::check_crate(&ty_cx, krate));\n \n-    let middle::moves::MoveMaps {moves_map, capture_map} =\n-        time(time_passes, \"compute moves\", (), |_|\n-             middle::moves::compute_moves(&ty_cx, krate));\n-\n     time(time_passes, \"match checking\", (), |_|\n-         middle::check_match::check_crate(&ty_cx, &moves_map, krate));\n+         middle::check_match::check_crate(&ty_cx, krate));\n \n     time(time_passes, \"liveness checking\", (), |_|\n-         middle::liveness::check_crate(&ty_cx, &capture_map, krate));\n+         middle::liveness::check_crate(&ty_cx, krate));\n \n     time(time_passes, \"borrow checking\", (), |_|\n-         middle::borrowck::check_crate(&ty_cx, &moves_map,\n-                                       &capture_map, krate));\n-\n-    drop(moves_map);\n+         middle::borrowck::check_crate(&ty_cx, krate));\n \n     time(time_passes, \"kind checking\", (), |_|\n          kind::check_crate(&ty_cx, krate));\n@@ -384,9 +375,6 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n         ty_cx: ty_cx,\n         exported_items: exported_items,\n         public_items: public_items,\n-        maps: astencode::Maps {\n-            capture_map: RefCell::new(capture_map)\n-        },\n         reachable: reachable_map\n     }\n }"}, {"sha": "25a4adcfca195f24dfd3c7f563c27cfacd69e13f", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=96dfed2b62c6e84a542f9a170133ec528e2191c2", "patch": "@@ -86,13 +86,13 @@ pub mod middle {\n     pub mod astencode;\n     pub mod lang_items;\n     pub mod privacy;\n-    pub mod moves;\n     pub mod entry;\n     pub mod effect;\n     pub mod reachable;\n     pub mod graph;\n     pub mod cfg;\n     pub mod dead;\n+    pub mod expr_use_visitor;\n }\n \n pub mod front {"}, {"sha": "5ada0068a47ef6e8f5fa106e3b8fa3a84752210a", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 65, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=96dfed2b62c6e84a542f9a170133ec528e2191c2", "patch": "@@ -24,8 +24,7 @@ use metadata::tydecode::{DefIdSource, NominalType, TypeWithId, TypeParameter,\n                          RegionParameter};\n use metadata::tyencode;\n use middle::typeck::{MethodCall, MethodCallee, MethodOrigin};\n-use middle::{ty, typeck, moves};\n-use middle;\n+use middle::{ty, typeck};\n use util::ppaux::ty_to_str;\n \n use syntax::{ast, ast_map, ast_util, codemap, fold};\n@@ -36,7 +35,6 @@ use syntax;\n \n use libc;\n use std::cast;\n-use std::cell::RefCell;\n use std::io::Seek;\n use std::io::MemWriter;\n use std::rc::Rc;\n@@ -52,15 +50,9 @@ use writer = serialize::ebml::writer;\n #[cfg(test)] use syntax::parse;\n #[cfg(test)] use syntax::print::pprust;\n \n-// Auxiliary maps of things to be encoded\n-pub struct Maps {\n-    pub capture_map: RefCell<middle::moves::CaptureMap>,\n-}\n-\n struct DecodeContext<'a> {\n     cdata: &'a cstore::crate_metadata,\n     tcx: &'a ty::ctxt,\n-    maps: &'a Maps\n }\n \n struct ExtendedDecodeContext<'a> {\n@@ -84,8 +76,7 @@ pub type Encoder<'a> = writer::Encoder<'a, MemWriter>;\n \n pub fn encode_inlined_item(ecx: &e::EncodeContext,\n                            ebml_w: &mut Encoder,\n-                           ii: e::InlinedItemRef,\n-                           maps: &Maps) {\n+                           ii: e::InlinedItemRef) {\n     let id = match ii {\n         e::IIItemRef(i) => i.id,\n         e::IIForeignRef(i) => i.id,\n@@ -101,7 +92,7 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n     ebml_w.start_tag(c::tag_ast as uint);\n     id_range.encode(ebml_w);\n     encode_ast(ebml_w, ii);\n-    encode_side_tables_for_ii(ecx, maps, ebml_w, &ii);\n+    encode_side_tables_for_ii(ecx, ebml_w, &ii);\n     ebml_w.end_tag();\n \n     debug!(\"< Encoded inlined fn: {} ({})\",\n@@ -111,14 +102,12 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n \n pub fn decode_inlined_item(cdata: &cstore::crate_metadata,\n                            tcx: &ty::ctxt,\n-                           maps: &Maps,\n                            path: Vec<ast_map::PathElem>,\n                            par_doc: ebml::Doc)\n                            -> Result<ast::InlinedItem, Vec<ast_map::PathElem>> {\n     let dcx = &DecodeContext {\n         cdata: cdata,\n         tcx: tcx,\n-        maps: maps\n     };\n     match par_doc.opt_child(c::tag_ast) {\n       None => Err(path),\n@@ -551,32 +540,6 @@ impl tr for freevar_entry {\n     }\n }\n \n-// ______________________________________________________________________\n-// Encoding and decoding of CaptureVar information\n-\n-trait capture_var_helper {\n-    fn read_capture_var(&mut self, xcx: &ExtendedDecodeContext)\n-                        -> moves::CaptureVar;\n-}\n-\n-impl<'a> capture_var_helper for reader::Decoder<'a> {\n-    fn read_capture_var(&mut self, xcx: &ExtendedDecodeContext)\n-                        -> moves::CaptureVar {\n-        let cvar: moves::CaptureVar = Decodable::decode(self).unwrap();\n-        cvar.tr(xcx)\n-    }\n-}\n-\n-impl tr for moves::CaptureVar {\n-    fn tr(&self, xcx: &ExtendedDecodeContext) -> moves::CaptureVar {\n-        moves::CaptureVar {\n-            def: self.def.tr(xcx),\n-            span: self.span.tr(xcx),\n-            mode: self.mode\n-        }\n-    }\n-}\n-\n // ______________________________________________________________________\n // Encoding and decoding of MethodCallee\n \n@@ -935,7 +898,6 @@ impl<'a> write_tag_and_id for Encoder<'a> {\n struct SideTableEncodingIdVisitor<'a,'b> {\n     ecx_ptr: *libc::c_void,\n     new_ebml_w: &'a mut Encoder<'b>,\n-    maps: &'a Maps,\n }\n \n impl<'a,'b> ast_util::IdVisitingOperation for\n@@ -953,12 +915,11 @@ impl<'a,'b> ast_util::IdVisitingOperation for\n         let ecx: &e::EncodeContext = unsafe {\n             cast::transmute(self.ecx_ptr)\n         };\n-        encode_side_tables_for_id(ecx, self.maps, &mut new_ebml_w, id)\n+        encode_side_tables_for_id(ecx, &mut new_ebml_w, id)\n     }\n }\n \n fn encode_side_tables_for_ii(ecx: &e::EncodeContext,\n-                             maps: &Maps,\n                              ebml_w: &mut Encoder,\n                              ii: &ast::InlinedItem) {\n     ebml_w.start_tag(c::tag_table as uint);\n@@ -974,13 +935,11 @@ fn encode_side_tables_for_ii(ecx: &e::EncodeContext,\n             cast::transmute(ecx)\n         },\n         new_ebml_w: &mut new_ebml_w,\n-        maps: maps,\n     });\n     ebml_w.end_tag();\n }\n \n fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n-                             maps: &Maps,\n                              ebml_w: &mut Encoder,\n                              id: ast::NodeId) {\n     let tcx = ecx.tcx;\n@@ -1096,17 +1055,6 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n             })\n         })\n     }\n-\n-    for &cap_vars in maps.capture_map.borrow().find(&id).iter() {\n-        ebml_w.tag(c::tag_table_capture_map, |ebml_w| {\n-            ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                ebml_w.emit_from_vec(cap_vars.as_slice(), |ebml_w, cap_var| {\n-                    cap_var.encode(ebml_w)\n-                });\n-            })\n-        })\n-    }\n }\n \n trait doc_decoder_helpers {\n@@ -1405,15 +1353,6 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n                         let adj: ty::AutoAdjustment = val_dsr.read_auto_adjustment(xcx);\n                         dcx.tcx.adjustments.borrow_mut().insert(id, adj);\n                     }\n-                    c::tag_table_capture_map => {\n-                        let cvars =\n-                                val_dsr.read_to_vec(\n-                                            |val_dsr| Ok(val_dsr.read_capture_var(xcx)))\n-                                       .unwrap()\n-                                       .move_iter()\n-                                       .collect();\n-                        dcx.maps.capture_map.borrow_mut().insert(id, Rc::new(cvars));\n-                    }\n                     _ => {\n                         xcx.dcx.tcx.sess.bug(\n                             format!(\"unknown tag found in side tables: {:x}\", tag));"}, {"sha": "a24e7d6638066153322d6cc661ce54aa91b82c8f", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=96dfed2b62c6e84a542f9a170133ec528e2191c2", "patch": "@@ -18,9 +18,10 @@\n // 4. moves do not affect things loaned out in any way\n \n \n-use mc = middle::mem_categorization;\n use middle::borrowck::*;\n-use middle::moves;\n+use euv = middle::expr_use_visitor;\n+use middle::freevars;\n+use mc = middle::mem_categorization;\n use middle::ty;\n use middle::typeck::MethodCall;\n use syntax::ast;\n@@ -288,7 +289,7 @@ impl<'a> CheckLoanCtxt<'a> {\n             }\n \n             match new_loan.cause {\n-                ClosureCapture(span) => {\n+                euv::ClosureCapture(span) => {\n                     self.bccx.span_note(\n                         span,\n                         format!(\"borrow occurs due to use of `{}` in closure\",\n@@ -321,13 +322,17 @@ impl<'a> CheckLoanCtxt<'a> {\n             };\n \n             let borrow_summary = match old_loan.cause {\n-                ClosureCapture(_) => {\n+                euv::ClosureCapture(_) => {\n                     format!(\"previous borrow of `{}` occurs here due to \\\n                             use in closure\",\n                             self.bccx.loan_path_to_str(&*old_loan.loan_path))\n                 }\n \n-                AddrOf | AutoRef | RefBinding | ClosureInvocation => {\n+                euv::OverloadedOperator(..) |\n+                euv::AddrOf(..) |\n+                euv::AutoRef(..) |\n+                euv::ClosureInvocation(..) |\n+                euv::RefBinding(..) => {\n                     format!(\"previous borrow of `{}` occurs here\",\n                             self.bccx.loan_path_to_str(&*old_loan.loan_path))\n                 }\n@@ -711,29 +716,33 @@ impl<'a> CheckLoanCtxt<'a> {\n     fn check_captured_variables(&self,\n                                 closure_id: ast::NodeId,\n                                 span: Span) {\n-        for cap_var in self.bccx.capture_map.get(&closure_id).iter() {\n-            let var_id = ast_util::def_id_of_def(cap_var.def).node;\n-            self.check_if_path_is_moved(closure_id, span,\n-                                        MovedInCapture, &Rc::new(LpVar(var_id)));\n-            match cap_var.mode {\n-                moves::CapRef | moves::CapCopy => {}\n-                moves::CapMove => {\n-                    check_by_move_capture(self, closure_id, cap_var, &LpVar(var_id));\n+        let freevar_mode = freevars::get_capture_mode(self.tcx(), closure_id);\n+        freevars::with_freevars(self.tcx(), closure_id, |freevars| {\n+            for freevar in freevars.iter() {\n+                let var_id = ast_util::def_id_of_def(freevar.def).node;\n+                let var_path = Rc::new(LpVar(var_id));\n+                self.check_if_path_is_moved(closure_id, span,\n+                                            MovedInCapture, &var_path);\n+                match freevar_mode {\n+                    freevars::CaptureByRef => { }\n+                    freevars::CaptureByValue => {\n+                        check_by_move_capture(self, closure_id, freevar, &*var_path);\n+                    }\n                 }\n             }\n-        }\n+        });\n         return;\n \n         fn check_by_move_capture(this: &CheckLoanCtxt,\n                                  closure_id: ast::NodeId,\n-                                 cap_var: &moves::CaptureVar,\n+                                 freevar: &freevars::freevar_entry,\n                                  move_path: &LoanPath) {\n             let move_err = this.analyze_move_out_from(closure_id, move_path);\n             match move_err {\n                 MoveOk => {}\n                 MoveWhileBorrowed(loan_path, loan_span) => {\n                     this.bccx.span_err(\n-                        cap_var.span,\n+                        freevar.span,\n                         format!(\"cannot move `{}` into closure \\\n                                 because it is borrowed\",\n                                 this.bccx.loan_path_to_str(move_path)));"}, {"sha": "16fd03c1aadd4b290e91ced4bbce76227ebb0f61", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 7, "deletions": 42, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=96dfed2b62c6e84a542f9a170133ec528e2191c2", "patch": "@@ -17,7 +17,7 @@ use middle::borrowck::*;\n use middle::borrowck::gather_loans::move_error::{MoveError, MoveErrorCollector};\n use middle::borrowck::gather_loans::move_error::MoveSpanAndPath;\n use middle::borrowck::move_data::*;\n-use middle::moves;\n+use euv = middle::expr_use_visitor;\n use middle::ty;\n use syntax::ast;\n use syntax::codemap::Span;\n@@ -44,10 +44,10 @@ pub fn gather_decl(bccx: &BorrowckCtxt,\n pub fn gather_move_from_expr(bccx: &BorrowckCtxt,\n                              move_data: &MoveData,\n                              move_error_collector: &MoveErrorCollector,\n-                             move_expr: &ast::Expr,\n+                             move_expr_id: ast::NodeId,\n                              cmt: mc::cmt) {\n     let move_info = GatherMoveInfo {\n-        id: move_expr.id,\n+        id: move_expr_id,\n         kind: MoveExpr,\n         cmt: cmt,\n         span_path_opt: None,\n@@ -76,29 +76,6 @@ pub fn gather_move_from_pat(bccx: &BorrowckCtxt,\n     gather_move(bccx, move_data, move_error_collector, move_info);\n }\n \n-pub fn gather_captures(bccx: &BorrowckCtxt,\n-                       move_data: &MoveData,\n-                       move_error_collector: &MoveErrorCollector,\n-                       closure_expr: &ast::Expr) {\n-    for captured_var in bccx.capture_map.get(&closure_expr.id).iter() {\n-        match captured_var.mode {\n-            moves::CapMove => {\n-                let cmt = bccx.cat_captured_var(closure_expr.id,\n-                                                closure_expr.span,\n-                                                captured_var);\n-                let move_info = GatherMoveInfo {\n-                    id: closure_expr.id,\n-                    kind: Captured,\n-                    cmt: cmt,\n-                    span_path_opt: None\n-                };\n-                gather_move(bccx, move_data, move_error_collector, move_info);\n-            }\n-            moves::CapCopy | moves::CapRef => {}\n-        }\n-    }\n-}\n-\n fn gather_move(bccx: &BorrowckCtxt,\n                move_data: &MoveData,\n                move_error_collector: &MoveErrorCollector,\n@@ -110,6 +87,7 @@ fn gather_move(bccx: &BorrowckCtxt,\n                 check_and_get_illegal_move_origin(bccx, &move_info.cmt);\n     match potentially_illegal_move {\n         Some(illegal_move_origin) => {\n+            debug!(\"illegal_move_origin={}\", illegal_move_origin.repr(bccx.tcx));\n             let error = MoveError::with_move_info(illegal_move_origin,\n                                                   move_info.span_path_opt);\n             move_error_collector.add_error(error);\n@@ -134,27 +112,14 @@ pub fn gather_assignment(bccx: &BorrowckCtxt,\n                          assignment_id: ast::NodeId,\n                          assignment_span: Span,\n                          assignee_loan_path: Rc<LoanPath>,\n-                         assignee_id: ast::NodeId) {\n-    move_data.add_assignment(bccx.tcx,\n-                             assignee_loan_path,\n-                             assignment_id,\n-                             assignment_span,\n-                             assignee_id,\n-                             false);\n-}\n-\n-pub fn gather_move_and_assignment(bccx: &BorrowckCtxt,\n-                                  move_data: &MoveData,\n-                                  assignment_id: ast::NodeId,\n-                                  assignment_span: Span,\n-                                  assignee_loan_path: Rc<LoanPath>,\n-                                  assignee_id: ast::NodeId) {\n+                         assignee_id: ast::NodeId,\n+                         mode: euv::MutateMode) {\n     move_data.add_assignment(bccx.tcx,\n                              assignee_loan_path,\n                              assignment_id,\n                              assignment_span,\n                              assignee_id,\n-                             true);\n+                             mode);\n }\n \n fn check_and_get_illegal_move_origin(bccx: &BorrowckCtxt,"}, {"sha": "3337a56edf008d8f52f7e29d1f6d03bb3a034c43", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=96dfed2b62c6e84a542f9a170133ec528e2191c2", "patch": "@@ -14,6 +14,7 @@\n  */\n \n use middle::borrowck::*;\n+use euv = middle::expr_use_visitor;\n use mc = middle::mem_categorization;\n use middle::ty;\n use util::ppaux::Repr;\n@@ -24,9 +25,8 @@ type R = Result<(),()>;\n \n pub fn guarantee_lifetime(bccx: &BorrowckCtxt,\n                           item_scope_id: ast::NodeId,\n-                          root_scope_id: ast::NodeId,\n                           span: Span,\n-                          cause: LoanCause,\n+                          cause: euv::LoanCause,\n                           cmt: mc::cmt,\n                           loan_region: ty::Region,\n                           loan_kind: ty::BorrowKind)\n@@ -39,8 +39,7 @@ pub fn guarantee_lifetime(bccx: &BorrowckCtxt,\n                                          cause: cause,\n                                          loan_region: loan_region,\n                                          loan_kind: loan_kind,\n-                                         cmt_original: cmt.clone(),\n-                                         root_scope_id: root_scope_id};\n+                                         cmt_original: cmt.clone()};\n     ctxt.check(&cmt, None)\n }\n \n@@ -53,12 +52,8 @@ struct GuaranteeLifetimeContext<'a> {\n     // the node id of the function body for the enclosing item\n     item_scope_id: ast::NodeId,\n \n-    // the node id of the innermost loop / function body; this is the\n-    // longest scope for which we can root managed boxes\n-    root_scope_id: ast::NodeId,\n-\n     span: Span,\n-    cause: LoanCause,\n+    cause: euv::LoanCause,\n     loan_region: ty::Region,\n     loan_kind: ty::BorrowKind,\n     cmt_original: mc::cmt"}, {"sha": "b351c99084de3d9474b8f39dfa8af24dca36f8fd", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 104, "deletions": 580, "changes": 684, "blob_url": "https://github.com/rust-lang/rust/blob/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=96dfed2b62c6e84a542f9a170133ec528e2191c2", "patch": "@@ -18,323 +18,144 @@\n \n use middle::borrowck::*;\n use middle::borrowck::move_data::MoveData;\n+use euv = middle::expr_use_visitor;\n use mc = middle::mem_categorization;\n-use middle::moves;\n-use middle::pat_util;\n-use middle::ty::{ty_region};\n use middle::ty;\n-use middle::typeck::MethodCall;\n-use util::common::indenter;\n use util::ppaux::{Repr};\n \n use syntax::ast;\n-use syntax::ast_util;\n-use syntax::ast_util::IdRange;\n use syntax::codemap::Span;\n-use syntax::print::pprust;\n use syntax::visit;\n-use syntax::visit::{Visitor, FnKind};\n-use syntax::ast::{Expr, FnDecl, Block, NodeId, Stmt, Pat, Local};\n-\n-use std::rc::Rc;\n+use syntax::visit::{Visitor};\n+use syntax::ast::{Expr, FnDecl, Block, NodeId, Pat};\n \n mod lifetime;\n mod restrictions;\n mod gather_moves;\n mod move_error;\n \n-/// Context used while gathering loans:\n-///\n-/// - `bccx`: the borrow check context\n-/// - `item_ub`: the id of the block for the enclosing fn/method item\n-/// - `root_ub`: the id of the outermost block for which we can root\n-///   an `@T`.  This is the id of the innermost enclosing\n-///   loop or function body.\n-///\n-/// The role of `root_ub` is to prevent us from having to accumulate\n-/// vectors of rooted items at runtime.  Consider this case:\n-///\n-///     fn foo(...) -> int {\n-///         let mut ptr: &int;\n-///         while some_cond {\n-///             let x: @int = ...;\n-///             ptr = &*x;\n-///         }\n-///         *ptr\n-///     }\n-///\n-/// If we are not careful here, we would infer the scope of the borrow `&*x`\n-/// to be the body of the function `foo()` as a whole.  We would then\n-/// have root each `@int` that is produced, which is an unbounded number.\n-/// No good.  Instead what will happen is that `root_ub` will be set to the\n-/// body of the while loop and we will refuse to root the pointer `&*x`\n-/// because it would have to be rooted for a region greater than `root_ub`.\n-struct GatherLoanCtxt<'a> {\n-    bccx: &'a BorrowckCtxt<'a>,\n-    id_range: IdRange,\n-    move_data: move_data::MoveData,\n-    move_error_collector: move_error::MoveErrorCollector,\n-    all_loans: Vec<Loan>,\n-    item_ub: ast::NodeId,\n-    repeating_ids: Vec<ast::NodeId> }\n-\n-impl<'a> visit::Visitor<()> for GatherLoanCtxt<'a> {\n-    fn visit_expr(&mut self, ex: &Expr, _: ()) {\n-        gather_loans_in_expr(self, ex);\n-    }\n-    fn visit_block(&mut self, b: &Block, _: ()) {\n-        gather_loans_in_block(self, b);\n-    }\n-\n-    /// Do not visit closures or fn items here, the outer loop in\n-    /// borrowck/mod will visit them for us in turn.\n-    fn visit_fn(&mut self, _: &FnKind, _: &FnDecl, _: &Block,\n-                _: Span, _: NodeId, _: ()) {}\n-\n-    fn visit_stmt(&mut self, s: &Stmt, _: ()) {\n-        visit::walk_stmt(self, s, ());\n-    }\n-    fn visit_pat(&mut self, p: &Pat, _: ()) {\n-        add_pat_to_id_range(self, p);\n-    }\n-    fn visit_local(&mut self, l: &Local, _: ()) {\n-        gather_loans_in_local(self, l);\n-    }\n-\n-    // #7740: Do not visit items here, not even fn items nor methods\n-    // of impl items; the outer loop in borrowck/mod will visit them\n-    // for us in turn.  Thus override visit_item's walk with a no-op.\n-    fn visit_item(&mut self, _: &ast::Item, _: ()) {}\n-}\n-\n-fn add_pat_to_id_range(this: &mut GatherLoanCtxt,\n-                       p: &ast::Pat) {\n-    // NB: This visitor function just adds the pat ids into the id\n-    // range. We gather loans that occur in patterns using the\n-    // `gather_pat()` method below. Eventually these two should be\n-    // brought together.\n-    this.id_range.add(p.id);\n-    visit::walk_pat(this, p, ());\n-}\n-\n-pub fn gather_loans_in_fn(bccx: &BorrowckCtxt, decl: &ast::FnDecl, body: &ast::Block)\n-                    -> (IdRange, Vec<Loan>, move_data::MoveData) {\n+pub fn gather_loans_in_fn(bccx: &BorrowckCtxt,\n+                          decl: &ast::FnDecl,\n+                          body: &ast::Block)\n+                          -> (Vec<Loan>, move_data::MoveData)\n+{\n     let mut glcx = GatherLoanCtxt {\n         bccx: bccx,\n-        id_range: IdRange::max(),\n         all_loans: Vec::new(),\n         item_ub: body.id,\n-        repeating_ids: vec!(body.id),\n         move_data: MoveData::new(),\n         move_error_collector: move_error::MoveErrorCollector::new(),\n     };\n-    glcx.gather_fn_arg_patterns(decl, body);\n \n-    glcx.visit_block(body, ());\n+    {\n+        let mut euv = euv::ExprUseVisitor::new(&mut glcx, bccx.tcx);\n+        euv.walk_fn(decl, body);\n+    }\n+\n     glcx.report_potential_errors();\n-    let GatherLoanCtxt { id_range, all_loans, move_data, .. } = glcx;\n-    (id_range, all_loans, move_data)\n+    let GatherLoanCtxt { all_loans, move_data, .. } = glcx;\n+    (all_loans, move_data)\n }\n \n-fn gather_loans_in_block(this: &mut GatherLoanCtxt,\n-                         blk: &ast::Block) {\n-    this.id_range.add(blk.id);\n-    visit::walk_block(this, blk, ());\n+struct GatherLoanCtxt<'a> {\n+    bccx: &'a BorrowckCtxt<'a>,\n+    move_data: move_data::MoveData,\n+    move_error_collector: move_error::MoveErrorCollector,\n+    all_loans: Vec<Loan>,\n+    item_ub: ast::NodeId,\n }\n \n-fn gather_loans_in_local(this: &mut GatherLoanCtxt,\n-                         local: &ast::Local) {\n-    match local.init {\n-        None => {\n-            // Variable declarations without initializers are considered \"moves\":\n-            let tcx = this.bccx.tcx;\n-            pat_util::pat_bindings(&tcx.def_map, local.pat, |_, id, span, _| {\n-                gather_moves::gather_decl(this.bccx,\n-                                          &this.move_data,\n-                                          id,\n-                                          span,\n-                                          id);\n-            })\n+impl<'a> euv::Delegate for GatherLoanCtxt<'a> {\n+    fn consume(&mut self,\n+               consume_id: ast::NodeId,\n+               _consume_span: Span,\n+               cmt: mc::cmt,\n+               mode: euv::ConsumeMode) {\n+        debug!(\"consume(consume_id={}, cmt={}, mode={})\",\n+               consume_id, cmt.repr(self.tcx()), mode);\n+\n+        match mode {\n+            euv::Copy => { return; }\n+            euv::Move => { }\n         }\n-        Some(init) => {\n-            // Variable declarations with initializers are considered \"assigns\",\n-            // which is handled by `gather_pat`:\n-            let init_cmt = this.bccx.cat_expr(init);\n-            this.gather_pat(init_cmt, local.pat, None);\n-        }\n-    }\n-\n-    visit::walk_local(this, local, ());\n-}\n \n-fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n-                        ex: &ast::Expr) {\n-    let bccx = this.bccx;\n-    let tcx = bccx.tcx;\n+        gather_moves::gather_move_from_expr(\n+            self.bccx, &self.move_data, &self.move_error_collector,\n+            consume_id, cmt);\n+    }\n \n-    debug!(\"gather_loans_in_expr(expr={:?}/{})\",\n-           ex.id, pprust::expr_to_str(ex));\n+    fn consume_pat(&mut self,\n+                   consume_pat: &ast::Pat,\n+                   cmt: mc::cmt,\n+                   mode: euv::ConsumeMode) {\n+        debug!(\"consume_pat(consume_pat={}, cmt={}, mode={})\",\n+               consume_pat.repr(self.tcx()),\n+               cmt.repr(self.tcx()),\n+               mode);\n \n-    this.id_range.add(ex.id);\n+        match mode {\n+            euv::Copy => { return; }\n+            euv::Move => { }\n+        }\n \n-    // If this expression is borrowed, have to ensure it remains valid:\n-    for &adjustments in tcx.adjustments.borrow().find(&ex.id).iter() {\n-        this.guarantee_adjustments(ex, adjustments);\n+        gather_moves::gather_move_from_pat(\n+            self.bccx, &self.move_data, &self.move_error_collector,\n+            consume_pat, cmt);\n     }\n \n-    // If this expression is a move, gather it:\n-    if this.bccx.is_move(ex.id) {\n-        let cmt = this.bccx.cat_expr(ex);\n-        gather_moves::gather_move_from_expr(\n-            this.bccx, &this.move_data, &this.move_error_collector, ex, cmt);\n+    fn borrow(&mut self,\n+              borrow_id: ast::NodeId,\n+              borrow_span: Span,\n+              cmt: mc::cmt,\n+              loan_region: ty::Region,\n+              bk: ty::BorrowKind,\n+              loan_cause: euv::LoanCause)\n+    {\n+        debug!(\"borrow(borrow_id={}, cmt={}, loan_region={}, \\\n+               bk={}, loan_cause={:?})\",\n+               borrow_id, cmt.repr(self.tcx()), loan_region,\n+               bk, loan_cause);\n+\n+        self.guarantee_valid(borrow_id,\n+                             borrow_span,\n+                             cmt,\n+                             bk,\n+                             loan_region,\n+                             loan_cause);\n     }\n \n-    // Special checks for various kinds of expressions:\n-    let method_map = this.bccx.tcx.method_map.borrow();\n-    match ex.node {\n-      ast::ExprAddrOf(mutbl, base) => {\n-        let base_cmt = this.bccx.cat_expr(base);\n-\n-        // make sure that the thing we are pointing out stays valid\n-        // for the lifetime `scope_r` of the resulting ptr:\n-        let expr_ty = ty::expr_ty(tcx, ex);\n-        if !ty::type_is_bot(expr_ty) {\n-            let scope_r = ty_region(tcx, ex.span, expr_ty);\n-            this.guarantee_valid(ex.id,\n-                                 ex.span,\n-                                 base_cmt,\n-                                 mutbl,\n-                                 scope_r,\n-                                 AddrOf);\n-        }\n-        visit::walk_expr(this, ex, ());\n-      }\n-\n-      ast::ExprAssign(l, _) => {\n-          with_assignee_loan_path(\n-              this.bccx, l,\n-              |lp| gather_moves::gather_assignment(this.bccx, &this.move_data,\n-                                                   ex.id, ex.span, lp, l.id));\n-          visit::walk_expr(this, ex, ());\n-      }\n-\n-      ast::ExprAssignOp(_, l, _) => {\n-          with_assignee_loan_path(\n-              this.bccx, l,\n-              |lp| gather_moves::gather_move_and_assignment(this.bccx, &this.move_data,\n-                                                            ex.id, ex.span, lp, l.id));\n-          visit::walk_expr(this, ex, ());\n-      }\n-\n-      ast::ExprMatch(ex_v, ref arms) => {\n-        let cmt = this.bccx.cat_expr(ex_v);\n-        for arm in arms.iter() {\n-            for pat in arm.pats.iter() {\n-                this.gather_pat(cmt.clone(), *pat, Some((arm.body.id, ex.id)));\n+    fn mutate(&mut self,\n+              assignment_id: ast::NodeId,\n+              assignment_span: Span,\n+              assignee_cmt: mc::cmt,\n+              mode: euv::MutateMode)\n+    {\n+        debug!(\"mutate(assignment_id={}, assignee_cmt={})\",\n+               assignment_id, assignee_cmt.repr(self.tcx()));\n+\n+        match opt_loan_path(&assignee_cmt) {\n+            Some(lp) => {\n+                gather_moves::gather_assignment(self.bccx, &self.move_data,\n+                                                assignment_id, assignment_span,\n+                                                lp, assignee_cmt.id, mode);\n+            }\n+            None => {\n+                // This can occur with e.g. `*foo() = 5`.  In such\n+                // cases, there is no need to check for conflicts\n+                // with moves etc, just ignore.\n             }\n         }\n-        visit::walk_expr(this, ex, ());\n-      }\n-\n-      ast::ExprIndex(_, arg) |\n-      ast::ExprBinary(_, _, arg)\n-      if method_map.contains_key(&MethodCall::expr(ex.id)) => {\n-          // Arguments in method calls are always passed by ref.\n-          //\n-          // Currently these do not use adjustments, so we have to\n-          // hardcode this check here (note that the receiver DOES use\n-          // adjustments).\n-          let scope_r = ty::ReScope(ex.id);\n-          let arg_cmt = this.bccx.cat_expr(arg);\n-          this.guarantee_valid(arg.id,\n-                               arg.span,\n-                               arg_cmt,\n-                               ast::MutImmutable,\n-                               scope_r,\n-                               AutoRef);\n-          visit::walk_expr(this, ex, ());\n-      }\n-\n-      // see explanation attached to the `root_ub` field:\n-      ast::ExprWhile(cond, body) => {\n-          // during the condition, can only root for the condition\n-          this.push_repeating_id(cond.id);\n-          this.visit_expr(cond, ());\n-          this.pop_repeating_id(cond.id);\n-\n-          // during body, can only root for the body\n-          this.push_repeating_id(body.id);\n-          this.visit_block(body, ());\n-          this.pop_repeating_id(body.id);\n-      }\n-\n-      // see explanation attached to the `root_ub` field:\n-      ast::ExprLoop(body, _) => {\n-          this.push_repeating_id(body.id);\n-          visit::walk_expr(this, ex, ());\n-          this.pop_repeating_id(body.id);\n-      }\n-\n-      ast::ExprFnBlock(..) | ast::ExprProc(..) => {\n-          gather_moves::gather_captures(this.bccx, &this.move_data,\n-                                        &this.move_error_collector, ex);\n-          this.guarantee_captures(ex);\n-          visit::walk_expr(this, ex, ());\n-      }\n-\n-      ast::ExprInlineAsm(ref ia) => {\n-          for &(_, out) in ia.outputs.iter() {\n-              with_assignee_loan_path(\n-                  this.bccx, out,\n-                  |lp| gather_moves::gather_assignment(this.bccx, &this.move_data,\n-                                                       ex.id, ex.span, lp, out.id));\n-          }\n-          visit::walk_expr(this, ex, ());\n-      }\n-\n-      ast::ExprCall(f, _) => {\n-          let expr_ty = ty::expr_ty_adjusted(tcx, f);\n-          match ty::get(expr_ty).sty {\n-              ty::ty_closure(~ty::ClosureTy {\n-                  store: ty::RegionTraitStore(..), ..\n-              }) => {\n-                  let scope_r = ty::ReScope(ex.id);\n-                  let base_cmt = this.bccx.cat_expr(f);\n-                  this.guarantee_valid_kind(f.id,\n-                                            f.span,\n-                                            base_cmt,\n-                                            ty::UniqueImmBorrow,\n-                                            scope_r,\n-                                            ClosureInvocation);\n-              }\n-              _ => {}\n-          }\n-          visit::walk_expr(this, ex, ());\n-      }\n-\n-      _ => {\n-          visit::walk_expr(this, ex, ());\n-      }\n     }\n-}\n \n-fn with_assignee_loan_path(bccx: &BorrowckCtxt, expr: &ast::Expr, op: |Rc<LoanPath>|) {\n-    let cmt = bccx.cat_expr(expr);\n-    match opt_loan_path(&cmt) {\n-        Some(lp) => op(lp),\n-        None => {\n-            // This can occur with e.g. `*foo() = 5`.  In such\n-            // cases, there is no need to check for conflicts\n-            // with moves etc, just ignore.\n-        }\n+    fn decl_without_init(&mut self, id: ast::NodeId, span: Span) {\n+        gather_moves::gather_decl(self.bccx, &self.move_data, id, span, id);\n     }\n }\n \n-\n /// Implements the A-* rules in doc.rs.\n fn check_aliasability(bccx: &BorrowckCtxt,\n                       borrow_span: Span,\n-                      loan_cause: LoanCause,\n+                      loan_cause: euv::LoanCause,\n                       cmt: mc::cmt,\n                       req_kind: ty::BorrowKind)\n                       -> Result<(),()> {\n@@ -385,167 +206,13 @@ fn check_aliasability(bccx: &BorrowckCtxt,\n impl<'a> GatherLoanCtxt<'a> {\n     pub fn tcx(&self) -> &'a ty::ctxt { self.bccx.tcx }\n \n-    pub fn push_repeating_id(&mut self, id: ast::NodeId) {\n-        self.repeating_ids.push(id);\n-    }\n-\n-    pub fn pop_repeating_id(&mut self, id: ast::NodeId) {\n-        let popped = self.repeating_ids.pop().unwrap();\n-        assert_eq!(id, popped);\n-    }\n-\n-    pub fn guarantee_autoderefs(&mut self,\n-                                expr: &ast::Expr,\n-                                autoderefs: uint) {\n-        let method_map = self.bccx.tcx.method_map.borrow();\n-        for i in range(0, autoderefs) {\n-            match method_map.find(&MethodCall::autoderef(expr.id, i as u32)) {\n-                Some(method) => {\n-                    // Treat overloaded autoderefs as if an AutoRef adjustment\n-                    // was applied on the base type, as that is always the case.\n-                    let cmt = match self.bccx.mc().cat_expr_autoderefd(expr, i) {\n-                        Ok(v) => v,\n-                        Err(()) => self.tcx().sess.span_bug(expr.span, \"Err from mc\")\n-                    };\n-                    let self_ty = *ty::ty_fn_args(method.ty).get(0);\n-                    let (m, r) = match ty::get(self_ty).sty {\n-                        ty::ty_rptr(r, ref m) => (m.mutbl, r),\n-                        _ => self.tcx().sess.span_bug(expr.span,\n-                                format!(\"bad overloaded deref type {}\",\n-                                    method.ty.repr(self.tcx())))\n-                    };\n-                    self.guarantee_valid(expr.id,\n-                                         expr.span,\n-                                         cmt,\n-                                         m,\n-                                         r,\n-                                         AutoRef);\n-                }\n-                None => {}\n-            }\n-        }\n-    }\n-\n-    pub fn guarantee_adjustments(&mut self,\n-                                 expr: &ast::Expr,\n-                                 adjustment: &ty::AutoAdjustment) {\n-        debug!(\"guarantee_adjustments(expr={}, adjustment={:?})\",\n-               expr.repr(self.tcx()), adjustment);\n-        let _i = indenter();\n-\n-        match *adjustment {\n-            ty::AutoAddEnv(..) => {\n-                debug!(\"autoaddenv -- no autoref\");\n-                return;\n-            }\n-\n-            ty::AutoDerefRef(\n-                ty::AutoDerefRef {\n-                    autoref: None, autoderefs }) => {\n-                debug!(\"no autoref\");\n-                self.guarantee_autoderefs(expr, autoderefs);\n-                return;\n-            }\n-\n-            ty::AutoDerefRef(\n-                ty::AutoDerefRef {\n-                    autoref: Some(ref autoref),\n-                    autoderefs}) => {\n-                self.guarantee_autoderefs(expr, autoderefs);\n-                let mc = self.bccx.mc();\n-                let cmt = match mc.cat_expr_autoderefd(expr, autoderefs) {\n-                    Ok(v) => v,\n-                    Err(()) => self.tcx().sess.span_bug(expr.span, \"Err from mc\")\n-                };\n-                debug!(\"after autoderef, cmt={}\", cmt.repr(self.tcx()));\n-\n-                match *autoref {\n-                    ty::AutoPtr(r, m) => {\n-                        self.guarantee_valid(expr.id,\n-                                             expr.span,\n-                                             cmt,\n-                                             m,\n-                                             r,\n-                                             AutoRef)\n-                    }\n-                    ty::AutoBorrowVec(r, m) | ty::AutoBorrowVecRef(r, m) => {\n-                        let cmt_index = mc.cat_index(expr, cmt, autoderefs+1);\n-                        self.guarantee_valid(expr.id,\n-                                             expr.span,\n-                                             cmt_index,\n-                                             m,\n-                                             r,\n-                                             AutoRef)\n-                    }\n-                    ty::AutoBorrowObj(r, m) => {\n-                        let cmt_deref = mc.cat_deref_obj(expr, cmt);\n-                        self.guarantee_valid(expr.id,\n-                                             expr.span,\n-                                             cmt_deref,\n-                                             m,\n-                                             r,\n-                                             AutoRef)\n-                    }\n-                    ty::AutoUnsafe(_) => {}\n-                }\n-            }\n-\n-            ty::AutoObject(..) => {\n-                // FIXME: Handle ~Trait to &Trait casts here?\n-            }\n-        }\n-    }\n-\n-    fn guarantee_captures(&mut self,\n-                          closure_expr: &ast::Expr) {\n-        for captured_var in self.bccx.capture_map.get(&closure_expr.id).iter() {\n-            match captured_var.mode {\n-                moves::CapCopy | moves::CapMove => { continue; }\n-                moves::CapRef => { }\n-            }\n-\n-            let var_id = ast_util::def_id_of_def(captured_var.def).node;\n-            let var_cmt = self.bccx.cat_captured_var(closure_expr.id,\n-                                                     closure_expr.span,\n-                                                     captured_var);\n-\n-            // Lookup the kind of borrow the callee requires\n-            let upvar_id = ty::UpvarId { var_id: var_id,\n-                                         closure_expr_id: closure_expr.id };\n-            let upvar_borrow = self.tcx().upvar_borrow_map.borrow()\n-                                   .get_copy(&upvar_id);\n-\n-            self.guarantee_valid_kind(closure_expr.id,\n-                                      closure_expr.span,\n-                                      var_cmt,\n-                                      upvar_borrow.kind,\n-                                      upvar_borrow.region,\n-                                      ClosureCapture(captured_var.span));\n-        }\n-    }\n-\n-    pub fn guarantee_valid(&mut self,\n-                           borrow_id: ast::NodeId,\n-                           borrow_span: Span,\n-                           cmt: mc::cmt,\n-                           req_mutbl: ast::Mutability,\n-                           loan_region: ty::Region,\n-                           cause: LoanCause) {\n-        self.guarantee_valid_kind(borrow_id,\n-                                  borrow_span,\n-                                  cmt,\n-                                  ty::BorrowKind::from_mutbl(req_mutbl),\n-                                  loan_region,\n-                                  cause);\n-    }\n-\n-    fn guarantee_valid_kind(&mut self,\n-                            borrow_id: ast::NodeId,\n-                            borrow_span: Span,\n-                            cmt: mc::cmt,\n-                            req_kind: ty::BorrowKind,\n-                            loan_region: ty::Region,\n-                            cause: LoanCause) {\n+    fn guarantee_valid(&mut self,\n+                       borrow_id: ast::NodeId,\n+                       borrow_span: Span,\n+                       cmt: mc::cmt,\n+                       req_kind: ty::BorrowKind,\n+                       loan_region: ty::Region,\n+                       cause: euv::LoanCause) {\n         /*!\n          * Guarantees that `addr_of(cmt)` will be valid for the duration of\n          * `static_scope_r`, or reports an error.  This may entail taking\n@@ -567,11 +234,9 @@ impl<'a> GatherLoanCtxt<'a> {\n             return;\n         }\n \n-        let root_ub = { *self.repeating_ids.last().unwrap() }; // FIXME(#5074)\n-\n         // Check that the lifetime of the borrow does not exceed\n         // the lifetime of the data being borrowed.\n-        if lifetime::guarantee_lifetime(self.bccx, self.item_ub, root_ub,\n+        if lifetime::guarantee_lifetime(self.bccx, self.item_ub,\n                                         borrow_span, cause, cmt.clone(), loan_region,\n                                         req_kind).is_err() {\n             return; // reported an error, no sense in reporting more.\n@@ -689,7 +354,7 @@ impl<'a> GatherLoanCtxt<'a> {\n \n         fn check_mutability(bccx: &BorrowckCtxt,\n                             borrow_span: Span,\n-                            cause: LoanCause,\n+                            cause: euv::LoanCause,\n                             cmt: mc::cmt,\n                             req_kind: ty::BorrowKind)\n                             -> Result<(),()> {\n@@ -804,146 +469,6 @@ impl<'a> GatherLoanCtxt<'a> {\n         }\n     }\n \n-    fn gather_fn_arg_patterns(&mut self,\n-                              decl: &ast::FnDecl,\n-                              body: &ast::Block) {\n-        /*!\n-         * Walks the patterns for fn arguments, checking that they\n-         * do not attempt illegal moves or create refs that outlive\n-         * the arguments themselves. Just a shallow wrapper around\n-         * `gather_pat()`.\n-         */\n-\n-        let mc = self.bccx.mc();\n-        for arg in decl.inputs.iter() {\n-            let arg_ty = ty::node_id_to_type(self.tcx(), arg.pat.id);\n-\n-            let arg_cmt = mc.cat_rvalue(\n-                arg.id,\n-                arg.pat.span,\n-                ty::ReScope(body.id), // Args live only as long as the fn body.\n-                arg_ty);\n-\n-            self.gather_pat(arg_cmt, arg.pat, None);\n-        }\n-    }\n-\n-    fn gather_pat(&mut self,\n-                  discr_cmt: mc::cmt,\n-                  root_pat: @ast::Pat,\n-                  arm_match_ids: Option<(ast::NodeId, ast::NodeId)>) {\n-        /*!\n-         * Walks patterns, examining the bindings to determine if they\n-         * cause borrows (`ref` bindings, vector patterns) or\n-         * moves (non-`ref` bindings with linear type).\n-         */\n-\n-        self.bccx.cat_pattern(discr_cmt, root_pat, |cmt, pat| {\n-            match pat.node {\n-              ast::PatIdent(bm, _, _) if self.pat_is_binding(pat) => {\n-                // Each match binding is effectively an assignment.\n-                let tcx = self.bccx.tcx;\n-                pat_util::pat_bindings(&tcx.def_map, pat, |_, id, span, _| {\n-                    gather_moves::gather_assignment(self.bccx,\n-                                                    &self.move_data,\n-                                                    id,\n-                                                    span,\n-                                                    Rc::new(LpVar(id)),\n-                                                    id);\n-                });\n-\n-                match bm {\n-                  ast::BindByRef(mutbl) => {\n-                    // ref x or ref x @ p --- creates a ptr which must\n-                    // remain valid for the scope of the match\n-\n-                    // find the region of the resulting pointer (note that\n-                    // the type of such a pattern will *always* be a\n-                    // region pointer)\n-                    let scope_r =\n-                        ty_region(self.tcx(), pat.span,\n-                                  ty::node_id_to_type(self.tcx(), pat.id));\n-\n-                    // if the scope of the region ptr turns out to be\n-                    // specific to this arm, wrap the categorization\n-                    // with a cat_discr() node.  There is a detailed\n-                    // discussion of the function of this node in\n-                    // `lifetime.rs`:\n-                    let cmt_discr = match arm_match_ids {\n-                        None => cmt,\n-                        Some((arm_id, match_id)) => {\n-                            let arm_scope = ty::ReScope(arm_id);\n-                            if self.bccx.is_subregion_of(scope_r, arm_scope) {\n-                                self.bccx.cat_discr(cmt, match_id)\n-                            } else {\n-                                cmt\n-                            }\n-                        }\n-                    };\n-                    self.guarantee_valid(pat.id,\n-                                         pat.span,\n-                                         cmt_discr,\n-                                         mutbl,\n-                                         scope_r,\n-                                         RefBinding);\n-                  }\n-                  ast::BindByValue(_) => {\n-                      // No borrows here, but there may be moves\n-                      if self.bccx.is_move(pat.id) {\n-                          gather_moves::gather_move_from_pat(\n-                              self.bccx, &self.move_data,\n-                              &self.move_error_collector, pat, cmt);\n-                      }\n-                  }\n-                }\n-              }\n-\n-              ast::PatVec(_, Some(slice_pat), _) => {\n-                  // The `slice_pat` here creates a slice into the\n-                  // original vector.  This is effectively a borrow of\n-                  // the elements of the vector being matched.\n-\n-                  let (slice_cmt, slice_borrow_kind, slice_r) = {\n-                      match self.bccx.mc().cat_slice_pattern(cmt, slice_pat) {\n-                          Ok(v) => v,\n-                          Err(()) => {\n-                              self.tcx().sess.span_bug(slice_pat.span,\n-                                                       \"Err from mc\")\n-                          }\n-                      }\n-                  };\n-\n-                  // Note: We declare here that the borrow occurs upon\n-                  // entering the `[...]` pattern. This implies that\n-                  // something like `[a, ..b]` where `a` is a move is\n-                  // illegal, because the borrow is already in effect.\n-                  // In fact such a move would be safe-ish, but it\n-                  // effectively *requires* that we use the nulling\n-                  // out semantics to indicate when a value has been\n-                  // moved, which we are trying to move away from.\n-                  // Otherwise, how can we indicate that the first\n-                  // element in the vector has been moved?\n-                  // Eventually, we could perhaps modify this rule to\n-                  // permit `[..a, b]` where `b` is a move, because in\n-                  // that case we can adjust the length of the\n-                  // original vec accordingly, but we'd have to make\n-                  // trans do the right thing, and it would only work\n-                  // for `~` vectors. It seems simpler to just require\n-                  // that people call `vec.pop()` or `vec.unshift()`.\n-                  self.guarantee_valid(pat.id, pat.span,\n-                                       slice_cmt, slice_borrow_kind, slice_r,\n-                                       RefBinding);\n-              }\n-\n-              _ => {}\n-            }\n-        })\n-    }\n-\n-    pub fn pat_is_binding(&self, pat: &ast::Pat) -> bool {\n-        pat_util::pat_is_binding(&self.bccx.tcx.def_map, pat)\n-    }\n-\n     pub fn report_potential_errors(&self) {\n         self.move_error_collector.report_potential_errors(self.bccx);\n     }\n@@ -955,7 +480,6 @@ impl<'a> GatherLoanCtxt<'a> {\n /// sure the loans being taken are sound.\n struct StaticInitializerCtxt<'a> {\n     bccx: &'a BorrowckCtxt<'a>,\n-    id_range: IdRange,\n     item_ub: ast::NodeId,\n }\n \n@@ -966,7 +490,8 @@ impl<'a> visit::Visitor<()> for StaticInitializerCtxt<'a> {\n                 let base_cmt = self.bccx.cat_expr(base);\n                 let borrow_kind = ty::BorrowKind::from_mutbl(mutbl);\n                 // Check that we don't allow borrows of unsafe static items.\n-                if check_aliasability(self.bccx, ex.span, AddrOf, base_cmt, borrow_kind).is_err() {\n+                if check_aliasability(self.bccx, ex.span, euv::AddrOf,\n+                                      base_cmt, borrow_kind).is_err() {\n                     return; // reported an error, no sense in reporting more.\n                 }\n             }\n@@ -983,7 +508,6 @@ pub fn gather_loans_in_static_initializer(bccx: &mut BorrowckCtxt, expr: &ast::E\n \n     let mut sicx = StaticInitializerCtxt {\n         bccx: bccx,\n-        id_range: IdRange::max(),\n         item_ub: expr.id,\n     };\n "}, {"sha": "4662074aa47fb6302eb8c36e648f4e16d0e30d05", "filename": "src/librustc/middle/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=96dfed2b62c6e84a542f9a170133ec528e2191c2", "patch": "@@ -100,17 +100,20 @@ fn group_errors_with_same_origin(errors: &Vec<MoveError>)\n     fn append_to_grouped_errors(grouped_errors: &mut Vec<GroupedMoveErrors>,\n                                 error: &MoveError) {\n         let move_from_id = error.move_from.id;\n+        debug!(\"append_to_grouped_errors(move_from_id={})\", move_from_id);\n         let move_to = if error.move_to.is_some() {\n             vec!(error.move_to.clone().unwrap())\n         } else {\n             Vec::new()\n         };\n         for ge in grouped_errors.mut_iter() {\n             if move_from_id == ge.move_from.id && error.move_to.is_some() {\n+                debug!(\"appending move_to to list\");\n                 ge.move_to_places.push_all_move(move_to);\n                 return\n             }\n         }\n+        debug!(\"found a new move from location\");\n         grouped_errors.push(GroupedMoveErrors {\n             move_from: error.move_from.clone(),\n             move_to_places: move_to"}, {"sha": "552381e4216538bd7d6bb7078a3f0bc2a9fceffd", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=96dfed2b62c6e84a542f9a170133ec528e2191c2", "patch": "@@ -13,6 +13,7 @@\n  */\n \n use middle::borrowck::*;\n+use euv = middle::expr_use_visitor;\n use mc = middle::mem_categorization;\n use middle::ty;\n use syntax::codemap::Span;\n@@ -27,7 +28,7 @@ pub enum RestrictionResult {\n \n pub fn compute_restrictions(bccx: &BorrowckCtxt,\n                             span: Span,\n-                            cause: LoanCause,\n+                            cause: euv::LoanCause,\n                             cmt: mc::cmt,\n                             loan_region: ty::Region,\n                             restr: RestrictionSet) -> RestrictionResult {\n@@ -50,7 +51,7 @@ struct RestrictionsContext<'a> {\n     span: Span,\n     cmt_original: mc::cmt,\n     loan_region: ty::Region,\n-    cause: LoanCause,\n+    cause: euv::LoanCause,\n }\n \n impl<'a> RestrictionsContext<'a> {"}, {"sha": "4efb0e44e8ec0096c0eb5951f7dd83101e48c7f8", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 29, "deletions": 77, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=96dfed2b62c6e84a542f9a170133ec528e2191c2", "patch": "@@ -12,16 +12,14 @@\n \n #![allow(non_camel_case_types)]\n \n-use mc = middle::mem_categorization;\n-use middle::ty;\n-use middle::typeck;\n-use middle::moves;\n use middle::dataflow::DataFlowContext;\n use middle::dataflow::DataFlowOperator;\n-use util::nodemap::{NodeMap, NodeSet};\n+use euv = middle::expr_use_visitor;\n+use mc = middle::mem_categorization;\n+use middle::ty;\n use util::ppaux::{note_and_explain_region, Repr, UserString};\n \n-use std::cell::{Cell, RefCell};\n+use std::cell::{Cell};\n use std::ops::{BitOr, BitAnd};\n use std::rc::Rc;\n use std::strbuf::StrBuf;\n@@ -75,13 +73,9 @@ impl<'a> Visitor<()> for BorrowckCtxt<'a> {\n }\n \n pub fn check_crate(tcx: &ty::ctxt,\n-                   moves_map: &NodeSet,\n-                   capture_map: &moves::CaptureMap,\n                    krate: &ast::Crate) {\n     let mut bccx = BorrowckCtxt {\n         tcx: tcx,\n-        moves_map: moves_map,\n-        capture_map: capture_map,\n         stats: @BorrowStats {\n             loaned_paths_same: Cell::new(0),\n             loaned_paths_imm: Cell::new(0),\n@@ -135,7 +129,8 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n     debug!(\"borrowck_fn(id={})\", id);\n \n     // Check the body of fn items.\n-    let (id_range, all_loans, move_data) =\n+    let id_range = ast_util::compute_id_range_for_fn_body(fk, decl, body, sp, id);\n+    let (all_loans, move_data) =\n         gather_loans::gather_loans_in_fn(this, decl, body);\n     let mut loan_dfcx =\n         DataFlowContext::new(this.tcx,\n@@ -164,8 +159,6 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n \n pub struct BorrowckCtxt<'a> {\n     tcx: &'a ty::ctxt,\n-    moves_map: &'a NodeSet,\n-    capture_map: &'a moves::CaptureMap,\n \n     // Statistics:\n     stats: @BorrowStats\n@@ -199,16 +192,7 @@ pub struct Loan {\n     gen_scope: ast::NodeId,\n     kill_scope: ast::NodeId,\n     span: Span,\n-    cause: LoanCause,\n-}\n-\n-#[deriving(Eq)]\n-pub enum LoanCause {\n-    ClosureCapture(Span),\n-    AddrOf,\n-    AutoRef,\n-    RefBinding,\n-    ClosureInvocation,\n+    cause: euv::LoanCause,\n }\n \n #[deriving(Eq, TotalEq, Hash)]\n@@ -341,14 +325,14 @@ pub enum bckerr_code {\n #[deriving(Eq)]\n pub struct BckError {\n     span: Span,\n-    cause: LoanCause,\n+    cause: euv::LoanCause,\n     cmt: mc::cmt,\n     code: bckerr_code\n }\n \n pub enum AliasableViolationKind {\n     MutabilityViolation,\n-    BorrowViolation(LoanCause)\n+    BorrowViolation(euv::LoanCause)\n }\n \n pub enum MovedValueUseKind {\n@@ -370,14 +354,8 @@ impl<'a> BorrowckCtxt<'a> {\n         self.tcx.region_maps.is_subscope_of(r_sub, r_sup)\n     }\n \n-    pub fn is_move(&self, id: ast::NodeId) -> bool {\n-        self.moves_map.contains(&id)\n-    }\n-\n-    pub fn mc(&self) -> mc::MemCategorizationContext<&'a ty::ctxt> {\n-        mc::MemCategorizationContext {\n-            typer: self.tcx,\n-        }\n+    pub fn mc(&self) -> mc::MemCategorizationContext<'a,ty::ctxt> {\n+        mc::MemCategorizationContext::new(self.tcx)\n     }\n \n     pub fn cat_expr(&self, expr: &ast::Expr) -> mc::cmt {\n@@ -439,14 +417,15 @@ impl<'a> BorrowckCtxt<'a> {\n     }\n \n     pub fn cat_captured_var(&self,\n-                            id: ast::NodeId,\n-                            span: Span,\n-                            captured_var: &moves::CaptureVar) -> mc::cmt {\n+                            closure_id: ast::NodeId,\n+                            closure_span: Span,\n+                            upvar_def: ast::Def)\n+                            -> mc::cmt {\n         // Create the cmt for the variable being borrowed, from the\n         // caller's perspective\n-        let var_id = ast_util::def_id_of_def(captured_var.def).node;\n+        let var_id = ast_util::def_id_of_def(upvar_def).node;\n         let var_ty = ty::node_id_to_type(self.tcx, var_id);\n-        self.cat_def(id, span, var_ty, captured_var.def)\n+        self.cat_def(closure_id, closure_span, var_ty, upvar_def)\n     }\n \n     pub fn cat_discr(&self, cmt: mc::cmt, match_id: ast::NodeId) -> mc::cmt {\n@@ -604,13 +583,16 @@ impl<'a> BorrowckCtxt<'a> {\n                 };\n \n                 match err.cause {\n-                    ClosureCapture(_) => {\n+                    euv::ClosureCapture(_) => {\n                         format!(\"closure cannot assign to {}\", descr)\n                     }\n-                    AddrOf | RefBinding | AutoRef => {\n+                    euv::OverloadedOperator |\n+                    euv::AddrOf |\n+                    euv::RefBinding |\n+                    euv::AutoRef => {\n                         format!(\"cannot borrow {} as mutable\", descr)\n                     }\n-                    ClosureInvocation => {\n+                    euv::ClosureInvocation => {\n                         self.tcx.sess.span_bug(err.span,\n                             \"err_mutbl with a closure invocation\");\n                     }\n@@ -644,7 +626,7 @@ impl<'a> BorrowckCtxt<'a> {\n             MutabilityViolation => {\n                 \"cannot assign to data\"\n             }\n-            BorrowViolation(ClosureCapture(_)) => {\n+            BorrowViolation(euv::ClosureCapture(_)) => {\n                 // I don't think we can get aliasability violations\n                 // with closure captures, so no need to come up with a\n                 // good error message. The reason this cannot happen\n@@ -654,13 +636,14 @@ impl<'a> BorrowckCtxt<'a> {\n                     span,\n                     \"aliasability violation with closure\");\n             }\n-            BorrowViolation(AddrOf) |\n-            BorrowViolation(AutoRef) |\n-            BorrowViolation(RefBinding) => {\n+            BorrowViolation(euv::OverloadedOperator) |\n+            BorrowViolation(euv::AddrOf) |\n+            BorrowViolation(euv::AutoRef) |\n+            BorrowViolation(euv::RefBinding) => {\n                 \"cannot borrow data mutably\"\n             }\n \n-            BorrowViolation(ClosureInvocation) => {\n+            BorrowViolation(euv::ClosureInvocation) => {\n                 \"closure invocation\"\n             }\n         };\n@@ -839,34 +822,3 @@ impl Repr for LoanPath {\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n-impl<'a> mc::Typer for &'a ty::ctxt {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n-        *self\n-    }\n-\n-    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<ty::t> {\n-        Ok(ty::node_id_to_type(*self, id))\n-    }\n-\n-    fn node_method_ty(&self, method_call: typeck::MethodCall) -> Option<ty::t> {\n-        self.method_map.borrow().find(&method_call).map(|method| method.ty)\n-    }\n-\n-    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment>> {\n-        &self.adjustments\n-    }\n-\n-    fn is_method_call(&self, id: ast::NodeId) -> bool {\n-        self.method_map.borrow().contains_key(&typeck::MethodCall::expr(id))\n-    }\n-\n-    fn temporary_scope(&self, id: ast::NodeId) -> Option<ast::NodeId> {\n-        self.region_maps.temporary_scope(id)\n-    }\n-\n-    fn upvar_borrow(&self, id: ty::UpvarId) -> ty::UpvarBorrow {\n-        self.upvar_borrow_map.borrow().get_copy(&id)\n-    }\n-}"}, {"sha": "2ae07e9a48034f316253a470bfe4f3a5d018c715", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=96dfed2b62c6e84a542f9a170133ec528e2191c2", "patch": "@@ -22,6 +22,7 @@ use collections::{HashMap, HashSet};\n use middle::borrowck::*;\n use middle::dataflow::DataFlowContext;\n use middle::dataflow::DataFlowOperator;\n+use euv = middle::expr_use_visitor;\n use middle::ty;\n use syntax::ast;\n use syntax::ast_util;\n@@ -357,7 +358,7 @@ impl MoveData {\n                           assign_id: ast::NodeId,\n                           span: Span,\n                           assignee_id: ast::NodeId,\n-                          is_also_move: bool) {\n+                          mode: euv::MutateMode) {\n         /*!\n          * Adds a new record for an assignment to `lp` that occurs at\n          * location `id` with the given `span`.\n@@ -368,8 +369,11 @@ impl MoveData {\n \n         let path_index = self.move_path(tcx, lp.clone());\n \n-        if !is_also_move {\n-            self.assignee_ids.borrow_mut().insert(assignee_id);\n+        match mode {\n+            euv::JustWrite => {\n+                self.assignee_ids.borrow_mut().insert(assignee_id);\n+            }\n+            euv::WriteAndRead => { }\n         }\n \n         let assignment = Assignment {"}, {"sha": "3e7d1ef6a163233420ad8b381f8bf65a73c5a158", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=96dfed2b62c6e84a542f9a170133ec528e2191c2", "patch": "@@ -15,7 +15,6 @@ use middle::const_eval::{eval_const_expr, const_val, const_bool, const_float};\n use middle::pat_util::*;\n use middle::ty::*;\n use middle::ty;\n-use util::nodemap::NodeSet;\n use util::ppaux::ty_to_str;\n \n use std::cmp;\n@@ -29,7 +28,6 @@ use syntax::visit::{Visitor, FnKind};\n \n struct MatchCheckCtxt<'a> {\n     tcx: &'a ty::ctxt,\n-    moves_map: &'a NodeSet\n }\n \n impl<'a> Visitor<()> for MatchCheckCtxt<'a> {\n@@ -45,11 +43,9 @@ impl<'a> Visitor<()> for MatchCheckCtxt<'a> {\n }\n \n pub fn check_crate(tcx: &ty::ctxt,\n-                   moves_map: &NodeSet,\n                    krate: &Crate) {\n     let mut cx = MatchCheckCtxt {\n         tcx: tcx,\n-        moves_map: moves_map\n     };\n \n     visit::walk_crate(&mut cx, krate, ());\n@@ -931,22 +927,18 @@ fn is_refutable(cx: &MatchCheckCtxt, pat: &Pat) -> bool {\n // Legality of move bindings checking\n \n fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n-                                       has_guard: bool,\n-                                       pats: &[@Pat]) {\n+                                   has_guard: bool,\n+                                   pats: &[@Pat]) {\n     let tcx = cx.tcx;\n     let def_map = &tcx.def_map;\n     let mut by_ref_span = None;\n-    let mut any_by_move = false;\n     for pat in pats.iter() {\n-        pat_bindings(def_map, *pat, |bm, id, span, _path| {\n+        pat_bindings(def_map, *pat, |bm, _, span, _path| {\n             match bm {\n                 BindByRef(_) => {\n                     by_ref_span = Some(span);\n                 }\n                 BindByValue(_) => {\n-                    if cx.moves_map.contains(&id) {\n-                        any_by_move = true;\n-                    }\n                 }\n             }\n         })\n@@ -975,16 +967,18 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n         }\n     };\n \n-    if !any_by_move { return; } // pointless micro-optimization\n     for pat in pats.iter() {\n         walk_pat(*pat, |p| {\n             if pat_is_binding(def_map, p) {\n                 match p.node {\n-                    PatIdent(_, _, sub) => {\n-                        if cx.moves_map.contains(&p.id) {\n+                    PatIdent(BindByValue(_), _, sub) => {\n+                        let pat_ty = ty::node_id_to_type(tcx, p.id);\n+                        if ty::type_moves_by_default(tcx, pat_ty) {\n                             check_move(p, sub);\n                         }\n                     }\n+                    PatIdent(BindByRef(_), _, _) => {\n+                    }\n                     _ => {\n                         cx.tcx.sess.span_bug(\n                             p.span,"}, {"sha": "56284984a243c7e1c681dbf1cde40f03a52809a2", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=96dfed2b62c6e84a542f9a170133ec528e2191c2", "patch": "@@ -15,15 +15,14 @@ use middle::astencode;\n \n use middle::ty;\n use middle::typeck::astconv;\n-use util::nodemap::{DefIdMap, NodeMap};\n+use util::nodemap::{DefIdMap};\n \n use syntax::ast::*;\n use syntax::parse::token::InternedString;\n use syntax::visit::Visitor;\n use syntax::visit;\n use syntax::{ast, ast_map, ast_util};\n \n-use std::cell::RefCell;\n use std::rc::Rc;\n \n //\n@@ -125,11 +124,8 @@ pub fn lookup_variant_by_id(tcx: &ty::ctxt,\n             Some(&e) => return e,\n             None => {}\n         }\n-        let maps = astencode::Maps {\n-            capture_map: RefCell::new(NodeMap::new())\n-        };\n         let e = match csearch::maybe_get_item_ast(tcx, enum_def,\n-            |a, b, c, d| astencode::decode_inlined_item(a, b, &maps, c, d)) {\n+            |a, b, c, d| astencode::decode_inlined_item(a, b, c, d)) {\n             csearch::found(ast::IIItem(item)) => match item.node {\n                 ItemEnum(ast::EnumDef { variants: ref variants }, _) => {\n                     variant_expr(variants.as_slice(), variant_def.node)\n@@ -163,11 +159,8 @@ pub fn lookup_const_by_id(tcx: &ty::ctxt, def_id: ast::DefId)\n             Some(&e) => return e,\n             None => {}\n         }\n-        let maps = astencode::Maps {\n-            capture_map: RefCell::new(NodeMap::new())\n-        };\n         let e = match csearch::maybe_get_item_ast(tcx, def_id,\n-            |a, b, c, d| astencode::decode_inlined_item(a, b, &maps, c, d)) {\n+            |a, b, c, d| astencode::decode_inlined_item(a, b, c, d)) {\n             csearch::found(ast::IIItem(item)) => match item.node {\n                 ItemStatic(_, ast::MutImmutable, const_expr) => Some(const_expr),\n                 _ => None"}, {"sha": "17f423aa5926fa4e37bb25ae60e4a6ccce399725", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "added", "additions": 868, "deletions": 0, "changes": 868, "blob_url": "https://github.com/rust-lang/rust/blob/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=96dfed2b62c6e84a542f9a170133ec528e2191c2", "patch": "@@ -0,0 +1,868 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * A different sort of visitor for walking fn bodies.  Unlike the\n+ * normal visitor, which just walks the entire body in one shot, the\n+ * `ExprUseVisitor` determines how expressions are being used.\n+ */\n+\n+use mc = middle::mem_categorization;\n+use middle::freevars;\n+use middle::pat_util;\n+use middle::ty;\n+use middle::typeck;\n+use syntax::ast;\n+use syntax::ast_util;\n+use syntax::codemap::{Span};\n+use util::ppaux::Repr;\n+\n+///////////////////////////////////////////////////////////////////////////\n+// The Delegate trait\n+//\n+// This trait defines the callbacks you can expect to receiver when\n+// employing the ExprUseVisitor.\n+\n+#[deriving(Eq)]\n+pub enum LoanCause {\n+    ClosureCapture(Span),\n+    AddrOf,\n+    AutoRef,\n+    RefBinding,\n+    OverloadedOperator,\n+    ClosureInvocation\n+}\n+\n+#[deriving(Eq,Show)]\n+pub enum ConsumeMode {\n+    Copy,    // reference to x where x has a type that copies\n+    Move,    // reference to x where x has a type that moves\n+}\n+\n+#[deriving(Eq,Show)]\n+pub enum MutateMode {\n+    JustWrite,    // x = y\n+    WriteAndRead, // x += y\n+}\n+\n+pub trait Delegate {\n+    // The value found at `cmt` is either copied or moved, depending\n+    // on mode.\n+    fn consume(&mut self,\n+               _consume_id: ast::NodeId,\n+               _consume_span: Span,\n+               _cmt: mc::cmt,\n+               _mode: ConsumeMode)\n+    { }\n+\n+    // The value found at `cmt` is either copied or moved via the\n+    // pattern binding `consume_pat`, depending on mode.\n+    fn consume_pat(&mut self,\n+                   _consume_pat: &ast::Pat,\n+                   _cmt: mc::cmt,\n+                   _mode: ConsumeMode)\n+    { }\n+\n+    // The value found at `borrow` is being borrowed at the point\n+    // `borrow_id` for the region `loan_region` with kind `bk`.\n+    fn borrow(&mut self,\n+              _borrow_id: ast::NodeId,\n+              _borrow_span: Span,\n+              _cmt: mc::cmt,\n+              _loan_region: ty::Region,\n+              _bk: ty::BorrowKind,\n+              _loan_cause: LoanCause)\n+    { }\n+\n+    // The local variable `id` is declared but not initialized.\n+    fn decl_without_init(&mut self,\n+                         _id: ast::NodeId,\n+                         _span: Span)\n+    { }\n+\n+    // The path at `cmt` is being assigned to.\n+    fn mutate(&mut self,\n+              _assignment_id: ast::NodeId,\n+              _assignment_span: Span,\n+              _assignee_cmt: mc::cmt,\n+              _mode: MutateMode)\n+    { }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// The ExprUseVisitor type\n+//\n+// This is the code that actually walks the tree. Like\n+// mem_categorization, it requires a TYPER, which is a type that\n+// supplies types from the tree. After type checking is complete, you\n+// can just use the tcx as the typer.\n+\n+pub struct ExprUseVisitor<'d,'t,D,TYPER> {\n+    typer: &'t TYPER,\n+    mc: mc::MemCategorizationContext<'t,TYPER>,\n+    delegate: &'d mut D,\n+}\n+\n+// If the TYPER results in an error, it's because the type check\n+// failed (or will fail, when the error is uncovered and reported\n+// during writeback). In this case, we just ignore this part of the\n+// code.\n+//\n+// Note that this macro appears similar to try!(), but, unlike try!(),\n+// it does not propagate the error.\n+macro_rules! ignore_err(\n+    ($inp: expr) => (\n+        match $inp {\n+            Ok(v) => v,\n+            Err(()) => return\n+        }\n+    )\n+)\n+\n+impl<'d,'t,D:Delegate,TYPER:mc::Typer> ExprUseVisitor<'d,'t,D,TYPER> {\n+    pub fn new(delegate: &'d mut D,\n+               typer: &'t TYPER)\n+               -> ExprUseVisitor<'d,'t,D,TYPER> {\n+        ExprUseVisitor { typer: typer,\n+                         mc: mc::MemCategorizationContext::new(typer),\n+                         delegate: delegate }\n+    }\n+\n+    pub fn walk_fn(&mut self,\n+                   decl: &ast::FnDecl,\n+                   body: &ast::Block) {\n+        self.walk_arg_patterns(decl, body);\n+        self.walk_block(body);\n+    }\n+\n+    fn walk_arg_patterns(&mut self,\n+                         decl: &ast::FnDecl,\n+                         body: &ast::Block) {\n+        for arg in decl.inputs.iter() {\n+            let arg_ty = ty::node_id_to_type(self.tcx(), arg.pat.id);\n+\n+            let arg_cmt = self.mc.cat_rvalue(\n+                arg.id,\n+                arg.pat.span,\n+                ty::ReScope(body.id), // Args live only as long as the fn body.\n+                arg_ty);\n+\n+            self.walk_pat(arg_cmt, arg.pat);\n+        }\n+    }\n+\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+        self.typer.tcx()\n+    }\n+\n+    fn delegate_consume(&mut self,\n+                        consume_id: ast::NodeId,\n+                        consume_span: Span,\n+                        cmt: mc::cmt) {\n+        let mode = copy_or_move(self.tcx(), cmt.ty);\n+        self.delegate.consume(consume_id, consume_span, cmt, mode);\n+    }\n+\n+    fn consume_exprs(&mut self, exprs: &Vec<@ast::Expr>) {\n+        for &expr in exprs.iter() {\n+            self.consume_expr(expr);\n+        }\n+    }\n+\n+    fn consume_expr(&mut self, expr: &ast::Expr) {\n+        debug!(\"consume_expr(expr={})\", expr.repr(self.tcx()));\n+\n+        let cmt = ignore_err!(self.mc.cat_expr(expr));\n+        self.delegate_consume(expr.id, expr.span, cmt);\n+\n+        match expr.node {\n+            ast::ExprParen(subexpr) => {\n+                // Argh but is ExprParen horrible. So, if we consume\n+                // `(x)`, that generally is also consuming `x`, UNLESS\n+                // there are adjustments on the `(x)` expression\n+                // (e.g., autoderefs and autorefs).\n+                if self.typer.adjustments().borrow().contains_key(&expr.id) {\n+                    self.walk_expr(expr);\n+                } else {\n+                    self.consume_expr(subexpr);\n+                }\n+            }\n+\n+            _ => {\n+                self.walk_expr(expr)\n+            }\n+        }\n+    }\n+\n+    fn mutate_expr(&mut self,\n+                   assignment_expr: &ast::Expr,\n+                   expr: &ast::Expr,\n+                   mode: MutateMode) {\n+        let cmt = ignore_err!(self.mc.cat_expr(expr));\n+        self.delegate.mutate(assignment_expr.id, assignment_expr.span, cmt, mode);\n+        self.walk_expr(expr);\n+    }\n+\n+    fn borrow_expr(&mut self,\n+                   expr: &ast::Expr,\n+                   r: ty::Region,\n+                   bk: ty::BorrowKind,\n+                   cause: LoanCause) {\n+        debug!(\"borrow_expr(expr={}, r={}, bk={})\",\n+               expr.repr(self.tcx()), r.repr(self.tcx()), bk.repr(self.tcx()));\n+\n+        let cmt = ignore_err!(self.mc.cat_expr(expr));\n+        self.delegate.borrow(expr.id, expr.span, cmt, r, bk, cause);\n+\n+        // Note: Unlike consume, we can ignore ExprParen. cat_expr\n+        // already skips over them, and walk will uncover any\n+        // attachments or whatever.\n+        self.walk_expr(expr)\n+    }\n+\n+    fn select_from_expr(&mut self, expr: &ast::Expr) {\n+        self.walk_expr(expr)\n+    }\n+\n+    fn walk_expr(&mut self, expr: &ast::Expr) {\n+        debug!(\"walk_expr(expr={})\", expr.repr(self.tcx()));\n+\n+        self.walk_adjustment(expr);\n+\n+        match expr.node {\n+            ast::ExprParen(subexpr) => {\n+                self.walk_expr(subexpr)\n+            }\n+\n+            ast::ExprPath(..) => { }\n+\n+            ast::ExprUnary(ast::UnDeref, base) => {      // *base\n+                if !self.walk_overloaded_operator(expr, base, []) {\n+                    self.select_from_expr(base);\n+                }\n+            }\n+\n+            ast::ExprField(base, _, _) => {         // base.f\n+                self.select_from_expr(base);\n+            }\n+\n+            ast::ExprIndex(lhs, rhs) => {           // lhs[rhs]\n+                if !self.walk_overloaded_operator(expr, lhs, [rhs]) {\n+                    self.select_from_expr(lhs);\n+                    self.consume_expr(rhs);\n+                }\n+            }\n+\n+            ast::ExprCall(callee, ref args) => {    // callee(args)\n+                self.walk_callee(expr, callee);\n+                self.consume_exprs(args);\n+            }\n+\n+            ast::ExprMethodCall(_, _, ref args) => { // callee.m(args)\n+                self.consume_exprs(args);\n+            }\n+\n+            ast::ExprStruct(_, ref fields, opt_with) => {\n+                self.walk_struct_expr(expr, fields, opt_with);\n+            }\n+\n+            ast::ExprTup(ref exprs) => {\n+                self.consume_exprs(exprs);\n+            }\n+\n+            ast::ExprIf(cond_expr, then_blk, opt_else_expr) => {\n+                self.consume_expr(cond_expr);\n+                self.walk_block(then_blk);\n+                for else_expr in opt_else_expr.iter() {\n+                    self.consume_expr(*else_expr);\n+                }\n+            }\n+\n+            ast::ExprMatch(discr, ref arms) => {\n+                // treatment of the discriminant is handled while\n+                // walking the arms:\n+                self.walk_expr(discr);\n+                let discr_cmt = ignore_err!(self.mc.cat_expr(discr));\n+                for arm in arms.iter() {\n+                    self.walk_arm(discr_cmt.clone(), arm);\n+                }\n+            }\n+\n+            ast::ExprVec(ref exprs) => {\n+                self.consume_exprs(exprs);\n+            }\n+\n+            ast::ExprAddrOf(m, base) => {   // &base\n+                // make sure that the thing we are pointing out stays valid\n+                // for the lifetime `scope_r` of the resulting ptr:\n+                let expr_ty = ty::expr_ty(self.tcx(), expr);\n+                if !ty::type_is_bot(expr_ty) {\n+                    let r = ty::ty_region(self.tcx(), expr.span, expr_ty);\n+                    let bk = ty::BorrowKind::from_mutbl(m);\n+                    self.borrow_expr(base, r, bk, AddrOf);\n+                } else {\n+                    self.walk_expr(base);\n+                }\n+            }\n+\n+            ast::ExprInlineAsm(ref ia) => {\n+                for &(_, input) in ia.inputs.iter() {\n+                    self.consume_expr(input);\n+                }\n+\n+                for &(_, output) in ia.outputs.iter() {\n+                    self.mutate_expr(expr, output, JustWrite);\n+                }\n+            }\n+\n+            ast::ExprBreak(..) |\n+            ast::ExprAgain(..) |\n+            ast::ExprLit(..) => {}\n+\n+            ast::ExprLoop(blk, _) => {\n+                self.walk_block(blk);\n+            }\n+\n+            ast::ExprWhile(cond_expr, blk) => {\n+                self.consume_expr(cond_expr);\n+                self.walk_block(blk);\n+            }\n+\n+            ast::ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n+\n+            ast::ExprUnary(_, lhs) => {\n+                if !self.walk_overloaded_operator(expr, lhs, []) {\n+                    self.consume_expr(lhs);\n+                }\n+            }\n+\n+            ast::ExprBinary(_, lhs, rhs) => {\n+                if !self.walk_overloaded_operator(expr, lhs, [rhs]) {\n+                    self.consume_expr(lhs);\n+                    self.consume_expr(rhs);\n+                }\n+            }\n+\n+            ast::ExprBlock(blk) => {\n+                self.walk_block(blk);\n+            }\n+\n+            ast::ExprRet(ref opt_expr) => {\n+                for expr in opt_expr.iter() {\n+                    self.consume_expr(*expr);\n+                }\n+            }\n+\n+            ast::ExprAssign(lhs, rhs) => {\n+                self.mutate_expr(expr, lhs, JustWrite);\n+                self.consume_expr(rhs);\n+            }\n+\n+            ast::ExprCast(base, _) => {\n+                self.consume_expr(base);\n+            }\n+\n+            ast::ExprAssignOp(_, lhs, rhs) => {\n+                // FIXME(#4712) --- Overloaded operators?\n+                //\n+                // if !self.walk_overloaded_operator(expr, [lhs, rhs])\n+                // {\n+                self.mutate_expr(expr, lhs, WriteAndRead);\n+                self.consume_expr(rhs);\n+                // }\n+            }\n+\n+            ast::ExprRepeat(base, count) => {\n+                self.consume_expr(base);\n+                self.consume_expr(count);\n+            }\n+\n+            ast::ExprFnBlock(..) |\n+            ast::ExprProc(..) => {\n+                self.walk_captures(expr)\n+            }\n+\n+            ast::ExprVstore(base, _) => {\n+                self.consume_expr(base);\n+            }\n+\n+            ast::ExprBox(place, base) => {\n+                self.consume_expr(place);\n+                self.consume_expr(base);\n+            }\n+\n+            ast::ExprMac(..) => {\n+                self.tcx().sess.span_bug(\n+                    expr.span,\n+                    \"macro expression remains after expansion\");\n+            }\n+        }\n+    }\n+\n+    fn walk_callee(&mut self, call: &ast::Expr, callee: &ast::Expr) {\n+        let callee_ty = ty::expr_ty_adjusted(self.tcx(), callee);\n+        debug!(\"walk_callee: callee={} callee_ty={}\",\n+               callee.repr(self.tcx()), callee_ty.repr(self.tcx()));\n+        match ty::get(callee_ty).sty {\n+            ty::ty_bare_fn(..) => {\n+                self.consume_expr(callee);\n+            }\n+            ty::ty_closure(ref f) => {\n+                match f.onceness {\n+                    ast::Many => {\n+                        self.borrow_expr(callee,\n+                                         ty::ReScope(call.id),\n+                                         ty::UniqueImmBorrow,\n+                                         ClosureInvocation);\n+                    }\n+                    ast::Once => {\n+                        self.consume_expr(callee);\n+                    }\n+                }\n+            }\n+            _ => {\n+                self.tcx().sess.span_bug(\n+                    callee.span,\n+                    format!(\"unxpected callee type {}\",\n+                            callee_ty.repr(self.tcx())));\n+            }\n+        }\n+    }\n+\n+    fn walk_stmt(&mut self, stmt: &ast::Stmt) {\n+        match stmt.node {\n+            ast::StmtDecl(decl, _) => {\n+                match decl.node {\n+                    ast::DeclLocal(local) => {\n+                        self.walk_local(local);\n+                    }\n+\n+                    ast::DeclItem(_) => {\n+                        // we don't visit nested items in this visitor,\n+                        // only the fn body we were given.\n+                    }\n+                }\n+            }\n+\n+            ast::StmtExpr(expr, _) |\n+            ast::StmtSemi(expr, _) => {\n+                self.consume_expr(expr);\n+            }\n+\n+            ast::StmtMac(..) => {\n+                self.tcx().sess.span_bug(\n+                    stmt.span,\n+                    format!(\"unexpanded stmt macro\"));\n+            }\n+        }\n+    }\n+\n+    fn walk_local(&mut self, local: @ast::Local) {\n+        match local.init {\n+            None => {\n+                let delegate = &mut self.delegate;\n+                pat_util::pat_bindings(&self.typer.tcx().def_map, local.pat, |_, id, span, _| {\n+                    delegate.decl_without_init(id, span);\n+                })\n+            }\n+\n+            Some(expr) => {\n+                // Variable declarations with\n+                // initializers are considered\n+                // \"assigns\", which is handled by\n+                // `walk_pat`:\n+                self.walk_expr(expr);\n+                let init_cmt = ignore_err!(self.mc.cat_expr(expr));\n+                self.walk_pat(init_cmt, local.pat);\n+            }\n+        }\n+    }\n+\n+    fn walk_block(&mut self, blk: &ast::Block) {\n+        /*!\n+         * Indicates that the value of `blk` will be consumed,\n+         * meaning either copied or moved depending on its type.\n+         */\n+\n+        debug!(\"walk_block(blk.id={:?})\", blk.id);\n+\n+        for stmt in blk.stmts.iter() {\n+            self.walk_stmt(*stmt);\n+        }\n+\n+        for tail_expr in blk.expr.iter() {\n+            self.consume_expr(*tail_expr);\n+        }\n+    }\n+\n+    fn walk_struct_expr(&mut self,\n+                        _expr: &ast::Expr,\n+                        fields: &Vec<ast::Field>,\n+                        opt_with: Option<@ast::Expr>) {\n+        // Consume the expressions supplying values for each field.\n+        for field in fields.iter() {\n+            self.consume_expr(field.expr);\n+        }\n+\n+        let with_expr = match opt_with {\n+            Some(w) => { w }\n+            None => { return; }\n+        };\n+\n+        let with_cmt = ignore_err!(self.mc.cat_expr(with_expr));\n+\n+        // Select just those fields of the `with`\n+        // expression that will actually be used\n+        let with_fields = match ty::get(with_cmt.ty).sty {\n+            ty::ty_struct(did, ref substs) => {\n+                ty::struct_fields(self.tcx(), did, substs)\n+            }\n+            _ => {\n+                self.tcx().sess.span_bug(\n+                    with_expr.span,\n+                    format!(\"with expression doesn't evaluate to a struct\"));\n+            }\n+        };\n+\n+        // Consume those fields of the with expression that are needed.\n+        for with_field in with_fields.iter() {\n+            if !contains_field_named(with_field, fields) {\n+                let cmt_field = self.mc.cat_field(with_expr,\n+                                                  with_cmt.clone(),\n+                                                  with_field.ident,\n+                                                  with_field.mt.ty);\n+                self.delegate_consume(with_expr.id, with_expr.span, cmt_field);\n+            }\n+        }\n+\n+        fn contains_field_named(field: &ty::field,\n+                                fields: &Vec<ast::Field>)\n+                                -> bool\n+        {\n+            fields.iter().any(\n+                |f| f.ident.node.name == field.ident.name)\n+        }\n+    }\n+\n+    // Invoke the appropriate delegate calls for anything that gets\n+    // consumed or borrowed as part of the automatic adjustment\n+    // process.\n+    fn walk_adjustment(&mut self, expr: &ast::Expr) {\n+        let typer = self.typer;\n+        match typer.adjustments().borrow().find(&expr.id) {\n+            None => { }\n+            Some(adjustment) => {\n+                match *adjustment {\n+                    ty::AutoAddEnv(..) |\n+                    ty::AutoObject(..) => {\n+                        // Creating an object or closure consumes the\n+                        // input and stores it into the resulting rvalue.\n+                        debug!(\"walk_adjustment(AutoAddEnv|AutoObject)\");\n+                        let cmt_unadjusted =\n+                            ignore_err!(self.mc.cat_expr_unadjusted(expr));\n+                        self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n+                    }\n+                    ty::AutoDerefRef(ty::AutoDerefRef {\n+                        autoref: ref opt_autoref,\n+                        autoderefs: n\n+                    }) => {\n+                        self.walk_autoderefs(expr, n);\n+\n+                        match *opt_autoref {\n+                            None => { }\n+                            Some(ref r) => {\n+                                self.walk_autoref(expr, r, n);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn walk_autoderefs(&mut self,\n+                       expr: &ast::Expr,\n+                       autoderefs: uint) {\n+        /*!\n+         * Autoderefs for overloaded Deref calls in fact reference\n+         * their receiver. That is, if we have `(*x)` where `x` is of\n+         * type `Rc<T>`, then this in fact is equivalent to\n+         * `x.deref()`. Since `deref()` is declared with `&self`, this\n+         * is an autoref of `x`.\n+         */\n+        debug!(\"walk_autoderefs expr={} autoderefs={}\", expr.repr(self.tcx()), autoderefs);\n+\n+        for i in range(0, autoderefs) {\n+            let deref_id = typeck::MethodCall::autoderef(expr.id, i as u32);\n+            match self.typer.node_method_ty(deref_id) {\n+                None => {}\n+                Some(method_ty) => {\n+                    let cmt = ignore_err!(self.mc.cat_expr_autoderefd(expr, i));\n+                    let self_ty = *ty::ty_fn_args(method_ty).get(0);\n+                    let (m, r) = match ty::get(self_ty).sty {\n+                        ty::ty_rptr(r, ref m) => (m.mutbl, r),\n+                        _ => self.tcx().sess.span_bug(expr.span,\n+                                format!(\"bad overloaded deref type {}\",\n+                                    method_ty.repr(self.tcx())))\n+                    };\n+                    let bk = ty::BorrowKind::from_mutbl(m);\n+                    self.delegate.borrow(expr.id, expr.span, cmt,\n+                                         r, bk, AutoRef);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn walk_autoref(&mut self,\n+                    expr: &ast::Expr,\n+                    autoref: &ty::AutoRef,\n+                    autoderefs: uint) {\n+        debug!(\"walk_autoref expr={} autoderefs={}\", expr.repr(self.tcx()), autoderefs);\n+\n+        let cmt_derefd = ignore_err!(\n+            self.mc.cat_expr_autoderefd(expr, autoderefs));\n+\n+        debug!(\"walk_autoref: cmt_derefd={}\", cmt_derefd.repr(self.tcx()));\n+\n+        match *autoref {\n+            ty::AutoPtr(r, m) => {\n+                self.delegate.borrow(expr.id,\n+                                     expr.span,\n+                                     cmt_derefd,\n+                                     r,\n+                                     ty::BorrowKind::from_mutbl(m),\n+                                     AutoRef)\n+            }\n+            ty::AutoBorrowVec(r, m) | ty::AutoBorrowVecRef(r, m) => {\n+                let cmt_index = self.mc.cat_index(expr, cmt_derefd, autoderefs+1);\n+                self.delegate.borrow(expr.id,\n+                                     expr.span,\n+                                     cmt_index,\n+                                     r,\n+                                     ty::BorrowKind::from_mutbl(m),\n+                                     AutoRef)\n+            }\n+            ty::AutoBorrowObj(r, m) => {\n+                let cmt_deref = self.mc.cat_deref_obj(expr, cmt_derefd);\n+                self.delegate.borrow(expr.id,\n+                                     expr.span,\n+                                     cmt_deref,\n+                                     r,\n+                                     ty::BorrowKind::from_mutbl(m),\n+                                     AutoRef)\n+            }\n+            ty::AutoUnsafe(_) => {}\n+        }\n+    }\n+\n+    fn walk_overloaded_operator(&mut self,\n+                                expr: &ast::Expr,\n+                                receiver: &ast::Expr,\n+                                args: &[@ast::Expr])\n+                                -> bool\n+    {\n+        if !self.typer.is_method_call(expr.id) {\n+            return false;\n+        }\n+\n+        self.walk_expr(receiver);\n+\n+        // Arguments (but not receivers) to overloaded operator\n+        // methods are implicitly autoref'd which sadly does not use\n+        // adjustments, so we must hardcode the borrow here.\n+\n+        let r = ty::ReScope(expr.id);\n+        let bk = ty::ImmBorrow;\n+\n+        for &arg in args.iter() {\n+            self.borrow_expr(arg, r, bk, OverloadedOperator);\n+        }\n+        return true;\n+    }\n+\n+    fn walk_arm(&mut self, discr_cmt: mc::cmt, arm: &ast::Arm) {\n+        for &pat in arm.pats.iter() {\n+            self.walk_pat(discr_cmt.clone(), pat);\n+        }\n+\n+        for guard in arm.guard.iter() {\n+            self.consume_expr(*guard);\n+        }\n+\n+        self.consume_expr(arm.body);\n+    }\n+\n+    fn walk_pat(&mut self, cmt_discr: mc::cmt, pat: @ast::Pat) {\n+        debug!(\"walk_pat cmt_discr={} pat={}\", cmt_discr.repr(self.tcx()),\n+               pat.repr(self.tcx()));\n+        let mc = &self.mc;\n+        let typer = self.typer;\n+        let tcx = typer.tcx();\n+        let def_map = &self.typer.tcx().def_map;\n+        let delegate = &mut self.delegate;\n+        ignore_err!(mc.cat_pattern(cmt_discr, pat, |mc, cmt_pat, pat| {\n+            if pat_util::pat_is_binding(def_map, pat) {\n+                let tcx = typer.tcx();\n+\n+                debug!(\"binding cmt_pat={} pat={}\",\n+                       cmt_pat.repr(tcx),\n+                       pat.repr(tcx));\n+\n+                // pat_ty: the type of the binding being produced.\n+                let pat_ty = ty::node_id_to_type(tcx, pat.id);\n+\n+                // Each match binding is effectively an assignment to the\n+                // binding being produced.\n+                let def = def_map.borrow().get_copy(&pat.id);\n+                match mc.cat_def(pat.id, pat.span, pat_ty, def) {\n+                    Ok(binding_cmt) => {\n+                        delegate.mutate(pat.id, pat.span, binding_cmt, JustWrite);\n+                    }\n+                    Err(_) => { }\n+                }\n+\n+                // It is also a borrow or copy/move of the value being matched.\n+                match pat.node {\n+                    ast::PatIdent(ast::BindByRef(m), _, _) => {\n+                        let (r, bk) = {\n+                            (ty::ty_region(tcx, pat.span, pat_ty),\n+                             ty::BorrowKind::from_mutbl(m))\n+                        };\n+                        delegate.borrow(pat.id, pat.span, cmt_pat,\n+                                             r, bk, RefBinding);\n+                    }\n+                    ast::PatIdent(ast::BindByValue(_), _, _) => {\n+                        let mode = copy_or_move(typer.tcx(), cmt_pat.ty);\n+                        delegate.consume_pat(pat, cmt_pat, mode);\n+                    }\n+                    _ => {\n+                        typer.tcx().sess.span_bug(\n+                            pat.span,\n+                            \"binding pattern not an identifier\");\n+                    }\n+                }\n+            } else {\n+                match pat.node {\n+                    ast::PatVec(_, Some(slice_pat), _) => {\n+                        // The `slice_pat` here creates a slice into\n+                        // the original vector.  This is effectively a\n+                        // borrow of the elements of the vector being\n+                        // matched.\n+\n+                        let (slice_cmt, slice_mutbl, slice_r) = {\n+                            match mc.cat_slice_pattern(cmt_pat, slice_pat) {\n+                                Ok(v) => v,\n+                                Err(()) => {\n+                                    tcx.sess.span_bug(slice_pat.span,\n+                                                      \"Err from mc\")\n+                                }\n+                            }\n+                        };\n+\n+                        // Note: We declare here that the borrow\n+                        // occurs upon entering the `[...]`\n+                        // pattern. This implies that something like\n+                        // `[a, ..b]` where `a` is a move is illegal,\n+                        // because the borrow is already in effect.\n+                        // In fact such a move would be safe-ish, but\n+                        // it effectively *requires* that we use the\n+                        // nulling out semantics to indicate when a\n+                        // value has been moved, which we are trying\n+                        // to move away from.  Otherwise, how can we\n+                        // indicate that the first element in the\n+                        // vector has been moved?  Eventually, we\n+                        // could perhaps modify this rule to permit\n+                        // `[..a, b]` where `b` is a move, because in\n+                        // that case we can adjust the length of the\n+                        // original vec accordingly, but we'd have to\n+                        // make trans do the right thing, and it would\n+                        // only work for `~` vectors. It seems simpler\n+                        // to just require that people call\n+                        // `vec.pop()` or `vec.unshift()`.\n+                        let slice_bk = ty::BorrowKind::from_mutbl(slice_mutbl);\n+                        delegate.borrow(pat.id, pat.span,\n+                                        slice_cmt, slice_r,\n+                                        slice_bk, RefBinding);\n+                    }\n+                    _ => { }\n+                }\n+            }\n+        }));\n+    }\n+\n+    fn walk_captures(&mut self, closure_expr: &ast::Expr) {\n+        debug!(\"walk_captures({})\", closure_expr.repr(self.tcx()));\n+\n+        let tcx = self.typer.tcx();\n+        freevars::with_freevars(tcx, closure_expr.id, |freevars| {\n+            match freevars::get_capture_mode(self.tcx(), closure_expr.id) {\n+                freevars::CaptureByRef => {\n+                    self.walk_by_ref_captures(closure_expr, freevars);\n+                }\n+                freevars::CaptureByValue => {\n+                    self.walk_by_value_captures(closure_expr, freevars);\n+                }\n+            }\n+        });\n+    }\n+\n+    fn walk_by_ref_captures(&mut self,\n+                            closure_expr: &ast::Expr,\n+                            freevars: &[freevars::freevar_entry]) {\n+        for freevar in freevars.iter() {\n+            let id_var = ast_util::def_id_of_def(freevar.def).node;\n+            let cmt_var = ignore_err!(self.cat_captured_var(closure_expr.id,\n+                                                            closure_expr.span,\n+                                                            freevar.def));\n+\n+            // Lookup the kind of borrow the callee requires, as\n+            // inferred by regionbk\n+            let upvar_id = ty::UpvarId { var_id: id_var,\n+                                         closure_expr_id: closure_expr.id };\n+            let upvar_borrow = self.tcx().upvar_borrow_map.borrow()\n+                                   .get_copy(&upvar_id);\n+\n+            self.delegate.borrow(closure_expr.id,\n+                                 closure_expr.span,\n+                                 cmt_var,\n+                                 upvar_borrow.region,\n+                                 upvar_borrow.kind,\n+                                 ClosureCapture(freevar.span));\n+        }\n+    }\n+\n+    fn walk_by_value_captures(&mut self,\n+                              closure_expr: &ast::Expr,\n+                              freevars: &[freevars::freevar_entry]) {\n+        for freevar in freevars.iter() {\n+            let cmt_var = ignore_err!(self.cat_captured_var(closure_expr.id,\n+                                                            closure_expr.span,\n+                                                            freevar.def));\n+            self.delegate_consume(closure_expr.id, freevar.span, cmt_var);\n+        }\n+    }\n+\n+    fn cat_captured_var(&mut self,\n+                        closure_id: ast::NodeId,\n+                        closure_span: Span,\n+                        upvar_def: ast::Def)\n+                        -> mc::McResult<mc::cmt> {\n+        // Create the cmt for the variable being borrowed, from the\n+        // caller's perspective\n+        let var_id = ast_util::def_id_of_def(upvar_def).node;\n+        let var_ty = ty::node_id_to_type(self.tcx(), var_id);\n+        self.mc.cat_def(closure_id, closure_span, var_ty, upvar_def)\n+    }\n+}\n+\n+fn copy_or_move(tcx: &ty::ctxt, ty: ty::t) -> ConsumeMode {\n+    if ty::type_moves_by_default(tcx, ty) { Move } else { Copy }\n+}\n+"}, {"sha": "8839164434af66811ef83ca559fa5aa9f8c42ecf", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=96dfed2b62c6e84a542f9a170133ec528e2191c2", "patch": "@@ -22,6 +22,15 @@ use syntax::{ast, ast_util};\n use syntax::visit;\n use syntax::visit::Visitor;\n \n+#[deriving(Show)]\n+pub enum CaptureMode {\n+    /// Copy/move the value from this llvm ValueRef into the environment.\n+    CaptureByValue,\n+\n+    /// Access by reference (used for stack closures).\n+    CaptureByRef\n+}\n+\n // A vector of defs representing the free variables referred to in a function.\n // (The def_upvar will already have been stripped).\n #[deriving(Encodable, Decodable)]\n@@ -38,7 +47,6 @@ struct CollectFreevarsVisitor<'a> {\n }\n \n impl<'a> Visitor<int> for CollectFreevarsVisitor<'a> {\n-\n     fn visit_item(&mut self, _: &ast::Item, _: int) {\n         // ignore_item\n     }\n@@ -133,3 +141,14 @@ pub fn with_freevars<T>(tcx: &ty::ctxt, fid: ast::NodeId, f: |&[freevar_entry]|\n         Some(d) => f(d.as_slice())\n     }\n }\n+\n+pub fn get_capture_mode(tcx: &ty::ctxt,\n+                        closure_expr_id: ast::NodeId)\n+                        -> CaptureMode\n+{\n+    let fn_ty = ty::node_id_to_type(tcx, closure_expr_id);\n+    match ty::ty_closure_store(fn_ty) {\n+        ty::RegionTraitStore(..) => CaptureByRef,\n+        ty::UniqTraitStore => CaptureByValue\n+    }\n+}"}, {"sha": "92695d7a1d60f78bb03c45a2658d441ca62f0f2b", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=96dfed2b62c6e84a542f9a170133ec528e2191c2", "patch": "@@ -228,11 +228,11 @@ fn check_fn(\n \n     // Check kinds on free variables:\n     with_appropriate_checker(cx, fn_id, |chk| {\n-        freevars::with_freevars(cx.tcx, fn_id, |r| {\n-            for fv in r.iter() {\n+        freevars::with_freevars(cx.tcx, fn_id, |freevars| {\n+            for fv in freevars.iter() {\n                 chk(cx, fv);\n             }\n-        })\n+        });\n     });\n \n     visit::walk_fn(cx, fk, decl, body, sp, fn_id, ());"}, {"sha": "43ffe3b2d9df4f856ced4f1933d200366f334ad9", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 43, "deletions": 28, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=96dfed2b62c6e84a542f9a170133ec528e2191c2", "patch": "@@ -103,10 +103,10 @@\n  */\n \n \n+use middle::freevars;\n use middle::lint::{UnusedVariable, DeadAssignment};\n use middle::pat_util;\n use middle::ty;\n-use middle::moves;\n use util::nodemap::NodeMap;\n \n use std::cast::transmute;\n@@ -170,9 +170,8 @@ impl<'a> Visitor<()> for IrMaps<'a> {\n }\n \n pub fn check_crate(tcx: &ty::ctxt,\n-                   capture_map: &moves::CaptureMap,\n                    krate: &Crate) {\n-    visit::walk_crate(&mut IrMaps(tcx, capture_map), krate, ());\n+    visit::walk_crate(&mut IrMaps(tcx), krate, ());\n     tcx.sess.abort_if_errors();\n }\n \n@@ -245,7 +244,6 @@ enum VarKind {\n \n struct IrMaps<'a> {\n     tcx: &'a ty::ctxt,\n-    capture_map: &'a moves::CaptureMap,\n \n     num_live_nodes: uint,\n     num_vars: uint,\n@@ -256,12 +254,10 @@ struct IrMaps<'a> {\n     lnks: Vec<LiveNodeKind>,\n }\n \n-fn IrMaps<'a>(tcx: &'a ty::ctxt,\n-              capture_map: &'a moves::CaptureMap)\n+fn IrMaps<'a>(tcx: &'a ty::ctxt)\n               -> IrMaps<'a> {\n     IrMaps {\n         tcx: tcx,\n-        capture_map: capture_map,\n         num_live_nodes: 0,\n         num_vars: 0,\n         live_node_map: NodeMap::new(),\n@@ -361,7 +357,7 @@ fn visit_fn(ir: &mut IrMaps,\n     let _i = ::util::common::indenter();\n \n     // swap in a new set of IR maps for this function body:\n-    let mut fn_maps = IrMaps(ir.tcx, ir.capture_map);\n+    let mut fn_maps = IrMaps(ir.tcx);\n \n     unsafe {\n         debug!(\"creating fn_maps: {}\", transmute::<&IrMaps, *IrMaps>(&fn_maps));\n@@ -446,13 +442,23 @@ fn visit_arm(ir: &mut IrMaps, arm: &Arm) {\n     visit::walk_arm(ir, arm, ());\n }\n \n+fn moved_variable_node_id_from_def(def: Def) -> Option<NodeId> {\n+    match def {\n+        DefBinding(nid, _) |\n+        DefArg(nid, _) |\n+        DefLocal(nid, _) => Some(nid),\n+\n+      _ => None\n+    }\n+}\n+\n fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       ExprPath(_) => {\n         let def = ir.tcx.def_map.borrow().get_copy(&expr.id);\n         debug!(\"expr {}: path that leads to {:?}\", expr.id, def);\n-        if moves::moved_variable_node_id_from_def(def).is_some() {\n+        if moved_variable_node_id_from_def(def).is_some() {\n             ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         }\n         visit::walk_expr(ir, expr, ());\n@@ -467,24 +473,33 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n         // in better error messages than just pointing at the closure\n         // construction site.\n         let mut call_caps = Vec::new();\n-        for cv in ir.capture_map.get(&expr.id).iter() {\n-            match moves::moved_variable_node_id_from_def(cv.def) {\n-              Some(rv) => {\n-                let cv_ln = ir.add_live_node(FreeVarNode(cv.span));\n-                let is_move = match cv.mode {\n-                    // var must be dead afterwards\n-                    moves::CapMove => true,\n-\n-                    // var can still be used\n-                    moves::CapCopy | moves::CapRef => false\n-                };\n-                call_caps.push(CaptureInfo {ln: cv_ln,\n-                                            is_move: is_move,\n-                                            var_nid: rv});\n-              }\n-              None => {}\n+        let fv_mode = freevars::get_capture_mode(ir.tcx, expr.id);\n+        freevars::with_freevars(ir.tcx, expr.id, |freevars| {\n+            for fv in freevars.iter() {\n+                match moved_variable_node_id_from_def(fv.def) {\n+                    Some(rv) => {\n+                        let fv_ln = ir.add_live_node(FreeVarNode(fv.span));\n+                        let fv_id = ast_util::def_id_of_def(fv.def).node;\n+                        let fv_ty = ty::node_id_to_type(ir.tcx, fv_id);\n+                        let is_move = match fv_mode {\n+                            // var must be dead afterwards\n+                            freevars::CaptureByValue => {\n+                                ty::type_moves_by_default(ir.tcx, fv_ty)\n+                            }\n+\n+                            // var can still be used\n+                            freevars::CaptureByRef => {\n+                                false\n+                            }\n+                        };\n+                        call_caps.push(CaptureInfo {ln: fv_ln,\n+                                                    is_move: is_move,\n+                                                    var_nid: rv});\n+                    }\n+                    None => {}\n+                }\n             }\n-        }\n+        });\n         ir.set_captures(expr.id, call_caps);\n \n         visit::walk_expr(ir, expr, ());\n@@ -1270,7 +1285,7 @@ impl<'a> Liveness<'a> {\n     fn access_path(&mut self, expr: &Expr, succ: LiveNode, acc: uint)\n                    -> LiveNode {\n         let def = self.ir.tcx.def_map.borrow().get_copy(&expr.id);\n-        match moves::moved_variable_node_id_from_def(def) {\n+        match moved_variable_node_id_from_def(def) {\n           Some(nid) => {\n             let ln = self.live_node(expr.id, expr.span);\n             if acc != 0u {\n@@ -1497,7 +1512,7 @@ impl<'a> Liveness<'a> {\n                 self.warn_about_dead_assign(expr.span, expr.id, ln, var);\n               }\n               def => {\n-                match moves::moved_variable_node_id_from_def(def) {\n+                match moved_variable_node_id_from_def(def) {\n                   Some(nid) => {\n                     let ln = self.live_node(expr.id, expr.span);\n                     let var = self.variable(nid, expr.span);"}, {"sha": "57f6e9632b1696906fdbf9d99a46c2b7b4f417bf", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=96dfed2b62c6e84a542f9a170133ec528e2191c2", "patch": "@@ -241,8 +241,8 @@ impl ast_node for ast::Pat {\n     fn span(&self) -> Span { self.span }\n }\n \n-pub struct MemCategorizationContext<TYPER> {\n-    pub typer: TYPER\n+pub struct MemCategorizationContext<'t,TYPER> {\n+    typer: &'t TYPER\n }\n \n pub type McResult<T> = Result<T, ()>;\n@@ -349,8 +349,12 @@ macro_rules! if_ok(\n     )\n )\n \n-impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n+    pub fn new(typer: &'t TYPER) -> MemCategorizationContext<'t,TYPER> {\n+        MemCategorizationContext { typer: typer }\n+    }\n+\n+    fn tcx(&self) -> &'t ty::ctxt {\n         self.typer.tcx()\n     }\n \n@@ -418,7 +422,9 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         }\n     }\n \n-    pub fn cat_expr_autoderefd(&self, expr: &ast::Expr, autoderefs: uint)\n+    pub fn cat_expr_autoderefd(&self,\n+                               expr: &ast::Expr,\n+                               autoderefs: uint)\n                                -> McResult<cmt> {\n         let mut cmt = if_ok!(self.cat_expr_unadjusted(expr));\n         for deref in range(1u, autoderefs + 1) {\n@@ -456,7 +462,9 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n \n-          ast::ExprParen(e) => self.cat_expr_unadjusted(e),\n+          ast::ExprParen(e) => {\n+            self.cat_expr(e)\n+          }\n \n           ast::ExprAddrOf(..) | ast::ExprCall(..) |\n           ast::ExprAssign(..) | ast::ExprAssignOp(..) |"}, {"sha": "1e44e1ab7f967b0a335d30e51872c08a135fc047", "filename": "src/librustc/middle/moves.rs", "status": "removed", "additions": 0, "deletions": 655, "changes": 655, "blob_url": "https://github.com/rust-lang/rust/blob/77a975df85694a4de07abb5f99f1159799b1160d/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77a975df85694a4de07abb5f99f1159799b1160d/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=77a975df85694a4de07abb5f99f1159799b1160d", "patch": "@@ -1,655 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-# Moves Computation\n-\n-The goal of this file is to compute which\n-expressions/patterns/captures correspond to *moves*.  This is\n-generally a function of the context in which the expression appears as\n-well as the expression's type.\n-\n-## Examples\n-\n-We will use the following fragment of code to explain the various\n-considerations.  Note that in this code `x` is used after it has been\n-moved here.  This is not relevant to this pass, though the information\n-we compute would later be used to detect this error (see the section\n-Enforcement of Moves, below).\n-\n-    struct Foo { a: int, b: ~int }\n-    let x: Foo = ...;\n-    let w = (x {Read}).a;      // Read\n-    let y = (x {Move}).b;      // Move\n-    let z = copy (x {Read}).b; // Read\n-\n-Let's look at these examples one by one.  In the first case, `w`, the\n-expression being assigned is `x.a`, which has `int` type.  In that\n-case, the value is read, and the container (`x`) is also read.\n-\n-In the second case, `y`, `x.b` is being assigned which has type\n-`~int`.  Because this type moves by default, that will be a move\n-reference.  Whenever we move from a compound expression like `x.b` (or\n-`x[b]` or `*x` or `{x}[b].c`, etc), this invalidates all containing\n-expressions since we do not currently permit \"incomplete\" variables\n-where part of them has been moved and part has not.  In this case,\n-this means that the reference to `x` is also a move.  We'll see later,\n-though, that these kind of \"partial moves\", where part of the\n-expression has been moved, are classified and stored somewhat\n-differently.\n-\n-The final example (`z`) is `copy x.b`: in this case, although the\n-expression being assigned has type `~int`, there are no moves\n-involved.\n-\n-### Patterns\n-\n-For each binding in a match or let pattern, we also compute a read\n-or move designation.  A move binding means that the value will be\n-moved from the value being matched.  As a result, the expression\n-being matched (aka, the 'discriminant') is either moved or read\n-depending on whether the bindings move the value they bind to out of\n-the discriminant.\n-\n-For examples, consider this match expression:\n-\n-    match x {Move} {\n-      Foo { a: a {Read}, b: b {Move} } => {...}\n-    }\n-\n-Here, the binding `b` is value (not ref) mode, and `b` has type\n-`~int`, and therefore the discriminant expression `x` would be\n-incomplete so it also considered moved.\n-\n-In the following two examples, in contrast, the mode of `b` is either\n-`copy` or `ref` and hence the overall result is a read:\n-\n-    match x {Read} {\n-      Foo { a: a {Read}, b: copy b {Read} } => {...}\n-    }\n-\n-    match x {Read} {\n-      Foo { a: a {Read}, b: ref b {Read} } => {...}\n-    }\n-\n-Similar reasoning can be applied to `let` expressions:\n-\n-    let Foo { a: a {Read}, b: b {Move} } = x {Move};\n-    let Foo { a: a {Read}, b: copy b {Read} } = x {Read};\n-    let Foo { a: a {Read}, b: ref b  {Read} } = x {Read};\n-\n-## Output\n-\n-The pass results in the struct `MoveMaps` which contains several\n-maps:\n-\n-`moves_map` is a set containing the id of every *outermost expression* or\n-*binding* that causes a move.  Note that `moves_map` only contains the *outermost\n-expressions* that are moved.  Therefore, if you have a use of `x.b`,\n-as in the example `y` above, the expression `x.b` would be in the\n-`moves_map` but not `x`.  The reason for this is that, for most\n-purposes, it's only the outermost expression that is needed.  The\n-borrow checker and trans, for example, only care about the outermost\n-expressions that are moved.  It is more efficient therefore just to\n-store those entries.\n-\n-Finally, the `capture_map` maps from the node_id of a closure\n-expression to an array of `CaptureVar` structs detailing which\n-variables are captured and how (by ref, by copy, by move).\n-\n-## Enforcement of Moves\n-\n-The enforcement of moves is done by the borrow checker.  Please see\n-the section \"Moves and initialization\" in `middle/borrowck/doc.rs`.\n-\n-## Distributive property\n-\n-Copies are \"distributive\" over parenthesization, but blocks are\n-considered rvalues.  What this means is that, for example, neither\n-`a.clone()` nor `(a).clone()` will move `a` (presuming that `a` has a\n-linear type and `clone()` takes its self by reference), but\n-`{a}.clone()` will move `a`, as would `(if cond {a} else {b}).clone()`\n-and so on.\n-\n-*/\n-\n-\n-use middle::pat_util::{pat_bindings};\n-use middle::freevars;\n-use middle::ty;\n-use middle::typeck::MethodCall;\n-use util::ppaux;\n-use util::ppaux::Repr;\n-use util::common::indenter;\n-use util::ppaux::UserString;\n-use util::nodemap::{NodeMap, NodeSet};\n-\n-use std::rc::Rc;\n-use syntax::ast::*;\n-use syntax::ast_util;\n-use syntax::visit;\n-use syntax::visit::Visitor;\n-use syntax::codemap::Span;\n-\n-#[deriving(Eq, Encodable, Decodable)]\n-pub enum CaptureMode {\n-    CapCopy, // Copy the value into the closure.\n-    CapMove, // Move the value into the closure.\n-    CapRef,  // Reference directly from parent stack frame (used by `||`).\n-}\n-\n-#[deriving(Encodable, Decodable)]\n-pub struct CaptureVar {\n-    pub def: Def,         // Variable being accessed free\n-    pub span: Span,       // Location of an access to this variable\n-    pub mode: CaptureMode // How variable is being accessed\n-}\n-\n-pub type CaptureMap = NodeMap<Rc<Vec<CaptureVar>>>;\n-\n-/** See the section Output on the module comment for explanation. */\n-#[deriving(Clone)]\n-pub struct MoveMaps {\n-    pub moves_map: NodeSet,\n-    /**\n-     * Set of variable node-ids that are moved.\n-     *\n-     * pub Note: The `moves_map` stores expression ids that are moves,\n-     * whereas this set stores the ids of the variables that are\n-     * moved at some point */\n-    pub capture_map: CaptureMap\n-}\n-\n-#[deriving(Clone)]\n-struct VisitContext<'a> {\n-    tcx: &'a ty::ctxt,\n-    move_maps: MoveMaps\n-}\n-\n-#[deriving(Eq)]\n-enum UseMode {\n-    Move,        // This value or something owned by it is moved.\n-    Read         // Read no matter what the type.\n-}\n-\n-impl<'a> visit::Visitor<()> for VisitContext<'a> {\n-    fn visit_fn(&mut self, fk: &visit::FnKind, fd: &FnDecl,\n-                b: &Block, s: Span, n: NodeId, _: ()) {\n-        compute_modes_for_fn(self, fk, fd, b, s, n);\n-    }\n-    fn visit_expr(&mut self, ex: &Expr, _: ()) {\n-        compute_modes_for_expr(self, ex);\n-    }\n-    fn visit_local(&mut self, l: &Local, _: ()) {\n-        compute_modes_for_local(self, l);\n-    }\n-    // FIXME(#10894) should continue recursing\n-    fn visit_ty(&mut self, _t: &Ty, _: ()) {}\n-}\n-\n-pub fn compute_moves(tcx: &ty::ctxt, krate: &Crate) -> MoveMaps {\n-    let mut visit_cx = VisitContext {\n-        tcx: tcx,\n-        move_maps: MoveMaps {\n-            moves_map: NodeSet::new(),\n-            capture_map: NodeMap::new()\n-        }\n-    };\n-    visit::walk_crate(&mut visit_cx, krate, ());\n-    visit_cx.move_maps\n-}\n-\n-pub fn moved_variable_node_id_from_def(def: Def) -> Option<NodeId> {\n-    match def {\n-        DefBinding(nid, _) |\n-        DefArg(nid, _) |\n-        DefLocal(nid, _) => Some(nid),\n-\n-      _ => None\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Expressions\n-\n-fn compute_modes_for_local<'a>(cx: &mut VisitContext,\n-                               local: &Local) {\n-    cx.use_pat(local.pat);\n-    for &init in local.init.iter() {\n-        cx.use_expr(init, Read);\n-    }\n-}\n-\n-fn compute_modes_for_fn(cx: &mut VisitContext,\n-                        fk: &visit::FnKind,\n-                        decl: &FnDecl,\n-                        body: &Block,\n-                        span: Span,\n-                        id: NodeId) {\n-    for a in decl.inputs.iter() {\n-        cx.use_pat(a.pat);\n-    }\n-    visit::walk_fn(cx, fk, decl, body, span, id, ());\n-}\n-\n-fn compute_modes_for_expr(cx: &mut VisitContext,\n-                          expr: &Expr)\n-{\n-    cx.consume_expr(expr);\n-}\n-\n-impl<'a> VisitContext<'a> {\n-    pub fn consume_exprs(&mut self, exprs: &[@Expr]) {\n-        for expr in exprs.iter() {\n-            self.consume_expr(*expr);\n-        }\n-    }\n-\n-    pub fn consume_expr(&mut self, expr: &Expr) {\n-        /*!\n-         * Indicates that the value of `expr` will be consumed,\n-         * meaning either copied or moved depending on its type.\n-         */\n-\n-        debug!(\"consume_expr(expr={})\",\n-               expr.repr(self.tcx));\n-\n-        let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n-        if ty::type_moves_by_default(self.tcx, expr_ty) {\n-            self.move_maps.moves_map.insert(expr.id);\n-            self.use_expr(expr, Move);\n-        } else {\n-            self.use_expr(expr, Read);\n-        };\n-    }\n-\n-    pub fn consume_block(&mut self, blk: &Block) {\n-        /*!\n-         * Indicates that the value of `blk` will be consumed,\n-         * meaning either copied or moved depending on its type.\n-         */\n-\n-        debug!(\"consume_block(blk.id={:?})\", blk.id);\n-\n-        for stmt in blk.stmts.iter() {\n-            self.visit_stmt(*stmt, ());\n-        }\n-\n-        for tail_expr in blk.expr.iter() {\n-            self.consume_expr(*tail_expr);\n-        }\n-    }\n-\n-    pub fn use_expr(&mut self,\n-                    expr: &Expr,\n-                    expr_mode: UseMode) {\n-        /*!\n-         * Indicates that `expr` is used with a given mode.  This will\n-         * in turn trigger calls to the subcomponents of `expr`.\n-         */\n-\n-        debug!(\"use_expr(expr={}, mode={:?})\",\n-               expr.repr(self.tcx),\n-               expr_mode);\n-\n-        // `expr_mode` refers to the post-adjustment value.  If one of\n-        // those adjustments is to take a reference, then it's only\n-        // reading the underlying expression, not moving it.\n-        let comp_mode = match self.tcx.adjustments.borrow().find(&expr.id) {\n-            Some(adjustment) => {\n-                match *adjustment {\n-                    ty::AutoDerefRef(ty::AutoDerefRef {\n-                        autoref: Some(_),\n-                        ..\n-                    }) => Read,\n-                    _ => expr_mode,\n-                }\n-            }\n-            _ => expr_mode,\n-        };\n-\n-        debug!(\"comp_mode = {:?}\", comp_mode);\n-\n-        match expr.node {\n-            ExprUnary(UnDeref, base) => {      // *base\n-                if !self.use_overloaded_operator(expr, base, []) {\n-                    // Moving out of *base moves out of base.\n-                    self.use_expr(base, comp_mode);\n-                }\n-            }\n-\n-            ExprField(base, _, _) => {         // base.f\n-                // Moving out of base.f moves out of base.\n-                self.use_expr(base, comp_mode);\n-            }\n-\n-            ExprIndex(lhs, rhs) => {           // lhs[rhs]\n-                if !self.use_overloaded_operator(expr, lhs, [rhs]) {\n-                    self.use_expr(lhs, comp_mode);\n-                    self.consume_expr(rhs);\n-                }\n-            }\n-\n-            ExprCall(callee, ref args) => {    // callee(args)\n-                // Figure out whether the called function is consumed.\n-                let mode = match ty::get(ty::expr_ty(self.tcx, callee)).sty {\n-                    ty::ty_closure(ref cty) => {\n-                        match cty.onceness {\n-                        Once => Move,\n-                        Many => Read,\n-                        }\n-                    },\n-                    ty::ty_bare_fn(..) => Read,\n-                    ref x =>\n-                        self.tcx.sess.span_bug(callee.span,\n-                            format!(\"non-function type in moves for expr_call: {:?}\", x)),\n-                };\n-                // Note we're not using consume_expr, which uses type_moves_by_default\n-                // to determine the mode, for this. The reason is that while stack\n-                // closures should be noncopyable, they shouldn't move by default;\n-                // calling a closure should only consume it if it's once.\n-                if mode == Move {\n-                    self.move_maps.moves_map.insert(callee.id);\n-                }\n-                self.use_expr(callee, mode);\n-                self.use_fn_args(args.as_slice());\n-            }\n-\n-            ExprMethodCall(_, _, ref args) => { // callee.m(args)\n-                self.use_fn_args(args.as_slice());\n-            }\n-\n-            ExprStruct(_, ref fields, opt_with) => {\n-                for field in fields.iter() {\n-                    self.consume_expr(field.expr);\n-                }\n-\n-                for with_expr in opt_with.iter() {\n-                    // If there are any fields whose type is move-by-default,\n-                    // then `with` is consumed, otherwise it is only read\n-                    let with_ty = ty::expr_ty(self.tcx, *with_expr);\n-                    let with_fields = match ty::get(with_ty).sty {\n-                        ty::ty_struct(did, ref substs) => {\n-                            ty::struct_fields(self.tcx, did, substs)\n-                        }\n-                        ref r => {\n-                           self.tcx.sess.span_bug(\n-                                with_expr.span,\n-                                format!(\"bad base expr type in record: {:?}\", r))\n-                        }\n-                    };\n-\n-                    // The `with` expr must be consumed if it contains\n-                    // any fields which (1) were not explicitly\n-                    // specified and (2) have a type that\n-                    // moves-by-default:\n-                    let consume_with = with_fields.iter().any(|tf| {\n-                        !fields.iter().any(|f| f.ident.node.name == tf.ident.name) &&\n-                            ty::type_moves_by_default(self.tcx, tf.mt.ty)\n-                    });\n-\n-                    fn has_dtor(tcx: &ty::ctxt, ty: ty::t) -> bool {\n-                        use middle::ty::{get,ty_struct,ty_enum};\n-                        match get(ty).sty {\n-                            ty_struct(did, _) | ty_enum(did, _) => ty::has_dtor(tcx, did),\n-                            _ => false,\n-                        }\n-                    }\n-\n-                    if consume_with {\n-                        if has_dtor(self.tcx, with_ty) {\n-                            self.tcx.sess.span_err(with_expr.span,\n-                                                   format!(\"cannot move out of type `{}`, \\\n-                                                         which defines the `Drop` trait\",\n-                                                        with_ty.user_string(self.tcx)));\n-                        }\n-                        self.consume_expr(*with_expr);\n-                    } else {\n-                        self.use_expr(*with_expr, Read);\n-                    }\n-                }\n-            }\n-\n-            ExprTup(ref exprs) => {\n-                self.consume_exprs(exprs.as_slice());\n-            }\n-\n-            ExprIf(cond_expr, then_blk, opt_else_expr) => {\n-                self.consume_expr(cond_expr);\n-                self.consume_block(then_blk);\n-                for else_expr in opt_else_expr.iter() {\n-                    self.consume_expr(*else_expr);\n-                }\n-            }\n-\n-            ExprMatch(discr, ref arms) => {\n-                for arm in arms.iter() {\n-                    self.consume_arm(arm);\n-                }\n-\n-                // The discriminant may, in fact, be partially moved\n-                // if there are by-move bindings, but borrowck deals\n-                // with that itself.\n-                self.use_expr(discr, Read);\n-            }\n-\n-            ExprParen(base) => {\n-                // Note: base is not considered a *component* here, so\n-                // use `expr_mode` not `comp_mode`.\n-                self.use_expr(base, expr_mode);\n-            }\n-\n-            ExprVec(ref exprs) => {\n-                self.consume_exprs(exprs.as_slice());\n-            }\n-\n-            ExprAddrOf(_, base) => {   // &base\n-                self.use_expr(base, Read);\n-            }\n-\n-            ExprPath(..) |\n-            ExprInlineAsm(..) |\n-            ExprBreak(..) |\n-            ExprAgain(..) |\n-            ExprLit(..) => {}\n-\n-            ExprLoop(blk, _) => {\n-                self.consume_block(blk);\n-            }\n-\n-            ExprWhile(cond_expr, blk) => {\n-                self.consume_expr(cond_expr);\n-                self.consume_block(blk);\n-            }\n-\n-            ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n-\n-            ExprUnary(_, lhs) => {\n-                if !self.use_overloaded_operator(expr, lhs, []) {\n-                    self.consume_expr(lhs);\n-                }\n-            }\n-\n-            ExprBinary(_, lhs, rhs) => {\n-                if !self.use_overloaded_operator(expr, lhs, [rhs]) {\n-                    self.consume_expr(lhs);\n-                    self.consume_expr(rhs);\n-                }\n-            }\n-\n-            ExprBlock(blk) => {\n-                self.consume_block(blk);\n-            }\n-\n-            ExprRet(ref opt_expr) => {\n-                for expr in opt_expr.iter() {\n-                    self.consume_expr(*expr);\n-                }\n-            }\n-\n-            ExprAssign(lhs, rhs) => {\n-                self.use_expr(lhs, Read);\n-                self.consume_expr(rhs);\n-            }\n-\n-            ExprCast(base, _) => {\n-                self.consume_expr(base);\n-            }\n-\n-            ExprAssignOp(_, lhs, rhs) => {\n-                // FIXME(#4712) --- Overloaded operators?\n-                //\n-                // if !self.use_overloaded_operator(expr, DoDerefArgs, lhs, [rhs])\n-                // {\n-                self.consume_expr(lhs);\n-                self.consume_expr(rhs);\n-                // }\n-            }\n-\n-            ExprRepeat(base, count) => {\n-                self.consume_expr(base);\n-                self.consume_expr(count);\n-            }\n-\n-            ExprFnBlock(ref decl, body) |\n-            ExprProc(ref decl, body) => {\n-                for a in decl.inputs.iter() {\n-                    self.use_pat(a.pat);\n-                }\n-                let cap_vars = self.compute_captures(expr.id);\n-                self.move_maps.capture_map.insert(expr.id, Rc::new(cap_vars));\n-                self.consume_block(body);\n-            }\n-\n-            ExprVstore(base, _) => {\n-                self.use_expr(base, comp_mode);\n-            }\n-\n-            ExprBox(place, base) => {\n-                self.use_expr(place, comp_mode);\n-                self.use_expr(base, comp_mode);\n-            }\n-\n-            ExprMac(..) => {\n-                self.tcx.sess.span_bug(\n-                    expr.span,\n-                    \"macro expression remains after expansion\");\n-            }\n-        }\n-    }\n-\n-    pub fn use_overloaded_operator(&mut self,\n-                                   expr: &Expr,\n-                                   receiver_expr: @Expr,\n-                                   arg_exprs: &[@Expr])\n-                                   -> bool {\n-        let method_call = MethodCall::expr(expr.id);\n-        if !self.tcx.method_map.borrow().contains_key(&method_call) {\n-            return false;\n-        }\n-\n-        self.use_fn_arg(receiver_expr);\n-\n-        // for overloaded operatrs, we are always passing in a\n-        // reference, so it's always read mode:\n-        for arg_expr in arg_exprs.iter() {\n-            self.use_expr(*arg_expr, Read);\n-        }\n-\n-        return true;\n-    }\n-\n-    pub fn consume_arm(&mut self, arm: &Arm) {\n-        for pat in arm.pats.iter() {\n-            self.use_pat(*pat);\n-        }\n-\n-        for guard in arm.guard.iter() {\n-            self.consume_expr(*guard);\n-        }\n-\n-        self.consume_expr(arm.body);\n-    }\n-\n-    pub fn use_pat(&mut self, pat: @Pat) {\n-        /*!\n-         *\n-         * Decides whether each binding in a pattern moves the value\n-         * into itself or not based on its type and annotation.\n-         */\n-\n-        pat_bindings(&self.tcx.def_map, pat, |bm, id, _span, path| {\n-            let binding_moves = match bm {\n-                BindByRef(_) => false,\n-                BindByValue(_) => {\n-                    let pat_ty = ty::node_id_to_type(self.tcx, id);\n-                    debug!(\"pattern {:?} {} type is {}\",\n-                           id,\n-                           ast_util::path_to_ident(path).repr(self.tcx),\n-                           pat_ty.repr(self.tcx));\n-                    ty::type_moves_by_default(self.tcx, pat_ty)\n-                }\n-            };\n-\n-            debug!(\"pattern binding {:?}: bm={:?}, binding_moves={}\",\n-                   id, bm, binding_moves);\n-\n-            if binding_moves {\n-                self.move_maps.moves_map.insert(id);\n-            }\n-        })\n-    }\n-\n-    pub fn use_fn_args(&mut self, arg_exprs: &[@Expr]) {\n-        //! Uses the argument expressions.\n-        for arg_expr in arg_exprs.iter() {\n-            self.use_fn_arg(*arg_expr);\n-        }\n-    }\n-\n-    pub fn use_fn_arg(&mut self, arg_expr: @Expr) {\n-        //! Uses the argument.\n-        self.consume_expr(arg_expr)\n-    }\n-\n-    fn compute_captures(&mut self, fn_expr_id: NodeId) -> Vec<CaptureVar> {\n-        debug!(\"compute_capture_vars(fn_expr_id={:?})\", fn_expr_id);\n-        let _indenter = indenter();\n-\n-        let fn_ty = ty::node_id_to_type(self.tcx, fn_expr_id);\n-        freevars::with_freevars(self.tcx, fn_expr_id, |freevars| {\n-            match ty::ty_closure_store(fn_ty) {\n-                ty::RegionTraitStore(..) => {\n-                    // || captures everything by ref\n-                    freevars.iter()\n-                            .map(|fvar| CaptureVar {def: fvar.def, span: fvar.span, mode: CapRef})\n-                            .collect()\n-                }\n-                ty::UniqTraitStore => {\n-                    // proc captures by copy or by move depending on type\n-                    freevars.iter()\n-                            .map(|fvar| {\n-                        let fvar_def_id = ast_util::def_id_of_def(fvar.def).node;\n-                        let fvar_ty = ty::node_id_to_type(self.tcx, fvar_def_id);\n-                        debug!(\"fvar_def_id={:?} fvar_ty={}\",\n-                            fvar_def_id, ppaux::ty_to_str(self.tcx, fvar_ty));\n-                        let mode = if ty::type_moves_by_default(self.tcx, fvar_ty) {\n-                            CapMove\n-                        } else {\n-                            CapCopy\n-                        };\n-                        CaptureVar {def: fvar.def, span: fvar.span, mode:mode}\n-                    }).collect()\n-                }\n-            }\n-        })\n-    }\n-}"}, {"sha": "e5ddf07b682ea1912d82e5bbf444e5e19c386329", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=96dfed2b62c6e84a542f9a170133ec528e2191c2", "patch": "@@ -2073,7 +2073,7 @@ pub fn write_metadata(cx: &CrateContext, krate: &ast::Crate) -> Vec<u8> {\n     }\n \n     let encode_inlined_item: encoder::EncodeInlinedItem =\n-        |ecx, ebml_w, ii| astencode::encode_inlined_item(ecx, ebml_w, ii, &cx.maps);\n+        |ecx, ebml_w, ii| astencode::encode_inlined_item(ecx, ebml_w, ii);\n \n     let encode_parms = crate_ctxt_to_encode_parms(cx, encode_inlined_item);\n     let metadata = encoder::encode_metadata(encode_parms, krate);\n@@ -2103,7 +2103,7 @@ pub fn write_metadata(cx: &CrateContext, krate: &ast::Crate) -> Vec<u8> {\n pub fn trans_crate(krate: ast::Crate,\n                    analysis: CrateAnalysis,\n                    output: &OutputFilenames) -> (ty::ctxt, CrateTranslation) {\n-    let CrateAnalysis { ty_cx: tcx, exp_map2, maps, reachable, .. } = analysis;\n+    let CrateAnalysis { ty_cx: tcx, exp_map2, reachable, .. } = analysis;\n \n     // Before we touch LLVM, make sure that multithreading is enabled.\n     unsafe {\n@@ -2135,7 +2135,7 @@ pub fn trans_crate(krate: ast::Crate,\n     // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n     let llmod_id = link_meta.crateid.name + \".rs\";\n \n-    let ccx = CrateContext::new(llmod_id, tcx, exp_map2, maps,\n+    let ccx = CrateContext::new(llmod_id, tcx, exp_map2,\n                                 Sha256::new(), link_meta, reachable);\n     {\n         let _icx = push_ctxt(\"text\");"}, {"sha": "a846848f4949a2dd5c146d8cbbc75b1b81d334f0", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 31, "deletions": 63, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=96dfed2b62c6e84a542f9a170133ec528e2191c2", "patch": "@@ -13,8 +13,8 @@ use back::abi;\n use back::link::mangle_internal_name_by_path_and_seq;\n use driver::session::FullDebugInfo;\n use lib::llvm::ValueRef;\n+use middle::freevars;\n use middle::lang_items::ClosureExchangeMallocFnLangItem;\n-use middle::moves;\n use middle::trans::base::*;\n use middle::trans::build::*;\n use middle::trans::common::*;\n@@ -98,35 +98,14 @@ use syntax::ast_util;\n //\n // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n-pub enum EnvAction {\n-    /// Copy the value from this llvm ValueRef into the environment.\n-    EnvCopy,\n-\n-    /// Move the value from this llvm ValueRef into the environment.\n-    EnvMove,\n-\n-    /// Access by reference (used for stack closures).\n-    EnvRef\n-}\n-\n pub struct EnvValue {\n-    action: EnvAction,\n+    action: freevars::CaptureMode,\n     datum: Datum<Lvalue>\n }\n \n-impl EnvAction {\n-    pub fn to_str(&self) -> ~str {\n-        match *self {\n-            EnvCopy => \"EnvCopy\".to_owned(),\n-            EnvMove => \"EnvMove\".to_owned(),\n-            EnvRef => \"EnvRef\".to_owned()\n-        }\n-    }\n-}\n-\n impl EnvValue {\n     pub fn to_str(&self, ccx: &CrateContext) -> ~str {\n-        format!(\"{}({})\", self.action.to_str(), self.datum.to_str(ccx))\n+        format!(\"{}({})\", self.action, self.datum.to_str(ccx))\n     }\n }\n \n@@ -140,8 +119,8 @@ pub fn mk_closure_tys(tcx: &ty::ctxt,\n     // converted to ptrs.\n     let bound_tys = bound_values.iter().map(|bv| {\n         match bv.action {\n-            EnvCopy | EnvMove => bv.datum.ty,\n-            EnvRef => ty::mk_mut_ptr(tcx, bv.datum.ty)\n+            freevars::CaptureByValue => bv.datum.ty,\n+            freevars::CaptureByRef => ty::mk_mut_ptr(tcx, bv.datum.ty)\n         }\n     }).collect();\n     let cdata_ty = ty::mk_tup(tcx, bound_tys);\n@@ -232,10 +211,10 @@ pub fn store_environment<'a>(\n         let bound_data = GEPi(bcx, llbox, [0u, abi::box_field_body, i]);\n \n         match bv.action {\n-            EnvCopy | EnvMove => {\n+            freevars::CaptureByValue => {\n                 bcx = bv.datum.store_to(bcx, bound_data);\n             }\n-            EnvRef => {\n+            freevars::CaptureByRef => {\n                 Store(bcx, bv.datum.to_llref(), bound_data);\n             }\n         }\n@@ -247,38 +226,21 @@ pub fn store_environment<'a>(\n // Given a context and a list of upvars, build a closure. This just\n // collects the upvars and packages them up for store_environment.\n fn build_closure<'a>(bcx0: &'a Block<'a>,\n-                     cap_vars: &[moves::CaptureVar],\n+                     freevar_mode: freevars::CaptureMode,\n+                     freevars: &Vec<freevars::freevar_entry>,\n                      store: ty::TraitStore)\n-                     -> ClosureResult<'a> {\n+                     -> ClosureResult<'a>\n+{\n     let _icx = push_ctxt(\"closure::build_closure\");\n \n     // If we need to, package up the iterator body to call\n     let bcx = bcx0;\n \n     // Package up the captured upvars\n     let mut env_vals = Vec::new();\n-    for cap_var in cap_vars.iter() {\n-        debug!(\"Building closure: captured variable {:?}\", *cap_var);\n-        let datum = expr::trans_local_var(bcx, cap_var.def);\n-        match cap_var.mode {\n-            moves::CapRef => {\n-                let is_region_closure = match store {\n-                    ty::RegionTraitStore(..) => true,\n-                    ty::UniqTraitStore => false\n-                };\n-                assert!(is_region_closure);\n-                env_vals.push(EnvValue {action: EnvRef,\n-                                        datum: datum});\n-            }\n-            moves::CapCopy => {\n-                env_vals.push(EnvValue {action: EnvCopy,\n-                                        datum: datum});\n-            }\n-            moves::CapMove => {\n-                env_vals.push(EnvValue {action: EnvMove,\n-                                        datum: datum});\n-            }\n-        }\n+    for freevar in freevars.iter() {\n+        let datum = expr::trans_local_var(bcx, freevar.def);\n+        env_vals.push(EnvValue {action: freevar_mode, datum: datum});\n     }\n \n     store_environment(bcx, env_vals, store)\n@@ -287,13 +249,15 @@ fn build_closure<'a>(bcx0: &'a Block<'a>,\n // Given an enclosing block context, a new function context, a closure type,\n // and a list of upvars, generate code to load and populate the environment\n // with the upvars and type descriptors.\n-fn load_environment<'a>(bcx: &'a Block<'a>, cdata_ty: ty::t,\n-                        cap_vars: &[moves::CaptureVar],\n-                        store: ty::TraitStore) -> &'a Block<'a> {\n+fn load_environment<'a>(bcx: &'a Block<'a>,\n+                        cdata_ty: ty::t,\n+                        freevars: &Vec<freevars::freevar_entry>,\n+                        store: ty::TraitStore)\n+                        -> &'a Block<'a> {\n     let _icx = push_ctxt(\"closure::load_environment\");\n \n     // Don't bother to create the block if there's nothing to load\n-    if cap_vars.len() == 0 {\n+    if freevars.len() == 0 {\n         return bcx;\n     }\n \n@@ -312,13 +276,13 @@ fn load_environment<'a>(bcx: &'a Block<'a>, cdata_ty: ty::t,\n \n     // Populate the upvars from the environment\n     let mut i = 0u;\n-    for cap_var in cap_vars.iter() {\n+    for freevar in freevars.iter() {\n         let mut upvarptr = GEPi(bcx, llcdata, [0u, i]);\n         match store {\n             ty::RegionTraitStore(..) => { upvarptr = Load(bcx, upvarptr); }\n             ty::UniqTraitStore => {}\n         }\n-        let def_id = ast_util::def_id_of_def(cap_var.def);\n+        let def_id = ast_util::def_id_of_def(freevar.def);\n \n         bcx.fcx.llupvars.borrow_mut().insert(def_id.node, upvarptr);\n \n@@ -330,7 +294,7 @@ fn load_environment<'a>(bcx: &'a Block<'a>, cdata_ty: ty::t,\n                 env_pointer_alloca,\n                 i,\n                 store,\n-                cap_var.span);\n+                freevar.span);\n         }\n \n         i += 1u;\n@@ -395,15 +359,19 @@ pub fn trans_expr_fn<'a>(\n     // set an inline hint for all closures\n     set_inline_hint(llfn);\n \n-    let cap_vars = ccx.maps.capture_map.borrow().get_copy(&id);\n+    let freevar_mode = freevars::get_capture_mode(tcx, id);\n+    let freevars: Vec<freevars::freevar_entry> =\n+        freevars::with_freevars(\n+            tcx, id,\n+            |fv| fv.iter().map(|&fv| fv).collect());\n+\n     let ClosureResult {llbox, cdata_ty, bcx} =\n-        build_closure(bcx, cap_vars.as_slice(), store);\n+        build_closure(bcx, freevar_mode, &freevars, store);\n     trans_closure(ccx, decl, body, llfn,\n                   bcx.fcx.param_substs, id,\n                   [], ty::ty_fn_ret(fty),\n-                  |bcx| load_environment(bcx, cdata_ty, cap_vars.as_slice(), store));\n+                  |bcx| load_environment(bcx, cdata_ty, &freevars, store));\n     fill_fn_pair(bcx, dest_addr, llfn, llbox);\n-\n     bcx\n }\n "}, {"sha": "f46c323232657683f241b33780066960eca9444b", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=96dfed2b62c6e84a542f9a170133ec528e2191c2", "patch": "@@ -15,7 +15,6 @@ use lib::llvm::{ContextRef, ModuleRef, ValueRef};\n use lib::llvm::{llvm, TargetData, TypeNames};\n use lib::llvm::mk_target_data;\n use metadata::common::LinkMeta;\n-use middle::astencode;\n use middle::resolve;\n use middle::trans::adt;\n use middle::trans::base;\n@@ -113,7 +112,6 @@ pub struct CrateContext {\n     pub type_hashcodes: RefCell<HashMap<ty::t, ~str>>,\n     pub all_llvm_symbols: RefCell<HashSet<~str>>,\n     pub tcx: ty::ctxt,\n-    pub maps: astencode::Maps,\n     pub stats: Stats,\n     pub int_type: Type,\n     pub opaque_vec_type: Type,\n@@ -131,7 +129,6 @@ impl CrateContext {\n     pub fn new(name: &str,\n                tcx: ty::ctxt,\n                emap2: resolve::ExportMap2,\n-               maps: astencode::Maps,\n                symbol_hasher: Sha256,\n                link_meta: LinkMeta,\n                reachable: NodeSet)\n@@ -195,7 +192,6 @@ impl CrateContext {\n                 type_hashcodes: RefCell::new(HashMap::new()),\n                 all_llvm_symbols: RefCell::new(HashSet::new()),\n                 tcx: tcx,\n-                maps: maps,\n                 stats: Stats {\n                     n_static_tydescs: Cell::new(0u),\n                     n_glues_created: Cell::new(0u),"}, {"sha": "fa4a62319dbf991df4d653708368bf1d404849f5", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=96dfed2b62c6e84a542f9a170133ec528e2191c2", "patch": "@@ -40,7 +40,7 @@ pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n     let csearch_result =\n         csearch::maybe_get_item_ast(\n             ccx.tcx(), fn_id,\n-            |a,b,c,d| astencode::decode_inlined_item(a, b, &ccx.maps, c, d));\n+            |a,b,c,d| astencode::decode_inlined_item(a, b, c, d));\n     return match csearch_result {\n         csearch::not_found => {\n             ccx.external.borrow_mut().insert(fn_id, None);"}, {"sha": "aa460cc9c18852c4d204a84d26d4aa1da2a93366", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=96dfed2b62c6e84a542f9a170133ec528e2191c2", "patch": "@@ -13,6 +13,7 @@\n use back::svh::Svh;\n use driver::session::Session;\n use metadata::csearch;\n+use mc = middle::mem_categorization;\n use middle::const_eval;\n use middle::lang_items::{ExchangeHeapLangItem, OpaqueStructLangItem};\n use middle::lang_items::{TyDescStructLangItem, TyVisitorTraitLangItem};\n@@ -508,7 +509,7 @@ pub struct UpvarId {\n     pub closure_expr_id: ast::NodeId,\n }\n \n-#[deriving(Clone, Eq, TotalEq, Hash)]\n+#[deriving(Clone, Eq, TotalEq, Hash, Show)]\n pub enum BorrowKind {\n     /// Data must be immutable and is aliasable.\n     ImmBorrow,\n@@ -4779,3 +4780,33 @@ impl BorrowKind {\n         }\n     }\n }\n+\n+impl mc::Typer for ty::ctxt {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+        self\n+    }\n+\n+    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<ty::t> {\n+        Ok(ty::node_id_to_type(self, id))\n+    }\n+\n+    fn node_method_ty(&self, method_call: typeck::MethodCall) -> Option<ty::t> {\n+        self.method_map.borrow().find(&method_call).map(|method| method.ty)\n+    }\n+\n+    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment>> {\n+        &self.adjustments\n+    }\n+\n+    fn is_method_call(&self, id: ast::NodeId) -> bool {\n+        self.method_map.borrow().contains_key(&typeck::MethodCall::expr(id))\n+    }\n+\n+    fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<ast::NodeId> {\n+        self.region_maps.temporary_scope(rvalue_id)\n+    }\n+\n+    fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow {\n+        self.upvar_borrow_map.borrow().get_copy(&upvar_id)\n+    }\n+}"}, {"sha": "4922ed116d8fb9450461147a904374062b5a4392", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=96dfed2b62c6e84a542f9a170133ec528e2191c2", "patch": "@@ -261,7 +261,7 @@ impl<'a> Rcx<'a> {\n     }\n }\n \n-impl<'a, 'b> mc::Typer for &'a Rcx<'b> {\n+impl<'fcx> mc::Typer for Rcx<'fcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n         self.fcx.tcx()\n     }\n@@ -638,7 +638,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n         ty::ty_closure(~ty::ClosureTy {store: ty::RegionTraitStore(..), ..}) => {\n             freevars::with_freevars(tcx, expr.id, |freevars| {\n                 propagate_upupvar_borrow_kind(rcx, expr, freevars);\n-            });\n+            })\n         }\n         _ => ()\n     }\n@@ -754,9 +754,9 @@ fn constrain_callee(rcx: &mut Rcx,\n                 ty::RegionTraitStore(r, _) => {\n                     // While we're here, link the closure's region with a unique\n                     // immutable borrow (gathered later in borrowck)\n-                    let mc = mc::MemCategorizationContext { typer: &*rcx };\n+                    let mc = mc::MemCategorizationContext::new(rcx);\n                     let expr_cmt = ignore_err!(mc.cat_expr(callee_expr));\n-                    link_region(mc.typer, callee_expr.span, call_region,\n+                    link_region(rcx, callee_expr.span, call_region,\n                                 ty::UniqueImmBorrow, expr_cmt);\n                     r\n                 }\n@@ -880,9 +880,9 @@ fn constrain_autoderefs(rcx: &mut Rcx,\n                                 method.ty.repr(rcx.tcx())))\n                 };\n                 {\n-                    let mc = mc::MemCategorizationContext { typer: &*rcx };\n+                    let mc = mc::MemCategorizationContext::new(rcx);\n                     let self_cmt = ignore_err!(mc.cat_expr_autoderefd(deref_expr, i));\n-                    link_region(mc.typer, deref_expr.span, r,\n+                    link_region(rcx, deref_expr.span, r,\n                                 ty::BorrowKind::from_mutbl(m), self_cmt);\n                 }\n \n@@ -1038,7 +1038,7 @@ fn link_addr_of(rcx: &mut Rcx, expr: &ast::Expr,\n     debug!(\"link_addr_of(base=?)\");\n \n     let cmt = {\n-        let mc = mc::MemCategorizationContext { typer: &*rcx };\n+        let mc = mc::MemCategorizationContext::new(rcx);\n         ignore_err!(mc.cat_expr(base))\n     };\n     link_region_from_node_type(rcx, expr.span, expr.id, mutability, cmt);\n@@ -1056,9 +1056,9 @@ fn link_local(rcx: &Rcx, local: &ast::Local) {\n         None => { return; }\n         Some(expr) => expr,\n     };\n-    let mc = mc::MemCategorizationContext { typer: rcx };\n+    let mc = mc::MemCategorizationContext::new(rcx);\n     let discr_cmt = ignore_err!(mc.cat_expr(init_expr));\n-    link_pattern(mc, discr_cmt, local.pat);\n+    link_pattern(rcx, mc, discr_cmt, local.pat);\n }\n \n fn link_match(rcx: &Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n@@ -1069,17 +1069,18 @@ fn link_match(rcx: &Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n      */\n \n     debug!(\"regionck::for_match()\");\n-    let mc = mc::MemCategorizationContext { typer: rcx };\n+    let mc = mc::MemCategorizationContext::new(rcx);\n     let discr_cmt = ignore_err!(mc.cat_expr(discr));\n-    debug!(\"discr_cmt={}\", discr_cmt.repr(mc.typer.tcx()));\n+    debug!(\"discr_cmt={}\", discr_cmt.repr(rcx.tcx()));\n     for arm in arms.iter() {\n         for &root_pat in arm.pats.iter() {\n-            link_pattern(mc, discr_cmt.clone(), root_pat);\n+            link_pattern(rcx, mc, discr_cmt.clone(), root_pat);\n         }\n     }\n }\n \n-fn link_pattern(mc: mc::MemCategorizationContext<&Rcx>,\n+fn link_pattern(rcx: &Rcx,\n+                mc: mc::MemCategorizationContext<Rcx>,\n                 discr_cmt: mc::cmt,\n                 root_pat: &ast::Pat) {\n     /*!\n@@ -1092,15 +1093,15 @@ fn link_pattern(mc: mc::MemCategorizationContext<&Rcx>,\n                 // `ref x` pattern\n                 ast::PatIdent(ast::BindByRef(mutbl), _, _) => {\n                     link_region_from_node_type(\n-                        mc.typer, sub_pat.span, sub_pat.id,\n+                        rcx, sub_pat.span, sub_pat.id,\n                         mutbl, sub_cmt);\n                 }\n \n                 // `[_, ..slice, _]` pattern\n                 ast::PatVec(_, Some(slice_pat), _) => {\n                     match mc.cat_slice_pattern(sub_cmt, slice_pat) {\n                         Ok((slice_cmt, slice_mutbl, slice_r)) => {\n-                            link_region(mc.typer, sub_pat.span, slice_r,\n+                            link_region(rcx, sub_pat.span, slice_r,\n                                         ty::BorrowKind::from_mutbl(slice_mutbl),\n                                         slice_cmt);\n                         }\n@@ -1122,25 +1123,25 @@ fn link_autoref(rcx: &Rcx,\n      */\n \n     debug!(\"link_autoref(autoref={:?})\", autoref);\n-    let mc = mc::MemCategorizationContext { typer: rcx };\n+    let mc = mc::MemCategorizationContext::new(rcx);\n     let expr_cmt = ignore_err!(mc.cat_expr_autoderefd(expr, autoderefs));\n-    debug!(\"expr_cmt={}\", expr_cmt.repr(mc.typer.tcx()));\n+    debug!(\"expr_cmt={}\", expr_cmt.repr(rcx.tcx()));\n \n     match *autoref {\n         ty::AutoPtr(r, m) => {\n-            link_region(mc.typer, expr.span, r,\n+            link_region(rcx, expr.span, r,\n                         ty::BorrowKind::from_mutbl(m), expr_cmt);\n         }\n \n         ty::AutoBorrowVec(r, m) | ty::AutoBorrowVecRef(r, m) => {\n             let cmt_index = mc.cat_index(expr, expr_cmt, autoderefs+1);\n-            link_region(mc.typer, expr.span, r,\n+            link_region(rcx, expr.span, r,\n                         ty::BorrowKind::from_mutbl(m), cmt_index);\n         }\n \n         ty::AutoBorrowObj(r, m) => {\n             let cmt_deref = mc.cat_deref_obj(expr, expr_cmt);\n-            link_region(mc.typer, expr.span, r,\n+            link_region(rcx, expr.span, r,\n                         ty::BorrowKind::from_mutbl(m), cmt_deref);\n         }\n \n@@ -1160,10 +1161,10 @@ fn link_by_ref(rcx: &Rcx,\n     let tcx = rcx.tcx();\n     debug!(\"link_by_ref(expr={}, callee_scope={})\",\n            expr.repr(tcx), callee_scope);\n-    let mc = mc::MemCategorizationContext { typer: rcx };\n+    let mc = mc::MemCategorizationContext::new(rcx);\n     let expr_cmt = ignore_err!(mc.cat_expr(expr));\n     let region_min = ty::ReScope(callee_scope);\n-    link_region(mc.typer, expr.span, region_min, ty::ImmBorrow, expr_cmt);\n+    link_region(rcx, expr.span, region_min, ty::ImmBorrow, expr_cmt);\n }\n \n fn link_region_from_node_type(rcx: &Rcx,\n@@ -1306,9 +1307,9 @@ fn adjust_borrow_kind_for_assignment_lhs(rcx: &Rcx,\n      * expression.\n      */\n \n-    let mc = mc::MemCategorizationContext { typer: rcx };\n+    let mc = mc::MemCategorizationContext::new(rcx);\n     let cmt = ignore_err!(mc.cat_expr(lhs));\n-    adjust_upvar_borrow_kind_for_mut(mc.typer, cmt);\n+    adjust_upvar_borrow_kind_for_mut(rcx, cmt);\n }\n \n fn adjust_upvar_borrow_kind_for_mut(rcx: &Rcx,"}, {"sha": "0fb9a2491db95db4c2e4a2e6501ce97e01bff85f", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=96dfed2b62c6e84a542f9a170133ec528e2191c2", "patch": "@@ -469,7 +469,6 @@ impl<'a, O: IdVisitingOperation> Visitor<()> for IdVisitor<'a, O> {\n         visit::walk_pat(self, pattern, env)\n     }\n \n-\n     fn visit_expr(&mut self, expression: &Expr, env: ()) {\n         self.operation.visit_id(expression.id);\n         visit::walk_expr(self, expression, env)\n@@ -590,6 +589,30 @@ pub fn compute_id_range_for_inlined_item(item: &InlinedItem) -> IdRange {\n     visitor.result.get()\n }\n \n+pub fn compute_id_range_for_fn_body(fk: &visit::FnKind,\n+                                    decl: &FnDecl,\n+                                    body: &Block,\n+                                    sp: Span,\n+                                    id: NodeId)\n+                                    -> IdRange\n+{\n+    /*!\n+     * Computes the id range for a single fn body,\n+     * ignoring nested items.\n+     */\n+\n+    let visitor = IdRangeComputingVisitor {\n+        result: Cell::new(IdRange::max())\n+    };\n+    let mut id_visitor = IdVisitor {\n+        operation: &visitor,\n+        pass_through_items: false,\n+        visited_outermost: false,\n+    };\n+    id_visitor.visit_fn(fk, decl, body, sp, id, ());\n+    visitor.result.get()\n+}\n+\n pub fn is_item_impl(item: @ast::Item) -> bool {\n     match item.node {\n         ItemImpl(..) => true,"}, {"sha": "3306d19186c55fea82dd08b2650467e05775eecb", "filename": "src/test/compile-fail/moves-sru-moved-field.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Ftest%2Fcompile-fail%2Fmoves-sru-moved-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96dfed2b62c6e84a542f9a170133ec528e2191c2/src%2Ftest%2Fcompile-fail%2Fmoves-sru-moved-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-sru-moved-field.rs?ref=96dfed2b62c6e84a542f9a170133ec528e2191c2", "patch": "@@ -25,13 +25,13 @@ fn test0(f: Foo, g: Noncopyable, h: Noncopyable) {\n fn test1(f: Foo, g: Noncopyable, h: Noncopyable) {\n     // copying move-by-default fields from `f`, so move:\n     let _b = Foo {noncopyable: g, ..f};\n-    let _c = Foo {noncopyable: h, ..f}; //~ ERROR use of moved value: `f`\n+    let _c = Foo {noncopyable: h, ..f}; //~ ERROR use of partially moved value: `f`\n }\n \n fn test2(f: Foo, g: Noncopyable) {\n     // move non-copyable field\n     let _b = Foo {copied: 22, moved: ~23, ..f};\n-    let _c = Foo {noncopyable: g, ..f}; //~ ERROR use of moved value: `f`\n+    let _c = Foo {noncopyable: g, ..f}; //~ ERROR use of partially moved value: `f`\n }\n \n fn main() {}"}]}