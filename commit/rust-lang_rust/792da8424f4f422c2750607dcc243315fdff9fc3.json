{"sha": "792da8424f4f422c2750607dcc243315fdff9fc3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5MmRhODQyNGY0ZjQyMmMyNzUwNjA3ZGNjMjQzMzE1ZmRmZjlmYzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-13T05:36:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-13T05:36:40Z"}, "message": "auto merge of #12823 : alexcrichton/rust/issue-12666, r=pcwalton\n\nIf a TTY fails to get initialized, it still needs to have uv_close invoked on\r\nit. This fixes the problem by constructing the TtyWatcher struct before the call\r\nto uv_tty_init. The struct has a destructor on it which will close the handle\r\nproperly.\r\n\r\nCloses #12666", "tree": {"sha": "379b00baf982ea5b67c998f7f94f61e7af21eaf2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/379b00baf982ea5b67c998f7f94f61e7af21eaf2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/792da8424f4f422c2750607dcc243315fdff9fc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/792da8424f4f422c2750607dcc243315fdff9fc3", "html_url": "https://github.com/rust-lang/rust/commit/792da8424f4f422c2750607dcc243315fdff9fc3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/792da8424f4f422c2750607dcc243315fdff9fc3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e86e1d88b2842671123d0a072d00c94bd3f39264", "url": "https://api.github.com/repos/rust-lang/rust/commits/e86e1d88b2842671123d0a072d00c94bd3f39264", "html_url": "https://github.com/rust-lang/rust/commit/e86e1d88b2842671123d0a072d00c94bd3f39264"}, {"sha": "65cca4bd3fa0abe1000662014b3e3ea1420728f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/65cca4bd3fa0abe1000662014b3e3ea1420728f5", "html_url": "https://github.com/rust-lang/rust/commit/65cca4bd3fa0abe1000662014b3e3ea1420728f5"}], "stats": {"total": 105, "additions": 93, "deletions": 12}, "files": [{"sha": "19c98c79b6abd9828baa4115ce833cb9b5906b80", "filename": "src/librustuv/tty.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/792da8424f4f422c2750607dcc243315fdff9fc3/src%2Flibrustuv%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792da8424f4f422c2750607dcc243315fdff9fc3/src%2Flibrustuv%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftty.rs?ref=792da8424f4f422c2750607dcc243315fdff9fc3", "patch": "@@ -8,8 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::libc;\n use std::io::IoError;\n+use std::libc;\n+use std::ptr;\n use std::rt::rtio::RtioTTY;\n \n use homing::{HomingIO, HomeHandle};\n@@ -54,20 +55,24 @@ impl TtyWatcher {\n         // If this file descriptor is indeed guessed to be a tty, then go ahead\n         // with attempting to open it as a tty.\n         let handle = UvHandle::alloc(None::<TtyWatcher>, uvll::UV_TTY);\n+        let mut watcher = TtyWatcher {\n+            tty: handle,\n+            stream: StreamWatcher::new(handle),\n+            home: io.make_handle(),\n+            fd: fd,\n+        };\n         match unsafe {\n             uvll::uv_tty_init(io.uv_loop(), handle, fd as libc::c_int,\n                               readable as libc::c_int)\n         } {\n-            0 => {\n-                Ok(TtyWatcher {\n-                    tty: handle,\n-                    stream: StreamWatcher::new(handle),\n-                    home: io.make_handle(),\n-                    fd: fd,\n-                })\n-            }\n+            0 => Ok(watcher),\n             n => {\n-                unsafe { uvll::free_handle(handle) }\n+                // On windows, libuv returns errors before initializing the\n+                // handle, so our only cleanup is to free the handle itself\n+                if cfg!(windows) {\n+                    unsafe { uvll::free_handle(handle); }\n+                    watcher.tty = ptr::null();\n+                }\n                 Err(UvError(n))\n             }\n         }\n@@ -124,7 +129,9 @@ impl HomingIO for TtyWatcher {\n \n impl Drop for TtyWatcher {\n     fn drop(&mut self) {\n-        let _m = self.fire_homing_missile();\n-        self.close_async_();\n+        if !self.tty.is_null() {\n+            let _m = self.fire_homing_missile();\n+            self.close_async_();\n+        }\n     }\n }"}, {"sha": "d1fc90cf007f0fb0c7705571b5d61444df52f378", "filename": "src/test/run-pass/tcp-stress.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/792da8424f4f422c2750607dcc243315fdff9fc3/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/792da8424f4f422c2750607dcc243315fdff9fc3/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-stress.rs?ref=792da8424f4f422c2750607dcc243315fdff9fc3", "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-linux see joyent/libuv#1189\n+// ignore-fast\n+// ignore-android needs extra network permissions\n+// exec-env:RUST_LOG=debug\n+\n+use std::libc;\n+use std::io::net::ip::{Ipv4Addr, SocketAddr};\n+use std::io::net::tcp::{TcpListener, TcpStream};\n+use std::io::{Acceptor, Listener};\n+\n+fn main() {\n+    // This test has a chance to time out, try to not let it time out\n+    spawn(proc() {\n+        use std::io::timer;\n+        timer::sleep(30 * 1000);\n+        println!(\"timed out!\");\n+        unsafe { libc::exit(1) }\n+    });\n+\n+    let addr = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 0 };\n+    let (p, c) = Chan::new();\n+    spawn(proc() {\n+        let mut listener = TcpListener::bind(addr).unwrap();\n+        c.send(listener.socket_name().unwrap());\n+        let mut acceptor = listener.listen();\n+        loop {\n+            let mut stream = match acceptor.accept() {\n+                Ok(stream) => stream,\n+                Err(error) => {\n+                    debug!(\"accept failed: {:?}\", error);\n+                    continue;\n+                }\n+            };\n+            stream.read_byte();\n+            stream.write([2]);\n+        }\n+    });\n+    let addr = p.recv();\n+\n+    let (p, c) = Chan::new();\n+    for _ in range(0, 1000) {\n+        let c = c.clone();\n+        spawn(proc() {\n+            match TcpStream::connect(addr) {\n+                Ok(stream) => {\n+                    let mut stream = stream;\n+                    stream.write([1]);\n+                    let mut buf = [0];\n+                    stream.read(buf);\n+                },\n+                Err(e) => debug!(\"{:?}\", e)\n+            }\n+            c.send(());\n+        });\n+    }\n+\n+    // Wait for all clients to exit, but don't wait for the server to exit. The\n+    // server just runs infinitely.\n+    drop(c);\n+    for _ in range(0, 1000) {\n+        p.recv();\n+    }\n+    unsafe { libc::exit(0) }\n+}"}]}