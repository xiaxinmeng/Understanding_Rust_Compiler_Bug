{"sha": "c9fdeef643329266cedb67369328795c4abb7740", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5ZmRlZWY2NDMzMjkyNjZjZWRiNjczNjkzMjg3OTVjNGFiYjc3NDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-06T06:59:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-06T06:59:33Z"}, "message": "Auto merge of #6078 - ebroto:unnecessary_sort_by_take_2, r=phansch\n\nunnecessary sort by: avoid dereferencing the suggested closure parameter\n\nThis change tries to simplify the solution for problematic cases but is less restrictive than  #6006.\n\n* We can't dereference shared references to non-Copy types, so the new suggestion does not do that. Note that this implies that the suggested closure parameter will be a reference.\n* We can't take a reference to the closure parameter in the returned key, so we don't lint in those cases. This can happen either because the key borrows from the parameter (e.g. `|a| a.borrows()`), or because we suggest `|a| Reverse(a)`. If we did we would hit this error:\n```\nerror: lifetime may not live long enough\n  --> /home/ebroto/src/ebroto-clippy/tests/ui/unnecessary_sort_by.fixed:19:25\n   |\n19 |     vec.sort_by_key(|b| Reverse(b));\n   |                      -- ^^^^^^^^^^ returning this value requires that `'1` must outlive `'2`\n   |                      ||\n   |                      |return type of closure is Reverse<&'2 isize>\n   |                      has type `&'1 isize`\n\nerror: aborting due to previous error\n```\n\nNote that Clippy does not currently have the (MIR-based) machinery necessary to check that what is borrowed is actually the closure parameter.\n\nchangelog: [`unnecessary_sort_by`]: avoid dereferencing the suggested closure parameter\n\nFixes #6001", "tree": {"sha": "04e575fde9c7c9ca78d004a116a2756bd71a3f7b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04e575fde9c7c9ca78d004a116a2756bd71a3f7b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9fdeef643329266cedb67369328795c4abb7740", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9fdeef643329266cedb67369328795c4abb7740", "html_url": "https://github.com/rust-lang/rust/commit/c9fdeef643329266cedb67369328795c4abb7740", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9fdeef643329266cedb67369328795c4abb7740/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3239b46e920be50dd486d7565db070598aa65a46", "url": "https://api.github.com/repos/rust-lang/rust/commits/3239b46e920be50dd486d7565db070598aa65a46", "html_url": "https://github.com/rust-lang/rust/commit/3239b46e920be50dd486d7565db070598aa65a46"}, {"sha": "9365660a2fc57210996df733efe468019c671b2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9365660a2fc57210996df733efe468019c671b2f", "html_url": "https://github.com/rust-lang/rust/commit/9365660a2fc57210996df733efe468019c671b2f"}], "stats": {"total": 150, "additions": 81, "deletions": 69}, "files": [{"sha": "1307237dbc70a98ec5997f370212c5c2d80cebb7", "filename": "clippy_lints/src/unnecessary_sort_by.rs", "status": "modified", "additions": 20, "deletions": 38, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c9fdeef643329266cedb67369328795c4abb7740/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9fdeef643329266cedb67369328795c4abb7740/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs?ref=c9fdeef643329266cedb67369328795c4abb7740", "patch": "@@ -170,22 +170,12 @@ fn mirrored_exprs(\n }\n \n fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n-    // NOTE: Vectors of references are not supported. In order to avoid hitting https://github.com/rust-lang/rust/issues/34162,\n-    // (different unnamed lifetimes for closure arg and return type) we need to make sure the suggested\n-    // closure parameter is not a reference in case we suggest `Reverse`. Trying to destructure more\n-    // than one level of references would add some extra complexity as we would have to compensate\n-    // in the closure body.\n-\n     if_chain! {\n         if let ExprKind::MethodCall(name_ident, _, args, _) = &expr.kind;\n         if let name = name_ident.ident.name.to_ident_string();\n         if name == \"sort_by\" || name == \"sort_unstable_by\";\n         if let [vec, Expr { kind: ExprKind::Closure(_, _, closure_body_id, _, _), .. }] = args;\n-        let vec_ty = cx.typeck_results().expr_ty(vec);\n-        if utils::is_type_diagnostic_item(cx, vec_ty, sym!(vec_type));\n-        let ty = vec_ty.walk().nth(1).unwrap().expect_ty(); // T in Vec<T>\n-        if !matches!(&ty.kind(), ty::Ref(..));\n-        if utils::is_copy(cx, ty);\n+        if utils::is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(vec), sym!(vec_type));\n         if let closure_body = cx.tcx.hir().body(*closure_body_id);\n         if let &[\n             Param { pat: Pat { kind: PatKind::Binding(_, _, left_ident, _), .. }, ..},\n@@ -210,40 +200,32 @@ fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n             let vec_name = Sugg::hir(cx, &args[0], \"..\").to_string();\n             let unstable = name == \"sort_unstable_by\";\n \n-            if_chain! {\n-                if let ExprKind::Path(QPath::Resolved(_, Path {\n-                    segments: [PathSegment { ident: left_name, .. }], ..\n-                })) = &left_expr.kind;\n-                if left_name == left_ident;\n-                then {\n-                    return Some(LintTrigger::Sort(SortDetection { vec_name, unstable }))\n-                } else {\n-                    if !key_returns_borrow(cx, left_expr) {\n-                        return Some(LintTrigger::SortByKey(SortByKeyDetection {\n-                            vec_name,\n-                            unstable,\n-                            closure_arg,\n-                            closure_body,\n-                            reverse\n-                        }))\n-                    }\n+            if let ExprKind::Path(QPath::Resolved(_, Path {\n+                segments: [PathSegment { ident: left_name, .. }], ..\n+            })) = &left_expr.kind {\n+                if left_name == left_ident {\n+                    return Some(LintTrigger::Sort(SortDetection { vec_name, unstable }));\n                 }\n             }\n+\n+            if !expr_borrows(cx, left_expr) {\n+                return Some(LintTrigger::SortByKey(SortByKeyDetection {\n+                    vec_name,\n+                    unstable,\n+                    closure_arg,\n+                    closure_body,\n+                    reverse\n+                }));\n+            }\n         }\n     }\n \n     None\n }\n \n-fn key_returns_borrow(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    if let Some(def_id) = utils::fn_def_id(cx, expr) {\n-        let output = cx.tcx.fn_sig(def_id).output();\n-        let ty = output.skip_binder();\n-        return matches!(ty.kind(), ty::Ref(..))\n-            || ty.walk().any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)));\n-    }\n-\n-    false\n+fn expr_borrows(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    let ty = cx.typeck_results().expr_ty(expr);\n+    matches!(ty.kind(), ty::Ref(..)) || ty.walk().any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)))\n }\n \n impl LateLintPass<'_> for UnnecessarySortBy {\n@@ -256,7 +238,7 @@ impl LateLintPass<'_> for UnnecessarySortBy {\n                 \"use Vec::sort_by_key here instead\",\n                 \"try\",\n                 format!(\n-                    \"{}.sort{}_by_key(|&{}| {})\",\n+                    \"{}.sort{}_by_key(|{}| {})\",\n                     trigger.vec_name,\n                     if trigger.unstable { \"_unstable\" } else { \"\" },\n                     trigger.closure_arg,"}, {"sha": "b45b27d8f23b1a92bc006bc64104b97302beda7c", "filename": "tests/ui/unnecessary_sort_by.fixed", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c9fdeef643329266cedb67369328795c4abb7740/tests%2Fui%2Funnecessary_sort_by.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c9fdeef643329266cedb67369328795c4abb7740/tests%2Fui%2Funnecessary_sort_by.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_sort_by.fixed?ref=c9fdeef643329266cedb67369328795c4abb7740", "patch": "@@ -13,23 +13,24 @@ fn unnecessary_sort_by() {\n     // Forward examples\n     vec.sort();\n     vec.sort_unstable();\n-    vec.sort_by_key(|&a| (a + 5).abs());\n-    vec.sort_unstable_by_key(|&a| id(-a));\n+    vec.sort_by_key(|a| (a + 5).abs());\n+    vec.sort_unstable_by_key(|a| id(-a));\n     // Reverse examples\n-    vec.sort_by_key(|&b| Reverse(b));\n-    vec.sort_by_key(|&b| Reverse((b + 5).abs()));\n-    vec.sort_unstable_by_key(|&b| Reverse(id(-b)));\n+    vec.sort_by(|a, b| b.cmp(a)); // not linted to avoid suggesting `Reverse(b)` which would borrow\n+    vec.sort_by_key(|b| Reverse((b + 5).abs()));\n+    vec.sort_unstable_by_key(|b| Reverse(id(-b)));\n     // Negative examples (shouldn't be changed)\n     let c = &7;\n     vec.sort_by(|a, b| (b - a).cmp(&(a - b)));\n     vec.sort_by(|_, b| b.cmp(&5));\n     vec.sort_by(|_, b| b.cmp(c));\n     vec.sort_unstable_by(|a, _| a.cmp(c));\n \n-    // Ignore vectors of references\n+    // Vectors of references are fine as long as the resulting key does not borrow\n     let mut vec: Vec<&&&isize> = vec![&&&3, &&&6, &&&1, &&&2, &&&5];\n-    vec.sort_by(|a, b| (***a).abs().cmp(&(***b).abs()));\n-    vec.sort_unstable_by(|a, b| (***a).abs().cmp(&(***b).abs()));\n+    vec.sort_by_key(|a| (***a).abs());\n+    vec.sort_unstable_by_key(|a| (***a).abs());\n+    // `Reverse(b)` would borrow in the following cases, don't lint\n     vec.sort_by(|a, b| b.cmp(a));\n     vec.sort_unstable_by(|a, b| b.cmp(a));\n }\n@@ -68,10 +69,9 @@ mod issue_5754 {\n     }\n }\n \n-// `Vec::sort_by_key` closure parameter is `F: FnMut(&T) -> K`\n-// The suggestion is destructuring T and we know T is not a reference, so test that non-Copy T are\n-// not linted.\n+// The closure parameter is not dereferenced anymore, so non-Copy types can be linted\n mod issue_6001 {\n+    use super::*;\n     struct Test(String);\n \n     impl Test {\n@@ -85,11 +85,11 @@ mod issue_6001 {\n         let mut args: Vec<Test> = vec![];\n \n         // Forward\n-        args.sort_by(|a, b| a.name().cmp(&b.name()));\n-        args.sort_unstable_by(|a, b| a.name().cmp(&b.name()));\n+        args.sort_by_key(|a| a.name());\n+        args.sort_unstable_by_key(|a| a.name());\n         // Reverse\n-        args.sort_by(|a, b| b.name().cmp(&a.name()));\n-        args.sort_unstable_by(|a, b| b.name().cmp(&a.name()));\n+        args.sort_by_key(|b| Reverse(b.name()));\n+        args.sort_unstable_by_key(|b| Reverse(b.name()));\n     }\n }\n "}, {"sha": "be2abe7f7014d785b59ccae8875d550829a3ca23", "filename": "tests/ui/unnecessary_sort_by.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c9fdeef643329266cedb67369328795c4abb7740/tests%2Fui%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9fdeef643329266cedb67369328795c4abb7740/tests%2Fui%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_sort_by.rs?ref=c9fdeef643329266cedb67369328795c4abb7740", "patch": "@@ -16,7 +16,7 @@ fn unnecessary_sort_by() {\n     vec.sort_by(|a, b| (a + 5).abs().cmp(&(b + 5).abs()));\n     vec.sort_unstable_by(|a, b| id(-a).cmp(&id(-b)));\n     // Reverse examples\n-    vec.sort_by(|a, b| b.cmp(a));\n+    vec.sort_by(|a, b| b.cmp(a)); // not linted to avoid suggesting `Reverse(b)` which would borrow\n     vec.sort_by(|a, b| (b + 5).abs().cmp(&(a + 5).abs()));\n     vec.sort_unstable_by(|a, b| id(-b).cmp(&id(-a)));\n     // Negative examples (shouldn't be changed)\n@@ -26,10 +26,11 @@ fn unnecessary_sort_by() {\n     vec.sort_by(|_, b| b.cmp(c));\n     vec.sort_unstable_by(|a, _| a.cmp(c));\n \n-    // Ignore vectors of references\n+    // Vectors of references are fine as long as the resulting key does not borrow\n     let mut vec: Vec<&&&isize> = vec![&&&3, &&&6, &&&1, &&&2, &&&5];\n     vec.sort_by(|a, b| (***a).abs().cmp(&(***b).abs()));\n     vec.sort_unstable_by(|a, b| (***a).abs().cmp(&(***b).abs()));\n+    // `Reverse(b)` would borrow in the following cases, don't lint\n     vec.sort_by(|a, b| b.cmp(a));\n     vec.sort_unstable_by(|a, b| b.cmp(a));\n }\n@@ -68,10 +69,9 @@ mod issue_5754 {\n     }\n }\n \n-// `Vec::sort_by_key` closure parameter is `F: FnMut(&T) -> K`\n-// The suggestion is destructuring T and we know T is not a reference, so test that non-Copy T are\n-// not linted.\n+// The closure parameter is not dereferenced anymore, so non-Copy types can be linted\n mod issue_6001 {\n+    use super::*;\n     struct Test(String);\n \n     impl Test {"}, {"sha": "50607933e18f7b5ed5dc012a362eb03f9d910240", "filename": "tests/ui/unnecessary_sort_by.stderr", "status": "modified", "additions": 41, "deletions": 11, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c9fdeef643329266cedb67369328795c4abb7740/tests%2Fui%2Funnecessary_sort_by.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c9fdeef643329266cedb67369328795c4abb7740/tests%2Fui%2Funnecessary_sort_by.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_sort_by.stderr?ref=c9fdeef643329266cedb67369328795c4abb7740", "patch": "@@ -16,31 +16,61 @@ error: use Vec::sort_by_key here instead\n   --> $DIR/unnecessary_sort_by.rs:16:5\n    |\n LL |     vec.sort_by(|a, b| (a + 5).abs().cmp(&(b + 5).abs()));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_by_key(|&a| (a + 5).abs())`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_by_key(|a| (a + 5).abs())`\n \n error: use Vec::sort_by_key here instead\n   --> $DIR/unnecessary_sort_by.rs:17:5\n    |\n LL |     vec.sort_unstable_by(|a, b| id(-a).cmp(&id(-b)));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_unstable_by_key(|&a| id(-a))`\n-\n-error: use Vec::sort_by_key here instead\n-  --> $DIR/unnecessary_sort_by.rs:19:5\n-   |\n-LL |     vec.sort_by(|a, b| b.cmp(a));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_by_key(|&b| Reverse(b))`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_unstable_by_key(|a| id(-a))`\n \n error: use Vec::sort_by_key here instead\n   --> $DIR/unnecessary_sort_by.rs:20:5\n    |\n LL |     vec.sort_by(|a, b| (b + 5).abs().cmp(&(a + 5).abs()));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_by_key(|&b| Reverse((b + 5).abs()))`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_by_key(|b| Reverse((b + 5).abs()))`\n \n error: use Vec::sort_by_key here instead\n   --> $DIR/unnecessary_sort_by.rs:21:5\n    |\n LL |     vec.sort_unstable_by(|a, b| id(-b).cmp(&id(-a)));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_unstable_by_key(|&b| Reverse(id(-b)))`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_unstable_by_key(|b| Reverse(id(-b)))`\n+\n+error: use Vec::sort_by_key here instead\n+  --> $DIR/unnecessary_sort_by.rs:31:5\n+   |\n+LL |     vec.sort_by(|a, b| (***a).abs().cmp(&(***b).abs()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_by_key(|a| (***a).abs())`\n+\n+error: use Vec::sort_by_key here instead\n+  --> $DIR/unnecessary_sort_by.rs:32:5\n+   |\n+LL |     vec.sort_unstable_by(|a, b| (***a).abs().cmp(&(***b).abs()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_unstable_by_key(|a| (***a).abs())`\n+\n+error: use Vec::sort_by_key here instead\n+  --> $DIR/unnecessary_sort_by.rs:88:9\n+   |\n+LL |         args.sort_by(|a, b| a.name().cmp(&b.name()));\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `args.sort_by_key(|a| a.name())`\n+\n+error: use Vec::sort_by_key here instead\n+  --> $DIR/unnecessary_sort_by.rs:89:9\n+   |\n+LL |         args.sort_unstable_by(|a, b| a.name().cmp(&b.name()));\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `args.sort_unstable_by_key(|a| a.name())`\n+\n+error: use Vec::sort_by_key here instead\n+  --> $DIR/unnecessary_sort_by.rs:91:9\n+   |\n+LL |         args.sort_by(|a, b| b.name().cmp(&a.name()));\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `args.sort_by_key(|b| Reverse(b.name()))`\n+\n+error: use Vec::sort_by_key here instead\n+  --> $DIR/unnecessary_sort_by.rs:92:9\n+   |\n+LL |         args.sort_unstable_by(|a, b| b.name().cmp(&a.name()));\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `args.sort_unstable_by_key(|b| Reverse(b.name()))`\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 12 previous errors\n "}]}