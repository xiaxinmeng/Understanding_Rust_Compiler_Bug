{"sha": "33c6c7abc6621f8b0cf083a98f7e4788cf4b5b54", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzYzZjN2FiYzY2MjFmOGIwY2YwODNhOThmN2U0Nzg4Y2Y0YjViNTQ=", "commit": {"author": {"name": "Emil Lauridsen", "email": "mine809@gmail.com", "date": "2020-03-16T12:43:29Z"}, "committer": {"name": "Emil Lauridsen", "email": "mine809@gmail.com", "date": "2020-03-17T13:47:05Z"}, "message": "Support loading OUT_DIR from cargo check at launch", "tree": {"sha": "4b763fd11f25db269eacd9302042a54b50eda174", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b763fd11f25db269eacd9302042a54b50eda174"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33c6c7abc6621f8b0cf083a98f7e4788cf4b5b54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33c6c7abc6621f8b0cf083a98f7e4788cf4b5b54", "html_url": "https://github.com/rust-lang/rust/commit/33c6c7abc6621f8b0cf083a98f7e4788cf4b5b54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33c6c7abc6621f8b0cf083a98f7e4788cf4b5b54/comments", "author": {"login": "kiljacken", "id": 209321, "node_id": "MDQ6VXNlcjIwOTMyMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/209321?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kiljacken", "html_url": "https://github.com/kiljacken", "followers_url": "https://api.github.com/users/kiljacken/followers", "following_url": "https://api.github.com/users/kiljacken/following{/other_user}", "gists_url": "https://api.github.com/users/kiljacken/gists{/gist_id}", "starred_url": "https://api.github.com/users/kiljacken/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kiljacken/subscriptions", "organizations_url": "https://api.github.com/users/kiljacken/orgs", "repos_url": "https://api.github.com/users/kiljacken/repos", "events_url": "https://api.github.com/users/kiljacken/events{/privacy}", "received_events_url": "https://api.github.com/users/kiljacken/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kiljacken", "id": 209321, "node_id": "MDQ6VXNlcjIwOTMyMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/209321?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kiljacken", "html_url": "https://github.com/kiljacken", "followers_url": "https://api.github.com/users/kiljacken/followers", "following_url": "https://api.github.com/users/kiljacken/following{/other_user}", "gists_url": "https://api.github.com/users/kiljacken/gists{/gist_id}", "starred_url": "https://api.github.com/users/kiljacken/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kiljacken/subscriptions", "organizations_url": "https://api.github.com/users/kiljacken/orgs", "repos_url": "https://api.github.com/users/kiljacken/repos", "events_url": "https://api.github.com/users/kiljacken/events{/privacy}", "received_events_url": "https://api.github.com/users/kiljacken/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2720e2374be951bb762ff2815dd67c7ffe3419b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/2720e2374be951bb762ff2815dd67c7ffe3419b7", "html_url": "https://github.com/rust-lang/rust/commit/2720e2374be951bb762ff2815dd67c7ffe3419b7"}], "stats": {"total": 362, "additions": 248, "deletions": 114}, "files": [{"sha": "f7685772485701ba3b02dd83b0cf517f909b6891", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/33c6c7abc6621f8b0cf083a98f7e4788cf4b5b54/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/33c6c7abc6621f8b0cf083a98f7e4788cf4b5b54/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=33c6c7abc6621f8b0cf083a98f7e4788cf4b5b54", "patch": "@@ -1092,6 +1092,7 @@ dependencies = [\n  \"cargo_metadata\",\n  \"log\",\n  \"ra_arena\",\n+ \"ra_cargo_watch\",\n  \"ra_cfg\",\n  \"ra_db\",\n  \"rustc-hash\","}, {"sha": "71aa28f0a6b880b6c0cafd34d8cc0d13bc36445e", "filename": "crates/ra_cargo_watch/src/lib.rs", "status": "modified", "additions": 96, "deletions": 79, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/33c6c7abc6621f8b0cf083a98f7e4788cf4b5b54/crates%2Fra_cargo_watch%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c6c7abc6621f8b0cf083a98f7e4788cf4b5b54/crates%2Fra_cargo_watch%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cargo_watch%2Fsrc%2Flib.rs?ref=33c6c7abc6621f8b0cf083a98f7e4788cf4b5b54", "patch": "@@ -9,8 +9,8 @@ use lsp_types::{\n };\n use std::{\n     io::{BufRead, BufReader},\n-    path::PathBuf,\n-    process::{Command, Stdio},\n+    path::{Path, PathBuf},\n+    process::{Child, Command, Stdio},\n     thread::JoinHandle,\n     time::Instant,\n };\n@@ -246,102 +246,119 @@ enum CheckEvent {\n     End,\n }\n \n+pub fn run_cargo(\n+    args: &[String],\n+    current_dir: Option<&Path>,\n+    mut on_message: impl FnMut(cargo_metadata::Message) -> bool,\n+) -> Child {\n+    let mut command = Command::new(\"cargo\");\n+    if let Some(current_dir) = current_dir {\n+        command.current_dir(current_dir);\n+    }\n+\n+    let mut child = command\n+        .args(args)\n+        .stdout(Stdio::piped())\n+        .stderr(Stdio::null())\n+        .stdin(Stdio::null())\n+        .spawn()\n+        .expect(\"couldn't launch cargo\");\n+\n+    // We manually read a line at a time, instead of using serde's\n+    // stream deserializers, because the deserializer cannot recover\n+    // from an error, resulting in it getting stuck, because we try to\n+    // be resillient against failures.\n+    //\n+    // Because cargo only outputs one JSON object per line, we can\n+    // simply skip a line if it doesn't parse, which just ignores any\n+    // erroneus output.\n+    let stdout = BufReader::new(child.stdout.take().unwrap());\n+    for line in stdout.lines() {\n+        let line = match line {\n+            Ok(line) => line,\n+            Err(err) => {\n+                log::error!(\"Couldn't read line from cargo: {}\", err);\n+                continue;\n+            }\n+        };\n+\n+        let message = serde_json::from_str::<cargo_metadata::Message>(&line);\n+        let message = match message {\n+            Ok(message) => message,\n+            Err(err) => {\n+                log::error!(\"Invalid json from cargo check, ignoring ({}): {:?} \", err, line);\n+                continue;\n+            }\n+        };\n+\n+        if !on_message(message) {\n+            break;\n+        }\n+    }\n+\n+    child\n+}\n+\n impl WatchThread {\n     fn dummy() -> WatchThread {\n         WatchThread { handle: None, message_recv: never() }\n     }\n \n-    fn new(options: &CheckOptions, workspace_root: &PathBuf) -> WatchThread {\n+    fn new(options: &CheckOptions, workspace_root: &Path) -> WatchThread {\n         let mut args: Vec<String> = vec![\n             options.command.clone(),\n             \"--workspace\".to_string(),\n             \"--message-format=json\".to_string(),\n             \"--manifest-path\".to_string(),\n-            format!(\"{}/Cargo.toml\", workspace_root.to_string_lossy()),\n+            format!(\"{}/Cargo.toml\", workspace_root.display()),\n         ];\n         if options.all_targets {\n             args.push(\"--all-targets\".to_string());\n         }\n         args.extend(options.args.iter().cloned());\n \n         let (message_send, message_recv) = unbounded();\n-        let enabled = options.enable;\n-        let handle = std::thread::spawn(move || {\n-            if !enabled {\n-                return;\n-            }\n-\n-            let mut command = Command::new(\"cargo\")\n-                .args(&args)\n-                .stdout(Stdio::piped())\n-                .stderr(Stdio::null())\n-                .stdin(Stdio::null())\n-                .spawn()\n-                .expect(\"couldn't launch cargo\");\n-\n-            // If we trigger an error here, we will do so in the loop instead,\n-            // which will break out of the loop, and continue the shutdown\n-            let _ = message_send.send(CheckEvent::Begin);\n-\n-            // We manually read a line at a time, instead of using serde's\n-            // stream deserializers, because the deserializer cannot recover\n-            // from an error, resulting in it getting stuck, because we try to\n-            // be resillient against failures.\n-            //\n-            // Because cargo only outputs one JSON object per line, we can\n-            // simply skip a line if it doesn't parse, which just ignores any\n-            // erroneus output.\n-            let stdout = BufReader::new(command.stdout.take().unwrap());\n-            for line in stdout.lines() {\n-                let line = match line {\n-                    Ok(line) => line,\n-                    Err(err) => {\n-                        log::error!(\"Couldn't read line from cargo: {}\", err);\n-                        continue;\n-                    }\n-                };\n-\n-                let message = serde_json::from_str::<cargo_metadata::Message>(&line);\n-                let message = match message {\n-                    Ok(message) => message,\n-                    Err(err) => {\n-                        log::error!(\n-                            \"Invalid json from cargo check, ignoring ({}): {:?} \",\n-                            err,\n-                            line\n-                        );\n-                        continue;\n+        let workspace_root = workspace_root.to_owned();\n+        let handle = if options.enable {\n+            Some(std::thread::spawn(move || {\n+                // If we trigger an error here, we will do so in the loop instead,\n+                // which will break out of the loop, and continue the shutdown\n+                let _ = message_send.send(CheckEvent::Begin);\n+\n+                let mut child = run_cargo(&args, Some(&workspace_root), |message| {\n+                    // Skip certain kinds of messages to only spend time on what's useful\n+                    match &message {\n+                        Message::CompilerArtifact(artifact) if artifact.fresh => return true,\n+                        Message::BuildScriptExecuted(_) => return true,\n+                        Message::Unknown => return true,\n+                        _ => {}\n                     }\n-                };\n-\n-                // Skip certain kinds of messages to only spend time on what's useful\n-                match &message {\n-                    Message::CompilerArtifact(artifact) if artifact.fresh => continue,\n-                    Message::BuildScriptExecuted(_) => continue,\n-                    Message::Unknown => continue,\n-                    _ => {}\n-                }\n \n-                match message_send.send(CheckEvent::Msg(message)) {\n-                    Ok(()) => {}\n-                    Err(_err) => {\n-                        // The send channel was closed, so we want to shutdown\n-                        break;\n-                    }\n-                }\n-            }\n-\n-            // We can ignore any error here, as we are already in the progress\n-            // of shutting down.\n-            let _ = message_send.send(CheckEvent::End);\n-\n-            // It is okay to ignore the result, as it only errors if the process is already dead\n-            let _ = command.kill();\n-\n-            // Again, we don't care about the exit status so just ignore the result\n-            let _ = command.wait();\n-        });\n-        WatchThread { handle: Some(handle), message_recv }\n+                    match message_send.send(CheckEvent::Msg(message)) {\n+                        Ok(()) => {}\n+                        Err(_err) => {\n+                            // The send channel was closed, so we want to shutdown\n+                            return false;\n+                        }\n+                    };\n+\n+                    true\n+                });\n+\n+                // We can ignore any error here, as we are already in the progress\n+                // of shutting down.\n+                let _ = message_send.send(CheckEvent::End);\n+\n+                // It is okay to ignore the result, as it only errors if the process is already dead\n+                let _ = child.kill();\n+\n+                // Again, we don't care about the exit status so just ignore the result\n+                let _ = child.wait();\n+            }))\n+        } else {\n+            None\n+        };\n+        WatchThread { handle, message_recv }\n     }\n }\n "}, {"sha": "e371f849dff95edd8db4e0b1950ef1725a68da52", "filename": "crates/ra_db/src/input.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/33c6c7abc6621f8b0cf083a98f7e4788cf4b5b54/crates%2Fra_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c6c7abc6621f8b0cf083a98f7e4788cf4b5b54/crates%2Fra_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Finput.rs?ref=33c6c7abc6621f8b0cf083a98f7e4788cf4b5b54", "patch": "@@ -6,7 +6,11 @@\n //! actual IO. See `vfs` and `project_model` in the `rust-analyzer` crate for how\n //! actual IO is done and lowered to input.\n \n-use std::{fmt, ops, str::FromStr};\n+use std::{\n+    fmt, ops,\n+    path::{Path, PathBuf},\n+    str::FromStr,\n+};\n \n use ra_cfg::CfgOptions;\n use ra_syntax::SmolStr;\n@@ -144,7 +148,7 @@ pub struct Env {\n // crate. We store a map to allow remap it to ExternSourceId\n #[derive(Default, Debug, Clone, PartialEq, Eq)]\n pub struct ExternSource {\n-    extern_paths: FxHashMap<String, ExternSourceId>,\n+    extern_paths: FxHashMap<PathBuf, ExternSourceId>,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -294,13 +298,10 @@ impl Env {\n }\n \n impl ExternSource {\n-    pub fn extern_path(&self, path: &str) -> Option<(ExternSourceId, RelativePathBuf)> {\n+    pub fn extern_path(&self, path: impl AsRef<Path>) -> Option<(ExternSourceId, RelativePathBuf)> {\n+        let path = path.as_ref();\n         self.extern_paths.iter().find_map(|(root_path, id)| {\n-            if path.starts_with(root_path) {\n-                let mut rel_path = &path[root_path.len()..];\n-                if rel_path.starts_with(\"/\") {\n-                    rel_path = &rel_path[1..];\n-                }\n+            if let Ok(rel_path) = path.strip_prefix(root_path) {\n                 let rel_path = RelativePathBuf::from_path(rel_path).ok()?;\n                 Some((id.clone(), rel_path))\n             } else {\n@@ -309,8 +310,8 @@ impl ExternSource {\n         })\n     }\n \n-    pub fn set_extern_path(&mut self, root_path: &str, root: ExternSourceId) {\n-        self.extern_paths.insert(root_path.to_owned(), root);\n+    pub fn set_extern_path(&mut self, root_path: &Path, root: ExternSourceId) {\n+        self.extern_paths.insert(root_path.to_path_buf(), root);\n     }\n }\n "}, {"sha": "22300548a7ffd323f356d6a618e0d9d773eef853", "filename": "crates/ra_project_model/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/33c6c7abc6621f8b0cf083a98f7e4788cf4b5b54/crates%2Fra_project_model%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/33c6c7abc6621f8b0cf083a98f7e4788cf4b5b54/crates%2Fra_project_model%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2FCargo.toml?ref=33c6c7abc6621f8b0cf083a98f7e4788cf4b5b54", "patch": "@@ -16,6 +16,7 @@ cargo_metadata = \"0.9.1\"\n ra_arena = { path = \"../ra_arena\" }\n ra_db = { path = \"../ra_db\" }\n ra_cfg = { path = \"../ra_cfg\" }\n+ra_cargo_watch = { path = \"../ra_cargo_watch\" }\n \n serde = { version = \"1.0.104\", features = [\"derive\"] }\n serde_json = \"1.0.48\""}, {"sha": "eeeb102339d7f7b1894328442bcf370c496738ad", "filename": "crates/ra_project_model/src/cargo_workspace.rs", "status": "modified", "additions": 65, "deletions": 2, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/33c6c7abc6621f8b0cf083a98f7e4788cf4b5b54/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c6c7abc6621f8b0cf083a98f7e4788cf4b5b54/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs?ref=33c6c7abc6621f8b0cf083a98f7e4788cf4b5b54", "patch": "@@ -3,8 +3,9 @@\n use std::path::{Path, PathBuf};\n \n use anyhow::{Context, Result};\n-use cargo_metadata::{CargoOpt, MetadataCommand};\n+use cargo_metadata::{CargoOpt, Message, MetadataCommand, PackageId};\n use ra_arena::{impl_arena_id, Arena, RawId};\n+use ra_cargo_watch::run_cargo;\n use ra_db::Edition;\n use rustc_hash::FxHashMap;\n use serde::Deserialize;\n@@ -35,11 +36,19 @@ pub struct CargoFeatures {\n     /// List of features to activate.\n     /// This will be ignored if `cargo_all_features` is true.\n     pub features: Vec<String>,\n+\n+    /// Runs cargo check on launch to figure out the correct values of OUT_DIR\n+    pub load_out_dirs_from_check: bool,\n }\n \n impl Default for CargoFeatures {\n     fn default() -> Self {\n-        CargoFeatures { no_default_features: false, all_features: true, features: Vec::new() }\n+        CargoFeatures {\n+            no_default_features: false,\n+            all_features: true,\n+            features: Vec::new(),\n+            load_out_dirs_from_check: false,\n+        }\n     }\n }\n \n@@ -60,6 +69,7 @@ struct PackageData {\n     dependencies: Vec<PackageDependency>,\n     edition: Edition,\n     features: Vec<String>,\n+    out_dir: Option<PathBuf>,\n }\n \n #[derive(Debug, Clone)]\n@@ -131,6 +141,9 @@ impl Package {\n     ) -> impl Iterator<Item = &'a PackageDependency> + 'a {\n         ws.packages[self].dependencies.iter()\n     }\n+    pub fn out_dir(self, ws: &CargoWorkspace) -> Option<&Path> {\n+        ws.packages[self].out_dir.as_ref().map(|od| od.as_path())\n+    }\n }\n \n impl Target {\n@@ -173,6 +186,12 @@ impl CargoWorkspace {\n         let meta = meta.exec().with_context(|| {\n             format!(\"Failed to run `cargo metadata --manifest-path {}`\", cargo_toml.display())\n         })?;\n+\n+        let mut out_dir_by_id = FxHashMap::default();\n+        if cargo_features.load_out_dirs_from_check {\n+            out_dir_by_id = load_out_dirs(cargo_toml, cargo_features);\n+        }\n+\n         let mut pkg_by_id = FxHashMap::default();\n         let mut packages = Arena::default();\n         let mut targets = Arena::default();\n@@ -193,6 +212,7 @@ impl CargoWorkspace {\n                 edition,\n                 dependencies: Vec::new(),\n                 features: Vec::new(),\n+                out_dir: out_dir_by_id.get(&id).cloned(),\n             });\n             let pkg_data = &mut packages[pkg];\n             pkg_by_id.insert(id, pkg);\n@@ -252,3 +272,46 @@ impl CargoWorkspace {\n         &self.workspace_root\n     }\n }\n+\n+pub fn load_out_dirs(\n+    cargo_toml: &Path,\n+    cargo_features: &CargoFeatures,\n+) -> FxHashMap<PackageId, PathBuf> {\n+    let mut args: Vec<String> = vec![\n+        \"check\".to_string(),\n+        \"--message-format=json\".to_string(),\n+        \"--manifest-path\".to_string(),\n+        format!(\"{}\", cargo_toml.display()),\n+    ];\n+\n+    if cargo_features.all_features {\n+        args.push(\"--all-features\".to_string());\n+    } else if cargo_features.no_default_features {\n+        // FIXME: `NoDefaultFeatures` is mutual exclusive with `SomeFeatures`\n+        // https://github.com/oli-obk/cargo_metadata/issues/79\n+        args.push(\"--no-default-features\".to_string());\n+    } else if !cargo_features.features.is_empty() {\n+        for feature in &cargo_features.features {\n+            args.push(feature.clone());\n+        }\n+    }\n+\n+    let mut res = FxHashMap::default();\n+    let mut child = run_cargo(&args, cargo_toml.parent(), |message| {\n+        match message {\n+            Message::BuildScriptExecuted(message) => {\n+                let package_id = message.package_id;\n+                let out_dir = message.out_dir;\n+                res.insert(package_id, out_dir);\n+            }\n+\n+            Message::CompilerArtifact(_) => (),\n+            Message::CompilerMessage(_) => (),\n+            Message::Unknown => (),\n+        }\n+        true\n+    });\n+\n+    let _ = child.wait();\n+    res\n+}"}, {"sha": "43f8342530a7315ddeb45637a9bb5689861d9c23", "filename": "crates/ra_project_model/src/lib.rs", "status": "modified", "additions": 36, "deletions": 7, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/33c6c7abc6621f8b0cf083a98f7e4788cf4b5b54/crates%2Fra_project_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c6c7abc6621f8b0cf083a98f7e4788cf4b5b54/crates%2Fra_project_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Flib.rs?ref=33c6c7abc6621f8b0cf083a98f7e4788cf4b5b54", "patch": "@@ -150,6 +150,21 @@ impl ProjectWorkspace {\n         }\n     }\n \n+    pub fn out_dirs(&self) -> Vec<PathBuf> {\n+        match self {\n+            ProjectWorkspace::Json { project: _project } => vec![],\n+            ProjectWorkspace::Cargo { cargo, sysroot: _sysroot } => {\n+                let mut out_dirs = Vec::with_capacity(cargo.packages().len());\n+                for pkg in cargo.packages() {\n+                    if let Some(out_dir) = pkg.out_dir(&cargo) {\n+                        out_dirs.push(out_dir.to_path_buf());\n+                    }\n+                }\n+                out_dirs\n+            }\n+        }\n+    }\n+\n     pub fn n_packages(&self) -> usize {\n         match self {\n             ProjectWorkspace::Json { project } => project.crates.len(),\n@@ -162,7 +177,8 @@ impl ProjectWorkspace {\n     pub fn to_crate_graph(\n         &self,\n         default_cfg_options: &CfgOptions,\n-        outdirs: &FxHashMap<String, (ExternSourceId, String)>,\n+        additional_out_dirs: &FxHashMap<String, PathBuf>,\n+        extern_source_roots: &FxHashMap<PathBuf, ExternSourceId>,\n         load: &mut dyn FnMut(&Path) -> Option<FileId>,\n     ) -> CrateGraph {\n         let mut crate_graph = CrateGraph::default();\n@@ -237,9 +253,11 @@ impl ProjectWorkspace {\n \n                         let mut env = Env::default();\n                         let mut extern_source = ExternSource::default();\n-                        if let Some((id, path)) = outdirs.get(krate.name(&sysroot)) {\n-                            env.set(\"OUT_DIR\", path.clone());\n-                            extern_source.set_extern_path(&path, *id);\n+                        if let Some(path) = additional_out_dirs.get(krate.name(&sysroot)) {\n+                            env.set(\"OUT_DIR\", path.to_string_lossy().to_string());\n+                            if let Some(extern_source_id) = extern_source_roots.get(path) {\n+                                extern_source.set_extern_path(&path, *extern_source_id);\n+                            }\n                         }\n \n                         let crate_id = crate_graph.add_crate_root(\n@@ -292,9 +310,20 @@ impl ProjectWorkspace {\n                             };\n                             let mut env = Env::default();\n                             let mut extern_source = ExternSource::default();\n-                            if let Some((id, path)) = outdirs.get(pkg.name(&cargo)) {\n-                                env.set(\"OUT_DIR\", path.clone());\n-                                extern_source.set_extern_path(&path, *id);\n+                            if let Some(out_dir) = dbg!(pkg.out_dir(cargo)) {\n+                                env.set(\"OUT_DIR\", out_dir.to_string_lossy().to_string());\n+                                if let Some(extern_source_id) =\n+                                    dbg!(dbg!(&extern_source_roots).get(out_dir))\n+                                {\n+                                    extern_source.set_extern_path(&out_dir, *extern_source_id);\n+                                }\n+                            } else {\n+                                if let Some(path) = additional_out_dirs.get(pkg.name(&cargo)) {\n+                                    env.set(\"OUT_DIR\", path.to_string_lossy().to_string());\n+                                    if let Some(extern_source_id) = extern_source_roots.get(path) {\n+                                        extern_source.set_extern_path(&path, *extern_source_id);\n+                                    }\n+                                }\n                             }\n                             let crate_id = crate_graph.add_crate_root(\n                                 file_id,"}, {"sha": "7d75b991d39ebda90dc4b556cef714957a4d7012", "filename": "crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/33c6c7abc6621f8b0cf083a98f7e4788cf4b5b54/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c6c7abc6621f8b0cf083a98f7e4788cf4b5b54/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=33c6c7abc6621f8b0cf083a98f7e4788cf4b5b54", "patch": "@@ -54,12 +54,18 @@ pub(crate) fn load_cargo(\n \n     // FIXME: outdirs?\n     let outdirs = FxHashMap::default();\n-\n-    let crate_graph = ws.to_crate_graph(&default_cfg_options, &outdirs, &mut |path: &Path| {\n-        let vfs_file = vfs.load(path);\n-        log::debug!(\"vfs file {:?} -> {:?}\", path, vfs_file);\n-        vfs_file.map(vfs_file_to_id)\n-    });\n+    let extern_source_roots = FxHashMap::default();\n+\n+    let crate_graph = ws.to_crate_graph(\n+        &default_cfg_options,\n+        &outdirs,\n+        &extern_source_roots,\n+        &mut |path: &Path| {\n+            let vfs_file = vfs.load(path);\n+            log::debug!(\"vfs file {:?} -> {:?}\", path, vfs_file);\n+            vfs_file.map(vfs_file_to_id)\n+        },\n+    );\n     log::debug!(\"crate graph: {:?}\", crate_graph);\n \n     let source_roots = roots"}, {"sha": "63e91304711b98b9df12ce0a69e594bae1ee22b6", "filename": "crates/rust-analyzer/src/world.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/33c6c7abc6621f8b0cf083a98f7e4788cf4b5b54/crates%2Frust-analyzer%2Fsrc%2Fworld.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c6c7abc6621f8b0cf083a98f7e4788cf4b5b54/crates%2Frust-analyzer%2Fsrc%2Fworld.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fworld.rs?ref=33c6c7abc6621f8b0cf083a98f7e4788cf4b5b54", "patch": "@@ -105,11 +105,15 @@ impl WorldState {\n             }));\n         }\n \n-        let extern_dirs: FxHashSet<_> =\n+        let mut extern_dirs: FxHashSet<_> =\n             additional_out_dirs.iter().map(|(_, path)| (PathBuf::from(path))).collect();\n+        for ws in workspaces.iter() {\n+            extern_dirs.extend(ws.out_dirs());\n+        }\n+\n         let mut extern_source_roots = FxHashMap::default();\n \n-        roots.extend(additional_out_dirs.iter().map(|(_, path)| {\n+        roots.extend(extern_dirs.iter().map(|path| {\n             let mut filter = RustPackageFilterBuilder::default().set_member(false);\n             for glob in exclude_globs.iter() {\n                 filter = filter.exclude(glob.clone());\n@@ -148,17 +152,21 @@ impl WorldState {\n             vfs_file.map(|f| FileId(f.0))\n         };\n \n-        let mut outdirs = FxHashMap::default();\n-        for (name, path) in additional_out_dirs {\n-            let path = PathBuf::from(&path);\n-            if let Some(id) = extern_source_roots.get(&path) {\n-                outdirs.insert(name, (id.clone(), path.to_string_lossy().replace(\"\\\\\", \"/\")));\n-            }\n-        }\n+        let additional_out_dirs: FxHashMap<String, PathBuf> = additional_out_dirs\n+            .into_iter()\n+            .map(|(name, path)| (name, PathBuf::from(&path)))\n+            .collect();\n \n         workspaces\n             .iter()\n-            .map(|ws| ws.to_crate_graph(&default_cfg_options, &outdirs, &mut load))\n+            .map(|ws| {\n+                ws.to_crate_graph(\n+                    &default_cfg_options,\n+                    &additional_out_dirs,\n+                    &extern_source_roots,\n+                    &mut load,\n+                )\n+            })\n             .for_each(|graph| {\n                 crate_graph.extend(graph);\n             });"}, {"sha": "188a2f9ca685e8c64506a1da51c8e88702fe3294", "filename": "editors/code/package.json", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/33c6c7abc6621f8b0cf083a98f7e4788cf4b5b54/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/33c6c7abc6621f8b0cf083a98f7e4788cf4b5b54/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=33c6c7abc6621f8b0cf083a98f7e4788cf4b5b54", "patch": "@@ -362,6 +362,11 @@\n                     },\n                     \"default\": [],\n                     \"description\": \"List of features to activate\"\n+                },\n+                \"rust-analyzer.cargoFeatures.loadOutDirsFromCheck\": {\n+                    \"type\": \"boolean\",\n+                    \"default\": false,\n+                    \"markdownDescription\": \"Run `cargo check` on startup to get the correct value for package OUT_DIRs\"\n                 }\n             }\n         },"}, {"sha": "84ec81ecdc16c86e7aa4aedd1cba19cb375d08ae", "filename": "editors/code/src/config.ts", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/33c6c7abc6621f8b0cf083a98f7e4788cf4b5b54/editors%2Fcode%2Fsrc%2Fconfig.ts", "raw_url": "https://github.com/rust-lang/rust/raw/33c6c7abc6621f8b0cf083a98f7e4788cf4b5b54/editors%2Fcode%2Fsrc%2Fconfig.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fconfig.ts?ref=33c6c7abc6621f8b0cf083a98f7e4788cf4b5b54", "patch": "@@ -22,6 +22,7 @@ export interface CargoFeatures {\n     noDefaultFeatures: boolean;\n     allFeatures: boolean;\n     features: string[];\n+    loadOutDirsFromCheck: boolean;\n }\n \n export const enum UpdatesChannel {\n@@ -204,6 +205,7 @@ export class Config {\n     get featureFlags() { return this.cfg.get(\"featureFlags\") as Record<string, boolean>; }\n     get additionalOutDirs() { return this.cfg.get(\"additionalOutDirs\") as Record<string, string>; }\n     get rustfmtArgs() { return this.cfg.get(\"rustfmtArgs\") as string[]; }\n+    get loadOutDirsFromCheck() { return this.cfg.get(\"loadOutDirsFromCheck\") as boolean; }\n \n     get cargoWatchOptions(): CargoWatchOptions {\n         return {\n@@ -219,6 +221,7 @@ export class Config {\n             noDefaultFeatures: this.cfg.get(\"cargoFeatures.noDefaultFeatures\") as boolean,\n             allFeatures: this.cfg.get(\"cargoFeatures.allFeatures\") as boolean,\n             features: this.cfg.get(\"cargoFeatures.features\") as string[],\n+            loadOutDirsFromCheck: this.cfg.get(\"cargoFeatures.loadOutDirsFromCheck\") as boolean,\n         };\n     }\n "}]}