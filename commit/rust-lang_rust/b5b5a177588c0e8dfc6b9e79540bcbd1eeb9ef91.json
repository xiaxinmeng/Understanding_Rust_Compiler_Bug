{"sha": "b5b5a177588c0e8dfc6b9e79540bcbd1eeb9ef91", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1YjVhMTc3NTg4YzBlOGRmYzZiOWU3OTU0MGJjYmQxZWViOWVmOTE=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-05-08T13:06:16Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-05-08T13:06:16Z"}, "message": "dropck: must assume `Box<Trait + 'a>` has a destructor of interest.\n\nImplements this (previously overlooked) note from [RFC 769]:\n\n> (Note: When encountering a D of the form `Box<Trait+'b>`, we\n> conservatively assume that such a type has a Drop implementation\n> parametric in 'b.)\n\nFix #25199.\n\n[breaking-change]\n\nThe breakage here falls into both obvious and non-obvious cases.\n\nThe obvious case: if you were relying on the unsoundness this exposes\n(namely being able to reference dead storage from a destructor, by\ndoing it via a boxed trait object bounded by the lifetime of the dead\nstorage), then this change disallows that.\n\nThe non-obvious cases: The way dropck works, it causes lifetimes to be\nextended to longer extents than they covered before. I.e.  lifetimes\nthat are attached as trait-bounds may become longer than they were\npreviously.\n\n* This includes lifetimes that are only *implicitly* attached as\n  trait-bounds (due to [RFC 599]). So you may have code that was\n  e.g. taking a parameter of type `&'a Box<Trait>` (which expands to\n  `&'a Box<Trait+'a>`), that now may need to be assigned type `&'a\n  Box<Trait+'static>` to ensure that `'a` is not inadvertantly\n  inferred to a region that is actually too long.  (See earlier commit\n  in this PR for an example of this.)\n\n[RFC 769]: https://github.com/rust-lang/rfcs/blob/master/text/0769-sound-generic-drop.md#the-drop-check-rule\n\n[RFC 599]: https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md", "tree": {"sha": "22fc5503ae4af14216db4032f597b47799480749", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22fc5503ae4af14216db4032f597b47799480749"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5b5a177588c0e8dfc6b9e79540bcbd1eeb9ef91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5b5a177588c0e8dfc6b9e79540bcbd1eeb9ef91", "html_url": "https://github.com/rust-lang/rust/commit/b5b5a177588c0e8dfc6b9e79540bcbd1eeb9ef91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5b5a177588c0e8dfc6b9e79540bcbd1eeb9ef91/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee06263f9227c75a3e0df6997bb0bb203c2efa65", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee06263f9227c75a3e0df6997bb0bb203c2efa65", "html_url": "https://github.com/rust-lang/rust/commit/ee06263f9227c75a3e0df6997bb0bb203c2efa65"}], "stats": {"total": 259, "additions": 153, "deletions": 106}, "files": [{"sha": "fd90d662bd141d5eb4e9343adc455e8757f39b9a", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 153, "deletions": 106, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/b5b5a177588c0e8dfc6b9e79540bcbd1eeb9ef91/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b5a177588c0e8dfc6b9e79540bcbd1eeb9ef91/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=b5b5a177588c0e8dfc6b9e79540bcbd1eeb9ef91", "patch": "@@ -396,19 +396,24 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n             }\n         };\n \n-        let opt_type_did = match typ.sty {\n-            ty::ty_struct(struct_did, _) => Some(struct_did),\n-            ty::ty_enum(enum_did, _) => Some(enum_did),\n-            _ => None,\n+        let dtor_kind = match typ.sty {\n+            ty::ty_enum(def_id, _) |\n+            ty::ty_struct(def_id, _) => {\n+                match destructor_for_type.get(&def_id) {\n+                    Some(def_id) => DtorKind::KnownDropMethod(*def_id),\n+                    None => DtorKind::PureRecur,\n+                }\n+            }\n+            ty::ty_trait(ref ty_trait) => {\n+                DtorKind::Unknown(ty_trait.bounds.clone())\n+            }\n+            _ => DtorKind::PureRecur,\n         };\n \n-        let opt_dtor =\n-            opt_type_did.and_then(|did| destructor_for_type.get(&did));\n-\n         debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n-                {}typ: {} scope: {:?} opt_dtor: {:?} xref: {}\",\n+                {}typ: {} scope: {:?} xref: {}\",\n                (0..depth).map(|_| ' ').collect::<String>(),\n-               typ.repr(rcx.tcx()), scope, opt_dtor, xref_depth);\n+               typ.repr(rcx.tcx()), scope, xref_depth);\n \n         // If `typ` has a destructor, then we must ensure that all\n         // borrowed data reachable via `typ` must outlive the parent\n@@ -439,102 +444,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n         // simply skip the `type_must_outlive` call entirely (but\n         // resume the recursive checking of the type-substructure).\n \n-        let has_dtor_of_interest;\n-\n-        if let Some(&dtor_method_did) = opt_dtor {\n-            let impl_did = ty::impl_of_method(rcx.tcx(), dtor_method_did)\n-                .unwrap_or_else(|| {\n-                    rcx.tcx().sess.span_bug(\n-                        span, \"no Drop impl found for drop method\")\n-                });\n-\n-            let dtor_typescheme = ty::lookup_item_type(rcx.tcx(), impl_did);\n-            let dtor_generics = dtor_typescheme.generics;\n-\n-            let mut has_pred_of_interest = false;\n-\n-            let mut seen_items = Vec::new();\n-            let mut items_to_inspect = vec![impl_did];\n-            'items: while let Some(item_def_id) = items_to_inspect.pop() {\n-                if seen_items.contains(&item_def_id) {\n-                    continue;\n-                }\n-\n-                for pred in ty::lookup_predicates(rcx.tcx(), item_def_id).predicates {\n-                    let result = match pred {\n-                        ty::Predicate::Equate(..) |\n-                        ty::Predicate::RegionOutlives(..) |\n-                        ty::Predicate::TypeOutlives(..) |\n-                        ty::Predicate::Projection(..) => {\n-                            // For now, assume all these where-clauses\n-                            // may give drop implementation capabilty\n-                            // to access borrowed data.\n-                            true\n-                        }\n-\n-                        ty::Predicate::Trait(ty::Binder(ref t_pred)) => {\n-                            let def_id = t_pred.trait_ref.def_id;\n-                            if ty::trait_items(rcx.tcx(), def_id).len() != 0 {\n-                                // If trait has items, assume it adds\n-                                // capability to access borrowed data.\n-                                true\n-                            } else {\n-                                // Trait without items is itself\n-                                // uninteresting from POV of dropck.\n-                                //\n-                                // However, may have parent w/ items;\n-                                // so schedule checking of predicates,\n-                                items_to_inspect.push(def_id);\n-                                // and say \"no capability found\" for now.\n-                                false\n-                            }\n-                        }\n-                    };\n-\n-                    if result {\n-                        has_pred_of_interest = true;\n-                        debug!(\"typ: {} has interesting dtor due to generic preds, e.g. {}\",\n-                               typ.repr(rcx.tcx()), pred.repr(rcx.tcx()));\n-                        break 'items;\n-                    }\n-                }\n-\n-                seen_items.push(item_def_id);\n-            }\n-\n-            // In `impl<'a> Drop ...`, we automatically assume\n-            // `'a` is meaningful and thus represents a bound\n-            // through which we could reach borrowed data.\n-            //\n-            // FIXME (pnkfelix): In the future it would be good to\n-            // extend the language to allow the user to express,\n-            // in the impl signature, that a lifetime is not\n-            // actually used (something like `where 'a: ?Live`).\n-            let has_region_param_of_interest =\n-                dtor_generics.has_region_params(subst::TypeSpace);\n-\n-            has_dtor_of_interest =\n-                has_region_param_of_interest ||\n-                has_pred_of_interest;\n-\n-            if has_dtor_of_interest {\n-                debug!(\"typ: {} has interesting dtor, due to \\\n-                        region params: {} or pred: {}\",\n-                       typ.repr(rcx.tcx()),\n-                       has_region_param_of_interest,\n-                       has_pred_of_interest);\n-            } else {\n-                debug!(\"typ: {} has dtor, but it is uninteresting\",\n-                       typ.repr(rcx.tcx()));\n-            }\n-\n-        } else {\n-            debug!(\"typ: {} has no dtor, and thus is uninteresting\",\n-                   typ.repr(rcx.tcx()));\n-            has_dtor_of_interest = false;\n-        }\n-\n-        if has_dtor_of_interest {\n+        if has_dtor_of_interest(rcx.tcx(), dtor_kind, typ, span) {\n             // If `typ` has a destructor, then we must ensure that all\n             // borrowed data reachable via `typ` must outlive the\n             // parent of `scope`. (It does not suffice for it to\n@@ -620,7 +530,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n \n                 ty::ty_rptr(..) | ty::ty_ptr(_) | ty::ty_bare_fn(..) => {\n                     // Don't recurse, since references, pointers,\n-                    // boxes, and bare functions don't own instances\n+                    // and bare functions don't own instances\n                     // of the types appearing within them.\n                     walker.skip_current_subtree();\n                 }\n@@ -639,3 +549,140 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n \n     return Ok(());\n }\n+\n+enum DtorKind<'tcx> {\n+    // Type has an associated drop method with this def id\n+    KnownDropMethod(ast::DefId),\n+\n+    // Type has no destructor (or its dtor is known to be pure\n+    // with respect to lifetimes), though its *substructure*\n+    // may carry a destructor.\n+    PureRecur,\n+\n+    // Type may have impure destructor that is unknown;\n+    // e.g. `Box<Trait+'a>`\n+    Unknown(ty::ExistentialBounds<'tcx>),\n+}\n+\n+fn has_dtor_of_interest<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                              dtor_kind: DtorKind,\n+                              typ: ty::Ty<'tcx>,\n+                              span: Span) -> bool {\n+    let has_dtor_of_interest: bool;\n+\n+    match dtor_kind {\n+        DtorKind::PureRecur => {\n+            has_dtor_of_interest = false;\n+            debug!(\"typ: {} has no dtor, and thus is uninteresting\",\n+                   typ.repr(tcx));\n+        }\n+        DtorKind::Unknown(bounds) => {\n+            match bounds.region_bound {\n+                ty::ReStatic => {\n+                    debug!(\"trait: {} has 'static bound, and thus is uninteresting\",\n+                           typ.repr(tcx));\n+                    has_dtor_of_interest = false;\n+                }\n+                ty::ReEmpty => {\n+                    debug!(\"trait: {} has empty region bound, and thus is uninteresting\",\n+                           typ.repr(tcx));\n+                    has_dtor_of_interest = false;\n+                }\n+                r => {\n+                    debug!(\"trait: {} has non-static bound: {}; assumed interesting\",\n+                           typ.repr(tcx), r.repr(tcx));\n+                    has_dtor_of_interest = true;\n+                }\n+            }\n+        }\n+        DtorKind::KnownDropMethod(dtor_method_did) => {\n+            let impl_did = ty::impl_of_method(tcx, dtor_method_did)\n+                .unwrap_or_else(|| {\n+                    tcx.sess.span_bug(\n+                        span, \"no Drop impl found for drop method\")\n+                });\n+\n+            let dtor_typescheme = ty::lookup_item_type(tcx, impl_did);\n+            let dtor_generics = dtor_typescheme.generics;\n+\n+            let mut has_pred_of_interest = false;\n+\n+            let mut seen_items = Vec::new();\n+            let mut items_to_inspect = vec![impl_did];\n+            'items: while let Some(item_def_id) = items_to_inspect.pop() {\n+                if seen_items.contains(&item_def_id) {\n+                    continue;\n+                }\n+\n+                for pred in ty::lookup_predicates(tcx, item_def_id).predicates {\n+                    let result = match pred {\n+                        ty::Predicate::Equate(..) |\n+                        ty::Predicate::RegionOutlives(..) |\n+                        ty::Predicate::TypeOutlives(..) |\n+                        ty::Predicate::Projection(..) => {\n+                            // For now, assume all these where-clauses\n+                            // may give drop implementation capabilty\n+                            // to access borrowed data.\n+                            true\n+                        }\n+\n+                        ty::Predicate::Trait(ty::Binder(ref t_pred)) => {\n+                            let def_id = t_pred.trait_ref.def_id;\n+                            if ty::trait_items(tcx, def_id).len() != 0 {\n+                                // If trait has items, assume it adds\n+                                // capability to access borrowed data.\n+                                true\n+                            } else {\n+                                // Trait without items is itself\n+                                // uninteresting from POV of dropck.\n+                                //\n+                                // However, may have parent w/ items;\n+                                // so schedule checking of predicates,\n+                                items_to_inspect.push(def_id);\n+                                // and say \"no capability found\" for now.\n+                                false\n+                            }\n+                        }\n+                    };\n+\n+                    if result {\n+                        has_pred_of_interest = true;\n+                        debug!(\"typ: {} has interesting dtor due to generic preds, e.g. {}\",\n+                               typ.repr(tcx), pred.repr(tcx));\n+                        break 'items;\n+                    }\n+                }\n+\n+                seen_items.push(item_def_id);\n+            }\n+\n+            // In `impl<'a> Drop ...`, we automatically assume\n+            // `'a` is meaningful and thus represents a bound\n+            // through which we could reach borrowed data.\n+            //\n+            // FIXME (pnkfelix): In the future it would be good to\n+            // extend the language to allow the user to express,\n+            // in the impl signature, that a lifetime is not\n+            // actually used (something like `where 'a: ?Live`).\n+            let has_region_param_of_interest =\n+                dtor_generics.has_region_params(subst::TypeSpace);\n+\n+            has_dtor_of_interest =\n+                has_region_param_of_interest ||\n+                has_pred_of_interest;\n+\n+            if has_dtor_of_interest {\n+                debug!(\"typ: {} has interesting dtor, due to \\\n+                        region params: {} or pred: {}\",\n+                       typ.repr(tcx),\n+                       has_region_param_of_interest,\n+                       has_pred_of_interest);\n+            } else {\n+                debug!(\"typ: {} has dtor, but it is uninteresting\",\n+                       typ.repr(tcx));\n+            }\n+        }\n+    }\n+\n+    return has_dtor_of_interest;\n+}"}]}