{"sha": "aeb20284817497a895fee5a22b0013acd0a430e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlYjIwMjg0ODE3NDk3YTg5NWZlZTVhMjJiMDAxM2FjZDBhNDMwZTI=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-08-04T06:35:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-08-04T06:35:58Z"}, "message": "Rollup merge of #53022 - RalfJung:volatile, r=alexcrichton\n\nvolatile operations docs: clarify that this does not help wrt. concurrency\n\nTriggered by https://github.com/rust-lang/rust/pull/52391. Cc @stjepang @Amanieu\n\nShould the intrinsics themselves also get more documentation? They generally do not seem to have much of that.", "tree": {"sha": "5d1a3ca06d7725cf4452391b94b61a6cb556b5b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d1a3ca06d7725cf4452391b94b61a6cb556b5b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aeb20284817497a895fee5a22b0013acd0a430e2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbZUlOCRBK7hj4Ov3rIwAAdHIIAGJqv1unTpKTVzvHiGhDukdr\n2UT++AlzlIv8BQJrvEZvmpWFaZ3H1h3fESWbCGj88cYcVJRZHY6noWvuU5aGhkWc\nH6wIqiAEB5OXsixWYs6LI+BFHKs/5QpFto57khHtd+imLxjXFGJYuJLSeIMlfZOe\nuzTrFp7jcUWO66rin9UUb/cPyZO0qiscYVXfdxG4v88kSeWhUkAWaONsfUPXRVRq\n+GILVv6Ui3GLd0ZWta5ygCWuGlCDzggjmicHH/1dwZBQF4LF6/Y6e9JQ20nOJIeg\nX6CgbiirO1VX6Bhkeob6HbmAujPwTSZwd3rDMfAsPEz4a5fU1PSvroptYBLPfVg=\n=l+qm\n-----END PGP SIGNATURE-----\n", "payload": "tree 5d1a3ca06d7725cf4452391b94b61a6cb556b5b2\nparent 7a23b5dec33d615a55f1cc6ca339fcd5ada1cab2\nparent 71460d4d1144de2ddc4a088b81a30c6bc47dee59\nauthor kennytm <kennytm@gmail.com> 1533364558 +0800\ncommitter GitHub <noreply@github.com> 1533364558 +0800\n\nRollup merge of #53022 - RalfJung:volatile, r=alexcrichton\n\nvolatile operations docs: clarify that this does not help wrt. concurrency\n\nTriggered by https://github.com/rust-lang/rust/pull/52391. Cc @stjepang @Amanieu\n\nShould the intrinsics themselves also get more documentation? They generally do not seem to have much of that.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aeb20284817497a895fee5a22b0013acd0a430e2", "html_url": "https://github.com/rust-lang/rust/commit/aeb20284817497a895fee5a22b0013acd0a430e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aeb20284817497a895fee5a22b0013acd0a430e2/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a23b5dec33d615a55f1cc6ca339fcd5ada1cab2", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a23b5dec33d615a55f1cc6ca339fcd5ada1cab2", "html_url": "https://github.com/rust-lang/rust/commit/7a23b5dec33d615a55f1cc6ca339fcd5ada1cab2"}, {"sha": "71460d4d1144de2ddc4a088b81a30c6bc47dee59", "url": "https://api.github.com/repos/rust-lang/rust/commits/71460d4d1144de2ddc4a088b81a30c6bc47dee59", "html_url": "https://github.com/rust-lang/rust/commit/71460d4d1144de2ddc4a088b81a30c6bc47dee59"}], "stats": {"total": 30, "additions": 30, "deletions": 0}, "files": [{"sha": "c8670e5ec34d347b9f2f5aef6180ee29f10a0b4f", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/aeb20284817497a895fee5a22b0013acd0a430e2/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb20284817497a895fee5a22b0013acd0a430e2/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=aeb20284817497a895fee5a22b0013acd0a430e2", "patch": "@@ -448,6 +448,12 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n /// `write_bytes`, or `copy`). Note that `*src = foo` counts as a use\n /// because it will attempt to drop the value previously at `*src`.\n ///\n+/// Just like in C, whether an operation is volatile has no bearing whatsoever\n+/// on questions involving concurrent access from multiple threads. Volatile\n+/// accesses behave exactly like non-atomic accesses in that regard. In particular,\n+/// a race between a `read_volatile` and any write operation to the same location\n+/// is undefined behavior.\n+///\n /// # Examples\n ///\n /// Basic usage:\n@@ -498,6 +504,12 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n /// This is appropriate for initializing uninitialized memory, or overwriting\n /// memory that has previously been `read` from.\n ///\n+/// Just like in C, whether an operation is volatile has no bearing whatsoever\n+/// on questions involving concurrent access from multiple threads. Volatile\n+/// accesses behave exactly like non-atomic accesses in that regard. In particular,\n+/// a race between a `write_volatile` and any other operation (reading or writing)\n+/// on the same location is undefined behavior.\n+///\n /// # Examples\n ///\n /// Basic usage:\n@@ -1057,6 +1069,12 @@ impl<T: ?Sized> *const T {\n     /// `write_bytes`, or `copy`). Note that `*self = foo` counts as a use\n     /// because it will attempt to drop the value previously at `*self`.\n     ///\n+    /// Just like in C, whether an operation is volatile has no bearing whatsoever\n+    /// on questions involving concurrent access from multiple threads. Volatile\n+    /// accesses behave exactly like non-atomic accesses in that regard. In particular,\n+    /// a race between a `read_volatile` and any write operation to the same location\n+    /// is undefined behavior.\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1790,6 +1808,12 @@ impl<T: ?Sized> *mut T {\n     /// `write_bytes`, or `copy`). Note that `*self = foo` counts as a use\n     /// because it will attempt to drop the value previously at `*self`.\n     ///\n+    /// Just like in C, whether an operation is volatile has no bearing whatsoever\n+    /// on questions involving concurrent access from multiple threads. Volatile\n+    /// accesses behave exactly like non-atomic accesses in that regard. In particular,\n+    /// a race between a `read_volatile` and any write operation to the same location\n+    /// is undefined behavior.\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -2105,6 +2129,12 @@ impl<T: ?Sized> *mut T {\n     /// This is appropriate for initializing uninitialized memory, or overwriting\n     /// memory that has previously been `read` from.\n     ///\n+    /// Just like in C, whether an operation is volatile has no bearing whatsoever\n+    /// on questions involving concurrent access from multiple threads. Volatile\n+    /// accesses behave exactly like non-atomic accesses in that regard. In particular,\n+    /// a race between a `write_volatile` and any other operation (reading or writing)\n+    /// on the same location is undefined behavior.\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:"}]}