{"sha": "c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "node_id": "C_kwDOAAsO6NoAKGM5YmU1N2RiZjNkNGEzNzY2MjBkNmMyOWVmNGNjNDg2YTE3MzVkY2I", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2022-05-28T08:55:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-05-28T08:55:25Z"}, "message": "Merge branch 'master' into doc_link_with_quotes", "tree": {"sha": "72455b76a6b4b54cc4af90658979727a2428bbef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72455b76a6b4b54cc4af90658979727a2428bbef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJikeN9CRBK7hj4Ov3rIwAA79oIAER/mBQZpUlMdF5gBf+/aN10\nRU8AVtyB2sTeKYj12jLSzBMLrVjfR+VOQ37Oh3bwRFJXnRONtsNehvc2GwjB4tGi\nMYNBl6wYXE0Wz7Lny9s24xEPrWpsLuTWLuLeXWPjkkI1tshv/oE850MlMzHcnkMU\nNA8YbUX5RoDty3SA9oNURtTOXweferaACDglSPSb0ClBxU6qNUWS6HB3eyudqbr2\ntVH/56M2sZE0QHMK3hv+T9u8lzRyrikekIGiLTY2Z2EBNolCK2SadTPY304rKNst\nQF02cIWcD/9GOBuGMgk/O5mloJzv0XaZl/Wfe5t1LeOGOv9CghtWuhNPtCZb1wM=\n=VFI8\n-----END PGP SIGNATURE-----\n", "payload": "tree 72455b76a6b4b54cc4af90658979727a2428bbef\nparent cb29e3effbf72db2e1f5177336bfb3309ec8805e\nparent 1dd55471b4e95ab8dfc5e55e80a2a59f55817931\nauthor llogiq <bogusandre@gmail.com> 1653728125 +0200\ncommitter GitHub <noreply@github.com> 1653728125 +0200\n\nMerge branch 'master' into doc_link_with_quotes"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "html_url": "https://github.com/rust-lang/rust/commit/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb29e3effbf72db2e1f5177336bfb3309ec8805e", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb29e3effbf72db2e1f5177336bfb3309ec8805e", "html_url": "https://github.com/rust-lang/rust/commit/cb29e3effbf72db2e1f5177336bfb3309ec8805e"}, {"sha": "1dd55471b4e95ab8dfc5e55e80a2a59f55817931", "url": "https://api.github.com/repos/rust-lang/rust/commits/1dd55471b4e95ab8dfc5e55e80a2a59f55817931", "html_url": "https://github.com/rust-lang/rust/commit/1dd55471b4e95ab8dfc5e55e80a2a59f55817931"}], "stats": {"total": 39732, "additions": 28859, "deletions": 10873}, "files": [{"sha": "89884bfc85902ee4cf825d2d5130a6d5b9935d69", "filename": ".github/ISSUE_TEMPLATE/blank_issue.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/.github%2FISSUE_TEMPLATE%2Fblank_issue.yml", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/.github%2FISSUE_TEMPLATE%2Fblank_issue.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fblank_issue.yml?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -9,7 +9,7 @@ body:\n     attributes:\n       label: Description\n       description: >\n-        Please provide a discription of the issue, along with any information\n+        Please provide a description of the issue, along with any information\n         you feel relevant to replicate it.\n     validations:\n       required: true"}, {"sha": "b6f70a7f18300227ce4cf88379d2231813c98f1b", "filename": ".github/ISSUE_TEMPLATE/bug_report.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/.github%2FISSUE_TEMPLATE%2Fbug_report.yml", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/.github%2FISSUE_TEMPLATE%2Fbug_report.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fbug_report.yml?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -18,7 +18,7 @@ body:\n     id: reproducer\n     attributes:\n       label: Reproducer\n-      description: Please provide the code and steps to repoduce the bug\n+      description: Please provide the code and steps to reproduce the bug\n       value: |\n         I tried this code:\n "}, {"sha": "25e436d30b97dc42dacee379ad90f9d069c462d5", "filename": ".github/ISSUE_TEMPLATE/false_negative.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/.github%2FISSUE_TEMPLATE%2Ffalse_negative.yml", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/.github%2FISSUE_TEMPLATE%2Ffalse_negative.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Ffalse_negative.yml?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -23,7 +23,7 @@ body:\n     id: reproducer\n     attributes:\n       label: Reproducer\n-      description: Please provide the code and steps to repoduce the bug\n+      description: Please provide the code and steps to reproduce the bug\n       value: |\n         I tried this code:\n "}, {"sha": "561b65c93a7f9329799d2be796c2590b1ae215dd", "filename": ".github/ISSUE_TEMPLATE/false_positive.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/.github%2FISSUE_TEMPLATE%2Ffalse_positive.yml", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/.github%2FISSUE_TEMPLATE%2Ffalse_positive.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Ffalse_positive.yml?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -24,7 +24,7 @@ body:\n     attributes:\n       label: Reproducer\n       description: >\n-        Please provide the code and steps to repoduce the bug together with the\n+        Please provide the code and steps to reproduce the bug together with the\n         output from Clippy.\n       value: |\n         I tried this code:"}, {"sha": "81bd9c5e032780eb306c9e5c245939f2aa1a4850", "filename": ".github/ISSUE_TEMPLATE/ice.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/.github%2FISSUE_TEMPLATE%2Fice.yml", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/.github%2FISSUE_TEMPLATE%2Fice.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fice.yml?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -10,7 +10,7 @@ body:\n     attributes:\n       label: Summary\n       description: |\n-        If possible, try to provide a minimal verifiable example. You can read [\"Rust Bug Minimization Patterns\"][mve] for how to create smaller examples. Otherwise, provide the crate where the ICE occured.\n+        If possible, try to provide a minimal verifiable example. You can read [\"Rust Bug Minimization Patterns\"][mve] for how to create smaller examples. Otherwise, provide the crate where the ICE occurred.\n \n         [mve]: http://blog.pnkfx.org/blog/2019/11/18/rust-bug-minimization-patterns/\n     validations:"}, {"sha": "5a59f94ec918bbc3c824b828f97a53ea98979034", "filename": ".github/deploy.sh", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/.github%2Fdeploy.sh", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/.github%2Fdeploy.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fdeploy.sh?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -8,6 +8,7 @@ rm -rf out/master/ || exit 0\n echo \"Making the docs for master\"\n mkdir out/master/\n cp util/gh-pages/index.html out/master\n+cp util/gh-pages/script.js out/master\n cp util/gh-pages/lints.json out/master\n \n if [[ -n $TAG_NAME ]]; then"}, {"sha": "0e27cc927acea4c010f810cd350f047eebece429", "filename": ".github/workflows/clippy.yml", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/.github%2Fworkflows%2Fclippy.yml", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/.github%2Fworkflows%2Fclippy.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fclippy.yml?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -6,14 +6,14 @@ on:\n     branches-ignore:\n       - auto\n       - try\n-    # Don't run Clippy tests, when only textfiles were modified\n+    # Don't run Clippy tests, when only text files were modified\n     paths-ignore:\n     - 'COPYRIGHT'\n     - 'LICENSE-*'\n     - '**.md'\n     - '**.txt'\n   pull_request:\n-    # Don't run Clippy tests, when only textfiles were modified\n+    # Don't run Clippy tests, when only text files were modified\n     paths-ignore:\n     - 'COPYRIGHT'\n     - 'LICENSE-*'\n@@ -37,7 +37,7 @@ jobs:\n         github_token: \"${{ secrets.github_token }}\"\n \n     - name: Checkout\n-      uses: actions/checkout@v2.3.3\n+      uses: actions/checkout@v3.0.2\n \n     - name: Install toolchain\n       run: rustup show active-toolchain\n@@ -74,10 +74,3 @@ jobs:\n       run: bash .github/driver.sh\n       env:\n         OS: ${{ runner.os }}\n-\n-    - name: Test cargo dev new lint\n-      run: |\n-        cargo dev new_lint --name new_early_pass --pass early\n-        cargo dev new_lint --name new_late_pass --pass late\n-        cargo check\n-        git reset --hard HEAD"}, {"sha": "9b3fd3ddfeb38cc357c20e0c818b2fcad5cd9977", "filename": ".github/workflows/clippy_bors.yml", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/.github%2Fworkflows%2Fclippy_bors.yml", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/.github%2Fworkflows%2Fclippy_bors.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fclippy_bors.yml?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -25,7 +25,7 @@ jobs:\n         github_token: \"${{ secrets.github_token }}\"\n \n     - name: Checkout\n-      uses: actions/checkout@v2.3.3\n+      uses: actions/checkout@v3.0.2\n       with:\n         ref: ${{ github.ref }}\n \n@@ -88,7 +88,7 @@ jobs:\n       if: matrix.host == 'i686-unknown-linux-gnu'\n \n     - name: Checkout\n-      uses: actions/checkout@v2.3.3\n+      uses: actions/checkout@v3.0.2\n \n     - name: Install toolchain\n       run: rustup show active-toolchain\n@@ -143,13 +143,6 @@ jobs:\n       env:\n         OS: ${{ runner.os }}\n \n-    - name: Test cargo dev new lint\n-      run: |\n-        cargo dev new_lint --name new_early_pass --pass early\n-        cargo dev new_lint --name new_late_pass --pass late\n-        cargo check\n-        git reset --hard HEAD\n-\n   integration_build:\n     needs: changelog\n     runs-on: ubuntu-latest\n@@ -161,7 +154,7 @@ jobs:\n         github_token: \"${{ secrets.github_token }}\"\n \n     - name: Checkout\n-      uses: actions/checkout@v2.3.3\n+      uses: actions/checkout@v3.0.2\n \n     - name: Install toolchain\n       run: rustup show active-toolchain\n@@ -219,7 +212,7 @@ jobs:\n         github_token: \"${{ secrets.github_token }}\"\n \n     - name: Checkout\n-      uses: actions/checkout@v2.3.3\n+      uses: actions/checkout@v3.0.2\n \n     - name: Install toolchain\n       run: rustup show active-toolchain"}, {"sha": "22051093c9cf960992c3a80923e71f72ef4414f1", "filename": ".github/workflows/clippy_dev.yml", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/.github%2Fworkflows%2Fclippy_dev.yml", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/.github%2Fworkflows%2Fclippy_dev.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fclippy_dev.yml?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -23,7 +23,7 @@ jobs:\n     steps:\n     # Setup\n     - name: Checkout\n-      uses: actions/checkout@v2.3.3\n+      uses: actions/checkout@v3.0.2\n \n     # Run\n     - name: Build\n@@ -36,6 +36,13 @@ jobs:\n     - name: Test fmt\n       run: cargo dev fmt --check\n \n+    - name: Test cargo dev new lint\n+      run: |\n+        cargo dev new_lint --name new_early_pass --pass early\n+        cargo dev new_lint --name new_late_pass --pass late\n+        cargo check\n+        git reset --hard HEAD\n+\n   # These jobs doesn't actually test anything, but they're only used to tell\n   # bors the build completed, as there is no practical way to detect when a\n   # workflow is successful listening to webhooks only."}, {"sha": "71d71d10359e7e76b4f2cbc1b8843247d266659c", "filename": ".github/workflows/deploy.yml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/.github%2Fworkflows%2Fdeploy.yml", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/.github%2Fworkflows%2Fdeploy.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fdeploy.yml?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -21,10 +21,10 @@ jobs:\n     steps:\n     # Setup\n     - name: Checkout\n-      uses: actions/checkout@v2.3.3\n+      uses: actions/checkout@v3.0.2\n \n     - name: Checkout\n-      uses: actions/checkout@v2.3.3\n+      uses: actions/checkout@v3.0.2\n       with:\n         ref: ${{ env.TARGET_BRANCH }}\n         path: 'out'"}, {"sha": "a179bfa72617213735d50473ae66a73dc2355ecc", "filename": ".github/workflows/remark.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/.github%2Fworkflows%2Fremark.yml", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/.github%2Fworkflows%2Fremark.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fremark.yml?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -16,7 +16,7 @@ jobs:\n     steps:\n     # Setup\n     - name: Checkout\n-      uses: actions/checkout@v2.3.3\n+      uses: actions/checkout@v3.0.2\n \n     - name: Setup Node.js\n       uses: actions/setup-node@v1.4.4"}, {"sha": "3aaa79a1719c231be2b76c08cd8d44a7b11835c0", "filename": "CHANGELOG.md", "status": "modified", "additions": 482, "deletions": 6, "changes": 488, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -6,14 +6,418 @@ document.\n \n ## Unreleased / In Rust Nightly\n \n-[e181011...master](https://github.com/rust-lang/rust-clippy/compare/e181011...master)\n+[d0cf3481...master](https://github.com/rust-lang/rust-clippy/compare/d0cf3481...master)\n \n-## Rust 1.58 (beta)\n+## Rust 1.61\n \n-Current beta, release 2022-01-13\n+Current stable, released 2022-05-19\n+\n+[57b3c4b...d0cf3481](https://github.com/rust-lang/rust-clippy/compare/57b3c4b...d0cf3481)\n+\n+### New Lints\n+\n+* [`only_used_in_recursion`]\n+  [#8422](https://github.com/rust-lang/rust-clippy/pull/8422)\n+* [`cast_enum_truncation`]\n+  [#8381](https://github.com/rust-lang/rust-clippy/pull/8381)\n+* [`missing_spin_loop`]\n+  [#8174](https://github.com/rust-lang/rust-clippy/pull/8174)\n+* [`deref_by_slicing`]\n+  [#8218](https://github.com/rust-lang/rust-clippy/pull/8218)\n+* [`needless_match`]\n+  [#8471](https://github.com/rust-lang/rust-clippy/pull/8471)\n+* [`allow_attributes_without_reason`] (Requires `#![feature(lint_reasons)]`)\n+  [#8504](https://github.com/rust-lang/rust-clippy/pull/8504)\n+* [`print_in_format_impl`]\n+  [#8253](https://github.com/rust-lang/rust-clippy/pull/8253)\n+* [`unnecessary_find_map`]\n+  [#8489](https://github.com/rust-lang/rust-clippy/pull/8489)\n+* [`or_then_unwrap`]\n+  [#8561](https://github.com/rust-lang/rust-clippy/pull/8561)\n+* [`unnecessary_join`]\n+  [#8579](https://github.com/rust-lang/rust-clippy/pull/8579)\n+* [`iter_with_drain`]\n+  [#8483](https://github.com/rust-lang/rust-clippy/pull/8483)\n+* [`cast_enum_constructor`]\n+  [#8562](https://github.com/rust-lang/rust-clippy/pull/8562)\n+* [`cast_slice_different_sizes`]\n+  [#8445](https://github.com/rust-lang/rust-clippy/pull/8445)\n+\n+### Moves and Deprecations\n+\n+* Moved [`transmute_undefined_repr`] to `nursery` (now allow-by-default)\n+  [#8432](https://github.com/rust-lang/rust-clippy/pull/8432)\n+* Moved [`try_err`] to `restriction`\n+  [#8544](https://github.com/rust-lang/rust-clippy/pull/8544)\n+* Move [`iter_with_drain`] to `nursery`\n+  [#8541](https://github.com/rust-lang/rust-clippy/pull/8541)\n+* Renamed `to_string_in_display` to [`recursive_format_impl`]\n+  [#8188](https://github.com/rust-lang/rust-clippy/pull/8188)\n+\n+### Enhancements\n+\n+* [`dbg_macro`]: The lint level can now be set with crate attributes and works inside macros\n+  [#8411](https://github.com/rust-lang/rust-clippy/pull/8411)\n+* [`ptr_as_ptr`]: Now works inside macros\n+  [#8442](https://github.com/rust-lang/rust-clippy/pull/8442)\n+* [`use_self`]: Now works for variants in match expressions\n+  [#8456](https://github.com/rust-lang/rust-clippy/pull/8456)\n+* [`await_holding_lock`]: Now lints for `parking_lot::{Mutex, RwLock}`\n+  [#8419](https://github.com/rust-lang/rust-clippy/pull/8419)\n+* [`recursive_format_impl`]: Now checks for format calls on `self`\n+  [#8188](https://github.com/rust-lang/rust-clippy/pull/8188)\n+\n+### False Positive Fixes\n+\n+* [`new_without_default`]: No longer lints for `new()` methods with `#[doc(hidden)]`\n+  [#8472](https://github.com/rust-lang/rust-clippy/pull/8472)\n+* [`transmute_undefined_repr`]: No longer lints for single field structs with `#[repr(C)]`,\n+  generic parameters, wide pointers, unions, tuples and allow several forms of type erasure\n+  [#8425](https://github.com/rust-lang/rust-clippy/pull/8425)\n+  [#8553](https://github.com/rust-lang/rust-clippy/pull/8553)\n+  [#8440](https://github.com/rust-lang/rust-clippy/pull/8440)\n+  [#8547](https://github.com/rust-lang/rust-clippy/pull/8547)\n+* [`match_single_binding`], [`match_same_arms`], [`match_as_ref`], [`match_bool`]: No longer\n+  lint `match` expressions with `cfg`ed arms\n+  [#8443](https://github.com/rust-lang/rust-clippy/pull/8443)\n+* [`single_component_path_imports`]: No longer lint on macros\n+  [#8537](https://github.com/rust-lang/rust-clippy/pull/8537)\n+* [`ptr_arg`]: Allow `&mut` arguments for `Cow<_>`\n+  [#8552](https://github.com/rust-lang/rust-clippy/pull/8552)\n+* [`needless_borrow`]: No longer lints for method calls\n+  [#8441](https://github.com/rust-lang/rust-clippy/pull/8441)\n+* [`match_same_arms`]: Now ensures that interposing arm patterns don't overlap\n+  [#8232](https://github.com/rust-lang/rust-clippy/pull/8232)\n+* [`default_trait_access`]: Now allows `Default::default` in update expressions\n+  [#8433](https://github.com/rust-lang/rust-clippy/pull/8433)\n+\n+### Suggestion Fixes/Improvements\n+\n+* [`redundant_slicing`]: Fixed suggestion for a method calls\n+  [#8218](https://github.com/rust-lang/rust-clippy/pull/8218)\n+* [`map_flatten`]: Long suggestions will now be split up into two help messages\n+  [#8520](https://github.com/rust-lang/rust-clippy/pull/8520)\n+* [`unnecessary_lazy_evaluations`]: Now shows suggestions for longer code snippets\n+  [#8543](https://github.com/rust-lang/rust-clippy/pull/8543)\n+* [`unnecessary_sort_by`]: Now suggests `Reverse` including the path\n+  [#8462](https://github.com/rust-lang/rust-clippy/pull/8462)\n+* [`search_is_some`]: More suggestions are now `MachineApplicable`\n+  [#8536](https://github.com/rust-lang/rust-clippy/pull/8536)\n+\n+### Documentation Improvements\n+\n+* [`new_without_default`]: Document `pub` requirement for the struct and fields\n+  [#8429](https://github.com/rust-lang/rust-clippy/pull/8429)\n+\n+## Rust 1.60\n+\n+Released 2022-04-07\n+\n+[0eff589...57b3c4b](https://github.com/rust-lang/rust-clippy/compare/0eff589...57b3c4b)\n+\n+### New Lints\n+\n+* [`single_char_lifetime_names`]\n+  [#8236](https://github.com/rust-lang/rust-clippy/pull/8236)\n+* [`iter_overeager_cloned`]\n+  [#8203](https://github.com/rust-lang/rust-clippy/pull/8203)\n+* [`transmute_undefined_repr`]\n+  [#8398](https://github.com/rust-lang/rust-clippy/pull/8398)\n+* [`default_union_representation`]\n+  [#8289](https://github.com/rust-lang/rust-clippy/pull/8289)\n+* [`manual_bits`]\n+  [#8213](https://github.com/rust-lang/rust-clippy/pull/8213)\n+* [`borrow_as_ptr`]\n+  [#8210](https://github.com/rust-lang/rust-clippy/pull/8210)\n+\n+### Moves and Deprecations\n+\n+* Moved [`disallowed_methods`] and [`disallowed_types`] to `style` (now warn-by-default)\n+  [#8261](https://github.com/rust-lang/rust-clippy/pull/8261)\n+* Rename `ref_in_deref` to [`needless_borrow`]\n+  [#8217](https://github.com/rust-lang/rust-clippy/pull/8217)\n+* Moved [`mutex_atomic`] to `nursery` (now allow-by-default)\n+  [#8260](https://github.com/rust-lang/rust-clippy/pull/8260)\n+\n+### Enhancements\n+\n+* [`ptr_arg`]: Now takes the argument usage into account and lints for mutable references\n+  [#8271](https://github.com/rust-lang/rust-clippy/pull/8271)\n+* [`unused_io_amount`]: Now supports async read and write traits\n+  [#8179](https://github.com/rust-lang/rust-clippy/pull/8179)\n+* [`while_let_on_iterator`]: Improved detection to catch more cases\n+  [#8221](https://github.com/rust-lang/rust-clippy/pull/8221)\n+* [`trait_duplication_in_bounds`]: Now covers trait functions with `Self` bounds\n+  [#8252](https://github.com/rust-lang/rust-clippy/pull/8252)\n+* [`unwrap_used`]: Now works for `.get(i).unwrap()` and `.get_mut(i).unwrap()`\n+  [#8372](https://github.com/rust-lang/rust-clippy/pull/8372)\n+* [`map_clone`]: The suggestion takes `msrv` into account\n+  [#8280](https://github.com/rust-lang/rust-clippy/pull/8280)\n+* [`manual_bits`] and [`borrow_as_ptr`]: Now track the `clippy::msrv` attribute\n+  [#8280](https://github.com/rust-lang/rust-clippy/pull/8280)\n+* [`disallowed_methods`]: Now works for methods on primitive types\n+  [#8112](https://github.com/rust-lang/rust-clippy/pull/8112)\n+* [`not_unsafe_ptr_arg_deref`]: Now works for type aliases\n+  [#8273](https://github.com/rust-lang/rust-clippy/pull/8273)\n+* [`needless_question_mark`]: Now works for async functions\n+  [#8311](https://github.com/rust-lang/rust-clippy/pull/8311)\n+* [`iter_not_returning_iterator`]: Now handles type projections\n+  [#8228](https://github.com/rust-lang/rust-clippy/pull/8228)\n+* [`wrong_self_convention`]: Now detects wrong `self` references in more cases\n+  [#8208](https://github.com/rust-lang/rust-clippy/pull/8208)\n+* [`single_match`]: Now works for `match` statements with tuples\n+  [#8322](https://github.com/rust-lang/rust-clippy/pull/8322)\n+\n+### False Positive Fixes\n+\n+* [`erasing_op`]: No longer triggers if the output type changes\n+  [#8204](https://github.com/rust-lang/rust-clippy/pull/8204)\n+* [`if_same_then_else`]: No longer triggers for `if let` statements\n+  [#8297](https://github.com/rust-lang/rust-clippy/pull/8297)\n+* [`manual_memcpy`]: No longer lints on `VecDeque`\n+  [#8226](https://github.com/rust-lang/rust-clippy/pull/8226)\n+* [`trait_duplication_in_bounds`]: Now takes path segments into account\n+  [#8315](https://github.com/rust-lang/rust-clippy/pull/8315)\n+* [`deref_addrof`]: No longer lints when the dereference or borrow occurs in different a context\n+  [#8268](https://github.com/rust-lang/rust-clippy/pull/8268)\n+* [`type_repetition_in_bounds`]: Now checks for full equality to prevent false positives\n+  [#8224](https://github.com/rust-lang/rust-clippy/pull/8224)\n+* [`ptr_arg`]: No longer lint for mutable references in traits\n+  [#8369](https://github.com/rust-lang/rust-clippy/pull/8369)\n+* [`implicit_clone`]: No longer lints for double references\n+  [#8231](https://github.com/rust-lang/rust-clippy/pull/8231)\n+* [`needless_lifetimes`]: No longer lints lifetimes for explicit `self` types\n+  [#8278](https://github.com/rust-lang/rust-clippy/pull/8278)\n+* [`op_ref`]: No longer lints in `BinOp` impl if that can cause recursion\n+  [#8298](https://github.com/rust-lang/rust-clippy/pull/8298)\n+* [`enum_variant_names`]: No longer triggers for empty variant names\n+  [#8329](https://github.com/rust-lang/rust-clippy/pull/8329)\n+* [`redundant_closure`]: No longer lints for `Arc<T>` or `Rc<T>`\n+  [#8193](https://github.com/rust-lang/rust-clippy/pull/8193)\n+* [`iter_not_returning_iterator`]: No longer lints on trait implementations but therefore on trait definitions\n+  [#8228](https://github.com/rust-lang/rust-clippy/pull/8228)\n+* [`single_match`]: No longer lints on exhaustive enum patterns without a wildcard\n+  [#8322](https://github.com/rust-lang/rust-clippy/pull/8322)\n+* [`manual_swap`]: No longer lints on cases that involve automatic dereferences\n+  [#8220](https://github.com/rust-lang/rust-clippy/pull/8220)\n+* [`useless_format`]: Now works for implicit named arguments\n+  [#8295](https://github.com/rust-lang/rust-clippy/pull/8295)\n+\n+### Suggestion Fixes/Improvements\n+\n+* [`needless_borrow`]: Prevent mutable borrows being moved and suggest removing the borrow on method calls\n+  [#8217](https://github.com/rust-lang/rust-clippy/pull/8217)\n+* [`chars_next_cmp`]: Correctly excapes the suggestion\n+  [#8376](https://github.com/rust-lang/rust-clippy/pull/8376)\n+* [`explicit_write`]: Add suggestions for `write!`s with format arguments\n+  [#8365](https://github.com/rust-lang/rust-clippy/pull/8365)\n+* [`manual_memcpy`]: Suggests `copy_from_slice` when applicable\n+  [#8226](https://github.com/rust-lang/rust-clippy/pull/8226)\n+* [`or_fun_call`]: Improved suggestion display for long arguments\n+  [#8292](https://github.com/rust-lang/rust-clippy/pull/8292)\n+* [`unnecessary_cast`]: Now correctly includes the sign\n+  [#8350](https://github.com/rust-lang/rust-clippy/pull/8350)\n+* [`cmp_owned`]: No longer flips the comparison order\n+  [#8299](https://github.com/rust-lang/rust-clippy/pull/8299)\n+* [`explicit_counter_loop`]: Now correctly suggests `iter()` on references\n+  [#8382](https://github.com/rust-lang/rust-clippy/pull/8382)\n+\n+### ICE Fixes\n+\n+* [`manual_split_once`]\n+  [#8250](https://github.com/rust-lang/rust-clippy/pull/8250)\n+\n+### Documentation Improvements\n+\n+* [`map_flatten`]: Add documentation for the `Option` type\n+  [#8354](https://github.com/rust-lang/rust-clippy/pull/8354)\n+* Document that Clippy's driver might use a different code generation than rustc\n+  [#8037](https://github.com/rust-lang/rust-clippy/pull/8037)\n+* Clippy's lint list will now automatically focus the search box\n+  [#8343](https://github.com/rust-lang/rust-clippy/pull/8343)\n+\n+### Others\n+\n+* Clippy now warns if we find multiple Clippy config files exist\n+  [#8326](https://github.com/rust-lang/rust-clippy/pull/8326)\n+\n+## Rust 1.59\n+\n+Released 2022-02-24\n+\n+[e181011...0eff589](https://github.com/rust-lang/rust-clippy/compare/e181011...0eff589)\n+\n+### New Lints\n+\n+* [`index_refutable_slice`]\n+  [#7643](https://github.com/rust-lang/rust-clippy/pull/7643)\n+* [`needless_splitn`]\n+  [#7896](https://github.com/rust-lang/rust-clippy/pull/7896)\n+* [`unnecessary_to_owned`]\n+  [#7978](https://github.com/rust-lang/rust-clippy/pull/7978)\n+* [`needless_late_init`]\n+  [#7995](https://github.com/rust-lang/rust-clippy/pull/7995)\n+* [`octal_escapes`] [#8007](https://github.com/rust-lang/rust-clippy/pull/8007)\n+* [`return_self_not_must_use`]\n+  [#8071](https://github.com/rust-lang/rust-clippy/pull/8071)\n+* [`init_numbered_fields`]\n+  [#8170](https://github.com/rust-lang/rust-clippy/pull/8170)\n+\n+### Moves and Deprecations\n+\n+* Move `if_then_panic` to `pedantic` and rename to [`manual_assert`] (now\n+  allow-by-default) [#7810](https://github.com/rust-lang/rust-clippy/pull/7810)\n+* Rename `disallow_type` to [`disallowed_types`] and `disallowed_method` to\n+  [`disallowed_methods`]\n+  [#7984](https://github.com/rust-lang/rust-clippy/pull/7984)\n+* Move [`map_flatten`] to `complexity` (now warn-by-default)\n+  [#8054](https://github.com/rust-lang/rust-clippy/pull/8054)\n+\n+### Enhancements\n+\n+* [`match_overlapping_arm`]: Fix false negative where after included ranges,\n+  overlapping ranges weren't linted anymore\n+  [#7909](https://github.com/rust-lang/rust-clippy/pull/7909)\n+* [`deprecated_cfg_attr`]: Now takes the specified MSRV into account\n+  [#7944](https://github.com/rust-lang/rust-clippy/pull/7944)\n+* [`cast_lossless`]: Now also lints for `bool` to integer casts\n+  [#7948](https://github.com/rust-lang/rust-clippy/pull/7948)\n+* [`let_underscore_lock`]: Also emit lints for the `parking_lot` crate\n+  [#7957](https://github.com/rust-lang/rust-clippy/pull/7957)\n+* [`needless_borrow`]\n+  [#7977](https://github.com/rust-lang/rust-clippy/pull/7977)\n+    * Lint when a borrow is auto-dereffed more than once\n+    * Lint in the trailing expression of a block for a match arm\n+* [`strlen_on_c_strings`]\n+  [8001](https://github.com/rust-lang/rust-clippy/pull/8001)\n+    * Lint when used without a fully-qualified path\n+    * Suggest removing the surrounding unsafe block when possible\n+* [`non_ascii_literal`]: Now also lints on `char`s, not just `string`s\n+  [#8034](https://github.com/rust-lang/rust-clippy/pull/8034)\n+* [`single_char_pattern`]: Now also lints on `split_inclusive`, `split_once`,\n+  `rsplit_once`, `replace`, and `replacen`\n+  [#8077](https://github.com/rust-lang/rust-clippy/pull/8077)\n+* [`unwrap_or_else_default`]: Now also lints on `std` constructors like\n+  `Vec::new`, `HashSet::new`, and `HashMap::new`\n+  [#8163](https://github.com/rust-lang/rust-clippy/pull/8163)\n+* [`shadow_reuse`]: Now also lints on shadowed `if let` bindings, instead of\n+  [`shadow_unrelated`]\n+  [#8165](https://github.com/rust-lang/rust-clippy/pull/8165)\n+\n+### False Positive Fixes\n+\n+* [`or_fun_call`], [`unnecessary_lazy_evaluations`]: Improve heuristics, so that\n+  cheap functions (e.g. calling `.len()` on a `Vec`) won't get linted anymore\n+  [#7639](https://github.com/rust-lang/rust-clippy/pull/7639)\n+* [`manual_split_once`]: No longer suggests code changing the original behavior\n+  [#7896](https://github.com/rust-lang/rust-clippy/pull/7896)\n+* Don't show [`no_effect`] or [`unnecessary_operation`] warning for unit struct\n+  implementing `FnOnce`\n+  [#7898](https://github.com/rust-lang/rust-clippy/pull/7898)\n+* [`semicolon_if_nothing_returned`]: Fixed a bug, where the lint wrongly\n+  triggered on `let-else` statements\n+  [#7955](https://github.com/rust-lang/rust-clippy/pull/7955)\n+* [`if_then_some_else_none`]: No longer lints if there is an early return\n+  [#7980](https://github.com/rust-lang/rust-clippy/pull/7980)\n+* [`needless_collect`]: No longer suggests removal of `collect` when removal\n+  would create code requiring mutably borrowing a value multiple times\n+  [#7982](https://github.com/rust-lang/rust-clippy/pull/7982)\n+* [`shadow_same`]: Fix false positive for `async` function's params\n+  [#7997](https://github.com/rust-lang/rust-clippy/pull/7997)\n+* [`suboptimal_flops`]: No longer triggers in constant functions\n+  [#8009](https://github.com/rust-lang/rust-clippy/pull/8009)\n+* [`type_complexity`]: No longer lints on associated types in traits\n+  [#8030](https://github.com/rust-lang/rust-clippy/pull/8030)\n+* [`question_mark`]: No longer lints if returned object is not local\n+  [#8080](https://github.com/rust-lang/rust-clippy/pull/8080)\n+* [`option_if_let_else`]: No longer lint on complex sub-patterns\n+  [#8086](https://github.com/rust-lang/rust-clippy/pull/8086)\n+* [`blocks_in_if_conditions`]: No longer lints on empty closures\n+  [#8100](https://github.com/rust-lang/rust-clippy/pull/8100)\n+* [`enum_variant_names`]: No longer lint when first prefix is only a substring\n+  of a camel-case word\n+  [#8127](https://github.com/rust-lang/rust-clippy/pull/8127)\n+* [`identity_op`]: Only lint on integral operands\n+  [#8183](https://github.com/rust-lang/rust-clippy/pull/8183)\n+\n+### Suggestion Fixes/Improvements\n+\n+* [`search_is_some`]: Fix suggestion for `any()` not taking item by reference\n+  [#7463](https://github.com/rust-lang/rust-clippy/pull/7463)\n+* [`almost_swapped`]: Now detects if there is a `no_std` or `no_core` attribute\n+  and adapts the suggestion accordingly\n+  [#7877](https://github.com/rust-lang/rust-clippy/pull/7877)\n+* [`redundant_pattern_matching`]: Fix suggestion for deref expressions\n+  [#7949](https://github.com/rust-lang/rust-clippy/pull/7949)\n+* [`explicit_counter_loop`]: Now also produces a suggestion for non-`usize`\n+  types [#7950](https://github.com/rust-lang/rust-clippy/pull/7950)\n+* [`manual_map`]: Fix suggestion when used with unsafe functions and blocks\n+  [#7968](https://github.com/rust-lang/rust-clippy/pull/7968)\n+* [`option_map_or_none`]: Suggest `map` over `and_then` when possible\n+  [#7971](https://github.com/rust-lang/rust-clippy/pull/7971)\n+* [`option_if_let_else`]: No longer expands macros in the suggestion\n+  [#7974](https://github.com/rust-lang/rust-clippy/pull/7974)\n+* [`iter_cloned_collect`]: Suggest `copied` over `cloned` when possible\n+  [#8006](https://github.com/rust-lang/rust-clippy/pull/8006)\n+* [`doc_markdown`]: No longer uses inline hints to improve readability of\n+  suggestion [#8011](https://github.com/rust-lang/rust-clippy/pull/8011)\n+* [`needless_question_mark`]: Now better explains the suggestion\n+  [#8028](https://github.com/rust-lang/rust-clippy/pull/8028)\n+* [`single_char_pattern`]: Escape backslash `\\` in suggestion\n+  [#8067](https://github.com/rust-lang/rust-clippy/pull/8067)\n+* [`needless_bool`]: Suggest `a != b` over `!(a == b)`\n+  [#8117](https://github.com/rust-lang/rust-clippy/pull/8117)\n+* [`iter_skip_next`]: Suggest to add a `mut` if it is necessary in order to\n+  apply this lints suggestion\n+  [#8133](https://github.com/rust-lang/rust-clippy/pull/8133)\n+* [`neg_multiply`]: Now produces a suggestion\n+  [#8144](https://github.com/rust-lang/rust-clippy/pull/8144)\n+* [`needless_return`]: Now suggests the unit type `()` over an empty block `{}`\n+  in match arms [#8185](https://github.com/rust-lang/rust-clippy/pull/8185)\n+* [`suboptimal_flops`]: Now gives a syntactically correct suggestion for\n+  `to_radians` and `to_degrees`\n+  [#8187](https://github.com/rust-lang/rust-clippy/pull/8187)\n+\n+### ICE Fixes\n+\n+* [`undocumented_unsafe_blocks`]\n+  [#7945](https://github.com/rust-lang/rust-clippy/pull/7945)\n+  [#7988](https://github.com/rust-lang/rust-clippy/pull/7988)\n+* [`unnecessary_cast`]\n+  [#8167](https://github.com/rust-lang/rust-clippy/pull/8167)\n+\n+### Documentation Improvements\n+\n+* [`print_stdout`], [`print_stderr`], [`dbg_macro`]: Document how the lint level\n+  can be changed crate-wide\n+  [#8040](https://github.com/rust-lang/rust-clippy/pull/8040)\n+* Added a note to the `README` that config changes don't apply to already\n+  compiled code [#8175](https://github.com/rust-lang/rust-clippy/pull/8175)\n+\n+### Others\n+\n+* [Clippy's lint\n+  list](https://rust-lang.github.io/rust-clippy/master/index.html) now displays\n+  the version a lint was added. :tada:\n+  [#7813](https://github.com/rust-lang/rust-clippy/pull/7813)\n+* New and improved issue templates\n+  [#8032](https://github.com/rust-lang/rust-clippy/pull/8032)\n+* _Dev:_ Add `cargo dev lint` command, to run your modified Clippy version on a\n+  file [#7917](https://github.com/rust-lang/rust-clippy/pull/7917)\n+\n+## Rust 1.58\n+\n+Released 2022-01-13\n \n [00e31fa...e181011](https://github.com/rust-lang/rust-clippy/compare/00e31fa...e181011)\n \n+### Rust 1.58.1\n+\n+* Move [`non_send_fields_in_send_ty`] to `nursery` (now allow-by-default)\n+  [#8075](https://github.com/rust-lang/rust-clippy/pull/8075)\n+* [`useless_format`]: Handle implicit named arguments\n+  [#8295](https://github.com/rust-lang/rust-clippy/pull/8295)\n+\n ### New lints\n \n * [`transmute_num_to_bytes`]\n@@ -124,7 +528,7 @@ Current beta, release 2022-01-13\n \n ## Rust 1.57\n \n-Current stable, released 2021-12-02\n+Released 2021-12-02\n \n [7bfc26e...00e31fa](https://github.com/rust-lang/rust-clippy/compare/7bfc26e...00e31fa)\n \n@@ -1267,7 +1671,7 @@ Released 2020-11-19\n * [`manual_strip`] [#6038](https://github.com/rust-lang/rust-clippy/pull/6038)\n * [`map_err_ignore`] [#5998](https://github.com/rust-lang/rust-clippy/pull/5998)\n * [`rc_buffer`] [#6044](https://github.com/rust-lang/rust-clippy/pull/6044)\n-* [`to_string_in_display`] [#5831](https://github.com/rust-lang/rust-clippy/pull/5831)\n+* `to_string_in_display` [#5831](https://github.com/rust-lang/rust-clippy/pull/5831)\n * `single_char_push_str` [#5881](https://github.com/rust-lang/rust-clippy/pull/5881)\n \n ### Moves and Deprecations\n@@ -1310,7 +1714,7 @@ Released 2020-11-19\n   [#5949](https://github.com/rust-lang/rust-clippy/pull/5949)\n * [`doc_markdown`]: allow using \"GraphQL\" without backticks\n   [#5996](https://github.com/rust-lang/rust-clippy/pull/5996)\n-* [`to_string_in_display`]: avoid linting when calling `to_string()` on anything that is not `self`\n+* `to_string_in_display`: avoid linting when calling `to_string()` on anything that is not `self`\n   [#5971](https://github.com/rust-lang/rust-clippy/pull/5971)\n * [`indexing_slicing`] and [`out_of_bounds_indexing`] treat references to arrays as arrays\n   [#6034](https://github.com/rust-lang/rust-clippy/pull/6034)\n@@ -2871,39 +3275,49 @@ Released 2018-09-13\n <!-- lint disable no-unused-definitions -->\n <!-- begin autogenerated links to lint list -->\n [`absurd_extreme_comparisons`]: https://rust-lang.github.io/rust-clippy/master/index.html#absurd_extreme_comparisons\n+[`allow_attributes_without_reason`]: https://rust-lang.github.io/rust-clippy/master/index.html#allow_attributes_without_reason\n [`almost_swapped`]: https://rust-lang.github.io/rust-clippy/master/index.html#almost_swapped\n [`approx_constant`]: https://rust-lang.github.io/rust-clippy/master/index.html#approx_constant\n [`as_conversions`]: https://rust-lang.github.io/rust-clippy/master/index.html#as_conversions\n [`assertions_on_constants`]: https://rust-lang.github.io/rust-clippy/master/index.html#assertions_on_constants\n [`assign_op_pattern`]: https://rust-lang.github.io/rust-clippy/master/index.html#assign_op_pattern\n [`assign_ops`]: https://rust-lang.github.io/rust-clippy/master/index.html#assign_ops\n [`async_yields_async`]: https://rust-lang.github.io/rust-clippy/master/index.html#async_yields_async\n+[`await_holding_invalid_type`]: https://rust-lang.github.io/rust-clippy/master/index.html#await_holding_invalid_type\n [`await_holding_lock`]: https://rust-lang.github.io/rust-clippy/master/index.html#await_holding_lock\n [`await_holding_refcell_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#await_holding_refcell_ref\n [`bad_bit_mask`]: https://rust-lang.github.io/rust-clippy/master/index.html#bad_bit_mask\n [`bind_instead_of_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#bind_instead_of_map\n [`blacklisted_name`]: https://rust-lang.github.io/rust-clippy/master/index.html#blacklisted_name\n [`blanket_clippy_restriction_lints`]: https://rust-lang.github.io/rust-clippy/master/index.html#blanket_clippy_restriction_lints\n+[`block_in_if_condition_expr`]: https://rust-lang.github.io/rust-clippy/master/index.html#block_in_if_condition_expr\n+[`block_in_if_condition_stmt`]: https://rust-lang.github.io/rust-clippy/master/index.html#block_in_if_condition_stmt\n [`blocks_in_if_conditions`]: https://rust-lang.github.io/rust-clippy/master/index.html#blocks_in_if_conditions\n [`bool_assert_comparison`]: https://rust-lang.github.io/rust-clippy/master/index.html#bool_assert_comparison\n [`bool_comparison`]: https://rust-lang.github.io/rust-clippy/master/index.html#bool_comparison\n [`borrow_as_ptr`]: https://rust-lang.github.io/rust-clippy/master/index.html#borrow_as_ptr\n [`borrow_interior_mutable_const`]: https://rust-lang.github.io/rust-clippy/master/index.html#borrow_interior_mutable_const\n [`borrowed_box`]: https://rust-lang.github.io/rust-clippy/master/index.html#borrowed_box\n [`box_collection`]: https://rust-lang.github.io/rust-clippy/master/index.html#box_collection\n+[`box_vec`]: https://rust-lang.github.io/rust-clippy/master/index.html#box_vec\n [`boxed_local`]: https://rust-lang.github.io/rust-clippy/master/index.html#boxed_local\n [`branches_sharing_code`]: https://rust-lang.github.io/rust-clippy/master/index.html#branches_sharing_code\n [`builtin_type_shadow`]: https://rust-lang.github.io/rust-clippy/master/index.html#builtin_type_shadow\n+[`bytes_count_to_len`]: https://rust-lang.github.io/rust-clippy/master/index.html#bytes_count_to_len\n [`bytes_nth`]: https://rust-lang.github.io/rust-clippy/master/index.html#bytes_nth\n [`cargo_common_metadata`]: https://rust-lang.github.io/rust-clippy/master/index.html#cargo_common_metadata\n [`case_sensitive_file_extension_comparisons`]: https://rust-lang.github.io/rust-clippy/master/index.html#case_sensitive_file_extension_comparisons\n+[`cast_abs_to_unsigned`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_abs_to_unsigned\n+[`cast_enum_constructor`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_enum_constructor\n+[`cast_enum_truncation`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_enum_truncation\n [`cast_lossless`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_lossless\n [`cast_possible_truncation`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_possible_truncation\n [`cast_possible_wrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_possible_wrap\n [`cast_precision_loss`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_precision_loss\n [`cast_ptr_alignment`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_ptr_alignment\n [`cast_ref_to_mut`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_ref_to_mut\n [`cast_sign_loss`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_sign_loss\n+[`cast_slice_different_sizes`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_slice_different_sizes\n [`char_lit_as_u8`]: https://rust-lang.github.io/rust-clippy/master/index.html#char_lit_as_u8\n [`chars_last_cmp`]: https://rust-lang.github.io/rust-clippy/master/index.html#chars_last_cmp\n [`chars_next_cmp`]: https://rust-lang.github.io/rust-clippy/master/index.html#chars_next_cmp\n@@ -2921,9 +3335,12 @@ Released 2018-09-13\n [`collapsible_match`]: https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_match\n [`comparison_chain`]: https://rust-lang.github.io/rust-clippy/master/index.html#comparison_chain\n [`comparison_to_empty`]: https://rust-lang.github.io/rust-clippy/master/index.html#comparison_to_empty\n+[`const_static_lifetime`]: https://rust-lang.github.io/rust-clippy/master/index.html#const_static_lifetime\n [`copy_iterator`]: https://rust-lang.github.io/rust-clippy/master/index.html#copy_iterator\n+[`crate_in_macro_def`]: https://rust-lang.github.io/rust-clippy/master/index.html#crate_in_macro_def\n [`create_dir`]: https://rust-lang.github.io/rust-clippy/master/index.html#create_dir\n [`crosspointer_transmute`]: https://rust-lang.github.io/rust-clippy/master/index.html#crosspointer_transmute\n+[`cyclomatic_complexity`]: https://rust-lang.github.io/rust-clippy/master/index.html#cyclomatic_complexity\n [`dbg_macro`]: https://rust-lang.github.io/rust-clippy/master/index.html#dbg_macro\n [`debug_assert_with_mut_call`]: https://rust-lang.github.io/rust-clippy/master/index.html#debug_assert_with_mut_call\n [`decimal_literal_representation`]: https://rust-lang.github.io/rust-clippy/master/index.html#decimal_literal_representation\n@@ -2934,11 +3351,15 @@ Released 2018-09-13\n [`deprecated_cfg_attr`]: https://rust-lang.github.io/rust-clippy/master/index.html#deprecated_cfg_attr\n [`deprecated_semver`]: https://rust-lang.github.io/rust-clippy/master/index.html#deprecated_semver\n [`deref_addrof`]: https://rust-lang.github.io/rust-clippy/master/index.html#deref_addrof\n+[`deref_by_slicing`]: https://rust-lang.github.io/rust-clippy/master/index.html#deref_by_slicing\n [`derivable_impls`]: https://rust-lang.github.io/rust-clippy/master/index.html#derivable_impls\n [`derive_hash_xor_eq`]: https://rust-lang.github.io/rust-clippy/master/index.html#derive_hash_xor_eq\n [`derive_ord_xor_partial_ord`]: https://rust-lang.github.io/rust-clippy/master/index.html#derive_ord_xor_partial_ord\n+[`derive_partial_eq_without_eq`]: https://rust-lang.github.io/rust-clippy/master/index.html#derive_partial_eq_without_eq\n+[`disallowed_method`]: https://rust-lang.github.io/rust-clippy/master/index.html#disallowed_method\n [`disallowed_methods`]: https://rust-lang.github.io/rust-clippy/master/index.html#disallowed_methods\n [`disallowed_script_idents`]: https://rust-lang.github.io/rust-clippy/master/index.html#disallowed_script_idents\n+[`disallowed_type`]: https://rust-lang.github.io/rust-clippy/master/index.html#disallowed_type\n [`disallowed_types`]: https://rust-lang.github.io/rust-clippy/master/index.html#disallowed_types\n [`diverging_sub_expression`]: https://rust-lang.github.io/rust-clippy/master/index.html#diverging_sub_expression\n [`doc_link_with_quotes`]: https://rust-lang.github.io/rust-clippy/master/index.html#doc_link_with_quotes\n@@ -2947,20 +3368,26 @@ Released 2018-09-13\n [`double_must_use`]: https://rust-lang.github.io/rust-clippy/master/index.html#double_must_use\n [`double_neg`]: https://rust-lang.github.io/rust-clippy/master/index.html#double_neg\n [`double_parens`]: https://rust-lang.github.io/rust-clippy/master/index.html#double_parens\n+[`drop_bounds`]: https://rust-lang.github.io/rust-clippy/master/index.html#drop_bounds\n [`drop_copy`]: https://rust-lang.github.io/rust-clippy/master/index.html#drop_copy\n+[`drop_non_drop`]: https://rust-lang.github.io/rust-clippy/master/index.html#drop_non_drop\n [`drop_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#drop_ref\n+[`duplicate_mod`]: https://rust-lang.github.io/rust-clippy/master/index.html#duplicate_mod\n [`duplicate_underscore_argument`]: https://rust-lang.github.io/rust-clippy/master/index.html#duplicate_underscore_argument\n [`duration_subsec`]: https://rust-lang.github.io/rust-clippy/master/index.html#duration_subsec\n [`else_if_without_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#else_if_without_else\n+[`empty_drop`]: https://rust-lang.github.io/rust-clippy/master/index.html#empty_drop\n [`empty_enum`]: https://rust-lang.github.io/rust-clippy/master/index.html#empty_enum\n [`empty_line_after_outer_attr`]: https://rust-lang.github.io/rust-clippy/master/index.html#empty_line_after_outer_attr\n [`empty_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#empty_loop\n+[`empty_structs_with_brackets`]: https://rust-lang.github.io/rust-clippy/master/index.html#empty_structs_with_brackets\n [`enum_clike_unportable_variant`]: https://rust-lang.github.io/rust-clippy/master/index.html#enum_clike_unportable_variant\n [`enum_glob_use`]: https://rust-lang.github.io/rust-clippy/master/index.html#enum_glob_use\n [`enum_variant_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#enum_variant_names\n [`eq_op`]: https://rust-lang.github.io/rust-clippy/master/index.html#eq_op\n [`equatable_if_let`]: https://rust-lang.github.io/rust-clippy/master/index.html#equatable_if_let\n [`erasing_op`]: https://rust-lang.github.io/rust-clippy/master/index.html#erasing_op\n+[`err_expect`]: https://rust-lang.github.io/rust-clippy/master/index.html#err_expect\n [`eval_order_dependence`]: https://rust-lang.github.io/rust-clippy/master/index.html#eval_order_dependence\n [`excessive_precision`]: https://rust-lang.github.io/rust-clippy/master/index.html#excessive_precision\n [`exhaustive_enums`]: https://rust-lang.github.io/rust-clippy/master/index.html#exhaustive_enums\n@@ -2997,19 +3424,26 @@ Released 2018-09-13\n [`fn_to_numeric_cast_any`]: https://rust-lang.github.io/rust-clippy/master/index.html#fn_to_numeric_cast_any\n [`fn_to_numeric_cast_with_truncation`]: https://rust-lang.github.io/rust-clippy/master/index.html#fn_to_numeric_cast_with_truncation\n [`for_kv_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#for_kv_map\n+[`for_loop_over_option`]: https://rust-lang.github.io/rust-clippy/master/index.html#for_loop_over_option\n+[`for_loop_over_result`]: https://rust-lang.github.io/rust-clippy/master/index.html#for_loop_over_result\n [`for_loops_over_fallibles`]: https://rust-lang.github.io/rust-clippy/master/index.html#for_loops_over_fallibles\n [`forget_copy`]: https://rust-lang.github.io/rust-clippy/master/index.html#forget_copy\n+[`forget_non_drop`]: https://rust-lang.github.io/rust-clippy/master/index.html#forget_non_drop\n [`forget_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#forget_ref\n [`format_in_format_args`]: https://rust-lang.github.io/rust-clippy/master/index.html#format_in_format_args\n+[`format_push_string`]: https://rust-lang.github.io/rust-clippy/master/index.html#format_push_string\n [`from_iter_instead_of_collect`]: https://rust-lang.github.io/rust-clippy/master/index.html#from_iter_instead_of_collect\n [`from_over_into`]: https://rust-lang.github.io/rust-clippy/master/index.html#from_over_into\n [`from_str_radix_10`]: https://rust-lang.github.io/rust-clippy/master/index.html#from_str_radix_10\n [`future_not_send`]: https://rust-lang.github.io/rust-clippy/master/index.html#future_not_send\n+[`get_first`]: https://rust-lang.github.io/rust-clippy/master/index.html#get_first\n [`get_last_with_len`]: https://rust-lang.github.io/rust-clippy/master/index.html#get_last_with_len\n [`get_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#get_unwrap\n+[`identity_conversion`]: https://rust-lang.github.io/rust-clippy/master/index.html#identity_conversion\n [`identity_op`]: https://rust-lang.github.io/rust-clippy/master/index.html#identity_op\n [`if_let_mutex`]: https://rust-lang.github.io/rust-clippy/master/index.html#if_let_mutex\n [`if_let_redundant_pattern_matching`]: https://rust-lang.github.io/rust-clippy/master/index.html#if_let_redundant_pattern_matching\n+[`if_let_some_result`]: https://rust-lang.github.io/rust-clippy/master/index.html#if_let_some_result\n [`if_not_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#if_not_else\n [`if_same_then_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#if_same_then_else\n [`if_then_some_else_none`]: https://rust-lang.github.io/rust-clippy/master/index.html#if_then_some_else_none\n@@ -3038,11 +3472,15 @@ Released 2018-09-13\n [`int_plus_one`]: https://rust-lang.github.io/rust-clippy/master/index.html#int_plus_one\n [`integer_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#integer_arithmetic\n [`integer_division`]: https://rust-lang.github.io/rust-clippy/master/index.html#integer_division\n+[`into_iter_on_array`]: https://rust-lang.github.io/rust-clippy/master/index.html#into_iter_on_array\n [`into_iter_on_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#into_iter_on_ref\n+[`invalid_atomic_ordering`]: https://rust-lang.github.io/rust-clippy/master/index.html#invalid_atomic_ordering\n [`invalid_null_ptr_usage`]: https://rust-lang.github.io/rust-clippy/master/index.html#invalid_null_ptr_usage\n+[`invalid_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#invalid_ref\n [`invalid_regex`]: https://rust-lang.github.io/rust-clippy/master/index.html#invalid_regex\n [`invalid_upcast_comparisons`]: https://rust-lang.github.io/rust-clippy/master/index.html#invalid_upcast_comparisons\n [`invisible_characters`]: https://rust-lang.github.io/rust-clippy/master/index.html#invisible_characters\n+[`is_digit_ascii_radix`]: https://rust-lang.github.io/rust-clippy/master/index.html#is_digit_ascii_radix\n [`items_after_statements`]: https://rust-lang.github.io/rust-clippy/master/index.html#items_after_statements\n [`iter_cloned_collect`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_cloned_collect\n [`iter_count`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_count\n@@ -3053,11 +3491,13 @@ Released 2018-09-13\n [`iter_nth_zero`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_nth_zero\n [`iter_overeager_cloned`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_overeager_cloned\n [`iter_skip_next`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_skip_next\n+[`iter_with_drain`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_with_drain\n [`iterator_step_by_zero`]: https://rust-lang.github.io/rust-clippy/master/index.html#iterator_step_by_zero\n [`just_underscores_and_digits`]: https://rust-lang.github.io/rust-clippy/master/index.html#just_underscores_and_digits\n [`large_const_arrays`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_const_arrays\n [`large_digit_groups`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_digit_groups\n [`large_enum_variant`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_enum_variant\n+[`large_include_file`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_include_file\n [`large_stack_arrays`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_stack_arrays\n [`large_types_passed_by_value`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_types_passed_by_value\n [`len_without_is_empty`]: https://rust-lang.github.io/rust-clippy/master/index.html#len_without_is_empty\n@@ -3110,6 +3550,7 @@ Released 2018-09-13\n [`match_wild_err_arm`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_wild_err_arm\n [`match_wildcard_for_single_variants`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_wildcard_for_single_variants\n [`maybe_infinite_iter`]: https://rust-lang.github.io/rust-clippy/master/index.html#maybe_infinite_iter\n+[`mem_discriminant_non_enum`]: https://rust-lang.github.io/rust-clippy/master/index.html#mem_discriminant_non_enum\n [`mem_forget`]: https://rust-lang.github.io/rust-clippy/master/index.html#mem_forget\n [`mem_replace_option_with_none`]: https://rust-lang.github.io/rust-clippy/master/index.html#mem_replace_option_with_none\n [`mem_replace_with_default`]: https://rust-lang.github.io/rust-clippy/master/index.html#mem_replace_with_default\n@@ -3125,8 +3566,10 @@ Released 2018-09-13\n [`missing_inline_in_public_items`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_inline_in_public_items\n [`missing_panics_doc`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_panics_doc\n [`missing_safety_doc`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_safety_doc\n+[`missing_spin_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#missing_spin_loop\n [`mistyped_literal_suffixes`]: https://rust-lang.github.io/rust-clippy/master/index.html#mistyped_literal_suffixes\n [`mixed_case_hex_literals`]: https://rust-lang.github.io/rust-clippy/master/index.html#mixed_case_hex_literals\n+[`mixed_read_write_in_expression`]: https://rust-lang.github.io/rust-clippy/master/index.html#mixed_read_write_in_expression\n [`mod_module_files`]: https://rust-lang.github.io/rust-clippy/master/index.html#mod_module_files\n [`module_inception`]: https://rust-lang.github.io/rust-clippy/master/index.html#module_inception\n [`module_name_repetitions`]: https://rust-lang.github.io/rust-clippy/master/index.html#module_name_repetitions\n@@ -3155,7 +3598,9 @@ Released 2018-09-13\n [`needless_for_each`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_for_each\n [`needless_late_init`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_late_init\n [`needless_lifetimes`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_lifetimes\n+[`needless_match`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_match\n [`needless_option_as_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_option_as_deref\n+[`needless_option_take`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_option_take\n [`needless_pass_by_value`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_pass_by_value\n [`needless_question_mark`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_question_mark\n [`needless_range_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_range_loop\n@@ -3168,7 +3613,9 @@ Released 2018-09-13\n [`never_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#never_loop\n [`new_ret_no_self`]: https://rust-lang.github.io/rust-clippy/master/index.html#new_ret_no_self\n [`new_without_default`]: https://rust-lang.github.io/rust-clippy/master/index.html#new_without_default\n+[`new_without_default_derive`]: https://rust-lang.github.io/rust-clippy/master/index.html#new_without_default_derive\n [`no_effect`]: https://rust-lang.github.io/rust-clippy/master/index.html#no_effect\n+[`no_effect_replace`]: https://rust-lang.github.io/rust-clippy/master/index.html#no_effect_replace\n [`no_effect_underscore_binding`]: https://rust-lang.github.io/rust-clippy/master/index.html#no_effect_underscore_binding\n [`non_ascii_literal`]: https://rust-lang.github.io/rust-clippy/master/index.html#non_ascii_literal\n [`non_octal_unix_permissions`]: https://rust-lang.github.io/rust-clippy/master/index.html#non_octal_unix_permissions\n@@ -3179,25 +3626,34 @@ Released 2018-09-13\n [`not_unsafe_ptr_arg_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#not_unsafe_ptr_arg_deref\n [`octal_escapes`]: https://rust-lang.github.io/rust-clippy/master/index.html#octal_escapes\n [`ok_expect`]: https://rust-lang.github.io/rust-clippy/master/index.html#ok_expect\n+[`only_used_in_recursion`]: https://rust-lang.github.io/rust-clippy/master/index.html#only_used_in_recursion\n [`op_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#op_ref\n+[`option_and_then_some`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_and_then_some\n [`option_as_ref_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_as_ref_deref\n [`option_env_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_env_unwrap\n+[`option_expect_used`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_expect_used\n [`option_filter_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_filter_map\n [`option_if_let_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_if_let_else\n [`option_map_or_none`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_map_or_none\n [`option_map_unit_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_map_unit_fn\n+[`option_map_unwrap_or`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_map_unwrap_or\n+[`option_map_unwrap_or_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_map_unwrap_or_else\n [`option_option`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_option\n+[`option_unwrap_used`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_unwrap_used\n [`or_fun_call`]: https://rust-lang.github.io/rust-clippy/master/index.html#or_fun_call\n+[`or_then_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#or_then_unwrap\n [`out_of_bounds_indexing`]: https://rust-lang.github.io/rust-clippy/master/index.html#out_of_bounds_indexing\n [`overflow_check_conditional`]: https://rust-lang.github.io/rust-clippy/master/index.html#overflow_check_conditional\n [`panic`]: https://rust-lang.github.io/rust-clippy/master/index.html#panic\n [`panic_in_result_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#panic_in_result_fn\n+[`panic_params`]: https://rust-lang.github.io/rust-clippy/master/index.html#panic_params\n [`panicking_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#panicking_unwrap\n [`partialeq_ne_impl`]: https://rust-lang.github.io/rust-clippy/master/index.html#partialeq_ne_impl\n [`path_buf_push_overwrite`]: https://rust-lang.github.io/rust-clippy/master/index.html#path_buf_push_overwrite\n [`pattern_type_mismatch`]: https://rust-lang.github.io/rust-clippy/master/index.html#pattern_type_mismatch\n [`possible_missing_comma`]: https://rust-lang.github.io/rust-clippy/master/index.html#possible_missing_comma\n [`precedence`]: https://rust-lang.github.io/rust-clippy/master/index.html#precedence\n+[`print_in_format_impl`]: https://rust-lang.github.io/rust-clippy/master/index.html#print_in_format_impl\n [`print_literal`]: https://rust-lang.github.io/rust-clippy/master/index.html#print_literal\n [`print_stderr`]: https://rust-lang.github.io/rust-clippy/master/index.html#print_stderr\n [`print_stdout`]: https://rust-lang.github.io/rust-clippy/master/index.html#print_stdout\n@@ -3208,13 +3664,16 @@ Released 2018-09-13\n [`ptr_eq`]: https://rust-lang.github.io/rust-clippy/master/index.html#ptr_eq\n [`ptr_offset_with_cast`]: https://rust-lang.github.io/rust-clippy/master/index.html#ptr_offset_with_cast\n [`pub_enum_variant_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#pub_enum_variant_names\n+[`pub_use`]: https://rust-lang.github.io/rust-clippy/master/index.html#pub_use\n [`question_mark`]: https://rust-lang.github.io/rust-clippy/master/index.html#question_mark\n [`range_minus_one`]: https://rust-lang.github.io/rust-clippy/master/index.html#range_minus_one\n [`range_plus_one`]: https://rust-lang.github.io/rust-clippy/master/index.html#range_plus_one\n [`range_step_by_zero`]: https://rust-lang.github.io/rust-clippy/master/index.html#range_step_by_zero\n [`range_zip_with_len`]: https://rust-lang.github.io/rust-clippy/master/index.html#range_zip_with_len\n [`rc_buffer`]: https://rust-lang.github.io/rust-clippy/master/index.html#rc_buffer\n+[`rc_clone_in_vec_init`]: https://rust-lang.github.io/rust-clippy/master/index.html#rc_clone_in_vec_init\n [`rc_mutex`]: https://rust-lang.github.io/rust-clippy/master/index.html#rc_mutex\n+[`recursive_format_impl`]: https://rust-lang.github.io/rust-clippy/master/index.html#recursive_format_impl\n [`redundant_allocation`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_allocation\n [`redundant_clone`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_clone\n [`redundant_closure`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_closure\n@@ -3229,14 +3688,18 @@ Released 2018-09-13\n [`redundant_slicing`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_slicing\n [`redundant_static_lifetimes`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_static_lifetimes\n [`ref_binding_to_reference`]: https://rust-lang.github.io/rust-clippy/master/index.html#ref_binding_to_reference\n+[`ref_in_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#ref_in_deref\n [`ref_option_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#ref_option_ref\n [`regex_macro`]: https://rust-lang.github.io/rust-clippy/master/index.html#regex_macro\n [`repeat_once`]: https://rust-lang.github.io/rust-clippy/master/index.html#repeat_once\n [`replace_consts`]: https://rust-lang.github.io/rust-clippy/master/index.html#replace_consts\n [`rest_pat_in_fully_bound_structs`]: https://rust-lang.github.io/rust-clippy/master/index.html#rest_pat_in_fully_bound_structs\n+[`result_expect_used`]: https://rust-lang.github.io/rust-clippy/master/index.html#result_expect_used\n [`result_map_or_into_option`]: https://rust-lang.github.io/rust-clippy/master/index.html#result_map_or_into_option\n [`result_map_unit_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#result_map_unit_fn\n+[`result_map_unwrap_or_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#result_map_unwrap_or_else\n [`result_unit_err`]: https://rust-lang.github.io/rust-clippy/master/index.html#result_unit_err\n+[`result_unwrap_used`]: https://rust-lang.github.io/rust-clippy/master/index.html#result_unwrap_used\n [`return_self_not_must_use`]: https://rust-lang.github.io/rust-clippy/master/index.html#return_self_not_must_use\n [`reversed_empty_ranges`]: https://rust-lang.github.io/rust-clippy/master/index.html#reversed_empty_ranges\n [`same_functions_in_if_condition`]: https://rust-lang.github.io/rust-clippy/master/index.html#same_functions_in_if_condition\n@@ -3255,10 +3718,12 @@ Released 2018-09-13\n [`short_circuit_statement`]: https://rust-lang.github.io/rust-clippy/master/index.html#short_circuit_statement\n [`should_assert_eq`]: https://rust-lang.github.io/rust-clippy/master/index.html#should_assert_eq\n [`should_implement_trait`]: https://rust-lang.github.io/rust-clippy/master/index.html#should_implement_trait\n+[`significant_drop_in_scrutinee`]: https://rust-lang.github.io/rust-clippy/master/index.html#significant_drop_in_scrutinee\n [`similar_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#similar_names\n [`single_char_add_str`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_char_add_str\n [`single_char_lifetime_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_char_lifetime_names\n [`single_char_pattern`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_char_pattern\n+[`single_char_push_str`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_char_push_str\n [`single_component_path_imports`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_component_path_imports\n [`single_element_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_element_loop\n [`single_match`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_match\n@@ -3277,6 +3742,7 @@ Released 2018-09-13\n [`string_to_string`]: https://rust-lang.github.io/rust-clippy/master/index.html#string_to_string\n [`strlen_on_c_strings`]: https://rust-lang.github.io/rust-clippy/master/index.html#strlen_on_c_strings\n [`struct_excessive_bools`]: https://rust-lang.github.io/rust-clippy/master/index.html#struct_excessive_bools\n+[`stutter`]: https://rust-lang.github.io/rust-clippy/master/index.html#stutter\n [`suboptimal_flops`]: https://rust-lang.github.io/rust-clippy/master/index.html#suboptimal_flops\n [`suspicious_arithmetic_impl`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_arithmetic_impl\n [`suspicious_assignment_formatting`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_assignment_formatting\n@@ -3288,6 +3754,7 @@ Released 2018-09-13\n [`suspicious_unary_op_formatting`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_unary_op_formatting\n [`tabs_in_doc_comments`]: https://rust-lang.github.io/rust-clippy/master/index.html#tabs_in_doc_comments\n [`temporary_assignment`]: https://rust-lang.github.io/rust-clippy/master/index.html#temporary_assignment\n+[`temporary_cstring_as_ptr`]: https://rust-lang.github.io/rust-clippy/master/index.html#temporary_cstring_as_ptr\n [`to_digit_is_some`]: https://rust-lang.github.io/rust-clippy/master/index.html#to_digit_is_some\n [`to_string_in_display`]: https://rust-lang.github.io/rust-clippy/master/index.html#to_string_in_display\n [`to_string_in_format_args`]: https://rust-lang.github.io/rust-clippy/master/index.html#to_string_in_format_args\n@@ -3305,8 +3772,10 @@ Released 2018-09-13\n [`transmute_num_to_bytes`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_num_to_bytes\n [`transmute_ptr_to_ptr`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_ptr_to_ptr\n [`transmute_ptr_to_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_ptr_to_ref\n+[`transmute_undefined_repr`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_undefined_repr\n [`transmutes_expressible_as_ptr_casts`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmutes_expressible_as_ptr_casts\n [`transmuting_null`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmuting_null\n+[`trim_split_whitespace`]: https://rust-lang.github.io/rust-clippy/master/index.html#trim_split_whitespace\n [`trivial_regex`]: https://rust-lang.github.io/rust-clippy/master/index.html#trivial_regex\n [`trivially_copy_pass_by_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#trivially_copy_pass_by_ref\n [`try_err`]: https://rust-lang.github.io/rust-clippy/master/index.html#try_err\n@@ -3322,12 +3791,16 @@ Released 2018-09-13\n [`unit_cmp`]: https://rust-lang.github.io/rust-clippy/master/index.html#unit_cmp\n [`unit_hash`]: https://rust-lang.github.io/rust-clippy/master/index.html#unit_hash\n [`unit_return_expecting_ord`]: https://rust-lang.github.io/rust-clippy/master/index.html#unit_return_expecting_ord\n+[`unknown_clippy_lints`]: https://rust-lang.github.io/rust-clippy/master/index.html#unknown_clippy_lints\n [`unnecessary_cast`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n [`unnecessary_filter_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_filter_map\n+[`unnecessary_find_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_find_map\n [`unnecessary_fold`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_fold\n+[`unnecessary_join`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_join\n [`unnecessary_lazy_evaluations`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_lazy_evaluations\n [`unnecessary_mut_passed`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_mut_passed\n [`unnecessary_operation`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_operation\n+[`unnecessary_owned_empty_strings`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_owned_empty_strings\n [`unnecessary_self_imports`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_self_imports\n [`unnecessary_sort_by`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_sort_by\n [`unnecessary_to_owned`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_to_owned\n@@ -3348,6 +3821,8 @@ Released 2018-09-13\n [`unused_async`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_async\n [`unused_collect`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_collect\n [`unused_io_amount`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_io_amount\n+[`unused_label`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_label\n+[`unused_rounding`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_rounding\n [`unused_self`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_self\n [`unused_unit`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_unit\n [`unusual_byte_groupings`]: https://rust-lang.github.io/rust-clippy/master/index.html#unusual_byte_groupings\n@@ -3388,5 +3863,6 @@ Released 2018-09-13\n [`zero_prefixed_literal`]: https://rust-lang.github.io/rust-clippy/master/index.html#zero_prefixed_literal\n [`zero_ptr`]: https://rust-lang.github.io/rust-clippy/master/index.html#zero_ptr\n [`zero_sized_map_values`]: https://rust-lang.github.io/rust-clippy/master/index.html#zero_sized_map_values\n+[`zero_width_space`]: https://rust-lang.github.io/rust-clippy/master/index.html#zero_width_space\n [`zst_offset`]: https://rust-lang.github.io/rust-clippy/master/index.html#zst_offset\n <!-- end autogenerated links to lint list -->"}, {"sha": "6ab2bd59137fa0ef56e13933b9b001ca06fe1bfa", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -67,9 +67,9 @@ and resolved paths.\n \n [`T-AST`] issues will generally need you to match against a predefined syntax structure.\n To figure out how this syntax structure is encoded in the AST, it is recommended to run\n-`rustc -Z ast-json` on an example of the structure and compare with the [nodes in the AST docs].\n+`rustc -Z unpretty=ast-tree` on an example of the structure and compare with the [nodes in the AST docs].\n Usually the lint will end up to be a nested series of matches and ifs, [like so][deep-nesting].\n-But we can make it nest-less by using [if_chain] macro, [like this][nest-less].\n+But we can make it nest-less by using [let chains], [like this][nest-less].\n \n [`E-medium`] issues are generally pretty easy too, though it's recommended you work on an [`good-first-issue`]\n first. Sometimes they are only somewhat involved code wise, but not difficult per-se.\n@@ -87,9 +87,9 @@ an AST expression). `match_def_path()` in Clippy's `utils` module can also be us\n [`E-medium`]: https://github.com/rust-lang/rust-clippy/labels/E-medium\n [`ty`]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty\n [nodes in the AST docs]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/ast/\n-[deep-nesting]: https://github.com/rust-lang/rust-clippy/blob/557f6848bd5b7183f55c1e1522a326e9e1df6030/clippy_lints/src/mem_forget.rs#L29-L43\n-[if_chain]: https://docs.rs/if_chain/*/if_chain\n-[nest-less]: https://github.com/rust-lang/rust-clippy/blob/557f6848bd5b7183f55c1e1522a326e9e1df6030/clippy_lints/src/bit_mask.rs#L124-L150\n+[deep-nesting]: https://github.com/rust-lang/rust-clippy/blob/5e4f0922911536f80d9591180fa604229ac13939/clippy_lints/src/mem_forget.rs#L31-L45\n+[let chains]: https://github.com/rust-lang/rust/pull/94927\n+[nest-less]: https://github.com/rust-lang/rust-clippy/blob/5e4f0922911536f80d9591180fa604229ac13939/clippy_lints/src/bit_mask.rs#L133-L159\n \n ## Writing code\n "}, {"sha": "d23d681df00c1d9ac45a125ae406a8f88008cedb", "filename": "Cargo.toml", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.1.60\"\n+version = \"0.1.63\"\n description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n repository = \"https://github.com/rust-lang/rust-clippy\"\n readme = \"README.md\"\n@@ -21,14 +21,14 @@ name = \"clippy-driver\"\n path = \"src/driver.rs\"\n \n [dependencies]\n-clippy_lints = { version = \"0.1\", path = \"clippy_lints\" }\n+clippy_lints = { path = \"clippy_lints\" }\n semver = \"1.0\"\n-rustc_tools_util = { version = \"0.2\", path = \"rustc_tools_util\" }\n+rustc_tools_util = { path = \"rustc_tools_util\" }\n tempfile = { version = \"3.2\", optional = true }\n+termize = \"0.1\"\n \n [dev-dependencies]\n-cargo_metadata = \"0.14\"\n-compiletest_rs = { version = \"0.7.1\", features = [\"tmp\"] }\n+compiletest_rs = { version = \"0.8\", features = [\"tmp\"] }\n tester = \"0.9\"\n regex = \"1.5\"\n # This is used by the `collect-metadata` alias.\n@@ -40,16 +40,18 @@ filetime = \"0.2\"\n rustc-workspace-hack = \"1.0\"\n \n # UI test dependencies\n+clap = { version = \"3.1\", features = [\"derive\"] }\n clippy_utils = { path = \"clippy_utils\" }\n derive-new = \"0.5\"\n if_chain = \"1.0\"\n-itertools = \"0.10\"\n+itertools = \"0.10.1\"\n quote = \"1.0\"\n-serde = { version = \"1.0\", features = [\"derive\"] }\n+serde = { version = \"1.0.125\", features = [\"derive\"] }\n syn = { version = \"1.0\", features = [\"full\"] }\n futures = \"0.3\"\n-parking_lot = \"0.11.2\"\n+parking_lot = \"0.12\"\n tokio = { version = \"1\", features = [\"io-util\"] }\n+rustc-semver = \"1.1\"\n \n [build-dependencies]\n rustc_tools_util = { version = \"0.2\", path = \"rustc_tools_util\" }"}, {"sha": "b0d470a2124d86be497b1e46b7a959de4a0ef69b", "filename": "clippy_dev/Cargo.toml", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_dev%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_dev%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2FCargo.toml?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -4,15 +4,18 @@ version = \"0.0.1\"\n edition = \"2021\"\n \n [dependencies]\n-bytecount = \"0.6\"\n-clap = \"2.33\"\n+aho-corasick = \"0.7\"\n+clap = \"3.1\"\n indoc = \"1.0\"\n-itertools = \"0.10\"\n+itertools = \"0.10.1\"\n opener = \"0.5\"\n-regex = \"1.5\"\n shell-escape = \"0.1\"\n+tempfile = \"3.2\"\n walkdir = \"2.3\"\n-cargo_metadata = \"0.14\"\n \n [features]\n deny-warnings = []\n+\n+[package.metadata.rust-analyzer]\n+# This package uses #[feature(rustc_private)]\n+rustc_private = true"}, {"sha": "8e5c739afe05ae85e3a00cee769678233806b5ba", "filename": "clippy_dev/src/bless.rs", "status": "modified", "additions": 21, "deletions": 57, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_dev%2Fsrc%2Fbless.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_dev%2Fsrc%2Fbless.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fbless.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,66 +1,39 @@\n //! `bless` updates the reference files in the repo with changed output files\n //! from the last test run.\n \n+use crate::cargo_clippy_path;\n use std::ffi::OsStr;\n use std::fs;\n use std::lazy::SyncLazy;\n use std::path::{Path, PathBuf};\n-use walkdir::WalkDir;\n+use walkdir::{DirEntry, WalkDir};\n \n-use crate::clippy_project_root;\n-\n-#[cfg(not(windows))]\n-static CARGO_CLIPPY_EXE: &str = \"cargo-clippy\";\n-#[cfg(windows)]\n-static CARGO_CLIPPY_EXE: &str = \"cargo-clippy.exe\";\n-\n-static CLIPPY_BUILD_TIME: SyncLazy<Option<std::time::SystemTime>> = SyncLazy::new(|| {\n-    let mut path = std::env::current_exe().unwrap();\n-    path.set_file_name(CARGO_CLIPPY_EXE);\n-    fs::metadata(path).ok()?.modified().ok()\n-});\n+static CLIPPY_BUILD_TIME: SyncLazy<Option<std::time::SystemTime>> =\n+    SyncLazy::new(|| cargo_clippy_path().metadata().ok()?.modified().ok());\n \n /// # Panics\n ///\n /// Panics if the path to a test file is broken\n pub fn bless(ignore_timestamp: bool) {\n-    let test_suite_dirs = [\n-        clippy_project_root().join(\"tests\").join(\"ui\"),\n-        clippy_project_root().join(\"tests\").join(\"ui-internal\"),\n-        clippy_project_root().join(\"tests\").join(\"ui-toml\"),\n-        clippy_project_root().join(\"tests\").join(\"ui-cargo\"),\n-    ];\n-    for test_suite_dir in &test_suite_dirs {\n-        WalkDir::new(test_suite_dir)\n-            .into_iter()\n-            .filter_map(Result::ok)\n-            .filter(|f| f.path().extension() == Some(OsStr::new(\"rs\")))\n-            .for_each(|f| {\n-                let test_name = f.path().strip_prefix(test_suite_dir).unwrap();\n-                for &ext in &[\"stdout\", \"stderr\", \"fixed\"] {\n-                    let test_name_ext = format!(\"stage-id.{}\", ext);\n-                    update_reference_file(\n-                        f.path().with_extension(ext),\n-                        test_name.with_extension(test_name_ext),\n-                        ignore_timestamp,\n-                    );\n-                }\n-            });\n-    }\n+    let extensions = [\"stdout\", \"stderr\", \"fixed\"].map(OsStr::new);\n+\n+    WalkDir::new(build_dir())\n+        .into_iter()\n+        .map(Result::unwrap)\n+        .filter(|entry| entry.path().extension().map_or(false, |ext| extensions.contains(&ext)))\n+        .for_each(|entry| update_reference_file(&entry, ignore_timestamp));\n }\n \n-fn update_reference_file(reference_file_path: PathBuf, test_name: PathBuf, ignore_timestamp: bool) {\n-    let test_output_path = build_dir().join(test_name);\n-    let relative_reference_file_path = reference_file_path.strip_prefix(clippy_project_root()).unwrap();\n+fn update_reference_file(test_output_entry: &DirEntry, ignore_timestamp: bool) {\n+    let test_output_path = test_output_entry.path();\n \n-    // If compiletest did not write any changes during the test run,\n-    // we don't have to update anything\n-    if !test_output_path.exists() {\n-        return;\n-    }\n+    let reference_file_name = test_output_entry.file_name().to_str().unwrap().replace(\".stage-id\", \"\");\n+    let reference_file_path = Path::new(\"tests\")\n+        .join(test_output_path.strip_prefix(build_dir()).unwrap())\n+        .with_file_name(reference_file_name);\n \n     // If the test output was not updated since the last clippy build, it may be outdated\n-    if !ignore_timestamp && !updated_since_clippy_build(&test_output_path).unwrap_or(true) {\n+    if !ignore_timestamp && !updated_since_clippy_build(test_output_entry).unwrap_or(true) {\n         return;\n     }\n \n@@ -69,23 +42,14 @@ fn update_reference_file(reference_file_path: PathBuf, test_name: PathBuf, ignor\n \n     if test_output_file != reference_file {\n         // If a test run caused an output file to change, update the reference file\n-        println!(\"updating {}\", &relative_reference_file_path.display());\n+        println!(\"updating {}\", reference_file_path.display());\n         fs::copy(test_output_path, &reference_file_path).expect(\"Could not update reference file\");\n-\n-        // We need to re-read the file now because it was potentially updated from copying\n-        let reference_file = fs::read(&reference_file_path).unwrap_or_default();\n-\n-        if reference_file.is_empty() {\n-            // If we copied over an empty output file, we remove the now empty reference file\n-            println!(\"removing {}\", &relative_reference_file_path.display());\n-            fs::remove_file(reference_file_path).expect(\"Could not remove reference file\");\n-        }\n     }\n }\n \n-fn updated_since_clippy_build(path: &Path) -> Option<bool> {\n+fn updated_since_clippy_build(entry: &DirEntry) -> Option<bool> {\n     let clippy_build_time = (*CLIPPY_BUILD_TIME)?;\n-    let modified = fs::metadata(path).ok()?.modified().ok()?;\n+    let modified = entry.metadata().ok()?.modified().ok()?;\n     Some(modified >= clippy_build_time)\n }\n "}, {"sha": "81e807cf10c7c3a489e3a601b569714b160fbf66", "filename": "clippy_dev/src/lib.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_dev%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_dev%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Flib.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,8 +1,13 @@\n+#![feature(let_chains)]\n+#![feature(let_else)]\n #![feature(once_cell)]\n+#![feature(rustc_private)]\n #![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n // warn on lints, that are included in `rust-lang/rust`s bootstrap\n #![warn(rust_2018_idioms, unused_lifetimes)]\n \n+extern crate rustc_lexer;\n+\n use std::path::PathBuf;\n \n pub mod bless;\n@@ -13,6 +18,19 @@ pub mod serve;\n pub mod setup;\n pub mod update_lints;\n \n+#[cfg(not(windows))]\n+static CARGO_CLIPPY_EXE: &str = \"cargo-clippy\";\n+#[cfg(windows)]\n+static CARGO_CLIPPY_EXE: &str = \"cargo-clippy.exe\";\n+\n+/// Returns the path to the `cargo-clippy` binary\n+#[must_use]\n+pub fn cargo_clippy_path() -> PathBuf {\n+    let mut path = std::env::current_exe().expect(\"failed to get current executable name\");\n+    path.set_file_name(CARGO_CLIPPY_EXE);\n+    path\n+}\n+\n /// Returns the path to the Clippy project directory\n ///\n /// # Panics"}, {"sha": "9e463aa741c758d7bdf3023d6eff1b0f4d353ba6", "filename": "clippy_dev/src/lint.rs", "status": "modified", "additions": 51, "deletions": 15, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_dev%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_dev%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Flint.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,19 +1,55 @@\n-use std::process::{self, Command};\n+use crate::cargo_clippy_path;\n+use std::process::{self, Command, ExitStatus};\n+use std::{fs, io};\n \n-pub fn run(filename: &str) {\n-    let code = Command::new(\"cargo\")\n-        .args([\"run\", \"--bin\", \"clippy-driver\", \"--\"])\n-        .args([\"-L\", \"./target/debug\"])\n-        .args([\"-Z\", \"no-codegen\"])\n-        .args([\"--edition\", \"2021\"])\n-        .arg(filename)\n-        .status()\n-        .expect(\"failed to run cargo\")\n-        .code();\n-\n-    if code.is_none() {\n-        eprintln!(\"Killed by signal\");\n+fn exit_if_err(status: io::Result<ExitStatus>) {\n+    match status.expect(\"failed to run command\").code() {\n+        Some(0) => {},\n+        Some(n) => process::exit(n),\n+        None => {\n+            eprintln!(\"Killed by signal\");\n+            process::exit(1);\n+        },\n     }\n+}\n+\n+pub fn run<'a>(path: &str, args: impl Iterator<Item = &'a str>) {\n+    let is_file = match fs::metadata(path) {\n+        Ok(metadata) => metadata.is_file(),\n+        Err(e) => {\n+            eprintln!(\"Failed to read {path}: {e:?}\");\n+            process::exit(1);\n+        },\n+    };\n+\n+    if is_file {\n+        exit_if_err(\n+            Command::new(\"cargo\")\n+                .args([\"run\", \"--bin\", \"clippy-driver\", \"--\"])\n+                .args([\"-L\", \"./target/debug\"])\n+                .args([\"-Z\", \"no-codegen\"])\n+                .args([\"--edition\", \"2021\"])\n+                .arg(path)\n+                .args(args)\n+                .status(),\n+        );\n+    } else {\n+        exit_if_err(Command::new(\"cargo\").arg(\"build\").status());\n \n-    process::exit(code.unwrap_or(1));\n+        // Run in a tempdir as changes to clippy do not retrigger linting\n+        let target = tempfile::Builder::new()\n+            .prefix(\"clippy\")\n+            .tempdir()\n+            .expect(\"failed to create tempdir\");\n+\n+        let status = Command::new(cargo_clippy_path())\n+            .arg(\"clippy\")\n+            .args(args)\n+            .current_dir(path)\n+            .env(\"CARGO_TARGET_DIR\", target.as_ref())\n+            .status();\n+\n+        target.close().expect(\"failed to remove tempdir\");\n+        exit_if_err(status);\n+    }\n }"}, {"sha": "ee535b1d3be8bb17d2a2283539bdc8e102a9c9f4", "filename": "clippy_dev/src/main.rs", "status": "modified", "additions": 158, "deletions": 87, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_dev%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_dev%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fmain.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -2,139 +2,154 @@\n // warn on lints, that are included in `rust-lang/rust`s bootstrap\n #![warn(rust_2018_idioms, unused_lifetimes)]\n \n-use clap::{App, AppSettings, Arg, ArgMatches, SubCommand};\n+use clap::{Arg, ArgMatches, Command};\n use clippy_dev::{bless, fmt, lint, new_lint, serve, setup, update_lints};\n+use indoc::indoc;\n fn main() {\n     let matches = get_clap_config();\n \n     match matches.subcommand() {\n-        (\"bless\", Some(matches)) => {\n+        Some((\"bless\", matches)) => {\n             bless::bless(matches.is_present(\"ignore-timestamp\"));\n         },\n-        (\"fmt\", Some(matches)) => {\n+        Some((\"fmt\", matches)) => {\n             fmt::run(matches.is_present(\"check\"), matches.is_present(\"verbose\"));\n         },\n-        (\"update_lints\", Some(matches)) => {\n+        Some((\"update_lints\", matches)) => {\n             if matches.is_present(\"print-only\") {\n                 update_lints::print_lints();\n             } else if matches.is_present(\"check\") {\n-                update_lints::run(update_lints::UpdateMode::Check);\n+                update_lints::update(update_lints::UpdateMode::Check);\n             } else {\n-                update_lints::run(update_lints::UpdateMode::Change);\n+                update_lints::update(update_lints::UpdateMode::Change);\n             }\n         },\n-        (\"new_lint\", Some(matches)) => {\n+        Some((\"new_lint\", matches)) => {\n             match new_lint::create(\n                 matches.value_of(\"pass\"),\n                 matches.value_of(\"name\"),\n                 matches.value_of(\"category\"),\n                 matches.is_present(\"msrv\"),\n             ) {\n-                Ok(_) => update_lints::run(update_lints::UpdateMode::Change),\n+                Ok(_) => update_lints::update(update_lints::UpdateMode::Change),\n                 Err(e) => eprintln!(\"Unable to create lint: {}\", e),\n             }\n         },\n-        (\"setup\", Some(sub_command)) => match sub_command.subcommand() {\n-            (\"intellij\", Some(matches)) => setup::intellij::setup_rustc_src(\n-                matches\n-                    .value_of(\"rustc-repo-path\")\n-                    .expect(\"this field is mandatory and therefore always valid\"),\n-            ),\n-            (\"git-hook\", Some(matches)) => setup::git_hook::install_hook(matches.is_present(\"force-override\")),\n-            (\"vscode-tasks\", Some(matches)) => setup::vscode::install_tasks(matches.is_present(\"force-override\")),\n+        Some((\"setup\", sub_command)) => match sub_command.subcommand() {\n+            Some((\"intellij\", matches)) => {\n+                if matches.is_present(\"remove\") {\n+                    setup::intellij::remove_rustc_src();\n+                } else {\n+                    setup::intellij::setup_rustc_src(\n+                        matches\n+                            .value_of(\"rustc-repo-path\")\n+                            .expect(\"this field is mandatory and therefore always valid\"),\n+                    );\n+                }\n+            },\n+            Some((\"git-hook\", matches)) => {\n+                if matches.is_present(\"remove\") {\n+                    setup::git_hook::remove_hook();\n+                } else {\n+                    setup::git_hook::install_hook(matches.is_present(\"force-override\"));\n+                }\n+            },\n+            Some((\"vscode-tasks\", matches)) => {\n+                if matches.is_present(\"remove\") {\n+                    setup::vscode::remove_tasks();\n+                } else {\n+                    setup::vscode::install_tasks(matches.is_present(\"force-override\"));\n+                }\n+            },\n             _ => {},\n         },\n-        (\"remove\", Some(sub_command)) => match sub_command.subcommand() {\n-            (\"git-hook\", Some(_)) => setup::git_hook::remove_hook(),\n-            (\"intellij\", Some(_)) => setup::intellij::remove_rustc_src(),\n-            (\"vscode-tasks\", Some(_)) => setup::vscode::remove_tasks(),\n+        Some((\"remove\", sub_command)) => match sub_command.subcommand() {\n+            Some((\"git-hook\", _)) => setup::git_hook::remove_hook(),\n+            Some((\"intellij\", _)) => setup::intellij::remove_rustc_src(),\n+            Some((\"vscode-tasks\", _)) => setup::vscode::remove_tasks(),\n             _ => {},\n         },\n-        (\"serve\", Some(matches)) => {\n+        Some((\"serve\", matches)) => {\n             let port = matches.value_of(\"port\").unwrap().parse().unwrap();\n             let lint = matches.value_of(\"lint\");\n             serve::run(port, lint);\n         },\n-        (\"lint\", Some(matches)) => {\n-            let filename = matches.value_of(\"filename\").unwrap();\n-            lint::run(filename);\n+        Some((\"lint\", matches)) => {\n+            let path = matches.value_of(\"path\").unwrap();\n+            let args = matches.values_of(\"args\").into_iter().flatten();\n+            lint::run(path, args);\n+        },\n+        Some((\"rename_lint\", matches)) => {\n+            let old_name = matches.value_of(\"old_name\").unwrap();\n+            let new_name = matches.value_of(\"new_name\").unwrap_or(old_name);\n+            let uplift = matches.is_present(\"uplift\");\n+            update_lints::rename(old_name, new_name, uplift);\n         },\n         _ => {},\n     }\n }\n \n-fn get_clap_config<'a>() -> ArgMatches<'a> {\n-    App::new(\"Clippy developer tooling\")\n-        .setting(AppSettings::ArgRequiredElseHelp)\n+fn get_clap_config() -> ArgMatches {\n+    Command::new(\"Clippy developer tooling\")\n+        .arg_required_else_help(true)\n         .subcommand(\n-            SubCommand::with_name(\"bless\")\n-                .about(\"bless the test output changes\")\n-                .arg(\n-                    Arg::with_name(\"ignore-timestamp\")\n-                        .long(\"ignore-timestamp\")\n-                        .help(\"Include files updated before clippy was built\"),\n-                ),\n+            Command::new(\"bless\").about(\"bless the test output changes\").arg(\n+                Arg::new(\"ignore-timestamp\")\n+                    .long(\"ignore-timestamp\")\n+                    .help(\"Include files updated before clippy was built\"),\n+            ),\n         )\n         .subcommand(\n-            SubCommand::with_name(\"fmt\")\n+            Command::new(\"fmt\")\n                 .about(\"Run rustfmt on all projects and tests\")\n-                .arg(\n-                    Arg::with_name(\"check\")\n-                        .long(\"check\")\n-                        .help(\"Use the rustfmt --check option\"),\n-                )\n-                .arg(\n-                    Arg::with_name(\"verbose\")\n-                        .short(\"v\")\n-                        .long(\"verbose\")\n-                        .help(\"Echo commands run\"),\n-                ),\n+                .arg(Arg::new(\"check\").long(\"check\").help(\"Use the rustfmt --check option\"))\n+                .arg(Arg::new(\"verbose\").short('v').long(\"verbose\").help(\"Echo commands run\")),\n         )\n         .subcommand(\n-            SubCommand::with_name(\"update_lints\")\n+            Command::new(\"update_lints\")\n                 .about(\"Updates lint registration and information from the source code\")\n                 .long_about(\n                     \"Makes sure that:\\n \\\n                  * the lint count in README.md is correct\\n \\\n                  * the changelog contains markdown link references at the bottom\\n \\\n                  * all lint groups include the correct lints\\n \\\n-                 * lint modules in `clippy_lints/*` are visible in `src/lifb.rs` via `pub mod`\\n \\\n+                 * lint modules in `clippy_lints/*` are visible in `src/lib.rs` via `pub mod`\\n \\\n                  * all lints are registered in the lint store\",\n                 )\n-                .arg(Arg::with_name(\"print-only\").long(\"print-only\").help(\n+                .arg(Arg::new(\"print-only\").long(\"print-only\").help(\n                     \"Print a table of lints to STDOUT. \\\n                  This does not include deprecated and internal lints. \\\n                  (Does not modify any files)\",\n                 ))\n                 .arg(\n-                    Arg::with_name(\"check\")\n+                    Arg::new(\"check\")\n                         .long(\"check\")\n                         .help(\"Checks that `cargo dev update_lints` has been run. Used on CI.\"),\n                 ),\n         )\n         .subcommand(\n-            SubCommand::with_name(\"new_lint\")\n+            Command::new(\"new_lint\")\n                 .about(\"Create new lint and run `cargo dev update_lints`\")\n                 .arg(\n-                    Arg::with_name(\"pass\")\n-                        .short(\"p\")\n+                    Arg::new(\"pass\")\n+                        .short('p')\n                         .long(\"pass\")\n                         .help(\"Specify whether the lint runs during the early or late pass\")\n                         .takes_value(true)\n                         .possible_values(&[\"early\", \"late\"])\n                         .required(true),\n                 )\n                 .arg(\n-                    Arg::with_name(\"name\")\n-                        .short(\"n\")\n+                    Arg::new(\"name\")\n+                        .short('n')\n                         .long(\"name\")\n                         .help(\"Name of the new lint in snake case, ex: fn_too_long\")\n                         .takes_value(true)\n                         .required(true),\n                 )\n                 .arg(\n-                    Arg::with_name(\"category\")\n-                        .short(\"c\")\n+                    Arg::new(\"category\")\n+                        .short('c')\n                         .long(\"category\")\n                         .help(\"What category the lint belongs to\")\n                         .default_value(\"nursery\")\n@@ -153,83 +168,139 @@ fn get_clap_config<'a>() -> ArgMatches<'a> {\n                         ])\n                         .takes_value(true),\n                 )\n-                .arg(\n-                    Arg::with_name(\"msrv\")\n-                        .long(\"msrv\")\n-                        .help(\"Add MSRV config code to the lint\"),\n-                ),\n+                .arg(Arg::new(\"msrv\").long(\"msrv\").help(\"Add MSRV config code to the lint\")),\n         )\n         .subcommand(\n-            SubCommand::with_name(\"setup\")\n+            Command::new(\"setup\")\n                 .about(\"Support for setting up your personal development environment\")\n-                .setting(AppSettings::ArgRequiredElseHelp)\n+                .arg_required_else_help(true)\n                 .subcommand(\n-                    SubCommand::with_name(\"intellij\")\n+                    Command::new(\"intellij\")\n                         .about(\"Alter dependencies so Intellij Rust can find rustc internals\")\n                         .arg(\n-                            Arg::with_name(\"rustc-repo-path\")\n+                            Arg::new(\"remove\")\n+                                .long(\"remove\")\n+                                .help(\"Remove the dependencies added with 'cargo dev setup intellij'\")\n+                                .required(false),\n+                        )\n+                        .arg(\n+                            Arg::new(\"rustc-repo-path\")\n                                 .long(\"repo-path\")\n-                                .short(\"r\")\n+                                .short('r')\n                                 .help(\"The path to a rustc repo that will be used for setting the dependencies\")\n                                 .takes_value(true)\n                                 .value_name(\"path\")\n+                                .conflicts_with(\"remove\")\n                                 .required(true),\n                         ),\n                 )\n                 .subcommand(\n-                    SubCommand::with_name(\"git-hook\")\n+                    Command::new(\"git-hook\")\n                         .about(\"Add a pre-commit git hook that formats your code to make it look pretty\")\n                         .arg(\n-                            Arg::with_name(\"force-override\")\n+                            Arg::new(\"remove\")\n+                                .long(\"remove\")\n+                                .help(\"Remove the pre-commit hook added with 'cargo dev setup git-hook'\")\n+                                .required(false),\n+                        )\n+                        .arg(\n+                            Arg::new(\"force-override\")\n                                 .long(\"force-override\")\n-                                .short(\"f\")\n+                                .short('f')\n                                 .help(\"Forces the override of an existing git pre-commit hook\")\n                                 .required(false),\n                         ),\n                 )\n                 .subcommand(\n-                    SubCommand::with_name(\"vscode-tasks\")\n+                    Command::new(\"vscode-tasks\")\n                         .about(\"Add several tasks to vscode for formatting, validation and testing\")\n                         .arg(\n-                            Arg::with_name(\"force-override\")\n+                            Arg::new(\"remove\")\n+                                .long(\"remove\")\n+                                .help(\"Remove the tasks added with 'cargo dev setup vscode-tasks'\")\n+                                .required(false),\n+                        )\n+                        .arg(\n+                            Arg::new(\"force-override\")\n                                 .long(\"force-override\")\n-                                .short(\"f\")\n+                                .short('f')\n                                 .help(\"Forces the override of existing vscode tasks\")\n                                 .required(false),\n                         ),\n                 ),\n         )\n         .subcommand(\n-            SubCommand::with_name(\"remove\")\n+            Command::new(\"remove\")\n                 .about(\"Support for undoing changes done by the setup command\")\n-                .setting(AppSettings::ArgRequiredElseHelp)\n-                .subcommand(SubCommand::with_name(\"git-hook\").about(\"Remove any existing pre-commit git hook\"))\n-                .subcommand(SubCommand::with_name(\"vscode-tasks\").about(\"Remove any existing vscode tasks\"))\n+                .arg_required_else_help(true)\n+                .subcommand(Command::new(\"git-hook\").about(\"Remove any existing pre-commit git hook\"))\n+                .subcommand(Command::new(\"vscode-tasks\").about(\"Remove any existing vscode tasks\"))\n                 .subcommand(\n-                    SubCommand::with_name(\"intellij\")\n-                        .about(\"Removes rustc source paths added via `cargo dev setup intellij`\"),\n+                    Command::new(\"intellij\").about(\"Removes rustc source paths added via `cargo dev setup intellij`\"),\n                 ),\n         )\n         .subcommand(\n-            SubCommand::with_name(\"serve\")\n+            Command::new(\"serve\")\n                 .about(\"Launch a local 'ALL the Clippy Lints' website in a browser\")\n                 .arg(\n-                    Arg::with_name(\"port\")\n+                    Arg::new(\"port\")\n                         .long(\"port\")\n-                        .short(\"p\")\n+                        .short('p')\n                         .help(\"Local port for the http server\")\n                         .default_value(\"8000\")\n                         .validator_os(serve::validate_port),\n                 )\n-                .arg(Arg::with_name(\"lint\").help(\"Which lint's page to load initially (optional)\")),\n+                .arg(Arg::new(\"lint\").help(\"Which lint's page to load initially (optional)\")),\n+        )\n+        .subcommand(\n+            Command::new(\"lint\")\n+                .about(\"Manually run clippy on a file or package\")\n+                .after_help(indoc! {\"\n+                    EXAMPLES\n+                        Lint a single file:\n+                            cargo dev lint tests/ui/attrs.rs\n+\n+                        Lint a package directory:\n+                            cargo dev lint tests/ui-cargo/wildcard_dependencies/fail\n+                            cargo dev lint ~/my-project\n+\n+                        Run rustfix:\n+                            cargo dev lint ~/my-project -- --fix\n+\n+                        Set lint levels:\n+                            cargo dev lint file.rs -- -W clippy::pedantic\n+                            cargo dev lint ~/my-project -- -- -W clippy::pedantic\n+                \"})\n+                .arg(\n+                    Arg::new(\"path\")\n+                        .required(true)\n+                        .help(\"The path to a file or package directory to lint\"),\n+                )\n+                .arg(\n+                    Arg::new(\"args\")\n+                        .multiple_occurrences(true)\n+                        .help(\"Pass extra arguments to cargo/clippy-driver\"),\n+                ),\n         )\n         .subcommand(\n-            SubCommand::with_name(\"lint\")\n-                .about(\"Manually run clippy on a file\")\n+            Command::new(\"rename_lint\")\n+                .about(\"Renames the given lint\")\n                 .arg(\n-                    Arg::with_name(\"filename\")\n+                    Arg::new(\"old_name\")\n+                        .index(1)\n                         .required(true)\n-                        .help(\"The path to a file to lint\"),\n+                        .help(\"The name of the lint to rename\"),\n+                )\n+                .arg(\n+                    Arg::new(\"new_name\")\n+                        .index(2)\n+                        .required_unless_present(\"uplift\")\n+                        .help(\"The new name of the lint\"),\n+                )\n+                .arg(\n+                    Arg::new(\"uplift\")\n+                        .long(\"uplift\")\n+                        .help(\"This lint will be uplifted into rustc\"),\n                 ),\n         )\n         .get_matches()"}, {"sha": "07d196387887cc84ede7b05f5fef5eb9832e8eed", "filename": "clippy_dev/src/new_lint.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_dev%2Fsrc%2Fnew_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_dev%2Fsrc%2Fnew_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fnew_lint.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,5 +1,6 @@\n use crate::clippy_project_root;\n use indoc::indoc;\n+use std::fmt::Write as _;\n use std::fs::{self, OpenOptions};\n use std::io::prelude::*;\n use std::io::{self, ErrorKind};\n@@ -132,16 +133,24 @@ fn to_camel_case(name: &str) -> String {\n         .collect()\n }\n \n-fn get_stabilisation_version() -> String {\n-    let mut command = cargo_metadata::MetadataCommand::new();\n-    command.no_deps();\n-    if let Ok(metadata) = command.exec() {\n-        if let Some(pkg) = metadata.packages.iter().find(|pkg| pkg.name == \"clippy\") {\n-            return format!(\"{}.{}.0\", pkg.version.minor, pkg.version.patch);\n-        }\n+fn get_stabilization_version() -> String {\n+    fn parse_manifest(contents: &str) -> Option<String> {\n+        let version = contents\n+            .lines()\n+            .filter_map(|l| l.split_once('='))\n+            .find_map(|(k, v)| (k.trim() == \"version\").then(|| v.trim()))?;\n+        let Some((\"0\", version)) = version.get(1..version.len() - 1)?.split_once('.') else {\n+            return None;\n+        };\n+        let (minor, patch) = version.split_once('.')?;\n+        Some(format!(\n+            \"{}.{}.0\",\n+            minor.parse::<u32>().ok()?,\n+            patch.parse::<u32>().ok()?\n+        ))\n     }\n-\n-    String::from(\"<TODO set version(see doc/adding_lints.md)>\")\n+    let contents = fs::read_to_string(\"Cargo.toml\").expect(\"Unable to read `Cargo.toml`\");\n+    parse_manifest(&contents).expect(\"Unable to find package version in `Cargo.toml`\")\n }\n \n fn get_test_file_contents(lint_name: &str, header_commands: Option<&str>) -> String {\n@@ -190,7 +199,7 @@ fn get_lint_file_contents(lint: &LintData<'_>, enable_msrv: bool) -> String {\n         },\n     };\n \n-    let version = get_stabilisation_version();\n+    let version = get_stabilization_version();\n     let lint_name = lint.name;\n     let category = lint.category;\n     let name_camel = to_camel_case(lint.name);\n@@ -224,7 +233,8 @@ fn get_lint_file_contents(lint: &LintData<'_>, enable_msrv: bool) -> String {\n         )\n     });\n \n-    result.push_str(&format!(\n+    let _ = write!(\n+        result,\n         indoc! {r#\"\n             declare_clippy_lint! {{\n                 /// ### What it does\n@@ -248,7 +258,7 @@ fn get_lint_file_contents(lint: &LintData<'_>, enable_msrv: bool) -> String {\n         version = version,\n         name_upper = name_upper,\n         category = category,\n-    ));\n+    );\n \n     result.push_str(&if enable_msrv {\n         format!("}, {"sha": "d55b1a354d003cba512928e27b0b4e4310b7209b", "filename": "clippy_dev/src/serve.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_dev%2Fsrc%2Fserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_dev%2Fsrc%2Fserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fserve.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,4 +1,5 @@\n-use std::ffi::{OsStr, OsString};\n+use std::ffi::OsStr;\n+use std::num::ParseIntError;\n use std::path::Path;\n use std::process::Command;\n use std::thread;\n@@ -59,9 +60,6 @@ fn mtime(path: impl AsRef<Path>) -> SystemTime {\n }\n \n #[allow(clippy::missing_errors_doc)]\n-pub fn validate_port(arg: &OsStr) -> Result<(), OsString> {\n-    match arg.to_string_lossy().parse::<u16>() {\n-        Ok(_port) => Ok(()),\n-        Err(err) => Err(OsString::from(err.to_string())),\n-    }\n+pub fn validate_port(arg: &OsStr) -> Result<(), ParseIntError> {\n+    arg.to_string_lossy().parse::<u16>().map(|_| ())\n }"}, {"sha": "f691ae4fa45da22e67d8700894b2365db3d4fad2", "filename": "clippy_dev/src/setup/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_dev%2Fsrc%2Fsetup%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_dev%2Fsrc%2Fsetup%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fsetup%2Fmod.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -7,7 +7,7 @@ use std::path::Path;\n const CLIPPY_DEV_DIR: &str = \"clippy_dev\";\n \n /// This function verifies that the tool is being executed in the clippy directory.\n-/// This is useful to ensure that setups only modify Clippys resources. The verification\n+/// This is useful to ensure that setups only modify Clippy's resources. The verification\n /// is done by checking that `clippy_dev` is a sub directory of the current directory.\n ///\n /// It will print an error message and return `false` if the directory could not be\n@@ -17,7 +17,7 @@ fn verify_inside_clippy_dir() -> bool {\n     if path.exists() && path.is_dir() {\n         true\n     } else {\n-        eprintln!(\"error: unable to verify that the working directory is clippys directory\");\n+        eprintln!(\"error: unable to verify that the working directory is clippy's directory\");\n         false\n     }\n }"}, {"sha": "5024e63bfa738edcfe7e6f30de8d28eded58d722", "filename": "clippy_dev/src/update_lints.rs", "status": "modified", "additions": 627, "deletions": 385, "changes": 1012, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_dev%2Fsrc%2Fupdate_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_dev%2Fsrc%2Fupdate_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fupdate_lints.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,49 +1,23 @@\n+use aho_corasick::AhoCorasickBuilder;\n+use core::fmt::Write as _;\n use itertools::Itertools;\n-use regex::Regex;\n-use std::collections::HashMap;\n+use rustc_lexer::{tokenize, unescape, LiteralKind, TokenKind};\n+use std::collections::{HashMap, HashSet};\n use std::ffi::OsStr;\n use std::fs;\n-use std::lazy::SyncLazy;\n-use std::path::Path;\n-use walkdir::WalkDir;\n+use std::io::{self, Read as _, Seek as _, Write as _};\n+use std::path::{Path, PathBuf};\n+use walkdir::{DirEntry, WalkDir};\n \n use crate::clippy_project_root;\n \n const GENERATED_FILE_COMMENT: &str = \"// This file was generated by `cargo dev update_lints`.\\n\\\n      // Use that command to update this file and do not edit by hand.\\n\\\n      // Manual edits will be overwritten.\\n\\n\";\n \n-static DEC_CLIPPY_LINT_RE: SyncLazy<Regex> = SyncLazy::new(|| {\n-    Regex::new(\n-        r#\"(?x)\n-    declare_clippy_lint!\\s*[\\{(]\n-    (?:\\s+///.*)*\n-    (?:\\s*\\#\\[clippy::version\\s*=\\s*\"[^\"]*\"\\])?\n-    \\s+pub\\s+(?P<name>[A-Z_][A-Z_0-9]*)\\s*,\\s*\n-    (?P<cat>[a-z_]+)\\s*,\\s*\n-    \"(?P<desc>(?:[^\"\\\\]+|\\\\(?s).(?-s))*)\"\\s*[})]\n-\"#,\n-    )\n-    .unwrap()\n-});\n-\n-static DEC_DEPRECATED_LINT_RE: SyncLazy<Regex> = SyncLazy::new(|| {\n-    Regex::new(\n-        r#\"(?x)\n-    declare_deprecated_lint!\\s*[{(]\\s*\n-    (?:\\s+///.*)*\n-    (?:\\s*\\#\\[clippy::version\\s*=\\s*\"[^\"]*\"\\])?\n-    \\s+pub\\s+(?P<name>[A-Z_][A-Z_0-9]*)\\s*,\\s*\n-    \"(?P<desc>(?:[^\"\\\\]+|\\\\(?s).(?-s))*)\"\\s*[})]\n-\"#,\n-    )\n-    .unwrap()\n-});\n-static NL_ESCAPE_RE: SyncLazy<Regex> = SyncLazy::new(|| Regex::new(r#\"\\\\\\n\\s*\"#).unwrap());\n-\n-static DOCS_LINK: &str = \"https://rust-lang.github.io/rust-clippy/master/index.html\";\n-\n-#[derive(Clone, Copy, PartialEq)]\n+const DOCS_LINK: &str = \"https://rust-lang.github.io/rust-clippy/master/index.html\";\n+\n+#[derive(Clone, Copy, PartialEq, Eq)]\n pub enum UpdateMode {\n     Check,\n     Change,\n@@ -58,62 +32,66 @@ pub enum UpdateMode {\n /// # Panics\n ///\n /// Panics if a file path could not read from or then written to\n-#[allow(clippy::too_many_lines)]\n-pub fn run(update_mode: UpdateMode) {\n-    let lint_list: Vec<Lint> = gather_all().collect();\n+pub fn update(update_mode: UpdateMode) {\n+    let (lints, deprecated_lints, renamed_lints) = gather_all();\n+    generate_lint_files(update_mode, &lints, &deprecated_lints, &renamed_lints);\n+}\n \n-    let internal_lints = Lint::internal_lints(&lint_list);\n-    let deprecated_lints = Lint::deprecated_lints(&lint_list);\n-    let usable_lints = Lint::usable_lints(&lint_list);\n+fn generate_lint_files(\n+    update_mode: UpdateMode,\n+    lints: &[Lint],\n+    deprecated_lints: &[DeprecatedLint],\n+    renamed_lints: &[RenamedLint],\n+) {\n+    let internal_lints = Lint::internal_lints(lints);\n+    let usable_lints = Lint::usable_lints(lints);\n     let mut sorted_usable_lints = usable_lints.clone();\n     sorted_usable_lints.sort_by_key(|lint| lint.name.clone());\n \n-    let usable_lint_count = round_to_fifty(usable_lints.len());\n-\n-    let mut file_change = false;\n-\n-    file_change |= replace_region_in_file(\n+    replace_region_in_file(\n+        update_mode,\n         Path::new(\"README.md\"),\n-        &format!(\n-            r#\"\\[There are over \\d+ lints included in this crate!\\]\\({}\\)\"#,\n-            DOCS_LINK\n-        ),\n-        \"\",\n-        true,\n-        update_mode == UpdateMode::Change,\n-        || {\n-            vec![format!(\n-                \"[There are over {} lints included in this crate!]({})\",\n-                usable_lint_count, DOCS_LINK\n-            )]\n+        \"[There are over \",\n+        \" lints included in this crate!]\",\n+        |res| {\n+            write!(res, \"{}\", round_to_fifty(usable_lints.len())).unwrap();\n         },\n-    )\n-    .changed;\n+    );\n \n-    file_change |= replace_region_in_file(\n+    replace_region_in_file(\n+        update_mode,\n         Path::new(\"CHANGELOG.md\"),\n-        \"<!-- begin autogenerated links to lint list -->\",\n+        \"<!-- begin autogenerated links to lint list -->\\n\",\n         \"<!-- end autogenerated links to lint list -->\",\n-        false,\n-        update_mode == UpdateMode::Change,\n-        || gen_changelog_lint_list(usable_lints.iter().chain(deprecated_lints.iter())),\n-    )\n-    .changed;\n+        |res| {\n+            for lint in usable_lints\n+                .iter()\n+                .map(|l| &*l.name)\n+                .chain(deprecated_lints.iter().map(|l| &*l.name))\n+                .chain(\n+                    renamed_lints\n+                        .iter()\n+                        .map(|l| l.old_name.strip_prefix(\"clippy::\").unwrap_or(&l.old_name)),\n+                )\n+                .sorted()\n+            {\n+                writeln!(res, \"[`{}`]: {}#{}\", lint, DOCS_LINK, lint).unwrap();\n+            }\n+        },\n+    );\n \n     // This has to be in lib.rs, otherwise rustfmt doesn't work\n-    file_change |= replace_region_in_file(\n+    replace_region_in_file(\n+        update_mode,\n         Path::new(\"clippy_lints/src/lib.rs\"),\n-        \"begin lints modules\",\n-        \"end lints modules\",\n-        false,\n-        update_mode == UpdateMode::Change,\n-        || gen_modules_list(usable_lints.iter()),\n-    )\n-    .changed;\n-\n-    if file_change && update_mode == UpdateMode::Check {\n-        exit_with_failure();\n-    }\n+        \"// begin lints modules, do not remove this comment, it\u2019s used in `update_lints`\\n\",\n+        \"// end lints modules, do not remove this comment, it\u2019s used in `update_lints`\",\n+        |res| {\n+            for lint_mod in usable_lints.iter().map(|l| &l.module).unique().sorted() {\n+                writeln!(res, \"mod {};\", lint_mod).unwrap();\n+            }\n+        },\n+    );\n \n     process_file(\n         \"clippy_lints/src/lib.register_lints.rs\",\n@@ -123,7 +101,7 @@ pub fn run(update_mode: UpdateMode) {\n     process_file(\n         \"clippy_lints/src/lib.deprecated.rs\",\n         update_mode,\n-        &gen_deprecated(deprecated_lints.iter()),\n+        &gen_deprecated(deprecated_lints),\n     );\n \n     let all_group_lints = usable_lints.iter().filter(|l| {\n@@ -143,18 +121,21 @@ pub fn run(update_mode: UpdateMode) {\n             &content,\n         );\n     }\n+\n+    let content = gen_deprecated_lints_test(deprecated_lints);\n+    process_file(\"tests/ui/deprecated.rs\", update_mode, &content);\n+\n+    let content = gen_renamed_lints_test(renamed_lints);\n+    process_file(\"tests/ui/rename.rs\", update_mode, &content);\n }\n \n pub fn print_lints() {\n-    let lint_list: Vec<Lint> = gather_all().collect();\n+    let (lint_list, _, _) = gather_all();\n     let usable_lints = Lint::usable_lints(&lint_list);\n     let usable_lint_count = usable_lints.len();\n     let grouped_by_lint_group = Lint::by_lint_group(usable_lints.into_iter());\n \n     for (lint_group, mut lints) in grouped_by_lint_group {\n-        if lint_group == \"Deprecated\" {\n-            continue;\n-        }\n         println!(\"\\n## {}\", lint_group);\n \n         lints.sort_by_key(|l| l.name.clone());\n@@ -167,6 +148,209 @@ pub fn print_lints() {\n     println!(\"there are {} lints\", usable_lint_count);\n }\n \n+/// Runs the `rename_lint` command.\n+///\n+/// This does the following:\n+/// * Adds an entry to `renamed_lints.rs`.\n+/// * Renames all lint attributes to the new name (e.g. `#[allow(clippy::lint_name)]`).\n+/// * Renames the lint struct to the new name.\n+/// * Renames the module containing the lint struct to the new name if it shares a name with the\n+///   lint.\n+///\n+/// # Panics\n+/// Panics for the following conditions:\n+/// * If a file path could not read from or then written to\n+/// * If either lint name has a prefix\n+/// * If `old_name` doesn't name an existing lint.\n+/// * If `old_name` names a deprecated or renamed lint.\n+#[allow(clippy::too_many_lines)]\n+pub fn rename(old_name: &str, new_name: &str, uplift: bool) {\n+    if let Some((prefix, _)) = old_name.split_once(\"::\") {\n+        panic!(\"`{}` should not contain the `{}` prefix\", old_name, prefix);\n+    }\n+    if let Some((prefix, _)) = new_name.split_once(\"::\") {\n+        panic!(\"`{}` should not contain the `{}` prefix\", new_name, prefix);\n+    }\n+\n+    let (mut lints, deprecated_lints, mut renamed_lints) = gather_all();\n+    let mut old_lint_index = None;\n+    let mut found_new_name = false;\n+    for (i, lint) in lints.iter().enumerate() {\n+        if lint.name == old_name {\n+            old_lint_index = Some(i);\n+        } else if lint.name == new_name {\n+            found_new_name = true;\n+        }\n+    }\n+    let old_lint_index = old_lint_index.unwrap_or_else(|| panic!(\"could not find lint `{}`\", old_name));\n+\n+    let lint = RenamedLint {\n+        old_name: format!(\"clippy::{}\", old_name),\n+        new_name: if uplift {\n+            new_name.into()\n+        } else {\n+            format!(\"clippy::{}\", new_name)\n+        },\n+    };\n+\n+    // Renamed lints and deprecated lints shouldn't have been found in the lint list, but check just in\n+    // case.\n+    assert!(\n+        !renamed_lints.iter().any(|l| lint.old_name == l.old_name),\n+        \"`{}` has already been renamed\",\n+        old_name\n+    );\n+    assert!(\n+        !deprecated_lints.iter().any(|l| lint.old_name == l.name),\n+        \"`{}` has already been deprecated\",\n+        old_name\n+    );\n+\n+    // Update all lint level attributes. (`clippy::lint_name`)\n+    for file in WalkDir::new(clippy_project_root())\n+        .into_iter()\n+        .map(Result::unwrap)\n+        .filter(|f| {\n+            let name = f.path().file_name();\n+            let ext = f.path().extension();\n+            (ext == Some(OsStr::new(\"rs\")) || ext == Some(OsStr::new(\"fixed\")))\n+                && name != Some(OsStr::new(\"rename.rs\"))\n+                && name != Some(OsStr::new(\"renamed_lints.rs\"))\n+        })\n+    {\n+        rewrite_file(file.path(), |s| {\n+            replace_ident_like(s, &[(&lint.old_name, &lint.new_name)])\n+        });\n+    }\n+\n+    renamed_lints.push(lint);\n+    renamed_lints.sort_by(|lhs, rhs| {\n+        lhs.new_name\n+            .starts_with(\"clippy::\")\n+            .cmp(&rhs.new_name.starts_with(\"clippy::\"))\n+            .reverse()\n+            .then_with(|| lhs.old_name.cmp(&rhs.old_name))\n+    });\n+\n+    write_file(\n+        Path::new(\"clippy_lints/src/renamed_lints.rs\"),\n+        &gen_renamed_lints_list(&renamed_lints),\n+    );\n+\n+    if uplift {\n+        write_file(Path::new(\"tests/ui/rename.rs\"), &gen_renamed_lints_test(&renamed_lints));\n+        println!(\n+            \"`{}` has be uplifted. All the code inside `clippy_lints` related to it needs to be removed manually.\",\n+            old_name\n+        );\n+    } else if found_new_name {\n+        write_file(Path::new(\"tests/ui/rename.rs\"), &gen_renamed_lints_test(&renamed_lints));\n+        println!(\n+            \"`{}` is already defined. The old linting code inside `clippy_lints` needs to be updated/removed manually.\",\n+            new_name\n+        );\n+    } else {\n+        // Rename the lint struct and source files sharing a name with the lint.\n+        let lint = &mut lints[old_lint_index];\n+        let old_name_upper = old_name.to_uppercase();\n+        let new_name_upper = new_name.to_uppercase();\n+        lint.name = new_name.into();\n+\n+        // Rename test files. only rename `.stderr` and `.fixed` files if the new test name doesn't exist.\n+        if try_rename_file(\n+            Path::new(&format!(\"tests/ui/{}.rs\", old_name)),\n+            Path::new(&format!(\"tests/ui/{}.rs\", new_name)),\n+        ) {\n+            try_rename_file(\n+                Path::new(&format!(\"tests/ui/{}.stderr\", old_name)),\n+                Path::new(&format!(\"tests/ui/{}.stderr\", new_name)),\n+            );\n+            try_rename_file(\n+                Path::new(&format!(\"tests/ui/{}.fixed\", old_name)),\n+                Path::new(&format!(\"tests/ui/{}.fixed\", new_name)),\n+            );\n+        }\n+\n+        // Try to rename the file containing the lint if the file name matches the lint's name.\n+        let replacements;\n+        let replacements = if lint.module == old_name\n+            && try_rename_file(\n+                Path::new(&format!(\"clippy_lints/src/{}.rs\", old_name)),\n+                Path::new(&format!(\"clippy_lints/src/{}.rs\", new_name)),\n+            ) {\n+            // Edit the module name in the lint list. Note there could be multiple lints.\n+            for lint in lints.iter_mut().filter(|l| l.module == old_name) {\n+                lint.module = new_name.into();\n+            }\n+            replacements = [(&*old_name_upper, &*new_name_upper), (old_name, new_name)];\n+            replacements.as_slice()\n+        } else if !lint.module.contains(\"::\")\n+            // Catch cases like `methods/lint_name.rs` where the lint is stored in `methods/mod.rs`\n+            && try_rename_file(\n+                Path::new(&format!(\"clippy_lints/src/{}/{}.rs\", lint.module, old_name)),\n+                Path::new(&format!(\"clippy_lints/src/{}/{}.rs\", lint.module, new_name)),\n+            )\n+        {\n+            // Edit the module name in the lint list. Note there could be multiple lints, or none.\n+            let renamed_mod = format!(\"{}::{}\", lint.module, old_name);\n+            for lint in lints.iter_mut().filter(|l| l.module == renamed_mod) {\n+                lint.module = format!(\"{}::{}\", lint.module, new_name);\n+            }\n+            replacements = [(&*old_name_upper, &*new_name_upper), (old_name, new_name)];\n+            replacements.as_slice()\n+        } else {\n+            replacements = [(&*old_name_upper, &*new_name_upper), (\"\", \"\")];\n+            &replacements[0..1]\n+        };\n+\n+        // Don't change `clippy_utils/src/renamed_lints.rs` here as it would try to edit the lint being\n+        // renamed.\n+        for (_, file) in clippy_lints_src_files().filter(|(rel_path, _)| rel_path != OsStr::new(\"renamed_lints.rs\")) {\n+            rewrite_file(file.path(), |s| replace_ident_like(s, replacements));\n+        }\n+\n+        generate_lint_files(UpdateMode::Change, &lints, &deprecated_lints, &renamed_lints);\n+        println!(\"{} has been successfully renamed\", old_name);\n+    }\n+\n+    println!(\"note: `cargo uitest` still needs to be run to update the test results\");\n+}\n+\n+/// Replace substrings if they aren't bordered by identifier characters. Returns `None` if there\n+/// were no replacements.\n+fn replace_ident_like(contents: &str, replacements: &[(&str, &str)]) -> Option<String> {\n+    fn is_ident_char(c: u8) -> bool {\n+        matches!(c, b'a'..=b'z' | b'A'..=b'Z' | b'0'..=b'9' | b'_')\n+    }\n+\n+    let searcher = AhoCorasickBuilder::new()\n+        .dfa(true)\n+        .match_kind(aho_corasick::MatchKind::LeftmostLongest)\n+        .build_with_size::<u16, _, _>(replacements.iter().map(|&(x, _)| x.as_bytes()))\n+        .unwrap();\n+\n+    let mut result = String::with_capacity(contents.len() + 1024);\n+    let mut pos = 0;\n+    let mut edited = false;\n+    for m in searcher.find_iter(contents) {\n+        let (old, new) = replacements[m.pattern()];\n+        result.push_str(&contents[pos..m.start()]);\n+        result.push_str(\n+            if !is_ident_char(contents.as_bytes().get(m.start().wrapping_sub(1)).copied().unwrap_or(0))\n+                && !is_ident_char(contents.as_bytes().get(m.end()).copied().unwrap_or(0))\n+            {\n+                edited = true;\n+                new\n+            } else {\n+                old\n+            },\n+        );\n+        pos = m.end();\n+    }\n+    result.push_str(&contents[pos..]);\n+    edited.then(|| result)\n+}\n+\n fn round_to_fifty(count: usize) -> usize {\n     count / 50 * 50\n }\n@@ -193,24 +377,22 @@ fn exit_with_failure() {\n }\n \n /// Lint data parsed from the Clippy source code.\n-#[derive(Clone, PartialEq, Debug)]\n+#[derive(Clone, PartialEq, Eq, Debug)]\n struct Lint {\n     name: String,\n     group: String,\n     desc: String,\n-    deprecation: Option<String>,\n     module: String,\n }\n \n impl Lint {\n     #[must_use]\n-    fn new(name: &str, group: &str, desc: &str, deprecation: Option<&str>, module: &str) -> Self {\n+    fn new(name: &str, group: &str, desc: &str, module: &str) -> Self {\n         Self {\n             name: name.to_lowercase(),\n-            group: group.to_string(),\n-            desc: NL_ESCAPE_RE.replace(&desc.replace(\"\\\\\\\"\", \"\\\"\"), \"\").to_string(),\n-            deprecation: deprecation.map(ToString::to_string),\n-            module: module.to_string(),\n+            group: group.into(),\n+            desc: remove_line_splices(desc),\n+            module: module.into(),\n         }\n     }\n \n@@ -219,7 +401,7 @@ impl Lint {\n     fn usable_lints(lints: &[Self]) -> Vec<Self> {\n         lints\n             .iter()\n-            .filter(|l| l.deprecation.is_none() && !l.group.starts_with(\"internal\"))\n+            .filter(|l| !l.group.starts_with(\"internal\"))\n             .cloned()\n             .collect()\n     }\n@@ -230,74 +412,76 @@ impl Lint {\n         lints.iter().filter(|l| l.group == \"internal\").cloned().collect()\n     }\n \n-    /// Returns all deprecated lints\n-    #[must_use]\n-    fn deprecated_lints(lints: &[Self]) -> Vec<Self> {\n-        lints.iter().filter(|l| l.deprecation.is_some()).cloned().collect()\n-    }\n-\n     /// Returns the lints in a `HashMap`, grouped by the different lint groups\n     #[must_use]\n     fn by_lint_group(lints: impl Iterator<Item = Self>) -> HashMap<String, Vec<Self>> {\n         lints.map(|lint| (lint.group.to_string(), lint)).into_group_map()\n     }\n }\n \n+#[derive(Clone, PartialEq, Eq, Debug)]\n+struct DeprecatedLint {\n+    name: String,\n+    reason: String,\n+}\n+impl DeprecatedLint {\n+    fn new(name: &str, reason: &str) -> Self {\n+        Self {\n+            name: name.to_lowercase(),\n+            reason: remove_line_splices(reason),\n+        }\n+    }\n+}\n+\n+struct RenamedLint {\n+    old_name: String,\n+    new_name: String,\n+}\n+impl RenamedLint {\n+    fn new(old_name: &str, new_name: &str) -> Self {\n+        Self {\n+            old_name: remove_line_splices(old_name),\n+            new_name: remove_line_splices(new_name),\n+        }\n+    }\n+}\n+\n /// Generates the code for registering a group\n fn gen_lint_group_list<'a>(group_name: &str, lints: impl Iterator<Item = &'a Lint>) -> String {\n     let mut details: Vec<_> = lints.map(|l| (&l.module, l.name.to_uppercase())).collect();\n     details.sort_unstable();\n \n     let mut output = GENERATED_FILE_COMMENT.to_string();\n \n-    output.push_str(&format!(\n-        \"store.register_group(true, \\\"clippy::{0}\\\", Some(\\\"clippy_{0}\\\"), vec![\\n\",\n+    let _ = writeln!(\n+        output,\n+        \"store.register_group(true, \\\"clippy::{0}\\\", Some(\\\"clippy_{0}\\\"), vec![\",\n         group_name\n-    ));\n+    );\n     for (module, name) in details {\n-        output.push_str(&format!(\"    LintId::of({}::{}),\\n\", module, name));\n+        let _ = writeln!(output, \"    LintId::of({}::{}),\", module, name);\n     }\n     output.push_str(\"])\\n\");\n \n     output\n }\n \n-/// Generates the module declarations for `lints`\n-#[must_use]\n-fn gen_modules_list<'a>(lints: impl Iterator<Item = &'a Lint>) -> Vec<String> {\n-    lints\n-        .map(|l| &l.module)\n-        .unique()\n-        .map(|module| format!(\"mod {};\", module))\n-        .sorted()\n-        .collect::<Vec<String>>()\n-}\n-\n-/// Generates the list of lint links at the bottom of the CHANGELOG\n-#[must_use]\n-fn gen_changelog_lint_list<'a>(lints: impl Iterator<Item = &'a Lint>) -> Vec<String> {\n-    lints\n-        .sorted_by_key(|l| &l.name)\n-        .map(|l| format!(\"[`{}`]: {}#{}\", l.name, DOCS_LINK, l.name))\n-        .collect()\n-}\n-\n /// Generates the `register_removed` code\n #[must_use]\n-fn gen_deprecated<'a>(lints: impl Iterator<Item = &'a Lint>) -> String {\n+fn gen_deprecated(lints: &[DeprecatedLint]) -> String {\n     let mut output = GENERATED_FILE_COMMENT.to_string();\n     output.push_str(\"{\\n\");\n-    for Lint { name, deprecation, .. } in lints {\n-        output.push_str(&format!(\n+    for lint in lints {\n+        let _ = write!(\n+            output,\n             concat!(\n                 \"    store.register_removed(\\n\",\n                 \"        \\\"clippy::{}\\\",\\n\",\n                 \"        \\\"{}\\\",\\n\",\n                 \"    );\\n\"\n             ),\n-            name,\n-            deprecation.as_ref().expect(\"`lints` are deprecated\")\n-        ));\n+            lint.name, lint.reason,\n+        );\n     }\n     output.push_str(\"}\\n\");\n \n@@ -323,68 +507,207 @@ fn gen_register_lint_list<'a>(\n         if !is_public {\n             output.push_str(\"    #[cfg(feature = \\\"internal\\\")]\\n\");\n         }\n-        output.push_str(&format!(\"    {}::{},\\n\", module_name, lint_name));\n+        let _ = writeln!(output, \"    {}::{},\", module_name, lint_name);\n     }\n     output.push_str(\"])\\n\");\n \n     output\n }\n \n-/// Gathers all files in `src/clippy_lints` and gathers all lints inside\n-fn gather_all() -> impl Iterator<Item = Lint> {\n-    lint_files().flat_map(|f| gather_from_file(&f))\n+fn gen_deprecated_lints_test(lints: &[DeprecatedLint]) -> String {\n+    let mut res: String = GENERATED_FILE_COMMENT.into();\n+    for lint in lints {\n+        writeln!(res, \"#![warn(clippy::{})]\", lint.name).unwrap();\n+    }\n+    res.push_str(\"\\nfn main() {}\\n\");\n+    res\n }\n \n-fn gather_from_file(dir_entry: &walkdir::DirEntry) -> impl Iterator<Item = Lint> {\n-    let content = fs::read_to_string(dir_entry.path()).unwrap();\n-    let path = dir_entry.path();\n-    let filename = path.file_stem().unwrap();\n-    let path_buf = path.with_file_name(filename);\n-    let mut rel_path = path_buf\n-        .strip_prefix(clippy_project_root().join(\"clippy_lints/src\"))\n-        .expect(\"only files in `clippy_lints/src` should be looked at\");\n-    // If the lints are stored in mod.rs, we get the module name from\n-    // the containing directory:\n-    if filename == \"mod\" {\n-        rel_path = rel_path.parent().unwrap();\n+fn gen_renamed_lints_test(lints: &[RenamedLint]) -> String {\n+    let mut seen_lints = HashSet::new();\n+    let mut res: String = GENERATED_FILE_COMMENT.into();\n+    res.push_str(\"// run-rustfix\\n\\n\");\n+    for lint in lints {\n+        if seen_lints.insert(&lint.new_name) {\n+            writeln!(res, \"#![allow({})]\", lint.new_name).unwrap();\n+        }\n+    }\n+    seen_lints.clear();\n+    for lint in lints {\n+        if seen_lints.insert(&lint.old_name) {\n+            writeln!(res, \"#![warn({})]\", lint.old_name).unwrap();\n+        }\n     }\n+    res.push_str(\"\\nfn main() {}\\n\");\n+    res\n+}\n \n-    let module = rel_path\n-        .components()\n-        .map(|c| c.as_os_str().to_str().unwrap())\n-        .collect::<Vec<_>>()\n-        .join(\"::\");\n+fn gen_renamed_lints_list(lints: &[RenamedLint]) -> String {\n+    const HEADER: &str = \"\\\n+        // This file is managed by `cargo dev rename_lint`. Prefer using that when possible.\\n\\n\\\n+        #[rustfmt::skip]\\n\\\n+        pub static RENAMED_LINTS: &[(&str, &str)] = &[\\n\";\n \n-    parse_contents(&content, &module)\n+    let mut res = String::from(HEADER);\n+    for lint in lints {\n+        writeln!(res, \"    (\\\"{}\\\", \\\"{}\\\"),\", lint.old_name, lint.new_name).unwrap();\n+    }\n+    res.push_str(\"];\\n\");\n+    res\n }\n \n-fn parse_contents(content: &str, module: &str) -> impl Iterator<Item = Lint> {\n-    let lints = DEC_CLIPPY_LINT_RE\n-        .captures_iter(content)\n-        .map(|m| Lint::new(&m[\"name\"], &m[\"cat\"], &m[\"desc\"], None, module));\n-    let deprecated = DEC_DEPRECATED_LINT_RE\n-        .captures_iter(content)\n-        .map(|m| Lint::new(&m[\"name\"], \"Deprecated\", &m[\"desc\"], Some(&m[\"desc\"]), module));\n-    // Removing the `.collect::<Vec<Lint>>().into_iter()` causes some lifetime issues due to the map\n-    lints.chain(deprecated).collect::<Vec<Lint>>().into_iter()\n+/// Gathers all lints defined in `clippy_lints/src`\n+fn gather_all() -> (Vec<Lint>, Vec<DeprecatedLint>, Vec<RenamedLint>) {\n+    let mut lints = Vec::with_capacity(1000);\n+    let mut deprecated_lints = Vec::with_capacity(50);\n+    let mut renamed_lints = Vec::with_capacity(50);\n+\n+    for (rel_path, file) in clippy_lints_src_files() {\n+        let path = file.path();\n+        let contents =\n+            fs::read_to_string(path).unwrap_or_else(|e| panic!(\"Cannot read from `{}`: {}\", path.display(), e));\n+        let module = rel_path\n+            .components()\n+            .map(|c| c.as_os_str().to_str().unwrap())\n+            .collect::<Vec<_>>()\n+            .join(\"::\");\n+\n+        // If the lints are stored in mod.rs, we get the module name from\n+        // the containing directory:\n+        let module = if let Some(module) = module.strip_suffix(\"::mod.rs\") {\n+            module\n+        } else {\n+            module.strip_suffix(\".rs\").unwrap_or(&module)\n+        };\n+\n+        match module {\n+            \"deprecated_lints\" => parse_deprecated_contents(&contents, &mut deprecated_lints),\n+            \"renamed_lints\" => parse_renamed_contents(&contents, &mut renamed_lints),\n+            _ => parse_contents(&contents, module, &mut lints),\n+        }\n+    }\n+    (lints, deprecated_lints, renamed_lints)\n }\n \n-/// Collects all .rs files in the `clippy_lints/src` directory\n-fn lint_files() -> impl Iterator<Item = walkdir::DirEntry> {\n-    // We use `WalkDir` instead of `fs::read_dir` here in order to recurse into subdirectories.\n-    // Otherwise we would not collect all the lints, for example in `clippy_lints/src/methods/`.\n-    let path = clippy_project_root().join(\"clippy_lints/src\");\n-    WalkDir::new(path)\n-        .into_iter()\n-        .filter_map(Result::ok)\n+fn clippy_lints_src_files() -> impl Iterator<Item = (PathBuf, DirEntry)> {\n+    let root_path = clippy_project_root().join(\"clippy_lints/src\");\n+    let iter = WalkDir::new(&root_path).into_iter();\n+    iter.map(Result::unwrap)\n         .filter(|f| f.path().extension() == Some(OsStr::new(\"rs\")))\n+        .map(move |f| (f.path().strip_prefix(&root_path).unwrap().to_path_buf(), f))\n+}\n+\n+macro_rules! match_tokens {\n+    ($iter:ident, $($token:ident $({$($fields:tt)*})? $(($capture:ident))?)*) => {\n+         {\n+            $($(let $capture =)? if let Some((TokenKind::$token $({$($fields)*})?, _x)) = $iter.next() {\n+                _x\n+            } else {\n+                continue;\n+            };)*\n+            #[allow(clippy::unused_unit)]\n+            { ($($($capture,)?)*) }\n+        }\n+    }\n+}\n+\n+/// Parse a source file looking for `declare_clippy_lint` macro invocations.\n+fn parse_contents(contents: &str, module: &str, lints: &mut Vec<Lint>) {\n+    let mut offset = 0usize;\n+    let mut iter = tokenize(contents).map(|t| {\n+        let range = offset..offset + t.len;\n+        offset = range.end;\n+        (t.kind, &contents[range])\n+    });\n+\n+    while iter.any(|(kind, s)| kind == TokenKind::Ident && s == \"declare_clippy_lint\") {\n+        let mut iter = iter\n+            .by_ref()\n+            .filter(|&(kind, _)| !matches!(kind, TokenKind::Whitespace | TokenKind::LineComment { .. }));\n+        // matches `!{`\n+        match_tokens!(iter, Bang OpenBrace);\n+        match iter.next() {\n+            // #[clippy::version = \"version\"] pub\n+            Some((TokenKind::Pound, _)) => {\n+                match_tokens!(iter, OpenBracket Ident Colon Colon Ident Eq Literal{..} CloseBracket Ident);\n+            },\n+            // pub\n+            Some((TokenKind::Ident, _)) => (),\n+            _ => continue,\n+        }\n+        let (name, group, desc) = match_tokens!(\n+            iter,\n+            // LINT_NAME\n+            Ident(name) Comma\n+            // group,\n+            Ident(group) Comma\n+            // \"description\" }\n+            Literal{..}(desc) CloseBrace\n+        );\n+        lints.push(Lint::new(name, group, desc, module));\n+    }\n+}\n+\n+/// Parse a source file looking for `declare_deprecated_lint` macro invocations.\n+fn parse_deprecated_contents(contents: &str, lints: &mut Vec<DeprecatedLint>) {\n+    let mut offset = 0usize;\n+    let mut iter = tokenize(contents).map(|t| {\n+        let range = offset..offset + t.len;\n+        offset = range.end;\n+        (t.kind, &contents[range])\n+    });\n+    while iter.any(|(kind, s)| kind == TokenKind::Ident && s == \"declare_deprecated_lint\") {\n+        let mut iter = iter\n+            .by_ref()\n+            .filter(|&(kind, _)| !matches!(kind, TokenKind::Whitespace | TokenKind::LineComment { .. }));\n+        let (name, reason) = match_tokens!(\n+            iter,\n+            // !{\n+            Bang OpenBrace\n+            // #[clippy::version = \"version\"]\n+            Pound OpenBracket Ident Colon Colon Ident Eq Literal{..} CloseBracket\n+            // pub LINT_NAME,\n+            Ident Ident(name) Comma\n+            // \"description\"\n+            Literal{kind: LiteralKind::Str{..},..}(reason)\n+            // }\n+            CloseBrace\n+        );\n+        lints.push(DeprecatedLint::new(name, reason));\n+    }\n+}\n+\n+fn parse_renamed_contents(contents: &str, lints: &mut Vec<RenamedLint>) {\n+    for line in contents.lines() {\n+        let mut offset = 0usize;\n+        let mut iter = tokenize(line).map(|t| {\n+            let range = offset..offset + t.len;\n+            offset = range.end;\n+            (t.kind, &line[range])\n+        });\n+        let (old_name, new_name) = match_tokens!(\n+            iter,\n+            // (\"old_name\",\n+            Whitespace OpenParen Literal{kind: LiteralKind::Str{..},..}(old_name) Comma\n+            // \"new_name\"),\n+            Whitespace Literal{kind: LiteralKind::Str{..},..}(new_name) CloseParen Comma\n+        );\n+        lints.push(RenamedLint::new(old_name, new_name));\n+    }\n }\n \n-/// Whether a file has had its text changed or not\n-#[derive(PartialEq, Debug)]\n-struct FileChange {\n-    changed: bool,\n-    new_lines: String,\n+/// Removes the line splices and surrounding quotes from a string literal\n+fn remove_line_splices(s: &str) -> String {\n+    let s = s\n+        .strip_prefix('r')\n+        .unwrap_or(s)\n+        .trim_matches('#')\n+        .strip_prefix('\"')\n+        .and_then(|s| s.strip_suffix('\"'))\n+        .unwrap_or_else(|| panic!(\"expected quoted string, found `{}`\", s));\n+    let mut res = String::with_capacity(s.len());\n+    unescape::unescape_literal(s, unescape::Mode::Str, &mut |range, _| res.push_str(&s[range]));\n+    res\n }\n \n /// Replaces a region in a file delimited by two lines matching regexes.\n@@ -396,200 +719,161 @@ struct FileChange {\n /// # Panics\n ///\n /// Panics if the path could not read or then written\n-fn replace_region_in_file<F>(\n+fn replace_region_in_file(\n+    update_mode: UpdateMode,\n     path: &Path,\n     start: &str,\n     end: &str,\n-    replace_start: bool,\n-    write_back: bool,\n-    replacements: F,\n-) -> FileChange\n-where\n-    F: FnOnce() -> Vec<String>,\n-{\n-    let contents = fs::read_to_string(path).unwrap_or_else(|e| panic!(\"Cannot read from {}: {}\", path.display(), e));\n-    let file_change = replace_region_in_text(&contents, start, end, replace_start, replacements);\n-\n-    if write_back {\n-        if let Err(e) = fs::write(path, file_change.new_lines.as_bytes()) {\n-            panic!(\"Cannot write to {}: {}\", path.display(), e);\n-        }\n-    }\n-    file_change\n-}\n-\n-/// Replaces a region in a text delimited by two lines matching regexes.\n-///\n-/// * `text` is the input text on which you want to perform the replacement\n-/// * `start` is a `&str` that describes the delimiter line before the region you want to replace.\n-///   As the `&str` will be converted to a `Regex`, this can contain regex syntax, too.\n-/// * `end` is a `&str` that describes the delimiter line until where the replacement should happen.\n-///   As the `&str` will be converted to a `Regex`, this can contain regex syntax, too.\n-/// * If `replace_start` is true, the `start` delimiter line is replaced as well. The `end`\n-///   delimiter line is never replaced.\n-/// * `replacements` is a closure that has to return a `Vec<String>` which contains the new text.\n-///\n-/// If you want to perform the replacement on files instead of already parsed text,\n-/// use `replace_region_in_file`.\n-///\n-/// # Example\n-///\n-/// ```ignore\n-/// let the_text = \"replace_start\\nsome text\\nthat will be replaced\\nreplace_end\";\n-/// let result =\n-///     replace_region_in_text(the_text, \"replace_start\", \"replace_end\", false, || {\n-///         vec![\"a different\".to_string(), \"text\".to_string()]\n-///     })\n-///     .new_lines;\n-/// assert_eq!(\"replace_start\\na different\\ntext\\nreplace_end\", result);\n-/// ```\n-///\n-/// # Panics\n-///\n-/// Panics if start or end is not valid regex\n-fn replace_region_in_text<F>(text: &str, start: &str, end: &str, replace_start: bool, replacements: F) -> FileChange\n-where\n-    F: FnOnce() -> Vec<String>,\n-{\n-    let replace_it = replacements();\n-    let mut in_old_region = false;\n-    let mut found = false;\n-    let mut new_lines = vec![];\n-    let start = Regex::new(start).unwrap();\n-    let end = Regex::new(end).unwrap();\n-\n-    for line in text.lines() {\n-        if in_old_region {\n-            if end.is_match(line) {\n-                in_old_region = false;\n-                new_lines.extend(replace_it.clone());\n-                new_lines.push(line.to_string());\n-            }\n-        } else if start.is_match(line) {\n-            if !replace_start {\n-                new_lines.push(line.to_string());\n+    write_replacement: impl FnMut(&mut String),\n+) {\n+    let contents = fs::read_to_string(path).unwrap_or_else(|e| panic!(\"Cannot read from `{}`: {}\", path.display(), e));\n+    let new_contents = match replace_region_in_text(&contents, start, end, write_replacement) {\n+        Ok(x) => x,\n+        Err(delim) => panic!(\"Couldn't find `{}` in file `{}`\", delim, path.display()),\n+    };\n+\n+    match update_mode {\n+        UpdateMode::Check if contents != new_contents => exit_with_failure(),\n+        UpdateMode::Check => (),\n+        UpdateMode::Change => {\n+            if let Err(e) = fs::write(path, new_contents.as_bytes()) {\n+                panic!(\"Cannot write to `{}`: {}\", path.display(), e);\n             }\n-            in_old_region = true;\n-            found = true;\n-        } else {\n-            new_lines.push(line.to_string());\n-        }\n-    }\n-\n-    if !found {\n-        // This happens if the provided regex in `clippy_dev/src/main.rs` does not match in the\n-        // given text or file. Most likely this is an error on the programmer's side and the Regex\n-        // is incorrect.\n-        eprintln!(\"error: regex \\n{:?}\\ndoesn't match. You may have to update it.\", start);\n-        std::process::exit(1);\n+        },\n     }\n+}\n \n-    let mut new_lines = new_lines.join(\"\\n\");\n-    if text.ends_with('\\n') {\n-        new_lines.push('\\n');\n-    }\n-    let changed = new_lines != text;\n-    FileChange { changed, new_lines }\n+/// Replaces a region in a text delimited by two strings. Returns the new text if both delimiters\n+/// were found, or the missing delimiter if not.\n+fn replace_region_in_text<'a>(\n+    text: &str,\n+    start: &'a str,\n+    end: &'a str,\n+    mut write_replacement: impl FnMut(&mut String),\n+) -> Result<String, &'a str> {\n+    let (text_start, rest) = text.split_once(start).ok_or(start)?;\n+    let (_, text_end) = rest.split_once(end).ok_or(end)?;\n+\n+    let mut res = String::with_capacity(text.len() + 4096);\n+    res.push_str(text_start);\n+    res.push_str(start);\n+    write_replacement(&mut res);\n+    res.push_str(end);\n+    res.push_str(text_end);\n+\n+    Ok(res)\n }\n \n-#[test]\n-fn test_parse_contents() {\n-    let result: Vec<Lint> = parse_contents(\n-        r#\"\n-declare_clippy_lint! {\n-    #[clippy::version = \"Hello Clippy!\"]\n-    pub PTR_ARG,\n-    style,\n-    \"really long \\\n-     text\"\n+fn try_rename_file(old_name: &Path, new_name: &Path) -> bool {\n+    match fs::OpenOptions::new().create_new(true).write(true).open(new_name) {\n+        Ok(file) => drop(file),\n+        Err(e) if matches!(e.kind(), io::ErrorKind::AlreadyExists | io::ErrorKind::NotFound) => return false,\n+        Err(e) => panic_file(e, new_name, \"create\"),\n+    };\n+    match fs::rename(old_name, new_name) {\n+        Ok(()) => true,\n+        Err(e) => {\n+            drop(fs::remove_file(new_name));\n+            if e.kind() == io::ErrorKind::NotFound {\n+                false\n+            } else {\n+                panic_file(e, old_name, \"rename\");\n+            }\n+        },\n+    }\n }\n \n-declare_clippy_lint!{\n-    #[clippy::version = \"Test version\"]\n-    pub DOC_MARKDOWN,\n-    pedantic,\n-    \"single line\"\n+#[allow(clippy::needless_pass_by_value)]\n+fn panic_file(error: io::Error, name: &Path, action: &str) -> ! {\n+    panic!(\"failed to {} file `{}`: {}\", action, name.display(), error)\n }\n \n-/// some doc comment\n-declare_deprecated_lint! {\n-    #[clippy::version = \"I'm a version\"]\n-    pub SHOULD_ASSERT_EQ,\n-    \"`assert!()` will be more flexible with RFC 2011\"\n+fn rewrite_file(path: &Path, f: impl FnOnce(&str) -> Option<String>) {\n+    let mut file = fs::OpenOptions::new()\n+        .write(true)\n+        .read(true)\n+        .open(path)\n+        .unwrap_or_else(|e| panic_file(e, path, \"open\"));\n+    let mut buf = String::new();\n+    file.read_to_string(&mut buf)\n+        .unwrap_or_else(|e| panic_file(e, path, \"read\"));\n+    if let Some(new_contents) = f(&buf) {\n+        file.rewind().unwrap_or_else(|e| panic_file(e, path, \"write\"));\n+        file.write_all(new_contents.as_bytes())\n+            .unwrap_or_else(|e| panic_file(e, path, \"write\"));\n+        file.set_len(new_contents.len() as u64)\n+            .unwrap_or_else(|e| panic_file(e, path, \"write\"));\n+    }\n }\n-    \"#,\n-        \"module_name\",\n-    )\n-    .collect();\n \n-    let expected = vec![\n-        Lint::new(\"ptr_arg\", \"style\", \"really long text\", None, \"module_name\"),\n-        Lint::new(\"doc_markdown\", \"pedantic\", \"single line\", None, \"module_name\"),\n-        Lint::new(\n-            \"should_assert_eq\",\n-            \"Deprecated\",\n-            \"`assert!()` will be more flexible with RFC 2011\",\n-            Some(\"`assert!()` will be more flexible with RFC 2011\"),\n-            \"module_name\",\n-        ),\n-    ];\n-    assert_eq!(expected, result);\n+fn write_file(path: &Path, contents: &str) {\n+    fs::write(path, contents).unwrap_or_else(|e| panic_file(e, path, \"write\"));\n }\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n \n     #[test]\n-    fn test_replace_region() {\n-        let text = \"\\nabc\\n123\\n789\\ndef\\nghi\";\n-        let expected = FileChange {\n-            changed: true,\n-            new_lines: \"\\nabc\\nhello world\\ndef\\nghi\".to_string(),\n-        };\n-        let result = replace_region_in_text(text, r#\"^\\s*abc$\"#, r#\"^\\s*def\"#, false, || {\n-            vec![\"hello world\".to_string()]\n-        });\n-        assert_eq!(expected, result);\n-    }\n+    fn test_parse_contents() {\n+        static CONTENTS: &str = r#\"\n+            declare_clippy_lint! {\n+                #[clippy::version = \"Hello Clippy!\"]\n+                pub PTR_ARG,\n+                style,\n+                \"really long \\\n+                text\"\n+            }\n \n-    #[test]\n-    fn test_replace_region_with_start() {\n-        let text = \"\\nabc\\n123\\n789\\ndef\\nghi\";\n-        let expected = FileChange {\n-            changed: true,\n-            new_lines: \"\\nhello world\\ndef\\nghi\".to_string(),\n-        };\n-        let result = replace_region_in_text(text, r#\"^\\s*abc$\"#, r#\"^\\s*def\"#, true, || {\n-            vec![\"hello world\".to_string()]\n-        });\n+            declare_clippy_lint!{\n+                #[clippy::version = \"Test version\"]\n+                pub DOC_MARKDOWN,\n+                pedantic,\n+                \"single line\"\n+            }\n+        \"#;\n+        let mut result = Vec::new();\n+        parse_contents(CONTENTS, \"module_name\", &mut result);\n+\n+        let expected = vec![\n+            Lint::new(\"ptr_arg\", \"style\", \"\\\"really long text\\\"\", \"module_name\"),\n+            Lint::new(\"doc_markdown\", \"pedantic\", \"\\\"single line\\\"\", \"module_name\"),\n+        ];\n         assert_eq!(expected, result);\n     }\n \n     #[test]\n-    fn test_replace_region_no_changes() {\n-        let text = \"123\\n456\\n789\";\n-        let expected = FileChange {\n-            changed: false,\n-            new_lines: \"123\\n456\\n789\".to_string(),\n-        };\n-        let result = replace_region_in_text(text, r#\"^\\s*123$\"#, r#\"^\\s*456\"#, false, Vec::new);\n+    fn test_parse_deprecated_contents() {\n+        static DEPRECATED_CONTENTS: &str = r#\"\n+            /// some doc comment\n+            declare_deprecated_lint! {\n+                #[clippy::version = \"I'm a version\"]\n+                pub SHOULD_ASSERT_EQ,\n+                \"`assert!()` will be more flexible with RFC 2011\"\n+            }\n+        \"#;\n+\n+        let mut result = Vec::new();\n+        parse_deprecated_contents(DEPRECATED_CONTENTS, &mut result);\n+\n+        let expected = vec![DeprecatedLint::new(\n+            \"should_assert_eq\",\n+            \"\\\"`assert!()` will be more flexible with RFC 2011\\\"\",\n+        )];\n         assert_eq!(expected, result);\n     }\n \n     #[test]\n     fn test_usable_lints() {\n         let lints = vec![\n-            Lint::new(\"should_assert_eq\", \"Deprecated\", \"abc\", Some(\"Reason\"), \"module_name\"),\n-            Lint::new(\"should_assert_eq2\", \"Not Deprecated\", \"abc\", None, \"module_name\"),\n-            Lint::new(\"should_assert_eq2\", \"internal\", \"abc\", None, \"module_name\"),\n-            Lint::new(\"should_assert_eq2\", \"internal_style\", \"abc\", None, \"module_name\"),\n+            Lint::new(\"should_assert_eq2\", \"Not Deprecated\", \"\\\"abc\\\"\", \"module_name\"),\n+            Lint::new(\"should_assert_eq2\", \"internal\", \"\\\"abc\\\"\", \"module_name\"),\n+            Lint::new(\"should_assert_eq2\", \"internal_style\", \"\\\"abc\\\"\", \"module_name\"),\n         ];\n         let expected = vec![Lint::new(\n             \"should_assert_eq2\",\n             \"Not Deprecated\",\n-            \"abc\",\n-            None,\n+            \"\\\"abc\\\"\",\n             \"module_name\",\n         )];\n         assert_eq!(expected, Lint::usable_lints(&lints));\n@@ -598,55 +882,30 @@ mod tests {\n     #[test]\n     fn test_by_lint_group() {\n         let lints = vec![\n-            Lint::new(\"should_assert_eq\", \"group1\", \"abc\", None, \"module_name\"),\n-            Lint::new(\"should_assert_eq2\", \"group2\", \"abc\", None, \"module_name\"),\n-            Lint::new(\"incorrect_match\", \"group1\", \"abc\", None, \"module_name\"),\n+            Lint::new(\"should_assert_eq\", \"group1\", \"\\\"abc\\\"\", \"module_name\"),\n+            Lint::new(\"should_assert_eq2\", \"group2\", \"\\\"abc\\\"\", \"module_name\"),\n+            Lint::new(\"incorrect_match\", \"group1\", \"\\\"abc\\\"\", \"module_name\"),\n         ];\n         let mut expected: HashMap<String, Vec<Lint>> = HashMap::new();\n         expected.insert(\n             \"group1\".to_string(),\n             vec![\n-                Lint::new(\"should_assert_eq\", \"group1\", \"abc\", None, \"module_name\"),\n-                Lint::new(\"incorrect_match\", \"group1\", \"abc\", None, \"module_name\"),\n+                Lint::new(\"should_assert_eq\", \"group1\", \"\\\"abc\\\"\", \"module_name\"),\n+                Lint::new(\"incorrect_match\", \"group1\", \"\\\"abc\\\"\", \"module_name\"),\n             ],\n         );\n         expected.insert(\n             \"group2\".to_string(),\n-            vec![Lint::new(\"should_assert_eq2\", \"group2\", \"abc\", None, \"module_name\")],\n+            vec![Lint::new(\"should_assert_eq2\", \"group2\", \"\\\"abc\\\"\", \"module_name\")],\n         );\n         assert_eq!(expected, Lint::by_lint_group(lints.into_iter()));\n     }\n \n-    #[test]\n-    fn test_gen_changelog_lint_list() {\n-        let lints = vec![\n-            Lint::new(\"should_assert_eq\", \"group1\", \"abc\", None, \"module_name\"),\n-            Lint::new(\"should_assert_eq2\", \"group2\", \"abc\", None, \"module_name\"),\n-        ];\n-        let expected = vec![\n-            format!(\"[`should_assert_eq`]: {}#should_assert_eq\", DOCS_LINK),\n-            format!(\"[`should_assert_eq2`]: {}#should_assert_eq2\", DOCS_LINK),\n-        ];\n-        assert_eq!(expected, gen_changelog_lint_list(lints.iter()));\n-    }\n-\n     #[test]\n     fn test_gen_deprecated() {\n         let lints = vec![\n-            Lint::new(\n-                \"should_assert_eq\",\n-                \"group1\",\n-                \"abc\",\n-                Some(\"has been superseded by should_assert_eq2\"),\n-                \"module_name\",\n-            ),\n-            Lint::new(\n-                \"another_deprecated\",\n-                \"group2\",\n-                \"abc\",\n-                Some(\"will be removed\"),\n-                \"module_name\",\n-            ),\n+            DeprecatedLint::new(\"should_assert_eq\", \"\\\"has been superseded by should_assert_eq2\\\"\"),\n+            DeprecatedLint::new(\"another_deprecated\", \"\\\"will be removed\\\"\"),\n         ];\n \n         let expected = GENERATED_FILE_COMMENT.to_string()\n@@ -665,32 +924,15 @@ mod tests {\n             .join(\"\\n\")\n             + \"\\n\";\n \n-        assert_eq!(expected, gen_deprecated(lints.iter()));\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_gen_deprecated_fail() {\n-        let lints = vec![Lint::new(\"should_assert_eq2\", \"group2\", \"abc\", None, \"module_name\")];\n-        let _deprecated_lints = gen_deprecated(lints.iter());\n-    }\n-\n-    #[test]\n-    fn test_gen_modules_list() {\n-        let lints = vec![\n-            Lint::new(\"should_assert_eq\", \"group1\", \"abc\", None, \"module_name\"),\n-            Lint::new(\"incorrect_stuff\", \"group3\", \"abc\", None, \"another_module\"),\n-        ];\n-        let expected = vec![\"mod another_module;\".to_string(), \"mod module_name;\".to_string()];\n-        assert_eq!(expected, gen_modules_list(lints.iter()));\n+        assert_eq!(expected, gen_deprecated(&lints));\n     }\n \n     #[test]\n     fn test_gen_lint_group_list() {\n         let lints = vec![\n-            Lint::new(\"abc\", \"group1\", \"abc\", None, \"module_name\"),\n-            Lint::new(\"should_assert_eq\", \"group1\", \"abc\", None, \"module_name\"),\n-            Lint::new(\"internal\", \"internal_style\", \"abc\", None, \"module_name\"),\n+            Lint::new(\"abc\", \"group1\", \"\\\"abc\\\"\", \"module_name\"),\n+            Lint::new(\"should_assert_eq\", \"group1\", \"\\\"abc\\\"\", \"module_name\"),\n+            Lint::new(\"internal\", \"internal_style\", \"\\\"abc\\\"\", \"module_name\"),\n         ];\n         let expected = GENERATED_FILE_COMMENT.to_string()\n             + &["}, {"sha": "0a3f04da35705ccb479bd918d07df089099b5b9a", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy_lints\"\n-version = \"0.1.60\"\n+version = \"0.1.63\"\n description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n repository = \"https://github.com/rust-lang/rust-clippy\"\n readme = \"README.md\"\n@@ -12,7 +12,7 @@ edition = \"2021\"\n cargo_metadata = \"0.14\"\n clippy_utils = { path = \"../clippy_utils\" }\n if_chain = \"1.0\"\n-itertools = \"0.10\"\n+itertools = \"0.10.1\"\n pulldown-cmark = { version = \"0.9\", default-features = false }\n quine-mc_cluskey = \"0.2\"\n regex-syntax = \"0.6\""}, {"sha": "da1b646f4777a006ee434094d0b9c0e113782508", "filename": "clippy_lints/src/approx_const.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fapprox_const.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -87,9 +87,7 @@ impl ApproxConstant {\n         let s = s.as_str();\n         if s.parse::<f64>().is_ok() {\n             for &(constant, name, min_digits, msrv) in &KNOWN_CONSTS {\n-                if is_approx_const(constant, s, min_digits)\n-                    && msrv.as_ref().map_or(true, |msrv| meets_msrv(self.msrv.as_ref(), msrv))\n-                {\n+                if is_approx_const(constant, s, min_digits) && msrv.map_or(true, |msrv| meets_msrv(self.msrv, msrv)) {\n                     span_lint_and_help(\n                         cx,\n                         APPROX_CONSTANT,"}, {"sha": "c5948707c812448d88a8ec9c45eb7c97c31f4bb3", "filename": "clippy_lints/src/arithmetic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farithmetic.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -139,11 +139,11 @@ impl<'tcx> LateLintPass<'tcx> for Arithmetic {\n     }\n \n     fn check_body(&mut self, cx: &LateContext<'_>, body: &hir::Body<'_>) {\n-        let body_owner = cx.tcx.hir().body_owner(body.id());\n+        let body_owner = cx.tcx.hir().body_owner_def_id(body.id());\n \n         match cx.tcx.hir().body_owner_kind(body_owner) {\n             hir::BodyOwnerKind::Static(_) | hir::BodyOwnerKind::Const => {\n-                let body_span = cx.tcx.hir().span(body_owner);\n+                let body_span = cx.tcx.def_span(body_owner);\n \n                 if let Some(span) = self.const_span {\n                     if span.contains(body_span) {"}, {"sha": "4c2d3366483af094b5d5aa539ae5042aabf1b438", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -50,7 +50,7 @@ declare_clippy_lint! {\n     /// ### Known problems\n     /// Clippy cannot know for sure if `a op= a op b` should have\n     /// been `a = a op a op b` or `a = a op b`/`a op= b`. Therefore, it suggests both.\n-    /// If `a op= a op b` is really the correct behaviour it should be\n+    /// If `a op= a op b` is really the correct behavior it should be\n     /// written as `a = a op a op b` as it's less confusing.\n     ///\n     /// ### Example"}, {"sha": "7105ce4b292aee99bc5689db2592a89dd30de130", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 88, "deletions": 25, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -255,7 +255,38 @@ declare_clippy_lint! {\n     \"usage of `cfg(operating_system)` instead of `cfg(target_os = \\\"operating_system\\\")`\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for attributes that allow lints without a reason.\n+    ///\n+    /// (This requires the `lint_reasons` feature)\n+    ///\n+    /// ### Why is this bad?\n+    /// Allowing a lint should always have a reason. This reason should be documented to\n+    /// ensure that others understand the reasoning\n+    ///\n+    /// ### Example\n+    /// Bad:\n+    /// ```rust\n+    /// #![feature(lint_reasons)]\n+    ///\n+    /// #![allow(clippy::some_lint)]\n+    /// ```\n+    ///\n+    /// Good:\n+    /// ```rust\n+    /// #![feature(lint_reasons)]\n+    ///\n+    /// #![allow(clippy::some_lint, reason = \"False positive rust-lang/rust-clippy#1002020\")]\n+    /// ```\n+    #[clippy::version = \"1.61.0\"]\n+    pub ALLOW_ATTRIBUTES_WITHOUT_REASON,\n+    restriction,\n+    \"ensures that all `allow` and `expect` attributes have a reason\"\n+}\n+\n declare_lint_pass!(Attributes => [\n+    ALLOW_ATTRIBUTES_WITHOUT_REASON,\n     INLINE_ALWAYS,\n     DEPRECATED_SEMVER,\n     USELESS_ATTRIBUTE,\n@@ -269,6 +300,9 @@ impl<'tcx> LateLintPass<'tcx> for Attributes {\n                 if is_lint_level(ident.name) {\n                     check_clippy_lint_names(cx, ident.name, items);\n                 }\n+                if matches!(ident.name, sym::allow | sym::expect) {\n+                    check_lint_reason(cx, ident.name, items, attr);\n+                }\n                 if items.is_empty() || !attr.has_name(sym::deprecated) {\n                     return;\n                 }\n@@ -301,20 +335,19 @@ impl<'tcx> LateLintPass<'tcx> for Attributes {\n                     }\n                     if let Some(lint_list) = &attr.meta_item_list() {\n                         if attr.ident().map_or(false, |ident| is_lint_level(ident.name)) {\n-                            // permit `unused_imports`, `deprecated`, `unreachable_pub`,\n-                            // `clippy::wildcard_imports`, and `clippy::enum_glob_use` for `use` items\n-                            // and `unused_imports` for `extern crate` items with `macro_use`\n                             for lint in lint_list {\n                                 match item.kind {\n                                     ItemKind::Use(..) => {\n                                         if is_word(lint, sym!(unused_imports))\n                                             || is_word(lint, sym::deprecated)\n                                             || is_word(lint, sym!(unreachable_pub))\n                                             || is_word(lint, sym!(unused))\n-                                            || extract_clippy_lint(lint)\n-                                                .map_or(false, |s| s.as_str() == \"wildcard_imports\")\n-                                            || extract_clippy_lint(lint)\n-                                                .map_or(false, |s| s.as_str() == \"enum_glob_use\")\n+                                            || extract_clippy_lint(lint).map_or(false, |s| {\n+                                                matches!(\n+                                                    s.as_str(),\n+                                                    \"wildcard_imports\" | \"enum_glob_use\" | \"redundant_pub_crate\",\n+                                                )\n+                                            })\n                                         {\n                                             return;\n                                         }\n@@ -404,6 +437,30 @@ fn check_clippy_lint_names(cx: &LateContext<'_>, name: Symbol, items: &[NestedMe\n     }\n }\n \n+fn check_lint_reason(cx: &LateContext<'_>, name: Symbol, items: &[NestedMetaItem], attr: &'_ Attribute) {\n+    // Check for the feature\n+    if !cx.tcx.sess.features_untracked().lint_reasons {\n+        return;\n+    }\n+\n+    // Check if the reason is present\n+    if let Some(item) = items.last().and_then(NestedMetaItem::meta_item)\n+        && let MetaItemKind::NameValue(_) = &item.kind\n+        && item.path == sym::reason\n+    {\n+        return;\n+    }\n+\n+    span_lint_and_help(\n+        cx,\n+        ALLOW_ATTRIBUTES_WITHOUT_REASON,\n+        attr.span,\n+        &format!(\"`{}` attribute without specifying a reason\", name.as_str()),\n+        None,\n+        \"try adding a reason at the end with `, reason = \\\"..\\\"`\",\n+    );\n+}\n+\n fn is_relevant_item(cx: &LateContext<'_>, item: &Item<'_>) -> bool {\n     if let ItemKind::Fn(_, _, eid) = item.kind {\n         is_relevant_expr(cx, cx.tcx.typeck_body(eid), &cx.tcx.hir().body(eid).value)\n@@ -528,22 +585,21 @@ impl EarlyLintPass for EarlyAttributes {\n }\n \n fn check_empty_line_after_outer_attr(cx: &EarlyContext<'_>, item: &rustc_ast::Item) {\n-    for attr in &item.attrs {\n-        let attr_item = if let AttrKind::Normal(ref attr, _) = attr.kind {\n-            attr\n-        } else {\n-            return;\n-        };\n-\n-        if attr.style == AttrStyle::Outer {\n-            if attr_item.args.inner_tokens().is_empty() || !is_present_in_source(cx, attr.span) {\n-                return;\n-            }\n-\n+    let mut iter = item.attrs.iter().peekable();\n+    while let Some(attr) = iter.next() {\n+        if matches!(attr.kind, AttrKind::Normal(..))\n+            && attr.style == AttrStyle::Outer\n+            && is_present_in_source(cx, attr.span)\n+        {\n             let begin_of_attr_to_item = Span::new(attr.span.lo(), item.span.lo(), item.span.ctxt(), item.span.parent());\n-            let end_of_attr_to_item = Span::new(attr.span.hi(), item.span.lo(), item.span.ctxt(), item.span.parent());\n+            let end_of_attr_to_next_attr_or_item = Span::new(\n+                attr.span.hi(),\n+                iter.peek().map_or(item.span.lo(), |next_attr| next_attr.span.lo()),\n+                item.span.ctxt(),\n+                item.span.parent(),\n+            );\n \n-            if let Some(snippet) = snippet_opt(cx, end_of_attr_to_item) {\n+            if let Some(snippet) = snippet_opt(cx, end_of_attr_to_next_attr_or_item) {\n                 let lines = snippet.split('\\n').collect::<Vec<_>>();\n                 let lines = without_block_comments(lines);\n \n@@ -563,7 +619,7 @@ fn check_empty_line_after_outer_attr(cx: &EarlyContext<'_>, item: &rustc_ast::It\n \n fn check_deprecated_cfg_attr(cx: &EarlyContext<'_>, attr: &Attribute, msrv: Option<RustcVersion>) {\n     if_chain! {\n-        if meets_msrv(msrv.as_ref(), &msrvs::TOOL_ATTRIBUTES);\n+        if meets_msrv(msrv, msrvs::TOOL_ATTRIBUTES);\n         // check cfg_attr\n         if attr.has_name(sym::cfg_attr);\n         if let Some(items) = attr.meta_item_list();\n@@ -573,8 +629,15 @@ fn check_deprecated_cfg_attr(cx: &EarlyContext<'_>, attr: &Attribute, msrv: Opti\n         if feature_item.has_name(sym::rustfmt);\n         // check for `rustfmt_skip` and `rustfmt::skip`\n         if let Some(skip_item) = &items[1].meta_item();\n-        if skip_item.has_name(sym!(rustfmt_skip)) ||\n-            skip_item.path.segments.last().expect(\"empty path in attribute\").ident.name == sym::skip;\n+        if skip_item.has_name(sym!(rustfmt_skip))\n+            || skip_item\n+                .path\n+                .segments\n+                .last()\n+                .expect(\"empty path in attribute\")\n+                .ident\n+                .name\n+                == sym::skip;\n         // Only lint outer attributes, because custom inner attributes are unstable\n         // Tracking issue: https://github.com/rust-lang/rust/issues/54726\n         if attr.style == AttrStyle::Outer;\n@@ -659,5 +722,5 @@ fn check_mismatched_target_os(cx: &EarlyContext<'_>, attr: &Attribute) {\n }\n \n fn is_lint_level(symbol: Symbol) -> bool {\n-    matches!(symbol, sym::allow | sym::warn | sym::deny | sym::forbid)\n+    matches!(symbol, sym::allow | sym::expect | sym::warn | sym::deny | sym::forbid)\n }"}, {"sha": "5b7c4591504e1cbaa3710a1cad5b684b4f13efbe", "filename": "clippy_lints/src/await_holding_invalid.rs", "status": "modified", "additions": 191, "deletions": 55, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,16 +1,18 @@\n-use clippy_utils::diagnostics::span_lint_and_note;\n+use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::{match_def_path, paths};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::{AsyncGeneratorKind, Body, BodyId, GeneratorKind};\n+use rustc_hir::{def::Res, AsyncGeneratorKind, Body, BodyId, GeneratorKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::GeneratorInteriorTypeCause;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::Span;\n \n+use crate::utils::conf::DisallowedType;\n+\n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for calls to await while holding a\n-    /// non-async-aware MutexGuard.\n+    /// Checks for calls to await while holding a non-async-aware MutexGuard.\n     ///\n     /// ### Why is this bad?\n     /// The Mutex types found in std::sync and parking_lot\n@@ -22,90 +24,189 @@ declare_clippy_lint! {\n     /// either by introducing a scope or an explicit call to Drop::drop.\n     ///\n     /// ### Known problems\n-    /// Will report false positive for explicitly dropped guards ([#6446](https://github.com/rust-lang/rust-clippy/issues/6446)).\n+    /// Will report false positive for explicitly dropped guards\n+    /// ([#6446](https://github.com/rust-lang/rust-clippy/issues/6446)). A workaround for this is\n+    /// to wrap the `.lock()` call in a block instead of explicitly dropping the guard.\n     ///\n     /// ### Example\n-    /// ```rust,ignore\n-    /// use std::sync::Mutex;\n-    ///\n+    /// ```rust\n+    /// # use std::sync::Mutex;\n+    /// # async fn baz() {}\n     /// async fn foo(x: &Mutex<u32>) {\n-    ///   let guard = x.lock().unwrap();\n+    ///   let mut guard = x.lock().unwrap();\n     ///   *guard += 1;\n-    ///   bar.await;\n+    ///   baz().await;\n+    /// }\n+    ///\n+    /// async fn bar(x: &Mutex<u32>) {\n+    ///   let mut guard = x.lock().unwrap();\n+    ///   *guard += 1;\n+    ///   drop(guard); // explicit drop\n+    ///   baz().await;\n     /// }\n     /// ```\n     ///\n     /// Use instead:\n-    /// ```rust,ignore\n-    /// use std::sync::Mutex;\n-    ///\n+    /// ```rust\n+    /// # use std::sync::Mutex;\n+    /// # async fn baz() {}\n     /// async fn foo(x: &Mutex<u32>) {\n     ///   {\n-    ///     let guard = x.lock().unwrap();\n+    ///     let mut guard = x.lock().unwrap();\n     ///     *guard += 1;\n     ///   }\n-    ///   bar.await;\n+    ///   baz().await;\n+    /// }\n+    ///\n+    /// async fn bar(x: &Mutex<u32>) {\n+    ///   {\n+    ///     let mut guard = x.lock().unwrap();\n+    ///     *guard += 1;\n+    ///   } // guard dropped here at end of scope\n+    ///   baz().await;\n     /// }\n     /// ```\n     #[clippy::version = \"1.45.0\"]\n     pub AWAIT_HOLDING_LOCK,\n-    pedantic,\n-    \"Inside an async function, holding a MutexGuard while calling await\"\n+    suspicious,\n+    \"inside an async function, holding a `MutexGuard` while calling `await`\"\n }\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for calls to await while holding a\n-    /// `RefCell` `Ref` or `RefMut`.\n+    /// Checks for calls to await while holding a `RefCell` `Ref` or `RefMut`.\n     ///\n     /// ### Why is this bad?\n     /// `RefCell` refs only check for exclusive mutable access\n     /// at runtime. Holding onto a `RefCell` ref across an `await` suspension point\n     /// risks panics from a mutable ref shared while other refs are outstanding.\n     ///\n     /// ### Known problems\n-    /// Will report false positive for explicitly dropped refs ([#6353](https://github.com/rust-lang/rust-clippy/issues/6353)).\n+    /// Will report false positive for explicitly dropped refs\n+    /// ([#6353](https://github.com/rust-lang/rust-clippy/issues/6353)). A workaround for this is\n+    /// to wrap the `.borrow[_mut]()` call in a block instead of explicitly dropping the ref.\n     ///\n     /// ### Example\n-    /// ```rust,ignore\n-    /// use std::cell::RefCell;\n-    ///\n+    /// ```rust\n+    /// # use std::cell::RefCell;\n+    /// # async fn baz() {}\n     /// async fn foo(x: &RefCell<u32>) {\n     ///   let mut y = x.borrow_mut();\n     ///   *y += 1;\n-    ///   bar.await;\n+    ///   baz().await;\n+    /// }\n+    ///\n+    /// async fn bar(x: &RefCell<u32>) {\n+    ///   let mut y = x.borrow_mut();\n+    ///   *y += 1;\n+    ///   drop(y); // explicit drop\n+    ///   baz().await;\n     /// }\n     /// ```\n     ///\n     /// Use instead:\n-    /// ```rust,ignore\n-    /// use std::cell::RefCell;\n-    ///\n+    /// ```rust\n+    /// # use std::cell::RefCell;\n+    /// # async fn baz() {}\n     /// async fn foo(x: &RefCell<u32>) {\n     ///   {\n     ///      let mut y = x.borrow_mut();\n     ///      *y += 1;\n     ///   }\n-    ///   bar.await;\n+    ///   baz().await;\n+    /// }\n+    ///\n+    /// async fn bar(x: &RefCell<u32>) {\n+    ///   {\n+    ///     let mut y = x.borrow_mut();\n+    ///     *y += 1;\n+    ///   } // y dropped here at end of scope\n+    ///   baz().await;\n     /// }\n     /// ```\n     #[clippy::version = \"1.49.0\"]\n     pub AWAIT_HOLDING_REFCELL_REF,\n-    pedantic,\n-    \"Inside an async function, holding a RefCell ref while calling await\"\n+    suspicious,\n+    \"inside an async function, holding a `RefCell` ref while calling `await`\"\n }\n \n-declare_lint_pass!(AwaitHolding => [AWAIT_HOLDING_LOCK, AWAIT_HOLDING_REFCELL_REF]);\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Allows users to configure types which should not be held across `await`\n+    /// suspension points.\n+    ///\n+    /// ### Why is this bad?\n+    /// There are some types which are perfectly \"safe\" to be used concurrently\n+    /// from a memory access perspective but will cause bugs at runtime if they\n+    /// are held in such a way.\n+    ///\n+    /// ### Known problems\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```toml\n+    /// await-holding-invalid-types = [\n+    ///   # You can specify a type name\n+    ///   \"CustomLockType\",\n+    ///   # You can (optionally) specify a reason\n+    ///   { path = \"OtherCustomLockType\", reason = \"Relies on a thread local\" }\n+    /// ]\n+    /// ```\n+    ///\n+    /// ```rust\n+    /// # async fn baz() {}\n+    /// struct CustomLockType;\n+    /// struct OtherCustomLockType;\n+    /// async fn foo() {\n+    ///   let _x = CustomLockType;\n+    ///   let _y = OtherCustomLockType;\n+    ///   baz().await; // Lint violation\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.49.0\"]\n+    pub AWAIT_HOLDING_INVALID_TYPE,\n+    suspicious,\n+    \"holding a type across an await point which is not allowed to be held as per the configuration\"\n+}\n+\n+impl_lint_pass!(AwaitHolding => [AWAIT_HOLDING_LOCK, AWAIT_HOLDING_REFCELL_REF, AWAIT_HOLDING_INVALID_TYPE]);\n+\n+#[derive(Debug)]\n+pub struct AwaitHolding {\n+    conf_invalid_types: Vec<DisallowedType>,\n+    def_ids: FxHashMap<DefId, DisallowedType>,\n+}\n+\n+impl AwaitHolding {\n+    pub(crate) fn new(conf_invalid_types: Vec<DisallowedType>) -> Self {\n+        Self {\n+            conf_invalid_types,\n+            def_ids: FxHashMap::default(),\n+        }\n+    }\n+}\n \n impl LateLintPass<'_> for AwaitHolding {\n+    fn check_crate(&mut self, cx: &LateContext<'_>) {\n+        for conf in &self.conf_invalid_types {\n+            let path = match conf {\n+                DisallowedType::Simple(path) | DisallowedType::WithReason { path, .. } => path,\n+            };\n+            let segs: Vec<_> = path.split(\"::\").collect();\n+            if let Res::Def(_, id) = clippy_utils::def_path_res(cx, &segs) {\n+                self.def_ids.insert(id, conf.clone());\n+            }\n+        }\n+    }\n+\n     fn check_body(&mut self, cx: &LateContext<'_>, body: &'_ Body<'_>) {\n         use AsyncGeneratorKind::{Block, Closure, Fn};\n         if let Some(GeneratorKind::Async(Block | Closure | Fn)) = body.generator_kind {\n             let body_id = BodyId {\n                 hir_id: body.value.hir_id,\n             };\n             let typeck_results = cx.tcx.typeck_body(body_id);\n-            check_interior_types(\n+            self.check_interior_types(\n                 cx,\n                 typeck_results.generator_interior_types.as_ref().skip_binder(),\n                 body.value.span,\n@@ -114,33 +215,68 @@ impl LateLintPass<'_> for AwaitHolding {\n     }\n }\n \n-fn check_interior_types(cx: &LateContext<'_>, ty_causes: &[GeneratorInteriorTypeCause<'_>], span: Span) {\n-    for ty_cause in ty_causes {\n-        if let rustc_middle::ty::Adt(adt, _) = ty_cause.ty.kind() {\n-            if is_mutex_guard(cx, adt.did) {\n-                span_lint_and_note(\n-                    cx,\n-                    AWAIT_HOLDING_LOCK,\n-                    ty_cause.span,\n-                    \"this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await\",\n-                    ty_cause.scope_span.or(Some(span)),\n-                    \"these are all the await points this lock is held through\",\n-                );\n-            }\n-            if is_refcell_ref(cx, adt.did) {\n-                span_lint_and_note(\n-                    cx,\n-                    AWAIT_HOLDING_REFCELL_REF,\n-                    ty_cause.span,\n-                    \"this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await\",\n-                    ty_cause.scope_span.or(Some(span)),\n-                    \"these are all the await points this ref is held through\",\n-                );\n+impl AwaitHolding {\n+    fn check_interior_types(&self, cx: &LateContext<'_>, ty_causes: &[GeneratorInteriorTypeCause<'_>], span: Span) {\n+        for ty_cause in ty_causes {\n+            if let rustc_middle::ty::Adt(adt, _) = ty_cause.ty.kind() {\n+                if is_mutex_guard(cx, adt.did()) {\n+                    span_lint_and_then(\n+                        cx,\n+                        AWAIT_HOLDING_LOCK,\n+                        ty_cause.span,\n+                        \"this `MutexGuard` is held across an `await` point\",\n+                        |diag| {\n+                            diag.help(\n+                                \"consider using an async-aware `Mutex` type or ensuring the \\\n+                                `MutexGuard` is dropped before calling await\",\n+                            );\n+                            diag.span_note(\n+                                ty_cause.scope_span.unwrap_or(span),\n+                                \"these are all the `await` points this lock is held through\",\n+                            );\n+                        },\n+                    );\n+                } else if is_refcell_ref(cx, adt.did()) {\n+                    span_lint_and_then(\n+                        cx,\n+                        AWAIT_HOLDING_REFCELL_REF,\n+                        ty_cause.span,\n+                        \"this `RefCell` reference is held across an `await` point\",\n+                        |diag| {\n+                            diag.help(\"ensure the reference is dropped before calling `await`\");\n+                            diag.span_note(\n+                                ty_cause.scope_span.unwrap_or(span),\n+                                \"these are all the `await` points this reference is held through\",\n+                            );\n+                        },\n+                    );\n+                } else if let Some(disallowed) = self.def_ids.get(&adt.did()) {\n+                    emit_invalid_type(cx, ty_cause.span, disallowed);\n+                }\n             }\n         }\n     }\n }\n \n+fn emit_invalid_type(cx: &LateContext<'_>, span: Span, disallowed: &DisallowedType) {\n+    let (type_name, reason) = match disallowed {\n+        DisallowedType::Simple(path) => (path, &None),\n+        DisallowedType::WithReason { path, reason } => (path, reason),\n+    };\n+\n+    span_lint_and_then(\n+        cx,\n+        AWAIT_HOLDING_INVALID_TYPE,\n+        span,\n+        &format!(\"`{type_name}` may not be held across an `await` point per `clippy.toml`\",),\n+        |diag| {\n+            if let Some(reason) = reason {\n+                diag.note(reason.clone());\n+            }\n+        },\n+    );\n+}\n+\n fn is_mutex_guard(cx: &LateContext<'_>, def_id: DefId) -> bool {\n     match_def_path(cx, def_id, &paths::MUTEX_GUARD)\n         || match_def_path(cx, def_id, &paths::RWLOCK_READ_GUARD)"}, {"sha": "dc7e400fdc28156ed88bea412dcc8b92158ef654", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,7 +1,6 @@\n use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_then};\n use clippy_utils::sugg::Sugg;\n-use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Expr, ExprKind};\n@@ -130,32 +129,33 @@ impl<'tcx> LateLintPass<'tcx> for BitMask {\n                 }\n             }\n         }\n-        if_chain! {\n-            if let ExprKind::Binary(op, left, right) = &e.kind;\n-            if BinOpKind::Eq == op.node;\n-            if let ExprKind::Binary(op1, left1, right1) = &left.kind;\n-            if BinOpKind::BitAnd == op1.node;\n-            if let ExprKind::Lit(lit) = &right1.kind;\n-            if let LitKind::Int(n, _) = lit.node;\n-            if let ExprKind::Lit(lit1) = &right.kind;\n-            if let LitKind::Int(0, _) = lit1.node;\n-            if n.leading_zeros() == n.count_zeros();\n-            if n > u128::from(self.verbose_bit_mask_threshold);\n-            then {\n-                span_lint_and_then(cx,\n-                                   VERBOSE_BIT_MASK,\n-                                   e.span,\n-                                   \"bit mask could be simplified with a call to `trailing_zeros`\",\n-                                   |diag| {\n+\n+        if let ExprKind::Binary(op, left, right) = &e.kind\n+            && BinOpKind::Eq == op.node\n+            && let ExprKind::Binary(op1, left1, right1) = &left.kind\n+            && BinOpKind::BitAnd == op1.node\n+            && let ExprKind::Lit(lit) = &right1.kind\n+            && let LitKind::Int(n, _) = lit.node\n+            && let ExprKind::Lit(lit1) = &right.kind\n+            && let LitKind::Int(0, _) = lit1.node\n+            && n.leading_zeros() == n.count_zeros()\n+            && n > u128::from(self.verbose_bit_mask_threshold)\n+        {\n+            span_lint_and_then(\n+                cx,\n+                VERBOSE_BIT_MASK,\n+                e.span,\n+                \"bit mask could be simplified with a call to `trailing_zeros`\",\n+                |diag| {\n                     let sugg = Sugg::hir(cx, left1, \"...\").maybe_par();\n                     diag.span_suggestion(\n                         e.span,\n                         \"try\",\n                         format!(\"{}.trailing_zeros() >= {}\", sugg, n.count_ones()),\n                         Applicability::MaybeIncorrect,\n                     );\n-                });\n-            }\n+                },\n+            );\n         }\n     }\n }"}, {"sha": "4c4dd85d518a62ae9db0938d05f56f8fdfed47dc", "filename": "clippy_lints/src/blocks_in_if_conditions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,8 +1,8 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg};\n+use clippy_utils::get_parent_expr;\n use clippy_utils::higher;\n use clippy_utils::source::snippet_block_with_applicability;\n use clippy_utils::ty::implements_trait;\n-use clippy_utils::{differing_macro_contexts, get_parent_expr};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, Visitor};\n@@ -97,7 +97,7 @@ impl<'tcx> LateLintPass<'tcx> for BlocksInIfConditions {\n                         if let Some(ex) = &block.expr {\n                             // don't dig into the expression here, just suggest that they remove\n                             // the block\n-                            if expr.span.from_expansion() || differing_macro_contexts(expr.span, ex.span) {\n+                            if expr.span.from_expansion() || ex.span.from_expansion() {\n                                 return;\n                             }\n                             let mut applicability = Applicability::MachineApplicable;\n@@ -122,7 +122,7 @@ impl<'tcx> LateLintPass<'tcx> for BlocksInIfConditions {\n                         }\n                     } else {\n                         let span = block.expr.as_ref().map_or_else(|| block.stmts[0].span, |e| e.span);\n-                        if span.from_expansion() || differing_macro_contexts(expr.span, span) {\n+                        if span.from_expansion() || expr.span.from_expansion() {\n                             return;\n                         }\n                         // move block higher"}, {"sha": "0adb6327164e77f642b391dcad553ea0066fa5d6", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -137,7 +137,7 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n         }\n         for (n, expr) in self.terminals.iter().enumerate() {\n             if eq_expr_value(self.cx, e, expr) {\n-                #[allow(clippy::cast_possible_truncation)]\n+                #[expect(clippy::cast_possible_truncation)]\n                 return Ok(Bool::Term(n as u8));\n             }\n \n@@ -149,15 +149,15 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n                 if eq_expr_value(self.cx, e_lhs, expr_lhs);\n                 if eq_expr_value(self.cx, e_rhs, expr_rhs);\n                 then {\n-                    #[allow(clippy::cast_possible_truncation)]\n+                    #[expect(clippy::cast_possible_truncation)]\n                     return Ok(Bool::Not(Box::new(Bool::Term(n as u8))));\n                 }\n             }\n         }\n         let n = self.terminals.len();\n         self.terminals.push(e);\n         if n < 32 {\n-            #[allow(clippy::cast_possible_truncation)]\n+            #[expect(clippy::cast_possible_truncation)]\n             Ok(Bool::Term(n as u8))\n         } else {\n             Err(\"too many literals\".to_owned())"}, {"sha": "0993adbae2e6bfdb37c27b85335549c83c773dc9", "filename": "clippy_lints/src/borrow_as_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fborrow_as_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fborrow_as_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fborrow_as_ptr.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -57,7 +57,7 @@ impl BorrowAsPtr {\n \n impl<'tcx> LateLintPass<'tcx> for BorrowAsPtr {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if !meets_msrv(self.msrv.as_ref(), &msrvs::BORROW_AS_PTR) {\n+        if !meets_msrv(self.msrv, msrvs::BORROW_AS_PTR) {\n             return;\n         }\n "}, {"sha": "d70dbf5b23904aa282d7be16b3c025add46f1781", "filename": "clippy_lints/src/bytes_count_to_len.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fbytes_count_to_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fbytes_count_to_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytes_count_to_len.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,70 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{match_def_path, paths};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// It checks for `str::bytes().count()` and suggests replacing it with\n+    /// `str::len()`.\n+    ///\n+    /// ### Why is this bad?\n+    /// `str::bytes().count()` is longer and may not be as performant as using\n+    /// `str::len()`.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// \"hello\".bytes().count();\n+    /// String::from(\"hello\").bytes().count();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// \"hello\".len();\n+    /// String::from(\"hello\").len();\n+    /// ```\n+    #[clippy::version = \"1.62.0\"]\n+    pub BYTES_COUNT_TO_LEN,\n+    complexity,\n+    \"Using `bytes().count()` when `len()` performs the same functionality\"\n+}\n+\n+declare_lint_pass!(BytesCountToLen => [BYTES_COUNT_TO_LEN]);\n+\n+impl<'tcx> LateLintPass<'tcx> for BytesCountToLen {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        if_chain! {\n+            if let hir::ExprKind::MethodCall(_, expr_args, _) = &expr.kind;\n+            if let Some(expr_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+            if match_def_path(cx, expr_def_id, &paths::ITER_COUNT);\n+\n+            if let [bytes_expr] = &**expr_args;\n+            if let hir::ExprKind::MethodCall(_, bytes_args, _) = &bytes_expr.kind;\n+            if let Some(bytes_def_id) = cx.typeck_results().type_dependent_def_id(bytes_expr.hir_id);\n+            if match_def_path(cx, bytes_def_id, &paths::STR_BYTES);\n+\n+            if let [str_expr] = &**bytes_args;\n+            let ty = cx.typeck_results().expr_ty(str_expr).peel_refs();\n+\n+            if is_type_diagnostic_item(cx, ty, sym::String) || ty.kind() == &ty::Str;\n+            then {\n+                let mut applicability = Applicability::MachineApplicable;\n+                span_lint_and_sugg(\n+                    cx,\n+                    BYTES_COUNT_TO_LEN,\n+                    expr.span,\n+                    \"using long and hard to read `.bytes().count()`\",\n+                    \"consider calling `.len()` instead\",\n+                    format!(\"{}.len()\", snippet_with_applicability(cx, str_expr.span, \"..\", &mut applicability)),\n+                    applicability\n+                );\n+            }\n+        };\n+    }\n+}"}, {"sha": "e0442dda479d75c89023dde50eb2ca669a955356", "filename": "clippy_lints/src/cargo/common_metadata.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcargo%2Fcommon_metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcargo%2Fcommon_metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcargo%2Fcommon_metadata.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,54 @@\n+//! lint on missing cargo common metadata\n+\n+use cargo_metadata::Metadata;\n+use clippy_utils::diagnostics::span_lint;\n+use rustc_lint::LateContext;\n+use rustc_span::source_map::DUMMY_SP;\n+\n+use super::CARGO_COMMON_METADATA;\n+\n+pub(super) fn check(cx: &LateContext<'_>, metadata: &Metadata, ignore_publish: bool) {\n+    for package in &metadata.packages {\n+        // only run the lint if publish is `None` (`publish = true` or skipped entirely)\n+        // or if the vector isn't empty (`publish = [\"something\"]`)\n+        if package.publish.as_ref().filter(|publish| publish.is_empty()).is_none() || ignore_publish {\n+            if is_empty_str(&package.description) {\n+                missing_warning(cx, package, \"package.description\");\n+            }\n+\n+            if is_empty_str(&package.license) && is_empty_str(&package.license_file) {\n+                missing_warning(cx, package, \"either package.license or package.license_file\");\n+            }\n+\n+            if is_empty_str(&package.repository) {\n+                missing_warning(cx, package, \"package.repository\");\n+            }\n+\n+            if is_empty_str(&package.readme) {\n+                missing_warning(cx, package, \"package.readme\");\n+            }\n+\n+            if is_empty_vec(&package.keywords) {\n+                missing_warning(cx, package, \"package.keywords\");\n+            }\n+\n+            if is_empty_vec(&package.categories) {\n+                missing_warning(cx, package, \"package.categories\");\n+            }\n+        }\n+    }\n+}\n+\n+fn missing_warning(cx: &LateContext<'_>, package: &cargo_metadata::Package, field: &str) {\n+    let message = format!(\"package `{}` is missing `{}` metadata\", package.name, field);\n+    span_lint(cx, CARGO_COMMON_METADATA, DUMMY_SP, &message);\n+}\n+\n+fn is_empty_str<T: AsRef<std::ffi::OsStr>>(value: &Option<T>) -> bool {\n+    value.as_ref().map_or(true, |s| s.as_ref().is_empty())\n+}\n+\n+fn is_empty_vec(value: &[String]) -> bool {\n+    // This works because empty iterators return true\n+    value.iter().all(String::is_empty)\n+}"}, {"sha": "79a469a4258bbcc4643153e2d84eb64a814becfc", "filename": "clippy_lints/src/cargo/feature_name.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcargo%2Ffeature_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcargo%2Ffeature_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcargo%2Ffeature_name.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,92 @@\n+use cargo_metadata::Metadata;\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use rustc_lint::LateContext;\n+use rustc_span::source_map::DUMMY_SP;\n+\n+use super::{NEGATIVE_FEATURE_NAMES, REDUNDANT_FEATURE_NAMES};\n+\n+static PREFIXES: [&str; 8] = [\"no-\", \"no_\", \"not-\", \"not_\", \"use-\", \"use_\", \"with-\", \"with_\"];\n+static SUFFIXES: [&str; 2] = [\"-support\", \"_support\"];\n+\n+pub(super) fn check(cx: &LateContext<'_>, metadata: &Metadata) {\n+    for package in &metadata.packages {\n+        let mut features: Vec<&String> = package.features.keys().collect();\n+        features.sort();\n+        for feature in features {\n+            let prefix_opt = {\n+                let i = PREFIXES.partition_point(|prefix| prefix < &feature.as_str());\n+                if i > 0 && feature.starts_with(PREFIXES[i - 1]) {\n+                    Some(PREFIXES[i - 1])\n+                } else {\n+                    None\n+                }\n+            };\n+            if let Some(prefix) = prefix_opt {\n+                lint(cx, feature, prefix, true);\n+            }\n+\n+            let suffix_opt: Option<&str> = {\n+                let i = SUFFIXES.partition_point(|suffix| {\n+                    suffix.bytes().rev().cmp(feature.bytes().rev()) == std::cmp::Ordering::Less\n+                });\n+                if i > 0 && feature.ends_with(SUFFIXES[i - 1]) {\n+                    Some(SUFFIXES[i - 1])\n+                } else {\n+                    None\n+                }\n+            };\n+            if let Some(suffix) = suffix_opt {\n+                lint(cx, feature, suffix, false);\n+            }\n+        }\n+    }\n+}\n+\n+fn is_negative_prefix(s: &str) -> bool {\n+    s.starts_with(\"no\")\n+}\n+\n+fn lint(cx: &LateContext<'_>, feature: &str, substring: &str, is_prefix: bool) {\n+    let is_negative = is_prefix && is_negative_prefix(substring);\n+    span_lint_and_help(\n+        cx,\n+        if is_negative {\n+            NEGATIVE_FEATURE_NAMES\n+        } else {\n+            REDUNDANT_FEATURE_NAMES\n+        },\n+        DUMMY_SP,\n+        &format!(\n+            \"the \\\"{}\\\" {} in the feature name \\\"{}\\\" is {}\",\n+            substring,\n+            if is_prefix { \"prefix\" } else { \"suffix\" },\n+            feature,\n+            if is_negative { \"negative\" } else { \"redundant\" }\n+        ),\n+        None,\n+        &format!(\n+            \"consider renaming the feature to \\\"{}\\\"{}\",\n+            if is_prefix {\n+                feature.strip_prefix(substring)\n+            } else {\n+                feature.strip_suffix(substring)\n+            }\n+            .unwrap(),\n+            if is_negative {\n+                \", but make sure the feature adds functionality\"\n+            } else {\n+                \"\"\n+            }\n+        ),\n+    );\n+}\n+\n+#[test]\n+fn test_prefixes_sorted() {\n+    let mut sorted_prefixes = PREFIXES;\n+    sorted_prefixes.sort_unstable();\n+    assert_eq!(PREFIXES, sorted_prefixes);\n+    let mut sorted_suffixes = SUFFIXES;\n+    sorted_suffixes.sort_by(|a, b| a.bytes().rev().cmp(b.bytes().rev()));\n+    assert_eq!(SUFFIXES, sorted_suffixes);\n+}"}, {"sha": "abe95c6663f70eb6a614c4335fc96dfbeec2f356", "filename": "clippy_lints/src/cargo/mod.rs", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcargo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcargo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcargo%2Fmod.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,221 @@\n+use cargo_metadata::MetadataCommand;\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::is_lint_allowed;\n+use rustc_hir::hir_id::CRATE_HIR_ID;\n+use rustc_lint::{LateContext, LateLintPass, Lint};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::DUMMY_SP;\n+\n+mod common_metadata;\n+mod feature_name;\n+mod multiple_crate_versions;\n+mod wildcard_dependencies;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks to see if all common metadata is defined in\n+    /// `Cargo.toml`. See: https://rust-lang-nursery.github.io/api-guidelines/documentation.html#cargotoml-includes-all-common-metadata-c-metadata\n+    ///\n+    /// ### Why is this bad?\n+    /// It will be more difficult for users to discover the\n+    /// purpose of the crate, and key information related to it.\n+    ///\n+    /// ### Example\n+    /// ```toml\n+    /// # This `Cargo.toml` is missing a description field:\n+    /// [package]\n+    /// name = \"clippy\"\n+    /// version = \"0.0.212\"\n+    /// repository = \"https://github.com/rust-lang/rust-clippy\"\n+    /// readme = \"README.md\"\n+    /// license = \"MIT OR Apache-2.0\"\n+    /// keywords = [\"clippy\", \"lint\", \"plugin\"]\n+    /// categories = [\"development-tools\", \"development-tools::cargo-plugins\"]\n+    /// ```\n+    ///\n+    /// Should include a description field like:\n+    ///\n+    /// ```toml\n+    /// # This `Cargo.toml` includes all common metadata\n+    /// [package]\n+    /// name = \"clippy\"\n+    /// version = \"0.0.212\"\n+    /// description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n+    /// repository = \"https://github.com/rust-lang/rust-clippy\"\n+    /// readme = \"README.md\"\n+    /// license = \"MIT OR Apache-2.0\"\n+    /// keywords = [\"clippy\", \"lint\", \"plugin\"]\n+    /// categories = [\"development-tools\", \"development-tools::cargo-plugins\"]\n+    /// ```\n+    #[clippy::version = \"1.32.0\"]\n+    pub CARGO_COMMON_METADATA,\n+    cargo,\n+    \"common metadata is defined in `Cargo.toml`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for feature names with prefix `use-`, `with-` or suffix `-support`\n+    ///\n+    /// ### Why is this bad?\n+    /// These prefixes and suffixes have no significant meaning.\n+    ///\n+    /// ### Example\n+    /// ```toml\n+    /// # The `Cargo.toml` with feature name redundancy\n+    /// [features]\n+    /// default = [\"use-abc\", \"with-def\", \"ghi-support\"]\n+    /// use-abc = []  // redundant\n+    /// with-def = []   // redundant\n+    /// ghi-support = []   // redundant\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```toml\n+    /// [features]\n+    /// default = [\"abc\", \"def\", \"ghi\"]\n+    /// abc = []\n+    /// def = []\n+    /// ghi = []\n+    /// ```\n+    ///\n+    #[clippy::version = \"1.57.0\"]\n+    pub REDUNDANT_FEATURE_NAMES,\n+    cargo,\n+    \"usage of a redundant feature name\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for negative feature names with prefix `no-` or `not-`\n+    ///\n+    /// ### Why is this bad?\n+    /// Features are supposed to be additive, and negatively-named features violate it.\n+    ///\n+    /// ### Example\n+    /// ```toml\n+    /// # The `Cargo.toml` with negative feature names\n+    /// [features]\n+    /// default = []\n+    /// no-abc = []\n+    /// not-def = []\n+    ///\n+    /// ```\n+    /// Use instead:\n+    /// ```toml\n+    /// [features]\n+    /// default = [\"abc\", \"def\"]\n+    /// abc = []\n+    /// def = []\n+    ///\n+    /// ```\n+    #[clippy::version = \"1.57.0\"]\n+    pub NEGATIVE_FEATURE_NAMES,\n+    cargo,\n+    \"usage of a negative feature name\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks to see if multiple versions of a crate are being\n+    /// used.\n+    ///\n+    /// ### Why is this bad?\n+    /// This bloats the size of targets, and can lead to\n+    /// confusing error messages when structs or traits are used interchangeably\n+    /// between different versions of a crate.\n+    ///\n+    /// ### Known problems\n+    /// Because this can be caused purely by the dependencies\n+    /// themselves, it's not always possible to fix this issue.\n+    ///\n+    /// ### Example\n+    /// ```toml\n+    /// # This will pull in both winapi v0.3.x and v0.2.x, triggering a warning.\n+    /// [dependencies]\n+    /// ctrlc = \"=3.1.0\"\n+    /// ansi_term = \"=0.11.0\"\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub MULTIPLE_CRATE_VERSIONS,\n+    cargo,\n+    \"multiple versions of the same crate being used\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for wildcard dependencies in the `Cargo.toml`.\n+    ///\n+    /// ### Why is this bad?\n+    /// [As the edition guide says](https://rust-lang-nursery.github.io/edition-guide/rust-2018/cargo-and-crates-io/crates-io-disallows-wildcard-dependencies.html),\n+    /// it is highly unlikely that you work with any possible version of your dependency,\n+    /// and wildcard dependencies would cause unnecessary breakage in the ecosystem.\n+    ///\n+    /// ### Example\n+    /// ```toml\n+    /// [dependencies]\n+    /// regex = \"*\"\n+    /// ```\n+    #[clippy::version = \"1.32.0\"]\n+    pub WILDCARD_DEPENDENCIES,\n+    cargo,\n+    \"wildcard dependencies being used\"\n+}\n+\n+pub struct Cargo {\n+    pub ignore_publish: bool,\n+}\n+\n+impl_lint_pass!(Cargo => [\n+    CARGO_COMMON_METADATA,\n+    REDUNDANT_FEATURE_NAMES,\n+    NEGATIVE_FEATURE_NAMES,\n+    MULTIPLE_CRATE_VERSIONS,\n+    WILDCARD_DEPENDENCIES\n+]);\n+\n+impl LateLintPass<'_> for Cargo {\n+    fn check_crate(&mut self, cx: &LateContext<'_>) {\n+        static NO_DEPS_LINTS: &[&Lint] = &[\n+            CARGO_COMMON_METADATA,\n+            REDUNDANT_FEATURE_NAMES,\n+            NEGATIVE_FEATURE_NAMES,\n+            WILDCARD_DEPENDENCIES,\n+        ];\n+        static WITH_DEPS_LINTS: &[&Lint] = &[MULTIPLE_CRATE_VERSIONS];\n+\n+        if !NO_DEPS_LINTS\n+            .iter()\n+            .all(|&lint| is_lint_allowed(cx, lint, CRATE_HIR_ID))\n+        {\n+            match MetadataCommand::new().no_deps().exec() {\n+                Ok(metadata) => {\n+                    common_metadata::check(cx, &metadata, self.ignore_publish);\n+                    feature_name::check(cx, &metadata);\n+                    wildcard_dependencies::check(cx, &metadata);\n+                },\n+                Err(e) => {\n+                    for lint in NO_DEPS_LINTS {\n+                        span_lint(cx, lint, DUMMY_SP, &format!(\"could not read cargo metadata: {}\", e));\n+                    }\n+                },\n+            }\n+        }\n+\n+        if !WITH_DEPS_LINTS\n+            .iter()\n+            .all(|&lint| is_lint_allowed(cx, lint, CRATE_HIR_ID))\n+        {\n+            match MetadataCommand::new().exec() {\n+                Ok(metadata) => {\n+                    multiple_crate_versions::check(cx, &metadata);\n+                },\n+                Err(e) => {\n+                    for lint in WITH_DEPS_LINTS {\n+                        span_lint(cx, lint, DUMMY_SP, &format!(\"could not read cargo metadata: {}\", e));\n+                    }\n+                },\n+            }\n+        }\n+    }\n+}"}, {"sha": "76fd0819a39a5f5225e7b7b44feb0dfa1a1f203e", "filename": "clippy_lints/src/cargo/multiple_crate_versions.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcargo%2Fmultiple_crate_versions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcargo%2Fmultiple_crate_versions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcargo%2Fmultiple_crate_versions.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,63 @@\n+//! lint on multiple versions of a crate being used\n+\n+use cargo_metadata::{DependencyKind, Metadata, Node, Package, PackageId};\n+use clippy_utils::diagnostics::span_lint;\n+use if_chain::if_chain;\n+use itertools::Itertools;\n+use rustc_hir::def_id::LOCAL_CRATE;\n+use rustc_lint::LateContext;\n+use rustc_span::source_map::DUMMY_SP;\n+\n+use super::MULTIPLE_CRATE_VERSIONS;\n+\n+pub(super) fn check(cx: &LateContext<'_>, metadata: &Metadata) {\n+    let local_name = cx.tcx.crate_name(LOCAL_CRATE);\n+    let mut packages = metadata.packages.clone();\n+    packages.sort_by(|a, b| a.name.cmp(&b.name));\n+\n+    if_chain! {\n+        if let Some(resolve) = &metadata.resolve;\n+        if let Some(local_id) = packages\n+            .iter()\n+            .find_map(|p| if p.name == local_name.as_str() { Some(&p.id) } else { None });\n+        then {\n+            for (name, group) in &packages.iter().group_by(|p| p.name.clone()) {\n+                let group: Vec<&Package> = group.collect();\n+\n+                if group.len() <= 1 {\n+                    continue;\n+                }\n+\n+                if group.iter().all(|p| is_normal_dep(&resolve.nodes, local_id, &p.id)) {\n+                    let mut versions: Vec<_> = group.into_iter().map(|p| &p.version).collect();\n+                    versions.sort();\n+                    let versions = versions.iter().join(\", \");\n+\n+                    span_lint(\n+                        cx,\n+                        MULTIPLE_CRATE_VERSIONS,\n+                        DUMMY_SP,\n+                        &format!(\"multiple versions for dependency `{}`: {}\", name, versions),\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn is_normal_dep(nodes: &[Node], local_id: &PackageId, dep_id: &PackageId) -> bool {\n+    fn depends_on(node: &Node, dep_id: &PackageId) -> bool {\n+        node.deps.iter().any(|dep| {\n+            dep.pkg == *dep_id\n+                && dep\n+                    .dep_kinds\n+                    .iter()\n+                    .any(|info| matches!(info.kind, DependencyKind::Normal))\n+        })\n+    }\n+\n+    nodes\n+        .iter()\n+        .filter(|node| depends_on(node, dep_id))\n+        .any(|node| node.id == *local_id || is_normal_dep(nodes, local_id, &node.id))\n+}"}, {"sha": "7fa6acbf557b1efb7f293a9ee1947df122ee88bc", "filename": "clippy_lints/src/cargo/wildcard_dependencies.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcargo%2Fwildcard_dependencies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcargo%2Fwildcard_dependencies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcargo%2Fwildcard_dependencies.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,27 @@\n+use cargo_metadata::Metadata;\n+use clippy_utils::diagnostics::span_lint;\n+use if_chain::if_chain;\n+use rustc_lint::LateContext;\n+use rustc_span::source_map::DUMMY_SP;\n+\n+use super::WILDCARD_DEPENDENCIES;\n+\n+pub(super) fn check(cx: &LateContext<'_>, metadata: &Metadata) {\n+    for dep in &metadata.packages[0].dependencies {\n+        // VersionReq::any() does not work\n+        if_chain! {\n+            if let Ok(wildcard_ver) = semver::VersionReq::parse(\"*\");\n+            if let Some(ref source) = dep.source;\n+            if !source.starts_with(\"git\");\n+            if dep.req == wildcard_ver;\n+            then {\n+                span_lint(\n+                    cx,\n+                    WILDCARD_DEPENDENCIES,\n+                    DUMMY_SP,\n+                    &format!(\"wildcard dependency for `{}`\", dep.name),\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "23f79fdc68238ec24ecb1fe5dd2c6e7c08dd3279", "filename": "clippy_lints/src/cargo_common_metadata.rs", "status": "removed", "additions": 0, "deletions": 118, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/cb29e3effbf72db2e1f5177336bfb3309ec8805e/clippy_lints%2Fsrc%2Fcargo_common_metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb29e3effbf72db2e1f5177336bfb3309ec8805e/clippy_lints%2Fsrc%2Fcargo_common_metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcargo_common_metadata.rs?ref=cb29e3effbf72db2e1f5177336bfb3309ec8805e", "patch": "@@ -1,118 +0,0 @@\n-//! lint on missing cargo common metadata\n-\n-use clippy_utils::{diagnostics::span_lint, is_lint_allowed};\n-use rustc_hir::hir_id::CRATE_HIR_ID;\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::source_map::DUMMY_SP;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks to see if all common metadata is defined in\n-    /// `Cargo.toml`. See: https://rust-lang-nursery.github.io/api-guidelines/documentation.html#cargotoml-includes-all-common-metadata-c-metadata\n-    ///\n-    /// ### Why is this bad?\n-    /// It will be more difficult for users to discover the\n-    /// purpose of the crate, and key information related to it.\n-    ///\n-    /// ### Example\n-    /// ```toml\n-    /// # This `Cargo.toml` is missing a description field:\n-    /// [package]\n-    /// name = \"clippy\"\n-    /// version = \"0.0.212\"\n-    /// repository = \"https://github.com/rust-lang/rust-clippy\"\n-    /// readme = \"README.md\"\n-    /// license = \"MIT OR Apache-2.0\"\n-    /// keywords = [\"clippy\", \"lint\", \"plugin\"]\n-    /// categories = [\"development-tools\", \"development-tools::cargo-plugins\"]\n-    /// ```\n-    ///\n-    /// Should include a description field like:\n-    ///\n-    /// ```toml\n-    /// # This `Cargo.toml` includes all common metadata\n-    /// [package]\n-    /// name = \"clippy\"\n-    /// version = \"0.0.212\"\n-    /// description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n-    /// repository = \"https://github.com/rust-lang/rust-clippy\"\n-    /// readme = \"README.md\"\n-    /// license = \"MIT OR Apache-2.0\"\n-    /// keywords = [\"clippy\", \"lint\", \"plugin\"]\n-    /// categories = [\"development-tools\", \"development-tools::cargo-plugins\"]\n-    /// ```\n-    #[clippy::version = \"1.32.0\"]\n-    pub CARGO_COMMON_METADATA,\n-    cargo,\n-    \"common metadata is defined in `Cargo.toml`\"\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub struct CargoCommonMetadata {\n-    ignore_publish: bool,\n-}\n-\n-impl CargoCommonMetadata {\n-    pub fn new(ignore_publish: bool) -> Self {\n-        Self { ignore_publish }\n-    }\n-}\n-\n-impl_lint_pass!(CargoCommonMetadata => [\n-    CARGO_COMMON_METADATA\n-]);\n-\n-fn missing_warning(cx: &LateContext<'_>, package: &cargo_metadata::Package, field: &str) {\n-    let message = format!(\"package `{}` is missing `{}` metadata\", package.name, field);\n-    span_lint(cx, CARGO_COMMON_METADATA, DUMMY_SP, &message);\n-}\n-\n-fn is_empty_str<T: AsRef<std::ffi::OsStr>>(value: &Option<T>) -> bool {\n-    value.as_ref().map_or(true, |s| s.as_ref().is_empty())\n-}\n-\n-fn is_empty_vec(value: &[String]) -> bool {\n-    // This works because empty iterators return true\n-    value.iter().all(String::is_empty)\n-}\n-\n-impl LateLintPass<'_> for CargoCommonMetadata {\n-    fn check_crate(&mut self, cx: &LateContext<'_>) {\n-        if is_lint_allowed(cx, CARGO_COMMON_METADATA, CRATE_HIR_ID) {\n-            return;\n-        }\n-\n-        let metadata = unwrap_cargo_metadata!(cx, CARGO_COMMON_METADATA, false);\n-\n-        for package in metadata.packages {\n-            // only run the lint if publish is `None` (`publish = true` or skipped entirely)\n-            // or if the vector isn't empty (`publish = [\"something\"]`)\n-            if package.publish.as_ref().filter(|publish| publish.is_empty()).is_none() || self.ignore_publish {\n-                if is_empty_str(&package.description) {\n-                    missing_warning(cx, &package, \"package.description\");\n-                }\n-\n-                if is_empty_str(&package.license) && is_empty_str(&package.license_file) {\n-                    missing_warning(cx, &package, \"either package.license or package.license_file\");\n-                }\n-\n-                if is_empty_str(&package.repository) {\n-                    missing_warning(cx, &package, \"package.repository\");\n-                }\n-\n-                if is_empty_str(&package.readme) {\n-                    missing_warning(cx, &package, \"package.readme\");\n-                }\n-\n-                if is_empty_vec(&package.keywords) {\n-                    missing_warning(cx, &package, \"package.keywords\");\n-                }\n-\n-                if is_empty_vec(&package.categories) {\n-                    missing_warning(cx, &package, \"package.categories\");\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "7af200708ff0326533b354b5d9801515261e6d0c", "filename": "clippy_lints/src/case_sensitive_file_extension_comparisons.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -42,21 +42,21 @@ fn check_case_sensitive_file_extension_comparison(ctx: &LateContext<'_>, expr: &\n         if let ExprKind::Lit(Spanned { node: LitKind::Str(ext_literal, ..), ..}) = extension.kind;\n         if (2..=6).contains(&ext_literal.as_str().len());\n         if ext_literal.as_str().starts_with('.');\n-        if ext_literal.as_str().chars().skip(1).all(|c| c.is_uppercase() || c.is_digit(10))\n-            || ext_literal.as_str().chars().skip(1).all(|c| c.is_lowercase() || c.is_digit(10));\n+        if ext_literal.as_str().chars().skip(1).all(|c| c.is_uppercase() || c.is_ascii_digit())\n+            || ext_literal.as_str().chars().skip(1).all(|c| c.is_lowercase() || c.is_ascii_digit());\n         then {\n             let mut ty = ctx.typeck_results().expr_ty(obj);\n             ty = match ty.kind() {\n-                ty::Ref(_, ty, ..) => ty,\n+                ty::Ref(_, ty, ..) => *ty,\n                 _ => ty\n             };\n \n             match ty.kind() {\n                 ty::Str => {\n                     return Some(span);\n                 },\n-                ty::Adt(&ty::AdtDef { did, .. }, _) => {\n-                    if ctx.tcx.is_diagnostic_item(sym::String, did) {\n+                ty::Adt(def, _) => {\n+                    if ctx.tcx.is_diagnostic_item(sym::String, def.did()) {\n                         return Some(span);\n                     }\n                 },"}, {"sha": "6bac6bf83f8e5480e735854a695c5c0dbbafc98d", "filename": "clippy_lints/src/casts/cast_abs_to_unsigned.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcasts%2Fcast_abs_to_unsigned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcasts%2Fcast_abs_to_unsigned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_abs_to_unsigned.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,42 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::sugg::Sugg;\n+use clippy_utils::{meets_msrv, msrvs};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::Ty;\n+use rustc_semver::RustcVersion;\n+\n+use super::CAST_ABS_TO_UNSIGNED;\n+\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    expr: &Expr<'_>,\n+    cast_expr: &Expr<'_>,\n+    cast_from: Ty<'_>,\n+    cast_to: Ty<'_>,\n+    msrv: Option<RustcVersion>,\n+) {\n+    if_chain! {\n+        if meets_msrv(msrv, msrvs::UNSIGNED_ABS);\n+        if cast_from.is_integral();\n+        if cast_to.is_integral();\n+        if cast_from.is_signed();\n+        if !cast_to.is_signed();\n+        if let ExprKind::MethodCall(method_path, args, _) = cast_expr.kind;\n+        if let method_name = method_path.ident.name.as_str();\n+        if method_name == \"abs\";\n+        then {\n+            span_lint_and_sugg(\n+                cx,\n+                CAST_ABS_TO_UNSIGNED,\n+                expr.span,\n+                &format!(\"casting the result of `{}::{}()` to {}\", cast_from, method_name, cast_to),\n+                \"replace with\",\n+                format!(\"{}.unsigned_abs()\", Sugg::hir(cx, &args[0], \"..\")),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}"}, {"sha": "1973692e105f74050c0d191185667111aefcd061", "filename": "clippy_lints/src/casts/cast_enum_constructor.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcasts%2Fcast_enum_constructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcasts%2Fcast_enum_constructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_enum_constructor.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,21 @@\n+use clippy_utils::diagnostics::span_lint;\n+use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+\n+use super::CAST_ENUM_CONSTRUCTOR;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_expr: &Expr<'_>, cast_from: Ty<'_>) {\n+    if matches!(cast_from.kind(), ty::FnDef(..))\n+        && let ExprKind::Path(path) = &cast_expr.kind\n+        && let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), _) = cx.qpath_res(path, cast_expr.hir_id)\n+    {\n+        span_lint(\n+            cx,\n+            CAST_ENUM_CONSTRUCTOR,\n+            expr.span,\n+            \"cast of an enum tuple constructor to an integer\",\n+        );\n+    }\n+}"}, {"sha": "938458e30cadc6082697568ebdd7a9a413ebfa4d", "filename": "clippy_lints/src/casts/cast_lossless.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcasts%2Fcast_lossless.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcasts%2Fcast_lossless.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_lossless.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -16,7 +16,7 @@ pub(super) fn check(\n     cast_op: &Expr<'_>,\n     cast_from: Ty<'_>,\n     cast_to: Ty<'_>,\n-    msrv: &Option<RustcVersion>,\n+    msrv: Option<RustcVersion>,\n ) {\n     if !should_lint(cx, expr, cast_from, cast_to, msrv) {\n         return;\n@@ -68,7 +68,7 @@ fn should_lint(\n     expr: &Expr<'_>,\n     cast_from: Ty<'_>,\n     cast_to: Ty<'_>,\n-    msrv: &Option<RustcVersion>,\n+    msrv: Option<RustcVersion>,\n ) -> bool {\n     // Do not suggest using From in consts/statics until it is valid to do so (see #2267).\n     if in_constant(cx, expr.hir_id) {\n@@ -93,9 +93,9 @@ fn should_lint(\n             } else {\n                 64\n             };\n-            from_nbits < to_nbits\n+            !is_isize_or_usize(cast_from) && from_nbits < to_nbits\n         },\n-        (false, true) if matches!(cast_from.kind(), ty::Bool) && meets_msrv(msrv.as_ref(), &msrvs::FROM_BOOL) => true,\n+        (false, true) if matches!(cast_from.kind(), ty::Bool) && meets_msrv(msrv, msrvs::FROM_BOOL) => true,\n         (_, _) => {\n             matches!(cast_from.kind(), ty::Float(FloatTy::F32)) && matches!(cast_to.kind(), ty::Float(FloatTy::F64))\n         },"}, {"sha": "64f87c80f8d147a5e3e21aed776582434d465fee", "filename": "clippy_lints/src/casts/cast_possible_truncation.rs", "status": "modified", "additions": 65, "deletions": 23, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,12 +1,15 @@\n use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::expr_or_init;\n-use clippy_utils::ty::is_isize_or_usize;\n+use clippy_utils::ty::{get_discriminant_value, is_isize_or_usize};\n+use rustc_ast::ast;\n+use rustc_attr::IntType;\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::{BinOpKind, Expr, ExprKind};\n use rustc_lint::LateContext;\n use rustc_middle::ty::{self, FloatTy, Ty};\n \n-use super::{utils, CAST_POSSIBLE_TRUNCATION};\n+use super::{utils, CAST_ENUM_TRUNCATION, CAST_POSSIBLE_TRUNCATION};\n \n fn constant_int(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<u128> {\n     if let Some((Constant::Int(c), _)) = constant(cx, cx.typeck_results(), expr) {\n@@ -26,21 +29,19 @@ fn apply_reductions(cx: &LateContext<'_>, nbits: u64, expr: &Expr<'_>, signed: b\n         ExprKind::Block(block, _) => block.expr.map_or(nbits, |e| apply_reductions(cx, nbits, e, signed)),\n         ExprKind::Binary(op, left, right) => match op.node {\n             BinOpKind::Div => {\n-                apply_reductions(cx, nbits, left, signed)\n-                    - (if signed {\n-                        0 // let's be conservative here\n-                    } else {\n-                        // by dividing by 1, we remove 0 bits, etc.\n-                        get_constant_bits(cx, right).map_or(0, |b| b.saturating_sub(1))\n-                    })\n+                apply_reductions(cx, nbits, left, signed).saturating_sub(if signed {\n+                    // let's be conservative here\n+                    0\n+                } else {\n+                    // by dividing by 1, we remove 0 bits, etc.\n+                    get_constant_bits(cx, right).map_or(0, |b| b.saturating_sub(1))\n+                })\n             },\n             BinOpKind::Rem | BinOpKind::BitAnd => get_constant_bits(cx, right)\n                 .unwrap_or(u64::max_value())\n                 .min(apply_reductions(cx, nbits, left, signed)),\n-            BinOpKind::Shr => {\n-                apply_reductions(cx, nbits, left, signed)\n-                    - constant_int(cx, right).map_or(0, |s| u64::try_from(s).expect(\"shift too high\"))\n-            },\n+            BinOpKind::Shr => apply_reductions(cx, nbits, left, signed)\n+                .saturating_sub(constant_int(cx, right).map_or(0, |s| u64::try_from(s).expect(\"shift too high\"))),\n             _ => nbits,\n         },\n         ExprKind::MethodCall(method, [left, right], _) => {\n@@ -75,8 +76,8 @@ fn apply_reductions(cx: &LateContext<'_>, nbits: u64, expr: &Expr<'_>, signed: b\n }\n \n pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_expr: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n-    let msg = match (cast_from.is_integral(), cast_to.is_integral()) {\n-        (true, true) => {\n+    let msg = match (cast_from.kind(), cast_to.is_integral()) {\n+        (ty::Int(_) | ty::Uint(_), true) => {\n             let from_nbits = apply_reductions(\n                 cx,\n                 utils::int_ty_to_nbits(cast_from, cx.tcx),\n@@ -108,19 +109,60 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_expr: &Expr<'_>,\n             )\n         },\n \n-        (false, true) => {\n-            format!(\"casting `{}` to `{}` may truncate the value\", cast_from, cast_to)\n-        },\n-\n-        (_, _) => {\n-            if matches!(cast_from.kind(), &ty::Float(FloatTy::F64))\n-                && matches!(cast_to.kind(), &ty::Float(FloatTy::F32))\n+        (ty::Adt(def, _), true) if def.is_enum() => {\n+            let (from_nbits, variant) = if let ExprKind::Path(p) = &cast_expr.kind\n+                && let Res::Def(DefKind::Ctor(..), id) = cx.qpath_res(p, cast_expr.hir_id)\n             {\n-                \"casting `f64` to `f32` may truncate the value\".to_string()\n+                let i = def.variant_index_with_ctor_id(id);\n+                let variant = def.variant(i);\n+                let nbits = utils::enum_value_nbits(get_discriminant_value(cx.tcx, *def, i));\n+                (nbits, Some(variant))\n             } else {\n+                (utils::enum_ty_to_nbits(*def, cx.tcx), None)\n+            };\n+            let to_nbits = utils::int_ty_to_nbits(cast_to, cx.tcx);\n+\n+            let cast_from_ptr_size = def.repr().int.map_or(true, |ty| {\n+                matches!(\n+                    ty,\n+                    IntType::SignedInt(ast::IntTy::Isize) | IntType::UnsignedInt(ast::UintTy::Usize)\n+                )\n+            });\n+            let suffix = match (cast_from_ptr_size, is_isize_or_usize(cast_to)) {\n+                (false, false) if from_nbits > to_nbits => \"\",\n+                (true, false) if from_nbits > to_nbits => \"\",\n+                (false, true) if from_nbits > 64 => \"\",\n+                (false, true) if from_nbits > 32 => \" on targets with 32-bit wide pointers\",\n+                _ => return,\n+            };\n+\n+            if let Some(variant) = variant {\n+                span_lint(\n+                    cx,\n+                    CAST_ENUM_TRUNCATION,\n+                    expr.span,\n+                    &format!(\n+                        \"casting `{}::{}` to `{}` will truncate the value{}\",\n+                        cast_from, variant.name, cast_to, suffix,\n+                    ),\n+                );\n                 return;\n             }\n+            format!(\n+                \"casting `{}` to `{}` may truncate the value{}\",\n+                cast_from, cast_to, suffix,\n+            )\n+        },\n+\n+        (ty::Float(_), true) => {\n+            format!(\"casting `{}` to `{}` may truncate the value\", cast_from, cast_to)\n         },\n+\n+        (ty::Float(FloatTy::F64), false) if matches!(cast_to.kind(), &ty::Float(FloatTy::F32)) => {\n+            \"casting `f64` to `f32` may truncate the value\".to_string()\n+        },\n+\n+        _ => return,\n     };\n \n     span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span, &msg);"}, {"sha": "d476a1a7646c01e24bd8ea9b3df3297ec980fdba", "filename": "clippy_lints/src/casts/cast_ptr_alignment.rs", "status": "modified", "additions": 64, "deletions": 48, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,11 +1,10 @@\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::is_hir_ty_cfg_dependant;\n-use if_chain::if_chain;\n+use clippy_utils::ty::is_c_void;\n+use clippy_utils::{get_parent_expr, is_hir_ty_cfg_dependant, match_any_def_paths, paths};\n use rustc_hir::{Expr, ExprKind, GenericArg};\n use rustc_lint::LateContext;\n use rustc_middle::ty::layout::LayoutOf;\n use rustc_middle::ty::{self, Ty};\n-use rustc_span::symbol::sym;\n \n use super::CAST_PTR_ALIGNMENT;\n \n@@ -20,61 +19,78 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         );\n         lint_cast_ptr_alignment(cx, expr, cast_from, cast_to);\n     } else if let ExprKind::MethodCall(method_path, [self_arg, ..], _) = &expr.kind {\n-        if_chain! {\n-            if method_path.ident.name == sym!(cast);\n-            if let Some(generic_args) = method_path.args;\n-            if let [GenericArg::Type(cast_to)] = generic_args.args;\n+        if method_path.ident.name == sym!(cast)\n+            && let Some(generic_args) = method_path.args\n+            && let [GenericArg::Type(cast_to)] = generic_args.args\n             // There probably is no obvious reason to do this, just to be consistent with `as` cases.\n-            if !is_hir_ty_cfg_dependant(cx, cast_to);\n-            then {\n-                let (cast_from, cast_to) =\n-                    (cx.typeck_results().expr_ty(self_arg), cx.typeck_results().expr_ty(expr));\n-                lint_cast_ptr_alignment(cx, expr, cast_from, cast_to);\n-            }\n+            && !is_hir_ty_cfg_dependant(cx, cast_to)\n+        {\n+            let (cast_from, cast_to) =\n+                (cx.typeck_results().expr_ty(self_arg), cx.typeck_results().expr_ty(expr));\n+            lint_cast_ptr_alignment(cx, expr, cast_from, cast_to);\n         }\n     }\n }\n \n fn lint_cast_ptr_alignment<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, cast_from: Ty<'tcx>, cast_to: Ty<'tcx>) {\n-    if_chain! {\n-        if let ty::RawPtr(from_ptr_ty) = &cast_from.kind();\n-        if let ty::RawPtr(to_ptr_ty) = &cast_to.kind();\n-        if let Ok(from_layout) = cx.layout_of(from_ptr_ty.ty);\n-        if let Ok(to_layout) = cx.layout_of(to_ptr_ty.ty);\n-        if from_layout.align.abi < to_layout.align.abi;\n+    if let ty::RawPtr(from_ptr_ty) = &cast_from.kind()\n+        && let ty::RawPtr(to_ptr_ty) = &cast_to.kind()\n+        && let Ok(from_layout) = cx.layout_of(from_ptr_ty.ty)\n+        && let Ok(to_layout) = cx.layout_of(to_ptr_ty.ty)\n+        && from_layout.align.abi < to_layout.align.abi\n         // with c_void, we inherently need to trust the user\n-        if !is_c_void(cx, from_ptr_ty.ty);\n+        && !is_c_void(cx, from_ptr_ty.ty)\n         // when casting from a ZST, we don't know enough to properly lint\n-        if !from_layout.is_zst();\n-        then {\n-            span_lint(\n-                cx,\n-                CAST_PTR_ALIGNMENT,\n-                expr.span,\n-                &format!(\n-                    \"casting from `{}` to a more-strictly-aligned pointer (`{}`) ({} < {} bytes)\",\n-                    cast_from,\n-                    cast_to,\n-                    from_layout.align.abi.bytes(),\n-                    to_layout.align.abi.bytes(),\n-                ),\n-            );\n-        }\n+        && !from_layout.is_zst()\n+        && !is_used_as_unaligned(cx, expr)\n+    {\n+        span_lint(\n+            cx,\n+            CAST_PTR_ALIGNMENT,\n+            expr.span,\n+            &format!(\n+                \"casting from `{}` to a more-strictly-aligned pointer (`{}`) ({} < {} bytes)\",\n+                cast_from,\n+                cast_to,\n+                from_layout.align.abi.bytes(),\n+                to_layout.align.abi.bytes(),\n+            ),\n+        );\n     }\n }\n \n-/// Check if the given type is either `core::ffi::c_void` or\n-/// one of the platform specific `libc::<platform>::c_void` of libc.\n-fn is_c_void(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n-    if let ty::Adt(adt, _) = ty.kind() {\n-        let names = cx.get_def_path(adt.did);\n-\n-        if names.is_empty() {\n-            return false;\n-        }\n-        if names[0] == sym::libc || names[0] == sym::core && *names.last().unwrap() == sym!(c_void) {\n-            return true;\n-        }\n+fn is_used_as_unaligned(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n+    let Some(parent) = get_parent_expr(cx, e) else {\n+        return false;\n+    };\n+    match parent.kind {\n+        ExprKind::MethodCall(name, [self_arg, ..], _) if self_arg.hir_id == e.hir_id => {\n+            if matches!(name.ident.as_str(), \"read_unaligned\" | \"write_unaligned\")\n+                && let Some(def_id) = cx.typeck_results().type_dependent_def_id(parent.hir_id)\n+                && let Some(def_id) = cx.tcx.impl_of_method(def_id)\n+                && cx.tcx.type_of(def_id).is_unsafe_ptr()\n+            {\n+                true\n+            } else {\n+                false\n+            }\n+        },\n+        ExprKind::Call(func, [arg, ..]) if arg.hir_id == e.hir_id => {\n+            static PATHS: &[&[&str]] = &[\n+                paths::PTR_READ_UNALIGNED.as_slice(),\n+                paths::PTR_WRITE_UNALIGNED.as_slice(),\n+                paths::PTR_UNALIGNED_VOLATILE_LOAD.as_slice(),\n+                paths::PTR_UNALIGNED_VOLATILE_STORE.as_slice(),\n+            ];\n+            if let ExprKind::Path(path) = &func.kind\n+                && let Some(def_id) = cx.qpath_res(path, func.hir_id).opt_def_id()\n+                && match_any_def_paths(cx, def_id, PATHS).is_some()\n+            {\n+                true\n+            } else {\n+                false\n+            }\n+        },\n+        _ => false,\n     }\n-    false\n }"}, {"sha": "027c660ce3b2484014a2f5ea39df937f0cf93df8", "filename": "clippy_lints/src/casts/cast_slice_different_sizes.rs", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcasts%2Fcast_slice_different_sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcasts%2Fcast_slice_different_sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_slice_different_sizes.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,143 @@\n+use clippy_utils::{diagnostics::span_lint_and_then, meets_msrv, msrvs, source};\n+use if_chain::if_chain;\n+use rustc_ast::Mutability;\n+use rustc_hir::{Expr, ExprKind, Node};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, layout::LayoutOf, Ty, TypeAndMut};\n+use rustc_semver::RustcVersion;\n+\n+use super::CAST_SLICE_DIFFERENT_SIZES;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>, msrv: Option<RustcVersion>) {\n+    // suggestion is invalid if `ptr::slice_from_raw_parts` does not exist\n+    if !meets_msrv(msrv, msrvs::PTR_SLICE_RAW_PARTS) {\n+        return;\n+    }\n+\n+    // if this cast is the child of another cast expression then don't emit something for it, the full\n+    // chain will be analyzed\n+    if is_child_of_cast(cx, expr) {\n+        return;\n+    }\n+\n+    if let Some(CastChainInfo {\n+        left_cast,\n+        start_ty,\n+        end_ty,\n+    }) = expr_cast_chain_tys(cx, expr)\n+    {\n+        if let (Ok(from_layout), Ok(to_layout)) = (cx.layout_of(start_ty.ty), cx.layout_of(end_ty.ty)) {\n+            let from_size = from_layout.size.bytes();\n+            let to_size = to_layout.size.bytes();\n+            if from_size != to_size && from_size != 0 && to_size != 0 {\n+                span_lint_and_then(\n+                    cx,\n+                    CAST_SLICE_DIFFERENT_SIZES,\n+                    expr.span,\n+                    &format!(\n+                        \"casting between raw pointers to `[{}]` (element size {}) and `[{}]` (element size {}) does not adjust the count\",\n+                        start_ty.ty, from_size, end_ty.ty, to_size,\n+                    ),\n+                    |diag| {\n+                        let ptr_snippet = source::snippet(cx, left_cast.span, \"..\");\n+\n+                        let (mutbl_fn_str, mutbl_ptr_str) = match end_ty.mutbl {\n+                            Mutability::Mut => (\"_mut\", \"mut\"),\n+                            Mutability::Not => (\"\", \"const\"),\n+                        };\n+                        let sugg = format!(\n+                            \"core::ptr::slice_from_raw_parts{mutbl_fn_str}({ptr_snippet} as *{mutbl_ptr_str} {}, ..)\",\n+                            // get just the ty from the TypeAndMut so that the printed type isn't something like `mut\n+                            // T`, extract just the `T`\n+                            end_ty.ty\n+                        );\n+\n+                        diag.span_suggestion(\n+                            expr.span,\n+                            &format!(\"replace with `ptr::slice_from_raw_parts{mutbl_fn_str}`\"),\n+                            sugg,\n+                            rustc_errors::Applicability::HasPlaceholders,\n+                        );\n+                    },\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+fn is_child_of_cast(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    let map = cx.tcx.hir();\n+    if_chain! {\n+        if let Some(parent_id) = map.find_parent_node(expr.hir_id);\n+        if let Some(parent) = map.find(parent_id);\n+        then {\n+            let expr = match parent {\n+                Node::Block(block) => {\n+                    if let Some(parent_expr) = block.expr {\n+                        parent_expr\n+                    } else {\n+                        return false;\n+                    }\n+                },\n+                Node::Expr(expr) => expr,\n+                _ => return false,\n+            };\n+\n+            matches!(expr.kind, ExprKind::Cast(..))\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+/// Returns the type T of the pointed to *const [T] or *mut [T] and the mutability of the slice if\n+/// the type is one of those slices\n+fn get_raw_slice_ty_mut(ty: Ty<'_>) -> Option<TypeAndMut<'_>> {\n+    match ty.kind() {\n+        ty::RawPtr(TypeAndMut { ty: slice_ty, mutbl }) => match slice_ty.kind() {\n+            ty::Slice(ty) => Some(TypeAndMut { ty: *ty, mutbl: *mutbl }),\n+            _ => None,\n+        },\n+        _ => None,\n+    }\n+}\n+\n+struct CastChainInfo<'tcx> {\n+    /// The left most part of the cast chain, or in other words, the first cast in the chain\n+    /// Used for diagnostics\n+    left_cast: &'tcx Expr<'tcx>,\n+    /// The starting type of the cast chain\n+    start_ty: TypeAndMut<'tcx>,\n+    /// The final type of the cast chain\n+    end_ty: TypeAndMut<'tcx>,\n+}\n+\n+/// Returns a `CastChainInfo` with the left-most cast in the chain and the original ptr T and final\n+/// ptr U if the expression is composed of casts.\n+/// Returns None if the expr is not a Cast\n+fn expr_cast_chain_tys<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) -> Option<CastChainInfo<'tcx>> {\n+    if let ExprKind::Cast(cast_expr, _cast_to_hir_ty) = expr.peel_blocks().kind {\n+        let cast_to = cx.typeck_results().expr_ty(expr);\n+        let to_slice_ty = get_raw_slice_ty_mut(cast_to)?;\n+\n+        // If the expression that makes up the source of this cast is itself a cast, recursively\n+        // call `expr_cast_chain_tys` and update the end type with the final target type.\n+        // Otherwise, this cast is not immediately nested, just construct the info for this cast\n+        if let Some(prev_info) = expr_cast_chain_tys(cx, cast_expr) {\n+            Some(CastChainInfo {\n+                end_ty: to_slice_ty,\n+                ..prev_info\n+            })\n+        } else {\n+            let cast_from = cx.typeck_results().expr_ty(cast_expr);\n+            let from_slice_ty = get_raw_slice_ty_mut(cast_from)?;\n+            Some(CastChainInfo {\n+                left_cast: cast_expr,\n+                start_ty: from_slice_ty,\n+                end_ty: to_slice_ty,\n+            })\n+        }\n+    } else {\n+        None\n+    }\n+}"}, {"sha": "daf3b7b4ce4fec2c5dcc0ee446d327dc9e618fd7", "filename": "clippy_lints/src/casts/mod.rs", "status": "modified", "additions": 124, "deletions": 6, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,10 +1,13 @@\n+mod cast_abs_to_unsigned;\n+mod cast_enum_constructor;\n mod cast_lossless;\n mod cast_possible_truncation;\n mod cast_possible_wrap;\n mod cast_precision_loss;\n mod cast_ptr_alignment;\n mod cast_ref_to_mut;\n mod cast_sign_loss;\n+mod cast_slice_different_sizes;\n mod char_lit_as_u8;\n mod fn_to_numeric_cast;\n mod fn_to_numeric_cast_any;\n@@ -267,7 +270,7 @@ declare_clippy_lint! {\n     ///\n     /// ### Why is this bad?\n     /// Casting a function pointer to an integer can have surprising results and can occur\n-    /// accidentally if parantheses are omitted from a function call. If you aren't doing anything\n+    /// accidentally if parentheses are omitted from a function call. If you aren't doing anything\n     /// low-level with function pointers then you can opt-out of casting functions to integers in\n     /// order to avoid mistakes. Alternatively, you can use this lint to audit all uses of function\n     /// pointer casts in your code.\n@@ -303,7 +306,7 @@ declare_clippy_lint! {\n     /// Checks for casts of `&T` to `&mut T` anywhere in the code.\n     ///\n     /// ### Why is this bad?\n-    /// It\u2019s basically guaranteed to be undefined behaviour.\n+    /// It\u2019s basically guaranteed to be undefined behavior.\n     /// `UnsafeCell` is the only way to obtain aliasable data that is considered\n     /// mutable.\n     ///\n@@ -390,6 +393,111 @@ declare_clippy_lint! {\n     \"casting using `as` from and to raw pointers that doesn't change its mutability, where `pointer::cast` could take the place of `as`\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for casts from an enum type to an integral type which will definitely truncate the\n+    /// value.\n+    ///\n+    /// ### Why is this bad?\n+    /// The resulting integral value will not match the value of the variant it came from.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// enum E { X = 256 };\n+    /// let _ = E::X as u8;\n+    /// ```\n+    #[clippy::version = \"1.60.0\"]\n+    pub CAST_ENUM_TRUNCATION,\n+    suspicious,\n+    \"casts from an enum type to an integral type which will truncate the value\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `as` casts between raw pointers to slices with differently sized elements.\n+    ///\n+    /// ### Why is this bad?\n+    /// The produced raw pointer to a slice does not update its length metadata. The produced\n+    /// pointer will point to a different number of bytes than the original pointer because the\n+    /// length metadata of a raw slice pointer is in elements rather than bytes.\n+    /// Producing a slice reference from the raw pointer will either create a slice with\n+    /// less data (which can be surprising) or create a slice with more data and cause Undefined Behavior.\n+    ///\n+    /// ### Example\n+    /// // Missing data\n+    /// ```rust\n+    /// let a = [1_i32, 2, 3, 4];\n+    /// let p = &a as *const [i32] as *const [u8];\n+    /// unsafe {\n+    ///     println!(\"{:?}\", &*p);\n+    /// }\n+    /// ```\n+    /// // Undefined Behavior (note: also potential alignment issues)\n+    /// ```rust\n+    /// let a = [1_u8, 2, 3, 4];\n+    /// let p = &a as *const [u8] as *const [u32];\n+    /// unsafe {\n+    ///     println!(\"{:?}\", &*p);\n+    /// }\n+    /// ```\n+    /// Instead use `ptr::slice_from_raw_parts` to construct a slice from a data pointer and the correct length\n+    /// ```rust\n+    /// let a = [1_i32, 2, 3, 4];\n+    /// let old_ptr = &a as *const [i32];\n+    /// // The data pointer is cast to a pointer to the target `u8` not `[u8]`\n+    /// // The length comes from the known length of 4 i32s times the 4 bytes per i32\n+    /// let new_ptr = core::ptr::slice_from_raw_parts(old_ptr as *const u8, 16);\n+    /// unsafe {\n+    ///     println!(\"{:?}\", &*new_ptr);\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.60.0\"]\n+    pub CAST_SLICE_DIFFERENT_SIZES,\n+    correctness,\n+    \"casting using `as` between raw pointers to slices of types with different sizes\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for casts from an enum tuple constructor to an integer.\n+    ///\n+    /// ### Why is this bad?\n+    /// The cast is easily confused with casting a c-like enum value to an integer.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// enum E { X(i32) };\n+    /// let _ = E::X as usize;\n+    /// ```\n+    #[clippy::version = \"1.61.0\"]\n+    pub CAST_ENUM_CONSTRUCTOR,\n+    suspicious,\n+    \"casts from an enum tuple constructor to an integer\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for uses of the `abs()` method that cast the result to unsigned.\n+    ///\n+    /// ### Why is this bad?\n+    /// The `unsigned_abs()` method avoids panic when called on the MIN value.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x: i32 = -42;\n+    /// let y: u32 = x.abs() as u32;\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let x: i32 = -42;\n+    /// let y: u32 = x.unsigned_abs();\n+    /// ```\n+    #[clippy::version = \"1.61.0\"]\n+    pub CAST_ABS_TO_UNSIGNED,\n+    suspicious,\n+    \"casting the result of `abs()` to an unsigned integer can panic\"\n+}\n+\n pub struct Casts {\n     msrv: Option<RustcVersion>,\n }\n@@ -409,16 +517,24 @@ impl_lint_pass!(Casts => [\n     CAST_LOSSLESS,\n     CAST_REF_TO_MUT,\n     CAST_PTR_ALIGNMENT,\n+    CAST_SLICE_DIFFERENT_SIZES,\n     UNNECESSARY_CAST,\n     FN_TO_NUMERIC_CAST_ANY,\n     FN_TO_NUMERIC_CAST,\n     FN_TO_NUMERIC_CAST_WITH_TRUNCATION,\n     CHAR_LIT_AS_U8,\n     PTR_AS_PTR,\n+    CAST_ENUM_TRUNCATION,\n+    CAST_ENUM_CONSTRUCTOR,\n+    CAST_ABS_TO_UNSIGNED\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Casts {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if !in_external_macro(cx.sess(), expr.span) {\n+            ptr_as_ptr::check(cx, expr, self.msrv);\n+        }\n+\n         if expr.span.from_expansion() {\n             return;\n         }\n@@ -441,21 +557,23 @@ impl<'tcx> LateLintPass<'tcx> for Casts {\n             fn_to_numeric_cast_with_truncation::check(cx, expr, cast_expr, cast_from, cast_to);\n \n             if cast_to.is_numeric() && !in_external_macro(cx.sess(), expr.span) {\n+                cast_possible_truncation::check(cx, expr, cast_expr, cast_from, cast_to);\n                 if cast_from.is_numeric() {\n-                    cast_possible_truncation::check(cx, expr, cast_expr, cast_from, cast_to);\n                     cast_possible_wrap::check(cx, expr, cast_from, cast_to);\n                     cast_precision_loss::check(cx, expr, cast_from, cast_to);\n                     cast_sign_loss::check(cx, expr, cast_expr, cast_from, cast_to);\n+                    cast_abs_to_unsigned::check(cx, expr, cast_expr, cast_from, cast_to, self.msrv);\n                 }\n-\n-                cast_lossless::check(cx, expr, cast_expr, cast_from, cast_to, &self.msrv);\n+                cast_lossless::check(cx, expr, cast_expr, cast_from, cast_to, self.msrv);\n+                cast_enum_constructor::check(cx, expr, cast_expr, cast_from);\n             }\n         }\n \n         cast_ref_to_mut::check(cx, expr);\n         cast_ptr_alignment::check(cx, expr);\n         char_lit_as_u8::check(cx, expr);\n-        ptr_as_ptr::check(cx, expr, &self.msrv);\n+        ptr_as_ptr::check(cx, expr, self.msrv);\n+        cast_slice_different_sizes::check(cx, expr, self.msrv);\n     }\n \n     extract_msrv_attr!(LateContext);"}, {"sha": "46d45d09661ae6d220eeebe2ab2d1c276a423deb", "filename": "clippy_lints/src/casts/ptr_as_ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcasts%2Fptr_as_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcasts%2Fptr_as_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fptr_as_ptr.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -12,8 +12,8 @@ use rustc_semver::RustcVersion;\n \n use super::PTR_AS_PTR;\n \n-pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, msrv: &Option<RustcVersion>) {\n-    if !meets_msrv(msrv.as_ref(), &msrvs::POINTER_CAST) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, msrv: Option<RustcVersion>) {\n+    if !meets_msrv(msrv, msrvs::POINTER_CAST) {\n         return;\n     }\n "}, {"sha": "af56ec11ef8acd741ec4a8a45926d8fd2656e36a", "filename": "clippy_lints/src/casts/unnecessary_cast.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcasts%2Funnecessary_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcasts%2Funnecessary_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Funnecessary_cast.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -4,7 +4,8 @@ use clippy_utils::source::snippet_opt;\n use if_chain::if_chain;\n use rustc_ast::{LitFloatType, LitIntType, LitKind};\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, Lit, UnOp};\n+use rustc_hir::def::Res;\n+use rustc_hir::{Expr, ExprKind, Lit, QPath, TyKind, UnOp};\n use rustc_lint::{LateContext, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, FloatTy, InferTy, Ty};\n@@ -18,6 +19,17 @@ pub(super) fn check(\n     cast_from: Ty<'_>,\n     cast_to: Ty<'_>,\n ) -> bool {\n+    // skip non-primitive type cast\n+    if_chain! {\n+        if let ExprKind::Cast(_, cast_to) = expr.kind;\n+        if let TyKind::Path(QPath::Resolved(_, path)) = &cast_to.kind;\n+        if let Res::PrimTy(_) = path.res;\n+        then {}\n+        else {\n+            return false\n+        }\n+    }\n+\n     if let Some(lit) = get_numeric_literal(cast_expr) {\n         let literal_str = snippet_opt(cx, cast_expr.span).unwrap_or_default();\n "}, {"sha": "5a4f20f099060c7f911c3cf4e5e10937b59547f4", "filename": "clippy_lints/src/casts/utils.rs", "status": "modified", "additions": 51, "deletions": 1, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcasts%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcasts%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Futils.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,4 +1,5 @@\n-use rustc_middle::ty::{self, IntTy, Ty, TyCtxt, UintTy};\n+use clippy_utils::ty::{read_explicit_enum_value, EnumValue};\n+use rustc_middle::ty::{self, AdtDef, IntTy, Ty, TyCtxt, UintTy, VariantDiscr};\n \n /// Returns the size in bits of an integral type.\n /// Will return 0 if the type is not an int or uint variant\n@@ -23,3 +24,52 @@ pub(super) fn int_ty_to_nbits(typ: Ty<'_>, tcx: TyCtxt<'_>) -> u64 {\n         _ => 0,\n     }\n }\n+\n+pub(super) fn enum_value_nbits(value: EnumValue) -> u64 {\n+    match value {\n+        EnumValue::Unsigned(x) => 128 - x.leading_zeros(),\n+        EnumValue::Signed(x) if x < 0 => 128 - (-(x + 1)).leading_zeros() + 1,\n+        EnumValue::Signed(x) => 128 - x.leading_zeros(),\n+    }\n+    .into()\n+}\n+\n+pub(super) fn enum_ty_to_nbits(adt: AdtDef<'_>, tcx: TyCtxt<'_>) -> u64 {\n+    let mut explicit = 0i128;\n+    let (start, end) = adt\n+        .variants()\n+        .iter()\n+        .fold((0, i128::MIN), |(start, end), variant| match variant.discr {\n+            VariantDiscr::Relative(x) => match explicit.checked_add(i128::from(x)) {\n+                Some(x) => (start, end.max(x)),\n+                None => (i128::MIN, end),\n+            },\n+            VariantDiscr::Explicit(id) => match read_explicit_enum_value(tcx, id) {\n+                Some(EnumValue::Signed(x)) => {\n+                    explicit = x;\n+                    (start.min(x), end.max(x))\n+                },\n+                Some(EnumValue::Unsigned(x)) => match i128::try_from(x) {\n+                    Ok(x) => {\n+                        explicit = x;\n+                        (start, end.max(x))\n+                    },\n+                    Err(_) => (i128::MIN, end),\n+                },\n+                None => (start, end),\n+            },\n+        });\n+\n+    if start > end {\n+        // No variants.\n+        0\n+    } else {\n+        let neg_bits = if start < 0 {\n+            128 - (-(start + 1)).leading_zeros() + 1\n+        } else {\n+            0\n+        };\n+        let pos_bits = if end > 0 { 128 - end.leading_zeros() } else { 0 };\n+        neg_bits.max(pos_bits).into()\n+    }\n+}"}, {"sha": "7eeaaa0192147d822ab50be86d1238b044adce0a", "filename": "clippy_lints/src/checked_conversions.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fchecked_conversions.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -30,7 +30,6 @@ declare_clippy_lint! {\n     /// Could be written:\n     ///\n     /// ```rust\n-    /// # use std::convert::TryFrom;\n     /// # let foo = 1;\n     /// # let _ =\n     /// i32::try_from(foo).is_ok()\n@@ -57,7 +56,7 @@ impl_lint_pass!(CheckedConversions => [CHECKED_CONVERSIONS]);\n \n impl<'tcx> LateLintPass<'tcx> for CheckedConversions {\n     fn check_expr(&mut self, cx: &LateContext<'_>, item: &Expr<'_>) {\n-        if !meets_msrv(self.msrv.as_ref(), &msrvs::TRY_FROM) {\n+        if !meets_msrv(self.msrv, msrvs::TRY_FROM) {\n             return;\n         }\n \n@@ -123,7 +122,7 @@ struct Conversion<'a> {\n }\n \n /// The kind of conversion that is checked\n-#[derive(Copy, Clone, Debug, PartialEq)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n enum ConversionType {\n     SignedToUnsigned,\n     SignedToSigned,"}, {"sha": "317c4bfb3226ef1f5209a23ff6ee1b56d2b540f9", "filename": "clippy_lints/src/cognitive_complexity.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcognitive_complexity.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -48,7 +48,7 @@ impl CognitiveComplexity {\n impl_lint_pass!(CognitiveComplexity => [COGNITIVE_COMPLEXITY]);\n \n impl CognitiveComplexity {\n-    #[allow(clippy::cast_possible_truncation)]\n+    #[expect(clippy::cast_possible_truncation)]\n     fn check<'tcx>(\n         &mut self,\n         cx: &LateContext<'tcx>,\n@@ -70,7 +70,7 @@ impl CognitiveComplexity {\n         let ret_adjust = if is_type_diagnostic_item(cx, ret_ty, sym::Result) {\n             returns\n         } else {\n-            #[allow(clippy::integer_division)]\n+            #[expect(clippy::integer_division)]\n             (returns / 2)\n         };\n \n@@ -82,7 +82,7 @@ impl CognitiveComplexity {\n \n         if rust_cc > self.limit.limit() {\n             let fn_span = match kind {\n-                FnKind::ItemFn(ident, _, _, _) | FnKind::Method(ident, _, _) => ident.span,\n+                FnKind::ItemFn(ident, _, _) | FnKind::Method(ident, _) => ident.span,\n                 FnKind::Closure => {\n                     let header_span = body_span.with_hi(decl.output.span().lo());\n                     let pos = snippet_opt(cx, header_span).and_then(|snip| {"}, {"sha": "3227e6e86af4e3021c3b97c28655437536f12f2c", "filename": "clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -13,13 +13,14 @@\n //! This lint is **warn** by default\n \n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n-use clippy_utils::source::{snippet_block, snippet_block_with_applicability};\n+use clippy_utils::source::{snippet, snippet_block, snippet_block_with_applicability};\n use clippy_utils::sugg::Sugg;\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::Span;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -42,7 +43,7 @@ declare_clippy_lint! {\n     ///\n     /// Should be written:\n     ///\n-    /// ```rust.ignore\n+    /// ```rust,ignore\n     /// if x && y {\n     ///     \u2026\n     /// }\n@@ -76,7 +77,7 @@ declare_clippy_lint! {\n     ///\n     /// Should be written:\n     ///\n-    /// ```rust.ignore\n+    /// ```rust,ignore\n     /// if x {\n     ///     \u2026\n     /// } else if y {\n@@ -102,7 +103,7 @@ impl EarlyLintPass for CollapsibleIf {\n fn check_if(cx: &EarlyContext<'_>, expr: &ast::Expr) {\n     if let ast::ExprKind::If(check, then, else_) = &expr.kind {\n         if let Some(else_) = else_ {\n-            check_collapsible_maybe_if_let(cx, else_);\n+            check_collapsible_maybe_if_let(cx, then.span, else_);\n         } else if let ast::ExprKind::Let(..) = check.kind {\n             // Prevent triggering on `if let a = b { if c { .. } }`.\n         } else {\n@@ -119,7 +120,7 @@ fn block_starts_with_comment(cx: &EarlyContext<'_>, expr: &ast::Block) -> bool {\n     trimmed_block_text.starts_with(\"//\") || trimmed_block_text.starts_with(\"/*\")\n }\n \n-fn check_collapsible_maybe_if_let(cx: &EarlyContext<'_>, else_: &ast::Expr) {\n+fn check_collapsible_maybe_if_let(cx: &EarlyContext<'_>, then_span: Span, else_: &ast::Expr) {\n     if_chain! {\n         if let ast::ExprKind::Block(ref block, _) = else_.kind;\n         if !block_starts_with_comment(cx, block);\n@@ -128,14 +129,23 @@ fn check_collapsible_maybe_if_let(cx: &EarlyContext<'_>, else_: &ast::Expr) {\n         if !else_.span.from_expansion();\n         if let ast::ExprKind::If(..) = else_.kind;\n         then {\n+            // Prevent \"elseif\"\n+            // Check that the \"else\" is followed by whitespace\n+            let up_to_else = then_span.between(block.span);\n+            let requires_space = if let Some(c) = snippet(cx, up_to_else, \"..\").chars().last() { !c.is_whitespace() } else { false };\n+\n             let mut applicability = Applicability::MachineApplicable;\n             span_lint_and_sugg(\n                 cx,\n                 COLLAPSIBLE_ELSE_IF,\n                 block.span,\n                 \"this `else { if .. }` block can be collapsed\",\n                 \"collapse nested if block\",\n-                snippet_block_with_applicability(cx, else_.span, \"..\", Some(block.span), &mut applicability).into_owned(),\n+                format!(\n+                    \"{}{}\",\n+                    if requires_space { \" \" } else { \"\" },\n+                    snippet_block_with_applicability(cx, else_.span, \"..\", Some(block.span), &mut applicability)\n+                ),\n                 applicability,\n             );\n         }"}, {"sha": "ec55009f347d3704df40e3ca6c9402dec3acd51c", "filename": "clippy_lints/src/collapsible_match.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_match.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -3,11 +3,12 @@ use clippy_utils::higher::IfLetOrMatch;\n use clippy_utils::visitors::is_local_used;\n use clippy_utils::{is_lang_ctor, is_unit_expr, path_to_local, peel_blocks_with_stmt, peel_ref_operators, SpanlessEq};\n use if_chain::if_chain;\n+use rustc_errors::MultiSpan;\n use rustc_hir::LangItem::OptionNone;\n-use rustc_hir::{Arm, Expr, Guard, HirId, Pat, PatKind};\n+use rustc_hir::{Arm, Expr, Guard, HirId, Let, Pat, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::{MultiSpan, Span};\n+use rustc_span::Span;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -108,7 +109,10 @@ fn check_arm<'tcx>(\n             (Some(a), Some(b)) => SpanlessEq::new(cx).eq_expr(a, b),\n         };\n         // the binding must not be used in the if guard\n-        if outer_guard.map_or(true, |(Guard::If(e) | Guard::IfLet(_, e))| !is_local_used(cx, *e, binding_id));\n+        if outer_guard.map_or(\n+            true,\n+            |(Guard::If(e) | Guard::IfLet(Let { init: e, .. }))| !is_local_used(cx, *e, binding_id)\n+        );\n         // ...or anywhere in the inner expression\n         if match inner {\n             IfLetOrMatch::IfLet(_, _, body, els) => {\n@@ -129,8 +133,8 @@ fn check_arm<'tcx>(\n                 &msg,\n                 |diag| {\n                     let mut help_span = MultiSpan::from_spans(vec![binding_span, inner_then_pat.span]);\n-                    help_span.push_span_label(binding_span, \"replace this binding\".into());\n-                    help_span.push_span_label(inner_then_pat.span, \"with this pattern\".into());\n+                    help_span.push_span_label(binding_span, \"replace this binding\");\n+                    help_span.push_span_label(inner_then_pat.span, \"with this pattern\");\n                     diag.span_help(help_span, \"the outer pattern can be modified to include the inner pattern\");\n                 },\n             );"}, {"sha": "e6a0162fd02728d5c205996b2a34c0500756dba6", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -6,7 +6,7 @@ use clippy_utils::{\n };\n use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{Block, Expr, ExprKind, HirId};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -126,7 +126,7 @@ declare_clippy_lint! {\n     /// Duplicate code is less maintainable.\n     ///\n     /// ### Known problems\n-    /// * The lint doesn't check if the moved expressions modify values that are beeing used in\n+    /// * The lint doesn't check if the moved expressions modify values that are being used in\n     ///   the if condition. The suggestion can in that case modify the behavior of the program.\n     ///   See [rust-clippy#7452](https://github.com/rust-lang/rust-clippy/issues/7452)\n     ///\n@@ -489,7 +489,7 @@ fn emit_branches_sharing_code_lint(\n         add_expr_note = !cx.typeck_results().expr_ty(if_expr).is_unit();\n     }\n \n-    let add_optional_msgs = |diag: &mut DiagnosticBuilder<'_>| {\n+    let add_optional_msgs = |diag: &mut Diagnostic| {\n         if add_expr_note {\n             diag.note(\"The end suggestion probably needs some adjustments to use the expression result correctly\");\n         }"}, {"sha": "fc141b4a6e3afcc3874b5c776be3cfb88303bdfc", "filename": "clippy_lints/src/crate_in_macro_def.rs", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcrate_in_macro_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fcrate_in_macro_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcrate_in_macro_def.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,125 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use rustc_ast::ast::{AttrKind, Attribute, Item, ItemKind};\n+use rustc_ast::token::{Token, TokenKind};\n+use rustc_ast::tokenstream::{TokenStream, TokenTree};\n+use rustc_errors::Applicability;\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::{symbol::sym, Span};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for use of `crate` as opposed to `$crate` in a macro definition.\n+    ///\n+    /// ### Why is this bad?\n+    /// `crate` refers to the macro call's crate, whereas `$crate` refers to the macro definition's\n+    /// crate. Rarely is the former intended. See:\n+    /// https://doc.rust-lang.org/reference/macros-by-example.html#hygiene\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// #[macro_export]\n+    /// macro_rules! print_message {\n+    ///     () => {\n+    ///         println!(\"{}\", crate::MESSAGE);\n+    ///     };\n+    /// }\n+    /// pub const MESSAGE: &str = \"Hello!\";\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// #[macro_export]\n+    /// macro_rules! print_message {\n+    ///     () => {\n+    ///         println!(\"{}\", $crate::MESSAGE);\n+    ///     };\n+    /// }\n+    /// pub const MESSAGE: &str = \"Hello!\";\n+    /// ```\n+    ///\n+    /// Note that if the use of `crate` is intentional, an `allow` attribute can be applied to the\n+    /// macro definition, e.g.:\n+    /// ```rust,ignore\n+    /// #[allow(clippy::crate_in_macro_def)]\n+    /// macro_rules! ok { ... crate::foo ... }\n+    /// ```\n+    #[clippy::version = \"1.61.0\"]\n+    pub CRATE_IN_MACRO_DEF,\n+    suspicious,\n+    \"using `crate` in a macro definition\"\n+}\n+declare_lint_pass!(CrateInMacroDef => [CRATE_IN_MACRO_DEF]);\n+\n+impl EarlyLintPass for CrateInMacroDef {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n+        if_chain! {\n+            if item.attrs.iter().any(is_macro_export);\n+            if let ItemKind::MacroDef(macro_def) = &item.kind;\n+            let tts = macro_def.body.inner_tokens();\n+            if let Some(span) = contains_unhygienic_crate_reference(&tts);\n+            then {\n+                span_lint_and_sugg(\n+                    cx,\n+                    CRATE_IN_MACRO_DEF,\n+                    span,\n+                    \"`crate` references the macro call's crate\",\n+                    \"to reference the macro definition's crate, use\",\n+                    String::from(\"$crate\"),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+fn is_macro_export(attr: &Attribute) -> bool {\n+    if_chain! {\n+        if let AttrKind::Normal(attr_item, _) = &attr.kind;\n+        if let [segment] = attr_item.path.segments.as_slice();\n+        then {\n+            segment.ident.name == sym::macro_export\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+fn contains_unhygienic_crate_reference(tts: &TokenStream) -> Option<Span> {\n+    let mut prev_is_dollar = false;\n+    let mut cursor = tts.trees();\n+    while let Some(curr) = cursor.next() {\n+        if_chain! {\n+            if !prev_is_dollar;\n+            if let Some(span) = is_crate_keyword(&curr);\n+            if let Some(next) = cursor.look_ahead(0);\n+            if is_token(next, &TokenKind::ModSep);\n+            then {\n+                return Some(span);\n+            }\n+        }\n+        if let TokenTree::Delimited(_, _, tts) = &curr {\n+            let span = contains_unhygienic_crate_reference(tts);\n+            if span.is_some() {\n+                return span;\n+            }\n+        }\n+        prev_is_dollar = is_token(&curr, &TokenKind::Dollar);\n+    }\n+    None\n+}\n+\n+fn is_crate_keyword(tt: &TokenTree) -> Option<Span> {\n+    if_chain! {\n+        if let TokenTree::Token(Token { kind: TokenKind::Ident(symbol, _), span }) = tt;\n+        if symbol.as_str() == \"crate\";\n+        then { Some(*span) } else { None }\n+    }\n+}\n+\n+fn is_token(tt: &TokenTree, kind: &TokenKind) -> bool {\n+    if let TokenTree::Token(Token { kind: other, .. }) = tt {\n+        kind == other\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "17deccf8c3930b4fbc6f4ffc7e1077181345a010", "filename": "clippy_lints/src/dbg_macro.rs", "status": "modified", "additions": 71, "deletions": 46, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fdbg_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fdbg_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdbg_macro.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,11 +1,12 @@\n-use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg};\n-use clippy_utils::source::snippet_opt;\n-use rustc_ast::ast;\n-use rustc_ast::tokenstream::TokenStream;\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::macros::root_macro_call_first_node;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::{is_in_cfg_test, is_in_test_function};\n use rustc_errors::Applicability;\n-use rustc_lint::{EarlyContext, EarlyLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Span;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -15,14 +16,6 @@ declare_clippy_lint! {\n     /// `dbg!` macro is intended as a debugging tool. It\n     /// should not be in version control.\n     ///\n-    /// ### Known problems\n-    /// * The lint level is unaffected by crate attributes. The level can still\n-    ///   be set for functions, modules and other items. To change the level for\n-    ///   the entire crate, please use command line flags. More information and a\n-    ///   configuration example can be found in [clippy#6610].\n-    ///\n-    /// [clippy#6610]: https://github.com/rust-lang/rust-clippy/issues/6610#issuecomment-977120558\n-    ///\n     /// ### Example\n     /// ```rust,ignore\n     /// // Bad\n@@ -37,39 +30,71 @@ declare_clippy_lint! {\n     \"`dbg!` macro is intended as a debugging tool\"\n }\n \n-declare_lint_pass!(DbgMacro => [DBG_MACRO]);\n+#[derive(Copy, Clone)]\n+pub struct DbgMacro {\n+    allow_dbg_in_tests: bool,\n+}\n \n-impl EarlyLintPass for DbgMacro {\n-    fn check_mac(&mut self, cx: &EarlyContext<'_>, mac: &ast::MacCall) {\n-        if mac.path == sym!(dbg) {\n-            if let Some(sugg) = tts_span(mac.args.inner_tokens()).and_then(|span| snippet_opt(cx, span)) {\n-                span_lint_and_sugg(\n-                    cx,\n-                    DBG_MACRO,\n-                    mac.span(),\n-                    \"`dbg!` macro is intended as a debugging tool\",\n-                    \"ensure to avoid having uses of it in version control\",\n-                    sugg,\n-                    Applicability::MaybeIncorrect,\n-                );\n-            } else {\n-                span_lint_and_help(\n-                    cx,\n-                    DBG_MACRO,\n-                    mac.span(),\n-                    \"`dbg!` macro is intended as a debugging tool\",\n-                    None,\n-                    \"ensure to avoid having uses of it in version control\",\n-                );\n-            }\n-        }\n+impl_lint_pass!(DbgMacro => [DBG_MACRO]);\n+\n+impl DbgMacro {\n+    pub fn new(allow_dbg_in_tests: bool) -> Self {\n+        DbgMacro { allow_dbg_in_tests }\n     }\n }\n \n-// Get span enclosing entire the token stream.\n-fn tts_span(tts: TokenStream) -> Option<Span> {\n-    let mut cursor = tts.into_trees();\n-    let first = cursor.next()?.span();\n-    let span = cursor.last().map_or(first, |tree| first.to(tree.span()));\n-    Some(span)\n+impl LateLintPass<'_> for DbgMacro {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n+        let Some(macro_call) = root_macro_call_first_node(cx, expr) else { return };\n+        if cx.tcx.is_diagnostic_item(sym::dbg_macro, macro_call.def_id) {\n+            // allows `dbg!` in test code if allow-dbg-in-test is set to true in clippy.toml\n+            if self.allow_dbg_in_tests\n+                && (is_in_test_function(cx.tcx, expr.hir_id) || is_in_cfg_test(cx.tcx, expr.hir_id))\n+            {\n+                return;\n+            }\n+            let mut applicability = Applicability::MachineApplicable;\n+            let suggestion = match expr.peel_drop_temps().kind {\n+                // dbg!()\n+                ExprKind::Block(_, _) => String::new(),\n+                // dbg!(1)\n+                ExprKind::Match(val, ..) => {\n+                    snippet_with_applicability(cx, val.span.source_callsite(), \"..\", &mut applicability).to_string()\n+                },\n+                // dbg!(2, 3)\n+                ExprKind::Tup(\n+                    [\n+                        Expr {\n+                            kind: ExprKind::Match(first, ..),\n+                            ..\n+                        },\n+                        ..,\n+                        Expr {\n+                            kind: ExprKind::Match(last, ..),\n+                            ..\n+                        },\n+                    ],\n+                ) => {\n+                    let snippet = snippet_with_applicability(\n+                        cx,\n+                        first.span.source_callsite().to(last.span.source_callsite()),\n+                        \"..\",\n+                        &mut applicability,\n+                    );\n+                    format!(\"({snippet})\")\n+                },\n+                _ => return,\n+            };\n+\n+            span_lint_and_sugg(\n+                cx,\n+                DBG_MACRO,\n+                macro_call.span,\n+                \"`dbg!` macro is intended as a debugging tool\",\n+                \"ensure to avoid having uses of it in version control\",\n+                suggestion,\n+                applicability,\n+            );\n+        }\n+    }\n }"}, {"sha": "243dfd3a46183f0fefdec6b8c83bddb4ea911873", "filename": "clippy_lints/src/default.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::{span_lint_and_note, span_lint_and_sugg};\n use clippy_utils::source::snippet_with_macro_callsite;\n use clippy_utils::ty::{has_drop, is_copy};\n-use clippy_utils::{any_parent_is_automatically_derived, contains_name, match_def_path, paths};\n+use clippy_utils::{any_parent_is_automatically_derived, contains_name, get_parent_expr, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n@@ -88,14 +88,15 @@ impl<'tcx> LateLintPass<'tcx> for Default {\n             if let ExprKind::Path(ref qpath) = path.kind;\n             if let Some(def_id) = cx.qpath_res(qpath, path.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::DEFAULT_TRAIT_METHOD);\n+            if !is_update_syntax_base(cx, expr);\n             // Detect and ignore <Foo as Default>::default() because these calls do explicitly name the type.\n             if let QPath::Resolved(None, _path) = qpath;\n             let expr_ty = cx.typeck_results().expr_ty(expr);\n             if let ty::Adt(def, ..) = expr_ty.kind();\n             then {\n                 // TODO: Work out a way to put \"whatever the imported way of referencing\n                 // this type in this file\" rather than a fully-qualified type.\n-                let replacement = format!(\"{}::default()\", cx.tcx.def_path_str(def.did));\n+                let replacement = format!(\"{}::default()\", cx.tcx.def_path_str(def.did()));\n                 span_lint_and_sugg(\n                     cx,\n                     DEFAULT_TRAIT_ACCESS,\n@@ -109,7 +110,7 @@ impl<'tcx> LateLintPass<'tcx> for Default {\n         }\n     }\n \n-    #[allow(clippy::too_many_lines)]\n+    #[expect(clippy::too_many_lines)]\n     fn check_block(&mut self, cx: &LateContext<'tcx>, block: &Block<'tcx>) {\n         // start from the `let mut _ = _::default();` and look at all the following\n         // statements, see if they re-assign the fields of the binding\n@@ -136,7 +137,7 @@ impl<'tcx> LateLintPass<'tcx> for Default {\n                 if let Some(adt) = binding_type.ty_adt_def();\n                 if adt.is_struct();\n                 let variant = adt.non_enum_variant();\n-                if adt.did.is_local() || !variant.is_field_list_non_exhaustive();\n+                if adt.did().is_local() || !variant.is_field_list_non_exhaustive();\n                 let module_did = cx.tcx.parent_module(stmt.hir_id).to_def_id();\n                 if variant\n                     .fields\n@@ -215,7 +216,7 @@ impl<'tcx> LateLintPass<'tcx> for Default {\n                     if let ty::Adt(adt_def, substs) = binding_type.kind();\n                     if !substs.is_empty();\n                     then {\n-                        let adt_def_ty_name = cx.tcx.item_name(adt_def.did);\n+                        let adt_def_ty_name = cx.tcx.item_name(adt_def.did());\n                         let generic_args = substs.iter().collect::<Vec<_>>();\n                         let tys_str = generic_args\n                             .iter()\n@@ -290,3 +291,16 @@ fn field_reassigned_by_stmt<'tcx>(this: &Stmt<'tcx>, binding_name: Symbol) -> Op\n         }\n     }\n }\n+\n+/// Returns whether `expr` is the update syntax base: `Foo { a: 1, .. base }`\n+fn is_update_syntax_base<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+    if_chain! {\n+        if let Some(parent) = get_parent_expr(cx, expr);\n+        if let ExprKind::Struct(_, _, Some(base)) = parent.kind;\n+        then {\n+            base.hir_id == expr.hir_id\n+        } else {\n+            false\n+        }\n+    }\n+}"}, {"sha": "3d9f9ed41ce189eb5ac48c5f7903f453c374371f", "filename": "clippy_lints/src/default_numeric_fallback.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -116,14 +116,13 @@ impl<'a, 'tcx> NumericFallbackVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n-    #[allow(clippy::too_many_lines)]\n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         match &expr.kind {\n             ExprKind::Call(func, args) => {\n                 if let Some(fn_sig) = fn_sig_opt(self.cx, func.hir_id) {\n                     for (expr, bound) in iter::zip(*args, fn_sig.skip_binder().inputs()) {\n                         // Push found arg type, then visit arg.\n-                        self.ty_bounds.push(TyBound::Ty(bound));\n+                        self.ty_bounds.push(TyBound::Ty(*bound));\n                         self.visit_expr(expr);\n                         self.ty_bounds.pop();\n                     }\n@@ -135,7 +134,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n                 if let Some(def_id) = self.cx.typeck_results().type_dependent_def_id(expr.hir_id) {\n                     let fn_sig = self.cx.tcx.fn_sig(def_id).skip_binder();\n                     for (expr, bound) in iter::zip(*args, fn_sig.inputs()) {\n-                        self.ty_bounds.push(TyBound::Ty(bound));\n+                        self.ty_bounds.push(TyBound::Ty(*bound));\n                         self.visit_expr(expr);\n                         self.ty_bounds.pop();\n                     }\n@@ -148,7 +147,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n                 if_chain! {\n                     if let Some(adt_def) = ty.ty_adt_def();\n                     if adt_def.is_struct();\n-                    if let Some(variant) = adt_def.variants.iter().next();\n+                    if let Some(variant) = adt_def.variants().iter().next();\n                     then {\n                         let fields_def = &variant.fields;\n \n@@ -210,7 +209,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n \n fn fn_sig_opt<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Option<PolyFnSig<'tcx>> {\n     let node_ty = cx.typeck_results().node_type_opt(hir_id)?;\n-    // We can't use `TyS::fn_sig` because it automatically performs substs, this may result in FNs.\n+    // We can't use `Ty::fn_sig` because it automatically performs substs, this may result in FNs.\n     match node_ty.kind() {\n         ty::FnDef(def_id, _) => Some(cx.tcx.fn_sig(*def_id)),\n         ty::FnPtr(fn_sig) => Some(*fn_sig),"}, {"sha": "d559ad423df5f32f5ef8c3709487df507a92a028", "filename": "clippy_lints/src/default_union_representation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fdefault_union_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fdefault_union_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_union_representation.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -25,7 +25,7 @@ declare_clippy_lint! {\n     ///\n     /// fn main() {\n     ///     let _x: u32 = unsafe {\n-    ///         Foo { a: 0_i32 }.b // Undefined behaviour: `b` is allowed to be padding\n+    ///         Foo { a: 0_i32 }.b // Undefined behavior: `b` is allowed to be padding\n     ///     };\n     /// }\n     /// ```\n@@ -39,7 +39,7 @@ declare_clippy_lint! {\n     ///\n     /// fn main() {\n     ///     let _x: u32 = unsafe {\n-    ///         Foo { a: 0_i32 }.b // Now defined behaviour, this is just an i32 -> u32 transmute\n+    ///         Foo { a: 0_i32 }.b // Now defined behavior, this is just an i32 -> u32 transmute\n     ///     };\n     /// }\n     /// ```"}, {"sha": "5d5ea0f49c8c852076ec437aeb3905b74bbcd3f9", "filename": "clippy_lints/src/deprecated_lints.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fdeprecated_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fdeprecated_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdeprecated_lints.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -194,7 +194,6 @@ declare_deprecated_lint! {\n     /// ### Deprecation reason\n     /// The `avoid_breaking_exported_api` config option was added, which\n     /// enables the `enum_variant_names` lint for public items.\n-    /// ```\n     #[clippy::version = \"1.54.0\"]\n     pub PUB_ENUM_VARIANT_NAMES,\n     \"set the `avoid-breaking-exported-api` config option to `false` to enable the `enum_variant_names` lint for public items\""}, {"sha": "ea4c0207bb01312b82197ce0ec5c2310716e6067", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -12,7 +12,7 @@ use rustc_hir::{\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n-use rustc_middle::ty::{self, Ty, TyCtxt, TyS, TypeckResults};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeckResults};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{symbol::sym, Span};\n \n@@ -168,7 +168,7 @@ struct RefPat {\n }\n \n impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n-    #[allow(clippy::too_many_lines)]\n+    #[expect(clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         // Skip path expressions from deref calls. e.g. `Deref::deref(e)`\n         if Some(expr.hir_id) == self.skip_expr.take() {\n@@ -448,7 +448,7 @@ fn try_parse_ref_op<'tcx>(\n // the reference.\n fn deref_method_same_type(result_ty: Ty<'_>, arg_ty: Ty<'_>) -> bool {\n     match (result_ty.kind(), arg_ty.kind()) {\n-        (ty::Ref(_, result_ty, _), ty::Ref(_, arg_ty, _)) => TyS::same_type(result_ty, arg_ty),\n+        (ty::Ref(_, result_ty, _), ty::Ref(_, arg_ty, _)) => result_ty == arg_ty,\n \n         // The result type for a deref method is always a reference\n         // Not matching the previous pattern means the argument type is not a reference\n@@ -528,7 +528,7 @@ fn is_auto_reborrow_position(parent: Option<Node<'_>>) -> bool {\n fn is_auto_borrow_position(parent: Option<Node<'_>>, child_id: HirId) -> bool {\n     if let Some(Node::Expr(parent)) = parent {\n         match parent.kind {\n-            ExprKind::MethodCall(_, [self_arg, ..], _) => self_arg.hir_id == child_id,\n+            // ExprKind::MethodCall(_, [self_arg, ..], _) => self_arg.hir_id == child_id,\n             ExprKind::Field(..) => true,\n             ExprKind::Call(f, _) => f.hir_id == child_id,\n             _ => false,\n@@ -580,7 +580,7 @@ fn find_adjustments<'tcx>(\n     }\n }\n \n-#[allow(clippy::needless_pass_by_value)]\n+#[expect(clippy::needless_pass_by_value)]\n fn report(cx: &LateContext<'_>, expr: &Expr<'_>, state: State, data: StateData) {\n     match state {\n         State::DerefMethod {"}, {"sha": "34a5f8444dea0af0d58a1d221db4a1ca3998999a", "filename": "clippy_lints/src/derivable_impls.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fderivable_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fderivable_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderivable_impls.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::{is_automatically_derived, is_default_equivalent, peel_blocks};\n+use clippy_utils::{is_default_equivalent, peel_blocks};\n use rustc_hir::{\n     def::{DefKind, Res},\n     Body, Expr, ExprKind, GenericArg, Impl, ImplItemKind, Item, ItemKind, Node, PathSegment, QPath, TyKind,\n@@ -71,8 +71,7 @@ impl<'tcx> LateLintPass<'tcx> for DerivableImpls {\n                 self_ty,\n                 ..\n             }) = item.kind;\n-            if let attrs = cx.tcx.hir().attrs(item.hir_id());\n-            if !is_automatically_derived(attrs);\n+            if !cx.tcx.has_attr(item.def_id.to_def_id(), sym::automatically_derived);\n             if !item.span.from_expansion();\n             if let Some(def_id) = trait_ref.trait_def_id();\n             if cx.tcx.is_diagnostic_item(sym::Default, def_id);\n@@ -81,6 +80,7 @@ impl<'tcx> LateLintPass<'tcx> for DerivableImpls {\n             if let ImplItemKind::Fn(_, b) = &impl_item.kind;\n             if let Body { value: func_expr, .. } = cx.tcx.hir().body(*b);\n             if let Some(adt_def) = cx.tcx.type_of(item.def_id).ty_adt_def();\n+            if let attrs = cx.tcx.hir().attrs(item.hir_id());\n             if !attrs.iter().any(|attr| attr.doc_str().is_some());\n             if let child_attrs = cx.tcx.hir().attrs(impl_item_hir);\n             if !child_attrs.iter().any(|attr| attr.doc_str().is_some());\n@@ -103,7 +103,7 @@ impl<'tcx> LateLintPass<'tcx> for DerivableImpls {\n                     _ => false,\n                 };\n                 if should_emit {\n-                    let path_string = cx.tcx.def_path_str(adt_def.did);\n+                    let path_string = cx.tcx.def_path_str(adt_def.did());\n                     span_lint_and_help(\n                         cx,\n                         DERIVABLE_IMPLS,"}, {"sha": "fe99f4a8d55d1e359473da38289fb397400cd490", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 82, "deletions": 14, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,8 +1,9 @@\n-use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_note, span_lint_and_then};\n+use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::paths;\n use clippy_utils::ty::{implements_trait, is_copy};\n-use clippy_utils::{get_trait_def_id, is_automatically_derived, is_lint_allowed, match_def_path};\n+use clippy_utils::{is_lint_allowed, match_def_path};\n use if_chain::if_chain;\n+use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, walk_fn, walk_item, FnKind, Visitor};\n use rustc_hir::{\n     BlockCheckMode, BodyId, Expr, ExprKind, FnDecl, HirId, Impl, Item, ItemKind, TraitRef, UnsafeSource, Unsafety,\n@@ -12,6 +13,7 @@ use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -100,8 +102,8 @@ declare_clippy_lint! {\n     /// types.\n     ///\n     /// ### Why is this bad?\n-    /// To avoid surprising behaviour, these traits should\n-    /// agree and the behaviour of `Copy` cannot be overridden. In almost all\n+    /// To avoid surprising behavior, these traits should\n+    /// agree and the behavior of `Copy` cannot be overridden. In almost all\n     /// situations a `Copy` type should have a `Clone` implementation that does\n     /// nothing more than copy the object, which is what `#[derive(Copy, Clone)]`\n     /// gets you.\n@@ -155,11 +157,44 @@ declare_clippy_lint! {\n     \"deriving `serde::Deserialize` on a type that has methods using `unsafe`\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for types that derive `PartialEq` and could implement `Eq`.\n+    ///\n+    /// ### Why is this bad?\n+    /// If a type `T` derives `PartialEq` and all of its members implement `Eq`,\n+    /// then `T` can always implement `Eq`. Implementing `Eq` allows `T` to be used\n+    /// in APIs that require `Eq` types. It also allows structs containing `T` to derive\n+    /// `Eq` themselves.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// #[derive(PartialEq)]\n+    /// struct Foo {\n+    ///     i_am_eq: i32,\n+    ///     i_am_eq_too: Vec<String>,\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// #[derive(PartialEq, Eq)]\n+    /// struct Foo {\n+    ///     i_am_eq: i32,\n+    ///     i_am_eq_too: Vec<String>,\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.62.0\"]\n+    pub DERIVE_PARTIAL_EQ_WITHOUT_EQ,\n+    style,\n+    \"deriving `PartialEq` on a type that can implement `Eq`, without implementing `Eq`\"\n+}\n+\n declare_lint_pass!(Derive => [\n     EXPL_IMPL_CLONE_ON_COPY,\n     DERIVE_HASH_XOR_EQ,\n     DERIVE_ORD_XOR_PARTIAL_ORD,\n-    UNSAFE_DERIVE_DESERIALIZE\n+    UNSAFE_DERIVE_DESERIALIZE,\n+    DERIVE_PARTIAL_EQ_WITHOUT_EQ\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Derive {\n@@ -170,14 +205,14 @@ impl<'tcx> LateLintPass<'tcx> for Derive {\n         }) = item.kind\n         {\n             let ty = cx.tcx.type_of(item.def_id);\n-            let attrs = cx.tcx.hir().attrs(item.hir_id());\n-            let is_automatically_derived = is_automatically_derived(attrs);\n+            let is_automatically_derived = cx.tcx.has_attr(item.def_id.to_def_id(), sym::automatically_derived);\n \n             check_hash_peq(cx, item.span, trait_ref, ty, is_automatically_derived);\n             check_ord_partial_ord(cx, item.span, trait_ref, ty, is_automatically_derived);\n \n             if is_automatically_derived {\n                 check_unsafe_derive_deserialize(cx, item, trait_ref, ty);\n+                check_partial_eq_without_eq(cx, item.span, trait_ref, ty);\n             } else {\n                 check_copy_clone(cx, item, trait_ref, ty);\n             }\n@@ -196,11 +231,11 @@ fn check_hash_peq<'tcx>(\n     if_chain! {\n         if let Some(peq_trait_def_id) = cx.tcx.lang_items().eq_trait();\n         if let Some(def_id) = trait_ref.trait_def_id();\n-        if match_def_path(cx, def_id, &paths::HASH);\n+        if cx.tcx.is_diagnostic_item(sym::Hash, def_id);\n         then {\n             // Look for the PartialEq implementations for `ty`\n             cx.tcx.for_each_relevant_impl(peq_trait_def_id, ty, |impl_id| {\n-                let peq_is_automatically_derived = is_automatically_derived(cx.tcx.get_attrs(impl_id));\n+                let peq_is_automatically_derived = cx.tcx.has_attr(impl_id, sym::automatically_derived);\n \n                 if peq_is_automatically_derived == hash_is_automatically_derived {\n                     return;\n@@ -247,14 +282,14 @@ fn check_ord_partial_ord<'tcx>(\n     ord_is_automatically_derived: bool,\n ) {\n     if_chain! {\n-        if let Some(ord_trait_def_id) = get_trait_def_id(cx, &paths::ORD);\n+        if let Some(ord_trait_def_id) = cx.tcx.get_diagnostic_item(sym::Ord);\n         if let Some(partial_ord_trait_def_id) = cx.tcx.lang_items().partial_ord_trait();\n         if let Some(def_id) = &trait_ref.trait_def_id();\n         if *def_id == ord_trait_def_id;\n         then {\n             // Look for the PartialOrd implementations for `ty`\n             cx.tcx.for_each_relevant_impl(partial_ord_trait_def_id, ty, |impl_id| {\n-                let partial_ord_is_automatically_derived = is_automatically_derived(cx.tcx.get_attrs(impl_id));\n+                let partial_ord_is_automatically_derived = cx.tcx.has_attr(impl_id, sym::automatically_derived);\n \n                 if partial_ord_is_automatically_derived == ord_is_automatically_derived {\n                     return;\n@@ -314,7 +349,7 @@ fn check_copy_clone<'tcx>(cx: &LateContext<'tcx>, item: &Item<'_>, trait_ref: &T\n             let has_copy_impl = cx.tcx.all_local_trait_impls(()).get(&copy_id).map_or(false, |impls| {\n                 impls\n                     .iter()\n-                    .any(|&id| matches!(cx.tcx.type_of(id).kind(), ty::Adt(adt, _) if ty_adt.did == adt.did))\n+                    .any(|&id| matches!(cx.tcx.type_of(id).kind(), ty::Adt(adt, _) if ty_adt.did() == adt.did()))\n             });\n             if !has_copy_impl {\n                 return;\n@@ -356,10 +391,10 @@ fn check_unsafe_derive_deserialize<'tcx>(\n         if let Some(trait_def_id) = trait_ref.trait_def_id();\n         if match_def_path(cx, trait_def_id, &paths::SERDE_DESERIALIZE);\n         if let ty::Adt(def, _) = ty.kind();\n-        if let Some(local_def_id) = def.did.as_local();\n+        if let Some(local_def_id) = def.did().as_local();\n         let adt_hir_id = cx.tcx.hir().local_def_id_to_hir_id(local_def_id);\n         if !is_lint_allowed(cx, UNSAFE_DERIVE_DESERIALIZE, adt_hir_id);\n-        if cx.tcx.inherent_impls(def.did)\n+        if cx.tcx.inherent_impls(def.did())\n             .iter()\n             .map(|imp_did| cx.tcx.hir().expect_item(imp_did.expect_local()))\n             .any(|imp| has_unsafe(cx, imp));\n@@ -418,3 +453,36 @@ impl<'tcx> Visitor<'tcx> for UnsafeVisitor<'_, 'tcx> {\n         self.cx.tcx.hir()\n     }\n }\n+\n+/// Implementation of the `DERIVE_PARTIAL_EQ_WITHOUT_EQ` lint.\n+fn check_partial_eq_without_eq<'tcx>(cx: &LateContext<'tcx>, span: Span, trait_ref: &TraitRef<'_>, ty: Ty<'tcx>) {\n+    if_chain! {\n+        if let ty::Adt(adt, substs) = ty.kind();\n+        if let Some(eq_trait_def_id) = cx.tcx.get_diagnostic_item(sym::Eq);\n+        if let Some(def_id) = trait_ref.trait_def_id();\n+        if cx.tcx.is_diagnostic_item(sym::PartialEq, def_id);\n+        if !implements_trait(cx, ty, eq_trait_def_id, substs);\n+        then {\n+            // If all of our fields implement `Eq`, we can implement `Eq` too\n+            for variant in adt.variants() {\n+                for field in &variant.fields {\n+                    let ty = field.ty(cx.tcx, substs);\n+\n+                    if !implements_trait(cx, ty, eq_trait_def_id, substs) {\n+                        return;\n+                    }\n+                }\n+            }\n+\n+            span_lint_and_sugg(\n+                cx,\n+                DERIVE_PARTIAL_EQ_WITHOUT_EQ,\n+                span.ctxt().outer_expn_data().call_site,\n+                \"you are deriving `PartialEq` and can implement `Eq`\",\n+                \"consider deriving `Eq` as well\",\n+                \"PartialEq, Eq\".to_string(),\n+                Applicability::MachineApplicable,\n+            )\n+        }\n+    }\n+}"}, {"sha": "53973ab792a91a50cb55da6c89e8e8d6cbdd5c69", "filename": "clippy_lints/src/disallowed_methods.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fdisallowed_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fdisallowed_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdisallowed_methods.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::fn_def_id;\n+use clippy_utils::{fn_def_id, get_parent_expr, path_def_id};\n \n-use rustc_hir::{def::Res, def_id::DefIdMap, Expr};\n+use rustc_hir::{def::Res, def_id::DefIdMap, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n \n@@ -77,14 +77,22 @@ impl<'tcx> LateLintPass<'tcx> for DisallowedMethods {\n     fn check_crate(&mut self, cx: &LateContext<'_>) {\n         for (index, conf) in self.conf_disallowed.iter().enumerate() {\n             let segs: Vec<_> = conf.path().split(\"::\").collect();\n-            if let Res::Def(_, id) = clippy_utils::path_to_res(cx, &segs) {\n+            if let Res::Def(_, id) = clippy_utils::def_path_res(cx, &segs) {\n                 self.disallowed.insert(id, index);\n             }\n         }\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        let def_id = match fn_def_id(cx, expr) {\n+        let uncalled_path = if let Some(parent) = get_parent_expr(cx, expr)\n+            && let ExprKind::Call(receiver, _) = parent.kind\n+            && receiver.hir_id == expr.hir_id\n+        {\n+            None\n+        } else {\n+            path_def_id(cx, expr)\n+        };\n+        let def_id = match uncalled_path.or_else(|| fn_def_id(cx, expr)) {\n             Some(def_id) => def_id,\n             None => return,\n         };"}, {"sha": "14f89edce615db9993d811d34e6e8d42d62f8b14", "filename": "clippy_lints/src/disallowed_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fdisallowed_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fdisallowed_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdisallowed_types.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -96,7 +96,7 @@ impl<'tcx> LateLintPass<'tcx> for DisallowedTypes {\n                 ),\n             };\n             let segs: Vec<_> = path.split(\"::\").collect();\n-            match clippy_utils::path_to_res(cx, &segs) {\n+            match clippy_utils::def_path_res(cx, &segs) {\n                 Res::Def(_, id) => {\n                     self.def_ids.insert(id, reason);\n                 },"}, {"sha": "aaec88f50c771f2992c2a6df332d72083c33e7ce", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 29, "deletions": 20, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -11,7 +11,7 @@ use rustc_ast::token::CommentKind;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::emitter::EmitterWriter;\n-use rustc_errors::{Applicability, Handler, SuggestionStyle};\n+use rustc_errors::{Applicability, Handler, MultiSpan, SuggestionStyle};\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{AnonConst, Expr};\n@@ -25,7 +25,7 @@ use rustc_session::parse::ParseSess;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::def_id::LocalDefId;\n use rustc_span::edition::Edition;\n-use rustc_span::source_map::{BytePos, FilePathMapping, MultiSpan, SourceMap, Span};\n+use rustc_span::source_map::{BytePos, FilePathMapping, SourceMap, Span};\n use rustc_span::{sym, FileName, Pos};\n use std::io;\n use std::ops::Range;\n@@ -198,7 +198,7 @@ declare_clippy_lint! {\n     \"presence of `fn main() {` in code examples\"\n }\n \n-#[allow(clippy::module_name_repetitions)]\n+#[expect(clippy::module_name_repetitions)]\n #[derive(Clone)]\n pub struct DocMarkdown {\n     valid_idents: FxHashSet<String>,\n@@ -240,7 +240,7 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n                     lint_for_missing_headers(cx, item.def_id, item.span, sig, headers, Some(body_id), fpu.panic_span);\n                 }\n             },\n-            hir::ItemKind::Impl(ref impl_) => {\n+            hir::ItemKind::Impl(impl_) => {\n                 self.in_trait_impl = impl_.of_trait.is_some();\n             },\n             hir::ItemKind::Trait(_, unsafety, ..) => {\n@@ -373,7 +373,7 @@ fn lint_for_missing_headers<'tcx>(\n /// `rustc_ast::parse::lexer::comments::strip_doc_comment_decoration` because we\n /// need to keep track of\n /// the spans but this function is inspired from the later.\n-#[allow(clippy::cast_possible_truncation)]\n+#[expect(clippy::cast_possible_truncation)]\n #[must_use]\n pub fn strip_doc_comment_decoration(doc: &str, comment_kind: CommentKind, span: Span) -> (String, Vec<(usize, Span)>) {\n     // one-line comments lose their prefix\n@@ -428,7 +428,7 @@ fn check_attrs<'a>(cx: &LateContext<'_>, valid_idents: &FxHashSet<String>, attrs\n     /// We don't want the parser to choke on intra doc links. Since we don't\n     /// actually care about rendering them, just pretend that all broken links are\n     /// point to a fake address.\n-    #[allow(clippy::unnecessary_wraps)] // we're following a type signature\n+    #[expect(clippy::unnecessary_wraps)] // we're following a type signature\n     fn fake_broken_link_callback<'a>(_: BrokenLink<'_>) -> Option<(CowStr<'a>, CowStr<'a>)> {\n         Some((\"fake\".into(), \"fake\".into()))\n     }\n@@ -621,16 +621,26 @@ fn check_code(cx: &LateContext<'_>, text: &str, edition: Edition, span: Span) {\n                 let filename = FileName::anon_source_code(&code);\n \n                 let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n-                let emitter = EmitterWriter::new(Box::new(io::sink()), None, false, false, false, None, false);\n+                let fallback_bundle =\n+                    rustc_errors::fallback_fluent_bundle(rustc_errors::DEFAULT_LOCALE_RESOURCES, false);\n+                let emitter = EmitterWriter::new(\n+                    Box::new(io::sink()),\n+                    None,\n+                    None,\n+                    fallback_bundle,\n+                    false,\n+                    false,\n+                    false,\n+                    None,\n+                    false,\n+                );\n                 let handler = Handler::with_emitter(false, None, Box::new(emitter));\n                 let sess = ParseSess::with_span_handler(handler, sm);\n \n                 let mut parser = match maybe_new_parser_from_source_str(&sess, filename, code) {\n                     Ok(p) => p,\n                     Err(errs) => {\n-                        for mut err in errs {\n-                            err.cancel();\n-                        }\n+                        drop(errs);\n                         return false;\n                     },\n                 };\n@@ -639,12 +649,6 @@ fn check_code(cx: &LateContext<'_>, text: &str, edition: Edition, span: Span) {\n                 loop {\n                     match parser.parse_item(ForceCollect::No) {\n                         Ok(Some(item)) => match &item.kind {\n-                            // Tests with one of these items are ignored\n-                            ItemKind::Static(..)\n-                            | ItemKind::Const(..)\n-                            | ItemKind::ExternCrate(..)\n-                            | ItemKind::ForeignMod(..) => return false,\n-                            // We found a main function ...\n                             ItemKind::Fn(box Fn {\n                                 sig, body: Some(block), ..\n                             }) if item.ident.name == sym::main => {\n@@ -663,12 +667,17 @@ fn check_code(cx: &LateContext<'_>, text: &str, edition: Edition, span: Span) {\n                                     return false;\n                                 }\n                             },\n-                            // Another function was found; this case is ignored too\n-                            ItemKind::Fn(..) => return false,\n+                            // Tests with one of these items are ignored\n+                            ItemKind::Static(..)\n+                            | ItemKind::Const(..)\n+                            | ItemKind::ExternCrate(..)\n+                            | ItemKind::ForeignMod(..)\n+                            // Another function was found; this case is ignored\n+                            | ItemKind::Fn(..) => return false,\n                             _ => {},\n                         },\n                         Ok(None) => break,\n-                        Err(mut e) => {\n+                        Err(e) => {\n                             e.cancel();\n                             return false;\n                         },\n@@ -730,7 +739,7 @@ fn check_word(cx: &LateContext<'_>, word: &str, span: Span) {\n     /// letters (`Clippy` is ok) and one lower-case letter (`NASA` is ok).\n     /// Plurals are also excluded (`IDs` is ok).\n     fn is_camel_case(s: &str) -> bool {\n-        if s.starts_with(|c: char| c.is_digit(10)) {\n+        if s.starts_with(|c: char| c.is_ascii_digit()) {\n             return false;\n         }\n "}, {"sha": "be95375789d5b4663ac7ed7212e9e16bf195b9c0", "filename": "clippy_lints/src/double_comparison.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_comparison.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -40,7 +40,7 @@ declare_clippy_lint! {\n declare_lint_pass!(DoubleComparisons => [DOUBLE_COMPARISONS]);\n \n impl<'tcx> DoubleComparisons {\n-    #[allow(clippy::similar_names)]\n+    #[expect(clippy::similar_names)]\n     fn check_binop(cx: &LateContext<'tcx>, op: BinOpKind, lhs: &'tcx Expr<'_>, rhs: &'tcx Expr<'_>, span: Span) {\n         let (lkind, llhs, lrhs, rkind, rlhs, rrhs) = match (&lhs.kind, &rhs.kind) {\n             (ExprKind::Binary(lb, llhs, lrhs), ExprKind::Binary(rb, rlhs, rrhs)) => {"}, {"sha": "25014bfa1a5b12595b41415a2010317ac7952143", "filename": "clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 128, "deletions": 51, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,11 +1,10 @@\n-use clippy_utils::diagnostics::span_lint_and_note;\n-use clippy_utils::ty::is_copy;\n-use clippy_utils::{match_def_path, paths};\n-use if_chain::if_chain;\n-use rustc_hir::{Expr, ExprKind};\n+use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_note};\n+use clippy_utils::is_must_use_func_call;\n+use clippy_utils::ty::{is_copy, is_must_use_ty, is_type_lang_item};\n+use rustc_hir::{Expr, ExprKind, LangItem};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -103,6 +102,75 @@ declare_clippy_lint! {\n     \"calls to `std::mem::forget` with a value that implements Copy\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for calls to `std::mem::drop` with a value that does not implement `Drop`.\n+    ///\n+    /// ### Why is this bad?\n+    /// Calling `std::mem::drop` is no different than dropping such a type. A different value may\n+    /// have been intended.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// struct Foo;\n+    /// let x = Foo;\n+    /// std::mem::drop(x);\n+    /// ```\n+    #[clippy::version = \"1.61.0\"]\n+    pub DROP_NON_DROP,\n+    suspicious,\n+    \"call to `std::mem::drop` with a value which does not implement `Drop`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for calls to `std::mem::forget` with a value that does not implement `Drop`.\n+    ///\n+    /// ### Why is this bad?\n+    /// Calling `std::mem::forget` is no different than dropping such a type. A different value may\n+    /// have been intended.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// struct Foo;\n+    /// let x = Foo;\n+    /// std::mem::forget(x);\n+    /// ```\n+    #[clippy::version = \"1.61.0\"]\n+    pub FORGET_NON_DROP,\n+    suspicious,\n+    \"call to `std::mem::forget` with a value which does not implement `Drop`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Prevents the safe `std::mem::drop` function from being called on `std::mem::ManuallyDrop`.\n+    ///\n+    /// ### Why is this bad?\n+    /// The safe `drop` function does not drop the inner value of a `ManuallyDrop`.\n+    ///\n+    /// ### Known problems\n+    /// Does not catch cases if the user binds `std::mem::drop`\n+    /// to a different name and calls it that way.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// struct S;\n+    /// drop(std::mem::ManuallyDrop::new(S));\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// struct S;\n+    /// unsafe {\n+    ///     std::mem::ManuallyDrop::drop(&mut std::mem::ManuallyDrop::new(S));\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.49.0\"]\n+    pub UNDROPPED_MANUALLY_DROPS,\n+    correctness,\n+    \"use of safe `std::mem::drop` function to drop a std::mem::ManuallyDrop, which will not drop the inner value\"\n+}\n+\n const DROP_REF_SUMMARY: &str = \"calls to `std::mem::drop` with a reference instead of an owned value. \\\n                                 Dropping a reference does nothing\";\n const FORGET_REF_SUMMARY: &str = \"calls to `std::mem::forget` with a reference instead of an owned value. \\\n@@ -111,56 +179,65 @@ const DROP_COPY_SUMMARY: &str = \"calls to `std::mem::drop` with a value that imp\n                                  Dropping a copy leaves the original intact\";\n const FORGET_COPY_SUMMARY: &str = \"calls to `std::mem::forget` with a value that implements `Copy`. \\\n                                    Forgetting a copy leaves the original intact\";\n+const DROP_NON_DROP_SUMMARY: &str = \"call to `std::mem::drop` with a value that does not implement `Drop`. \\\n+                                 Dropping such a type only extends its contained lifetimes\";\n+const FORGET_NON_DROP_SUMMARY: &str = \"call to `std::mem::forget` with a value that does not implement `Drop`. \\\n+                                   Forgetting such a type is the same as dropping it\";\n \n-declare_lint_pass!(DropForgetRef => [DROP_REF, FORGET_REF, DROP_COPY, FORGET_COPY]);\n+declare_lint_pass!(DropForgetRef => [\n+    DROP_REF,\n+    FORGET_REF,\n+    DROP_COPY,\n+    FORGET_COPY,\n+    DROP_NON_DROP,\n+    FORGET_NON_DROP,\n+    UNDROPPED_MANUALLY_DROPS\n+]);\n \n impl<'tcx> LateLintPass<'tcx> for DropForgetRef {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if let ExprKind::Call(path, args) = expr.kind;\n-            if let ExprKind::Path(ref qpath) = path.kind;\n-            if args.len() == 1;\n-            if let Some(def_id) = cx.qpath_res(qpath, path.hir_id).opt_def_id();\n-            then {\n-                let lint;\n-                let msg;\n-                let arg = &args[0];\n-                let arg_ty = cx.typeck_results().expr_ty(arg);\n-\n-                if let ty::Ref(..) = arg_ty.kind() {\n-                    if match_def_path(cx, def_id, &paths::DROP) {\n-                        lint = DROP_REF;\n-                        msg = DROP_REF_SUMMARY.to_string();\n-                    } else if match_def_path(cx, def_id, &paths::MEM_FORGET) {\n-                        lint = FORGET_REF;\n-                        msg = FORGET_REF_SUMMARY.to_string();\n-                    } else {\n-                        return;\n-                    }\n-                    span_lint_and_note(cx,\n-                                       lint,\n-                                       expr.span,\n-                                       &msg,\n-                                       Some(arg.span),\n-                                       &format!(\"argument has type `{}`\", arg_ty));\n-                } else if is_copy(cx, arg_ty) {\n-                    if match_def_path(cx, def_id, &paths::DROP) {\n-                        lint = DROP_COPY;\n-                        msg = DROP_COPY_SUMMARY.to_string();\n-                    } else if match_def_path(cx, def_id, &paths::MEM_FORGET) {\n-                        lint = FORGET_COPY;\n-                        msg = FORGET_COPY_SUMMARY.to_string();\n-                    } else {\n-                        return;\n-                    }\n-                    span_lint_and_note(cx,\n-                                       lint,\n-                                       expr.span,\n-                                       &msg,\n-                                       Some(arg.span),\n-                                       &format!(\"argument has type {}\", arg_ty));\n+        if let ExprKind::Call(path, [arg]) = expr.kind\n+            && let ExprKind::Path(ref qpath) = path.kind\n+            && let Some(def_id) = cx.qpath_res(qpath, path.hir_id).opt_def_id()\n+            && let Some(fn_name) = cx.tcx.get_diagnostic_name(def_id)\n+        {\n+            let arg_ty = cx.typeck_results().expr_ty(arg);\n+            let (lint, msg) = match fn_name {\n+                sym::mem_drop if arg_ty.is_ref() => (DROP_REF, DROP_REF_SUMMARY),\n+                sym::mem_forget if arg_ty.is_ref() => (FORGET_REF, FORGET_REF_SUMMARY),\n+                sym::mem_drop if is_copy(cx, arg_ty) => (DROP_COPY, DROP_COPY_SUMMARY),\n+                sym::mem_forget if is_copy(cx, arg_ty) => (FORGET_COPY, FORGET_COPY_SUMMARY),\n+                sym::mem_drop if is_type_lang_item(cx, arg_ty, LangItem::ManuallyDrop) => {\n+                    span_lint_and_help(\n+                        cx,\n+                        UNDROPPED_MANUALLY_DROPS,\n+                        expr.span,\n+                        \"the inner value of this ManuallyDrop will not be dropped\",\n+                        None,\n+                        \"to drop a `ManuallyDrop<T>`, use std::mem::ManuallyDrop::drop\",\n+                    );\n+                    return;\n                 }\n-            }\n+                sym::mem_drop\n+                    if !(arg_ty.needs_drop(cx.tcx, cx.param_env)\n+                        || is_must_use_func_call(cx, arg)\n+                        || is_must_use_ty(cx, arg_ty)) =>\n+                {\n+                    (DROP_NON_DROP, DROP_NON_DROP_SUMMARY)\n+                },\n+                sym::mem_forget if !arg_ty.needs_drop(cx.tcx, cx.param_env) => {\n+                    (FORGET_NON_DROP, FORGET_NON_DROP_SUMMARY)\n+                },\n+                _ => return,\n+            };\n+            span_lint_and_note(\n+                cx,\n+                lint,\n+                expr.span,\n+                msg,\n+                Some(arg.span),\n+                &format!(\"argument has type `{}`\", arg_ty),\n+            );\n         }\n     }\n }"}, {"sha": "c6c7b959d4f49bb929dca16be321f8bdea633d06", "filename": "clippy_lints/src/duplicate_mod.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fduplicate_mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fduplicate_mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fduplicate_mod.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,102 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use rustc_ast::ast::{Crate, Inline, Item, ItemKind, ModKind};\n+use rustc_errors::MultiSpan;\n+use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::{FileName, Span};\n+use std::collections::BTreeMap;\n+use std::path::PathBuf;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for files that are included as modules multiple times.\n+    ///\n+    /// ### Why is this bad?\n+    /// Loading a file as a module more than once causes it to be compiled\n+    /// multiple times, taking longer and putting duplicate content into the\n+    /// module tree.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// // lib.rs\n+    /// mod a;\n+    /// mod b;\n+    /// ```\n+    /// ```rust,ignore\n+    /// // a.rs\n+    /// #[path = \"./b.rs\"]\n+    /// mod b;\n+    /// ```\n+    ///\n+    /// Use instead:\n+    ///\n+    /// ```rust,ignore\n+    /// // lib.rs\n+    /// mod a;\n+    /// mod b;\n+    /// ```\n+    /// ```rust,ignore\n+    /// // a.rs\n+    /// use crate::b;\n+    /// ```\n+    #[clippy::version = \"1.62.0\"]\n+    pub DUPLICATE_MOD,\n+    suspicious,\n+    \"file loaded as module multiple times\"\n+}\n+\n+#[derive(PartialOrd, Ord, PartialEq, Eq)]\n+struct Modules {\n+    local_path: PathBuf,\n+    spans: Vec<Span>,\n+}\n+\n+#[derive(Default)]\n+pub struct DuplicateMod {\n+    /// map from the canonicalized path to `Modules`, `BTreeMap` to make the\n+    /// order deterministic for tests\n+    modules: BTreeMap<PathBuf, Modules>,\n+}\n+\n+impl_lint_pass!(DuplicateMod => [DUPLICATE_MOD]);\n+\n+impl EarlyLintPass for DuplicateMod {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n+        if let ItemKind::Mod(_, ModKind::Loaded(_, Inline::No, mod_spans)) = &item.kind\n+            && let FileName::Real(real) = cx.sess().source_map().span_to_filename(mod_spans.inner_span)\n+            && let Some(local_path) = real.into_local_path()\n+            && let Ok(absolute_path) = local_path.canonicalize()\n+        {\n+            let modules = self.modules.entry(absolute_path).or_insert(Modules {\n+                local_path,\n+                spans: Vec::new(),\n+            });\n+            modules.spans.push(item.span_with_attributes());\n+        }\n+    }\n+\n+    fn check_crate_post(&mut self, cx: &EarlyContext<'_>, _: &Crate) {\n+        for Modules { local_path, spans } in self.modules.values() {\n+            if spans.len() < 2 {\n+                continue;\n+            }\n+\n+            let mut multi_span = MultiSpan::from_spans(spans.clone());\n+            let (&first, duplicates) = spans.split_first().unwrap();\n+\n+            multi_span.push_span_label(first, \"first loaded here\");\n+            for &duplicate in duplicates {\n+                multi_span.push_span_label(duplicate, \"loaded again here\");\n+            }\n+\n+            span_lint_and_help(\n+                cx,\n+                DUPLICATE_MOD,\n+                multi_span,\n+                &format!(\"file is loaded as a module multiple times: `{}`\", local_path.display()),\n+                None,\n+                \"replace all but one `mod` item with `use` items\",\n+            );\n+        }\n+    }\n+}"}, {"sha": "09318f74527c2bf16485add7c10f1cf70981f30e", "filename": "clippy_lints/src/duration_subsec.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fduration_subsec.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,15 +1,14 @@\n+use clippy_utils::consts::{constant, Constant};\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::ty::match_type;\n+use clippy_utils::ty::is_type_diagnostic_item;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Spanned;\n-\n-use clippy_utils::consts::{constant, Constant};\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::paths;\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -46,7 +45,7 @@ impl<'tcx> LateLintPass<'tcx> for DurationSubsec {\n         if_chain! {\n             if let ExprKind::Binary(Spanned { node: BinOpKind::Div, .. }, left, right) = expr.kind;\n             if let ExprKind::MethodCall(method_path, args, _) = left.kind;\n-            if match_type(cx, cx.typeck_results().expr_ty(&args[0]).peel_refs(), &paths::DURATION);\n+            if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&args[0]).peel_refs(), sym::Duration);\n             if let Some((Constant::Int(divisor), _)) = constant(cx, cx.typeck_results(), right);\n             then {\n                 let suggested_fn = match (method_path.ident.as_str(), divisor) {"}, {"sha": "325ae2356c14cb255531b3df3950d3208feaa39e", "filename": "clippy_lints/src/empty_drop.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fempty_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fempty_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fempty_drop.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,65 @@\n+use clippy_utils::{diagnostics::span_lint_and_sugg, peel_blocks};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Body, ExprKind, Impl, ImplItemKind, Item, ItemKind, Node};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for empty `Drop` implementations.\n+    ///\n+    /// ### Why is this bad?\n+    /// Empty `Drop` implementations have no effect when dropping an instance of the type. They are\n+    /// most likely useless. However, an empty `Drop` implementation prevents a type from being\n+    /// destructured, which might be the intention behind adding the implementation as a marker.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// struct S;\n+    ///\n+    /// impl Drop for S {\n+    ///     fn drop(&mut self) {}\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// struct S;\n+    /// ```\n+    #[clippy::version = \"1.61.0\"]\n+    pub EMPTY_DROP,\n+    restriction,\n+    \"empty `Drop` implementations\"\n+}\n+declare_lint_pass!(EmptyDrop => [EMPTY_DROP]);\n+\n+impl LateLintPass<'_> for EmptyDrop {\n+    fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n+        if_chain! {\n+            if let ItemKind::Impl(Impl {\n+                of_trait: Some(ref trait_ref),\n+                items: [child],\n+                ..\n+            }) = item.kind;\n+            if trait_ref.trait_def_id() == cx.tcx.lang_items().drop_trait();\n+            if let impl_item_hir = child.id.hir_id();\n+            if let Some(Node::ImplItem(impl_item)) = cx.tcx.hir().find(impl_item_hir);\n+            if let ImplItemKind::Fn(_, b) = &impl_item.kind;\n+            if let Body { value: func_expr, .. } = cx.tcx.hir().body(*b);\n+            let func_expr = peel_blocks(func_expr);\n+            if let ExprKind::Block(block, _) = func_expr.kind;\n+            if block.stmts.is_empty() && block.expr.is_none();\n+            then {\n+                span_lint_and_sugg(\n+                    cx,\n+                    EMPTY_DROP,\n+                    item.span,\n+                    \"empty drop implementation\",\n+                    \"try removing this impl\",\n+                    String::new(),\n+                    Applicability::MaybeIncorrect\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "b5d6b3c7524baad8f64bea9069054624c990707e", "filename": "clippy_lints/src/empty_enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fempty_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fempty_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fempty_enum.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -52,7 +52,7 @@ impl<'tcx> LateLintPass<'tcx> for EmptyEnum {\n         if let ItemKind::Enum(..) = item.kind {\n             let ty = cx.tcx.type_of(item.def_id);\n             let adt = ty.ty_adt_def().expect(\"already checked whether this is an enum\");\n-            if adt.variants.is_empty() {\n+            if adt.variants().is_empty() {\n                 span_lint_and_help(\n                     cx,\n                     EMPTY_ENUM,"}, {"sha": "8430e7b4c82713554b0107be84ef57d269c1a483", "filename": "clippy_lints/src/empty_structs_with_brackets.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fempty_structs_with_brackets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fempty_structs_with_brackets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fempty_structs_with_brackets.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,99 @@\n+use clippy_utils::{diagnostics::span_lint_and_then, source::snippet_opt};\n+use rustc_ast::ast::{Item, ItemKind, VariantData};\n+use rustc_errors::Applicability;\n+use rustc_lexer::TokenKind;\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Finds structs without fields (a so-called \"empty struct\") that are declared with brackets.\n+    ///\n+    /// ### Why is this bad?\n+    /// Empty brackets after a struct declaration can be omitted.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// struct Cookie {}\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// struct Cookie;\n+    /// ```\n+    #[clippy::version = \"1.62.0\"]\n+    pub EMPTY_STRUCTS_WITH_BRACKETS,\n+    restriction,\n+    \"finds struct declarations with empty brackets\"\n+}\n+declare_lint_pass!(EmptyStructsWithBrackets => [EMPTY_STRUCTS_WITH_BRACKETS]);\n+\n+impl EarlyLintPass for EmptyStructsWithBrackets {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n+        let span_after_ident = item.span.with_lo(item.ident.span.hi());\n+\n+        if let ItemKind::Struct(var_data, _) = &item.kind\n+            && has_brackets(var_data)\n+            && has_no_fields(cx, var_data, span_after_ident) {\n+            span_lint_and_then(\n+                cx,\n+                EMPTY_STRUCTS_WITH_BRACKETS,\n+                span_after_ident,\n+                \"found empty brackets on struct declaration\",\n+                |diagnostic| {\n+                    diagnostic.span_suggestion_hidden(\n+                        span_after_ident,\n+                        \"remove the brackets\",\n+                        \";\".to_string(),\n+                        Applicability::MachineApplicable);\n+                    },\n+            );\n+        }\n+    }\n+}\n+\n+fn has_no_ident_token(braces_span_str: &str) -> bool {\n+    !rustc_lexer::tokenize(braces_span_str).any(|t| t.kind == TokenKind::Ident)\n+}\n+\n+fn has_brackets(var_data: &VariantData) -> bool {\n+    !matches!(var_data, VariantData::Unit(_))\n+}\n+\n+fn has_no_fields(cx: &EarlyContext<'_>, var_data: &VariantData, braces_span: Span) -> bool {\n+    if !var_data.fields().is_empty() {\n+        return false;\n+    }\n+\n+    // there might still be field declarations hidden from the AST\n+    // (conditionally compiled code using #[cfg(..)])\n+\n+    let Some(braces_span_str) = snippet_opt(cx, braces_span) else {\n+        return false;\n+    };\n+\n+    has_no_ident_token(braces_span_str.as_ref())\n+}\n+\n+#[cfg(test)]\n+mod unit_test {\n+    use super::*;\n+\n+    #[test]\n+    fn test_has_no_ident_token() {\n+        let input = \"{ field: u8 }\";\n+        assert!(!has_no_ident_token(input));\n+\n+        let input = \"(u8, String);\";\n+        assert!(!has_no_ident_token(input));\n+\n+        let input = \" {\n+                // test = 5\n+        }\n+        \";\n+        assert!(has_no_ident_token(input));\n+\n+        let input = \" ();\";\n+        assert!(has_no_ident_token(input));\n+    }\n+}"}, {"sha": "c5a987842c3f186cfc4119f658a890f1d60846ce", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -11,7 +11,7 @@ use rustc_errors::Applicability;\n use rustc_hir::{\n     hir_id::HirIdSet,\n     intravisit::{walk_expr, Visitor},\n-    Block, Expr, ExprKind, Guard, HirId, Pat, Stmt, StmtKind, UnOp,\n+    Block, Expr, ExprKind, Guard, HirId, Let, Pat, Stmt, StmtKind, UnOp,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -63,7 +63,7 @@ declare_clippy_lint! {\n declare_lint_pass!(HashMapPass => [MAP_ENTRY]);\n \n impl<'tcx> LateLintPass<'tcx> for HashMapPass {\n-    #[allow(clippy::too_many_lines)]\n+    #[expect(clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         let (cond_expr, then_expr, else_expr) = match higher::If::hir(expr) {\n             Some(higher::If { cond, then, r#else }) => (cond, then, r#else),\n@@ -319,7 +319,7 @@ struct Insertion<'tcx> {\n ///   `or_insert_with`.\n /// * Determine if there's any sub-expression that can't be placed in a closure.\n /// * Determine if there's only a single insert statement. `or_insert` can be used in this case.\n-#[allow(clippy::struct_excessive_bools)]\n+#[expect(clippy::struct_excessive_bools)]\n struct InsertSearcher<'cx, 'tcx> {\n     cx: &'cx LateContext<'tcx>,\n     /// The map expression used in the contains call.\n@@ -478,7 +478,7 @@ impl<'tcx> Visitor<'tcx> for InsertSearcher<'_, 'tcx> {\n                     let mut is_map_used = self.is_map_used;\n                     for arm in arms {\n                         self.visit_pat(arm.pat);\n-                        if let Some(Guard::If(guard) | Guard::IfLet(_, guard)) = arm.guard {\n+                        if let Some(Guard::If(guard) | Guard::IfLet(&Let { init: guard, .. })) = arm.guard {\n                             self.visit_non_tail_expr(guard);\n                         }\n                         is_map_used |= self.visit_cond_arm(arm.body);"}, {"sha": "10be245b36293ee578c6a8adb64bd51beb7c900d", "filename": "clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_clike.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -8,7 +8,6 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::util::IntTypeExt;\n use rustc_middle::ty::{self, IntTy, UintTy};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use std::convert::TryFrom;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -37,7 +36,7 @@ declare_clippy_lint! {\n declare_lint_pass!(UnportableVariant => [ENUM_CLIKE_UNPORTABLE_VARIANT]);\n \n impl<'tcx> LateLintPass<'tcx> for UnportableVariant {\n-    #[allow(clippy::cast_possible_truncation, clippy::cast_possible_wrap, clippy::cast_sign_loss)]\n+    #[expect(clippy::cast_possible_wrap)]\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if cx.tcx.data_layout.pointer_size.bits() != 64 {\n             return;\n@@ -55,7 +54,7 @@ impl<'tcx> LateLintPass<'tcx> for UnportableVariant {\n                     if let Some(Constant::Int(val)) = constant.and_then(miri_to_const) {\n                         if let ty::Adt(adt, _) = ty.kind() {\n                             if adt.is_enum() {\n-                                ty = adt.repr.discr_type().to_ty(cx.tcx);\n+                                ty = adt.repr().discr_type().to_ty(cx.tcx);\n                             }\n                         }\n                         match ty.kind() {"}, {"sha": "e029b8e85379f1a6dda254a307fa2ec6cfd12d5b", "filename": "clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_variants.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -240,7 +240,7 @@ impl LateLintPass<'_> for EnumVariantNames {\n         assert!(last.is_some());\n     }\n \n-    #[allow(clippy::similar_names)]\n+    #[expect(clippy::similar_names)]\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n         let item_name = item.ident.name.as_str();\n         let item_camel = to_camel_case(item_name);\n@@ -260,7 +260,7 @@ impl LateLintPass<'_> for EnumVariantNames {\n                     }\n                     // The `module_name_repetitions` lint should only trigger if the item has the module in its\n                     // name. Having the same name is accepted.\n-                    if item.vis.node.is_pub() && item_camel.len() > mod_camel.len() {\n+                    if cx.tcx.visibility(item.def_id).is_public() && item_camel.len() > mod_camel.len() {\n                         let matching = count_match_start(mod_camel, &item_camel);\n                         let rmatching = count_match_end(mod_camel, &item_camel);\n                         let nchars = mod_camel.chars().count();"}, {"sha": "afb5d32f95334b31792d440185798047f2425a86", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -6,11 +6,9 @@ use clippy_utils::ty::{implements_trait, is_copy};\n use clippy_utils::{ast_utils::is_useless_with_eq_exprs, eq_expr_value, is_in_test_function};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{\n-    def::Res, def_id::DefId, BinOpKind, BorrowKind, Expr, ExprKind, GenericArg, ItemKind, QPath, Ty, TyKind,\n-};\n+use rustc_hir::{def::Res, def_id::DefId, BinOpKind, BorrowKind, Expr, ExprKind, GenericArg, ItemKind, QPath, TyKind};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{self, TyS};\n+use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n@@ -74,7 +72,7 @@ declare_clippy_lint! {\n declare_lint_pass!(EqOp => [EQ_OP, OP_REF]);\n \n impl<'tcx> LateLintPass<'tcx> for EqOp {\n-    #[allow(clippy::similar_names, clippy::too_many_lines)]\n+    #[expect(clippy::similar_names, clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         if_chain! {\n             if let Some((macro_call, macro_name)) = first_node_macro_backtrace(cx, e).find_map(|macro_call| {\n@@ -140,7 +138,6 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n                 },\n             };\n             if let Some(trait_id) = trait_id {\n-                #[allow(clippy::match_same_arms)]\n                 match (&left.kind, &right.kind) {\n                     // do not suggest to dereference literals\n                     (&ExprKind::Lit(..), _) | (_, &ExprKind::Lit(..)) => {},\n@@ -279,7 +276,11 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n     }\n }\n \n-fn in_impl<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, bin_op: DefId) -> Option<(&'tcx Ty<'tcx>, &'tcx Ty<'tcx>)> {\n+fn in_impl<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    bin_op: DefId,\n+) -> Option<(&'tcx rustc_hir::Ty<'tcx>, &'tcx rustc_hir::Ty<'tcx>)> {\n     if_chain! {\n         if let Some(block) = get_enclosing_block(cx, e.hir_id);\n         if let Some(impl_def_id) = cx.tcx.impl_of_method(block.hir_id.owner.to_def_id());\n@@ -301,10 +302,10 @@ fn in_impl<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, bin_op: DefId) -> Op\n     }\n }\n \n-fn are_equal<'tcx>(cx: &LateContext<'tcx>, middle_ty: &TyS<'_>, hir_ty: &Ty<'_>) -> bool {\n+fn are_equal<'tcx>(cx: &LateContext<'tcx>, middle_ty: Ty<'_>, hir_ty: &rustc_hir::Ty<'_>) -> bool {\n     if_chain! {\n         if let ty::Adt(adt_def, _) = middle_ty.kind();\n-        if let Some(local_did) = adt_def.did.as_local();\n+        if let Some(local_did) = adt_def.did().as_local();\n         let item = cx.tcx.hir().expect_item(local_did);\n         let middle_ty_id = item.def_id.to_def_id();\n         if let TyKind::Path(QPath::Resolved(_, path)) = hir_ty.kind;"}, {"sha": "530d6d4de35f1c2bceb58e92c6b8624c9db23c75", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -3,13 +3,14 @@ use clippy_utils::higher::VecArgs;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::usage::local_used_after_expr;\n-use clippy_utils::{get_enclosing_loop_or_closure, higher, path_to_local, path_to_local_id};\n+use clippy_utils::{higher, is_adjusted, path_to_local, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::def_id::DefId;\n use rustc_hir::{Expr, ExprKind, Param, PatKind, Unsafety};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n+use rustc_middle::ty::binding::BindingMode;\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, ClosureKind, Ty, TypeFoldable};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -102,6 +103,7 @@ impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n         let closure_ty = cx.typeck_results().expr_ty(expr);\n \n         if_chain!(\n+            if !is_adjusted(cx, &body.value);\n             if let ExprKind::Call(callee, args) = body.value.kind;\n             if let ExprKind::Path(_) = callee.kind;\n             if check_inputs(cx, body.params, args);\n@@ -124,8 +126,7 @@ impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n                         if_chain! {\n                             if let ty::Closure(_, substs) = callee_ty.peel_refs().kind();\n                             if substs.as_closure().kind() == ClosureKind::FnMut;\n-                            if get_enclosing_loop_or_closure(cx.tcx, expr).is_some()\n-                                || path_to_local(callee).map_or(false, |l| local_used_after_expr(cx, l, callee));\n+                            if path_to_local(callee).map_or(false, |l| local_used_after_expr(cx, l, expr));\n \n                             then {\n                                 // Mutable closure is used after current expr; we cannot consume it.\n@@ -144,11 +145,12 @@ impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n         );\n \n         if_chain!(\n+            if !is_adjusted(cx, &body.value);\n             if let ExprKind::MethodCall(path, args, _) = body.value.kind;\n             if check_inputs(cx, body.params, args);\n             let method_def_id = cx.typeck_results().type_dependent_def_id(body.value.hir_id).unwrap();\n             let substs = cx.typeck_results().node_substs(body.value.hir_id);\n-            let call_ty = cx.tcx.type_of(method_def_id).subst(cx.tcx, substs);\n+            let call_ty = cx.tcx.bound_type_of(method_def_id).subst(cx.tcx, substs);\n             if check_sig(cx, closure_ty, call_ty);\n             then {\n                 span_lint_and_then(cx, REDUNDANT_CLOSURE_FOR_METHOD_CALLS, expr.span, \"redundant closure\", |diag| {\n@@ -169,11 +171,17 @@ fn check_inputs(cx: &LateContext<'_>, params: &[Param<'_>], call_args: &[Expr<'_\n     if params.len() != call_args.len() {\n         return false;\n     }\n+    let binding_modes = cx.typeck_results().pat_binding_modes();\n     std::iter::zip(params, call_args).all(|(param, arg)| {\n         match param.pat.kind {\n             PatKind::Binding(_, id, ..) if path_to_local_id(arg, id) => {},\n             _ => return false,\n         }\n+        // checks that parameters are not bound as `ref` or `ref mut`\n+        if let Some(BindingMode::BindByReference(_)) = binding_modes.get(param.pat.hir_id) {\n+            return false;\n+        }\n+\n         match *cx.typeck_results().expr_adjustments(arg) {\n             [] => true,\n             [\n@@ -217,7 +225,7 @@ fn get_ufcs_type_name(cx: &LateContext<'_>, method_def_id: DefId) -> String {\n         ty::ImplContainer(def_id) => {\n             let ty = cx.tcx.type_of(def_id);\n             match ty.kind() {\n-                ty::Adt(adt, _) => cx.tcx.def_path_str(adt.did),\n+                ty::Adt(adt, _) => cx.tcx.def_path_str(adt.did()),\n                 _ => ty.to_string(),\n             }\n         },"}, {"sha": "7a81fb37e841cf7f218f23bbbddb9ecaf7ae7bea", "filename": "clippy_lints/src/excessive_bools.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fexcessive_bools.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fexcessive_bools.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexcessive_bools.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -4,8 +4,6 @@ use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{sym, Span};\n \n-use std::convert::TryInto;\n-\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for excessive"}, {"sha": "173d41b4b05060b7794a9cbac5432ace09c817c0", "filename": "clippy_lints/src/exhaustive_items.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fexhaustive_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fexhaustive_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexhaustive_items.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -78,7 +78,10 @@ impl LateLintPass<'_> for ExhaustiveItems {\n             if !attrs.iter().any(|a| a.has_name(sym::non_exhaustive));\n             then {\n                 let (lint, msg) = if let ItemKind::Struct(ref v, ..) = item.kind {\n-                    if v.fields().iter().any(|f| !f.vis.node.is_pub()) {\n+                    if v.fields().iter().any(|f| {\n+                        let def_id = cx.tcx.hir().local_def_id(f.hir_id);\n+                        !cx.tcx.visibility(def_id).is_public()\n+                    }) {\n                         // skip structs with private fields\n                         return;\n                     }"}, {"sha": "3e2217c28da3a0dee72c6d62b567fe6fb3014436", "filename": "clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexplicit_write.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,5 +1,6 @@\n-use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg};\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::macros::FormatArgsExpn;\n+use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::{is_expn_of, match_function_call, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -79,28 +80,22 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitWrite {\n                         \"print\".into(),\n                     )\n                 };\n-                let msg = format!(\"use of `{}.unwrap()`\", used);\n-                if let [write_output] = *format_args.format_string_parts {\n-                    let mut write_output = write_output.to_string();\n-                    if write_output.ends_with('\\n') {\n-                        write_output.pop();\n-                    }\n-\n-                    let sugg = format!(\"{}{}!(\\\"{}\\\")\", prefix, sugg_mac, write_output.escape_default());\n-                    span_lint_and_sugg(\n-                        cx,\n-                        EXPLICIT_WRITE,\n-                        expr.span,\n-                        &msg,\n-                        \"try this\",\n-                        sugg,\n-                        Applicability::MachineApplicable\n-                    );\n-                } else {\n-                    // We don't have a proper suggestion\n-                    let help = format!(\"consider using `{}{}!` instead\", prefix, sugg_mac);\n-                    span_lint_and_help(cx, EXPLICIT_WRITE, expr.span, &msg, None, &help);\n-                }\n+                let mut applicability = Applicability::MachineApplicable;\n+                let inputs_snippet = snippet_with_applicability(\n+                    cx,\n+                    format_args.inputs_span(),\n+                    \"..\",\n+                    &mut applicability,\n+                );\n+                span_lint_and_sugg(\n+                    cx,\n+                    EXPLICIT_WRITE,\n+                    expr.span,\n+                    &format!(\"use of `{}.unwrap()`\", used),\n+                    \"try this\",\n+                    format!(\"{}{}!({})\", prefix, sugg_mac, inputs_snippet),\n+                    applicability,\n+                )\n             }\n         }\n     }"}, {"sha": "9f868df3ad063452f3dd45ebe960d2430fb1efc0", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -32,7 +32,6 @@ declare_clippy_lint! {\n     /// // Good\n     /// struct Foo(i32);\n     ///\n-    /// use std::convert::TryFrom;\n     /// impl TryFrom<String> for Foo {\n     ///     type Error = ();\n     ///     fn try_from(s: String) -> Result<Self, Self::Error> {\n@@ -86,9 +85,9 @@ fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_items: &[h\n \n             // check for `unwrap`\n             if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n-                let reciever_ty = self.typeck_results.expr_ty(&arglists[0][0]).peel_refs();\n-                if is_type_diagnostic_item(self.lcx, reciever_ty, sym::Option)\n-                    || is_type_diagnostic_item(self.lcx, reciever_ty, sym::Result)\n+                let receiver_ty = self.typeck_results.expr_ty(&arglists[0][0]).peel_refs();\n+                if is_type_diagnostic_item(self.lcx, receiver_ty, sym::Option)\n+                    || is_type_diagnostic_item(self.lcx, receiver_ty, sym::Result)\n                 {\n                     self.result.push(expr.span);\n                 }"}, {"sha": "dc6bef52ddd9fb3256168e3cec80fd9a2bfb0af1", "filename": "clippy_lints/src/feature_name.rs", "status": "removed", "additions": 0, "deletions": 166, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/cb29e3effbf72db2e1f5177336bfb3309ec8805e/clippy_lints%2Fsrc%2Ffeature_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb29e3effbf72db2e1f5177336bfb3309ec8805e/clippy_lints%2Fsrc%2Ffeature_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffeature_name.rs?ref=cb29e3effbf72db2e1f5177336bfb3309ec8805e", "patch": "@@ -1,166 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::{diagnostics::span_lint, is_lint_allowed};\n-use rustc_hir::CRATE_HIR_ID;\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::DUMMY_SP;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for feature names with prefix `use-`, `with-` or suffix `-support`\n-    ///\n-    /// ### Why is this bad?\n-    /// These prefixes and suffixes have no significant meaning.\n-    ///\n-    /// ### Example\n-    /// ```toml\n-    /// # The `Cargo.toml` with feature name redundancy\n-    /// [features]\n-    /// default = [\"use-abc\", \"with-def\", \"ghi-support\"]\n-    /// use-abc = []  // redundant\n-    /// with-def = []   // redundant\n-    /// ghi-support = []   // redundant\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```toml\n-    /// [features]\n-    /// default = [\"abc\", \"def\", \"ghi\"]\n-    /// abc = []\n-    /// def = []\n-    /// ghi = []\n-    /// ```\n-    ///\n-    #[clippy::version = \"1.57.0\"]\n-    pub REDUNDANT_FEATURE_NAMES,\n-    cargo,\n-    \"usage of a redundant feature name\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for negative feature names with prefix `no-` or `not-`\n-    ///\n-    /// ### Why is this bad?\n-    /// Features are supposed to be additive, and negatively-named features violate it.\n-    ///\n-    /// ### Example\n-    /// ```toml\n-    /// # The `Cargo.toml` with negative feature names\n-    /// [features]\n-    /// default = []\n-    /// no-abc = []\n-    /// not-def = []\n-    ///\n-    /// ```\n-    /// Use instead:\n-    /// ```toml\n-    /// [features]\n-    /// default = [\"abc\", \"def\"]\n-    /// abc = []\n-    /// def = []\n-    ///\n-    /// ```\n-    #[clippy::version = \"1.57.0\"]\n-    pub NEGATIVE_FEATURE_NAMES,\n-    cargo,\n-    \"usage of a negative feature name\"\n-}\n-\n-declare_lint_pass!(FeatureName => [REDUNDANT_FEATURE_NAMES, NEGATIVE_FEATURE_NAMES]);\n-\n-static PREFIXES: [&str; 8] = [\"no-\", \"no_\", \"not-\", \"not_\", \"use-\", \"use_\", \"with-\", \"with_\"];\n-static SUFFIXES: [&str; 2] = [\"-support\", \"_support\"];\n-\n-fn is_negative_prefix(s: &str) -> bool {\n-    s.starts_with(\"no\")\n-}\n-\n-fn lint(cx: &LateContext<'_>, feature: &str, substring: &str, is_prefix: bool) {\n-    let is_negative = is_prefix && is_negative_prefix(substring);\n-    span_lint_and_help(\n-        cx,\n-        if is_negative {\n-            NEGATIVE_FEATURE_NAMES\n-        } else {\n-            REDUNDANT_FEATURE_NAMES\n-        },\n-        DUMMY_SP,\n-        &format!(\n-            \"the \\\"{}\\\" {} in the feature name \\\"{}\\\" is {}\",\n-            substring,\n-            if is_prefix { \"prefix\" } else { \"suffix\" },\n-            feature,\n-            if is_negative { \"negative\" } else { \"redundant\" }\n-        ),\n-        None,\n-        &format!(\n-            \"consider renaming the feature to \\\"{}\\\"{}\",\n-            if is_prefix {\n-                feature.strip_prefix(substring)\n-            } else {\n-                feature.strip_suffix(substring)\n-            }\n-            .unwrap(),\n-            if is_negative {\n-                \", but make sure the feature adds functionality\"\n-            } else {\n-                \"\"\n-            }\n-        ),\n-    );\n-}\n-\n-impl LateLintPass<'_> for FeatureName {\n-    fn check_crate(&mut self, cx: &LateContext<'_>) {\n-        if is_lint_allowed(cx, REDUNDANT_FEATURE_NAMES, CRATE_HIR_ID)\n-            && is_lint_allowed(cx, NEGATIVE_FEATURE_NAMES, CRATE_HIR_ID)\n-        {\n-            return;\n-        }\n-\n-        let metadata = unwrap_cargo_metadata!(cx, REDUNDANT_FEATURE_NAMES, false);\n-\n-        for package in metadata.packages {\n-            let mut features: Vec<&String> = package.features.keys().collect();\n-            features.sort();\n-            for feature in features {\n-                let prefix_opt = {\n-                    let i = PREFIXES.partition_point(|prefix| prefix < &feature.as_str());\n-                    if i > 0 && feature.starts_with(PREFIXES[i - 1]) {\n-                        Some(PREFIXES[i - 1])\n-                    } else {\n-                        None\n-                    }\n-                };\n-                if let Some(prefix) = prefix_opt {\n-                    lint(cx, feature, prefix, true);\n-                }\n-\n-                let suffix_opt: Option<&str> = {\n-                    let i = SUFFIXES.partition_point(|suffix| {\n-                        suffix.bytes().rev().cmp(feature.bytes().rev()) == std::cmp::Ordering::Less\n-                    });\n-                    if i > 0 && feature.ends_with(SUFFIXES[i - 1]) {\n-                        Some(SUFFIXES[i - 1])\n-                    } else {\n-                        None\n-                    }\n-                };\n-                if let Some(suffix) = suffix_opt {\n-                    lint(cx, feature, suffix, false);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_prefixes_sorted() {\n-    let mut sorted_prefixes = PREFIXES;\n-    sorted_prefixes.sort_unstable();\n-    assert_eq!(PREFIXES, sorted_prefixes);\n-    let mut sorted_suffixes = SUFFIXES;\n-    sorted_suffixes.sort_by(|a, b| a.bytes().rev().cmp(b.bytes().rev()));\n-    assert_eq!(SUFFIXES, sorted_suffixes);\n-}"}, {"sha": "98aee7592ae80a496bde4da3e3f47327a7a547b3", "filename": "clippy_lints/src/float_equality_without_abs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -20,7 +20,7 @@ declare_clippy_lint! {\n     ///\n     /// ### Known problems\n     /// If the user can ensure that b is larger than a, the `.abs()` is\n-    /// technically unneccessary. However, it will make the code more robust and doesn't have any\n+    /// technically unnecessary. However, it will make the code more robust and doesn't have any\n     /// large performance implications. If the abs call was deliberately left out for performance\n     /// reasons, it is probably better to state this explicitly in the code, which then can be done\n     /// with an allow.\n@@ -69,7 +69,7 @@ impl<'tcx> LateLintPass<'tcx> for FloatEqualityWithoutAbs {\n \n         if_chain! {\n \n-            // left hand side is a substraction\n+            // left hand side is a subtraction\n             if let ExprKind::Binary(\n                 Spanned {\n                     node: BinOpKind::Sub,\n@@ -84,7 +84,7 @@ impl<'tcx> LateLintPass<'tcx> for FloatEqualityWithoutAbs {\n             if let Res::Def(DefKind::AssocConst, def_id) = cx.qpath_res(epsilon_path, rhs.hir_id);\n             if match_def_path(cx, def_id, &paths::F32_EPSILON) || match_def_path(cx, def_id, &paths::F64_EPSILON);\n \n-            // values of the substractions on the left hand side are of the type float\n+            // values of the subtractions on the left hand side are of the type float\n             let t_val_l = cx.typeck_results().expr_ty(val_l);\n             let t_val_r = cx.typeck_results().expr_ty(val_r);\n             if let ty::Float(_) = t_val_l.kind();"}, {"sha": "42503c26de1d1dcb1112fd1cf3a888a0acbec037", "filename": "clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -215,7 +215,7 @@ fn check_ln1p(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n // converted to an integer without loss of precision. For now we only check\n // ranges [-16777215, 16777216) for type f32 as whole number floats outside\n // this range are lossy and ambiguous.\n-#[allow(clippy::cast_possible_truncation)]\n+#[expect(clippy::cast_possible_truncation)]\n fn get_integer_from_float_constant(value: &Constant) -> Option<i32> {\n     match value {\n         F32(num) if num.fract() == 0.0 => {"}, {"sha": "64c41b565878b36772fe2d2e5d17882c2f867314", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -72,7 +72,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessFormat {\n             if_chain! {\n                 if format_args.format_string_parts == [kw::Empty];\n                 if match cx.typeck_results().expr_ty(value).peel_refs().kind() {\n-                    ty::Adt(adt, _) => cx.tcx.is_diagnostic_item(sym::String, adt.did),\n+                    ty::Adt(adt, _) => cx.tcx.is_diagnostic_item(sym::String, adt.did()),\n                     ty::Str => true,\n                     _ => false,\n                 };"}, {"sha": "1e6feaac26c3ab77e604572bd461efcc27803ca3", "filename": "clippy_lints/src/format_args.rs", "status": "modified", "additions": 4, "deletions": 24, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fformat_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fformat_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat_args.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,8 +1,8 @@\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n-use clippy_utils::macros::{FormatArgsArg, FormatArgsExpn};\n+use clippy_utils::is_diag_trait_item;\n+use clippy_utils::macros::{is_format_macro, FormatArgsArg, FormatArgsExpn};\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::implements_trait;\n-use clippy_utils::{is_diag_trait_item, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind};\n@@ -65,34 +65,14 @@ declare_clippy_lint! {\n \n declare_lint_pass!(FormatArgs => [FORMAT_IN_FORMAT_ARGS, TO_STRING_IN_FORMAT_ARGS]);\n \n-const FORMAT_MACRO_PATHS: &[&[&str]] = &[\n-    &paths::FORMAT_ARGS_MACRO,\n-    &paths::ASSERT_EQ_MACRO,\n-    &paths::ASSERT_MACRO,\n-    &paths::ASSERT_NE_MACRO,\n-    &paths::EPRINT_MACRO,\n-    &paths::EPRINTLN_MACRO,\n-    &paths::PRINT_MACRO,\n-    &paths::PRINTLN_MACRO,\n-    &paths::WRITE_MACRO,\n-    &paths::WRITELN_MACRO,\n-];\n-\n-const FORMAT_MACRO_DIAG_ITEMS: &[Symbol] = &[sym::format_macro, sym::std_panic_macro];\n-\n impl<'tcx> LateLintPass<'tcx> for FormatArgs {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n         if_chain! {\n             if let Some(format_args) = FormatArgsExpn::parse(cx, expr);\n             let expr_expn_data = expr.span.ctxt().outer_expn_data();\n             let outermost_expn_data = outermost_expn_data(expr_expn_data);\n             if let Some(macro_def_id) = outermost_expn_data.macro_def_id;\n-            if FORMAT_MACRO_PATHS\n-                .iter()\n-                .any(|path| match_def_path(cx, macro_def_id, path))\n-                || FORMAT_MACRO_DIAG_ITEMS\n-                    .iter()\n-                    .any(|diag_item| cx.tcx.is_diagnostic_item(*diag_item, macro_def_id));\n+            if is_format_macro(cx, macro_def_id);\n             if let ExpnKind::Macro(_, name) = outermost_expn_data.kind;\n             if let Some(args) = format_args.args();\n             then {\n@@ -211,7 +191,7 @@ where\n             if overloaded_deref.is_some() {\n                 n_needed = n_total;\n             }\n-            ty = target;\n+            ty = *target;\n         } else {\n             return (n_needed, ty);\n         }"}, {"sha": "ef8be9e878f6cb6f60a9342455e6d00b904987ad", "filename": "clippy_lints/src/format_impl.rs", "status": "added", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fformat_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fformat_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat_impl.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,253 @@\n+use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg};\n+use clippy_utils::macros::{is_format_macro, root_macro_call_first_node, FormatArgsArg, FormatArgsExpn};\n+use clippy_utils::{get_parent_as_impl, is_diag_trait_item, path_to_local, peel_ref_operators};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, Impl, ImplItem, ImplItemKind, QPath};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::{sym, symbol::kw, Symbol};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for format trait implementations (e.g. `Display`) with a recursive call to itself\n+    /// which uses `self` as a parameter.\n+    /// This is typically done indirectly with the `write!` macro or with `to_string()`.\n+    ///\n+    /// ### Why is this bad?\n+    /// This will lead to infinite recursion and a stack overflow.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// use std::fmt;\n+    ///\n+    /// struct Structure(i32);\n+    /// impl fmt::Display for Structure {\n+    ///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    ///         write!(f, \"{}\", self.to_string())\n+    ///     }\n+    /// }\n+    ///\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// use std::fmt;\n+    ///\n+    /// struct Structure(i32);\n+    /// impl fmt::Display for Structure {\n+    ///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    ///         write!(f, \"{}\", self.0)\n+    ///     }\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.48.0\"]\n+    pub RECURSIVE_FORMAT_IMPL,\n+    correctness,\n+    \"Format trait method called while implementing the same Format trait\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for use of `println`, `print`, `eprintln` or `eprint` in an\n+    /// implementation of a formatting trait.\n+    ///\n+    /// ### Why is this bad?\n+    /// Using a print macro is likely unintentional since formatting traits\n+    /// should write to the `Formatter`, not stdout/stderr.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// use std::fmt::{Display, Error, Formatter};\n+    ///\n+    /// struct S;\n+    /// impl Display for S {\n+    ///     fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n+    ///         println!(\"S\");\n+    ///\n+    ///         Ok(())\n+    ///     }\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// use std::fmt::{Display, Error, Formatter};\n+    ///\n+    /// struct S;\n+    /// impl Display for S {\n+    ///     fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n+    ///         writeln!(f, \"S\");\n+    ///\n+    ///         Ok(())\n+    ///     }\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.61.0\"]\n+    pub PRINT_IN_FORMAT_IMPL,\n+    suspicious,\n+    \"use of a print macro in a formatting trait impl\"\n+}\n+\n+#[derive(Clone, Copy)]\n+struct FormatTrait {\n+    /// e.g. `sym::Display`\n+    name: Symbol,\n+    /// `f` in `fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {}`\n+    formatter_name: Option<Symbol>,\n+}\n+\n+#[derive(Default)]\n+pub struct FormatImpl {\n+    // Whether we are inside Display or Debug trait impl - None for neither\n+    format_trait_impl: Option<FormatTrait>,\n+}\n+\n+impl FormatImpl {\n+    pub fn new() -> Self {\n+        Self {\n+            format_trait_impl: None,\n+        }\n+    }\n+}\n+\n+impl_lint_pass!(FormatImpl => [RECURSIVE_FORMAT_IMPL, PRINT_IN_FORMAT_IMPL]);\n+\n+impl<'tcx> LateLintPass<'tcx> for FormatImpl {\n+    fn check_impl_item(&mut self, cx: &LateContext<'_>, impl_item: &ImplItem<'_>) {\n+        self.format_trait_impl = is_format_trait_impl(cx, impl_item);\n+    }\n+\n+    fn check_impl_item_post(&mut self, cx: &LateContext<'_>, impl_item: &ImplItem<'_>) {\n+        // Assume no nested Impl of Debug and Display within eachother\n+        if is_format_trait_impl(cx, impl_item).is_some() {\n+            self.format_trait_impl = None;\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        let Some(format_trait_impl) = self.format_trait_impl else { return };\n+\n+        if format_trait_impl.name == sym::Display {\n+            check_to_string_in_display(cx, expr);\n+        }\n+\n+        check_self_in_format_args(cx, expr, format_trait_impl);\n+        check_print_in_format_impl(cx, expr, format_trait_impl);\n+    }\n+}\n+\n+fn check_to_string_in_display(cx: &LateContext<'_>, expr: &Expr<'_>) {\n+    if_chain! {\n+        // Get the hir_id of the object we are calling the method on\n+        if let ExprKind::MethodCall(path, [ref self_arg, ..], _) = expr.kind;\n+        // Is the method to_string() ?\n+        if path.ident.name == sym!(to_string);\n+        // Is the method a part of the ToString trait? (i.e. not to_string() implemented\n+        // separately)\n+        if let Some(expr_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+        if is_diag_trait_item(cx, expr_def_id, sym::ToString);\n+        // Is the method is called on self\n+        if let ExprKind::Path(QPath::Resolved(_, path)) = self_arg.kind;\n+        if let [segment] = path.segments;\n+        if segment.ident.name == kw::SelfLower;\n+        then {\n+            span_lint(\n+                cx,\n+                RECURSIVE_FORMAT_IMPL,\n+                expr.span,\n+                \"using `self.to_string` in `fmt::Display` implementation will cause infinite recursion\",\n+            );\n+        }\n+    }\n+}\n+\n+fn check_self_in_format_args<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, impl_trait: FormatTrait) {\n+    // Check each arg in format calls - do we ever use Display on self (directly or via deref)?\n+    if_chain! {\n+        if let Some(outer_macro) = root_macro_call_first_node(cx, expr);\n+        if let macro_def_id = outer_macro.def_id;\n+        if let Some(format_args) = FormatArgsExpn::find_nested(cx, expr, outer_macro.expn);\n+        if is_format_macro(cx, macro_def_id);\n+        if let Some(args) = format_args.args();\n+        then {\n+            for arg in args {\n+                if arg.format_trait != impl_trait.name {\n+                    continue;\n+                }\n+                check_format_arg_self(cx, expr, &arg, impl_trait);\n+            }\n+        }\n+    }\n+}\n+\n+fn check_format_arg_self(cx: &LateContext<'_>, expr: &Expr<'_>, arg: &FormatArgsArg<'_>, impl_trait: FormatTrait) {\n+    // Handle multiple dereferencing of references e.g. &&self\n+    // Handle dereference of &self -> self that is equivalent (i.e. via *self in fmt() impl)\n+    // Since the argument to fmt is itself a reference: &self\n+    let reference = peel_ref_operators(cx, arg.value);\n+    let map = cx.tcx.hir();\n+    // Is the reference self?\n+    if path_to_local(reference).map(|x| map.name(x)) == Some(kw::SelfLower) {\n+        let FormatTrait { name, .. } = impl_trait;\n+        span_lint(\n+            cx,\n+            RECURSIVE_FORMAT_IMPL,\n+            expr.span,\n+            &format!(\"using `self` as `{name}` in `impl {name}` will cause infinite recursion\"),\n+        );\n+    }\n+}\n+\n+fn check_print_in_format_impl(cx: &LateContext<'_>, expr: &Expr<'_>, impl_trait: FormatTrait) {\n+    if_chain! {\n+        if let Some(macro_call) = root_macro_call_first_node(cx, expr);\n+        if let Some(name) = cx.tcx.get_diagnostic_name(macro_call.def_id);\n+        then {\n+            let replacement = match name {\n+                sym::print_macro | sym::eprint_macro => \"write\",\n+                sym::println_macro | sym::eprintln_macro => \"writeln\",\n+                _ => return,\n+            };\n+\n+            let name = name.as_str().strip_suffix(\"_macro\").unwrap();\n+\n+            span_lint_and_sugg(\n+                cx,\n+                PRINT_IN_FORMAT_IMPL,\n+                macro_call.span,\n+                &format!(\"use of `{}!` in `{}` impl\", name, impl_trait.name),\n+                \"replace with\",\n+                if let Some(formatter_name) = impl_trait.formatter_name {\n+                    format!(\"{}!({}, ..)\", replacement, formatter_name)\n+                } else {\n+                    format!(\"{}!(..)\", replacement)\n+                },\n+                Applicability::HasPlaceholders,\n+            );\n+        }\n+    }\n+}\n+\n+fn is_format_trait_impl(cx: &LateContext<'_>, impl_item: &ImplItem<'_>) -> Option<FormatTrait> {\n+    if_chain! {\n+        if impl_item.ident.name == sym::fmt;\n+        if let ImplItemKind::Fn(_, body_id) = impl_item.kind;\n+        if let Some(Impl { of_trait: Some(trait_ref),..}) = get_parent_as_impl(cx.tcx, impl_item.hir_id());\n+        if let Some(did) = trait_ref.trait_def_id();\n+        if let Some(name) = cx.tcx.get_diagnostic_name(did);\n+        if matches!(name, sym::Debug | sym::Display);\n+        then {\n+            let body = cx.tcx.hir().body(body_id);\n+            let formatter_name = body.params.get(1)\n+                .and_then(|param| param.pat.simple_ident())\n+                .map(|ident| ident.name);\n+\n+            Some(FormatTrait {\n+                name,\n+                formatter_name,\n+            })\n+        } else {\n+            None\n+        }\n+    }\n+}"}, {"sha": "ee15ae9f59aca8eb96429d52464b3c53ae689a5b", "filename": "clippy_lints/src/format_push_string.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fformat_push_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fformat_push_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat_push_string.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,77 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{match_def_path, paths, peel_hir_expr_refs};\n+use rustc_hir::{BinOpKind, Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Detects cases where the result of a `format!` call is\n+    /// appended to an existing `String`.\n+    ///\n+    /// ### Why is this bad?\n+    /// Introduces an extra, avoidable heap allocation.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let mut s = String::new();\n+    /// s += &format!(\"0x{:X}\", 1024);\n+    /// s.push_str(&format!(\"0x{:X}\", 1024));\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// use std::fmt::Write as _; // import without risk of name clashing\n+    ///\n+    /// let mut s = String::new();\n+    /// let _ = write!(s, \"0x{:X}\", 1024);\n+    /// ```\n+    #[clippy::version = \"1.61.0\"]\n+    pub FORMAT_PUSH_STRING,\n+    perf,\n+    \"`format!(..)` appended to existing `String`\"\n+}\n+declare_lint_pass!(FormatPushString => [FORMAT_PUSH_STRING]);\n+\n+fn is_string(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n+    is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(e).peel_refs(), sym::String)\n+}\n+fn is_format(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n+    if let Some(macro_def_id) = e.span.ctxt().outer_expn_data().macro_def_id {\n+        cx.tcx.get_diagnostic_name(macro_def_id) == Some(sym::format_macro)\n+    } else {\n+        false\n+    }\n+}\n+\n+impl<'tcx> LateLintPass<'tcx> for FormatPushString {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        let arg = match expr.kind {\n+            ExprKind::MethodCall(_, [_, arg], _) => {\n+                if let Some(fn_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id) &&\n+                match_def_path(cx, fn_def_id, &paths::PUSH_STR) {\n+                    arg\n+                } else {\n+                    return;\n+                }\n+            }\n+            ExprKind::AssignOp(op, left, arg)\n+            if op.node == BinOpKind::Add && is_string(cx, left) => {\n+                arg\n+            },\n+            _ => return,\n+        };\n+        let (arg, _) = peel_hir_expr_refs(arg);\n+        if is_format(cx, arg) {\n+            span_lint_and_help(\n+                cx,\n+                FORMAT_PUSH_STRING,\n+                expr.span,\n+                \"`format!(..)` appended to existing `String`\",\n+                None,\n+                \"consider using `write!` to avoid the extra allocation\",\n+            );\n+        }\n+    }\n+}"}, {"sha": "57964b8d48ea9c4904282e191e097b044b140534", "filename": "clippy_lints/src/formatting.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformatting.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,5 +1,4 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_note};\n-use clippy_utils::differing_macro_contexts;\n use clippy_utils::source::snippet_opt;\n use if_chain::if_chain;\n use rustc_ast::ast::{BinOpKind, Block, Expr, ExprKind, StmtKind, UnOp};\n@@ -135,7 +134,7 @@ impl EarlyLintPass for Formatting {\n /// Implementation of the `SUSPICIOUS_ASSIGNMENT_FORMATTING` lint.\n fn check_assign(cx: &EarlyContext<'_>, expr: &Expr) {\n     if let ExprKind::Assign(ref lhs, ref rhs, _) = expr.kind {\n-        if !differing_macro_contexts(lhs.span, rhs.span) && !lhs.span.from_expansion() {\n+        if !lhs.span.from_expansion() && !rhs.span.from_expansion() {\n             let eq_span = lhs.span.between(rhs.span);\n             if let ExprKind::Unary(op, ref sub_rhs) = rhs.kind {\n                 if let Some(eq_snippet) = snippet_opt(cx, eq_span) {\n@@ -165,7 +164,7 @@ fn check_assign(cx: &EarlyContext<'_>, expr: &Expr) {\n fn check_unop(cx: &EarlyContext<'_>, expr: &Expr) {\n     if_chain! {\n         if let ExprKind::Binary(ref binop, ref lhs, ref rhs) = expr.kind;\n-        if !differing_macro_contexts(lhs.span, rhs.span) && !lhs.span.from_expansion();\n+        if !lhs.span.from_expansion() && !rhs.span.from_expansion();\n         // span between BinOp LHS and RHS\n         let binop_span = lhs.span.between(rhs.span);\n         // if RHS is an UnOp\n@@ -206,8 +205,8 @@ fn check_else(cx: &EarlyContext<'_>, expr: &Expr) {\n     if_chain! {\n         if let ExprKind::If(_, then, Some(else_)) = &expr.kind;\n         if is_block(else_) || is_if(else_);\n-        if !differing_macro_contexts(then.span, else_.span);\n-        if !then.span.from_expansion() && !in_external_macro(cx.sess(), expr.span);\n+        if !then.span.from_expansion() && !else_.span.from_expansion();\n+        if !in_external_macro(cx.sess(), expr.span);\n \n         // workaround for rust-lang/rust#43081\n         if expr.span.lo().0 != 0 && expr.span.hi().0 != 0;\n@@ -268,7 +267,7 @@ fn check_array(cx: &EarlyContext<'_>, expr: &Expr) {\n         for element in array {\n             if_chain! {\n                 if let ExprKind::Binary(ref op, ref lhs, _) = element.kind;\n-                if has_unary_equivalent(op.node) && !differing_macro_contexts(lhs.span, op.span);\n+                if has_unary_equivalent(op.node) && lhs.span.ctxt() == op.span.ctxt();\n                 let space_span = lhs.span.between(op.span);\n                 if let Some(space_snippet) = snippet_opt(cx, space_span);\n                 let lint_span = lhs.span.with_lo(lhs.span.hi());\n@@ -291,8 +290,7 @@ fn check_array(cx: &EarlyContext<'_>, expr: &Expr) {\n \n fn check_missing_else(cx: &EarlyContext<'_>, first: &Expr, second: &Expr) {\n     if_chain! {\n-        if !differing_macro_contexts(first.span, second.span);\n-        if !first.span.from_expansion();\n+        if !first.span.from_expansion() && !second.span.from_expansion();\n         if let ExprKind::If(cond_expr, ..) = &first.kind;\n         if is_block(second) || is_if(second);\n "}, {"sha": "5d25c1d06341f5bb57ccdd5e32b485226f61d30e", "filename": "clippy_lints/src/from_over_into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ffrom_over_into.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ffrom_over_into.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffrom_over_into.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -55,7 +55,7 @@ impl_lint_pass!(FromOverInto => [FROM_OVER_INTO]);\n \n impl<'tcx> LateLintPass<'tcx> for FromOverInto {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n-        if !meets_msrv(self.msrv.as_ref(), &msrvs::RE_REBALANCING_COHERENCE) {\n+        if !meets_msrv(self.msrv, msrvs::RE_REBALANCING_COHERENCE) {\n             return;\n         }\n "}, {"sha": "6672a6cb0b58fb7be926b3d0f074021645f602e2", "filename": "clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -13,14 +13,14 @@ use clippy_utils::attrs::is_proc_macro;\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_then};\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::is_must_use_ty;\n-use clippy_utils::{match_def_path, must_use_attr, return_ty, trait_ref_of_method};\n+use clippy_utils::{match_def_path, return_ty, trait_ref_of_method};\n \n use super::{DOUBLE_MUST_USE, MUST_USE_CANDIDATE, MUST_USE_UNIT};\n \n pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n     let attrs = cx.tcx.hir().attrs(item.hir_id());\n-    let attr = must_use_attr(attrs);\n-    if let hir::ItemKind::Fn(ref sig, ref _generics, ref body_id) = item.kind {\n+    let attr = cx.tcx.get_attr(item.def_id.to_def_id(), sym::must_use);\n+    if let hir::ItemKind::Fn(ref sig, _generics, ref body_id) = item.kind {\n         let is_public = cx.access_levels.is_exported(item.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n         if let Some(attr) = attr {\n@@ -44,7 +44,7 @@ pub(super) fn check_impl_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Imp\n         let is_public = cx.access_levels.is_exported(item.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n         let attrs = cx.tcx.hir().attrs(item.hir_id());\n-        let attr = must_use_attr(attrs);\n+        let attr = cx.tcx.get_attr(item.def_id.to_def_id(), sym::must_use);\n         if let Some(attr) = attr {\n             check_needless_must_use(cx, sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n         } else if is_public && !is_proc_macro(cx.sess(), attrs) && trait_ref_of_method(cx, item.def_id).is_none() {\n@@ -67,7 +67,7 @@ pub(super) fn check_trait_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Tr\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n \n         let attrs = cx.tcx.hir().attrs(item.hir_id());\n-        let attr = must_use_attr(attrs);\n+        let attr = cx.tcx.get_attr(item.def_id.to_def_id(), sym::must_use);\n         if let Some(attr) = attr {\n             check_needless_must_use(cx, sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n         } else if let hir::TraitFn::Provided(eid) = *eid {\n@@ -105,12 +105,7 @@ fn check_needless_must_use(\n             fn_header_span,\n             \"this unit-returning function has a `#[must_use]` attribute\",\n             |diag| {\n-                diag.span_suggestion(\n-                    attr.span,\n-                    \"remove the attribute\",\n-                    \"\".into(),\n-                    Applicability::MachineApplicable,\n-                );\n+                diag.span_suggestion(attr.span, \"remove the attribute\", \"\", Applicability::MachineApplicable);\n             },\n         );\n     } else if attr.value_str().is_none() && is_must_use_ty(cx, return_ty(cx, item_id)) {\n@@ -189,11 +184,11 @@ fn is_mutable_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span, tys: &m\n         // primitive types are never mutable\n         ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => false,\n         ty::Adt(adt, substs) => {\n-            tys.insert(adt.did) && !ty.is_freeze(cx.tcx.at(span), cx.param_env)\n-                || KNOWN_WRAPPER_TYS.iter().any(|path| match_def_path(cx, adt.did, path))\n+            tys.insert(adt.did()) && !ty.is_freeze(cx.tcx.at(span), cx.param_env)\n+                || KNOWN_WRAPPER_TYS.iter().any(|path| match_def_path(cx, adt.did(), path))\n                     && substs.types().any(|ty| is_mutable_ty(cx, ty, span, tys))\n         },\n-        ty::Tuple(substs) => substs.types().any(|ty| is_mutable_ty(cx, ty, span, tys)),\n+        ty::Tuple(substs) => substs.iter().any(|ty| is_mutable_ty(cx, ty, span, tys)),\n         ty::Array(ty, _) | ty::Slice(ty) => is_mutable_ty(cx, ty, span, tys),\n         ty::RawPtr(ty::TypeAndMut { ty, mutbl }) | ty::Ref(_, ty, mutbl) => {\n             mutbl == hir::Mutability::Mut || is_mutable_ty(cx, ty, span, tys)"}, {"sha": "565a1c871d7580458b633285ea8a84aa913e0410", "filename": "clippy_lints/src/functions/not_unsafe_ptr_arg_deref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -17,8 +17,8 @@ pub(super) fn check_fn<'tcx>(\n     hir_id: hir::HirId,\n ) {\n     let unsafety = match kind {\n-        intravisit::FnKind::ItemFn(_, _, hir::FnHeader { unsafety, .. }, _) => unsafety,\n-        intravisit::FnKind::Method(_, sig, _) => sig.header.unsafety,\n+        intravisit::FnKind::ItemFn(_, _, hir::FnHeader { unsafety, .. }) => unsafety,\n+        intravisit::FnKind::Method(_, sig) => sig.header.unsafety,\n         intravisit::FnKind::Closure => return,\n     };\n "}, {"sha": "2e63a1f920d64b39a69ad214ecd4cb6e03ada3a2", "filename": "clippy_lints/src/functions/result_unit_err.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ffunctions%2Fresult_unit_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ffunctions%2Fresult_unit_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fresult_unit_err.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -14,7 +14,7 @@ use clippy_utils::ty::is_type_diagnostic_item;\n use super::RESULT_UNIT_ERR;\n \n pub(super) fn check_item(cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-    if let hir::ItemKind::Fn(ref sig, ref _generics, _) = item.kind {\n+    if let hir::ItemKind::Fn(ref sig, _generics, _) = item.kind {\n         let is_public = cx.access_levels.is_exported(item.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n         if is_public {"}, {"sha": "5c8d8b8e7552c9e15f23b53a60f891a94357bf8a", "filename": "clippy_lints/src/functions/too_many_arguments.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_arguments.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -26,9 +26,8 @@ pub(super) fn check_fn(\n                     header: hir::FnHeader { abi: Abi::Rust, .. },\n                     ..\n                 },\n-                _,\n             )\n-            | intravisit::FnKind::ItemFn(_, _, hir::FnHeader { abi: Abi::Rust, .. }, _) => check_arg_number(\n+            | intravisit::FnKind::ItemFn(_, _, hir::FnHeader { abi: Abi::Rust, .. }) => check_arg_number(\n                 cx,\n                 decl,\n                 span.with_hi(decl.output.span().hi()),"}, {"sha": "5c46d6c7df7056856ed7afcd3d37f09b70cd2808", "filename": "clippy_lints/src/future_not_send.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffuture_not_send.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -5,7 +5,7 @@ use rustc_hir::{Body, FnDecl, HirId};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::subst::Subst;\n-use rustc_middle::ty::{Opaque, PredicateKind::Trait};\n+use rustc_middle::ty::{EarlyBinder, Opaque, PredicateKind::Trait};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{sym, Span};\n use rustc_trait_selection::traits::error_reporting::suggestions::InferCtxtExt;\n@@ -67,7 +67,7 @@ impl<'tcx> LateLintPass<'tcx> for FutureNotSend {\n             let preds = cx.tcx.explicit_item_bounds(id);\n             let mut is_future = false;\n             for &(p, _span) in preds {\n-                let p = p.subst(cx.tcx, subst);\n+                let p = EarlyBinder(p).subst(cx.tcx, subst);\n                 if let Some(trait_pred) = p.to_opt_poly_trait_pred() {\n                     if Some(trait_pred.skip_binder().trait_ref.def_id) == cx.tcx.lang_items().future_trait() {\n                         is_future = true;"}, {"sha": "0748ab45252ad3d8decd4ad9b8e80a99afc0f29c", "filename": "clippy_lints/src/get_first.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fget_first.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fget_first.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fget_first.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,69 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::{is_slice_of_primitives, match_def_path, paths};\n+use if_chain::if_chain;\n+use rustc_ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Spanned;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for using `x.get(0)` instead of\n+    /// `x.first()`.\n+    ///\n+    /// ### Why is this bad?\n+    /// Using `x.first()` is easier to read and has the same\n+    /// result.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// // Bad\n+    /// let x = vec![2, 3, 5];\n+    /// let first_element = x.get(0);\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// // Good\n+    /// let x = vec![2, 3, 5];\n+    /// let first_element = x.first();\n+    /// ```\n+    #[clippy::version = \"1.63.0\"]\n+    pub GET_FIRST,\n+    style,\n+    \"Using `x.get(0)` when `x.first()` is simpler\"\n+}\n+declare_lint_pass!(GetFirst => [GET_FIRST]);\n+\n+impl<'tcx> LateLintPass<'tcx> for GetFirst {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        if_chain! {\n+            if let hir::ExprKind::MethodCall(_, [struct_calling_on, method_arg], _) = &expr.kind;\n+            if let Some(expr_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+            if match_def_path(cx, expr_def_id, &paths::SLICE_GET);\n+\n+            if let Some(_) = is_slice_of_primitives(cx, struct_calling_on);\n+            if let hir::ExprKind::Lit(Spanned { node: LitKind::Int(0, _), .. }) = method_arg.kind;\n+\n+            then {\n+                let mut applicability = Applicability::MachineApplicable;\n+                let slice_name = snippet_with_applicability(\n+                    cx,\n+                    struct_calling_on.span, \"..\",\n+                    &mut applicability,\n+                );\n+                span_lint_and_sugg(\n+                    cx,\n+                    GET_FIRST,\n+                    expr.span,\n+                    &format!(\"accessing first element with `{0}.get(0)`\", slice_name),\n+                    \"try\",\n+                    format!(\"{}.first()\", slice_name),\n+                    applicability,\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "df29d9308e7124da07b112998729023abbba7e17", "filename": "clippy_lints/src/get_last_with_len.rs", "status": "removed", "additions": 0, "deletions": 107, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/cb29e3effbf72db2e1f5177336bfb3309ec8805e/clippy_lints%2Fsrc%2Fget_last_with_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb29e3effbf72db2e1f5177336bfb3309ec8805e/clippy_lints%2Fsrc%2Fget_last_with_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fget_last_with_len.rs?ref=cb29e3effbf72db2e1f5177336bfb3309ec8805e", "patch": "@@ -1,107 +0,0 @@\n-//! lint on using `x.get(x.len() - 1)` instead of `x.last()`\n-\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::SpanlessEq;\n-use if_chain::if_chain;\n-use rustc_ast::ast::LitKind;\n-use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Spanned;\n-use rustc_span::sym;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for using `x.get(x.len() - 1)` instead of\n-    /// `x.last()`.\n-    ///\n-    /// ### Why is this bad?\n-    /// Using `x.last()` is easier to read and has the same\n-    /// result.\n-    ///\n-    /// Note that using `x[x.len() - 1]` is semantically different from\n-    /// `x.last()`.  Indexing into the array will panic on out-of-bounds\n-    /// accesses, while `x.get()` and `x.last()` will return `None`.\n-    ///\n-    /// There is another lint (get_unwrap) that covers the case of using\n-    /// `x.get(index).unwrap()` instead of `x[index]`.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// // Bad\n-    /// let x = vec![2, 3, 5];\n-    /// let last_element = x.get(x.len() - 1);\n-    ///\n-    /// // Good\n-    /// let x = vec![2, 3, 5];\n-    /// let last_element = x.last();\n-    /// ```\n-    #[clippy::version = \"1.37.0\"]\n-    pub GET_LAST_WITH_LEN,\n-    complexity,\n-    \"Using `x.get(x.len() - 1)` when `x.last()` is correct and simpler\"\n-}\n-\n-declare_lint_pass!(GetLastWithLen => [GET_LAST_WITH_LEN]);\n-\n-impl<'tcx> LateLintPass<'tcx> for GetLastWithLen {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            // Is a method call\n-            if let ExprKind::MethodCall(path, args, _) = expr.kind;\n-\n-            // Method name is \"get\"\n-            if path.ident.name == sym!(get);\n-\n-            // Argument 0 (the struct we're calling the method on) is a vector\n-            if let Some(struct_calling_on) = args.get(0);\n-            let struct_ty = cx.typeck_results().expr_ty(struct_calling_on);\n-            if is_type_diagnostic_item(cx, struct_ty, sym::Vec);\n-\n-            // Argument to \"get\" is a subtraction\n-            if let Some(get_index_arg) = args.get(1);\n-            if let ExprKind::Binary(\n-                Spanned {\n-                    node: BinOpKind::Sub,\n-                    ..\n-                },\n-                lhs,\n-                rhs,\n-            ) = &get_index_arg.kind;\n-\n-            // LHS of subtraction is \"x.len()\"\n-            if let ExprKind::MethodCall(arg_lhs_path, lhs_args, _) = &lhs.kind;\n-            if arg_lhs_path.ident.name == sym::len;\n-            if let Some(arg_lhs_struct) = lhs_args.get(0);\n-\n-            // The two vectors referenced (x in x.get(...) and in x.len())\n-            if SpanlessEq::new(cx).eq_expr(struct_calling_on, arg_lhs_struct);\n-\n-            // RHS of subtraction is 1\n-            if let ExprKind::Lit(rhs_lit) = &rhs.kind;\n-            if let LitKind::Int(1, ..) = rhs_lit.node;\n-\n-            then {\n-                let mut applicability = Applicability::MachineApplicable;\n-                let vec_name = snippet_with_applicability(\n-                    cx,\n-                    struct_calling_on.span, \"vec\",\n-                    &mut applicability,\n-                );\n-\n-                span_lint_and_sugg(\n-                    cx,\n-                    GET_LAST_WITH_LEN,\n-                    expr.span,\n-                    &format!(\"accessing last element with `{0}.get({0}.len() - 1)`\", vec_name),\n-                    \"try\",\n-                    format!(\"{}.last()\", vec_name),\n-                    applicability,\n-                );\n-            }\n-        }\n-    }\n-}"}, {"sha": "419ea5a6811b87884acd5822d0e3fb979b7803ca", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 110, "deletions": 38, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,14 +1,14 @@\n-use clippy_utils::source::snippet;\n-use rustc_hir::{BinOp, BinOpKind, Expr, ExprKind};\n+use clippy_utils::consts::{constant_full_int, constant_simple, Constant, FullInt};\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::{clip, unsext};\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOp, BinOpKind, Expr, ExprKind, Node};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n \n-use clippy_utils::consts::{constant_simple, Constant};\n-use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::{clip, unsext};\n-\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for identity operations, e.g., `x + 0`.\n@@ -31,35 +31,83 @@ declare_clippy_lint! {\n declare_lint_pass!(IdentityOp => [IDENTITY_OP]);\n \n impl<'tcx> LateLintPass<'tcx> for IdentityOp {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        if e.span.from_expansion() {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if expr.span.from_expansion() {\n             return;\n         }\n-        if let ExprKind::Binary(cmp, left, right) = e.kind {\n-            if is_allowed(cx, cmp, left, right) {\n-                return;\n-            }\n-            match cmp.node {\n-                BinOpKind::Add | BinOpKind::BitOr | BinOpKind::BitXor => {\n-                    check(cx, left, 0, e.span, right.span);\n-                    check(cx, right, 0, e.span, left.span);\n-                },\n-                BinOpKind::Shl | BinOpKind::Shr | BinOpKind::Sub => check(cx, right, 0, e.span, left.span),\n-                BinOpKind::Mul => {\n-                    check(cx, left, 1, e.span, right.span);\n-                    check(cx, right, 1, e.span, left.span);\n-                },\n-                BinOpKind::Div => check(cx, right, 1, e.span, left.span),\n-                BinOpKind::BitAnd => {\n-                    check(cx, left, -1, e.span, right.span);\n-                    check(cx, right, -1, e.span, left.span);\n-                },\n-                _ => (),\n+        if let ExprKind::Binary(cmp, left, right) = &expr.kind {\n+            if !is_allowed(cx, *cmp, left, right) {\n+                match cmp.node {\n+                    BinOpKind::Add | BinOpKind::BitOr | BinOpKind::BitXor => {\n+                        check(cx, left, 0, expr.span, right.span, needs_parenthesis(cx, expr, right));\n+                        check(cx, right, 0, expr.span, left.span, Parens::Unneeded);\n+                    },\n+                    BinOpKind::Shl | BinOpKind::Shr | BinOpKind::Sub => {\n+                        check(cx, right, 0, expr.span, left.span, Parens::Unneeded);\n+                    },\n+                    BinOpKind::Mul => {\n+                        check(cx, left, 1, expr.span, right.span, needs_parenthesis(cx, expr, right));\n+                        check(cx, right, 1, expr.span, left.span, Parens::Unneeded);\n+                    },\n+                    BinOpKind::Div => check(cx, right, 1, expr.span, left.span, Parens::Unneeded),\n+                    BinOpKind::BitAnd => {\n+                        check(cx, left, -1, expr.span, right.span, needs_parenthesis(cx, expr, right));\n+                        check(cx, right, -1, expr.span, left.span, Parens::Unneeded);\n+                    },\n+                    BinOpKind::Rem => check_remainder(cx, left, right, expr.span, left.span),\n+                    _ => (),\n+                }\n             }\n         }\n     }\n }\n \n+#[derive(Copy, Clone)]\n+enum Parens {\n+    Needed,\n+    Unneeded,\n+}\n+\n+/// Checks if `left op right` needs parenthesis when reduced to `right`\n+/// e.g. `0 + if b { 1 } else { 2 } + if b { 3 } else { 4 }` cannot be reduced\n+/// to `if b { 1 } else { 2 } + if b { 3 } else { 4 }` where the `if` could be\n+/// interpreted as a statement\n+///\n+/// See #8724\n+fn needs_parenthesis(cx: &LateContext<'_>, binary: &Expr<'_>, right: &Expr<'_>) -> Parens {\n+    match right.kind {\n+        ExprKind::Binary(_, lhs, _) | ExprKind::Cast(lhs, _) => {\n+            // ensure we're checking against the leftmost expression of `right`\n+            //\n+            //     ~~~ `lhs`\n+            // 0 + {4} * 2\n+            //     ~~~~~~~ `right`\n+            return needs_parenthesis(cx, binary, lhs);\n+        },\n+        ExprKind::If(..) | ExprKind::Match(..) | ExprKind::Block(..) | ExprKind::Loop(..) => {},\n+        _ => return Parens::Unneeded,\n+    }\n+\n+    let mut prev_id = binary.hir_id;\n+    for (_, node) in cx.tcx.hir().parent_iter(binary.hir_id) {\n+        if let Node::Expr(expr) = node\n+            && let ExprKind::Binary(_, lhs, _) | ExprKind::Cast(lhs, _) = expr.kind\n+            && lhs.hir_id == prev_id\n+        {\n+            // keep going until we find a node that encompasses left of `binary`\n+            prev_id = expr.hir_id;\n+            continue;\n+        }\n+\n+        match node {\n+            Node::Block(_) | Node::Stmt(_) => break,\n+            _ => return Parens::Unneeded,\n+        };\n+    }\n+\n+    Parens::Needed\n+}\n+\n fn is_allowed(cx: &LateContext<'_>, cmp: BinOp, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n     // This lint applies to integers\n     !cx.typeck_results().expr_ty(left).peel_refs().is_integral()\n@@ -70,7 +118,19 @@ fn is_allowed(cx: &LateContext<'_>, cmp: BinOp, left: &Expr<'_>, right: &Expr<'_\n             && constant_simple(cx, cx.typeck_results(), left) == Some(Constant::Int(1)))\n }\n \n-fn check(cx: &LateContext<'_>, e: &Expr<'_>, m: i8, span: Span, arg: Span) {\n+fn check_remainder(cx: &LateContext<'_>, left: &Expr<'_>, right: &Expr<'_>, span: Span, arg: Span) {\n+    let lhs_const = constant_full_int(cx, cx.typeck_results(), left);\n+    let rhs_const = constant_full_int(cx, cx.typeck_results(), right);\n+    if match (lhs_const, rhs_const) {\n+        (Some(FullInt::S(lv)), Some(FullInt::S(rv))) => lv.abs() < rv.abs(),\n+        (Some(FullInt::U(lv)), Some(FullInt::U(rv))) => lv < rv,\n+        _ => return,\n+    } {\n+        span_ineffective_operation(cx, span, arg, Parens::Unneeded);\n+    }\n+}\n+\n+fn check(cx: &LateContext<'_>, e: &Expr<'_>, m: i8, span: Span, arg: Span, parens: Parens) {\n     if let Some(Constant::Int(v)) = constant_simple(cx, cx.typeck_results(), e).map(Constant::peel_refs) {\n         let check = match *cx.typeck_results().expr_ty(e).peel_refs().kind() {\n             ty::Int(ity) => unsext(cx.tcx, -1_i128, ity),\n@@ -83,15 +143,27 @@ fn check(cx: &LateContext<'_>, e: &Expr<'_>, m: i8, span: Span, arg: Span) {\n             1 => v == 1,\n             _ => unreachable!(),\n         } {\n-            span_lint(\n-                cx,\n-                IDENTITY_OP,\n-                span,\n-                &format!(\n-                    \"the operation is ineffective. Consider reducing it to `{}`\",\n-                    snippet(cx, arg, \"..\")\n-                ),\n-            );\n+            span_ineffective_operation(cx, span, arg, parens);\n         }\n     }\n }\n+\n+fn span_ineffective_operation(cx: &LateContext<'_>, span: Span, arg: Span, parens: Parens) {\n+    let mut applicability = Applicability::MachineApplicable;\n+    let expr_snippet = snippet_with_applicability(cx, arg, \"..\", &mut applicability);\n+\n+    let suggestion = match parens {\n+        Parens::Needed => format!(\"({expr_snippet})\"),\n+        Parens::Unneeded => expr_snippet.into_owned(),\n+    };\n+\n+    span_lint_and_sugg(\n+        cx,\n+        IDENTITY_OP,\n+        span,\n+        \"this operation has no effect\",\n+        \"consider reducing it to\",\n+        suggestion,\n+        applicability,\n+    );\n+}"}, {"sha": "b8d227855d97616c1f4171dcd4e0b621068e328f", "filename": "clippy_lints/src/if_then_some_else_none.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -57,7 +57,7 @@ impl_lint_pass!(IfThenSomeElseNone => [IF_THEN_SOME_ELSE_NONE]);\n \n impl<'tcx> LateLintPass<'tcx> for IfThenSomeElseNone {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &'tcx Expr<'_>) {\n-        if !meets_msrv(self.msrv.as_ref(), &msrvs::BOOL_THEN) {\n+        if !meets_msrv(self.msrv, msrvs::BOOL_THEN) {\n             return;\n         }\n "}, {"sha": "4f9680f60fe8b4422d51931e1cd96148c671640e", "filename": "clippy_lints/src/implicit_hasher.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fimplicit_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fimplicit_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_hasher.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,14 +1,14 @@\n use std::borrow::Cow;\n use std::collections::BTreeMap;\n \n-use rustc_errors::DiagnosticBuilder;\n+use rustc_errors::Diagnostic;\n use rustc_hir as hir;\n use rustc_hir::intravisit::{walk_body, walk_expr, walk_inf, walk_ty, Visitor};\n use rustc_hir::{Body, Expr, ExprKind, GenericArg, Item, ItemKind, QPath, TyKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::nested_filter;\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{Ty, TyS, TypeckResults};\n+use rustc_middle::ty::{Ty, TypeckResults};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::sym;\n@@ -17,7 +17,6 @@ use rustc_typeck::hir_ty_to_ty;\n use if_chain::if_chain;\n \n use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_then};\n-use clippy_utils::differing_macro_contexts;\n use clippy_utils::source::{snippet, snippet_opt};\n use clippy_utils::ty::is_type_diagnostic_item;\n \n@@ -63,13 +62,13 @@ declare_clippy_lint! {\n declare_lint_pass!(ImplicitHasher => [IMPLICIT_HASHER]);\n \n impl<'tcx> LateLintPass<'tcx> for ImplicitHasher {\n-    #[allow(clippy::cast_possible_truncation, clippy::too_many_lines)]\n+    #[expect(clippy::cast_possible_truncation, clippy::too_many_lines)]\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         use rustc_span::BytePos;\n \n         fn suggestion<'tcx>(\n             cx: &LateContext<'tcx>,\n-            diag: &mut DiagnosticBuilder<'_>,\n+            diag: &mut Diagnostic,\n             generics_span: Span,\n             generics_suggestion_span: Span,\n             target: &ImplicitHasherType<'_>,\n@@ -118,12 +117,12 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitHasher {\n         }\n \n         match item.kind {\n-            ItemKind::Impl(ref impl_) => {\n+            ItemKind::Impl(impl_) => {\n                 let mut vis = ImplicitHasherTypeVisitor::new(cx);\n                 vis.visit_ty(impl_.self_ty);\n \n                 for target in &vis.found {\n-                    if differing_macro_contexts(item.span, target.span()) {\n+                    if item.span.ctxt() != target.span().ctxt() {\n                         return;\n                     }\n \n@@ -156,7 +155,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitHasher {\n                     );\n                 }\n             },\n-            ItemKind::Fn(ref sig, ref generics, body_id) => {\n+            ItemKind::Fn(ref sig, generics, body_id) => {\n                 let body = cx.tcx.hir().body(body_id);\n \n                 for ty in sig.decl.inputs {\n@@ -346,7 +345,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'a, 'b, 't\n             if let TyKind::Path(QPath::Resolved(None, ty_path)) = ty.kind;\n             if let Some(ty_did) = ty_path.res.opt_def_id();\n             then {\n-                if !TyS::same_type(self.target.ty(), self.maybe_typeck_results.unwrap().expr_ty(e)) {\n+                if self.target.ty() != self.maybe_typeck_results.unwrap().expr_ty(e) {\n                     return;\n                 }\n "}, {"sha": "647947d5d30d6b9517ce96b785e9ee87ab81e26b", "filename": "clippy_lints/src/implicit_return.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_return.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -164,7 +164,7 @@ fn lint_implicit_returns(\n             })\n             .visit_block(block);\n             if add_return {\n-                #[allow(clippy::option_if_let_else)]\n+                #[expect(clippy::option_if_let_else)]\n                 if let Some(span) = call_site_span {\n                     lint_return(cx, span);\n                     LintLocation::Parent\n@@ -196,7 +196,7 @@ fn lint_implicit_returns(\n \n         _ =>\n         {\n-            #[allow(clippy::option_if_let_else)]\n+            #[expect(clippy::option_if_let_else)]\n             if let Some(span) = call_site_span {\n                 lint_return(cx, span);\n                 LintLocation::Parent"}, {"sha": "ae4158662d46459c26419250fe5a2cd62cece2cb", "filename": "clippy_lints/src/implicit_saturating_sub.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -3,7 +3,7 @@ use clippy_utils::{higher, peel_blocks_with_stmt, SpanlessEq};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n-use rustc_hir::{lang_items::LangItem, BinOpKind, Expr, ExprKind, QPath};\n+use rustc_hir::{BinOpKind, Expr, ExprKind, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -82,14 +82,6 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n \n                 // Get the variable name\n                 let var_name = ares_path.segments[0].ident.name.as_str();\n-                const INT_TYPES: [LangItem; 5] = [\n-                    LangItem::I8,\n-                    LangItem::I16,\n-                    LangItem::I32,\n-                    LangItem::I64,\n-                    LangItem::Isize\n-                ];\n-\n                 match cond_num_val.kind {\n                     ExprKind::Lit(ref cond_lit) => {\n                         // Check if the constant is zero\n@@ -105,8 +97,8 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n                             if name.ident.as_str() == \"MIN\";\n                             if let Some(const_id) = cx.typeck_results().type_dependent_def_id(cond_num_val.hir_id);\n                             if let Some(impl_id) = cx.tcx.impl_of_method(const_id);\n-                            let mut int_ids = INT_TYPES.iter().filter_map(|&ty| cx.tcx.lang_items().require(ty).ok());\n-                            if int_ids.any(|int_id| int_id == impl_id);\n+                            if let None = cx.tcx.impl_trait_ref(impl_id); // An inherent impl\n+                            if cx.tcx.type_of(impl_id).is_integral();\n                             then {\n                                 print_lint_and_sugg(cx, var_name, expr)\n                             }\n@@ -118,8 +110,8 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n                             if name.ident.as_str() == \"min_value\";\n                             if let Some(func_id) = cx.typeck_results().type_dependent_def_id(func.hir_id);\n                             if let Some(impl_id) = cx.tcx.impl_of_method(func_id);\n-                            let mut int_ids = INT_TYPES.iter().filter_map(|&ty| cx.tcx.lang_items().require(ty).ok());\n-                            if int_ids.any(|int_id| int_id == impl_id);\n+                            if let None = cx.tcx.impl_trait_ref(impl_id); // An inherent impl\n+                            if cx.tcx.type_of(impl_id).is_integral();\n                             then {\n                                 print_lint_and_sugg(cx, var_name, expr)\n                             }"}, {"sha": "14b22d2b50d054fdec8e0061666bf02d381bd518", "filename": "clippy_lints/src/inconsistent_struct_constructor.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Finconsistent_struct_constructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Finconsistent_struct_constructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finconsistent_struct_constructor.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -7,6 +7,7 @@ use rustc_hir::{self as hir, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::symbol::Symbol;\n+use std::fmt::Write as _;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -71,7 +72,7 @@ impl<'tcx> LateLintPass<'tcx> for InconsistentStructConstructor {\n             let ty = cx.typeck_results().expr_ty(expr);\n             if let Some(adt_def) = ty.ty_adt_def();\n             if adt_def.is_struct();\n-            if let Some(variant) = adt_def.variants.iter().next();\n+            if let Some(variant) = adt_def.variants().iter().next();\n             if fields.iter().all(|f| f.is_shorthand);\n             then {\n                 let mut def_order_map = FxHashMap::default();\n@@ -89,7 +90,7 @@ impl<'tcx> LateLintPass<'tcx> for InconsistentStructConstructor {\n                 let mut fields_snippet = String::new();\n                 let (last_ident, idents) = ordered_fields.split_last().unwrap();\n                 for ident in idents {\n-                    fields_snippet.push_str(&format!(\"{}, \", ident));\n+                    let _ = write!(fields_snippet, \"{}, \", ident);\n                 }\n                 fields_snippet.push_str(&last_ident.to_string());\n "}, {"sha": "9ce5b8e17a9ae45ea1ba304ad7331ea07635f217", "filename": "clippy_lints/src/index_refutable_slice.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Findex_refutable_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Findex_refutable_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Findex_refutable_slice.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -4,7 +4,7 @@ use clippy_utils::higher::IfLet;\n use clippy_utils::ty::is_copy;\n use clippy_utils::{is_expn_of, is_lint_allowed, meets_msrv, msrvs, path_to_local};\n use if_chain::if_chain;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::{FxHashSet, FxIndexMap};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, Visitor};\n@@ -14,7 +14,6 @@ use rustc_middle::ty;\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{symbol::Ident, Span};\n-use std::convert::TryInto;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -75,7 +74,7 @@ impl<'tcx> LateLintPass<'tcx> for IndexRefutableSlice {\n             if !expr.span.from_expansion() || is_expn_of(expr.span, \"if_chain\").is_some();\n             if let Some(IfLet {let_pat, if_then, ..}) = IfLet::hir(cx, expr);\n             if !is_lint_allowed(cx, INDEX_REFUTABLE_SLICE, expr.hir_id);\n-            if meets_msrv(self.msrv.as_ref(), &msrvs::SLICE_PATTERNS);\n+            if meets_msrv(self.msrv, msrvs::SLICE_PATTERNS);\n \n             let found_slices = find_slice_values(cx, let_pat);\n             if !found_slices.is_empty();\n@@ -92,9 +91,9 @@ impl<'tcx> LateLintPass<'tcx> for IndexRefutableSlice {\n     extract_msrv_attr!(LateContext);\n }\n \n-fn find_slice_values(cx: &LateContext<'_>, pat: &hir::Pat<'_>) -> FxHashMap<hir::HirId, SliceLintInformation> {\n+fn find_slice_values(cx: &LateContext<'_>, pat: &hir::Pat<'_>) -> FxIndexMap<hir::HirId, SliceLintInformation> {\n     let mut removed_pat: FxHashSet<hir::HirId> = FxHashSet::default();\n-    let mut slices: FxHashMap<hir::HirId, SliceLintInformation> = FxHashMap::default();\n+    let mut slices: FxIndexMap<hir::HirId, SliceLintInformation> = FxIndexMap::default();\n     pat.walk_always(|pat| {\n         if let hir::PatKind::Binding(binding, value_hir_id, ident, sub_pat) = pat.kind {\n             // We'll just ignore mut and ref mut for simplicity sake right now\n@@ -116,9 +115,9 @@ fn find_slice_values(cx: &LateContext<'_>, pat: &hir::Pat<'_>) -> FxHashMap<hir:\n             let bound_ty = cx.typeck_results().node_type(pat.hir_id);\n             if let ty::Slice(inner_ty) | ty::Array(inner_ty, _) = bound_ty.peel_refs().kind() {\n                 // The values need to use the `ref` keyword if they can't be copied.\n-                // This will need to be adjusted if the lint want to support multable access in the future\n+                // This will need to be adjusted if the lint want to support mutable access in the future\n                 let src_is_ref = bound_ty.is_ref() && binding != hir::BindingAnnotation::Ref;\n-                let needs_ref = !(src_is_ref || is_copy(cx, inner_ty));\n+                let needs_ref = !(src_is_ref || is_copy(cx, *inner_ty));\n \n                 let slice_info = slices\n                     .entry(value_hir_id)\n@@ -208,10 +207,10 @@ impl SliceLintInformation {\n \n fn filter_lintable_slices<'a, 'tcx>(\n     cx: &'a LateContext<'tcx>,\n-    slice_lint_info: FxHashMap<hir::HirId, SliceLintInformation>,\n+    slice_lint_info: FxIndexMap<hir::HirId, SliceLintInformation>,\n     max_suggested_slice: u64,\n     scope: &'tcx hir::Expr<'tcx>,\n-) -> FxHashMap<hir::HirId, SliceLintInformation> {\n+) -> FxIndexMap<hir::HirId, SliceLintInformation> {\n     let mut visitor = SliceIndexLintingVisitor {\n         cx,\n         slice_lint_info,\n@@ -225,7 +224,7 @@ fn filter_lintable_slices<'a, 'tcx>(\n \n struct SliceIndexLintingVisitor<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n-    slice_lint_info: FxHashMap<hir::HirId, SliceLintInformation>,\n+    slice_lint_info: FxIndexMap<hir::HirId, SliceLintInformation>,\n     max_suggested_slice: u64,\n }\n "}, {"sha": "4ba7477add82a420dc3b160da1782e880adf85a0", "filename": "clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Findexing_slicing.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -96,6 +96,10 @@ declare_lint_pass!(IndexingSlicing => [INDEXING_SLICING, OUT_OF_BOUNDS_INDEXING]\n \n impl<'tcx> LateLintPass<'tcx> for IndexingSlicing {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if cx.tcx.hir().is_inside_const_context(expr.hir_id) {\n+            return;\n+        }\n+\n         if let ExprKind::Index(array, index) = &expr.kind {\n             let ty = cx.typeck_results().expr_ty(array).peel_refs();\n             if let Some(range) = higher::Range::hir(index) {\n@@ -151,6 +155,10 @@ impl<'tcx> LateLintPass<'tcx> for IndexingSlicing {\n             } else {\n                 // Catchall non-range index, i.e., [n] or [n << m]\n                 if let ty::Array(..) = ty.kind() {\n+                    // Index is a const block.\n+                    if let ExprKind::ConstBlock(..) = index.kind {\n+                        return;\n+                    }\n                     // Index is a constant uint.\n                     if let Some(..) = constant(cx, cx.typeck_results(), index) {\n                         // Let rustc's `const_err` lint handle constant `usize` indexing on arrays."}, {"sha": "b2b9889f5dc74c21431c6bac8c98d842849044b7", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item};\n-use clippy_utils::{get_trait_def_id, higher, is_qpath_def_path, paths};\n+use clippy_utils::{higher, match_def_path, path_def_id, paths};\n use rustc_hir::{BorrowKind, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -167,13 +167,9 @@ fn is_infinite(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n         },\n         ExprKind::Block(block, _) => block.expr.as_ref().map_or(Finite, |e| is_infinite(cx, e)),\n         ExprKind::Box(e) | ExprKind::AddrOf(BorrowKind::Ref, _, e) => is_infinite(cx, e),\n-        ExprKind::Call(path, _) => {\n-            if let ExprKind::Path(ref qpath) = path.kind {\n-                is_qpath_def_path(cx, qpath, path.hir_id, &paths::ITER_REPEAT).into()\n-            } else {\n-                Finite\n-            }\n-        },\n+        ExprKind::Call(path, _) => path_def_id(cx, path)\n+            .map_or(false, |id| match_def_path(cx, id, &paths::ITER_REPEAT))\n+            .into(),\n         ExprKind::Struct(..) => higher::Range::hir(expr).map_or(false, |r| r.end.is_none()).into(),\n         _ => Finite,\n     }\n@@ -233,9 +229,12 @@ fn complete_infinite_iter(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n                 }\n             }\n             if method.ident.name == sym!(last) && args.len() == 1 {\n-                let not_double_ended = get_trait_def_id(cx, &paths::DOUBLE_ENDED_ITERATOR).map_or(false, |id| {\n-                    !implements_trait(cx, cx.typeck_results().expr_ty(&args[0]), id, &[])\n-                });\n+                let not_double_ended = cx\n+                    .tcx\n+                    .get_diagnostic_item(sym::DoubleEndedIterator)\n+                    .map_or(false, |id| {\n+                        !implements_trait(cx, cx.typeck_results().expr_ty(&args[0]), id, &[])\n+                    });\n                 if not_double_ended {\n                     return is_infinite(cx, &args[0]);\n                 }"}, {"sha": "6a031a627df946669e206ae77fb2255d21bf71e4", "filename": "clippy_lints/src/inherent_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Finherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Finherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finherent_impl.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -119,7 +119,7 @@ impl<'tcx> LateLintPass<'tcx> for MultipleInherentImpl {\n fn get_impl_span(cx: &LateContext<'_>, id: LocalDefId) -> Option<Span> {\n     let id = cx.tcx.hir().local_def_id_to_hir_id(id);\n     if let Node::Item(&Item {\n-        kind: ItemKind::Impl(ref impl_item),\n+        kind: ItemKind::Impl(impl_item),\n         span,\n         ..\n     }) = cx.tcx.hir().get(id)"}, {"sha": "7e1548531f10cc9301c558d013dcd133c30dc330", "filename": "clippy_lints/src/init_numbered_fields.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Finit_numbered_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Finit_numbered_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finit_numbered_fields.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,6 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use rustc_errors::Applicability;\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -49,6 +50,7 @@ impl<'tcx> LateLintPass<'tcx> for NumberedFields {\n                 && fields\n                     .iter()\n                     .all(|f| f.ident.as_str().as_bytes().iter().all(u8::is_ascii_digit))\n+                && !matches!(cx.qpath_res(path, e.hir_id), Res::Def(DefKind::TyAlias, ..))\n             {\n                 let expr_spans = fields\n                     .iter()"}, {"sha": "dd7177e0131ca5d3ef2ff523a6d68a1b023ccf26", "filename": "clippy_lints/src/inline_fn_without_body.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Finline_fn_without_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Finline_fn_without_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finline_fn_without_body.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,7 +1,7 @@\n //! checks for `#[inline]` on trait methods without bodies\n \n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::sugg::DiagnosticBuilderExt;\n+use clippy_utils::sugg::DiagnosticExt;\n use rustc_ast::ast::Attribute;\n use rustc_errors::Applicability;\n use rustc_hir::{TraitFn, TraitItem, TraitItemKind};"}, {"sha": "8db7b307ddb75e5fa1138eeb9c8188dc7245c4d8", "filename": "clippy_lints/src/int_plus_one.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fint_plus_one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fint_plus_one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fint_plus_one.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -52,7 +52,7 @@ enum Side {\n }\n \n impl IntPlusOne {\n-    #[allow(clippy::cast_sign_loss)]\n+    #[expect(clippy::cast_sign_loss)]\n     fn check_lit(lit: &Lit, target_value: i128) -> bool {\n         if let LitKind::Int(value, ..) = lit.kind {\n             return value == (target_value as u128);"}, {"sha": "27db6388136139e1789e570826078a7ddaeba901", "filename": "clippy_lints/src/large_const_arrays.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flarge_const_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flarge_const_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_const_arrays.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -53,9 +53,9 @@ impl<'tcx> LateLintPass<'tcx> for LargeConstArrays {\n             if let ItemKind::Const(hir_ty, _) = &item.kind;\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n             if let ty::Array(element_type, cst) = ty.kind();\n-            if let ConstKind::Value(ConstValue::Scalar(element_count)) = cst.val;\n+            if let ConstKind::Value(ConstValue::Scalar(element_count)) = cst.val();\n             if let Ok(element_count) = element_count.to_machine_usize(&cx.tcx);\n-            if let Ok(element_size) = cx.layout_of(element_type).map(|l| l.size.bytes());\n+            if let Ok(element_size) = cx.layout_of(*element_type).map(|l| l.size.bytes());\n             if self.maximum_allowed_size < element_count * element_size;\n \n             then {"}, {"sha": "0f3889a2936188a8ffdb83aea483ce7504727785", "filename": "clippy_lints/src/large_enum_variant.rs", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -81,37 +81,33 @@ impl<'tcx> LateLintPass<'tcx> for LargeEnumVariant {\n         if let ItemKind::Enum(ref def, _) = item.kind {\n             let ty = cx.tcx.type_of(item.def_id);\n             let adt = ty.ty_adt_def().expect(\"already checked whether this is an enum\");\n-            if adt.variants.len() <= 1 {\n+            if adt.variants().len() <= 1 {\n                 return;\n             }\n-            let mut variants_size: Vec<VariantInfo> = adt\n-                .variants\n-                .iter()\n-                .enumerate()\n-                .map(|(i, variant)| {\n-                    let mut fields_size = Vec::new();\n-                    let size: u64 = variant\n-                        .fields\n-                        .iter()\n-                        .enumerate()\n-                        .filter_map(|(i, f)| {\n-                            let ty = cx.tcx.type_of(f.did);\n-                            // don't count generics by filtering out everything\n-                            // that does not have a layout\n-                            cx.layout_of(ty).ok().map(|l| {\n-                                let size = l.size.bytes();\n-                                fields_size.push(FieldInfo { ind: i, size });\n-                                size\n-                            })\n-                        })\n-                        .sum();\n-                    VariantInfo {\n-                        ind: i,\n-                        size,\n-                        fields_size,\n+            let mut variants_size: Vec<VariantInfo> = Vec::new();\n+            for (i, variant) in adt.variants().iter().enumerate() {\n+                let mut fields_size = Vec::new();\n+                for (i, f) in variant.fields.iter().enumerate() {\n+                    let ty = cx.tcx.type_of(f.did);\n+                    // don't lint variants which have a field of generic type.\n+                    match cx.layout_of(ty) {\n+                        Ok(l) => {\n+                            let fsize = l.size.bytes();\n+                            fields_size.push(FieldInfo { ind: i, size: fsize });\n+                        },\n+                        Err(_) => {\n+                            return;\n+                        },\n                     }\n-                })\n-                .collect();\n+                }\n+                let size: u64 = fields_size.iter().map(|info| info.size).sum();\n+\n+                variants_size.push(VariantInfo {\n+                    ind: i,\n+                    size,\n+                    fields_size,\n+                });\n+            }\n \n             variants_size.sort_by(|a, b| (b.size.cmp(&a.size)));\n "}, {"sha": "8bef13c682dbfe86c92da5ba743fcc1af6efa975", "filename": "clippy_lints/src/large_include_file.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flarge_include_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flarge_include_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_include_file.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,86 @@\n+use clippy_utils::diagnostics::span_lint_and_note;\n+use clippy_utils::is_lint_allowed;\n+use clippy_utils::macros::root_macro_call_first_node;\n+use rustc_ast::LitKind;\n+use rustc_hir::Expr;\n+use rustc_hir::ExprKind;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::sym;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for the inclusion of large files via `include_bytes!()`\n+    /// and `include_str!()`\n+    ///\n+    /// ### Why is this bad?\n+    /// Including large files can increase the size of the binary\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// let included_str = include_str!(\"very_large_file.txt\");\n+    /// let included_bytes = include_bytes!(\"very_large_file.txt\");\n+    /// ```\n+    ///\n+    /// Instead, you can load the file at runtime:\n+    /// ```rust,ignore\n+    /// use std::fs;\n+    ///\n+    /// let string = fs::read_to_string(\"very_large_file.txt\")?;\n+    /// let bytes = fs::read(\"very_large_file.txt\")?;\n+    /// ```\n+    #[clippy::version = \"1.62.0\"]\n+    pub LARGE_INCLUDE_FILE,\n+    restriction,\n+    \"including a large file\"\n+}\n+\n+pub struct LargeIncludeFile {\n+    max_file_size: u64,\n+}\n+\n+impl LargeIncludeFile {\n+    #[must_use]\n+    pub fn new(max_file_size: u64) -> Self {\n+        Self { max_file_size }\n+    }\n+}\n+\n+impl_lint_pass!(LargeIncludeFile => [LARGE_INCLUDE_FILE]);\n+\n+impl LateLintPass<'_> for LargeIncludeFile {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &'_ Expr<'_>) {\n+        if_chain! {\n+            if let Some(macro_call) = root_macro_call_first_node(cx, expr);\n+            if !is_lint_allowed(cx, LARGE_INCLUDE_FILE, expr.hir_id);\n+            if cx.tcx.is_diagnostic_item(sym::include_bytes_macro, macro_call.def_id)\n+            || cx.tcx.is_diagnostic_item(sym::include_str_macro, macro_call.def_id);\n+            if let ExprKind::Lit(lit) = &expr.kind;\n+            then {\n+                let len = match &lit.node {\n+                    // include_bytes\n+                    LitKind::ByteStr(bstr) => bstr.len(),\n+                    // include_str\n+                    LitKind::Str(sym, _) => sym.as_str().len(),\n+                    _ => return,\n+                };\n+\n+                if len as u64 <= self.max_file_size {\n+                    return;\n+                }\n+\n+                span_lint_and_note(\n+                    cx,\n+                    LARGE_INCLUDE_FILE,\n+                    expr.span,\n+                    \"attempted to include a large file\",\n+                    None,\n+                    &format!(\n+                        \"the configuration allows a maximum size of {} bytes\",\n+                        self.max_file_size\n+                    ),\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "57b0d709acd4de9dcc4efef8062a037ddac23396", "filename": "clippy_lints/src/large_stack_arrays.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_stack_arrays.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -43,9 +43,9 @@ impl<'tcx> LateLintPass<'tcx> for LargeStackArrays {\n         if_chain! {\n             if let ExprKind::Repeat(_, _) = expr.kind;\n             if let ty::Array(element_type, cst) = cx.typeck_results().expr_ty(expr).kind();\n-            if let ConstKind::Value(ConstValue::Scalar(element_count)) = cst.val;\n+            if let ConstKind::Value(ConstValue::Scalar(element_count)) = cst.val();\n             if let Ok(element_count) = element_count.to_machine_usize(&cx.tcx);\n-            if let Ok(element_size) = cx.layout_of(element_type).map(|l| l.size.bytes());\n+            if let Ok(element_size) = cx.layout_of(*element_type).map(|l| l.size.bytes());\n             if self.maximum_allowed_size < element_count * element_size;\n             then {\n                 span_lint_and_help("}, {"sha": "dabbb8375f0a6ff97b030379624a2d3861cd8e7b", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -10,7 +10,7 @@ use rustc_hir::{\n     ItemKind, Mutability, Node, TraitItemRef, TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{self, AssocKind, FnSig, Ty, TyS};\n+use rustc_middle::ty::{self, AssocKind, FnSig, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{\n     source_map::{Span, Spanned, Symbol},\n@@ -248,13 +248,13 @@ enum LenOutput<'tcx> {\n fn parse_len_output<'tcx>(cx: &LateContext<'_>, sig: FnSig<'tcx>) -> Option<LenOutput<'tcx>> {\n     match *sig.output().kind() {\n         ty::Int(_) | ty::Uint(_) => Some(LenOutput::Integral),\n-        ty::Adt(adt, subs) if cx.tcx.is_diagnostic_item(sym::Option, adt.did) => {\n-            subs.type_at(0).is_integral().then(|| LenOutput::Option(adt.did))\n+        ty::Adt(adt, subs) if cx.tcx.is_diagnostic_item(sym::Option, adt.did()) => {\n+            subs.type_at(0).is_integral().then(|| LenOutput::Option(adt.did()))\n         },\n-        ty::Adt(adt, subs) if cx.tcx.is_diagnostic_item(sym::Result, adt.did) => subs\n+        ty::Adt(adt, subs) if cx.tcx.is_diagnostic_item(sym::Result, adt.did()) => subs\n             .type_at(0)\n             .is_integral()\n-            .then(|| LenOutput::Result(adt.did, subs.type_at(1))),\n+            .then(|| LenOutput::Result(adt.did(), subs.type_at(1))),\n         _ => None,\n     }\n }\n@@ -263,9 +263,9 @@ impl LenOutput<'_> {\n     fn matches_is_empty_output(self, ty: Ty<'_>) -> bool {\n         match (self, ty.kind()) {\n             (_, &ty::Bool) => true,\n-            (Self::Option(id), &ty::Adt(adt, subs)) if id == adt.did => subs.type_at(0).is_bool(),\n-            (Self::Result(id, err_ty), &ty::Adt(adt, subs)) if id == adt.did => {\n-                subs.type_at(0).is_bool() && TyS::same_type(subs.type_at(1), err_ty)\n+            (Self::Option(id), &ty::Adt(adt, subs)) if id == adt.did() => subs.type_at(0).is_bool(),\n+            (Self::Result(id, err_ty), &ty::Adt(adt, subs)) if id == adt.did() => {\n+                subs.type_at(0).is_bool() && subs.type_at(1) == err_ty\n             },\n             _ => false,\n         }\n@@ -294,7 +294,7 @@ impl LenOutput<'_> {\n /// Checks if the given signature matches the expectations for `is_empty`\n fn check_is_empty_sig(sig: FnSig<'_>, self_kind: ImplicitSelfKind, len_output: LenOutput<'_>) -> bool {\n     match &**sig.inputs_and_output {\n-        [arg, res] if len_output.matches_is_empty_output(res) => {\n+        [arg, res] if len_output.matches_is_empty_output(*res) => {\n             matches!(\n                 (arg.kind(), self_kind),\n                 (ty::Ref(_, _, Mutability::Not), ImplicitSelfKind::ImmRef)\n@@ -488,7 +488,7 @@ fn has_is_empty(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n                 .any(|item| is_is_empty(cx, item))\n         }),\n         ty::Projection(ref proj) => has_is_empty_impl(cx, proj.item_def_id),\n-        ty::Adt(id, _) => has_is_empty_impl(cx, id.did),\n+        ty::Adt(id, _) => has_is_empty_impl(cx, id.did()),\n         ty::Array(..) | ty::Slice(..) | ty::Str => true,\n         _ => false,\n     }"}, {"sha": "a028b41db7740af125b61df78aed18d3f7779cea", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 34, "deletions": 8, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -14,14 +14,22 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(attrs::DEPRECATED_SEMVER),\n     LintId::of(attrs::MISMATCHED_TARGET_OS),\n     LintId::of(attrs::USELESS_ATTRIBUTE),\n+    LintId::of(await_holding_invalid::AWAIT_HOLDING_INVALID_TYPE),\n+    LintId::of(await_holding_invalid::AWAIT_HOLDING_LOCK),\n+    LintId::of(await_holding_invalid::AWAIT_HOLDING_REFCELL_REF),\n     LintId::of(bit_mask::BAD_BIT_MASK),\n     LintId::of(bit_mask::INEFFECTIVE_BIT_MASK),\n     LintId::of(blacklisted_name::BLACKLISTED_NAME),\n     LintId::of(blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS),\n     LintId::of(bool_assert_comparison::BOOL_ASSERT_COMPARISON),\n     LintId::of(booleans::LOGIC_BUG),\n     LintId::of(booleans::NONMINIMAL_BOOL),\n+    LintId::of(bytes_count_to_len::BYTES_COUNT_TO_LEN),\n+    LintId::of(casts::CAST_ABS_TO_UNSIGNED),\n+    LintId::of(casts::CAST_ENUM_CONSTRUCTOR),\n+    LintId::of(casts::CAST_ENUM_TRUNCATION),\n     LintId::of(casts::CAST_REF_TO_MUT),\n+    LintId::of(casts::CAST_SLICE_DIFFERENT_SIZES),\n     LintId::of(casts::CHAR_LIT_AS_U8),\n     LintId::of(casts::FN_TO_NUMERIC_CAST),\n     LintId::of(casts::FN_TO_NUMERIC_CAST_WITH_TRUNCATION),\n@@ -32,21 +40,27 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(comparison_chain::COMPARISON_CHAIN),\n     LintId::of(copies::IFS_SAME_COND),\n     LintId::of(copies::IF_SAME_THEN_ELSE),\n+    LintId::of(crate_in_macro_def::CRATE_IN_MACRO_DEF),\n     LintId::of(default::FIELD_REASSIGN_WITH_DEFAULT),\n     LintId::of(dereference::NEEDLESS_BORROW),\n     LintId::of(derivable_impls::DERIVABLE_IMPLS),\n     LintId::of(derive::DERIVE_HASH_XOR_EQ),\n     LintId::of(derive::DERIVE_ORD_XOR_PARTIAL_ORD),\n+    LintId::of(derive::DERIVE_PARTIAL_EQ_WITHOUT_EQ),\n     LintId::of(disallowed_methods::DISALLOWED_METHODS),\n     LintId::of(disallowed_types::DISALLOWED_TYPES),\n     LintId::of(doc::MISSING_SAFETY_DOC),\n     LintId::of(doc::NEEDLESS_DOCTEST_MAIN),\n     LintId::of(double_comparison::DOUBLE_COMPARISONS),\n     LintId::of(double_parens::DOUBLE_PARENS),\n     LintId::of(drop_forget_ref::DROP_COPY),\n+    LintId::of(drop_forget_ref::DROP_NON_DROP),\n     LintId::of(drop_forget_ref::DROP_REF),\n     LintId::of(drop_forget_ref::FORGET_COPY),\n+    LintId::of(drop_forget_ref::FORGET_NON_DROP),\n     LintId::of(drop_forget_ref::FORGET_REF),\n+    LintId::of(drop_forget_ref::UNDROPPED_MANUALLY_DROPS),\n+    LintId::of(duplicate_mod::DUPLICATE_MOD),\n     LintId::of(duration_subsec::DURATION_SUBSEC),\n     LintId::of(entry::MAP_ENTRY),\n     LintId::of(enum_clike::ENUM_CLIKE_UNPORTABLE_VARIANT),\n@@ -57,14 +71,15 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(erasing_op::ERASING_OP),\n     LintId::of(escape::BOXED_LOCAL),\n     LintId::of(eta_reduction::REDUNDANT_CLOSURE),\n-    LintId::of(eval_order_dependence::DIVERGING_SUB_EXPRESSION),\n-    LintId::of(eval_order_dependence::EVAL_ORDER_DEPENDENCE),\n     LintId::of(explicit_write::EXPLICIT_WRITE),\n     LintId::of(float_equality_without_abs::FLOAT_EQUALITY_WITHOUT_ABS),\n     LintId::of(float_literal::EXCESSIVE_PRECISION),\n     LintId::of(format::USELESS_FORMAT),\n     LintId::of(format_args::FORMAT_IN_FORMAT_ARGS),\n     LintId::of(format_args::TO_STRING_IN_FORMAT_ARGS),\n+    LintId::of(format_impl::PRINT_IN_FORMAT_IMPL),\n+    LintId::of(format_impl::RECURSIVE_FORMAT_IMPL),\n+    LintId::of(format_push_string::FORMAT_PUSH_STRING),\n     LintId::of(formatting::POSSIBLE_MISSING_COMMA),\n     LintId::of(formatting::SUSPICIOUS_ASSIGNMENT_FORMATTING),\n     LintId::of(formatting::SUSPICIOUS_ELSE_FORMATTING),\n@@ -76,7 +91,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(functions::NOT_UNSAFE_PTR_ARG_DEREF),\n     LintId::of(functions::RESULT_UNIT_ERR),\n     LintId::of(functions::TOO_MANY_ARGUMENTS),\n-    LintId::of(get_last_with_len::GET_LAST_WITH_LEN),\n+    LintId::of(get_first::GET_FIRST),\n     LintId::of(identity_op::IDENTITY_OP),\n     LintId::of(if_let_mutex::IF_LET_MUTEX),\n     LintId::of(indexing_slicing::OUT_OF_BOUNDS_INDEXING),\n@@ -104,6 +119,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(loops::ITER_NEXT_LOOP),\n     LintId::of(loops::MANUAL_FLATTEN),\n     LintId::of(loops::MANUAL_MEMCPY),\n+    LintId::of(loops::MISSING_SPIN_LOOP),\n     LintId::of(loops::MUT_RANGE_BOUND),\n     LintId::of(loops::NEEDLESS_COLLECT),\n     LintId::of(loops::NEEDLESS_RANGE_LOOP),\n@@ -131,6 +147,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(matches::MATCH_OVERLAPPING_ARM),\n     LintId::of(matches::MATCH_REF_PATS),\n     LintId::of(matches::MATCH_SINGLE_BINDING),\n+    LintId::of(matches::NEEDLESS_MATCH),\n     LintId::of(matches::REDUNDANT_PATTERN_MATCHING),\n     LintId::of(matches::SINGLE_MATCH),\n     LintId::of(matches::WILDCARD_IN_OR_PATTERNS),\n@@ -143,13 +160,16 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(methods::CHARS_NEXT_CMP),\n     LintId::of(methods::CLONE_DOUBLE_REF),\n     LintId::of(methods::CLONE_ON_COPY),\n+    LintId::of(methods::ERR_EXPECT),\n     LintId::of(methods::EXPECT_FUN_CALL),\n     LintId::of(methods::EXTEND_WITH_DRAIN),\n     LintId::of(methods::FILTER_MAP_IDENTITY),\n     LintId::of(methods::FILTER_NEXT),\n     LintId::of(methods::FLAT_MAP_IDENTITY),\n+    LintId::of(methods::GET_LAST_WITH_LEN),\n     LintId::of(methods::INSPECT_FOR_EACH),\n     LintId::of(methods::INTO_ITER_ON_REF),\n+    LintId::of(methods::IS_DIGIT_ASCII_RADIX),\n     LintId::of(methods::ITERATOR_STEP_BY_ZERO),\n     LintId::of(methods::ITER_CLONED_COLLECT),\n     LintId::of(methods::ITER_COUNT),\n@@ -166,13 +186,17 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(methods::MAP_COLLECT_RESULT_UNIT),\n     LintId::of(methods::MAP_FLATTEN),\n     LintId::of(methods::MAP_IDENTITY),\n+    LintId::of(methods::NEEDLESS_OPTION_AS_DEREF),\n+    LintId::of(methods::NEEDLESS_OPTION_TAKE),\n     LintId::of(methods::NEEDLESS_SPLITN),\n     LintId::of(methods::NEW_RET_NO_SELF),\n+    LintId::of(methods::NO_EFFECT_REPLACE),\n     LintId::of(methods::OK_EXPECT),\n     LintId::of(methods::OPTION_AS_REF_DEREF),\n     LintId::of(methods::OPTION_FILTER_MAP),\n     LintId::of(methods::OPTION_MAP_OR_NONE),\n     LintId::of(methods::OR_FUN_CALL),\n+    LintId::of(methods::OR_THEN_UNWRAP),\n     LintId::of(methods::RESULT_MAP_OR_INTO_OPTION),\n     LintId::of(methods::SEARCH_IS_SOME),\n     LintId::of(methods::SHOULD_IMPLEMENT_TRAIT),\n@@ -184,6 +208,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(methods::SUSPICIOUS_SPLITN),\n     LintId::of(methods::UNINIT_ASSUMED_INIT),\n     LintId::of(methods::UNNECESSARY_FILTER_MAP),\n+    LintId::of(methods::UNNECESSARY_FIND_MAP),\n     LintId::of(methods::UNNECESSARY_FOLD),\n     LintId::of(methods::UNNECESSARY_LAZY_EVALUATIONS),\n     LintId::of(methods::UNNECESSARY_TO_OWNED),\n@@ -205,6 +230,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(misc_early::REDUNDANT_PATTERN),\n     LintId::of(misc_early::UNNEEDED_WILDCARD_PATTERN),\n     LintId::of(misc_early::ZERO_PREFIXED_LITERAL),\n+    LintId::of(mixed_read_write_in_expression::DIVERGING_SUB_EXPRESSION),\n     LintId::of(mut_key::MUTABLE_KEY_TYPE),\n     LintId::of(mut_mutex_lock::MUT_MUTEX_LOCK),\n     LintId::of(mut_reference::UNNECESSARY_MUT_PASSED),\n@@ -213,7 +239,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(needless_bool::NEEDLESS_BOOL),\n     LintId::of(needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE),\n     LintId::of(needless_late_init::NEEDLESS_LATE_INIT),\n-    LintId::of(needless_option_as_deref::NEEDLESS_OPTION_AS_DEREF),\n     LintId::of(needless_question_mark::NEEDLESS_QUESTION_MARK),\n     LintId::of(needless_update::NEEDLESS_UPDATE),\n     LintId::of(neg_cmp_op_on_partial_ord::NEG_CMP_OP_ON_PARTIAL_ORD),\n@@ -241,6 +266,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(ranges::MANUAL_RANGE_CONTAINS),\n     LintId::of(ranges::RANGE_ZIP_WITH_LEN),\n     LintId::of(ranges::REVERSED_EMPTY_RANGES),\n+    LintId::of(rc_clone_in_vec_init::RC_CLONE_IN_VEC_INIT),\n     LintId::of(redundant_clone::REDUNDANT_CLONE),\n     LintId::of(redundant_closure_call::REDUNDANT_CLOSURE_CALL),\n     LintId::of(redundant_field_names::REDUNDANT_FIELD_NAMES),\n@@ -254,11 +280,12 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(self_assignment::SELF_ASSIGNMENT),\n     LintId::of(self_named_constructors::SELF_NAMED_CONSTRUCTORS),\n     LintId::of(serde_api::SERDE_API_MISUSE),\n+    LintId::of(significant_drop_in_scrutinee::SIGNIFICANT_DROP_IN_SCRUTINEE),\n     LintId::of(single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS),\n     LintId::of(size_of_in_element_count::SIZE_OF_IN_ELEMENT_COUNT),\n     LintId::of(slow_vector_initialization::SLOW_VECTOR_INITIALIZATION),\n-    LintId::of(stable_sort_primitive::STABLE_SORT_PRIMITIVE),\n     LintId::of(strings::STRING_FROM_UTF8_AS_BYTES),\n+    LintId::of(strings::TRIM_SPLIT_WHITESPACE),\n     LintId::of(strlen_on_c_strings::STRLEN_ON_C_STRINGS),\n     LintId::of(suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL),\n     LintId::of(suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL),\n@@ -267,7 +294,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(tabs_in_doc_comments::TABS_IN_DOC_COMMENTS),\n     LintId::of(temporary_assignment::TEMPORARY_ASSIGNMENT),\n     LintId::of(to_digit_is_some::TO_DIGIT_IS_SOME),\n-    LintId::of(to_string_in_display::TO_STRING_IN_DISPLAY),\n     LintId::of(transmute::CROSSPOINTER_TRANSMUTE),\n     LintId::of(transmute::TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS),\n     LintId::of(transmute::TRANSMUTE_BYTES_TO_STR),\n@@ -280,21 +306,21 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(transmute::UNSOUND_COLLECTION_TRANSMUTE),\n     LintId::of(transmute::WRONG_TRANSMUTE),\n     LintId::of(transmuting_null::TRANSMUTING_NULL),\n-    LintId::of(try_err::TRY_ERR),\n     LintId::of(types::BORROWED_BOX),\n     LintId::of(types::BOX_COLLECTION),\n     LintId::of(types::REDUNDANT_ALLOCATION),\n     LintId::of(types::TYPE_COMPLEXITY),\n     LintId::of(types::VEC_BOX),\n-    LintId::of(undropped_manually_drops::UNDROPPED_MANUALLY_DROPS),\n     LintId::of(unicode::INVISIBLE_CHARACTERS),\n     LintId::of(uninit_vec::UNINIT_VEC),\n     LintId::of(unit_hash::UNIT_HASH),\n     LintId::of(unit_return_expecting_ord::UNIT_RETURN_EXPECTING_ORD),\n+    LintId::of(unit_types::LET_UNIT_VALUE),\n     LintId::of(unit_types::UNIT_ARG),\n     LintId::of(unit_types::UNIT_CMP),\n     LintId::of(unnamed_address::FN_ADDRESS_COMPARISONS),\n     LintId::of(unnamed_address::VTABLE_ADDRESS_COMPARISONS),\n+    LintId::of(unnecessary_owned_empty_strings::UNNECESSARY_OWNED_EMPTY_STRINGS),\n     LintId::of(unnecessary_sort_by::UNNECESSARY_SORT_BY),\n     LintId::of(unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME),\n     LintId::of(unused_io_amount::UNUSED_IO_AMOUNT),"}, {"sha": "c890523fe5aebc1808dba4de08d1d4956f2fca28", "filename": "clippy_lints/src/lib.register_cargo.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flib.register_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flib.register_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_cargo.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -3,9 +3,9 @@\n // Manual edits will be overwritten.\n \n store.register_group(true, \"clippy::cargo\", Some(\"clippy_cargo\"), vec![\n-    LintId::of(cargo_common_metadata::CARGO_COMMON_METADATA),\n-    LintId::of(feature_name::NEGATIVE_FEATURE_NAMES),\n-    LintId::of(feature_name::REDUNDANT_FEATURE_NAMES),\n-    LintId::of(multiple_crate_versions::MULTIPLE_CRATE_VERSIONS),\n-    LintId::of(wildcard_dependencies::WILDCARD_DEPENDENCIES),\n+    LintId::of(cargo::CARGO_COMMON_METADATA),\n+    LintId::of(cargo::MULTIPLE_CRATE_VERSIONS),\n+    LintId::of(cargo::NEGATIVE_FEATURE_NAMES),\n+    LintId::of(cargo::REDUNDANT_FEATURE_NAMES),\n+    LintId::of(cargo::WILDCARD_DEPENDENCIES),\n ])"}, {"sha": "d5dfcd10a66834c33298276a8344891943a878f2", "filename": "clippy_lints/src/lib.register_complexity.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_complexity.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -5,17 +5,16 @@\n store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec![\n     LintId::of(attrs::DEPRECATED_CFG_ATTR),\n     LintId::of(booleans::NONMINIMAL_BOOL),\n+    LintId::of(bytes_count_to_len::BYTES_COUNT_TO_LEN),\n     LintId::of(casts::CHAR_LIT_AS_U8),\n     LintId::of(casts::UNNECESSARY_CAST),\n     LintId::of(derivable_impls::DERIVABLE_IMPLS),\n     LintId::of(double_comparison::DOUBLE_COMPARISONS),\n     LintId::of(double_parens::DOUBLE_PARENS),\n     LintId::of(duration_subsec::DURATION_SUBSEC),\n-    LintId::of(eval_order_dependence::DIVERGING_SUB_EXPRESSION),\n     LintId::of(explicit_write::EXPLICIT_WRITE),\n     LintId::of(format::USELESS_FORMAT),\n     LintId::of(functions::TOO_MANY_ARGUMENTS),\n-    LintId::of(get_last_with_len::GET_LAST_WITH_LEN),\n     LintId::of(identity_op::IDENTITY_OP),\n     LintId::of(int_plus_one::INT_PLUS_ONE),\n     LintId::of(lifetimes::EXTRA_UNUSED_LIFETIMES),\n@@ -30,34 +29,40 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(map_unit_fn::RESULT_MAP_UNIT_FN),\n     LintId::of(matches::MATCH_AS_REF),\n     LintId::of(matches::MATCH_SINGLE_BINDING),\n+    LintId::of(matches::NEEDLESS_MATCH),\n     LintId::of(matches::WILDCARD_IN_OR_PATTERNS),\n     LintId::of(methods::BIND_INSTEAD_OF_MAP),\n     LintId::of(methods::CLONE_ON_COPY),\n     LintId::of(methods::FILTER_MAP_IDENTITY),\n     LintId::of(methods::FILTER_NEXT),\n     LintId::of(methods::FLAT_MAP_IDENTITY),\n+    LintId::of(methods::GET_LAST_WITH_LEN),\n     LintId::of(methods::INSPECT_FOR_EACH),\n     LintId::of(methods::ITER_COUNT),\n     LintId::of(methods::MANUAL_FILTER_MAP),\n     LintId::of(methods::MANUAL_FIND_MAP),\n     LintId::of(methods::MANUAL_SPLIT_ONCE),\n     LintId::of(methods::MAP_FLATTEN),\n     LintId::of(methods::MAP_IDENTITY),\n+    LintId::of(methods::NEEDLESS_OPTION_AS_DEREF),\n+    LintId::of(methods::NEEDLESS_OPTION_TAKE),\n     LintId::of(methods::NEEDLESS_SPLITN),\n     LintId::of(methods::OPTION_AS_REF_DEREF),\n     LintId::of(methods::OPTION_FILTER_MAP),\n+    LintId::of(methods::OR_THEN_UNWRAP),\n     LintId::of(methods::SEARCH_IS_SOME),\n     LintId::of(methods::SKIP_WHILE_NEXT),\n     LintId::of(methods::UNNECESSARY_FILTER_MAP),\n+    LintId::of(methods::UNNECESSARY_FIND_MAP),\n     LintId::of(methods::USELESS_ASREF),\n     LintId::of(misc::SHORT_CIRCUIT_STATEMENT),\n     LintId::of(misc_early::UNNEEDED_WILDCARD_PATTERN),\n     LintId::of(misc_early::ZERO_PREFIXED_LITERAL),\n+    LintId::of(mixed_read_write_in_expression::DIVERGING_SUB_EXPRESSION),\n     LintId::of(needless_arbitrary_self_type::NEEDLESS_ARBITRARY_SELF_TYPE),\n     LintId::of(needless_bool::BOOL_COMPARISON),\n     LintId::of(needless_bool::NEEDLESS_BOOL),\n     LintId::of(needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE),\n-    LintId::of(needless_option_as_deref::NEEDLESS_OPTION_AS_DEREF),\n     LintId::of(needless_question_mark::NEEDLESS_QUESTION_MARK),\n     LintId::of(needless_update::NEEDLESS_UPDATE),\n     LintId::of(neg_cmp_op_on_partial_ord::NEG_CMP_OP_ON_PARTIAL_ORD),"}, {"sha": "6bf2c4bbaedc024ad45ac7970c6fc030be7c9d67", "filename": "clippy_lints/src/lib.register_correctness.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flib.register_correctness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flib.register_correctness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_correctness.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -13,6 +13,7 @@ store.register_group(true, \"clippy::correctness\", Some(\"clippy_correctness\"), ve\n     LintId::of(bit_mask::INEFFECTIVE_BIT_MASK),\n     LintId::of(booleans::LOGIC_BUG),\n     LintId::of(casts::CAST_REF_TO_MUT),\n+    LintId::of(casts::CAST_SLICE_DIFFERENT_SIZES),\n     LintId::of(copies::IFS_SAME_COND),\n     LintId::of(copies::IF_SAME_THEN_ELSE),\n     LintId::of(derive::DERIVE_HASH_XOR_EQ),\n@@ -21,9 +22,11 @@ store.register_group(true, \"clippy::correctness\", Some(\"clippy_correctness\"), ve\n     LintId::of(drop_forget_ref::DROP_REF),\n     LintId::of(drop_forget_ref::FORGET_COPY),\n     LintId::of(drop_forget_ref::FORGET_REF),\n+    LintId::of(drop_forget_ref::UNDROPPED_MANUALLY_DROPS),\n     LintId::of(enum_clike::ENUM_CLIKE_UNPORTABLE_VARIANT),\n     LintId::of(eq_op::EQ_OP),\n     LintId::of(erasing_op::ERASING_OP),\n+    LintId::of(format_impl::RECURSIVE_FORMAT_IMPL),\n     LintId::of(formatting::POSSIBLE_MISSING_COMMA),\n     LintId::of(functions::NOT_UNSAFE_PTR_ARG_DEREF),\n     LintId::of(if_let_mutex::IF_LET_MUTEX),\n@@ -57,11 +60,9 @@ store.register_group(true, \"clippy::correctness\", Some(\"clippy_correctness\"), ve\n     LintId::of(serde_api::SERDE_API_MISUSE),\n     LintId::of(size_of_in_element_count::SIZE_OF_IN_ELEMENT_COUNT),\n     LintId::of(swap::ALMOST_SWAPPED),\n-    LintId::of(to_string_in_display::TO_STRING_IN_DISPLAY),\n     LintId::of(transmute::UNSOUND_COLLECTION_TRANSMUTE),\n     LintId::of(transmute::WRONG_TRANSMUTE),\n     LintId::of(transmuting_null::TRANSMUTING_NULL),\n-    LintId::of(undropped_manually_drops::UNDROPPED_MANUALLY_DROPS),\n     LintId::of(unicode::INVISIBLE_CHARACTERS),\n     LintId::of(uninit_vec::UNINIT_VEC),\n     LintId::of(unit_hash::UNIT_HASH),"}, {"sha": "4778f4fdfa76c365a40d4d1a325516d86ff8ef6c", "filename": "clippy_lints/src/lib.register_internal.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flib.register_internal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flib.register_internal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_internal.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -14,6 +14,7 @@ store.register_group(true, \"clippy::internal\", Some(\"clippy_internal\"), vec![\n     LintId::of(utils::internal_lints::LINT_WITHOUT_LINT_PASS),\n     LintId::of(utils::internal_lints::MATCH_TYPE_ON_DIAGNOSTIC_ITEM),\n     LintId::of(utils::internal_lints::MISSING_CLIPPY_VERSION_ATTRIBUTE),\n+    LintId::of(utils::internal_lints::MISSING_MSRV_ATTR_IMPL),\n     LintId::of(utils::internal_lints::OUTER_EXPN_EXPN_DATA),\n     LintId::of(utils::internal_lints::PRODUCE_ICE),\n     LintId::of(utils::internal_lints::UNNECESSARY_SYMBOL_STR),"}, {"sha": "1f2132cf6200326b06f423e986391778430c91b4", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 50, "deletions": 11, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -26,6 +26,8 @@ store.register_lints(&[\n     #[cfg(feature = \"internal\")]\n     utils::internal_lints::MISSING_CLIPPY_VERSION_ATTRIBUTE,\n     #[cfg(feature = \"internal\")]\n+    utils::internal_lints::MISSING_MSRV_ATTR_IMPL,\n+    #[cfg(feature = \"internal\")]\n     utils::internal_lints::OUTER_EXPN_EXPN_DATA,\n     #[cfg(feature = \"internal\")]\n     utils::internal_lints::PRODUCE_ICE,\n@@ -42,13 +44,15 @@ store.register_lints(&[\n     assign_ops::ASSIGN_OP_PATTERN,\n     assign_ops::MISREFACTORED_ASSIGN_OP,\n     async_yields_async::ASYNC_YIELDS_ASYNC,\n+    attrs::ALLOW_ATTRIBUTES_WITHOUT_REASON,\n     attrs::BLANKET_CLIPPY_RESTRICTION_LINTS,\n     attrs::DEPRECATED_CFG_ATTR,\n     attrs::DEPRECATED_SEMVER,\n     attrs::EMPTY_LINE_AFTER_OUTER_ATTR,\n     attrs::INLINE_ALWAYS,\n     attrs::MISMATCHED_TARGET_OS,\n     attrs::USELESS_ATTRIBUTE,\n+    await_holding_invalid::AWAIT_HOLDING_INVALID_TYPE,\n     await_holding_invalid::AWAIT_HOLDING_LOCK,\n     await_holding_invalid::AWAIT_HOLDING_REFCELL_REF,\n     bit_mask::BAD_BIT_MASK,\n@@ -61,15 +65,24 @@ store.register_lints(&[\n     booleans::NONMINIMAL_BOOL,\n     borrow_as_ptr::BORROW_AS_PTR,\n     bytecount::NAIVE_BYTECOUNT,\n-    cargo_common_metadata::CARGO_COMMON_METADATA,\n+    bytes_count_to_len::BYTES_COUNT_TO_LEN,\n+    cargo::CARGO_COMMON_METADATA,\n+    cargo::MULTIPLE_CRATE_VERSIONS,\n+    cargo::NEGATIVE_FEATURE_NAMES,\n+    cargo::REDUNDANT_FEATURE_NAMES,\n+    cargo::WILDCARD_DEPENDENCIES,\n     case_sensitive_file_extension_comparisons::CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS,\n+    casts::CAST_ABS_TO_UNSIGNED,\n+    casts::CAST_ENUM_CONSTRUCTOR,\n+    casts::CAST_ENUM_TRUNCATION,\n     casts::CAST_LOSSLESS,\n     casts::CAST_POSSIBLE_TRUNCATION,\n     casts::CAST_POSSIBLE_WRAP,\n     casts::CAST_PRECISION_LOSS,\n     casts::CAST_PTR_ALIGNMENT,\n     casts::CAST_REF_TO_MUT,\n     casts::CAST_SIGN_LOSS,\n+    casts::CAST_SLICE_DIFFERENT_SIZES,\n     casts::CHAR_LIT_AS_U8,\n     casts::FN_TO_NUMERIC_CAST,\n     casts::FN_TO_NUMERIC_CAST_ANY,\n@@ -87,6 +100,7 @@ store.register_lints(&[\n     copies::IF_SAME_THEN_ELSE,\n     copies::SAME_FUNCTIONS_IN_IF_CONDITION,\n     copy_iterator::COPY_ITERATOR,\n+    crate_in_macro_def::CRATE_IN_MACRO_DEF,\n     create_dir::CREATE_DIR,\n     dbg_macro::DBG_MACRO,\n     default::DEFAULT_TRAIT_ACCESS,\n@@ -99,6 +113,7 @@ store.register_lints(&[\n     derivable_impls::DERIVABLE_IMPLS,\n     derive::DERIVE_HASH_XOR_EQ,\n     derive::DERIVE_ORD_XOR_PARTIAL_ORD,\n+    derive::DERIVE_PARTIAL_EQ_WITHOUT_EQ,\n     derive::EXPL_IMPL_CLONE_ON_COPY,\n     derive::UNSAFE_DERIVE_DESERIALIZE,\n     disallowed_methods::DISALLOWED_METHODS,\n@@ -113,12 +128,18 @@ store.register_lints(&[\n     double_comparison::DOUBLE_COMPARISONS,\n     double_parens::DOUBLE_PARENS,\n     drop_forget_ref::DROP_COPY,\n+    drop_forget_ref::DROP_NON_DROP,\n     drop_forget_ref::DROP_REF,\n     drop_forget_ref::FORGET_COPY,\n+    drop_forget_ref::FORGET_NON_DROP,\n     drop_forget_ref::FORGET_REF,\n+    drop_forget_ref::UNDROPPED_MANUALLY_DROPS,\n+    duplicate_mod::DUPLICATE_MOD,\n     duration_subsec::DURATION_SUBSEC,\n     else_if_without_else::ELSE_IF_WITHOUT_ELSE,\n+    empty_drop::EMPTY_DROP,\n     empty_enum::EMPTY_ENUM,\n+    empty_structs_with_brackets::EMPTY_STRUCTS_WITH_BRACKETS,\n     entry::MAP_ENTRY,\n     enum_clike::ENUM_CLIKE_UNPORTABLE_VARIANT,\n     enum_variants::ENUM_VARIANT_NAMES,\n@@ -131,17 +152,13 @@ store.register_lints(&[\n     escape::BOXED_LOCAL,\n     eta_reduction::REDUNDANT_CLOSURE,\n     eta_reduction::REDUNDANT_CLOSURE_FOR_METHOD_CALLS,\n-    eval_order_dependence::DIVERGING_SUB_EXPRESSION,\n-    eval_order_dependence::EVAL_ORDER_DEPENDENCE,\n     excessive_bools::FN_PARAMS_EXCESSIVE_BOOLS,\n     excessive_bools::STRUCT_EXCESSIVE_BOOLS,\n     exhaustive_items::EXHAUSTIVE_ENUMS,\n     exhaustive_items::EXHAUSTIVE_STRUCTS,\n     exit::EXIT,\n     explicit_write::EXPLICIT_WRITE,\n     fallible_impl_from::FALLIBLE_IMPL_FROM,\n-    feature_name::NEGATIVE_FEATURE_NAMES,\n-    feature_name::REDUNDANT_FEATURE_NAMES,\n     float_equality_without_abs::FLOAT_EQUALITY_WITHOUT_ABS,\n     float_literal::EXCESSIVE_PRECISION,\n     float_literal::LOSSY_FLOAT_LITERAL,\n@@ -150,6 +167,9 @@ store.register_lints(&[\n     format::USELESS_FORMAT,\n     format_args::FORMAT_IN_FORMAT_ARGS,\n     format_args::TO_STRING_IN_FORMAT_ARGS,\n+    format_impl::PRINT_IN_FORMAT_IMPL,\n+    format_impl::RECURSIVE_FORMAT_IMPL,\n+    format_push_string::FORMAT_PUSH_STRING,\n     formatting::POSSIBLE_MISSING_COMMA,\n     formatting::SUSPICIOUS_ASSIGNMENT_FORMATTING,\n     formatting::SUSPICIOUS_ELSE_FORMATTING,\n@@ -164,7 +184,7 @@ store.register_lints(&[\n     functions::TOO_MANY_ARGUMENTS,\n     functions::TOO_MANY_LINES,\n     future_not_send::FUTURE_NOT_SEND,\n-    get_last_with_len::GET_LAST_WITH_LEN,\n+    get_first::GET_FIRST,\n     identity_op::IDENTITY_OP,\n     if_let_mutex::IF_LET_MUTEX,\n     if_not_else::IF_NOT_ELSE,\n@@ -190,6 +210,7 @@ store.register_lints(&[\n     iter_not_returning_iterator::ITER_NOT_RETURNING_ITERATOR,\n     large_const_arrays::LARGE_CONST_ARRAYS,\n     large_enum_variant::LARGE_ENUM_VARIANT,\n+    large_include_file::LARGE_INCLUDE_FILE,\n     large_stack_arrays::LARGE_STACK_ARRAYS,\n     len_zero::COMPARISON_TO_EMPTY,\n     len_zero::LEN_WITHOUT_IS_EMPTY,\n@@ -215,6 +236,7 @@ store.register_lints(&[\n     loops::ITER_NEXT_LOOP,\n     loops::MANUAL_FLATTEN,\n     loops::MANUAL_MEMCPY,\n+    loops::MISSING_SPIN_LOOP,\n     loops::MUT_RANGE_BOUND,\n     loops::NEEDLESS_COLLECT,\n     loops::NEEDLESS_RANGE_LOOP,\n@@ -251,6 +273,7 @@ store.register_lints(&[\n     matches::MATCH_SINGLE_BINDING,\n     matches::MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n     matches::MATCH_WILD_ERR_ARM,\n+    matches::NEEDLESS_MATCH,\n     matches::REDUNDANT_PATTERN_MATCHING,\n     matches::REST_PAT_IN_FULLY_BOUND_STRUCTS,\n     matches::SINGLE_MATCH,\n@@ -269,6 +292,7 @@ store.register_lints(&[\n     methods::CLONE_DOUBLE_REF,\n     methods::CLONE_ON_COPY,\n     methods::CLONE_ON_REF_PTR,\n+    methods::ERR_EXPECT,\n     methods::EXPECT_FUN_CALL,\n     methods::EXPECT_USED,\n     methods::EXTEND_WITH_DRAIN,\n@@ -279,11 +303,13 @@ store.register_lints(&[\n     methods::FLAT_MAP_IDENTITY,\n     methods::FLAT_MAP_OPTION,\n     methods::FROM_ITER_INSTEAD_OF_COLLECT,\n+    methods::GET_LAST_WITH_LEN,\n     methods::GET_UNWRAP,\n     methods::IMPLICIT_CLONE,\n     methods::INEFFICIENT_TO_STRING,\n     methods::INSPECT_FOR_EACH,\n     methods::INTO_ITER_ON_REF,\n+    methods::IS_DIGIT_ASCII_RADIX,\n     methods::ITERATOR_STEP_BY_ZERO,\n     methods::ITER_CLONED_COLLECT,\n     methods::ITER_COUNT,\n@@ -292,6 +318,7 @@ store.register_lints(&[\n     methods::ITER_NTH_ZERO,\n     methods::ITER_OVEREAGER_CLONED,\n     methods::ITER_SKIP_NEXT,\n+    methods::ITER_WITH_DRAIN,\n     methods::MANUAL_FILTER_MAP,\n     methods::MANUAL_FIND_MAP,\n     methods::MANUAL_SATURATING_ARITHMETIC,\n@@ -301,13 +328,17 @@ store.register_lints(&[\n     methods::MAP_FLATTEN,\n     methods::MAP_IDENTITY,\n     methods::MAP_UNWRAP_OR,\n+    methods::NEEDLESS_OPTION_AS_DEREF,\n+    methods::NEEDLESS_OPTION_TAKE,\n     methods::NEEDLESS_SPLITN,\n     methods::NEW_RET_NO_SELF,\n+    methods::NO_EFFECT_REPLACE,\n     methods::OK_EXPECT,\n     methods::OPTION_AS_REF_DEREF,\n     methods::OPTION_FILTER_MAP,\n     methods::OPTION_MAP_OR_NONE,\n     methods::OR_FUN_CALL,\n+    methods::OR_THEN_UNWRAP,\n     methods::RESULT_MAP_OR_INTO_OPTION,\n     methods::SEARCH_IS_SOME,\n     methods::SHOULD_IMPLEMENT_TRAIT,\n@@ -319,7 +350,9 @@ store.register_lints(&[\n     methods::SUSPICIOUS_SPLITN,\n     methods::UNINIT_ASSUMED_INIT,\n     methods::UNNECESSARY_FILTER_MAP,\n+    methods::UNNECESSARY_FIND_MAP,\n     methods::UNNECESSARY_FOLD,\n+    methods::UNNECESSARY_JOIN,\n     methods::UNNECESSARY_LAZY_EVALUATIONS,\n     methods::UNNECESSARY_TO_OWNED,\n     methods::UNWRAP_OR_ELSE_DEFAULT,\n@@ -351,10 +384,11 @@ store.register_lints(&[\n     missing_doc::MISSING_DOCS_IN_PRIVATE_ITEMS,\n     missing_enforced_import_rename::MISSING_ENFORCED_IMPORT_RENAMES,\n     missing_inline::MISSING_INLINE_IN_PUBLIC_ITEMS,\n+    mixed_read_write_in_expression::DIVERGING_SUB_EXPRESSION,\n+    mixed_read_write_in_expression::MIXED_READ_WRITE_IN_EXPRESSION,\n     module_style::MOD_MODULE_FILES,\n     module_style::SELF_NAMED_MODULE_FILES,\n     modulo_arithmetic::MODULO_ARITHMETIC,\n-    multiple_crate_versions::MULTIPLE_CRATE_VERSIONS,\n     mut_key::MUTABLE_KEY_TYPE,\n     mut_mut::MUT_MUT,\n     mut_mutex_lock::MUT_MUTEX_LOCK,\n@@ -370,7 +404,6 @@ store.register_lints(&[\n     needless_continue::NEEDLESS_CONTINUE,\n     needless_for_each::NEEDLESS_FOR_EACH,\n     needless_late_init::NEEDLESS_LATE_INIT,\n-    needless_option_as_deref::NEEDLESS_OPTION_AS_DEREF,\n     needless_pass_by_value::NEEDLESS_PASS_BY_VALUE,\n     needless_question_mark::NEEDLESS_QUESTION_MARK,\n     needless_update::NEEDLESS_UPDATE,\n@@ -389,6 +422,7 @@ store.register_lints(&[\n     non_send_fields_in_send_ty::NON_SEND_FIELDS_IN_SEND_TY,\n     nonstandard_macro_braces::NONSTANDARD_MACRO_BRACES,\n     octal_escapes::OCTAL_ESCAPES,\n+    only_used_in_recursion::ONLY_USED_IN_RECURSION,\n     open_options::NONSENSICAL_OPEN_OPTIONS,\n     option_env_unwrap::OPTION_ENV_UNWRAP,\n     option_if_let_else::OPTION_IF_LET_ELSE,\n@@ -410,17 +444,20 @@ store.register_lints(&[\n     ptr::PTR_ARG,\n     ptr_eq::PTR_EQ,\n     ptr_offset_with_cast::PTR_OFFSET_WITH_CAST,\n+    pub_use::PUB_USE,\n     question_mark::QUESTION_MARK,\n     ranges::MANUAL_RANGE_CONTAINS,\n     ranges::RANGE_MINUS_ONE,\n     ranges::RANGE_PLUS_ONE,\n     ranges::RANGE_ZIP_WITH_LEN,\n     ranges::REVERSED_EMPTY_RANGES,\n+    rc_clone_in_vec_init::RC_CLONE_IN_VEC_INIT,\n     redundant_clone::REDUNDANT_CLONE,\n     redundant_closure_call::REDUNDANT_CLOSURE_CALL,\n     redundant_else::REDUNDANT_ELSE,\n     redundant_field_names::REDUNDANT_FIELD_NAMES,\n     redundant_pub_crate::REDUNDANT_PUB_CRATE,\n+    redundant_slicing::DEREF_BY_SLICING,\n     redundant_slicing::REDUNDANT_SLICING,\n     redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES,\n     ref_option_ref::REF_OPTION_REF,\n@@ -439,6 +476,7 @@ store.register_lints(&[\n     shadow::SHADOW_REUSE,\n     shadow::SHADOW_SAME,\n     shadow::SHADOW_UNRELATED,\n+    significant_drop_in_scrutinee::SIGNIFICANT_DROP_IN_SCRUTINEE,\n     single_char_lifetime_names::SINGLE_CHAR_LIFETIME_NAMES,\n     single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS,\n     size_of_in_element_count::SIZE_OF_IN_ELEMENT_COUNT,\n@@ -451,6 +489,7 @@ store.register_lints(&[\n     strings::STRING_SLICE,\n     strings::STRING_TO_STRING,\n     strings::STR_TO_STRING,\n+    strings::TRIM_SPLIT_WHITESPACE,\n     strlen_on_c_strings::STRLEN_ON_C_STRINGS,\n     suspicious_operation_groupings::SUSPICIOUS_OPERATION_GROUPINGS,\n     suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL,\n@@ -460,7 +499,6 @@ store.register_lints(&[\n     tabs_in_doc_comments::TABS_IN_DOC_COMMENTS,\n     temporary_assignment::TEMPORARY_ASSIGNMENT,\n     to_digit_is_some::TO_DIGIT_IS_SOME,\n-    to_string_in_display::TO_STRING_IN_DISPLAY,\n     trailing_empty_array::TRAILING_EMPTY_ARRAY,\n     trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS,\n     trait_bounds::TYPE_REPETITION_IN_BOUNDS,\n@@ -474,6 +512,7 @@ store.register_lints(&[\n     transmute::TRANSMUTE_NUM_TO_BYTES,\n     transmute::TRANSMUTE_PTR_TO_PTR,\n     transmute::TRANSMUTE_PTR_TO_REF,\n+    transmute::TRANSMUTE_UNDEFINED_REPR,\n     transmute::UNSOUND_COLLECTION_TRANSMUTE,\n     transmute::USELESS_TRANSMUTE,\n     transmute::WRONG_TRANSMUTE,\n@@ -489,7 +528,6 @@ store.register_lints(&[\n     types::TYPE_COMPLEXITY,\n     types::VEC_BOX,\n     undocumented_unsafe_blocks::UNDOCUMENTED_UNSAFE_BLOCKS,\n-    undropped_manually_drops::UNDROPPED_MANUALLY_DROPS,\n     unicode::INVISIBLE_CHARACTERS,\n     unicode::NON_ASCII_LITERAL,\n     unicode::UNICODE_NOT_NFC,\n@@ -501,13 +539,15 @@ store.register_lints(&[\n     unit_types::UNIT_CMP,\n     unnamed_address::FN_ADDRESS_COMPARISONS,\n     unnamed_address::VTABLE_ADDRESS_COMPARISONS,\n+    unnecessary_owned_empty_strings::UNNECESSARY_OWNED_EMPTY_STRINGS,\n     unnecessary_self_imports::UNNECESSARY_SELF_IMPORTS,\n     unnecessary_sort_by::UNNECESSARY_SORT_BY,\n     unnecessary_wraps::UNNECESSARY_WRAPS,\n     unnested_or_patterns::UNNESTED_OR_PATTERNS,\n     unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME,\n     unused_async::UNUSED_ASYNC,\n     unused_io_amount::UNUSED_IO_AMOUNT,\n+    unused_rounding::UNUSED_ROUNDING,\n     unused_self::UNUSED_SELF,\n     unused_unit::UNUSED_UNIT,\n     unwrap::PANICKING_UNWRAP,\n@@ -520,7 +560,6 @@ store.register_lints(&[\n     vec_init_then_push::VEC_INIT_THEN_PUSH,\n     vec_resize_to_zero::VEC_RESIZE_TO_ZERO,\n     verbose_file_reads::VERBOSE_FILE_READS,\n-    wildcard_dependencies::WILDCARD_DEPENDENCIES,\n     wildcard_imports::ENUM_GLOB_USE,\n     wildcard_imports::WILDCARD_IMPORTS,\n     write::PRINTLN_EMPTY_STRING,"}, {"sha": "10808af363d7019d6bb393c37e29f7760a215b47", "filename": "clippy_lints/src/lib.register_nursery.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flib.register_nursery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flib.register_nursery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_nursery.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -13,19 +13,25 @@ store.register_group(true, \"clippy::nursery\", Some(\"clippy_nursery\"), vec![\n     LintId::of(future_not_send::FUTURE_NOT_SEND),\n     LintId::of(index_refutable_slice::INDEX_REFUTABLE_SLICE),\n     LintId::of(let_if_seq::USELESS_LET_IF_SEQ),\n+    LintId::of(methods::ITER_WITH_DRAIN),\n     LintId::of(missing_const_for_fn::MISSING_CONST_FOR_FN),\n     LintId::of(mutable_debug_assertion::DEBUG_ASSERT_WITH_MUT_CALL),\n     LintId::of(mutex_atomic::MUTEX_ATOMIC),\n     LintId::of(mutex_atomic::MUTEX_INTEGER),\n     LintId::of(non_send_fields_in_send_ty::NON_SEND_FIELDS_IN_SEND_TY),\n     LintId::of(nonstandard_macro_braces::NONSTANDARD_MACRO_BRACES),\n+    LintId::of(only_used_in_recursion::ONLY_USED_IN_RECURSION),\n     LintId::of(option_if_let_else::OPTION_IF_LET_ELSE),\n     LintId::of(path_buf_push_overwrite::PATH_BUF_PUSH_OVERWRITE),\n     LintId::of(redundant_pub_crate::REDUNDANT_PUB_CRATE),\n     LintId::of(regex::TRIVIAL_REGEX),\n     LintId::of(strings::STRING_LIT_AS_BYTES),\n     LintId::of(suspicious_operation_groupings::SUSPICIOUS_OPERATION_GROUPINGS),\n     LintId::of(trailing_empty_array::TRAILING_EMPTY_ARRAY),\n+    LintId::of(trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS),\n+    LintId::of(trait_bounds::TYPE_REPETITION_IN_BOUNDS),\n+    LintId::of(transmute::TRANSMUTE_UNDEFINED_REPR),\n     LintId::of(transmute::USELESS_TRANSMUTE),\n+    LintId::of(unused_rounding::UNUSED_ROUNDING),\n     LintId::of(use_self::USE_SELF),\n ])"}, {"sha": "5684972b8bedfde3acb8d4851f6ee4b22943b81d", "filename": "clippy_lints/src/lib.register_pedantic.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flib.register_pedantic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flib.register_pedantic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_pedantic.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -4,8 +4,6 @@\n \n store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n     LintId::of(attrs::INLINE_ALWAYS),\n-    LintId::of(await_holding_invalid::AWAIT_HOLDING_LOCK),\n-    LintId::of(await_holding_invalid::AWAIT_HOLDING_REFCELL_REF),\n     LintId::of(bit_mask::VERBOSE_BIT_MASK),\n     LintId::of(borrow_as_ptr::BORROW_AS_PTR),\n     LintId::of(bytecount::NAIVE_BYTECOUNT),\n@@ -66,6 +64,7 @@ store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n     LintId::of(methods::IMPLICIT_CLONE),\n     LintId::of(methods::INEFFICIENT_TO_STRING),\n     LintId::of(methods::MAP_UNWRAP_OR),\n+    LintId::of(methods::UNNECESSARY_JOIN),\n     LintId::of(misc::FLOAT_CMP),\n     LintId::of(misc::USED_UNDERSCORE_BINDING),\n     LintId::of(mut_mut::MUT_MUT),\n@@ -84,14 +83,12 @@ store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n     LintId::of(ref_option_ref::REF_OPTION_REF),\n     LintId::of(return_self_not_must_use::RETURN_SELF_NOT_MUST_USE),\n     LintId::of(semicolon_if_nothing_returned::SEMICOLON_IF_NOTHING_RETURNED),\n+    LintId::of(stable_sort_primitive::STABLE_SORT_PRIMITIVE),\n     LintId::of(strings::STRING_ADD_ASSIGN),\n-    LintId::of(trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS),\n-    LintId::of(trait_bounds::TYPE_REPETITION_IN_BOUNDS),\n     LintId::of(transmute::TRANSMUTE_PTR_TO_PTR),\n     LintId::of(types::LINKEDLIST),\n     LintId::of(types::OPTION_OPTION),\n     LintId::of(unicode::UNICODE_NOT_NFC),\n-    LintId::of(unit_types::LET_UNIT_VALUE),\n     LintId::of(unnecessary_wraps::UNNECESSARY_WRAPS),\n     LintId::of(unnested_or_patterns::UNNESTED_OR_PATTERNS),\n     LintId::of(unused_async::UNUSED_ASYNC),"}, {"sha": "82431863e6cfd56cf3482b2f9f03c6d3ebbd003c", "filename": "clippy_lints/src/lib.register_perf.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flib.register_perf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flib.register_perf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_perf.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -7,9 +7,11 @@ store.register_group(true, \"clippy::perf\", Some(\"clippy_perf\"), vec![\n     LintId::of(escape::BOXED_LOCAL),\n     LintId::of(format_args::FORMAT_IN_FORMAT_ARGS),\n     LintId::of(format_args::TO_STRING_IN_FORMAT_ARGS),\n+    LintId::of(format_push_string::FORMAT_PUSH_STRING),\n     LintId::of(large_const_arrays::LARGE_CONST_ARRAYS),\n     LintId::of(large_enum_variant::LARGE_ENUM_VARIANT),\n     LintId::of(loops::MANUAL_MEMCPY),\n+    LintId::of(loops::MISSING_SPIN_LOOP),\n     LintId::of(loops::NEEDLESS_COLLECT),\n     LintId::of(methods::EXPECT_FUN_CALL),\n     LintId::of(methods::EXTEND_WITH_DRAIN),\n@@ -22,7 +24,6 @@ store.register_group(true, \"clippy::perf\", Some(\"clippy_perf\"), vec![\n     LintId::of(misc::CMP_OWNED),\n     LintId::of(redundant_clone::REDUNDANT_CLONE),\n     LintId::of(slow_vector_initialization::SLOW_VECTOR_INITIALIZATION),\n-    LintId::of(stable_sort_primitive::STABLE_SORT_PRIMITIVE),\n     LintId::of(types::BOX_COLLECTION),\n     LintId::of(types::REDUNDANT_ALLOCATION),\n     LintId::of(vec::USELESS_VEC),"}, {"sha": "a6d3a06dc16e34063572e52e326c30ce4a369848", "filename": "clippy_lints/src/lib.register_restriction.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flib.register_restriction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flib.register_restriction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_restriction.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -8,13 +8,16 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(as_conversions::AS_CONVERSIONS),\n     LintId::of(asm_syntax::INLINE_ASM_X86_ATT_SYNTAX),\n     LintId::of(asm_syntax::INLINE_ASM_X86_INTEL_SYNTAX),\n+    LintId::of(attrs::ALLOW_ATTRIBUTES_WITHOUT_REASON),\n     LintId::of(casts::FN_TO_NUMERIC_CAST_ANY),\n     LintId::of(create_dir::CREATE_DIR),\n     LintId::of(dbg_macro::DBG_MACRO),\n     LintId::of(default_numeric_fallback::DEFAULT_NUMERIC_FALLBACK),\n     LintId::of(default_union_representation::DEFAULT_UNION_REPRESENTATION),\n     LintId::of(disallowed_script_idents::DISALLOWED_SCRIPT_IDENTS),\n     LintId::of(else_if_without_else::ELSE_IF_WITHOUT_ELSE),\n+    LintId::of(empty_drop::EMPTY_DROP),\n+    LintId::of(empty_structs_with_brackets::EMPTY_STRUCTS_WITH_BRACKETS),\n     LintId::of(exhaustive_items::EXHAUSTIVE_ENUMS),\n     LintId::of(exhaustive_items::EXHAUSTIVE_STRUCTS),\n     LintId::of(exit::EXIT),\n@@ -24,6 +27,7 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(indexing_slicing::INDEXING_SLICING),\n     LintId::of(inherent_impl::MULTIPLE_INHERENT_IMPL),\n     LintId::of(integer_division::INTEGER_DIVISION),\n+    LintId::of(large_include_file::LARGE_INCLUDE_FILE),\n     LintId::of(let_underscore::LET_UNDERSCORE_MUST_USE),\n     LintId::of(literal_representation::DECIMAL_LITERAL_REPRESENTATION),\n     LintId::of(map_err_ignore::MAP_ERR_IGNORE),\n@@ -42,6 +46,7 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(missing_doc::MISSING_DOCS_IN_PRIVATE_ITEMS),\n     LintId::of(missing_enforced_import_rename::MISSING_ENFORCED_IMPORT_RENAMES),\n     LintId::of(missing_inline::MISSING_INLINE_IN_PUBLIC_ITEMS),\n+    LintId::of(mixed_read_write_in_expression::MIXED_READ_WRITE_IN_EXPRESSION),\n     LintId::of(module_style::MOD_MODULE_FILES),\n     LintId::of(module_style::SELF_NAMED_MODULE_FILES),\n     LintId::of(modulo_arithmetic::MODULO_ARITHMETIC),\n@@ -51,6 +56,8 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(panic_unimplemented::UNIMPLEMENTED),\n     LintId::of(panic_unimplemented::UNREACHABLE),\n     LintId::of(pattern_type_mismatch::PATTERN_TYPE_MISMATCH),\n+    LintId::of(pub_use::PUB_USE),\n+    LintId::of(redundant_slicing::DEREF_BY_SLICING),\n     LintId::of(same_name_method::SAME_NAME_METHOD),\n     LintId::of(shadow::SHADOW_REUSE),\n     LintId::of(shadow::SHADOW_SAME),\n@@ -60,6 +67,7 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(strings::STRING_SLICE),\n     LintId::of(strings::STRING_TO_STRING),\n     LintId::of(strings::STR_TO_STRING),\n+    LintId::of(try_err::TRY_ERR),\n     LintId::of(types::RC_BUFFER),\n     LintId::of(types::RC_MUTEX),\n     LintId::of(undocumented_unsafe_blocks::UNDOCUMENTED_UNSAFE_BLOCKS),"}, {"sha": "ea2e1082458c29b53840d673df6eb6af43a5d148", "filename": "clippy_lints/src/lib.register_style.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flib.register_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flib.register_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_style.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -16,6 +16,7 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(comparison_chain::COMPARISON_CHAIN),\n     LintId::of(default::FIELD_REASSIGN_WITH_DEFAULT),\n     LintId::of(dereference::NEEDLESS_BORROW),\n+    LintId::of(derive::DERIVE_PARTIAL_EQ_WITHOUT_EQ),\n     LintId::of(disallowed_methods::DISALLOWED_METHODS),\n     LintId::of(disallowed_types::DISALLOWED_TYPES),\n     LintId::of(doc::MISSING_SAFETY_DOC),\n@@ -30,6 +31,7 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(functions::DOUBLE_MUST_USE),\n     LintId::of(functions::MUST_USE_UNIT),\n     LintId::of(functions::RESULT_UNIT_ERR),\n+    LintId::of(get_first::GET_FIRST),\n     LintId::of(inherent_to_string::INHERENT_TO_STRING),\n     LintId::of(init_numbered_fields::INIT_NUMBERED_FIELDS),\n     LintId::of(len_zero::COMPARISON_TO_EMPTY),\n@@ -59,7 +61,9 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(methods::BYTES_NTH),\n     LintId::of(methods::CHARS_LAST_CMP),\n     LintId::of(methods::CHARS_NEXT_CMP),\n+    LintId::of(methods::ERR_EXPECT),\n     LintId::of(methods::INTO_ITER_ON_REF),\n+    LintId::of(methods::IS_DIGIT_ASCII_RADIX),\n     LintId::of(methods::ITER_CLONED_COLLECT),\n     LintId::of(methods::ITER_NEXT_SLICE),\n     LintId::of(methods::ITER_NTH_ZERO),\n@@ -103,9 +107,11 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(returns::NEEDLESS_RETURN),\n     LintId::of(self_named_constructors::SELF_NAMED_CONSTRUCTORS),\n     LintId::of(single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS),\n+    LintId::of(strings::TRIM_SPLIT_WHITESPACE),\n     LintId::of(tabs_in_doc_comments::TABS_IN_DOC_COMMENTS),\n     LintId::of(to_digit_is_some::TO_DIGIT_IS_SOME),\n-    LintId::of(try_err::TRY_ERR),\n+    LintId::of(unit_types::LET_UNIT_VALUE),\n+    LintId::of(unnecessary_owned_empty_strings::UNNECESSARY_OWNED_EMPTY_STRINGS),\n     LintId::of(unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME),\n     LintId::of(unused_unit::UNUSED_UNIT),\n     LintId::of(upper_case_acronyms::UPPER_CASE_ACRONYMS),"}, {"sha": "20bf5a245b157c2d8d48b88d28fcb6c5e5f06370", "filename": "clippy_lints/src/lib.register_suspicious.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flib.register_suspicious.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flib.register_suspicious.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_suspicious.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -5,17 +5,30 @@\n store.register_group(true, \"clippy::suspicious\", Some(\"clippy_suspicious\"), vec![\n     LintId::of(assign_ops::MISREFACTORED_ASSIGN_OP),\n     LintId::of(attrs::BLANKET_CLIPPY_RESTRICTION_LINTS),\n-    LintId::of(eval_order_dependence::EVAL_ORDER_DEPENDENCE),\n+    LintId::of(await_holding_invalid::AWAIT_HOLDING_INVALID_TYPE),\n+    LintId::of(await_holding_invalid::AWAIT_HOLDING_LOCK),\n+    LintId::of(await_holding_invalid::AWAIT_HOLDING_REFCELL_REF),\n+    LintId::of(casts::CAST_ABS_TO_UNSIGNED),\n+    LintId::of(casts::CAST_ENUM_CONSTRUCTOR),\n+    LintId::of(casts::CAST_ENUM_TRUNCATION),\n+    LintId::of(crate_in_macro_def::CRATE_IN_MACRO_DEF),\n+    LintId::of(drop_forget_ref::DROP_NON_DROP),\n+    LintId::of(drop_forget_ref::FORGET_NON_DROP),\n+    LintId::of(duplicate_mod::DUPLICATE_MOD),\n     LintId::of(float_equality_without_abs::FLOAT_EQUALITY_WITHOUT_ABS),\n+    LintId::of(format_impl::PRINT_IN_FORMAT_IMPL),\n     LintId::of(formatting::SUSPICIOUS_ASSIGNMENT_FORMATTING),\n     LintId::of(formatting::SUSPICIOUS_ELSE_FORMATTING),\n     LintId::of(formatting::SUSPICIOUS_UNARY_OP_FORMATTING),\n     LintId::of(loops::EMPTY_LOOP),\n     LintId::of(loops::FOR_LOOPS_OVER_FALLIBLES),\n     LintId::of(loops::MUT_RANGE_BOUND),\n+    LintId::of(methods::NO_EFFECT_REPLACE),\n     LintId::of(methods::SUSPICIOUS_MAP),\n     LintId::of(mut_key::MUTABLE_KEY_TYPE),\n     LintId::of(octal_escapes::OCTAL_ESCAPES),\n+    LintId::of(rc_clone_in_vec_init::RC_CLONE_IN_VEC_INIT),\n+    LintId::of(significant_drop_in_scrutinee::SIGNIFICANT_DROP_IN_SCRUTINEE),\n     LintId::of(suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL),\n     LintId::of(suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL),\n ])"}, {"sha": "d611600cf711b36d854704b029184f762c1c70e9", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 79, "deletions": 64, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,11 +1,14 @@\n // error-pattern:cargo-clippy\n \n+#![feature(array_windows)]\n #![feature(binary_heap_into_iter_sorted)]\n #![feature(box_patterns)]\n #![feature(control_flow_enum)]\n #![feature(drain_filter)]\n #![feature(iter_intersperse)]\n+#![feature(let_chains)]\n #![feature(let_else)]\n+#![feature(lint_reasons)]\n #![feature(once_cell)]\n #![feature(rustc_private)]\n #![feature(stmt_expr_attributes)]\n@@ -17,11 +20,15 @@\n #![warn(rust_2018_idioms, unused_lifetimes)]\n // warn on rustc internal lints\n #![warn(rustc::internal)]\n+// Disable this rustc lint for now, as it was also done in rustc\n+#![allow(rustc::potential_query_instability)]\n \n // FIXME: switch to something more ergonomic here, once available.\n // (Currently there is no way to opt into sysroot crates without `extern crate`.)\n+extern crate rustc_arena;\n extern crate rustc_ast;\n extern crate rustc_ast_pretty;\n+extern crate rustc_attr;\n extern crate rustc_data_structures;\n extern crate rustc_driver;\n extern crate rustc_errors;\n@@ -157,6 +164,8 @@ mod deprecated_lints;\n #[cfg_attr(feature = \"internal\", allow(clippy::missing_clippy_version_attribute))]\n mod utils;\n \n+mod renamed_lints;\n+\n // begin lints modules, do not remove this comment, it\u2019s used in `update_lints`\n mod absurd_extreme_comparisons;\n mod approx_const;\n@@ -175,7 +184,8 @@ mod bool_assert_comparison;\n mod booleans;\n mod borrow_as_ptr;\n mod bytecount;\n-mod cargo_common_metadata;\n+mod bytes_count_to_len;\n+mod cargo;\n mod case_sensitive_file_extension_comparisons;\n mod casts;\n mod checked_conversions;\n@@ -185,6 +195,7 @@ mod collapsible_match;\n mod comparison_chain;\n mod copies;\n mod copy_iterator;\n+mod crate_in_macro_def;\n mod create_dir;\n mod dbg_macro;\n mod default;\n@@ -201,9 +212,12 @@ mod doc_link_with_quotes;\n mod double_comparison;\n mod double_parens;\n mod drop_forget_ref;\n+mod duplicate_mod;\n mod duration_subsec;\n mod else_if_without_else;\n+mod empty_drop;\n mod empty_enum;\n+mod empty_structs_with_brackets;\n mod entry;\n mod enum_clike;\n mod enum_variants;\n@@ -212,24 +226,24 @@ mod equatable_if_let;\n mod erasing_op;\n mod escape;\n mod eta_reduction;\n-mod eval_order_dependence;\n mod excessive_bools;\n mod exhaustive_items;\n mod exit;\n mod explicit_write;\n mod fallible_impl_from;\n-mod feature_name;\n mod float_equality_without_abs;\n mod float_literal;\n mod floating_point_arithmetic;\n mod format;\n mod format_args;\n+mod format_impl;\n+mod format_push_string;\n mod formatting;\n mod from_over_into;\n mod from_str_radix_10;\n mod functions;\n mod future_not_send;\n-mod get_last_with_len;\n+mod get_first;\n mod identity_op;\n mod if_let_mutex;\n mod if_not_else;\n@@ -252,6 +266,7 @@ mod items_after_statements;\n mod iter_not_returning_iterator;\n mod large_const_arrays;\n mod large_enum_variant;\n+mod large_include_file;\n mod large_stack_arrays;\n mod len_zero;\n mod let_if_seq;\n@@ -286,9 +301,9 @@ mod missing_const_for_fn;\n mod missing_doc;\n mod missing_enforced_import_rename;\n mod missing_inline;\n+mod mixed_read_write_in_expression;\n mod module_style;\n mod modulo_arithmetic;\n-mod multiple_crate_versions;\n mod mut_key;\n mod mut_mut;\n mod mut_mutex_lock;\n@@ -302,7 +317,6 @@ mod needless_borrowed_ref;\n mod needless_continue;\n mod needless_for_each;\n mod needless_late_init;\n-mod needless_option_as_deref;\n mod needless_pass_by_value;\n mod needless_question_mark;\n mod needless_update;\n@@ -316,6 +330,7 @@ mod non_octal_unix_permissions;\n mod non_send_fields_in_send_ty;\n mod nonstandard_macro_braces;\n mod octal_escapes;\n+mod only_used_in_recursion;\n mod open_options;\n mod option_env_unwrap;\n mod option_if_let_else;\n@@ -330,8 +345,10 @@ mod precedence;\n mod ptr;\n mod ptr_eq;\n mod ptr_offset_with_cast;\n+mod pub_use;\n mod question_mark;\n mod ranges;\n+mod rc_clone_in_vec_init;\n mod redundant_clone;\n mod redundant_closure_call;\n mod redundant_else;\n@@ -351,6 +368,7 @@ mod self_named_constructors;\n mod semicolon_if_nothing_returned;\n mod serde_api;\n mod shadow;\n+mod significant_drop_in_scrutinee;\n mod single_char_lifetime_names;\n mod single_component_path_imports;\n mod size_of_in_element_count;\n@@ -364,28 +382,28 @@ mod swap;\n mod tabs_in_doc_comments;\n mod temporary_assignment;\n mod to_digit_is_some;\n-mod to_string_in_display;\n mod trailing_empty_array;\n mod trait_bounds;\n mod transmute;\n mod transmuting_null;\n mod try_err;\n mod types;\n mod undocumented_unsafe_blocks;\n-mod undropped_manually_drops;\n mod unicode;\n mod uninit_vec;\n mod unit_hash;\n mod unit_return_expecting_ord;\n mod unit_types;\n mod unnamed_address;\n+mod unnecessary_owned_empty_strings;\n mod unnecessary_self_imports;\n mod unnecessary_sort_by;\n mod unnecessary_wraps;\n mod unnested_or_patterns;\n mod unsafe_removed_from_name;\n mod unused_async;\n mod unused_io_amount;\n+mod unused_rounding;\n mod unused_self;\n mod unused_unit;\n mod unwrap;\n@@ -397,15 +415,14 @@ mod vec;\n mod vec_init_then_push;\n mod vec_resize_to_zero;\n mod verbose_file_reads;\n-mod wildcard_dependencies;\n mod wildcard_imports;\n mod write;\n mod zero_div_zero;\n mod zero_sized_map_values;\n // end lints modules, do not remove this comment, it\u2019s used in `update_lints`\n \n pub use crate::utils::conf::Conf;\n-use crate::utils::conf::TryConf;\n+use crate::utils::conf::{format_error, TryConf};\n \n /// Register all pre expansion lints\n ///\n@@ -430,7 +447,6 @@ pub fn register_pre_expansion_lints(store: &mut rustc_lint::LintStore, sess: &Se\n \n     store.register_pre_expansion_pass(|| Box::new(write::Write::default()));\n     store.register_pre_expansion_pass(move || Box::new(attrs::EarlyAttributes { msrv }));\n-    store.register_pre_expansion_pass(|| Box::new(dbg_macro::DbgMacro));\n }\n \n #[doc(hidden)]\n@@ -451,7 +467,7 @@ pub fn read_conf(sess: &Session) -> Conf {\n         sess.struct_err(&format!(\n             \"error reading Clippy's configuration file `{}`: {}\",\n             file_name.display(),\n-            error\n+            format_error(error)\n         ))\n         .emit();\n     }\n@@ -462,7 +478,7 @@ pub fn read_conf(sess: &Session) -> Conf {\n /// Register all lints and lint groups with the rustc plugin registry\n ///\n /// Used in `./src/driver.rs`.\n-#[allow(clippy::too_many_lines)]\n+#[expect(clippy::too_many_lines)]\n pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf: &Conf) {\n     register_removed_non_tool_lints(store);\n \n@@ -497,7 +513,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     {\n         store.register_early_pass(|| Box::new(utils::internal_lints::ClippyLintsInternal));\n         store.register_early_pass(|| Box::new(utils::internal_lints::ProduceIce));\n-        store.register_late_pass(|| Box::new(utils::inspector::DeepCodeInspector));\n         store.register_late_pass(|| Box::new(utils::internal_lints::CollapsibleCalls));\n         store.register_late_pass(|| Box::new(utils::internal_lints::CompilerLintFunctions::new()));\n         store.register_late_pass(|| Box::new(utils::internal_lints::IfChainStyle));\n@@ -506,10 +521,17 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         store.register_late_pass(|| Box::new(utils::internal_lints::LintWithoutLintPass::default()));\n         store.register_late_pass(|| Box::new(utils::internal_lints::MatchTypeOnDiagItem));\n         store.register_late_pass(|| Box::new(utils::internal_lints::OuterExpnDataPass));\n+        store.register_late_pass(|| Box::new(utils::internal_lints::MsrvAttrImpl));\n     }\n \n+    store.register_late_pass(|| Box::new(utils::dump_hir::DumpHir));\n     store.register_late_pass(|| Box::new(utils::author::Author));\n-    store.register_late_pass(|| Box::new(await_holding_invalid::AwaitHolding));\n+    let await_holding_invalid_types = conf.await_holding_invalid_types.clone();\n+    store.register_late_pass(move || {\n+        Box::new(await_holding_invalid::AwaitHolding::new(\n+            await_holding_invalid_types.clone(),\n+        ))\n+    });\n     store.register_late_pass(|| Box::new(serde_api::SerdeApi));\n     let vec_box_size_threshold = conf.vec_box_size_threshold;\n     let type_complexity_threshold = conf.type_complexity_threshold;\n@@ -531,7 +553,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(ptr::Ptr));\n     store.register_late_pass(|| Box::new(ptr_eq::PtrEq));\n     store.register_late_pass(|| Box::new(needless_bool::NeedlessBool));\n-    store.register_late_pass(|| Box::new(needless_option_as_deref::OptionNeedlessDeref));\n     store.register_late_pass(|| Box::new(needless_bool::BoolComparison));\n     store.register_late_pass(|| Box::new(needless_for_each::NeedlessForEach));\n     store.register_late_pass(|| Box::new(misc::MiscLints));\n@@ -567,10 +588,20 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     });\n \n     let avoid_breaking_exported_api = conf.avoid_breaking_exported_api;\n+    let allow_expect_in_tests = conf.allow_expect_in_tests;\n+    let allow_unwrap_in_tests = conf.allow_unwrap_in_tests;\n     store.register_late_pass(move || Box::new(approx_const::ApproxConstant::new(msrv)));\n-    store.register_late_pass(move || Box::new(methods::Methods::new(avoid_breaking_exported_api, msrv)));\n+    store.register_late_pass(move || {\n+        Box::new(methods::Methods::new(\n+            avoid_breaking_exported_api,\n+            msrv,\n+            allow_expect_in_tests,\n+            allow_unwrap_in_tests,\n+        ))\n+    });\n     store.register_late_pass(move || Box::new(matches::Matches::new(msrv)));\n-    store.register_early_pass(move || Box::new(manual_non_exhaustive::ManualNonExhaustive::new(msrv)));\n+    store.register_early_pass(move || Box::new(manual_non_exhaustive::ManualNonExhaustiveStruct::new(msrv)));\n+    store.register_late_pass(move || Box::new(manual_non_exhaustive::ManualNonExhaustiveEnum::new(msrv)));\n     store.register_late_pass(move || Box::new(manual_strip::ManualStrip::new(msrv)));\n     store.register_early_pass(move || Box::new(redundant_static_lifetimes::RedundantStaticLifetimes::new(msrv)));\n     store.register_early_pass(move || Box::new(redundant_field_names::RedundantFieldNames::new(msrv)));\n@@ -623,7 +654,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(strings::StringLitAsBytes));\n     store.register_late_pass(|| Box::new(derive::Derive));\n     store.register_late_pass(|| Box::new(derivable_impls::DerivableImpls));\n-    store.register_late_pass(|| Box::new(get_last_with_len::GetLastWithLen));\n     store.register_late_pass(|| Box::new(drop_forget_ref::DropForgetRef));\n     store.register_late_pass(|| Box::new(empty_enum::EmptyEnum));\n     store.register_late_pass(|| Box::new(absurd_extreme_comparisons::AbsurdExtremeComparisons));\n@@ -652,7 +682,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(arithmetic::Arithmetic::default()));\n     store.register_late_pass(|| Box::new(assign_ops::AssignOps));\n     store.register_late_pass(|| Box::new(let_if_seq::LetIfSeq));\n-    store.register_late_pass(|| Box::new(eval_order_dependence::EvalOrderDependence));\n+    store.register_late_pass(|| Box::new(mixed_read_write_in_expression::EvalOrderDependence));\n     store.register_late_pass(|| Box::new(missing_doc::MissingDoc::new()));\n     store.register_late_pass(|| Box::new(missing_inline::MissingInline));\n     store.register_late_pass(move || Box::new(exhaustive_items::ExhaustiveItems));\n@@ -706,7 +736,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(modulo_arithmetic::ModuloArithmetic));\n     store.register_early_pass(|| Box::new(reference::DerefAddrOf));\n     store.register_early_pass(|| Box::new(double_parens::DoubleParens));\n-    store.register_late_pass(|| Box::new(to_string_in_display::ToStringInDisplay::new()));\n+    store.register_late_pass(|| Box::new(format_impl::FormatImpl::new()));\n     store.register_early_pass(|| Box::new(unsafe_removed_from_name::UnsafeNameRemoval));\n     store.register_early_pass(|| Box::new(else_if_without_else::ElseIfWithoutElse));\n     store.register_early_pass(|| Box::new(int_plus_one::IntPlusOne));\n@@ -723,10 +753,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(|| Box::new(redundant_else::RedundantElse));\n     store.register_late_pass(|| Box::new(create_dir::CreateDir));\n     store.register_early_pass(|| Box::new(needless_arbitrary_self_type::NeedlessArbitrarySelfType));\n-    let cargo_ignore_publish = conf.cargo_ignore_publish;\n-    store.register_late_pass(move || Box::new(cargo_common_metadata::CargoCommonMetadata::new(cargo_ignore_publish)));\n-    store.register_late_pass(|| Box::new(multiple_crate_versions::MultipleCrateVersions));\n-    store.register_late_pass(|| Box::new(wildcard_dependencies::WildcardDependencies));\n     let literal_representation_lint_fraction_readability = conf.unreadable_literal_lint_fractions;\n     store.register_early_pass(move || {\n         Box::new(literal_representation::LiteralDigitGrouping::new(\n@@ -814,7 +840,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || Box::new(disallowed_methods::DisallowedMethods::new(disallowed_methods.clone())));\n     store.register_early_pass(|| Box::new(asm_syntax::InlineAsmX86AttSyntax));\n     store.register_early_pass(|| Box::new(asm_syntax::InlineAsmX86IntelSyntax));\n-    store.register_late_pass(|| Box::new(undropped_manually_drops::UndroppedManuallyDrops));\n+    store.register_late_pass(|| Box::new(empty_drop::EmptyDrop));\n     store.register_late_pass(|| Box::new(strings::StrToString));\n     store.register_late_pass(|| Box::new(strings::StringToString));\n     store.register_late_pass(|| Box::new(zero_sized_map_values::ZeroSizedMapValues));\n@@ -841,7 +867,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(move || Box::new(disallowed_script_idents::DisallowedScriptIdents::new(&scripts)));\n     store.register_late_pass(|| Box::new(strlen_on_c_strings::StrlenOnCStrings));\n     store.register_late_pass(move || Box::new(self_named_constructors::SelfNamedConstructors));\n-    store.register_late_pass(move || Box::new(feature_name::FeatureName));\n     store.register_late_pass(move || Box::new(iter_not_returning_iterator::IterNotReturningIterator));\n     store.register_late_pass(move || Box::new(manual_assert::ManualAssert));\n     let enable_raw_pointer_heuristic_for_send = conf.enable_raw_pointer_heuristic_for_send;\n@@ -850,7 +875,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n             enable_raw_pointer_heuristic_for_send,\n         ))\n     });\n-    store.register_late_pass(move || Box::new(undocumented_unsafe_blocks::UndocumentedUnsafeBlocks::default()));\n+    store.register_late_pass(move || Box::new(undocumented_unsafe_blocks::UndocumentedUnsafeBlocks));\n     store.register_late_pass(|| Box::new(match_str_case_mismatch::MatchStrCaseMismatch));\n     store.register_late_pass(move || Box::new(format_args::FormatArgs));\n     store.register_late_pass(|| Box::new(trailing_empty_array::TrailingEmptyArray));\n@@ -863,6 +888,29 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || Box::new(manual_bits::ManualBits::new(msrv)));\n     store.register_late_pass(|| Box::new(default_union_representation::DefaultUnionRepresentation));\n     store.register_early_pass(|| Box::new(doc_link_with_quotes::DocLinkWithQuotes));\n+    store.register_late_pass(|| Box::new(only_used_in_recursion::OnlyUsedInRecursion));\n+    store.register_late_pass(|| Box::new(significant_drop_in_scrutinee::SignificantDropInScrutinee));\n+    let allow_dbg_in_tests = conf.allow_dbg_in_tests;\n+    store.register_late_pass(move || Box::new(dbg_macro::DbgMacro::new(allow_dbg_in_tests)));\n+    let cargo_ignore_publish = conf.cargo_ignore_publish;\n+    store.register_late_pass(move || {\n+        Box::new(cargo::Cargo {\n+            ignore_publish: cargo_ignore_publish,\n+        })\n+    });\n+    store.register_early_pass(|| Box::new(crate_in_macro_def::CrateInMacroDef));\n+    store.register_early_pass(|| Box::new(empty_structs_with_brackets::EmptyStructsWithBrackets));\n+    store.register_late_pass(|| Box::new(unnecessary_owned_empty_strings::UnnecessaryOwnedEmptyStrings));\n+    store.register_early_pass(|| Box::new(pub_use::PubUse));\n+    store.register_late_pass(|| Box::new(format_push_string::FormatPushString));\n+    store.register_late_pass(|| Box::new(bytes_count_to_len::BytesCountToLen));\n+    let max_include_file_size = conf.max_include_file_size;\n+    store.register_late_pass(move || Box::new(large_include_file::LargeIncludeFile::new(max_include_file_size)));\n+    store.register_late_pass(|| Box::new(strings::TrimSplitWhitespace));\n+    store.register_late_pass(|| Box::new(rc_clone_in_vec_init::RcCloneInVecInit));\n+    store.register_early_pass(|| Box::new(duplicate_mod::DuplicateMod::default()));\n+    store.register_late_pass(|| Box::new(get_first::GetFirst));\n+    store.register_early_pass(|| Box::new(unused_rounding::UnusedRounding));\n     // add lints here, do not remove this comment, it's used in `new_lint`\n }\n \n@@ -914,42 +962,9 @@ fn register_removed_non_tool_lints(store: &mut rustc_lint::LintStore) {\n ///\n /// Used in `./src/driver.rs`.\n pub fn register_renamed(ls: &mut rustc_lint::LintStore) {\n-    // NOTE: when renaming a lint, add a corresponding test to tests/ui/rename.rs\n-    ls.register_renamed(\"clippy::stutter\", \"clippy::module_name_repetitions\");\n-    ls.register_renamed(\"clippy::new_without_default_derive\", \"clippy::new_without_default\");\n-    ls.register_renamed(\"clippy::cyclomatic_complexity\", \"clippy::cognitive_complexity\");\n-    ls.register_renamed(\"clippy::const_static_lifetime\", \"clippy::redundant_static_lifetimes\");\n-    ls.register_renamed(\"clippy::option_and_then_some\", \"clippy::bind_instead_of_map\");\n-    ls.register_renamed(\"clippy::box_vec\", \"clippy::box_collection\");\n-    ls.register_renamed(\"clippy::block_in_if_condition_expr\", \"clippy::blocks_in_if_conditions\");\n-    ls.register_renamed(\"clippy::block_in_if_condition_stmt\", \"clippy::blocks_in_if_conditions\");\n-    ls.register_renamed(\"clippy::option_map_unwrap_or\", \"clippy::map_unwrap_or\");\n-    ls.register_renamed(\"clippy::option_map_unwrap_or_else\", \"clippy::map_unwrap_or\");\n-    ls.register_renamed(\"clippy::result_map_unwrap_or_else\", \"clippy::map_unwrap_or\");\n-    ls.register_renamed(\"clippy::option_unwrap_used\", \"clippy::unwrap_used\");\n-    ls.register_renamed(\"clippy::result_unwrap_used\", \"clippy::unwrap_used\");\n-    ls.register_renamed(\"clippy::option_expect_used\", \"clippy::expect_used\");\n-    ls.register_renamed(\"clippy::result_expect_used\", \"clippy::expect_used\");\n-    ls.register_renamed(\"clippy::for_loop_over_option\", \"clippy::for_loops_over_fallibles\");\n-    ls.register_renamed(\"clippy::for_loop_over_result\", \"clippy::for_loops_over_fallibles\");\n-    ls.register_renamed(\"clippy::identity_conversion\", \"clippy::useless_conversion\");\n-    ls.register_renamed(\"clippy::zero_width_space\", \"clippy::invisible_characters\");\n-    ls.register_renamed(\"clippy::single_char_push_str\", \"clippy::single_char_add_str\");\n-    ls.register_renamed(\"clippy::if_let_some_result\", \"clippy::match_result_ok\");\n-    ls.register_renamed(\"clippy::disallowed_type\", \"clippy::disallowed_types\");\n-    ls.register_renamed(\"clippy::disallowed_method\", \"clippy::disallowed_methods\");\n-    ls.register_renamed(\"clippy::ref_in_deref\", \"clippy::needless_borrow\");\n-\n-    // uplifted lints\n-    ls.register_renamed(\"clippy::invalid_ref\", \"invalid_value\");\n-    ls.register_renamed(\"clippy::into_iter_on_array\", \"array_into_iter\");\n-    ls.register_renamed(\"clippy::unused_label\", \"unused_labels\");\n-    ls.register_renamed(\"clippy::drop_bounds\", \"drop_bounds\");\n-    ls.register_renamed(\"clippy::temporary_cstring_as_ptr\", \"temporary_cstring_as_ptr\");\n-    ls.register_renamed(\"clippy::panic_params\", \"non_fmt_panics\");\n-    ls.register_renamed(\"clippy::unknown_clippy_lints\", \"unknown_lints\");\n-    ls.register_renamed(\"clippy::invalid_atomic_ordering\", \"invalid_atomic_ordering\");\n-    ls.register_renamed(\"clippy::mem_discriminant_non_enum\", \"enum_intrinsics_non_enums\");\n+    for (old_name, new_name) in renamed_lints::RENAMED_LINTS {\n+        ls.register_renamed(old_name, new_name);\n+    }\n }\n \n // only exists to let the dogfood integration test works."}, {"sha": "51d5b510ab93053e155d1b6ec3cbb0ade5ceb101", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 96, "deletions": 39, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,16 +1,19 @@\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::trait_ref_of_method;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_hir::intravisit::nested_filter::{self as hir_nested_filter, NestedFilter};\n use rustc_hir::intravisit::{\n-    walk_fn_decl, walk_generic_param, walk_generics, walk_item, walk_param_bound, walk_poly_trait_ref, walk_ty, Visitor,\n+    walk_fn_decl, walk_generic_param, walk_generics, walk_impl_item_ref, walk_item, walk_param_bound,\n+    walk_poly_trait_ref, walk_trait_ref, walk_ty, Visitor,\n };\n use rustc_hir::FnRetTy::Return;\n use rustc_hir::{\n-    BareFnTy, BodyId, FnDecl, GenericArg, GenericBound, GenericParam, GenericParamKind, Generics, ImplItem,\n-    ImplItemKind, Item, ItemKind, LangItem, Lifetime, LifetimeName, ParamName, PolyTraitRef, TraitBoundModifier,\n-    TraitFn, TraitItem, TraitItemKind, Ty, TyKind, WhereClause, WherePredicate,\n+    BareFnTy, BodyId, FnDecl, GenericArg, GenericBound, GenericParam, GenericParamKind, Generics, Impl, ImplItem,\n+    ImplItemKind, Item, ItemKind, LangItem, Lifetime, LifetimeName, ParamName, PolyTraitRef, PredicateOrigin,\n+    TraitBoundModifier, TraitFn, TraitItem, TraitItemKind, Ty, TyKind, WherePredicate,\n };\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::nested_filter as middle_nested_filter;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{kw, Ident, Symbol};\n@@ -82,8 +85,10 @@ declare_lint_pass!(Lifetimes => [NEEDLESS_LIFETIMES, EXTRA_UNUSED_LIFETIMES]);\n \n impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        if let ItemKind::Fn(ref sig, ref generics, id) = item.kind {\n+        if let ItemKind::Fn(ref sig, generics, id) = item.kind {\n             check_fn_inner(cx, sig.decl, Some(id), None, generics, item.span, true);\n+        } else if let ItemKind::Impl(impl_) = item.kind {\n+            report_extra_impl_lifetimes(cx, impl_);\n         }\n     }\n \n@@ -95,7 +100,7 @@ impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n                 sig.decl,\n                 Some(id),\n                 None,\n-                &item.generics,\n+                item.generics,\n                 item.span,\n                 report_extra_lifetimes,\n             );\n@@ -108,7 +113,7 @@ impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n                 TraitFn::Required(sig) => (None, Some(sig)),\n                 TraitFn::Provided(id) => (Some(id), None),\n             };\n-            check_fn_inner(cx, sig.decl, body, trait_sig, &item.generics, item.span, true);\n+            check_fn_inner(cx, sig.decl, body, trait_sig, item.generics, item.span, true);\n         }\n     }\n }\n@@ -130,7 +135,7 @@ fn check_fn_inner<'tcx>(\n     span: Span,\n     report_extra_lifetimes: bool,\n ) {\n-    if span.from_expansion() || has_where_lifetimes(cx, &generics.where_clause) {\n+    if span.from_expansion() || has_where_lifetimes(cx, generics) {\n         return;\n     }\n \n@@ -139,28 +144,35 @@ fn check_fn_inner<'tcx>(\n         .iter()\n         .filter(|param| matches!(param.kind, GenericParamKind::Type { .. }));\n     for typ in types {\n-        for bound in typ.bounds {\n-            let mut visitor = RefVisitor::new(cx);\n-            walk_param_bound(&mut visitor, bound);\n-            if visitor.lts.iter().any(|lt| matches!(lt, RefLt::Named(_))) {\n-                return;\n+        for pred in generics.bounds_for_param(cx.tcx.hir().local_def_id(typ.hir_id)) {\n+            if pred.origin == PredicateOrigin::WhereClause {\n+                // has_where_lifetimes checked that this predicate contains no lifetime.\n+                continue;\n             }\n-            if let GenericBound::Trait(ref trait_ref, _) = *bound {\n-                let params = &trait_ref\n-                    .trait_ref\n-                    .path\n-                    .segments\n-                    .last()\n-                    .expect(\"a path must have at least one segment\")\n-                    .args;\n-                if let Some(params) = *params {\n-                    let lifetimes = params.args.iter().filter_map(|arg| match arg {\n-                        GenericArg::Lifetime(lt) => Some(lt),\n-                        _ => None,\n-                    });\n-                    for bound in lifetimes {\n-                        if bound.name != LifetimeName::Static && !bound.is_elided() {\n-                            return;\n+\n+            for bound in pred.bounds {\n+                let mut visitor = RefVisitor::new(cx);\n+                walk_param_bound(&mut visitor, bound);\n+                if visitor.lts.iter().any(|lt| matches!(lt, RefLt::Named(_))) {\n+                    return;\n+                }\n+                if let GenericBound::Trait(ref trait_ref, _) = *bound {\n+                    let params = &trait_ref\n+                        .trait_ref\n+                        .path\n+                        .segments\n+                        .last()\n+                        .expect(\"a path must have at least one segment\")\n+                        .args;\n+                    if let Some(params) = *params {\n+                        let lifetimes = params.args.iter().filter_map(|arg| match arg {\n+                            GenericArg::Lifetime(lt) => Some(lt),\n+                            _ => None,\n+                        });\n+                        for bound in lifetimes {\n+                            if bound.name != LifetimeName::Static && !bound.is_elided() {\n+                                return;\n+                            }\n                         }\n                     }\n                 }\n@@ -194,8 +206,7 @@ fn explicit_self_type<'tcx>(cx: &LateContext<'tcx>, func: &FnDecl<'tcx>, ident:\n             visitor.visit_ty(self_ty);\n \n             !visitor.all_lts().is_empty()\n-        }\n-        else {\n+        } else {\n             false\n         }\n     }\n@@ -322,9 +333,7 @@ fn allowed_lts_from(named_generics: &[GenericParam<'_>]) -> FxHashSet<RefLt> {\n     let mut allowed_lts = FxHashSet::default();\n     for par in named_generics.iter() {\n         if let GenericParamKind::Lifetime { .. } = par.kind {\n-            if par.bounds.is_empty() {\n-                allowed_lts.insert(RefLt::Named(par.name.ident().name));\n-            }\n+            allowed_lts.insert(RefLt::Named(par.name.ident().name));\n         }\n     }\n     allowed_lts.insert(RefLt::Unnamed);\n@@ -445,8 +454,8 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n \n /// Are any lifetimes mentioned in the `where` clause? If so, we don't try to\n /// reason about elision.\n-fn has_where_lifetimes<'tcx>(cx: &LateContext<'tcx>, where_clause: &'tcx WhereClause<'_>) -> bool {\n-    for predicate in where_clause.predicates {\n+fn has_where_lifetimes<'tcx>(cx: &LateContext<'tcx>, generics: &'tcx Generics<'_>) -> bool {\n+    for predicate in generics.predicates {\n         match *predicate {\n             WherePredicate::RegionPredicate(..) => return true,\n             WherePredicate::BoundPredicate(ref pred) => {\n@@ -481,11 +490,29 @@ fn has_where_lifetimes<'tcx>(cx: &LateContext<'tcx>, where_clause: &'tcx WhereCl\n     false\n }\n \n-struct LifetimeChecker {\n+struct LifetimeChecker<'cx, 'tcx, F> {\n+    cx: &'cx LateContext<'tcx>,\n     map: FxHashMap<Symbol, Span>,\n+    phantom: std::marker::PhantomData<F>,\n }\n \n-impl<'tcx> Visitor<'tcx> for LifetimeChecker {\n+impl<'cx, 'tcx, F> LifetimeChecker<'cx, 'tcx, F> {\n+    fn new(cx: &'cx LateContext<'tcx>, map: FxHashMap<Symbol, Span>) -> LifetimeChecker<'cx, 'tcx, F> {\n+        Self {\n+            cx,\n+            map,\n+            phantom: std::marker::PhantomData,\n+        }\n+    }\n+}\n+\n+impl<'cx, 'tcx, F> Visitor<'tcx> for LifetimeChecker<'cx, 'tcx, F>\n+where\n+    F: NestedFilter<'tcx>,\n+{\n+    type Map = rustc_middle::hir::map::Map<'tcx>;\n+    type NestedFilter = F;\n+\n     // for lifetimes as parameters of generics\n     fn visit_lifetime(&mut self, lifetime: &'tcx Lifetime) {\n         self.map.remove(&lifetime.name.ident().name);\n@@ -501,6 +528,10 @@ impl<'tcx> Visitor<'tcx> for LifetimeChecker {\n             walk_generic_param(self, param);\n         }\n     }\n+\n+    fn nested_visit_map(&mut self) -> Self::Map {\n+        self.cx.tcx.hir()\n+    }\n }\n \n fn report_extra_lifetimes<'tcx>(cx: &LateContext<'tcx>, func: &'tcx FnDecl<'_>, generics: &'tcx Generics<'_>) {\n@@ -512,7 +543,7 @@ fn report_extra_lifetimes<'tcx>(cx: &LateContext<'tcx>, func: &'tcx FnDecl<'_>,\n             _ => None,\n         })\n         .collect();\n-    let mut checker = LifetimeChecker { map: hs };\n+    let mut checker = LifetimeChecker::<hir_nested_filter::None>::new(cx, hs);\n \n     walk_generics(&mut checker, generics);\n     walk_fn_decl(&mut checker, func);\n@@ -527,6 +558,32 @@ fn report_extra_lifetimes<'tcx>(cx: &LateContext<'tcx>, func: &'tcx FnDecl<'_>,\n     }\n }\n \n+fn report_extra_impl_lifetimes<'tcx>(cx: &LateContext<'tcx>, impl_: &'tcx Impl<'_>) {\n+    let hs = impl_\n+        .generics\n+        .params\n+        .iter()\n+        .filter_map(|par| match par.kind {\n+            GenericParamKind::Lifetime { .. } => Some((par.name.ident().name, par.span)),\n+            _ => None,\n+        })\n+        .collect();\n+    let mut checker = LifetimeChecker::<middle_nested_filter::All>::new(cx, hs);\n+\n+    walk_generics(&mut checker, impl_.generics);\n+    if let Some(ref trait_ref) = impl_.of_trait {\n+        walk_trait_ref(&mut checker, trait_ref);\n+    }\n+    walk_ty(&mut checker, impl_.self_ty);\n+    for item in impl_.items {\n+        walk_impl_item_ref(&mut checker, item);\n+    }\n+\n+    for &v in checker.map.values() {\n+        span_lint(cx, EXTRA_UNUSED_LIFETIMES, v, \"this lifetime isn't used in the impl\");\n+    }\n+}\n+\n struct BodyLifetimeChecker {\n     lifetimes_used_in_body: bool,\n }"}, {"sha": "9998712b8527dadb3e139a6888a3869f71c37b3c", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 38, "deletions": 15, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -42,17 +42,12 @@ declare_clippy_lint! {\n     /// This is most probably a typo\n     ///\n     /// ### Known problems\n-    /// - Recommends a signed suffix, even though the number might be too big and an unsigned\n-    ///   suffix is required\n+    /// - Does not match on integers too large to fit in the corresponding unsigned type\n     /// - Does not match on `_127` since that is a valid grouping for decimal and octal numbers\n     ///\n     /// ### Example\n-    /// ```rust\n-    /// // Probably mistyped\n-    /// 2_32;\n-    ///\n-    /// // Good\n-    /// 2_i32;\n+    /// `2_32` => `2_i32`\n+    /// `250_8 => `250_u8`\n     /// ```\n     #[clippy::version = \"1.30.0\"]\n     pub MISTYPED_LITERAL_SUFFIXES,\n@@ -209,7 +204,6 @@ impl WarningType {\n     }\n }\n \n-#[allow(clippy::module_name_repetitions)]\n #[derive(Copy, Clone)]\n pub struct LiteralDigitGrouping {\n     lint_fraction_readability: bool,\n@@ -310,18 +304,47 @@ impl LiteralDigitGrouping {\n             return true;\n         }\n \n-        let (part, mistyped_suffixes, missing_char) = if let Some((_, exponent)) = &mut num_lit.exponent {\n-            (exponent, &[\"32\", \"64\"][..], 'f')\n+        let (part, mistyped_suffixes, is_float) = if let Some((_, exponent)) = &mut num_lit.exponent {\n+            (exponent, &[\"32\", \"64\"][..], true)\n         } else if num_lit.fraction.is_some() {\n-            (&mut num_lit.integer, &[\"32\", \"64\"][..], 'f')\n+            return true;\n         } else {\n-            (&mut num_lit.integer, &[\"8\", \"16\", \"32\", \"64\"][..], 'i')\n+            (&mut num_lit.integer, &[\"8\", \"16\", \"32\", \"64\"][..], false)\n         };\n \n         let mut split = part.rsplit('_');\n         let last_group = split.next().expect(\"At least one group\");\n         if split.next().is_some() && mistyped_suffixes.contains(&last_group) {\n-            *part = &part[..part.len() - last_group.len()];\n+            let main_part = &part[..part.len() - last_group.len()];\n+            let missing_char;\n+            if is_float {\n+                missing_char = 'f';\n+            } else {\n+                let radix = match num_lit.radix {\n+                    Radix::Binary => 2,\n+                    Radix::Octal => 8,\n+                    Radix::Decimal => 10,\n+                    Radix::Hexadecimal => 16,\n+                };\n+                if let Ok(int) = u64::from_str_radix(&main_part.replace('_', \"\"), radix) {\n+                    missing_char = match (last_group, int) {\n+                        (\"8\", i) if i8::try_from(i).is_ok() => 'i',\n+                        (\"16\", i) if i16::try_from(i).is_ok() => 'i',\n+                        (\"32\", i) if i32::try_from(i).is_ok() => 'i',\n+                        (\"64\", i) if i64::try_from(i).is_ok() => 'i',\n+                        (\"8\", u) if u8::try_from(u).is_ok() => 'u',\n+                        (\"16\", u) if u16::try_from(u).is_ok() => 'u',\n+                        (\"32\", u) if u32::try_from(u).is_ok() => 'u',\n+                        (\"64\", _) => 'u',\n+                        _ => {\n+                            return true;\n+                        },\n+                    }\n+                } else {\n+                    return true;\n+                }\n+            }\n+            *part = main_part;\n             let mut sugg = num_lit.format();\n             sugg.push('_');\n             sugg.push(missing_char);\n@@ -408,7 +431,7 @@ impl LiteralDigitGrouping {\n     }\n }\n \n-#[allow(clippy::module_name_repetitions)]\n+#[expect(clippy::module_name_repetitions)]\n #[derive(Copy, Clone)]\n pub struct DecimalLiteralRepresentation {\n     threshold: u64,"}, {"sha": "fc50e8addccec8f84e87c03fffedd10a92daa3dd", "filename": "clippy_lints/src/loops/explicit_counter_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -7,7 +7,7 @@ use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_block, walk_expr};\n use rustc_hir::{Expr, Pat};\n use rustc_lint::LateContext;\n-use rustc_middle::ty::{self, UintTy};\n+use rustc_middle::ty::{self, Ty, UintTy};\n \n // To trigger the EXPLICIT_COUNTER_LOOP lint, a variable must be\n // incremented exactly once in the loop body, and initialized to zero\n@@ -36,7 +36,7 @@ pub(super) fn check<'tcx>(\n                 then {\n                     let mut applicability = Applicability::MachineApplicable;\n \n-                    let int_name = match ty.map(ty::TyS::kind) {\n+                    let int_name = match ty.map(Ty::kind) {\n                         // usize or inferred\n                         Some(ty::Uint(UintTy::Usize)) | None => {\n                             span_lint_and_sugg("}, {"sha": "175e2b382e3f6d03b3afef51d5259e6dbcbddd15", "filename": "clippy_lints/src/loops/explicit_into_iter_loop.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Floops%2Fexplicit_into_iter_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Floops%2Fexplicit_into_iter_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fexplicit_into_iter_loop.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -5,13 +5,12 @@ use clippy_utils::source::snippet_with_applicability;\n use rustc_errors::Applicability;\n use rustc_hir::Expr;\n use rustc_lint::LateContext;\n-use rustc_middle::ty::TyS;\n use rustc_span::symbol::sym;\n \n pub(super) fn check(cx: &LateContext<'_>, self_arg: &Expr<'_>, call_expr: &Expr<'_>) {\n     let self_ty = cx.typeck_results().expr_ty(self_arg);\n     let self_ty_adjusted = cx.typeck_results().expr_ty_adjusted(self_arg);\n-    if !(TyS::same_type(self_ty, self_ty_adjusted) && is_trait_method(cx, call_expr, sym::IntoIterator)) {\n+    if !(self_ty == self_ty_adjusted && is_trait_method(cx, call_expr, sym::IntoIterator)) {\n         return;\n     }\n "}, {"sha": "5f5beccd030c171c4a1c80566b1c8e75fc16a59d", "filename": "clippy_lints/src/loops/explicit_iter_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Floops%2Fexplicit_iter_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Floops%2Fexplicit_iter_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fexplicit_iter_loop.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -6,7 +6,7 @@ use clippy_utils::ty::is_type_diagnostic_item;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, Mutability};\n use rustc_lint::LateContext;\n-use rustc_middle::ty::{self, Ty, TyS};\n+use rustc_middle::ty::{self, Ty};\n use rustc_span::sym;\n \n pub(super) fn check(cx: &LateContext<'_>, self_arg: &Expr<'_>, arg: &Expr<'_>, method_name: &str) {\n@@ -22,7 +22,7 @@ pub(super) fn check(cx: &LateContext<'_>, self_arg: &Expr<'_>, arg: &Expr<'_>, m\n                     mutbl: Mutability::Not,\n                 },\n             );\n-            TyS::same_type(receiver_ty_adjusted, ref_receiver_ty)\n+            receiver_ty_adjusted == ref_receiver_ty\n         },\n         _ => false,\n     };"}, {"sha": "b31015d195b52007211e0bf97b04b39f9c19733e", "filename": "clippy_lints/src/loops/manual_memcpy.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -334,9 +334,9 @@ struct Start<'hir> {\n \n fn get_slice_like_element_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     match ty.kind() {\n-        ty::Adt(adt, subs) if cx.tcx.is_diagnostic_item(sym::Vec, adt.did) => Some(subs.type_at(0)),\n-        ty::Ref(_, subty, _) => get_slice_like_element_ty(cx, subty),\n-        ty::Slice(ty) | ty::Array(ty, _) => Some(ty),\n+        ty::Adt(adt, subs) if cx.tcx.is_diagnostic_item(sym::Vec, adt.did()) => Some(subs.type_at(0)),\n+        ty::Ref(_, subty, _) => get_slice_like_element_ty(cx, *subty),\n+        ty::Slice(ty) | ty::Array(ty, _) => Some(*ty),\n         _ => None,\n     }\n }"}, {"sha": "0696afa39225f52281ba9dc01463e212d70117de", "filename": "clippy_lints/src/loops/missing_spin_loop.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Floops%2Fmissing_spin_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Floops%2Fmissing_spin_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmissing_spin_loop.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,56 @@\n+use super::MISSING_SPIN_LOOP;\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_no_std_crate;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Block, Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::sym;\n+\n+fn unpack_cond<'tcx>(cond: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n+    match &cond.kind {\n+        ExprKind::Block(\n+            Block {\n+                stmts: [],\n+                expr: Some(e),\n+                ..\n+            },\n+            _,\n+        )\n+        | ExprKind::Unary(_, e) => unpack_cond(e),\n+        ExprKind::Binary(_, l, r) => {\n+            let l = unpack_cond(l);\n+            if let ExprKind::MethodCall(..) = l.kind {\n+                l\n+            } else {\n+                unpack_cond(r)\n+            }\n+        },\n+        _ => cond,\n+    }\n+}\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, cond: &'tcx Expr<'_>, body: &'tcx Expr<'_>) {\n+    if_chain! {\n+        if let ExprKind::Block(Block { stmts: [], expr: None, ..}, _) = body.kind;\n+        if let ExprKind::MethodCall(method, [callee, ..], _) = unpack_cond(cond).kind;\n+        if [sym::load, sym::compare_exchange, sym::compare_exchange_weak].contains(&method.ident.name);\n+        if let ty::Adt(def, _substs) = cx.typeck_results().expr_ty(callee).kind();\n+        if cx.tcx.is_diagnostic_item(sym::AtomicBool, def.did());\n+        then {\n+            span_lint_and_sugg(\n+                cx,\n+                MISSING_SPIN_LOOP,\n+                body.span,\n+                \"busy-waiting loop should at least have a spin loop hint\",\n+                \"try this\",\n+                (if is_no_std_crate(cx) {\n+                    \"{ core::hint::spin_loop() }\"\n+                } else {\n+                    \"{ std::hint::spin_loop() }\"\n+                }).into(),\n+                Applicability::MachineApplicable\n+            );\n+        }\n+    }\n+}"}, {"sha": "75d771f992a8c48261afb5deba2a3302237302b1", "filename": "clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -7,6 +7,7 @@ mod for_loops_over_fallibles;\n mod iter_next_loop;\n mod manual_flatten;\n mod manual_memcpy;\n+mod missing_spin_loop;\n mod mut_range_bound;\n mod needless_collect;\n mod needless_range_loop;\n@@ -560,6 +561,42 @@ declare_clippy_lint! {\n     \"for loops over `Option`s or `Result`s with a single expression can be simplified\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Check for empty spin loops\n+    ///\n+    /// ### Why is this bad?\n+    /// The loop body should have something like `thread::park()` or at least\n+    /// `std::hint::spin_loop()` to avoid needlessly burning cycles and conserve\n+    /// energy. Perhaps even better use an actual lock, if possible.\n+    ///\n+    /// ### Known problems\n+    /// This lint doesn't currently trigger on `while let` or\n+    /// `loop { match .. { .. } }` loops, which would be considered idiomatic in\n+    /// combination with e.g. `AtomicBool::compare_exchange_weak`.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```ignore\n+    /// use core::sync::atomic::{AtomicBool, Ordering};\n+    /// let b = AtomicBool::new(true);\n+    /// // give a ref to `b` to another thread,wait for it to become false\n+    /// while b.load(Ordering::Acquire) {};\n+    /// ```\n+    /// Use instead:\n+    /// ```rust,no_run\n+    ///# use core::sync::atomic::{AtomicBool, Ordering};\n+    ///# let b = AtomicBool::new(true);\n+    /// while b.load(Ordering::Acquire) {\n+    ///     std::hint::spin_loop()\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.59.0\"]\n+    pub MISSING_SPIN_LOOP,\n+    perf,\n+    \"An empty busy waiting loop\"\n+}\n+\n declare_lint_pass!(Loops => [\n     MANUAL_MEMCPY,\n     MANUAL_FLATTEN,\n@@ -579,10 +616,10 @@ declare_lint_pass!(Loops => [\n     WHILE_IMMUTABLE_CONDITION,\n     SAME_ITEM_PUSH,\n     SINGLE_ELEMENT_LOOP,\n+    MISSING_SPIN_LOOP,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Loops {\n-    #[allow(clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         let for_loop = higher::ForLoop::hir(expr);\n         if let Some(higher::ForLoop {\n@@ -628,6 +665,7 @@ impl<'tcx> LateLintPass<'tcx> for Loops {\n \n         if let Some(higher::While { condition, body }) = higher::While::hir(expr) {\n             while_immutable_condition::check(cx, condition, body);\n+            missing_spin_loop::check(cx, condition, body);\n         }\n \n         needless_collect::check(expr, cx);"}, {"sha": "ddaffc751880db30251f01d8c246af8c9d8568d6", "filename": "clippy_lints/src/loops/needless_collect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -6,15 +6,15 @@ use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::{can_move_expr_to_closure, is_trait_method, path_to_local, path_to_local_id, CaptureKind};\n use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::Applicability;\n+use rustc_errors::{Applicability, MultiSpan};\n use rustc_hir::intravisit::{walk_block, walk_expr, Visitor};\n use rustc_hir::{Block, Expr, ExprKind, HirId, HirIdSet, Local, Mutability, Node, PatKind, Stmt, StmtKind};\n use rustc_lint::LateContext;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::{self, TyS};\n+use rustc_middle::ty::{self, Ty};\n use rustc_span::sym;\n-use rustc_span::{MultiSpan, Span};\n+use rustc_span::Span;\n \n const NEEDLESS_COLLECT_MSG: &str = \"avoid using `collect()` when not needed\";\n \n@@ -102,7 +102,7 @@ fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCo\n \n                     // Suggest replacing iter_call with iter_replacement, and removing stmt\n                     let mut span = MultiSpan::from_span(method_name.ident.span);\n-                    span.push_span_label(iter_call.span, \"the iterator could be used here instead\".into());\n+                    span.push_span_label(iter_call.span, \"the iterator could be used here instead\");\n                     span_lint_hir_and_then(\n                         cx,\n                         super::NEEDLESS_COLLECT,\n@@ -334,8 +334,8 @@ fn detect_iter_and_into_iters<'tcx: 'a, 'a>(\n     }\n }\n \n-fn get_captured_ids(cx: &LateContext<'_>, ty: &'_ TyS<'_>) -> HirIdSet {\n-    fn get_captured_ids_recursive(cx: &LateContext<'_>, ty: &'_ TyS<'_>, set: &mut HirIdSet) {\n+fn get_captured_ids(cx: &LateContext<'_>, ty: Ty<'_>) -> HirIdSet {\n+    fn get_captured_ids_recursive(cx: &LateContext<'_>, ty: Ty<'_>, set: &mut HirIdSet) {\n         match ty.kind() {\n             ty::Adt(_, generics) => {\n                 for generic in *generics {"}, {"sha": "09f9c05b4fced3d7cc8f01f7c3580b3ea390908f", "filename": "clippy_lints/src/loops/needless_range_loop.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -19,7 +19,7 @@ use std::mem;\n \n /// Checks for looping over a range and then indexing a sequence with it.\n /// The iteratee must be a range literal.\n-#[allow(clippy::too_many_lines)]\n+#[expect(clippy::too_many_lines)]\n pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     pat: &'tcx Pat<'_>,\n@@ -59,7 +59,7 @@ pub(super) fn check<'tcx>(\n                 if let Some(indexed_extent) = indexed_extent {\n                     let parent_def_id = cx.tcx.hir().get_parent_item(expr.hir_id);\n                     let region_scope_tree = cx.tcx.region_scope_tree(parent_def_id);\n-                    let pat_extent = region_scope_tree.var_scope(pat.hir_id.local_id);\n+                    let pat_extent = region_scope_tree.var_scope(pat.hir_id.local_id).unwrap();\n                     if region_scope_tree.is_subscope_of(indexed_extent, pat_extent) {\n                         return;\n                     }\n@@ -262,7 +262,7 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n                 match res {\n                     Res::Local(hir_id) => {\n                         let parent_def_id = self.cx.tcx.hir().get_parent_item(expr.hir_id);\n-                        let extent = self.cx.tcx.region_scope_tree(parent_def_id).var_scope(hir_id.local_id);\n+                        let extent = self.cx.tcx.region_scope_tree(parent_def_id).var_scope(hir_id.local_id).unwrap();\n                         if index_used_directly {\n                             self.indexed_directly.insert(\n                                 seqvar.segments[0].ident.name,\n@@ -273,7 +273,7 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n                         }\n                         return false;  // no need to walk further *on the variable*\n                     }\n-                    Res::Def(DefKind::Static | DefKind::Const, ..) => {\n+                    Res::Def(DefKind::Static (_)| DefKind::Const, ..) => {\n                         if index_used_directly {\n                             self.indexed_directly.insert(\n                                 seqvar.segments[0].ident.name,"}, {"sha": "70a118d6b353930ea8c751c0eef2fe0a96b47e0b", "filename": "clippy_lints/src/loops/never_loop.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -168,14 +168,16 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n             .operands\n             .iter()\n             .map(|(o, _)| match o {\n-                InlineAsmOperand::In { expr, .. }\n-                | InlineAsmOperand::InOut { expr, .. }\n-                | InlineAsmOperand::Sym { expr } => never_loop_expr(expr, main_loop_id),\n+                InlineAsmOperand::In { expr, .. } | InlineAsmOperand::InOut { expr, .. } => {\n+                    never_loop_expr(expr, main_loop_id)\n+                },\n                 InlineAsmOperand::Out { expr, .. } => never_loop_expr_all(&mut expr.iter(), main_loop_id),\n                 InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n                     never_loop_expr_all(&mut once(in_expr).chain(out_expr.iter()), main_loop_id)\n                 },\n-                InlineAsmOperand::Const { .. } => NeverLoopResult::Otherwise,\n+                InlineAsmOperand::Const { .. }\n+                | InlineAsmOperand::SymFn { .. }\n+                | InlineAsmOperand::SymStatic { .. } => NeverLoopResult::Otherwise,\n             })\n             .fold(NeverLoopResult::Otherwise, combine_both),\n         ExprKind::Struct(_, _, None)"}, {"sha": "a0bd7ad0ac647fb7d0f606e932b15a7e5a5031b3", "filename": "clippy_lints/src/loops/single_element_loop.rs", "status": "modified", "additions": 68, "deletions": 16, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,11 +1,13 @@\n use super::SINGLE_ELEMENT_LOOP;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::single_segment_path;\n-use clippy_utils::source::{indent_of, snippet};\n+use clippy_utils::source::{indent_of, snippet_with_applicability};\n use if_chain::if_chain;\n+use rustc_ast::util::parser::PREC_PREFIX;\n+use rustc_ast::Mutability;\n use rustc_errors::Applicability;\n-use rustc_hir::{BorrowKind, Expr, ExprKind, Pat, PatKind};\n+use rustc_hir::{is_range_literal, BorrowKind, Expr, ExprKind, Pat};\n use rustc_lint::LateContext;\n+use rustc_span::edition::Edition;\n \n pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n@@ -14,35 +16,85 @@ pub(super) fn check<'tcx>(\n     body: &'tcx Expr<'_>,\n     expr: &'tcx Expr<'_>,\n ) {\n-    let arg_expr = match arg.kind {\n-        ExprKind::AddrOf(BorrowKind::Ref, _, ref_arg) => ref_arg,\n-        ExprKind::MethodCall(method, args, _) if args.len() == 1 && method.ident.name == rustc_span::sym::iter => {\n-            &args[0]\n-        },\n+    let (arg_expression, prefix) = match arg.kind {\n+        ExprKind::AddrOf(\n+            BorrowKind::Ref,\n+            Mutability::Not,\n+            Expr {\n+                kind: ExprKind::Array([arg]),\n+                ..\n+            },\n+        ) => (arg, \"&\"),\n+        ExprKind::AddrOf(\n+            BorrowKind::Ref,\n+            Mutability::Mut,\n+            Expr {\n+                kind: ExprKind::Array([arg]),\n+                ..\n+            },\n+        ) => (arg, \"&mut \"),\n+        ExprKind::MethodCall(\n+            method,\n+            [\n+                Expr {\n+                    kind: ExprKind::Array([arg]),\n+                    ..\n+                },\n+            ],\n+            _,\n+        ) if method.ident.name == rustc_span::sym::iter => (arg, \"&\"),\n+        ExprKind::MethodCall(\n+            method,\n+            [\n+                Expr {\n+                    kind: ExprKind::Array([arg]),\n+                    ..\n+                },\n+            ],\n+            _,\n+        ) if method.ident.name.as_str() == \"iter_mut\" => (arg, \"&mut \"),\n+        ExprKind::MethodCall(\n+            method,\n+            [\n+                Expr {\n+                    kind: ExprKind::Array([arg]),\n+                    ..\n+                },\n+            ],\n+            _,\n+        ) if method.ident.name == rustc_span::sym::into_iter => (arg, \"\"),\n+        // Only check for arrays edition 2021 or later, as this case will trigger a compiler error otherwise.\n+        ExprKind::Array([arg]) if cx.tcx.sess.edition() >= Edition::Edition2021 => (arg, \"\"),\n         _ => return,\n     };\n     if_chain! {\n-        if let PatKind::Binding(.., target, _) = pat.kind;\n-        if let ExprKind::Array([arg_expression]) = arg_expr.kind;\n-        if let ExprKind::Path(ref list_item) = arg_expression.kind;\n-        if let Some(list_item_name) = single_segment_path(list_item).map(|ps| ps.ident.name);\n         if let ExprKind::Block(block, _) = body.kind;\n         if !block.stmts.is_empty();\n-\n         then {\n-            let mut block_str = snippet(cx, block.span, \"..\").into_owned();\n+            let mut applicability = Applicability::MachineApplicable;\n+            let pat_snip = snippet_with_applicability(cx, pat.span, \"..\", &mut applicability);\n+            let mut arg_snip = snippet_with_applicability(cx, arg_expression.span, \"..\", &mut applicability);\n+            let mut block_str = snippet_with_applicability(cx, block.span, \"..\", &mut applicability).into_owned();\n             block_str.remove(0);\n             block_str.pop();\n+            let indent = \" \".repeat(indent_of(cx, block.stmts[0].span).unwrap_or(0));\n \n+            // Reference iterator from `&(mut) []` or `[].iter(_mut)()`.\n+            if !prefix.is_empty() && (\n+                // Precedence of internal expression is less than or equal to precedence of `&expr`.\n+                arg_expression.precedence().order() <= PREC_PREFIX || is_range_literal(arg_expression)\n+            ) {\n+                arg_snip = format!(\"({arg_snip})\").into();\n+            }\n \n             span_lint_and_sugg(\n                 cx,\n                 SINGLE_ELEMENT_LOOP,\n                 expr.span,\n                 \"for loop over a single element\",\n                 \"try\",\n-                format!(\"{{\\n{}let {} = &{};{}}}\", \" \".repeat(indent_of(cx, block.stmts[0].span).unwrap_or(0)), target.name, list_item_name, block_str),\n-                Applicability::MachineApplicable\n+                format!(\"{{\\n{indent}let {pat_snip} = {prefix}{arg_snip};{block_str}}}\"),\n+                applicability,\n             )\n         }\n     }"}, {"sha": "4801a84eb92ced8d1ac9b10a8e8e4e7d7cd8215b", "filename": "clippy_lints/src/loops/utils.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Floops%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Floops%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Futils.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -7,13 +7,13 @@ use rustc_hir::intravisit::{walk_expr, walk_local, walk_pat, walk_stmt, Visitor}\n use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind, HirId, HirIdMap, Local, Mutability, Pat, PatKind, Stmt};\n use rustc_lint::LateContext;\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::ty::Ty;\n+use rustc_middle::ty::{self, Ty};\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_typeck::hir_ty_to_ty;\n use std::iter::Iterator;\n \n-#[derive(Debug, PartialEq)]\n+#[derive(Debug, PartialEq, Eq)]\n enum IncrementVisitorVarState {\n     Initial,  // Not examined yet\n     IncrOnce, // Incremented exactly once, may be a loop counter\n@@ -332,18 +332,21 @@ pub(super) fn make_iterator_snippet(cx: &LateContext<'_>, arg: &Expr<'_>, applic\n     } else {\n         // (&x).into_iter() ==> x.iter()\n         // (&mut x).into_iter() ==> x.iter_mut()\n-        match &arg.kind {\n-            ExprKind::AddrOf(BorrowKind::Ref, mutability, arg_inner)\n-                if has_iter_method(cx, cx.typeck_results().expr_ty(arg_inner)).is_some() =>\n-            {\n-                let meth_name = match mutability {\n+        let arg_ty = cx.typeck_results().expr_ty_adjusted(arg);\n+        match &arg_ty.kind() {\n+            ty::Ref(_, inner_ty, mutbl) if has_iter_method(cx, *inner_ty).is_some() => {\n+                let method_name = match mutbl {\n                     Mutability::Mut => \"iter_mut\",\n                     Mutability::Not => \"iter\",\n                 };\n+                let caller = match &arg.kind {\n+                    ExprKind::AddrOf(BorrowKind::Ref, _, arg_inner) => arg_inner,\n+                    _ => arg,\n+                };\n                 format!(\n                     \"{}.{}()\",\n-                    sugg::Sugg::hir_with_applicability(cx, arg_inner, \"_\", applic_ref).maybe_par(),\n-                    meth_name,\n+                    sugg::Sugg::hir_with_applicability(cx, caller, \"_\", applic_ref).maybe_par(),\n+                    method_name,\n                 )\n             },\n             _ => format!("}, {"sha": "a63422d2a36ac530c14b75843a7bd38905c58774", "filename": "clippy_lints/src/loops/while_immutable_condition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Floops%2Fwhile_immutable_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Floops%2Fwhile_immutable_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_immutable_condition.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -104,7 +104,7 @@ impl<'a, 'tcx> VarCollectorVisitor<'a, 'tcx> {\n                     Res::Local(hir_id) => {\n                         self.ids.insert(hir_id);\n                     },\n-                    Res::Def(DefKind::Static, def_id) => {\n+                    Res::Def(DefKind::Static(_), def_id) => {\n                         let mutable = self.cx.tcx.is_mutable_static(def_id);\n                         self.def_ids.insert(def_id, mutable);\n                     },"}, {"sha": "82760607ba295e5e11ee219b28346fd54927e469", "filename": "clippy_lints/src/loops/while_let_on_iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -239,7 +239,7 @@ fn uses_iter<'tcx>(cx: &LateContext<'tcx>, iter_expr: &IterExpr, container: &'tc\n     v.uses_iter\n }\n \n-#[allow(clippy::too_many_lines)]\n+#[expect(clippy::too_many_lines)]\n fn needs_mutable_borrow(cx: &LateContext<'_>, iter_expr: &IterExpr, loop_expr: &Expr<'_>) -> bool {\n     struct AfterLoopVisitor<'a, 'b, 'tcx> {\n         cx: &'a LateContext<'tcx>,"}, {"sha": "da806918be06113ef42f6b40640e1510b60ca3b4", "filename": "clippy_lints/src/macro_use.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmacro_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmacro_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmacro_use.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -49,7 +49,7 @@ impl MacroRefData {\n }\n \n #[derive(Default)]\n-#[allow(clippy::module_name_repetitions)]\n+#[expect(clippy::module_name_repetitions)]\n pub struct MacroUseImports {\n     /// the actual import path used and the span of the attribute above it.\n     imports: Vec<(String, Span)>,\n@@ -135,7 +135,6 @@ impl<'tcx> LateLintPass<'tcx> for MacroUseImports {\n             self.push_unique_macro_pat_ty(cx, ty.span);\n         }\n     }\n-    #[allow(clippy::too_many_lines)]\n     fn check_crate_post(&mut self, cx: &LateContext<'_>) {\n         let mut used = FxHashMap::default();\n         let mut check_dup = vec![];"}, {"sha": "20333c150e3d5b3a9c5edae3ef5da557281eac47", "filename": "clippy_lints/src/main_recursion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmain_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmain_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmain_recursion.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -12,7 +12,7 @@ declare_clippy_lint! {\n     ///\n     /// ### Why is this bad?\n     /// Apart from special setups (which we could detect following attributes like #![no_std]),\n-    /// recursing into main() seems like an unintuitive antipattern we should be able to detect.\n+    /// recursing into main() seems like an unintuitive anti-pattern we should be able to detect.\n     ///\n     /// ### Example\n     /// ```no_run"}, {"sha": "60bbcde4f1de566b2ab100acc675130691ba61cd", "filename": "clippy_lints/src/manual_bits.rs", "status": "modified", "additions": 45, "deletions": 8, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmanual_bits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmanual_bits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_bits.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,13 +1,14 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet_opt;\n-use clippy_utils::{match_def_path, meets_msrv, msrvs, paths};\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::{get_parent_expr, meets_msrv, msrvs};\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Expr, ExprKind, GenericArg, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::{self, Ty};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -23,7 +24,7 @@ declare_clippy_lint! {\n     /// ```\n     /// Use instead:\n     /// ```rust\n-    /// usize::BITS;\n+    /// usize::BITS as usize;\n     /// ```\n     #[clippy::version = \"1.60.0\"]\n     pub MANUAL_BITS,\n@@ -47,7 +48,7 @@ impl_lint_pass!(ManualBits => [MANUAL_BITS]);\n \n impl<'tcx> LateLintPass<'tcx> for ManualBits {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if !meets_msrv(self.msrv.as_ref(), &msrvs::MANUAL_BITS) {\n+        if !meets_msrv(self.msrv, msrvs::MANUAL_BITS) {\n             return;\n         }\n \n@@ -58,16 +59,19 @@ impl<'tcx> LateLintPass<'tcx> for ManualBits {\n             if matches!(resolved_ty.kind(), ty::Int(_) | ty::Uint(_));\n             if let ExprKind::Lit(lit) = &other_expr.kind;\n             if let LitKind::Int(8, _) = lit.node;\n-\n             then {\n+                let mut app = Applicability::MachineApplicable;\n+                let ty_snip = snippet_with_applicability(cx, real_ty.span, \"..\", &mut app);\n+                let sugg = create_sugg(cx, expr, format!(\"{ty_snip}::BITS\"));\n+\n                 span_lint_and_sugg(\n                     cx,\n                     MANUAL_BITS,\n                     expr.span,\n                     \"usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\",\n                     \"consider using\",\n-                    format!(\"{}::BITS\", snippet_opt(cx, real_ty.span).unwrap()),\n-                    Applicability::MachineApplicable,\n+                    sugg,\n+                    app,\n                 );\n             }\n         }\n@@ -99,11 +103,44 @@ fn get_size_of_ty<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<\n         if let Some(GenericArg::Type(real_ty)) = args.args.get(0);\n \n         if let Some(def_id) = cx.qpath_res(count_func_qpath, count_func.hir_id).opt_def_id();\n-        if match_def_path(cx, def_id, &paths::MEM_SIZE_OF);\n+        if cx.tcx.is_diagnostic_item(sym::mem_size_of, def_id);\n         then {\n             cx.typeck_results().node_substs(count_func.hir_id).types().next().map(|resolved_ty| (real_ty, resolved_ty))\n         } else {\n             None\n         }\n     }\n }\n+\n+fn create_sugg(cx: &LateContext<'_>, expr: &Expr<'_>, base_sugg: String) -> String {\n+    if let Some(parent_expr) = get_parent_expr(cx, expr) {\n+        if is_ty_conversion(parent_expr) {\n+            return base_sugg;\n+        }\n+\n+        // These expressions have precedence over casts, the suggestion therefore\n+        // needs to be wrapped into parentheses\n+        match parent_expr.kind {\n+            ExprKind::Unary(..) | ExprKind::AddrOf(..) | ExprKind::MethodCall(..) => {\n+                return format!(\"({base_sugg} as usize)\");\n+            },\n+            _ => {},\n+        }\n+    }\n+\n+    format!(\"{base_sugg} as usize\")\n+}\n+\n+fn is_ty_conversion(expr: &Expr<'_>) -> bool {\n+    if let ExprKind::Cast(..) = expr.kind {\n+        true\n+    } else if let ExprKind::MethodCall(path, [_], _) = expr.kind\n+        && path.ident.name == rustc_span::sym::try_into\n+    {\n+        // This is only called for `usize` which implements `TryInto`. Therefore,\n+        // we don't have to check here if `self` implements the `TryInto` trait.\n+        true\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "230ae029ed9d28978eeb256c40604e24e0df1d81", "filename": "clippy_lints/src/manual_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_map.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -46,7 +46,7 @@ declare_clippy_lint! {\n declare_lint_pass!(ManualMap => [MANUAL_MAP]);\n \n impl<'tcx> LateLintPass<'tcx> for ManualMap {\n-    #[allow(clippy::too_many_lines)]\n+    #[expect(clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         let (scrutinee, then_pat, then_body, else_pat, else_body) = match IfLetOrMatch::parse(cx, expr) {\n             Some(IfLetOrMatch::IfLet(scrutinee, pat, body, Some(r#else))) => (scrutinee, pat, body, None, r#else),"}, {"sha": "80845ace3f94071404cc6b208a969552bc308e7a", "filename": "clippy_lints/src/manual_non_exhaustive.rs", "status": "modified", "additions": 116, "deletions": 82, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,13 +1,16 @@\n-use clippy_utils::attrs::is_doc_hidden;\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::{meets_msrv, msrvs};\n-use if_chain::if_chain;\n-use rustc_ast::ast::{FieldDef, Item, ItemKind, Variant, VariantData, VisibilityKind};\n+use clippy_utils::{is_doc_hidden, is_lint_allowed, meets_msrv, msrvs};\n+use rustc_ast::ast::{self, VisibilityKind};\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n-use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n+use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n+use rustc_hir::{self as hir, Expr, ExprKind, QPath};\n+use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n+use rustc_middle::ty::DefIdTree;\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::def_id::{DefId, LocalDefId};\n use rustc_span::{sym, Span};\n \n declare_clippy_lint! {\n@@ -58,129 +61,160 @@ declare_clippy_lint! {\n     \"manual implementations of the non-exhaustive pattern can be simplified using #[non_exhaustive]\"\n }\n \n-#[derive(Clone)]\n-pub struct ManualNonExhaustive {\n+#[expect(clippy::module_name_repetitions)]\n+pub struct ManualNonExhaustiveStruct {\n     msrv: Option<RustcVersion>,\n }\n \n-impl ManualNonExhaustive {\n+impl ManualNonExhaustiveStruct {\n     #[must_use]\n     pub fn new(msrv: Option<RustcVersion>) -> Self {\n         Self { msrv }\n     }\n }\n \n-impl_lint_pass!(ManualNonExhaustive => [MANUAL_NON_EXHAUSTIVE]);\n+impl_lint_pass!(ManualNonExhaustiveStruct => [MANUAL_NON_EXHAUSTIVE]);\n \n-impl EarlyLintPass for ManualNonExhaustive {\n-    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n-        if !meets_msrv(self.msrv.as_ref(), &msrvs::NON_EXHAUSTIVE) {\n-            return;\n-        }\n+#[expect(clippy::module_name_repetitions)]\n+pub struct ManualNonExhaustiveEnum {\n+    msrv: Option<RustcVersion>,\n+    constructed_enum_variants: FxHashSet<(DefId, DefId)>,\n+    potential_enums: Vec<(LocalDefId, LocalDefId, Span, Span)>,\n+}\n \n-        match &item.kind {\n-            ItemKind::Enum(def, _) => {\n-                check_manual_non_exhaustive_enum(cx, item, &def.variants);\n-            },\n-            ItemKind::Struct(variant_data, _) => {\n-                if let VariantData::Unit(..) = variant_data {\n-                    return;\n-                }\n-\n-                check_manual_non_exhaustive_struct(cx, item, variant_data);\n-            },\n-            _ => {},\n+impl ManualNonExhaustiveEnum {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self {\n+            msrv,\n+            constructed_enum_variants: FxHashSet::default(),\n+            potential_enums: Vec::new(),\n         }\n     }\n-\n-    extract_msrv_attr!(EarlyContext);\n }\n \n-fn check_manual_non_exhaustive_enum(cx: &EarlyContext<'_>, item: &Item, variants: &[Variant]) {\n-    fn is_non_exhaustive_marker(variant: &Variant) -> bool {\n-        matches!(variant.data, VariantData::Unit(_))\n-            && variant.ident.as_str().starts_with('_')\n-            && is_doc_hidden(&variant.attrs)\n-    }\n+impl_lint_pass!(ManualNonExhaustiveEnum => [MANUAL_NON_EXHAUSTIVE]);\n \n-    let mut markers = variants.iter().filter(|v| is_non_exhaustive_marker(v));\n-    if_chain! {\n-        if let Some(marker) = markers.next();\n-        if markers.count() == 0 && variants.len() > 1;\n-        then {\n-            span_lint_and_then(\n-                cx,\n-                MANUAL_NON_EXHAUSTIVE,\n-                item.span,\n-                \"this seems like a manual implementation of the non-exhaustive pattern\",\n-                |diag| {\n-                    if_chain! {\n-                        if !item.attrs.iter().any(|attr| attr.has_name(sym::non_exhaustive));\n-                        let header_span = cx.sess().source_map().span_until_char(item.span, '{');\n-                        if let Some(snippet) = snippet_opt(cx, header_span);\n-                        then {\n+impl EarlyLintPass for ManualNonExhaustiveStruct {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &ast::Item) {\n+        if !meets_msrv(self.msrv, msrvs::NON_EXHAUSTIVE) {\n+            return;\n+        }\n+\n+        if let ast::ItemKind::Struct(variant_data, _) = &item.kind {\n+            let (fields, delimiter) = match variant_data {\n+                ast::VariantData::Struct(fields, _) => (&**fields, '{'),\n+                ast::VariantData::Tuple(fields, _) => (&**fields, '('),\n+                ast::VariantData::Unit(_) => return,\n+            };\n+            if fields.len() <= 1 {\n+                return;\n+            }\n+            let mut iter = fields.iter().filter_map(|f| match f.vis.kind {\n+                VisibilityKind::Public => None,\n+                VisibilityKind::Inherited => Some(Ok(f)),\n+                _ => Some(Err(())),\n+            });\n+            if let Some(Ok(field)) = iter.next()\n+                && iter.next().is_none()\n+                && field.ty.kind.is_unit()\n+                && field.ident.map_or(true, |name| name.as_str().starts_with('_'))\n+            {\n+                span_lint_and_then(\n+                    cx,\n+                    MANUAL_NON_EXHAUSTIVE,\n+                    item.span,\n+                    \"this seems like a manual implementation of the non-exhaustive pattern\",\n+                    |diag| {\n+                        if !item.attrs.iter().any(|attr| attr.has_name(sym::non_exhaustive))\n+                            && let header_span = cx.sess().source_map().span_until_char(item.span, delimiter)\n+                            && let Some(snippet) = snippet_opt(cx, header_span)\n+                        {\n                             diag.span_suggestion(\n                                 header_span,\n                                 \"add the attribute\",\n                                 format!(\"#[non_exhaustive] {}\", snippet),\n                                 Applicability::Unspecified,\n                             );\n                         }\n+                        diag.span_help(field.span, \"remove this field\");\n                     }\n-                    diag.span_help(marker.span, \"remove this variant\");\n-                });\n+                );\n+            }\n         }\n     }\n+\n+    extract_msrv_attr!(EarlyContext);\n }\n \n-fn check_manual_non_exhaustive_struct(cx: &EarlyContext<'_>, item: &Item, data: &VariantData) {\n-    fn is_private(field: &FieldDef) -> bool {\n-        matches!(field.vis.kind, VisibilityKind::Inherited)\n-    }\n+impl<'tcx> LateLintPass<'tcx> for ManualNonExhaustiveEnum {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n+        if !meets_msrv(self.msrv, msrvs::NON_EXHAUSTIVE) {\n+            return;\n+        }\n \n-    fn is_non_exhaustive_marker(field: &FieldDef) -> bool {\n-        is_private(field) && field.ty.kind.is_unit() && field.ident.map_or(true, |n| n.as_str().starts_with('_'))\n+        if let hir::ItemKind::Enum(def, _) = &item.kind\n+            && def.variants.len() > 1\n+        {\n+            let mut iter = def.variants.iter().filter_map(|v| {\n+                let id = cx.tcx.hir().local_def_id(v.id);\n+                (matches!(v.data, hir::VariantData::Unit(_))\n+                    && v.ident.as_str().starts_with('_')\n+                    && is_doc_hidden(cx.tcx.hir().attrs(v.id)))\n+                .then(|| (id, v.span))\n+            });\n+            if let Some((id, span)) = iter.next()\n+                && iter.next().is_none()\n+            {\n+                self.potential_enums.push((item.def_id, id, item.span, span));\n+            }\n+        }\n     }\n \n-    fn find_header_span(cx: &EarlyContext<'_>, item: &Item, data: &VariantData) -> Span {\n-        let delimiter = match data {\n-            VariantData::Struct(..) => '{',\n-            VariantData::Tuple(..) => '(',\n-            VariantData::Unit(_) => unreachable!(\"`VariantData::Unit` is already handled above\"),\n-        };\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n+        if let ExprKind::Path(QPath::Resolved(None, p)) = &e.kind\n+            && let [.., name] = p.segments\n+            && let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Const), id) = p.res\n+            && name.ident.as_str().starts_with('_')\n+        {\n+            let variant_id = cx.tcx.parent(id);\n+            let enum_id = cx.tcx.parent(variant_id);\n \n-        cx.sess().source_map().span_until_char(item.span, delimiter)\n+            self.constructed_enum_variants.insert((enum_id, variant_id));\n+        }\n     }\n \n-    let fields = data.fields();\n-    let private_fields = fields.iter().filter(|f| is_private(f)).count();\n-    let public_fields = fields.iter().filter(|f| f.vis.kind.is_pub()).count();\n-\n-    if_chain! {\n-        if private_fields == 1 && public_fields >= 1 && public_fields == fields.len() - 1;\n-        if let Some(marker) = fields.iter().find(|f| is_non_exhaustive_marker(f));\n-        then {\n+    fn check_crate_post(&mut self, cx: &LateContext<'tcx>) {\n+        for &(enum_id, _, enum_span, variant_span) in\n+            self.potential_enums.iter().filter(|&&(enum_id, variant_id, _, _)| {\n+                !self\n+                    .constructed_enum_variants\n+                    .contains(&(enum_id.to_def_id(), variant_id.to_def_id()))\n+                    && !is_lint_allowed(cx, MANUAL_NON_EXHAUSTIVE, cx.tcx.hir().local_def_id_to_hir_id(enum_id))\n+            })\n+        {\n             span_lint_and_then(\n                 cx,\n                 MANUAL_NON_EXHAUSTIVE,\n-                item.span,\n+                enum_span,\n                 \"this seems like a manual implementation of the non-exhaustive pattern\",\n                 |diag| {\n-                    if_chain! {\n-                        if !item.attrs.iter().any(|attr| attr.has_name(sym::non_exhaustive));\n-                        let header_span = find_header_span(cx, item, data);\n-                        if let Some(snippet) = snippet_opt(cx, header_span);\n-                        then {\n+                    if !cx.tcx.adt_def(enum_id).is_variant_list_non_exhaustive()\n+                        && let header_span = cx.sess().source_map().span_until_char(enum_span, '{')\n+                        && let Some(snippet) = snippet_opt(cx, header_span)\n+                    {\n                             diag.span_suggestion(\n                                 header_span,\n                                 \"add the attribute\",\n                                 format!(\"#[non_exhaustive] {}\", snippet),\n                                 Applicability::Unspecified,\n                             );\n-                        }\n                     }\n-                    diag.span_help(marker.span, \"remove this field\");\n-                });\n+                    diag.span_help(variant_span, \"remove this variant\");\n+                },\n+            );\n         }\n     }\n+\n+    extract_msrv_attr!(LateContext);\n }"}, {"sha": "dfb3efc4e28b65c246e3fe67b3be4b74ac12c8e0", "filename": "clippy_lints/src/manual_strip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmanual_strip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmanual_strip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_strip.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -68,7 +68,7 @@ enum StripKind {\n \n impl<'tcx> LateLintPass<'tcx> for ManualStrip {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if !meets_msrv(self.msrv.as_ref(), &msrvs::STR_STRIP_PREFIX) {\n+        if !meets_msrv(self.msrv, msrvs::STR_STRIP_PREFIX) {\n             return;\n         }\n "}, {"sha": "a13d191375bfa02ad4df4afaf56dbb107da67f46", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -100,7 +100,7 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n                                     let obj_ty = cx.typeck_results().expr_ty(obj);\n                                     if let ty::Ref(_, ty, mutability) = obj_ty.kind() {\n                                         if matches!(mutability, Mutability::Not) {\n-                                            let copy = is_copy(cx, ty);\n+                                            let copy = is_copy(cx, *ty);\n                                             self.lint_explicit_closure(cx, e.span, args[0].span, copy);\n                                         }\n                                     } else {\n@@ -143,15 +143,11 @@ fn lint_needless_cloning(cx: &LateContext<'_>, root: Span, receiver: Span) {\n impl MapClone {\n     fn lint_explicit_closure(&self, cx: &LateContext<'_>, replace: Span, root: Span, is_copy: bool) {\n         let mut applicability = Applicability::MachineApplicable;\n-        let message = if is_copy {\n-            \"you are using an explicit closure for copying elements\"\n-        } else {\n-            \"you are using an explicit closure for cloning elements\"\n-        };\n-        let sugg_method = if is_copy && meets_msrv(self.msrv.as_ref(), &msrvs::ITERATOR_COPIED) {\n-            \"copied\"\n+\n+        let (message, sugg_method) = if is_copy && meets_msrv(self.msrv, msrvs::ITERATOR_COPIED) {\n+            (\"you are using an explicit closure for copying elements\", \"copied\")\n         } else {\n-            \"cloned\"\n+            (\"you are using an explicit closure for cloning elements\", \"cloned\")\n         };\n \n         span_lint_and_sugg("}, {"sha": "f552d5c1afab9268f4448af24acbd7e881cd2a84", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::source::snippet;\n+use clippy_utils::source::{snippet, snippet_with_applicability, snippet_with_context};\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::{iter_input_pats, method_chain_args};\n use if_chain::if_chain;\n@@ -217,36 +217,33 @@ fn lint_map_unit_fn(cx: &LateContext<'_>, stmt: &hir::Stmt<'_>, expr: &hir::Expr\n     let fn_arg = &map_args[1];\n \n     if is_unit_function(cx, fn_arg) {\n+        let mut applicability = Applicability::MachineApplicable;\n         let msg = suggestion_msg(\"function\", map_type);\n         let suggestion = format!(\n             \"if let {0}({binding}) = {1} {{ {2}({binding}) }}\",\n             variant,\n-            snippet(cx, var_arg.span, \"_\"),\n-            snippet(cx, fn_arg.span, \"_\"),\n+            snippet_with_applicability(cx, var_arg.span, \"_\", &mut applicability),\n+            snippet_with_applicability(cx, fn_arg.span, \"_\", &mut applicability),\n             binding = let_binding_name(cx, var_arg)\n         );\n \n         span_lint_and_then(cx, lint, expr.span, &msg, |diag| {\n-            diag.span_suggestion(stmt.span, \"try this\", suggestion, Applicability::MachineApplicable);\n+            diag.span_suggestion(stmt.span, \"try this\", suggestion, applicability);\n         });\n     } else if let Some((binding, closure_expr)) = unit_closure(cx, fn_arg) {\n         let msg = suggestion_msg(\"closure\", map_type);\n \n         span_lint_and_then(cx, lint, expr.span, &msg, |diag| {\n             if let Some(reduced_expr_span) = reduce_unit_expression(cx, closure_expr) {\n+                let mut applicability = Applicability::MachineApplicable;\n                 let suggestion = format!(\n                     \"if let {0}({1}) = {2} {{ {3} }}\",\n                     variant,\n-                    snippet(cx, binding.pat.span, \"_\"),\n-                    snippet(cx, var_arg.span, \"_\"),\n-                    snippet(cx, reduced_expr_span, \"_\")\n-                );\n-                diag.span_suggestion(\n-                    stmt.span,\n-                    \"try this\",\n-                    suggestion,\n-                    Applicability::MachineApplicable, // snippet\n+                    snippet_with_applicability(cx, binding.pat.span, \"_\", &mut applicability),\n+                    snippet_with_applicability(cx, var_arg.span, \"_\", &mut applicability),\n+                    snippet_with_context(cx, reduced_expr_span, var_arg.span.ctxt(), \"_\", &mut applicability).0,\n                 );\n+                diag.span_suggestion(stmt.span, \"try this\", suggestion, applicability);\n             } else {\n                 let suggestion = format!(\n                     \"if let {0}({1}) = {2} {{ ... }}\","}, {"sha": "3349b85f1347a396519aeb5cba96c59813c93cec", "filename": "clippy_lints/src/match_result_ok.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatch_result_ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatch_result_ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatch_result_ok.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -24,7 +24,7 @@ declare_clippy_lint! {\n     ///     vec.push(value)\n     /// }\n     ///\n-    /// if let Some(valie) = iter.next().ok() {\n+    /// if let Some(value) = iter.next().ok() {\n     ///     vec.push(value)\n     /// }\n     /// ```\n@@ -60,7 +60,7 @@ impl<'tcx> LateLintPass<'tcx> for MatchResultOk {\n         if_chain! {\n             if let ExprKind::MethodCall(ok_path, [ref result_types_0, ..], _) = let_expr.kind; //check is expr.ok() has type Result<T,E>.ok(, _)\n             if let PatKind::TupleStruct(QPath::Resolved(_, x), y, _)  = let_pat.kind; //get operation\n-            if method_chain_args(let_expr, &[\"ok\"]).is_some(); //test to see if using ok() methoduse std::marker::Sized;\n+            if method_chain_args(let_expr, &[\"ok\"]).is_some(); //test to see if using ok() method use std::marker::Sized;\n             if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(result_types_0), sym::Result);\n             if rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_path(x, false)) == \"Some\";\n "}, {"sha": "d97a878825af209d3db3f6281baed84ecb9acc6d", "filename": "clippy_lints/src/match_str_case_mismatch.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatch_str_case_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatch_str_case_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatch_str_case_mismatch.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -21,7 +21,6 @@ declare_clippy_lint! {\n     /// ### Example\n     /// ```rust\n     /// # let text = \"Foo\";\n-    ///\n     /// match &*text.to_ascii_lowercase() {\n     ///     \"foo\" => {},\n     ///     \"Bar\" => {},\n@@ -31,7 +30,6 @@ declare_clippy_lint! {\n     /// Use instead:\n     /// ```rust\n     /// # let text = \"Foo\";\n-    ///\n     /// match &*text.to_ascii_lowercase() {\n     ///     \"foo\" => {},\n     ///     \"bar\" => {},"}, {"sha": "e0cbadeb64550dc3ce5192a10f2f6cab17bee4bb", "filename": "clippy_lints/src/matches.rs", "status": "removed", "additions": 0, "deletions": 2437, "changes": 2437, "blob_url": "https://github.com/rust-lang/rust/blob/cb29e3effbf72db2e1f5177336bfb3309ec8805e/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb29e3effbf72db2e1f5177336bfb3309ec8805e/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=cb29e3effbf72db2e1f5177336bfb3309ec8805e", "patch": "@@ -1,2437 +0,0 @@\n-use clippy_utils::consts::{constant, constant_full_int, miri_to_const, FullInt};\n-use clippy_utils::diagnostics::{\n-    multispan_sugg, span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then,\n-};\n-use clippy_utils::macros::{is_panic, root_macro_call};\n-use clippy_utils::source::{expr_block, indent_of, snippet, snippet_block, snippet_opt, snippet_with_applicability};\n-use clippy_utils::sugg::Sugg;\n-use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, match_type, peel_mid_ty_refs};\n-use clippy_utils::visitors::is_local_used;\n-use clippy_utils::{\n-    get_parent_expr, is_lang_ctor, is_lint_allowed, is_refutable, is_unit_expr, is_wild, meets_msrv, msrvs,\n-    path_to_local, path_to_local_id, peel_blocks, peel_hir_pat_refs, peel_n_hir_expr_refs, recurse_or_patterns,\n-    strip_pat_refs,\n-};\n-use clippy_utils::{higher, peel_blocks_with_stmt};\n-use clippy_utils::{paths, search_same, SpanlessEq, SpanlessHash};\n-use core::iter::{once, ExactSizeIterator};\n-use if_chain::if_chain;\n-use rustc_ast::ast::{Attribute, LitKind};\n-use rustc_errors::Applicability;\n-use rustc_hir::def::{CtorKind, DefKind, Res};\n-use rustc_hir::LangItem::{OptionNone, OptionSome};\n-use rustc_hir::{\n-    self as hir, Arm, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, Guard, HirId, Local, MatchSource,\n-    Mutability, Node, Pat, PatKind, PathSegment, QPath, RangeEnd, TyKind,\n-};\n-use rustc_hir::{HirIdMap, HirIdSet};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{self, Ty, TyS, VariantDef};\n-use rustc_semver::RustcVersion;\n-use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::source_map::{Span, Spanned};\n-use rustc_span::{sym, symbol::kw};\n-use std::cmp::{max, Ordering};\n-use std::collections::hash_map::Entry;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for matches with a single arm where an `if let`\n-    /// will usually suffice.\n-    ///\n-    /// ### Why is this bad?\n-    /// Just readability \u2013 `if let` nests less than a `match`.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # fn bar(stool: &str) {}\n-    /// # let x = Some(\"abc\");\n-    /// // Bad\n-    /// match x {\n-    ///     Some(ref foo) => bar(foo),\n-    ///     _ => (),\n-    /// }\n-    ///\n-    /// // Good\n-    /// if let Some(ref foo) = x {\n-    ///     bar(foo);\n-    /// }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub SINGLE_MATCH,\n-    style,\n-    \"a `match` statement with a single nontrivial arm (i.e., where the other arm is `_ => {}`) instead of `if let`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for matches with two arms where an `if let else` will\n-    /// usually suffice.\n-    ///\n-    /// ### Why is this bad?\n-    /// Just readability \u2013 `if let` nests less than a `match`.\n-    ///\n-    /// ### Known problems\n-    /// Personal style preferences may differ.\n-    ///\n-    /// ### Example\n-    /// Using `match`:\n-    ///\n-    /// ```rust\n-    /// # fn bar(foo: &usize) {}\n-    /// # let other_ref: usize = 1;\n-    /// # let x: Option<&usize> = Some(&1);\n-    /// match x {\n-    ///     Some(ref foo) => bar(foo),\n-    ///     _ => bar(&other_ref),\n-    /// }\n-    /// ```\n-    ///\n-    /// Using `if let` with `else`:\n-    ///\n-    /// ```rust\n-    /// # fn bar(foo: &usize) {}\n-    /// # let other_ref: usize = 1;\n-    /// # let x: Option<&usize> = Some(&1);\n-    /// if let Some(ref foo) = x {\n-    ///     bar(foo);\n-    /// } else {\n-    ///     bar(&other_ref);\n-    /// }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub SINGLE_MATCH_ELSE,\n-    pedantic,\n-    \"a `match` statement with two arms where the second arm's pattern is a placeholder instead of a specific match pattern\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for matches where all arms match a reference,\n-    /// suggesting to remove the reference and deref the matched expression\n-    /// instead. It also checks for `if let &foo = bar` blocks.\n-    ///\n-    /// ### Why is this bad?\n-    /// It just makes the code less readable. That reference\n-    /// destructuring adds nothing to the code.\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// // Bad\n-    /// match x {\n-    ///     &A(ref y) => foo(y),\n-    ///     &B => bar(),\n-    ///     _ => frob(&x),\n-    /// }\n-    ///\n-    /// // Good\n-    /// match *x {\n-    ///     A(ref y) => foo(y),\n-    ///     B => bar(),\n-    ///     _ => frob(x),\n-    /// }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub MATCH_REF_PATS,\n-    style,\n-    \"a `match` or `if let` with all arms prefixed with `&` instead of deref-ing the match expression\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for matches where match expression is a `bool`. It\n-    /// suggests to replace the expression with an `if...else` block.\n-    ///\n-    /// ### Why is this bad?\n-    /// It makes the code less readable.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # fn foo() {}\n-    /// # fn bar() {}\n-    /// let condition: bool = true;\n-    /// match condition {\n-    ///     true => foo(),\n-    ///     false => bar(),\n-    /// }\n-    /// ```\n-    /// Use if/else instead:\n-    /// ```rust\n-    /// # fn foo() {}\n-    /// # fn bar() {}\n-    /// let condition: bool = true;\n-    /// if condition {\n-    ///     foo();\n-    /// } else {\n-    ///     bar();\n-    /// }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub MATCH_BOOL,\n-    pedantic,\n-    \"a `match` on a boolean expression instead of an `if..else` block\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for overlapping match arms.\n-    ///\n-    /// ### Why is this bad?\n-    /// It is likely to be an error and if not, makes the code\n-    /// less obvious.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let x = 5;\n-    /// match x {\n-    ///     1..=10 => println!(\"1 ... 10\"),\n-    ///     5..=15 => println!(\"5 ... 15\"),\n-    ///     _ => (),\n-    /// }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub MATCH_OVERLAPPING_ARM,\n-    style,\n-    \"a `match` with overlapping arms\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for arm which matches all errors with `Err(_)`\n-    /// and take drastic actions like `panic!`.\n-    ///\n-    /// ### Why is this bad?\n-    /// It is generally a bad practice, similar to\n-    /// catching all exceptions in java with `catch(Exception)`\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let x: Result<i32, &str> = Ok(3);\n-    /// match x {\n-    ///     Ok(_) => println!(\"ok\"),\n-    ///     Err(_) => panic!(\"err\"),\n-    /// }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub MATCH_WILD_ERR_ARM,\n-    pedantic,\n-    \"a `match` with `Err(_)` arm and take drastic actions\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for match which is used to add a reference to an\n-    /// `Option` value.\n-    ///\n-    /// ### Why is this bad?\n-    /// Using `as_ref()` or `as_mut()` instead is shorter.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let x: Option<()> = None;\n-    ///\n-    /// // Bad\n-    /// let r: Option<&()> = match x {\n-    ///     None => None,\n-    ///     Some(ref v) => Some(v),\n-    /// };\n-    ///\n-    /// // Good\n-    /// let r: Option<&()> = x.as_ref();\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub MATCH_AS_REF,\n-    complexity,\n-    \"a `match` on an Option value instead of using `as_ref()` or `as_mut`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for wildcard enum matches using `_`.\n-    ///\n-    /// ### Why is this bad?\n-    /// New enum variants added by library updates can be missed.\n-    ///\n-    /// ### Known problems\n-    /// Suggested replacements may be incorrect if guards exhaustively cover some\n-    /// variants, and also may not use correct path to enum if it's not present in the current scope.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # enum Foo { A(usize), B(usize) }\n-    /// # let x = Foo::B(1);\n-    /// // Bad\n-    /// match x {\n-    ///     Foo::A(_) => {},\n-    ///     _ => {},\n-    /// }\n-    ///\n-    /// // Good\n-    /// match x {\n-    ///     Foo::A(_) => {},\n-    ///     Foo::B(_) => {},\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.34.0\"]\n-    pub WILDCARD_ENUM_MATCH_ARM,\n-    restriction,\n-    \"a wildcard enum match arm using `_`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for wildcard enum matches for a single variant.\n-    ///\n-    /// ### Why is this bad?\n-    /// New enum variants added by library updates can be missed.\n-    ///\n-    /// ### Known problems\n-    /// Suggested replacements may not use correct path to enum\n-    /// if it's not present in the current scope.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # enum Foo { A, B, C }\n-    /// # let x = Foo::B;\n-    /// // Bad\n-    /// match x {\n-    ///     Foo::A => {},\n-    ///     Foo::B => {},\n-    ///     _ => {},\n-    /// }\n-    ///\n-    /// // Good\n-    /// match x {\n-    ///     Foo::A => {},\n-    ///     Foo::B => {},\n-    ///     Foo::C => {},\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.45.0\"]\n-    pub MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n-    pedantic,\n-    \"a wildcard enum match for a single variant\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for wildcard pattern used with others patterns in same match arm.\n-    ///\n-    /// ### Why is this bad?\n-    /// Wildcard pattern already covers any other pattern as it will match anyway.\n-    /// It makes the code less readable, especially to spot wildcard pattern use in match arm.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// // Bad\n-    /// match \"foo\" {\n-    ///     \"a\" => {},\n-    ///     \"bar\" | _ => {},\n-    /// }\n-    ///\n-    /// // Good\n-    /// match \"foo\" {\n-    ///     \"a\" => {},\n-    ///     _ => {},\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.42.0\"]\n-    pub WILDCARD_IN_OR_PATTERNS,\n-    complexity,\n-    \"a wildcard pattern used with others patterns in same match arm\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for matches being used to destructure a single-variant enum\n-    /// or tuple struct where a `let` will suffice.\n-    ///\n-    /// ### Why is this bad?\n-    /// Just readability \u2013 `let` doesn't nest, whereas a `match` does.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// enum Wrapper {\n-    ///     Data(i32),\n-    /// }\n-    ///\n-    /// let wrapper = Wrapper::Data(42);\n-    ///\n-    /// let data = match wrapper {\n-    ///     Wrapper::Data(i) => i,\n-    /// };\n-    /// ```\n-    ///\n-    /// The correct use would be:\n-    /// ```rust\n-    /// enum Wrapper {\n-    ///     Data(i32),\n-    /// }\n-    ///\n-    /// let wrapper = Wrapper::Data(42);\n-    /// let Wrapper::Data(data) = wrapper;\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub INFALLIBLE_DESTRUCTURING_MATCH,\n-    style,\n-    \"a `match` statement with a single infallible arm instead of a `let`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for useless match that binds to only one value.\n-    ///\n-    /// ### Why is this bad?\n-    /// Readability and needless complexity.\n-    ///\n-    /// ### Known problems\n-    ///  Suggested replacements may be incorrect when `match`\n-    /// is actually binding temporary value, bringing a 'dropped while borrowed' error.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let a = 1;\n-    /// # let b = 2;\n-    ///\n-    /// // Bad\n-    /// match (a, b) {\n-    ///     (c, d) => {\n-    ///         // useless match\n-    ///     }\n-    /// }\n-    ///\n-    /// // Good\n-    /// let (c, d) = (a, b);\n-    /// ```\n-    #[clippy::version = \"1.43.0\"]\n-    pub MATCH_SINGLE_BINDING,\n-    complexity,\n-    \"a match with a single binding instead of using `let` statement\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for unnecessary '..' pattern binding on struct when all fields are explicitly matched.\n-    ///\n-    /// ### Why is this bad?\n-    /// Correctness and readability. It's like having a wildcard pattern after\n-    /// matching all enum variants explicitly.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # struct A { a: i32 }\n-    /// let a = A { a: 5 };\n-    ///\n-    /// // Bad\n-    /// match a {\n-    ///     A { a: 5, .. } => {},\n-    ///     _ => {},\n-    /// }\n-    ///\n-    /// // Good\n-    /// match a {\n-    ///     A { a: 5 } => {},\n-    ///     _ => {},\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.43.0\"]\n-    pub REST_PAT_IN_FULLY_BOUND_STRUCTS,\n-    restriction,\n-    \"a match on a struct that binds all fields but still uses the wildcard pattern\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Lint for redundant pattern matching over `Result`, `Option`,\n-    /// `std::task::Poll` or `std::net::IpAddr`\n-    ///\n-    /// ### Why is this bad?\n-    /// It's more concise and clear to just use the proper\n-    /// utility function\n-    ///\n-    /// ### Known problems\n-    /// This will change the drop order for the matched type. Both `if let` and\n-    /// `while let` will drop the value at the end of the block, both `if` and `while` will drop the\n-    /// value before entering the block. For most types this change will not matter, but for a few\n-    /// types this will not be an acceptable change (e.g. locks). See the\n-    /// [reference](https://doc.rust-lang.org/reference/destructors.html#drop-scopes) for more about\n-    /// drop order.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # use std::task::Poll;\n-    /// # use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n-    /// if let Ok(_) = Ok::<i32, i32>(42) {}\n-    /// if let Err(_) = Err::<i32, i32>(42) {}\n-    /// if let None = None::<()> {}\n-    /// if let Some(_) = Some(42) {}\n-    /// if let Poll::Pending = Poll::Pending::<()> {}\n-    /// if let Poll::Ready(_) = Poll::Ready(42) {}\n-    /// if let IpAddr::V4(_) = IpAddr::V4(Ipv4Addr::LOCALHOST) {}\n-    /// if let IpAddr::V6(_) = IpAddr::V6(Ipv6Addr::LOCALHOST) {}\n-    /// match Ok::<i32, i32>(42) {\n-    ///     Ok(_) => true,\n-    ///     Err(_) => false,\n-    /// };\n-    /// ```\n-    ///\n-    /// The more idiomatic use would be:\n-    ///\n-    /// ```rust\n-    /// # use std::task::Poll;\n-    /// # use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n-    /// if Ok::<i32, i32>(42).is_ok() {}\n-    /// if Err::<i32, i32>(42).is_err() {}\n-    /// if None::<()>.is_none() {}\n-    /// if Some(42).is_some() {}\n-    /// if Poll::Pending::<()>.is_pending() {}\n-    /// if Poll::Ready(42).is_ready() {}\n-    /// if IpAddr::V4(Ipv4Addr::LOCALHOST).is_ipv4() {}\n-    /// if IpAddr::V6(Ipv6Addr::LOCALHOST).is_ipv6() {}\n-    /// Ok::<i32, i32>(42).is_ok();\n-    /// ```\n-    #[clippy::version = \"1.31.0\"]\n-    pub REDUNDANT_PATTERN_MATCHING,\n-    style,\n-    \"use the proper utility function avoiding an `if let`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for `match`  or `if let` expressions producing a\n-    /// `bool` that could be written using `matches!`\n-    ///\n-    /// ### Why is this bad?\n-    /// Readability and needless complexity.\n-    ///\n-    /// ### Known problems\n-    /// This lint falsely triggers, if there are arms with\n-    /// `cfg` attributes that remove an arm evaluating to `false`.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let x = Some(5);\n-    ///\n-    /// // Bad\n-    /// let a = match x {\n-    ///     Some(0) => true,\n-    ///     _ => false,\n-    /// };\n-    ///\n-    /// let a = if let Some(0) = x {\n-    ///     true\n-    /// } else {\n-    ///     false\n-    /// };\n-    ///\n-    /// // Good\n-    /// let a = matches!(x, Some(0));\n-    /// ```\n-    #[clippy::version = \"1.47.0\"]\n-    pub MATCH_LIKE_MATCHES_MACRO,\n-    style,\n-    \"a match that could be written with the matches! macro\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for `match` with identical arm bodies.\n-    ///\n-    /// ### Why is this bad?\n-    /// This is probably a copy & paste error. If arm bodies\n-    /// are the same on purpose, you can factor them\n-    /// [using `|`](https://doc.rust-lang.org/book/patterns.html#multiple-patterns).\n-    ///\n-    /// ### Known problems\n-    /// False positive possible with order dependent `match`\n-    /// (see issue\n-    /// [#860](https://github.com/rust-lang/rust-clippy/issues/860)).\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// match foo {\n-    ///     Bar => bar(),\n-    ///     Quz => quz(),\n-    ///     Baz => bar(), // <= oops\n-    /// }\n-    /// ```\n-    ///\n-    /// This should probably be\n-    /// ```rust,ignore\n-    /// match foo {\n-    ///     Bar => bar(),\n-    ///     Quz => quz(),\n-    ///     Baz => baz(), // <= fixed\n-    /// }\n-    /// ```\n-    ///\n-    /// or if the original code was not a typo:\n-    /// ```rust,ignore\n-    /// match foo {\n-    ///     Bar | Baz => bar(), // <= shows the intent better\n-    ///     Quz => quz(),\n-    /// }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub MATCH_SAME_ARMS,\n-    pedantic,\n-    \"`match` with identical arm bodies\"\n-}\n-\n-#[derive(Default)]\n-pub struct Matches {\n-    msrv: Option<RustcVersion>,\n-    infallible_destructuring_match_linted: bool,\n-}\n-\n-impl Matches {\n-    #[must_use]\n-    pub fn new(msrv: Option<RustcVersion>) -> Self {\n-        Self {\n-            msrv,\n-            ..Matches::default()\n-        }\n-    }\n-}\n-\n-impl_lint_pass!(Matches => [\n-    SINGLE_MATCH,\n-    MATCH_REF_PATS,\n-    MATCH_BOOL,\n-    SINGLE_MATCH_ELSE,\n-    MATCH_OVERLAPPING_ARM,\n-    MATCH_WILD_ERR_ARM,\n-    MATCH_AS_REF,\n-    WILDCARD_ENUM_MATCH_ARM,\n-    MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n-    WILDCARD_IN_OR_PATTERNS,\n-    MATCH_SINGLE_BINDING,\n-    INFALLIBLE_DESTRUCTURING_MATCH,\n-    REST_PAT_IN_FULLY_BOUND_STRUCTS,\n-    REDUNDANT_PATTERN_MATCHING,\n-    MATCH_LIKE_MATCHES_MACRO,\n-    MATCH_SAME_ARMS,\n-]);\n-\n-impl<'tcx> LateLintPass<'tcx> for Matches {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if expr.span.from_expansion() {\n-            return;\n-        }\n-\n-        redundant_pattern_match::check(cx, expr);\n-\n-        if meets_msrv(self.msrv.as_ref(), &msrvs::MATCHES_MACRO) {\n-            if !check_match_like_matches(cx, expr) {\n-                lint_match_arms(cx, expr);\n-            }\n-        } else {\n-            lint_match_arms(cx, expr);\n-        }\n-\n-        if let ExprKind::Match(ex, arms, MatchSource::Normal) = expr.kind {\n-            check_single_match(cx, ex, arms, expr);\n-            check_match_bool(cx, ex, arms, expr);\n-            check_overlapping_arms(cx, ex, arms);\n-            check_wild_err_arm(cx, ex, arms);\n-            check_wild_enum_match(cx, ex, arms);\n-            check_match_as_ref(cx, ex, arms, expr);\n-            check_wild_in_or_pats(cx, arms);\n-\n-            if self.infallible_destructuring_match_linted {\n-                self.infallible_destructuring_match_linted = false;\n-            } else {\n-                check_match_single_binding(cx, ex, arms, expr);\n-            }\n-        }\n-        if let ExprKind::Match(ex, arms, _) = expr.kind {\n-            check_match_ref_pats(cx, ex, arms.iter().map(|el| el.pat), expr);\n-        }\n-    }\n-\n-    fn check_local(&mut self, cx: &LateContext<'tcx>, local: &'tcx Local<'_>) {\n-        if_chain! {\n-            if !local.span.from_expansion();\n-            if let Some(expr) = local.init;\n-            if let ExprKind::Match(target, arms, MatchSource::Normal) = expr.kind;\n-            if arms.len() == 1 && arms[0].guard.is_none();\n-            if let PatKind::TupleStruct(\n-                QPath::Resolved(None, variant_name), args, _) = arms[0].pat.kind;\n-            if args.len() == 1;\n-            if let PatKind::Binding(_, arg, ..) = strip_pat_refs(&args[0]).kind;\n-            let body = peel_blocks(arms[0].body);\n-            if path_to_local_id(body, arg);\n-\n-            then {\n-                let mut applicability = Applicability::MachineApplicable;\n-                self.infallible_destructuring_match_linted = true;\n-                span_lint_and_sugg(\n-                    cx,\n-                    INFALLIBLE_DESTRUCTURING_MATCH,\n-                    local.span,\n-                    \"you seem to be trying to use `match` to destructure a single infallible pattern. \\\n-                    Consider using `let`\",\n-                    \"try this\",\n-                    format!(\n-                        \"let {}({}) = {};\",\n-                        snippet_with_applicability(cx, variant_name.span, \"..\", &mut applicability),\n-                        snippet_with_applicability(cx, local.pat.span, \"..\", &mut applicability),\n-                        snippet_with_applicability(cx, target.span, \"..\", &mut applicability),\n-                    ),\n-                    applicability,\n-                );\n-            }\n-        }\n-    }\n-\n-    fn check_pat(&mut self, cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) {\n-        if_chain! {\n-            if !pat.span.from_expansion();\n-            if let PatKind::Struct(QPath::Resolved(_, path), fields, true) = pat.kind;\n-            if let Some(def_id) = path.res.opt_def_id();\n-            let ty = cx.tcx.type_of(def_id);\n-            if let ty::Adt(def, _) = ty.kind();\n-            if def.is_struct() || def.is_union();\n-            if fields.len() == def.non_enum_variant().fields.len();\n-\n-            then {\n-                span_lint_and_help(\n-                    cx,\n-                    REST_PAT_IN_FULLY_BOUND_STRUCTS,\n-                    pat.span,\n-                    \"unnecessary use of `..` pattern in struct binding. All fields were already bound\",\n-                    None,\n-                    \"consider removing `..` from this binding\",\n-                );\n-            }\n-        }\n-    }\n-\n-    extract_msrv_attr!(LateContext);\n-}\n-\n-#[rustfmt::skip]\n-fn check_single_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n-    if arms.len() == 2 && arms[0].guard.is_none() && arms[1].guard.is_none() {\n-        if expr.span.from_expansion() {\n-            // Don't lint match expressions present in\n-            // macro_rules! block\n-            return;\n-        }\n-        if let PatKind::Or(..) = arms[0].pat.kind {\n-            // don't lint for or patterns for now, this makes\n-            // the lint noisy in unnecessary situations\n-            return;\n-        }\n-        let els = arms[1].body;\n-        let els = if is_unit_expr(peel_blocks(els)) {\n-            None\n-        } else if let ExprKind::Block(Block { stmts, expr: block_expr, .. }, _) = els.kind {\n-            if stmts.len() == 1 && block_expr.is_none() || stmts.is_empty() && block_expr.is_some() {\n-                // single statement/expr \"else\" block, don't lint\n-                return;\n-            }\n-            // block with 2+ statements or 1 expr and 1+ statement\n-            Some(els)\n-        } else {\n-            // not a block, don't lint\n-            return;\n-        };\n-\n-        let ty = cx.typeck_results().expr_ty(ex);\n-        if *ty.kind() != ty::Bool || is_lint_allowed(cx, MATCH_BOOL, ex.hir_id) {\n-            check_single_match_single_pattern(cx, ex, arms, expr, els);\n-            check_single_match_opt_like(cx, ex, arms, expr, ty, els);\n-        }\n-    }\n-}\n-\n-fn check_single_match_single_pattern(\n-    cx: &LateContext<'_>,\n-    ex: &Expr<'_>,\n-    arms: &[Arm<'_>],\n-    expr: &Expr<'_>,\n-    els: Option<&Expr<'_>>,\n-) {\n-    if is_wild(arms[1].pat) {\n-        report_single_match_single_pattern(cx, ex, arms, expr, els);\n-    }\n-}\n-\n-fn report_single_match_single_pattern(\n-    cx: &LateContext<'_>,\n-    ex: &Expr<'_>,\n-    arms: &[Arm<'_>],\n-    expr: &Expr<'_>,\n-    els: Option<&Expr<'_>>,\n-) {\n-    let lint = if els.is_some() { SINGLE_MATCH_ELSE } else { SINGLE_MATCH };\n-    let els_str = els.map_or(String::new(), |els| {\n-        format!(\" else {}\", expr_block(cx, els, None, \"..\", Some(expr.span)))\n-    });\n-\n-    let (pat, pat_ref_count) = peel_hir_pat_refs(arms[0].pat);\n-    let (msg, sugg) = if_chain! {\n-        if let PatKind::Path(_) | PatKind::Lit(_) = pat.kind;\n-        let (ty, ty_ref_count) = peel_mid_ty_refs(cx.typeck_results().expr_ty(ex));\n-        if let Some(spe_trait_id) = cx.tcx.lang_items().structural_peq_trait();\n-        if let Some(pe_trait_id) = cx.tcx.lang_items().eq_trait();\n-        if ty.is_integral() || ty.is_char() || ty.is_str()\n-            || (implements_trait(cx, ty, spe_trait_id, &[])\n-                && implements_trait(cx, ty, pe_trait_id, &[ty.into()]));\n-        then {\n-            // scrutinee derives PartialEq and the pattern is a constant.\n-            let pat_ref_count = match pat.kind {\n-                // string literals are already a reference.\n-                PatKind::Lit(Expr { kind: ExprKind::Lit(lit), .. }) if lit.node.is_str() => pat_ref_count + 1,\n-                _ => pat_ref_count,\n-            };\n-            // References are only implicitly added to the pattern, so no overflow here.\n-            // e.g. will work: match &Some(_) { Some(_) => () }\n-            // will not: match Some(_) { &Some(_) => () }\n-            let ref_count_diff = ty_ref_count - pat_ref_count;\n-\n-            // Try to remove address of expressions first.\n-            let (ex, removed) = peel_n_hir_expr_refs(ex, ref_count_diff);\n-            let ref_count_diff = ref_count_diff - removed;\n-\n-            let msg = \"you seem to be trying to use `match` for an equality check. Consider using `if`\";\n-            let sugg = format!(\n-                \"if {} == {}{} {}{}\",\n-                snippet(cx, ex.span, \"..\"),\n-                // PartialEq for different reference counts may not exist.\n-                \"&\".repeat(ref_count_diff),\n-                snippet(cx, arms[0].pat.span, \"..\"),\n-                expr_block(cx, arms[0].body, None, \"..\", Some(expr.span)),\n-                els_str,\n-            );\n-            (msg, sugg)\n-        } else {\n-            let msg = \"you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\";\n-            let sugg = format!(\n-                \"if let {} = {} {}{}\",\n-                snippet(cx, arms[0].pat.span, \"..\"),\n-                snippet(cx, ex.span, \"..\"),\n-                expr_block(cx, arms[0].body, None, \"..\", Some(expr.span)),\n-                els_str,\n-            );\n-            (msg, sugg)\n-        }\n-    };\n-\n-    span_lint_and_sugg(\n-        cx,\n-        lint,\n-        expr.span,\n-        msg,\n-        \"try this\",\n-        sugg,\n-        Applicability::HasPlaceholders,\n-    );\n-}\n-\n-fn check_single_match_opt_like<'a>(\n-    cx: &LateContext<'a>,\n-    ex: &Expr<'_>,\n-    arms: &[Arm<'_>],\n-    expr: &Expr<'_>,\n-    ty: Ty<'a>,\n-    els: Option<&Expr<'_>>,\n-) {\n-    // list of candidate `Enum`s we know will never get any more members\n-    let candidates = &[\n-        (&paths::COW, \"Borrowed\"),\n-        (&paths::COW, \"Cow::Borrowed\"),\n-        (&paths::COW, \"Cow::Owned\"),\n-        (&paths::COW, \"Owned\"),\n-        (&paths::OPTION, \"None\"),\n-        (&paths::RESULT, \"Err\"),\n-        (&paths::RESULT, \"Ok\"),\n-    ];\n-\n-    // We want to suggest to exclude an arm that contains only wildcards or forms the exhaustive\n-    // match with the second branch, without enum variants in matches.\n-    if !contains_only_wilds(arms[1].pat) && !form_exhaustive_matches(arms[0].pat, arms[1].pat) {\n-        return;\n-    }\n-\n-    let mut paths_and_types = Vec::new();\n-    if !collect_pat_paths(&mut paths_and_types, cx, arms[1].pat, ty) {\n-        return;\n-    }\n-\n-    let in_candidate_enum = |path_info: &(String, &TyS<'_>)| -> bool {\n-        let (path, ty) = path_info;\n-        for &(ty_path, pat_path) in candidates {\n-            if path == pat_path && match_type(cx, ty, ty_path) {\n-                return true;\n-            }\n-        }\n-        false\n-    };\n-    if paths_and_types.iter().all(in_candidate_enum) {\n-        report_single_match_single_pattern(cx, ex, arms, expr, els);\n-    }\n-}\n-\n-/// Collects paths and their types from the given patterns. Returns true if the given pattern could\n-/// be simplified, false otherwise.\n-fn collect_pat_paths<'a>(acc: &mut Vec<(String, Ty<'a>)>, cx: &LateContext<'a>, pat: &Pat<'_>, ty: Ty<'a>) -> bool {\n-    match pat.kind {\n-        PatKind::Wild => true,\n-        PatKind::Tuple(inner, _) => inner.iter().all(|p| {\n-            let p_ty = cx.typeck_results().pat_ty(p);\n-            collect_pat_paths(acc, cx, p, p_ty)\n-        }),\n-        PatKind::TupleStruct(ref path, ..) => {\n-            let path = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| {\n-                s.print_qpath(path, false);\n-            });\n-            acc.push((path, ty));\n-            true\n-        },\n-        PatKind::Binding(BindingAnnotation::Unannotated, .., ident, None) => {\n-            acc.push((ident.to_string(), ty));\n-            true\n-        },\n-        PatKind::Path(ref path) => {\n-            let path = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| {\n-                s.print_qpath(path, false);\n-            });\n-            acc.push((path, ty));\n-            true\n-        },\n-        _ => false,\n-    }\n-}\n-\n-/// Returns true if the given arm of pattern matching contains wildcard patterns.\n-fn contains_only_wilds(pat: &Pat<'_>) -> bool {\n-    match pat.kind {\n-        PatKind::Wild => true,\n-        PatKind::Tuple(inner, _) | PatKind::TupleStruct(_, inner, ..) => inner.iter().all(contains_only_wilds),\n-        _ => false,\n-    }\n-}\n-\n-/// Returns true if the given patterns forms only exhaustive matches that don't contain enum\n-/// patterns without a wildcard.\n-fn form_exhaustive_matches(left: &Pat<'_>, right: &Pat<'_>) -> bool {\n-    match (&left.kind, &right.kind) {\n-        (PatKind::Wild, _) | (_, PatKind::Wild) => true,\n-        (PatKind::Tuple(left_in, left_pos), PatKind::Tuple(right_in, right_pos)) => {\n-            // We don't actually know the position and the presence of the `..` (dotdot) operator\n-            // in the arms, so we need to evaluate the correct offsets here in order to iterate in\n-            // both arms at the same time.\n-            let len = max(\n-                left_in.len() + {\n-                    if left_pos.is_some() { 1 } else { 0 }\n-                },\n-                right_in.len() + {\n-                    if right_pos.is_some() { 1 } else { 0 }\n-                },\n-            );\n-            let mut left_pos = left_pos.unwrap_or(usize::MAX);\n-            let mut right_pos = right_pos.unwrap_or(usize::MAX);\n-            let mut left_dot_space = 0;\n-            let mut right_dot_space = 0;\n-            for i in 0..len {\n-                let mut found_dotdot = false;\n-                if i == left_pos {\n-                    left_dot_space += 1;\n-                    if left_dot_space < len - left_in.len() {\n-                        left_pos += 1;\n-                    }\n-                    found_dotdot = true;\n-                }\n-                if i == right_pos {\n-                    right_dot_space += 1;\n-                    if right_dot_space < len - right_in.len() {\n-                        right_pos += 1;\n-                    }\n-                    found_dotdot = true;\n-                }\n-                if found_dotdot {\n-                    continue;\n-                }\n-                if !contains_only_wilds(&left_in[i - left_dot_space])\n-                    && !contains_only_wilds(&right_in[i - right_dot_space])\n-                {\n-                    return false;\n-                }\n-            }\n-            true\n-        },\n-        _ => false,\n-    }\n-}\n-\n-fn check_match_bool(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n-    // Type of expression is `bool`.\n-    if *cx.typeck_results().expr_ty(ex).kind() == ty::Bool {\n-        span_lint_and_then(\n-            cx,\n-            MATCH_BOOL,\n-            expr.span,\n-            \"you seem to be trying to match on a boolean expression\",\n-            move |diag| {\n-                if arms.len() == 2 {\n-                    // no guards\n-                    let exprs = if let PatKind::Lit(arm_bool) = arms[0].pat.kind {\n-                        if let ExprKind::Lit(ref lit) = arm_bool.kind {\n-                            match lit.node {\n-                                LitKind::Bool(true) => Some((&*arms[0].body, &*arms[1].body)),\n-                                LitKind::Bool(false) => Some((&*arms[1].body, &*arms[0].body)),\n-                                _ => None,\n-                            }\n-                        } else {\n-                            None\n-                        }\n-                    } else {\n-                        None\n-                    };\n-\n-                    if let Some((true_expr, false_expr)) = exprs {\n-                        let sugg = match (is_unit_expr(true_expr), is_unit_expr(false_expr)) {\n-                            (false, false) => Some(format!(\n-                                \"if {} {} else {}\",\n-                                snippet(cx, ex.span, \"b\"),\n-                                expr_block(cx, true_expr, None, \"..\", Some(expr.span)),\n-                                expr_block(cx, false_expr, None, \"..\", Some(expr.span))\n-                            )),\n-                            (false, true) => Some(format!(\n-                                \"if {} {}\",\n-                                snippet(cx, ex.span, \"b\"),\n-                                expr_block(cx, true_expr, None, \"..\", Some(expr.span))\n-                            )),\n-                            (true, false) => {\n-                                let test = Sugg::hir(cx, ex, \"..\");\n-                                Some(format!(\n-                                    \"if {} {}\",\n-                                    !test,\n-                                    expr_block(cx, false_expr, None, \"..\", Some(expr.span))\n-                                ))\n-                            },\n-                            (true, true) => None,\n-                        };\n-\n-                        if let Some(sugg) = sugg {\n-                            diag.span_suggestion(\n-                                expr.span,\n-                                \"consider using an `if`/`else` expression\",\n-                                sugg,\n-                                Applicability::HasPlaceholders,\n-                            );\n-                        }\n-                    }\n-                }\n-            },\n-        );\n-    }\n-}\n-\n-fn check_overlapping_arms<'tcx>(cx: &LateContext<'tcx>, ex: &'tcx Expr<'_>, arms: &'tcx [Arm<'_>]) {\n-    if arms.len() >= 2 && cx.typeck_results().expr_ty(ex).is_integral() {\n-        let ranges = all_ranges(cx, arms, cx.typeck_results().expr_ty(ex));\n-        if !ranges.is_empty() {\n-            if let Some((start, end)) = overlapping(&ranges) {\n-                span_lint_and_note(\n-                    cx,\n-                    MATCH_OVERLAPPING_ARM,\n-                    start.span,\n-                    \"some ranges overlap\",\n-                    Some(end.span),\n-                    \"overlaps with this\",\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-fn check_wild_err_arm<'tcx>(cx: &LateContext<'tcx>, ex: &Expr<'tcx>, arms: &[Arm<'tcx>]) {\n-    let ex_ty = cx.typeck_results().expr_ty(ex).peel_refs();\n-    if is_type_diagnostic_item(cx, ex_ty, sym::Result) {\n-        for arm in arms {\n-            if let PatKind::TupleStruct(ref path, inner, _) = arm.pat.kind {\n-                let path_str = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_qpath(path, false));\n-                if path_str == \"Err\" {\n-                    let mut matching_wild = inner.iter().any(is_wild);\n-                    let mut ident_bind_name = kw::Underscore;\n-                    if !matching_wild {\n-                        // Looking for unused bindings (i.e.: `_e`)\n-                        for pat in inner.iter() {\n-                            if let PatKind::Binding(_, id, ident, None) = pat.kind {\n-                                if ident.as_str().starts_with('_') && !is_local_used(cx, arm.body, id) {\n-                                    ident_bind_name = ident.name;\n-                                    matching_wild = true;\n-                                }\n-                            }\n-                        }\n-                    }\n-                    if_chain! {\n-                        if matching_wild;\n-                        if let Some(macro_call) = root_macro_call(peel_blocks_with_stmt(arm.body).span);\n-                        if is_panic(cx, macro_call.def_id);\n-                        then {\n-                            // `Err(_)` or `Err(_e)` arm with `panic!` found\n-                            span_lint_and_note(cx,\n-                                MATCH_WILD_ERR_ARM,\n-                                arm.pat.span,\n-                                &format!(\"`Err({})` matches all errors\", ident_bind_name),\n-                                None,\n-                                \"match each error separately or use the error output, or use `.except(msg)` if the error case is unreachable\",\n-                            );\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-enum CommonPrefixSearcher<'a> {\n-    None,\n-    Path(&'a [PathSegment<'a>]),\n-    Mixed,\n-}\n-impl<'a> CommonPrefixSearcher<'a> {\n-    fn with_path(&mut self, path: &'a [PathSegment<'a>]) {\n-        match path {\n-            [path @ .., _] => self.with_prefix(path),\n-            [] => (),\n-        }\n-    }\n-\n-    fn with_prefix(&mut self, path: &'a [PathSegment<'a>]) {\n-        match self {\n-            Self::None => *self = Self::Path(path),\n-            Self::Path(self_path)\n-                if path\n-                    .iter()\n-                    .map(|p| p.ident.name)\n-                    .eq(self_path.iter().map(|p| p.ident.name)) => {},\n-            Self::Path(_) => *self = Self::Mixed,\n-            Self::Mixed => (),\n-        }\n-    }\n-}\n-\n-fn is_hidden(cx: &LateContext<'_>, variant_def: &VariantDef) -> bool {\n-    let attrs = cx.tcx.get_attrs(variant_def.def_id);\n-    clippy_utils::attrs::is_doc_hidden(attrs) || clippy_utils::attrs::is_unstable(attrs)\n-}\n-\n-#[allow(clippy::too_many_lines)]\n-fn check_wild_enum_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n-    let ty = cx.typeck_results().expr_ty(ex).peel_refs();\n-    let adt_def = match ty.kind() {\n-        ty::Adt(adt_def, _)\n-            if adt_def.is_enum()\n-                && !(is_type_diagnostic_item(cx, ty, sym::Option) || is_type_diagnostic_item(cx, ty, sym::Result)) =>\n-        {\n-            adt_def\n-        },\n-        _ => return,\n-    };\n-\n-    // First pass - check for violation, but don't do much book-keeping because this is hopefully\n-    // the uncommon case, and the book-keeping is slightly expensive.\n-    let mut wildcard_span = None;\n-    let mut wildcard_ident = None;\n-    let mut has_non_wild = false;\n-    for arm in arms {\n-        match peel_hir_pat_refs(arm.pat).0.kind {\n-            PatKind::Wild => wildcard_span = Some(arm.pat.span),\n-            PatKind::Binding(_, _, ident, None) => {\n-                wildcard_span = Some(arm.pat.span);\n-                wildcard_ident = Some(ident);\n-            },\n-            _ => has_non_wild = true,\n-        }\n-    }\n-    let wildcard_span = match wildcard_span {\n-        Some(x) if has_non_wild => x,\n-        _ => return,\n-    };\n-\n-    // Accumulate the variants which should be put in place of the wildcard because they're not\n-    // already covered.\n-    let has_hidden = adt_def.variants.iter().any(|x| is_hidden(cx, x));\n-    let mut missing_variants: Vec<_> = adt_def.variants.iter().filter(|x| !is_hidden(cx, x)).collect();\n-\n-    let mut path_prefix = CommonPrefixSearcher::None;\n-    for arm in arms {\n-        // Guards mean that this case probably isn't exhaustively covered. Technically\n-        // this is incorrect, as we should really check whether each variant is exhaustively\n-        // covered by the set of guards that cover it, but that's really hard to do.\n-        recurse_or_patterns(arm.pat, |pat| {\n-            let path = match &peel_hir_pat_refs(pat).0.kind {\n-                PatKind::Path(path) => {\n-                    #[allow(clippy::match_same_arms)]\n-                    let id = match cx.qpath_res(path, pat.hir_id) {\n-                        Res::Def(\n-                            DefKind::Const | DefKind::ConstParam | DefKind::AnonConst | DefKind::InlineConst,\n-                            _,\n-                        ) => return,\n-                        Res::Def(_, id) => id,\n-                        _ => return,\n-                    };\n-                    if arm.guard.is_none() {\n-                        missing_variants.retain(|e| e.ctor_def_id != Some(id));\n-                    }\n-                    path\n-                },\n-                PatKind::TupleStruct(path, patterns, ..) => {\n-                    if let Some(id) = cx.qpath_res(path, pat.hir_id).opt_def_id() {\n-                        if arm.guard.is_none() && patterns.iter().all(|p| !is_refutable(cx, p)) {\n-                            missing_variants.retain(|e| e.ctor_def_id != Some(id));\n-                        }\n-                    }\n-                    path\n-                },\n-                PatKind::Struct(path, patterns, ..) => {\n-                    if let Some(id) = cx.qpath_res(path, pat.hir_id).opt_def_id() {\n-                        if arm.guard.is_none() && patterns.iter().all(|p| !is_refutable(cx, p.pat)) {\n-                            missing_variants.retain(|e| e.def_id != id);\n-                        }\n-                    }\n-                    path\n-                },\n-                _ => return,\n-            };\n-            match path {\n-                QPath::Resolved(_, path) => path_prefix.with_path(path.segments),\n-                QPath::TypeRelative(\n-                    hir::Ty {\n-                        kind: TyKind::Path(QPath::Resolved(_, path)),\n-                        ..\n-                    },\n-                    _,\n-                ) => path_prefix.with_prefix(path.segments),\n-                _ => (),\n-            }\n-        });\n-    }\n-\n-    let format_suggestion = |variant: &VariantDef| {\n-        format!(\n-            \"{}{}{}{}\",\n-            if let Some(ident) = wildcard_ident {\n-                format!(\"{} @ \", ident.name)\n-            } else {\n-                String::new()\n-            },\n-            if let CommonPrefixSearcher::Path(path_prefix) = path_prefix {\n-                let mut s = String::new();\n-                for seg in path_prefix {\n-                    s.push_str(seg.ident.as_str());\n-                    s.push_str(\"::\");\n-                }\n-                s\n-            } else {\n-                let mut s = cx.tcx.def_path_str(adt_def.did);\n-                s.push_str(\"::\");\n-                s\n-            },\n-            variant.name,\n-            match variant.ctor_kind {\n-                CtorKind::Fn if variant.fields.len() == 1 => \"(_)\",\n-                CtorKind::Fn => \"(..)\",\n-                CtorKind::Const => \"\",\n-                CtorKind::Fictive => \"{ .. }\",\n-            }\n-        )\n-    };\n-\n-    match missing_variants.as_slice() {\n-        [] => (),\n-        [x] if !adt_def.is_variant_list_non_exhaustive() && !has_hidden => span_lint_and_sugg(\n-            cx,\n-            MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n-            wildcard_span,\n-            \"wildcard matches only a single variant and will also match any future added variants\",\n-            \"try this\",\n-            format_suggestion(x),\n-            Applicability::MaybeIncorrect,\n-        ),\n-        variants => {\n-            let mut suggestions: Vec<_> = variants.iter().copied().map(format_suggestion).collect();\n-            let message = if adt_def.is_variant_list_non_exhaustive() || has_hidden {\n-                suggestions.push(\"_\".into());\n-                \"wildcard matches known variants and will also match future added variants\"\n-            } else {\n-                \"wildcard match will also match any future added variants\"\n-            };\n-\n-            span_lint_and_sugg(\n-                cx,\n-                WILDCARD_ENUM_MATCH_ARM,\n-                wildcard_span,\n-                message,\n-                \"try this\",\n-                suggestions.join(\" | \"),\n-                Applicability::MaybeIncorrect,\n-            );\n-        },\n-    };\n-}\n-\n-fn check_match_ref_pats<'a, 'b, I>(cx: &LateContext<'_>, ex: &Expr<'_>, pats: I, expr: &Expr<'_>)\n-where\n-    'b: 'a,\n-    I: Clone + Iterator<Item = &'a Pat<'b>>,\n-{\n-    if !has_multiple_ref_pats(pats.clone()) {\n-        return;\n-    }\n-\n-    let (first_sugg, msg, title);\n-    let span = ex.span.source_callsite();\n-    if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, inner) = ex.kind {\n-        first_sugg = once((span, Sugg::hir_with_macro_callsite(cx, inner, \"..\").to_string()));\n-        msg = \"try\";\n-        title = \"you don't need to add `&` to both the expression and the patterns\";\n-    } else {\n-        first_sugg = once((span, Sugg::hir_with_macro_callsite(cx, ex, \"..\").deref().to_string()));\n-        msg = \"instead of prefixing all patterns with `&`, you can dereference the expression\";\n-        title = \"you don't need to add `&` to all patterns\";\n-    }\n-\n-    let remaining_suggs = pats.filter_map(|pat| {\n-        if let PatKind::Ref(refp, _) = pat.kind {\n-            Some((pat.span, snippet(cx, refp.span, \"..\").to_string()))\n-        } else {\n-            None\n-        }\n-    });\n-\n-    span_lint_and_then(cx, MATCH_REF_PATS, expr.span, title, |diag| {\n-        if !expr.span.from_expansion() {\n-            multispan_sugg(diag, msg, first_sugg.chain(remaining_suggs));\n-        }\n-    });\n-}\n-\n-fn check_match_as_ref(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n-    if arms.len() == 2 && arms[0].guard.is_none() && arms[1].guard.is_none() {\n-        let arm_ref: Option<BindingAnnotation> = if is_none_arm(cx, &arms[0]) {\n-            is_ref_some_arm(cx, &arms[1])\n-        } else if is_none_arm(cx, &arms[1]) {\n-            is_ref_some_arm(cx, &arms[0])\n-        } else {\n-            None\n-        };\n-        if let Some(rb) = arm_ref {\n-            let suggestion = if rb == BindingAnnotation::Ref {\n-                \"as_ref\"\n-            } else {\n-                \"as_mut\"\n-            };\n-\n-            let output_ty = cx.typeck_results().expr_ty(expr);\n-            let input_ty = cx.typeck_results().expr_ty(ex);\n-\n-            let cast = if_chain! {\n-                if let ty::Adt(_, substs) = input_ty.kind();\n-                let input_ty = substs.type_at(0);\n-                if let ty::Adt(_, substs) = output_ty.kind();\n-                let output_ty = substs.type_at(0);\n-                if let ty::Ref(_, output_ty, _) = *output_ty.kind();\n-                if input_ty != output_ty;\n-                then {\n-                    \".map(|x| x as _)\"\n-                } else {\n-                    \"\"\n-                }\n-            };\n-\n-            let mut applicability = Applicability::MachineApplicable;\n-            span_lint_and_sugg(\n-                cx,\n-                MATCH_AS_REF,\n-                expr.span,\n-                &format!(\"use `{}()` instead\", suggestion),\n-                \"try this\",\n-                format!(\n-                    \"{}.{}(){}\",\n-                    snippet_with_applicability(cx, ex.span, \"_\", &mut applicability),\n-                    suggestion,\n-                    cast,\n-                ),\n-                applicability,\n-            );\n-        }\n-    }\n-}\n-\n-fn check_wild_in_or_pats(cx: &LateContext<'_>, arms: &[Arm<'_>]) {\n-    for arm in arms {\n-        if let PatKind::Or(fields) = arm.pat.kind {\n-            // look for multiple fields in this arm that contains at least one Wild pattern\n-            if fields.len() > 1 && fields.iter().any(is_wild) {\n-                span_lint_and_help(\n-                    cx,\n-                    WILDCARD_IN_OR_PATTERNS,\n-                    arm.pat.span,\n-                    \"wildcard pattern covers any other pattern as it will match anyway\",\n-                    None,\n-                    \"consider handling `_` separately\",\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-/// Lint a `match` or `if let .. { .. } else { .. }` expr that could be replaced by `matches!`\n-fn check_match_like_matches<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n-    if let Some(higher::IfLet {\n-        let_pat,\n-        let_expr,\n-        if_then,\n-        if_else: Some(if_else),\n-    }) = higher::IfLet::hir(cx, expr)\n-    {\n-        return find_matches_sugg(\n-            cx,\n-            let_expr,\n-            IntoIterator::into_iter([(&[][..], Some(let_pat), if_then, None), (&[][..], None, if_else, None)]),\n-            expr,\n-            true,\n-        );\n-    }\n-\n-    if let ExprKind::Match(scrut, arms, MatchSource::Normal) = expr.kind {\n-        return find_matches_sugg(\n-            cx,\n-            scrut,\n-            arms.iter().map(|arm| {\n-                (\n-                    cx.tcx.hir().attrs(arm.hir_id),\n-                    Some(arm.pat),\n-                    arm.body,\n-                    arm.guard.as_ref(),\n-                )\n-            }),\n-            expr,\n-            false,\n-        );\n-    }\n-\n-    false\n-}\n-\n-/// Lint a `match` or `if let` for replacement by `matches!`\n-fn find_matches_sugg<'a, 'b, I>(\n-    cx: &LateContext<'_>,\n-    ex: &Expr<'_>,\n-    mut iter: I,\n-    expr: &Expr<'_>,\n-    is_if_let: bool,\n-) -> bool\n-where\n-    'b: 'a,\n-    I: Clone\n-        + DoubleEndedIterator\n-        + ExactSizeIterator\n-        + Iterator<\n-            Item = (\n-                &'a [Attribute],\n-                Option<&'a Pat<'b>>,\n-                &'a Expr<'b>,\n-                Option<&'a Guard<'b>>,\n-            ),\n-        >,\n-{\n-    if_chain! {\n-        if iter.len() >= 2;\n-        if cx.typeck_results().expr_ty(expr).is_bool();\n-        if let Some((_, last_pat_opt, last_expr, _)) = iter.next_back();\n-        let iter_without_last = iter.clone();\n-        if let Some((first_attrs, _, first_expr, first_guard)) = iter.next();\n-        if let Some(b0) = find_bool_lit(&first_expr.kind, is_if_let);\n-        if let Some(b1) = find_bool_lit(&last_expr.kind, is_if_let);\n-        if b0 != b1;\n-        if first_guard.is_none() || iter.len() == 0;\n-        if first_attrs.is_empty();\n-        if iter\n-            .all(|arm| {\n-                find_bool_lit(&arm.2.kind, is_if_let).map_or(false, |b| b == b0) && arm.3.is_none() && arm.0.is_empty()\n-            });\n-        then {\n-            if let Some(last_pat) = last_pat_opt {\n-                if !is_wild(last_pat) {\n-                    return false;\n-                }\n-            }\n-\n-            // The suggestion may be incorrect, because some arms can have `cfg` attributes\n-            // evaluated into `false` and so such arms will be stripped before.\n-            let mut applicability = Applicability::MaybeIncorrect;\n-            let pat = {\n-                use itertools::Itertools as _;\n-                iter_without_last\n-                    .filter_map(|arm| {\n-                        let pat_span = arm.1?.span;\n-                        Some(snippet_with_applicability(cx, pat_span, \"..\", &mut applicability))\n-                    })\n-                    .join(\" | \")\n-            };\n-            let pat_and_guard = if let Some(Guard::If(g)) = first_guard {\n-                format!(\"{} if {}\", pat, snippet_with_applicability(cx, g.span, \"..\", &mut applicability))\n-            } else {\n-                pat\n-            };\n-\n-            // strip potential borrows (#6503), but only if the type is a reference\n-            let mut ex_new = ex;\n-            if let ExprKind::AddrOf(BorrowKind::Ref, .., ex_inner) = ex.kind {\n-                if let ty::Ref(..) = cx.typeck_results().expr_ty(ex_inner).kind() {\n-                    ex_new = ex_inner;\n-                }\n-            };\n-            span_lint_and_sugg(\n-                cx,\n-                MATCH_LIKE_MATCHES_MACRO,\n-                expr.span,\n-                &format!(\"{} expression looks like `matches!` macro\", if is_if_let { \"if let .. else\" } else { \"match\" }),\n-                \"try this\",\n-                format!(\n-                    \"{}matches!({}, {})\",\n-                    if b0 { \"\" } else { \"!\" },\n-                    snippet_with_applicability(cx, ex_new.span, \"..\", &mut applicability),\n-                    pat_and_guard,\n-                ),\n-                applicability,\n-            );\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-}\n-\n-/// Extract a `bool` or `{ bool }`\n-fn find_bool_lit(ex: &ExprKind<'_>, is_if_let: bool) -> Option<bool> {\n-    match ex {\n-        ExprKind::Lit(Spanned {\n-            node: LitKind::Bool(b), ..\n-        }) => Some(*b),\n-        ExprKind::Block(\n-            rustc_hir::Block {\n-                stmts: &[],\n-                expr: Some(exp),\n-                ..\n-            },\n-            _,\n-        ) if is_if_let => {\n-            if let ExprKind::Lit(Spanned {\n-                node: LitKind::Bool(b), ..\n-            }) = exp.kind\n-            {\n-                Some(b)\n-            } else {\n-                None\n-            }\n-        },\n-        _ => None,\n-    }\n-}\n-\n-#[allow(clippy::too_many_lines)]\n-fn check_match_single_binding<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n-    if expr.span.from_expansion() || arms.len() != 1 || is_refutable(cx, arms[0].pat) {\n-        return;\n-    }\n-\n-    // HACK:\n-    // This is a hack to deal with arms that are excluded by macros like `#[cfg]`. It is only used here\n-    // to prevent false positives as there is currently no better way to detect if code was excluded by\n-    // a macro. See PR #6435\n-    if_chain! {\n-        if let Some(match_snippet) = snippet_opt(cx, expr.span);\n-        if let Some(arm_snippet) = snippet_opt(cx, arms[0].span);\n-        if let Some(ex_snippet) = snippet_opt(cx, ex.span);\n-        let rest_snippet = match_snippet.replace(&arm_snippet, \"\").replace(&ex_snippet, \"\");\n-        if rest_snippet.contains(\"=>\");\n-        then {\n-            // The code it self contains another thick arrow \"=>\"\n-            // -> Either another arm or a comment\n-            return;\n-        }\n-    }\n-\n-    let matched_vars = ex.span;\n-    let bind_names = arms[0].pat.span;\n-    let match_body = peel_blocks(arms[0].body);\n-    let mut snippet_body = if match_body.span.from_expansion() {\n-        Sugg::hir_with_macro_callsite(cx, match_body, \"..\").to_string()\n-    } else {\n-        snippet_block(cx, match_body.span, \"..\", Some(expr.span)).to_string()\n-    };\n-\n-    // Do we need to add ';' to suggestion ?\n-    match match_body.kind {\n-        ExprKind::Block(block, _) => {\n-            // macro + expr_ty(body) == ()\n-            if block.span.from_expansion() && cx.typeck_results().expr_ty(match_body).is_unit() {\n-                snippet_body.push(';');\n-            }\n-        },\n-        _ => {\n-            // expr_ty(body) == ()\n-            if cx.typeck_results().expr_ty(match_body).is_unit() {\n-                snippet_body.push(';');\n-            }\n-        },\n-    }\n-\n-    let mut applicability = Applicability::MaybeIncorrect;\n-    match arms[0].pat.kind {\n-        PatKind::Binding(..) | PatKind::Tuple(_, _) | PatKind::Struct(..) => {\n-            // If this match is in a local (`let`) stmt\n-            let (target_span, sugg) = if let Some(parent_let_node) = opt_parent_let(cx, ex) {\n-                (\n-                    parent_let_node.span,\n-                    format!(\n-                        \"let {} = {};\\n{}let {} = {};\",\n-                        snippet_with_applicability(cx, bind_names, \"..\", &mut applicability),\n-                        snippet_with_applicability(cx, matched_vars, \"..\", &mut applicability),\n-                        \" \".repeat(indent_of(cx, expr.span).unwrap_or(0)),\n-                        snippet_with_applicability(cx, parent_let_node.pat.span, \"..\", &mut applicability),\n-                        snippet_body\n-                    ),\n-                )\n-            } else {\n-                // If we are in closure, we need curly braces around suggestion\n-                let mut indent = \" \".repeat(indent_of(cx, ex.span).unwrap_or(0));\n-                let (mut cbrace_start, mut cbrace_end) = (\"\".to_string(), \"\".to_string());\n-                if let Some(parent_expr) = get_parent_expr(cx, expr) {\n-                    if let ExprKind::Closure(..) = parent_expr.kind {\n-                        cbrace_end = format!(\"\\n{}}}\", indent);\n-                        // Fix body indent due to the closure\n-                        indent = \" \".repeat(indent_of(cx, bind_names).unwrap_or(0));\n-                        cbrace_start = format!(\"{{\\n{}\", indent);\n-                    }\n-                }\n-                // If the parent is already an arm, and the body is another match statement,\n-                // we need curly braces around suggestion\n-                let parent_node_id = cx.tcx.hir().get_parent_node(expr.hir_id);\n-                if let Node::Arm(arm) = &cx.tcx.hir().get(parent_node_id) {\n-                    if let ExprKind::Match(..) = arm.body.kind {\n-                        cbrace_end = format!(\"\\n{}}}\", indent);\n-                        // Fix body indent due to the match\n-                        indent = \" \".repeat(indent_of(cx, bind_names).unwrap_or(0));\n-                        cbrace_start = format!(\"{{\\n{}\", indent);\n-                    }\n-                }\n-                (\n-                    expr.span,\n-                    format!(\n-                        \"{}let {} = {};\\n{}{}{}\",\n-                        cbrace_start,\n-                        snippet_with_applicability(cx, bind_names, \"..\", &mut applicability),\n-                        snippet_with_applicability(cx, matched_vars, \"..\", &mut applicability),\n-                        indent,\n-                        snippet_body,\n-                        cbrace_end\n-                    ),\n-                )\n-            };\n-            span_lint_and_sugg(\n-                cx,\n-                MATCH_SINGLE_BINDING,\n-                target_span,\n-                \"this match could be written as a `let` statement\",\n-                \"consider using `let` statement\",\n-                sugg,\n-                applicability,\n-            );\n-        },\n-        PatKind::Wild => {\n-            if ex.can_have_side_effects() {\n-                let indent = \" \".repeat(indent_of(cx, expr.span).unwrap_or(0));\n-                let sugg = format!(\n-                    \"{};\\n{}{}\",\n-                    snippet_with_applicability(cx, ex.span, \"..\", &mut applicability),\n-                    indent,\n-                    snippet_body\n-                );\n-                span_lint_and_sugg(\n-                    cx,\n-                    MATCH_SINGLE_BINDING,\n-                    expr.span,\n-                    \"this match could be replaced by its scrutinee and body\",\n-                    \"consider using the scrutinee and body instead\",\n-                    sugg,\n-                    applicability,\n-                );\n-            } else {\n-                span_lint_and_sugg(\n-                    cx,\n-                    MATCH_SINGLE_BINDING,\n-                    expr.span,\n-                    \"this match could be replaced by its body itself\",\n-                    \"consider using the match body instead\",\n-                    snippet_body,\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        },\n-        _ => (),\n-    }\n-}\n-\n-/// Returns true if the `ex` match expression is in a local (`let`) statement\n-fn opt_parent_let<'a>(cx: &LateContext<'a>, ex: &Expr<'a>) -> Option<&'a Local<'a>> {\n-    let map = &cx.tcx.hir();\n-    if_chain! {\n-        if let Some(Node::Expr(parent_arm_expr)) = map.find(map.get_parent_node(ex.hir_id));\n-        if let Some(Node::Local(parent_let_expr)) = map.find(map.get_parent_node(parent_arm_expr.hir_id));\n-        then {\n-            return Some(parent_let_expr);\n-        }\n-    }\n-    None\n-}\n-\n-/// Gets the ranges for each range pattern arm. Applies `ty` bounds for open ranges.\n-fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>) -> Vec<SpannedRange<FullInt>> {\n-    arms.iter()\n-        .filter_map(|arm| {\n-            if let Arm { pat, guard: None, .. } = *arm {\n-                if let PatKind::Range(ref lhs, ref rhs, range_end) = pat.kind {\n-                    let lhs_const = match lhs {\n-                        Some(lhs) => constant(cx, cx.typeck_results(), lhs)?.0,\n-                        None => miri_to_const(ty.numeric_min_val(cx.tcx)?)?,\n-                    };\n-                    let rhs_const = match rhs {\n-                        Some(rhs) => constant(cx, cx.typeck_results(), rhs)?.0,\n-                        None => miri_to_const(ty.numeric_max_val(cx.tcx)?)?,\n-                    };\n-\n-                    let lhs_val = lhs_const.int_value(cx, ty)?;\n-                    let rhs_val = rhs_const.int_value(cx, ty)?;\n-\n-                    let rhs_bound = match range_end {\n-                        RangeEnd::Included => EndBound::Included(rhs_val),\n-                        RangeEnd::Excluded => EndBound::Excluded(rhs_val),\n-                    };\n-                    return Some(SpannedRange {\n-                        span: pat.span,\n-                        node: (lhs_val, rhs_bound),\n-                    });\n-                }\n-\n-                if let PatKind::Lit(value) = pat.kind {\n-                    let value = constant_full_int(cx, cx.typeck_results(), value)?;\n-                    return Some(SpannedRange {\n-                        span: pat.span,\n-                        node: (value, EndBound::Included(value)),\n-                    });\n-                }\n-            }\n-            None\n-        })\n-        .collect()\n-}\n-\n-#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n-pub enum EndBound<T> {\n-    Included(T),\n-    Excluded(T),\n-}\n-\n-#[derive(Debug, Eq, PartialEq)]\n-struct SpannedRange<T> {\n-    pub span: Span,\n-    pub node: (T, EndBound<T>),\n-}\n-\n-// Checks if arm has the form `None => None`\n-fn is_none_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n-    matches!(arm.pat.kind, PatKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone))\n-}\n-\n-// Checks if arm has the form `Some(ref v) => Some(v)` (checks for `ref` and `ref mut`)\n-fn is_ref_some_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> Option<BindingAnnotation> {\n-    if_chain! {\n-        if let PatKind::TupleStruct(ref qpath, [first_pat, ..], _) = arm.pat.kind;\n-        if is_lang_ctor(cx, qpath, OptionSome);\n-        if let PatKind::Binding(rb, .., ident, _) = first_pat.kind;\n-        if rb == BindingAnnotation::Ref || rb == BindingAnnotation::RefMut;\n-        if let ExprKind::Call(e, args) = peel_blocks(arm.body).kind;\n-        if let ExprKind::Path(ref some_path) = e.kind;\n-        if is_lang_ctor(cx, some_path, OptionSome) && args.len() == 1;\n-        if let ExprKind::Path(QPath::Resolved(_, path2)) = args[0].kind;\n-        if path2.segments.len() == 1 && ident.name == path2.segments[0].ident.name;\n-        then {\n-            return Some(rb)\n-        }\n-    }\n-    None\n-}\n-\n-fn has_multiple_ref_pats<'a, 'b, I>(pats: I) -> bool\n-where\n-    'b: 'a,\n-    I: Iterator<Item = &'a Pat<'b>>,\n-{\n-    let mut ref_count = 0;\n-    for opt in pats.map(|pat| match pat.kind {\n-        PatKind::Ref(..) => Some(true), // &-patterns\n-        PatKind::Wild => Some(false),   // an \"anything\" wildcard is also fine\n-        _ => None,                      // any other pattern is not fine\n-    }) {\n-        if let Some(inner) = opt {\n-            if inner {\n-                ref_count += 1;\n-            }\n-        } else {\n-            return false;\n-        }\n-    }\n-    ref_count > 1\n-}\n-\n-fn overlapping<T>(ranges: &[SpannedRange<T>]) -> Option<(&SpannedRange<T>, &SpannedRange<T>)>\n-where\n-    T: Copy + Ord,\n-{\n-    #[derive(Copy, Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]\n-    enum BoundKind {\n-        EndExcluded,\n-        Start,\n-        EndIncluded,\n-    }\n-\n-    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-    struct RangeBound<'a, T>(T, BoundKind, &'a SpannedRange<T>);\n-\n-    impl<'a, T: Copy + Ord> PartialOrd for RangeBound<'a, T> {\n-        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-            Some(self.cmp(other))\n-        }\n-    }\n-\n-    impl<'a, T: Copy + Ord> Ord for RangeBound<'a, T> {\n-        fn cmp(&self, RangeBound(other_value, other_kind, _): &Self) -> Ordering {\n-            let RangeBound(self_value, self_kind, _) = *self;\n-            (self_value, self_kind).cmp(&(*other_value, *other_kind))\n-        }\n-    }\n-\n-    let mut values = Vec::with_capacity(2 * ranges.len());\n-\n-    for r @ SpannedRange { node: (start, end), .. } in ranges {\n-        values.push(RangeBound(*start, BoundKind::Start, r));\n-        values.push(match end {\n-            EndBound::Excluded(val) => RangeBound(*val, BoundKind::EndExcluded, r),\n-            EndBound::Included(val) => RangeBound(*val, BoundKind::EndIncluded, r),\n-        });\n-    }\n-\n-    values.sort();\n-\n-    let mut started = vec![];\n-\n-    for RangeBound(_, kind, range) in values {\n-        match kind {\n-            BoundKind::Start => started.push(range),\n-            BoundKind::EndExcluded | BoundKind::EndIncluded => {\n-                let mut overlap = None;\n-\n-                while let Some(last_started) = started.pop() {\n-                    if last_started == range {\n-                        break;\n-                    }\n-                    overlap = Some(last_started);\n-                }\n-\n-                if let Some(first_overlapping) = overlap {\n-                    return Some((range, first_overlapping));\n-                }\n-            },\n-        }\n-    }\n-\n-    None\n-}\n-\n-mod redundant_pattern_match {\n-    use super::REDUNDANT_PATTERN_MATCHING;\n-    use clippy_utils::diagnostics::span_lint_and_then;\n-    use clippy_utils::higher;\n-    use clippy_utils::source::snippet;\n-    use clippy_utils::sugg::Sugg;\n-    use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, is_type_lang_item, match_type};\n-    use clippy_utils::{is_lang_ctor, is_qpath_def_path, is_trait_method, paths};\n-    use if_chain::if_chain;\n-    use rustc_ast::ast::LitKind;\n-    use rustc_data_structures::fx::FxHashSet;\n-    use rustc_errors::Applicability;\n-    use rustc_hir::LangItem::{OptionNone, OptionSome, PollPending, PollReady, ResultErr, ResultOk};\n-    use rustc_hir::{\n-        intravisit::{walk_expr, Visitor},\n-        Arm, Block, Expr, ExprKind, LangItem, MatchSource, Node, Pat, PatKind, QPath, UnOp,\n-    };\n-    use rustc_lint::LateContext;\n-    use rustc_middle::ty::{self, subst::GenericArgKind, Ty};\n-    use rustc_span::sym;\n-\n-    pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let Some(higher::IfLet {\n-            if_else,\n-            let_pat,\n-            let_expr,\n-            ..\n-        }) = higher::IfLet::hir(cx, expr)\n-        {\n-            find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"if\", if_else.is_some());\n-        }\n-        if let ExprKind::Match(op, arms, MatchSource::Normal) = &expr.kind {\n-            find_sugg_for_match(cx, expr, op, arms);\n-        }\n-        if let Some(higher::WhileLet { let_pat, let_expr, .. }) = higher::WhileLet::hir(expr) {\n-            find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"while\", false);\n-        }\n-    }\n-\n-    /// Checks if the drop order for a type matters. Some std types implement drop solely to\n-    /// deallocate memory. For these types, and composites containing them, changing the drop order\n-    /// won't result in any observable side effects.\n-    fn type_needs_ordered_drop<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n-        type_needs_ordered_drop_inner(cx, ty, &mut FxHashSet::default())\n-    }\n-\n-    fn type_needs_ordered_drop_inner<'tcx>(\n-        cx: &LateContext<'tcx>,\n-        ty: Ty<'tcx>,\n-        seen: &mut FxHashSet<Ty<'tcx>>,\n-    ) -> bool {\n-        if !seen.insert(ty) {\n-            return false;\n-        }\n-        if !ty.needs_drop(cx.tcx, cx.param_env) {\n-            false\n-        } else if !cx\n-            .tcx\n-            .lang_items()\n-            .drop_trait()\n-            .map_or(false, |id| implements_trait(cx, ty, id, &[]))\n-        {\n-            // This type doesn't implement drop, so no side effects here.\n-            // Check if any component type has any.\n-            match ty.kind() {\n-                ty::Tuple(_) => ty.tuple_fields().any(|ty| type_needs_ordered_drop_inner(cx, ty, seen)),\n-                ty::Array(ty, _) => type_needs_ordered_drop_inner(cx, ty, seen),\n-                ty::Adt(adt, subs) => adt\n-                    .all_fields()\n-                    .map(|f| f.ty(cx.tcx, subs))\n-                    .any(|ty| type_needs_ordered_drop_inner(cx, ty, seen)),\n-                _ => true,\n-            }\n-        }\n-        // Check for std types which implement drop, but only for memory allocation.\n-        else if is_type_diagnostic_item(cx, ty, sym::Vec)\n-            || is_type_lang_item(cx, ty, LangItem::OwnedBox)\n-            || is_type_diagnostic_item(cx, ty, sym::Rc)\n-            || is_type_diagnostic_item(cx, ty, sym::Arc)\n-            || is_type_diagnostic_item(cx, ty, sym::cstring_type)\n-            || is_type_diagnostic_item(cx, ty, sym::BTreeMap)\n-            || is_type_diagnostic_item(cx, ty, sym::LinkedList)\n-            || match_type(cx, ty, &paths::WEAK_RC)\n-            || match_type(cx, ty, &paths::WEAK_ARC)\n-        {\n-            // Check all of the generic arguments.\n-            if let ty::Adt(_, subs) = ty.kind() {\n-                subs.types().any(|ty| type_needs_ordered_drop_inner(cx, ty, seen))\n-            } else {\n-                true\n-            }\n-        } else {\n-            true\n-        }\n-    }\n-\n-    // Extract the generic arguments out of a type\n-    fn try_get_generic_ty(ty: Ty<'_>, index: usize) -> Option<Ty<'_>> {\n-        if_chain! {\n-            if let ty::Adt(_, subs) = ty.kind();\n-            if let Some(sub) = subs.get(index);\n-            if let GenericArgKind::Type(sub_ty) = sub.unpack();\n-            then {\n-                Some(sub_ty)\n-            } else {\n-                None\n-            }\n-        }\n-    }\n-\n-    // Checks if there are any temporaries created in the given expression for which drop order\n-    // matters.\n-    fn temporaries_need_ordered_drop<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n-        struct V<'a, 'tcx> {\n-            cx: &'a LateContext<'tcx>,\n-            res: bool,\n-        }\n-        impl<'a, 'tcx> Visitor<'tcx> for V<'a, 'tcx> {\n-            fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-                match expr.kind {\n-                    // Taking the reference of a value leaves a temporary\n-                    // e.g. In `&String::new()` the string is a temporary value.\n-                    // Remaining fields are temporary values\n-                    // e.g. In `(String::new(), 0).1` the string is a temporary value.\n-                    ExprKind::AddrOf(_, _, expr) | ExprKind::Field(expr, _) => {\n-                        if !matches!(expr.kind, ExprKind::Path(_)) {\n-                            if type_needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(expr)) {\n-                                self.res = true;\n-                            } else {\n-                                self.visit_expr(expr);\n-                            }\n-                        }\n-                    },\n-                    // the base type is alway taken by reference.\n-                    // e.g. In `(vec![0])[0]` the vector is a temporary value.\n-                    ExprKind::Index(base, index) => {\n-                        if !matches!(base.kind, ExprKind::Path(_)) {\n-                            if type_needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(base)) {\n-                                self.res = true;\n-                            } else {\n-                                self.visit_expr(base);\n-                            }\n-                        }\n-                        self.visit_expr(index);\n-                    },\n-                    // Method calls can take self by reference.\n-                    // e.g. In `String::new().len()` the string is a temporary value.\n-                    ExprKind::MethodCall(_, [self_arg, args @ ..], _) => {\n-                        if !matches!(self_arg.kind, ExprKind::Path(_)) {\n-                            let self_by_ref = self\n-                                .cx\n-                                .typeck_results()\n-                                .type_dependent_def_id(expr.hir_id)\n-                                .map_or(false, |id| self.cx.tcx.fn_sig(id).skip_binder().inputs()[0].is_ref());\n-                            if self_by_ref\n-                                && type_needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(self_arg))\n-                            {\n-                                self.res = true;\n-                            } else {\n-                                self.visit_expr(self_arg);\n-                            }\n-                        }\n-                        args.iter().for_each(|arg| self.visit_expr(arg));\n-                    },\n-                    // Either explicitly drops values, or changes control flow.\n-                    ExprKind::DropTemps(_)\n-                    | ExprKind::Ret(_)\n-                    | ExprKind::Break(..)\n-                    | ExprKind::Yield(..)\n-                    | ExprKind::Block(Block { expr: None, .. }, _)\n-                    | ExprKind::Loop(..) => (),\n-\n-                    // Only consider the final expression.\n-                    ExprKind::Block(Block { expr: Some(expr), .. }, _) => self.visit_expr(expr),\n-\n-                    _ => walk_expr(self, expr),\n-                }\n-            }\n-        }\n-\n-        let mut v = V { cx, res: false };\n-        v.visit_expr(expr);\n-        v.res\n-    }\n-\n-    fn find_sugg_for_if_let<'tcx>(\n-        cx: &LateContext<'tcx>,\n-        expr: &'tcx Expr<'_>,\n-        let_pat: &Pat<'_>,\n-        let_expr: &'tcx Expr<'_>,\n-        keyword: &'static str,\n-        has_else: bool,\n-    ) {\n-        // also look inside refs\n-        let mut kind = &let_pat.kind;\n-        // if we have &None for example, peel it so we can detect \"if let None = x\"\n-        if let PatKind::Ref(inner, _mutability) = kind {\n-            kind = &inner.kind;\n-        }\n-        let op_ty = cx.typeck_results().expr_ty(let_expr);\n-        // Determine which function should be used, and the type contained by the corresponding\n-        // variant.\n-        let (good_method, inner_ty) = match kind {\n-            PatKind::TupleStruct(ref path, [sub_pat], _) => {\n-                if let PatKind::Wild = sub_pat.kind {\n-                    if is_lang_ctor(cx, path, ResultOk) {\n-                        (\"is_ok()\", try_get_generic_ty(op_ty, 0).unwrap_or(op_ty))\n-                    } else if is_lang_ctor(cx, path, ResultErr) {\n-                        (\"is_err()\", try_get_generic_ty(op_ty, 1).unwrap_or(op_ty))\n-                    } else if is_lang_ctor(cx, path, OptionSome) {\n-                        (\"is_some()\", op_ty)\n-                    } else if is_lang_ctor(cx, path, PollReady) {\n-                        (\"is_ready()\", op_ty)\n-                    } else if is_qpath_def_path(cx, path, sub_pat.hir_id, &paths::IPADDR_V4) {\n-                        (\"is_ipv4()\", op_ty)\n-                    } else if is_qpath_def_path(cx, path, sub_pat.hir_id, &paths::IPADDR_V6) {\n-                        (\"is_ipv6()\", op_ty)\n-                    } else {\n-                        return;\n-                    }\n-                } else {\n-                    return;\n-                }\n-            },\n-            PatKind::Path(ref path) => {\n-                let method = if is_lang_ctor(cx, path, OptionNone) {\n-                    \"is_none()\"\n-                } else if is_lang_ctor(cx, path, PollPending) {\n-                    \"is_pending()\"\n-                } else {\n-                    return;\n-                };\n-                // `None` and `Pending` don't have an inner type.\n-                (method, cx.tcx.types.unit)\n-            },\n-            _ => return,\n-        };\n-\n-        // If this is the last expression in a block or there is an else clause then the whole\n-        // type needs to be considered, not just the inner type of the branch being matched on.\n-        // Note the last expression in a block is dropped after all local bindings.\n-        let check_ty = if has_else\n-            || (keyword == \"if\" && matches!(cx.tcx.hir().parent_iter(expr.hir_id).next(), Some((_, Node::Block(..)))))\n-        {\n-            op_ty\n-        } else {\n-            inner_ty\n-        };\n-\n-        // All temporaries created in the scrutinee expression are dropped at the same time as the\n-        // scrutinee would be, so they have to be considered as well.\n-        // e.g. in `if let Some(x) = foo.lock().unwrap().baz.as_ref() { .. }` the lock will be held\n-        // for the duration if body.\n-        let needs_drop = type_needs_ordered_drop(cx, check_ty) || temporaries_need_ordered_drop(cx, let_expr);\n-\n-        // check that `while_let_on_iterator` lint does not trigger\n-        if_chain! {\n-            if keyword == \"while\";\n-            if let ExprKind::MethodCall(method_path, _, _) = let_expr.kind;\n-            if method_path.ident.name == sym::next;\n-            if is_trait_method(cx, let_expr, sym::Iterator);\n-            then {\n-                return;\n-            }\n-        }\n-\n-        let result_expr = match &let_expr.kind {\n-            ExprKind::AddrOf(_, _, borrowed) => borrowed,\n-            ExprKind::Unary(UnOp::Deref, deref) => deref,\n-            _ => let_expr,\n-        };\n-\n-        span_lint_and_then(\n-            cx,\n-            REDUNDANT_PATTERN_MATCHING,\n-            let_pat.span,\n-            &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n-            |diag| {\n-                // if/while let ... = ... { ... }\n-                // ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-                let expr_span = expr.span;\n-\n-                // if/while let ... = ... { ... }\n-                //                 ^^^\n-                let op_span = result_expr.span.source_callsite();\n-\n-                // if/while let ... = ... { ... }\n-                // ^^^^^^^^^^^^^^^^^^^\n-                let span = expr_span.until(op_span.shrink_to_hi());\n-\n-                let app = if needs_drop {\n-                    Applicability::MaybeIncorrect\n-                } else {\n-                    Applicability::MachineApplicable\n-                };\n-\n-                let sugg = Sugg::hir_with_macro_callsite(cx, result_expr, \"_\")\n-                    .maybe_par()\n-                    .to_string();\n-\n-                diag.span_suggestion(span, \"try this\", format!(\"{} {}.{}\", keyword, sugg, good_method), app);\n-\n-                if needs_drop {\n-                    diag.note(\"this will change drop order of the result, as well as all temporaries\");\n-                    diag.note(\"add `#[allow(clippy::redundant_pattern_matching)]` if this is important\");\n-                }\n-            },\n-        );\n-    }\n-\n-    fn find_sugg_for_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op: &Expr<'_>, arms: &[Arm<'_>]) {\n-        if arms.len() == 2 {\n-            let node_pair = (&arms[0].pat.kind, &arms[1].pat.kind);\n-\n-            let found_good_method = match node_pair {\n-                (\n-                    PatKind::TupleStruct(ref path_left, patterns_left, _),\n-                    PatKind::TupleStruct(ref path_right, patterns_right, _),\n-                ) if patterns_left.len() == 1 && patterns_right.len() == 1 => {\n-                    if let (PatKind::Wild, PatKind::Wild) = (&patterns_left[0].kind, &patterns_right[0].kind) {\n-                        find_good_method_for_match(\n-                            cx,\n-                            arms,\n-                            path_left,\n-                            path_right,\n-                            &paths::RESULT_OK,\n-                            &paths::RESULT_ERR,\n-                            \"is_ok()\",\n-                            \"is_err()\",\n-                        )\n-                        .or_else(|| {\n-                            find_good_method_for_match(\n-                                cx,\n-                                arms,\n-                                path_left,\n-                                path_right,\n-                                &paths::IPADDR_V4,\n-                                &paths::IPADDR_V6,\n-                                \"is_ipv4()\",\n-                                \"is_ipv6()\",\n-                            )\n-                        })\n-                    } else {\n-                        None\n-                    }\n-                },\n-                (PatKind::TupleStruct(ref path_left, patterns, _), PatKind::Path(ref path_right))\n-                | (PatKind::Path(ref path_left), PatKind::TupleStruct(ref path_right, patterns, _))\n-                    if patterns.len() == 1 =>\n-                {\n-                    if let PatKind::Wild = patterns[0].kind {\n-                        find_good_method_for_match(\n-                            cx,\n-                            arms,\n-                            path_left,\n-                            path_right,\n-                            &paths::OPTION_SOME,\n-                            &paths::OPTION_NONE,\n-                            \"is_some()\",\n-                            \"is_none()\",\n-                        )\n-                        .or_else(|| {\n-                            find_good_method_for_match(\n-                                cx,\n-                                arms,\n-                                path_left,\n-                                path_right,\n-                                &paths::POLL_READY,\n-                                &paths::POLL_PENDING,\n-                                \"is_ready()\",\n-                                \"is_pending()\",\n-                            )\n-                        })\n-                    } else {\n-                        None\n-                    }\n-                },\n-                _ => None,\n-            };\n-\n-            if let Some(good_method) = found_good_method {\n-                let span = expr.span.to(op.span);\n-                let result_expr = match &op.kind {\n-                    ExprKind::AddrOf(_, _, borrowed) => borrowed,\n-                    _ => op,\n-                };\n-                span_lint_and_then(\n-                    cx,\n-                    REDUNDANT_PATTERN_MATCHING,\n-                    expr.span,\n-                    &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n-                    |diag| {\n-                        diag.span_suggestion(\n-                            span,\n-                            \"try this\",\n-                            format!(\"{}.{}\", snippet(cx, result_expr.span, \"_\"), good_method),\n-                            Applicability::MaybeIncorrect, // snippet\n-                        );\n-                    },\n-                );\n-            }\n-        }\n-    }\n-\n-    #[allow(clippy::too_many_arguments)]\n-    fn find_good_method_for_match<'a>(\n-        cx: &LateContext<'_>,\n-        arms: &[Arm<'_>],\n-        path_left: &QPath<'_>,\n-        path_right: &QPath<'_>,\n-        expected_left: &[&str],\n-        expected_right: &[&str],\n-        should_be_left: &'a str,\n-        should_be_right: &'a str,\n-    ) -> Option<&'a str> {\n-        let body_node_pair = if is_qpath_def_path(cx, path_left, arms[0].pat.hir_id, expected_left)\n-            && is_qpath_def_path(cx, path_right, arms[1].pat.hir_id, expected_right)\n-        {\n-            (&(*arms[0].body).kind, &(*arms[1].body).kind)\n-        } else if is_qpath_def_path(cx, path_right, arms[1].pat.hir_id, expected_left)\n-            && is_qpath_def_path(cx, path_left, arms[0].pat.hir_id, expected_right)\n-        {\n-            (&(*arms[1].body).kind, &(*arms[0].body).kind)\n-        } else {\n-            return None;\n-        };\n-\n-        match body_node_pair {\n-            (ExprKind::Lit(ref lit_left), ExprKind::Lit(ref lit_right)) => match (&lit_left.node, &lit_right.node) {\n-                (LitKind::Bool(true), LitKind::Bool(false)) => Some(should_be_left),\n-                (LitKind::Bool(false), LitKind::Bool(true)) => Some(should_be_right),\n-                _ => None,\n-            },\n-            _ => None,\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_overlapping() {\n-    use rustc_span::source_map::DUMMY_SP;\n-\n-    let sp = |s, e| SpannedRange {\n-        span: DUMMY_SP,\n-        node: (s, e),\n-    };\n-\n-    assert_eq!(None, overlapping::<u8>(&[]));\n-    assert_eq!(None, overlapping(&[sp(1, EndBound::Included(4))]));\n-    assert_eq!(\n-        None,\n-        overlapping(&[sp(1, EndBound::Included(4)), sp(5, EndBound::Included(6))])\n-    );\n-    assert_eq!(\n-        None,\n-        overlapping(&[\n-            sp(1, EndBound::Included(4)),\n-            sp(5, EndBound::Included(6)),\n-            sp(10, EndBound::Included(11))\n-        ],)\n-    );\n-    assert_eq!(\n-        Some((&sp(1, EndBound::Included(4)), &sp(3, EndBound::Included(6)))),\n-        overlapping(&[sp(1, EndBound::Included(4)), sp(3, EndBound::Included(6))])\n-    );\n-    assert_eq!(\n-        Some((&sp(5, EndBound::Included(6)), &sp(6, EndBound::Included(11)))),\n-        overlapping(&[\n-            sp(1, EndBound::Included(4)),\n-            sp(5, EndBound::Included(6)),\n-            sp(6, EndBound::Included(11))\n-        ],)\n-    );\n-}\n-\n-/// Implementation of `MATCH_SAME_ARMS`.\n-fn lint_match_arms<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n-    if let ExprKind::Match(_, arms, MatchSource::Normal) = expr.kind {\n-        let hash = |&(_, arm): &(usize, &Arm<'_>)| -> u64 {\n-            let mut h = SpanlessHash::new(cx);\n-            h.hash_expr(arm.body);\n-            h.finish()\n-        };\n-\n-        let eq = |&(lindex, lhs): &(usize, &Arm<'_>), &(rindex, rhs): &(usize, &Arm<'_>)| -> bool {\n-            let min_index = usize::min(lindex, rindex);\n-            let max_index = usize::max(lindex, rindex);\n-\n-            let mut local_map: HirIdMap<HirId> = HirIdMap::default();\n-            let eq_fallback = |a: &Expr<'_>, b: &Expr<'_>| {\n-                if_chain! {\n-                    if let Some(a_id) = path_to_local(a);\n-                    if let Some(b_id) = path_to_local(b);\n-                    let entry = match local_map.entry(a_id) {\n-                        Entry::Vacant(entry) => entry,\n-                        // check if using the same bindings as before\n-                        Entry::Occupied(entry) => return *entry.get() == b_id,\n-                    };\n-                    // the names technically don't have to match; this makes the lint more conservative\n-                    if cx.tcx.hir().name(a_id) == cx.tcx.hir().name(b_id);\n-                    if TyS::same_type(cx.typeck_results().expr_ty(a), cx.typeck_results().expr_ty(b));\n-                    if pat_contains_local(lhs.pat, a_id);\n-                    if pat_contains_local(rhs.pat, b_id);\n-                    then {\n-                        entry.insert(b_id);\n-                        true\n-                    } else {\n-                        false\n-                    }\n-                }\n-            };\n-            // Arms with a guard are ignored, those can\u2019t always be merged together\n-            // This is also the case for arms in-between each there is an arm with a guard\n-            (min_index..=max_index).all(|index| arms[index].guard.is_none())\n-                && SpanlessEq::new(cx)\n-                    .expr_fallback(eq_fallback)\n-                    .eq_expr(lhs.body, rhs.body)\n-                // these checks could be removed to allow unused bindings\n-                && bindings_eq(lhs.pat, local_map.keys().copied().collect())\n-                && bindings_eq(rhs.pat, local_map.values().copied().collect())\n-        };\n-\n-        let indexed_arms: Vec<(usize, &Arm<'_>)> = arms.iter().enumerate().collect();\n-        for (&(_, i), &(_, j)) in search_same(&indexed_arms, hash, eq) {\n-            span_lint_and_then(\n-                cx,\n-                MATCH_SAME_ARMS,\n-                j.body.span,\n-                \"this `match` has identical arm bodies\",\n-                |diag| {\n-                    diag.span_note(i.body.span, \"same as this\");\n-\n-                    // Note: this does not use `span_suggestion` on purpose:\n-                    // there is no clean way\n-                    // to remove the other arm. Building a span and suggest to replace it to \"\"\n-                    // makes an even more confusing error message. Also in order not to make up a\n-                    // span for the whole pattern, the suggestion is only shown when there is only\n-                    // one pattern. The user should know about `|` if they are already using it\u2026\n-\n-                    let lhs = snippet(cx, i.pat.span, \"<pat1>\");\n-                    let rhs = snippet(cx, j.pat.span, \"<pat2>\");\n-\n-                    if let PatKind::Wild = j.pat.kind {\n-                        // if the last arm is _, then i could be integrated into _\n-                        // note that i.pat cannot be _, because that would mean that we're\n-                        // hiding all the subsequent arms, and rust won't compile\n-                        diag.span_note(\n-                            i.body.span,\n-                            &format!(\n-                                \"`{}` has the same arm body as the `_` wildcard, consider removing it\",\n-                                lhs\n-                            ),\n-                        );\n-                    } else {\n-                        diag.span_help(i.pat.span, &format!(\"consider refactoring into `{} | {}`\", lhs, rhs,))\n-                            .help(\"...or consider changing the match arm bodies\");\n-                    }\n-                },\n-            );\n-        }\n-    }\n-}\n-\n-fn pat_contains_local(pat: &Pat<'_>, id: HirId) -> bool {\n-    let mut result = false;\n-    pat.walk_short(|p| {\n-        result |= matches!(p.kind, PatKind::Binding(_, binding_id, ..) if binding_id == id);\n-        !result\n-    });\n-    result\n-}\n-\n-/// Returns true if all the bindings in the `Pat` are in `ids` and vice versa\n-fn bindings_eq(pat: &Pat<'_>, mut ids: HirIdSet) -> bool {\n-    let mut result = true;\n-    pat.each_binding_or_first(&mut |_, id, _, _| result &= ids.remove(&id));\n-    result && ids.is_empty()\n-}"}, {"sha": "2472acb6f6e8b6f974fcf898010e45140bc021ff", "filename": "clippy_lints/src/matches/infallible_destructuring_match.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatches%2Finfallible_destructuring_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatches%2Finfallible_destructuring_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Finfallible_destructuring_match.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,44 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::{path_to_local_id, peel_blocks, strip_pat_refs};\n+use rustc_errors::Applicability;\n+use rustc_hir::{ExprKind, Local, MatchSource, PatKind, QPath};\n+use rustc_lint::LateContext;\n+\n+use super::INFALLIBLE_DESTRUCTURING_MATCH;\n+\n+pub(crate) fn check(cx: &LateContext<'_>, local: &Local<'_>) -> bool {\n+    if_chain! {\n+        if !local.span.from_expansion();\n+        if let Some(expr) = local.init;\n+        if let ExprKind::Match(target, arms, MatchSource::Normal) = expr.kind;\n+        if arms.len() == 1 && arms[0].guard.is_none();\n+        if let PatKind::TupleStruct(\n+            QPath::Resolved(None, variant_name), args, _) = arms[0].pat.kind;\n+        if args.len() == 1;\n+        if let PatKind::Binding(_, arg, ..) = strip_pat_refs(&args[0]).kind;\n+        let body = peel_blocks(arms[0].body);\n+        if path_to_local_id(body, arg);\n+\n+        then {\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                INFALLIBLE_DESTRUCTURING_MATCH,\n+                local.span,\n+                \"you seem to be trying to use `match` to destructure a single infallible pattern. \\\n+                Consider using `let`\",\n+                \"try this\",\n+                format!(\n+                    \"let {}({}) = {};\",\n+                    snippet_with_applicability(cx, variant_name.span, \"..\", &mut applicability),\n+                    snippet_with_applicability(cx, local.pat.span, \"..\", &mut applicability),\n+                    snippet_with_applicability(cx, target.span, \"..\", &mut applicability),\n+                ),\n+                applicability,\n+            );\n+            return true;\n+        }\n+    }\n+    false\n+}"}, {"sha": "d914eba01716b69e6fb182bcede18001c2e6f94b", "filename": "clippy_lints/src/matches/match_as_ref.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatches%2Fmatch_as_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatches%2Fmatch_as_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_as_ref.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,85 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::{is_lang_ctor, peel_blocks};\n+use rustc_errors::Applicability;\n+use rustc_hir::{Arm, BindingAnnotation, Expr, ExprKind, LangItem, PatKind, QPath};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+\n+use super::MATCH_AS_REF;\n+\n+pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n+    if arms.len() == 2 && arms[0].guard.is_none() && arms[1].guard.is_none() {\n+        let arm_ref: Option<BindingAnnotation> = if is_none_arm(cx, &arms[0]) {\n+            is_ref_some_arm(cx, &arms[1])\n+        } else if is_none_arm(cx, &arms[1]) {\n+            is_ref_some_arm(cx, &arms[0])\n+        } else {\n+            None\n+        };\n+        if let Some(rb) = arm_ref {\n+            let suggestion = if rb == BindingAnnotation::Ref {\n+                \"as_ref\"\n+            } else {\n+                \"as_mut\"\n+            };\n+\n+            let output_ty = cx.typeck_results().expr_ty(expr);\n+            let input_ty = cx.typeck_results().expr_ty(ex);\n+\n+            let cast = if_chain! {\n+                if let ty::Adt(_, substs) = input_ty.kind();\n+                let input_ty = substs.type_at(0);\n+                if let ty::Adt(_, substs) = output_ty.kind();\n+                let output_ty = substs.type_at(0);\n+                if let ty::Ref(_, output_ty, _) = *output_ty.kind();\n+                if input_ty != output_ty;\n+                then {\n+                    \".map(|x| x as _)\"\n+                } else {\n+                    \"\"\n+                }\n+            };\n+\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                MATCH_AS_REF,\n+                expr.span,\n+                &format!(\"use `{}()` instead\", suggestion),\n+                \"try this\",\n+                format!(\n+                    \"{}.{}(){}\",\n+                    snippet_with_applicability(cx, ex.span, \"_\", &mut applicability),\n+                    suggestion,\n+                    cast,\n+                ),\n+                applicability,\n+            );\n+        }\n+    }\n+}\n+\n+// Checks if arm has the form `None => None`\n+fn is_none_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n+    matches!(arm.pat.kind, PatKind::Path(ref qpath) if is_lang_ctor(cx, qpath, LangItem::OptionNone))\n+}\n+\n+// Checks if arm has the form `Some(ref v) => Some(v)` (checks for `ref` and `ref mut`)\n+fn is_ref_some_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> Option<BindingAnnotation> {\n+    if_chain! {\n+        if let PatKind::TupleStruct(ref qpath, [first_pat, ..], _) = arm.pat.kind;\n+        if is_lang_ctor(cx, qpath, LangItem::OptionSome);\n+        if let PatKind::Binding(rb, .., ident, _) = first_pat.kind;\n+        if rb == BindingAnnotation::Ref || rb == BindingAnnotation::RefMut;\n+        if let ExprKind::Call(e, args) = peel_blocks(arm.body).kind;\n+        if let ExprKind::Path(ref some_path) = e.kind;\n+        if is_lang_ctor(cx, some_path, LangItem::OptionSome) && args.len() == 1;\n+        if let ExprKind::Path(QPath::Resolved(_, path2)) = args[0].kind;\n+        if path2.segments.len() == 1 && ident.name == path2.segments[0].ident.name;\n+        then {\n+            return Some(rb)\n+        }\n+    }\n+    None\n+}"}, {"sha": "90c50b994d2bfe11245881843feef728b1829ad5", "filename": "clippy_lints/src/matches/match_bool.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatches%2Fmatch_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatches%2Fmatch_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_bool.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,75 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::is_unit_expr;\n+use clippy_utils::source::{expr_block, snippet};\n+use clippy_utils::sugg::Sugg;\n+use rustc_ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Arm, Expr, ExprKind, PatKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+\n+use super::MATCH_BOOL;\n+\n+pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n+    // Type of expression is `bool`.\n+    if *cx.typeck_results().expr_ty(ex).kind() == ty::Bool {\n+        span_lint_and_then(\n+            cx,\n+            MATCH_BOOL,\n+            expr.span,\n+            \"you seem to be trying to match on a boolean expression\",\n+            move |diag| {\n+                if arms.len() == 2 {\n+                    // no guards\n+                    let exprs = if let PatKind::Lit(arm_bool) = arms[0].pat.kind {\n+                        if let ExprKind::Lit(ref lit) = arm_bool.kind {\n+                            match lit.node {\n+                                LitKind::Bool(true) => Some((&*arms[0].body, &*arms[1].body)),\n+                                LitKind::Bool(false) => Some((&*arms[1].body, &*arms[0].body)),\n+                                _ => None,\n+                            }\n+                        } else {\n+                            None\n+                        }\n+                    } else {\n+                        None\n+                    };\n+\n+                    if let Some((true_expr, false_expr)) = exprs {\n+                        let sugg = match (is_unit_expr(true_expr), is_unit_expr(false_expr)) {\n+                            (false, false) => Some(format!(\n+                                \"if {} {} else {}\",\n+                                snippet(cx, ex.span, \"b\"),\n+                                expr_block(cx, true_expr, None, \"..\", Some(expr.span)),\n+                                expr_block(cx, false_expr, None, \"..\", Some(expr.span))\n+                            )),\n+                            (false, true) => Some(format!(\n+                                \"if {} {}\",\n+                                snippet(cx, ex.span, \"b\"),\n+                                expr_block(cx, true_expr, None, \"..\", Some(expr.span))\n+                            )),\n+                            (true, false) => {\n+                                let test = Sugg::hir(cx, ex, \"..\");\n+                                Some(format!(\n+                                    \"if {} {}\",\n+                                    !test,\n+                                    expr_block(cx, false_expr, None, \"..\", Some(expr.span))\n+                                ))\n+                            },\n+                            (true, true) => None,\n+                        };\n+\n+                        if let Some(sugg) = sugg {\n+                            diag.span_suggestion(\n+                                expr.span,\n+                                \"consider using an `if`/`else` expression\",\n+                                sugg,\n+                                Applicability::HasPlaceholders,\n+                            );\n+                        }\n+                    }\n+                }\n+            },\n+        );\n+    }\n+}"}, {"sha": "2e1f7646eb400b3924ff813738c90091205e139f", "filename": "clippy_lints/src/matches/match_like_matches.rs", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,169 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::{higher, is_wild};\n+use rustc_ast::{Attribute, LitKind};\n+use rustc_errors::Applicability;\n+use rustc_hir::{Arm, BorrowKind, Expr, ExprKind, Guard, Pat};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::source_map::Spanned;\n+\n+use super::MATCH_LIKE_MATCHES_MACRO;\n+\n+/// Lint a `match` or `if let .. { .. } else { .. }` expr that could be replaced by `matches!`\n+pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+    if let Some(higher::IfLet {\n+        let_pat,\n+        let_expr,\n+        if_then,\n+        if_else: Some(if_else),\n+    }) = higher::IfLet::hir(cx, expr)\n+    {\n+        find_matches_sugg(\n+            cx,\n+            let_expr,\n+            IntoIterator::into_iter([(&[][..], Some(let_pat), if_then, None), (&[][..], None, if_else, None)]),\n+            expr,\n+            true,\n+        );\n+    }\n+}\n+\n+pub(super) fn check_match<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    scrutinee: &'tcx Expr<'_>,\n+    arms: &'tcx [Arm<'tcx>],\n+) -> bool {\n+    find_matches_sugg(\n+        cx,\n+        scrutinee,\n+        arms.iter().map(|arm| {\n+            (\n+                cx.tcx.hir().attrs(arm.hir_id),\n+                Some(arm.pat),\n+                arm.body,\n+                arm.guard.as_ref(),\n+            )\n+        }),\n+        e,\n+        false,\n+    )\n+}\n+\n+/// Lint a `match` or `if let` for replacement by `matches!`\n+fn find_matches_sugg<'a, 'b, I>(\n+    cx: &LateContext<'_>,\n+    ex: &Expr<'_>,\n+    mut iter: I,\n+    expr: &Expr<'_>,\n+    is_if_let: bool,\n+) -> bool\n+where\n+    'b: 'a,\n+    I: Clone\n+        + DoubleEndedIterator\n+        + ExactSizeIterator\n+        + Iterator<\n+            Item = (\n+                &'a [Attribute],\n+                Option<&'a Pat<'b>>,\n+                &'a Expr<'b>,\n+                Option<&'a Guard<'b>>,\n+            ),\n+        >,\n+{\n+    if_chain! {\n+        if iter.len() >= 2;\n+        if cx.typeck_results().expr_ty(expr).is_bool();\n+        if let Some((_, last_pat_opt, last_expr, _)) = iter.next_back();\n+        let iter_without_last = iter.clone();\n+        if let Some((first_attrs, _, first_expr, first_guard)) = iter.next();\n+        if let Some(b0) = find_bool_lit(&first_expr.kind, is_if_let);\n+        if let Some(b1) = find_bool_lit(&last_expr.kind, is_if_let);\n+        if b0 != b1;\n+        if first_guard.is_none() || iter.len() == 0;\n+        if first_attrs.is_empty();\n+        if iter\n+            .all(|arm| {\n+                find_bool_lit(&arm.2.kind, is_if_let).map_or(false, |b| b == b0) && arm.3.is_none() && arm.0.is_empty()\n+            });\n+        then {\n+            if let Some(last_pat) = last_pat_opt {\n+                if !is_wild(last_pat) {\n+                    return false;\n+                }\n+            }\n+\n+            // The suggestion may be incorrect, because some arms can have `cfg` attributes\n+            // evaluated into `false` and so such arms will be stripped before.\n+            let mut applicability = Applicability::MaybeIncorrect;\n+            let pat = {\n+                use itertools::Itertools as _;\n+                iter_without_last\n+                    .filter_map(|arm| {\n+                        let pat_span = arm.1?.span;\n+                        Some(snippet_with_applicability(cx, pat_span, \"..\", &mut applicability))\n+                    })\n+                    .join(\" | \")\n+            };\n+            let pat_and_guard = if let Some(Guard::If(g)) = first_guard {\n+                format!(\"{} if {}\", pat, snippet_with_applicability(cx, g.span, \"..\", &mut applicability))\n+            } else {\n+                pat\n+            };\n+\n+            // strip potential borrows (#6503), but only if the type is a reference\n+            let mut ex_new = ex;\n+            if let ExprKind::AddrOf(BorrowKind::Ref, .., ex_inner) = ex.kind {\n+                if let ty::Ref(..) = cx.typeck_results().expr_ty(ex_inner).kind() {\n+                    ex_new = ex_inner;\n+                }\n+            };\n+            span_lint_and_sugg(\n+                cx,\n+                MATCH_LIKE_MATCHES_MACRO,\n+                expr.span,\n+                &format!(\"{} expression looks like `matches!` macro\", if is_if_let { \"if let .. else\" } else { \"match\" }),\n+                \"try this\",\n+                format!(\n+                    \"{}matches!({}, {})\",\n+                    if b0 { \"\" } else { \"!\" },\n+                    snippet_with_applicability(cx, ex_new.span, \"..\", &mut applicability),\n+                    pat_and_guard,\n+                ),\n+                applicability,\n+            );\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+/// Extract a `bool` or `{ bool }`\n+fn find_bool_lit(ex: &ExprKind<'_>, is_if_let: bool) -> Option<bool> {\n+    match ex {\n+        ExprKind::Lit(Spanned {\n+            node: LitKind::Bool(b), ..\n+        }) => Some(*b),\n+        ExprKind::Block(\n+            rustc_hir::Block {\n+                stmts: &[],\n+                expr: Some(exp),\n+                ..\n+            },\n+            _,\n+        ) if is_if_let => {\n+            if let ExprKind::Lit(Spanned {\n+                node: LitKind::Bool(b), ..\n+            }) = exp.kind\n+            {\n+                Some(b)\n+            } else {\n+                None\n+            }\n+        },\n+        _ => None,\n+    }\n+}"}, {"sha": "80f964ba1b72c4a246f24ee264d3ce5a508276d4", "filename": "clippy_lints/src/matches/match_ref_pats.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatches%2Fmatch_ref_pats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatches%2Fmatch_ref_pats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_ref_pats.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,66 @@\n+use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_then};\n+use clippy_utils::source::snippet;\n+use clippy_utils::sugg::Sugg;\n+use core::iter::once;\n+use rustc_hir::{BorrowKind, Expr, ExprKind, Mutability, Pat, PatKind};\n+use rustc_lint::LateContext;\n+\n+use super::MATCH_REF_PATS;\n+\n+pub(crate) fn check<'a, 'b, I>(cx: &LateContext<'_>, ex: &Expr<'_>, pats: I, expr: &Expr<'_>)\n+where\n+    'b: 'a,\n+    I: Clone + Iterator<Item = &'a Pat<'b>>,\n+{\n+    if !has_multiple_ref_pats(pats.clone()) {\n+        return;\n+    }\n+\n+    let (first_sugg, msg, title);\n+    let span = ex.span.source_callsite();\n+    if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, inner) = ex.kind {\n+        first_sugg = once((span, Sugg::hir_with_macro_callsite(cx, inner, \"..\").to_string()));\n+        msg = \"try\";\n+        title = \"you don't need to add `&` to both the expression and the patterns\";\n+    } else {\n+        first_sugg = once((span, Sugg::hir_with_macro_callsite(cx, ex, \"..\").deref().to_string()));\n+        msg = \"instead of prefixing all patterns with `&`, you can dereference the expression\";\n+        title = \"you don't need to add `&` to all patterns\";\n+    }\n+\n+    let remaining_suggs = pats.filter_map(|pat| {\n+        if let PatKind::Ref(refp, _) = pat.kind {\n+            Some((pat.span, snippet(cx, refp.span, \"..\").to_string()))\n+        } else {\n+            None\n+        }\n+    });\n+\n+    span_lint_and_then(cx, MATCH_REF_PATS, expr.span, title, |diag| {\n+        if !expr.span.from_expansion() {\n+            multispan_sugg(diag, msg, first_sugg.chain(remaining_suggs));\n+        }\n+    });\n+}\n+\n+fn has_multiple_ref_pats<'a, 'b, I>(pats: I) -> bool\n+where\n+    'b: 'a,\n+    I: Iterator<Item = &'a Pat<'b>>,\n+{\n+    let mut ref_count = 0;\n+    for opt in pats.map(|pat| match pat.kind {\n+        PatKind::Ref(..) => Some(true), // &-patterns\n+        PatKind::Wild => Some(false),   // an \"anything\" wildcard is also fine\n+        _ => None,                      // any other pattern is not fine\n+    }) {\n+        if let Some(inner) = opt {\n+            if inner {\n+                ref_count += 1;\n+            }\n+        } else {\n+            return false;\n+        }\n+    }\n+    ref_count > 1\n+}"}, {"sha": "a96a7fe55f3a3bb8304711b9a00923c64e41725d", "filename": "clippy_lints/src/matches/match_same_arms.rs", "status": "added", "additions": 419, "deletions": 0, "changes": 419, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,419 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::source::snippet;\n+use clippy_utils::{path_to_local, search_same, SpanlessEq, SpanlessHash};\n+use core::cmp::Ordering;\n+use core::iter;\n+use core::slice;\n+use rustc_arena::DroplessArena;\n+use rustc_ast::ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::{Arm, Expr, ExprKind, HirId, HirIdMap, HirIdSet, Pat, PatKind, RangeEnd};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::Symbol;\n+use std::collections::hash_map::Entry;\n+\n+use super::MATCH_SAME_ARMS;\n+\n+#[expect(clippy::too_many_lines)]\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>]) {\n+    let hash = |&(_, arm): &(usize, &Arm<'_>)| -> u64 {\n+        let mut h = SpanlessHash::new(cx);\n+        h.hash_expr(arm.body);\n+        h.finish()\n+    };\n+\n+    let arena = DroplessArena::default();\n+    let normalized_pats: Vec<_> = arms\n+        .iter()\n+        .map(|a| NormalizedPat::from_pat(cx, &arena, a.pat))\n+        .collect();\n+\n+    // The furthest forwards a pattern can move without semantic changes\n+    let forwards_blocking_idxs: Vec<_> = normalized_pats\n+        .iter()\n+        .enumerate()\n+        .map(|(i, pat)| {\n+            normalized_pats[i + 1..]\n+                .iter()\n+                .enumerate()\n+                .find_map(|(j, other)| pat.has_overlapping_values(other).then(|| i + 1 + j))\n+                .unwrap_or(normalized_pats.len())\n+        })\n+        .collect();\n+\n+    // The furthest backwards a pattern can move without semantic changes\n+    let backwards_blocking_idxs: Vec<_> = normalized_pats\n+        .iter()\n+        .enumerate()\n+        .map(|(i, pat)| {\n+            normalized_pats[..i]\n+                .iter()\n+                .enumerate()\n+                .rev()\n+                .zip(forwards_blocking_idxs[..i].iter().copied().rev())\n+                .skip_while(|&(_, forward_block)| forward_block > i)\n+                .find_map(|((j, other), forward_block)| {\n+                    (forward_block == i || pat.has_overlapping_values(other)).then(|| j)\n+                })\n+                .unwrap_or(0)\n+        })\n+        .collect();\n+\n+    let eq = |&(lindex, lhs): &(usize, &Arm<'_>), &(rindex, rhs): &(usize, &Arm<'_>)| -> bool {\n+        let min_index = usize::min(lindex, rindex);\n+        let max_index = usize::max(lindex, rindex);\n+\n+        let mut local_map: HirIdMap<HirId> = HirIdMap::default();\n+        let eq_fallback = |a: &Expr<'_>, b: &Expr<'_>| {\n+            if_chain! {\n+                if let Some(a_id) = path_to_local(a);\n+                if let Some(b_id) = path_to_local(b);\n+                let entry = match local_map.entry(a_id) {\n+                    Entry::Vacant(entry) => entry,\n+                    // check if using the same bindings as before\n+                    Entry::Occupied(entry) => return *entry.get() == b_id,\n+                };\n+                // the names technically don't have to match; this makes the lint more conservative\n+                if cx.tcx.hir().name(a_id) == cx.tcx.hir().name(b_id);\n+                if cx.typeck_results().expr_ty(a) == cx.typeck_results().expr_ty(b);\n+                if pat_contains_local(lhs.pat, a_id);\n+                if pat_contains_local(rhs.pat, b_id);\n+                then {\n+                    entry.insert(b_id);\n+                    true\n+                } else {\n+                    false\n+                }\n+            }\n+        };\n+        // Arms with a guard are ignored, those can\u2019t always be merged together\n+        // If both arms overlap with an arm in between then these can't be merged either.\n+        !(backwards_blocking_idxs[max_index] > min_index && forwards_blocking_idxs[min_index] < max_index)\n+                && lhs.guard.is_none()\n+                && rhs.guard.is_none()\n+                && SpanlessEq::new(cx)\n+                    .expr_fallback(eq_fallback)\n+                    .eq_expr(lhs.body, rhs.body)\n+                // these checks could be removed to allow unused bindings\n+                && bindings_eq(lhs.pat, local_map.keys().copied().collect())\n+                && bindings_eq(rhs.pat, local_map.values().copied().collect())\n+    };\n+\n+    let indexed_arms: Vec<(usize, &Arm<'_>)> = arms.iter().enumerate().collect();\n+    for (&(i, arm1), &(j, arm2)) in search_same(&indexed_arms, hash, eq) {\n+        if matches!(arm2.pat.kind, PatKind::Wild) {\n+            span_lint_and_then(\n+                cx,\n+                MATCH_SAME_ARMS,\n+                arm1.span,\n+                \"this match arm has an identical body to the `_` wildcard arm\",\n+                |diag| {\n+                    diag.span_suggestion(\n+                        arm1.span,\n+                        \"try removing the arm\",\n+                        String::new(),\n+                        Applicability::MaybeIncorrect,\n+                    )\n+                    .help(\"or try changing either arm body\")\n+                    .span_note(arm2.span, \"`_` wildcard arm here\");\n+                },\n+            );\n+        } else {\n+            let back_block = backwards_blocking_idxs[j];\n+            let (keep_arm, move_arm) = if back_block < i || (back_block == 0 && forwards_blocking_idxs[i] <= j) {\n+                (arm1, arm2)\n+            } else {\n+                (arm2, arm1)\n+            };\n+\n+            span_lint_and_then(\n+                cx,\n+                MATCH_SAME_ARMS,\n+                keep_arm.span,\n+                \"this match arm has an identical body to another arm\",\n+                |diag| {\n+                    let move_pat_snip = snippet(cx, move_arm.pat.span, \"<pat2>\");\n+                    let keep_pat_snip = snippet(cx, keep_arm.pat.span, \"<pat1>\");\n+\n+                    diag.span_suggestion(\n+                        keep_arm.pat.span,\n+                        \"try merging the arm patterns\",\n+                        format!(\"{} | {}\", keep_pat_snip, move_pat_snip),\n+                        Applicability::MaybeIncorrect,\n+                    )\n+                    .help(\"or try changing either arm body\")\n+                    .span_note(move_arm.span, \"other arm here\");\n+                },\n+            );\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy)]\n+enum NormalizedPat<'a> {\n+    Wild,\n+    Struct(Option<DefId>, &'a [(Symbol, Self)]),\n+    Tuple(Option<DefId>, &'a [Self]),\n+    Or(&'a [Self]),\n+    Path(Option<DefId>),\n+    LitStr(Symbol),\n+    LitBytes(&'a [u8]),\n+    LitInt(u128),\n+    LitBool(bool),\n+    Range(PatRange),\n+    /// A slice pattern. If the second value is `None`, then this matches an exact size. Otherwise\n+    /// the first value contains everything before the `..` wildcard pattern, and the second value\n+    /// contains everything afterwards. Note that either side, or both sides, may contain zero\n+    /// patterns.\n+    Slice(&'a [Self], Option<&'a [Self]>),\n+}\n+\n+#[derive(Clone, Copy)]\n+struct PatRange {\n+    start: u128,\n+    end: u128,\n+    bounds: RangeEnd,\n+}\n+impl PatRange {\n+    fn contains(&self, x: u128) -> bool {\n+        x >= self.start\n+            && match self.bounds {\n+                RangeEnd::Included => x <= self.end,\n+                RangeEnd::Excluded => x < self.end,\n+            }\n+    }\n+\n+    fn overlaps(&self, other: &Self) -> bool {\n+        // Note: Empty ranges are impossible, so this is correct even though it would return true if an\n+        // empty exclusive range were to reside within an inclusive range.\n+        (match self.bounds {\n+            RangeEnd::Included => self.end >= other.start,\n+            RangeEnd::Excluded => self.end > other.start,\n+        } && match other.bounds {\n+            RangeEnd::Included => self.start <= other.end,\n+            RangeEnd::Excluded => self.start < other.end,\n+        })\n+    }\n+}\n+\n+/// Iterates over the pairs of fields with matching names.\n+fn iter_matching_struct_fields<'a>(\n+    left: &'a [(Symbol, NormalizedPat<'a>)],\n+    right: &'a [(Symbol, NormalizedPat<'a>)],\n+) -> impl Iterator<Item = (&'a NormalizedPat<'a>, &'a NormalizedPat<'a>)> + 'a {\n+    struct Iter<'a>(\n+        slice::Iter<'a, (Symbol, NormalizedPat<'a>)>,\n+        slice::Iter<'a, (Symbol, NormalizedPat<'a>)>,\n+    );\n+    impl<'a> Iterator for Iter<'a> {\n+        type Item = (&'a NormalizedPat<'a>, &'a NormalizedPat<'a>);\n+        fn next(&mut self) -> Option<Self::Item> {\n+            // Note: all the fields in each slice are sorted by symbol value.\n+            let mut left = self.0.next()?;\n+            let mut right = self.1.next()?;\n+            loop {\n+                match left.0.cmp(&right.0) {\n+                    Ordering::Equal => return Some((&left.1, &right.1)),\n+                    Ordering::Less => left = self.0.next()?,\n+                    Ordering::Greater => right = self.1.next()?,\n+                }\n+            }\n+        }\n+    }\n+    Iter(left.iter(), right.iter())\n+}\n+\n+#[expect(clippy::similar_names)]\n+impl<'a> NormalizedPat<'a> {\n+    #[expect(clippy::too_many_lines)]\n+    fn from_pat(cx: &LateContext<'_>, arena: &'a DroplessArena, pat: &'a Pat<'_>) -> Self {\n+        match pat.kind {\n+            PatKind::Wild | PatKind::Binding(.., None) => Self::Wild,\n+            PatKind::Binding(.., Some(pat)) | PatKind::Box(pat) | PatKind::Ref(pat, _) => {\n+                Self::from_pat(cx, arena, pat)\n+            },\n+            PatKind::Struct(ref path, fields, _) => {\n+                let fields =\n+                    arena.alloc_from_iter(fields.iter().map(|f| (f.ident.name, Self::from_pat(cx, arena, f.pat))));\n+                fields.sort_by_key(|&(name, _)| name);\n+                Self::Struct(cx.qpath_res(path, pat.hir_id).opt_def_id(), fields)\n+            },\n+            PatKind::TupleStruct(ref path, pats, wild_idx) => {\n+                let adt = match cx.typeck_results().pat_ty(pat).ty_adt_def() {\n+                    Some(x) => x,\n+                    None => return Self::Wild,\n+                };\n+                let (var_id, variant) = if adt.is_enum() {\n+                    match cx.qpath_res(path, pat.hir_id).opt_def_id() {\n+                        Some(x) => (Some(x), adt.variant_with_ctor_id(x)),\n+                        None => return Self::Wild,\n+                    }\n+                } else {\n+                    (None, adt.non_enum_variant())\n+                };\n+                let (front, back) = match wild_idx {\n+                    Some(i) => pats.split_at(i),\n+                    None => (pats, [].as_slice()),\n+                };\n+                let pats = arena.alloc_from_iter(\n+                    front\n+                        .iter()\n+                        .map(|pat| Self::from_pat(cx, arena, pat))\n+                        .chain(iter::repeat_with(|| Self::Wild).take(variant.fields.len() - pats.len()))\n+                        .chain(back.iter().map(|pat| Self::from_pat(cx, arena, pat))),\n+                );\n+                Self::Tuple(var_id, pats)\n+            },\n+            PatKind::Or(pats) => Self::Or(arena.alloc_from_iter(pats.iter().map(|pat| Self::from_pat(cx, arena, pat)))),\n+            PatKind::Path(ref path) => Self::Path(cx.qpath_res(path, pat.hir_id).opt_def_id()),\n+            PatKind::Tuple(pats, wild_idx) => {\n+                let field_count = match cx.typeck_results().pat_ty(pat).kind() {\n+                    ty::Tuple(subs) => subs.len(),\n+                    _ => return Self::Wild,\n+                };\n+                let (front, back) = match wild_idx {\n+                    Some(i) => pats.split_at(i),\n+                    None => (pats, [].as_slice()),\n+                };\n+                let pats = arena.alloc_from_iter(\n+                    front\n+                        .iter()\n+                        .map(|pat| Self::from_pat(cx, arena, pat))\n+                        .chain(iter::repeat_with(|| Self::Wild).take(field_count - pats.len()))\n+                        .chain(back.iter().map(|pat| Self::from_pat(cx, arena, pat))),\n+                );\n+                Self::Tuple(None, pats)\n+            },\n+            PatKind::Lit(e) => match &e.kind {\n+                // TODO: Handle negative integers. They're currently treated as a wild match.\n+                ExprKind::Lit(lit) => match lit.node {\n+                    LitKind::Str(sym, _) => Self::LitStr(sym),\n+                    LitKind::ByteStr(ref bytes) => Self::LitBytes(&**bytes),\n+                    LitKind::Byte(val) => Self::LitInt(val.into()),\n+                    LitKind::Char(val) => Self::LitInt(val.into()),\n+                    LitKind::Int(val, _) => Self::LitInt(val),\n+                    LitKind::Bool(val) => Self::LitBool(val),\n+                    LitKind::Float(..) | LitKind::Err(_) => Self::Wild,\n+                },\n+                _ => Self::Wild,\n+            },\n+            PatKind::Range(start, end, bounds) => {\n+                // TODO: Handle negative integers. They're currently treated as a wild match.\n+                let start = match start {\n+                    None => 0,\n+                    Some(e) => match &e.kind {\n+                        ExprKind::Lit(lit) => match lit.node {\n+                            LitKind::Int(val, _) => val,\n+                            LitKind::Char(val) => val.into(),\n+                            LitKind::Byte(val) => val.into(),\n+                            _ => return Self::Wild,\n+                        },\n+                        _ => return Self::Wild,\n+                    },\n+                };\n+                let (end, bounds) = match end {\n+                    None => (u128::MAX, RangeEnd::Included),\n+                    Some(e) => match &e.kind {\n+                        ExprKind::Lit(lit) => match lit.node {\n+                            LitKind::Int(val, _) => (val, bounds),\n+                            LitKind::Char(val) => (val.into(), bounds),\n+                            LitKind::Byte(val) => (val.into(), bounds),\n+                            _ => return Self::Wild,\n+                        },\n+                        _ => return Self::Wild,\n+                    },\n+                };\n+                Self::Range(PatRange { start, end, bounds })\n+            },\n+            PatKind::Slice(front, wild_pat, back) => Self::Slice(\n+                arena.alloc_from_iter(front.iter().map(|pat| Self::from_pat(cx, arena, pat))),\n+                wild_pat.map(|_| &*arena.alloc_from_iter(back.iter().map(|pat| Self::from_pat(cx, arena, pat)))),\n+            ),\n+        }\n+    }\n+\n+    /// Checks if two patterns overlap in the values they can match assuming they are for the same\n+    /// type.\n+    fn has_overlapping_values(&self, other: &Self) -> bool {\n+        match (*self, *other) {\n+            (Self::Wild, _) | (_, Self::Wild) => true,\n+            (Self::Or(pats), ref other) | (ref other, Self::Or(pats)) => {\n+                pats.iter().any(|pat| pat.has_overlapping_values(other))\n+            },\n+            (Self::Struct(lpath, lfields), Self::Struct(rpath, rfields)) => {\n+                if lpath != rpath {\n+                    return false;\n+                }\n+                iter_matching_struct_fields(lfields, rfields).all(|(lpat, rpat)| lpat.has_overlapping_values(rpat))\n+            },\n+            (Self::Tuple(lpath, lpats), Self::Tuple(rpath, rpats)) => {\n+                if lpath != rpath {\n+                    return false;\n+                }\n+                lpats\n+                    .iter()\n+                    .zip(rpats.iter())\n+                    .all(|(lpat, rpat)| lpat.has_overlapping_values(rpat))\n+            },\n+            (Self::Path(x), Self::Path(y)) => x == y,\n+            (Self::LitStr(x), Self::LitStr(y)) => x == y,\n+            (Self::LitBytes(x), Self::LitBytes(y)) => x == y,\n+            (Self::LitInt(x), Self::LitInt(y)) => x == y,\n+            (Self::LitBool(x), Self::LitBool(y)) => x == y,\n+            (Self::Range(ref x), Self::Range(ref y)) => x.overlaps(y),\n+            (Self::Range(ref range), Self::LitInt(x)) | (Self::LitInt(x), Self::Range(ref range)) => range.contains(x),\n+            (Self::Slice(lpats, None), Self::Slice(rpats, None)) => {\n+                lpats.len() == rpats.len() && lpats.iter().zip(rpats.iter()).all(|(x, y)| x.has_overlapping_values(y))\n+            },\n+            (Self::Slice(pats, None), Self::Slice(front, Some(back)))\n+            | (Self::Slice(front, Some(back)), Self::Slice(pats, None)) => {\n+                // Here `pats` is an exact size match. If the combined lengths of `front` and `back` are greater\n+                // then the minium length required will be greater than the length of `pats`.\n+                if pats.len() < front.len() + back.len() {\n+                    return false;\n+                }\n+                pats[..front.len()]\n+                    .iter()\n+                    .zip(front.iter())\n+                    .chain(pats[pats.len() - back.len()..].iter().zip(back.iter()))\n+                    .all(|(x, y)| x.has_overlapping_values(y))\n+            },\n+            (Self::Slice(lfront, Some(lback)), Self::Slice(rfront, Some(rback))) => lfront\n+                .iter()\n+                .zip(rfront.iter())\n+                .chain(lback.iter().rev().zip(rback.iter().rev()))\n+                .all(|(x, y)| x.has_overlapping_values(y)),\n+\n+            // Enums can mix unit variants with tuple/struct variants. These can never overlap.\n+            (Self::Path(_), Self::Tuple(..) | Self::Struct(..))\n+            | (Self::Tuple(..) | Self::Struct(..), Self::Path(_)) => false,\n+\n+            // Tuples can be matched like a struct.\n+            (Self::Tuple(x, _), Self::Struct(y, _)) | (Self::Struct(x, _), Self::Tuple(y, _)) => {\n+                // TODO: check fields here.\n+                x == y\n+            },\n+\n+            // TODO: Lit* with Path, Range with Path, LitBytes with Slice\n+            _ => true,\n+        }\n+    }\n+}\n+\n+fn pat_contains_local(pat: &Pat<'_>, id: HirId) -> bool {\n+    let mut result = false;\n+    pat.walk_short(|p| {\n+        result |= matches!(p.kind, PatKind::Binding(_, binding_id, ..) if binding_id == id);\n+        !result\n+    });\n+    result\n+}\n+\n+/// Returns true if all the bindings in the `Pat` are in `ids` and vice versa\n+fn bindings_eq(pat: &Pat<'_>, mut ids: HirIdSet) -> bool {\n+    let mut result = true;\n+    pat.each_binding_or_first(&mut |_, id, _, _| result &= ids.remove(&id));\n+    result && ids.is_empty()\n+}"}, {"sha": "a59711d4cace5f7b17b0a4f3bf8675cfb9ca4c80", "filename": "clippy_lints/src/matches/match_single_binding.rs", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,216 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::macros::HirNode;\n+use clippy_utils::source::{indent_of, snippet, snippet_block, snippet_with_applicability};\n+use clippy_utils::sugg::Sugg;\n+use clippy_utils::{get_parent_expr, is_refutable, peel_blocks};\n+use rustc_errors::Applicability;\n+use rustc_hir::{Arm, Expr, ExprKind, Node, PatKind};\n+use rustc_lint::LateContext;\n+use rustc_span::Span;\n+\n+use super::MATCH_SINGLE_BINDING;\n+\n+enum AssignmentExpr {\n+    Assign { span: Span, match_span: Span },\n+    Local { span: Span, pat_span: Span },\n+}\n+\n+#[expect(clippy::too_many_lines)]\n+pub(crate) fn check<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], expr: &Expr<'a>) {\n+    if expr.span.from_expansion() || arms.len() != 1 || is_refutable(cx, arms[0].pat) {\n+        return;\n+    }\n+\n+    let matched_vars = ex.span;\n+    let bind_names = arms[0].pat.span;\n+    let match_body = peel_blocks(arms[0].body);\n+    let mut snippet_body = if match_body.span.from_expansion() {\n+        Sugg::hir_with_macro_callsite(cx, match_body, \"..\").to_string()\n+    } else {\n+        snippet_block(cx, match_body.span, \"..\", Some(expr.span)).to_string()\n+    };\n+\n+    // Do we need to add ';' to suggestion ?\n+    match match_body.kind {\n+        ExprKind::Block(block, _) => {\n+            // macro + expr_ty(body) == ()\n+            if block.span.from_expansion() && cx.typeck_results().expr_ty(match_body).is_unit() {\n+                snippet_body.push(';');\n+            }\n+        },\n+        _ => {\n+            // expr_ty(body) == ()\n+            if cx.typeck_results().expr_ty(match_body).is_unit() {\n+                snippet_body.push(';');\n+            }\n+        },\n+    }\n+\n+    let mut applicability = Applicability::MaybeIncorrect;\n+    match arms[0].pat.kind {\n+        PatKind::Binding(..) | PatKind::Tuple(_, _) | PatKind::Struct(..) => {\n+            let (target_span, sugg) = match opt_parent_assign_span(cx, ex) {\n+                Some(AssignmentExpr::Assign { span, match_span }) => {\n+                    let sugg = sugg_with_curlies(\n+                        cx,\n+                        (ex, expr),\n+                        (bind_names, matched_vars),\n+                        &*snippet_body,\n+                        &mut applicability,\n+                        Some(span),\n+                    );\n+\n+                    span_lint_and_sugg(\n+                        cx,\n+                        MATCH_SINGLE_BINDING,\n+                        span.to(match_span),\n+                        \"this assignment could be simplified\",\n+                        \"consider removing the `match` expression\",\n+                        sugg,\n+                        applicability,\n+                    );\n+\n+                    return;\n+                },\n+                Some(AssignmentExpr::Local { span, pat_span }) => (\n+                    span,\n+                    format!(\n+                        \"let {} = {};\\n{}let {} = {};\",\n+                        snippet_with_applicability(cx, bind_names, \"..\", &mut applicability),\n+                        snippet_with_applicability(cx, matched_vars, \"..\", &mut applicability),\n+                        \" \".repeat(indent_of(cx, expr.span).unwrap_or(0)),\n+                        snippet_with_applicability(cx, pat_span, \"..\", &mut applicability),\n+                        snippet_body\n+                    ),\n+                ),\n+                None => {\n+                    let sugg = sugg_with_curlies(\n+                        cx,\n+                        (ex, expr),\n+                        (bind_names, matched_vars),\n+                        &*snippet_body,\n+                        &mut applicability,\n+                        None,\n+                    );\n+                    (expr.span, sugg)\n+                },\n+            };\n+\n+            span_lint_and_sugg(\n+                cx,\n+                MATCH_SINGLE_BINDING,\n+                target_span,\n+                \"this match could be written as a `let` statement\",\n+                \"consider using a `let` statement\",\n+                sugg,\n+                applicability,\n+            );\n+        },\n+        PatKind::Wild => {\n+            if ex.can_have_side_effects() {\n+                let indent = \" \".repeat(indent_of(cx, expr.span).unwrap_or(0));\n+                let sugg = format!(\n+                    \"{};\\n{}{}\",\n+                    snippet_with_applicability(cx, ex.span, \"..\", &mut applicability),\n+                    indent,\n+                    snippet_body\n+                );\n+\n+                span_lint_and_sugg(\n+                    cx,\n+                    MATCH_SINGLE_BINDING,\n+                    expr.span,\n+                    \"this match could be replaced by its scrutinee and body\",\n+                    \"consider using the scrutinee and body instead\",\n+                    sugg,\n+                    applicability,\n+                );\n+            } else {\n+                span_lint_and_sugg(\n+                    cx,\n+                    MATCH_SINGLE_BINDING,\n+                    expr.span,\n+                    \"this match could be replaced by its body itself\",\n+                    \"consider using the match body instead\",\n+                    snippet_body,\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        },\n+        _ => (),\n+    }\n+}\n+\n+/// Returns true if the `ex` match expression is in a local (`let`) or assign expression\n+fn opt_parent_assign_span<'a>(cx: &LateContext<'a>, ex: &Expr<'a>) -> Option<AssignmentExpr> {\n+    let map = &cx.tcx.hir();\n+\n+    if let Some(Node::Expr(parent_arm_expr)) = map.find(map.get_parent_node(ex.hir_id)) {\n+        return match map.find(map.get_parent_node(parent_arm_expr.hir_id)) {\n+            Some(Node::Local(parent_let_expr)) => Some(AssignmentExpr::Local {\n+                span: parent_let_expr.span,\n+                pat_span: parent_let_expr.pat.span(),\n+            }),\n+            Some(Node::Expr(Expr {\n+                kind: ExprKind::Assign(parent_assign_expr, match_expr, _),\n+                ..\n+            })) => Some(AssignmentExpr::Assign {\n+                span: parent_assign_expr.span,\n+                match_span: match_expr.span,\n+            }),\n+            _ => None,\n+        };\n+    }\n+\n+    None\n+}\n+\n+fn sugg_with_curlies<'a>(\n+    cx: &LateContext<'a>,\n+    (ex, match_expr): (&Expr<'a>, &Expr<'a>),\n+    (bind_names, matched_vars): (Span, Span),\n+    snippet_body: &str,\n+    applicability: &mut Applicability,\n+    assignment: Option<Span>,\n+) -> String {\n+    let mut indent = \" \".repeat(indent_of(cx, ex.span).unwrap_or(0));\n+\n+    let (mut cbrace_start, mut cbrace_end) = (String::new(), String::new());\n+    if let Some(parent_expr) = get_parent_expr(cx, match_expr) {\n+        if let ExprKind::Closure(..) = parent_expr.kind {\n+            cbrace_end = format!(\"\\n{}}}\", indent);\n+            // Fix body indent due to the closure\n+            indent = \" \".repeat(indent_of(cx, bind_names).unwrap_or(0));\n+            cbrace_start = format!(\"{{\\n{}\", indent);\n+        }\n+    }\n+\n+    // If the parent is already an arm, and the body is another match statement,\n+    // we need curly braces around suggestion\n+    let parent_node_id = cx.tcx.hir().get_parent_node(match_expr.hir_id);\n+    if let Node::Arm(arm) = &cx.tcx.hir().get(parent_node_id) {\n+        if let ExprKind::Match(..) = arm.body.kind {\n+            cbrace_end = format!(\"\\n{}}}\", indent);\n+            // Fix body indent due to the match\n+            indent = \" \".repeat(indent_of(cx, bind_names).unwrap_or(0));\n+            cbrace_start = format!(\"{{\\n{}\", indent);\n+        }\n+    }\n+\n+    let assignment_str = assignment.map_or_else(String::new, |span| {\n+        let mut s = snippet(cx, span, \"..\").to_string();\n+        s.push_str(\" = \");\n+        s\n+    });\n+\n+    format!(\n+        \"{}let {} = {};\\n{}{}{}{}\",\n+        cbrace_start,\n+        snippet_with_applicability(cx, bind_names, \"..\", applicability),\n+        snippet_with_applicability(cx, matched_vars, \"..\", applicability),\n+        indent,\n+        assignment_str,\n+        snippet_body,\n+        cbrace_end\n+    )\n+}"}, {"sha": "6f8d766aef7c7806b382b51ec1d3edb9af26a9e6", "filename": "clippy_lints/src/matches/match_wild_enum.rs", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_enum.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,196 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{is_refutable, peel_hir_pat_refs, recurse_or_patterns};\n+use rustc_errors::Applicability;\n+use rustc_hir::def::{CtorKind, DefKind, Res};\n+use rustc_hir::{Arm, Expr, PatKind, PathSegment, QPath, Ty, TyKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, VariantDef};\n+use rustc_span::sym;\n+\n+use super::{MATCH_WILDCARD_FOR_SINGLE_VARIANTS, WILDCARD_ENUM_MATCH_ARM};\n+\n+#[expect(clippy::too_many_lines)]\n+pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n+    let ty = cx.typeck_results().expr_ty(ex).peel_refs();\n+    let adt_def = match ty.kind() {\n+        ty::Adt(adt_def, _)\n+            if adt_def.is_enum()\n+                && !(is_type_diagnostic_item(cx, ty, sym::Option) || is_type_diagnostic_item(cx, ty, sym::Result)) =>\n+        {\n+            adt_def\n+        },\n+        _ => return,\n+    };\n+\n+    // First pass - check for violation, but don't do much book-keeping because this is hopefully\n+    // the uncommon case, and the book-keeping is slightly expensive.\n+    let mut wildcard_span = None;\n+    let mut wildcard_ident = None;\n+    let mut has_non_wild = false;\n+    for arm in arms {\n+        match peel_hir_pat_refs(arm.pat).0.kind {\n+            PatKind::Wild => wildcard_span = Some(arm.pat.span),\n+            PatKind::Binding(_, _, ident, None) => {\n+                wildcard_span = Some(arm.pat.span);\n+                wildcard_ident = Some(ident);\n+            },\n+            _ => has_non_wild = true,\n+        }\n+    }\n+    let wildcard_span = match wildcard_span {\n+        Some(x) if has_non_wild => x,\n+        _ => return,\n+    };\n+\n+    // Accumulate the variants which should be put in place of the wildcard because they're not\n+    // already covered.\n+    let has_hidden = adt_def.variants().iter().any(|x| is_hidden(cx, x));\n+    let mut missing_variants: Vec<_> = adt_def.variants().iter().filter(|x| !is_hidden(cx, x)).collect();\n+\n+    let mut path_prefix = CommonPrefixSearcher::None;\n+    for arm in arms {\n+        // Guards mean that this case probably isn't exhaustively covered. Technically\n+        // this is incorrect, as we should really check whether each variant is exhaustively\n+        // covered by the set of guards that cover it, but that's really hard to do.\n+        recurse_or_patterns(arm.pat, |pat| {\n+            let path = match &peel_hir_pat_refs(pat).0.kind {\n+                PatKind::Path(path) => {\n+                    let id = match cx.qpath_res(path, pat.hir_id) {\n+                        Res::Def(\n+                            DefKind::Const | DefKind::ConstParam | DefKind::AnonConst | DefKind::InlineConst,\n+                            _,\n+                        ) => return,\n+                        Res::Def(_, id) => id,\n+                        _ => return,\n+                    };\n+                    if arm.guard.is_none() {\n+                        missing_variants.retain(|e| e.ctor_def_id != Some(id));\n+                    }\n+                    path\n+                },\n+                PatKind::TupleStruct(path, patterns, ..) => {\n+                    if let Some(id) = cx.qpath_res(path, pat.hir_id).opt_def_id() {\n+                        if arm.guard.is_none() && patterns.iter().all(|p| !is_refutable(cx, p)) {\n+                            missing_variants.retain(|e| e.ctor_def_id != Some(id));\n+                        }\n+                    }\n+                    path\n+                },\n+                PatKind::Struct(path, patterns, ..) => {\n+                    if let Some(id) = cx.qpath_res(path, pat.hir_id).opt_def_id() {\n+                        if arm.guard.is_none() && patterns.iter().all(|p| !is_refutable(cx, p.pat)) {\n+                            missing_variants.retain(|e| e.def_id != id);\n+                        }\n+                    }\n+                    path\n+                },\n+                _ => return,\n+            };\n+            match path {\n+                QPath::Resolved(_, path) => path_prefix.with_path(path.segments),\n+                QPath::TypeRelative(\n+                    Ty {\n+                        kind: TyKind::Path(QPath::Resolved(_, path)),\n+                        ..\n+                    },\n+                    _,\n+                ) => path_prefix.with_prefix(path.segments),\n+                _ => (),\n+            }\n+        });\n+    }\n+\n+    let format_suggestion = |variant: &VariantDef| {\n+        format!(\n+            \"{}{}{}{}\",\n+            if let Some(ident) = wildcard_ident {\n+                format!(\"{} @ \", ident.name)\n+            } else {\n+                String::new()\n+            },\n+            if let CommonPrefixSearcher::Path(path_prefix) = path_prefix {\n+                let mut s = String::new();\n+                for seg in path_prefix {\n+                    s.push_str(seg.ident.as_str());\n+                    s.push_str(\"::\");\n+                }\n+                s\n+            } else {\n+                let mut s = cx.tcx.def_path_str(adt_def.did());\n+                s.push_str(\"::\");\n+                s\n+            },\n+            variant.name,\n+            match variant.ctor_kind {\n+                CtorKind::Fn if variant.fields.len() == 1 => \"(_)\",\n+                CtorKind::Fn => \"(..)\",\n+                CtorKind::Const => \"\",\n+                CtorKind::Fictive => \"{ .. }\",\n+            }\n+        )\n+    };\n+\n+    match missing_variants.as_slice() {\n+        [] => (),\n+        [x] if !adt_def.is_variant_list_non_exhaustive() && !has_hidden => span_lint_and_sugg(\n+            cx,\n+            MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n+            wildcard_span,\n+            \"wildcard matches only a single variant and will also match any future added variants\",\n+            \"try this\",\n+            format_suggestion(x),\n+            Applicability::MaybeIncorrect,\n+        ),\n+        variants => {\n+            let mut suggestions: Vec<_> = variants.iter().copied().map(format_suggestion).collect();\n+            let message = if adt_def.is_variant_list_non_exhaustive() || has_hidden {\n+                suggestions.push(\"_\".into());\n+                \"wildcard matches known variants and will also match future added variants\"\n+            } else {\n+                \"wildcard match will also match any future added variants\"\n+            };\n+\n+            span_lint_and_sugg(\n+                cx,\n+                WILDCARD_ENUM_MATCH_ARM,\n+                wildcard_span,\n+                message,\n+                \"try this\",\n+                suggestions.join(\" | \"),\n+                Applicability::MaybeIncorrect,\n+            );\n+        },\n+    };\n+}\n+\n+enum CommonPrefixSearcher<'a> {\n+    None,\n+    Path(&'a [PathSegment<'a>]),\n+    Mixed,\n+}\n+impl<'a> CommonPrefixSearcher<'a> {\n+    fn with_path(&mut self, path: &'a [PathSegment<'a>]) {\n+        match path {\n+            [path @ .., _] => self.with_prefix(path),\n+            [] => (),\n+        }\n+    }\n+\n+    fn with_prefix(&mut self, path: &'a [PathSegment<'a>]) {\n+        match self {\n+            Self::None => *self = Self::Path(path),\n+            Self::Path(self_path)\n+                if path\n+                    .iter()\n+                    .map(|p| p.ident.name)\n+                    .eq(self_path.iter().map(|p| p.ident.name)) => {},\n+            Self::Path(_) => *self = Self::Mixed,\n+            Self::Mixed => (),\n+        }\n+    }\n+}\n+\n+fn is_hidden(cx: &LateContext<'_>, variant_def: &VariantDef) -> bool {\n+    cx.tcx.is_doc_hidden(variant_def.def_id) || cx.tcx.has_attr(variant_def.def_id, sym::unstable)\n+}"}, {"sha": "bc16f17b6196e420184860ce3dd731f9eeeebdbe", "filename": "clippy_lints/src/matches/match_wild_err_arm.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_err_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_err_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_err_arm.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,51 @@\n+use clippy_utils::diagnostics::span_lint_and_note;\n+use clippy_utils::macros::{is_panic, root_macro_call};\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::visitors::is_local_used;\n+use clippy_utils::{is_wild, peel_blocks_with_stmt};\n+use rustc_hir::{Arm, Expr, PatKind};\n+use rustc_lint::LateContext;\n+use rustc_span::symbol::{kw, sym};\n+\n+use super::MATCH_WILD_ERR_ARM;\n+\n+pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, ex: &Expr<'tcx>, arms: &[Arm<'tcx>]) {\n+    let ex_ty = cx.typeck_results().expr_ty(ex).peel_refs();\n+    if is_type_diagnostic_item(cx, ex_ty, sym::Result) {\n+        for arm in arms {\n+            if let PatKind::TupleStruct(ref path, inner, _) = arm.pat.kind {\n+                let path_str = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_qpath(path, false));\n+                if path_str == \"Err\" {\n+                    let mut matching_wild = inner.iter().any(is_wild);\n+                    let mut ident_bind_name = kw::Underscore;\n+                    if !matching_wild {\n+                        // Looking for unused bindings (i.e.: `_e`)\n+                        for pat in inner.iter() {\n+                            if let PatKind::Binding(_, id, ident, None) = pat.kind {\n+                                if ident.as_str().starts_with('_') && !is_local_used(cx, arm.body, id) {\n+                                    ident_bind_name = ident.name;\n+                                    matching_wild = true;\n+                                }\n+                            }\n+                        }\n+                    }\n+                    if_chain! {\n+                        if matching_wild;\n+                        if let Some(macro_call) = root_macro_call(peel_blocks_with_stmt(arm.body).span);\n+                        if is_panic(cx, macro_call.def_id);\n+                        then {\n+                            // `Err(_)` or `Err(_e)` arm with `panic!` found\n+                            span_lint_and_note(cx,\n+                                MATCH_WILD_ERR_ARM,\n+                                arm.pat.span,\n+                                &format!(\"`Err({})` matches all errors\", ident_bind_name),\n+                                None,\n+                                \"match each error separately or use the error output, or use `.except(msg)` if the error case is unreachable\",\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "3d8391bce2b28ff49a7c0e87fa20bec7f9700684", "filename": "clippy_lints/src/matches/mod.rs", "status": "added", "additions": 796, "deletions": 0, "changes": 796, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,796 @@\n+use clippy_utils::source::{snippet_opt, span_starts_with, walk_span_to_context};\n+use clippy_utils::{meets_msrv, msrvs};\n+use rustc_hir::{Arm, Expr, ExprKind, Local, MatchSource, Pat};\n+use rustc_lexer::{tokenize, TokenKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::{Span, SpanData, SyntaxContext};\n+\n+mod infallible_destructuring_match;\n+mod match_as_ref;\n+mod match_bool;\n+mod match_like_matches;\n+mod match_ref_pats;\n+mod match_same_arms;\n+mod match_single_binding;\n+mod match_wild_enum;\n+mod match_wild_err_arm;\n+mod needless_match;\n+mod overlapping_arms;\n+mod redundant_pattern_match;\n+mod rest_pat_in_fully_bound_struct;\n+mod single_match;\n+mod wild_in_or_pats;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for matches with a single arm where an `if let`\n+    /// will usually suffice.\n+    ///\n+    /// ### Why is this bad?\n+    /// Just readability \u2013 `if let` nests less than a `match`.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # fn bar(stool: &str) {}\n+    /// # let x = Some(\"abc\");\n+    /// // Bad\n+    /// match x {\n+    ///     Some(ref foo) => bar(foo),\n+    ///     _ => (),\n+    /// }\n+    ///\n+    /// // Good\n+    /// if let Some(ref foo) = x {\n+    ///     bar(foo);\n+    /// }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub SINGLE_MATCH,\n+    style,\n+    \"a `match` statement with a single nontrivial arm (i.e., where the other arm is `_ => {}`) instead of `if let`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for matches with two arms where an `if let else` will\n+    /// usually suffice.\n+    ///\n+    /// ### Why is this bad?\n+    /// Just readability \u2013 `if let` nests less than a `match`.\n+    ///\n+    /// ### Known problems\n+    /// Personal style preferences may differ.\n+    ///\n+    /// ### Example\n+    /// Using `match`:\n+    ///\n+    /// ```rust\n+    /// # fn bar(foo: &usize) {}\n+    /// # let other_ref: usize = 1;\n+    /// # let x: Option<&usize> = Some(&1);\n+    /// match x {\n+    ///     Some(ref foo) => bar(foo),\n+    ///     _ => bar(&other_ref),\n+    /// }\n+    /// ```\n+    ///\n+    /// Using `if let` with `else`:\n+    ///\n+    /// ```rust\n+    /// # fn bar(foo: &usize) {}\n+    /// # let other_ref: usize = 1;\n+    /// # let x: Option<&usize> = Some(&1);\n+    /// if let Some(ref foo) = x {\n+    ///     bar(foo);\n+    /// } else {\n+    ///     bar(&other_ref);\n+    /// }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub SINGLE_MATCH_ELSE,\n+    pedantic,\n+    \"a `match` statement with two arms where the second arm's pattern is a placeholder instead of a specific match pattern\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for matches where all arms match a reference,\n+    /// suggesting to remove the reference and deref the matched expression\n+    /// instead. It also checks for `if let &foo = bar` blocks.\n+    ///\n+    /// ### Why is this bad?\n+    /// It just makes the code less readable. That reference\n+    /// destructuring adds nothing to the code.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// // Bad\n+    /// match x {\n+    ///     &A(ref y) => foo(y),\n+    ///     &B => bar(),\n+    ///     _ => frob(&x),\n+    /// }\n+    ///\n+    /// // Good\n+    /// match *x {\n+    ///     A(ref y) => foo(y),\n+    ///     B => bar(),\n+    ///     _ => frob(x),\n+    /// }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub MATCH_REF_PATS,\n+    style,\n+    \"a `match` or `if let` with all arms prefixed with `&` instead of deref-ing the match expression\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for matches where match expression is a `bool`. It\n+    /// suggests to replace the expression with an `if...else` block.\n+    ///\n+    /// ### Why is this bad?\n+    /// It makes the code less readable.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # fn foo() {}\n+    /// # fn bar() {}\n+    /// let condition: bool = true;\n+    /// match condition {\n+    ///     true => foo(),\n+    ///     false => bar(),\n+    /// }\n+    /// ```\n+    /// Use if/else instead:\n+    /// ```rust\n+    /// # fn foo() {}\n+    /// # fn bar() {}\n+    /// let condition: bool = true;\n+    /// if condition {\n+    ///     foo();\n+    /// } else {\n+    ///     bar();\n+    /// }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub MATCH_BOOL,\n+    pedantic,\n+    \"a `match` on a boolean expression instead of an `if..else` block\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for overlapping match arms.\n+    ///\n+    /// ### Why is this bad?\n+    /// It is likely to be an error and if not, makes the code\n+    /// less obvious.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x = 5;\n+    /// match x {\n+    ///     1..=10 => println!(\"1 ... 10\"),\n+    ///     5..=15 => println!(\"5 ... 15\"),\n+    ///     _ => (),\n+    /// }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub MATCH_OVERLAPPING_ARM,\n+    style,\n+    \"a `match` with overlapping arms\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for arm which matches all errors with `Err(_)`\n+    /// and take drastic actions like `panic!`.\n+    ///\n+    /// ### Why is this bad?\n+    /// It is generally a bad practice, similar to\n+    /// catching all exceptions in java with `catch(Exception)`\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x: Result<i32, &str> = Ok(3);\n+    /// match x {\n+    ///     Ok(_) => println!(\"ok\"),\n+    ///     Err(_) => panic!(\"err\"),\n+    /// }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub MATCH_WILD_ERR_ARM,\n+    pedantic,\n+    \"a `match` with `Err(_)` arm and take drastic actions\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for match which is used to add a reference to an\n+    /// `Option` value.\n+    ///\n+    /// ### Why is this bad?\n+    /// Using `as_ref()` or `as_mut()` instead is shorter.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x: Option<()> = None;\n+    ///\n+    /// // Bad\n+    /// let r: Option<&()> = match x {\n+    ///     None => None,\n+    ///     Some(ref v) => Some(v),\n+    /// };\n+    ///\n+    /// // Good\n+    /// let r: Option<&()> = x.as_ref();\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub MATCH_AS_REF,\n+    complexity,\n+    \"a `match` on an Option value instead of using `as_ref()` or `as_mut`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for wildcard enum matches using `_`.\n+    ///\n+    /// ### Why is this bad?\n+    /// New enum variants added by library updates can be missed.\n+    ///\n+    /// ### Known problems\n+    /// Suggested replacements may be incorrect if guards exhaustively cover some\n+    /// variants, and also may not use correct path to enum if it's not present in the current scope.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # enum Foo { A(usize), B(usize) }\n+    /// # let x = Foo::B(1);\n+    /// // Bad\n+    /// match x {\n+    ///     Foo::A(_) => {},\n+    ///     _ => {},\n+    /// }\n+    ///\n+    /// // Good\n+    /// match x {\n+    ///     Foo::A(_) => {},\n+    ///     Foo::B(_) => {},\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.34.0\"]\n+    pub WILDCARD_ENUM_MATCH_ARM,\n+    restriction,\n+    \"a wildcard enum match arm using `_`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for wildcard enum matches for a single variant.\n+    ///\n+    /// ### Why is this bad?\n+    /// New enum variants added by library updates can be missed.\n+    ///\n+    /// ### Known problems\n+    /// Suggested replacements may not use correct path to enum\n+    /// if it's not present in the current scope.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # enum Foo { A, B, C }\n+    /// # let x = Foo::B;\n+    /// // Bad\n+    /// match x {\n+    ///     Foo::A => {},\n+    ///     Foo::B => {},\n+    ///     _ => {},\n+    /// }\n+    ///\n+    /// // Good\n+    /// match x {\n+    ///     Foo::A => {},\n+    ///     Foo::B => {},\n+    ///     Foo::C => {},\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.45.0\"]\n+    pub MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n+    pedantic,\n+    \"a wildcard enum match for a single variant\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for wildcard pattern used with others patterns in same match arm.\n+    ///\n+    /// ### Why is this bad?\n+    /// Wildcard pattern already covers any other pattern as it will match anyway.\n+    /// It makes the code less readable, especially to spot wildcard pattern use in match arm.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// // Bad\n+    /// match \"foo\" {\n+    ///     \"a\" => {},\n+    ///     \"bar\" | _ => {},\n+    /// }\n+    ///\n+    /// // Good\n+    /// match \"foo\" {\n+    ///     \"a\" => {},\n+    ///     _ => {},\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.42.0\"]\n+    pub WILDCARD_IN_OR_PATTERNS,\n+    complexity,\n+    \"a wildcard pattern used with others patterns in same match arm\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for matches being used to destructure a single-variant enum\n+    /// or tuple struct where a `let` will suffice.\n+    ///\n+    /// ### Why is this bad?\n+    /// Just readability \u2013 `let` doesn't nest, whereas a `match` does.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// enum Wrapper {\n+    ///     Data(i32),\n+    /// }\n+    ///\n+    /// let wrapper = Wrapper::Data(42);\n+    ///\n+    /// let data = match wrapper {\n+    ///     Wrapper::Data(i) => i,\n+    /// };\n+    /// ```\n+    ///\n+    /// The correct use would be:\n+    /// ```rust\n+    /// enum Wrapper {\n+    ///     Data(i32),\n+    /// }\n+    ///\n+    /// let wrapper = Wrapper::Data(42);\n+    /// let Wrapper::Data(data) = wrapper;\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub INFALLIBLE_DESTRUCTURING_MATCH,\n+    style,\n+    \"a `match` statement with a single infallible arm instead of a `let`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for useless match that binds to only one value.\n+    ///\n+    /// ### Why is this bad?\n+    /// Readability and needless complexity.\n+    ///\n+    /// ### Known problems\n+    ///  Suggested replacements may be incorrect when `match`\n+    /// is actually binding temporary value, bringing a 'dropped while borrowed' error.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let a = 1;\n+    /// # let b = 2;\n+    ///\n+    /// // Bad\n+    /// match (a, b) {\n+    ///     (c, d) => {\n+    ///         // useless match\n+    ///     }\n+    /// }\n+    ///\n+    /// // Good\n+    /// let (c, d) = (a, b);\n+    /// ```\n+    #[clippy::version = \"1.43.0\"]\n+    pub MATCH_SINGLE_BINDING,\n+    complexity,\n+    \"a match with a single binding instead of using `let` statement\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for unnecessary '..' pattern binding on struct when all fields are explicitly matched.\n+    ///\n+    /// ### Why is this bad?\n+    /// Correctness and readability. It's like having a wildcard pattern after\n+    /// matching all enum variants explicitly.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # struct A { a: i32 }\n+    /// let a = A { a: 5 };\n+    ///\n+    /// // Bad\n+    /// match a {\n+    ///     A { a: 5, .. } => {},\n+    ///     _ => {},\n+    /// }\n+    ///\n+    /// // Good\n+    /// match a {\n+    ///     A { a: 5 } => {},\n+    ///     _ => {},\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.43.0\"]\n+    pub REST_PAT_IN_FULLY_BOUND_STRUCTS,\n+    restriction,\n+    \"a match on a struct that binds all fields but still uses the wildcard pattern\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Lint for redundant pattern matching over `Result`, `Option`,\n+    /// `std::task::Poll` or `std::net::IpAddr`\n+    ///\n+    /// ### Why is this bad?\n+    /// It's more concise and clear to just use the proper\n+    /// utility function\n+    ///\n+    /// ### Known problems\n+    /// This will change the drop order for the matched type. Both `if let` and\n+    /// `while let` will drop the value at the end of the block, both `if` and `while` will drop the\n+    /// value before entering the block. For most types this change will not matter, but for a few\n+    /// types this will not be an acceptable change (e.g. locks). See the\n+    /// [reference](https://doc.rust-lang.org/reference/destructors.html#drop-scopes) for more about\n+    /// drop order.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # use std::task::Poll;\n+    /// # use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+    /// if let Ok(_) = Ok::<i32, i32>(42) {}\n+    /// if let Err(_) = Err::<i32, i32>(42) {}\n+    /// if let None = None::<()> {}\n+    /// if let Some(_) = Some(42) {}\n+    /// if let Poll::Pending = Poll::Pending::<()> {}\n+    /// if let Poll::Ready(_) = Poll::Ready(42) {}\n+    /// if let IpAddr::V4(_) = IpAddr::V4(Ipv4Addr::LOCALHOST) {}\n+    /// if let IpAddr::V6(_) = IpAddr::V6(Ipv6Addr::LOCALHOST) {}\n+    /// match Ok::<i32, i32>(42) {\n+    ///     Ok(_) => true,\n+    ///     Err(_) => false,\n+    /// };\n+    /// ```\n+    ///\n+    /// The more idiomatic use would be:\n+    ///\n+    /// ```rust\n+    /// # use std::task::Poll;\n+    /// # use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+    /// if Ok::<i32, i32>(42).is_ok() {}\n+    /// if Err::<i32, i32>(42).is_err() {}\n+    /// if None::<()>.is_none() {}\n+    /// if Some(42).is_some() {}\n+    /// if Poll::Pending::<()>.is_pending() {}\n+    /// if Poll::Ready(42).is_ready() {}\n+    /// if IpAddr::V4(Ipv4Addr::LOCALHOST).is_ipv4() {}\n+    /// if IpAddr::V6(Ipv6Addr::LOCALHOST).is_ipv6() {}\n+    /// Ok::<i32, i32>(42).is_ok();\n+    /// ```\n+    #[clippy::version = \"1.31.0\"]\n+    pub REDUNDANT_PATTERN_MATCHING,\n+    style,\n+    \"use the proper utility function avoiding an `if let`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `match`  or `if let` expressions producing a\n+    /// `bool` that could be written using `matches!`\n+    ///\n+    /// ### Why is this bad?\n+    /// Readability and needless complexity.\n+    ///\n+    /// ### Known problems\n+    /// This lint falsely triggers, if there are arms with\n+    /// `cfg` attributes that remove an arm evaluating to `false`.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x = Some(5);\n+    ///\n+    /// // Bad\n+    /// let a = match x {\n+    ///     Some(0) => true,\n+    ///     _ => false,\n+    /// };\n+    ///\n+    /// let a = if let Some(0) = x {\n+    ///     true\n+    /// } else {\n+    ///     false\n+    /// };\n+    ///\n+    /// // Good\n+    /// let a = matches!(x, Some(0));\n+    /// ```\n+    #[clippy::version = \"1.47.0\"]\n+    pub MATCH_LIKE_MATCHES_MACRO,\n+    style,\n+    \"a match that could be written with the matches! macro\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `match` with identical arm bodies.\n+    ///\n+    /// ### Why is this bad?\n+    /// This is probably a copy & paste error. If arm bodies\n+    /// are the same on purpose, you can factor them\n+    /// [using `|`](https://doc.rust-lang.org/book/patterns.html#multiple-patterns).\n+    ///\n+    /// ### Known problems\n+    /// False positive possible with order dependent `match`\n+    /// (see issue\n+    /// [#860](https://github.com/rust-lang/rust-clippy/issues/860)).\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// match foo {\n+    ///     Bar => bar(),\n+    ///     Quz => quz(),\n+    ///     Baz => bar(), // <= oops\n+    /// }\n+    /// ```\n+    ///\n+    /// This should probably be\n+    /// ```rust,ignore\n+    /// match foo {\n+    ///     Bar => bar(),\n+    ///     Quz => quz(),\n+    ///     Baz => baz(), // <= fixed\n+    /// }\n+    /// ```\n+    ///\n+    /// or if the original code was not a typo:\n+    /// ```rust,ignore\n+    /// match foo {\n+    ///     Bar | Baz => bar(), // <= shows the intent better\n+    ///     Quz => quz(),\n+    /// }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub MATCH_SAME_ARMS,\n+    pedantic,\n+    \"`match` with identical arm bodies\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for unnecessary `match` or match-like `if let` returns for `Option` and `Result`\n+    /// when function signatures are the same.\n+    ///\n+    /// ### Why is this bad?\n+    /// This `match` block does nothing and might not be what the coder intended.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// fn foo() -> Result<(), i32> {\n+    ///     match result {\n+    ///         Ok(val) => Ok(val),\n+    ///         Err(err) => Err(err),\n+    ///     }\n+    /// }\n+    ///\n+    /// fn bar() -> Option<i32> {\n+    ///     if let Some(val) = option {\n+    ///         Some(val)\n+    ///     } else {\n+    ///         None\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// Could be replaced as\n+    ///\n+    /// ```rust,ignore\n+    /// fn foo() -> Result<(), i32> {\n+    ///     result\n+    /// }\n+    ///\n+    /// fn bar() -> Option<i32> {\n+    ///     option\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.61.0\"]\n+    pub NEEDLESS_MATCH,\n+    complexity,\n+    \"`match` or match-like `if let` that are unnecessary\"\n+}\n+\n+#[derive(Default)]\n+pub struct Matches {\n+    msrv: Option<RustcVersion>,\n+    infallible_destructuring_match_linted: bool,\n+}\n+\n+impl Matches {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self {\n+            msrv,\n+            ..Matches::default()\n+        }\n+    }\n+}\n+\n+impl_lint_pass!(Matches => [\n+    SINGLE_MATCH,\n+    MATCH_REF_PATS,\n+    MATCH_BOOL,\n+    SINGLE_MATCH_ELSE,\n+    MATCH_OVERLAPPING_ARM,\n+    MATCH_WILD_ERR_ARM,\n+    MATCH_AS_REF,\n+    WILDCARD_ENUM_MATCH_ARM,\n+    MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n+    WILDCARD_IN_OR_PATTERNS,\n+    MATCH_SINGLE_BINDING,\n+    INFALLIBLE_DESTRUCTURING_MATCH,\n+    REST_PAT_IN_FULLY_BOUND_STRUCTS,\n+    REDUNDANT_PATTERN_MATCHING,\n+    MATCH_LIKE_MATCHES_MACRO,\n+    MATCH_SAME_ARMS,\n+    NEEDLESS_MATCH,\n+]);\n+\n+impl<'tcx> LateLintPass<'tcx> for Matches {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if expr.span.from_expansion() {\n+            return;\n+        }\n+\n+        if let ExprKind::Match(ex, arms, source) = expr.kind {\n+            if !span_starts_with(cx, expr.span, \"match\") {\n+                return;\n+            }\n+            if !contains_cfg_arm(cx, expr, ex, arms) {\n+                if source == MatchSource::Normal {\n+                    if !(meets_msrv(self.msrv, msrvs::MATCHES_MACRO)\n+                        && match_like_matches::check_match(cx, expr, ex, arms))\n+                    {\n+                        match_same_arms::check(cx, arms);\n+                    }\n+\n+                    redundant_pattern_match::check_match(cx, expr, ex, arms);\n+                    single_match::check(cx, ex, arms, expr);\n+                    match_bool::check(cx, ex, arms, expr);\n+                    overlapping_arms::check(cx, ex, arms);\n+                    match_wild_enum::check(cx, ex, arms);\n+                    match_as_ref::check(cx, ex, arms, expr);\n+                    needless_match::check_match(cx, ex, arms, expr);\n+\n+                    if self.infallible_destructuring_match_linted {\n+                        self.infallible_destructuring_match_linted = false;\n+                    } else {\n+                        match_single_binding::check(cx, ex, arms, expr);\n+                    }\n+                }\n+                match_ref_pats::check(cx, ex, arms.iter().map(|el| el.pat), expr);\n+            }\n+\n+            // These don't depend on a relationship between multiple arms\n+            match_wild_err_arm::check(cx, ex, arms);\n+            wild_in_or_pats::check(cx, arms);\n+        } else {\n+            if meets_msrv(self.msrv, msrvs::MATCHES_MACRO) {\n+                match_like_matches::check(cx, expr);\n+            }\n+            redundant_pattern_match::check(cx, expr);\n+            needless_match::check(cx, expr);\n+        }\n+    }\n+\n+    fn check_local(&mut self, cx: &LateContext<'tcx>, local: &'tcx Local<'_>) {\n+        self.infallible_destructuring_match_linted |= infallible_destructuring_match::check(cx, local);\n+    }\n+\n+    fn check_pat(&mut self, cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) {\n+        rest_pat_in_fully_bound_struct::check(cx, pat);\n+    }\n+\n+    extract_msrv_attr!(LateContext);\n+}\n+\n+/// Checks if there are any arms with a `#[cfg(..)]` attribute.\n+fn contains_cfg_arm(cx: &LateContext<'_>, e: &Expr<'_>, scrutinee: &Expr<'_>, arms: &[Arm<'_>]) -> bool {\n+    let Some(scrutinee_span) = walk_span_to_context(scrutinee.span, SyntaxContext::root()) else {\n+        // Shouldn't happen, but treat this as though a `cfg` attribute were found\n+        return true;\n+    };\n+\n+    let start = scrutinee_span.hi();\n+    let mut arm_spans = arms.iter().map(|arm| {\n+        let data = arm.span.data();\n+        (data.ctxt == SyntaxContext::root()).then(|| (data.lo, data.hi))\n+    });\n+    let end = e.span.hi();\n+\n+    // Walk through all the non-code space before each match arm. The space trailing the final arm is\n+    // handled after the `try_fold` e.g.\n+    //\n+    // match foo {\n+    // _________^-                      everything between the scrutinee and arm1\n+    //|    arm1 => (),\n+    //|---^___________^                 everything before arm2\n+    //|    #[cfg(feature = \"enabled\")]\n+    //|    arm2 => some_code(),\n+    //|---^____________________^        everything before arm3\n+    //|    // some comment about arm3\n+    //|    arm3 => some_code(),\n+    //|---^____________________^        everything after arm3\n+    //|    #[cfg(feature = \"disabled\")]\n+    //|    arm4 = some_code(),\n+    //|};\n+    //|^\n+    let found = arm_spans.try_fold(start, |start, range| {\n+        let Some((end, next_start)) = range else {\n+            // Shouldn't happen as macros can't expand to match arms, but treat this as though a `cfg` attribute were\n+            // found.\n+            return Err(());\n+        };\n+        let span = SpanData {\n+            lo: start,\n+            hi: end,\n+            ctxt: SyntaxContext::root(),\n+            parent: None,\n+        }\n+        .span();\n+        (!span_contains_cfg(cx, span)).then(|| next_start).ok_or(())\n+    });\n+    match found {\n+        Ok(start) => {\n+            let span = SpanData {\n+                lo: start,\n+                hi: end,\n+                ctxt: SyntaxContext::root(),\n+                parent: None,\n+            }\n+            .span();\n+            span_contains_cfg(cx, span)\n+        },\n+        Err(()) => true,\n+    }\n+}\n+\n+/// Checks if the given span contains a `#[cfg(..)]` attribute\n+fn span_contains_cfg(cx: &LateContext<'_>, s: Span) -> bool {\n+    let Some(snip) = snippet_opt(cx, s) else {\n+        // Assume true. This would require either an invalid span, or one which crosses file boundaries.\n+        return true;\n+    };\n+    let mut pos = 0usize;\n+    let mut iter = tokenize(&snip).map(|t| {\n+        let start = pos;\n+        pos += t.len;\n+        (t.kind, start..pos)\n+    });\n+\n+    // Search for the token sequence [`#`, `[`, `cfg`]\n+    while iter.any(|(t, _)| matches!(t, TokenKind::Pound)) {\n+        let mut iter = iter.by_ref().skip_while(|(t, _)| {\n+            matches!(\n+                t,\n+                TokenKind::Whitespace | TokenKind::LineComment { .. } | TokenKind::BlockComment { .. }\n+            )\n+        });\n+        if matches!(iter.next(), Some((TokenKind::OpenBracket, _)))\n+            && matches!(iter.next(), Some((TokenKind::Ident, range)) if &snip[range.clone()] == \"cfg\")\n+        {\n+            return true;\n+        }\n+    }\n+    false\n+}"}, {"sha": "f920ad4651f9d4b8c8d304cfb55bd1e99eb1d73c", "filename": "clippy_lints/src/matches/needless_match.rs", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,209 @@\n+use super::NEEDLESS_MATCH;\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::ty::{is_type_diagnostic_item, same_type_and_consts};\n+use clippy_utils::{\n+    eq_expr_value, get_parent_expr_for_hir, get_parent_node, higher, is_else_clause, is_lang_ctor, over,\n+    peel_blocks_with_stmt,\n+};\n+use rustc_errors::Applicability;\n+use rustc_hir::LangItem::OptionNone;\n+use rustc_hir::{Arm, BindingAnnotation, Expr, ExprKind, FnRetTy, Node, Pat, PatKind, Path, QPath};\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+use rustc_typeck::hir_ty_to_ty;\n+\n+pub(crate) fn check_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n+    if arms.len() > 1 && expr_ty_matches_p_ty(cx, ex, expr) && check_all_arms(cx, ex, arms) {\n+        let mut applicability = Applicability::MachineApplicable;\n+        span_lint_and_sugg(\n+            cx,\n+            NEEDLESS_MATCH,\n+            expr.span,\n+            \"this match expression is unnecessary\",\n+            \"replace it with\",\n+            snippet_with_applicability(cx, ex.span, \"..\", &mut applicability).to_string(),\n+            applicability,\n+        );\n+    }\n+}\n+\n+/// Check for nop `if let` expression that assembled as unnecessary match\n+///\n+/// ```rust,ignore\n+/// if let Some(a) = option {\n+///     Some(a)\n+/// } else {\n+///     None\n+/// }\n+/// ```\n+/// OR\n+/// ```rust,ignore\n+/// if let SomeEnum::A = some_enum {\n+///     SomeEnum::A\n+/// } else if let SomeEnum::B = some_enum {\n+///     SomeEnum::B\n+/// } else {\n+///     some_enum\n+/// }\n+/// ```\n+pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>) {\n+    if let Some(ref if_let) = higher::IfLet::hir(cx, ex) {\n+        if !is_else_clause(cx.tcx, ex) && expr_ty_matches_p_ty(cx, if_let.let_expr, ex) && check_if_let(cx, if_let) {\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                NEEDLESS_MATCH,\n+                ex.span,\n+                \"this if-let expression is unnecessary\",\n+                \"replace it with\",\n+                snippet_with_applicability(cx, if_let.let_expr.span, \"..\", &mut applicability).to_string(),\n+                applicability,\n+            );\n+        }\n+    }\n+}\n+\n+fn check_all_arms(cx: &LateContext<'_>, match_expr: &Expr<'_>, arms: &[Arm<'_>]) -> bool {\n+    for arm in arms {\n+        let arm_expr = peel_blocks_with_stmt(arm.body);\n+        if let PatKind::Wild = arm.pat.kind {\n+            return eq_expr_value(cx, match_expr, strip_return(arm_expr));\n+        } else if !pat_same_as_expr(arm.pat, arm_expr) {\n+            return false;\n+        }\n+    }\n+\n+    true\n+}\n+\n+fn check_if_let(cx: &LateContext<'_>, if_let: &higher::IfLet<'_>) -> bool {\n+    if let Some(if_else) = if_let.if_else {\n+        if !pat_same_as_expr(if_let.let_pat, peel_blocks_with_stmt(if_let.if_then)) {\n+            return false;\n+        }\n+\n+        // Recursively check for each `else if let` phrase,\n+        if let Some(ref nested_if_let) = higher::IfLet::hir(cx, if_else) {\n+            return check_if_let(cx, nested_if_let);\n+        }\n+\n+        if matches!(if_else.kind, ExprKind::Block(..)) {\n+            let else_expr = peel_blocks_with_stmt(if_else);\n+            if matches!(else_expr.kind, ExprKind::Block(..)) {\n+                return false;\n+            }\n+            let ret = strip_return(else_expr);\n+            let let_expr_ty = cx.typeck_results().expr_ty(if_let.let_expr);\n+            if is_type_diagnostic_item(cx, let_expr_ty, sym::Option) {\n+                if let ExprKind::Path(ref qpath) = ret.kind {\n+                    return is_lang_ctor(cx, qpath, OptionNone) || eq_expr_value(cx, if_let.let_expr, ret);\n+                }\n+                return false;\n+            }\n+            return eq_expr_value(cx, if_let.let_expr, ret);\n+        }\n+    }\n+\n+    false\n+}\n+\n+/// Strip `return` keyword if the expression type is `ExprKind::Ret`.\n+fn strip_return<'hir>(expr: &'hir Expr<'hir>) -> &'hir Expr<'hir> {\n+    if let ExprKind::Ret(Some(ret)) = expr.kind {\n+        ret\n+    } else {\n+        expr\n+    }\n+}\n+\n+/// Manually check for coercion casting by checking if the type of the match operand or let expr\n+/// differs with the assigned local variable or the function return type.\n+fn expr_ty_matches_p_ty(cx: &LateContext<'_>, expr: &Expr<'_>, p_expr: &Expr<'_>) -> bool {\n+    if let Some(p_node) = get_parent_node(cx.tcx, p_expr.hir_id) {\n+        match p_node {\n+            // Compare match_expr ty with local in `let local = match match_expr {..}`\n+            Node::Local(local) => {\n+                let results = cx.typeck_results();\n+                return same_type_and_consts(results.node_type(local.hir_id), results.expr_ty(expr));\n+            },\n+            // compare match_expr ty with RetTy in `fn foo() -> RetTy`\n+            Node::Item(..) => {\n+                if let Some(fn_decl) = p_node.fn_decl() {\n+                    if let FnRetTy::Return(ret_ty) = fn_decl.output {\n+                        return same_type_and_consts(hir_ty_to_ty(cx.tcx, ret_ty), cx.typeck_results().expr_ty(expr));\n+                    }\n+                }\n+            },\n+            // check the parent expr for this whole block `{ match match_expr {..} }`\n+            Node::Block(block) => {\n+                if let Some(block_parent_expr) = get_parent_expr_for_hir(cx, block.hir_id) {\n+                    return expr_ty_matches_p_ty(cx, expr, block_parent_expr);\n+                }\n+            },\n+            // recursively call on `if xxx {..}` etc.\n+            Node::Expr(p_expr) => {\n+                return expr_ty_matches_p_ty(cx, expr, p_expr);\n+            },\n+            _ => {},\n+        }\n+    }\n+    false\n+}\n+\n+fn pat_same_as_expr(pat: &Pat<'_>, expr: &Expr<'_>) -> bool {\n+    let expr = strip_return(expr);\n+    match (&pat.kind, &expr.kind) {\n+        // Example: `Some(val) => Some(val)`\n+        (PatKind::TupleStruct(QPath::Resolved(_, path), tuple_params, _), ExprKind::Call(call_expr, call_params)) => {\n+            if let ExprKind::Path(QPath::Resolved(_, call_path)) = call_expr.kind {\n+                return over(path.segments, call_path.segments, |pat_seg, call_seg| {\n+                    pat_seg.ident.name == call_seg.ident.name\n+                }) && same_non_ref_symbols(tuple_params, call_params);\n+            }\n+        },\n+        // Example: `val => val`\n+        (\n+            PatKind::Binding(annot, _, pat_ident, _),\n+            ExprKind::Path(QPath::Resolved(\n+                _,\n+                Path {\n+                    segments: [first_seg, ..],\n+                    ..\n+                },\n+            )),\n+        ) => {\n+            return !matches!(annot, BindingAnnotation::Ref | BindingAnnotation::RefMut)\n+                && pat_ident.name == first_seg.ident.name;\n+        },\n+        // Example: `Custom::TypeA => Custom::TypeB`, or `None => None`\n+        (PatKind::Path(QPath::Resolved(_, p_path)), ExprKind::Path(QPath::Resolved(_, e_path))) => {\n+            return over(p_path.segments, e_path.segments, |p_seg, e_seg| {\n+                p_seg.ident.name == e_seg.ident.name\n+            });\n+        },\n+        // Example: `5 => 5`\n+        (PatKind::Lit(pat_lit_expr), ExprKind::Lit(expr_spanned)) => {\n+            if let ExprKind::Lit(pat_spanned) = &pat_lit_expr.kind {\n+                return pat_spanned.node == expr_spanned.node;\n+            }\n+        },\n+        _ => {},\n+    }\n+\n+    false\n+}\n+\n+fn same_non_ref_symbols(pats: &[Pat<'_>], exprs: &[Expr<'_>]) -> bool {\n+    if pats.len() != exprs.len() {\n+        return false;\n+    }\n+\n+    for i in 0..pats.len() {\n+        if !pat_same_as_expr(&pats[i], &exprs[i]) {\n+            return false;\n+        }\n+    }\n+\n+    true\n+}"}, {"sha": "c0b3e95b18523fcbd40bb7523be6d0b96d6b6731", "filename": "clippy_lints/src/matches/overlapping_arms.rs", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatches%2Foverlapping_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatches%2Foverlapping_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Foverlapping_arms.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,179 @@\n+use clippy_utils::consts::{constant, constant_full_int, miri_to_const, FullInt};\n+use clippy_utils::diagnostics::span_lint_and_note;\n+use core::cmp::Ordering;\n+use rustc_hir::{Arm, Expr, PatKind, RangeEnd};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::Ty;\n+use rustc_span::Span;\n+\n+use super::MATCH_OVERLAPPING_ARM;\n+\n+pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, ex: &'tcx Expr<'_>, arms: &'tcx [Arm<'_>]) {\n+    if arms.len() >= 2 && cx.typeck_results().expr_ty(ex).is_integral() {\n+        let ranges = all_ranges(cx, arms, cx.typeck_results().expr_ty(ex));\n+        if !ranges.is_empty() {\n+            if let Some((start, end)) = overlapping(&ranges) {\n+                span_lint_and_note(\n+                    cx,\n+                    MATCH_OVERLAPPING_ARM,\n+                    start.span,\n+                    \"some ranges overlap\",\n+                    Some(end.span),\n+                    \"overlaps with this\",\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+/// Gets the ranges for each range pattern arm. Applies `ty` bounds for open ranges.\n+fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>) -> Vec<SpannedRange<FullInt>> {\n+    arms.iter()\n+        .filter_map(|arm| {\n+            if let Arm { pat, guard: None, .. } = *arm {\n+                if let PatKind::Range(ref lhs, ref rhs, range_end) = pat.kind {\n+                    let lhs_const = match lhs {\n+                        Some(lhs) => constant(cx, cx.typeck_results(), lhs)?.0,\n+                        None => miri_to_const(ty.numeric_min_val(cx.tcx)?)?,\n+                    };\n+                    let rhs_const = match rhs {\n+                        Some(rhs) => constant(cx, cx.typeck_results(), rhs)?.0,\n+                        None => miri_to_const(ty.numeric_max_val(cx.tcx)?)?,\n+                    };\n+                    let lhs_val = lhs_const.int_value(cx, ty)?;\n+                    let rhs_val = rhs_const.int_value(cx, ty)?;\n+                    let rhs_bound = match range_end {\n+                        RangeEnd::Included => EndBound::Included(rhs_val),\n+                        RangeEnd::Excluded => EndBound::Excluded(rhs_val),\n+                    };\n+                    return Some(SpannedRange {\n+                        span: pat.span,\n+                        node: (lhs_val, rhs_bound),\n+                    });\n+                }\n+\n+                if let PatKind::Lit(value) = pat.kind {\n+                    let value = constant_full_int(cx, cx.typeck_results(), value)?;\n+                    return Some(SpannedRange {\n+                        span: pat.span,\n+                        node: (value, EndBound::Included(value)),\n+                    });\n+                }\n+            }\n+            None\n+        })\n+        .collect()\n+}\n+\n+#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n+pub enum EndBound<T> {\n+    Included(T),\n+    Excluded(T),\n+}\n+\n+#[derive(Debug, Eq, PartialEq)]\n+struct SpannedRange<T> {\n+    pub span: Span,\n+    pub node: (T, EndBound<T>),\n+}\n+\n+fn overlapping<T>(ranges: &[SpannedRange<T>]) -> Option<(&SpannedRange<T>, &SpannedRange<T>)>\n+where\n+    T: Copy + Ord,\n+{\n+    #[derive(Copy, Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]\n+    enum BoundKind {\n+        EndExcluded,\n+        Start,\n+        EndIncluded,\n+    }\n+\n+    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+    struct RangeBound<'a, T>(T, BoundKind, &'a SpannedRange<T>);\n+\n+    impl<'a, T: Copy + Ord> PartialOrd for RangeBound<'a, T> {\n+        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+            Some(self.cmp(other))\n+        }\n+    }\n+\n+    impl<'a, T: Copy + Ord> Ord for RangeBound<'a, T> {\n+        fn cmp(&self, RangeBound(other_value, other_kind, _): &Self) -> Ordering {\n+            let RangeBound(self_value, self_kind, _) = *self;\n+            (self_value, self_kind).cmp(&(*other_value, *other_kind))\n+        }\n+    }\n+\n+    let mut values = Vec::with_capacity(2 * ranges.len());\n+\n+    for r @ SpannedRange { node: (start, end), .. } in ranges {\n+        values.push(RangeBound(*start, BoundKind::Start, r));\n+        values.push(match end {\n+            EndBound::Excluded(val) => RangeBound(*val, BoundKind::EndExcluded, r),\n+            EndBound::Included(val) => RangeBound(*val, BoundKind::EndIncluded, r),\n+        });\n+    }\n+\n+    values.sort();\n+\n+    let mut started = vec![];\n+\n+    for RangeBound(_, kind, range) in values {\n+        match kind {\n+            BoundKind::Start => started.push(range),\n+            BoundKind::EndExcluded | BoundKind::EndIncluded => {\n+                let mut overlap = None;\n+\n+                while let Some(last_started) = started.pop() {\n+                    if last_started == range {\n+                        break;\n+                    }\n+                    overlap = Some(last_started);\n+                }\n+\n+                if let Some(first_overlapping) = overlap {\n+                    return Some((range, first_overlapping));\n+                }\n+            },\n+        }\n+    }\n+\n+    None\n+}\n+\n+#[test]\n+fn test_overlapping() {\n+    use rustc_span::source_map::DUMMY_SP;\n+\n+    let sp = |s, e| SpannedRange {\n+        span: DUMMY_SP,\n+        node: (s, e),\n+    };\n+\n+    assert_eq!(None, overlapping::<u8>(&[]));\n+    assert_eq!(None, overlapping(&[sp(1, EndBound::Included(4))]));\n+    assert_eq!(\n+        None,\n+        overlapping(&[sp(1, EndBound::Included(4)), sp(5, EndBound::Included(6))])\n+    );\n+    assert_eq!(\n+        None,\n+        overlapping(&[\n+            sp(1, EndBound::Included(4)),\n+            sp(5, EndBound::Included(6)),\n+            sp(10, EndBound::Included(11))\n+        ],)\n+    );\n+    assert_eq!(\n+        Some((&sp(1, EndBound::Included(4)), &sp(3, EndBound::Included(6)))),\n+        overlapping(&[sp(1, EndBound::Included(4)), sp(3, EndBound::Included(6))])\n+    );\n+    assert_eq!(\n+        Some((&sp(5, EndBound::Included(6)), &sp(6, EndBound::Included(11)))),\n+        overlapping(&[\n+            sp(1, EndBound::Included(4)),\n+            sp(5, EndBound::Included(6)),\n+            sp(6, EndBound::Included(11))\n+        ],)\n+    );\n+}"}, {"sha": "1a8b9d15f370f1e3df5843b5b6bf22b6d36ae1fc", "filename": "clippy_lints/src/matches/redundant_pattern_match.rs", "status": "added", "additions": 378, "deletions": 0, "changes": 378, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,378 @@\n+use super::REDUNDANT_PATTERN_MATCHING;\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::source::snippet;\n+use clippy_utils::sugg::Sugg;\n+use clippy_utils::ty::needs_ordered_drop;\n+use clippy_utils::{higher, match_def_path};\n+use clippy_utils::{is_lang_ctor, is_trait_method, paths};\n+use if_chain::if_chain;\n+use rustc_ast::ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir::LangItem::{OptionNone, PollPending};\n+use rustc_hir::{\n+    intravisit::{walk_expr, Visitor},\n+    Arm, Block, Expr, ExprKind, Node, Pat, PatKind, QPath, UnOp,\n+};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, subst::GenericArgKind, DefIdTree, Ty};\n+use rustc_span::sym;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+    if let Some(higher::IfLet {\n+        if_else,\n+        let_pat,\n+        let_expr,\n+        ..\n+    }) = higher::IfLet::hir(cx, expr)\n+    {\n+        find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"if\", if_else.is_some());\n+    } else if let Some(higher::WhileLet { let_pat, let_expr, .. }) = higher::WhileLet::hir(expr) {\n+        find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"while\", false);\n+    }\n+}\n+\n+// Extract the generic arguments out of a type\n+fn try_get_generic_ty(ty: Ty<'_>, index: usize) -> Option<Ty<'_>> {\n+    if_chain! {\n+        if let ty::Adt(_, subs) = ty.kind();\n+        if let Some(sub) = subs.get(index);\n+        if let GenericArgKind::Type(sub_ty) = sub.unpack();\n+        then {\n+            Some(sub_ty)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+// Checks if there are any temporaries created in the given expression for which drop order\n+// matters.\n+fn temporaries_need_ordered_drop<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n+    struct V<'a, 'tcx> {\n+        cx: &'a LateContext<'tcx>,\n+        res: bool,\n+    }\n+    impl<'a, 'tcx> Visitor<'tcx> for V<'a, 'tcx> {\n+        fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+            match expr.kind {\n+                // Taking the reference of a value leaves a temporary\n+                // e.g. In `&String::new()` the string is a temporary value.\n+                // Remaining fields are temporary values\n+                // e.g. In `(String::new(), 0).1` the string is a temporary value.\n+                ExprKind::AddrOf(_, _, expr) | ExprKind::Field(expr, _) => {\n+                    if !matches!(expr.kind, ExprKind::Path(_)) {\n+                        if needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(expr)) {\n+                            self.res = true;\n+                        } else {\n+                            self.visit_expr(expr);\n+                        }\n+                    }\n+                },\n+                // the base type is alway taken by reference.\n+                // e.g. In `(vec![0])[0]` the vector is a temporary value.\n+                ExprKind::Index(base, index) => {\n+                    if !matches!(base.kind, ExprKind::Path(_)) {\n+                        if needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(base)) {\n+                            self.res = true;\n+                        } else {\n+                            self.visit_expr(base);\n+                        }\n+                    }\n+                    self.visit_expr(index);\n+                },\n+                // Method calls can take self by reference.\n+                // e.g. In `String::new().len()` the string is a temporary value.\n+                ExprKind::MethodCall(_, [self_arg, args @ ..], _) => {\n+                    if !matches!(self_arg.kind, ExprKind::Path(_)) {\n+                        let self_by_ref = self\n+                            .cx\n+                            .typeck_results()\n+                            .type_dependent_def_id(expr.hir_id)\n+                            .map_or(false, |id| self.cx.tcx.fn_sig(id).skip_binder().inputs()[0].is_ref());\n+                        if self_by_ref && needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(self_arg)) {\n+                            self.res = true;\n+                        } else {\n+                            self.visit_expr(self_arg);\n+                        }\n+                    }\n+                    args.iter().for_each(|arg| self.visit_expr(arg));\n+                },\n+                // Either explicitly drops values, or changes control flow.\n+                ExprKind::DropTemps(_)\n+                | ExprKind::Ret(_)\n+                | ExprKind::Break(..)\n+                | ExprKind::Yield(..)\n+                | ExprKind::Block(Block { expr: None, .. }, _)\n+                | ExprKind::Loop(..) => (),\n+\n+                // Only consider the final expression.\n+                ExprKind::Block(Block { expr: Some(expr), .. }, _) => self.visit_expr(expr),\n+\n+                _ => walk_expr(self, expr),\n+            }\n+        }\n+    }\n+\n+    let mut v = V { cx, res: false };\n+    v.visit_expr(expr);\n+    v.res\n+}\n+\n+fn find_sugg_for_if_let<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    let_pat: &Pat<'_>,\n+    let_expr: &'tcx Expr<'_>,\n+    keyword: &'static str,\n+    has_else: bool,\n+) {\n+    // also look inside refs\n+    // if we have &None for example, peel it so we can detect \"if let None = x\"\n+    let check_pat = match let_pat.kind {\n+        PatKind::Ref(inner, _mutability) => inner,\n+        _ => let_pat,\n+    };\n+    let op_ty = cx.typeck_results().expr_ty(let_expr);\n+    // Determine which function should be used, and the type contained by the corresponding\n+    // variant.\n+    let (good_method, inner_ty) = match check_pat.kind {\n+        PatKind::TupleStruct(ref qpath, [sub_pat], _) => {\n+            if let PatKind::Wild = sub_pat.kind {\n+                let res = cx.typeck_results().qpath_res(qpath, check_pat.hir_id);\n+                let Some(id) = res.opt_def_id().map(|ctor_id| cx.tcx.parent(ctor_id)) else { return };\n+                let lang_items = cx.tcx.lang_items();\n+                if Some(id) == lang_items.result_ok_variant() {\n+                    (\"is_ok()\", try_get_generic_ty(op_ty, 0).unwrap_or(op_ty))\n+                } else if Some(id) == lang_items.result_err_variant() {\n+                    (\"is_err()\", try_get_generic_ty(op_ty, 1).unwrap_or(op_ty))\n+                } else if Some(id) == lang_items.option_some_variant() {\n+                    (\"is_some()\", op_ty)\n+                } else if Some(id) == lang_items.poll_ready_variant() {\n+                    (\"is_ready()\", op_ty)\n+                } else if match_def_path(cx, id, &paths::IPADDR_V4) {\n+                    (\"is_ipv4()\", op_ty)\n+                } else if match_def_path(cx, id, &paths::IPADDR_V6) {\n+                    (\"is_ipv6()\", op_ty)\n+                } else {\n+                    return;\n+                }\n+            } else {\n+                return;\n+            }\n+        },\n+        PatKind::Path(ref path) => {\n+            let method = if is_lang_ctor(cx, path, OptionNone) {\n+                \"is_none()\"\n+            } else if is_lang_ctor(cx, path, PollPending) {\n+                \"is_pending()\"\n+            } else {\n+                return;\n+            };\n+            // `None` and `Pending` don't have an inner type.\n+            (method, cx.tcx.types.unit)\n+        },\n+        _ => return,\n+    };\n+\n+    // If this is the last expression in a block or there is an else clause then the whole\n+    // type needs to be considered, not just the inner type of the branch being matched on.\n+    // Note the last expression in a block is dropped after all local bindings.\n+    let check_ty = if has_else\n+        || (keyword == \"if\" && matches!(cx.tcx.hir().parent_iter(expr.hir_id).next(), Some((_, Node::Block(..)))))\n+    {\n+        op_ty\n+    } else {\n+        inner_ty\n+    };\n+\n+    // All temporaries created in the scrutinee expression are dropped at the same time as the\n+    // scrutinee would be, so they have to be considered as well.\n+    // e.g. in `if let Some(x) = foo.lock().unwrap().baz.as_ref() { .. }` the lock will be held\n+    // for the duration if body.\n+    let needs_drop = needs_ordered_drop(cx, check_ty) || temporaries_need_ordered_drop(cx, let_expr);\n+\n+    // check that `while_let_on_iterator` lint does not trigger\n+    if_chain! {\n+        if keyword == \"while\";\n+        if let ExprKind::MethodCall(method_path, _, _) = let_expr.kind;\n+        if method_path.ident.name == sym::next;\n+        if is_trait_method(cx, let_expr, sym::Iterator);\n+        then {\n+            return;\n+        }\n+    }\n+\n+    let result_expr = match &let_expr.kind {\n+        ExprKind::AddrOf(_, _, borrowed) => borrowed,\n+        ExprKind::Unary(UnOp::Deref, deref) => deref,\n+        _ => let_expr,\n+    };\n+\n+    span_lint_and_then(\n+        cx,\n+        REDUNDANT_PATTERN_MATCHING,\n+        let_pat.span,\n+        &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n+        |diag| {\n+            // if/while let ... = ... { ... }\n+            // ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+            let expr_span = expr.span;\n+\n+            // if/while let ... = ... { ... }\n+            //                 ^^^\n+            let op_span = result_expr.span.source_callsite();\n+\n+            // if/while let ... = ... { ... }\n+            // ^^^^^^^^^^^^^^^^^^^\n+            let span = expr_span.until(op_span.shrink_to_hi());\n+\n+            let app = if needs_drop {\n+                Applicability::MaybeIncorrect\n+            } else {\n+                Applicability::MachineApplicable\n+            };\n+\n+            let sugg = Sugg::hir_with_macro_callsite(cx, result_expr, \"_\")\n+                .maybe_par()\n+                .to_string();\n+\n+            diag.span_suggestion(span, \"try this\", format!(\"{} {}.{}\", keyword, sugg, good_method), app);\n+\n+            if needs_drop {\n+                diag.note(\"this will change drop order of the result, as well as all temporaries\");\n+                diag.note(\"add `#[allow(clippy::redundant_pattern_matching)]` if this is important\");\n+            }\n+        },\n+    );\n+}\n+\n+pub(super) fn check_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op: &Expr<'_>, arms: &[Arm<'_>]) {\n+    if arms.len() == 2 {\n+        let node_pair = (&arms[0].pat.kind, &arms[1].pat.kind);\n+\n+        let found_good_method = match node_pair {\n+            (\n+                PatKind::TupleStruct(ref path_left, patterns_left, _),\n+                PatKind::TupleStruct(ref path_right, patterns_right, _),\n+            ) if patterns_left.len() == 1 && patterns_right.len() == 1 => {\n+                if let (PatKind::Wild, PatKind::Wild) = (&patterns_left[0].kind, &patterns_right[0].kind) {\n+                    find_good_method_for_match(\n+                        cx,\n+                        arms,\n+                        path_left,\n+                        path_right,\n+                        &paths::RESULT_OK,\n+                        &paths::RESULT_ERR,\n+                        \"is_ok()\",\n+                        \"is_err()\",\n+                    )\n+                    .or_else(|| {\n+                        find_good_method_for_match(\n+                            cx,\n+                            arms,\n+                            path_left,\n+                            path_right,\n+                            &paths::IPADDR_V4,\n+                            &paths::IPADDR_V6,\n+                            \"is_ipv4()\",\n+                            \"is_ipv6()\",\n+                        )\n+                    })\n+                } else {\n+                    None\n+                }\n+            },\n+            (PatKind::TupleStruct(ref path_left, patterns, _), PatKind::Path(ref path_right))\n+            | (PatKind::Path(ref path_left), PatKind::TupleStruct(ref path_right, patterns, _))\n+                if patterns.len() == 1 =>\n+            {\n+                if let PatKind::Wild = patterns[0].kind {\n+                    find_good_method_for_match(\n+                        cx,\n+                        arms,\n+                        path_left,\n+                        path_right,\n+                        &paths::OPTION_SOME,\n+                        &paths::OPTION_NONE,\n+                        \"is_some()\",\n+                        \"is_none()\",\n+                    )\n+                    .or_else(|| {\n+                        find_good_method_for_match(\n+                            cx,\n+                            arms,\n+                            path_left,\n+                            path_right,\n+                            &paths::POLL_READY,\n+                            &paths::POLL_PENDING,\n+                            \"is_ready()\",\n+                            \"is_pending()\",\n+                        )\n+                    })\n+                } else {\n+                    None\n+                }\n+            },\n+            _ => None,\n+        };\n+\n+        if let Some(good_method) = found_good_method {\n+            let span = expr.span.to(op.span);\n+            let result_expr = match &op.kind {\n+                ExprKind::AddrOf(_, _, borrowed) => borrowed,\n+                _ => op,\n+            };\n+            span_lint_and_then(\n+                cx,\n+                REDUNDANT_PATTERN_MATCHING,\n+                expr.span,\n+                &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n+                |diag| {\n+                    diag.span_suggestion(\n+                        span,\n+                        \"try this\",\n+                        format!(\"{}.{}\", snippet(cx, result_expr.span, \"_\"), good_method),\n+                        Applicability::MaybeIncorrect, // snippet\n+                    );\n+                },\n+            );\n+        }\n+    }\n+}\n+\n+#[expect(clippy::too_many_arguments)]\n+fn find_good_method_for_match<'a>(\n+    cx: &LateContext<'_>,\n+    arms: &[Arm<'_>],\n+    path_left: &QPath<'_>,\n+    path_right: &QPath<'_>,\n+    expected_left: &[&str],\n+    expected_right: &[&str],\n+    should_be_left: &'a str,\n+    should_be_right: &'a str,\n+) -> Option<&'a str> {\n+    let left_id = cx\n+        .typeck_results()\n+        .qpath_res(path_left, arms[0].pat.hir_id)\n+        .opt_def_id()?;\n+    let right_id = cx\n+        .typeck_results()\n+        .qpath_res(path_right, arms[1].pat.hir_id)\n+        .opt_def_id()?;\n+    let body_node_pair = if match_def_path(cx, left_id, expected_left) && match_def_path(cx, right_id, expected_right) {\n+        (&(*arms[0].body).kind, &(*arms[1].body).kind)\n+    } else if match_def_path(cx, right_id, expected_left) && match_def_path(cx, right_id, expected_right) {\n+        (&(*arms[1].body).kind, &(*arms[0].body).kind)\n+    } else {\n+        return None;\n+    };\n+\n+    match body_node_pair {\n+        (ExprKind::Lit(ref lit_left), ExprKind::Lit(ref lit_right)) => match (&lit_left.node, &lit_right.node) {\n+            (LitKind::Bool(true), LitKind::Bool(false)) => Some(should_be_left),\n+            (LitKind::Bool(false), LitKind::Bool(true)) => Some(should_be_right),\n+            _ => None,\n+        },\n+        _ => None,\n+    }\n+}"}, {"sha": "0aadb482acddad443b4161732e31cc7871937146", "filename": "clippy_lints/src/matches/rest_pat_in_fully_bound_struct.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatches%2Frest_pat_in_fully_bound_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatches%2Frest_pat_in_fully_bound_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Frest_pat_in_fully_bound_struct.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,30 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use rustc_hir::{Pat, PatKind, QPath};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+\n+use super::REST_PAT_IN_FULLY_BOUND_STRUCTS;\n+\n+pub(crate) fn check(cx: &LateContext<'_>, pat: &Pat<'_>) {\n+    if_chain! {\n+        if !pat.span.from_expansion();\n+        if let PatKind::Struct(QPath::Resolved(_, path), fields, true) = pat.kind;\n+        if let Some(def_id) = path.res.opt_def_id();\n+        let ty = cx.tcx.type_of(def_id);\n+        if let ty::Adt(def, _) = ty.kind();\n+        if def.is_struct() || def.is_union();\n+        if fields.len() == def.non_enum_variant().fields.len();\n+        if !def.non_enum_variant().is_field_list_non_exhaustive();\n+\n+        then {\n+            span_lint_and_help(\n+                cx,\n+                REST_PAT_IN_FULLY_BOUND_STRUCTS,\n+                pat.span,\n+                \"unnecessary use of `..` pattern in struct binding. All fields were already bound\",\n+                None,\n+                \"consider removing `..` from this binding\",\n+            );\n+        }\n+    }\n+}"}, {"sha": "0c4cb45d147cae84cd16e949c6e783e436a842f8", "filename": "clippy_lints/src/matches/single_match.rs", "status": "added", "additions": 269, "deletions": 0, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,269 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::{expr_block, snippet};\n+use clippy_utils::ty::{implements_trait, match_type, peel_mid_ty_refs};\n+use clippy_utils::{\n+    is_lint_allowed, is_unit_expr, is_wild, paths, peel_blocks, peel_hir_pat_refs, peel_n_hir_expr_refs,\n+};\n+use core::cmp::max;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, Pat, PatKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+\n+use super::{MATCH_BOOL, SINGLE_MATCH, SINGLE_MATCH_ELSE};\n+\n+#[rustfmt::skip]\n+pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n+    if arms.len() == 2 && arms[0].guard.is_none() && arms[1].guard.is_none() {\n+        if expr.span.from_expansion() {\n+            // Don't lint match expressions present in\n+            // macro_rules! block\n+            return;\n+        }\n+        if let PatKind::Or(..) = arms[0].pat.kind {\n+            // don't lint for or patterns for now, this makes\n+            // the lint noisy in unnecessary situations\n+            return;\n+        }\n+        let els = arms[1].body;\n+        let els = if is_unit_expr(peel_blocks(els)) {\n+            None\n+        } else if let ExprKind::Block(Block { stmts, expr: block_expr, .. }, _) = els.kind {\n+            if stmts.len() == 1 && block_expr.is_none() || stmts.is_empty() && block_expr.is_some() {\n+                // single statement/expr \"else\" block, don't lint\n+                return;\n+            }\n+            // block with 2+ statements or 1 expr and 1+ statement\n+            Some(els)\n+        } else {\n+            // not a block, don't lint\n+            return;\n+        };\n+\n+        let ty = cx.typeck_results().expr_ty(ex);\n+        if *ty.kind() != ty::Bool || is_lint_allowed(cx, MATCH_BOOL, ex.hir_id) {\n+            check_single_pattern(cx, ex, arms, expr, els);\n+            check_opt_like(cx, ex, arms, expr, ty, els);\n+        }\n+    }\n+}\n+\n+fn check_single_pattern(\n+    cx: &LateContext<'_>,\n+    ex: &Expr<'_>,\n+    arms: &[Arm<'_>],\n+    expr: &Expr<'_>,\n+    els: Option<&Expr<'_>>,\n+) {\n+    if is_wild(arms[1].pat) {\n+        report_single_pattern(cx, ex, arms, expr, els);\n+    }\n+}\n+\n+fn report_single_pattern(\n+    cx: &LateContext<'_>,\n+    ex: &Expr<'_>,\n+    arms: &[Arm<'_>],\n+    expr: &Expr<'_>,\n+    els: Option<&Expr<'_>>,\n+) {\n+    let lint = if els.is_some() { SINGLE_MATCH_ELSE } else { SINGLE_MATCH };\n+    let els_str = els.map_or(String::new(), |els| {\n+        format!(\" else {}\", expr_block(cx, els, None, \"..\", Some(expr.span)))\n+    });\n+\n+    let (pat, pat_ref_count) = peel_hir_pat_refs(arms[0].pat);\n+    let (msg, sugg) = if_chain! {\n+        if let PatKind::Path(_) | PatKind::Lit(_) = pat.kind;\n+        let (ty, ty_ref_count) = peel_mid_ty_refs(cx.typeck_results().expr_ty(ex));\n+        if let Some(spe_trait_id) = cx.tcx.lang_items().structural_peq_trait();\n+        if let Some(pe_trait_id) = cx.tcx.lang_items().eq_trait();\n+        if ty.is_integral() || ty.is_char() || ty.is_str()\n+            || (implements_trait(cx, ty, spe_trait_id, &[])\n+                && implements_trait(cx, ty, pe_trait_id, &[ty.into()]));\n+        then {\n+            // scrutinee derives PartialEq and the pattern is a constant.\n+            let pat_ref_count = match pat.kind {\n+                // string literals are already a reference.\n+                PatKind::Lit(Expr { kind: ExprKind::Lit(lit), .. }) if lit.node.is_str() => pat_ref_count + 1,\n+                _ => pat_ref_count,\n+            };\n+            // References are only implicitly added to the pattern, so no overflow here.\n+            // e.g. will work: match &Some(_) { Some(_) => () }\n+            // will not: match Some(_) { &Some(_) => () }\n+            let ref_count_diff = ty_ref_count - pat_ref_count;\n+\n+            // Try to remove address of expressions first.\n+            let (ex, removed) = peel_n_hir_expr_refs(ex, ref_count_diff);\n+            let ref_count_diff = ref_count_diff - removed;\n+\n+            let msg = \"you seem to be trying to use `match` for an equality check. Consider using `if`\";\n+            let sugg = format!(\n+                \"if {} == {}{} {}{}\",\n+                snippet(cx, ex.span, \"..\"),\n+                // PartialEq for different reference counts may not exist.\n+                \"&\".repeat(ref_count_diff),\n+                snippet(cx, arms[0].pat.span, \"..\"),\n+                expr_block(cx, arms[0].body, None, \"..\", Some(expr.span)),\n+                els_str,\n+            );\n+            (msg, sugg)\n+        } else {\n+            let msg = \"you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\";\n+            let sugg = format!(\n+                \"if let {} = {} {}{}\",\n+                snippet(cx, arms[0].pat.span, \"..\"),\n+                snippet(cx, ex.span, \"..\"),\n+                expr_block(cx, arms[0].body, None, \"..\", Some(expr.span)),\n+                els_str,\n+            );\n+            (msg, sugg)\n+        }\n+    };\n+\n+    span_lint_and_sugg(\n+        cx,\n+        lint,\n+        expr.span,\n+        msg,\n+        \"try this\",\n+        sugg,\n+        Applicability::HasPlaceholders,\n+    );\n+}\n+\n+fn check_opt_like<'a>(\n+    cx: &LateContext<'a>,\n+    ex: &Expr<'_>,\n+    arms: &[Arm<'_>],\n+    expr: &Expr<'_>,\n+    ty: Ty<'a>,\n+    els: Option<&Expr<'_>>,\n+) {\n+    // list of candidate `Enum`s we know will never get any more members\n+    let candidates = &[\n+        (&paths::COW, \"Borrowed\"),\n+        (&paths::COW, \"Cow::Borrowed\"),\n+        (&paths::COW, \"Cow::Owned\"),\n+        (&paths::COW, \"Owned\"),\n+        (&paths::OPTION, \"None\"),\n+        (&paths::RESULT, \"Err\"),\n+        (&paths::RESULT, \"Ok\"),\n+    ];\n+\n+    // We want to suggest to exclude an arm that contains only wildcards or forms the exhaustive\n+    // match with the second branch, without enum variants in matches.\n+    if !contains_only_wilds(arms[1].pat) && !form_exhaustive_matches(arms[0].pat, arms[1].pat) {\n+        return;\n+    }\n+\n+    let mut paths_and_types = Vec::new();\n+    if !collect_pat_paths(&mut paths_and_types, cx, arms[1].pat, ty) {\n+        return;\n+    }\n+\n+    let in_candidate_enum = |path_info: &(String, Ty<'_>)| -> bool {\n+        let (path, ty) = path_info;\n+        for &(ty_path, pat_path) in candidates {\n+            if path == pat_path && match_type(cx, *ty, ty_path) {\n+                return true;\n+            }\n+        }\n+        false\n+    };\n+    if paths_and_types.iter().all(in_candidate_enum) {\n+        report_single_pattern(cx, ex, arms, expr, els);\n+    }\n+}\n+\n+/// Collects paths and their types from the given patterns. Returns true if the given pattern could\n+/// be simplified, false otherwise.\n+fn collect_pat_paths<'a>(acc: &mut Vec<(String, Ty<'a>)>, cx: &LateContext<'a>, pat: &Pat<'_>, ty: Ty<'a>) -> bool {\n+    match pat.kind {\n+        PatKind::Wild => true,\n+        PatKind::Tuple(inner, _) => inner.iter().all(|p| {\n+            let p_ty = cx.typeck_results().pat_ty(p);\n+            collect_pat_paths(acc, cx, p, p_ty)\n+        }),\n+        PatKind::TupleStruct(ref path, ..) => {\n+            let path = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| {\n+                s.print_qpath(path, false);\n+            });\n+            acc.push((path, ty));\n+            true\n+        },\n+        PatKind::Binding(BindingAnnotation::Unannotated, .., ident, None) => {\n+            acc.push((ident.to_string(), ty));\n+            true\n+        },\n+        PatKind::Path(ref path) => {\n+            let path = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| {\n+                s.print_qpath(path, false);\n+            });\n+            acc.push((path, ty));\n+            true\n+        },\n+        _ => false,\n+    }\n+}\n+\n+/// Returns true if the given arm of pattern matching contains wildcard patterns.\n+fn contains_only_wilds(pat: &Pat<'_>) -> bool {\n+    match pat.kind {\n+        PatKind::Wild => true,\n+        PatKind::Tuple(inner, _) | PatKind::TupleStruct(_, inner, ..) => inner.iter().all(contains_only_wilds),\n+        _ => false,\n+    }\n+}\n+\n+/// Returns true if the given patterns forms only exhaustive matches that don't contain enum\n+/// patterns without a wildcard.\n+fn form_exhaustive_matches(left: &Pat<'_>, right: &Pat<'_>) -> bool {\n+    match (&left.kind, &right.kind) {\n+        (PatKind::Wild, _) | (_, PatKind::Wild) => true,\n+        (PatKind::Tuple(left_in, left_pos), PatKind::Tuple(right_in, right_pos)) => {\n+            // We don't actually know the position and the presence of the `..` (dotdot) operator\n+            // in the arms, so we need to evaluate the correct offsets here in order to iterate in\n+            // both arms at the same time.\n+            let len = max(\n+                left_in.len() + {\n+                    if left_pos.is_some() { 1 } else { 0 }\n+                },\n+                right_in.len() + {\n+                    if right_pos.is_some() { 1 } else { 0 }\n+                },\n+            );\n+            let mut left_pos = left_pos.unwrap_or(usize::MAX);\n+            let mut right_pos = right_pos.unwrap_or(usize::MAX);\n+            let mut left_dot_space = 0;\n+            let mut right_dot_space = 0;\n+            for i in 0..len {\n+                let mut found_dotdot = false;\n+                if i == left_pos {\n+                    left_dot_space += 1;\n+                    if left_dot_space < len - left_in.len() {\n+                        left_pos += 1;\n+                    }\n+                    found_dotdot = true;\n+                }\n+                if i == right_pos {\n+                    right_dot_space += 1;\n+                    if right_dot_space < len - right_in.len() {\n+                        right_pos += 1;\n+                    }\n+                    found_dotdot = true;\n+                }\n+                if found_dotdot {\n+                    continue;\n+                }\n+                if !contains_only_wilds(&left_in[i - left_dot_space])\n+                    && !contains_only_wilds(&right_in[i - right_dot_space])\n+                {\n+                    return false;\n+                }\n+            }\n+            true\n+        },\n+        _ => false,\n+    }\n+}"}, {"sha": "459513e65bfad1b1aeb7e503a06e9c6949c6f0c3", "filename": "clippy_lints/src/matches/wild_in_or_pats.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatches%2Fwild_in_or_pats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmatches%2Fwild_in_or_pats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fwild_in_or_pats.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,24 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::is_wild;\n+use rustc_hir::{Arm, PatKind};\n+use rustc_lint::LateContext;\n+\n+use super::WILDCARD_IN_OR_PATTERNS;\n+\n+pub(crate) fn check(cx: &LateContext<'_>, arms: &[Arm<'_>]) {\n+    for arm in arms {\n+        if let PatKind::Or(fields) = arm.pat.kind {\n+            // look for multiple fields in this arm that contains at least one Wild pattern\n+            if fields.len() > 1 && fields.iter().any(is_wild) {\n+                span_lint_and_help(\n+                    cx,\n+                    WILDCARD_IN_OR_PATTERNS,\n+                    arm.pat.span,\n+                    \"wildcard pattern covers any other pattern as it will match anyway\",\n+                    None,\n+                    \"consider handling `_` separately\",\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "d6c235b5a693a96975c006c3f5ee123f17a82fa5", "filename": "clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_forget.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,8 +1,8 @@\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::{match_def_path, paths};\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -32,7 +32,7 @@ impl<'tcx> LateLintPass<'tcx> for MemForget {\n         if let ExprKind::Call(path_expr, [ref first_arg, ..]) = e.kind {\n             if let ExprKind::Path(ref qpath) = path_expr.kind {\n                 if let Some(def_id) = cx.qpath_res(qpath, path_expr.hir_id).opt_def_id() {\n-                    if match_def_path(cx, def_id, &paths::MEM_FORGET) {\n+                    if cx.tcx.is_diagnostic_item(sym::mem_forget, def_id) {\n                         let forgot_ty = cx.typeck_results().expr_ty(first_arg);\n \n                         if forgot_ty.ty_adt_def().map_or(false, |def| def.has_dtor(cx.tcx)) {"}, {"sha": "41073d40f3d79052530e6afc063eeeb9ed44f970", "filename": "clippy_lints/src/mem_replace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_replace.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::ty::is_non_aggregate_primitive_type;\n-use clippy_utils::{is_default_equivalent, is_lang_ctor, match_def_path, meets_msrv, msrvs, paths};\n+use clippy_utils::{is_default_equivalent, is_lang_ctor, meets_msrv, msrvs};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::OptionNone;\n@@ -249,12 +249,12 @@ impl<'tcx> LateLintPass<'tcx> for MemReplace {\n             if let ExprKind::Call(func, func_args) = expr.kind;\n             if let ExprKind::Path(ref func_qpath) = func.kind;\n             if let Some(def_id) = cx.qpath_res(func_qpath, func.hir_id).opt_def_id();\n-            if match_def_path(cx, def_id, &paths::MEM_REPLACE);\n+            if cx.tcx.is_diagnostic_item(sym::mem_replace, def_id);\n             if let [dest, src] = func_args;\n             then {\n                 check_replace_option_with_none(cx, src, dest, expr.span);\n                 check_replace_with_uninit(cx, src, dest, expr.span);\n-                if meets_msrv(self.msrv.as_ref(), &msrvs::MEM_TAKE) {\n+                if meets_msrv(self.msrv, msrvs::MEM_TAKE) {\n                     check_replace_with_default(cx, src, dest, expr.span);\n                 }\n             }"}, {"sha": "b88ec0963f2b55da8cd2f4567e8b91d9f3f58e45", "filename": "clippy_lints/src/methods/bind_instead_of_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -42,7 +42,7 @@ pub(crate) trait BindInsteadOfMap {\n \n     fn no_op_msg(cx: &LateContext<'_>) -> Option<String> {\n         let variant_id = cx.tcx.lang_items().require(Self::VARIANT_LANG_ITEM).ok()?;\n-        let item_id = cx.tcx.parent(variant_id)?;\n+        let item_id = cx.tcx.parent(variant_id);\n         Some(format!(\n             \"using `{}.{}({})`, which is a no-op\",\n             cx.tcx.item_name(item_id),\n@@ -53,7 +53,7 @@ pub(crate) trait BindInsteadOfMap {\n \n     fn lint_msg(cx: &LateContext<'_>) -> Option<String> {\n         let variant_id = cx.tcx.lang_items().require(Self::VARIANT_LANG_ITEM).ok()?;\n-        let item_id = cx.tcx.parent(variant_id)?;\n+        let item_id = cx.tcx.parent(variant_id);\n         Some(format!(\n             \"using `{}.{}(|x| {}(y))`, which is more succinctly expressed as `{}(|x| y)`\",\n             cx.tcx.item_name(item_id),\n@@ -145,7 +145,7 @@ pub(crate) trait BindInsteadOfMap {\n         if_chain! {\n             if let Some(adt) = cx.typeck_results().expr_ty(recv).ty_adt_def();\n             if let Ok(vid) = cx.tcx.lang_items().require(Self::VARIANT_LANG_ITEM);\n-            if Some(adt.did) == cx.tcx.parent(vid);\n+            if adt.did() == cx.tcx.parent(vid);\n             then {} else { return false; }\n         }\n \n@@ -182,7 +182,7 @@ pub(crate) trait BindInsteadOfMap {\n     fn is_variant(cx: &LateContext<'_>, res: Res) -> bool {\n         if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), id) = res {\n             if let Ok(variant_id) = cx.tcx.lang_items().require(Self::VARIANT_LANG_ITEM) {\n-                return cx.tcx.parent(id) == Some(variant_id);\n+                return cx.tcx.parent(id) == variant_id;\n             }\n         }\n         false"}, {"sha": "44857d61fef8f9461e03eca830e4adccf882ca88", "filename": "clippy_lints/src/methods/bytes_nth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fbytes_nth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fbytes_nth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fbytes_nth.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -22,7 +22,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, recv: &'tcx E\n         cx,\n         BYTES_NTH,\n         expr.span,\n-        &format!(\"called `.byte().nth()` on a `{}`\", caller_type),\n+        &format!(\"called `.bytes().nth()` on a `{}`\", caller_type),\n         \"try\",\n         format!(\n             \"{}.as_bytes().get({})\","}, {"sha": "f7b79f0839ba8c17ffbfd08172c16df143491df8", "filename": "clippy_lints/src/methods/chars_cmp.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,13 +1,12 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::{method_chain_args, single_segment_path};\n+use clippy_utils::{method_chain_args, path_def_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n use rustc_lint::Lint;\n-use rustc_middle::ty;\n-use rustc_span::sym;\n+use rustc_middle::ty::{self, DefIdTree};\n \n /// Wrapper fn for `CHARS_NEXT_CMP` and `CHARS_LAST_CMP` lints.\n pub(super) fn check(\n@@ -19,11 +18,9 @@ pub(super) fn check(\n ) -> bool {\n     if_chain! {\n         if let Some(args) = method_chain_args(info.chain, chain_methods);\n-        if let hir::ExprKind::Call(fun, arg_char) = info.other.kind;\n-        if arg_char.len() == 1;\n-        if let hir::ExprKind::Path(ref qpath) = fun.kind;\n-        if let Some(segment) = single_segment_path(qpath);\n-        if segment.ident.name == sym::Some;\n+        if let hir::ExprKind::Call(fun, [arg_char]) = info.other.kind;\n+        if let Some(id) = path_def_id(cx, fun).map(|ctor_id| cx.tcx.parent(ctor_id));\n+        if Some(id) == cx.tcx.lang_items().option_some_variant();\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n             let self_ty = cx.typeck_results().expr_ty_adjusted(&args[0][0]).peel_refs();\n@@ -42,7 +39,7 @@ pub(super) fn check(\n                         if info.eq { \"\" } else { \"!\" },\n                         snippet_with_applicability(cx, args[0][0].span, \"..\", &mut applicability),\n                         suggest,\n-                        snippet_with_applicability(cx, arg_char[0].span, \"..\", &mut applicability)),\n+                        snippet_with_applicability(cx, arg_char.span, \"..\", &mut applicability)),\n                 applicability,\n             );\n "}, {"sha": "a7c0e43923e139b3cc378b6f54aa19161d396f6e", "filename": "clippy_lints/src/methods/chars_cmp_with_unwrap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp_with_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp_with_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp_with_unwrap.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -32,7 +32,7 @@ pub(super) fn check<'tcx>(\n                         if info.eq { \"\" } else { \"!\" },\n                         snippet_with_applicability(cx, args[0][0].span, \"..\", &mut applicability),\n                         suggest,\n-                        c),\n+                        c.escape_default()),\n                 applicability,\n             );\n "}, {"sha": "e9aeab2d5b62e37180d67dc5bc64b75b12fa8666", "filename": "clippy_lints/src/methods/cloned_instead_of_copied.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fcloned_instead_of_copied.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fcloned_instead_of_copied.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fcloned_instead_of_copied.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -10,16 +10,16 @@ use rustc_span::{sym, Span};\n \n use super::CLONED_INSTEAD_OF_COPIED;\n \n-pub fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, span: Span, msrv: Option<&RustcVersion>) {\n+pub fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, span: Span, msrv: Option<RustcVersion>) {\n     let recv_ty = cx.typeck_results().expr_ty_adjusted(recv);\n     let inner_ty = match recv_ty.kind() {\n         // `Option<T>` -> `T`\n         ty::Adt(adt, subst)\n-            if cx.tcx.is_diagnostic_item(sym::Option, adt.did) && meets_msrv(msrv, &msrvs::OPTION_COPIED) =>\n+            if cx.tcx.is_diagnostic_item(sym::Option, adt.did()) && meets_msrv(msrv, msrvs::OPTION_COPIED) =>\n         {\n             subst.type_at(0)\n         },\n-        _ if is_trait_method(cx, expr, sym::Iterator) && meets_msrv(msrv, &msrvs::ITERATOR_COPIED) => {\n+        _ if is_trait_method(cx, expr, sym::Iterator) && meets_msrv(msrv, msrvs::ITERATOR_COPIED) => {\n             match get_iterator_item_ty(cx, recv_ty) {\n                 // <T as Iterator>::Item\n                 Some(ty) => ty,\n@@ -30,7 +30,7 @@ pub fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, span: Span,\n     };\n     match inner_ty.kind() {\n         // &T where T: Copy\n-        ty::Ref(_, ty, _) if is_copy(cx, ty) => {},\n+        ty::Ref(_, ty, _) if is_copy(cx, *ty) => {},\n         _ => return,\n     };\n     span_lint_and_sugg("}, {"sha": "570a1b87358ddb042699df7a3b3b778c7f125a46", "filename": "clippy_lints/src/methods/err_expect.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Ferr_expect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Ferr_expect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ferr_expect.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,60 @@\n+use super::ERR_EXPECT;\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::ty::implements_trait;\n+use clippy_utils::{meets_msrv, msrvs, ty::is_type_diagnostic_item};\n+use rustc_errors::Applicability;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_middle::ty::Ty;\n+use rustc_semver::RustcVersion;\n+use rustc_span::{sym, Span};\n+\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    _expr: &rustc_hir::Expr<'_>,\n+    recv: &rustc_hir::Expr<'_>,\n+    msrv: Option<RustcVersion>,\n+    expect_span: Span,\n+    err_span: Span,\n+) {\n+    if_chain! {\n+        if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(recv), sym::Result);\n+        // Test the version to make sure the lint can be showed (expect_err has been\n+        // introduced in rust 1.17.0 : https://github.com/rust-lang/rust/pull/38982)\n+        if meets_msrv(msrv, msrvs::EXPECT_ERR);\n+\n+        // Grabs the `Result<T, E>` type\n+        let result_type = cx.typeck_results().expr_ty(recv);\n+        // Tests if the T type in a `Result<T, E>` is not None\n+        if let Some(data_type) = get_data_type(cx, result_type);\n+        // Tests if the T type in a `Result<T, E>` implements debug\n+        if has_debug_impl(data_type, cx);\n+\n+        then {\n+            span_lint_and_sugg(\n+                cx,\n+                ERR_EXPECT,\n+                err_span.to(expect_span),\n+                \"called `.err().expect()` on a `Result` value\",\n+                \"try\",\n+                \"expect_err\".to_string(),\n+                Applicability::MachineApplicable\n+        );\n+        }\n+    };\n+}\n+\n+/// Given a `Result<T, E>` type, return its data (`T`).\n+fn get_data_type<'a>(cx: &LateContext<'_>, ty: Ty<'a>) -> Option<Ty<'a>> {\n+    match ty.kind() {\n+        ty::Adt(_, substs) if is_type_diagnostic_item(cx, ty, sym::Result) => substs.types().next(),\n+        _ => None,\n+    }\n+}\n+\n+/// Given a type, very if the Debug trait has been impl'd\n+fn has_debug_impl<'tcx>(ty: Ty<'tcx>, cx: &LateContext<'tcx>) -> bool {\n+    cx.tcx\n+        .get_diagnostic_item(sym::Debug)\n+        .map_or(false, |debug| implements_trait(cx, ty, debug, &[]))\n+}"}, {"sha": "6f2307d8f18ff1505acd84603ff2003c3f0e1feb", "filename": "clippy_lints/src/methods/expect_fun_call.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -73,7 +73,7 @@ pub(super) fn check<'tcx>(\n                     match cx.qpath_res(p, fun.hir_id) {\n                         hir::def::Res::Def(hir::def::DefKind::Fn | hir::def::DefKind::AssocFn, def_id) => matches!(\n                             cx.tcx.fn_sig(def_id).output().skip_binder().kind(),\n-                            ty::Ref(ty::ReStatic, ..)\n+                            ty::Ref(re, ..) if re.is_static(),\n                         ),\n                         _ => false,\n                     }\n@@ -87,13 +87,13 @@ pub(super) fn check<'tcx>(\n                     .map_or(false, |method_id| {\n                         matches!(\n                             cx.tcx.fn_sig(method_id).output().skip_binder().kind(),\n-                            ty::Ref(ty::ReStatic, ..)\n+                            ty::Ref(re, ..) if re.is_static()\n                         )\n                     })\n             },\n             hir::ExprKind::Path(ref p) => matches!(\n                 cx.qpath_res(p, arg.hir_id),\n-                hir::def::Res::Def(hir::def::DefKind::Const | hir::def::DefKind::Static, _)\n+                hir::def::Res::Def(hir::def::DefKind::Const | hir::def::DefKind::Static(_), _)\n             ),\n             _ => false,\n         }"}, {"sha": "fbc3348f1855fe3b7a8af071101bde3548905971", "filename": "clippy_lints/src/methods/expect_used.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fexpect_used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fexpect_used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fexpect_used.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,4 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::is_in_test_function;\n use clippy_utils::ty::is_type_diagnostic_item;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n@@ -7,7 +8,7 @@ use rustc_span::sym;\n use super::EXPECT_USED;\n \n /// lint use of `expect()` for `Option`s and `Result`s\n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>, allow_expect_in_tests: bool) {\n     let obj_ty = cx.typeck_results().expr_ty(recv).peel_refs();\n \n     let mess = if is_type_diagnostic_item(cx, obj_ty, sym::Option) {\n@@ -18,6 +19,10 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr\n         None\n     };\n \n+    if allow_expect_in_tests && is_in_test_function(cx.tcx, expr.hir_id) {\n+        return;\n+    }\n+\n     if let Some((lint, kind, none_value)) = mess {\n         span_lint_and_help(\n             cx,"}, {"sha": "558cb6bd64e7275a04e2ba49e27acb706eef8049", "filename": "clippy_lints/src/methods/filter_map.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -8,7 +8,6 @@ use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::{Expr, ExprKind, PatKind, QPath, UnOp};\n use rustc_lint::LateContext;\n-use rustc_middle::ty::TyS;\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{sym, Symbol};\n use std::borrow::Cow;\n@@ -120,9 +119,9 @@ pub(super) fn check<'tcx>(\n             if let PatKind::Binding(_, filter_param_id, _, None) = filter_pat.kind;\n             if let ExprKind::MethodCall(path, [filter_arg], _) = filter_body.value.kind;\n             if let Some(opt_ty) = cx.typeck_results().expr_ty(filter_arg).ty_adt_def();\n-            if let Some(is_result) = if cx.tcx.is_diagnostic_item(sym::Option, opt_ty.did) {\n+            if let Some(is_result) = if cx.tcx.is_diagnostic_item(sym::Option, opt_ty.did()) {\n                 Some(false)\n-            } else if cx.tcx.is_diagnostic_item(sym::Result, opt_ty.did) {\n+            } else if cx.tcx.is_diagnostic_item(sym::Result, opt_ty.did()) {\n                 Some(true)\n             } else {\n                 None\n@@ -149,7 +148,7 @@ pub(super) fn check<'tcx>(\n                 if_chain! {\n                     if path_to_local_id(a_path, filter_param_id);\n                     if path_to_local_id(b, map_param_id);\n-                    if TyS::same_type(cx.typeck_results().expr_ty_adjusted(a), cx.typeck_results().expr_ty_adjusted(b));\n+                    if cx.typeck_results().expr_ty_adjusted(a) == cx.typeck_results().expr_ty_adjusted(b);\n                     then {\n                         return true;\n                     }"}, {"sha": "38ec4d8e3ab8fb9ea62e50d3b45e5473041b9279", "filename": "clippy_lints/src/methods/filter_map_next.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_next.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_next.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_next.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -14,10 +14,10 @@ pub(super) fn check<'tcx>(\n     expr: &'tcx hir::Expr<'_>,\n     recv: &'tcx hir::Expr<'_>,\n     arg: &'tcx hir::Expr<'_>,\n-    msrv: Option<&RustcVersion>,\n+    msrv: Option<RustcVersion>,\n ) {\n     if is_trait_method(cx, expr, sym::Iterator) {\n-        if !meets_msrv(msrv, &msrvs::ITERATOR_FIND_MAP) {\n+        if !meets_msrv(msrv, msrvs::ITERATOR_FIND_MAP) {\n             return;\n         }\n "}, {"sha": "23368238ef5cce6511ff799e008287b5b9fc4ccd", "filename": "clippy_lints/src/methods/get_last_with_len.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fget_last_with_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fget_last_with_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fget_last_with_len.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,55 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::SpanlessEq;\n+use rustc_ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::source_map::Spanned;\n+use rustc_span::sym;\n+\n+use super::GET_LAST_WITH_LEN;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, arg: &Expr<'_>) {\n+    // Argument to \"get\" is a subtraction\n+    if let ExprKind::Binary(\n+        Spanned {\n+            node: BinOpKind::Sub, ..\n+        },\n+        lhs,\n+        rhs,\n+    ) = arg.kind\n+\n+        // LHS of subtraction is \"x.len()\"\n+        && let ExprKind::MethodCall(lhs_path, [lhs_recv], _) = &lhs.kind\n+        && lhs_path.ident.name == sym::len\n+\n+        // RHS of subtraction is 1\n+        && let ExprKind::Lit(rhs_lit) = &rhs.kind\n+        && let LitKind::Int(1, ..) = rhs_lit.node\n+\n+        // check that recv == lhs_recv `recv.get(lhs_recv.len() - 1)`\n+        && SpanlessEq::new(cx).eq_expr(recv, lhs_recv)\n+        && !recv.can_have_side_effects()\n+    {\n+        let method = match cx.typeck_results().expr_ty_adjusted(recv).peel_refs().kind() {\n+            ty::Adt(def, _) if cx.tcx.is_diagnostic_item(sym::VecDeque, def.did()) => \"back\",\n+            ty::Slice(_) => \"last\",\n+            _ => return,\n+        };\n+\n+        let mut applicability = Applicability::MachineApplicable;\n+        let recv_snippet = snippet_with_applicability(cx, recv.span, \"_\", &mut applicability);\n+\n+        span_lint_and_sugg(\n+            cx,\n+            GET_LAST_WITH_LEN,\n+            expr.span,\n+            &format!(\"accessing last element with `{recv_snippet}.get({recv_snippet}.len() - 1)`\"),\n+            \"try\",\n+            format!(\"{recv_snippet}.{method}()\"),\n+            applicability,\n+        );\n+    }\n+}"}, {"sha": "9651a52be4e7281a28a4891a942c5d415d3de761", "filename": "clippy_lints/src/methods/implicit_clone.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -6,7 +6,6 @@ use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n-use rustc_middle::ty::TyS;\n use rustc_span::sym;\n \n use super::IMPLICIT_CLONE;\n@@ -18,8 +17,8 @@ pub fn check(cx: &LateContext<'_>, method_name: &str, expr: &hir::Expr<'_>, recv\n         let return_type = cx.typeck_results().expr_ty(expr);\n         let input_type = cx.typeck_results().expr_ty(recv);\n         let (input_type, ref_count) = peel_mid_ty_refs(input_type);\n-        if let Some(ty_name) = input_type.ty_adt_def().map(|adt_def| cx.tcx.item_name(adt_def.did));\n-        if TyS::same_type(return_type, input_type);\n+        if let Some(ty_name) = input_type.ty_adt_def().map(|adt_def| cx.tcx.item_name(adt_def.did()));\n+        if return_type == input_type;\n         then {\n             let mut app = Applicability::MachineApplicable;\n             let recv_snip = snippet_with_context(cx, recv.span, expr.span.ctxt(), \"..\", &mut app).0;\n@@ -49,12 +48,11 @@ pub fn is_clone_like(cx: &LateContext<'_>, method_name: &str, method_def_id: hir\n         \"to_os_string\" => is_diag_item_method(cx, method_def_id, sym::OsStr),\n         \"to_owned\" => is_diag_trait_item(cx, method_def_id, sym::ToOwned),\n         \"to_path_buf\" => is_diag_item_method(cx, method_def_id, sym::Path),\n-        \"to_vec\" => {\n-            cx.tcx\n-                .impl_of_method(method_def_id)\n-                .map(|impl_did| Some(impl_did) == cx.tcx.lang_items().slice_alloc_impl())\n-                == Some(true)\n-        },\n+        \"to_vec\" => cx\n+            .tcx\n+            .impl_of_method(method_def_id)\n+            .filter(|&impl_did| cx.tcx.type_of(impl_did).is_slice() && cx.tcx.impl_trait_ref(impl_did).is_none())\n+            .is_some(),\n         _ => false,\n     }\n }"}, {"sha": "06ead144afa24b459a406639721ea06fdf7a7f1a", "filename": "clippy_lints/src/methods/inefficient_to_string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -60,7 +60,7 @@ fn specializes_tostring(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n     }\n \n     if let ty::Adt(adt, substs) = ty.kind() {\n-        match_def_path(cx, adt.did, &paths::COW) && substs.type_at(1).is_str()\n+        match_def_path(cx, adt.did(), &paths::COW) && substs.type_at(1).is_str()\n     } else {\n         false\n     }"}, {"sha": "aa176dcc8b4af2016da9584758306e610129aa64", "filename": "clippy_lints/src/methods/is_digit_ascii_radix.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fis_digit_ascii_radix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fis_digit_ascii_radix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fis_digit_ascii_radix.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,50 @@\n+//! Lint for `c.is_digit(10)`\n+\n+use super::IS_DIGIT_ASCII_RADIX;\n+use clippy_utils::{\n+    consts::constant_full_int, consts::FullInt, diagnostics::span_lint_and_sugg, meets_msrv, msrvs,\n+    source::snippet_with_applicability,\n+};\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_semver::RustcVersion;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    self_arg: &'tcx Expr<'_>,\n+    radix: &'tcx Expr<'_>,\n+    msrv: Option<RustcVersion>,\n+) {\n+    if !meets_msrv(msrv, msrvs::IS_ASCII_DIGIT) {\n+        return;\n+    }\n+\n+    if !cx.typeck_results().expr_ty_adjusted(self_arg).peel_refs().is_char() {\n+        return;\n+    }\n+\n+    if let Some(radix_val) = constant_full_int(cx, cx.typeck_results(), radix) {\n+        let (num, replacement) = match radix_val {\n+            FullInt::S(10) | FullInt::U(10) => (10, \"is_ascii_digit\"),\n+            FullInt::S(16) | FullInt::U(16) => (16, \"is_ascii_hexdigit\"),\n+            _ => return,\n+        };\n+        let mut applicability = Applicability::MachineApplicable;\n+\n+        span_lint_and_sugg(\n+            cx,\n+            IS_DIGIT_ASCII_RADIX,\n+            expr.span,\n+            &format!(\"use of `char::is_digit` with literal radix of {}\", num),\n+            \"try\",\n+            format!(\n+                \"{}.{}()\",\n+                snippet_with_applicability(cx, self_arg.span, \"..\", &mut applicability),\n+                replacement\n+            ),\n+            applicability,\n+        );\n+    }\n+}"}, {"sha": "b8d1dabe007641423c65a180080412c750222117", "filename": "clippy_lints/src/methods/iter_next_slice.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -34,13 +34,18 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, cal\n             if let ast::LitKind::Int(start_idx, _) = start_lit.node;\n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n+                let suggest = if start_idx == 0 {\n+                    format!(\"{}.first()\", snippet_with_applicability(cx, caller_var.span, \"..\", &mut applicability))\n+                } else {\n+                    format!(\"{}.get({})\", snippet_with_applicability(cx, caller_var.span, \"..\", &mut applicability), start_idx)\n+                };\n                 span_lint_and_sugg(\n                     cx,\n                     ITER_NEXT_SLICE,\n                     expr.span,\n                     \"using `.iter().next()` on a Slice without end index\",\n                     \"try calling\",\n-                    format!(\"{}.get({})\", snippet_with_applicability(cx, caller_var.span, \"..\", &mut applicability), start_idx),\n+                    suggest,\n                     applicability,\n                 );\n             }\n@@ -55,7 +60,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, cal\n             \"using `.iter().next()` on an array\",\n             \"try calling\",\n             format!(\n-                \"{}.get(0)\",\n+                \"{}.first()\",\n                 snippet_with_applicability(cx, caller_expr.span, \"..\", &mut applicability)\n             ),\n             applicability,"}, {"sha": "54c9ca435a447d8e870403ecf78cc48a5ce7d09a", "filename": "clippy_lints/src/methods/iter_overeager_cloned.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fiter_overeager_cloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fiter_overeager_cloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_overeager_cloned.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,11 +1,12 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet;\n-use clippy_utils::ty::{get_iterator_item_ty, is_copy};\n+use clippy_utils::ty::{get_iterator_item_ty, implements_trait, is_copy};\n use itertools::Itertools;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n use rustc_middle::ty;\n+use rustc_span::sym;\n use std::ops::Not;\n \n use super::ITER_OVEREAGER_CLONED;\n@@ -20,13 +21,20 @@ pub(super) fn check<'tcx>(\n     map_arg: &[hir::Expr<'_>],\n ) {\n     // Check if it's iterator and get type associated with `Item`.\n-    let inner_ty = match get_iterator_item_ty(cx, cx.typeck_results().expr_ty_adjusted(recv)) {\n-        Some(ty) => ty,\n-        _ => return,\n+    let inner_ty = if_chain! {\n+        if let Some(iterator_trait_id) = cx.tcx.get_diagnostic_item(sym::Iterator);\n+        let recv_ty = cx.typeck_results().expr_ty(recv);\n+        if implements_trait(cx, recv_ty, iterator_trait_id, &[]);\n+        if let Some(inner_ty) = get_iterator_item_ty(cx, cx.typeck_results().expr_ty_adjusted(recv));\n+        then {\n+            inner_ty\n+        } else {\n+            return;\n+        }\n     };\n \n     match inner_ty.kind() {\n-        ty::Ref(_, ty, _) if !is_copy(cx, ty) => {},\n+        ty::Ref(_, ty, _) if !is_copy(cx, *ty) => {},\n         _ => return,\n     };\n "}, {"sha": "152072e09c77275795922332495b9622baea5335", "filename": "clippy_lints/src/methods/iter_with_drain.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fiter_with_drain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fiter_with_drain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_with_drain.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,47 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::higher::Range;\n+use clippy_utils::is_integer_const;\n+use rustc_ast::ast::RangeLimits;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, QPath};\n+use rustc_lint::LateContext;\n+use rustc_span::symbol::sym;\n+use rustc_span::Span;\n+\n+use super::ITER_WITH_DRAIN;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, span: Span, arg: &Expr<'_>) {\n+    if !matches!(recv.kind, ExprKind::Field(..))\n+        && let Some(adt) = cx.typeck_results().expr_ty(recv).ty_adt_def()\n+        && let Some(ty_name) = cx.tcx.get_diagnostic_name(adt.did())\n+        && matches!(ty_name, sym::Vec | sym::VecDeque)\n+        && let Some(range) = Range::hir(arg)\n+        && is_full_range(cx, recv, range)\n+    {\n+        span_lint_and_sugg(\n+            cx,\n+            ITER_WITH_DRAIN,\n+            span.with_hi(expr.span.hi()),\n+            &format!(\"`drain(..)` used on a `{}`\", ty_name),\n+            \"try this\",\n+            \"into_iter()\".to_string(),\n+            Applicability::MaybeIncorrect,\n+        );\n+    };\n+}\n+\n+fn is_full_range(cx: &LateContext<'_>, container: &Expr<'_>, range: Range<'_>) -> bool {\n+    range.start.map_or(true, |e| is_integer_const(cx, e, 0))\n+        && range.end.map_or(true, |e| {\n+            if range.limits == RangeLimits::HalfOpen\n+                && let ExprKind::Path(QPath::Resolved(None, container_path)) = container.kind\n+                && let ExprKind::MethodCall(name, [self_arg], _) = e.kind\n+                && name.ident.name == sym::len\n+                && let ExprKind::Path(QPath::Resolved(None, path)) = self_arg.kind\n+            {\n+                container_path.res == path.res\n+            } else {\n+                false\n+            }\n+        })\n+}"}, {"sha": "0fe510beaa07ee8640d48599b3025775744c8e84", "filename": "clippy_lints/src/methods/manual_saturating_arithmetic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::is_qpath_def_path;\n use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::{match_def_path, path_def_id};\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_errors::Applicability;\n@@ -93,12 +93,12 @@ fn is_min_or_max<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>) -> Option<M\n     let ty_str = ty.to_string();\n \n     // `std::T::MAX` `std::T::MIN` constants\n-    if let hir::ExprKind::Path(path) = &expr.kind {\n-        if is_qpath_def_path(cx, path, expr.hir_id, &[\"core\", &ty_str, \"MAX\"][..]) {\n+    if let Some(id) = path_def_id(cx, expr) {\n+        if match_def_path(cx, id, &[\"core\", &ty_str, \"MAX\"]) {\n             return Some(MinMax::Max);\n         }\n \n-        if is_qpath_def_path(cx, path, expr.hir_id, &[\"core\", &ty_str, \"MIN\"][..]) {\n+        if match_def_path(cx, id, &[\"core\", &ty_str, \"MIN\"]) {\n             return Some(MinMax::Min);\n         }\n     }"}, {"sha": "68a75667914aa0f8f6ab34c80d408ba3a812741a", "filename": "clippy_lints/src/methods/manual_str_repeat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -8,7 +8,7 @@ use rustc_ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, LangItem};\n use rustc_lint::LateContext;\n-use rustc_middle::ty::{self, Ty, TyS};\n+use rustc_middle::ty::{self, Ty};\n use rustc_span::symbol::sym;\n use std::borrow::Cow;\n \n@@ -37,8 +37,8 @@ fn parse_repeat_arg(cx: &LateContext<'_>, e: &Expr<'_>) -> Option<RepeatKind> {\n     } else {\n         let ty = cx.typeck_results().expr_ty(e);\n         if is_type_diagnostic_item(cx, ty, sym::String)\n-            || (is_type_lang_item(cx, ty, LangItem::OwnedBox) && get_ty_param(ty).map_or(false, TyS::is_str))\n-            || (match_type(cx, ty, &paths::COW) && get_ty_param(ty).map_or(false, TyS::is_str))\n+            || (is_type_lang_item(cx, ty, LangItem::OwnedBox) && get_ty_param(ty).map_or(false, Ty::is_str))\n+            || (match_type(cx, ty, &paths::COW) && get_ty_param(ty).map_or(false, Ty::is_str))\n         {\n             Some(RepeatKind::String)\n         } else {"}, {"sha": "f447940ea3b5aaa84a2845c7ff8bbffc1e08fc1b", "filename": "clippy_lints/src/methods/map_flatten.rs", "status": "modified", "additions": 56, "deletions": 66, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,83 +1,73 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::diagnostics::span_lint_and_sugg_for_edges;\n use clippy_utils::is_trait_method;\n-use clippy_utils::source::snippet;\n+use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_type_diagnostic_item;\n use rustc_errors::Applicability;\n-use rustc_hir as hir;\n+use rustc_hir::Expr;\n use rustc_lint::LateContext;\n use rustc_middle::ty;\n-use rustc_span::symbol::sym;\n+use rustc_span::{symbol::sym, Span};\n \n use super::MAP_FLATTEN;\n \n /// lint use of `map().flatten()` for `Iterators` and 'Options'\n-pub(super) fn check<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    expr: &'tcx hir::Expr<'_>,\n-    recv: &'tcx hir::Expr<'_>,\n-    map_arg: &'tcx hir::Expr<'_>,\n-) {\n-    // lint if caller of `.map().flatten()` is an Iterator\n-    if is_trait_method(cx, expr, sym::Iterator) {\n-        let map_closure_ty = cx.typeck_results().expr_ty(map_arg);\n-        let is_map_to_option = match map_closure_ty.kind() {\n-            ty::Closure(_, _) | ty::FnDef(_, _) | ty::FnPtr(_) => {\n-                let map_closure_sig = match map_closure_ty.kind() {\n-                    ty::Closure(_, substs) => substs.as_closure().sig(),\n-                    _ => map_closure_ty.fn_sig(cx.tcx),\n-                };\n-                let map_closure_return_ty = cx.tcx.erase_late_bound_regions(map_closure_sig.output());\n-                is_type_diagnostic_item(cx, map_closure_return_ty, sym::Option)\n-            },\n-            _ => false,\n-        };\n-\n-        let method_to_use = if is_map_to_option {\n-            // `(...).map(...)` has type `impl Iterator<Item=Option<...>>\n-            \"filter_map\"\n-        } else {\n-            // `(...).map(...)` has type `impl Iterator<Item=impl Iterator<...>>\n-            \"flat_map\"\n-        };\n-        let func_snippet = snippet(cx, map_arg.span, \"..\");\n-        let hint = format!(\".{0}({1})\", method_to_use, func_snippet);\n-        span_lint_and_sugg(\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, map_arg: &Expr<'_>, map_span: Span) {\n+    if let Some((caller_ty_name, method_to_use)) = try_get_caller_ty_name_and_method_name(cx, expr, recv, map_arg) {\n+        let mut applicability = Applicability::MachineApplicable;\n+        let help_msgs = [\n+            &format!(\"try replacing `map` with `{}`\", method_to_use),\n+            \"and remove the `.flatten()`\",\n+        ];\n+        let closure_snippet = snippet_with_applicability(cx, map_arg.span, \"..\", &mut applicability);\n+        span_lint_and_sugg_for_edges(\n             cx,\n             MAP_FLATTEN,\n-            expr.span.with_lo(recv.span.hi()),\n-            \"called `map(..).flatten()` on an `Iterator`\",\n-            &format!(\"try using `{}` instead\", method_to_use),\n-            hint,\n-            Applicability::MachineApplicable,\n+            expr.span.with_lo(map_span.lo()),\n+            &format!(\"called `map(..).flatten()` on `{}`\", caller_ty_name),\n+            &help_msgs,\n+            format!(\"{}({})\", method_to_use, closure_snippet),\n+            applicability,\n         );\n     }\n+}\n \n-    // lint if caller of `.map().flatten()` is an Option or Result\n-    let caller_type = match cx.typeck_results().expr_ty(recv).kind() {\n-        ty::Adt(adt, _) => {\n-            if cx.tcx.is_diagnostic_item(sym::Option, adt.did) {\n-                \"Option\"\n-            } else if cx.tcx.is_diagnostic_item(sym::Result, adt.did) {\n-                \"Result\"\n-            } else {\n-                return;\n+fn try_get_caller_ty_name_and_method_name(\n+    cx: &LateContext<'_>,\n+    expr: &Expr<'_>,\n+    caller_expr: &Expr<'_>,\n+    map_arg: &Expr<'_>,\n+) -> Option<(&'static str, &'static str)> {\n+    if is_trait_method(cx, expr, sym::Iterator) {\n+        if is_map_to_option(cx, map_arg) {\n+            // `(...).map(...)` has type `impl Iterator<Item=Option<...>>\n+            Some((\"Iterator\", \"filter_map\"))\n+        } else {\n+            // `(...).map(...)` has type `impl Iterator<Item=impl Iterator<...>>\n+            Some((\"Iterator\", \"flat_map\"))\n+        }\n+    } else {\n+        if let ty::Adt(adt, _) = cx.typeck_results().expr_ty(caller_expr).kind() {\n+            if cx.tcx.is_diagnostic_item(sym::Option, adt.did()) {\n+                return Some((\"Option\", \"and_then\"));\n+            } else if cx.tcx.is_diagnostic_item(sym::Result, adt.did()) {\n+                return Some((\"Result\", \"and_then\"));\n             }\n-        },\n-        _ => {\n-            return;\n-        },\n-    };\n+        }\n+        None\n+    }\n+}\n \n-    let func_snippet = snippet(cx, map_arg.span, \"..\");\n-    let hint = format!(\".and_then({})\", func_snippet);\n-    let lint_info = format!(\"called `map(..).flatten()` on an `{}`\", caller_type);\n-    span_lint_and_sugg(\n-        cx,\n-        MAP_FLATTEN,\n-        expr.span.with_lo(recv.span.hi()),\n-        &lint_info,\n-        \"try using `and_then` instead\",\n-        hint,\n-        Applicability::MachineApplicable,\n-    );\n+fn is_map_to_option(cx: &LateContext<'_>, map_arg: &Expr<'_>) -> bool {\n+    let map_closure_ty = cx.typeck_results().expr_ty(map_arg);\n+    match map_closure_ty.kind() {\n+        ty::Closure(_, _) | ty::FnDef(_, _) | ty::FnPtr(_) => {\n+            let map_closure_sig = match map_closure_ty.kind() {\n+                ty::Closure(_, substs) => substs.as_closure().sig(),\n+                _ => map_closure_ty.fn_sig(cx.tcx),\n+            };\n+            let map_closure_return_ty = cx.tcx.erase_late_bound_regions(map_closure_sig.output());\n+            is_type_diagnostic_item(cx, map_closure_return_ty, sym::Option)\n+        },\n+        _ => false,\n+    }\n }"}, {"sha": "862a9578e6ff26d76296e18ad7b78a9e53ec36d0", "filename": "clippy_lints/src/methods/map_identity.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fmap_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fmap_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmap_identity.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -13,6 +13,7 @@ pub(super) fn check(\n     expr: &hir::Expr<'_>,\n     caller: &hir::Expr<'_>,\n     map_arg: &hir::Expr<'_>,\n+    name: &str,\n     _map_span: Span,\n ) {\n     let caller_ty = cx.typeck_results().expr_ty(caller);\n@@ -29,7 +30,7 @@ pub(super) fn check(\n                 MAP_IDENTITY,\n                 sugg_span,\n                 \"unnecessary map of the identity function\",\n-                \"remove the call to `map`\",\n+                &format!(\"remove the call to `{}`\", name),\n                 String::new(),\n                 Applicability::MachineApplicable,\n             )"}, {"sha": "4a8e7ce4ddbbd3d9dc171e2732f93e55b99f85ae", "filename": "clippy_lints/src/methods/map_unwrap_or.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fmap_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fmap_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmap_unwrap_or.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -19,13 +19,13 @@ pub(super) fn check<'tcx>(\n     recv: &'tcx hir::Expr<'_>,\n     map_arg: &'tcx hir::Expr<'_>,\n     unwrap_arg: &'tcx hir::Expr<'_>,\n-    msrv: Option<&RustcVersion>,\n+    msrv: Option<RustcVersion>,\n ) -> bool {\n     // lint if the caller of `map()` is an `Option`\n     let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(recv), sym::Option);\n     let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(recv), sym::Result);\n \n-    if is_result && !meets_msrv(msrv, &msrvs::RESULT_MAP_OR_ELSE) {\n+    if is_result && !meets_msrv(msrv, msrvs::RESULT_MAP_OR_ELSE) {\n         return false;\n     }\n "}, {"sha": "b820b7409304562ce75a4d7045e571eb393b2770", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 522, "deletions": 181, "changes": 703, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -9,6 +9,7 @@ mod chars_next_cmp_with_unwrap;\n mod clone_on_copy;\n mod clone_on_ref_ptr;\n mod cloned_instead_of_copied;\n+mod err_expect;\n mod expect_fun_call;\n mod expect_used;\n mod extend_with_drain;\n@@ -20,30 +21,37 @@ mod filter_next;\n mod flat_map_identity;\n mod flat_map_option;\n mod from_iter_instead_of_collect;\n+mod get_last_with_len;\n mod get_unwrap;\n mod implicit_clone;\n mod inefficient_to_string;\n mod inspect_for_each;\n mod into_iter_on_ref;\n+mod is_digit_ascii_radix;\n mod iter_cloned_collect;\n mod iter_count;\n mod iter_next_slice;\n mod iter_nth;\n mod iter_nth_zero;\n mod iter_overeager_cloned;\n mod iter_skip_next;\n+mod iter_with_drain;\n mod iterator_step_by_zero;\n mod manual_saturating_arithmetic;\n mod manual_str_repeat;\n mod map_collect_result_unit;\n mod map_flatten;\n mod map_identity;\n mod map_unwrap_or;\n+mod needless_option_as_deref;\n+mod needless_option_take;\n+mod no_effect_replace;\n mod ok_expect;\n mod option_as_ref_deref;\n mod option_map_or_none;\n mod option_map_unwrap_or;\n mod or_fun_call;\n+mod or_then_unwrap;\n mod search_is_some;\n mod single_char_add_str;\n mod single_char_insert_string;\n@@ -58,6 +66,7 @@ mod uninit_assumed_init;\n mod unnecessary_filter_map;\n mod unnecessary_fold;\n mod unnecessary_iter_cloned;\n+mod unnecessary_join;\n mod unnecessary_lazy_eval;\n mod unnecessary_to_owned;\n mod unwrap_or_else_default;\n@@ -78,7 +87,7 @@ use rustc_hir::def::Res;\n use rustc_hir::{Expr, ExprKind, PrimTy, QPath, TraitItem, TraitItemKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, TraitRef, Ty, TyS};\n+use rustc_middle::ty::{self, TraitRef, Ty};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{sym, Span};\n@@ -289,15 +298,15 @@ declare_clippy_lint! {\n     /// Checks for methods with certain name prefixes and which\n     /// doesn't match how self is taken. The actual rules are:\n     ///\n-    /// |Prefix |Postfix     |`self` taken           | `self` type  |\n-    /// |-------|------------|-----------------------|--------------|\n-    /// |`as_`  | none       |`&self` or `&mut self` | any          |\n-    /// |`from_`| none       | none                  | any          |\n-    /// |`into_`| none       |`self`                 | any          |\n-    /// |`is_`  | none       |`&self` or none        | any          |\n-    /// |`to_`  | `_mut`     |`&mut self`            | any          |\n-    /// |`to_`  | not `_mut` |`self`                 | `Copy`       |\n-    /// |`to_`  | not `_mut` |`&self`                | not `Copy`   |\n+    /// |Prefix |Postfix     |`self` taken                   | `self` type  |\n+    /// |-------|------------|-------------------------------|--------------|\n+    /// |`as_`  | none       |`&self` or `&mut self`         | any          |\n+    /// |`from_`| none       | none                          | any          |\n+    /// |`into_`| none       |`self`                         | any          |\n+    /// |`is_`  | none       |`&mut self` or `&self` or none | any          |\n+    /// |`to_`  | `_mut`     |`&mut self`                    | any          |\n+    /// |`to_`  | not `_mut` |`self`                         | `Copy`       |\n+    /// |`to_`  | not `_mut` |`&self`                        | not `Copy`   |\n     ///\n     /// Note: Clippy doesn't trigger methods with `to_` prefix in:\n     /// - Traits definition.\n@@ -359,6 +368,29 @@ declare_clippy_lint! {\n     \"using `ok().expect()`, which gives worse error messages than calling `expect` directly on the Result\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `.err().expect()` calls on the `Result` type.\n+    ///\n+    /// ### Why is this bad?\n+    /// `.expect_err()` can be called directly to avoid the extra type conversion from `err()`.\n+    ///\n+    /// ### Example\n+    /// ```should_panic\n+    /// let x: Result<u32, &str> = Ok(10);\n+    /// x.err().expect(\"Testing err().expect()\");\n+    /// ```\n+    /// Use instead:\n+    /// ```should_panic\n+    /// let x: Result<u32, &str> = Ok(10);\n+    /// x.expect_err(\"Testing expect_err\");\n+    /// ```\n+    #[clippy::version = \"1.61.0\"]\n+    pub ERR_EXPECT,\n+    style,\n+    r#\"using `.err().expect(\"\")` when `.expect_err(\"\")` can be used\"#\n+}\n+\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for usages of `_.unwrap_or_else(Default::default)` on `Option` and\n@@ -777,6 +809,42 @@ declare_clippy_lint! {\n     \"using any `*or` method with a function call, which suggests `*or_else`\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `.or(\u2026).unwrap()` calls to Options and Results.\n+    ///\n+    /// ### Why is this bad?\n+    /// You should use `.unwrap_or(\u2026)` instead for clarity.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let fallback = \"fallback\";\n+    /// // Result\n+    /// # type Error = &'static str;\n+    /// # let result: Result<&str, Error> = Err(\"error\");\n+    /// let value = result.or::<Error>(Ok(fallback)).unwrap();\n+    ///\n+    /// // Option\n+    /// # let option: Option<&str> = None;\n+    /// let value = option.or(Some(fallback)).unwrap();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # let fallback = \"fallback\";\n+    /// // Result\n+    /// # let result: Result<&str, &str> = Err(\"error\");\n+    /// let value = result.unwrap_or(fallback);\n+    ///\n+    /// // Option\n+    /// # let option: Option<&str> = None;\n+    /// let value = option.unwrap_or(fallback);\n+    /// ```\n+    #[clippy::version = \"1.61.0\"]\n+    pub OR_THEN_UNWRAP,\n+    complexity,\n+    \"checks for `.or(\u2026).unwrap()` calls to Options and Results.\"\n+}\n+\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for calls to `.expect(&format!(...))`, `.expect(foo(..))`,\n@@ -1118,6 +1186,63 @@ declare_clippy_lint! {\n     \"using `.skip(x).next()` on an iterator\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for use of `.drain(..)` on `Vec` and `VecDeque` for iteration.\n+    ///\n+    /// ### Why is this bad?\n+    /// `.into_iter()` is simpler with better performance.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # use std::collections::HashSet;\n+    /// let mut foo = vec![0, 1, 2, 3];\n+    /// let bar: HashSet<usize> = foo.drain(..).collect();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # use std::collections::HashSet;\n+    /// let foo = vec![0, 1, 2, 3];\n+    /// let bar: HashSet<usize> = foo.into_iter().collect();\n+    /// ```\n+    #[clippy::version = \"1.61.0\"]\n+    pub ITER_WITH_DRAIN,\n+    nursery,\n+    \"replace `.drain(..)` with `.into_iter()`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for using `x.get(x.len() - 1)` instead of\n+    /// `x.last()`.\n+    ///\n+    /// ### Why is this bad?\n+    /// Using `x.last()` is easier to read and has the same\n+    /// result.\n+    ///\n+    /// Note that using `x[x.len() - 1]` is semantically different from\n+    /// `x.last()`.  Indexing into the array will panic on out-of-bounds\n+    /// accesses, while `x.get()` and `x.last()` will return `None`.\n+    ///\n+    /// There is another lint (get_unwrap) that covers the case of using\n+    /// `x.get(index).unwrap()` instead of `x[index]`.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// // Bad\n+    /// let x = vec![2, 3, 5];\n+    /// let last_element = x.get(x.len() - 1);\n+    ///\n+    /// // Good\n+    /// let x = vec![2, 3, 5];\n+    /// let last_element = x.last();\n+    /// ```\n+    #[clippy::version = \"1.37.0\"]\n+    pub GET_LAST_WITH_LEN,\n+    complexity,\n+    \"Using `x.get(x.len() - 1)` when `x.last()` is correct and simpler\"\n+}\n+\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for use of `.get().unwrap()` (or\n@@ -1176,7 +1301,7 @@ declare_clippy_lint! {\n     #[clippy::version = \"1.55.0\"]\n     pub EXTEND_WITH_DRAIN,\n     perf,\n-    \"using vec.append(&mut vec) to move the full range of a vecor to another\"\n+    \"using vec.append(&mut vec) to move the full range of a vector to another\"\n }\n \n declare_clippy_lint! {\n@@ -1309,7 +1434,7 @@ declare_clippy_lint! {\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for `filter_map` calls which could be replaced by `filter` or `map`.\n+    /// Checks for `filter_map` calls that could be replaced by `filter` or `map`.\n     /// More specifically it checks if the closure provided is only performing one of the\n     /// filter or map operations and suggests the appropriate option.\n     ///\n@@ -1337,6 +1462,36 @@ declare_clippy_lint! {\n     \"using `filter_map` when a more succinct alternative exists\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `find_map` calls that could be replaced by `find` or `map`. More\n+    /// specifically it checks if the closure provided is only performing one of the\n+    /// find or map operations and suggests the appropriate option.\n+    ///\n+    /// ### Why is this bad?\n+    /// Complexity. The intent is also clearer if only a single\n+    /// operation is being performed.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let _ = (0..3).find_map(|x| if x > 2 { Some(x) } else { None });\n+    ///\n+    /// // As there is no transformation of the argument this could be written as:\n+    /// let _ = (0..3).find(|&x| x > 2);\n+    /// ```\n+    ///\n+    /// ```rust\n+    /// let _ = (0..4).find_map(|x| Some(x + 1));\n+    ///\n+    /// // As there is no conditional check on the argument this could be written as:\n+    /// let _ = (0..4).map(|x| x + 1).next();\n+    /// ```\n+    #[clippy::version = \"1.61.0\"]\n+    pub UNNECESSARY_FIND_MAP,\n+    complexity,\n+    \"using `find_map` when a more succinct alternative exists\"\n+}\n+\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for `into_iter` calls on references which should be replaced by `iter`\n@@ -1442,7 +1597,7 @@ declare_clippy_lint! {\n     #[clippy::version = \"1.39.0\"]\n     pub MANUAL_SATURATING_ARITHMETIC,\n     style,\n-    \"`.chcked_add/sub(x).unwrap_or(MAX/MIN)`\"\n+    \"`.checked_add/sub(x).unwrap_or(MAX/MIN)`\"\n }\n \n declare_clippy_lint! {\n@@ -1655,8 +1810,6 @@ declare_clippy_lint! {\n     ///\n     /// ### Example\n     /// ```rust\n-    /// use std::iter::FromIterator;\n-    ///\n     /// let five_fives = std::iter::repeat(5).take(5);\n     ///\n     /// let v = Vec::from_iter(five_fives);\n@@ -1888,13 +2041,27 @@ declare_clippy_lint! {\n     /// ### Example\n     /// ```rust,ignore\n     /// // Bad\n-    ///  let (key, value) = _.splitn(2, '=').next_tuple()?;\n-    ///  let value = _.splitn(2, '=').nth(1)?;\n+    /// let s = \"key=value=add\";\n+    /// let (key, value) = s.splitn(2, '=').next_tuple()?;\n+    /// let value = s.splitn(2, '=').nth(1)?;\n     ///\n+    /// let mut parts = s.splitn(2, '=');\n+    /// let key = parts.next()?;\n+    /// let value = parts.next()?;\n+    /// ```\n+    /// Use instead:\n+    /// ```rust,ignore\n     /// // Good\n-    /// let (key, value) = _.split_once('=')?;\n-    /// let value = _.split_once('=')?.1;\n+    /// let s = \"key=value=add\";\n+    /// let (key, value) = s.split_once('=')?;\n+    /// let value = s.split_once('=')?.1;\n+    ///\n+    /// let (key, value) = s.split_once('=')?;\n     /// ```\n+    ///\n+    /// ### Limitations\n+    /// The multiple statement variant currently only detects `iter.next()?`/`iter.next().unwrap()`\n+    /// in two separate `let` statements that immediately follow the `splitn()`\n     #[clippy::version = \"1.57.0\"]\n     pub MANUAL_SPLIT_ONCE,\n     complexity,\n@@ -1956,17 +2123,150 @@ declare_clippy_lint! {\n     \"unnecessary calls to `to_owned`-like functions\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for use of `.collect::<Vec<String>>().join(\"\")` on iterators.\n+    ///\n+    /// ### Why is this bad?\n+    /// `.collect::<String>()` is more concise and might be more performant\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let vector = vec![\"hello\",  \"world\"];\n+    /// let output = vector.iter().map(|item| item.to_uppercase()).collect::<Vec<String>>().join(\"\");\n+    /// println!(\"{}\", output);\n+    /// ```\n+    /// The correct use would be:\n+    /// ```rust\n+    /// let vector = vec![\"hello\",  \"world\"];\n+    /// let output = vector.iter().map(|item| item.to_uppercase()).collect::<String>();\n+    /// println!(\"{}\", output);\n+    /// ```\n+    /// ### Known problems\n+    /// While `.collect::<String>()` is sometimes more performant, there are cases where\n+    /// using `.collect::<String>()` over `.collect::<Vec<String>>().join(\"\")`\n+    /// will prevent loop unrolling and will result in a negative performance impact.\n+    ///\n+    /// Additionally, differences have been observed between aarch64 and x86_64 assembly output,\n+    /// with aarch64 tending to producing faster assembly in more cases when using `.collect::<String>()`\n+    #[clippy::version = \"1.61.0\"]\n+    pub UNNECESSARY_JOIN,\n+    pedantic,\n+    \"using `.collect::<Vec<String>>().join(\\\"\\\")` on an iterator\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for no-op uses of `Option::{as_deref, as_deref_mut}`,\n+    /// for example, `Option<&T>::as_deref()` returns the same type.\n+    ///\n+    /// ### Why is this bad?\n+    /// Redundant code and improving readability.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let a = Some(&1);\n+    /// let b = a.as_deref(); // goes from Option<&i32> to Option<&i32>\n+    /// ```\n+    /// Could be written as:\n+    /// ```rust\n+    /// let a = Some(&1);\n+    /// let b = a;\n+    /// ```\n+    #[clippy::version = \"1.57.0\"]\n+    pub NEEDLESS_OPTION_AS_DEREF,\n+    complexity,\n+    \"no-op use of `deref` or `deref_mut` method to `Option`.\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Finds usages of [`char::is_digit`]\n+    /// (https://doc.rust-lang.org/stable/std/primitive.char.html#method.is_digit) that\n+    /// can be replaced with [`is_ascii_digit`]\n+    /// (https://doc.rust-lang.org/stable/std/primitive.char.html#method.is_ascii_digit) or\n+    /// [`is_ascii_hexdigit`]\n+    /// (https://doc.rust-lang.org/stable/std/primitive.char.html#method.is_ascii_hexdigit).\n+    ///\n+    /// ### Why is this bad?\n+    /// `is_digit(..)` is slower and requires specifying the radix.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let c: char = '6';\n+    /// c.is_digit(10);\n+    /// c.is_digit(16);\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let c: char = '6';\n+    /// c.is_ascii_digit();\n+    /// c.is_ascii_hexdigit();\n+    /// ```\n+    #[clippy::version = \"1.61.0\"]\n+    pub IS_DIGIT_ASCII_RADIX,\n+    style,\n+    \"use of `char::is_digit(..)` with literal radix of 10 or 16\"\n+}\n+\n+declare_clippy_lint! {\n+    ///\n+    /// ### Why is this bad?\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x = Some(3);\n+    /// x.as_ref().take();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let x = Some(3);\n+    /// x.as_ref();\n+    /// ```\n+    #[clippy::version = \"1.61.0\"]\n+    pub NEEDLESS_OPTION_TAKE,\n+    complexity,\n+    \"using `.as_ref().take()` on a temporary value\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `replace` statements which have no effect.\n+    ///\n+    /// ### Why is this bad?\n+    /// It's either a mistake or confusing.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// \"1234\".replace(\"12\", \"12\");\n+    /// \"1234\".replacen(\"12\", \"12\", 1);\n+    /// ```\n+    #[clippy::version = \"1.62.0\"]\n+    pub NO_EFFECT_REPLACE,\n+    suspicious,\n+    \"replace with no effect\"\n+}\n+\n pub struct Methods {\n     avoid_breaking_exported_api: bool,\n     msrv: Option<RustcVersion>,\n+    allow_expect_in_tests: bool,\n+    allow_unwrap_in_tests: bool,\n }\n \n impl Methods {\n     #[must_use]\n-    pub fn new(avoid_breaking_exported_api: bool, msrv: Option<RustcVersion>) -> Self {\n+    pub fn new(\n+        avoid_breaking_exported_api: bool,\n+        msrv: Option<RustcVersion>,\n+        allow_expect_in_tests: bool,\n+        allow_unwrap_in_tests: bool,\n+    ) -> Self {\n         Self {\n             avoid_breaking_exported_api,\n             msrv,\n+            allow_expect_in_tests,\n+            allow_unwrap_in_tests,\n         }\n     }\n }\n@@ -1983,6 +2283,7 @@ impl_lint_pass!(Methods => [\n     OPTION_MAP_OR_NONE,\n     BIND_INSTEAD_OF_MAP,\n     OR_FUN_CALL,\n+    OR_THEN_UNWRAP,\n     EXPECT_FUN_CALL,\n     CHARS_NEXT_CMP,\n     CHARS_LAST_CMP,\n@@ -2015,11 +2316,14 @@ impl_lint_pass!(Methods => [\n     BYTES_NTH,\n     ITER_SKIP_NEXT,\n     GET_UNWRAP,\n+    GET_LAST_WITH_LEN,\n     STRING_EXTEND_CHARS,\n     ITER_CLONED_COLLECT,\n+    ITER_WITH_DRAIN,\n     USELESS_ASREF,\n     UNNECESSARY_FOLD,\n     UNNECESSARY_FILTER_MAP,\n+    UNNECESSARY_FIND_MAP,\n     INTO_ITER_ON_REF,\n     SUSPICIOUS_MAP,\n     UNINIT_ASSUMED_INIT,\n@@ -2038,6 +2342,12 @@ impl_lint_pass!(Methods => [\n     MANUAL_SPLIT_ONCE,\n     NEEDLESS_SPLITN,\n     UNNECESSARY_TO_OWNED,\n+    UNNECESSARY_JOIN,\n+    ERR_EXPECT,\n+    NEEDLESS_OPTION_AS_DEREF,\n+    IS_DIGIT_ASCII_RADIX,\n+    NEEDLESS_OPTION_TAKE,\n+    NO_EFFECT_REPLACE,\n ]);\n \n /// Extracts a method call name, args, and `Span` of the method name.\n@@ -2057,7 +2367,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             return;\n         }\n \n-        check_methods(cx, expr, self.msrv.as_ref());\n+        self.check_methods(cx, expr);\n \n         match expr.kind {\n             hir::ExprKind::Call(func, args) => {\n@@ -2073,7 +2383,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                 single_char_add_str::check(cx, expr, args);\n                 into_iter_on_ref::check(cx, expr, method_span, method_call.ident.name, args);\n                 single_char_pattern::check(cx, expr, method_call.ident.name, args);\n-                unnecessary_to_owned::check(cx, expr, method_call.ident.name, args);\n+                unnecessary_to_owned::check(cx, expr, method_call.ident.name, args, self.msrv);\n             },\n             hir::ExprKind::Binary(op, lhs, rhs) if op.node == hir::BinOpKind::Eq || op.node == hir::BinOpKind::Ne => {\n                 let mut info = BinaryExprInfo {\n@@ -2106,7 +2416,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             let method_sig = cx.tcx.fn_sig(impl_item.def_id);\n             let method_sig = cx.tcx.erase_late_bound_regions(method_sig);\n \n-            let first_arg_ty = &method_sig.inputs().iter().next();\n+            let first_arg_ty = method_sig.inputs().iter().next();\n \n             // check conventions w.r.t. conversion method names and predicates\n             if let Some(first_arg_ty) = first_arg_ty;\n@@ -2119,7 +2429,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                         if name == method_config.method_name &&\n                             sig.decl.inputs.len() == method_config.param_count &&\n                             method_config.output_type.matches(&sig.decl.output) &&\n-                            method_config.self_kind.matches(cx, self_ty, first_arg_ty) &&\n+                            method_config.self_kind.matches(cx, self_ty, *first_arg_ty) &&\n                             fn_header_equals(method_config.fn_header, sig.header) &&\n                             method_config.lifetime_param_cond(impl_item)\n                         {\n@@ -2151,7 +2461,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                         cx,\n                         name,\n                         self_ty,\n-                        first_arg_ty,\n+                        *first_arg_ty,\n                         first_arg.pat.span,\n                         implements_trait,\n                         false\n@@ -2198,7 +2508,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                 }\n             }\n \n-            if name == \"new\" && !TyS::same_type(ret_ty, self_ty) {\n+            if name == \"new\" && ret_ty != self_ty {\n                 span_lint(\n                     cx,\n                     NEW_RET_NO_SELF,\n@@ -2256,174 +2566,205 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n     extract_msrv_attr!(LateContext);\n }\n \n-#[allow(clippy::too_many_lines)]\n-fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Option<&RustcVersion>) {\n-    if let Some((name, [recv, args @ ..], span)) = method_call(expr) {\n-        match (name, args) {\n-            (\"add\" | \"offset\" | \"sub\" | \"wrapping_offset\" | \"wrapping_add\" | \"wrapping_sub\", [_arg]) => {\n-                zst_offset::check(cx, expr, recv);\n-            },\n-            (\"and_then\", [arg]) => {\n-                let biom_option_linted = bind_instead_of_map::OptionAndThenSome::check(cx, expr, recv, arg);\n-                let biom_result_linted = bind_instead_of_map::ResultAndThenOk::check(cx, expr, recv, arg);\n-                if !biom_option_linted && !biom_result_linted {\n-                    unnecessary_lazy_eval::check(cx, expr, recv, arg, \"and\");\n-                }\n-            },\n-            (\"as_mut\", []) => useless_asref::check(cx, expr, \"as_mut\", recv),\n-            (\"as_ref\", []) => useless_asref::check(cx, expr, \"as_ref\", recv),\n-            (\"assume_init\", []) => uninit_assumed_init::check(cx, expr, recv),\n-            (\"cloned\", []) => cloned_instead_of_copied::check(cx, expr, recv, span, msrv),\n-            (\"collect\", []) => match method_call(recv) {\n-                Some((name @ (\"cloned\" | \"copied\"), [recv2], _)) => {\n-                    iter_cloned_collect::check(cx, name, expr, recv2);\n+impl Methods {\n+    #[allow(clippy::too_many_lines)]\n+    fn check_methods<'tcx>(&self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if let Some((name, [recv, args @ ..], span)) = method_call(expr) {\n+            match (name, args) {\n+                (\"add\" | \"offset\" | \"sub\" | \"wrapping_offset\" | \"wrapping_add\" | \"wrapping_sub\", [_arg]) => {\n+                    zst_offset::check(cx, expr, recv);\n                 },\n-                Some((\"map\", [m_recv, m_arg], _)) => {\n-                    map_collect_result_unit::check(cx, expr, m_recv, m_arg, recv);\n+                (\"and_then\", [arg]) => {\n+                    let biom_option_linted = bind_instead_of_map::OptionAndThenSome::check(cx, expr, recv, arg);\n+                    let biom_result_linted = bind_instead_of_map::ResultAndThenOk::check(cx, expr, recv, arg);\n+                    if !biom_option_linted && !biom_result_linted {\n+                        unnecessary_lazy_eval::check(cx, expr, recv, arg, \"and\");\n+                    }\n+                },\n+                (\"as_deref\" | \"as_deref_mut\", []) => {\n+                    needless_option_as_deref::check(cx, expr, recv, name);\n+                },\n+                (\"as_mut\", []) => useless_asref::check(cx, expr, \"as_mut\", recv),\n+                (\"as_ref\", []) => useless_asref::check(cx, expr, \"as_ref\", recv),\n+                (\"assume_init\", []) => uninit_assumed_init::check(cx, expr, recv),\n+                (\"cloned\", []) => cloned_instead_of_copied::check(cx, expr, recv, span, self.msrv),\n+                (\"collect\", []) => match method_call(recv) {\n+                    Some((name @ (\"cloned\" | \"copied\"), [recv2], _)) => {\n+                        iter_cloned_collect::check(cx, name, expr, recv2);\n+                    },\n+                    Some((\"map\", [m_recv, m_arg], _)) => {\n+                        map_collect_result_unit::check(cx, expr, m_recv, m_arg, recv);\n+                    },\n+                    Some((\"take\", [take_self_arg, take_arg], _)) => {\n+                        if meets_msrv(self.msrv, msrvs::STR_REPEAT) {\n+                            manual_str_repeat::check(cx, expr, recv, take_self_arg, take_arg);\n+                        }\n+                    },\n+                    _ => {},\n+                },\n+                (name @ \"count\", args @ []) => match method_call(recv) {\n+                    Some((\"cloned\", [recv2], _)) => iter_overeager_cloned::check(cx, expr, recv2, name, args),\n+                    Some((name2 @ (\"into_iter\" | \"iter\" | \"iter_mut\"), [recv2], _)) => {\n+                        iter_count::check(cx, expr, recv2, name2);\n+                    },\n+                    Some((\"map\", [_, arg], _)) => suspicious_map::check(cx, expr, recv, arg),\n+                    _ => {},\n+                },\n+                (\"drain\", [arg]) => {\n+                    iter_with_drain::check(cx, expr, recv, span, arg);\n+                },\n+                (\"expect\", [_]) => match method_call(recv) {\n+                    Some((\"ok\", [recv], _)) => ok_expect::check(cx, expr, recv),\n+                    Some((\"err\", [recv], err_span)) => err_expect::check(cx, expr, recv, self.msrv, span, err_span),\n+                    _ => expect_used::check(cx, expr, recv, self.allow_expect_in_tests),\n                 },\n-                Some((\"take\", [take_self_arg, take_arg], _)) => {\n-                    if meets_msrv(msrv, &msrvs::STR_REPEAT) {\n-                        manual_str_repeat::check(cx, expr, recv, take_self_arg, take_arg);\n+                (\"extend\", [arg]) => {\n+                    string_extend_chars::check(cx, expr, recv, arg);\n+                    extend_with_drain::check(cx, expr, recv, arg);\n+                },\n+                (\"filter_map\", [arg]) => {\n+                    unnecessary_filter_map::check(cx, expr, arg, name);\n+                    filter_map_identity::check(cx, expr, arg, span);\n+                },\n+                (\"find_map\", [arg]) => {\n+                    unnecessary_filter_map::check(cx, expr, arg, name);\n+                },\n+                (\"flat_map\", [arg]) => {\n+                    flat_map_identity::check(cx, expr, arg, span);\n+                    flat_map_option::check(cx, expr, arg, span);\n+                },\n+                (name @ \"flatten\", args @ []) => match method_call(recv) {\n+                    Some((\"map\", [recv, map_arg], map_span)) => map_flatten::check(cx, expr, recv, map_arg, map_span),\n+                    Some((\"cloned\", [recv2], _)) => iter_overeager_cloned::check(cx, expr, recv2, name, args),\n+                    _ => {},\n+                },\n+                (\"fold\", [init, acc]) => unnecessary_fold::check(cx, expr, init, acc, span),\n+                (\"for_each\", [_]) => {\n+                    if let Some((\"inspect\", [_, _], span2)) = method_call(recv) {\n+                        inspect_for_each::check(cx, expr, span2);\n                     }\n                 },\n-                _ => {},\n-            },\n-            (name @ \"count\", args @ []) => match method_call(recv) {\n-                Some((\"cloned\", [recv2], _)) => iter_overeager_cloned::check(cx, expr, recv2, name, args),\n-                Some((name2 @ (\"into_iter\" | \"iter\" | \"iter_mut\"), [recv2], _)) => {\n-                    iter_count::check(cx, expr, recv2, name2);\n+                (\"get\", [arg]) => get_last_with_len::check(cx, expr, recv, arg),\n+                (\"get_or_insert_with\", [arg]) => unnecessary_lazy_eval::check(cx, expr, recv, arg, \"get_or_insert\"),\n+                (\"is_file\", []) => filetype_is_file::check(cx, expr, recv),\n+                (\"is_digit\", [radix]) => is_digit_ascii_radix::check(cx, expr, recv, radix, self.msrv),\n+                (\"is_none\", []) => check_is_some_is_none(cx, expr, recv, false),\n+                (\"is_some\", []) => check_is_some_is_none(cx, expr, recv, true),\n+                (\"join\", [join_arg]) => {\n+                    if let Some((\"collect\", _, span)) = method_call(recv) {\n+                        unnecessary_join::check(cx, expr, recv, join_arg, span);\n+                    }\n                 },\n-                Some((\"map\", [_, arg], _)) => suspicious_map::check(cx, expr, recv, arg),\n-                _ => {},\n-            },\n-            (\"expect\", [_]) => match method_call(recv) {\n-                Some((\"ok\", [recv], _)) => ok_expect::check(cx, expr, recv),\n-                _ => expect_used::check(cx, expr, recv),\n-            },\n-            (\"extend\", [arg]) => {\n-                string_extend_chars::check(cx, expr, recv, arg);\n-                extend_with_drain::check(cx, expr, recv, arg);\n-            },\n-            (\"filter_map\", [arg]) => {\n-                unnecessary_filter_map::check(cx, expr, arg);\n-                filter_map_identity::check(cx, expr, arg, span);\n-            },\n-            (\"flat_map\", [arg]) => {\n-                flat_map_identity::check(cx, expr, arg, span);\n-                flat_map_option::check(cx, expr, arg, span);\n-            },\n-            (name @ \"flatten\", args @ []) => match method_call(recv) {\n-                Some((\"map\", [recv, map_arg], _)) => map_flatten::check(cx, expr, recv, map_arg),\n-                Some((\"cloned\", [recv2], _)) => iter_overeager_cloned::check(cx, expr, recv2, name, args),\n-                _ => {},\n-            },\n-            (\"fold\", [init, acc]) => unnecessary_fold::check(cx, expr, init, acc, span),\n-            (\"for_each\", [_]) => {\n-                if let Some((\"inspect\", [_, _], span2)) = method_call(recv) {\n-                    inspect_for_each::check(cx, expr, span2);\n-                }\n-            },\n-            (\"get_or_insert_with\", [arg]) => unnecessary_lazy_eval::check(cx, expr, recv, arg, \"get_or_insert\"),\n-            (\"is_file\", []) => filetype_is_file::check(cx, expr, recv),\n-            (\"is_none\", []) => check_is_some_is_none(cx, expr, recv, false),\n-            (\"is_some\", []) => check_is_some_is_none(cx, expr, recv, true),\n-            (\"last\", args @ []) | (\"skip\", args @ [_]) => {\n-                if let Some((name2, [recv2, args2 @ ..], _span2)) = method_call(recv) {\n-                    if let (\"cloned\", []) = (name2, args2) {\n-                        iter_overeager_cloned::check(cx, expr, recv2, name, args);\n+                (\"last\", args @ []) | (\"skip\", args @ [_]) => {\n+                    if let Some((name2, [recv2, args2 @ ..], _span2)) = method_call(recv) {\n+                        if let (\"cloned\", []) = (name2, args2) {\n+                            iter_overeager_cloned::check(cx, expr, recv2, name, args);\n+                        }\n                     }\n-                }\n-            },\n-            (\"map\", [m_arg]) => {\n-                if let Some((name, [recv2, args @ ..], span2)) = method_call(recv) {\n-                    match (name, args) {\n-                        (\"as_mut\", []) => option_as_ref_deref::check(cx, expr, recv2, m_arg, true, msrv),\n-                        (\"as_ref\", []) => option_as_ref_deref::check(cx, expr, recv2, m_arg, false, msrv),\n-                        (\"filter\", [f_arg]) => {\n-                            filter_map::check(cx, expr, recv2, f_arg, span2, recv, m_arg, span, false);\n-                        },\n-                        (\"find\", [f_arg]) => filter_map::check(cx, expr, recv2, f_arg, span2, recv, m_arg, span, true),\n-                        _ => {},\n+                },\n+                (name @ (\"map\" | \"map_err\"), [m_arg]) => {\n+                    if let Some((name, [recv2, args @ ..], span2)) = method_call(recv) {\n+                        match (name, args) {\n+                            (\"as_mut\", []) => option_as_ref_deref::check(cx, expr, recv2, m_arg, true, self.msrv),\n+                            (\"as_ref\", []) => option_as_ref_deref::check(cx, expr, recv2, m_arg, false, self.msrv),\n+                            (\"filter\", [f_arg]) => {\n+                                filter_map::check(cx, expr, recv2, f_arg, span2, recv, m_arg, span, false);\n+                            },\n+                            (\"find\", [f_arg]) => {\n+                                filter_map::check(cx, expr, recv2, f_arg, span2, recv, m_arg, span, true);\n+                            },\n+                            _ => {},\n+                        }\n                     }\n-                }\n-                map_identity::check(cx, expr, recv, m_arg, span);\n-            },\n-            (\"map_or\", [def, map]) => option_map_or_none::check(cx, expr, recv, def, map),\n-            (name @ \"next\", args @ []) => {\n-                if let Some((name2, [recv2, args2 @ ..], _)) = method_call(recv) {\n-                    match (name2, args2) {\n-                        (\"cloned\", []) => iter_overeager_cloned::check(cx, expr, recv2, name, args),\n-                        (\"filter\", [arg]) => filter_next::check(cx, expr, recv2, arg),\n-                        (\"filter_map\", [arg]) => filter_map_next::check(cx, expr, recv2, arg, msrv),\n-                        (\"iter\", []) => iter_next_slice::check(cx, expr, recv2),\n-                        (\"skip\", [arg]) => iter_skip_next::check(cx, expr, recv2, arg),\n-                        (\"skip_while\", [_]) => skip_while_next::check(cx, expr),\n-                        _ => {},\n+                    map_identity::check(cx, expr, recv, m_arg, name, span);\n+                },\n+                (\"map_or\", [def, map]) => option_map_or_none::check(cx, expr, recv, def, map),\n+                (name @ \"next\", args @ []) => {\n+                    if let Some((name2, [recv2, args2 @ ..], _)) = method_call(recv) {\n+                        match (name2, args2) {\n+                            (\"cloned\", []) => iter_overeager_cloned::check(cx, expr, recv2, name, args),\n+                            (\"filter\", [arg]) => filter_next::check(cx, expr, recv2, arg),\n+                            (\"filter_map\", [arg]) => filter_map_next::check(cx, expr, recv2, arg, self.msrv),\n+                            (\"iter\", []) => iter_next_slice::check(cx, expr, recv2),\n+                            (\"skip\", [arg]) => iter_skip_next::check(cx, expr, recv2, arg),\n+                            (\"skip_while\", [_]) => skip_while_next::check(cx, expr),\n+                            _ => {},\n+                        }\n                     }\n-                }\n-            },\n-            (\"nth\", args @ [n_arg]) => match method_call(recv) {\n-                Some((\"bytes\", [recv2], _)) => bytes_nth::check(cx, expr, recv2, n_arg),\n-                Some((\"cloned\", [recv2], _)) => iter_overeager_cloned::check(cx, expr, recv2, name, args),\n-                Some((\"iter\", [recv2], _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, false),\n-                Some((\"iter_mut\", [recv2], _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, true),\n-                _ => iter_nth_zero::check(cx, expr, recv, n_arg),\n-            },\n-            (\"ok_or_else\", [arg]) => unnecessary_lazy_eval::check(cx, expr, recv, arg, \"ok_or\"),\n-            (\"or_else\", [arg]) => {\n-                if !bind_instead_of_map::ResultOrElseErrInfo::check(cx, expr, recv, arg) {\n-                    unnecessary_lazy_eval::check(cx, expr, recv, arg, \"or\");\n-                }\n-            },\n-            (\"splitn\" | \"rsplitn\", [count_arg, pat_arg]) => {\n-                if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg) {\n-                    suspicious_splitn::check(cx, name, expr, recv, count);\n-                    if count == 2 && meets_msrv(msrv, &msrvs::STR_SPLIT_ONCE) {\n-                        str_splitn::check_manual_split_once(cx, name, expr, recv, pat_arg);\n+                },\n+                (\"nth\", args @ [n_arg]) => match method_call(recv) {\n+                    Some((\"bytes\", [recv2], _)) => bytes_nth::check(cx, expr, recv2, n_arg),\n+                    Some((\"cloned\", [recv2], _)) => iter_overeager_cloned::check(cx, expr, recv2, name, args),\n+                    Some((\"iter\", [recv2], _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, false),\n+                    Some((\"iter_mut\", [recv2], _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, true),\n+                    _ => iter_nth_zero::check(cx, expr, recv, n_arg),\n+                },\n+                (\"ok_or_else\", [arg]) => unnecessary_lazy_eval::check(cx, expr, recv, arg, \"ok_or\"),\n+                (\"or_else\", [arg]) => {\n+                    if !bind_instead_of_map::ResultOrElseErrInfo::check(cx, expr, recv, arg) {\n+                        unnecessary_lazy_eval::check(cx, expr, recv, arg, \"or\");\n                     }\n-                    if count >= 2 {\n-                        str_splitn::check_needless_splitn(cx, name, expr, recv, pat_arg, count);\n+                },\n+                (\"splitn\" | \"rsplitn\", [count_arg, pat_arg]) => {\n+                    if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg) {\n+                        suspicious_splitn::check(cx, name, expr, recv, count);\n+                        str_splitn::check(cx, name, expr, recv, pat_arg, count, self.msrv);\n                     }\n-                }\n-            },\n-            (\"splitn_mut\" | \"rsplitn_mut\", [count_arg, _]) => {\n-                if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg) {\n-                    suspicious_splitn::check(cx, name, expr, recv, count);\n-                }\n-            },\n-            (\"step_by\", [arg]) => iterator_step_by_zero::check(cx, expr, arg),\n-            (\"take\", args @ [_arg]) => {\n-                if let Some((name2, [recv2, args2 @ ..], _span2)) = method_call(recv) {\n-                    if let (\"cloned\", []) = (name2, args2) {\n-                        iter_overeager_cloned::check(cx, expr, recv2, name, args);\n+                },\n+                (\"splitn_mut\" | \"rsplitn_mut\", [count_arg, _]) => {\n+                    if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg) {\n+                        suspicious_splitn::check(cx, name, expr, recv, count);\n+                    }\n+                },\n+                (\"step_by\", [arg]) => iterator_step_by_zero::check(cx, expr, arg),\n+                (\"take\", args @ [_arg]) => {\n+                    if let Some((name2, [recv2, args2 @ ..], _span2)) = method_call(recv) {\n+                        if let (\"cloned\", []) = (name2, args2) {\n+                            iter_overeager_cloned::check(cx, expr, recv2, name, args);\n+                        }\n                     }\n-                }\n-            },\n-            (\"to_os_string\" | \"to_owned\" | \"to_path_buf\" | \"to_vec\", []) => {\n-                implicit_clone::check(cx, name, expr, recv);\n-            },\n-            (\"unwrap\", []) => match method_call(recv) {\n-                Some((\"get\", [recv, get_arg], _)) => get_unwrap::check(cx, expr, recv, get_arg, false),\n-                Some((\"get_mut\", [recv, get_arg], _)) => get_unwrap::check(cx, expr, recv, get_arg, true),\n-                _ => unwrap_used::check(cx, expr, recv),\n-            },\n-            (\"unwrap_or\", [u_arg]) => match method_call(recv) {\n-                Some((arith @ (\"checked_add\" | \"checked_sub\" | \"checked_mul\"), [lhs, rhs], _)) => {\n-                    manual_saturating_arithmetic::check(cx, expr, lhs, rhs, u_arg, &arith[\"checked_\".len()..]);\n                 },\n-                Some((\"map\", [m_recv, m_arg], span)) => {\n-                    option_map_unwrap_or::check(cx, expr, m_recv, m_arg, recv, u_arg, span);\n+                (\"take\", []) => needless_option_take::check(cx, expr, recv),\n+                (\"to_os_string\" | \"to_owned\" | \"to_path_buf\" | \"to_vec\", []) => {\n+                    implicit_clone::check(cx, name, expr, recv);\n                 },\n-                _ => {},\n-            },\n-            (\"unwrap_or_else\", [u_arg]) => match method_call(recv) {\n-                Some((\"map\", [recv, map_arg], _)) if map_unwrap_or::check(cx, expr, recv, map_arg, u_arg, msrv) => {},\n-                _ => {\n-                    unwrap_or_else_default::check(cx, expr, recv, u_arg);\n-                    unnecessary_lazy_eval::check(cx, expr, recv, u_arg, \"unwrap_or\");\n+                (\"unwrap\", []) => {\n+                    match method_call(recv) {\n+                        Some((\"get\", [recv, get_arg], _)) => {\n+                            get_unwrap::check(cx, expr, recv, get_arg, false);\n+                        },\n+                        Some((\"get_mut\", [recv, get_arg], _)) => {\n+                            get_unwrap::check(cx, expr, recv, get_arg, true);\n+                        },\n+                        Some((\"or\", [recv, or_arg], or_span)) => {\n+                            or_then_unwrap::check(cx, expr, recv, or_arg, or_span);\n+                        },\n+                        _ => {},\n+                    }\n+                    unwrap_used::check(cx, expr, recv, self.allow_unwrap_in_tests);\n                 },\n-            },\n-            _ => {},\n+                (\"unwrap_or\", [u_arg]) => match method_call(recv) {\n+                    Some((arith @ (\"checked_add\" | \"checked_sub\" | \"checked_mul\"), [lhs, rhs], _)) => {\n+                        manual_saturating_arithmetic::check(cx, expr, lhs, rhs, u_arg, &arith[\"checked_\".len()..]);\n+                    },\n+                    Some((\"map\", [m_recv, m_arg], span)) => {\n+                        option_map_unwrap_or::check(cx, expr, m_recv, m_arg, recv, u_arg, span);\n+                    },\n+                    _ => {},\n+                },\n+                (\"unwrap_or_else\", [u_arg]) => match method_call(recv) {\n+                    Some((\"map\", [recv, map_arg], _))\n+                        if map_unwrap_or::check(cx, expr, recv, map_arg, u_arg, self.msrv) => {},\n+                    _ => {\n+                        unwrap_or_else_default::check(cx, expr, recv, u_arg);\n+                        unnecessary_lazy_eval::check(cx, expr, recv, u_arg, \"unwrap_or\");\n+                    },\n+                },\n+                (\"replace\" | \"replacen\", [arg1, arg2] | [arg1, arg2, _]) => {\n+                    no_effect_replace::check(cx, expr, arg1, arg2);\n+                },\n+                _ => {},\n+            }\n         }\n     }\n }\n@@ -2550,7 +2891,7 @@ const TRAIT_METHODS: [ShouldImplTraitCase; 30] = [\n     ShouldImplTraitCase::new(\"std::ops::Sub\", \"sub\",  2,  FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n ];\n \n-#[derive(Clone, Copy, PartialEq, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n enum SelfKind {\n     Value,\n     Ref,"}, {"sha": "7030baf19ff5cf9bd9fd714a8ac9e319e957a54d", "filename": "clippy_lints/src/methods/needless_option_as_deref.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fneedless_option_as_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fneedless_option_as_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fneedless_option_as_deref.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,37 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::path_res;\n+use clippy_utils::source::snippet_opt;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::usage::local_used_after_expr;\n+use rustc_errors::Applicability;\n+use rustc_hir::def::Res;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+use super::NEEDLESS_OPTION_AS_DEREF;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, name: &str) {\n+    let typeck = cx.typeck_results();\n+    let outer_ty = typeck.expr_ty(expr);\n+\n+    if is_type_diagnostic_item(cx, outer_ty, sym::Option) && outer_ty == typeck.expr_ty(recv) {\n+        if name == \"as_deref_mut\" && recv.is_syntactic_place_expr() {\n+            let Res::Local(binding_id) = path_res(cx, recv) else { return };\n+\n+            if local_used_after_expr(cx, binding_id, recv) {\n+                return;\n+            }\n+        }\n+\n+        span_lint_and_sugg(\n+            cx,\n+            NEEDLESS_OPTION_AS_DEREF,\n+            expr.span,\n+            \"derefed type is same as origin\",\n+            \"try this\",\n+            snippet_opt(cx, recv.span).unwrap(),\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}"}, {"sha": "829c118d2916386974ab7835e8be9fe72a2bf5c1", "filename": "clippy_lints/src/methods/needless_option_take.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fneedless_option_take.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fneedless_option_take.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fneedless_option_take.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,41 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::match_def_path;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+use super::NEEDLESS_OPTION_TAKE;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, recv: &'tcx Expr<'_>) {\n+    // Checks if expression type is equal to sym::Option and if the expr is not a syntactic place\n+    if !recv.is_syntactic_place_expr() && is_expr_option(cx, recv) && has_expr_as_ref_path(cx, recv) {\n+        let mut applicability = Applicability::MachineApplicable;\n+        span_lint_and_sugg(\n+            cx,\n+            NEEDLESS_OPTION_TAKE,\n+            expr.span,\n+            \"called `Option::take()` on a temporary value\",\n+            \"try\",\n+            format!(\n+                \"{}\",\n+                snippet_with_applicability(cx, recv.span, \"..\", &mut applicability)\n+            ),\n+            applicability,\n+        );\n+    }\n+}\n+\n+fn is_expr_option(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    let expr_type = cx.typeck_results().expr_ty(expr);\n+    is_type_diagnostic_item(cx, expr_type, sym::Option)\n+}\n+\n+fn has_expr_as_ref_path(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    if let Some(ref_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id) {\n+        return match_def_path(cx, ref_id, &[\"core\", \"option\", \"Option\", \"as_ref\"]);\n+    }\n+    false\n+}"}, {"sha": "a76341855b6db8fbb34cb2fb56f98317091acb2b", "filename": "clippy_lints/src/methods/no_effect_replace.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fno_effect_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fno_effect_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fno_effect_replace.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,47 @@\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::SpanlessEq;\n+use if_chain::if_chain;\n+use rustc_ast::LitKind;\n+use rustc_hir::ExprKind;\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+use super::NO_EFFECT_REPLACE;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx rustc_hir::Expr<'_>,\n+    arg1: &'tcx rustc_hir::Expr<'_>,\n+    arg2: &'tcx rustc_hir::Expr<'_>,\n+) {\n+    let ty = cx.typeck_results().expr_ty(expr).peel_refs();\n+    if !(ty.is_str() || is_type_diagnostic_item(cx, ty, sym::String)) {\n+        return;\n+    }\n+\n+    if_chain! {\n+        if let ExprKind::Lit(spanned) = &arg1.kind;\n+        if let Some(param1) = lit_string_value(&spanned.node);\n+\n+        if let ExprKind::Lit(spanned) = &arg2.kind;\n+        if let LitKind::Str(param2, _) = &spanned.node;\n+        if param1 == param2.as_str();\n+\n+        then {\n+            span_lint(cx, NO_EFFECT_REPLACE, expr.span, \"replacing text with itself\");\n+        }\n+    }\n+\n+    if SpanlessEq::new(cx).eq_expr(arg1, arg2) {\n+        span_lint(cx, NO_EFFECT_REPLACE, expr.span, \"replacing text with itself\");\n+    }\n+}\n+\n+fn lit_string_value(node: &LitKind) -> Option<String> {\n+    match node {\n+        LitKind::Char(value) => Some(value.to_string()),\n+        LitKind::Str(value, _) => Some(value.as_str().to_owned()),\n+        _ => None,\n+    }\n+}"}, {"sha": "b50a173d8359b83ab361506f2737be370bc432af", "filename": "clippy_lints/src/methods/option_as_ref_deref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -19,9 +19,9 @@ pub(super) fn check<'tcx>(\n     as_ref_recv: &hir::Expr<'_>,\n     map_arg: &hir::Expr<'_>,\n     is_mut: bool,\n-    msrv: Option<&RustcVersion>,\n+    msrv: Option<RustcVersion>,\n ) {\n-    if !meets_msrv(msrv, &msrvs::OPTION_AS_DEREF) {\n+    if !meets_msrv(msrv, msrvs::OPTION_AS_DEREF) {\n         return;\n     }\n "}, {"sha": "76bc9466ed81800e23cdf94f4f8b771a2cc1a895", "filename": "clippy_lints/src/methods/option_map_or_none.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,30 +1,28 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{is_lang_ctor, single_segment_path};\n+use clippy_utils::{is_lang_ctor, path_def_id};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_lint::LateContext;\n+use rustc_middle::ty::DefIdTree;\n use rustc_span::symbol::sym;\n \n use super::OPTION_MAP_OR_NONE;\n use super::RESULT_MAP_OR_INTO_OPTION;\n \n // The expression inside a closure may or may not have surrounding braces\n // which causes problems when generating a suggestion.\n-fn reduce_unit_expression<'a>(\n-    cx: &LateContext<'_>,\n-    expr: &'a hir::Expr<'_>,\n-) -> Option<(&'a hir::Expr<'a>, &'a [hir::Expr<'a>])> {\n+fn reduce_unit_expression<'a>(expr: &'a hir::Expr<'_>) -> Option<(&'a hir::Expr<'a>, &'a [hir::Expr<'a>])> {\n     match expr.kind {\n         hir::ExprKind::Call(func, arg_char) => Some((func, arg_char)),\n         hir::ExprKind::Block(block, _) => {\n             match (block.stmts, block.expr) {\n                 (&[], Some(inner_expr)) => {\n                     // If block only contains an expression,\n                     // reduce `|x| { x + 1 }` to `|x| x + 1`\n-                    reduce_unit_expression(cx, inner_expr)\n+                    reduce_unit_expression(inner_expr)\n                 },\n                 _ => None,\n             }\n@@ -76,13 +74,11 @@ pub(super) fn check<'tcx>(\n         if let hir::ExprKind::Closure(_, _, id, span, _) = map_arg.kind;\n             let arg_snippet = snippet(cx, span, \"..\");\n             let body = cx.tcx.hir().body(id);\n-                if let Some((func, arg_char)) = reduce_unit_expression(cx, &body.value);\n-                if arg_char.len() == 1;\n-                if let hir::ExprKind::Path(ref qpath) = func.kind;\n-                if let Some(segment) = single_segment_path(qpath);\n-                if segment.ident.name == sym::Some;\n+                if let Some((func, [arg_char])) = reduce_unit_expression(&body.value);\n+                if let Some(id) = path_def_id(cx, func).map(|ctor_id| cx.tcx.parent(ctor_id));\n+                if Some(id) == cx.tcx.lang_items().option_some_variant();\n                 then {\n-                    let func_snippet = snippet(cx, arg_char[0].span, \"..\");\n+                    let func_snippet = snippet(cx, arg_char.span, \"..\");\n                     let msg = \"called `map_or(None, ..)` on an `Option` value. This can be done more directly by calling \\\n                        `map(..)` instead\";\n                     return span_lint_and_sugg("}, {"sha": "6c641af59f92b9c6a3f1b6941c01305f8b8bd464", "filename": "clippy_lints/src/methods/option_map_unwrap_or.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,5 +1,4 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::differing_macro_contexts;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_copy;\n use clippy_utils::ty::is_type_diagnostic_item;\n@@ -48,7 +47,7 @@ pub(super) fn check<'tcx>(\n             }\n         }\n \n-        if differing_macro_contexts(unwrap_arg.span, map_span) {\n+        if unwrap_arg.span.ctxt() != map_span.ctxt() {\n             return;\n         }\n "}, {"sha": "be5768c354504790eb9e073750d88759e9a1725a", "filename": "clippy_lints/src/methods/or_then_unwrap.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2For_then_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2For_then_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2For_then_unwrap.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,68 @@\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{diagnostics::span_lint_and_sugg, is_lang_ctor};\n+use rustc_errors::Applicability;\n+use rustc_hir::{lang_items::LangItem, Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_span::{sym, Span};\n+\n+use super::OR_THEN_UNWRAP;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    unwrap_expr: &Expr<'_>,\n+    recv: &'tcx Expr<'tcx>,\n+    or_arg: &'tcx Expr<'_>,\n+    or_span: Span,\n+) {\n+    let ty = cx.typeck_results().expr_ty(recv); // get type of x (we later check if it's Option or Result)\n+    let title;\n+    let or_arg_content: Span;\n+\n+    if is_type_diagnostic_item(cx, ty, sym::Option) {\n+        title = \"found `.or(Some(\u2026)).unwrap()`\";\n+        if let Some(content) = get_content_if_ctor_matches(cx, or_arg, LangItem::OptionSome) {\n+            or_arg_content = content;\n+        } else {\n+            return;\n+        }\n+    } else if is_type_diagnostic_item(cx, ty, sym::Result) {\n+        title = \"found `.or(Ok(\u2026)).unwrap()`\";\n+        if let Some(content) = get_content_if_ctor_matches(cx, or_arg, LangItem::ResultOk) {\n+            or_arg_content = content;\n+        } else {\n+            return;\n+        }\n+    } else {\n+        // Someone has implemented a struct with .or(...).unwrap() chaining,\n+        // but it's not an Option or a Result, so bail\n+        return;\n+    }\n+\n+    let mut applicability = Applicability::MachineApplicable;\n+    let suggestion = format!(\n+        \"unwrap_or({})\",\n+        snippet_with_applicability(cx, or_arg_content, \"..\", &mut applicability)\n+    );\n+\n+    span_lint_and_sugg(\n+        cx,\n+        OR_THEN_UNWRAP,\n+        unwrap_expr.span.with_lo(or_span.lo()),\n+        title,\n+        \"try this\",\n+        suggestion,\n+        applicability,\n+    );\n+}\n+\n+fn get_content_if_ctor_matches(cx: &LateContext<'_>, expr: &Expr<'_>, item: LangItem) -> Option<Span> {\n+    if let ExprKind::Call(some_expr, [arg]) = expr.kind\n+        && let ExprKind::Path(qpath) = &some_expr.kind\n+        && is_lang_ctor(cx, qpath, item)\n+    {\n+        Some(arg.span)\n+    } else {\n+        None\n+    }\n+}"}, {"sha": "90651a6ba045888935fa1b6a29294e191d775662", "filename": "clippy_lints/src/methods/str_splitn.rs", "status": "modified", "additions": 241, "deletions": 174, "changes": 415, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,36 +1,83 @@\n use clippy_utils::consts::{constant, Constant};\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::snippet_with_context;\n-use clippy_utils::{is_diag_item_method, match_def_path, paths};\n+use clippy_utils::usage::local_used_after_expr;\n+use clippy_utils::visitors::expr_visitor;\n+use clippy_utils::{is_diag_item_method, match_def_path, meets_msrv, msrvs, path_to_local_id, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, HirId, LangItem, Node, QPath};\n+use rustc_hir::intravisit::Visitor;\n+use rustc_hir::{\n+    BindingAnnotation, Expr, ExprKind, HirId, LangItem, Local, MatchSource, Node, Pat, PatKind, QPath, Stmt, StmtKind,\n+};\n use rustc_lint::LateContext;\n-use rustc_middle::ty::{self, adjustment::Adjust};\n-use rustc_span::{symbol::sym, Span, SyntaxContext};\n+use rustc_middle::ty;\n+use rustc_semver::RustcVersion;\n+use rustc_span::{sym, Span, Symbol, SyntaxContext};\n \n-use super::MANUAL_SPLIT_ONCE;\n+use super::{MANUAL_SPLIT_ONCE, NEEDLESS_SPLITN};\n \n-pub(super) fn check_manual_split_once(\n+pub(super) fn check(\n     cx: &LateContext<'_>,\n     method_name: &str,\n     expr: &Expr<'_>,\n     self_arg: &Expr<'_>,\n     pat_arg: &Expr<'_>,\n+    count: u128,\n+    msrv: Option<RustcVersion>,\n ) {\n-    if !cx.typeck_results().expr_ty_adjusted(self_arg).peel_refs().is_str() {\n+    if count < 2 || !cx.typeck_results().expr_ty_adjusted(self_arg).peel_refs().is_str() {\n         return;\n     }\n \n+    let needless = |usage_kind| match usage_kind {\n+        IterUsageKind::Nth(n) => count > n + 1,\n+        IterUsageKind::NextTuple => count > 2,\n+    };\n+    let manual = count == 2 && meets_msrv(msrv, msrvs::STR_SPLIT_ONCE);\n+\n+    match parse_iter_usage(cx, expr.span.ctxt(), cx.tcx.hir().parent_iter(expr.hir_id)) {\n+        Some(usage) if needless(usage.kind) => lint_needless(cx, method_name, expr, self_arg, pat_arg),\n+        Some(usage) if manual => check_manual_split_once(cx, method_name, expr, self_arg, pat_arg, &usage),\n+        None if manual => {\n+            check_manual_split_once_indirect(cx, method_name, expr, self_arg, pat_arg);\n+        },\n+        _ => {},\n+    }\n+}\n+\n+fn lint_needless(cx: &LateContext<'_>, method_name: &str, expr: &Expr<'_>, self_arg: &Expr<'_>, pat_arg: &Expr<'_>) {\n+    let mut app = Applicability::MachineApplicable;\n+    let r = if method_name == \"splitn\" { \"\" } else { \"r\" };\n+\n+    span_lint_and_sugg(\n+        cx,\n+        NEEDLESS_SPLITN,\n+        expr.span,\n+        &format!(\"unnecessary use of `{r}splitn`\"),\n+        \"try this\",\n+        format!(\n+            \"{}.{r}split({})\",\n+            snippet_with_context(cx, self_arg.span, expr.span.ctxt(), \"..\", &mut app).0,\n+            snippet_with_context(cx, pat_arg.span, expr.span.ctxt(), \"..\", &mut app).0,\n+        ),\n+        app,\n+    );\n+}\n+\n+fn check_manual_split_once(\n+    cx: &LateContext<'_>,\n+    method_name: &str,\n+    expr: &Expr<'_>,\n+    self_arg: &Expr<'_>,\n+    pat_arg: &Expr<'_>,\n+    usage: &IterUsage,\n+) {\n     let ctxt = expr.span.ctxt();\n-    let (method_name, msg, reverse) = if method_name == \"splitn\" {\n-        (\"split_once\", \"manual implementation of `split_once`\", false)\n+    let (msg, reverse) = if method_name == \"splitn\" {\n+        (\"manual implementation of `split_once`\", false)\n     } else {\n-        (\"rsplit_once\", \"manual implementation of `rsplit_once`\", true)\n-    };\n-    let usage = match parse_iter_usage(cx, ctxt, cx.tcx.hir().parent_iter(expr.hir_id), reverse) {\n-        Some(x) => x,\n-        None => return,\n+        (\"manual implementation of `rsplit_once`\", true)\n     };\n \n     let mut app = Applicability::MachineApplicable;\n@@ -39,84 +86,198 @@ pub(super) fn check_manual_split_once(\n \n     let sugg = match usage.kind {\n         IterUsageKind::NextTuple => {\n-            format!(\"{}.{}({})\", self_snip, method_name, pat_snip)\n-        },\n-        IterUsageKind::RNextTuple => format!(\"{}.{}({}).map(|(x, y)| (y, x))\", self_snip, method_name, pat_snip),\n-        IterUsageKind::Next | IterUsageKind::Second => {\n-            let self_deref = {\n-                let adjust = cx.typeck_results().expr_adjustments(self_arg);\n-                if adjust.len() < 2 {\n-                    String::new()\n-                } else if cx.typeck_results().expr_ty(self_arg).is_box()\n-                    || adjust\n-                        .iter()\n-                        .any(|a| matches!(a.kind, Adjust::Deref(Some(_))) || a.target.is_box())\n-                {\n-                    format!(\"&{}\", \"*\".repeat(adjust.len().saturating_sub(1)))\n-                } else {\n-                    \"*\".repeat(adjust.len().saturating_sub(2))\n-                }\n-            };\n-            if matches!(usage.kind, IterUsageKind::Next) {\n-                match usage.unwrap_kind {\n-                    Some(UnwrapKind::Unwrap) => {\n-                        if reverse {\n-                            format!(\"{}.{}({}).unwrap().0\", self_snip, method_name, pat_snip)\n-                        } else {\n-                            format!(\n-                                \"{}.{}({}).map_or({}{}, |x| x.0)\",\n-                                self_snip, method_name, pat_snip, self_deref, &self_snip\n-                            )\n-                        }\n-                    },\n-                    Some(UnwrapKind::QuestionMark) => {\n-                        format!(\n-                            \"{}.{}({}).map_or({}{}, |x| x.0)\",\n-                            self_snip, method_name, pat_snip, self_deref, &self_snip\n-                        )\n-                    },\n-                    None => {\n-                        format!(\n-                            \"Some({}.{}({}).map_or({}{}, |x| x.0))\",\n-                            &self_snip, method_name, pat_snip, self_deref, &self_snip\n-                        )\n-                    },\n-                }\n+            if reverse {\n+                format!(\"{self_snip}.rsplit_once({pat_snip}).map(|(x, y)| (y, x))\")\n             } else {\n-                match usage.unwrap_kind {\n-                    Some(UnwrapKind::Unwrap) => {\n-                        if reverse {\n-                            // In this case, no better suggestion is offered.\n-                            return;\n-                        }\n-                        format!(\"{}.{}({}).unwrap().1\", self_snip, method_name, pat_snip)\n-                    },\n-                    Some(UnwrapKind::QuestionMark) => {\n-                        format!(\"{}.{}({})?.1\", self_snip, method_name, pat_snip)\n-                    },\n-                    None => {\n-                        format!(\"{}.{}({}).map(|x| x.1)\", self_snip, method_name, pat_snip)\n-                    },\n-                }\n+                format!(\"{self_snip}.split_once({pat_snip})\")\n+            }\n+        },\n+        IterUsageKind::Nth(1) => {\n+            let (r, field) = if reverse { (\"r\", 0) } else { (\"\", 1) };\n+\n+            match usage.unwrap_kind {\n+                Some(UnwrapKind::Unwrap) => {\n+                    format!(\"{self_snip}.{r}split_once({pat_snip}).unwrap().{field}\")\n+                },\n+                Some(UnwrapKind::QuestionMark) => {\n+                    format!(\"{self_snip}.{r}split_once({pat_snip})?.{field}\")\n+                },\n+                None => {\n+                    format!(\"{self_snip}.{r}split_once({pat_snip}).map(|x| x.{field})\")\n+                },\n             }\n         },\n+        IterUsageKind::Nth(_) => return,\n     };\n \n     span_lint_and_sugg(cx, MANUAL_SPLIT_ONCE, usage.span, msg, \"try this\", sugg, app);\n }\n \n+/// checks for\n+///\n+/// ```\n+/// let mut iter = \"a.b.c\".splitn(2, '.');\n+/// let a = iter.next();\n+/// let b = iter.next();\n+/// ```\n+fn check_manual_split_once_indirect(\n+    cx: &LateContext<'_>,\n+    method_name: &str,\n+    expr: &Expr<'_>,\n+    self_arg: &Expr<'_>,\n+    pat_arg: &Expr<'_>,\n+) -> Option<()> {\n+    let ctxt = expr.span.ctxt();\n+    let mut parents = cx.tcx.hir().parent_iter(expr.hir_id);\n+    if let (_, Node::Local(local)) = parents.next()?\n+        && let PatKind::Binding(BindingAnnotation::Mutable, iter_binding_id, iter_ident, None) = local.pat.kind\n+        && let (iter_stmt_id, Node::Stmt(_)) = parents.next()?\n+        && let (_, Node::Block(enclosing_block)) = parents.next()?\n+\n+        && let mut stmts = enclosing_block\n+            .stmts\n+            .iter()\n+            .skip_while(|stmt| stmt.hir_id != iter_stmt_id)\n+            .skip(1)\n+\n+        && let first = indirect_usage(cx, stmts.next()?, iter_binding_id, ctxt)?\n+        && let second = indirect_usage(cx, stmts.next()?, iter_binding_id, ctxt)?\n+        && first.unwrap_kind == second.unwrap_kind\n+        && first.name != second.name\n+        && !local_used_after_expr(cx, iter_binding_id, second.init_expr)\n+    {\n+        let (r, lhs, rhs) = if method_name == \"splitn\" {\n+            (\"\", first.name, second.name)\n+        } else {\n+            (\"r\", second.name, first.name)\n+        };\n+        let msg = format!(\"manual implementation of `{r}split_once`\");\n+\n+        let mut app = Applicability::MachineApplicable;\n+        let self_snip = snippet_with_context(cx, self_arg.span, ctxt, \"..\", &mut app).0;\n+        let pat_snip = snippet_with_context(cx, pat_arg.span, ctxt, \"..\", &mut app).0;\n+\n+        span_lint_and_then(cx, MANUAL_SPLIT_ONCE, local.span, &msg, |diag| {\n+            diag.span_label(first.span, \"first usage here\");\n+            diag.span_label(second.span, \"second usage here\");\n+\n+            let unwrap = match first.unwrap_kind {\n+                UnwrapKind::Unwrap => \".unwrap()\",\n+                UnwrapKind::QuestionMark => \"?\",\n+            };\n+            diag.span_suggestion_verbose(\n+                local.span,\n+                &format!(\"try `{r}split_once`\"),\n+                format!(\"let ({lhs}, {rhs}) = {self_snip}.{r}split_once({pat_snip}){unwrap};\"),\n+                app,\n+            );\n+\n+            let remove_msg = format!(\"remove the `{iter_ident}` usages\");\n+            diag.span_suggestion(\n+                first.span,\n+                &remove_msg,\n+                String::new(),\n+                app,\n+            );\n+            diag.span_suggestion(\n+                second.span,\n+                &remove_msg,\n+                String::new(),\n+                app,\n+            );\n+        });\n+    }\n+\n+    Some(())\n+}\n+\n+#[derive(Debug)]\n+struct IndirectUsage<'a> {\n+    name: Symbol,\n+    span: Span,\n+    init_expr: &'a Expr<'a>,\n+    unwrap_kind: UnwrapKind,\n+}\n+\n+/// returns `Some(IndirectUsage)` for e.g.\n+///\n+/// ```ignore\n+/// let name = binding.next()?;\n+/// let name = binding.next().unwrap();\n+/// ```\n+fn indirect_usage<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    stmt: &Stmt<'tcx>,\n+    binding: HirId,\n+    ctxt: SyntaxContext,\n+) -> Option<IndirectUsage<'tcx>> {\n+    if let StmtKind::Local(Local {\n+        pat:\n+            Pat {\n+                kind: PatKind::Binding(BindingAnnotation::Unannotated, _, ident, None),\n+                ..\n+            },\n+        init: Some(init_expr),\n+        hir_id: local_hir_id,\n+        ..\n+    }) = stmt.kind\n+    {\n+        let mut path_to_binding = None;\n+        expr_visitor(cx, |expr| {\n+            if path_to_local_id(expr, binding) {\n+                path_to_binding = Some(expr);\n+            }\n+\n+            path_to_binding.is_none()\n+        })\n+        .visit_expr(init_expr);\n+\n+        let mut parents = cx.tcx.hir().parent_iter(path_to_binding?.hir_id);\n+        let iter_usage = parse_iter_usage(cx, ctxt, &mut parents)?;\n+\n+        let (parent_id, _) = parents.find(|(_, node)| {\n+            !matches!(\n+                node,\n+                Node::Expr(Expr {\n+                    kind: ExprKind::Match(.., MatchSource::TryDesugar),\n+                    ..\n+                })\n+            )\n+        })?;\n+\n+        if let IterUsage {\n+            kind: IterUsageKind::Nth(0),\n+            unwrap_kind: Some(unwrap_kind),\n+            ..\n+        } = iter_usage\n+        {\n+            if parent_id == *local_hir_id {\n+                return Some(IndirectUsage {\n+                    name: ident.name,\n+                    span: stmt.span,\n+                    init_expr,\n+                    unwrap_kind,\n+                });\n+            }\n+        }\n+    }\n+\n+    None\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n enum IterUsageKind {\n-    Next,\n-    Second,\n+    Nth(u128),\n     NextTuple,\n-    RNextTuple,\n }\n \n+#[derive(Debug, PartialEq, Eq)]\n enum UnwrapKind {\n     Unwrap,\n     QuestionMark,\n }\n \n+#[derive(Debug)]\n struct IterUsage {\n     kind: IterUsageKind,\n     unwrap_kind: Option<UnwrapKind>,\n@@ -128,7 +289,6 @@ fn parse_iter_usage<'tcx>(\n     cx: &LateContext<'tcx>,\n     ctxt: SyntaxContext,\n     mut iter: impl Iterator<Item = (HirId, Node<'tcx>)>,\n-    reverse: bool,\n ) -> Option<IterUsage> {\n     let (kind, span) = match iter.next() {\n         Some((_, Node::Expr(e))) if e.span.ctxt() == ctxt => {\n@@ -141,23 +301,17 @@ fn parse_iter_usage<'tcx>(\n             let iter_id = cx.tcx.get_diagnostic_item(sym::Iterator)?;\n \n             match (name.ident.as_str(), args) {\n-                (\"next\", []) if cx.tcx.trait_of_item(did) == Some(iter_id) => {\n-                    if reverse {\n-                        (IterUsageKind::Second, e.span)\n-                    } else {\n-                        (IterUsageKind::Next, e.span)\n-                    }\n-                },\n+                (\"next\", []) if cx.tcx.trait_of_item(did) == Some(iter_id) => (IterUsageKind::Nth(0), e.span),\n                 (\"next_tuple\", []) => {\n                     return if_chain! {\n                         if match_def_path(cx, did, &paths::ITERTOOLS_NEXT_TUPLE);\n                         if let ty::Adt(adt_def, subs) = cx.typeck_results().expr_ty(e).kind();\n-                        if cx.tcx.is_diagnostic_item(sym::Option, adt_def.did);\n+                        if cx.tcx.is_diagnostic_item(sym::Option, adt_def.did());\n                         if let ty::Tuple(subs) = subs.type_at(0).kind();\n                         if subs.len() == 2;\n                         then {\n                             Some(IterUsage {\n-                                kind: if reverse { IterUsageKind::RNextTuple } else { IterUsageKind::NextTuple },\n+                                kind: IterUsageKind::NextTuple,\n                                 span: e.span,\n                                 unwrap_kind: None\n                             })\n@@ -185,11 +339,7 @@ fn parse_iter_usage<'tcx>(\n                                 }\n                             }\n                         };\n-                        match if reverse { idx ^ 1 } else { idx } {\n-                            0 => (IterUsageKind::Next, span),\n-                            1 => (IterUsageKind::Second, span),\n-                            _ => return None,\n-                        }\n+                        (IterUsageKind::Nth(idx), span)\n                     } else {\n                         return None;\n                     }\n@@ -238,86 +388,3 @@ fn parse_iter_usage<'tcx>(\n         span,\n     })\n }\n-\n-use super::NEEDLESS_SPLITN;\n-\n-pub(super) fn check_needless_splitn(\n-    cx: &LateContext<'_>,\n-    method_name: &str,\n-    expr: &Expr<'_>,\n-    self_arg: &Expr<'_>,\n-    pat_arg: &Expr<'_>,\n-    count: u128,\n-) {\n-    if !cx.typeck_results().expr_ty_adjusted(self_arg).peel_refs().is_str() {\n-        return;\n-    }\n-    let ctxt = expr.span.ctxt();\n-    let mut app = Applicability::MachineApplicable;\n-    let (reverse, message) = if method_name == \"splitn\" {\n-        (false, \"unnecessary use of `splitn`\")\n-    } else {\n-        (true, \"unnecessary use of `rsplitn`\")\n-    };\n-    if_chain! {\n-        if count >= 2;\n-        if check_iter(cx, ctxt, cx.tcx.hir().parent_iter(expr.hir_id), count);\n-        then {\n-            span_lint_and_sugg(\n-                cx,\n-                NEEDLESS_SPLITN,\n-                expr.span,\n-                message,\n-                \"try this\",\n-                format!(\n-                    \"{}.{}({})\",\n-                    snippet_with_context(cx, self_arg.span, ctxt, \"..\", &mut app).0,\n-                    if reverse {\"rsplit\"} else {\"split\"},\n-                    snippet_with_context(cx, pat_arg.span, ctxt, \"..\", &mut app).0\n-                ),\n-                app,\n-            );\n-        }\n-    }\n-}\n-\n-fn check_iter<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    ctxt: SyntaxContext,\n-    mut iter: impl Iterator<Item = (HirId, Node<'tcx>)>,\n-    count: u128,\n-) -> bool {\n-    match iter.next() {\n-        Some((_, Node::Expr(e))) if e.span.ctxt() == ctxt => {\n-            let (name, args) = if let ExprKind::MethodCall(name, [_, args @ ..], _) = e.kind {\n-                (name, args)\n-            } else {\n-                return false;\n-            };\n-            if_chain! {\n-                if let Some(did) = cx.typeck_results().type_dependent_def_id(e.hir_id);\n-                if let Some(iter_id) = cx.tcx.get_diagnostic_item(sym::Iterator);\n-                then {\n-                    match (name.ident.as_str(), args) {\n-                        (\"next\", []) if cx.tcx.trait_of_item(did) == Some(iter_id) => {\n-                            return true;\n-                        },\n-                        (\"next_tuple\", []) if count > 2 => {\n-                            return true;\n-                        },\n-                        (\"nth\", [idx_expr]) if cx.tcx.trait_of_item(did) == Some(iter_id) => {\n-                            if let Some((Constant::Int(idx), _)) = constant(cx, cx.typeck_results(), idx_expr) {\n-                                if count > idx + 1 {\n-                                    return true;\n-                                }\n-                            }\n-                        },\n-                        _ =>  return false,\n-                    }\n-                }\n-            }\n-        },\n-        _ => return false,\n-    };\n-    false\n-}"}, {"sha": "55567d8625e529dfc541d3bf937284c130a9e516", "filename": "clippy_lints/src/methods/suspicious_splitn.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_splitn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_splitn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_splitn.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -12,13 +12,13 @@ pub(super) fn check(cx: &LateContext<'_>, method_name: &str, expr: &Expr<'_>, se\n         if count <= 1;\n         if let Some(call_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n         if let Some(impl_id) = cx.tcx.impl_of_method(call_id);\n-        let lang_items = cx.tcx.lang_items();\n-        if lang_items.slice_impl() == Some(impl_id) || lang_items.str_impl() == Some(impl_id);\n+        if cx.tcx.impl_trait_ref(impl_id).is_none();\n+        let self_ty = cx.tcx.type_of(impl_id);\n+        if self_ty.is_slice() || self_ty.is_str();\n         then {\n             // Ignore empty slice and string literals when used with a literal count.\n             if matches!(self_arg.kind, ExprKind::Array([]))\n                 || matches!(self_arg.kind, ExprKind::Lit(Spanned { node: LitKind::Str(s, _), .. }) if s.is_empty())\n-\n             {\n                 return;\n             }\n@@ -28,7 +28,7 @@ pub(super) fn check(cx: &LateContext<'_>, method_name: &str, expr: &Expr<'_>, se\n                 \"the resulting iterator will always return `None`\")\n             } else {\n                 (format!(\"`{}` called with `1` split\", method_name),\n-                if lang_items.slice_impl() == Some(impl_id) {\n+                if self_ty.is_slice() {\n                     \"the resulting iterator will always return the entire slice followed by `None`\"\n                 } else {\n                     \"the resulting iterator will always return the entire string followed by `None`\""}, {"sha": "77d21f1d3730c66afeb7ac64f42ea735dd1e611e", "filename": "clippy_lints/src/methods/uninit_assumed_init.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,8 +1,9 @@\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::{is_expr_path_def_path, paths, ty::is_uninit_value_valid_for_ty};\n+use clippy_utils::{is_expr_diagnostic_item, ty::is_uninit_value_valid_for_ty};\n use if_chain::if_chain;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n+use rustc_span::sym;\n \n use super::UNINIT_ASSUMED_INIT;\n \n@@ -11,7 +12,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr\n     if_chain! {\n         if let hir::ExprKind::Call(callee, args) = recv.kind;\n         if args.is_empty();\n-        if is_expr_path_def_path(cx, callee, &paths::MEM_MAYBEUNINIT_UNINIT);\n+        if is_expr_diagnostic_item(cx, callee, sym::maybe_uninit_uninit);\n         if !is_uninit_value_valid_for_ty(cx, cx.typeck_results().expr_ty_adjusted(expr));\n         then {\n             span_lint("}, {"sha": "2fda254ca98e99ddf1820a790842ab0af2163a16", "filename": "clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,16 +1,19 @@\n+use super::utils::clone_or_copy_needed;\n use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::ty::is_copy;\n use clippy_utils::usage::mutated_variables;\n use clippy_utils::{is_lang_ctor, is_trait_method, path_to_local_id};\n use rustc_hir as hir;\n use rustc_hir::intravisit::{walk_expr, Visitor};\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_lint::LateContext;\n-use rustc_middle::ty::{self, TyS};\n+use rustc_middle::ty;\n use rustc_span::sym;\n \n use super::UNNECESSARY_FILTER_MAP;\n+use super::UNNECESSARY_FIND_MAP;\n \n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>, name: &str) {\n     if !is_trait_method(cx, expr, sym::Iterator) {\n         return;\n     }\n@@ -20,6 +23,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<\n         let arg_id = body.params[0].pat.hir_id;\n         let mutates_arg =\n             mutated_variables(&body.value, cx).map_or(true, |used_mutably| used_mutably.contains(&arg_id));\n+        let (clone_or_copy_needed, _) = clone_or_copy_needed(cx, body.params[0].pat, &body.value);\n \n         let (mut found_mapping, mut found_filtering) = check_expression(cx, arg_id, &body.value);\n \n@@ -28,15 +32,15 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<\n         found_mapping |= return_visitor.found_mapping;\n         found_filtering |= return_visitor.found_filtering;\n \n+        let in_ty = cx.typeck_results().node_type(body.params[0].hir_id);\n         let sugg = if !found_filtering {\n-            \"map\"\n-        } else if !found_mapping && !mutates_arg {\n-            let in_ty = cx.typeck_results().node_type(body.params[0].hir_id);\n+            if name == \"filter_map\" { \"map\" } else { \"map(..).next()\" }\n+        } else if !found_mapping && !mutates_arg && (!clone_or_copy_needed || is_copy(cx, in_ty)) {\n             match cx.typeck_results().expr_ty(&body.value).kind() {\n                 ty::Adt(adt, subst)\n-                    if cx.tcx.is_diagnostic_item(sym::Option, adt.did) && TyS::same_type(in_ty, subst.type_at(0)) =>\n+                    if cx.tcx.is_diagnostic_item(sym::Option, adt.did()) && in_ty == subst.type_at(0) =>\n                 {\n-                    \"filter\"\n+                    if name == \"filter_map\" { \"filter\" } else { \"find\" }\n                 },\n                 _ => return,\n             }\n@@ -45,9 +49,13 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<\n         };\n         span_lint(\n             cx,\n-            UNNECESSARY_FILTER_MAP,\n+            if name == \"filter_map\" {\n+                UNNECESSARY_FILTER_MAP\n+            } else {\n+                UNNECESSARY_FIND_MAP\n+            },\n             expr.span,\n-            &format!(\"this `.filter_map` can be written more simply using `.{}`\", sugg),\n+            &format!(\"this `.{}` can be written more simply using `.{}`\", name, sugg),\n         );\n     }\n }"}, {"sha": "7a39557ad5757971a1bdcfddc31697232184f29e", "filename": "clippy_lints/src/methods/unnecessary_iter_cloned.rs", "status": "modified", "additions": 3, "deletions": 88, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,14 +1,12 @@\n+use super::utils::clone_or_copy_needed;\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher::ForLoop;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::{get_associated_type, get_iterator_item_ty, implements_trait};\n-use clippy_utils::{fn_def_id, get_parent_expr, path_to_local_id, usage};\n+use clippy_utils::{fn_def_id, get_parent_expr};\n use rustc_errors::Applicability;\n-use rustc_hir::intravisit::{walk_expr, Visitor};\n-use rustc_hir::{def_id::DefId, BorrowKind, Expr, ExprKind, HirId, LangItem, Mutability, Pat};\n+use rustc_hir::{def_id::DefId, Expr, ExprKind, LangItem};\n use rustc_lint::LateContext;\n-use rustc_middle::hir::nested_filter;\n-use rustc_middle::ty;\n use rustc_span::{sym, Symbol};\n \n use super::UNNECESSARY_TO_OWNED;\n@@ -100,89 +98,6 @@ pub fn check_for_loop_iter(\n     false\n }\n \n-/// The core logic of `check_for_loop_iter` above, this function wraps a use of\n-/// `CloneOrCopyVisitor`.\n-fn clone_or_copy_needed<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    pat: &Pat<'tcx>,\n-    body: &'tcx Expr<'tcx>,\n-) -> (bool, Vec<&'tcx Expr<'tcx>>) {\n-    let mut visitor = CloneOrCopyVisitor {\n-        cx,\n-        binding_hir_ids: pat_bindings(pat),\n-        clone_or_copy_needed: false,\n-        addr_of_exprs: Vec::new(),\n-    };\n-    visitor.visit_expr(body);\n-    (visitor.clone_or_copy_needed, visitor.addr_of_exprs)\n-}\n-\n-/// Returns a vector of all `HirId`s bound by the pattern.\n-fn pat_bindings(pat: &Pat<'_>) -> Vec<HirId> {\n-    let mut collector = usage::ParamBindingIdCollector {\n-        binding_hir_ids: Vec::new(),\n-    };\n-    collector.visit_pat(pat);\n-    collector.binding_hir_ids\n-}\n-\n-/// `clone_or_copy_needed` will be false when `CloneOrCopyVisitor` is done visiting if the only\n-/// operations performed on `binding_hir_ids` are:\n-/// * to take non-mutable references to them\n-/// * to use them as non-mutable `&self` in method calls\n-/// If any of `binding_hir_ids` is used in any other way, then `clone_or_copy_needed` will be true\n-/// when `CloneOrCopyVisitor` is done visiting.\n-struct CloneOrCopyVisitor<'cx, 'tcx> {\n-    cx: &'cx LateContext<'tcx>,\n-    binding_hir_ids: Vec<HirId>,\n-    clone_or_copy_needed: bool,\n-    addr_of_exprs: Vec<&'tcx Expr<'tcx>>,\n-}\n-\n-impl<'cx, 'tcx> Visitor<'tcx> for CloneOrCopyVisitor<'cx, 'tcx> {\n-    type NestedFilter = nested_filter::OnlyBodies;\n-\n-    fn nested_visit_map(&mut self) -> Self::Map {\n-        self.cx.tcx.hir()\n-    }\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-        walk_expr(self, expr);\n-        if self.is_binding(expr) {\n-            if let Some(parent) = get_parent_expr(self.cx, expr) {\n-                match parent.kind {\n-                    ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, _) => {\n-                        self.addr_of_exprs.push(parent);\n-                        return;\n-                    },\n-                    ExprKind::MethodCall(_, args, _) => {\n-                        if_chain! {\n-                            if args.iter().skip(1).all(|arg| !self.is_binding(arg));\n-                            if let Some(method_def_id) = self.cx.typeck_results().type_dependent_def_id(parent.hir_id);\n-                            let method_ty = self.cx.tcx.type_of(method_def_id);\n-                            let self_ty = method_ty.fn_sig(self.cx.tcx).input(0).skip_binder();\n-                            if matches!(self_ty.kind(), ty::Ref(_, _, Mutability::Not));\n-                            then {\n-                                return;\n-                            }\n-                        }\n-                    },\n-                    _ => {},\n-                }\n-            }\n-            self.clone_or_copy_needed = true;\n-        }\n-    }\n-}\n-\n-impl<'cx, 'tcx> CloneOrCopyVisitor<'cx, 'tcx> {\n-    fn is_binding(&self, expr: &Expr<'tcx>) -> bool {\n-        self.binding_hir_ids\n-            .iter()\n-            .any(|hir_id| path_to_local_id(expr, *hir_id))\n-    }\n-}\n-\n /// Returns true if the named method is `IntoIterator::into_iter`.\n pub fn is_into_iter(cx: &LateContext<'_>, callee_def_id: DefId) -> bool {\n     cx.tcx.lang_items().require(LangItem::IntoIterIntoIter) == Ok(callee_def_id)"}, {"sha": "973b8a7e6bf6a9409f44e399e31d2bbbd3e1ea10", "filename": "clippy_lints/src/methods/unnecessary_join.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_join.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_join.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_join.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -0,0 +1,41 @@\n+use clippy_utils::{diagnostics::span_lint_and_sugg, ty::is_type_diagnostic_item};\n+use rustc_ast::ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{Ref, Slice};\n+use rustc_span::{sym, Span};\n+\n+use super::UNNECESSARY_JOIN;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'tcx>,\n+    join_self_arg: &'tcx Expr<'tcx>,\n+    join_arg: &'tcx Expr<'tcx>,\n+    span: Span,\n+) {\n+    let applicability = Applicability::MachineApplicable;\n+    let collect_output_adjusted_type = cx.typeck_results().expr_ty_adjusted(join_self_arg);\n+    if_chain! {\n+        // the turbofish for collect is ::<Vec<String>>\n+        if let Ref(_, ref_type, _) = collect_output_adjusted_type.kind();\n+        if let Slice(slice) = ref_type.kind();\n+        if is_type_diagnostic_item(cx, *slice, sym::String);\n+        // the argument for join is \"\"\n+        if let ExprKind::Lit(spanned) = &join_arg.kind;\n+        if let LitKind::Str(symbol, _) = spanned.node;\n+        if symbol.is_empty();\n+        then {\n+            span_lint_and_sugg(\n+                cx,\n+                UNNECESSARY_JOIN,\n+                span.with_hi(expr.span.hi()),\n+                r#\"called `.collect<Vec<String>>().join(\"\")` on an iterator\"#,\n+                \"try using\",\n+                \"collect::<String>()\".to_owned(),\n+                applicability,\n+            );\n+        }\n+    }\n+}"}, {"sha": "2369be708129403f242fcdbfd55204d1295cf47b", "filename": "clippy_lints/src/methods/unnecessary_lazy_eval.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "patch": "@@ -1,4 +1,4 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::{eager_or_lazy, usage};\n@@ -48,20 +48,19 @@ pub(super) fn check<'tcx>(\n                     Applicability::MaybeIncorrect\n                 };\n \n-                span_lint_and_sugg(\n-                    cx,\n-                    UNNECESSARY_LAZY_EVALUATIONS,\n-                    expr.span,\n-                    msg,\n-                    &format!(\"use `{}` instead\", simplify_using),\n-                    format!(\n-                        \"{0}.{1}({2})\",\n-                        snippet(cx, recv.span, \"..\"),\n-                        simplify_using,\n-                        snippet(cx, body_expr.span, \"..\"),\n-                    ),\n-                    applicability,\n-                );\n+                // This is a duplicate of what's happening in clippy_lints::methods::method_call,\n+                // which isn't ideal, We want to get the method call span,\n+                // but prefer to avoid changing the signature of the function itself.\n+                if let hir::ExprKind::MethodCall(_, _, span) = expr.kind {\n+                    span_lint_and_then(cx, UNNECESSARY_LAZY_EVALUATIONS, expr.span, msg, |diag| {\n+                        diag.span_suggestion(\n+                            span,\n+                            &format!(\"use `{}(..)` instead\", simplify_using),\n+                            format!(\"{}({})\", simplify_using, snippet(cx, body_expr.span, \"..\")),\n+                            applicability,\n+                        );\n+                    });\n+                }\n             }\n         }\n     }"}, {"sha": "97c4feb3122a08fbaf684b56cd6d994bbf81f844", "filename": "clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "5c761014927c28dae2af593d4dcfaf5d46efb28e", "filename": "clippy_lints/src/methods/unwrap_used.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Funwrap_used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Funwrap_used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funwrap_used.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "3015531e8439327c1337e21e89acb6367fb437fa", "filename": "clippy_lints/src/methods/utils.rs", "status": "modified", "additions": 89, "deletions": 2, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Futils.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "4b368d3ffae254abd04ba4727b7b30faed484ef3", "filename": "clippy_lints/src/methods/wrong_self_convention.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "e9f268da691565c926ce31e9ab98ce5486a5ed08", "filename": "clippy_lints/src/methods/zst_offset.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fzst_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmethods%2Fzst_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fzst_offset.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "65d1f440b76391031109a7dbb7a1049cb9d869b3", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "7fdc28c5a062d3376472f4e2834f30d3934139ef", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "6860b60acbdb4612e144604db5ddd53b146e5b46", "filename": "clippy_lints/src/misc_early/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmisc_early%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmisc_early%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early%2Fmod.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "16d65966c10096622166221906219d1fdba863b1", "filename": "clippy_lints/src/missing_const_for_fn.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "b99052e66ba57dc718d998a183e6f6a62d5789ad", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "3d0a23822838e871c3c6ef5f891aa4303505b7d3", "filename": "clippy_lints/src/missing_enforced_import_rename.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmissing_enforced_import_rename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmissing_enforced_import_rename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_enforced_import_rename.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "0d95329918984c68a74d541042995ff1a94ec28b", "filename": "clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_inline.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "405fc23e8de0a5b68cab209b7d34f7bd663cd5f3", "filename": "clippy_lints/src/mixed_read_write_in_expression.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmixed_read_write_in_expression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmixed_read_write_in_expression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmixed_read_write_in_expression.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb", "previous_filename": "clippy_lints/src/eval_order_dependence.rs"}, {"sha": "0a393657267b07833371498eb52b5015faf8c874", "filename": "clippy_lints/src/module_style.rs", "status": "modified", "additions": 26, "deletions": 40, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmodule_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmodule_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmodule_style.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "195b2e5c2ee0a0ff722e1f39bbccadc1ed649b17", "filename": "clippy_lints/src/modulo_arithmetic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmodulo_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmodulo_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmodulo_arithmetic.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "1f9db39cf8ca6a7e9742a2761d4bb89b466614f6", "filename": "clippy_lints/src/multiple_crate_versions.rs", "status": "removed", "additions": 0, "deletions": 101, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/cb29e3effbf72db2e1f5177336bfb3309ec8805e/clippy_lints%2Fsrc%2Fmultiple_crate_versions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb29e3effbf72db2e1f5177336bfb3309ec8805e/clippy_lints%2Fsrc%2Fmultiple_crate_versions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmultiple_crate_versions.rs?ref=cb29e3effbf72db2e1f5177336bfb3309ec8805e"}, {"sha": "cba54e14212d0d18949213c00db27d684eea1237", "filename": "clippy_lints/src/mut_key.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_key.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "b7f981faa2d42c6491d8745fc9b76168bd4a2fe6", "filename": "clippy_lints/src/mut_mutex_lock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmut_mutex_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmut_mutex_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mutex_lock.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "9d8f8999ce409488a8c33f5c1c5a7dd0956a70a2", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "8dba60f3a5854953e6185cc48ca4d4a3cc04d693", "filename": "clippy_lints/src/mutable_debug_assertion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "623d22bc9bdfe6a6a6c1c1ef674da4ff5946e64c", "filename": "clippy_lints/src/needless_bitwise_bool.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fneedless_bitwise_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fneedless_bitwise_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bitwise_bool.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "b70871b38beab178f63735330657ab8388e2f355", "filename": "clippy_lints/src/needless_late_init.rs", "status": "modified", "additions": 44, "deletions": 10, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fneedless_late_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fneedless_late_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_late_init.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "21d8263390af3c813d2ae842d8bfa5f167fa0698", "filename": "clippy_lints/src/needless_option_as_deref.rs", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/cb29e3effbf72db2e1f5177336bfb3309ec8805e/clippy_lints%2Fsrc%2Fneedless_option_as_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb29e3effbf72db2e1f5177336bfb3309ec8805e/clippy_lints%2Fsrc%2Fneedless_option_as_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_option_as_deref.rs?ref=cb29e3effbf72db2e1f5177336bfb3309ec8805e"}, {"sha": "38960103d5e04c5f3aa1e0a23d57272182e6f362", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "8f85b00596c019f248a290b2087771977257e377", "filename": "clippy_lints/src/needless_question_mark.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fneedless_question_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fneedless_question_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_question_mark.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "c87c174ef732cb71824640bd7932ee874402c0b4", "filename": "clippy_lints/src/needless_update.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_update.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "707f3b2181ac9967df8c29d5a7c4ca480e7456d3", "filename": "clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_multiply.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "093ec389335db80d9a75e6ca6b566aad3c02fc16", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "8db41ba6ee296f399877221d2c24b77d6c0e6e06", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "7f6b535c7b16c07f5096269ea8903c32e86570d8", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "ddef7352de8891075d5a38ee8a6ae0f286e8d720", "filename": "clippy_lints/src/non_send_fields_in_send_ty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "e8532db4f711dbc658d9862f8ff6b4851253b5c8", "filename": "clippy_lints/src/octal_escapes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Foctal_escapes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Foctal_escapes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foctal_escapes.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "d66698f8adc6927e1546214232364e2a3c7bfc97", "filename": "clippy_lints/src/only_used_in_recursion.rs", "status": "added", "additions": 660, "deletions": 0, "changes": 660, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "ea5a8f0858b66aa14d084b55a585fa8ae7950be0", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "2f3007658ea6296f8e2b7b1c541f0224cc10fca0", "filename": "clippy_lints/src/panic_unimplemented.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "09ac514d014eb1d67fc1f9a6ad9a58f5061bdaaf", "filename": "clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "e3ded716341f633028736d387076ceae8a39f31f", "filename": "clippy_lints/src/pass_by_ref_or_value.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "a4d265111f9aee26d241d913d790c19bb0949740", "filename": "clippy_lints/src/pattern_type_mismatch.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpattern_type_mismatch.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "86460c1b27e390ccc0ad3c4209e6b32599c6a041", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 60, "deletions": 67, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "9d2b0cedb60a165f18a843a25cb8817468654f00", "filename": "clippy_lints/src/pub_use.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fpub_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fpub_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpub_use.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "899568a933f7afe196b890a5f81e146aca01ec2a", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "a47dc26f60347c71f291ade56959825849020700", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 57, "deletions": 36, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "8db8c4e9b7870117d71022f7baa10809ab1c6bbf", "filename": "clippy_lints/src/rc_clone_in_vec_init.rs", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Frc_clone_in_vec_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Frc_clone_in_vec_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Frc_clone_in_vec_init.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "0004b8afdd37557abdfa3cc60d6971423c14304c", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 39, "deletions": 31, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "40b03068f6c772059167ff6814824d1d0846e33e", "filename": "clippy_lints/src/redundant_field_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fredundant_field_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fredundant_field_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_field_names.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "323326381d4079149ce2591abd3c6a402b4e453b", "filename": "clippy_lints/src/redundant_pub_crate.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fredundant_pub_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fredundant_pub_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_pub_crate.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "25a9072ef6e0cf0a2ccd2eb395ec90d49c6cf3c0", "filename": "clippy_lints/src/redundant_slicing.rs", "status": "modified", "additions": 102, "deletions": 23, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fredundant_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fredundant_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_slicing.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "2d26c49252fa5d9db9231d70ecb6cda32c80c966", "filename": "clippy_lints/src/redundant_static_lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "f789cec6d6acfc22333a2318e5352f1212ac9e0b", "filename": "clippy_lints/src/reference.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Freference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Freference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freference.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "67129299e2f9294292c1abd84b95a86d74bce721", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "ba03ef93721186296021cb596a2992264072e4ee", "filename": "clippy_lints/src/renamed_lints.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Frenamed_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Frenamed_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Frenamed_lints.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "91e5e1e8b289288ae9c2e8d653f28484bfd8db36", "filename": "clippy_lints/src/return_self_not_must_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Freturn_self_not_must_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Freturn_self_not_must_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturn_self_not_must_use.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "9158cbcc04e1cb4586ffa3609d0d6422be15c910", "filename": "clippy_lints/src/same_name_method.rs", "status": "modified", "additions": 99, "deletions": 98, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fsame_name_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fsame_name_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsame_name_method.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "d07c26d7c8975da63108f5ec5e9af7efd2ab8ebd", "filename": "clippy_lints/src/self_named_constructors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fself_named_constructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fself_named_constructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fself_named_constructors.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "fc1c2af9257bf98484d807b775a7a2da416a56e2", "filename": "clippy_lints/src/serde_api.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fserde_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fserde_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fserde_api.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "1ab7f52110ce7c3742aeec202c9ccd4003959e99", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "424b361a905ce479105bf2c792138106ad23d7d8", "filename": "clippy_lints/src/significant_drop_in_scrutinee.rs", "status": "added", "additions": 406, "deletions": 0, "changes": 406, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fsignificant_drop_in_scrutinee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fsignificant_drop_in_scrutinee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsignificant_drop_in_scrutinee.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "66b79513032f6e8871e52ed543dafc9eb8585b5e", "filename": "clippy_lints/src/single_component_path_imports.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fsingle_component_path_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fsingle_component_path_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsingle_component_path_imports.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "3d7dc49b406a6cec8f294dbfb9ef99332279c5ad", "filename": "clippy_lints/src/size_of_in_element_count.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fsize_of_in_element_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fsize_of_in_element_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsize_of_in_element_count.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "a6c685df721d6fac310117306cb98cd2b46f9a96", "filename": "clippy_lints/src/stable_sort_primitive.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fstable_sort_primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fstable_sort_primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstable_sort_primitive.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "7c196ccaa8ccd2fb610f430e510b4a6aaa918314", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "c4c1aa11004acbc523d2ffe22a25c4148e96f9ff", "filename": "clippy_lints/src/suspicious_operation_groupings.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "1885f3ca414dfe9dbef2a600fc961cf4f6b9ebb5", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "e223aea297fc478bf9816be4ec8f4e73a65b6391", "filename": "clippy_lints/src/tabs_in_doc_comments.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftabs_in_doc_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftabs_in_doc_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftabs_in_doc_comments.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "03060d78fc5af39d325068a721a991b9e96a7e83", "filename": "clippy_lints/src/to_string_in_display.rs", "status": "removed", "additions": 0, "deletions": 123, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/cb29e3effbf72db2e1f5177336bfb3309ec8805e/clippy_lints%2Fsrc%2Fto_string_in_display.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb29e3effbf72db2e1f5177336bfb3309ec8805e/clippy_lints%2Fsrc%2Fto_string_in_display.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fto_string_in_display.rs?ref=cb29e3effbf72db2e1f5177336bfb3309ec8805e"}, {"sha": "58cc057a39ed94001c8417fc75ff09a48d39f8c3", "filename": "clippy_lints/src/trailing_empty_array.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftrailing_empty_array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftrailing_empty_array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrailing_empty_array.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "6c60fb4b8e029ed97424afada4d2f8695ea756da", "filename": "clippy_lints/src/trait_bounds.rs", "status": "modified", "additions": 27, "deletions": 31, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrait_bounds.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "d2a040beb0cf70e67c866b24a8dab247043b8b04", "filename": "clippy_lints/src/transmute/mod.rs", "status": "modified", "additions": 56, "deletions": 21, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "d5ef86dc4e572703af49941486832c5c9bea462e", "filename": "clippy_lints/src/transmute/transmute_float_to_int.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_float_to_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_float_to_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_float_to_int.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "8c50b58ca4b862af20360774f2a4654df4fa1085", "filename": "clippy_lints/src/transmute/transmute_int_to_bool.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_bool.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "9e1823c373bfdb4d641536bfd04b10157eda1b1c", "filename": "clippy_lints/src/transmute/transmute_int_to_char.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_char.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "b8703052e6c869750a09751579885123c0e1143a", "filename": "clippy_lints/src/transmute/transmute_int_to_float.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_float.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_float.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_float.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "52d193d11e1a08dab87adca2de3548d904b3d16f", "filename": "clippy_lints/src/transmute/transmute_num_to_bytes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_num_to_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_num_to_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_num_to_bytes.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "d712b33de9e1a49ead17804603354e5d09055bcd", "filename": "clippy_lints/src/transmute/transmute_ptr_to_ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ptr.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "f3653199b3758b2ecf4d68ef22832da4c298e8c6", "filename": "clippy_lints/src/transmute/transmute_ptr_to_ref.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ref.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "786e7bfc56f6ecbb00e442e72bd530f865d26100", "filename": "clippy_lints/src/transmute/transmute_ref_to_ref.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ref_to_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ref_to_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ref_to_ref.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "be6277332db4dbd5d7d9530388c36c62f46e4b13", "filename": "clippy_lints/src/transmute/transmute_undefined_repr.rs", "status": "added", "additions": 372, "deletions": 0, "changes": 372, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "626d7cd46fc43c1383717d3b670780df06bc6201", "filename": "clippy_lints/src/transmute/transmutes_expressible_as_ptr_casts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftransmute%2Ftransmutes_expressible_as_ptr_casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftransmute%2Ftransmutes_expressible_as_ptr_casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmutes_expressible_as_ptr_casts.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "831b0d450d20a7f933a6bd380dc370db37710a9e", "filename": "clippy_lints/src/transmute/unsound_collection_transmute.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftransmute%2Funsound_collection_transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftransmute%2Funsound_collection_transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Funsound_collection_transmute.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "3cc3d40a143dc1c96ca8d535e866968187b0eb48", "filename": "clippy_lints/src/transmute/useless_transmute.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftransmute%2Fuseless_transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftransmute%2Fuseless_transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Fuseless_transmute.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "0cbf5ccefa6d89ea6435cfc3a7647c81fee84e9e", "filename": "clippy_lints/src/transmute/utils.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Futils.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "e108f7be12e6a69c7835db14c506239fdc9e33fa", "filename": "clippy_lints/src/try_err.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftry_err.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "f35f44eda5679fb34f365965dac7433983875010", "filename": "clippy_lints/src/types/borrowed_box.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "21a9558ec076a54e938fadc06f56fb6f9fa5ee34", "filename": "clippy_lints/src/types/box_collection.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftypes%2Fbox_collection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftypes%2Fbox_collection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fbox_collection.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "353a6f6b899ea3e743ed57982b8acd130d185e14", "filename": "clippy_lints/src/types/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "8767e3c30a68ac4564ba72814b48f53719090be3", "filename": "clippy_lints/src/types/option_option.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftypes%2Foption_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftypes%2Foption_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Foption_option.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "4d72a29e8c74722711aeb3b6a754e3d0c2bd4765", "filename": "clippy_lints/src/types/rc_buffer.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftypes%2Frc_buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftypes%2Frc_buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Frc_buffer.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}, {"sha": "a75972cf3ddbe1e2d91acbf11fc541577c7ed7e5", "filename": "clippy_lints/src/types/rc_mutex.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftypes%2Frc_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9be57dbf3d4a376620d6c29ef4cc486a1735dcb/clippy_lints%2Fsrc%2Ftypes%2Frc_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Frc_mutex.rs?ref=c9be57dbf3d4a376620d6c29ef4cc486a1735dcb"}]}