{"sha": "594ce72d1e37dadb23c15b6daf18714200bfd191", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5NGNlNzJkMWUzN2RhZGIyM2MxNWI2ZGFmMTg3MTQyMDBiZmQxOTE=", "commit": {"author": {"name": "vsrs", "email": "vit@conrlab.com", "date": "2020-07-20T19:04:59Z"}, "committer": {"name": "vsrs", "email": "vit@conrlab.com", "date": "2020-07-24T10:13:39Z"}, "message": "Prepare server capabilities based on client ones.", "tree": {"sha": "9d06b9d97e82a42474a55823a7179c4637071d66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d06b9d97e82a42474a55823a7179c4637071d66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/594ce72d1e37dadb23c15b6daf18714200bfd191", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/594ce72d1e37dadb23c15b6daf18714200bfd191", "html_url": "https://github.com/rust-lang/rust/commit/594ce72d1e37dadb23c15b6daf18714200bfd191", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/594ce72d1e37dadb23c15b6daf18714200bfd191/comments", "author": {"login": "vsrs", "id": 62505555, "node_id": "MDQ6VXNlcjYyNTA1NTU1", "avatar_url": "https://avatars.githubusercontent.com/u/62505555?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vsrs", "html_url": "https://github.com/vsrs", "followers_url": "https://api.github.com/users/vsrs/followers", "following_url": "https://api.github.com/users/vsrs/following{/other_user}", "gists_url": "https://api.github.com/users/vsrs/gists{/gist_id}", "starred_url": "https://api.github.com/users/vsrs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vsrs/subscriptions", "organizations_url": "https://api.github.com/users/vsrs/orgs", "repos_url": "https://api.github.com/users/vsrs/repos", "events_url": "https://api.github.com/users/vsrs/events{/privacy}", "received_events_url": "https://api.github.com/users/vsrs/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vsrs", "id": 62505555, "node_id": "MDQ6VXNlcjYyNTA1NTU1", "avatar_url": "https://avatars.githubusercontent.com/u/62505555?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vsrs", "html_url": "https://github.com/vsrs", "followers_url": "https://api.github.com/users/vsrs/followers", "following_url": "https://api.github.com/users/vsrs/following{/other_user}", "gists_url": "https://api.github.com/users/vsrs/gists{/gist_id}", "starred_url": "https://api.github.com/users/vsrs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vsrs/subscriptions", "organizations_url": "https://api.github.com/users/vsrs/orgs", "repos_url": "https://api.github.com/users/vsrs/repos", "events_url": "https://api.github.com/users/vsrs/events{/privacy}", "received_events_url": "https://api.github.com/users/vsrs/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ddcdb8b29f495f09b9e2456001be252d401e394", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ddcdb8b29f495f09b9e2456001be252d401e394", "html_url": "https://github.com/rust-lang/rust/commit/6ddcdb8b29f495f09b9e2456001be252d401e394"}], "stats": {"total": 108, "additions": 72, "deletions": 36}, "files": [{"sha": "34fefe034690324da8e491a1ee7daf359164f3b7", "filename": "crates/rust-analyzer/src/caps.rs", "status": "modified", "additions": 72, "deletions": 36, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/594ce72d1e37dadb23c15b6daf18714200bfd191/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/594ce72d1e37dadb23c15b6daf18714200bfd191/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs?ref=594ce72d1e37dadb23c15b6daf18714200bfd191", "patch": "@@ -7,16 +7,18 @@ use lsp_types::{\n     DocumentOnTypeFormattingOptions, FoldingRangeProviderCapability, HoverProviderCapability,\n     ImplementationProviderCapability, RenameOptions, RenameProviderCapability, SaveOptions,\n     SelectionRangeProviderCapability, SemanticTokensDocumentProvider, SemanticTokensLegend,\n-    SemanticTokensOptions, ServerCapabilities, SignatureHelpOptions, TextDocumentSyncCapability,\n-    TextDocumentSyncKind, TextDocumentSyncOptions, TypeDefinitionProviderCapability,\n-    WorkDoneProgressOptions,\n+    SemanticTokensOptions, SemanticTokensServerCapabilities, ServerCapabilities,\n+    SignatureHelpOptions, TextDocumentSyncCapability, TextDocumentSyncKind,\n+    TextDocumentSyncOptions, TypeDefinitionProviderCapability, WorkDoneProgressOptions,\n };\n-use serde_json::json;\n+use serde_json::{json, Value};\n \n use crate::semantic_tokens;\n \n pub fn server_capabilities(client_caps: &ClientCapabilities) -> ServerCapabilities {\n     let code_action_provider = code_action_capabilities(client_caps);\n+    let semantic_tokens_provider = semantic_tokens_capabilities(client_caps);\n+    let experimental = experimental_capabilities(client_caps);\n \n     ServerCapabilities {\n         text_document_sync: Some(TextDocumentSyncCapability::Options(TextDocumentSyncOptions {\n@@ -69,29 +71,58 @@ pub fn server_capabilities(client_caps: &ClientCapabilities) -> ServerCapabiliti\n         execute_command_provider: None,\n         workspace: None,\n         call_hierarchy_provider: Some(CallHierarchyServerCapability::Simple(true)),\n-        semantic_tokens_provider: Some(\n-            SemanticTokensOptions {\n-                legend: SemanticTokensLegend {\n-                    token_types: semantic_tokens::SUPPORTED_TYPES.to_vec(),\n-                    token_modifiers: semantic_tokens::SUPPORTED_MODIFIERS.to_vec(),\n-                },\n+        semantic_tokens_provider,\n+        experimental,\n+    }\n+}\n \n-                document_provider: Some(SemanticTokensDocumentProvider::Bool(true)),\n-                range_provider: Some(true),\n-                work_done_progress_options: Default::default(),\n+fn experimental_capabilities(client_caps: &ClientCapabilities) -> Option<Value> {\n+    client_caps.experimental.as_ref().and_then(|it| {\n+        it.as_object().map(|map| {\n+            let mut obj = json!({});\n+            let result = obj.as_object_mut().unwrap();\n+\n+            if map.contains_key(\"joinLines\") {\n+                result.insert(\"joinLines\".into(), true.into());\n+            }\n+\n+            if map.contains_key(\"ssr\") {\n+                result.insert(\"ssr\".into(), true.into());\n+            }\n+\n+            if map.contains_key(\"onEnter\") {\n+                result.insert(\"onEnter\".into(), true.into());\n             }\n-            .into(),\n-        ),\n-        experimental: Some(json!({\n-            \"joinLines\": true,\n-            \"ssr\": true,\n-            \"onEnter\": true,\n-            \"parentModule\": true,\n-            \"runnables\": {\n-                \"kinds\": [ \"cargo\" ],\n+\n+            if map.contains_key(\"parentModule\") {\n+                result.insert(\"parentModule\".into(), true.into());\n+            }\n+\n+            if map.contains_key(\"runnables\") {\n+                result.insert(\"runnables\".into(), json!({ \"kinds\": [ \"cargo\" ] }));\n+            }\n+\n+            obj\n+        })\n+    })\n+}\n+\n+fn semantic_tokens_capabilities(\n+    client_caps: &ClientCapabilities,\n+) -> Option<SemanticTokensServerCapabilities> {\n+    client_caps.text_document.as_ref().and_then(|it| it.semantic_tokens.as_ref()).map(|_|\n+            // client supports semanticTokens\n+            SemanticTokensOptions {\n+            legend: SemanticTokensLegend {\n+                token_types: semantic_tokens::SUPPORTED_TYPES.to_vec(),\n+                token_modifiers: semantic_tokens::SUPPORTED_MODIFIERS.to_vec(),\n             },\n-        })),\n-    }\n+\n+            document_provider: Some(SemanticTokensDocumentProvider::Bool(true)),\n+            range_provider: Some(true),\n+            work_done_progress_options: Default::default(),\n+        }\n+        .into())\n }\n \n fn code_action_capabilities(client_caps: &ClientCapabilities) -> CodeActionProviderCapability {\n@@ -100,19 +131,24 @@ fn code_action_capabilities(client_caps: &ClientCapabilities) -> CodeActionProvi\n         .as_ref()\n         .and_then(|it| it.code_action.as_ref())\n         .and_then(|it| it.code_action_literal_support.as_ref())\n-        .map_or(CodeActionProviderCapability::Simple(true), |_| {\n+        .map_or(CodeActionProviderCapability::Simple(true), |caps| {\n+            let mut action_kinds = vec![\n+                CodeActionKind::EMPTY,\n+                CodeActionKind::QUICKFIX,\n+                CodeActionKind::REFACTOR,\n+                CodeActionKind::REFACTOR_EXTRACT,\n+                CodeActionKind::REFACTOR_INLINE,\n+                CodeActionKind::REFACTOR_REWRITE,\n+            ];\n+\n+            // Not all clients can fall back gracefully for unknown values.\n+            // Microsoft.VisualStudio.LanguageServer.Protocol.CodeActionKind does not support CodeActionKind::EMPTY\n+            // So have to filter out.\n+            action_kinds\n+                .retain(|it| caps.code_action_kind.value_set.contains(&it.as_str().to_owned()));\n+\n             CodeActionProviderCapability::Options(CodeActionOptions {\n-                // Advertise support for all built-in CodeActionKinds.\n-                // Ideally we would base this off of the client capabilities\n-                // but the client is supposed to fall back gracefully for unknown values.\n-                code_action_kinds: Some(vec![\n-                    CodeActionKind::EMPTY,\n-                    CodeActionKind::QUICKFIX,\n-                    CodeActionKind::REFACTOR,\n-                    CodeActionKind::REFACTOR_EXTRACT,\n-                    CodeActionKind::REFACTOR_INLINE,\n-                    CodeActionKind::REFACTOR_REWRITE,\n-                ]),\n+                code_action_kinds: Some(action_kinds),\n                 work_done_progress_options: Default::default(),\n             })\n         })"}]}