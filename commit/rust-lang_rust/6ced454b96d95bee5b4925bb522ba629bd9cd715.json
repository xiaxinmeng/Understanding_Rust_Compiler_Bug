{"sha": "6ced454b96d95bee5b4925bb522ba629bd9cd715", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjZWQ0NTRiOTZkOTViZWU1YjQ5MjViYjUyMmJhNjI5YmQ5Y2Q3MTU=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-10-08T14:05:01Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-10-08T21:03:10Z"}, "message": "libcore: add pop/swap/consume to SendMap", "tree": {"sha": "22c2e16e153686bf36c372049e7f5b71123a7101", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22c2e16e153686bf36c372049e7f5b71123a7101"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ced454b96d95bee5b4925bb522ba629bd9cd715", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ced454b96d95bee5b4925bb522ba629bd9cd715", "html_url": "https://github.com/rust-lang/rust/commit/6ced454b96d95bee5b4925bb522ba629bd9cd715", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ced454b96d95bee5b4925bb522ba629bd9cd715/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a477c5af203e75cced729e85f9b54e8f2516502e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a477c5af203e75cced729e85f9b54e8f2516502e", "html_url": "https://github.com/rust-lang/rust/commit/a477c5af203e75cced729e85f9b54e8f2516502e"}], "stats": {"total": 155, "additions": 126, "deletions": 29}, "files": [{"sha": "d275069a14b5c2bd9c561b998f05d3715c091643", "filename": "src/libcore/send_map.rs", "status": "modified", "additions": 126, "deletions": 29, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/6ced454b96d95bee5b4925bb522ba629bd9cd715/src%2Flibcore%2Fsend_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ced454b96d95bee5b4925bb522ba629bd9cd715/src%2Flibcore%2Fsend_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsend_map.rs?ref=6ced454b96d95bee5b4925bb522ba629bd9cd715", "patch": "@@ -17,6 +17,9 @@ pub trait SendMap<K:Eq Hash, V: Copy> {\n \n     fn insert(&mut self, k: K, +v: V) -> bool;\n     fn remove(&mut self, k: &K) -> bool;\n+    fn pop(&mut self, k: &K) -> Option<V>;\n+    fn swap(&mut self, k: K, +v: V) -> Option<V>;\n+    fn consume(&mut self, f: fn(K, V));\n     fn clear(&mut self);\n     pure fn len(&const self) -> uint;\n     pure fn is_empty(&const self) -> bool;\n@@ -198,6 +201,52 @@ pub mod linear {\n             }\n         }\n \n+        fn pop_internal(&mut self, hash: uint, k: &K) -> Option<V> {\n+            // Removing from an open-addressed hashtable\n+            // is, well, painful.  The problem is that\n+            // the entry may lie on the probe path for other\n+            // entries, so removing it would make you think that\n+            // those probe paths are empty.\n+            //\n+            // To address this we basically have to keep walking,\n+            // re-inserting entries we find until we reach an empty\n+            // bucket.  We know we will eventually reach one because\n+            // we insert one ourselves at the beginning (the removed\n+            // entry).\n+            //\n+            // I found this explanation elucidating:\n+            // http://www.maths.lse.ac.uk/Courses/MA407/del-hash.pdf\n+            let mut idx = match self.bucket_for_key_with_hash(self.buckets,\n+                                                              hash, k) {\n+                TableFull | FoundHole(_) => return None,\n+                FoundEntry(idx) => idx\n+            };\n+\n+            let len_buckets = self.buckets.len();\n+            let mut bucket = None;\n+            self.buckets[idx] <-> bucket;\n+\n+            let value = match move bucket {\n+                None => None,\n+                Some(move bucket) => {\n+                    let Bucket { value: move value, _ } = move bucket;\n+                    Some(value)\n+                },\n+            };\n+\n+            idx = self.next_bucket(idx, len_buckets);\n+            while self.buckets[idx].is_some() {\n+                let mut bucket = None;\n+                bucket <-> self.buckets[idx];\n+                self.insert_opt_bucket(move bucket);\n+                idx = self.next_bucket(idx, len_buckets);\n+            }\n+            self.size -= 1;\n+\n+            value\n+\n+        }\n+\n         fn search(&self,\n                   hash: uint,\n                   op: fn(x: &Option<Bucket<K,V>>) -> bool) {\n@@ -222,37 +271,55 @@ pub mod linear {\n         }\n \n         fn remove(&mut self, k: &K) -> bool {\n-            // Removing from an open-addressed hashtable\n-            // is, well, painful.  The problem is that\n-            // the entry may lie on the probe path for other\n-            // entries, so removing it would make you think that\n-            // those probe paths are empty.\n-            //\n-            // To address this we basically have to keep walking,\n-            // re-inserting entries we find until we reach an empty\n-            // bucket.  We know we will eventually reach one because\n-            // we insert one ourselves at the beginning (the removed\n-            // entry).\n-            //\n-            // I found this explanation elucidating:\n-            // http://www.maths.lse.ac.uk/Courses/MA407/del-hash.pdf\n+            match self.pop(k) {\n+                Some(_) => true,\n+                None => false,\n+            }\n+        }\n \n-            let mut idx = match self.bucket_for_key(self.buckets, k) {\n-                TableFull | FoundHole(_) => return false,\n-                FoundEntry(idx) => idx\n-            };\n+        fn pop(&mut self, k: &K) -> Option<V> {\n+            let hash = k.hash_keyed(self.k0, self.k1) as uint;\n+            self.pop_internal(hash, k)\n+        }\n \n-            let len_buckets = self.buckets.len();\n-            self.buckets[idx] = None;\n-            idx = self.next_bucket(idx, len_buckets);\n-            while self.buckets[idx].is_some() {\n-                let mut bucket = None;\n-                bucket <-> self.buckets[idx];\n-                self.insert_opt_bucket(move bucket);\n-                idx = self.next_bucket(idx, len_buckets);\n+        fn swap(&mut self, k: K, v: V) -> Option<V> {\n+            // this could be faster.\n+            let hash = k.hash_keyed(self.k0, self.k1) as uint;\n+            let old_value = self.pop_internal(hash, &k);\n+\n+            if self.size >= self.resize_at {\n+                // n.b.: We could also do this after searching, so\n+                // that we do not resize if this call to insert is\n+                // simply going to update a key in place.  My sense\n+                // though is that it's worse to have to search through\n+                // buckets to find the right spot twice than to just\n+                // resize in this corner case.\n+                self.expand();\n+            }\n+\n+            self.insert_internal(hash, k, v);\n+\n+            old_value\n+        }\n+\n+        fn consume(&mut self, f: fn(K, V)) {\n+            let mut buckets = ~[];\n+            self.buckets <-> buckets;\n+            self.size = 0;\n+\n+            do vec::consume(buckets) |_i, bucket| {\n+                match move bucket {\n+                    None => { },\n+                    Some(move bucket) => {\n+                        let Bucket {\n+                            key: move key,\n+                            value: move value,\n+                            _\n+                        } = move bucket;\n+                        f(key, value)\n+                    }\n+                }\n             }\n-            self.size -= 1;\n-            return true;\n         }\n \n         fn clear(&mut self) {\n@@ -350,7 +417,6 @@ pub mod linear {\n             }\n             option::unwrap(move value)\n         }\n-\n     }\n }\n \n@@ -407,6 +473,37 @@ pub mod test {\n         assert m.is_empty();\n     }\n \n+    #[test]\n+    pub fn pops() {\n+        let mut m = ~LinearMap();\n+        m.insert(1, 2);\n+        assert m.pop(&1) == Some(2);\n+        assert m.pop(&1) == None;\n+    }\n+\n+    #[test]\n+    pub fn swaps() {\n+        let mut m = ~LinearMap();\n+        assert m.swap(1, 2) == None;\n+        assert m.swap(1, 3) == Some(2);\n+        assert m.swap(1, 4) == Some(3);\n+    }\n+\n+    #[test]\n+    pub fn consumes() {\n+        let mut m = ~LinearMap();\n+        assert m.insert(1, 2);\n+        assert m.insert(2, 3);\n+        let mut m2 = ~LinearMap();\n+        do m.consume |k, v| {\n+            m2.insert(k, v);\n+        }\n+        assert m.len() == 0;\n+        assert m2.len() == 2;\n+        assert m2.find(&1) == Some(2);\n+        assert m2.find(&2) == Some(3);\n+    }\n+\n     #[test]\n     pub fn iterate() {\n         let mut m = linear::linear_map_with_capacity(4);"}]}