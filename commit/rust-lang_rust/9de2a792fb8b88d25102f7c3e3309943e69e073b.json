{"sha": "9de2a792fb8b88d25102f7c3e3309943e69e073b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkZTJhNzkyZmI4Yjg4ZDI1MTAyZjdjM2UzMzA5OTQzZTY5ZTA3M2I=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-04-13T23:24:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-13T23:24:15Z"}, "message": "Rollup merge of #71092 - marmeladema:dummy-hir-id-removal, r=eddyb\n\nRemove some usage of `DUMMY_HIR_ID`", "tree": {"sha": "0a6a2a7b1f9470d22e4814e27e72affc22ca476d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a6a2a7b1f9470d22e4814e27e72affc22ca476d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9de2a792fb8b88d25102f7c3e3309943e69e073b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJelPSfCRBK7hj4Ov3rIwAAdHIIAD88Kh9CA8KPjcMy5W+l3/bG\njcUeYWn7tlUQ0yO+S9cfdMHTxmKsqEJN6dVNaWSsBLXuBEGPhWmThOFibRSD/Hvp\nwciB5WqReFxEUQ1RNG/OMfhMSKSEtSN8KDDUHhz/NObs/kHseI8osF/UGNid/227\nOj0pYVL0IpnKD7NgBnoH6T7JlGhzGw2+aQbcni5SbEI8oxTX1sE8PnwT1fhNF7zO\nIjcZyf0mi2aw0KSZDQWRCj2hqa1iZN/Mrxy+iKRnnmLgjkZndG1Wfowq47YzEEzj\nLr1aKvayk9VuejaL1rKJ7RcHNnlVNcchuJNVVEq3uXfI+cm6t5/+VicMwQ6RR/Y=\n=1UGX\n-----END PGP SIGNATURE-----\n", "payload": "tree 0a6a2a7b1f9470d22e4814e27e72affc22ca476d\nparent 048c8426e8fe0fad677c07af14d7e426dae2e5b9\nparent d0409ead2f44306fd54b12ed0ac83a4f5ee44910\nauthor Dylan DPC <dylan.dpc@gmail.com> 1586820255 +0200\ncommitter GitHub <noreply@github.com> 1586820255 +0200\n\nRollup merge of #71092 - marmeladema:dummy-hir-id-removal, r=eddyb\n\nRemove some usage of `DUMMY_HIR_ID`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9de2a792fb8b88d25102f7c3e3309943e69e073b", "html_url": "https://github.com/rust-lang/rust/commit/9de2a792fb8b88d25102f7c3e3309943e69e073b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9de2a792fb8b88d25102f7c3e3309943e69e073b/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "048c8426e8fe0fad677c07af14d7e426dae2e5b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/048c8426e8fe0fad677c07af14d7e426dae2e5b9", "html_url": "https://github.com/rust-lang/rust/commit/048c8426e8fe0fad677c07af14d7e426dae2e5b9"}, {"sha": "d0409ead2f44306fd54b12ed0ac83a4f5ee44910", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0409ead2f44306fd54b12ed0ac83a4f5ee44910", "html_url": "https://github.com/rust-lang/rust/commit/d0409ead2f44306fd54b12ed0ac83a4f5ee44910"}], "stats": {"total": 52, "additions": 22, "deletions": 30}, "files": [{"sha": "4189570a0da58d5f163705b50050da72b279440a", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9de2a792fb8b88d25102f7c3e3309943e69e073b/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de2a792fb8b88d25102f7c3e3309943e69e073b/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=9de2a792fb8b88d25102f7c3e3309943e69e073b", "patch": "@@ -191,7 +191,7 @@ fn msg_span_from_early_bound_and_free_regions(\n     let sm = tcx.sess.source_map();\n \n     let scope = region.free_region_binding_scope(tcx);\n-    let node = tcx.hir().as_local_hir_id(scope).unwrap_or(hir::DUMMY_HIR_ID);\n+    let node = tcx.hir().as_local_hir_id(scope).unwrap();\n     let tag = match tcx.hir().find(node) {\n         Some(Node::Block(_)) | Some(Node::Expr(_)) => \"body\",\n         Some(Node::Item(it)) => item_scope_tag(&it),"}, {"sha": "627a438c2c3b19e9a108c2f216081275477c9209", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9de2a792fb8b88d25102f7c3e3309943e69e073b/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de2a792fb8b88d25102f7c3e3309943e69e073b/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=9de2a792fb8b88d25102f7c3e3309943e69e073b", "patch": "@@ -1354,15 +1354,15 @@ declare_lint! {\n }\n \n pub struct UnnameableTestItems {\n-    boundary: hir::HirId, // HirId of the item under which things are not nameable\n+    boundary: Option<hir::HirId>, // HirId of the item under which things are not nameable\n     items_nameable: bool,\n }\n \n impl_lint_pass!(UnnameableTestItems => [UNNAMEABLE_TEST_ITEMS]);\n \n impl UnnameableTestItems {\n     pub fn new() -> Self {\n-        Self { boundary: hir::DUMMY_HIR_ID, items_nameable: true }\n+        Self { boundary: None, items_nameable: true }\n     }\n }\n \n@@ -1372,7 +1372,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnameableTestItems {\n             if let hir::ItemKind::Mod(..) = it.kind {\n             } else {\n                 self.items_nameable = false;\n-                self.boundary = it.hir_id;\n+                self.boundary = Some(it.hir_id);\n             }\n             return;\n         }\n@@ -1385,7 +1385,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnameableTestItems {\n     }\n \n     fn check_item_post(&mut self, _cx: &LateContext<'_, '_>, it: &hir::Item<'_>) {\n-        if !self.items_nameable && self.boundary == it.hir_id {\n+        if !self.items_nameable && self.boundary == Some(it.hir_id) {\n             self.items_nameable = true;\n         }\n     }"}, {"sha": "ee2ed8826ba125427e2701f7ae75ef6da7e6d5b1", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9de2a792fb8b88d25102f7c3e3309943e69e073b/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de2a792fb8b88d25102f7c3e3309943e69e073b/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=9de2a792fb8b88d25102f7c3e3309943e69e073b", "patch": "@@ -43,14 +43,14 @@ declare_lint! {\n #[derive(Copy, Clone)]\n pub struct TypeLimits {\n     /// Id of the last visited negated expression\n-    negated_expr_id: hir::HirId,\n+    negated_expr_id: Option<hir::HirId>,\n }\n \n impl_lint_pass!(TypeLimits => [UNUSED_COMPARISONS, OVERFLOWING_LITERALS]);\n \n impl TypeLimits {\n     pub fn new() -> TypeLimits {\n-        TypeLimits { negated_expr_id: hir::DUMMY_HIR_ID }\n+        TypeLimits { negated_expr_id: None }\n     }\n }\n \n@@ -244,7 +244,7 @@ fn lint_int_literal<'a, 'tcx>(\n     let int_type = t.normalize(cx.sess().target.ptr_width);\n     let (min, max) = int_ty_range(int_type);\n     let max = max as u128;\n-    let negative = type_limits.negated_expr_id == e.hir_id;\n+    let negative = type_limits.negated_expr_id == Some(e.hir_id);\n \n     // Detect literal value out of range [min, max] inclusive\n     // avoiding use of -min to prevent overflow/panic\n@@ -397,8 +397,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n         match e.kind {\n             hir::ExprKind::Unary(hir::UnOp::UnNeg, ref expr) => {\n                 // propagate negation, if the negation itself isn't negated\n-                if self.negated_expr_id != e.hir_id {\n-                    self.negated_expr_id = expr.hir_id;\n+                if self.negated_expr_id != Some(e.hir_id) {\n+                    self.negated_expr_id = Some(expr.hir_id);\n                 }\n             }\n             hir::ExprKind::Binary(binop, ref l, ref r) => {"}, {"sha": "e02e97be19db584928c2fbdaf6677675f909cc85", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9de2a792fb8b88d25102f7c3e3309943e69e073b/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de2a792fb8b88d25102f7c3e3309943e69e073b/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=9de2a792fb8b88d25102f7c3e3309943e69e073b", "patch": "@@ -1012,7 +1012,7 @@ impl DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n struct NamePrivacyVisitor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n-    current_item: hir::HirId,\n+    current_item: Option<hir::HirId>,\n     empty_tables: &'a ty::TypeckTables<'tcx>,\n }\n \n@@ -1028,7 +1028,7 @@ impl<'a, 'tcx> NamePrivacyVisitor<'a, 'tcx> {\n     ) {\n         // definition of the field\n         let ident = Ident::new(kw::Invalid, use_ctxt);\n-        let current_hir = self.current_item;\n+        let current_hir = self.current_item.unwrap();\n         let def_id = self.tcx.adjust_ident_and_get_scope(ident, def.did, current_hir).1;\n         if !def.is_enum() && !field.vis.is_accessible_from(def_id, self.tcx) {\n             let label = if in_update_syntax {\n@@ -1074,7 +1074,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        let orig_current_item = mem::replace(&mut self.current_item, item.hir_id);\n+        let orig_current_item = mem::replace(&mut self.current_item, Some(item.hir_id));\n         let orig_tables =\n             mem::replace(&mut self.tables, item_tables(self.tcx, item.hir_id, self.empty_tables));\n         intravisit::walk_item(self, item);\n@@ -2059,7 +2059,7 @@ fn check_mod_privacy(tcx: TyCtxt<'_>, module_def_id: DefId) {\n     let mut visitor = NamePrivacyVisitor {\n         tcx,\n         tables: &empty_tables,\n-        current_item: hir::DUMMY_HIR_ID,\n+        current_item: None,\n         empty_tables: &empty_tables,\n     };\n     let (module, span, hir_id) = tcx.hir().get_module(module_def_id);"}, {"sha": "6db2e557fea694a05f29cb2897c06e710f56a993", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9de2a792fb8b88d25102f7c3e3309943e69e073b/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de2a792fb8b88d25102f7c3e3309943e69e073b/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=9de2a792fb8b88d25102f7c3e3309943e69e073b", "patch": "@@ -62,7 +62,7 @@ fn compute_implied_outlives_bounds<'tcx>(\n         // unresolved inference variables here anyway, but there might be\n         // during typeck under some circumstances.)\n         let obligations =\n-            wf::obligations(infcx, param_env, hir::DUMMY_HIR_ID, ty, DUMMY_SP).unwrap_or(vec![]);\n+            wf::obligations(infcx, param_env, hir::CRATE_HIR_ID, ty, DUMMY_SP).unwrap_or(vec![]);\n \n         // N.B., all of these predicates *ought* to be easily proven\n         // true. In fact, their correctness is (mostly) implied by"}, {"sha": "4cb7b7d8fda247f0a8ae11585e448b383e127d3e", "filename": "src/librustc_ty/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9de2a792fb8b88d25102f7c3e3309943e69e073b/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de2a792fb8b88d25102f7c3e3309943e69e073b/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=9de2a792fb8b88d25102f7c3e3309943e69e073b", "patch": "@@ -265,7 +265,7 @@ fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ParamEnv<'_> {\n     let unnormalized_env =\n         ty::ParamEnv::new(tcx.intern_predicates(&predicates), traits::Reveal::UserFacing, None);\n \n-    let body_id = tcx.hir().as_local_hir_id(def_id).map_or(hir::DUMMY_HIR_ID, |id| {\n+    let body_id = tcx.hir().as_local_hir_id(def_id).map_or(hir::CRATE_HIR_ID, |id| {\n         tcx.hir().maybe_body_owned_by(id).map_or(id, |body| body.hir_id)\n     });\n     let cause = traits::ObligationCause::misc(tcx.def_span(def_id), body_id);"}, {"sha": "0a7d87adac7e1fd6c765007e3aa75031f5e1695c", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9de2a792fb8b88d25102f7c3e3309943e69e073b/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de2a792fb8b88d25102f7c3e3309943e69e073b/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=9de2a792fb8b88d25102f7c3e3309943e69e073b", "patch": "@@ -217,14 +217,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n         expected: Ty<'tcx>,\n         checked_ty: Ty<'tcx>,\n+        hir_id: hir::HirId,\n     ) -> Vec<AssocItem> {\n-        let mut methods = self.probe_for_return_type(\n-            span,\n-            probe::Mode::MethodCall,\n-            expected,\n-            checked_ty,\n-            hir::DUMMY_HIR_ID,\n-        );\n+        let mut methods =\n+            self.probe_for_return_type(span, probe::Mode::MethodCall, expected, checked_ty, hir_id);\n         methods.retain(|m| {\n             self.has_no_input_arg(m)\n                 && self"}, {"sha": "66a6790d45ef63f804b48439808f1e9466d25a58", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9de2a792fb8b88d25102f7c3e3309943e69e073b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de2a792fb8b88d25102f7c3e3309943e69e073b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=9de2a792fb8b88d25102f7c3e3309943e69e073b", "patch": "@@ -452,7 +452,7 @@ fn method_autoderef_steps<'tcx>(\n     tcx.infer_ctxt().enter_with_canonical(DUMMY_SP, &goal, |ref infcx, goal, inference_vars| {\n         let ParamEnvAnd { param_env, value: self_ty } = goal;\n \n-        let mut autoderef = Autoderef::new(infcx, param_env, hir::DUMMY_HIR_ID, DUMMY_SP, self_ty)\n+        let mut autoderef = Autoderef::new(infcx, param_env, hir::CRATE_HIR_ID, DUMMY_SP, self_ty)\n             .include_raw_pointers()\n             .silence_errors();\n         let mut reached_raw_pointer = false;\n@@ -1512,7 +1512,6 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             );\n             pcx.allow_similar_names = true;\n             pcx.assemble_inherent_candidates();\n-            pcx.assemble_extension_candidates_for_traits_in_scope(hir::DUMMY_HIR_ID)?;\n \n             let method_names = pcx.candidate_method_names();\n             pcx.allow_similar_names = false;\n@@ -1522,10 +1521,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     pcx.reset();\n                     pcx.method_name = Some(method_name);\n                     pcx.assemble_inherent_candidates();\n-                    pcx.assemble_extension_candidates_for_traits_in_scope(hir::DUMMY_HIR_ID)\n-                        .map_or(None, |_| {\n-                            pcx.pick_core().and_then(|pick| pick.ok()).map(|pick| pick.item)\n-                        })\n+                    pcx.pick_core().and_then(|pick| pick.ok()).map(|pick| pick.item)\n                 })\n                 .collect();\n "}, {"sha": "514186ba9a15c6e3e3c1cbe9bc782b6f09d54f58", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9de2a792fb8b88d25102f7c3e3309943e69e073b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de2a792fb8b88d25102f7c3e3309943e69e073b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9de2a792fb8b88d25102f7c3e3309943e69e073b", "patch": "@@ -4981,7 +4981,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         } else if !self.check_for_cast(err, expr, found, expected) {\n             let is_struct_pat_shorthand_field =\n                 self.is_hir_id_from_struct_pattern_shorthand_field(expr.hir_id, expr.span);\n-            let methods = self.get_conversion_methods(expr.span, expected, found);\n+            let methods = self.get_conversion_methods(expr.span, expected, found, expr.hir_id);\n             if let Ok(expr_text) = self.sess().source_map().span_to_snippet(expr.span) {\n                 let mut suggestions = iter::repeat(&expr_text)\n                     .zip(methods.iter())"}]}