{"sha": "2ad5a61fe234e54c9385efac7fb4d04f34a137b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhZDVhNjFmZTIzNGU1NGM5Mzg1ZWZhYzdmYjRkMDRmMzRhMTM3YjE=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-09-14T09:53:53Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-09-14T09:55:51Z"}, "message": "move traits structural impls to traits::structural_impls", "tree": {"sha": "080ff838be3a35e1d67735c6bc0f4995504b6125", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/080ff838be3a35e1d67735c6bc0f4995504b6125"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ad5a61fe234e54c9385efac7fb4d04f34a137b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ad5a61fe234e54c9385efac7fb4d04f34a137b1", "html_url": "https://github.com/rust-lang/rust/commit/2ad5a61fe234e54c9385efac7fb4d04f34a137b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ad5a61fe234e54c9385efac7fb4d04f34a137b1/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f564fbbe46ee609e841062dad1817f17f90943c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f564fbbe46ee609e841062dad1817f17f90943c", "html_url": "https://github.com/rust-lang/rust/commit/5f564fbbe46ee609e841062dad1817f17f90943c"}], "stats": {"total": 464, "additions": 238, "deletions": 226}, "files": [{"sha": "29032f0c4719a3df4afdd0fe9c2891825926fe2c", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2ad5a61fe234e54c9385efac7fb4d04f34a137b1/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad5a61fe234e54c9385efac7fb4d04f34a137b1/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=2ad5a61fe234e54c9385efac7fb4d04f34a137b1", "patch": "@@ -11,7 +11,6 @@\n use middle::infer::InferCtxt;\n use middle::ty::{self, RegionEscape, Ty, HasTypeFlags};\n \n-use std::fmt;\n use syntax::ast;\n use util::common::ErrorReported;\n use util::nodemap::{FnvHashSet, NodeMap};\n@@ -509,14 +508,6 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n     }\n }\n \n-impl<'tcx> fmt::Debug for RegionObligation<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"RegionObligation(sub_region={:?}, sup_type={:?})\",\n-               self.sub_region,\n-               self.sup_type)\n-    }\n-}\n-\n fn register_region_obligation<'tcx>(t_a: Ty<'tcx>,\n                                     r_b: ty::Region,\n                                     cause: ObligationCause<'tcx>,"}, {"sha": "14765e861c32d04636064145606bdd62a6864af3", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ad5a61fe234e54c9385efac7fb4d04f34a137b1/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad5a61fe234e54c9385efac7fb4d04f34a137b1/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=2ad5a61fe234e54c9385efac7fb4d04f34a137b1", "patch": "@@ -63,6 +63,7 @@ mod fulfill;\n mod project;\n mod object_safety;\n mod select;\n+mod structural_impls;\n mod util;\n \n /// An `Obligation` represents some trait reference (e.g. `int:Eq`) for"}, {"sha": "a2c09f88ab331cfbc3c9db74865dc403f98d9208", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2ad5a61fe234e54c9385efac7fb4d04f34a137b1/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad5a61fe234e54c9385efac7fb4d04f34a137b1/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=2ad5a61fe234e54c9385efac7fb4d04f34a137b1", "patch": "@@ -28,8 +28,6 @@ use middle::ty::fold::{TypeFoldable, TypeFolder};\n use syntax::parse::token;\n use util::common::FN_OUTPUT_NAME;\n \n-use std::fmt;\n-\n pub type PolyProjectionObligation<'tcx> =\n     Obligation<'tcx, ty::PolyProjectionPredicate<'tcx>>;\n \n@@ -917,27 +915,3 @@ fn confirm_impl_candidate<'cx,'tcx>(\n                               &format!(\"No associated type for {:?}\",\n                                        trait_ref));\n }\n-\n-impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Normalized<'tcx, T> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Normalized<'tcx, T> {\n-        Normalized {\n-            value: self.value.fold_with(folder),\n-            obligations: self.obligations.fold_with(folder),\n-        }\n-    }\n-}\n-\n-impl<'tcx, T: HasTypeFlags> HasTypeFlags for Normalized<'tcx, T> {\n-    fn has_type_flags(&self, flags: ty::TypeFlags) -> bool {\n-        self.value.has_type_flags(flags) ||\n-            self.obligations.has_type_flags(flags)\n-    }\n-}\n-\n-impl<'tcx, T:fmt::Debug> fmt::Debug for Normalized<'tcx, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"Normalized({:?},{:?})\",\n-               self.value,\n-               self.obligations)\n-    }\n-}"}, {"sha": "88c219a7c7acefa490aced29de818887cd3df9aa", "filename": "src/librustc/middle/traits/structural_impls.rs", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/2ad5a61fe234e54c9385efac7fb4d04f34a137b1/src%2Flibrustc%2Fmiddle%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad5a61fe234e54c9385efac7fb4d04f34a137b1/src%2Flibrustc%2Fmiddle%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fstructural_impls.rs?ref=2ad5a61fe234e54c9385efac7fb4d04f34a137b1", "patch": "@@ -0,0 +1,235 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::traits;\n+use middle::traits::project::Normalized;\n+use middle::ty::{HasTypeFlags, TypeFlags, RegionEscape};\n+use middle::ty::fold::{TypeFoldable, TypeFolder};\n+\n+use std::fmt;\n+\n+// structural impls for the structs in middle::traits\n+\n+impl<'tcx, T: fmt::Debug> fmt::Debug for Normalized<'tcx, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"Normalized({:?},{:?})\",\n+               self.value,\n+               self.obligations)\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for traits::RegionObligation<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"RegionObligation(sub_region={:?}, sup_type={:?})\",\n+               self.sub_region,\n+               self.sup_type)\n+    }\n+}\n+impl<'tcx, O: fmt::Debug> fmt::Debug for traits::Obligation<'tcx, O> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"Obligation(predicate={:?},depth={})\",\n+               self.predicate,\n+               self.recursion_depth)\n+    }\n+}\n+\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::Vtable<'tcx, N> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            super::VtableImpl(ref v) =>\n+                write!(f, \"{:?}\", v),\n+\n+            super::VtableDefaultImpl(ref t) =>\n+                write!(f, \"{:?}\", t),\n+\n+            super::VtableClosure(ref d) =>\n+                write!(f, \"{:?}\", d),\n+\n+            super::VtableFnPointer(ref d) =>\n+                write!(f, \"VtableFnPointer({:?})\", d),\n+\n+            super::VtableObject(ref d) =>\n+                write!(f, \"{:?}\", d),\n+\n+            super::VtableParam(ref n) =>\n+                write!(f, \"VtableParam({:?})\", n),\n+\n+            super::VtableBuiltin(ref d) =>\n+                write!(f, \"{:?}\", d)\n+        }\n+    }\n+}\n+\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableImplData<'tcx, N> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"VtableImpl(impl_def_id={:?}, substs={:?}, nested={:?})\",\n+               self.impl_def_id,\n+               self.substs,\n+               self.nested)\n+    }\n+}\n+\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableClosureData<'tcx, N> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"VtableClosure(closure_def_id={:?}, substs={:?}, nested={:?})\",\n+               self.closure_def_id,\n+               self.substs,\n+               self.nested)\n+    }\n+}\n+\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableBuiltinData<N> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"VtableBuiltin(nested={:?})\", self.nested)\n+    }\n+}\n+\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableDefaultImplData<N> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"VtableDefaultImplData(trait_def_id={:?}, nested={:?})\",\n+               self.trait_def_id,\n+               self.nested)\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for traits::VtableObjectData<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"VtableObject(upcast={:?}, vtable_base={})\",\n+               self.upcast_trait_ref,\n+               self.vtable_base)\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for traits::FulfillmentError<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"FulfillmentError({:?},{:?})\",\n+               self.obligation,\n+               self.code)\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for traits::FulfillmentErrorCode<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            super::CodeSelectionError(ref e) => write!(f, \"{:?}\", e),\n+            super::CodeProjectionError(ref e) => write!(f, \"{:?}\", e),\n+            super::CodeAmbiguity => write!(f, \"Ambiguity\")\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for traits::MismatchedProjectionTypes<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"MismatchedProjectionTypes({:?})\", self.err)\n+    }\n+}\n+\n+impl<'tcx, P: RegionEscape> RegionEscape for traits::Obligation<'tcx,P> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.predicate.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n+impl<'tcx, T: HasTypeFlags> HasTypeFlags for traits::Obligation<'tcx, T> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.predicate.has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx, T: HasTypeFlags> HasTypeFlags for Normalized<'tcx, T> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.value.has_type_flags(flags) ||\n+            self.obligations.has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx, O: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Obligation<'tcx, O>\n+{\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::Obligation<'tcx, O> {\n+        traits::Obligation {\n+            cause: self.cause.clone(),\n+            recursion_depth: self.recursion_depth,\n+            predicate: self.predicate.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableImplData<'tcx, N> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableImplData<'tcx, N> {\n+        traits::VtableImplData {\n+            impl_def_id: self.impl_def_id,\n+            substs: self.substs.fold_with(folder),\n+            nested: self.nested.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableClosureData<'tcx, N> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableClosureData<'tcx, N> {\n+        traits::VtableClosureData {\n+            closure_def_id: self.closure_def_id,\n+            substs: self.substs.fold_with(folder),\n+            nested: self.nested.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableDefaultImplData<N> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableDefaultImplData<N> {\n+        traits::VtableDefaultImplData {\n+            trait_def_id: self.trait_def_id,\n+            nested: self.nested.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableBuiltinData<N> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableBuiltinData<N> {\n+        traits::VtableBuiltinData {\n+            nested: self.nested.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::Vtable<'tcx, N> {\n+        match *self {\n+            traits::VtableImpl(ref v) => traits::VtableImpl(v.fold_with(folder)),\n+            traits::VtableDefaultImpl(ref t) => traits::VtableDefaultImpl(t.fold_with(folder)),\n+            traits::VtableClosure(ref d) => {\n+                traits::VtableClosure(d.fold_with(folder))\n+            }\n+            traits::VtableFnPointer(ref d) => {\n+                traits::VtableFnPointer(d.fold_with(folder))\n+            }\n+            traits::VtableParam(ref n) => traits::VtableParam(n.fold_with(folder)),\n+            traits::VtableBuiltin(ref d) => traits::VtableBuiltin(d.fold_with(folder)),\n+            traits::VtableObject(ref d) => traits::VtableObject(d.fold_with(folder)),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for traits::VtableObjectData<'tcx> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableObjectData<'tcx> {\n+        traits::VtableObjectData {\n+            upcast_trait_ref: self.upcast_trait_ref.fold_with(folder),\n+            vtable_base: self.vtable_base\n+        }\n+    }\n+}\n+\n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Normalized<'tcx, T> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Normalized<'tcx, T> {\n+        Normalized {\n+            value: self.value.fold_with(folder),\n+            obligations: self.obligations.fold_with(folder),\n+        }\n+    }\n+}"}, {"sha": "1c5156aab02be9c0a53b57df21167d87e51d57d9", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 2, "deletions": 109, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/2ad5a61fe234e54c9385efac7fb4d04f34a137b1/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad5a61fe234e54c9385efac7fb4d04f34a137b1/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=2ad5a61fe234e54c9385efac7fb4d04f34a137b1", "patch": "@@ -11,14 +11,12 @@\n use middle::def_id::DefId;\n use middle::infer::InferCtxt;\n use middle::subst::Substs;\n-use middle::ty::{self, HasTypeFlags, Ty, ToPredicate, ToPolyTraitRef};\n-use std::fmt;\n+use middle::ty::{self, Ty, ToPredicate, ToPolyTraitRef};\n use syntax::codemap::Span;\n use util::common::ErrorReported;\n use util::nodemap::FnvHashSet;\n \n-use super::{Obligation, ObligationCause, PredicateObligation,\n-            VtableImpl, VtableParam, VtableImplData, VtableDefaultImplData};\n+use super::{Obligation, ObligationCause, PredicateObligation};\n \n struct PredicateSet<'a,'tcx:'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n@@ -477,108 +475,3 @@ pub fn closure_trait_ref_and_return_type<'tcx>(\n     };\n     ty::Binder((trait_ref, sig.0.output.unwrap_or(tcx.mk_nil())))\n }\n-\n-impl<'tcx,O:fmt::Debug> fmt::Debug for super::Obligation<'tcx, O> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"Obligation(predicate={:?},depth={})\",\n-               self.predicate,\n-               self.recursion_depth)\n-    }\n-}\n-\n-impl<'tcx, N:fmt::Debug> fmt::Debug for super::Vtable<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            super::VtableImpl(ref v) =>\n-                write!(f, \"{:?}\", v),\n-\n-            super::VtableDefaultImpl(ref t) =>\n-                write!(f, \"{:?}\", t),\n-\n-            super::VtableClosure(ref d) =>\n-                write!(f, \"{:?}\", d),\n-\n-            super::VtableFnPointer(ref d) =>\n-                write!(f, \"VtableFnPointer({:?})\", d),\n-\n-            super::VtableObject(ref d) =>\n-                write!(f, \"{:?}\", d),\n-\n-            super::VtableParam(ref n) =>\n-                write!(f, \"VtableParam({:?})\", n),\n-\n-            super::VtableBuiltin(ref d) =>\n-                write!(f, \"{:?}\", d)\n-        }\n-    }\n-}\n-\n-impl<'tcx, N:fmt::Debug> fmt::Debug for super::VtableImplData<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableImpl(impl_def_id={:?}, substs={:?}, nested={:?})\",\n-               self.impl_def_id,\n-               self.substs,\n-               self.nested)\n-    }\n-}\n-\n-impl<'tcx, N:fmt::Debug> fmt::Debug for super::VtableClosureData<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableClosure(closure_def_id={:?}, substs={:?}, nested={:?})\",\n-               self.closure_def_id,\n-               self.substs,\n-               self.nested)\n-    }\n-}\n-\n-impl<'tcx, N:fmt::Debug> fmt::Debug for super::VtableBuiltinData<N> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableBuiltin(nested={:?})\", self.nested)\n-    }\n-}\n-\n-impl<'tcx, N:fmt::Debug> fmt::Debug for super::VtableDefaultImplData<N> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableDefaultImplData(trait_def_id={:?}, nested={:?})\",\n-               self.trait_def_id,\n-               self.nested)\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for super::VtableObjectData<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableObject(upcast={:?}, vtable_base={})\",\n-               self.upcast_trait_ref,\n-               self.vtable_base)\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for super::FulfillmentError<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"FulfillmentError({:?},{:?})\",\n-               self.obligation,\n-               self.code)\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for super::FulfillmentErrorCode<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            super::CodeSelectionError(ref e) => write!(f, \"{:?}\", e),\n-            super::CodeProjectionError(ref e) => write!(f, \"{:?}\", e),\n-            super::CodeAmbiguity => write!(f, \"Ambiguity\")\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for super::MismatchedProjectionTypes<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"MismatchedProjectionTypes({:?})\", self.err)\n-    }\n-}\n-\n-impl<'tcx, T: HasTypeFlags> HasTypeFlags for Obligation<'tcx, T> {\n-    fn has_type_flags(&self, flags: ty::TypeFlags) -> bool {\n-        self.predicate.has_type_flags(flags)\n-    }\n-}"}, {"sha": "94e4672ea9710e850f87fd0c4192464ed2c46557", "filename": "src/librustc/middle/ty/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/2ad5a61fe234e54c9385efac7fb4d04f34a137b1/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad5a61fe234e54c9385efac7fb4d04f34a137b1/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs?ref=2ad5a61fe234e54c9385efac7fb4d04f34a137b1", "patch": "@@ -116,12 +116,6 @@ impl<'tcx> RegionEscape for ty::Predicate<'tcx> {\n     }\n }\n \n-impl<'tcx,P:RegionEscape> RegionEscape for traits::Obligation<'tcx,P> {\n-    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n-        self.predicate.has_regions_escaping_depth(depth)\n-    }\n-}\n-\n impl<'tcx> RegionEscape for TraitRef<'tcx> {\n     fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n         self.substs.types.iter().any(|t| t.has_regions_escaping_depth(depth)) ||\n@@ -770,82 +764,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::InstantiatedPredicates<'tcx> {\n     }\n }\n \n-impl<'tcx,O> TypeFoldable<'tcx> for traits::Obligation<'tcx,O>\n-    where O : TypeFoldable<'tcx>\n-{\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::Obligation<'tcx, O> {\n-        traits::Obligation {\n-            cause: self.cause.clone(),\n-            recursion_depth: self.recursion_depth,\n-            predicate: self.predicate.fold_with(folder),\n-        }\n-    }\n-}\n-\n-impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableImplData<'tcx, N> {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableImplData<'tcx, N> {\n-        traits::VtableImplData {\n-            impl_def_id: self.impl_def_id,\n-            substs: self.substs.fold_with(folder),\n-            nested: self.nested.fold_with(folder),\n-        }\n-    }\n-}\n-\n-impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableClosureData<'tcx, N> {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableClosureData<'tcx, N> {\n-        traits::VtableClosureData {\n-            closure_def_id: self.closure_def_id,\n-            substs: self.substs.fold_with(folder),\n-            nested: self.nested.fold_with(folder),\n-        }\n-    }\n-}\n-\n-impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableDefaultImplData<N> {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableDefaultImplData<N> {\n-        traits::VtableDefaultImplData {\n-            trait_def_id: self.trait_def_id,\n-            nested: self.nested.fold_with(folder),\n-        }\n-    }\n-}\n-\n-impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableBuiltinData<N> {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableBuiltinData<N> {\n-        traits::VtableBuiltinData {\n-            nested: self.nested.fold_with(folder),\n-        }\n-    }\n-}\n-\n-impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N> {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::Vtable<'tcx, N> {\n-        match *self {\n-            traits::VtableImpl(ref v) => traits::VtableImpl(v.fold_with(folder)),\n-            traits::VtableDefaultImpl(ref t) => traits::VtableDefaultImpl(t.fold_with(folder)),\n-            traits::VtableClosure(ref d) => {\n-                traits::VtableClosure(d.fold_with(folder))\n-            }\n-            traits::VtableFnPointer(ref d) => {\n-                traits::VtableFnPointer(d.fold_with(folder))\n-            }\n-            traits::VtableParam(ref n) => traits::VtableParam(n.fold_with(folder)),\n-            traits::VtableBuiltin(ref d) => traits::VtableBuiltin(d.fold_with(folder)),\n-            traits::VtableObject(ref d) => traits::VtableObject(d.fold_with(folder)),\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for traits::VtableObjectData<'tcx> {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableObjectData<'tcx> {\n-        traits::VtableObjectData {\n-            upcast_trait_ref: self.upcast_trait_ref.fold_with(folder),\n-            vtable_base: self.vtable_base\n-        }\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for ty::EquatePredicate<'tcx> {\n     fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::EquatePredicate<'tcx> {\n         ty::EquatePredicate(self.0.fold_with(folder),"}]}