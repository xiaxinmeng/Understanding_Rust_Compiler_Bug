{"sha": "703390150a75abbe6fbacd6b6e3ae08c9a6f5e37", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwMzM5MDE1MGE3NWFiYmU2ZmJhY2Q2YjZlM2FlMDhjOWE2ZjVlMzc=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-04-19T15:45:25Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-04-28T16:51:15Z"}, "message": "fix for parsing x() as identifier pattern", "tree": {"sha": "9708ca96e4ea3924eda74d925784deb9aa7fe87b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9708ca96e4ea3924eda74d925784deb9aa7fe87b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/703390150a75abbe6fbacd6b6e3ae08c9a6f5e37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/703390150a75abbe6fbacd6b6e3ae08c9a6f5e37", "html_url": "https://github.com/rust-lang/rust/commit/703390150a75abbe6fbacd6b6e3ae08c9a6f5e37", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/703390150a75abbe6fbacd6b6e3ae08c9a6f5e37/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5119597dc6549e21d62ce7bae7b7418b3f8bf56e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5119597dc6549e21d62ce7bae7b7418b3f8bf56e", "html_url": "https://github.com/rust-lang/rust/commit/5119597dc6549e21d62ce7bae7b7418b3f8bf56e"}], "stats": {"total": 31, "additions": 14, "deletions": 17}, "files": [{"sha": "1ec7c91121dc48440f405e7b1ed7de5890d9be2c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/703390150a75abbe6fbacd6b6e3ae08c9a6f5e37/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/703390150a75abbe6fbacd6b6e3ae08c9a6f5e37/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=703390150a75abbe6fbacd6b6e3ae08c9a6f5e37", "patch": "@@ -2359,14 +2359,13 @@ pub impl Parser {\n                         }\n                         _ => {\n                             let mut args: ~[@pat] = ~[];\n-                            let mut star_pat = false;\n                             match *self.token {\n                               token::LPAREN => match self.look_ahead(1u) {\n                                 token::BINOP(token::STAR) => {\n                                     // This is a \"top constructor only\" pat\n                                       self.bump(); self.bump();\n-                                      star_pat = true;\n                                       self.expect(&token::RPAREN);\n+                                      pat = pat_enum(enum_path, None);\n                                   }\n                                 _ => {\n                                     args = self.parse_unspanned_seq(\n@@ -2377,23 +2376,21 @@ pub impl Parser {\n                                         ),\n                                         |p| p.parse_pat(refutable)\n                                     );\n+                                    pat = pat_enum(enum_path, Some(args));\n                                   }\n                               },\n-                              _ => ()\n-                            }\n-                            // at this point, we're not sure whether it's a\n-                            // enum or a bind\n-                            if star_pat {\n-                                pat = pat_enum(enum_path, None);\n-                            }\n-                            else if vec::is_empty(args) &&\n-                                vec::len(enum_path.idents) == 1u {\n-                                pat = pat_ident(binding_mode,\n-                                                enum_path,\n-                                                None);\n-                            }\n-                            else {\n-                                pat = pat_enum(enum_path, Some(args));\n+                              _ => {\n+                                  if vec::len(enum_path.idents)==1u {\n+                                      // it could still be either an enum\n+                                      // or an identifier pattern, resolve\n+                                      // will sort it out:\n+                                      pat = pat_ident(binding_mode,\n+                                                      enum_path,\n+                                                      None);\n+                                  } else {\n+                                      pat = pat_enum(enum_path, Some(args));\n+                                  }\n+                              }\n                             }\n                         }\n                     }"}]}