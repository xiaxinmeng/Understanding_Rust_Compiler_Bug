{"sha": "1ddee8070d3cb83609b1f71c29e3deda3d30fd51", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkZGVlODA3MGQzY2I4MzYwOWIxZjcxYzI5ZTNkZWRhM2QzMGZkNTE=", "commit": {"author": {"name": "Eli Friedman", "email": "eli.friedman@gmail.com", "date": "2015-08-16T07:42:53Z"}, "committer": {"name": "Eli Friedman", "email": "eli.friedman@gmail.com", "date": "2015-08-17T18:30:59Z"}, "message": "Remove dependencies on libm functions from libcore.\n\nThere wasn't any particular reason the functions needed to be there\nanyway, so just get rid of them, and adjust libstd to compensate.\n\nWith this change, libcore depends on exactly two floating-point functions:\nfmod and fmodf.  They are implicitly referenced because they are\nused to implement \"%\".", "tree": {"sha": "5cc0748842fb026f38f69b4932d925163afc4a15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5cc0748842fb026f38f69b4932d925163afc4a15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ddee8070d3cb83609b1f71c29e3deda3d30fd51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ddee8070d3cb83609b1f71c29e3deda3d30fd51", "html_url": "https://github.com/rust-lang/rust/commit/1ddee8070d3cb83609b1f71c29e3deda3d30fd51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ddee8070d3cb83609b1f71c29e3deda3d30fd51/comments", "author": {"login": "eefriedman", "id": 12769964, "node_id": "MDQ6VXNlcjEyNzY5OTY0", "avatar_url": "https://avatars.githubusercontent.com/u/12769964?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eefriedman", "html_url": "https://github.com/eefriedman", "followers_url": "https://api.github.com/users/eefriedman/followers", "following_url": "https://api.github.com/users/eefriedman/following{/other_user}", "gists_url": "https://api.github.com/users/eefriedman/gists{/gist_id}", "starred_url": "https://api.github.com/users/eefriedman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eefriedman/subscriptions", "organizations_url": "https://api.github.com/users/eefriedman/orgs", "repos_url": "https://api.github.com/users/eefriedman/repos", "events_url": "https://api.github.com/users/eefriedman/events{/privacy}", "received_events_url": "https://api.github.com/users/eefriedman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eefriedman", "id": 12769964, "node_id": "MDQ6VXNlcjEyNzY5OTY0", "avatar_url": "https://avatars.githubusercontent.com/u/12769964?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eefriedman", "html_url": "https://github.com/eefriedman", "followers_url": "https://api.github.com/users/eefriedman/followers", "following_url": "https://api.github.com/users/eefriedman/following{/other_user}", "gists_url": "https://api.github.com/users/eefriedman/gists{/gist_id}", "starred_url": "https://api.github.com/users/eefriedman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eefriedman/subscriptions", "organizations_url": "https://api.github.com/users/eefriedman/orgs", "repos_url": "https://api.github.com/users/eefriedman/repos", "events_url": "https://api.github.com/users/eefriedman/events{/privacy}", "received_events_url": "https://api.github.com/users/eefriedman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b7fc67dd453c470a48dbdcf64693a93293c9ab0", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b7fc67dd453c470a48dbdcf64693a93293c9ab0", "html_url": "https://github.com/rust-lang/rust/commit/7b7fc67dd453c470a48dbdcf64693a93293c9ab0"}], "stats": {"total": 512, "additions": 194, "deletions": 318}, "files": [{"sha": "883f9abf91716d0eda5d9964db1cf566756521e4", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 0, "deletions": 140, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/1ddee8070d3cb83609b1f71c29e3deda3d30fd51/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddee8070d3cb83609b1f71c29e3deda3d30fd51/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=1ddee8070d3cb83609b1f71c29e3deda3d30fd51", "patch": "@@ -222,63 +222,6 @@ impl Float for f32 {\n         (mantissa as u64, exponent, sign)\n     }\n \n-    /// Rounds towards minus infinity.\n-    #[inline]\n-    fn floor(self) -> f32 {\n-        return floorf(self);\n-\n-        // On MSVC LLVM will lower many math intrinsics to a call to the\n-        // corresponding function. On MSVC, however, many of these functions\n-        // aren't actually available as symbols to call, but rather they are all\n-        // `static inline` functions in header files. This means that from a C\n-        // perspective it's \"compatible\", but not so much from an ABI\n-        // perspective (which we're worried about).\n-        //\n-        // The inline header functions always just cast to a f64 and do their\n-        // operation, so we do that here as well, but only for MSVC targets.\n-        //\n-        // Note that there are many MSVC-specific float operations which\n-        // redirect to this comment, so `floorf` is just one case of a missing\n-        // function on MSVC, but there are many others elsewhere.\n-        #[cfg(target_env = \"msvc\")]\n-        fn floorf(f: f32) -> f32 { (f as f64).floor() as f32 }\n-        #[cfg(not(target_env = \"msvc\"))]\n-        fn floorf(f: f32) -> f32 { unsafe { intrinsics::floorf32(f) } }\n-    }\n-\n-    /// Rounds towards plus infinity.\n-    #[inline]\n-    fn ceil(self) -> f32 {\n-        return ceilf(self);\n-\n-        // see notes above in `floor`\n-        #[cfg(target_env = \"msvc\")]\n-        fn ceilf(f: f32) -> f32 { (f as f64).ceil() as f32 }\n-        #[cfg(not(target_env = \"msvc\"))]\n-        fn ceilf(f: f32) -> f32 { unsafe { intrinsics::ceilf32(f) } }\n-    }\n-\n-    /// Rounds to nearest integer. Rounds half-way cases away from zero.\n-    #[inline]\n-    fn round(self) -> f32 {\n-        unsafe { intrinsics::roundf32(self) }\n-    }\n-\n-    /// Returns the integer part of the number (rounds towards zero).\n-    #[inline]\n-    fn trunc(self) -> f32 {\n-        unsafe { intrinsics::truncf32(self) }\n-    }\n-\n-    /// The fractional part of the number, satisfying:\n-    ///\n-    /// ```\n-    /// let x = 1.65f32;\n-    /// assert!(x == x.trunc() + x.fract())\n-    /// ```\n-    #[inline]\n-    fn fract(self) -> f32 { self - self.trunc() }\n-\n     /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n     /// number is `Float::nan()`.\n     #[inline]\n@@ -314,14 +257,6 @@ impl Float for f32 {\n         self < 0.0 || (1.0 / self) == Float::neg_infinity()\n     }\n \n-    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n-    /// error. This produces a more accurate result with better performance than\n-    /// a separate multiplication operation followed by an add.\n-    #[inline]\n-    fn mul_add(self, a: f32, b: f32) -> f32 {\n-        unsafe { intrinsics::fmaf32(self, a, b) }\n-    }\n-\n     /// Returns the reciprocal (multiplicative inverse) of the number.\n     #[inline]\n     fn recip(self) -> f32 { 1.0 / self }\n@@ -331,81 +266,6 @@ impl Float for f32 {\n         unsafe { intrinsics::powif32(self, n) }\n     }\n \n-    #[inline]\n-    fn powf(self, n: f32) -> f32 {\n-        return powf(self, n);\n-\n-        // see notes above in `floor`\n-        #[cfg(target_env = \"msvc\")]\n-        fn powf(f: f32, n: f32) -> f32 { (f as f64).powf(n as f64) as f32 }\n-        #[cfg(not(target_env = \"msvc\"))]\n-        fn powf(f: f32, n: f32) -> f32 { unsafe { intrinsics::powf32(f, n) } }\n-    }\n-\n-    #[inline]\n-    fn sqrt(self) -> f32 {\n-        if self < 0.0 {\n-            NAN\n-        } else {\n-            unsafe { intrinsics::sqrtf32(self) }\n-        }\n-    }\n-\n-    #[inline]\n-    fn rsqrt(self) -> f32 { self.sqrt().recip() }\n-\n-    /// Returns the exponential of the number.\n-    #[inline]\n-    fn exp(self) -> f32 {\n-        return expf(self);\n-\n-        // see notes above in `floor`\n-        #[cfg(target_env = \"msvc\")]\n-        fn expf(f: f32) -> f32 { (f as f64).exp() as f32 }\n-        #[cfg(not(target_env = \"msvc\"))]\n-        fn expf(f: f32) -> f32 { unsafe { intrinsics::expf32(f) } }\n-    }\n-\n-    /// Returns 2 raised to the power of the number.\n-    #[inline]\n-    fn exp2(self) -> f32 {\n-        unsafe { intrinsics::exp2f32(self) }\n-    }\n-\n-    /// Returns the natural logarithm of the number.\n-    #[inline]\n-    fn ln(self) -> f32 {\n-        return logf(self);\n-\n-        // see notes above in `floor`\n-        #[cfg(target_env = \"msvc\")]\n-        fn logf(f: f32) -> f32 { (f as f64).ln() as f32 }\n-        #[cfg(not(target_env = \"msvc\"))]\n-        fn logf(f: f32) -> f32 { unsafe { intrinsics::logf32(f) } }\n-    }\n-\n-    /// Returns the logarithm of the number with respect to an arbitrary base.\n-    #[inline]\n-    fn log(self, base: f32) -> f32 { self.ln() / base.ln() }\n-\n-    /// Returns the base 2 logarithm of the number.\n-    #[inline]\n-    fn log2(self) -> f32 {\n-        unsafe { intrinsics::log2f32(self) }\n-    }\n-\n-    /// Returns the base 10 logarithm of the number.\n-    #[inline]\n-    fn log10(self) -> f32 {\n-        return log10f(self);\n-\n-        // see notes above in `floor`\n-        #[cfg(target_env = \"msvc\")]\n-        fn log10f(f: f32) -> f32 { (f as f64).log10() as f32 }\n-        #[cfg(not(target_env = \"msvc\"))]\n-        fn log10f(f: f32) -> f32 { unsafe { intrinsics::log10f32(f) } }\n-    }\n-\n     /// Converts to degrees, assuming the number is in radians.\n     #[inline]\n     fn to_degrees(self) -> f32 { self * (180.0f32 / consts::PI) }"}, {"sha": "248137f522923126e8c816158d425e74ef599ef6", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 0, "deletions": 92, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/1ddee8070d3cb83609b1f71c29e3deda3d30fd51/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddee8070d3cb83609b1f71c29e3deda3d30fd51/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=1ddee8070d3cb83609b1f71c29e3deda3d30fd51", "patch": "@@ -222,39 +222,6 @@ impl Float for f64 {\n         (mantissa, exponent, sign)\n     }\n \n-    /// Rounds towards minus infinity.\n-    #[inline]\n-    fn floor(self) -> f64 {\n-        unsafe { intrinsics::floorf64(self) }\n-    }\n-\n-    /// Rounds towards plus infinity.\n-    #[inline]\n-    fn ceil(self) -> f64 {\n-        unsafe { intrinsics::ceilf64(self) }\n-    }\n-\n-    /// Rounds to nearest integer. Rounds half-way cases away from zero.\n-    #[inline]\n-    fn round(self) -> f64 {\n-        unsafe { intrinsics::roundf64(self) }\n-    }\n-\n-    /// Returns the integer part of the number (rounds towards zero).\n-    #[inline]\n-    fn trunc(self) -> f64 {\n-        unsafe { intrinsics::truncf64(self) }\n-    }\n-\n-    /// The fractional part of the number, satisfying:\n-    ///\n-    /// ```\n-    /// let x = 1.65f64;\n-    /// assert!(x == x.trunc() + x.fract())\n-    /// ```\n-    #[inline]\n-    fn fract(self) -> f64 { self - self.trunc() }\n-\n     /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n     /// number is `Float::nan()`.\n     #[inline]\n@@ -290,74 +257,15 @@ impl Float for f64 {\n         self < 0.0 || (1.0 / self) == Float::neg_infinity()\n     }\n \n-    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n-    /// error. This produces a more accurate result with better performance than\n-    /// a separate multiplication operation followed by an add.\n-    #[inline]\n-    fn mul_add(self, a: f64, b: f64) -> f64 {\n-        unsafe { intrinsics::fmaf64(self, a, b) }\n-    }\n-\n     /// Returns the reciprocal (multiplicative inverse) of the number.\n     #[inline]\n     fn recip(self) -> f64 { 1.0 / self }\n \n-    #[inline]\n-    fn powf(self, n: f64) -> f64 {\n-        unsafe { intrinsics::powf64(self, n) }\n-    }\n-\n     #[inline]\n     fn powi(self, n: i32) -> f64 {\n         unsafe { intrinsics::powif64(self, n) }\n     }\n \n-    #[inline]\n-    fn sqrt(self) -> f64 {\n-        if self < 0.0 {\n-            NAN\n-        } else {\n-            unsafe { intrinsics::sqrtf64(self) }\n-        }\n-    }\n-\n-    #[inline]\n-    fn rsqrt(self) -> f64 { self.sqrt().recip() }\n-\n-    /// Returns the exponential of the number.\n-    #[inline]\n-    fn exp(self) -> f64 {\n-        unsafe { intrinsics::expf64(self) }\n-    }\n-\n-    /// Returns 2 raised to the power of the number.\n-    #[inline]\n-    fn exp2(self) -> f64 {\n-        unsafe { intrinsics::exp2f64(self) }\n-    }\n-\n-    /// Returns the natural logarithm of the number.\n-    #[inline]\n-    fn ln(self) -> f64 {\n-        unsafe { intrinsics::logf64(self) }\n-    }\n-\n-    /// Returns the logarithm of the number with respect to an arbitrary base.\n-    #[inline]\n-    fn log(self, base: f64) -> f64 { self.ln() / base.ln() }\n-\n-    /// Returns the base 2 logarithm of the number.\n-    #[inline]\n-    fn log2(self) -> f64 {\n-        unsafe { intrinsics::log2f64(self) }\n-    }\n-\n-    /// Returns the base 10 logarithm of the number.\n-    #[inline]\n-    fn log10(self) -> f64 {\n-        unsafe { intrinsics::log10f64(self) }\n-    }\n-\n     /// Converts to degrees, assuming the number is in radians.\n     #[inline]\n     fn to_degrees(self) -> f64 { self * (180.0f64 / consts::PI) }"}, {"sha": "6265691bde9e9ff278c1d73aa50b76d02653b4ca", "filename": "src/libcore/num/flt2dec/decoder.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1ddee8070d3cb83609b1f71c29e3deda3d30fd51/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddee8070d3cb83609b1f71c29e3deda3d30fd51/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs?ref=1ddee8070d3cb83609b1f71c29e3deda3d30fd51", "patch": "@@ -53,20 +53,15 @@ pub enum FullDecoded {\n \n /// A floating point type which can be `decode`d.\n pub trait DecodableFloat: Float + Copy {\n-    /// Returns `x * 2^exp`. Almost same to `std::{f32,f64}::ldexp`.\n-    /// This is used for testing.\n-    fn ldexpi(f: i64, exp: isize) -> Self;\n     /// The minimum positive normalized value.\n     fn min_pos_norm_value() -> Self;\n }\n \n impl DecodableFloat for f32 {\n-    fn ldexpi(f: i64, exp: isize) -> Self { f as Self * (exp as Self).exp2() }\n     fn min_pos_norm_value() -> Self { f32::MIN_POSITIVE }\n }\n \n impl DecodableFloat for f64 {\n-    fn ldexpi(f: i64, exp: isize) -> Self { f as Self * (exp as Self).exp2() }\n     fn min_pos_norm_value() -> Self { f64::MIN_POSITIVE }\n }\n "}, {"sha": "1277decf5e2fbc2e10f26c120f0214307f32abe4", "filename": "src/libcore/num/flt2dec/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1ddee8070d3cb83609b1f71c29e3deda3d30fd51/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddee8070d3cb83609b1f71c29e3deda3d30fd51/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs?ref=1ddee8070d3cb83609b1f71c29e3deda3d30fd51", "patch": "@@ -131,7 +131,6 @@ functions.\n \n use prelude::v1::*;\n use i16;\n-use num::Float;\n use slice::bytes;\n pub use self::decoder::{decode, DecodableFloat, FullDecoded, Decoded};\n "}, {"sha": "ab610f28e9eca69cc8b7ff0f7bdc8508ccce5e7d", "filename": "src/libcore/num/flt2dec/strategy/dragon.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1ddee8070d3cb83609b1f71c29e3deda3d30fd51/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddee8070d3cb83609b1f71c29e3deda3d30fd51/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs?ref=1ddee8070d3cb83609b1f71c29e3deda3d30fd51", "patch": "@@ -17,7 +17,6 @@ Almost direct (but slightly optimized) Rust translation of Figure 3 of [1].\n \n use prelude::v1::*;\n \n-use num::Float;\n use cmp::Ordering;\n \n use num::flt2dec::{Decoded, MAX_SIG_DIGITS, round_up};"}, {"sha": "b0822ca76c76b8b2641fc80efb74bb23745e825b", "filename": "src/libcore/num/flt2dec/strategy/grisu.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ddee8070d3cb83609b1f71c29e3deda3d30fd51/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddee8070d3cb83609b1f71c29e3deda3d30fd51/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=1ddee8070d3cb83609b1f71c29e3deda3d30fd51", "patch": "@@ -18,8 +18,6 @@ Rust adaptation of Grisu3 algorithm described in [1]. It uses about\n \n use prelude::v1::*;\n \n-use num::Float;\n-\n use num::flt2dec::{Decoded, MAX_SIG_DIGITS, round_up};\n \n /// A custom 64-bit floating point type, representing `f * 2^e`."}, {"sha": "60675a618684962765be6daa30501c54485f0f0c", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1ddee8070d3cb83609b1f71c29e3deda3d30fd51/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddee8070d3cb83609b1f71c29e3deda3d30fd51/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=1ddee8070d3cb83609b1f71c29e3deda3d30fd51", "patch": "@@ -1296,18 +1296,6 @@ pub trait Float {\n     /// Returns the mantissa, exponent and sign as integers, respectively.\n     fn integer_decode(self) -> (u64, i16, i8);\n \n-    /// Return the largest integer less than or equal to a number.\n-    fn floor(self) -> Self;\n-    /// Return the smallest integer greater than or equal to a number.\n-    fn ceil(self) -> Self;\n-    /// Return the nearest integer to a number. Round half-way cases away from\n-    /// `0.0`.\n-    fn round(self) -> Self;\n-    /// Return the integer part of a number.\n-    fn trunc(self) -> Self;\n-    /// Return the fractional part of a number.\n-    fn fract(self) -> Self;\n-\n     /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n     /// number is `Float::nan()`.\n     fn abs(self) -> Self;\n@@ -1324,39 +1312,13 @@ pub trait Float {\n     /// `Float::neg_infinity()`.\n     fn is_negative(self) -> bool;\n \n-    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n-    /// error. This produces a more accurate result with better performance than\n-    /// a separate multiplication operation followed by an add.\n-    fn mul_add(self, a: Self, b: Self) -> Self;\n     /// Take the reciprocal (inverse) of a number, `1/x`.\n     fn recip(self) -> Self;\n \n     /// Raise a number to an integer power.\n     ///\n     /// Using this function is generally faster than using `powf`\n     fn powi(self, n: i32) -> Self;\n-    /// Raise a number to a floating point power.\n-    fn powf(self, n: Self) -> Self;\n-\n-    /// Take the square root of a number.\n-    ///\n-    /// Returns NaN if `self` is a negative number.\n-    fn sqrt(self) -> Self;\n-    /// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n-    fn rsqrt(self) -> Self;\n-\n-    /// Returns `e^(self)`, (the exponential function).\n-    fn exp(self) -> Self;\n-    /// Returns 2 raised to the power of the number, `2^(self)`.\n-    fn exp2(self) -> Self;\n-    /// Returns the natural logarithm of the number.\n-    fn ln(self) -> Self;\n-    /// Returns the logarithm of the number with respect to an arbitrary base.\n-    fn log(self, base: Self) -> Self;\n-    /// Returns the base 2 logarithm of the number.\n-    fn log2(self) -> Self;\n-    /// Returns the base 10 logarithm of the number.\n-    fn log10(self) -> Self;\n \n     /// Convert radians to degrees.\n     fn to_degrees(self) -> Self;"}, {"sha": "061eba8a75e9437e87e75efbd07ea6817d87b126", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1ddee8070d3cb83609b1f71c29e3deda3d30fd51/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddee8070d3cb83609b1f71c29e3deda3d30fd51/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=1ddee8070d3cb83609b1f71c29e3deda3d30fd51", "patch": "@@ -445,7 +445,9 @@ rem_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n impl Rem for f32 {\n     type Output = f32;\n \n-    // see notes in `core::f32::Float::floor`\n+    // The builtin f32 rem operator is broken when targeting\n+    // MSVC; see comment in std::f32::floor.\n+    // FIXME: See also #27859.\n     #[inline]\n     #[cfg(target_env = \"msvc\")]\n     fn rem(self, other: f32) -> f32 {"}, {"sha": "8ae33a4420207038d5af70ba8818e56903d4f7f3", "filename": "src/libcoretest/num/flt2dec/mod.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1ddee8070d3cb83609b1f71c29e3deda3d30fd51/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddee8070d3cb83609b1f71c29e3deda3d30fd51/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fmod.rs?ref=1ddee8070d3cb83609b1f71c29e3deda3d30fd51", "patch": "@@ -164,12 +164,26 @@ fn check_exact<F, T>(mut f: F, v: T, vstr: &str, expected: &[u8], expectedk: i16\n     }\n }\n \n+trait TestableFloat : DecodableFloat + fmt::Display {\n+    /// Returns `x * 2^exp`. Almost same to `std::{f32,f64}::ldexp`.\n+    /// This is used for testing.\n+    fn ldexpi(f: i64, exp: isize) -> Self;\n+}\n+\n+impl TestableFloat for f32 {\n+    fn ldexpi(f: i64, exp: isize) -> Self { f as Self * (exp as Self).exp2() }\n+}\n+\n+impl TestableFloat for f64 {\n+    fn ldexpi(f: i64, exp: isize) -> Self { f as Self * (exp as Self).exp2() }\n+}\n+\n fn check_exact_one<F, T>(mut f: F, x: i64, e: isize, tstr: &str, expected: &[u8], expectedk: i16)\n-        where T: DecodableFloat + fmt::Display,\n+        where T: TestableFloat,\n               F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n     // use a large enough buffer\n     let mut buf = [b'_'; 1024];\n-    let v: T = DecodableFloat::ldexpi(x, e);\n+    let v: T = TestableFloat::ldexpi(x, e);\n     let decoded = decode_finite(v);\n \n     try_exact!(f(&decoded) => &mut buf, &expected, expectedk;"}, {"sha": "ce72fa08a73de728ed3193a419d3556bf0fb1dcb", "filename": "src/librand/distributions/exponential.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ddee8070d3cb83609b1f71c29e3deda3d30fd51/src%2Flibrand%2Fdistributions%2Fexponential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddee8070d3cb83609b1f71c29e3deda3d30fd51/src%2Flibrand%2Fdistributions%2Fexponential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fexponential.rs?ref=1ddee8070d3cb83609b1f71c29e3deda3d30fd51", "patch": "@@ -10,7 +10,7 @@\n \n //! The exponential distribution.\n \n-use core::num::Float;\n+use FloatMath;\n \n use {Rng, Rand};\n use distributions::{ziggurat, ziggurat_tables, Sample, IndependentSample};"}, {"sha": "2a5d4bbd2ec9db6818df0f201771fa148167cd8e", "filename": "src/librand/distributions/gamma.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ddee8070d3cb83609b1f71c29e3deda3d30fd51/src%2Flibrand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddee8070d3cb83609b1f71c29e3deda3d30fd51/src%2Flibrand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fgamma.rs?ref=1ddee8070d3cb83609b1f71c29e3deda3d30fd51", "patch": "@@ -13,7 +13,7 @@\n use self::GammaRepr::*;\n use self::ChiSquaredRepr::*;\n \n-use core::num::Float;\n+use FloatMath;\n \n use {Rng, Open01};\n use super::normal::StandardNormal;"}, {"sha": "cc70a695c8d594c1ab85cac67006c7a1ad77cd5c", "filename": "src/librand/distributions/normal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ddee8070d3cb83609b1f71c29e3deda3d30fd51/src%2Flibrand%2Fdistributions%2Fnormal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddee8070d3cb83609b1f71c29e3deda3d30fd51/src%2Flibrand%2Fdistributions%2Fnormal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fnormal.rs?ref=1ddee8070d3cb83609b1f71c29e3deda3d30fd51", "patch": "@@ -10,7 +10,7 @@\n \n //! The normal and derived distributions.\n \n-use core::num::Float;\n+use FloatMath;\n \n use {Rng, Rand, Open01};\n use distributions::{ziggurat, ziggurat_tables, Sample, IndependentSample};"}, {"sha": "aa4b93f06b4ad60c221d16b04cfcb5b4ce49e111", "filename": "src/librand/lib.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1ddee8070d3cb83609b1f71c29e3deda3d30fd51/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddee8070d3cb83609b1f71c29e3deda3d30fd51/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=1ddee8070d3cb83609b1f71c29e3deda3d30fd51", "patch": "@@ -29,6 +29,7 @@\n #![unstable(feature = \"rand\",\n             reason = \"use `rand` from crates.io\")]\n #![feature(core_float)]\n+#![feature(core_intrinsics)]\n #![feature(core_slice_ext)]\n #![feature(no_std)]\n #![feature(num_bits_bytes)]\n@@ -42,6 +43,8 @@\n #[cfg(test)] #[macro_use] extern crate std;\n #[cfg(test)] #[macro_use] extern crate log;\n \n+use core::f64;\n+use core::intrinsics;\n use core::marker::PhantomData;\n \n pub use isaac::{IsaacRng, Isaac64Rng};\n@@ -59,6 +62,43 @@ pub mod chacha;\n pub mod reseeding;\n mod rand_impls;\n \n+// Temporary trait to implement a few floating-point routines\n+// needed by librand; this is necessary because librand doesn't\n+// depend on libstd.  This will go away when librand is integrated\n+// into libstd.\n+trait FloatMath : Sized {\n+    fn exp(self) -> Self;\n+    fn ln(self) -> Self;\n+    fn sqrt(self) -> Self;\n+    fn powf(self, n: Self) -> Self;\n+}\n+\n+impl FloatMath for f64 {\n+    #[inline]\n+    fn exp(self) -> f64 {\n+        unsafe { intrinsics::expf64(self) }\n+    }\n+\n+    #[inline]\n+    fn ln(self) -> f64 {\n+        unsafe { intrinsics::logf64(self) }\n+    }\n+\n+    #[inline]\n+    fn powf(self, n: f64) -> f64 {\n+        unsafe { intrinsics::powf64(self, n) }\n+    }\n+\n+    #[inline]\n+    fn sqrt(self) -> f64 {\n+        if self < 0.0 {\n+            f64::NAN\n+        } else {\n+            unsafe { intrinsics::sqrtf64(self) }\n+        }\n+    }\n+}\n+\n /// A type that can be randomly generated using an `Rng`.\n #[doc(hidden)]\n pub trait Rand : Sized {"}, {"sha": "9c4320ff6334c2a1e7fd9f59c7c078b4c8f07ef2", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 92, "deletions": 17, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/1ddee8070d3cb83609b1f71c29e3deda3d30fd51/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddee8070d3cb83609b1f71c29e3deda3d30fd51/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=1ddee8070d3cb83609b1f71c29e3deda3d30fd51", "patch": "@@ -16,7 +16,6 @@\n #![allow(missing_docs)]\n \n use core::num;\n-#[cfg(not(target_env = \"msvc\"))]\n use intrinsics;\n use libc::c_int;\n use num::{FpCategory, ParseFloatError};\n@@ -40,11 +39,11 @@ mod cmath {\n         pub fn fmaxf(a: c_float, b: c_float) -> c_float;\n         pub fn fminf(a: c_float, b: c_float) -> c_float;\n         pub fn fmodf(a: c_float, b: c_float) -> c_float;\n-        pub fn nextafterf(x: c_float, y: c_float) -> c_float;\n+        pub fn ilogbf(n: c_float) -> c_int;\n         pub fn logbf(n: c_float) -> c_float;\n         pub fn log1pf(n: c_float) -> c_float;\n-        pub fn ilogbf(n: c_float) -> c_int;\n         pub fn modff(n: c_float, iptr: &mut c_float) -> c_float;\n+        pub fn nextafterf(x: c_float, y: c_float) -> c_float;\n         pub fn tgammaf(n: c_float) -> c_float;\n \n         #[cfg_attr(all(windows, target_env = \"msvc\"), link_name = \"__lgammaf_r\")]\n@@ -268,7 +267,27 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn floor(self) -> f32 { num::Float::floor(self) }\n+    pub fn floor(self) -> f32 {\n+        return floorf(self);\n+\n+        // On MSVC LLVM will lower many math intrinsics to a call to the\n+        // corresponding function. On MSVC, however, many of these functions\n+        // aren't actually available as symbols to call, but rather they are all\n+        // `static inline` functions in header files. This means that from a C\n+        // perspective it's \"compatible\", but not so much from an ABI\n+        // perspective (which we're worried about).\n+        //\n+        // The inline header functions always just cast to a f64 and do their\n+        // operation, so we do that here as well, but only for MSVC targets.\n+        //\n+        // Note that there are many MSVC-specific float operations which\n+        // redirect to this comment, so `floorf` is just one case of a missing\n+        // function on MSVC, but there are many others elsewhere.\n+        #[cfg(target_env = \"msvc\")]\n+        fn floorf(f: f32) -> f32 { (f as f64).floor() as f32 }\n+        #[cfg(not(target_env = \"msvc\"))]\n+        fn floorf(f: f32) -> f32 { unsafe { intrinsics::floorf32(f) } }\n+    }\n \n     /// Returns the smallest integer greater than or equal to a number.\n     ///\n@@ -281,7 +300,15 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn ceil(self) -> f32 { num::Float::ceil(self) }\n+    pub fn ceil(self) -> f32 {\n+        return ceilf(self);\n+\n+        // see notes above in `floor`\n+        #[cfg(target_env = \"msvc\")]\n+        fn ceilf(f: f32) -> f32 { (f as f64).ceil() as f32 }\n+        #[cfg(not(target_env = \"msvc\"))]\n+        fn ceilf(f: f32) -> f32 { unsafe { intrinsics::ceilf32(f) } }\n+    }\n \n     /// Returns the nearest integer to a number. Round half-way cases away from\n     /// `0.0`.\n@@ -295,7 +322,9 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn round(self) -> f32 { num::Float::round(self) }\n+    pub fn round(self) -> f32 {\n+        unsafe { intrinsics::roundf32(self) }\n+    }\n \n     /// Returns the integer part of a number.\n     ///\n@@ -308,7 +337,9 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn trunc(self) -> f32 { num::Float::trunc(self) }\n+    pub fn trunc(self) -> f32 {\n+        unsafe { intrinsics::truncf32(self) }\n+    }\n \n     /// Returns the fractional part of a number.\n     ///\n@@ -325,7 +356,7 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn fract(self) -> f32 { num::Float::fract(self) }\n+    pub fn fract(self) -> f32 { self - self.trunc() }\n \n     /// Computes the absolute value of `self`. Returns `NAN` if the\n     /// number is `NAN`.\n@@ -424,7 +455,9 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn mul_add(self, a: f32, b: f32) -> f32 { num::Float::mul_add(self, a, b) }\n+    pub fn mul_add(self, a: f32, b: f32) -> f32 {\n+        unsafe { intrinsics::fmaf32(self, a, b) }\n+    }\n \n     /// Takes the reciprocal (inverse) of a number, `1/x`.\n     ///\n@@ -468,7 +501,15 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn powf(self, n: f32) -> f32 { num::Float::powf(self, n) }\n+    pub fn powf(self, n: f32) -> f32 {\n+        return powf(self, n);\n+\n+        // see notes above in `floor`\n+        #[cfg(target_env = \"msvc\")]\n+        fn powf(f: f32, n: f32) -> f32 { (f as f64).powf(n as f64) as f32 }\n+        #[cfg(not(target_env = \"msvc\"))]\n+        fn powf(f: f32, n: f32) -> f32 { unsafe { intrinsics::powf32(f, n) } }\n+    }\n \n     /// Takes the square root of a number.\n     ///\n@@ -487,7 +528,13 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn sqrt(self) -> f32 { num::Float::sqrt(self) }\n+    pub fn sqrt(self) -> f32 {\n+        if self < 0.0 {\n+            NAN\n+        } else {\n+            unsafe { intrinsics::sqrtf32(self) }\n+        }\n+    }\n \n     /// Returns `e^(self)`, (the exponential function).\n     ///\n@@ -505,7 +552,15 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn exp(self) -> f32 { num::Float::exp(self) }\n+    pub fn exp(self) -> f32 {\n+        return expf(self);\n+\n+        // see notes above in `floor`\n+        #[cfg(target_env = \"msvc\")]\n+        fn expf(f: f32) -> f32 { (f as f64).exp() as f32 }\n+        #[cfg(not(target_env = \"msvc\"))]\n+        fn expf(f: f32) -> f32 { unsafe { intrinsics::expf32(f) } }\n+    }\n \n     /// Returns `2^(self)`.\n     ///\n@@ -521,7 +576,9 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn exp2(self) -> f32 { num::Float::exp2(self) }\n+    pub fn exp2(self) -> f32 {\n+        unsafe { intrinsics::exp2f32(self) }\n+    }\n \n     /// Returns the natural logarithm of the number.\n     ///\n@@ -539,7 +596,15 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn ln(self) -> f32 { num::Float::ln(self) }\n+    pub fn ln(self) -> f32 {\n+        return logf(self);\n+\n+        // see notes above in `floor`\n+        #[cfg(target_env = \"msvc\")]\n+        fn logf(f: f32) -> f32 { (f as f64).ln() as f32 }\n+        #[cfg(not(target_env = \"msvc\"))]\n+        fn logf(f: f32) -> f32 { unsafe { intrinsics::logf32(f) } }\n+    }\n \n     /// Returns the logarithm of the number with respect to an arbitrary base.\n     ///\n@@ -560,7 +625,7 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn log(self, base: f32) -> f32 { num::Float::log(self, base) }\n+    pub fn log(self, base: f32) -> f32 { self.ln() / base.ln() }\n \n     /// Returns the base 2 logarithm of the number.\n     ///\n@@ -576,7 +641,9 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn log2(self) -> f32 { num::Float::log2(self) }\n+    pub fn log2(self) -> f32 {\n+        unsafe { intrinsics::log2f32(self) }\n+    }\n \n     /// Returns the base 10 logarithm of the number.\n     ///\n@@ -592,7 +659,15 @@ impl f32 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn log10(self) -> f32 { num::Float::log10(self) }\n+    pub fn log10(self) -> f32 {\n+        return log10f(self);\n+\n+        // see notes above in `floor`\n+        #[cfg(target_env = \"msvc\")]\n+        fn log10f(f: f32) -> f32 { (f as f64).log10() as f32 }\n+        #[cfg(not(target_env = \"msvc\"))]\n+        fn log10f(f: f32) -> f32 { unsafe { intrinsics::log10f32(f) } }\n+    }\n \n     /// Converts radians to degrees.\n     ///"}, {"sha": "e94831390565eaef84466f01bb7119156abb52db", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 40, "deletions": 16, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/1ddee8070d3cb83609b1f71c29e3deda3d30fd51/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ddee8070d3cb83609b1f71c29e3deda3d30fd51/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=1ddee8070d3cb83609b1f71c29e3deda3d30fd51", "patch": "@@ -45,12 +45,12 @@ mod cmath {\n         pub fn fmax(a: c_double, b: c_double) -> c_double;\n         pub fn fmin(a: c_double, b: c_double) -> c_double;\n         pub fn fmod(a: c_double, b: c_double) -> c_double;\n-        pub fn nextafter(x: c_double, y: c_double) -> c_double;\n         pub fn frexp(n: c_double, value: &mut c_int) -> c_double;\n+        pub fn ilogb(n: c_double) -> c_int;\n         pub fn ldexp(x: c_double, n: c_int) -> c_double;\n         pub fn logb(n: c_double) -> c_double;\n         pub fn log1p(n: c_double) -> c_double;\n-        pub fn ilogb(n: c_double) -> c_int;\n+        pub fn nextafter(x: c_double, y: c_double) -> c_double;\n         pub fn modf(n: c_double, iptr: &mut c_double) -> c_double;\n         pub fn sinh(n: c_double) -> c_double;\n         pub fn tan(n: c_double) -> c_double;\n@@ -220,7 +220,9 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn floor(self) -> f64 { num::Float::floor(self) }\n+    pub fn floor(self) -> f64 {\n+        unsafe { intrinsics::floorf64(self) }\n+    }\n \n     /// Returns the smallest integer greater than or equal to a number.\n     ///\n@@ -233,7 +235,9 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn ceil(self) -> f64 { num::Float::ceil(self) }\n+    pub fn ceil(self) -> f64 {\n+        unsafe { intrinsics::ceilf64(self) }\n+    }\n \n     /// Returns the nearest integer to a number. Round half-way cases away from\n     /// `0.0`.\n@@ -247,7 +251,9 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn round(self) -> f64 { num::Float::round(self) }\n+    pub fn round(self) -> f64 {\n+        unsafe { intrinsics::roundf64(self) }\n+    }\n \n     /// Returns the integer part of a number.\n     ///\n@@ -260,7 +266,9 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn trunc(self) -> f64 { num::Float::trunc(self) }\n+    pub fn trunc(self) -> f64 {\n+        unsafe { intrinsics::truncf64(self) }\n+    }\n \n     /// Returns the fractional part of a number.\n     ///\n@@ -275,7 +283,7 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn fract(self) -> f64 { num::Float::fract(self) }\n+    pub fn fract(self) -> f64 { self - self.trunc() }\n \n     /// Computes the absolute value of `self`. Returns `NAN` if the\n     /// number is `NAN`.\n@@ -384,7 +392,9 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn mul_add(self, a: f64, b: f64) -> f64 { num::Float::mul_add(self, a, b) }\n+    pub fn mul_add(self, a: f64, b: f64) -> f64 {\n+        unsafe { intrinsics::fmaf64(self, a, b) }\n+    }\n \n     /// Takes the reciprocal (inverse) of a number, `1/x`.\n     ///\n@@ -422,7 +432,9 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn powf(self, n: f64) -> f64 { num::Float::powf(self, n) }\n+    pub fn powf(self, n: f64) -> f64 {\n+        unsafe { intrinsics::powf64(self, n) }\n+    }\n \n     /// Takes the square root of a number.\n     ///\n@@ -439,7 +451,9 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn sqrt(self) -> f64 { num::Float::sqrt(self) }\n+    pub fn sqrt(self) -> f64 {\n+        unsafe { intrinsics::sqrtf64(self) }\n+    }\n \n     /// Returns `e^(self)`, (the exponential function).\n     ///\n@@ -455,7 +469,9 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn exp(self) -> f64 { num::Float::exp(self) }\n+    pub fn exp(self) -> f64 {\n+        unsafe { intrinsics::expf64(self) }\n+    }\n \n     /// Returns `2^(self)`.\n     ///\n@@ -469,7 +485,9 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn exp2(self) -> f64 { num::Float::exp2(self) }\n+    pub fn exp2(self) -> f64 {\n+        unsafe { intrinsics::exp2f64(self) }\n+    }\n \n     /// Returns the natural logarithm of the number.\n     ///\n@@ -485,7 +503,9 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn ln(self) -> f64 { num::Float::ln(self) }\n+    pub fn ln(self) -> f64 {\n+        unsafe { intrinsics::logf64(self) }\n+    }\n \n     /// Returns the logarithm of the number with respect to an arbitrary base.\n     ///\n@@ -504,7 +524,7 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn log(self, base: f64) -> f64 { num::Float::log(self, base) }\n+    pub fn log(self, base: f64) -> f64 { self.ln() / base.ln() }\n \n     /// Returns the base 2 logarithm of the number.\n     ///\n@@ -518,7 +538,9 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn log2(self) -> f64 { num::Float::log2(self) }\n+    pub fn log2(self) -> f64 {\n+        unsafe { intrinsics::log2f64(self) }\n+    }\n \n     /// Returns the base 10 logarithm of the number.\n     ///\n@@ -532,7 +554,9 @@ impl f64 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn log10(self) -> f64 { num::Float::log10(self) }\n+    pub fn log10(self) -> f64 {\n+        unsafe { intrinsics::log10f64(self) }\n+    }\n \n     /// Converts radians to degrees.\n     ///"}]}