{"sha": "e4136bd552bc7bf2b83ceb5d114f9a254bfa2b01", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0MTM2YmQ1NTJiYzdiZjJiODNjZWI1ZDExNGY5YTI1NGJmYTJiMDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-27T17:57:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-27T17:57:05Z"}, "message": "auto merge of #10662 : alexcrichton/rust/thread-detach, r=pcwalton\n\nThis has one commit from a separate pull request (because these commits depend on that one), but otherwise the extra details can be found in the commit messages. The `rt::thread` module has been generally cleaned up for everyday safe usage (and it's a bug if it's not safe).", "tree": {"sha": "3b5accbf93dabd0921e46e326918a1c0e5bef263", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b5accbf93dabd0921e46e326918a1c0e5bef263"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4136bd552bc7bf2b83ceb5d114f9a254bfa2b01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4136bd552bc7bf2b83ceb5d114f9a254bfa2b01", "html_url": "https://github.com/rust-lang/rust/commit/e4136bd552bc7bf2b83ceb5d114f9a254bfa2b01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4136bd552bc7bf2b83ceb5d114f9a254bfa2b01/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6fc577ab580d09f05bb9b545b6a6511cfcb0a8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6fc577ab580d09f05bb9b545b6a6511cfcb0a8f", "html_url": "https://github.com/rust-lang/rust/commit/a6fc577ab580d09f05bb9b545b6a6511cfcb0a8f"}, {"sha": "5d6dbf3f262fabcb6cb920dd08be6f9d8df75d5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d6dbf3f262fabcb6cb920dd08be6f9d8df75d5c", "html_url": "https://github.com/rust-lang/rust/commit/5d6dbf3f262fabcb6cb920dd08be6f9d8df75d5c"}], "stats": {"total": 283, "additions": 208, "deletions": 75}, "files": [{"sha": "7b27161ab5d7c9fd7954ee3d2d604fd13ef05f05", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e4136bd552bc7bf2b83ceb5d114f9a254bfa2b01/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4136bd552bc7bf2b83ceb5d114f9a254bfa2b01/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=e4136bd552bc7bf2b83ceb5d114f9a254bfa2b01", "patch": "@@ -32,8 +32,8 @@ pub unsafe fn init(argc: int, argv: **u8) { imp::init(argc, argv) }\n pub unsafe fn init(argc: int, argv: **u8) { realargs::init(argc, argv) }\n \n /// One-time global cleanup.\n-#[cfg(not(test))] pub fn cleanup() { imp::cleanup() }\n-#[cfg(test)]      pub fn cleanup() { realargs::cleanup() }\n+#[cfg(not(test))] pub unsafe fn cleanup() { imp::cleanup() }\n+#[cfg(test)]      pub unsafe fn cleanup() { realargs::cleanup() }\n \n /// Take the global arguments from global storage.\n #[cfg(not(test))] pub fn take() -> Option<~[~str]> { imp::take() }\n@@ -74,14 +74,16 @@ mod imp {\n     use vec;\n \n     static mut global_args_ptr: uint = 0;\n+    static mut lock: Mutex = MUTEX_INIT;\n \n     pub unsafe fn init(argc: int, argv: **u8) {\n         let args = load_argc_and_argv(argc, argv);\n         put(args);\n     }\n \n-    pub fn cleanup() {\n+    pub unsafe fn cleanup() {\n         rtassert!(take().is_some());\n+        lock.destroy();\n     }\n \n     pub fn take() -> Option<~[~str]> {\n@@ -108,7 +110,6 @@ mod imp {\n     }\n \n     fn with_lock<T>(f: || -> T) -> T {\n-        static mut lock: Mutex = MUTEX_INIT;\n         (|| {\n             unsafe {\n                 lock.lock();"}, {"sha": "6355de36d43bb5d857dd9cb25b43ded57379ccce", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e4136bd552bc7bf2b83ceb5d114f9a254bfa2b01/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4136bd552bc7bf2b83ceb5d114f9a254bfa2b01/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=e4136bd552bc7bf2b83ceb5d114f9a254bfa2b01", "patch": "@@ -41,27 +41,49 @@ pub static mut RT_TLS_PTR: *mut c_void = 0 as *mut c_void;\n #[cfg(stage0)]\n #[cfg(windows)]\n static mut RT_TLS_KEY: tls::Key = -1;\n+#[cfg(stage0)]\n+#[cfg(windows)]\n+static mut tls_lock: Mutex = MUTEX_INIT;\n+static mut tls_initialized: bool = false;\n \n /// Initialize the TLS key. Other ops will fail if this isn't executed first.\n #[inline(never)]\n #[cfg(stage0)]\n #[cfg(windows)]\n pub fn init_tls_key() {\n-    static mut lock: Mutex = MUTEX_INIT;\n-    static mut initialized: bool = false;\n-\n     unsafe {\n-        lock.lock();\n-        if !initialized {\n+        tls_lock.lock();\n+        if !tls_initialized {\n             tls::create(&mut RT_TLS_KEY);\n-            initialized = true;\n+            tls_initialized = true;\n         }\n-        lock.unlock();\n+        tls_lock.unlock();\n     }\n }\n \n #[cfg(not(stage0), not(windows))]\n-pub fn init_tls_key() {}\n+pub fn init_tls_key() {\n+    unsafe {\n+        tls_initialized = true;\n+    }\n+}\n+\n+#[cfg(windows)]\n+pub unsafe fn cleanup() {\n+    // No real use to acquiring a lock around these operations. All we're\n+    // going to do is destroy the lock anyway which races locking itself. This\n+    // is why the whole function is labeled as 'unsafe'\n+    assert!(tls_initialized);\n+    tls::destroy(RT_TLS_KEY);\n+    tls_lock.destroy();\n+    tls_initialized = false;\n+}\n+\n+#[cfg(not(windows))]\n+pub unsafe fn cleanup() {\n+    assert!(tls_initialized);\n+    tls_initialized = false;\n+}\n \n /// Give a pointer to thread-local storage.\n ///"}, {"sha": "79b7dbf2aabf4f42fe47b51f4c9bc15672b4d553", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e4136bd552bc7bf2b83ceb5d114f9a254bfa2b01/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4136bd552bc7bf2b83ceb5d114f9a254bfa2b01/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=e4136bd552bc7bf2b83ceb5d114f9a254bfa2b01", "patch": "@@ -215,7 +215,8 @@ pub fn start(argc: int, argv: **u8, main: proc()) -> int {\n \n     init(argc, argv);\n     let exit_code = run(main);\n-    cleanup();\n+    // unsafe is ok b/c we're sure that the runtime is gone\n+    unsafe { cleanup(); }\n \n     return exit_code;\n }\n@@ -228,7 +229,8 @@ pub fn start(argc: int, argv: **u8, main: proc()) -> int {\n pub fn start_on_main_thread(argc: int, argv: **u8, main: proc()) -> int {\n     init(argc, argv);\n     let exit_code = run_on_main_thread(main);\n-    cleanup();\n+    // unsafe is ok b/c we're sure that the runtime is gone\n+    unsafe { cleanup(); }\n \n     return exit_code;\n }\n@@ -249,8 +251,17 @@ pub fn init(argc: int, argv: **u8) {\n }\n \n /// One-time runtime cleanup.\n-pub fn cleanup() {\n+///\n+/// This function is unsafe because it performs no checks to ensure that the\n+/// runtime has completely ceased running. It is the responsibility of the\n+/// caller to ensure that the runtime is entirely shut down and nothing will be\n+/// poking around at the internal components.\n+///\n+/// Invoking cleanup while portions of the runtime are still in use may cause\n+/// undefined behavior.\n+pub unsafe fn cleanup() {\n     args::cleanup();\n+    local_ptr::cleanup();\n }\n \n /// Execute the main function in a scheduler."}, {"sha": "943b76dd1a0ecd992bef605e8144f9fdd5517668", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4136bd552bc7bf2b83ceb5d114f9a254bfa2b01/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4136bd552bc7bf2b83ceb5d114f9a254bfa2b01/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=e4136bd552bc7bf2b83ceb5d114f9a254bfa2b01", "patch": "@@ -336,7 +336,7 @@ pub fn spawntask_try(f: proc()) -> Result<(),()> {\n }\n \n /// Spawn a new task in a new scheduler and return a thread handle.\n-pub fn spawntask_thread(f: proc()) -> Thread {\n+pub fn spawntask_thread(f: proc()) -> Thread<()> {\n \n     let f = Cell::new(f);\n "}, {"sha": "9031147f8b139a6a128afdb41849113b511d3bf8", "filename": "src/libstd/rt/thread.rs", "status": "modified", "additions": 145, "deletions": 58, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/e4136bd552bc7bf2b83ceb5d114f9a254bfa2b01/src%2Flibstd%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4136bd552bc7bf2b83ceb5d114f9a254bfa2b01/src%2Flibstd%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread.rs?ref=e4136bd552bc7bf2b83ceb5d114f9a254bfa2b01", "patch": "@@ -8,126 +8,213 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Native os-thread management\n+//!\n+//! This modules contains bindings necessary for managing OS-level threads.\n+//! These functions operate outside of the rust runtime, creating threads\n+//! which are not used for scheduling in any way.\n+\n #[allow(non_camel_case_types)];\n \n use cast;\n+use kinds::Send;\n use libc;\n use ops::Drop;\n-use uint;\n+use option::{Option, Some, None};\n use ptr;\n+use uint;\n \n #[cfg(windows)]\n use libc::types::os::arch::extra::{LPSECURITY_ATTRIBUTES, SIZE_T,\n                                    LPVOID, DWORD, LPDWORD, HANDLE};\n \n #[cfg(windows)] type rust_thread = HANDLE;\n #[cfg(unix)] type rust_thread = libc::pthread_t;\n+#[cfg(windows)] type rust_thread_return = DWORD;\n+#[cfg(unix)] type rust_thread_return = *libc::c_void;\n \n-pub struct Thread {\n+type StartFn = extern \"C\" fn(*libc::c_void) -> rust_thread_return;\n+\n+/// This struct represents a native thread's state. This is used to join on an\n+/// existing thread created in the join-able state.\n+pub struct Thread<T> {\n     priv native: rust_thread,\n-    priv joined: bool\n+    priv joined: bool,\n+    priv packet: ~Option<T>,\n }\n \n static DEFAULT_STACK_SIZE: libc::size_t = 1024*1024;\n \n-#[cfg(windows)] type rust_thread_return = DWORD;\n-#[cfg(unix)] type rust_thread_return = *libc::c_void;\n+// This is the starting point of rust os threads. The first thing we do\n+// is make sure that we don't trigger __morestack (also why this has a\n+// no_split_stack annotation), and then we extract the main function\n+// and invoke it.\n+#[no_split_stack]\n+extern fn thread_start(main: *libc::c_void) -> rust_thread_return {\n+    use rt::context;\n+    unsafe {\n+        context::record_stack_bounds(0, uint::max_value);\n+        let f: ~proc() = cast::transmute(main);\n+        (*f)();\n+        cast::transmute(0 as rust_thread_return)\n+    }\n+}\n \n-impl Thread {\n-\n-    pub fn start(main: proc()) -> Thread {\n-        // This is the starting point of rust os threads. The first thing we do\n-        // is make sure that we don't trigger __morestack (also why this has a\n-        // no_split_stack annotation), and then we extract the main function\n-        // and invoke it.\n-        #[no_split_stack]\n-        extern \"C\" fn thread_start(trampoline: *libc::c_void) -> rust_thread_return {\n-            use rt::context;\n-            unsafe {\n-                context::record_stack_bounds(0, uint::max_value);\n-                let f: ~proc() = cast::transmute(trampoline);\n-                (*f)();\n-            }\n-            unsafe { cast::transmute(0 as rust_thread_return) }\n-        }\n+// There are two impl blocks b/c if T were specified at the top then it's just a\n+// pain to specify a type parameter on Thread::spawn (which doesn't need the\n+// type parameter).\n+impl Thread<()> {\n+\n+    /// Starts execution of a new OS thread.\n+    ///\n+    /// This function will not wait for the thread to join, but a handle to the\n+    /// thread will be returned.\n+    ///\n+    /// Note that the handle returned is used to acquire the return value of the\n+    /// procedure `main`. The `join` function will wait for the thread to finish\n+    /// and return the value that `main` generated.\n+    ///\n+    /// Also note that the `Thread` returned will *always* wait for the thread\n+    /// to finish executing. This means that even if `join` is not explicitly\n+    /// called, when the `Thread` falls out of scope its destructor will block\n+    /// waiting for the OS thread.\n+    pub fn start<T: Send>(main: proc() -> T) -> Thread<T> {\n+\n+        // We need the address of the packet to fill in to be stable so when\n+        // `main` fills it in it's still valid, so allocate an extra ~ box to do\n+        // so.\n+        let packet = ~None;\n+        let packet2: *mut Option<T> = unsafe {\n+            *cast::transmute::<&~Option<T>, **mut Option<T>>(&packet)\n+        };\n+        let main: proc() = proc() unsafe { *packet2 = Some(main()); };\n+        let native = unsafe { native_thread_create(~main) };\n \n-        let native = native_thread_create(thread_start, ~main);\n         Thread {\n             native: native,\n             joined: false,\n+            packet: packet,\n         }\n     }\n \n-    pub fn join(mut self) {\n+    /// This will spawn a new thread, but it will not wait for the thread to\n+    /// finish, nor is it possible to wait for the thread to finish.\n+    ///\n+    /// This corresponds to creating threads in the 'detached' state on unix\n+    /// systems. Note that platforms may not keep the main program alive even if\n+    /// there are detached thread still running around.\n+    pub fn spawn(main: proc()) {\n+        unsafe {\n+            let handle = native_thread_create(~main);\n+            native_thread_detach(handle);\n+        }\n+    }\n+}\n+\n+impl<T: Send> Thread<T> {\n+    /// Wait for this thread to finish, returning the result of the thread's\n+    /// calculation.\n+    pub fn join(mut self) -> T {\n         assert!(!self.joined);\n-        native_thread_join(self.native);\n+        unsafe { native_thread_join(self.native) };\n         self.joined = true;\n+        assert!(self.packet.is_some());\n+        self.packet.take_unwrap()\n     }\n }\n \n-#[cfg(windows)]\n-fn native_thread_create(thread_start: extern \"C\" fn(*libc::c_void) -> rust_thread_return,\n-                        tramp: ~proc()) -> rust_thread {\n-    unsafe {\n-        let ptr: *mut libc::c_void = cast::transmute(tramp);\n-        CreateThread(ptr::mut_null(), DEFAULT_STACK_SIZE, thread_start, ptr, 0, ptr::mut_null())\n+#[unsafe_destructor]\n+impl<T: Send> Drop for Thread<T> {\n+    fn drop(&mut self) {\n+        // This is required for correctness. If this is not done then the thread\n+        // would fill in a return box which no longer exists.\n+        if !self.joined {\n+            unsafe { native_thread_join(self.native) };\n+        }\n     }\n }\n \n #[cfg(windows)]\n-fn native_thread_join(native: rust_thread) {\n+unsafe fn native_thread_create(p: ~proc()) -> rust_thread {\n+    let arg: *mut libc::c_void = cast::transmute(p);\n+    CreateThread(ptr::mut_null(), DEFAULT_STACK_SIZE, thread_start,\n+                 arg, 0, ptr::mut_null())\n+}\n+\n+#[cfg(windows)]\n+unsafe fn native_thread_join(native: rust_thread) {\n     use libc::consts::os::extra::INFINITE;\n-    unsafe { WaitForSingleObject(native, INFINITE); }\n+    WaitForSingleObject(native, INFINITE);\n+}\n+\n+#[cfg(windows)]\n+unsafe fn native_thread_detach(native: rust_thread) {\n+    assert!(libc::CloseHandle(native) != 0);\n }\n \n #[cfg(unix)]\n-fn native_thread_create(thread_start: extern \"C\" fn(*libc::c_void) -> rust_thread_return,\n-                        tramp: ~proc()) -> rust_thread {\n+unsafe fn native_thread_create(p: ~proc()) -> rust_thread {\n     use unstable::intrinsics;\n-    let mut native: libc::pthread_t = unsafe { intrinsics::uninit() };\n-\n-    unsafe {\n-        use libc::consts::os::posix01::PTHREAD_CREATE_JOINABLE;\n+    use libc::consts::os::posix01::PTHREAD_CREATE_JOINABLE;\n \n-        let mut attr: libc::pthread_attr_t = intrinsics::uninit();\n-        assert!(pthread_attr_init(&mut attr) == 0);\n-        assert!(pthread_attr_setstacksize(&mut attr, DEFAULT_STACK_SIZE) == 0);\n-        assert!(pthread_attr_setdetachstate(&mut attr, PTHREAD_CREATE_JOINABLE) == 0);\n+    let mut native: libc::pthread_t = intrinsics::uninit();\n+    let mut attr: libc::pthread_attr_t = intrinsics::uninit();\n+    assert_eq!(pthread_attr_init(&mut attr), 0);\n+    assert_eq!(pthread_attr_setstacksize(&mut attr, DEFAULT_STACK_SIZE), 0);\n+    assert_eq!(pthread_attr_setdetachstate(&mut attr, PTHREAD_CREATE_JOINABLE), 0);\n \n-        let ptr: *libc::c_void = cast::transmute(tramp);\n-        assert!(pthread_create(&mut native, &attr, thread_start, ptr) == 0);\n-    }\n+    let arg: *libc::c_void = cast::transmute(p);\n+    assert_eq!(pthread_create(&mut native, &attr, thread_start, arg), 0);\n     native\n }\n \n #[cfg(unix)]\n-fn native_thread_join(native: rust_thread) {\n-    unsafe { assert!(pthread_join(native, ptr::null()) == 0) }\n+unsafe fn native_thread_join(native: rust_thread) {\n+    assert_eq!(pthread_join(native, ptr::null()), 0);\n }\n \n-impl Drop for Thread {\n-    fn drop(&mut self) {\n-        assert!(self.joined);\n-    }\n+#[cfg(unix)]\n+fn native_thread_detach(native: rust_thread) {\n+    unsafe { assert_eq!(pthread_detach(native), 0) }\n }\n \n #[cfg(windows)]\n extern \"system\" {\n-    fn CreateThread(lpThreadAttributes: LPSECURITY_ATTRIBUTES, dwStackSize: SIZE_T,\n-                    lpStartAddress: extern \"C\" fn(*libc::c_void) -> rust_thread_return,\n-                    lpParameter: LPVOID, dwCreationFlags: DWORD, lpThreadId: LPDWORD) -> HANDLE;\n+    fn CreateThread(lpThreadAttributes: LPSECURITY_ATTRIBUTES,\n+                    dwStackSize: SIZE_T,\n+                    lpStartAddress: StartFn,\n+                    lpParameter: LPVOID,\n+                    dwCreationFlags: DWORD,\n+                    lpThreadId: LPDWORD) -> HANDLE;\n     fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;\n }\n \n #[cfg(unix)]\n extern {\n-    fn pthread_create(native: *mut libc::pthread_t, attr: *libc::pthread_attr_t,\n-                      f: extern \"C\" fn(*libc::c_void) -> rust_thread_return,\n+    fn pthread_create(native: *mut libc::pthread_t,\n+                      attr: *libc::pthread_attr_t,\n+                      f: StartFn,\n                       value: *libc::c_void) -> libc::c_int;\n-    fn pthread_join(native: libc::pthread_t, value: **libc::c_void) -> libc::c_int;\n+    fn pthread_join(native: libc::pthread_t,\n+                    value: **libc::c_void) -> libc::c_int;\n     fn pthread_attr_init(attr: *mut libc::pthread_attr_t) -> libc::c_int;\n     fn pthread_attr_setstacksize(attr: *mut libc::pthread_attr_t,\n                                  stack_size: libc::size_t) -> libc::c_int;\n     fn pthread_attr_setdetachstate(attr: *mut libc::pthread_attr_t,\n                                    state: libc::c_int) -> libc::c_int;\n+    fn pthread_detach(thread: libc::pthread_t) -> libc::c_int;\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::Thread;\n+\n+    #[test]\n+    fn smoke() { do Thread::start {}.join(); }\n+\n+    #[test]\n+    fn data() { assert_eq!(do Thread::start { 1 }.join(), 1); }\n+\n+    #[test]\n+    fn detached() { do Thread::spawn {} }\n }"}, {"sha": "62e1b6c50d65f82ec73004513396e3f2520dbc62", "filename": "src/libstd/rt/thread_local_storage.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e4136bd552bc7bf2b83ceb5d114f9a254bfa2b01/src%2Flibstd%2Frt%2Fthread_local_storage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4136bd552bc7bf2b83ceb5d114f9a254bfa2b01/src%2Flibstd%2Frt%2Fthread_local_storage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread_local_storage.rs?ref=e4136bd552bc7bf2b83ceb5d114f9a254bfa2b01", "patch": "@@ -34,6 +34,11 @@ pub unsafe fn get(key: Key) -> *mut c_void {\n     pthread_getspecific(key)\n }\n \n+#[cfg(unix)]\n+pub unsafe fn destroy(key: Key) {\n+    assert_eq!(0, pthread_key_delete(key));\n+}\n+\n #[cfg(target_os=\"macos\")]\n #[allow(non_camel_case_types)] // foreign type\n type pthread_key_t = ::libc::c_ulong;\n@@ -47,6 +52,7 @@ type pthread_key_t = ::libc::c_uint;\n #[cfg(unix)]\n extern {\n     fn pthread_key_create(key: *mut pthread_key_t, dtor: *u8) -> c_int;\n+    fn pthread_key_delete(key: pthread_key_t) -> c_int;\n     fn pthread_getspecific(key: pthread_key_t) -> *mut c_void;\n     fn pthread_setspecific(key: pthread_key_t, value: *mut c_void) -> c_int;\n }\n@@ -71,9 +77,15 @@ pub unsafe fn get(key: Key) -> *mut c_void {\n     TlsGetValue(key)\n }\n \n+#[cfg(windows)]\n+pub unsafe fn destroy(key: Key) {\n+    assert!(TlsFree(key) != 0);\n+}\n+\n #[cfg(windows)]\n extern \"system\" {\n     fn TlsAlloc() -> DWORD;\n+    fn TlsFree(dwTlsIndex: DWORD) -> BOOL;\n     fn TlsGetValue(dwTlsIndex: DWORD) -> LPVOID;\n     fn TlsSetValue(dwTlsIndex: DWORD, lpTlsvalue: LPVOID) -> BOOL;\n }"}, {"sha": "198fe596a896ee4fc18432bd99d7535ecf6c8233", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4136bd552bc7bf2b83ceb5d114f9a254bfa2b01/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4136bd552bc7bf2b83ceb5d114f9a254bfa2b01/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=e4136bd552bc7bf2b83ceb5d114f9a254bfa2b01", "patch": "@@ -139,7 +139,7 @@ pub fn spawn_raw(mut opts: TaskOpts, f: proc()) {\n             let join_task = do Task::build_child(None) {\n                 debug!(\"running join task\");\n                 let thread_port = thread_port_cell.take();\n-                let thread: Thread = thread_port.recv();\n+                let thread: Thread<()> = thread_port.recv();\n                 thread.join();\n             };\n "}]}