{"sha": "db9a8480c481deb0936508c224dc0514e4fe0e80", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiOWE4NDgwYzQ4MWRlYjA5MzY1MDhjMjI0ZGMwNTE0ZTRmZTBlODA=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-27T02:30:10Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-27T03:08:38Z"}, "message": "Simplify specialize_constructor\n\nAlso removes the ugly caching that was introduced in #76918. It was\nbolted on without deeper knowledge of the workings of the algorithm.\nThis commit manages to be more performant without any of the complexity.\nIt should be better on representative workloads too.", "tree": {"sha": "59cc4d46c802bad69d4aefae60a47e29f4452d51", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59cc4d46c802bad69d4aefae60a47e29f4452d51"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db9a8480c481deb0936508c224dc0514e4fe0e80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db9a8480c481deb0936508c224dc0514e4fe0e80", "html_url": "https://github.com/rust-lang/rust/commit/db9a8480c481deb0936508c224dc0514e4fe0e80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db9a8480c481deb0936508c224dc0514e4fe0e80/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54fa70290d8ab65e33116eb888278f7a64ca6da4", "url": "https://api.github.com/repos/rust-lang/rust/commits/54fa70290d8ab65e33116eb888278f7a64ca6da4", "html_url": "https://github.com/rust-lang/rust/commit/54fa70290d8ab65e33116eb888278f7a64ca6da4"}], "stats": {"total": 188, "additions": 13, "deletions": 175}, "files": [{"sha": "966d3c747f6e13cf7b462c6c14131a34a4bb4086", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 13, "deletions": 175, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/db9a8480c481deb0936508c224dc0514e4fe0e80/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db9a8480c481deb0936508c224dc0514e4fe0e80/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=db9a8480c481deb0936508c224dc0514e4fe0e80", "patch": "@@ -293,7 +293,7 @@ use self::Usefulness::*;\n use self::WitnessPreference::*;\n \n use rustc_data_structures::captures::Captures;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::OnceCell;\n use rustc_index::vec::Idx;\n \n@@ -401,48 +401,17 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n         }\n     }\n \n-    /// This computes `S(constructor, self)`. See top of the file for explanations.\n-    ///\n-    /// This is the main specialization step. It expands the pattern\n-    /// into `arity` patterns based on the constructor. For most patterns, the step is trivial,\n-    /// for instance tuple patterns are flattened and box patterns expand into their inner pattern.\n-    /// Returns `None` if the pattern does not have the given constructor.\n+    /// This computes `S(self.head_ctor(), self)`. See top of the file for explanations.\n     ///\n-    /// OTOH, slice patterns with a subslice pattern (tail @ ..) can be expanded into multiple\n-    /// different patterns.\n     /// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n     /// fields filled with wild patterns.\n     ///\n     /// This is roughly the inverse of `Constructor::apply`.\n-    fn specialize_constructor(\n-        &self,\n-        pcx: PatCtxt<'_, 'p, 'tcx>,\n-        ctor: &Constructor<'tcx>,\n-        ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n-        is_my_head_ctor: bool,\n-    ) -> Option<PatStack<'p, 'tcx>> {\n-        // We return `None` if `ctor` is not covered by `self.head()`. If `ctor` is known to be\n-        // derived from `self.head()`, then we don't need to check; otherwise, we check for\n-        // constructor inclusion.\n-        // Note that this shortcut is also necessary for correctness: a pattern should always be\n-        // specializable with its own constructor, even in cases where we refuse to inspect values like\n-        // opaque constants.\n-        if !is_my_head_ctor && !ctor.is_covered_by(pcx, self.head_ctor(pcx.cx)) {\n-            return None;\n-        }\n-        let new_fields = ctor_wild_subpatterns.replace_with_pattern_arguments(self.head());\n-\n-        debug!(\n-            \"specialize_constructor({:#?}, {:#?}, {:#?}) = {:#?}\",\n-            self.head(),\n-            ctor,\n-            ctor_wild_subpatterns,\n-            new_fields\n-        );\n-\n+    fn pop_head_constructor(&self, ctor_wild_subpatterns: &Fields<'p, 'tcx>) -> PatStack<'p, 'tcx> {\n         // We pop the head pattern and push the new fields extracted from the arguments of\n         // `self.head()`.\n-        Some(new_fields.push_on_patstack(&self.pats[1..]))\n+        let new_fields = ctor_wild_subpatterns.replace_with_pattern_arguments(self.head());\n+        new_fields.push_on_patstack(&self.pats[1..])\n     }\n }\n \n@@ -467,36 +436,15 @@ impl<'p, 'tcx> FromIterator<&'p Pat<'tcx>> for PatStack<'p, 'tcx> {\n     }\n }\n \n-/// Depending on the match patterns, the specialization process might be able to use a fast path.\n-/// Tracks whether we can use the fast path and the lookup table needed in those cases.\n-#[derive(Clone, Debug, PartialEq)]\n-enum SpecializationCache {\n-    /// Patterns consist of only enum variants.\n-    /// Variant patterns does not intersect with each other (in contrast to range patterns),\n-    /// so it is possible to precompute the result of `Matrix::specialize_constructor` at a\n-    /// lower computational complexity.\n-    /// `lookup` is responsible for holding the precomputed result of\n-    /// specialization, while `wilds` is used for two purposes: the first one is\n-    /// the precomputed result of specialization with a wildcard, and the second is to be used as a\n-    /// fallback for `Matrix::specialize_constructor` when it tries to apply a constructor that\n-    /// has not been seen in the `Matrix`. See `update_cache` for further explanations.\n-    Variants { lookup: FxHashMap<DefId, SmallVec<[usize; 1]>>, wilds: SmallVec<[usize; 1]> },\n-    /// Does not belong to the cases above, use the slow path.\n-    Incompatible,\n-}\n-\n /// A 2D matrix.\n #[derive(Clone, PartialEq)]\n crate struct Matrix<'p, 'tcx> {\n     patterns: Vec<PatStack<'p, 'tcx>>,\n-    cache: SpecializationCache,\n }\n \n impl<'p, 'tcx> Matrix<'p, 'tcx> {\n     crate fn empty() -> Self {\n-        // Use `SpecializationCache::Incompatible` as a placeholder; we will initialize it on the\n-        // first call to `push`. See the first half of `update_cache`.\n-        Matrix { patterns: vec![], cache: SpecializationCache::Incompatible }\n+        Matrix { patterns: vec![] }\n     }\n \n     /// Pushes a new row to the matrix. If the row starts with an or-pattern, this expands it.\n@@ -509,70 +457,6 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n             }\n         } else {\n             self.patterns.push(row);\n-            self.update_cache(self.patterns.len() - 1);\n-        }\n-    }\n-\n-    fn update_cache(&mut self, idx: usize) {\n-        let row = &self.patterns[idx];\n-        // We don't know which kind of cache could be used until we see the first row; therefore an\n-        // empty `Matrix` is initialized with `SpecializationCache::Empty`, then the cache is\n-        // assigned the appropriate variant below on the first call to `push`.\n-        if self.patterns.is_empty() {\n-            self.cache = if row.is_empty() {\n-                SpecializationCache::Incompatible\n-            } else {\n-                match *row.head().kind {\n-                    PatKind::Variant { .. } => SpecializationCache::Variants {\n-                        lookup: FxHashMap::default(),\n-                        wilds: SmallVec::new(),\n-                    },\n-                    // Note: If the first pattern is a wildcard, then all patterns after that is not\n-                    // useful. The check is simple enough so we treat it as the same as unsupported\n-                    // patterns.\n-                    _ => SpecializationCache::Incompatible,\n-                }\n-            };\n-        }\n-        // Update the cache.\n-        match &mut self.cache {\n-            SpecializationCache::Variants { ref mut lookup, ref mut wilds } => {\n-                let head = row.head();\n-                match *head.kind {\n-                    _ if head.is_wildcard() => {\n-                        // Per rule 1.3 in the top-level comments, a wildcard pattern is included in\n-                        // the result of `specialize_constructor` for *any* `Constructor`.\n-                        // We push the wildcard pattern to the precomputed result for constructors\n-                        // that we have seen before; results for constructors we have not yet seen\n-                        // defaults to `wilds`, which is updated right below.\n-                        for (_, v) in lookup.iter_mut() {\n-                            v.push(idx);\n-                        }\n-                        // Per rule 2.1 and 2.2 in the top-level comments, only wildcard patterns\n-                        // are included in the result of specialization with a wildcard.\n-                        // What we do here is to track the wildcards we have seen; so in addition to\n-                        // acting as the precomputed result of specialization with a wildcard, `wilds` also\n-                        // serves as the default value of `specialize_constructor` for constructors\n-                        // that are not in `lookup`.\n-                        wilds.push(idx);\n-                    }\n-                    PatKind::Variant { adt_def, variant_index, .. } => {\n-                        // Handle the cases of rule 1.1 and 1.2 in the top-level comments.\n-                        // A variant pattern can only be included in the results of\n-                        // `specialize_constructor` for a particular constructor, therefore we are\n-                        // using a HashMap to track that.\n-                        lookup\n-                            .entry(adt_def.variants[variant_index].def_id)\n-                            // Default to `wilds` for absent keys. See above for an explanation.\n-                            .or_insert_with(|| wilds.clone())\n-                            .push(idx);\n-                    }\n-                    _ => {\n-                        self.cache = SpecializationCache::Incompatible;\n-                    }\n-                }\n-            }\n-            SpecializationCache::Incompatible => {}\n         }\n     }\n \n@@ -593,59 +477,14 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n     fn specialize_constructor(\n         &self,\n         pcx: PatCtxt<'_, 'p, 'tcx>,\n-        constructor: &Constructor<'tcx>,\n+        ctor: &Constructor<'tcx>,\n         ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n     ) -> Matrix<'p, 'tcx> {\n-        match &self.cache {\n-            SpecializationCache::Variants { lookup, wilds } => {\n-                let cached = if let Constructor::Variant(id) = constructor {\n-                    lookup\n-                        .get(id)\n-                        // Default to `wilds` for absent keys. See `update_cache` for an explanation.\n-                        .unwrap_or(&wilds)\n-                } else if let Wildcard = constructor {\n-                    &wilds\n-                } else {\n-                    bug!(\n-                        \"unexpected constructor encountered while dealing with matrix cache: {:?}\",\n-                        constructor\n-                    );\n-                };\n-                let result: Self = cached\n-                    .iter()\n-                    .filter_map(|&i| {\n-                        self.patterns[i].specialize_constructor(\n-                            pcx,\n-                            constructor,\n-                            ctor_wild_subpatterns,\n-                            false,\n-                        )\n-                    })\n-                    .collect();\n-                // When debug assertions are enabled, check the results against the \"slow path\"\n-                // result.\n-                debug_assert_eq!(\n-                    result,\n-                    Matrix {\n-                        patterns: self.patterns.clone(),\n-                        cache: SpecializationCache::Incompatible\n-                    }\n-                    .specialize_constructor(\n-                        pcx,\n-                        constructor,\n-                        ctor_wild_subpatterns\n-                    )\n-                );\n-                result\n-            }\n-            SpecializationCache::Incompatible => self\n-                .patterns\n-                .iter()\n-                .filter_map(|r| {\n-                    r.specialize_constructor(pcx, constructor, ctor_wild_subpatterns, false)\n-                })\n-                .collect(),\n-        }\n+        self.patterns\n+            .iter()\n+            .filter(|r| ctor.is_covered_by(pcx, r.head_ctor(pcx.cx)))\n+            .map(|r| r.pop_head_constructor(ctor_wild_subpatterns))\n+            .collect()\n     }\n }\n \n@@ -2442,8 +2281,7 @@ crate fn is_useful<'p, 'tcx>(\n             // We cache the result of `Fields::wildcards` because it is used a lot.\n             let ctor_wild_subpatterns = Fields::wildcards(pcx, &ctor);\n             let matrix = pcx.matrix.specialize_constructor(pcx, &ctor, &ctor_wild_subpatterns);\n-            // Unwrap is ok: v can always be specialized with its own constructor.\n-            let v = v.specialize_constructor(pcx, &ctor, &ctor_wild_subpatterns, true).unwrap();\n+            let v = v.pop_head_constructor(&ctor_wild_subpatterns);\n             let usefulness =\n                 is_useful(pcx.cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false);\n             usefulness.apply_constructor(pcx, &ctor, &ctor_wild_subpatterns, is_top_level)"}]}