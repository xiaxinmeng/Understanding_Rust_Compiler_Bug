{"sha": "08f6380a9f0b866796080094f44fe25ea5636547", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4ZjYzODBhOWYwYjg2Njc5NjA4MDA5NGY0NGZlMjVlYTU2MzY1NDc=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2015-01-14T05:24:26Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2015-01-16T17:17:37Z"}, "message": "Rewrite Condvar::wait_timeout and make it public\n\n**The implementation is a direct adaptation of libcxx's\ncondition_variable implementation.**\n\npthread_cond_timedwait uses the non-monotonic system clock. It's\npossible to change the clock to a monotonic via pthread_cond_attr, but\nthis is incompatible with static initialization. To deal with this, we\ncalculate the timeout using the system clock, and maintain a separate\nrecord of the start and end times with a monotonic clock to be used for\ncalculation of the return value.", "tree": {"sha": "b07f1154c5095e48f96369ce9d37988e33ae3d71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b07f1154c5095e48f96369ce9d37988e33ae3d71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08f6380a9f0b866796080094f44fe25ea5636547", "comment_count": 12, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08f6380a9f0b866796080094f44fe25ea5636547", "html_url": "https://github.com/rust-lang/rust/commit/08f6380a9f0b866796080094f44fe25ea5636547", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08f6380a9f0b866796080094f44fe25ea5636547/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d5fbae33897a8340542f21b6ded913148ca9199", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d5fbae33897a8340542f21b6ded913148ca9199", "html_url": "https://github.com/rust-lang/rust/commit/3d5fbae33897a8340542f21b6ded913148ca9199"}], "stats": {"total": 440, "additions": 343, "deletions": 97}, "files": [{"sha": "b8b186f31e044089afe0e1fdfdb9d394489e757d", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 113, "deletions": 10, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/08f6380a9f0b866796080094f44fe25ea5636547/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f6380a9f0b866796080094f44fe25ea5636547/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=08f6380a9f0b866796080094f44fe25ea5636547", "patch": "@@ -12,6 +12,7 @@ use prelude::v1::*;\n \n use sync::atomic::{AtomicUsize, Ordering, ATOMIC_USIZE_INIT};\n use sync::poison::{self, LockResult};\n+use sys::time::SteadyTime;\n use sys_common::condvar as sys;\n use sys_common::mutex as sys_mutex;\n use time::Duration;\n@@ -153,20 +154,34 @@ impl Condvar {\n     ///\n     /// Like `wait`, the lock specified will be re-acquired when this function\n     /// returns, regardless of whether the timeout elapsed or not.\n-    // Note that this method is *not* public, and this is quite intentional\n-    // because we're not quite sure about the semantics of relative vs absolute\n-    // durations or how the timing guarantees play into what the system APIs\n-    // provide. There are also additional concerns about the unix-specific\n-    // implementation which may need to be addressed.\n-    #[allow(dead_code)]\n-    fn wait_timeout<'a, T>(&self, guard: MutexGuard<'a, T>, dur: Duration)\n+    #[unstable]\n+    pub fn wait_timeout<'a, T>(&self, guard: MutexGuard<'a, T>, dur: Duration)\n                            -> LockResult<(MutexGuard<'a, T>, bool)> {\n         unsafe {\n             let me: &'static Condvar = &*(self as *const _);\n             me.inner.wait_timeout(guard, dur)\n         }\n     }\n \n+    /// Wait on this condition variable for a notification, timing out after a\n+    /// specified duration.\n+    ///\n+    /// The semantics of this function are equivalent to `wait_timeout` except\n+    /// that the implementation will repeatedly wait while the duration has not\n+    /// passed and the provided function returns `false`.\n+    #[unstable]\n+    pub fn wait_timeout_with<'a, T, F>(&self,\n+                                       guard: MutexGuard<'a, T>,\n+                                       dur: Duration,\n+                                       f: F)\n+                                       -> LockResult<(MutexGuard<'a, T>, bool)>\n+            where F: FnMut(LockResult<&mut T>) -> bool {\n+        unsafe {\n+            let me: &'static Condvar = &*(self as *const _);\n+            me.inner.wait_timeout_with(guard, dur, f)\n+        }\n+    }\n+\n     /// Wake up one blocked thread on this condvar.\n     ///\n     /// If there is a blocked thread on this condition variable, then it will\n@@ -220,9 +235,9 @@ impl StaticCondvar {\n     /// specified duration.\n     ///\n     /// See `Condvar::wait_timeout`.\n-    #[allow(dead_code)] // may want to stabilize this later, see wait_timeout above\n-    fn wait_timeout<'a, T>(&'static self, guard: MutexGuard<'a, T>, dur: Duration)\n-                           -> LockResult<(MutexGuard<'a, T>, bool)> {\n+    #[unstable = \"may be merged with Condvar in the future\"]\n+    pub fn wait_timeout<'a, T>(&'static self, guard: MutexGuard<'a, T>, dur: Duration)\n+                               -> LockResult<(MutexGuard<'a, T>, bool)> {\n         let (poisoned, success) = unsafe {\n             let lock = mutex::guard_lock(&guard);\n             self.verify(lock);\n@@ -236,6 +251,50 @@ impl StaticCondvar {\n         }\n     }\n \n+    /// Wait on this condition variable for a notification, timing out after a\n+    /// specified duration.\n+    ///\n+    /// The implementation will repeatedly wait while the duration has not\n+    /// passed and the function returns `false`.\n+    ///\n+    /// See `Condvar::wait_timeout_with`.\n+    #[unstable = \"may be merged with Condvar in the future\"]\n+    pub fn wait_timeout_with<'a, T, F>(&'static self,\n+                                       guard: MutexGuard<'a, T>,\n+                                       dur: Duration,\n+                                       mut f: F)\n+                                       -> LockResult<(MutexGuard<'a, T>, bool)>\n+            where F: FnMut(LockResult<&mut T>) -> bool {\n+        // This could be made more efficient by pushing the implementation into sys::condvar\n+        let start = SteadyTime::now();\n+        let mut guard_result: LockResult<MutexGuard<'a, T>> = Ok(guard);\n+        while !f(guard_result\n+                    .as_mut()\n+                    .map(|g| &mut **g)\n+                    .map_err(|e| poison::new_poison_error(&mut **e.get_mut()))) {\n+            let now = SteadyTime::now();\n+            let consumed = &now - &start;\n+            let guard = guard_result.unwrap_or_else(|e| e.into_inner());\n+            let (new_guard_result, no_timeout) = match self.wait_timeout(guard, dur - consumed) {\n+                Ok((new_guard, no_timeout)) => (Ok(new_guard), no_timeout),\n+                Err(err) => {\n+                    let (new_guard, no_timeout) = err.into_inner();\n+                    (Err(poison::new_poison_error(new_guard)), no_timeout)\n+                }\n+            };\n+            guard_result = new_guard_result;\n+            if !no_timeout {\n+                let result = f(guard_result\n+                                    .as_mut()\n+                                    .map(|g| &mut **g)\n+                                    .map_err(|e| poison::new_poison_error(&mut **e.get_mut())));\n+                return poison::map_result(guard_result, |g| (g, result));\n+            }\n+        }\n+\n+        poison::map_result(guard_result, |g| (g, true))\n+    }\n+\n     /// Wake up one blocked thread on this condvar.\n     ///\n     /// See `Condvar::notify_one`.\n@@ -285,6 +344,7 @@ mod tests {\n     use super::{StaticCondvar, CONDVAR_INIT};\n     use sync::mpsc::channel;\n     use sync::{StaticMutex, MUTEX_INIT, Condvar, Mutex, Arc};\n+    use sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n     use thread::Thread;\n     use time::Duration;\n \n@@ -372,6 +432,49 @@ mod tests {\n         unsafe { C.destroy(); M.destroy(); }\n     }\n \n+    #[test]\n+    fn wait_timeout_with() {\n+        static C: StaticCondvar = CONDVAR_INIT;\n+        static M: StaticMutex = MUTEX_INIT;\n+        static S: AtomicUsize = ATOMIC_USIZE_INIT;\n+\n+        let g = M.lock().unwrap();\n+        let (g, success) = C.wait_timeout_with(g, Duration::nanoseconds(1000), |_| false).unwrap();\n+        assert!(!success);\n+\n+        let (tx, rx) = channel();\n+        let _t = Thread::scoped(move || {\n+            rx.recv().unwrap();\n+            let g = M.lock().unwrap();\n+            S.store(1, Ordering::SeqCst);\n+            C.notify_one();\n+            drop(g);\n+\n+            rx.recv().unwrap();\n+            let g = M.lock().unwrap();\n+            S.store(2, Ordering::SeqCst);\n+            C.notify_one();\n+            drop(g);\n+\n+            rx.recv().unwrap();\n+            let _g = M.lock().unwrap();\n+            S.store(3, Ordering::SeqCst);\n+            C.notify_one();\n+        });\n+\n+        let mut state = 0;\n+        let (_g, success) = C.wait_timeout_with(g, Duration::days(1), |_| {\n+            assert_eq!(state, S.load(Ordering::SeqCst));\n+            tx.send(()).unwrap();\n+            state += 1;\n+            match state {\n+                1|2 => false,\n+                _ => true,\n+            }\n+        }).unwrap();\n+        assert!(success);\n+    }\n+\n     #[test]\n     #[should_fail]\n     fn two_mutexes() {"}, {"sha": "cc8c331ef3997c3d2e34467de445907f3050d068", "filename": "src/libstd/sync/poison.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/08f6380a9f0b866796080094f44fe25ea5636547/src%2Flibstd%2Fsync%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f6380a9f0b866796080094f44fe25ea5636547/src%2Flibstd%2Fsync%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fpoison.rs?ref=08f6380a9f0b866796080094f44fe25ea5636547", "patch": "@@ -99,8 +99,23 @@ impl<T> fmt::Show for PoisonError<T> {\n impl<T> PoisonError<T> {\n     /// Consumes this error indicating that a lock is poisoned, returning the\n     /// underlying guard to allow access regardless.\n-    #[stable]\n+    #[deprecated=\"renamed to into_inner\"]\n     pub fn into_guard(self) -> T { self.guard }\n+\n+    /// Consumes this error indicating that a lock is poisoned, returning the\n+    /// underlying guard to allow access regardless.\n+    #[unstable]\n+    pub fn into_inner(self) -> T { self.guard }\n+\n+    /// Reaches into this error indicating that a lock is poisoned, returning a\n+    /// reference to the underlying guard to allow access regardless.\n+    #[unstable]\n+    pub fn get_ref(&self) -> &T { &self.guard }\n+\n+    /// Reaches into this error indicating that a lock is poisoned, returning a\n+    /// mutable reference to the underlying guard to allow access regardless.\n+    #[unstable]\n+    pub fn get_mut(&mut self) -> &mut T { &mut self.guard }\n }\n \n impl<T> FromError<PoisonError<T>> for TryLockError<T> {"}, {"sha": "85a65bbef508d541b92ef25d9d01a7a5e586c649", "filename": "src/libstd/sys/unix/condvar.rs", "status": "modified", "additions": 36, "deletions": 20, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/08f6380a9f0b866796080094f44fe25ea5636547/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f6380a9f0b866796080094f44fe25ea5636547/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs?ref=08f6380a9f0b866796080094f44fe25ea5636547", "patch": "@@ -10,9 +10,12 @@\n \n use cell::UnsafeCell;\n use libc;\n+use std::option::Option::{Some, None};\n use sys::mutex::{self, Mutex};\n+use sys::time;\n use sys::sync as ffi;\n use time::Duration;\n+use num::{Int, NumCast};\n \n pub struct Condvar { inner: UnsafeCell<ffi::pthread_cond_t> }\n \n@@ -46,33 +49,46 @@ impl Condvar {\n         debug_assert_eq!(r, 0);\n     }\n \n+    // This implementation is modeled after libcxx's condition_variable\n+    // https://github.com/llvm-mirror/libcxx/blob/release_35/src/condition_variable.cpp#L46\n+    // https://github.com/llvm-mirror/libcxx/blob/release_35/include/__mutex_base#L367\n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n-        assert!(dur >= Duration::nanoseconds(0));\n+        if dur <= Duration::zero() {\n+            return false;\n+        }\n \n-        // First, figure out what time it currently is\n-        let mut tv = libc::timeval { tv_sec: 0, tv_usec: 0 };\n-        let r = ffi::gettimeofday(&mut tv, 0 as *mut _);\n+        // First, figure out what time it currently is, in both system and stable time.\n+        // pthread_cond_timedwait uses system time, but we want to report timeout based on stable\n+        // time.\n+        let mut sys_now = libc::timeval { tv_sec: 0, tv_usec: 0 };\n+        let stable_now = time::SteadyTime::now();\n+        let r = ffi::gettimeofday(&mut sys_now, 0 as *mut _);\n         debug_assert_eq!(r, 0);\n \n-        // Offset that time with the specified duration\n-        let abs = Duration::seconds(tv.tv_sec as i64) +\n-                  Duration::microseconds(tv.tv_usec as i64) +\n-                  dur;\n-        let ns = abs.num_nanoseconds().unwrap() as u64;\n-        let timeout = libc::timespec {\n-            tv_sec: (ns / 1000000000) as libc::time_t,\n-            tv_nsec: (ns % 1000000000) as libc::c_long,\n+        let seconds = NumCast::from(dur.num_seconds());\n+        let timeout = match seconds.and_then(|s| sys_now.tv_sec.checked_add(s)) {\n+            Some(sec) => {\n+                libc::timespec {\n+                    tv_sec: sec,\n+                    tv_nsec: (dur - Duration::seconds(dur.num_seconds()))\n+                        .num_nanoseconds().unwrap() as libc::c_long,\n+                }\n+            }\n+            None => {\n+                libc::timespec {\n+                    tv_sec: Int::max_value(),\n+                    tv_nsec: 1_000_000_000 - 1,\n+                }\n+            }\n         };\n \n         // And wait!\n-        let r = ffi::pthread_cond_timedwait(self.inner.get(), mutex::raw(mutex),\n-                                            &timeout);\n-        if r != 0 {\n-            debug_assert_eq!(r as int, libc::ETIMEDOUT as int);\n-            false\n-        } else {\n-            true\n-        }\n+        let r = ffi::pthread_cond_timedwait(self.inner.get(), mutex::raw(mutex), &timeout);\n+        debug_assert!(r == libc::ETIMEDOUT || r == 0);\n+\n+        // ETIMEDOUT is not a totally reliable method of determining timeout due to clock shifts,\n+        // so do the check ourselves\n+        &time::SteadyTime::now() - &stable_now < dur\n     }\n \n     #[inline]"}, {"sha": "bb98d1e052a1c1172e85b60267037c149228ae97", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08f6380a9f0b866796080094f44fe25ea5636547/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f6380a9f0b866796080094f44fe25ea5636547/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=08f6380a9f0b866796080094f44fe25ea5636547", "patch": "@@ -52,6 +52,7 @@ pub mod sync;\n pub mod tcp;\n pub mod thread;\n pub mod thread_local;\n+pub mod time;\n pub mod timer;\n pub mod tty;\n pub mod udp;"}, {"sha": "cc1e23fbca98a267fb24702cc0af16e099195f4e", "filename": "src/libstd/sys/unix/time.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/08f6380a9f0b866796080094f44fe25ea5636547/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f6380a9f0b866796080094f44fe25ea5636547/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftime.rs?ref=08f6380a9f0b866796080094f44fe25ea5636547", "patch": "@@ -0,0 +1,124 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use self::inner::SteadyTime;\n+\n+#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+mod inner {\n+    use libc;\n+    use time::Duration;\n+    use ops::Sub;\n+    use sync::{Once, ONCE_INIT};\n+\n+    pub struct SteadyTime {\n+        t: u64\n+    }\n+\n+    extern {\n+        pub fn mach_absolute_time() -> u64;\n+        pub fn mach_timebase_info(info: *mut libc::mach_timebase_info) -> libc::c_int;\n+    }\n+\n+    impl SteadyTime {\n+        pub fn now() -> SteadyTime {\n+            SteadyTime {\n+                t: unsafe { mach_absolute_time() },\n+            }\n+        }\n+\n+        pub fn ns(&self) -> u64 {\n+            let info = info();\n+            self.t * info.numer as u64 / info.denom as u64\n+        }\n+    }\n+\n+    fn info() -> &'static libc::mach_timebase_info {\n+        static mut INFO: libc::mach_timebase_info = libc::mach_timebase_info {\n+            numer: 0,\n+            denom: 0,\n+        };\n+        static ONCE: Once = ONCE_INIT;\n+\n+        unsafe {\n+            ONCE.call_once(|| {\n+                mach_timebase_info(&mut INFO);\n+            });\n+            &INFO\n+        }\n+    }\n+\n+    impl<'a> Sub for &'a SteadyTime {\n+        type Output = Duration;\n+\n+        fn sub(self, other: &SteadyTime) -> Duration {\n+            unsafe {\n+                let info = info();\n+                let diff = self.t as i64 - other.t as i64;\n+                Duration::nanoseconds(diff * info.numer as i64 / info.denom as i64)\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n+mod inner {\n+    use libc;\n+    use time::Duration;\n+    use ops::Sub;\n+\n+    const NSEC_PER_SEC: i64 = 1_000_000_000;\n+\n+    pub struct SteadyTime {\n+        t: libc::timespec,\n+    }\n+\n+    // Apparently android provides this in some other library?\n+    #[cfg(not(target_os = \"android\"))]\n+    #[link(name = \"rt\")]\n+    extern {}\n+\n+    extern {\n+        fn clock_gettime(clk_id: libc::c_int, tp: *mut libc::timespec) -> libc::c_int;\n+    }\n+\n+    impl SteadyTime {\n+        pub fn now() -> SteadyTime {\n+            let mut t = SteadyTime {\n+                t: libc::timespec {\n+                    tv_sec: 0,\n+                    tv_nsec: 0,\n+                }\n+            };\n+            unsafe {\n+                assert_eq!(0, clock_gettime(libc::CLOCK_MONOTONIC, &mut t.t));\n+            }\n+            t\n+        }\n+\n+        pub fn ns(&self) -> u64 {\n+            self.t.tv_sec as u64 * NSEC_PER_SEC as u64 + self.t.tv_nsec as u64\n+        }\n+    }\n+\n+    impl<'a> Sub for &'a SteadyTime {\n+        type Output = Duration;\n+\n+        fn sub(self, other: &SteadyTime) -> Duration {\n+            if self.t.tv_nsec >= other.t.tv_nsec {\n+                Duration::seconds(self.t.tv_sec as i64 - other.t.tv_sec as i64) +\n+                    Duration::nanoseconds(self.t.tv_nsec as i64 - other.t.tv_nsec as i64)\n+            } else {\n+                Duration::seconds(self.t.tv_sec as i64 - 1 - other.t.tv_sec as i64) +\n+                    Duration::nanoseconds(self.t.tv_nsec as i64 + NSEC_PER_SEC -\n+                                          other.t.tv_nsec as i64)\n+            }\n+        }\n+    }\n+}"}, {"sha": "72fc2f8700d6fc03d36ce8741be914fa13645bd0", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08f6380a9f0b866796080094f44fe25ea5636547/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f6380a9f0b866796080094f44fe25ea5636547/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=08f6380a9f0b866796080094f44fe25ea5636547", "patch": "@@ -50,6 +50,7 @@ pub mod rwlock;\n pub mod sync;\n pub mod stack_overflow;\n pub mod tcp;\n+pub mod time;\n pub mod thread;\n pub mod thread_local;\n pub mod timer;"}, {"sha": "20ceff0aa6931c41105646a50b01c0fade32f4df", "filename": "src/libstd/sys/windows/time.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/08f6380a9f0b866796080094f44fe25ea5636547/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f6380a9f0b866796080094f44fe25ea5636547/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs?ref=08f6380a9f0b866796080094f44fe25ea5636547", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+use libc;\n+use ops::Sub;\n+use time::Duration;\n+use sync::{Once, ONCE_INIT};\n+\n+pub struct SteadyTime {\n+    t: libc::LARGE_INTEGER,\n+}\n+\n+impl SteadyTime {\n+    pub fn now() -> SteadyTime {\n+        let mut t = SteadyTime { t: 0 };\n+        unsafe { libc::QueryPerformanceCounter(&mut t.t); }\n+        t\n+    }\n+\n+    pub fn ns(&self) -> u64 {\n+        self.t as u64 * 1_000_000_000 / frequency() as u64\n+    }\n+}\n+\n+fn frequency() -> libc::LARGE_INTEGER {\n+    static mut FREQUENCY: libc::LARGE_INTEGER = 0;\n+    static ONCE: Once = ONCE_INIT;\n+\n+    unsafe {\n+        ONCE.call_once(|| {\n+            libc::QueryPerformanceFrequency(&mut FREQUENCY);\n+        });\n+        FREQUENCY\n+    }\n+}\n+\n+impl<'a> Sub for &'a SteadyTime {\n+    type Output = Duration;\n+\n+    fn sub(self, other: &SteadyTime) -> Duration {\n+        let diff = self.t as i64 - other.t as i64;\n+        Duration::microseconds(diff * 1_000_000 / frequency() as i64)\n+    }\n+}"}, {"sha": "f62571942a78df49cb3440306aeb5746d21d8df3", "filename": "src/libstd/time/mod.rs", "status": "modified", "additions": 2, "deletions": 66, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/08f6380a9f0b866796080094f44fe25ea5636547/src%2Flibstd%2Ftime%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f6380a9f0b866796080094f44fe25ea5636547/src%2Flibstd%2Ftime%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fmod.rs?ref=08f6380a9f0b866796080094f44fe25ea5636547", "patch": "@@ -10,7 +10,7 @@\n \n //! Temporal quantification.\n \n-use libc;\n+use sys::time::SteadyTime;\n \n pub use self::duration::Duration;\n \n@@ -20,69 +20,5 @@ pub mod duration;\n /// in nanoseconds since an unspecified epoch.\n // NB: this is intentionally not public, this is not ready to stabilize its api.\n fn precise_time_ns() -> u64 {\n-    return os_precise_time_ns();\n-\n-    #[cfg(windows)]\n-    fn os_precise_time_ns() -> u64 {\n-        let mut ticks_per_s = 0;\n-        assert_eq!(unsafe {\n-            libc::QueryPerformanceFrequency(&mut ticks_per_s)\n-        }, 1);\n-        let ticks_per_s = if ticks_per_s == 0 {1} else {ticks_per_s};\n-        let mut ticks = 0;\n-        assert_eq!(unsafe {\n-            libc::QueryPerformanceCounter(&mut ticks)\n-        }, 1);\n-\n-        return (ticks as u64 * 1000000000) / (ticks_per_s as u64);\n-    }\n-\n-    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-    fn os_precise_time_ns() -> u64 {\n-        use sync;\n-\n-        static mut TIMEBASE: libc::mach_timebase_info = libc::mach_timebase_info { numer: 0,\n-                                                                                   denom: 0 };\n-        static ONCE: sync::Once = sync::ONCE_INIT;\n-        unsafe {\n-            ONCE.call_once(|| {\n-                imp::mach_timebase_info(&mut TIMEBASE);\n-            });\n-            let time = imp::mach_absolute_time();\n-            time * TIMEBASE.numer as u64 / TIMEBASE.denom as u64\n-        }\n-    }\n-\n-    #[cfg(not(any(windows, target_os = \"macos\", target_os = \"ios\")))]\n-    fn os_precise_time_ns() -> u64 {\n-        let mut ts = libc::timespec { tv_sec: 0, tv_nsec: 0 };\n-        unsafe {\n-            imp::clock_gettime(libc::CLOCK_MONOTONIC, &mut ts);\n-        }\n-        return (ts.tv_sec as u64) * 1000000000 + (ts.tv_nsec as u64)\n-    }\n-}\n-\n-#[cfg(all(unix, not(target_os = \"macos\"), not(target_os = \"ios\")))]\n-mod imp {\n-    use libc::{c_int, timespec};\n-\n-    // Apparently android provides this in some other library?\n-    #[cfg(not(target_os = \"android\"))]\n-    #[link(name = \"rt\")]\n-    extern {}\n-\n-    extern {\n-        pub fn clock_gettime(clk_id: c_int, tp: *mut timespec) -> c_int;\n-    }\n-\n-}\n-#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-mod imp {\n-    use libc::{c_int, mach_timebase_info};\n-\n-    extern {\n-        pub fn mach_absolute_time() -> u64;\n-        pub fn mach_timebase_info(info: *mut mach_timebase_info) -> c_int;\n-    }\n+    SteadyTime::now().ns()\n }"}]}