{"sha": "4abc471390d897e97e07eafcb723a8dcb59c520f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhYmM0NzEzOTBkODk3ZTk3ZTA3ZWFmY2I3MjNhOGRjYjU5YzUyMGY=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2011-08-12T13:36:51Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-08-16T22:05:56Z"}, "message": "Port the compiler to foo<T> decl syntax.", "tree": {"sha": "ddd4e2cd31c18e1f786ed9b240b1dfe2cd947e46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ddd4e2cd31c18e1f786ed9b240b1dfe2cd947e46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4abc471390d897e97e07eafcb723a8dcb59c520f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4abc471390d897e97e07eafcb723a8dcb59c520f", "html_url": "https://github.com/rust-lang/rust/commit/4abc471390d897e97e07eafcb723a8dcb59c520f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4abc471390d897e97e07eafcb723a8dcb59c520f/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c9049c50c5c32f556eaefbcc50209ef8ee353d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c9049c50c5c32f556eaefbcc50209ef8ee353d0", "html_url": "https://github.com/rust-lang/rust/commit/4c9049c50c5c32f556eaefbcc50209ef8ee353d0"}], "stats": {"total": 154, "additions": 77, "deletions": 77}, "files": [{"sha": "b2ae862dc74ed3662605a79d181e28188d81803a", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=4abc471390d897e97e07eafcb723a8dcb59c520f", "patch": "@@ -110,7 +110,7 @@ fn parse_input_src(sess: session::session, cfg: &ast::crate_cfg,\n     ret {crate: crate, src: src};\n }\n \n-fn time[T](do_it: bool, what: str, thunk: fn() -> T ) -> T {\n+fn time<T>(do_it: bool, what: str, thunk: fn() -> T ) -> T {\n     if !do_it { ret thunk(); }\n     let start = std::time::precise_time_s();\n     let rv = thunk();"}, {"sha": "6e6b00954002009280ff5f40d140cec061cf19bb", "filename": "src/comp/front/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fattr.rs?ref=4abc471390d897e97e07eafcb723a8dcb59c520f", "patch": "@@ -189,7 +189,7 @@ fn require_unique_names(sess: &session::session,\n     }\n }\n \n-fn span[T](item: &T) -> ast::spanned<T> {\n+fn span<T>(item: &T) -> ast::spanned<T> {\n     ret {node: item, span: ast::mk_sp(0u, 0u)};\n }\n "}, {"sha": "86944452662e4b0ad24fc84762ce762e34677308", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=4abc471390d897e97e07eafcb723a8dcb59c520f", "patch": "@@ -167,7 +167,7 @@ fn mk_test_module(cx: &test_ctxt) -> @ast::item {\n     ret @item;\n }\n \n-fn nospan[T](t: &T) -> ast::spanned<T> {\n+fn nospan<T>(t: &T) -> ast::spanned<T> {\n     ret {node: t, span: ast::dummy_sp()};\n }\n "}, {"sha": "ca5f5af98c6b100be0c51ef5f62475f0d043f720", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=4abc471390d897e97e07eafcb723a8dcb59c520f", "patch": "@@ -36,7 +36,7 @@ fn encode_def_id(ebml_w: &ebml::writer, id: &def_id) {\n     ebml::end_tag(ebml_w);\n }\n \n-type entry[T] = {val: T, pos: uint};\n+type entry<T> = {val: T, pos: uint};\n \n fn encode_tag_variant_paths(ebml_w: &ebml::writer, variants: &[variant],\n                             path: &[str], index: &mutable [entry<str>]) {\n@@ -392,7 +392,7 @@ fn encode_info_for_items(ecx: &@encode_ctxt, ebml_w: &ebml::writer) ->\n \n // Path and definition ID indexing\n \n-fn create_index[T](index: &[entry<T>], hash_fn: fn(&T) -> uint ) ->\n+fn create_index<T>(index: &[entry<T>], hash_fn: fn(&T) -> uint ) ->\n    [@[entry<T>]] {\n     let buckets: [@mutable [entry<T>]] = ~[];\n     for each i: uint in uint::range(0u, 256u) { buckets += ~[@mutable ~[]]; }\n@@ -408,7 +408,7 @@ fn create_index[T](index: &[entry<T>], hash_fn: fn(&T) -> uint ) ->\n     ret buckets_frozen;\n }\n \n-fn encode_index[T](ebml_w: &ebml::writer, buckets: &[@[entry<T>]],\n+fn encode_index<T>(ebml_w: &ebml::writer, buckets: &[@[entry<T>]],\n                    write_fn: fn(&io::writer, &T) ) {\n     let writer = io::new_writer_(ebml_w.writer);\n     ebml::start_tag(ebml_w, tag_index);"}, {"sha": "4adbfb279c7ec25afff6b9246cdb21d220bdf2fb", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=4abc471390d897e97e07eafcb723a8dcb59c520f", "patch": "@@ -115,7 +115,7 @@ fn parse_path(st: @pstate, sd: str_def) -> ast::path {\n     fail \"parse_path: ill-formed path\";\n }\n \n-type arg_parser[T] = fn(@pstate, str_def) -> ast::constr_arg_general_<T> ;\n+type arg_parser<T> = fn(@pstate, str_def) -> ast::constr_arg_general_<T> ;\n \n fn parse_constr_arg(st: @pstate, sd: str_def) -> ast::fn_constr_arg {\n     alt peek(st) as char {\n@@ -150,7 +150,7 @@ fn parse_ty_constr_arg(st: @pstate, sd: str_def) ->\n     }\n }\n \n-fn parse_constr[@T](st: @pstate, sd: str_def, pser: arg_parser<T>) ->\n+fn parse_constr<@T>(st: @pstate, sd: str_def, pser: arg_parser<T>) ->\n    @ty::constr_general<T> {\n     let sp = ast::dummy_sp(); // FIXME: use a real span\n     let args: [@sp_constr_arg<T>] = ~[];"}, {"sha": "5af6d04a649e4b22ab400bfd825253e0bd1f74f0", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=4abc471390d897e97e07eafcb723a8dcb59c520f", "patch": "@@ -48,7 +48,7 @@ fn map_expr(map: &map, ex: &@expr, e: &(), v: &vt<()>) {\n     visit::visit_expr(ex, e, v);\n }\n \n-fn new_smallintmap_int_adapter[@V]() -> std::map::hashmap<int, V> {\n+fn new_smallintmap_int_adapter<@V>() -> std::map::hashmap<int, V> {\n     let key_idx = fn (key: &int) -> uint { key as uint };\n     let idx_key = fn (idx: &uint) -> int { idx as int };\n     ret new_smallintmap_adapter(key_idx, idx_key);\n@@ -59,13 +59,13 @@ fn new_smallintmap_int_adapter[@V]() -> std::map::hashmap<int, V> {\n // the entire codebase adapting all the callsites to the different\n // interface.\n // FIXME: hashmap and smallintmap should support the same interface.\n-fn new_smallintmap_adapter[@K,\n-                           @V](key_idx: fn(&K) -> uint ,\n+fn new_smallintmap_adapter<@K,\n+                           @V>(key_idx: fn(&K) -> uint ,\n                                idx_key: fn(&uint) -> K ) ->\n    std::map::hashmap<K, V> {\n \n-    obj adapter[@K,\n-                @V](map: smallintmap::smallintmap<V>,\n+    obj adapter<@K,\n+                @V>(map: smallintmap::smallintmap<V>,\n                     key_idx: fn(&K) -> uint ,\n                     idx_key: fn(&uint) -> K ) {\n "}, {"sha": "f919520a097cf898648a0e3efe1350f3124d96ee", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=4abc471390d897e97e07eafcb723a8dcb59c520f", "patch": "@@ -1392,7 +1392,7 @@ fn add_name(ch: &checker, sp: &span, name: &ident) {\n \n fn ident_id(i: &ident) -> ident { ret i; }\n \n-fn ensure_unique[T](e: &env, sp: &span, elts: &[T], id: fn(&T) -> ident ,\n+fn ensure_unique<T>(e: &env, sp: &span, elts: &[T], id: fn(&T) -> ident ,\n                     kind: &str) {\n     let ch = checker(e, kind);\n     for elt: T in elts { add_name(ch, sp, id(elt)); }"}, {"sha": "f213dc9feb857d6216677827f011f55703d5b98e", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=4abc471390d897e97e07eafcb723a8dcb59c520f", "patch": "@@ -1012,13 +1012,13 @@ fn non_init_constraint_mentions(fcx: &fn_ctxt, c: &norm_constraint,\n         };\n }\n \n-fn args_mention[T](args: &[@constr_arg_use], q: fn(&[T], node_id) -> bool ,\n+fn args_mention<T>(args: &[@constr_arg_use], q: fn(&[T], node_id) -> bool ,\n                    s: &[T]) -> bool {\n     /*\n       FIXME\n       The following version causes an assertion in trans to fail\n       (something about type_is_tup_like)\n-    fn mentions[T](&[T] s, &fn(&[T], def_id) -> bool q,\n+    fn mentions<T>(&[T] s, &fn(&[T], def_id) -> bool q,\n                             &@constr_arg_use a) -> bool {\n         alt (a.node) {\n             case (carg_ident(?p1)) {\n@@ -1051,7 +1051,7 @@ fn op_to_oper_ty(io: init_op) -> oper_type {\n }\n \n // default function visitor\n-fn do_nothing[T](f: &_fn, tp: &[ty_param], sp: &span, i: &fn_ident,\n+fn do_nothing<T>(f: &_fn, tp: &[ty_param], sp: &span, i: &fn_ident,\n                  iid: node_id, cx: &T, v: &visit::vt<T>) {\n }\n "}, {"sha": "001505b4b28cf3b919dc81369981cd5d697c7ae0", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=4abc471390d897e97e07eafcb723a8dcb59c520f", "patch": "@@ -284,7 +284,7 @@ tag sty {\n \n // In the middle end, constraints have a def_id attached, referring\n // to the definition of the operator in the constraint.\n-type constr_general[ARG] = spanned<constr_general_<ARG, def_id>>;\n+type constr_general<ARG> = spanned<constr_general_<ARG, def_id>>;\n type type_constr = constr_general<path>;\n type constr = constr_general<uint>;\n \n@@ -1554,7 +1554,7 @@ fn hash_ty(typ: &t) -> uint { ret typ; }\n // users should use `eq_ty()` instead.\n fn eq_int(x: &uint, y: &uint) -> bool { ret x == y; }\n \n-fn arg_eq[T](eq: &fn(&T, &T) -> bool , a: @sp_constr_arg<T>,\n+fn arg_eq<T>(eq: &fn(&T, &T) -> bool , a: @sp_constr_arg<T>,\n              b: @sp_constr_arg<T>) -> bool {\n     alt a.node {\n       ast::carg_base. {\n@@ -1569,7 +1569,7 @@ fn arg_eq[T](eq: &fn(&T, &T) -> bool , a: @sp_constr_arg<T>,\n     }\n }\n \n-fn args_eq[T](eq: fn(&T, &T) -> bool , a: &[@sp_constr_arg<T>],\n+fn args_eq<T>(eq: fn(&T, &T) -> bool , a: &[@sp_constr_arg<T>],\n               b: &[@sp_constr_arg<T>]) -> bool {\n     let i: uint = 0u;\n     for arg: @sp_constr_arg<T> in a {\n@@ -3090,7 +3090,7 @@ fn is_binopable(cx: &ctxt, ty: t, op: ast::binop) -> bool {\n     ret tbl.(tycat(cx, ty)).(opcat(op));\n }\n \n-fn ast_constr_to_constr[T](tcx: ty::ctxt, c: &@ast::constr_general<T>) ->\n+fn ast_constr_to_constr<T>(tcx: ty::ctxt, c: &@ast::constr_general<T>) ->\n    @ty::constr_general<T> {\n     alt tcx.def_map.find(c.node.id) {\n       some(ast::def_fn(pred_id, ast::pure_fn.)) {"}, {"sha": "4dcd6e7dc675b958f8ae210238df2bc272dc8231", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=4abc471390d897e97e07eafcb723a8dcb59c520f", "patch": "@@ -1281,10 +1281,10 @@ fn gather_locals(ccx: &@crate_ctxt, f: &ast::_fn, id: &ast::node_id,\n     };\n \n     // Don't descend into fns and items\n-    fn visit_fn[E](f: &ast::_fn, tp: &[ast::ty_param], sp: &span,\n+    fn visit_fn<E>(f: &ast::_fn, tp: &[ast::ty_param], sp: &span,\n                    i: &ast::fn_ident, id: ast::node_id, e: &E,\n                    v: &visit::vt<E>) { }\n-    fn visit_item[E](i: &@ast::item, e: &E, v: &visit::vt<E>) { }\n+    fn visit_item<E>(i: &@ast::item, e: &E, v: &visit::vt<E>) { }\n \n     let visit =\n         @{visit_local: visit_local,"}, {"sha": "5500d7a3e68ced02b7377ac9b94bff18000ce8f5", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=4abc471390d897e97e07eafcb723a8dcb59c520f", "patch": "@@ -5,8 +5,8 @@ import std::str;\n import codemap::span;\n import codemap::filename;\n \n-type spanned[T] = {node: T, span: span};\n-fn respan[T](sp: &span, t: &T) -> spanned<T> { ret {node: t, span: sp}; }\n+type spanned<T> = {node: T, span: span};\n+fn respan<T>(sp: &span, t: &T) -> spanned<T> { ret {node: t, span: sp}; }\n \n /* assuming that we're not in macro expansion */\n fn mk_sp(lo: uint, hi: uint) -> span {\n@@ -468,10 +468,10 @@ so that the typestate pass doesn't have to map a function name onto its decl.\n So, the constr_arg type is parameterized: it's instantiated with uint for\n declarations, and ident for uses.\n */\n-tag constr_arg_general_[T] { carg_base; carg_ident(T); carg_lit(@lit); }\n+tag constr_arg_general_<T> { carg_base; carg_ident(T); carg_lit(@lit); }\n \n type fn_constr_arg = constr_arg_general_<uint>;\n-type sp_constr_arg[T] = spanned<constr_arg_general_<T>>;\n+type sp_constr_arg<T> = spanned<constr_arg_general_<T>>;\n type ty_constr_arg = sp_constr_arg<path>;\n type constr_arg = spanned<fn_constr_arg>;\n \n@@ -480,12 +480,12 @@ type constr_arg = spanned<fn_constr_arg>;\n // The implicit root of such path, in the constraint-list for a\n // constrained type, is * (referring to the base record)\n \n-type constr_general_[ARG, ID] =\n+type constr_general_<ARG, ID> =\n     {path: path, args: [@spanned<constr_arg_general_<ARG>>], id: ID};\n \n // In the front end, constraints have a node ID attached.\n // Typeck turns this to a def_id, using the output of resolve.\n-type constr_general[ARG] = spanned<constr_general_<ARG, node_id>>;\n+type constr_general<ARG> = spanned<constr_general_<ARG, node_id>>;\n type constr_ = constr_general_<uint, node_id>;\n type constr = spanned<constr_general_<uint, node_id>>;\n type ty_constr_ = ast::constr_general_<ast::path, ast::node_id>;"}, {"sha": "462f9d7ce0c09290e26dbac4cdf089cc88673e75", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=4abc471390d897e97e07eafcb723a8dcb59c520f", "patch": "@@ -43,7 +43,7 @@ fn path_to_ident(pth: &path) -> option::t<ident> {\n type clause = {params: binders, body: @expr};\n \n /* logically, an arb_depth should contain only one kind of matchable */\n-tag arb_depth[T] { leaf(T); seq(@[arb_depth<T>], span); }\n+tag arb_depth<T> { leaf(T); seq(@[arb_depth<T>], span); }\n \n \n tag matchable {\n@@ -121,7 +121,7 @@ fn elts_to_ell(cx: &ext_ctxt, elts: &[@expr])\n     }\n }\n \n-fn option_flatten_map[T, U](f: &fn(&T) -> option::t<U>, v: &[T]) ->\n+fn option_flatten_map<T, U>(f: &fn(&T) -> option::t<U>, v: &[T]) ->\n    option::t<[U]> {\n     let res = ~[];\n     for elem: T in v {"}, {"sha": "5e6db11c9d2c187f5f630b6d8afecf3c269adbb1", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=4abc471390d897e97e07eafcb723a8dcb59c520f", "patch": "@@ -75,7 +75,7 @@ type a_f =\n      new_span: fn(&span) -> span};\n \n \n-//fn nf_dummy[T](&T node) -> T { fail; }\n+//fn nf_dummy<T>(&T node) -> T { fail; }\n fn nf_crate_dummy(c: &crate) -> crate { fail; }\n fn nf_crate_directive_dummy(c: &@crate_directive) -> @crate_directive {\n     fail;"}, {"sha": "aa5628b1bad0fc9845f26a6c8ecb6a4b0d61a5b6", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=4abc471390d897e97e07eafcb723a8dcb59c520f", "patch": "@@ -224,7 +224,7 @@ fn expect_gt(p: &parser) {\n     }\n }\n \n-fn spanned[T](lo: uint, hi: uint, node: &T) -> spanned<T> {\n+fn spanned<T>(lo: uint, hi: uint, node: &T) -> spanned<T> {\n     ret {node: node, span: ast::mk_sp(lo, hi)};\n }\n \n@@ -429,7 +429,7 @@ fn parse_constr_in_type(p: &parser) -> @ast::ty_constr {\n }\n \n \n-fn parse_constrs[T](pser: fn(&parser) -> @ast::constr_general<T>, p: &parser)\n+fn parse_constrs<T>(pser: fn(&parser) -> @ast::constr_general<T>, p: &parser)\n    -> [@ast::constr_general<T>] {\n     let constrs: [@ast::constr_general<T>] = ~[];\n     while true {\n@@ -643,7 +643,7 @@ fn parse_fn_block_arg(p: &parser) -> ast::arg {\n     ret {mode: m, ty: t, ident: i, id: p.get_id()};\n }\n \n-fn parse_seq_to_before_gt[T](sep: option::t<token::token>,\n+fn parse_seq_to_before_gt<T>(sep: option::t<token::token>,\n                              f: fn(&parser) -> T, p: &parser) -> [T] {\n     let first = true;\n     let v = ~[];\n@@ -660,15 +660,15 @@ fn parse_seq_to_before_gt[T](sep: option::t<token::token>,\n     ret v;\n }\n \n-fn parse_seq_to_gt[T](sep: option::t<token::token>, f: fn(&parser) -> T,\n+fn parse_seq_to_gt<T>(sep: option::t<token::token>, f: fn(&parser) -> T,\n                       p: &parser) -> [T] {\n     let v = parse_seq_to_before_gt(sep, f, p);\n     expect_gt(p);\n \n     ret v;\n }\n \n-fn parse_seq_lt_gt[T](sep: option::t<token::token>, f: fn(&parser) -> T,\n+fn parse_seq_lt_gt<T>(sep: option::t<token::token>, f: fn(&parser) -> T,\n                       p: &parser) -> spanned<[T]> {\n     let lo = p.get_lo_pos();\n     expect(p, token::LT);\n@@ -678,14 +678,14 @@ fn parse_seq_lt_gt[T](sep: option::t<token::token>, f: fn(&parser) -> T,\n     ret spanned(lo, hi, result);\n }\n \n-fn parse_seq_to_end[T](ket: token::token, sep: option::t<token::token>,\n+fn parse_seq_to_end<T>(ket: token::token, sep: option::t<token::token>,\n                        f: fn(&parser) -> T , p: &parser) -> [T] {\n     let val = parse_seq_to_before_end(ket, sep, f, p);\n     p.bump();\n     ret val;\n }\n \n-fn parse_seq_to_before_end[T](ket: token::token, sep: option::t<token::token>,\n+fn parse_seq_to_before_end<T>(ket: token::token, sep: option::t<token::token>,\n                               f: fn(&parser) -> T , p: &parser) -> [T] {\n     let first: bool = true;\n     let v: [T] = ~[];\n@@ -700,7 +700,7 @@ fn parse_seq_to_before_end[T](ket: token::token, sep: option::t<token::token>,\n }\n \n \n-fn parse_seq[T](bra: token::token, ket: token::token,\n+fn parse_seq<T>(bra: token::token, ket: token::token,\n                 sep: option::t<token::token>, f: fn(&parser) -> T ,\n                 p: &parser) -> spanned<[T]> {\n     let lo = p.get_lo_pos();"}, {"sha": "66a1062de7ef09601ddc05e239c5d6630d66f8ac", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=4abc471390d897e97e07eafcb723a8dcb59c520f", "patch": "@@ -217,7 +217,7 @@ fn synth_comment(s: &ps, text: str) {\n     word(s.s, \"*/\");\n }\n \n-fn commasep[IN](s: &ps, b: breaks, elts: &[IN], op: fn(&ps, &IN) ) {\n+fn commasep<IN>(s: &ps, b: breaks, elts: &[IN], op: fn(&ps, &IN) ) {\n     box(s, 0u, b);\n     let first = true;\n     for elt: IN in elts {\n@@ -228,7 +228,7 @@ fn commasep[IN](s: &ps, b: breaks, elts: &[IN], op: fn(&ps, &IN) ) {\n }\n \n \n-fn commasep_cmnt[IN](s: &ps, b: breaks, elts: &[IN], op: fn(&ps, &IN) ,\n+fn commasep_cmnt<IN>(s: &ps, b: breaks, elts: &[IN], op: fn(&ps, &IN) ,\n                      get_span: fn(&IN) -> codemap::span ) {\n     box(s, 0u, b);\n     let len = vec::len[IN](elts);\n@@ -1515,7 +1515,7 @@ fn escape_str(st: str, to_escape: char) -> str {\n     ret out;\n }\n \n-fn to_str[T](t: &T, f: fn(&ps, &T) ) -> str {\n+fn to_str<T>(t: &T, f: fn(&ps, &T) ) -> str {\n     let writer = io::string_writer();\n     let s = rust_printer(writer.get_writer());\n     f(s, t);\n@@ -1536,7 +1536,7 @@ fn next_comment(s: &ps) -> option::t<lexer::cmnt> {\n \n // Removing the aliases from the type of f in the next two functions\n // triggers memory corruption, but I haven't isolated the bug yet. FIXME\n-fn constr_args_to_str[T](f: &fn(&T) -> str ,\n+fn constr_args_to_str<T>(f: &fn(&T) -> str ,\n                          args: &[@ast::sp_constr_arg<T>]) -> str {\n     let comma = false;\n     let s = \"(\";\n@@ -1548,7 +1548,7 @@ fn constr_args_to_str[T](f: &fn(&T) -> str ,\n     ret s;\n }\n \n-fn constr_arg_to_str[T](f: &fn(&T) -> str, c: &ast::constr_arg_general_<T>)\n+fn constr_arg_to_str<T>(f: &fn(&T) -> str, c: &ast::constr_arg_general_<T>)\n    -> str {\n     alt c {\n       ast::carg_base. { ret \"*\"; }"}, {"sha": "cc746c00f4172f5d98fac63b921b8453fd6f6ee6", "filename": "src/comp/syntax/untyped_ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Fsyntax%2Funtyped_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Fsyntax%2Funtyped_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Funtyped_ast.rs?ref=4abc471390d897e97e07eafcb723a8dcb59c520f", "patch": "@@ -370,7 +370,7 @@ fn dummy() {\n          extract_fn(ctx, elts.(idx))]];\n }\n \n-fn seq_cv[T](conversion: fn (&ctx, &@ast_node) -> T)\n+fn seq_cv<T>(conversion: fn (&ctx, &@ast_node) -> T)\n     -> fn (&ctx, @ast_node) -> T[] {\n     ret lambda(ctx: &ctx, ut: @ast_node) -> T[] {\n         ret alt *ut {\n@@ -383,7 +383,7 @@ fn seq_cv[T](conversion: fn (&ctx, &@ast_node) -> T)\n     }\n }\n \n-fn opt_cv[T](conversion: fn (&ctx, &@ast_node) -> T)\n+fn opt_cv<T>(conversion: fn (&ctx, &@ast_node) -> T)\n     -> fn (&ctx, @ast_node) -> option::t<T> {\n     ret lambda(ctx: &ctx, ut: @ast_node) -> option::t<T> {\n         ret alt *ut {"}, {"sha": "8edfd3cb618661127665216f85744be1317c5516", "filename": "src/comp/syntax/util/interner.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs?ref=4abc471390d897e97e07eafcb723a8dcb59c520f", "patch": "@@ -10,18 +10,18 @@ import std::option;\n import std::option::none;\n import std::option::some;\n \n-type interner[T] =\n+type interner<T> =\n     {map: hashmap<T, uint>,\n      mutable vect: [T],\n      hasher: hashfn<T>,\n      eqer: eqfn<T>};\n \n-fn mk[@T](hasher: hashfn<T>, eqer: eqfn<T>) -> interner<T> {\n+fn mk<@T>(hasher: hashfn<T>, eqer: eqfn<T>) -> interner<T> {\n     let m = map::mk_hashmap[T, uint](hasher, eqer);\n     ret {map: m, mutable vect: ~[], hasher: hasher, eqer: eqer};\n }\n \n-fn intern[@T](itr: &interner<T>, val: &T) -> uint {\n+fn intern<@T>(itr: &interner<T>, val: &T) -> uint {\n     alt itr.map.find(val) {\n       some(idx) { ret idx; }\n       none. {\n@@ -33,7 +33,7 @@ fn intern[@T](itr: &interner<T>, val: &T) -> uint {\n     }\n }\n \n-fn get[T](itr: &interner<T>, idx: uint) -> T { ret itr.vect.(idx); }\n+fn get<T>(itr: &interner<T>, idx: uint) -> T { ret itr.vect.(idx); }\n \n-fn len[T](itr : &interner<T>) -> uint { ret vec::len(itr.vect); }\n+fn len<T>(itr : &interner<T>) -> uint { ret vec::len(itr.vect); }\n "}, {"sha": "2b91f7042853274614d38649bf9b026d5b7816bd", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=4abc471390d897e97e07eafcb723a8dcb59c520f", "patch": "@@ -14,9 +14,9 @@ import codemap::span;\n \n // Our typesystem doesn't do circular types, so the visitor record can not\n // hold functions that take visitors. A vt tag is used to break the cycle.\n-tag vt[E] { mk_vt(visitor<E>); }\n+tag vt<E> { mk_vt(visitor<E>); }\n \n-type visitor[E] =\n+type visitor<E> =\n     // takes the components so that one function can be\n     // generic over constr and ty_constr\n     @{visit_mod: fn(&_mod, &span, &E, &vt<E>),\n@@ -35,7 +35,7 @@ type visitor[E] =\n       visit_fn:\n           fn(&_fn, &[ty_param], &span, &fn_ident, node_id, &E, &vt<E>) };\n \n-fn default_visitor[E]() -> visitor<E> {\n+fn default_visitor<E>() -> visitor<E> {\n     ret @{visit_mod: bind visit_mod[E](_, _, _, _),\n           visit_view_item: bind visit_view_item[E](_, _, _),\n           visit_native_item: bind visit_native_item[E](_, _, _),\n@@ -52,11 +52,11 @@ fn default_visitor[E]() -> visitor<E> {\n           visit_fn: bind visit_fn[E](_, _, _, _, _, _, _)};\n }\n \n-fn visit_crate[E](c: &crate, e: &E, v: &vt<E>) {\n+fn visit_crate<E>(c: &crate, e: &E, v: &vt<E>) {\n     v.visit_mod(c.node.module, c.span, e, v);\n }\n \n-fn visit_crate_directive[E](cd: &@crate_directive, e: &E, v: &vt<E>) {\n+fn visit_crate_directive<E>(cd: &@crate_directive, e: &E, v: &vt<E>) {\n     alt cd.node {\n       cdir_src_mod(_, _, _) { }\n       cdir_dir_mod(_, _, cdirs, _) {\n@@ -70,20 +70,20 @@ fn visit_crate_directive[E](cd: &@crate_directive, e: &E, v: &vt<E>) {\n     }\n }\n \n-fn visit_mod[E](m: &_mod, sp: &span, e: &E, v: &vt<E>) {\n+fn visit_mod<E>(m: &_mod, sp: &span, e: &E, v: &vt<E>) {\n     for vi: @view_item in m.view_items { v.visit_view_item(vi, e, v); }\n     for i: @item in m.items { v.visit_item(i, e, v); }\n }\n \n-fn visit_view_item[E](vi: &@view_item, e: &E, v: &vt<E>) { }\n+fn visit_view_item<E>(vi: &@view_item, e: &E, v: &vt<E>) { }\n \n-fn visit_local[E](loc: &@local, e: &E, v: &vt<E>) {\n+fn visit_local<E>(loc: &@local, e: &E, v: &vt<E>) {\n     v.visit_pat(loc.node.pat, e, v);\n     v.visit_ty(loc.node.ty, e, v);\n     alt loc.node.init { none. { } some(i) { v.visit_expr(i.expr, e, v); } }\n }\n \n-fn visit_item[E](i: &@item, e: &E, v: &vt<E>) {\n+fn visit_item<E>(i: &@item, e: &E, v: &vt<E>) {\n     alt i.node {\n       item_const(t, ex) { v.visit_ty(t, e, v); v.visit_expr(ex, e, v); }\n       item_fn(f, tp) { v.visit_fn(f, tp, i.span, some(i.ident), i.id, e, v); }\n@@ -111,7 +111,7 @@ fn visit_item[E](i: &@item, e: &E, v: &vt<E>) {\n     }\n }\n \n-fn visit_ty[E](t: &@ty, e: &E, v: &vt<E>) {\n+fn visit_ty<E>(t: &@ty, e: &E, v: &vt<E>) {\n     alt t.node {\n       ty_nil. {/* no-op */ }\n       ty_bot. {/* no-op */ }\n@@ -161,12 +161,12 @@ fn visit_ty[E](t: &@ty, e: &E, v: &vt<E>) {\n     }\n }\n \n-fn visit_constr[E](operator: &path, sp: &span, id: node_id, e: &E,\n+fn visit_constr<E>(operator: &path, sp: &span, id: node_id, e: &E,\n                    v: &vt<E>) {\n     // default\n }\n \n-fn visit_pat[E](p: &@pat, e: &E, v: &vt<E>) {\n+fn visit_pat<E>(p: &@pat, e: &E, v: &vt<E>) {\n     alt p.node {\n       pat_tag(path, children) {\n         for tp: @ty in path.node.types { v.visit_ty(tp, e, v); }\n@@ -183,41 +183,41 @@ fn visit_pat[E](p: &@pat, e: &E, v: &vt<E>) {\n     }\n }\n \n-fn visit_native_item[E](ni: &@native_item, e: &E, v: &vt<E>) {\n+fn visit_native_item<E>(ni: &@native_item, e: &E, v: &vt<E>) {\n     alt ni.node {\n       native_item_fn(_, fd, _) { visit_fn_decl(fd, e, v); }\n       native_item_ty. { }\n     }\n }\n \n-fn visit_fn_decl[E](fd: &fn_decl, e: &E, v: &vt<E>) {\n+fn visit_fn_decl<E>(fd: &fn_decl, e: &E, v: &vt<E>) {\n     for a: arg in fd.inputs { v.visit_ty(a.ty, e, v); }\n     for c: @constr in fd.constraints {\n         v.visit_constr(c.node.path, c.span, c.node.id, e, v);\n     }\n     v.visit_ty(fd.output, e, v);\n }\n \n-fn visit_fn[E](f: &_fn, tp: &[ty_param], sp: &span, i: &fn_ident, id: node_id,\n+fn visit_fn<E>(f: &_fn, tp: &[ty_param], sp: &span, i: &fn_ident, id: node_id,\n                e: &E, v: &vt<E>) {\n     visit_fn_decl(f.decl, e, v);\n     v.visit_block(f.body, e, v);\n }\n \n-fn visit_block[E](b: &ast::blk, e: &E, v: &vt<E>) {\n+fn visit_block<E>(b: &ast::blk, e: &E, v: &vt<E>) {\n     for s: @stmt in b.node.stmts { v.visit_stmt(s, e, v); }\n     visit_expr_opt(b.node.expr, e, v);\n }\n \n-fn visit_stmt[E](s: &@stmt, e: &E, v: &vt<E>) {\n+fn visit_stmt<E>(s: &@stmt, e: &E, v: &vt<E>) {\n     alt s.node {\n       stmt_decl(d, _) { v.visit_decl(d, e, v); }\n       stmt_expr(ex, _) { v.visit_expr(ex, e, v); }\n       stmt_crate_directive(cd) { visit_crate_directive(cd, e, v); }\n     }\n }\n \n-fn visit_decl[E](d: &@decl, e: &E, v: &vt<E>) {\n+fn visit_decl<E>(d: &@decl, e: &E, v: &vt<E>) {\n     alt d.node {\n       decl_local(locs) {\n         for loc: @ast::local in locs { v.visit_local(loc, e, v); }\n@@ -226,15 +226,15 @@ fn visit_decl[E](d: &@decl, e: &E, v: &vt<E>) {\n     }\n }\n \n-fn visit_expr_opt[E](eo: option::t<@expr>, e: &E, v: &vt<E>) {\n+fn visit_expr_opt<E>(eo: option::t<@expr>, e: &E, v: &vt<E>) {\n     alt eo { none. { } some(ex) { v.visit_expr(ex, e, v); } }\n }\n \n-fn visit_exprs[E](exprs: &[@expr], e: &E, v: &vt<E>) {\n+fn visit_exprs<E>(exprs: &[@expr], e: &E, v: &vt<E>) {\n     for ex: @expr in exprs { v.visit_expr(ex, e, v); }\n }\n \n-fn visit_mac[E](m: mac, e: &E, v: &vt<E>) {\n+fn visit_mac<E>(m: mac, e: &E, v: &vt<E>) {\n     alt m.node {\n       ast::mac_invoc(pth, arg, body) { visit_expr(arg, e, v); }\n       ast::mac_embed_type(ty) { v.visit_ty(ty, e, v); }\n@@ -243,7 +243,7 @@ fn visit_mac[E](m: mac, e: &E, v: &vt<E>) {\n     }\n }\n \n-fn visit_expr[E](ex: &@expr, e: &E, v: &vt<E>) {\n+fn visit_expr<E>(ex: &@expr, e: &E, v: &vt<E>) {\n     alt ex.node {\n       expr_vec(es, _, _) { visit_exprs(es, e, v); }\n       expr_rec(flds, base) {\n@@ -338,7 +338,7 @@ fn visit_expr[E](ex: &@expr, e: &E, v: &vt<E>) {\n     }\n }\n \n-fn visit_arm[E](a: &arm, e: &E, v: &vt<E>) {\n+fn visit_arm<E>(a: &arm, e: &E, v: &vt<E>) {\n     for p: @pat in a.pats { v.visit_pat(p, e, v); }\n     v.visit_block(a.body, e, v);\n }"}, {"sha": "cfc96844933ab79b8ae2c6556c1343615830f94e", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=4abc471390d897e97e07eafcb723a8dcb59c520f", "patch": "@@ -41,7 +41,7 @@ fn hash_def(d: &ast::def_id) -> uint {\n     ret h;\n }\n \n-fn new_def_hash[@V]() -> std::map::hashmap<ast::def_id, V> {\n+fn new_def_hash<@V>() -> std::map::hashmap<ast::def_id, V> {\n     let hasher: std::map::hashfn<ast::def_id> = hash_def;\n     let eqer: std::map::eqfn<ast::def_id> = def_eq;\n     ret std::map::mk_hashmap[ast::def_id, V](hasher, eqer);"}, {"sha": "a13c96fe4694d135b96cf1a49275540dd575f1be", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4abc471390d897e97e07eafcb723a8dcb59c520f/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=4abc471390d897e97e07eafcb723a8dcb59c520f", "patch": "@@ -162,7 +162,7 @@ fn constrs_str(constrs: &[@constr]) -> str {\n     ret s;\n }\n \n-fn ty_constr_to_str[Q](c: &@ast::spanned<ast::constr_general_<ast::path, Q>>)\n+fn ty_constr_to_str<Q>(c: &@ast::spanned<ast::constr_general_<ast::path, Q>>)\n    -> str {\n     ret path_to_str(c.node.path) +\n             constr_args_to_str[ast::path](path_to_str, c.node.args);"}]}