{"sha": "afdf08e964345ac4a884a5630772611ba81f6969", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmZGYwOGU5NjQzNDVhYzRhODg0YTU2MzA3NzI2MTFiYTgxZjY5Njk=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-03-08T10:02:14Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-03-08T10:10:48Z"}, "message": "Move hypothetical expansion to hir_expand", "tree": {"sha": "b72b06310a3cd9bcec2234b0f38ff93eb6a8feb0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b72b06310a3cd9bcec2234b0f38ff93eb6a8feb0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afdf08e964345ac4a884a5630772611ba81f6969", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afdf08e964345ac4a884a5630772611ba81f6969", "html_url": "https://github.com/rust-lang/rust/commit/afdf08e964345ac4a884a5630772611ba81f6969", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afdf08e964345ac4a884a5630772611ba81f6969/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f617455d10084da30a13cc49ffdd6b86c6049ba1", "url": "https://api.github.com/repos/rust-lang/rust/commits/f617455d10084da30a13cc49ffdd6b86c6049ba1", "html_url": "https://github.com/rust-lang/rust/commit/f617455d10084da30a13cc49ffdd6b86c6049ba1"}], "stats": {"total": 82, "additions": 43, "deletions": 39}, "files": [{"sha": "3782a9984b772716710aafac6933e9ebf62117e8", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/afdf08e964345ac4a884a5630772611ba81f6969/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdf08e964345ac4a884a5630772611ba81f6969/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=afdf08e964345ac4a884a5630772611ba81f6969", "patch": "@@ -12,8 +12,7 @@ use hir_expand::ExpansionInfo;\n use ra_db::{FileId, FileRange};\n use ra_prof::profile;\n use ra_syntax::{\n-    algo::{self, skip_trivia_token},\n-    ast, AstNode, Direction, SyntaxNode, SyntaxToken, TextRange, TextUnit,\n+    algo::skip_trivia_token, ast, AstNode, Direction, SyntaxNode, SyntaxToken, TextRange, TextUnit,\n };\n use rustc_hash::{FxHashMap, FxHashSet};\n \n@@ -74,32 +73,15 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n     pub fn expand_hypothetical(\n         &self,\n         actual_macro_call: &ast::MacroCall,\n-        hypothetical_call: &ast::MacroCall,\n+        hypothetical_args: &ast::TokenTree,\n         token_to_map: SyntaxToken,\n     ) -> Option<(SyntaxNode, SyntaxToken)> {\n         let macro_call =\n             self.find_file(actual_macro_call.syntax().clone()).with_value(actual_macro_call);\n         let sa = self.analyze2(macro_call.map(|it| it.syntax()), None);\n         let macro_call_id = macro_call\n             .as_call_id(self.db, |path| sa.resolver.resolve_path_as_macro(self.db, &path))?;\n-        let macro_file = macro_call_id.as_file().macro_file().unwrap();\n-        let (tt, tmap_1) =\n-            hir_expand::syntax_node_to_token_tree(hypothetical_call.token_tree().unwrap().syntax())\n-                .unwrap();\n-        let range = token_to_map\n-            .text_range()\n-            .checked_sub(hypothetical_call.token_tree().unwrap().syntax().text_range().start())?;\n-        let token_id = tmap_1.token_by_range(range)?;\n-        let macro_def = hir_expand::db::expander(self.db, macro_call_id)?;\n-        let (node, tmap_2) = hir_expand::db::parse_macro_with_arg(\n-            self.db,\n-            macro_file,\n-            Some(std::sync::Arc::new((tt, tmap_1))),\n-        )?;\n-        let token_id = macro_def.0.map_id_down(token_id);\n-        let range = tmap_2.range_by_token(token_id)?.by_kind(token_to_map.kind())?;\n-        let token = algo::find_covering_element(&node.syntax_node(), range).into_token()?;\n-        Some((node.syntax_node(), token))\n+        hir_expand::db::expand_hypothetical(self.db, macro_call_id, hypothetical_args, token_to_map)\n     }\n \n     pub fn descend_into_macros(&self, token: SyntaxToken) -> SyntaxToken {"}, {"sha": "29dde3d807be977e2b8c40d4da3fa9b8f5abc479", "filename": "crates/ra_hir_expand/src/db.rs", "status": "modified", "additions": 34, "deletions": 9, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/afdf08e964345ac4a884a5630772611ba81f6969/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdf08e964345ac4a884a5630772611ba81f6969/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs?ref=afdf08e964345ac4a884a5630772611ba81f6969", "patch": "@@ -72,6 +72,30 @@ pub trait AstDatabase: SourceDatabase {\n     fn intern_eager_expansion(&self, eager: EagerCallLoc) -> EagerMacroId;\n }\n \n+/// This expands the given macro call, but with different arguments. This is\n+/// used for completion, where we want to see what 'would happen' if we insert a\n+/// token. The `token_to_map` mapped down into the expansion, with the mapped\n+/// token returned.\n+pub fn expand_hypothetical(\n+    db: &impl AstDatabase,\n+    actual_macro_call: MacroCallId,\n+    hypothetical_args: &ra_syntax::ast::TokenTree,\n+    token_to_map: ra_syntax::SyntaxToken,\n+) -> Option<(SyntaxNode, ra_syntax::SyntaxToken)> {\n+    let macro_file = MacroFile { macro_call_id: actual_macro_call };\n+    let (tt, tmap_1) = mbe::syntax_node_to_token_tree(hypothetical_args.syntax()).unwrap();\n+    let range =\n+        token_to_map.text_range().checked_sub(hypothetical_args.syntax().text_range().start())?;\n+    let token_id = tmap_1.token_by_range(range)?;\n+    let macro_def = expander(db, actual_macro_call)?;\n+    let (node, tmap_2) =\n+        parse_macro_with_arg(db, macro_file, Some(std::sync::Arc::new((tt, tmap_1))))?;\n+    let token_id = macro_def.0.map_id_down(token_id);\n+    let range = tmap_2.range_by_token(token_id)?.by_kind(token_to_map.kind())?;\n+    let token = ra_syntax::algo::find_covering_element(&node.syntax_node(), range).into_token()?;\n+    Some((node.syntax_node(), token))\n+}\n+\n pub(crate) fn ast_id_map(db: &dyn AstDatabase, file_id: HirFileId) -> Arc<AstIdMap> {\n     let map =\n         db.parse_or_expand(file_id).map_or_else(AstIdMap::default, |it| AstIdMap::from_source(&it));\n@@ -133,10 +157,7 @@ pub(crate) fn macro_expand(\n     macro_expand_with_arg(db, id, None)\n }\n \n-pub fn expander(\n-    db: &dyn AstDatabase,\n-    id: MacroCallId,\n-) -> Option<Arc<(TokenExpander, mbe::TokenMap)>> {\n+fn expander(db: &dyn AstDatabase, id: MacroCallId) -> Option<Arc<(TokenExpander, mbe::TokenMap)>> {\n     let lazy_id = match id {\n         MacroCallId::LazyMacro(id) => id,\n         MacroCallId::EagerMacro(_id) => {\n@@ -149,7 +170,7 @@ pub fn expander(\n     Some(macro_rules)\n }\n \n-pub(crate) fn macro_expand_with_arg(\n+fn macro_expand_with_arg(\n     db: &dyn AstDatabase,\n     id: MacroCallId,\n     arg: Option<Arc<(tt::Subtree, mbe::TokenMap)>>,\n@@ -158,7 +179,9 @@ pub(crate) fn macro_expand_with_arg(\n         MacroCallId::LazyMacro(id) => id,\n         MacroCallId::EagerMacro(id) => {\n             if arg.is_some() {\n-                return Err(\"hypothetical macro expansion not implemented for eager macro\".to_owned());\n+                return Err(\n+                    \"hypothetical macro expansion not implemented for eager macro\".to_owned()\n+                );\n             } else {\n                 return Ok(db.lookup_intern_eager_expansion(id).subtree);\n             }\n@@ -225,13 +248,15 @@ pub fn parse_macro_with_arg(\n                     .collect::<Vec<_>>()\n                     .join(\"\\n\");\n \n-                    eprintln!(\n+                    log::warn!(\n                         \"fail on macro_parse: (reason: {} macro_call: {:#}) parents: {}\",\n-                        err, node.value, parents\n+                        err,\n+                        node.value,\n+                        parents\n                     );\n                 }\n                 _ => {\n-                    eprintln!(\"fail on macro_parse: (reason: {})\", err);\n+                    log::warn!(\"fail on macro_parse: (reason: {})\", err);\n                 }\n             }\n         })"}, {"sha": "3fce73e8ad3507dc0eae3e050d13dfe983b24cff", "filename": "crates/ra_hir_expand/src/lib.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/afdf08e964345ac4a884a5630772611ba81f6969/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdf08e964345ac4a884a5630772611ba81f6969/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Flib.rs?ref=afdf08e964345ac4a884a5630772611ba81f6969", "patch": "@@ -157,13 +157,6 @@ impl HirFileId {\n             }\n         }\n     }\n-\n-    pub fn macro_file(self) -> Option<MacroFile> {\n-        match self.0 {\n-            HirFileIdRepr::FileId(_) => None,\n-            HirFileIdRepr::MacroFile(m) => Some(m),\n-        }\n-    }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -303,7 +296,7 @@ pub struct ExpansionInfo {\n     exp_map: Arc<mbe::TokenMap>,\n }\n \n-pub use mbe::{syntax_node_to_token_tree, Origin};\n+pub use mbe::Origin;\n use ra_parser::FragmentKind;\n \n impl ExpansionInfo {"}, {"sha": "40535c09e1cad5d903e44a07abb253d833391f29", "filename": "crates/ra_ide/src/completion/completion_context.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afdf08e964345ac4a884a5630772611ba81f6969/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdf08e964345ac4a884a5630772611ba81f6969/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=afdf08e964345ac4a884a5630772611ba81f6969", "patch": "@@ -119,11 +119,15 @@ impl<'a> CompletionContext<'a> {\n             {\n                 break;\n             }\n+            let hypothetical_args = match macro_call_with_fake_ident.token_tree() {\n+                Some(tt) => tt,\n+                None => break,\n+            };\n             if let (Some(actual_expansion), Some(hypothetical_expansion)) = (\n                 ctx.sema.expand(&actual_macro_call),\n                 ctx.sema.expand_hypothetical(\n                     &actual_macro_call,\n-                    &macro_call_with_fake_ident,\n+                    &hypothetical_args,\n                     fake_ident_token,\n                 ),\n             ) {"}]}