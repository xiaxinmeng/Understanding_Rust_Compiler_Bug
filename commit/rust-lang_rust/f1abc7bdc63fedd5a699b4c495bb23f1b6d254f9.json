{"sha": "f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxYWJjN2JkYzYzZmVkZDVhNjk5YjRjNDk1YmIyM2YxYjZkMjU0Zjk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-07-19T09:56:47Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-07-19T10:16:25Z"}, "message": "migrate ra_ide_api to the new rowan", "tree": {"sha": "9518c43f5ddeaa38426efddc17be19af5381f003", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9518c43f5ddeaa38426efddc17be19af5381f003"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9", "html_url": "https://github.com/rust-lang/rust/commit/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b", "html_url": "https://github.com/rust-lang/rust/commit/0343c4a815a0e82d5e55e76a01d21b0f7a00ff5b"}], "stats": {"total": 632, "additions": 342, "deletions": 290}, "files": [{"sha": "270499612bb216459a69d91fcb634a7d9222281d", "filename": "crates/ra_ide_api/src/call_info.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs?ref=f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9", "patch": "@@ -11,24 +11,24 @@ use crate::{db::RootDatabase, CallInfo, FilePosition, FunctionSignature};\n /// Computes parameter information for the given call expression.\n pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Option<CallInfo> {\n     let parse = db.parse(position.file_id);\n-    let syntax = parse.tree().syntax();\n+    let syntax = parse.tree().syntax().clone();\n \n     // Find the calling expression and it's NameRef\n-    let calling_node = FnCallNode::with_node(syntax, position.offset)?;\n+    let calling_node = FnCallNode::with_node(&syntax, position.offset)?;\n     let name_ref = calling_node.name_ref()?;\n \n     let analyzer = hir::SourceAnalyzer::new(db, position.file_id, name_ref.syntax(), None);\n-    let function = match calling_node {\n+    let function = match &calling_node {\n         FnCallNode::CallExpr(expr) => {\n             //FIXME: apply subst\n-            let (callable_def, _subst) = analyzer.type_of(db, expr.expr()?)?.as_callable()?;\n+            let (callable_def, _subst) = analyzer.type_of(db, &expr.expr()?)?.as_callable()?;\n             match callable_def {\n                 hir::CallableDef::Function(it) => it,\n                 //FIXME: handle other callables\n                 _ => return None,\n             }\n         }\n-        FnCallNode::MethodCallExpr(expr) => analyzer.resolve_method_call(expr)?,\n+        FnCallNode::MethodCallExpr(expr) => analyzer.resolve_method_call(&expr)?,\n     };\n \n     let mut call_info = CallInfo::new(db, function);\n@@ -73,13 +73,13 @@ pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Option<Cal\n     Some(call_info)\n }\n \n-enum FnCallNode<'a> {\n-    CallExpr(&'a ast::CallExpr),\n-    MethodCallExpr(&'a ast::MethodCallExpr),\n+enum FnCallNode {\n+    CallExpr(ast::CallExpr),\n+    MethodCallExpr(ast::MethodCallExpr),\n }\n \n-impl<'a> FnCallNode<'a> {\n-    fn with_node(syntax: &'a SyntaxNode, offset: TextUnit) -> Option<FnCallNode<'a>> {\n+impl FnCallNode {\n+    fn with_node(syntax: &SyntaxNode, offset: TextUnit) -> Option<FnCallNode> {\n         if let Some(expr) = find_node_at_offset::<ast::CallExpr>(syntax, offset) {\n             return Some(FnCallNode::CallExpr(expr));\n         }\n@@ -89,8 +89,8 @@ impl<'a> FnCallNode<'a> {\n         None\n     }\n \n-    fn name_ref(&self) -> Option<&'a ast::NameRef> {\n-        match *self {\n+    fn name_ref(&self) -> Option<ast::NameRef> {\n+        match self {\n             FnCallNode::CallExpr(call_expr) => Some(match call_expr.expr()?.kind() {\n                 ast::ExprKind::PathExpr(path_expr) => path_expr.path()?.segment()?.name_ref()?,\n                 _ => return None,\n@@ -102,8 +102,8 @@ impl<'a> FnCallNode<'a> {\n         }\n     }\n \n-    fn arg_list(&self) -> Option<&'a ast::ArgList> {\n-        match *self {\n+    fn arg_list(&self) -> Option<ast::ArgList> {\n+        match self {\n             FnCallNode::CallExpr(expr) => expr.arg_list(),\n             FnCallNode::MethodCallExpr(expr) => expr.arg_list(),\n         }"}, {"sha": "536ba36dff3e25f4ddd68c12111c076c0fb3ed9e", "filename": "crates/ra_ide_api/src/completion/complete_dot.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9", "patch": "@@ -5,10 +5,11 @@ use rustc_hash::FxHashSet;\n \n /// Complete dot accesses, i.e. fields or methods (currently only fields).\n pub(super) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) {\n-    let receiver_ty = match ctx.dot_receiver.and_then(|it| ctx.analyzer.type_of(ctx.db, it)) {\n-        Some(it) => it,\n-        None => return,\n-    };\n+    let receiver_ty =\n+        match ctx.dot_receiver.as_ref().and_then(|it| ctx.analyzer.type_of(ctx.db, it)) {\n+            Some(it) => it,\n+            None => return,\n+        };\n     if !ctx.is_call {\n         complete_fields(acc, ctx, receiver_ty.clone());\n     }"}, {"sha": "0887ef1f687f5eb276753061e3f91c7ba2ee3b15", "filename": "crates/ra_ide_api/src/completion/complete_fn_param.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs?ref=f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9", "patch": "@@ -20,7 +20,7 @@ pub(super) fn complete_fn_param(acc: &mut Completions, ctx: &CompletionContext)\n         let _ = visitor_ctx(&mut params)\n             .visit::<ast::SourceFile, _>(process)\n             .visit::<ast::ItemList, _>(process)\n-            .accept(node);\n+            .accept(&node);\n     }\n     params\n         .into_iter()\n@@ -38,10 +38,7 @@ pub(super) fn complete_fn_param(acc: &mut Completions, ctx: &CompletionContext)\n                 .add_to(acc)\n         });\n \n-    fn process<'a, N: ast::FnDefOwner>(\n-        node: &'a N,\n-        params: &mut FxHashMap<String, (u32, &'a ast::Param)>,\n-    ) {\n+    fn process<N: ast::FnDefOwner>(node: N, params: &mut FxHashMap<String, (u32, ast::Param)>) {\n         node.functions().filter_map(|it| it.param_list()).flat_map(|it| it.params()).for_each(\n             |param| {\n                 let text = param.syntax().text().to_string();"}, {"sha": "4cf34eff8a24b8007ebf8329ade3cc12b4bf2d14", "filename": "crates/ra_ide_api/src/completion/complete_keyword.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs?ref=f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9", "patch": "@@ -52,7 +52,7 @@ pub(super) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n         return;\n     }\n \n-    let fn_def = match ctx.function_syntax {\n+    let fn_def = match &ctx.function_syntax {\n         Some(it) => it,\n         None => return,\n     };\n@@ -65,7 +65,7 @@ pub(super) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n         acc.add(keyword(ctx, \"else\", \"else {$0}\"));\n         acc.add(keyword(ctx, \"else if\", \"else if $0 {}\"));\n     }\n-    if is_in_loop_body(ctx.token) {\n+    if is_in_loop_body(&ctx.token) {\n         if ctx.can_be_stmt {\n             acc.add(keyword(ctx, \"continue\", \"continue;\"));\n             acc.add(keyword(ctx, \"break\", \"break;\"));\n@@ -74,19 +74,19 @@ pub(super) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n             acc.add(keyword(ctx, \"break\", \"break\"));\n         }\n     }\n-    acc.add_all(complete_return(ctx, fn_def, ctx.can_be_stmt));\n+    acc.add_all(complete_return(ctx, &fn_def, ctx.can_be_stmt));\n }\n \n-fn is_in_loop_body(leaf: SyntaxToken) -> bool {\n+fn is_in_loop_body(leaf: &SyntaxToken) -> bool {\n     for node in leaf.parent().ancestors() {\n         if node.kind() == FN_DEF || node.kind() == LAMBDA_EXPR {\n             break;\n         }\n         let loop_body = visitor()\n-            .visit::<ast::ForExpr, _>(LoopBodyOwner::loop_body)\n-            .visit::<ast::WhileExpr, _>(LoopBodyOwner::loop_body)\n-            .visit::<ast::LoopExpr, _>(LoopBodyOwner::loop_body)\n-            .accept(node);\n+            .visit::<ast::ForExpr, _>(|it| it.loop_body())\n+            .visit::<ast::WhileExpr, _>(|it| it.loop_body())\n+            .visit::<ast::LoopExpr, _>(|it| it.loop_body())\n+            .accept(&node);\n         if let Some(Some(body)) = loop_body {\n             if leaf.range().is_subrange(&body.syntax().range()) {\n                 return true;"}, {"sha": "c75b1c159c3684b92387b65b6bae08614229d059", "filename": "crates/ra_ide_api/src/completion/complete_postfix.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs?ref=f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9", "patch": "@@ -11,7 +11,8 @@ use ra_text_edit::TextEditBuilder;\n \n fn postfix_snippet(ctx: &CompletionContext, label: &str, detail: &str, snippet: &str) -> Builder {\n     let edit = {\n-        let receiver_range = ctx.dot_receiver.expect(\"no receiver available\").syntax().range();\n+        let receiver_range =\n+            ctx.dot_receiver.as_ref().expect(\"no receiver available\").syntax().range();\n         let delete_range = TextRange::from_to(receiver_range.start(), ctx.source_range().end());\n         let mut builder = TextEditBuilder::default();\n         builder.replace(delete_range, snippet.to_string());\n@@ -38,9 +39,9 @@ fn is_bool_or_unknown(ty: Option<Ty>) -> bool {\n }\n \n pub(super) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n-    if let Some(dot_receiver) = ctx.dot_receiver {\n+    if let Some(dot_receiver) = &ctx.dot_receiver {\n         let receiver_text = dot_receiver.syntax().text().to_string();\n-        let receiver_ty = ctx.analyzer.type_of(ctx.db, dot_receiver);\n+        let receiver_ty = ctx.analyzer.type_of(ctx.db, &dot_receiver);\n         if is_bool_or_unknown(receiver_ty) {\n             postfix_snippet(ctx, \"if\", \"if expr {}\", &format!(\"if {} {{$0}}\", receiver_text))\n                 .add_to(acc);"}, {"sha": "f920340557c7a749719f89b9c76a897d7ddb9cf4", "filename": "crates/ra_ide_api/src/completion/complete_scope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs?ref=f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9", "patch": "@@ -20,8 +20,8 @@ pub(super) fn complete_scope(acc: &mut Completions, ctx: &CompletionContext) {\n                     let mut builder = TextEditBuilder::default();\n                     builder.replace(ctx.source_range(), name.to_string());\n                     auto_import::auto_import_text_edit(\n-                        ctx.token.parent(),\n-                        ctx.token.parent(),\n+                        &ctx.token.parent(),\n+                        &ctx.token.parent(),\n                         &path,\n                         &mut builder,\n                     );"}, {"sha": "9410f740ffe97864b1a59f1b47b8937e0bc310d8", "filename": "crates/ra_ide_api/src/completion/complete_struct_literal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_struct_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_struct_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_struct_literal.rs?ref=f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9", "patch": "@@ -4,8 +4,8 @@ use crate::completion::{CompletionContext, Completions};\n \n /// Complete fields in fields literals.\n pub(super) fn complete_struct_literal(acc: &mut Completions, ctx: &CompletionContext) {\n-    let (ty, variant) = match ctx.struct_lit_syntax.and_then(|it| {\n-        Some((ctx.analyzer.type_of(ctx.db, it.into())?, ctx.analyzer.resolve_variant(it)?))\n+    let (ty, variant) = match ctx.struct_lit_syntax.as_ref().and_then(|it| {\n+        Some((ctx.analyzer.type_of(ctx.db, &it.clone().into())?, ctx.analyzer.resolve_variant(it)?))\n     }) {\n         Some(it) => it,\n         _ => return,"}, {"sha": "b803271abaf28725dc83792fea189e09f0a5520f", "filename": "crates/ra_ide_api/src/completion/completion_context.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9", "patch": "@@ -16,11 +16,11 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) db: &'a db::RootDatabase,\n     pub(super) analyzer: hir::SourceAnalyzer,\n     pub(super) offset: TextUnit,\n-    pub(super) token: SyntaxToken<'a>,\n+    pub(super) token: SyntaxToken,\n     pub(super) module: Option<hir::Module>,\n-    pub(super) function_syntax: Option<&'a ast::FnDef>,\n-    pub(super) use_item_syntax: Option<&'a ast::UseItem>,\n-    pub(super) struct_lit_syntax: Option<&'a ast::StructLit>,\n+    pub(super) function_syntax: Option<ast::FnDef>,\n+    pub(super) use_item_syntax: Option<ast::UseItem>,\n+    pub(super) struct_lit_syntax: Option<ast::StructLit>,\n     pub(super) is_param: bool,\n     /// If a name-binding or reference to a const in a pattern.\n     /// Irrefutable patterns (like let) are excluded.\n@@ -35,7 +35,7 @@ pub(crate) struct CompletionContext<'a> {\n     /// Something is typed at the \"top\" level, in module or impl/trait.\n     pub(super) is_new_item: bool,\n     /// The receiver if this is a field or method access, i.e. writing something.<|>\n-    pub(super) dot_receiver: Option<&'a ast::Expr>,\n+    pub(super) dot_receiver: Option<ast::Expr>,\n     /// If this is a call (method or function) in particular, i.e. the () are already there.\n     pub(super) is_call: bool,\n }\n@@ -50,7 +50,7 @@ impl<'a> CompletionContext<'a> {\n         let token =\n             find_token_at_offset(original_parse.tree().syntax(), position.offset).left_biased()?;\n         let analyzer =\n-            hir::SourceAnalyzer::new(db, position.file_id, token.parent(), Some(position.offset));\n+            hir::SourceAnalyzer::new(db, position.file_id, &token.parent(), Some(position.offset));\n         let mut ctx = CompletionContext {\n             db,\n             analyzer,\n@@ -109,7 +109,7 @@ impl<'a> CompletionContext<'a> {\n             if is_node::<ast::BindPat>(name.syntax()) {\n                 let bind_pat = name.syntax().ancestors().find_map(ast::BindPat::cast).unwrap();\n                 let parent = bind_pat.syntax().parent();\n-                if parent.and_then(ast::MatchArm::cast).is_some()\n+                if parent.clone().and_then(ast::MatchArm::cast).is_some()\n                     || parent.and_then(ast::Condition::cast).is_some()\n                 {\n                     self.is_pat_binding = true;\n@@ -122,7 +122,7 @@ impl<'a> CompletionContext<'a> {\n         }\n     }\n \n-    fn classify_name_ref(&mut self, original_file: &'a SourceFile, name_ref: &ast::NameRef) {\n+    fn classify_name_ref(&mut self, original_file: SourceFile, name_ref: ast::NameRef) {\n         let name_range = name_ref.syntax().range();\n         if name_ref.syntax().parent().and_then(ast::NamedField::cast).is_some() {\n             self.struct_lit_syntax = find_node_at_offset(original_file.syntax(), self.offset);\n@@ -153,7 +153,7 @@ impl<'a> CompletionContext<'a> {\n             None => return,\n         };\n \n-        if let Some(segment) = ast::PathSegment::cast(parent) {\n+        if let Some(segment) = ast::PathSegment::cast(parent.clone()) {\n             let path = segment.parent_path();\n             self.is_call = path\n                 .syntax()\n@@ -162,7 +162,7 @@ impl<'a> CompletionContext<'a> {\n                 .and_then(|it| it.syntax().parent().and_then(ast::CallExpr::cast))\n                 .is_some();\n \n-            if let Some(mut path) = hir::Path::from_ast(path) {\n+            if let Some(mut path) = hir::Path::from_ast(path.clone()) {\n                 if !path.is_ident() {\n                     path.segments.pop().unwrap();\n                     self.path_prefix = Some(path);\n@@ -179,7 +179,7 @@ impl<'a> CompletionContext<'a> {\n                     .syntax()\n                     .ancestors()\n                     .find_map(|node| {\n-                        if let Some(stmt) = ast::ExprStmt::cast(node) {\n+                        if let Some(stmt) = ast::ExprStmt::cast(node.clone()) {\n                             return Some(stmt.syntax().range() == name_ref.syntax().range());\n                         }\n                         if let Some(block) = ast::Block::cast(node) {\n@@ -203,7 +203,7 @@ impl<'a> CompletionContext<'a> {\n                 }\n             }\n         }\n-        if let Some(field_expr) = ast::FieldExpr::cast(parent) {\n+        if let Some(field_expr) = ast::FieldExpr::cast(parent.clone()) {\n             // The receiver comes before the point of insertion of the fake\n             // ident, so it should have the same range in the non-modified file\n             self.dot_receiver = field_expr\n@@ -222,7 +222,7 @@ impl<'a> CompletionContext<'a> {\n     }\n }\n \n-fn find_node_with_range<N: AstNode>(syntax: &SyntaxNode, range: TextRange) -> Option<&N> {\n+fn find_node_with_range<N: AstNode>(syntax: &SyntaxNode, range: TextRange) -> Option<N> {\n     find_covering_element(syntax, range).ancestors().find_map(N::cast)\n }\n "}, {"sha": "affbad6cd05822d29cfc2effe8970fbe73cf8b89", "filename": "crates/ra_ide_api/src/diagnostics.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs?ref=f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9", "patch": "@@ -35,8 +35,8 @@ pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic>\n     }));\n \n     for node in parse.tree().syntax().descendants() {\n-        check_unnecessary_braces_in_use_statement(&mut res, file_id, node);\n-        check_struct_shorthand_initialization(&mut res, file_id, node);\n+        check_unnecessary_braces_in_use_statement(&mut res, file_id, &node);\n+        check_struct_shorthand_initialization(&mut res, file_id, &node);\n     }\n     let res = RefCell::new(res);\n     let mut sink = DiagnosticSink::new(|d| {\n@@ -60,7 +60,7 @@ pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic>\n     })\n     .on::<hir::diagnostics::MissingFields, _>(|d| {\n         let node = d.ast(db);\n-        let mut ast_editor = AstEditor::new(&*node);\n+        let mut ast_editor = AstEditor::new(node);\n         for f in d.missed_fields.iter() {\n             ast_editor.append_field(&AstBuilder::<NamedField>::from_name(f));\n         }\n@@ -94,11 +94,11 @@ fn check_unnecessary_braces_in_use_statement(\n     file_id: FileId,\n     node: &SyntaxNode,\n ) -> Option<()> {\n-    let use_tree_list = ast::UseTreeList::cast(node)?;\n+    let use_tree_list = ast::UseTreeList::cast(node.clone())?;\n     if let Some((single_use_tree,)) = use_tree_list.use_trees().collect_tuple() {\n         let range = use_tree_list.syntax().range();\n         let edit =\n-            text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(single_use_tree)\n+            text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(&single_use_tree)\n                 .unwrap_or_else(|| {\n                     let to_replace = single_use_tree.syntax().text().to_string();\n                     let mut edit_builder = TextEditBuilder::default();\n@@ -141,7 +141,7 @@ fn check_struct_shorthand_initialization(\n     file_id: FileId,\n     node: &SyntaxNode,\n ) -> Option<()> {\n-    let struct_lit = ast::StructLit::cast(node)?;\n+    let struct_lit = ast::StructLit::cast(node.clone())?;\n     let named_field_list = struct_lit.named_field_list()?;\n     for named_field in named_field_list.fields() {\n         if let (Some(name_ref), Some(expr)) = (named_field.name_ref(), named_field.expr()) {\n@@ -184,7 +184,7 @@ mod tests {\n         let parse = SourceFile::parse(code);\n         let mut diagnostics = Vec::new();\n         for node in parse.tree().syntax().descendants() {\n-            func(&mut diagnostics, FileId(0), node);\n+            func(&mut diagnostics, FileId(0), &node);\n         }\n         assert!(diagnostics.is_empty());\n     }\n@@ -193,7 +193,7 @@ mod tests {\n         let parse = SourceFile::parse(before);\n         let mut diagnostics = Vec::new();\n         for node in parse.tree().syntax().descendants() {\n-            func(&mut diagnostics, FileId(0), node);\n+            func(&mut diagnostics, FileId(0), &node);\n         }\n         let diagnostic =\n             diagnostics.pop().unwrap_or_else(|| panic!(\"no diagnostics for:\\n{}\\n\", before));"}, {"sha": "644a4532b61d8c55857657ccb5c693bf61660032", "filename": "crates/ra_ide_api/src/display/function_signature.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Ffunction_signature.rs?ref=f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9", "patch": "@@ -38,7 +38,7 @@ impl FunctionSignature {\n     pub(crate) fn from_hir(db: &db::RootDatabase, function: hir::Function) -> Self {\n         let doc = function.docs(db);\n         let ast_node = function.source(db).ast;\n-        FunctionSignature::from(&*ast_node).with_doc_opt(doc)\n+        FunctionSignature::from(&ast_node).with_doc_opt(doc)\n     }\n }\n "}, {"sha": "8cc853dd143871b0a97ba6e70cbdeab645cda513", "filename": "crates/ra_ide_api/src/display/navigation_target.rs", "status": "modified", "additions": 26, "deletions": 30, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs?ref=f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9", "patch": "@@ -5,7 +5,7 @@ use ra_syntax::{\n     ast::{self, DocCommentsOwner},\n     AstNode, AstPtr, SmolStr,\n     SyntaxKind::{self, NAME},\n-    SyntaxNode, TextRange, TreeArc,\n+    SyntaxNode, TextRange,\n };\n \n use super::short_label::ShortLabel;\n@@ -169,7 +169,7 @@ impl NavigationTarget {\n         let file_id = src.file_id.original_file(db);\n         match src.ast {\n             FieldSource::Named(it) => {\n-                NavigationTarget::from_named(file_id, &*it, it.doc_comment_text(), it.short_label())\n+                NavigationTarget::from_named(file_id, &it, it.doc_comment_text(), it.short_label())\n             }\n             FieldSource::Pos(it) => {\n                 NavigationTarget::from_syntax(file_id, \"\".into(), None, it.syntax(), None, None)\n@@ -179,13 +179,13 @@ impl NavigationTarget {\n \n     pub(crate) fn from_def_source<A, D>(db: &RootDatabase, def: D) -> NavigationTarget\n     where\n-        D: HasSource<Ast = TreeArc<A>>,\n+        D: HasSource<Ast = A>,\n         A: ast::DocCommentsOwner + ast::NameOwner + ShortLabel,\n     {\n         let src = def.source(db);\n         NavigationTarget::from_named(\n             src.file_id.original_file(db),\n-            &*src.ast,\n+            &src.ast,\n             src.ast.doc_comment_text(),\n             src.ast.short_label(),\n         )\n@@ -249,7 +249,7 @@ impl NavigationTarget {\n         log::debug!(\"nav target {}\", src.ast.syntax().debug_dump());\n         NavigationTarget::from_named(\n             src.file_id.original_file(db),\n-            &*src.ast,\n+            &src.ast,\n             src.ast.doc_comment_text(),\n             None,\n         )\n@@ -318,22 +318,18 @@ pub(crate) fn docs_from_symbol(db: &RootDatabase, symbol: &FileSymbol) -> Option\n     let parse = db.parse(symbol.file_id);\n     let node = symbol.ptr.to_node(parse.tree().syntax()).to_owned();\n \n-    fn doc_comments<N: ast::DocCommentsOwner>(node: &N) -> Option<String> {\n-        node.doc_comment_text()\n-    }\n-\n     visitor()\n-        .visit(doc_comments::<ast::FnDef>)\n-        .visit(doc_comments::<ast::StructDef>)\n-        .visit(doc_comments::<ast::EnumDef>)\n-        .visit(doc_comments::<ast::TraitDef>)\n-        .visit(doc_comments::<ast::Module>)\n-        .visit(doc_comments::<ast::TypeAliasDef>)\n-        .visit(doc_comments::<ast::ConstDef>)\n-        .visit(doc_comments::<ast::StaticDef>)\n-        .visit(doc_comments::<ast::NamedFieldDef>)\n-        .visit(doc_comments::<ast::EnumVariant>)\n-        .visit(doc_comments::<ast::MacroCall>)\n+        .visit(|it: ast::FnDef| it.doc_comment_text())\n+        .visit(|it: ast::StructDef| it.doc_comment_text())\n+        .visit(|it: ast::EnumDef| it.doc_comment_text())\n+        .visit(|it: ast::TraitDef| it.doc_comment_text())\n+        .visit(|it: ast::Module| it.doc_comment_text())\n+        .visit(|it: ast::TypeAliasDef| it.doc_comment_text())\n+        .visit(|it: ast::ConstDef| it.doc_comment_text())\n+        .visit(|it: ast::StaticDef| it.doc_comment_text())\n+        .visit(|it: ast::NamedFieldDef| it.doc_comment_text())\n+        .visit(|it: ast::EnumVariant| it.doc_comment_text())\n+        .visit(|it: ast::MacroCall| it.doc_comment_text())\n         .accept(&node)?\n }\n \n@@ -345,15 +341,15 @@ pub(crate) fn description_from_symbol(db: &RootDatabase, symbol: &FileSymbol) ->\n     let node = symbol.ptr.to_node(parse.tree().syntax()).to_owned();\n \n     visitor()\n-        .visit(|node: &ast::FnDef| node.short_label())\n-        .visit(|node: &ast::StructDef| node.short_label())\n-        .visit(|node: &ast::EnumDef| node.short_label())\n-        .visit(|node: &ast::TraitDef| node.short_label())\n-        .visit(|node: &ast::Module| node.short_label())\n-        .visit(|node: &ast::TypeAliasDef| node.short_label())\n-        .visit(|node: &ast::ConstDef| node.short_label())\n-        .visit(|node: &ast::StaticDef| node.short_label())\n-        .visit(|node: &ast::NamedFieldDef| node.short_label())\n-        .visit(|node: &ast::EnumVariant| node.short_label())\n+        .visit(|node: ast::FnDef| node.short_label())\n+        .visit(|node: ast::StructDef| node.short_label())\n+        .visit(|node: ast::EnumDef| node.short_label())\n+        .visit(|node: ast::TraitDef| node.short_label())\n+        .visit(|node: ast::Module| node.short_label())\n+        .visit(|node: ast::TypeAliasDef| node.short_label())\n+        .visit(|node: ast::ConstDef| node.short_label())\n+        .visit(|node: ast::StaticDef| node.short_label())\n+        .visit(|node: ast::NamedFieldDef| node.short_label())\n+        .visit(|node: ast::EnumVariant| node.short_label())\n         .accept(&node)?\n }"}, {"sha": "2e183d2f60fc25620aa6a53b44f226cb554d5c80", "filename": "crates/ra_ide_api/src/display/structure.rs", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fstructure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fstructure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fstructure.rs?ref=f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9", "patch": "@@ -24,14 +24,14 @@ pub fn file_structure(file: &SourceFile) -> Vec<StructureNode> {\n     for event in file.syntax().preorder() {\n         match event {\n             WalkEvent::Enter(node) => {\n-                if let Some(mut symbol) = structure_node(node) {\n+                if let Some(mut symbol) = structure_node(&node) {\n                     symbol.parent = stack.last().copied();\n                     stack.push(res.len());\n                     res.push(symbol);\n                 }\n             }\n             WalkEvent::Leave(node) => {\n-                if structure_node(node).is_some() {\n+                if structure_node(&node).is_some() {\n                     stack.pop().unwrap();\n                 }\n             }\n@@ -41,19 +41,20 @@ pub fn file_structure(file: &SourceFile) -> Vec<StructureNode> {\n }\n \n fn structure_node(node: &SyntaxNode) -> Option<StructureNode> {\n-    fn decl<N: NameOwner + AttrsOwner>(node: &N) -> Option<StructureNode> {\n+    fn decl<N: NameOwner + AttrsOwner>(node: N) -> Option<StructureNode> {\n         decl_with_detail(node, None)\n     }\n \n     fn decl_with_ascription<N: NameOwner + AttrsOwner + TypeAscriptionOwner>(\n-        node: &N,\n+        node: N,\n     ) -> Option<StructureNode> {\n-        decl_with_type_ref(node, node.ascribed_type())\n+        let ty = node.ascribed_type();\n+        decl_with_type_ref(node, ty)\n     }\n \n     fn decl_with_type_ref<N: NameOwner + AttrsOwner>(\n-        node: &N,\n-        type_ref: Option<&ast::TypeRef>,\n+        node: N,\n+        type_ref: Option<ast::TypeRef>,\n     ) -> Option<StructureNode> {\n         let detail = type_ref.map(|type_ref| {\n             let mut detail = String::new();\n@@ -64,7 +65,7 @@ fn structure_node(node: &SyntaxNode) -> Option<StructureNode> {\n     }\n \n     fn decl_with_detail<N: NameOwner + AttrsOwner>(\n-        node: &N,\n+        node: N,\n         detail: Option<String>,\n     ) -> Option<StructureNode> {\n         let name = node.name()?;\n@@ -82,22 +83,24 @@ fn structure_node(node: &SyntaxNode) -> Option<StructureNode> {\n \n     fn collapse_ws(node: &SyntaxNode, output: &mut String) {\n         let mut can_insert_ws = false;\n-        for line in node.text().chunks().flat_map(|chunk| chunk.lines()) {\n-            let line = line.trim();\n-            if line.is_empty() {\n-                if can_insert_ws {\n-                    output.push_str(\" \");\n-                    can_insert_ws = false;\n+        for chunk in node.text().chunks() {\n+            for line in chunk.lines() {\n+                let line = line.trim();\n+                if line.is_empty() {\n+                    if can_insert_ws {\n+                        output.push_str(\" \");\n+                        can_insert_ws = false;\n+                    }\n+                } else {\n+                    output.push_str(line);\n+                    can_insert_ws = true;\n                 }\n-            } else {\n-                output.push_str(line);\n-                can_insert_ws = true;\n             }\n         }\n     }\n \n     visitor()\n-        .visit(|fn_def: &ast::FnDef| {\n+        .visit(|fn_def: ast::FnDef| {\n             let mut detail = String::from(\"fn\");\n             if let Some(type_param_list) = fn_def.type_param_list() {\n                 collapse_ws(type_param_list.syntax(), &mut detail);\n@@ -117,11 +120,14 @@ fn structure_node(node: &SyntaxNode) -> Option<StructureNode> {\n         .visit(decl::<ast::EnumVariant>)\n         .visit(decl::<ast::TraitDef>)\n         .visit(decl::<ast::Module>)\n-        .visit(|td: &ast::TypeAliasDef| decl_with_type_ref(td, td.type_ref()))\n+        .visit(|td: ast::TypeAliasDef| {\n+            let ty = td.type_ref();\n+            decl_with_type_ref(td, ty)\n+        })\n         .visit(decl_with_ascription::<ast::NamedFieldDef>)\n         .visit(decl_with_ascription::<ast::ConstDef>)\n         .visit(decl_with_ascription::<ast::StaticDef>)\n-        .visit(|im: &ast::ImplBlock| {\n+        .visit(|im: ast::ImplBlock| {\n             let target_type = im.target_type()?;\n             let target_trait = im.target_trait();\n             let label = match target_trait {\n@@ -142,14 +148,14 @@ fn structure_node(node: &SyntaxNode) -> Option<StructureNode> {\n             };\n             Some(node)\n         })\n-        .visit(|mc: &ast::MacroCall| {\n+        .visit(|mc: ast::MacroCall| {\n             let first_token = mc.syntax().first_token().unwrap();\n             if first_token.text().as_str() != \"macro_rules\" {\n                 return None;\n             }\n             decl(mc)\n         })\n-        .accept(node)?\n+        .accept(&node)?\n }\n \n #[cfg(test)]"}, {"sha": "8c49960f529a93a0037c1b6fb7540bb4c4e4f21f", "filename": "crates/ra_ide_api/src/extend_selection.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fextend_selection.rs?ref=f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9", "patch": "@@ -42,7 +42,7 @@ fn try_extend_selection(root: &SyntaxNode, range: TextRange) -> Option<TextRange\n             TokenAtOffset::None => return None,\n             TokenAtOffset::Single(l) => {\n                 if string_kinds.contains(&l.kind()) {\n-                    extend_single_word_in_comment_or_string(l, offset).unwrap_or_else(|| l.range())\n+                    extend_single_word_in_comment_or_string(&l, offset).unwrap_or_else(|| l.range())\n                 } else {\n                     l.range()\n                 }\n@@ -56,7 +56,7 @@ fn try_extend_selection(root: &SyntaxNode, range: TextRange) -> Option<TextRange\n             if token.range() != range {\n                 return Some(token.range());\n             }\n-            if let Some(comment) = ast::Comment::cast(token) {\n+            if let Some(comment) = ast::Comment::cast(token.clone()) {\n                 if let Some(range) = extend_comments(comment) {\n                     return Some(range);\n                 }\n@@ -73,7 +73,7 @@ fn try_extend_selection(root: &SyntaxNode, range: TextRange) -> Option<TextRange\n     let node = node.ancestors().take_while(|n| n.range() == node.range()).last().unwrap();\n \n     if node.parent().map(|n| list_kinds.contains(&n.kind())) == Some(true) {\n-        if let Some(range) = extend_list_item(node) {\n+        if let Some(range) = extend_list_item(&node) {\n             return Some(range);\n         }\n     }\n@@ -82,7 +82,7 @@ fn try_extend_selection(root: &SyntaxNode, range: TextRange) -> Option<TextRange\n }\n \n fn extend_single_word_in_comment_or_string(\n-    leaf: SyntaxToken,\n+    leaf: &SyntaxToken,\n     offset: TextUnit,\n ) -> Option<TextRange> {\n     let text: &str = leaf.text();\n@@ -131,9 +131,9 @@ fn extend_ws(root: &SyntaxNode, ws: SyntaxToken, offset: TextUnit) -> TextRange\n     ws.range()\n }\n \n-fn pick_best<'a>(l: SyntaxToken<'a>, r: SyntaxToken<'a>) -> SyntaxToken<'a> {\n-    return if priority(r) > priority(l) { r } else { l };\n-    fn priority(n: SyntaxToken) -> usize {\n+fn pick_best<'a>(l: SyntaxToken, r: SyntaxToken) -> SyntaxToken {\n+    return if priority(&r) > priority(&l) { r } else { l };\n+    fn priority(n: &SyntaxToken) -> usize {\n         match n.kind() {\n             WHITESPACE => 0,\n             IDENT | T![self] | T![super] | T![crate] | LIFETIME => 2,\n@@ -156,7 +156,7 @@ fn extend_list_item(node: &SyntaxNode) -> Option<TextRange> {\n                 SyntaxElement::Token(it) => is_single_line_ws(it),\n             })\n             .next()\n-            .and_then(|it| it.as_token())\n+            .and_then(|it| it.as_token().cloned())\n             .filter(|node| node.kind() == T![,])\n     }\n \n@@ -167,7 +167,7 @@ fn extend_list_item(node: &SyntaxNode) -> Option<TextRange> {\n         // Include any following whitespace when comma if after list item.\n         let final_node = comma_node\n             .next_sibling_or_token()\n-            .and_then(|it| it.as_token())\n+            .and_then(|it| it.as_token().cloned())\n             .filter(|node| is_single_line_ws(node))\n             .unwrap_or(comma_node);\n \n@@ -178,23 +178,23 @@ fn extend_list_item(node: &SyntaxNode) -> Option<TextRange> {\n }\n \n fn extend_comments(comment: ast::Comment) -> Option<TextRange> {\n-    let prev = adj_comments(comment, Direction::Prev);\n-    let next = adj_comments(comment, Direction::Next);\n+    let prev = adj_comments(&comment, Direction::Prev);\n+    let next = adj_comments(&comment, Direction::Next);\n     if prev != next {\n         Some(TextRange::from_to(prev.syntax().range().start(), next.syntax().range().end()))\n     } else {\n         None\n     }\n }\n \n-fn adj_comments(comment: ast::Comment, dir: Direction) -> ast::Comment {\n-    let mut res = comment;\n+fn adj_comments(comment: &ast::Comment, dir: Direction) -> ast::Comment {\n+    let mut res = comment.clone();\n     for element in comment.syntax().siblings_with_tokens(dir) {\n         let token = match element.as_token() {\n             None => break,\n             Some(token) => token,\n         };\n-        if let Some(c) = ast::Comment::cast(token) {\n+        if let Some(c) = ast::Comment::cast(token.clone()) {\n             res = c\n         } else if token.kind() != WHITESPACE || token.text().contains(\"\\n\\n\") {\n             break;"}, {"sha": "c2b981aedc100f3646c8c1ac79040b4648bc96a3", "filename": "crates/ra_ide_api/src/folding_ranges.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Ffolding_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Ffolding_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Ffolding_ranges.rs?ref=f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9", "patch": "@@ -30,7 +30,7 @@ pub(crate) fn folding_ranges(file: &SourceFile) -> Vec<Fold> {\n     for element in file.syntax().descendants_with_tokens() {\n         // Fold items that span multiple lines\n         if let Some(kind) = fold_kind(element.kind()) {\n-            let is_multiline = match element {\n+            let is_multiline = match &element {\n                 SyntaxElement::Node(node) => node.text().contains('\\n'),\n                 SyntaxElement::Token(token) => token.text().contains('\\n'),\n             };\n@@ -56,7 +56,7 @@ pub(crate) fn folding_ranges(file: &SourceFile) -> Vec<Fold> {\n             SyntaxElement::Node(node) => {\n                 // Fold groups of imports\n                 if node.kind() == USE_ITEM && !visited_imports.contains(&node) {\n-                    if let Some(range) = contiguous_range_for_group(node, &mut visited_imports) {\n+                    if let Some(range) = contiguous_range_for_group(&node, &mut visited_imports) {\n                         res.push(Fold { range, kind: FoldKind::Imports })\n                     }\n                 }\n@@ -65,7 +65,7 @@ pub(crate) fn folding_ranges(file: &SourceFile) -> Vec<Fold> {\n                 if node.kind() == MODULE && !has_visibility(&node) && !visited_mods.contains(&node)\n                 {\n                     if let Some(range) =\n-                        contiguous_range_for_group_unless(node, has_visibility, &mut visited_mods)\n+                        contiguous_range_for_group_unless(&node, has_visibility, &mut visited_mods)\n                     {\n                         res.push(Fold { range, kind: FoldKind::Mods })\n                     }\n@@ -88,24 +88,24 @@ fn fold_kind(kind: SyntaxKind) -> Option<FoldKind> {\n }\n \n fn has_visibility(node: &SyntaxNode) -> bool {\n-    ast::Module::cast(node).and_then(|m| m.visibility()).is_some()\n+    ast::Module::cast(node.clone()).and_then(|m| m.visibility()).is_some()\n }\n \n-fn contiguous_range_for_group<'a>(\n-    first: &'a SyntaxNode,\n-    visited: &mut FxHashSet<&'a SyntaxNode>,\n+fn contiguous_range_for_group(\n+    first: &SyntaxNode,\n+    visited: &mut FxHashSet<SyntaxNode>,\n ) -> Option<TextRange> {\n     contiguous_range_for_group_unless(first, |_| false, visited)\n }\n \n-fn contiguous_range_for_group_unless<'a>(\n-    first: &'a SyntaxNode,\n-    unless: impl Fn(&'a SyntaxNode) -> bool,\n-    visited: &mut FxHashSet<&'a SyntaxNode>,\n+fn contiguous_range_for_group_unless(\n+    first: &SyntaxNode,\n+    unless: impl Fn(&SyntaxNode) -> bool,\n+    visited: &mut FxHashSet<SyntaxNode>,\n ) -> Option<TextRange> {\n-    visited.insert(first);\n+    visited.insert(first.clone());\n \n-    let mut last = first;\n+    let mut last = first.clone();\n     for element in first.siblings_with_tokens(Direction::Next) {\n         let node = match element {\n             SyntaxElement::Token(token) => {\n@@ -123,47 +123,47 @@ fn contiguous_range_for_group_unless<'a>(\n         };\n \n         // Stop if we find a node that doesn't belong to the group\n-        if node.kind() != first.kind() || unless(node) {\n+        if node.kind() != first.kind() || unless(&node) {\n             break;\n         }\n \n-        visited.insert(node);\n+        visited.insert(node.clone());\n         last = node;\n     }\n \n-    if first != last {\n+    if first != &last {\n         Some(TextRange::from_to(first.range().start(), last.range().end()))\n     } else {\n         // The group consists of only one element, therefore it cannot be folded\n         None\n     }\n }\n \n-fn contiguous_range_for_comment<'a>(\n-    first: ast::Comment<'a>,\n-    visited: &mut FxHashSet<ast::Comment<'a>>,\n+fn contiguous_range_for_comment(\n+    first: ast::Comment,\n+    visited: &mut FxHashSet<ast::Comment>,\n ) -> Option<TextRange> {\n-    visited.insert(first);\n+    visited.insert(first.clone());\n \n     // Only fold comments of the same flavor\n     let group_kind = first.kind();\n     if !group_kind.shape.is_line() {\n         return None;\n     }\n \n-    let mut last = first;\n+    let mut last = first.clone();\n     for element in first.syntax().siblings_with_tokens(Direction::Next) {\n         match element {\n             SyntaxElement::Token(token) => {\n-                if let Some(ws) = ast::Whitespace::cast(token) {\n+                if let Some(ws) = ast::Whitespace::cast(token.clone()) {\n                     if !ws.spans_multiple_lines() {\n                         // Ignore whitespace without blank lines\n                         continue;\n                     }\n                 }\n                 if let Some(c) = ast::Comment::cast(token) {\n                     if c.kind() == group_kind {\n-                        visited.insert(c);\n+                        visited.insert(c.clone());\n                         last = c;\n                         continue;\n                     }\n@@ -193,7 +193,7 @@ mod tests {\n     fn do_check(text: &str, fold_kinds: &[FoldKind]) {\n         let (ranges, text) = extract_ranges(text, \"fold\");\n         let parse = SourceFile::parse(&text);\n-        let folds = folding_ranges(parse.tree());\n+        let folds = folding_ranges(&parse.tree());\n \n         assert_eq!(\n             folds.len(),"}, {"sha": "82b5e3b5e173b5592ae3bb39a1e482239c9df578", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 78, "deletions": 28, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9", "patch": "@@ -20,13 +20,13 @@ pub(crate) fn goto_definition(\n     position: FilePosition,\n ) -> Option<RangeInfo<Vec<NavigationTarget>>> {\n     let parse = db.parse(position.file_id);\n-    let syntax = parse.tree().syntax();\n-    if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(syntax, position.offset) {\n-        let navs = reference_definition(db, position.file_id, name_ref).to_vec();\n+    let syntax = parse.tree().syntax().clone();\n+    if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(&syntax, position.offset) {\n+        let navs = reference_definition(db, position.file_id, &name_ref).to_vec();\n         return Some(RangeInfo::new(name_ref.syntax().range(), navs.to_vec()));\n     }\n-    if let Some(name) = find_node_at_offset::<ast::Name>(syntax, position.offset) {\n-        let navs = name_definition(db, position.file_id, name)?;\n+    if let Some(name) = find_node_at_offset::<ast::Name>(&syntax, position.offset) {\n+        let navs = name_definition(db, position.file_id, &name)?;\n         return Some(RangeInfo::new(name.syntax().range(), navs));\n     }\n     None\n@@ -94,7 +94,7 @@ pub(crate) fn name_definition(\n ) -> Option<Vec<NavigationTarget>> {\n     let parent = name.syntax().parent()?;\n \n-    if let Some(module) = ast::Module::cast(&parent) {\n+    if let Some(module) = ast::Module::cast(parent.clone()) {\n         if module.has_semi() {\n             if let Some(child_module) =\n                 hir::source_binder::module_from_declaration(db, file_id, module)\n@@ -114,38 +114,88 @@ pub(crate) fn name_definition(\n \n fn named_target(file_id: FileId, node: &SyntaxNode) -> Option<NavigationTarget> {\n     visitor()\n-        .visit(|node: &ast::StructDef| {\n-            NavigationTarget::from_named(file_id, node, node.doc_comment_text(), node.short_label())\n+        .visit(|node: ast::StructDef| {\n+            NavigationTarget::from_named(\n+                file_id,\n+                &node,\n+                node.doc_comment_text(),\n+                node.short_label(),\n+            )\n         })\n-        .visit(|node: &ast::EnumDef| {\n-            NavigationTarget::from_named(file_id, node, node.doc_comment_text(), node.short_label())\n+        .visit(|node: ast::EnumDef| {\n+            NavigationTarget::from_named(\n+                file_id,\n+                &node,\n+                node.doc_comment_text(),\n+                node.short_label(),\n+            )\n         })\n-        .visit(|node: &ast::EnumVariant| {\n-            NavigationTarget::from_named(file_id, node, node.doc_comment_text(), node.short_label())\n+        .visit(|node: ast::EnumVariant| {\n+            NavigationTarget::from_named(\n+                file_id,\n+                &node,\n+                node.doc_comment_text(),\n+                node.short_label(),\n+            )\n         })\n-        .visit(|node: &ast::FnDef| {\n-            NavigationTarget::from_named(file_id, node, node.doc_comment_text(), node.short_label())\n+        .visit(|node: ast::FnDef| {\n+            NavigationTarget::from_named(\n+                file_id,\n+                &node,\n+                node.doc_comment_text(),\n+                node.short_label(),\n+            )\n         })\n-        .visit(|node: &ast::TypeAliasDef| {\n-            NavigationTarget::from_named(file_id, node, node.doc_comment_text(), node.short_label())\n+        .visit(|node: ast::TypeAliasDef| {\n+            NavigationTarget::from_named(\n+                file_id,\n+                &node,\n+                node.doc_comment_text(),\n+                node.short_label(),\n+            )\n         })\n-        .visit(|node: &ast::ConstDef| {\n-            NavigationTarget::from_named(file_id, node, node.doc_comment_text(), node.short_label())\n+        .visit(|node: ast::ConstDef| {\n+            NavigationTarget::from_named(\n+                file_id,\n+                &node,\n+                node.doc_comment_text(),\n+                node.short_label(),\n+            )\n         })\n-        .visit(|node: &ast::StaticDef| {\n-            NavigationTarget::from_named(file_id, node, node.doc_comment_text(), node.short_label())\n+        .visit(|node: ast::StaticDef| {\n+            NavigationTarget::from_named(\n+                file_id,\n+                &node,\n+                node.doc_comment_text(),\n+                node.short_label(),\n+            )\n         })\n-        .visit(|node: &ast::TraitDef| {\n-            NavigationTarget::from_named(file_id, node, node.doc_comment_text(), node.short_label())\n+        .visit(|node: ast::TraitDef| {\n+            NavigationTarget::from_named(\n+                file_id,\n+                &node,\n+                node.doc_comment_text(),\n+                node.short_label(),\n+            )\n         })\n-        .visit(|node: &ast::NamedFieldDef| {\n-            NavigationTarget::from_named(file_id, node, node.doc_comment_text(), node.short_label())\n+        .visit(|node: ast::NamedFieldDef| {\n+            NavigationTarget::from_named(\n+                file_id,\n+                &node,\n+                node.doc_comment_text(),\n+                node.short_label(),\n+            )\n         })\n-        .visit(|node: &ast::Module| {\n-            NavigationTarget::from_named(file_id, node, node.doc_comment_text(), node.short_label())\n+        .visit(|node: ast::Module| {\n+            NavigationTarget::from_named(\n+                file_id,\n+                &node,\n+                node.doc_comment_text(),\n+                node.short_label(),\n+            )\n         })\n-        .visit(|node: &ast::MacroCall| {\n-            NavigationTarget::from_named(file_id, node, node.doc_comment_text(), None)\n+        .visit(|node: ast::MacroCall| {\n+            NavigationTarget::from_named(file_id, &node, node.doc_comment_text(), None)\n         })\n         .accept(node)\n }"}, {"sha": "fc4b6e1af59c6c8b34508e36463b031c71147ae6", "filename": "crates/ra_ide_api/src/goto_type_definition.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fgoto_type_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fgoto_type_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_type_definition.rs?ref=f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9", "patch": "@@ -13,15 +13,17 @@ pub(crate) fn goto_type_definition(\n         token\n             .parent()\n             .ancestors()\n-            .find(|n| ast::Expr::cast(*n).is_some() || ast::Pat::cast(*n).is_some())\n+            .find(|n| ast::Expr::cast(n.clone()).is_some() || ast::Pat::cast(n.clone()).is_some())\n     })?;\n \n-    let analyzer = hir::SourceAnalyzer::new(db, position.file_id, node, None);\n+    let analyzer = hir::SourceAnalyzer::new(db, position.file_id, &node, None);\n \n-    let ty: hir::Ty = if let Some(ty) = ast::Expr::cast(node).and_then(|e| analyzer.type_of(db, e))\n+    let ty: hir::Ty = if let Some(ty) =\n+        ast::Expr::cast(node.clone()).and_then(|e| analyzer.type_of(db, &e))\n     {\n         ty\n-    } else if let Some(ty) = ast::Pat::cast(node).and_then(|p| analyzer.type_of_pat(db, p)) {\n+    } else if let Some(ty) = ast::Pat::cast(node.clone()).and_then(|p| analyzer.type_of_pat(db, &p))\n+    {\n         ty\n     } else {\n         return None;"}, {"sha": "e503bf6a96aa4aa1a8bf0f12fb0e8c635ceab3e4", "filename": "crates/ra_ide_api/src/hover.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fhover.rs?ref=f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9", "patch": "@@ -6,7 +6,7 @@ use ra_syntax::{\n         visit::{visitor, Visitor},\n     },\n     ast::{self, DocCommentsOwner},\n-    AstNode, TreeArc,\n+    AstNode,\n };\n \n use crate::{\n@@ -104,7 +104,7 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n \n         let mut no_fallback = false;\n \n-        match classify_name_ref(db, &analyzer, name_ref) {\n+        match classify_name_ref(db, &analyzer, &name_ref) {\n             Some(Method(it)) => res.extend(from_def_source(db, it)),\n             Some(Macro(it)) => {\n                 let src = it.source(db);\n@@ -163,7 +163,7 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n \n         if res.is_empty() && !no_fallback {\n             // Fallback index based approach:\n-            let symbols = crate::symbol_index::index_resolve(db, name_ref);\n+            let symbols = crate::symbol_index::index_resolve(db, &name_ref);\n             for sym in symbols {\n                 let docs = docs_from_symbol(db, &sym);\n                 let desc = description_from_symbol(db, &sym);\n@@ -177,34 +177,32 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n     } else if let Some(name) = find_node_at_offset::<ast::Name>(file.syntax(), position.offset) {\n         if let Some(parent) = name.syntax().parent() {\n             let text = visitor()\n-                .visit(|node: &ast::StructDef| {\n+                .visit(|node: ast::StructDef| {\n                     hover_text(node.doc_comment_text(), node.short_label())\n                 })\n-                .visit(|node: &ast::EnumDef| {\n+                .visit(|node: ast::EnumDef| hover_text(node.doc_comment_text(), node.short_label()))\n+                .visit(|node: ast::EnumVariant| {\n                     hover_text(node.doc_comment_text(), node.short_label())\n                 })\n-                .visit(|node: &ast::EnumVariant| {\n+                .visit(|node: ast::FnDef| hover_text(node.doc_comment_text(), node.short_label()))\n+                .visit(|node: ast::TypeAliasDef| {\n                     hover_text(node.doc_comment_text(), node.short_label())\n                 })\n-                .visit(|node: &ast::FnDef| hover_text(node.doc_comment_text(), node.short_label()))\n-                .visit(|node: &ast::TypeAliasDef| {\n+                .visit(|node: ast::ConstDef| {\n                     hover_text(node.doc_comment_text(), node.short_label())\n                 })\n-                .visit(|node: &ast::ConstDef| {\n+                .visit(|node: ast::StaticDef| {\n                     hover_text(node.doc_comment_text(), node.short_label())\n                 })\n-                .visit(|node: &ast::StaticDef| {\n+                .visit(|node: ast::TraitDef| {\n                     hover_text(node.doc_comment_text(), node.short_label())\n                 })\n-                .visit(|node: &ast::TraitDef| {\n+                .visit(|node: ast::NamedFieldDef| {\n                     hover_text(node.doc_comment_text(), node.short_label())\n                 })\n-                .visit(|node: &ast::NamedFieldDef| {\n-                    hover_text(node.doc_comment_text(), node.short_label())\n-                })\n-                .visit(|node: &ast::Module| hover_text(node.doc_comment_text(), node.short_label()))\n-                .visit(|node: &ast::MacroCall| hover_text(node.doc_comment_text(), None))\n-                .accept(parent);\n+                .visit(|node: ast::Module| hover_text(node.doc_comment_text(), node.short_label()))\n+                .visit(|node: ast::MacroCall| hover_text(node.doc_comment_text(), None))\n+                .accept(&parent);\n \n             if let Some(text) = text {\n                 res.extend(text);\n@@ -217,8 +215,9 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n     }\n \n     if range.is_none() {\n-        let node = ancestors_at_offset(file.syntax(), position.offset)\n-            .find(|n| ast::Expr::cast(*n).is_some() || ast::Pat::cast(*n).is_some())?;\n+        let node = ancestors_at_offset(file.syntax(), position.offset).find(|n| {\n+            ast::Expr::cast(n.clone()).is_some() || ast::Pat::cast(n.clone()).is_some()\n+        })?;\n         let frange = FileRange { file_id: position.file_id, range: node.range() };\n         res.extend(type_of(db, frange).map(rust_code_markup));\n         range = Some(node.range());\n@@ -233,7 +232,7 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n \n     fn from_def_source<A, D>(db: &RootDatabase, def: D) -> Option<String>\n     where\n-        D: HasSource<Ast = TreeArc<A>>,\n+        D: HasSource<Ast = A>,\n         A: ast::DocCommentsOwner + ast::NameOwner + ShortLabel,\n     {\n         let src = def.source(db);\n@@ -243,17 +242,17 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n \n pub(crate) fn type_of(db: &RootDatabase, frange: FileRange) -> Option<String> {\n     let parse = db.parse(frange.file_id);\n-    let syntax = parse.tree().syntax();\n-    let leaf_node = find_covering_element(syntax, frange.range);\n+    let leaf_node = find_covering_element(parse.tree().syntax(), frange.range);\n     // if we picked identifier, expand to pattern/expression\n     let node = leaf_node\n         .ancestors()\n         .take_while(|it| it.range() == leaf_node.range())\n-        .find(|&it| ast::Expr::cast(it).is_some() || ast::Pat::cast(it).is_some())?;\n-    let analyzer = hir::SourceAnalyzer::new(db, frange.file_id, node, None);\n-    let ty = if let Some(ty) = ast::Expr::cast(node).and_then(|e| analyzer.type_of(db, e)) {\n+        .find(|it| ast::Expr::cast(it.clone()).is_some() || ast::Pat::cast(it.clone()).is_some())?;\n+    let analyzer = hir::SourceAnalyzer::new(db, frange.file_id, &node, None);\n+    let ty = if let Some(ty) = ast::Expr::cast(node.clone()).and_then(|e| analyzer.type_of(db, &e))\n+    {\n         ty\n-    } else if let Some(ty) = ast::Pat::cast(node).and_then(|p| analyzer.type_of_pat(db, p)) {\n+    } else if let Some(ty) = ast::Pat::cast(node).and_then(|p| analyzer.type_of_pat(db, &p)) {\n         ty\n     } else {\n         return None;"}, {"sha": "15999d4331adc5ebe6bdad12ea6989bf9aa1cc92", "filename": "crates/ra_ide_api/src/impls.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs?ref=f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9", "patch": "@@ -9,19 +9,19 @@ pub(crate) fn goto_implementation(\n     position: FilePosition,\n ) -> Option<RangeInfo<Vec<NavigationTarget>>> {\n     let parse = db.parse(position.file_id);\n-    let syntax = parse.tree().syntax();\n+    let syntax = parse.tree().syntax().clone();\n \n     let module = source_binder::module_from_position(db, position)?;\n \n-    if let Some(nominal_def) = find_node_at_offset::<ast::NominalDef>(syntax, position.offset) {\n+    if let Some(nominal_def) = find_node_at_offset::<ast::NominalDef>(&syntax, position.offset) {\n         return Some(RangeInfo::new(\n             nominal_def.syntax().range(),\n-            impls_for_def(db, nominal_def, module)?,\n+            impls_for_def(db, &nominal_def, module)?,\n         ));\n-    } else if let Some(trait_def) = find_node_at_offset::<ast::TraitDef>(syntax, position.offset) {\n+    } else if let Some(trait_def) = find_node_at_offset::<ast::TraitDef>(&syntax, position.offset) {\n         return Some(RangeInfo::new(\n             trait_def.syntax().range(),\n-            impls_for_trait(db, trait_def, module)?,\n+            impls_for_trait(db, &trait_def, module)?,\n         ));\n     }\n "}, {"sha": "50bcfb5b76a1436a962f556e6bd7fc4a92d9b360", "filename": "crates/ra_ide_api/src/join_lines.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fjoin_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fjoin_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fjoin_lines.rs?ref=f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9", "patch": "@@ -27,7 +27,7 @@ pub fn join_lines(file: &SourceFile, range: TextRange) -> TextEdit {\n         SyntaxElement::Token(token) => token.parent(),\n     };\n     let mut edit = TextEditBuilder::default();\n-    for token in node.descendants_with_tokens().filter_map(|it| it.as_token()) {\n+    for token in node.descendants_with_tokens().filter_map(|it| it.as_token().cloned()) {\n         let range = match range.intersection(&token.range()) {\n             Some(range) => range,\n             None => continue,\n@@ -37,15 +37,15 @@ pub fn join_lines(file: &SourceFile, range: TextRange) -> TextEdit {\n             let pos: TextUnit = (pos as u32).into();\n             let off = token.range().start() + range.start() + pos;\n             if !edit.invalidates_offset(off) {\n-                remove_newline(&mut edit, token, off);\n+                remove_newline(&mut edit, &token, off);\n             }\n         }\n     }\n \n     edit.finish()\n }\n \n-fn remove_newline(edit: &mut TextEditBuilder, token: SyntaxToken, offset: TextUnit) {\n+fn remove_newline(edit: &mut TextEditBuilder, token: &SyntaxToken, offset: TextUnit) {\n     if token.kind() != WHITESPACE || token.text().bytes().filter(|&b| b == b'\\n').count() != 1 {\n         // The node is either the first or the last in the file\n         let suff = &token.text()[TextRange::from_to(\n@@ -98,9 +98,10 @@ fn remove_newline(edit: &mut TextEditBuilder, token: SyntaxToken, offset: TextUn\n             TextRange::from_to(prev.range().start(), token.range().end()),\n             space.to_string(),\n         );\n-    } else if let (Some(_), Some(next)) =\n-        (prev.as_token().and_then(ast::Comment::cast), next.as_token().and_then(ast::Comment::cast))\n-    {\n+    } else if let (Some(_), Some(next)) = (\n+        prev.as_token().cloned().and_then(ast::Comment::cast),\n+        next.as_token().cloned().and_then(ast::Comment::cast),\n+    ) {\n         // Removes: newline (incl. surrounding whitespace), start of the next comment\n         edit.delete(TextRange::from_to(\n             token.range().start(),\n@@ -113,16 +114,16 @@ fn remove_newline(edit: &mut TextEditBuilder, token: SyntaxToken, offset: TextUn\n }\n \n fn has_comma_after(node: &SyntaxNode) -> bool {\n-    match non_trivia_sibling(node.into(), Direction::Next) {\n+    match non_trivia_sibling(node.clone().into(), Direction::Next) {\n         Some(n) => n.kind() == T![,],\n         _ => false,\n     }\n }\n \n-fn join_single_expr_block(edit: &mut TextEditBuilder, token: SyntaxToken) -> Option<()> {\n+fn join_single_expr_block(edit: &mut TextEditBuilder, token: &SyntaxToken) -> Option<()> {\n     let block = ast::Block::cast(token.parent())?;\n     let block_expr = ast::BlockExpr::cast(block.syntax().parent()?)?;\n-    let expr = extract_trivial_expression(block)?;\n+    let expr = extract_trivial_expression(&block)?;\n \n     let block_range = block_expr.syntax().range();\n     let mut buf = expr.syntax().text().to_string();\n@@ -139,7 +140,7 @@ fn join_single_expr_block(edit: &mut TextEditBuilder, token: SyntaxToken) -> Opt\n     Some(())\n }\n \n-fn join_single_use_tree(edit: &mut TextEditBuilder, token: SyntaxToken) -> Option<()> {\n+fn join_single_use_tree(edit: &mut TextEditBuilder, token: &SyntaxToken) -> Option<()> {\n     let use_tree_list = ast::UseTreeList::cast(token.parent())?;\n     let (tree,) = use_tree_list.use_trees().collect_tuple()?;\n     edit.replace(use_tree_list.syntax().range(), tree.syntax().text().to_string());\n@@ -504,7 +505,7 @@ fn foo() {\n     fn check_join_lines_sel(before: &str, after: &str) {\n         let (sel, before) = extract_range(before);\n         let parse = SourceFile::parse(&before);\n-        let result = join_lines(parse.tree(), sel);\n+        let result = join_lines(&parse.tree(), sel);\n         let actual = result.apply(&before);\n         assert_eq_text!(after, &actual);\n     }"}, {"sha": "c54d574bcc5db2bbd0f4f668f18186c7c0b95cc5", "filename": "crates/ra_ide_api/src/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Flib.rs?ref=f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9", "patch": "@@ -50,7 +50,7 @@ use ra_db::{\n     salsa::{self, ParallelDatabase},\n     CheckCanceled, SourceDatabase,\n };\n-use ra_syntax::{SourceFile, TextRange, TextUnit, TreeArc};\n+use ra_syntax::{SourceFile, TextRange, TextUnit};\n use ra_text_edit::TextEdit;\n use relative_path::RelativePathBuf;\n \n@@ -325,8 +325,8 @@ impl Analysis {\n     }\n \n     /// Gets the syntax tree of the file.\n-    pub fn parse(&self, file_id: FileId) -> TreeArc<SourceFile> {\n-        self.db.parse(file_id).tree().to_owned()\n+    pub fn parse(&self, file_id: FileId) -> SourceFile {\n+        self.db.parse(file_id).tree()\n     }\n \n     /// Gets the file's `LineIndex`: data structure to convert between absolute\n@@ -360,7 +360,7 @@ impl Analysis {\n         let parse = self.db.parse(frange.file_id);\n         let file_edit = SourceFileEdit {\n             file_id: frange.file_id,\n-            edit: join_lines::join_lines(parse.tree(), frange.range),\n+            edit: join_lines::join_lines(&parse.tree(), frange.range),\n         };\n         SourceChange::source_file_edit(\"join lines\", file_edit)\n     }\n@@ -393,13 +393,13 @@ impl Analysis {\n     /// file outline.\n     pub fn file_structure(&self, file_id: FileId) -> Vec<StructureNode> {\n         let parse = self.db.parse(file_id);\n-        file_structure(parse.tree())\n+        file_structure(&parse.tree())\n     }\n \n     /// Returns the set of folding ranges.\n     pub fn folding_ranges(&self, file_id: FileId) -> Vec<Fold> {\n         let parse = self.db.parse(file_id);\n-        folding_ranges::folding_ranges(parse.tree())\n+        folding_ranges::folding_ranges(&parse.tree())\n     }\n \n     /// Fuzzy searches for a symbol."}, {"sha": "102327fd73930fb3e968042aa4e7ded506813f70", "filename": "crates/ra_ide_api/src/matching_brace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fmatching_brace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fmatching_brace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fmatching_brace.rs?ref=f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9", "patch": "@@ -26,7 +26,7 @@ mod tests {\n         fn do_check(before: &str, after: &str) {\n             let (pos, before) = extract_offset(before);\n             let parse = SourceFile::parse(&before);\n-            let new_pos = match matching_brace(parse.tree(), pos) {\n+            let new_pos = match matching_brace(&parse.tree(), pos) {\n                 None => pos,\n                 Some(pos) => pos,\n             };"}, {"sha": "6832acf5dd22fbc4872c0d9eb2ca39cee3681374", "filename": "crates/ra_ide_api/src/name_ref_kind.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fname_ref_kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fname_ref_kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fname_ref_kind.rs?ref=f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9", "patch": "@@ -26,7 +26,7 @@ pub(crate) fn classify_name_ref(\n     // Check if it is a method\n     if let Some(method_call) = name_ref.syntax().parent().and_then(ast::MethodCallExpr::cast) {\n         tested_by!(goto_definition_works_for_methods);\n-        if let Some(func) = analyzer.resolve_method_call(method_call) {\n+        if let Some(func) = analyzer.resolve_method_call(&method_call) {\n             return Some(Method(func));\n         }\n     }\n@@ -40,15 +40,15 @@ pub(crate) fn classify_name_ref(\n         .and_then(ast::MacroCall::cast)\n     {\n         tested_by!(goto_definition_works_for_macros);\n-        if let Some(mac) = analyzer.resolve_macro_call(db, macro_call) {\n+        if let Some(mac) = analyzer.resolve_macro_call(db, &macro_call) {\n             return Some(Macro(mac));\n         }\n     }\n \n     // It could also be a field access\n     if let Some(field_expr) = name_ref.syntax().parent().and_then(ast::FieldExpr::cast) {\n         tested_by!(goto_definition_works_for_fields);\n-        if let Some(field) = analyzer.resolve_field(field_expr) {\n+        if let Some(field) = analyzer.resolve_field(&field_expr) {\n             return Some(FieldAccess(field));\n         };\n     }\n@@ -59,7 +59,7 @@ pub(crate) fn classify_name_ref(\n \n         let struct_lit = field_expr.syntax().ancestors().find_map(ast::StructLit::cast);\n \n-        if let Some(ty) = struct_lit.and_then(|lit| analyzer.type_of(db, lit.into())) {\n+        if let Some(ty) = struct_lit.and_then(|lit| analyzer.type_of(db, &lit.into())) {\n             if let Some((hir::AdtDef::Struct(s), _)) = ty.as_adt() {\n                 let hir_path = hir::Path::from_name_ref(name_ref);\n                 let hir_name = hir_path.as_ident().unwrap();\n@@ -73,7 +73,7 @@ pub(crate) fn classify_name_ref(\n \n     // General case, a path or a local:\n     if let Some(path) = name_ref.syntax().ancestors().find_map(ast::Path::cast) {\n-        if let Some(resolved) = analyzer.resolve_path(db, path) {\n+        if let Some(resolved) = analyzer.resolve_path(db, &path) {\n             return match resolved {\n                 hir::PathResolution::Def(def) => Some(Def(def)),\n                 hir::PathResolution::LocalBinding(Either::A(pat)) => Some(Pat(pat)),"}, {"sha": "1c4cd49dccebf9a48d0a08911bbdfc264cf9435f", "filename": "crates/ra_ide_api/src/references.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences.rs?ref=f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9", "patch": "@@ -50,11 +50,11 @@ pub(crate) fn find_all_refs(\n     position: FilePosition,\n ) -> Option<ReferenceSearchResult> {\n     let parse = db.parse(position.file_id);\n-    let (binding, analyzer) = find_binding(db, parse.tree(), position)?;\n-    let declaration = NavigationTarget::from_bind_pat(position.file_id, binding);\n+    let (binding, analyzer) = find_binding(db, &parse.tree(), position)?;\n+    let declaration = NavigationTarget::from_bind_pat(position.file_id, &binding);\n \n     let references = analyzer\n-        .find_all_refs(binding)\n+        .find_all_refs(&binding)\n         .into_iter()\n         .map(move |ref_desc| FileRange { file_id: position.file_id, range: ref_desc.range })\n         .collect::<Vec<_>>();\n@@ -63,17 +63,17 @@ pub(crate) fn find_all_refs(\n \n     fn find_binding<'a>(\n         db: &RootDatabase,\n-        source_file: &'a SourceFile,\n+        source_file: &SourceFile,\n         position: FilePosition,\n-    ) -> Option<(&'a ast::BindPat, hir::SourceAnalyzer)> {\n+    ) -> Option<(ast::BindPat, hir::SourceAnalyzer)> {\n         let syntax = source_file.syntax();\n         if let Some(binding) = find_node_at_offset::<ast::BindPat>(syntax, position.offset) {\n             let analyzer = hir::SourceAnalyzer::new(db, position.file_id, binding.syntax(), None);\n             return Some((binding, analyzer));\n         };\n         let name_ref = find_node_at_offset::<ast::NameRef>(syntax, position.offset)?;\n         let analyzer = hir::SourceAnalyzer::new(db, position.file_id, name_ref.syntax(), None);\n-        let resolved = analyzer.resolve_local_name(name_ref)?;\n+        let resolved = analyzer.resolve_local_name(&name_ref)?;\n         if let Either::A(ptr) = resolved.ptr() {\n             if let ast::PatKind::BindPat(binding) = ptr.to_node(source_file.syntax()).kind() {\n                 return Some((binding, analyzer));\n@@ -89,10 +89,10 @@ pub(crate) fn rename(\n     new_name: &str,\n ) -> Option<SourceChange> {\n     let parse = db.parse(position.file_id);\n-    let syntax = parse.tree().syntax();\n-\n-    if let Some((ast_name, ast_module)) = find_name_and_module_at_offset(syntax, position) {\n-        rename_mod(db, ast_name, ast_module, position, new_name)\n+    if let Some((ast_name, ast_module)) =\n+        find_name_and_module_at_offset(parse.tree().syntax(), position)\n+    {\n+        rename_mod(db, &ast_name, &ast_module, position, new_name)\n     } else {\n         rename_reference(db, position, new_name)\n     }\n@@ -101,14 +101,10 @@ pub(crate) fn rename(\n fn find_name_and_module_at_offset(\n     syntax: &SyntaxNode,\n     position: FilePosition,\n-) -> Option<(&ast::Name, &ast::Module)> {\n-    let ast_name = find_node_at_offset::<ast::Name>(syntax, position.offset);\n-    let ast_name_parent = ast::Module::cast(ast_name?.syntax().parent()?);\n-\n-    if let (Some(ast_module), Some(name)) = (ast_name_parent, ast_name) {\n-        return Some((name, ast_module));\n-    }\n-    None\n+) -> Option<(ast::Name, ast::Module)> {\n+    let ast_name = find_node_at_offset::<ast::Name>(syntax, position.offset)?;\n+    let ast_module = ast::Module::cast(ast_name.syntax().parent()?)?;\n+    Some((ast_name, ast_module))\n }\n \n fn source_edit_from_fileid_range(\n@@ -135,7 +131,8 @@ fn rename_mod(\n ) -> Option<SourceChange> {\n     let mut source_file_edits = Vec::new();\n     let mut file_system_edits = Vec::new();\n-    if let Some(module) = source_binder::module_from_declaration(db, position.file_id, &ast_module)\n+    if let Some(module) =\n+        source_binder::module_from_declaration(db, position.file_id, ast_module.clone())\n     {\n         let src = module.definition_source(db);\n         let file_id = src.file_id.as_original_file();"}, {"sha": "2009584341fcda9f7981b3fe13e6e25b1a23695c", "filename": "crates/ra_ide_api/src/runnables.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs?ref=f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9", "patch": "@@ -26,8 +26,8 @@ pub(crate) fn runnables(db: &RootDatabase, file_id: FileId) -> Vec<Runnable> {\n     parse.tree().syntax().descendants().filter_map(|i| runnable(db, file_id, i)).collect()\n }\n \n-fn runnable(db: &RootDatabase, file_id: FileId, item: &SyntaxNode) -> Option<Runnable> {\n-    if let Some(fn_def) = ast::FnDef::cast(item) {\n+fn runnable(db: &RootDatabase, file_id: FileId, item: SyntaxNode) -> Option<Runnable> {\n+    if let Some(fn_def) = ast::FnDef::cast(item.clone()) {\n         runnable_fn(fn_def)\n     } else if let Some(m) = ast::Module::cast(item) {\n         runnable_mod(db, file_id, m)\n@@ -36,8 +36,8 @@ fn runnable(db: &RootDatabase, file_id: FileId, item: &SyntaxNode) -> Option<Run\n     }\n }\n \n-fn runnable_fn(fn_def: &ast::FnDef) -> Option<Runnable> {\n-    let name = fn_def.name()?.text();\n+fn runnable_fn(fn_def: ast::FnDef) -> Option<Runnable> {\n+    let name = fn_def.name()?.text().clone();\n     let kind = if name == \"main\" {\n         RunnableKind::Bin\n     } else if fn_def.has_atom_attr(\"test\") {\n@@ -50,7 +50,7 @@ fn runnable_fn(fn_def: &ast::FnDef) -> Option<Runnable> {\n     Some(Runnable { range: fn_def.syntax().range(), kind })\n }\n \n-fn runnable_mod(db: &RootDatabase, file_id: FileId, module: &ast::Module) -> Option<Runnable> {\n+fn runnable_mod(db: &RootDatabase, file_id: FileId, module: ast::Module) -> Option<Runnable> {\n     let has_test_function = module\n         .item_list()?\n         .items()"}, {"sha": "d533d1742c46fb27939bcc1ea7c50a4fb527e808", "filename": "crates/ra_ide_api/src/status.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fstatus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fstatus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fstatus.rs?ref=f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9", "patch": "@@ -104,7 +104,7 @@ impl FromIterator<TableEntry<MacroFile, Option<Parse<SyntaxNode>>>> for SyntaxTr\n         let mut res = SyntaxTreeStats::default();\n         for entry in iter {\n             res.total += 1;\n-            if let Some(tree) = entry.value.and_then(|it| it).map(|it| it.tree().to_owned()) {\n+            if let Some(tree) = entry.value.and_then(|it| it).map(|it| it.syntax_node()) {\n                 res.retained += 1;\n                 res.retained_size += tree.memory_size_of_subtree();\n             }"}, {"sha": "e784b5f69a19ff6921ebf23c7529c68b619900ee", "filename": "crates/ra_ide_api/src/symbol_index.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsymbol_index.rs?ref=f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9", "patch": "@@ -61,7 +61,7 @@ fn file_symbols(db: &impl SymbolsDatabase, file_id: FileId) -> Arc<SymbolIndex>\n     db.check_canceled();\n     let parse = db.parse(file_id);\n \n-    let symbols = source_file_to_file_symbols(parse.tree(), file_id);\n+    let symbols = source_file_to_file_symbols(&parse.tree(), file_id);\n \n     // FIXME: add macros here\n \n@@ -173,7 +173,7 @@ impl SymbolIndex {\n         files: impl ParallelIterator<Item = (FileId, Parse<ast::SourceFile>)>,\n     ) -> SymbolIndex {\n         let symbols = files\n-            .flat_map(|(file_id, file)| source_file_to_file_symbols(file.tree(), file_id))\n+            .flat_map(|(file_id, file)| source_file_to_file_symbols(&file.tree(), file_id))\n             .collect::<Vec<_>>();\n         SymbolIndex::new(symbols)\n     }\n@@ -249,7 +249,7 @@ fn source_file_to_file_symbols(source_file: &SourceFile, file_id: FileId) -> Vec\n     for event in source_file.syntax().preorder() {\n         match event {\n             WalkEvent::Enter(node) => {\n-                if let Some(mut symbol) = to_file_symbol(node, file_id) {\n+                if let Some(mut symbol) = to_file_symbol(&node, file_id) {\n                     symbol.container_name = stack.last().cloned();\n \n                     stack.push(symbol.name.clone());\n@@ -258,7 +258,7 @@ fn source_file_to_file_symbols(source_file: &SourceFile, file_id: FileId) -> Vec\n             }\n \n             WalkEvent::Leave(node) => {\n-                if to_symbol(node).is_some() {\n+                if to_symbol(&node).is_some() {\n                     stack.pop();\n                 }\n             }\n@@ -269,7 +269,7 @@ fn source_file_to_file_symbols(source_file: &SourceFile, file_id: FileId) -> Vec\n }\n \n fn to_symbol(node: &SyntaxNode) -> Option<(SmolStr, SyntaxNodePtr, TextRange)> {\n-    fn decl<N: NameOwner>(node: &N) -> Option<(SmolStr, SyntaxNodePtr, TextRange)> {\n+    fn decl<N: NameOwner>(node: N) -> Option<(SmolStr, SyntaxNodePtr, TextRange)> {\n         let name = node.name()?;\n         let name_range = name.syntax().range();\n         let name = name.text().clone();"}, {"sha": "16a7287899fc6a5944b2aa1c88f894df7566ba09", "filename": "crates/ra_ide_api/src/syntax_highlighting.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs?ref=f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9", "patch": "@@ -31,8 +31,8 @@ fn is_control_keyword(kind: SyntaxKind) -> bool {\n     }\n }\n \n-fn is_variable_mutable(db: &RootDatabase, analyzer: &hir::SourceAnalyzer, pat: &ast::Pat) -> bool {\n-    let ty = analyzer.type_of_pat(db, pat).unwrap_or(Ty::Unknown);\n+fn is_variable_mutable(db: &RootDatabase, analyzer: &hir::SourceAnalyzer, pat: ast::Pat) -> bool {\n+    let ty = analyzer.type_of_pat(db, &pat).unwrap_or(Ty::Unknown);\n     let is_ty_mut = {\n         if let Some((_, mutability)) = ty.as_reference() {\n             match mutability {\n@@ -55,7 +55,7 @@ fn is_variable_mutable(db: &RootDatabase, analyzer: &hir::SourceAnalyzer, pat: &\n pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRange> {\n     let _p = profile(\"highlight\");\n     let parse = db.parse(file_id);\n-    let root = parse.tree().syntax();\n+    let root = parse.tree().syntax().clone();\n \n     fn calc_binding_hash(file_id: FileId, text: &SmolStr, shadow_count: u32) -> u64 {\n         fn hash<T: std::hash::Hash + std::fmt::Debug>(x: T) -> u64 {\n@@ -70,6 +70,7 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRa\n     }\n \n     // Visited nodes to handle highlighting priorities\n+    // FIXME: retain only ranges here\n     let mut highlighted: FxHashSet<SyntaxElement> = FxHashSet::default();\n     let mut bindings_shadow_count: FxHashMap<SmolStr, u32> = FxHashMap::default();\n \n@@ -84,14 +85,14 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRa\n             STRING | RAW_STRING | RAW_BYTE_STRING | BYTE_STRING => \"string\",\n             ATTR => \"attribute\",\n             NAME_REF => {\n-                if let Some(name_ref) = node.as_node().and_then(ast::NameRef::cast) {\n+                if let Some(name_ref) = node.as_node().cloned().and_then(ast::NameRef::cast) {\n                     // FIXME: revisit this after #1340\n                     use crate::name_ref_kind::{classify_name_ref, NameRefKind::*};\n                     use hir::{ImplItem, ModuleDef};\n \n                     // FIXME: try to reuse the SourceAnalyzers\n                     let analyzer = hir::SourceAnalyzer::new(db, file_id, name_ref.syntax(), None);\n-                    match classify_name_ref(db, &analyzer, name_ref) {\n+                    match classify_name_ref(db, &analyzer, &name_ref) {\n                         Some(Method(_)) => \"function\",\n                         Some(Macro(_)) => \"macro\",\n                         Some(FieldAccess(_)) => \"field\",\n@@ -113,13 +114,13 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRa\n                         Some(Pat(ptr)) => {\n                             binding_hash = Some({\n                                 let text =\n-                                    ptr.syntax_node_ptr().to_node(root).text().to_smol_string();\n+                                    ptr.syntax_node_ptr().to_node(&root).text().to_smol_string();\n                                 let shadow_count =\n                                     bindings_shadow_count.entry(text.clone()).or_default();\n                                 calc_binding_hash(file_id, &text, *shadow_count)\n                             });\n \n-                            if is_variable_mutable(db, &analyzer, ptr.to_node(root)) {\n+                            if is_variable_mutable(db, &analyzer, ptr.to_node(&root)) {\n                                 \"variable.mut\"\n                             } else {\n                                 \"variable\"\n@@ -134,7 +135,7 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRa\n                 }\n             }\n             NAME => {\n-                if let Some(name) = node.as_node().and_then(ast::Name::cast) {\n+                if let Some(name) = node.as_node().cloned().and_then(ast::Name::cast) {\n                     let analyzer = hir::SourceAnalyzer::new(db, file_id, name.syntax(), None);\n                     if let Some(pat) = name.syntax().ancestors().find_map(ast::Pat::cast) {\n                         binding_hash = Some({\n@@ -176,12 +177,11 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRa\n             k if is_control_keyword(k) => \"keyword.control\",\n             k if k.is_keyword() => \"keyword\",\n             _ => {\n-                // let analyzer = hir::SourceAnalyzer::new(db, file_id, name_ref.syntax(), None);\n-                if let Some(macro_call) = node.as_node().and_then(ast::MacroCall::cast) {\n+                if let Some(macro_call) = node.as_node().cloned().and_then(ast::MacroCall::cast) {\n                     if let Some(path) = macro_call.path() {\n                         if let Some(segment) = path.segment() {\n                             if let Some(name_ref) = segment.name_ref() {\n-                                highlighted.insert(name_ref.syntax().into());\n+                                highlighted.insert(name_ref.syntax().clone().into());\n                                 let range_start = name_ref.syntax().range().start();\n                                 let mut range_end = name_ref.syntax().range().end();\n                                 for sibling in path.syntax().siblings_with_tokens(Direction::Next) {\n@@ -230,7 +230,8 @@ pub(crate) fn highlight_as_html(db: &RootDatabase, file_id: FileId, rainbow: boo\n     let mut buf = String::new();\n     buf.push_str(&STYLE);\n     buf.push_str(\"<pre><code>\");\n-    let tokens = parse.tree().syntax().descendants_with_tokens().filter_map(|it| it.as_token());\n+    let tokens =\n+        parse.tree().syntax().descendants_with_tokens().filter_map(|it| it.as_token().cloned());\n     for token in tokens {\n         could_intersect.retain(|it| token.range().start() <= it.range.end());\n         while let Some(r) = ranges.get(frontier) {"}, {"sha": "3d7373d02bce1879d392b6a105b3785b6343efdf", "filename": "crates/ra_ide_api/src/syntax_tree.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fsyntax_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Fsyntax_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsyntax_tree.rs?ref=f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9", "patch": "@@ -18,7 +18,7 @@ pub(crate) fn syntax_tree(\n         let node = match algo::find_covering_element(parse.tree().syntax(), text_range) {\r\n             SyntaxElement::Node(node) => node,\r\n             SyntaxElement::Token(token) => {\r\n-                if let Some(tree) = syntax_tree_for_string(token, text_range) {\r\n+                if let Some(tree) = syntax_tree_for_string(&token, text_range) {\r\n                     return tree;\r\n                 }\r\n                 token.parent()\r\n@@ -33,7 +33,7 @@ pub(crate) fn syntax_tree(\n \r\n /// Attempts parsing the selected contents of a string literal\r\n /// as rust syntax and returns its syntax tree\r\n-fn syntax_tree_for_string(token: SyntaxToken, text_range: TextRange) -> Option<String> {\r\n+fn syntax_tree_for_string(token: &SyntaxToken, text_range: TextRange) -> Option<String> {\r\n     // When the range is inside a string\r\n     // we'll attempt parsing it as rust syntax\r\n     // to provide the syntax tree of the contents of the string\r\n@@ -43,7 +43,7 @@ fn syntax_tree_for_string(token: SyntaxToken, text_range: TextRange) -> Option<S\n     }\r\n }\r\n \r\n-fn syntax_tree_for_token(node: SyntaxToken, text_range: TextRange) -> Option<String> {\r\n+fn syntax_tree_for_token(node: &SyntaxToken, text_range: TextRange) -> Option<String> {\r\n     // Range of the full node\r\n     let node_range = node.range();\r\n     let text = node.text().to_string();\r"}, {"sha": "ad0ababcc0aa2d7a8cc115b21b657a325547d735", "filename": "crates/ra_ide_api/src/typing.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9/crates%2Fra_ide_api%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Ftyping.rs?ref=f1abc7bdc63fedd5a699b4c495bb23f1b6d254f9", "patch": "@@ -1,15 +1,16 @@\n-use crate::{db::RootDatabase, SourceChange, SourceFileEdit};\n use ra_db::{FilePosition, SourceDatabase};\n use ra_fmt::leading_indent;\n use ra_syntax::{\n     algo::{find_node_at_offset, find_token_at_offset, TokenAtOffset},\n     ast::{self, AstToken},\n-    AstNode, SourceFile,\n+    AstNode, SmolStr, SourceFile,\n     SyntaxKind::*,\n     SyntaxToken, TextRange, TextUnit,\n };\n use ra_text_edit::{TextEdit, TextEditBuilder};\n \n+use crate::{db::RootDatabase, SourceChange, SourceFileEdit};\n+\n pub(crate) fn on_enter(db: &RootDatabase, position: FilePosition) -> Option<SourceChange> {\n     let parse = db.parse(position.file_id);\n     let file = parse.tree();\n@@ -43,15 +44,15 @@ pub(crate) fn on_enter(db: &RootDatabase, position: FilePosition) -> Option<Sour\n     )\n }\n \n-fn node_indent<'a>(file: &'a SourceFile, token: SyntaxToken) -> Option<&'a str> {\n+fn node_indent(file: &SourceFile, token: &SyntaxToken) -> Option<SmolStr> {\n     let ws = match find_token_at_offset(file.syntax(), token.range().start()) {\n         TokenAtOffset::Between(l, r) => {\n-            assert!(r == token);\n+            assert!(r == *token);\n             l\n         }\n         TokenAtOffset::Single(n) => {\n-            assert!(n == token);\n-            return Some(\"\");\n+            assert!(n == *token);\n+            return Some(\"\".into());\n         }\n         TokenAtOffset::None => unreachable!(),\n     };\n@@ -60,12 +61,12 @@ fn node_indent<'a>(file: &'a SourceFile, token: SyntaxToken) -> Option<&'a str>\n     }\n     let text = ws.text();\n     let pos = text.rfind('\\n').map(|it| it + 1).unwrap_or(0);\n-    Some(&text[pos..])\n+    Some(text[pos..].into())\n }\n \n pub fn on_eq_typed(file: &SourceFile, eq_offset: TextUnit) -> Option<TextEdit> {\n     assert_eq!(file.syntax().text().char_at(eq_offset), Some('='));\n-    let let_stmt: &ast::LetStmt = find_node_at_offset(file.syntax(), eq_offset)?;\n+    let let_stmt: ast::LetStmt = find_node_at_offset(file.syntax(), eq_offset)?;\n     if let_stmt.has_semi() {\n         return None;\n     }\n@@ -141,7 +142,7 @@ mod tests {\n             edit.insert(offset, \"=\".to_string());\n             let before = edit.finish().apply(&before);\n             let parse = SourceFile::parse(&before);\n-            if let Some(result) = on_eq_typed(parse.tree(), offset) {\n+            if let Some(result) = on_eq_typed(&parse.tree(), offset) {\n                 let actual = result.apply(&before);\n                 assert_eq_text!(after, &actual);\n             } else {"}]}